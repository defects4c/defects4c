{
    "2b62d1dda41590db29368ec7ba5f4faf3464765a___print-icmp.c": {
        "start": 329,
        "end": 691,
        "buggy": "void\nicmp_print(netdissect_options *ndo, const u_char *bp, u_int plen, const u_char *bp2,\n           int fragmented)\n{\n\tchar *cp;\n\tconst struct icmp *dp;\n        const struct icmp_ext_t *ext_dp;\n\tconst struct ip *ip;\n\tconst char *str, *fmt;\n\tconst struct ip *oip;\n\tconst struct udphdr *ouh;\n        const uint8_t *obj_tptr;\n        uint32_t raw_label;\n        const u_char *snapend_save;\n\tconst struct icmp_mpls_ext_object_header_t *icmp_mpls_ext_object_header;\n\tu_int hlen, dport, mtu, obj_tlen, obj_class_num, obj_ctype;\n\tchar buf[MAXHOSTNAMELEN + 100];\n\tstruct cksum_vec vec[1];\n\n\tdp = (const struct icmp *)bp;\n        ext_dp = (const struct icmp_ext_t *)bp;\n\tip = (const struct ip *)bp2;\n\tstr = buf;\n\n\tND_TCHECK(dp->icmp_code);\n\tswitch (dp->icmp_type) {\n\n\tcase ICMP_ECHO:\n\tcase ICMP_ECHOREPLY:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf), \"echo %s, id %u, seq %u\",\n                               dp->icmp_type == ICMP_ECHO ?\n                               \"request\" : \"reply\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_UNREACH:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_UNREACH_PROTOCOL:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"%s protocol %d unreachable\",\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t\t    dp->icmp_ip.ip_p);\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_PORT:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\toip = &dp->icmp_ip;\n\t\t\thlen = IP_HL(oip) * 4;\n\t\t\touh = (const struct udphdr *)(((const u_char *)oip) + hlen);\n\t\t\tND_TCHECK(ouh->uh_dport);\n\t\t\tdport = EXTRACT_16BITS(&ouh->uh_dport);\n\t\t\tswitch (oip->ip_p) {\n\n\t\t\tcase IPPROTO_TCP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s tcp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\ttcpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tcase IPPROTO_UDP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s udp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\tudpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s protocol %d port %d unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\toip->ip_p, dport);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_NEEDFRAG:\n\t\t    {\n\t\t\tregister const struct mtu_discovery *mp;\n\t\t\tmp = (const struct mtu_discovery *)(const u_char *)&dp->icmp_void;\n\t\t\tmtu = EXTRACT_16BITS(&mp->nexthopmtu);\n\t\t\tif (mtu) {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag (mtu %d)\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst), mtu);\n\t\t\t} else {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\t}\n\t\t    }\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmt = tok2str(unreach2str, \"#%d %%s unreachable\",\n\t\t\t    dp->icmp_code);\n\t\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_REDIRECT:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tfmt = tok2str(type2str, \"redirect-#%d %%s to net %%s\",\n\t\t    dp->icmp_code);\n\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t    ipaddr_string(ndo, &dp->icmp_gwaddr));\n\t\tbreak;\n\n\tcase ICMP_ROUTERADVERT:\n\t    {\n\t\tregister const struct ih_rdiscovery *ihp;\n\t\tregister const struct id_rdiscovery *idp;\n\t\tu_int lifetime, num, size;\n\n\t\t(void)snprintf(buf, sizeof(buf), \"router advertisement\");\n\t\tcp = buf + strlen(buf);\n\n\t\tihp = (const struct ih_rdiscovery *)&dp->icmp_void;\n\t\tND_TCHECK(*ihp);\n\t\t(void)strncpy(cp, \" lifetime \", sizeof(buf) - (cp - buf));\n\t\tcp = buf + strlen(buf);\n\t\tlifetime = EXTRACT_16BITS(&ihp->ird_lifetime);\n\t\tif (lifetime < 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u\",\n\t\t\t    lifetime);\n\t\t} else if (lifetime < 60 * 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u:%02u\",\n\t\t\t    lifetime / 60, lifetime % 60);\n\t\t} else {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \"%u:%02u:%02u\",\n\t\t\t    lifetime / 3600,\n\t\t\t    (lifetime % 3600) / 60,\n\t\t\t    lifetime % 60);\n\t\t}\n\t\tcp = buf + strlen(buf);\n\n\t\tnum = ihp->ird_addrnum;\n\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" %d:\", num);\n\t\tcp = buf + strlen(buf);\n\n\t\tsize = ihp->ird_addrsiz;\n\t\tif (size != 2) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \" [size %d]\", size);\n\t\t\tbreak;\n\t\t}\n\t\tidp = (const struct id_rdiscovery *)&dp->icmp_data;\n\t\twhile (num-- > 0) {\n\t\t\tND_TCHECK(*idp);\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" {%s %u}\",\n\t\t\t    ipaddr_string(ndo, &idp->ird_addr),\n\t\t\t    EXTRACT_32BITS(&idp->ird_pref));\n\t\t\tcp = buf + strlen(buf);\n\t\t\t++idp;\n\t\t}\n\t    }\n\t\tbreak;\n\n\tcase ICMP_TIMXCEED:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_TIMXCEED_INTRANS:\n\t\t\tstr = \"time exceeded in-transit\";\n\t\t\tbreak;\n\n\t\tcase ICMP_TIMXCEED_REASS:\n\t\t\tstr = \"ip reassembly time exceeded\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"time exceeded-#%d\",\n\t\t\t    dp->icmp_code);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_PARAMPROB:\n\t\tif (dp->icmp_code)\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - code %d\", dp->icmp_code);\n\t\telse {\n\t\t\tND_TCHECK(dp->icmp_pptr);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - octet %d\", dp->icmp_pptr);\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_MASKREPLY:\n\t\tND_TCHECK(dp->icmp_mask);\n\t\t(void)snprintf(buf, sizeof(buf), \"address mask is 0x%08x\",\n\t\t    EXTRACT_32BITS(&dp->icmp_mask));\n\t\tbreak;\n\n\tcase ICMP_TSTAMP:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp query id %u seq %u\",\n\t\t    EXTRACT_16BITS(&dp->icmp_id),\n\t\t    EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_TSTAMPREPLY:\n\t\tND_TCHECK(dp->icmp_ttime);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp reply id %u seq %u: org %s\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq),\n                               icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_otime)));\n\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", recv %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_rtime)));\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", xmit %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_ttime)));\n                break;\n\n\tdefault:\n\t\tstr = tok2str(icmp2str, \"type-#%d\", dp->icmp_type);\n\t\tbreak;\n\t}\n\tND_PRINT((ndo, \"ICMP %s, length %u\", str, plen));\n\tif (ndo->ndo_vflag && !fragmented) { /* don't attempt checksumming if this is a frag */\n\t\tuint16_t sum, icmp_sum;\n\n\t\tif (ND_TTEST2(*bp, plen)) {\n\t\t\tvec[0].ptr = (const uint8_t *)(const void *)dp;\n\t\t\tvec[0].len = plen;\n\t\t\tsum = in_cksum(vec, 1);\n\t\t\tif (sum != 0) {\n\t\t\t\ticmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);\n\t\t\t\tND_PRINT((ndo, \" (wrong icmp cksum %x (->%x)!)\",\n\t\t\t\t\t     icmp_sum,\n\t\t\t\t\t     in_cksum_shouldbe(icmp_sum, sum)));\n\t\t\t}\n\t\t}\n\t}\n\n        /*\n         * print the remnants of the IP packet.\n         * save the snaplength as this may get overidden in the IP printer.\n         */\n\tif (ndo->ndo_vflag >= 1 && ICMP_ERRTYPE(dp->icmp_type)) {\n\t\tbp += 8;\n\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\tip = (const struct ip *)bp;\n                snapend_save = ndo->ndo_snapend;\n\t\tip_print(ndo, bp, EXTRACT_16BITS(&ip->ip_len));\n                ndo->ndo_snapend = snapend_save;\n\t}\n\n        /*\n         * Attempt to decode the MPLS extensions only for some ICMP types.\n         */\n        if (ndo->ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE(dp->icmp_type)) {\n\n            ND_TCHECK(*ext_dp);\n\n            /*\n             * Check first if the mpls extension header shows a non-zero length.\n             * If the length field is not set then silently verify the checksum\n             * to check if an extension header is present. This is expedient,\n             * however not all implementations set the length field proper.\n             */\n            if (!ext_dp->icmp_length) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = plen - ICMP_EXTD_MINLEN;\n                if (in_cksum(vec, 1)) {\n                    return;\n                }\n            }\n\n            ND_PRINT((ndo, \"\\n\\tMPLS extension v%u\",\n                   ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res))));\n\n            /*\n             * Sanity checking of the header.\n             */\n            if (ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res)) !=\n                ICMP_MPLS_EXT_VERSION) {\n                ND_PRINT((ndo, \" packet not supported\"));\n                return;\n            }\n\n            hlen = plen - ICMP_EXTD_MINLEN;\n            vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n            vec[0].len = hlen;\n            ND_PRINT((ndo, \", checksum 0x%04x (%scorrect), length %u\",\n                   EXTRACT_16BITS(ext_dp->icmp_ext_checksum),\n                   in_cksum(vec, 1) ? \"in\" : \"\",\n                   hlen));\n\n            hlen -= 4; /* subtract common header size */\n            obj_tptr = (const uint8_t *)ext_dp->icmp_ext_data;\n\n            while (hlen > sizeof(struct icmp_mpls_ext_object_header_t)) {\n\n                icmp_mpls_ext_object_header = (const struct icmp_mpls_ext_object_header_t *)obj_tptr;\n                ND_TCHECK(*icmp_mpls_ext_object_header);\n                obj_tlen = EXTRACT_16BITS(icmp_mpls_ext_object_header->length);\n                obj_class_num = icmp_mpls_ext_object_header->class_num;\n                obj_ctype = icmp_mpls_ext_object_header->ctype;\n                obj_tptr += sizeof(struct icmp_mpls_ext_object_header_t);\n\n                ND_PRINT((ndo, \"\\n\\t  %s Object (%u), Class-Type: %u, length %u\",\n                       tok2str(icmp_mpls_ext_obj_values,\"unknown\",obj_class_num),\n                       obj_class_num,\n                       obj_ctype,\n                       obj_tlen));\n\n                hlen-=sizeof(struct icmp_mpls_ext_object_header_t); /* length field includes tlv header */\n\n                /* infinite loop protection */\n                if ((obj_class_num == 0) ||\n                    (obj_tlen < sizeof(struct icmp_mpls_ext_object_header_t))) {\n                    return;\n                }\n                obj_tlen-=sizeof(struct icmp_mpls_ext_object_header_t);\n\n                switch (obj_class_num) {\n                case 1:\n                    switch(obj_ctype) {\n                    case 1:\n                        ND_TCHECK2(*obj_tptr, 4);\n                        raw_label = EXTRACT_32BITS(obj_tptr);\n                        ND_PRINT((ndo, \"\\n\\t    label %u, exp %u\", MPLS_LABEL(raw_label), MPLS_EXP(raw_label)));\n                        if (MPLS_STACK(raw_label))\n                            ND_PRINT((ndo, \", [S]\"));\n                        ND_PRINT((ndo, \", ttl %u\", MPLS_TTL(raw_label)));\n                        break;\n                    default:\n                        print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    }\n                    break;\n\n               /*\n                *  FIXME those are the defined objects that lack a decoder\n                *  you are welcome to contribute code ;-)\n                */\n                case 2:\n                default:\n                    print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    break;\n                }\n                if (hlen < obj_tlen)\n                    break;\n                hlen -= obj_tlen;\n                obj_tptr += obj_tlen;\n            }\n        }\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"[|icmp]\"));\n}\n",
        "fix": null,
        "src_path": "2b62d1dda41590db29368ec7ba5f4faf3464765a___print-icmp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/2b62d1dda41590db29368ec7ba5f4faf3464765a",
        "commit_msg": "CVE-2017-12895/ICMP: Check the availability of data before checksumming it.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd tests using the capture files supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -452,6 +452,10 @@ slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve\n # bad packets from Otto Airamo and Antti Levom\u00e4ki\n nbns-valgrind\t\tnbns-valgrind.pcap\t\tnbns-valgrind.out\t-vvv -e\n arp-oobr\t\tarp-oobr.pcap\t\t\tarp-oobr.out\t-vvv -e\n+icmp-cksum-oobr-1\ticmp-cksum-oobr-1.pcap\t\ticmp-cksum-oobr-1.out\t-vvv -e\n+icmp-cksum-oobr-2\ticmp-cksum-oobr-2.pcap\t\ticmp-cksum-oobr-2.out\t-vvv -e\n+icmp-cksum-oobr-3\ticmp-cksum-oobr-3.pcap\t\ticmp-cksum-oobr-3.out\t-vvv -e\n+icmp-cksum-oobr-4\ticmp-cksum-oobr-4.pcap\t\ticmp-cksum-oobr-4.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/icmp-cksum-oobr-1.out",
                "patch": "@@ -0,0 +1,5 @@\n+Out 00:16:3e:27:78:a2 ethertype IPv4 (0x0800), length 204: truncated-ip - 13723 bytes missing! (tos 0x72,ECT(0), ttl 64, id 9472, offset 0, flags [none], proto ICMP (1), length 13911, bad cksum 67ea (->8c0c)!)\n+    62.220.31.247 > 62.225.245.115: ICMP 62.220.31.247 udp port 1027 unreachable, length 13891\n+\t(tos 0xa0, ttl 114, id 30054, offset 0, flags [none], proto UDP (17), length 13728, bad cksum 3f1f (->a1f)!)\n+    62.225.245.115.9109 > 62.220.31.247.1027: [bad udp cksum 0xdfe7 -> 0xdb95!] UDP, length 132\n+\tMPLS extension v0 packet not supported"
            },
            {
                "fn": "tests/icmp-cksum-oobr-2.out",
                "patch": "@@ -0,0 +1,11 @@\n+IP (0x0021), length 244: truncated-ip - 32768 bytes missing! (tos 0x0, ttl 254, id 59168, offset 0, flags [DF], proto ICMP (1), length 33008, bad cksum 7ade (->fabd)!)\n+    10.4.0.34 > 12.4.4.4: ICMP time exceeded in-transit, length 32988\n+\t(tos 0x0, ttl 1, id 42321, offset 0, flags [none], proto UDP (17), length 40)\n+    12.4.4.4.42315 > 12.1.1.1.33440: [bad udp cksum 0x1000 -> 0xbad0!] UDP, length 12\n+\tMPLS extension v2\n+\t  Extended Payload Object (2), Class-Type: 14, length 80\n+\t    0x0000:  0000 000f 0001 0000 0a0a 0a0a 3f54 6869\n+\t    0x0010:  732d 6973 2d74 6865 2d6e 616d 652d 6f66\n+\t    0x0020:  2d74 6865 2d49 6e74 6572 6661 6365 2d74\n+\t    0x0030:  6861 742d 7765 2d61 7265 2d6c 6f6f 6b69\n+\t    0x0040:  6e67 2d66 6f72 2d5b 3a2d 295d[|icmp]"
            },
            {
                "fn": "tests/icmp-cksum-oobr-3.out",
                "patch": "@@ -0,0 +1,5 @@\n+00:00:00:00:00:00 > 00:00:00:00:00:00, ethertype IPv4 (0x0800), length 337: truncated-ip - 4096 bytes missing! (tos 0x0, ttl 64, id 30662, offset 0, flags [DF], proto ICMP (1), length 4419, bad cksum cdf9 (->bdf9)!)\n+    97.242.24.11 > 97.242.24.11: ICMP 97.242.24.11 udp port 162 unreachable, length 4399\n+\t(tos 0x0, ttl 128, id 30661, offset 0, flags [DF], proto UDP (17), length 295)\n+    97.242.24.11.60377 > 97.242.24.11.162: [udp sum ok]  { SNMPv1 C=\"trap\" { Trap(251)  .1.3.6.1.4.1.3830.1.1.2.2.1 97.242.24.11 enterpriseSpecific s=52 61498489 .1.3.6.1.4.1.3830.1.1.2.1.1.1=3 .1.3.6.1.4.1.3830.1.1.2.1.1.2=2 .1.3.6.1.4.1.3830.1.1.2.1.1.3=\"%SMSA-E-POLLERR, Polling the SMSC was not successful.\" .1.3.6.1.4.1.3830.1.1.2.1.1.4=\"OPCOM\" .1.3.6.1.4.1.3830.1.1.2.1.1.5=\"28-OCT-2010 20:42:14.67\" .1.3.6.1.4.1.3830.1.1.2.1.1.6=\"SMRL51\" } } \n+\tMPLS extension v0 packet not supported"
            },
            {
                "fn": "tests/icmp-cksum-oobr-4.out",
                "patch": "@@ -0,0 +1,7 @@\n+IP (0x0021), length 172: truncated-ip - 8192 bytes missing! (tos 0xc0, ttl 251, id 5047, offset 0, flags [none], proto ICMP (1), length 8360, bad cksum 7edb (->5edb)!)\n+    10.0.12.2 > 10.0.12.1: ICMP time exceeded in-transit, length 8340\n+\t(tos 0x0, ttl 1, id 2574, offset 0, flags [none], proto UDP (17), length 28)\n+    10.0.12.1.49215 > 10.255.255.4.33435: [udp sum ok] UDP, length 0\n+\tMPLS extension v2\n+\t  MPLS Stack Entry Object (1), Class-Type: 1, length 8\n+\t    label 16, exp 0, [S], ttl 1[|icmp]"
            }
        ],
        "error_msg": "    icmp-cksum-oobr-1                  : TEST FAILED(exit 256)\n    icmp-cksum-oobr-2                  : TEST FAILED(exit 256)\n    icmp-cksum-oobr-3                  : TEST FAILED(exit 256)\n    icmp-cksum-oobr-4                  : TEST FAILED(exit 256)\n"
    },
    "e942fb84fbe3a73a98a00d2a279425872b5fb9d2___print-ripng.c": {
        "start": 108,
        "end": 174,
        "buggy": "void\nripng_print(netdissect_options *ndo, const u_char *dat, unsigned int length)\n{\n\tregister const struct rip6 *rp = (const struct rip6 *)dat;\n\tregister const struct netinfo6 *ni;\n\tregister u_int amt;\n\tregister u_int i;\n\tint j;\n\tint trunc;\n\n\tif (ndo->ndo_snapend < dat)\n\t\treturn;\n\tamt = ndo->ndo_snapend - dat;\n\ti = min(length, amt);\n\tif (i < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n\t\treturn;\n\ti -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n\n\tswitch (rp->rip6_cmd) {\n\n\tcase RIP6_REQUEST:\n\t\tj = length / sizeof(*ni);\n\t\tif (j == 1\n\t\t    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6\n\t\t    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {\n\t\t\tND_PRINT((ndo, \" ripng-req dump\"));\n\t\t\tbreak;\n\t\t}\n\t\tif (j * sizeof(*ni) != length - 4)\n\t\t\tND_PRINT((ndo, \" ripng-req %d[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-req %d:\", j));\n\t\ttrunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);\n\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n\t\t    i -= sizeof(*ni), ++ni) {\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, 0);\n\t\t}\n\t\tbreak;\n\tcase RIP6_RESPONSE:\n\t\tj = length / sizeof(*ni);\n\t\tif (j * sizeof(*ni) != length - 4)\n\t\t\tND_PRINT((ndo, \" ripng-resp %d[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-resp %d:\", j));\n\t\ttrunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);\n\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n\t\t    i -= sizeof(*ni), ++ni) {\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, ni->rip6_metric);\n\t\t}\n\t\tif (trunc)\n\t\t\tND_PRINT((ndo, \"[|ripng]\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \" ripng-%d ?? %u\", rp->rip6_cmd, length));\n\t\tbreak;\n\t}\n\tif (rp->rip6_vers != RIP6_VERSION)\n\t\tND_PRINT((ndo, \" [vers %d]\", rp->rip6_vers));\n}\n",
        "fix": null,
        "src_path": "e942fb84fbe3a73a98a00d2a279425872b5fb9d2___print-ripng.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/e942fb84fbe3a73a98a00d2a279425872b5fb9d2",
        "commit_msg": "CVE-2017-12992/RIPng: Clean up bounds checking.\n\nDo bounds checking as we access items.\n\nScan the list of netinfo6 entries based on the supplied packet length,\nwithout taking the captured length into account; let the aforementioned\nbounds checking handle that.\n\nThis fixes a buffer over-read discovered by Kamil Frankowicz.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -450,6 +450,7 @@ isoclns-oobr\t\tisoclns-oobr.pcap\t\tisoclns-oobr.out\n nfs-attr-oobr\t\tnfs-attr-oobr.pcap\t\tnfs-attr-oobr.out\n decnet-oobr\t\tdecnet-oobr.pcap\t\tdecnet-oobr.out\n oobr_parse_elements\toobr_parse_elements.pcap\toobr_parse_elements.out\n+hoobr_ripng_print\thoobr_ripng_print.pcap\t\thoobr_ripng_print.out\n \n # bad packets from Wilfried Kirsch\n slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve"
            },
            {
                "fn": "tests/hoobr_ripng_print.out",
                "patch": "@@ -0,0 +1 @@\n+IP 48.48.48.48.521 > 48.48.48.48.12336: [|ripng]"
            }
        ],
        "error_msg": "    hoobr_ripng_print                  : TEST FAILED(exit 256)\n"
    },
    "ffde45acf3348f8353fb4064a1b21683ee6b5ddf___print-bgp.c": {
        "start": 1349,
        "end": 2305,
        "buggy": "static int\nbgp_attr_print(netdissect_options *ndo,\n               u_int atype, const u_char *pptr, u_int len)\n{\n\tint i;\n\tuint16_t af;\n\tuint8_t safi, snpa, nhlen;\n        union { /* copy buffer for bandwidth values */\n            float f;\n            uint32_t i;\n        } bw;\n\tint advance;\n\tu_int tlen;\n\tconst u_char *tptr;\n\tchar buf[MAXHOSTNAMELEN + 100];\n        int  as_size;\n\n        tptr = pptr;\n        tlen=len;\n\n\tswitch (atype) {\n\tcase BGPTYPE_ORIGIN:\n\t\tif (len != 1)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK(*tptr);\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(bgp_origin_values,\n\t\t\t\t\t\t\"Unknown Origin Typecode\",\n\t\t\t\t\t\ttptr[0])));\n\t\t}\n\t\tbreak;\n\n        /*\n         * Process AS4 byte path and AS2 byte path attributes here.\n         */\n\tcase BGPTYPE_AS4_PATH:\n\tcase BGPTYPE_AS_PATH:\n\t\tif (len % 2) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                if (!len) {\n\t\t\tND_PRINT((ndo, \"empty\"));\n\t\t\tbreak;\n                }\n\n                /*\n                 * BGP updates exchanged between New speakers that support 4\n                 * byte AS, ASs are always encoded in 4 bytes. There is no\n                 * definitive way to find this, just by the packet's\n                 * contents. So, check for packet's TLV's sanity assuming\n                 * 2 bytes first, and it does not pass, assume that ASs are\n                 * encoded in 4 bytes format and move on.\n                 */\n                as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);\n\n\t\twhile (tptr < pptr + len) {\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_open_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n\t\t\tND_TCHECK(tptr[1]);\n                        for (i = 0; i < tptr[1] * as_size; i += as_size) {\n                            ND_TCHECK2(tptr[2 + i], as_size);\n\t\t\t    ND_PRINT((ndo, \"%s \",\n\t\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\t\tas_size == 2 ?\n\t\t\t\tEXTRACT_16BITS(&tptr[2 + i]) :\n\t\t\t\tEXTRACT_32BITS(&tptr[2 + i]))));\n                        }\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_close_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n                        ND_TCHECK(tptr[1]);\n                        tptr += 2 + tptr[1] * as_size;\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_NEXT_HOP:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_MULTI_EXIT_DISC:\n\tcase BGPTYPE_LOCAL_PREF:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_ATOMIC_AGGREGATE:\n\t\tif (len != 0)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\tbreak;\n        case BGPTYPE_AGGREGATOR:\n\n                /*\n                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,\n                 * the length of this PA can be either 6 bytes or 8 bytes.\n                 */\n                if (len != 6 && len != 8) {\n                    ND_PRINT((ndo, \"invalid len\"));\n                    break;\n                }\n                ND_TCHECK2(tptr[0], len);\n                if (len == 6) {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),\n\t\t\tipaddr_string(ndo, tptr + 2)));\n                } else {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\tEXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));\n                }\n                break;\n\tcase BGPTYPE_AGGREGATOR4:\n\t\tif (len != 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 8);\n\t\tND_PRINT((ndo, \" AS #%s, origin %s\",\n\t   \t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),\n\t\t    ipaddr_string(ndo, tptr + 4)));\n\t\tbreak;\n\tcase BGPTYPE_COMMUNITIES:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\twhile (tlen>0) {\n\t\t\tuint32_t comm;\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tcomm = EXTRACT_32BITS(tptr);\n\t\t\tswitch (comm) {\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_ADVERT:\n\t\t\t\tND_PRINT((ndo, \" NO_ADVERTISE\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT_SUBCONFED:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT_SUBCONFED\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"%u:%u%s\",\n                                       (comm >> 16) & 0xffff,\n                                       comm & 0xffff,\n                                       (tlen>4) ? \", \" : \"\"));\n\t\t\t\tbreak;\n\t\t\t}\n                        tlen -=4;\n                        tptr +=4;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_ORIGINATOR_ID:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 4);\n                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                break;\n        case BGPTYPE_CLUSTER_LIST:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n\t\t\tND_TCHECK2(tptr[0], 4);\n                        ND_PRINT((ndo, \"%s%s\",\n                               ipaddr_string(ndo, tptr),\n                                (tlen>4) ? \", \" : \"\"));\n                        tlen -=4;\n                        tptr +=4;\n                }\n                break;\n\tcase BGPTYPE_MP_REACH_NLRI:\n\t\tND_TCHECK2(tptr[0], 3);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                switch(af<<8 | safi) {\n                case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n\t\tcase (AFNUM_INET<<8 | SAFNUM_MDT):\n                case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    break;\n                default:\n                    ND_TCHECK2(tptr[0], tlen);\n                    ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                    goto done;\n                    break;\n                }\n\n                tptr +=3;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tnhlen = tptr[0];\n                tlen = nhlen;\n                tptr++;\n\n\t\tif (tlen) {\n                    int nnh = 0;\n                    ND_PRINT((ndo, \"\\n\\t    nexthop: \"));\n                    while (tlen > 0) {\n                        if ( nnh++ > 0 ) {\n                            ND_PRINT((ndo,  \", \" ));\n                        }\n                        switch(af<<8 | safi) {\n                        case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n                        case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t\t    if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in_addr);\n                                tptr += sizeof(struct in_addr);\n                            }\n                            break;\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                            if (tlen < (int)sizeof(struct in6_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr));\n                                ND_PRINT((ndo, \"%s\", ip6addr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in6_addr);\n                                tptr += sizeof(struct in6_addr);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n                                tlen -= (sizeof(struct in_addr));\n                                tptr += (sizeof(struct in_addr));\n                            }\n                            break;\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"%s\", isonsap_string(ndo, tptr, tlen)));\n                            tptr += tlen;\n                            tlen = 0;\n                            break;\n\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < BGP_VPN_RD_LEN+1) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], tlen);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));\n                                /* rfc986 mapped IPv4 address ? */\n                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)\n                                    ND_PRINT((ndo, \" = %s\", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));\n                                /* rfc1888 mapped IPv6 address ? */\n                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)\n                                    ND_PRINT((ndo, \" = %s\", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));\n                                tptr += tlen;\n                                tlen = 0;\n                            }\n                            break;\n                        default:\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"no AFI %u/SAFI %u decoder\", af, safi));\n                            if (ndo->ndo_vflag <= 1)\n                                print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                            tptr += tlen;\n                            tlen = 0;\n                            goto done;\n                            break;\n                        }\n                    }\n\t\t}\n\t\tND_PRINT((ndo, \", nh-length: %u\", nhlen));\n\t\ttptr += tlen;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tsnpa = tptr[0];\n\t\ttptr++;\n\n\t\tif (snpa) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    %u SNPA\", snpa));\n\t\t\tfor (/*nothing*/; snpa > 0; snpa--) {\n\t\t\t\tND_TCHECK(tptr[0]);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      %d bytes\", tptr[0]));\n\t\t\t\ttptr += tptr[0] + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \", no SNPA\"));\n                }\n\n\t\twhile (len - (tptr - pptr) > 0) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,tlen);\n                        ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n        done:\n\t\tbreak;\n\n\tcase BGPTYPE_MP_UNREACH_NLRI:\n\t\tND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                if (len == BGP_MP_NLRI_MINSIZE)\n                    ND_PRINT((ndo, \"\\n\\t      End-of-Rib Marker (empty NLRI)\"));\n\n\t\ttptr += 3;\n\n\t\twhile (len - (tptr - pptr) > 0) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*(tptr-3),tlen);\n                        ND_PRINT((ndo, \"no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr-3, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_EXTD_COMMUNITIES:\n\t\tif (len % 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n                    uint16_t extd_comm;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    extd_comm=EXTRACT_16BITS(tptr);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s (0x%04x), Flags [%s]\",\n\t\t\t   tok2str(bgp_extd_comm_subtype_values,\n\t\t\t\t      \"unknown extd community typecode\",\n\t\t\t\t      extd_comm),\n\t\t\t   extd_comm,\n\t\t\t   bittok2str(bgp_extd_comm_flag_values, \"none\", extd_comm)));\n\n                    ND_TCHECK2(*(tptr+2), 6);\n                    switch(extd_comm) {\n                    case BGP_EXT_COM_RT_0:\n                    case BGP_EXT_COM_RO_0:\n                    case BGP_EXT_COM_L2VPN_RT_0:\n                        ND_PRINT((ndo, \": %u:%u (= %s)\",\n                               EXTRACT_16BITS(tptr+2),\n                               EXTRACT_32BITS(tptr+4),\n                               ipaddr_string(ndo, tptr+4)));\n                        break;\n                    case BGP_EXT_COM_RT_1:\n                    case BGP_EXT_COM_RO_1:\n                    case BGP_EXT_COM_L2VPN_RT_1:\n                    case BGP_EXT_COM_VRF_RT_IMP:\n                        ND_PRINT((ndo, \": %s:%u\",\n                               ipaddr_string(ndo, tptr+2),\n                               EXTRACT_16BITS(tptr+6)));\n                        break;\n                    case BGP_EXT_COM_RT_2:\n                    case BGP_EXT_COM_RO_2:\n\t\t\tND_PRINT((ndo, \": %s:%u\",\n\t\t\t    as_printf(ndo, astostr, sizeof(astostr),\n\t\t\t    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));\n\t\t\tbreak;\n                    case BGP_EXT_COM_LINKBAND:\n\t\t        bw.i = EXTRACT_32BITS(tptr+2);\n                        ND_PRINT((ndo, \": bandwidth: %.3f Mbps\",\n                               bw.f*8/1000000));\n                        break;\n                    case BGP_EXT_COM_VPN_ORIGIN:\n                    case BGP_EXT_COM_VPN_ORIGIN2:\n                    case BGP_EXT_COM_VPN_ORIGIN3:\n                    case BGP_EXT_COM_VPN_ORIGIN4:\n                    case BGP_EXT_COM_OSPF_RID:\n                    case BGP_EXT_COM_OSPF_RID2:\n                        ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr+2)));\n                        break;\n                    case BGP_EXT_COM_OSPF_RTYPE:\n                    case BGP_EXT_COM_OSPF_RTYPE2:\n                        ND_PRINT((ndo, \": area:%s, router-type:%s, metric-type:%s%s\",\n                               ipaddr_string(ndo, tptr+2),\n                               tok2str(bgp_extd_comm_ospf_rtype_values,\n\t\t\t\t\t  \"unknown (0x%02x)\",\n\t\t\t\t\t  *(tptr+6)),\n                               (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? \"E2\" : \"\",\n                               ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? \"E1\" : \"\"));\n                        break;\n                    case BGP_EXT_COM_L2INFO:\n                        ND_PRINT((ndo, \": %s Control Flags [0x%02x]:MTU %u\",\n                               tok2str(l2vpn_encaps_values,\n\t\t\t\t\t  \"unknown encaps\",\n\t\t\t\t\t  *(tptr+2)),\n                                       *(tptr+3),\n                               EXTRACT_16BITS(tptr+4)));\n                        break;\n                    case BGP_EXT_COM_SOURCE_AS:\n                        ND_PRINT((ndo, \": AS %u\", EXTRACT_16BITS(tptr+2)));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,8);\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", 8);\n                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n                ND_TCHECK2(tptr[0], 5);\n                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {\n                case BGP_PMSI_TUNNEL_PIM_SM: /* fall through */\n                case BGP_PMSI_TUNNEL_PIM_BIDIR:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Sender %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n\n                case BGP_PMSI_TUNNEL_PIM_SSM:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_INGRESS:\n                    ND_TCHECK2(tptr[0], 4);\n                    ND_PRINT((ndo, \"\\n\\t      Tunnel-Endpoint %s\",\n                           ipaddr_string(ndo, tptr)));\n                    break;\n                case BGP_PMSI_TUNNEL_LDP_P2MP: /* fall through */\n                case BGP_PMSI_TUNNEL_LDP_MP2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, LSP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_RSVP_P2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                default:\n                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\tND_TCHECK2(tptr[0], 3);\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length - 3);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        ND_TCHECK2(tptr[3], 8);\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr+3)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr+3,\"\\n\\t      \", length-3);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);\n                if (len < 4)\n                \tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t    Origin AS: %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));\n\t\ttptr+=4;\n                len -=4;\n\n                while (len) {\n                    u_int aflags, alenlen, alen;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    if (len < 2)\n                        goto trunc;\n                    aflags = *tptr;\n                    atype = *(tptr + 1);\n                    tptr += 2;\n                    len -= 2;\n                    alenlen = bgp_attr_lenlen(aflags, tptr);\n                    ND_TCHECK2(tptr[0], alenlen);\n                    if (len < alenlen)\n                        goto trunc;\n                    alen = bgp_attr_len(aflags, tptr);\n                    tptr += alenlen;\n                    len -= alenlen;\n\n                    ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                           tok2str(bgp_attr_values,\n                                      \"Unknown Attribute\", atype),\n                           atype,\n                           alen));\n\n                    if (aflags) {\n                        ND_PRINT((ndo, \", Flags [%s%s%s%s\",\n                               aflags & 0x80 ? \"O\" : \"\",\n                               aflags & 0x40 ? \"T\" : \"\",\n                               aflags & 0x20 ? \"P\" : \"\",\n                               aflags & 0x10 ? \"E\" : \"\"));\n                        if (aflags & 0xf)\n                            ND_PRINT((ndo, \"+%x\", aflags & 0xf));\n                        ND_PRINT((ndo, \"]: \"));\n                    }\n                    /* FIXME check for recursion */\n                    if (!bgp_attr_print(ndo, atype, tptr, alen))\n                        return 0;\n                    tptr += alen;\n                    len -= alen;\n\t\t}\n                break;\n\n\tcase BGPTYPE_LARGE_COMMUNITY:\n\t\tif (len == 0 || len % 12) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\twhile (len > 0) {\n\t\t\tND_TCHECK2(*tptr, 12);\n\t\t\tND_PRINT((ndo, \"%u:%u:%u%s\",\n\t\t\t\t EXTRACT_32BITS(tptr),\n\t\t\t\t EXTRACT_32BITS(tptr + 4),\n\t\t\t\t EXTRACT_32BITS(tptr + 8),\n\t\t\t\t (len > 12) ? \", \" : \"\"));\n                        tptr += 12;\n                        len -= 12;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t    ND_TCHECK2(*pptr,len);\n            ND_PRINT((ndo, \"\\n\\t    no Attribute %u decoder\", atype)); /* we have no decoder for the attribute */\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n            break;\n\t}\n        if (ndo->ndo_vflag > 1 && len) { /* omit zero length attributes*/\n            ND_TCHECK2(*pptr,len);\n            print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n        }\n        return 1;\n\ntrunc:\n        return 0;\n}\n",
        "fix": null,
        "src_path": "ffde45acf3348f8353fb4064a1b21683ee6b5ddf___print-bgp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/ffde45acf3348f8353fb4064a1b21683ee6b5ddf",
        "commit_msg": "CVE-2017-12994/BGP: Move a test inside a loop.\n\nThe loop can be executed more than once (that's kinda the whole point of\na loop), so the check has to be made each time through the loop, not\njust once before the loop is executed.\n\nDo some additional length checks while we're at it.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -473,6 +473,7 @@ zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n telnet-iac-check-oobr\ttelnet-iac-check-oobr.pcap\ttelnet-iac-check-oobr.out\t-vvv -e\n resp_4_infiniteloop\tresp_4_infiniteloop.pcap\tresp_4_infiniteloop.out\t-vvv -e\n+bgp-aigp-oobr\t\tbgp-aigp-oobr.pcap\t\tbgp-aigp-oobr.out\t\t-vvv -e\n \n # RTP tests\n # fuzzed pcap"
            }
        ],
        "error_msg": "    bgp-aigp-oobr                      : TEST FAILED(exit 256)\n"
    },
    "3a76fd7c95fced2c2f8c8148a9055c3a542eff29___print-domain.c": {
        "start": 147,
        "end": 229,
        "buggy": "const u_char *\nns_nprint(netdissect_options *ndo,\n          register const u_char *cp, register const u_char *bp)\n{\n\tregister u_int i, l;\n\tregister const u_char *rp = NULL;\n\tregister int compress = 0;\n\tint chars_processed;\n\tint elt;\n\tint data_size = ndo->ndo_snapend - bp;\n\n\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\treturn(NULL);\n\tif (!ND_TTEST2(*cp, 1))\n\t\treturn(NULL);\n\tchars_processed = 1;\n\tif (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {\n\t\tcompress = 0;\n\t\trp = cp + l;\n\t}\n\n\tif (i != 0)\n\t\twhile (i && cp < ndo->ndo_snapend) {\n\t\t\tif ((i & INDIR_MASK) == INDIR_MASK) {\n\t\t\t\tif (!compress) {\n\t\t\t\t\trp = cp + 1;\n\t\t\t\t\tcompress = 1;\n\t\t\t\t}\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\tcp = bp + (((i << 8) | *cp) & 0x3fff);\n\t\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\t\treturn(NULL);\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\ti = *cp++;\n\t\t\t\tchars_processed++;\n\n\t\t\t\t/*\n\t\t\t\t * If we've looked at every character in\n\t\t\t\t * the message, this pointer will make\n\t\t\t\t * us look at some character again,\n\t\t\t\t * which means we're looping.\n\t\t\t\t */\n\t\t\t\tif (chars_processed >= data_size) {\n\t\t\t\t\tND_PRINT((ndo, \"<LOOP>\"));\n\t\t\t\t\treturn (NULL);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((i & INDIR_MASK) == EDNS0_MASK) {\n\t\t\t\telt = (i & ~INDIR_MASK);\n\t\t\t\tswitch(elt) {\n\t\t\t\tcase EDNS0_ELT_BITLABEL:\n\t\t\t\t\tif (blabel_print(ndo, cp) == NULL)\n\t\t\t\t\t\treturn (NULL);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* unknown ELT */\n\t\t\t\t\tND_PRINT((ndo, \"<ELT %d>\", elt));\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (fn_printn(ndo, cp, l, ndo->ndo_snapend))\n\t\t\t\t\treturn(NULL);\n\t\t\t}\n\n\t\t\tcp += l;\n\t\t\tchars_processed += l;\n\t\t\tND_PRINT((ndo, \".\"));\n\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\treturn(NULL);\n\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\treturn(NULL);\n\t\t\ti = *cp++;\n\t\t\tchars_processed++;\n\t\t\tif (!compress)\n\t\t\t\trp += l + 1;\n\t\t}\n\telse\n\t\tND_PRINT((ndo, \".\"));\n\treturn (rp);\n}\n",
        "fix": null,
        "src_path": "3a76fd7c95fced2c2f8c8148a9055c3a542eff29___print-domain.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/3a76fd7c95fced2c2f8c8148a9055c3a542eff29",
        "commit_msg": "CVE-2017-12995/Check for DNS compression pointers that don't point backwards.\n\nThis is what BIND 9.11.0-P2 does; it not only detects pointers that\nloop, as \"point backwards\" means \"point before anything we've processed\nso far, including what we're processing right now\", so the pointer can't\npoint to itself (as that's what we're processing right now).\n\nThis fixes an infinite loop discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).\n\nAlso, add some infinite-pointer-loop captures.\n\nMore checks should be done.  We might, for example, want to make sure\nthe upper 2 bits of the label length/pointer byte are 00 or 11, and that\nif we encounter a pointer and jump backwards to what we think is a label\nthe label ends before the beginning of the last label we processed, to\nmake sure the pointer doesn't point backwards into the *middle* of a\nlabel, and also make sure the entire name is <= 255 bytes long.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -474,6 +474,7 @@ zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n telnet-iac-check-oobr\ttelnet-iac-check-oobr.pcap\ttelnet-iac-check-oobr.out\t-vvv -e\n resp_4_infiniteloop\tresp_4_infiniteloop.pcap\tresp_4_infiniteloop.out\t-vvv -e\n+dns_fwdptr\t\tdns_fwdptr.pcap\t\t\tdns_fwdptr.out\t\t-vvv -e\n \n # RTP tests\n # fuzzed pcap\n@@ -483,3 +484,11 @@ rtp-seg-fault-2  rtp-seg-fault-2.pcap  rtp-seg-fault-2.out  -v -T rtp\n # NFS tests\n # fuzzed pcap\n nfs-seg-fault-1  nfs-seg-fault-1.pcap  nfs-seg-fault-1.out\n+\n+# DNS infinite loop tests\n+#\n+# See http://marc.info/?l=tcpdump-workers&m=95552439022555\n+#\n+dns-zlip-1\t\tdns-zlip-1.pcap\t\tdns-zlip-1.out\n+dns-zlip-2\t\tdns-zlip-2.pcap\t\tdns-zlip-2.out\n+dns-zlip-3\t\tdns-zlip-3.pcap\t\tdns-zlip-3.out"
            },
            {
                "fn": "tests/dns-zlip-1.out",
                "patch": "@@ -0,0 +1 @@\n+IP 10.0.0.1.1024 > 146.84.28.88.53: 60777 Type49159 (Class 49168)? <BAD PTR>[|domain]"
            },
            {
                "fn": "tests/dns-zlip-2.out",
                "patch": "@@ -0,0 +1 @@\n+IP 10.0.0.1.1024 > 146.84.28.88.53: 18992 Type49164 (Class 49168)? <BAD PTR>[|domain]"
            },
            {
                "fn": "tests/dns-zlip-3.out",
                "patch": "@@ -0,0 +1 @@\n+IP 10.0.0.1.1024 > 146.84.28.88.53: 65483 Type49164 (Class 49164)? thisleetostringwillcrashyourlittlenameserverforsurehahahahahah.<BAD PTR>[|domain]"
            },
            {
                "fn": "tests/dns_fwdptr.out",
                "patch": "@@ -0,0 +1,2 @@\n+be:af:ca:ce:ff:ff > de:ad:be:ef:00:01, ethertype IPv4 (0x0800), length 63207: (tos 0x0, ttl 128, id 36039, offset 0, flags [none], proto UDP (17), length 63193)\n+    156.118.17.235.53 > 156.118.27.229.500: [udp sum ok] 51584 zoneRef NoChange*|$ [64259q] q: Type507 (Class 769)? M-{.^AM-{^C.M-{.^AM-{^C.M-{.^AM-{^C.M-{.^AM-{^C.M-{.^AM-{ .M-{^C^A.<BAD PTR>[|domain]"
            }
        ],
        "error_msg": "    dns-zlip-1                         : TEST FAILED(exit 256)\n    dns-zlip-2                         : TEST FAILED(exit 256)\n    dns-zlip-3                         : TEST FAILED(exit 256)\n"
    },
    "6fca58f5f9c96749a575f52e20598ad43f5bdf30___print-pim.c": {
        "start": 655,
        "end": 1151,
        "buggy": "static void\npimv2_print(netdissect_options *ndo,\n            register const u_char *bp, register u_int len, const u_char *bp2)\n{\n\tregister const u_char *ep;\n\tregister const struct pim *pim = (const struct pim *)bp;\n\tint advance;\n\tenum checksum_status cksum_status;\n\n\tep = (const u_char *)ndo->ndo_snapend;\n\tif (bp >= ep)\n\t\treturn;\n\tif (ep > bp + len)\n\t\tep = bp + len;\n\tND_TCHECK(pim->pim_rsv);\n\tpimv2_addr_len = pim->pim_rsv;\n\tif (pimv2_addr_len != 0)\n\t\tND_PRINT((ndo, \", RFC2117-encoding\"));\n\n\tND_PRINT((ndo, \", cksum 0x%04x \", EXTRACT_16BITS(&pim->pim_cksum)));\n\tif (EXTRACT_16BITS(&pim->pim_cksum) == 0) {\n\t\tND_PRINT((ndo, \"(unverified)\"));\n\t} else {\n\t\tif (PIM_TYPE(pim->pim_typever) == PIMV2_TYPE_REGISTER) {\n\t\t\t/*\n\t\t\t * The checksum only covers the packet header,\n\t\t\t * not the encapsulated packet.\n\t\t\t */\n\t\t\tcksum_status = pimv2_check_checksum(ndo, bp, bp2, 8);\n\t\t\tif (cksum_status == INCORRECT) {\n\t\t\t\t/*\n\t\t\t\t * To quote RFC 4601, \"For interoperability\n\t\t\t\t * reasons, a message carrying a checksum\n\t\t\t\t * calculated over the entire PIM Register\n\t\t\t\t * message should also be accepted.\"\n\t\t\t\t */\n\t\t\t\tcksum_status = pimv2_check_checksum(ndo, bp, bp2, len);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * The checksum covers the entire packet.\n\t\t\t */\n\t\t\tcksum_status = pimv2_check_checksum(ndo, bp, bp2, len);\n\t\t}\n\t\tswitch (cksum_status) {\n\n\t\tcase CORRECT:\n\t\t\tND_PRINT((ndo, \"(correct)\"));\n\t\t\tbreak;\n\n\t\tcase INCORRECT:\n\t\t\tND_PRINT((ndo, \"(incorrect)\"));\n\t\t\tbreak;\n\n\t\tcase UNVERIFIED:\n\t\t\tND_PRINT((ndo, \"(unverified)\"));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (PIM_TYPE(pim->pim_typever)) {\n\tcase PIMV2_TYPE_HELLO:\n\t    {\n\t\tuint16_t otype, olen;\n\t\tbp += 4;\n\t\twhile (bp < ep) {\n\t\t\tND_TCHECK2(bp[0], 4);\n\t\t\totype = EXTRACT_16BITS(&bp[0]);\n\t\t\tolen = EXTRACT_16BITS(&bp[2]);\n\t\t\tND_TCHECK2(bp[0], 4 + olen);\n\t\t\tND_PRINT((ndo, \"\\n\\t  %s Option (%u), length %u, Value: \",\n\t\t\t          tok2str(pimv2_hello_option_values, \"Unknown\", otype),\n\t\t\t          otype,\n\t\t\t          olen));\n\t\t\tbp += 4;\n\n\t\t\tswitch (otype) {\n\t\t\tcase PIMV2_HELLO_OPTION_HOLDTIME:\n\t\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(bp));\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_LANPRUNEDELAY:\n\t\t\t\tif (olen != 4) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: Option Length != 4 Bytes (%u)\", olen));\n\t\t\t\t} else {\n\t\t\t\t\tchar t_bit;\n\t\t\t\t\tuint16_t lan_delay, override_interval;\n\t\t\t\t\tlan_delay = EXTRACT_16BITS(bp);\n\t\t\t\t\toverride_interval = EXTRACT_16BITS(bp+2);\n\t\t\t\t\tt_bit = (lan_delay & 0x8000)? 1 : 0;\n\t\t\t\t\tlan_delay &= ~0x8000;\n\t\t\t\t\tND_PRINT((ndo, \"\\n\\t    T-bit=%d, LAN delay %dms, Override interval %dms\",\n\t\t\t\t\tt_bit, lan_delay, override_interval));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_DR_PRIORITY_OLD:\n\t\t\tcase PIMV2_HELLO_OPTION_DR_PRIORITY:\n\t\t\t\tswitch (olen) {\n\t\t\t\tcase 0:\n\t\t\t\t\tND_PRINT((ndo, \"Bi-Directional Capability (Old)\"));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(bp)));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: Option Length != 4 Bytes (%u)\", olen));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_GENID:\n\t\t\t\tND_PRINT((ndo, \"0x%08x\", EXTRACT_32BITS(bp)));\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_REFRESH_CAP:\n\t\t\t\tND_PRINT((ndo, \"v%d\", *bp));\n\t\t\t\tif (*(bp+1) != 0) {\n\t\t\t\t\tND_PRINT((ndo, \", interval \"));\n\t\t\t\t\tunsigned_relts_print(ndo, *(bp+1));\n\t\t\t\t}\n\t\t\t\tif (EXTRACT_16BITS(bp+2) != 0) {\n\t\t\t\t\tND_PRINT((ndo, \" ?0x%04x?\", EXTRACT_16BITS(bp+2)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase  PIMV2_HELLO_OPTION_BIDIR_CAP:\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_ADDRESS_LIST_OLD:\n\t\t\tcase PIMV2_HELLO_OPTION_ADDRESS_LIST:\n\t\t\t\tif (ndo->ndo_vflag > 1) {\n\t\t\t\t\tconst u_char *ptr = bp;\n\t\t\t\t\twhile (ptr < (bp+olen)) {\n\t\t\t\t\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\t\t\t\t\tadvance = pimv2_addr_print(ndo, ptr, pimv2_unicast, 0);\n\t\t\t\t\t\tif (advance < 0) {\n\t\t\t\t\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tptr += advance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (ndo->ndo_vflag <= 1)\n\t\t\t\t\tprint_unknown_data(ndo, bp, \"\\n\\t    \", olen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* do we want to see an additionally hexdump ? */\n\t\t\tif (ndo->ndo_vflag> 1)\n\t\t\t\tprint_unknown_data(ndo, bp, \"\\n\\t    \", olen);\n\t\t\tbp += olen;\n\t\t}\n\t\tbreak;\n\t    }\n\n\tcase PIMV2_TYPE_REGISTER:\n\t{\n\t\tconst struct ip *ip;\n\n\t\tND_TCHECK2(*(bp + 4), PIMV2_REGISTER_FLAG_LEN);\n\n\t\tND_PRINT((ndo, \", Flags [ %s ]\\n\\t\",\n\t\t          tok2str(pimv2_register_flag_values,\n\t\t          \"none\",\n\t\t          EXTRACT_32BITS(bp+4))));\n\n\t\tbp += 8; len -= 8;\n\t\t/* encapsulated multicast packet */\n\t\tip = (const struct ip *)bp;\n\t\tswitch (IP_V(ip)) {\n                case 0: /* Null header */\n\t\t\tND_PRINT((ndo, \"IP-Null-header %s > %s\",\n\t\t\t          ipaddr_string(ndo, &ip->ip_src),\n\t\t\t          ipaddr_string(ndo, &ip->ip_dst)));\n\t\t\tbreak;\n\n\t\tcase 4:\t/* IPv4 */\n\t\t\tip_print(ndo, bp, len);\n\t\t\tbreak;\n\n\t\tcase 6:\t/* IPv6 */\n\t\t\tip6_print(ndo, bp, len);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tND_PRINT((ndo, \"IP ver %d\", IP_V(ip)));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PIMV2_TYPE_REGISTER_STOP:\n\t\tbp += 4; len -= 4;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" group=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" source=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tbreak;\n\n\tcase PIMV2_TYPE_JOIN_PRUNE:\n\tcase PIMV2_TYPE_GRAFT:\n\tcase PIMV2_TYPE_GRAFT_ACK:\n\n\n        /*\n         * 0                   1                   2                   3\n         *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |PIM Ver| Type  | Addr length   |           Checksum            |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |             Unicast-Upstream Neighbor Address                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |  Reserved     | Num groups    |          Holdtime             |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |            Encoded-Multicast Group Address-1                  |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |   Number of Joined  Sources   |   Number of Pruned Sources    |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Joined Source Address-1                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                             .                                 |\n         *  |                             .                                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Joined Source Address-n                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Pruned Source Address-1                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                             .                                 |\n         *  |                             .                                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Pruned Source Address-n                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                           .                                   |\n         *  |                           .                                   |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                Encoded-Multicast Group Address-n              |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         */\n\n\t    {\n\t\tuint8_t ngroup;\n\t\tuint16_t holdtime;\n\t\tuint16_t njoin;\n\t\tuint16_t nprune;\n\t\tint i, j;\n\n\t\tbp += 4; len -= 4;\n\t\tif (PIM_TYPE(pim->pim_typever) != 7) {\t/*not for Graft-ACK*/\n\t\t\tif (bp >= ep)\n\t\t\t\tbreak;\n\t\t\tND_PRINT((ndo, \", upstream-neighbor: \"));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbp += advance; len -= advance;\n\t\t}\n\t\tif (bp + 4 > ep)\n\t\t\tbreak;\n\t\tngroup = bp[1];\n\t\tholdtime = EXTRACT_16BITS(&bp[2]);\n\t\tND_PRINT((ndo, \"\\n\\t  %u group(s)\", ngroup));\n\t\tif (PIM_TYPE(pim->pim_typever) != 7) {\t/*not for Graft-ACK*/\n\t\t\tND_PRINT((ndo, \", holdtime: \"));\n\t\t\tif (holdtime == 0xffff)\n\t\t\t\tND_PRINT((ndo, \"infinite\"));\n\t\t\telse\n\t\t\t\tunsigned_relts_print(ndo, holdtime);\n\t\t}\n\t\tbp += 4; len -= 4;\n\t\tfor (i = 0; i < ngroup; i++) {\n\t\t\tif (bp >= ep)\n\t\t\t\tgoto jp_done;\n\t\t\tND_PRINT((ndo, \"\\n\\t    group #%u: \", i+1));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto jp_done;\n\t\t\t}\n\t\t\tbp += advance; len -= advance;\n\t\t\tif (bp + 4 > ep) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto jp_done;\n\t\t\t}\n\t\t\tnjoin = EXTRACT_16BITS(&bp[0]);\n\t\t\tnprune = EXTRACT_16BITS(&bp[2]);\n\t\t\tND_PRINT((ndo, \", joined sources: %u, pruned sources: %u\", njoin, nprune));\n\t\t\tbp += 4; len -= 4;\n\t\t\tfor (j = 0; j < njoin; j++) {\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      joined source #%u: \", j+1));\n\t\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_source, 0)) < 0) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto jp_done;\n\t\t\t\t}\n\t\t\t\tbp += advance; len -= advance;\n\t\t\t}\n\t\t\tfor (j = 0; j < nprune; j++) {\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      pruned source #%u: \", j+1));\n\t\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_source, 0)) < 0) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto jp_done;\n\t\t\t\t}\n\t\t\t\tbp += advance; len -= advance;\n\t\t\t}\n\t\t}\n\tjp_done:\n\t\tbreak;\n\t    }\n\n\tcase PIMV2_TYPE_BOOTSTRAP:\n\t{\n\t\tint i, j, frpcnt;\n\t\tbp += 4;\n\n\t\t/* Fragment Tag, Hash Mask len, and BSR-priority */\n\t\tif (bp + sizeof(uint16_t) >= ep) break;\n\t\tND_PRINT((ndo, \" tag=%x\", EXTRACT_16BITS(bp)));\n\t\tbp += sizeof(uint16_t);\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" hashmlen=%d\", bp[0]));\n\t\tif (bp + 1 >= ep) break;\n\t\tND_PRINT((ndo, \" BSRprio=%d\", bp[1]));\n\t\tbp += 2;\n\n\t\t/* Encoded-Unicast-BSR-Address */\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" BSR=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\n\t\tfor (i = 0; bp < ep; i++) {\n\t\t\t/* Encoded-Group Address */\n\t\t\tND_PRINT((ndo, \" (group%d: \", i));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0))\n\t\t\t    < 0) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto bs_done;\n\t\t\t}\n\t\t\tbp += advance;\n\n\t\t\t/* RP-Count, Frag RP-Cnt, and rsvd */\n\t\t\tif (bp >= ep) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto bs_done;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \" RPcnt=%d\", bp[0]));\n\t\t\tif (bp + 1 >= ep) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto bs_done;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \" FRPcnt=%d\", frpcnt = bp[1]));\n\t\t\tbp += 4;\n\n\t\t\tfor (j = 0; j < frpcnt && bp < ep; j++) {\n\t\t\t\t/* each RP info */\n\t\t\t\tND_PRINT((ndo, \" RP%d=\", j));\n\t\t\t\tif ((advance = pimv2_addr_print(ndo, bp,\n\t\t\t\t\t\t\t\tpimv2_unicast,\n\t\t\t\t\t\t\t\t0)) < 0) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto bs_done;\n\t\t\t\t}\n\t\t\t\tbp += advance;\n\n\t\t\t\tif (bp + 1 >= ep) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto bs_done;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, \",holdtime=\"));\n\t\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(bp));\n\t\t\t\tif (bp + 2 >= ep) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto bs_done;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, \",prio=%d\", bp[2]));\n\t\t\t\tbp += 4;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t}\n\t   bs_done:\n\t\tbreak;\n\t}\n\tcase PIMV2_TYPE_ASSERT:\n\t\tbp += 4; len -= 4;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" group=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" src=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tif (bp + 8 > ep)\n\t\t\tbreak;\n\t\tif (bp[0] & 0x80)\n\t\t\tND_PRINT((ndo, \" RPT\"));\n\t\tND_PRINT((ndo, \" pref=%u\", EXTRACT_32BITS(&bp[0]) & 0x7fffffff));\n\t\tND_PRINT((ndo, \" metric=%u\", EXTRACT_32BITS(&bp[4])));\n\t\tbreak;\n\n\tcase PIMV2_TYPE_CANDIDATE_RP:\n\t{\n\t\tint i, pfxcnt;\n\t\tbp += 4;\n\n\t\t/* Prefix-Cnt, Priority, and Holdtime */\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" prefix-cnt=%d\", bp[0]));\n\t\tpfxcnt = bp[0];\n\t\tif (bp + 1 >= ep) break;\n\t\tND_PRINT((ndo, \" prio=%d\", bp[1]));\n\t\tif (bp + 3 >= ep) break;\n\t\tND_PRINT((ndo, \" holdtime=\"));\n\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(&bp[2]));\n\t\tbp += 4;\n\n\t\t/* Encoded-Unicast-RP-Address */\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" RP=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\n\t\t/* Encoded-Group Addresses */\n\t\tfor (i = 0; i < pfxcnt && bp < ep; i++) {\n\t\t\tND_PRINT((ndo, \" Group%d=\", i));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0))\n\t\t\t    < 0) {\n\t\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbp += advance;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PIMV2_TYPE_PRUNE_REFRESH:\n\t\tND_PRINT((ndo, \" src=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\t\tND_PRINT((ndo, \" grp=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\t\tND_PRINT((ndo, \" forwarder=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\t\tND_TCHECK2(bp[0], 2);\n\t\tND_PRINT((ndo, \" TUNR \"));\n\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(bp));\n\t\tbreak;\n\n\n\t default:\n\t\tND_PRINT((ndo, \" [type %d]\", PIM_TYPE(pim->pim_typever)));\n\t\tbreak;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pim]\"));\n}\n",
        "fix": null,
        "src_path": "6fca58f5f9c96749a575f52e20598ad43f5bdf30___print-pim.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/6fca58f5f9c96749a575f52e20598ad43f5bdf30",
        "commit_msg": "CVE-2017-12996/PIMv2: Make sure PIM TLVs have the right length.\n\nWe do bounds checks based on the TLV length, so if the TLV's length is\ntoo short, and we don't check for that, we could end up fetching data\npast the end of the TLV - including past the length of the captured data\nin the packet.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd tests using the capture files supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -481,6 +481,10 @@ isis-areaaddr-oobr-2\tisis-areaaddr-oobr-2.pcap\tisis-areaaddr-oobr-2.out\t\t-vvv -e\n isis-extd-ipreach-oobr\tisis-extd-ipreach-oobr.pcap\tisis-extd-ipreach-oobr.out\t\t-vvv -e\n lldp-infinite-loop-1\tlldp-infinite-loop-1.pcap\tlldp-infinite-loop-1.out\t\t-vvv -e\n lldp-infinite-loop-2\tlldp-infinite-loop-2.pcap\tlldp-infinite-loop-2.out\t\t-vvv -e\n+pimv2-oobr-1\t\tpimv2-oobr-1.pcap\t\tpimv2-oobr-1.out\t\t-vvv -e\n+pimv2-oobr-2\t\tpimv2-oobr-2.pcap\t\tpimv2-oobr-2.out\t\t-vvv -e\n+pimv2-oobr-3\t\tpimv2-oobr-3.pcap\t\tpimv2-oobr-3.out\t\t-vvv -e\n+pimv2-oobr-4\t\tpimv2-oobr-4.pcap\t\tpimv2-oobr-4.out\t\t-vvv -e\n \n # RTP tests\n # fuzzed pcap"
            }
        ],
        "error_msg": "    pimv2-oobr-1                       : TEST FAILED(exit 256)\n    pimv2-oobr-2                       : TEST FAILED(exit 256)\n    pimv2-oobr-3                       : TEST FAILED(exit 256)\n    pimv2-oobr-4                       : TEST FAILED(exit 256)\n"
    },
    "7a923447fd49a069a0fd3b6c3547438ab5ee2123___print-nfs.c": {
        "start": 784,
        "end": 831,
        "buggy": "static void\nnfs_printfh(netdissect_options *ndo,\n            register const uint32_t *dp, const u_int len)\n{\n\tmy_fsid fsid;\n\tuint32_t ino;\n\tconst char *sfsname = NULL;\n\tchar *spacep;\n\n\tif (ndo->ndo_uflag) {\n\t\tu_int i;\n\t\tchar const *sep = \"\";\n\n\t\tND_PRINT((ndo, \" fh[\"));\n\t\tfor (i=0; i<len; i++) {\n\t\t\tND_PRINT((ndo, \"%s%x\", sep, dp[i]));\n\t\t\tsep = \":\";\n\t\t}\n\t\tND_PRINT((ndo, \"]\"));\n\t\treturn;\n\t}\n\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n\n\tif (sfsname) {\n\t\t/* file system ID is ASCII, not numeric, for this server OS */\n\t\tstatic char temp[NFSX_V3FHMAX+1];\n\n\t\t/* Make sure string is null-terminated */\n\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n\t\ttemp[sizeof(temp) - 1] = '\\0';\n\t\t/* Remove trailing spaces */\n\t\tspacep = strchr(temp, ' ');\n\t\tif (spacep)\n\t\t\t*spacep = '\\0';\n\n\t\tND_PRINT((ndo, \" fh %s/\", temp));\n\t} else {\n\t\tND_PRINT((ndo, \" fh %d,%d/\",\n\t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n\t}\n\n\tif(fsid.Fsid_dev.Minor == 257)\n\t\t/* Print the undecoded handle */\n\t\tND_PRINT((ndo, \"%s\", fsid.Opaque_Handle));\n\telse\n\t\tND_PRINT((ndo, \"%ld\", (long) ino));\n}\n",
        "fix": null,
        "src_path": "7a923447fd49a069a0fd3b6c3547438ab5ee2123___print-nfs.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/7a923447fd49a069a0fd3b6c3547438ab5ee2123",
        "commit_msg": "CVE-2017-13001/NFS: Don't copy more data than is in the file handle.\n\nAlso, put the buffer on the stack; no reason to make it static.  (65\nbytes isn't a lot.)\n\nThis fixes a buffer over-read discovered by Kamil Frankowicz.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -458,6 +458,7 @@ hoobr_parse_field\thoobr_parse_field.pcap\t\thoobr_parse_field.out\n hoobr_chdlc_print\thoobr_chdlc_print.pcap\t\thoobr_chdlc_print.out\n hoobr_lookup_nsap\thoobr_lookup_nsap.pcap\t\thoobr_lookup_nsap.out\n hoobr_rt6_print\t\thoobr_rt6_print.pcap\t\thoobr_rt6_print.out\n+hoobr_nfs_printfh\thoobr_nfs_printfh.pcap\t\thoobr_nfs_printfh.out\n \n # bad packets from Wilfried Kirsch\n slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve"
            },
            {
                "fn": "tests/hoobr_nfs_printfh.out",
                "patch": "@@ -0,0 +1,104 @@\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00d0:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030                      00000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00d0:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030                                0000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030                                0000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00d0:  3030 3030 3030 3030 3030 3030            000000000000\n+IP 48.48.48.48.12336 > 48.48.48.48.2049: Flags [.U], seq 808464432:808476728, ack 808464432, win 12336, urg 12336, length 12296: NFS request xid 808464432 12292 readlink fh 00000000/808464432"
            }
        ],
        "error_msg": "    hoobr_nfs_printfh                  : TEST FAILED(exit 256)\n"
    },
    "b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd___print-nfs.c": {
        "start": 865,
        "end": 905,
        "buggy": "static int\nxid_map_enter(netdissect_options *ndo,\n              const struct sunrpc_msg *rp, const u_char *bp)\n{\n\tconst struct ip *ip = NULL;\n\tconst struct ip6_hdr *ip6 = NULL;\n\tstruct xid_map_entry *xmep;\n\n\tif (!ND_TTEST(rp->rm_call.cb_vers))\n\t\treturn (0);\n\tswitch (IP_V((const struct ip *)bp)) {\n\tcase 4:\n\t\tip = (const struct ip *)bp;\n\t\tbreak;\n\tcase 6:\n\t\tip6 = (const struct ip6_hdr *)bp;\n\t\tbreak;\n\tdefault:\n\t\treturn (1);\n\t}\n\n\txmep = &xid_map[xid_map_next];\n\n\tif (++xid_map_next >= XIDMAPSIZE)\n\t\txid_map_next = 0;\n\n\tUNALIGNED_MEMCPY(&xmep->xid, &rp->rm_xid, sizeof(xmep->xid));\n\tif (ip) {\n\t\txmep->ipver = 4;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));\n\t}\n\telse if (ip6) {\n\t\txmep->ipver = 6;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));\n\t}\n\txmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);\n\txmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);\n\treturn (1);\n}\n",
        "fix": null,
        "src_path": "b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd___print-nfs.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd",
        "commit_msg": "CVE-2017-13005/NFS: Add two bounds checks before fetching data\n\nThis fixes a buffer over-read discovered by Kamil Frankowicz.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -461,6 +461,7 @@ hoobr_lookup_nsap\thoobr_lookup_nsap.pcap\t\thoobr_lookup_nsap.out\n hoobr_rt6_print\t\thoobr_rt6_print.pcap\t\thoobr_rt6_print.out\n hoobr_nfs_printfh\thoobr_nfs_printfh.pcap\t\thoobr_nfs_printfh.out\n hoobr_aodv_extension\thoobr_aodv_extension.pcap\thoobr_aodv_extension.out\n+hoobr_nfs_xid_map_enter hoobr_nfs_xid_map_enter.pcap    hoobr_nfs_xid_map_enter.out\n \n # bad packets from Wilfried Kirsch\n slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve"
            },
            {
                "fn": "tests/hoobr_nfs_xid_map_enter.out",
                "patch": "@@ -0,0 +1,41 @@\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+IP 48.48.48.48.12336 > 48.48.48.48.2049: NFS request xid 808464432 12308 [|nfs]"
            }
        ],
        "error_msg": "    hoobr_nfs_xid_map_enter            : TEST FAILED(exit 256)\n"
    },
    "5edf405d7ed9fc92f4f43e8a3d44baa4c6387562___print-802_11.c": {
        "start": 997,
        "end": 1220,
        "buggy": "static int\nparse_elements(netdissect_options *ndo,\n               struct mgmt_body_t *pbody, const u_char *p, int offset,\n               u_int length)\n{\n\tu_int elementlen;\n\tstruct ssid_t ssid;\n\tstruct challenge_t challenge;\n\tstruct rates_t rates;\n\tstruct ds_t ds;\n\tstruct cf_t cf;\n\tstruct tim_t tim;\n\n\t/*\n\t * We haven't seen any elements yet.\n\t */\n\tpbody->challenge_present = 0;\n\tpbody->ssid_present = 0;\n\tpbody->rates_present = 0;\n\tpbody->ds_present = 0;\n\tpbody->cf_present = 0;\n\tpbody->tim_present = 0;\n\n\twhile (length != 0) {\n\t\t/* Make sure we at least have the element ID and length. */\n\t\tif (!ND_TTEST2(*(p + offset), 2))\n\t\t\treturn 0;\n\t\tif (length < 2)\n\t\t\treturn 0;\n\t\telementlen = *(p + offset + 1);\n\n\t\t/* Make sure we have the entire element. */\n\t\tif (!ND_TTEST2(*(p + offset + 2), elementlen))\n\t\t\treturn 0;\n\t\tif (length < elementlen + 2)\n\t\t\treturn 0;\n\n\t\tswitch (*(p + offset)) {\n\t\tcase E_SSID:\n\t\t\tmemcpy(&ssid, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (ssid.length != 0) {\n\t\t\t\tif (ssid.length > sizeof(ssid.ssid) - 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), ssid.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < ssid.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&ssid.ssid, p + offset, ssid.length);\n\t\t\t\toffset += ssid.length;\n\t\t\t\tlength -= ssid.length;\n\t\t\t}\n\t\t\tssid.ssid[ssid.length] = '\\0';\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen an SSID IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->ssid_present) {\n\t\t\t\tpbody->ssid = ssid;\n\t\t\t\tpbody->ssid_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_CHALLENGE:\n\t\t\tmemcpy(&challenge, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (challenge.length != 0) {\n\t\t\t\tif (challenge.length >\n\t\t\t\t    sizeof(challenge.text) - 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), challenge.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < challenge.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&challenge.text, p + offset,\n\t\t\t\t    challenge.length);\n\t\t\t\toffset += challenge.length;\n\t\t\t\tlength -= challenge.length;\n\t\t\t}\n\t\t\tchallenge.text[challenge.length] = '\\0';\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a challenge IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->challenge_present) {\n\t\t\t\tpbody->challenge = challenge;\n\t\t\t\tpbody->challenge_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_RATES:\n\t\t\tmemcpy(&rates, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (rates.length != 0) {\n\t\t\t\tif (rates.length > sizeof rates.rate)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), rates.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < rates.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&rates.rate, p + offset, rates.length);\n\t\t\t\toffset += rates.length;\n\t\t\t\tlength -= rates.length;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a rates IE,\n\t\t\t * copy this one if it's not zero-length,\n\t\t\t * otherwise ignore this one, so we later\n\t\t\t * report the first one we saw.\n\t\t\t *\n\t\t\t * We ignore zero-length rates IEs as some\n\t\t\t * devices seem to put a zero-length rates\n\t\t\t * IE, followed by an SSID IE, followed by\n\t\t\t * a non-zero-length rates IE into frames,\n\t\t\t * even though IEEE Std 802.11-2007 doesn't\n\t\t\t * seem to indicate that a zero-length rates\n\t\t\t * IE is valid.\n\t\t\t */\n\t\t\tif (!pbody->rates_present && rates.length != 0) {\n\t\t\t\tpbody->rates = rates;\n\t\t\t\tpbody->rates_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_DS:\n\t\t\tmemcpy(&ds, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (ds.length != 1) {\n\t\t\t\toffset += ds.length;\n\t\t\t\tlength -= ds.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tds.channel = *(p + offset);\n\t\t\toffset += 1;\n\t\t\tlength -= 1;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a DS IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->ds_present) {\n\t\t\t\tpbody->ds = ds;\n\t\t\t\tpbody->ds_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_CF:\n\t\t\tmemcpy(&cf, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (cf.length != 6) {\n\t\t\t\toffset += cf.length;\n\t\t\t\tlength -= cf.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(&cf.count, p + offset, 6);\n\t\t\toffset += 6;\n\t\t\tlength -= 6;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a CF IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->cf_present) {\n\t\t\t\tpbody->cf = cf;\n\t\t\t\tpbody->cf_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_TIM:\n\t\t\tmemcpy(&tim, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (tim.length <= 3) {\n\t\t\t\toffset += tim.length;\n\t\t\t\tlength -= tim.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tim.length - 3 > (int)sizeof tim.bitmap)\n\t\t\t\treturn 0;\n\t\t\tmemcpy(&tim.count, p + offset, 3);\n\t\t\toffset += 3;\n\t\t\tlength -= 3;\n\n\t\t\tmemcpy(tim.bitmap, p + offset + 3, tim.length - 3);\n\t\t\toffset += tim.length - 3;\n\t\t\tlength -= tim.length - 3;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a TIM IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->tim_present) {\n\t\t\t\tpbody->tim = tim;\n\t\t\t\tpbody->tim_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n#if 0\n\t\t\tND_PRINT((ndo, \"(1) unhandled element_id (%d)  \",\n\t\t\t    *(p + offset)));\n#endif\n\t\t\toffset += 2 + elementlen;\n\t\t\tlength -= 2 + elementlen;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* No problems found. */\n\treturn 1;\n}\n",
        "fix": null,
        "src_path": "5edf405d7ed9fc92f4f43e8a3d44baa4c6387562___print-802_11.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/5edf405d7ed9fc92f4f43e8a3d44baa4c6387562",
        "commit_msg": "CVE-2017-13008/IEEE 802.11: Fix TIM bitmap copy to copy from p + offset.\n\noffset has already been advanced to point to the bitmap; we shouldn't\nadd the amount to advance again.\n\nThis fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.\n\nAdd a test using the capture file supplied by the reporter(s).\n\nWhile we're at it, remove some redundant tests - we've already checked,\nbefore the case statement, whether we have captured the entire\ninformation element and whether the entire information element is\npresent in the on-the-wire packet; in the cases for particular IEs, we\nonly need to make sure we don't go past the end of the IE.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -438,6 +438,7 @@ ipv6-rthdr-oobr\t\tipv6-rthdr-oobr.pcap\t\tipv6-rthdr-oobr.out\n ieee802.11_tim_ie_oobr\tieee802.11_tim_ie_oobr.pcap\tieee802.11_tim_ie_oobr.out\n decnet-shorthdr-oobr\tdecnet-shorthdr-oobr.pcap\tdecnet-shorthdr-oobr.out\n isakmp-3948-oobr-2\tisakmp-3948-oobr-2.pcap\t\tisakmp-3948-oobr-2.out\n+ieee802.11_rates_oobr\tieee802.11_rates_oobr.pcap\tieee802.11_rates_oobr.out\n \n # bad packets from Kamil Frankowicz\n snmp-heapoverflow-1\tsnmp-heapoverflow-1.pcap\tsnmp-heapoverflow-1.out"
            },
            {
                "fn": "tests/ieee802.11_rates_oobr.out",
                "patch": "@@ -0,0 +1 @@\n+fhset 48 fhpat 48 48dBm signal 48dB signal 48dB noise [|802.11]Beacon IBSS, PRIVACY[|802.11]"
            }
        ],
        "error_msg": "    ieee802.11_rates_oobr              : passed\n"
    },
    "985122081165753c7442bd7824c473eb9ff56308___print-eap.c": {
        "start": 149,
        "end": 288,
        "buggy": "void\neap_print(netdissect_options *ndo,\n          register const u_char *cp,\n          u_int length)\n{\n    const struct eap_frame_t *eap;\n    const u_char *tptr;\n    u_int tlen, type, subtype;\n    int count=0, len;\n\n    tptr = cp;\n    tlen = length;\n    eap = (const struct eap_frame_t *)cp;\n    ND_TCHECK(*eap);\n\n    /* in non-verbose mode just lets print the basic info */\n    if (ndo->ndo_vflag < 1) {\n\tND_PRINT((ndo, \"%s (%u) v%u, len %u\",\n               tok2str(eap_frame_type_values, \"unknown\", eap->type),\n               eap->type,\n               eap->version,\n               EXTRACT_16BITS(eap->length)));\n\treturn;\n    }\n\n    ND_PRINT((ndo, \"%s (%u) v%u, len %u\",\n           tok2str(eap_frame_type_values, \"unknown\", eap->type),\n           eap->type,\n           eap->version,\n           EXTRACT_16BITS(eap->length)));\n\n    tptr += sizeof(const struct eap_frame_t);\n    tlen -= sizeof(const struct eap_frame_t);\n\n    switch (eap->type) {\n    case EAP_FRAME_TYPE_PACKET:\n        type = *(tptr);\n        len = EXTRACT_16BITS(tptr+2);\n        ND_PRINT((ndo, \", %s (%u), id %u, len %u\",\n               tok2str(eap_code_values, \"unknown\", type),\n               type,\n               *(tptr+1),\n               len));\n\n        ND_TCHECK2(*tptr, len);\n\n        if (type <= 2) { /* For EAP_REQUEST and EAP_RESPONSE only */\n            subtype = *(tptr+4);\n            ND_PRINT((ndo, \"\\n\\t\\t Type %s (%u)\",\n                   tok2str(eap_type_values, \"unknown\", *(tptr+4)),\n                   *(tptr + 4)));\n\n            switch (subtype) {\n            case EAP_TYPE_IDENTITY:\n                if (len - 5 > 0) {\n                    ND_PRINT((ndo, \", Identity: \"));\n                    safeputs(ndo, tptr + 5, len - 5);\n                }\n                break;\n\n            case EAP_TYPE_NOTIFICATION:\n                if (len - 5 > 0) {\n                    ND_PRINT((ndo, \", Notification: \"));\n                    safeputs(ndo, tptr + 5, len - 5);\n                }\n                break;\n\n            case EAP_TYPE_NAK:\n                count = 5;\n\n                /*\n                 * one or more octets indicating\n                 * the desired authentication\n                 * type one octet per type\n                 */\n                while (count < len) {\n                    ND_PRINT((ndo, \" %s (%u),\",\n                           tok2str(eap_type_values, \"unknown\", *(tptr+count)),\n                           *(tptr + count)));\n                    count++;\n                }\n                break;\n\n            case EAP_TYPE_TTLS:\n                ND_PRINT((ndo, \" TTLSv%u\",\n                       EAP_TTLS_VERSION(*(tptr + 5)))); /* fall through */\n            case EAP_TYPE_TLS:\n                ND_PRINT((ndo, \" flags [%s] 0x%02x,\",\n                       bittok2str(eap_tls_flags_values, \"none\", *(tptr+5)),\n                       *(tptr + 5)));\n\n                if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {\n\t\t    ND_PRINT((ndo, \" len %u\", EXTRACT_32BITS(tptr + 6)));\n                }\n                break;\n\n            case EAP_TYPE_FAST:\n                ND_PRINT((ndo, \" FASTv%u\",\n                       EAP_TTLS_VERSION(*(tptr + 5))));\n                ND_PRINT((ndo, \" flags [%s] 0x%02x,\",\n                       bittok2str(eap_tls_flags_values, \"none\", *(tptr+5)),\n                       *(tptr + 5)));\n\n                if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {\n                    ND_PRINT((ndo, \" len %u\", EXTRACT_32BITS(tptr + 6)));\n                }\n\n                /* FIXME - TLV attributes follow */\n                break;\n\n            case EAP_TYPE_AKA:\n            case EAP_TYPE_SIM:\n                ND_PRINT((ndo, \" subtype [%s] 0x%02x,\",\n                       tok2str(eap_aka_subtype_values, \"unknown\", *(tptr+5)),\n                       *(tptr + 5)));\n\n                /* FIXME - TLV attributes follow */\n                break;\n\n            case EAP_TYPE_MD5_CHALLENGE:\n            case EAP_TYPE_OTP:\n            case EAP_TYPE_GTC:\n            case EAP_TYPE_EXPANDED_TYPES:\n            case EAP_TYPE_EXPERIMENTAL:\n            default:\n                break;\n            }\n        }\n        break;\n\n    case EAP_FRAME_TYPE_LOGOFF:\n    case EAP_FRAME_TYPE_ENCAP_ASF_ALERT:\n    default:\n        break;\n    }\n    return;\n\n trunc:\n    ND_PRINT((ndo, \"\\n\\t[|EAP]\"));\n}\n",
        "fix": null,
        "src_path": "985122081165753c7442bd7824c473eb9ff56308___print-eap.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/985122081165753c7442bd7824c473eb9ff56308",
        "commit_msg": "CVE-2017-13015/EAP: Add more bounds checks.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -512,6 +512,7 @@ wb-oobr\t\t\twb-oobr.pcap\t\t\twb-oobr.out\t-v\n lldp_asan\t\tlldp_asan.pcap\t\t\tlldp_asan.out\t-v\n extract_read2_asan\textract_read2_asan.pcap\t\textract_read2_asan.out\t-v\n getname_2_read4_asan\tgetname_2_read4_asan.pcap\tgetname_2_read4_asan.out\t-v\n+eap_extract_read2_asan\teap_extract_read2_asan.pcap\teap_extract_read2_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/eap_extract_read2_asan.out",
                "patch": "@@ -0,0 +1,2 @@\n+EAP packet (0) v155, len 0\n+\t[|EAP]"
            }
        ],
        "error_msg": "    eap_extract_read2_asan             : TEST FAILED(exit 256)\n"
    },
    "4601c685e7fd19c3724d5e499c69b8d3ec49933e___print-pgm.c": {
        "start": 145,
        "end": 788,
        "buggy": "void\npgm_print(netdissect_options *ndo,\n          register const u_char *bp, register u_int length,\n          register const u_char *bp2)\n{\n\tregister const struct pgm_header *pgm;\n\tregister const struct ip *ip;\n\tregister char ch;\n\tuint16_t sport, dport;\n\tu_int nla_afnum;\n\tchar nla_buf[INET6_ADDRSTRLEN];\n\tregister const struct ip6_hdr *ip6;\n\tuint8_t opt_type, opt_len;\n\tuint32_t seq, opts_len, len, offset;\n\n\tpgm = (const struct pgm_header *)bp;\n\tip = (const struct ip *)bp2;\n\tif (IP_V(ip) == 6)\n\t\tip6 = (const struct ip6_hdr *)bp2;\n\telse\n\t\tip6 = NULL;\n\tch = '\\0';\n\tif (!ND_TTEST(pgm->pgm_dport)) {\n\t\tif (ip6) {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst)));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst)));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsport = EXTRACT_16BITS(&pgm->pgm_sport);\n\tdport = EXTRACT_16BITS(&pgm->pgm_dport);\n\n\tif (ip6) {\n\t\tif (ip6->ip6_nxt == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t} else {\n\t\tif (ip->ip_p == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t}\n\n\tND_TCHECK(*pgm);\n\n        ND_PRINT((ndo, \"PGM, length %u\", EXTRACT_16BITS(&pgm->pgm_length)));\n\n        if (!ndo->ndo_vflag)\n            return;\n\n\tND_PRINT((ndo, \" 0x%02x%02x%02x%02x%02x%02x \",\n\t\t     pgm->pgm_gsid[0],\n                     pgm->pgm_gsid[1],\n                     pgm->pgm_gsid[2],\n\t\t     pgm->pgm_gsid[3],\n                     pgm->pgm_gsid[4],\n                     pgm->pgm_gsid[5]));\n\tswitch (pgm->pgm_type) {\n\tcase PGM_SPM: {\n\t    const struct pgm_spm *spm;\n\n\t    spm = (const struct pgm_spm *)(pgm + 1);\n\t    ND_TCHECK(*spm);\n\t    bp = (const u_char *) (spm + 1);\n\n\t    switch (EXTRACT_16BITS(&spm->pgms_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_PRINT((ndo, \"SPM seq %u trail %u lead %u nla %s\",\n\t\t\t EXTRACT_32BITS(&spm->pgms_seq),\n                         EXTRACT_32BITS(&spm->pgms_trailseq),\n\t\t\t EXTRACT_32BITS(&spm->pgms_leadseq),\n                         nla_buf));\n\t    break;\n\t}\n\n\tcase PGM_POLL: {\n\t    const struct pgm_poll *poll_msg;\n\n\t    poll_msg = (const struct pgm_poll *)(pgm + 1);\n\t    ND_TCHECK(*poll_msg);\n\t    ND_PRINT((ndo, \"POLL seq %u round %u\",\n\t\t\t EXTRACT_32BITS(&poll_msg->pgmp_seq),\n                         EXTRACT_16BITS(&poll_msg->pgmp_round)));\n\t    bp = (const u_char *) (poll_msg + 1);\n\t    break;\n\t}\n\tcase PGM_POLR: {\n\t    const struct pgm_polr *polr;\n\t    uint32_t ivl, rnd, mask;\n\n\t    polr = (const struct pgm_polr *)(pgm + 1);\n\t    ND_TCHECK(*polr);\n\t    bp = (const u_char *) (polr + 1);\n\n\t    switch (EXTRACT_16BITS(&polr->pgmp_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    ivl = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    rnd = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    mask = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_PRINT((ndo, \"POLR seq %u round %u nla %s ivl %u rnd 0x%08x \"\n\t\t\t \"mask 0x%08x\", EXTRACT_32BITS(&polr->pgmp_seq),\n\t\t\t EXTRACT_16BITS(&polr->pgmp_round), nla_buf, ivl, rnd, mask));\n\t    break;\n\t}\n\tcase PGM_ODATA: {\n\t    const struct pgm_data *odata;\n\n\t    odata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*odata);\n\t    ND_PRINT((ndo, \"ODATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&odata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&odata->pgmd_seq)));\n\t    bp = (const u_char *) (odata + 1);\n\t    break;\n\t}\n\n\tcase PGM_RDATA: {\n\t    const struct pgm_data *rdata;\n\n\t    rdata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*rdata);\n\t    ND_PRINT((ndo, \"RDATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_seq)));\n\t    bp = (const u_char *) (rdata + 1);\n\t    break;\n\t}\n\n\tcase PGM_NAK:\n\tcase PGM_NULLNAK:\n\tcase PGM_NCF: {\n\t    const struct pgm_nak *nak;\n\t    char source_buf[INET6_ADDRSTRLEN], group_buf[INET6_ADDRSTRLEN];\n\n\t    nak = (const struct pgm_nak *)(pgm + 1);\n\t    ND_TCHECK(*nak);\n\t    bp = (const u_char *) (nak + 1);\n\n\t    /*\n\t     * Skip past the source, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    switch (EXTRACT_16BITS(&nak->pgmn_source_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Skip past the group, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    bp += (2 * sizeof(uint16_t));\n\t    switch (EXTRACT_16BITS(bp)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Options decoding can go here.\n\t     */\n\t    switch (pgm->pgm_type) {\n\t\tcase PGM_NAK:\n\t\t    ND_PRINT((ndo, \"NAK \"));\n\t\t    break;\n\t\tcase PGM_NULLNAK:\n\t\t    ND_PRINT((ndo, \"NNAK \"));\n\t\t    break;\n\t\tcase PGM_NCF:\n\t\t    ND_PRINT((ndo, \"NCF \"));\n\t\t    break;\n\t\tdefault:\n                    break;\n\t    }\n\t    ND_PRINT((ndo, \"(%s -> %s), seq %u\",\n\t\t\t source_buf, group_buf, EXTRACT_32BITS(&nak->pgmn_seq)));\n\t    break;\n\t}\n\n\tcase PGM_ACK: {\n\t    const struct pgm_ack *ack;\n\n\t    ack = (const struct pgm_ack *)(pgm + 1);\n\t    ND_TCHECK(*ack);\n\t    ND_PRINT((ndo, \"ACK seq %u\",\n\t\t\t EXTRACT_32BITS(&ack->pgma_rx_max_seq)));\n\t    bp = (const u_char *) (ack + 1);\n\t    break;\n\t}\n\n\tcase PGM_SPMR:\n\t    ND_PRINT((ndo, \"SPMR\"));\n\t    break;\n\n\tdefault:\n\t    ND_PRINT((ndo, \"UNKNOWN type 0x%02x\", pgm->pgm_type));\n\t    break;\n\n\t}\n\tif (pgm->pgm_options & PGM_OPT_BIT_PRESENT) {\n\n\t    /*\n\t     * make sure there's enough for the first option header\n\t     */\n\t    if (!ND_TTEST2(*bp, PGM_MIN_OPT_LEN)) {\n\t\tND_PRINT((ndo, \"[|OPT]\"));\n\t\treturn;\n\t    }\n\n\t    /*\n\t     * That option header MUST be an OPT_LENGTH option\n\t     * (see the first paragraph of section 9.1 in RFC 3208).\n\t     */\n\t    opt_type = *bp++;\n\t    if ((opt_type & PGM_OPT_MASK) != PGM_OPT_LENGTH) {\n\t\tND_PRINT((ndo, \"[First option bad, should be PGM_OPT_LENGTH, is %u]\", opt_type & PGM_OPT_MASK));\n\t\treturn;\n\t    }\n\t    opt_len = *bp++;\n\t    if (opt_len != 4) {\n\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != 4]\", opt_len));\n\t\treturn;\n\t    }\n\t    opts_len = EXTRACT_16BITS(bp);\n\t    if (opts_len < 4) {\n\t\tND_PRINT((ndo, \"[Bad total option length %u < 4]\", opts_len));\n\t\treturn;\n\t    }\n\t    bp += sizeof(uint16_t);\n\t    ND_PRINT((ndo, \" OPTS LEN %d\", opts_len));\n\t    opts_len -= 4;\n\n\t    while (opts_len) {\n\t\tif (opts_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n\t\tif (!ND_TTEST2(*bp, 2)) {\n\t\t    ND_PRINT((ndo, \" [|OPT]\"));\n\t\t    return;\n\t\t}\n\t\topt_type = *bp++;\n\t\topt_len = *bp++;\n\t\tif (opt_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Bad option, length %u < %u]\", opt_len,\n\t\t        PGM_MIN_OPT_LEN));\n\t\t    break;\n\t\t}\n\t\tif (opts_len < opt_len) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n\t\tif (!ND_TTEST2(*bp, opt_len - 2)) {\n\t\t    ND_PRINT((ndo, \" [|OPT]\"));\n\t\t    return;\n\t\t}\n\n\t\tswitch (opt_type & PGM_OPT_MASK) {\n\t\tcase PGM_OPT_LENGTH:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    ND_PRINT((ndo, \" OPTS LEN (extra?) %d\", EXTRACT_16BITS(bp)));\n\t\t    bp += sizeof(uint16_t);\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_FRAGMENT:\n\t\t    if (opt_len != 16) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FRAGMENT option, length %u != 16]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" FRAG seq %u off %u len %u\", seq, offset, len));\n\t\t    opts_len -= 16;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_LIST:\n\t\t    bp += 2;\n\t\t    opt_len -= sizeof(uint32_t);\t/* option header */\n\t\t    ND_PRINT((ndo, \" NAK LIST\"));\n\t\t    while (opt_len) {\n\t\t\tif (opt_len < sizeof(uint32_t)) {\n\t\t\t    ND_PRINT((ndo, \"[Option length not a multiple of 4]\"));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(uint32_t));\n\t\t\tND_PRINT((ndo, \" %u\", EXTRACT_32BITS(bp)));\n\t\t\tbp += sizeof(uint32_t);\n\t\t\topt_len -= sizeof(uint32_t);\n\t\t\topts_len -= sizeof(uint32_t);\n\t\t    }\n\t\t    break;\n\n\t\tcase PGM_OPT_JOIN:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_JOIN option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" JOIN %u\", seq));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_BO_IVL:\n\t\t    if (opt_len != 12) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_IVL option, length %u != 12]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" BACKOFF ivl %u ivlseq %u\", offset, seq));\n\t\t    opts_len -= 12;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_BO_RNG:\n\t\t    if (opt_len != 12) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_RNG option, length %u != 12]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" BACKOFF max %u min %u\", offset, seq));\n\t\t    opts_len -= 12;\n\t\t    break;\n\n\t\tcase PGM_OPT_REDIRECT:\n\t\t    bp += 2;\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 4 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != 4 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 4 + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 4 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != 4 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 4 + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" REDIRECT %s\",  nla_buf));\n\t\t    break;\n\n\t\tcase PGM_OPT_PARITY_PRM:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_PRM option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" PARITY MAXTGS %u\", len));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_PARITY_GRP:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_GRP option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" PARITY GROUP %u\", seq));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_CURR_TGSIZE:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CURR_TGSIZE option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" PARITY ATGS %u\", len));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_NBR_UNREACH:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NBR_UNREACH option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" NBR_UNREACH\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_PATH_NLA:\n\t\t    ND_PRINT((ndo, \" PATH_NLA [%d]\", opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\n\t\tcase PGM_OPT_SYN:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_SYN option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" SYN\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_FIN:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FIN option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" FIN\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_RST:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_RST option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" RST\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_CR:\n\t\t    ND_PRINT((ndo, \" CR\"));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\n\t\tcase PGM_OPT_CRQST:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CRQST option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" CRQST\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_PGMCC_DATA:\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 12 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 12 + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 12 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 12 + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC DATA %u %s\", offset, nla_buf));\n\t\t    break;\n\n\t\tcase PGM_OPT_PGMCC_FEEDBACK:\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 12 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 12 + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 12 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 12 + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC FEEDBACK %u %s\", offset, nla_buf));\n\t\t    break;\n\n\t\tdefault:\n\t\t    ND_PRINT((ndo, \" OPT_%02X [%d] \", opt_type, opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\t\t}\n\n\t\tif (opt_type & PGM_OPT_END)\n\t\t    break;\n\t     }\n\t}\n\n\tND_PRINT((ndo, \" [%u]\", length));\n\tif (ndo->ndo_packettype == PT_PGM_ZMTP1 &&\n\t    (pgm->pgm_type == PGM_ODATA || pgm->pgm_type == PGM_RDATA))\n\t\tzmtp1_print_datagram(ndo, bp, EXTRACT_16BITS(&pgm->pgm_length));\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pgm]\"));\n\tif (ch != '\\0')\n\t\tND_PRINT((ndo, \">\"));\n}\n",
        "fix": null,
        "src_path": "4601c685e7fd19c3724d5e499c69b8d3ec49933e___print-pgm.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/4601c685e7fd19c3724d5e499c69b8d3ec49933e",
        "commit_msg": "CVE-2017-13019: Clean up PGM option processing.\n\nAdd #defines for option lengths or the lengths of the fixed-length part\nof the option.  Sometimes those #defines differ from what was there\nbefore; what was there before was wrong, probably because the option\nlengths given in RFC 3208 were sometimes wrong - some lengths included\nthe length of the option header, some lengths didn't.\n\nDon't use \"sizeof(uintXX_t)\" for sizes in the packet, just use the\nnumber of bytes directly.\n\nFor the options that include an IPv4 or IPv6 address, check the option\nlength against the length of what precedes the address before fetching\nany of that data.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -520,6 +520,7 @@ esis_snpa_asan-4\tesis_snpa_asan-4.pcap\t\tesis_snpa_asan-4.out\t-v\n esis_snpa_asan-5\tesis_snpa_asan-5.pcap\t\tesis_snpa_asan-5.out\t-v\n dhcp6_reconf_asan\tdhcp6_reconf_asan.pcap\t\tdhcp6_reconf_asan.out\t-v\n pgm_opts_asan\t\tpgm_opts_asan.pcap\t\tpgm_opts_asan.out\t-v\n+pgm_opts_asan_2\t\tpgm_opts_asan_2.pcap\t\tpgm_opts_asan_2.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/pgm_opts_asan_2.out",
                "patch": "@@ -0,0 +1,2 @@\n+IP (tos 0x41,ECT(1), id 0, offset 0, flags [none], proto PGM (113), length 32639, options (unknown 89 [bad length 232]), bad cksum 5959 (->96b9)!)\n+    128.121.89.107 > 89.89.16.63: 128.121.89.107.4 > 89.89.16.63.225: PGM, length 0 0x3414eb1f0022 UNKNOWN type 0x1f OPTS LEN 225 OPT_1F [13]  OPT_06 [26] [Bad OPT_PGMCC_DATA option, length 4 < 12]"
            }
        ],
        "error_msg": "    pgm_opts_asan_2                    : TEST FAILED(exit 256)\n"
    },
    "c5dd7bef5e54da5996dc4713284aa6266ae75b75___print-vtp.c": {
        "start": 119,
        "end": 376,
        "buggy": "void\nvtp_print (netdissect_options *ndo,\n           const u_char *pptr, u_int length)\n{\n    int type, len, tlv_len, tlv_value, mgmtd_len;\n    const u_char *tptr;\n    const struct vtp_vlan_ *vtp_vlan;\n\n    if (length < VTP_HEADER_LEN)\n        goto trunc;\n\n    tptr = pptr;\n\n    ND_TCHECK2(*tptr, VTP_HEADER_LEN);\n\n    type = *(tptr+1);\n    ND_PRINT((ndo, \"VTPv%u, Message %s (0x%02x), length %u\",\n\t   *tptr,\n\t   tok2str(vtp_message_type_values,\"Unknown message type\", type),\n\t   type,\n\t   length));\n\n    /* In non-verbose mode, just print version and message type */\n    if (ndo->ndo_vflag < 1) {\n        return;\n    }\n\n    /* verbose mode print all fields */\n    ND_PRINT((ndo, \"\\n\\tDomain name: \"));\n    mgmtd_len = *(tptr + 3);\n    if (mgmtd_len < 1 ||  mgmtd_len > 32) {\n\tND_PRINT((ndo, \" [invalid MgmtD Len %d]\", mgmtd_len));\n\treturn;\n    }\n    fn_printzp(ndo, tptr + 4, mgmtd_len, NULL);\n    ND_PRINT((ndo, \", %s: %u\",\n\t   tok2str(vtp_header_values, \"Unknown\", type),\n\t   *(tptr+2)));\n\n    tptr += VTP_HEADER_LEN;\n\n    switch (type) {\n\n    case VTP_SUMMARY_ADV:\n\n\t/*\n\t *  SUMMARY ADVERTISEMENT\n\t *\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |     Version   |     Code      |    Followers  |    MgmtD Len  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       Management Domain Name  (zero-padded to 32 bytes)       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                    Configuration revision number              |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                  Updater Identity IP address                  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                    Update Timestamp (12 bytes)                |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                        MD5 digest (16 bytes)                  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\tND_TCHECK2(*tptr, 8);\n\tND_PRINT((ndo, \"\\n\\t  Config Rev %x, Updater %s\",\n\t       EXTRACT_32BITS(tptr),\n\t       ipaddr_string(ndo, tptr+4)));\n\ttptr += 8;\n\tND_TCHECK2(*tptr, VTP_UPDATE_TIMESTAMP_LEN);\n\tND_PRINT((ndo, \", Timestamp 0x%08x 0x%08x 0x%08x\",\n\t       EXTRACT_32BITS(tptr),\n\t       EXTRACT_32BITS(tptr + 4),\n\t       EXTRACT_32BITS(tptr + 8)));\n\ttptr += VTP_UPDATE_TIMESTAMP_LEN;\n\tND_TCHECK2(*tptr, VTP_MD5_DIGEST_LEN);\n\tND_PRINT((ndo, \", MD5 digest: %08x%08x%08x%08x\",\n\t       EXTRACT_32BITS(tptr),\n\t       EXTRACT_32BITS(tptr + 4),\n\t       EXTRACT_32BITS(tptr + 8),\n\t       EXTRACT_32BITS(tptr + 12)));\n\ttptr += VTP_MD5_DIGEST_LEN;\n\tbreak;\n\n    case VTP_SUBSET_ADV:\n\n\t/*\n\t *  SUBSET ADVERTISEMENT\n\t *\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |     Version   |     Code      |   Seq number  |    MgmtD Len  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       Management Domain Name  (zero-padded to 32 bytes)       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                    Configuration revision number              |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         VLAN info field 1                     |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         ................                      |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         VLAN info field N                     |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\tND_PRINT((ndo, \", Config Rev %x\", EXTRACT_32BITS(tptr)));\n\n\t/*\n\t *  VLAN INFORMATION\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  | V info len    |    Status     |  VLAN type    | VLAN name len |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       ISL vlan id             |            MTU size           |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                     802.10 index (SAID)                       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         VLAN name                             |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\ttptr += 4;\n\twhile (tptr < (pptr+length)) {\n\n\t    len = *tptr;\n\t    if (len == 0)\n\t\tbreak;\n\n\t    ND_TCHECK2(*tptr, len);\n\n\t    vtp_vlan = (const struct vtp_vlan_*)tptr;\n\t    ND_TCHECK(*vtp_vlan);\n\t    ND_PRINT((ndo, \"\\n\\tVLAN info status %s, type %s, VLAN-id %u, MTU %u, SAID 0x%08x, Name \",\n\t\t   tok2str(vtp_vlan_status,\"Unknown\",vtp_vlan->status),\n\t\t   tok2str(vtp_vlan_type_values,\"Unknown\",vtp_vlan->type),\n\t\t   EXTRACT_16BITS(&vtp_vlan->vlanid),\n\t\t   EXTRACT_16BITS(&vtp_vlan->mtu),\n\t\t   EXTRACT_32BITS(&vtp_vlan->index)));\n\t    fn_printzp(ndo, tptr + VTP_VLAN_INFO_OFFSET, vtp_vlan->name_len, NULL);\n\n            /*\n             * Vlan names are aligned to 32-bit boundaries.\n             */\n            len  -= VTP_VLAN_INFO_OFFSET + 4*((vtp_vlan->name_len + 3)/4);\n            tptr += VTP_VLAN_INFO_OFFSET + 4*((vtp_vlan->name_len + 3)/4);\n\n            /* TLV information follows */\n\n            while (len > 0) {\n\n                /*\n                 * Cisco specs says 2 bytes for type + 2 bytes for length, take only 1\n                 * See: http://www.cisco.com/univercd/cc/td/doc/product/lan/trsrb/frames.htm\n                 */\n                type = *tptr;\n                tlv_len = *(tptr+1);\n\n                ND_PRINT((ndo, \"\\n\\t\\t%s (0x%04x) TLV\",\n                       tok2str(vtp_vlan_tlv_values, \"Unknown\", type),\n                       type));\n\n                /*\n                 * infinite loop check\n                 */\n                if (type == 0 || tlv_len == 0) {\n                    return;\n                }\n\n                ND_TCHECK2(*tptr, tlv_len * 2 +2);\n\n                tlv_value = EXTRACT_16BITS(tptr+2);\n\n                switch (type) {\n                case VTP_VLAN_STE_HOP_COUNT:\n                    ND_PRINT((ndo, \", %u\", tlv_value));\n                    break;\n\n                case VTP_VLAN_PRUNING:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tlv_value == 1 ? \"Enabled\" : \"Disabled\",\n                           tlv_value));\n                    break;\n\n                case VTP_VLAN_STP_TYPE:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tok2str(vtp_stp_type_values, \"Unknown\", tlv_value),\n                           tlv_value));\n                    break;\n\n                case VTP_VLAN_BRIDGE_TYPE:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tlv_value == 1 ? \"SRB\" : \"SRT\",\n                           tlv_value));\n                    break;\n\n                case VTP_VLAN_BACKUP_CRF_MODE:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tlv_value == 1 ? \"Backup\" : \"Not backup\",\n                           tlv_value));\n                    break;\n\n                    /*\n                     * FIXME those are the defined TLVs that lack a decoder\n                     * you are welcome to contribute code ;-)\n                     */\n\n                case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER:\n                case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER:\n                case VTP_VLAN_PARENT_VLAN:\n                case VTP_VLAN_TRANS_BRIDGED_VLAN:\n                case VTP_VLAN_ARP_HOP_COUNT:\n                default:\n\t\t    print_unknown_data(ndo, tptr, \"\\n\\t\\t  \", 2 + tlv_len*2);\n                    break;\n                }\n                len -= 2 + tlv_len*2;\n                tptr += 2 + tlv_len*2;\n            }\n\t}\n\tbreak;\n\n    case VTP_ADV_REQUEST:\n\n\t/*\n\t *  ADVERTISEMENT REQUEST\n\t *\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |     Version   |     Code      |   Reserved    |    MgmtD Len  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       Management Domain Name  (zero-padded to 32 bytes)       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                          Start value                          |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\tND_TCHECK2(*tptr, 4);\n\tND_PRINT((ndo, \"\\n\\tStart value: %u\", EXTRACT_32BITS(tptr)));\n\tbreak;\n\n    case VTP_JOIN_MESSAGE:\n\n\t/* FIXME - Could not find message format */\n\tbreak;\n\n    default:\n\tbreak;\n    }\n\n    return;\n\n trunc:\n    ND_PRINT((ndo, \"[|vtp]\"));\n}\n",
        "fix": null,
        "src_path": "c5dd7bef5e54da5996dc4713284aa6266ae75b75___print-vtp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/c5dd7bef5e54da5996dc4713284aa6266ae75b75",
        "commit_msg": "CVE-2017-13020/VTP: Add some missing bounds checks.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -521,6 +521,7 @@ esis_snpa_asan-5\tesis_snpa_asan-5.pcap\t\tesis_snpa_asan-5.out\t-v\n dhcp6_reconf_asan\tdhcp6_reconf_asan.pcap\t\tdhcp6_reconf_asan.out\t-v\n pgm_opts_asan\t\tpgm_opts_asan.pcap\t\tpgm_opts_asan.out\t-v\n pgm_opts_asan_2\t\tpgm_opts_asan_2.pcap\t\tpgm_opts_asan_2.out\t-v\n+vtp_asan\t\tvtp_asan.pcap\t\t\tvtp_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/vtp_asan.out",
                "patch": "@@ -0,0 +1,6 @@\n+FRF.16 Frag, seq 193, Flags [Begin, End], UI 08! VTPv69, Message Subset advertisement (0x02), length 2126400013\n+\tDomain name: , Seq number: 0[|vtp]\n+[|mfr]\n+[|mfr]\n+[|mfr]\n+[|mfr]"
            }
        ],
        "error_msg": "    vtp_asan                           : TEST FAILED(exit 256)\n"
    },
    "1bc78d795cd5cad5525498658f414a11ea0a7e9c___print-radius.c": {
        "start": 494,
        "end": 557,
        "buggy": "static void\nprint_attr_string(netdissect_options *ndo,\n                  register const u_char *data, u_int length, u_short attr_code)\n{\n   register u_int i;\n\n   ND_TCHECK2(data[0],length);\n\n   switch(attr_code)\n   {\n      case TUNNEL_PASS:\n           if (length < 3)\n           {\n              ND_PRINT((ndo, \"%s\", tstr));\n              return;\n           }\n           if (*data && (*data <=0x1F) )\n              ND_PRINT((ndo, \"Tag[%u] \", *data));\n           else\n              ND_PRINT((ndo, \"Tag[Unused] \"));\n           data++;\n           length--;\n           ND_PRINT((ndo, \"Salt %u \", EXTRACT_16BITS(data)));\n           data+=2;\n           length-=2;\n        break;\n      case TUNNEL_CLIENT_END:\n      case TUNNEL_SERVER_END:\n      case TUNNEL_PRIV_GROUP:\n      case TUNNEL_ASSIGN_ID:\n      case TUNNEL_CLIENT_AUTH:\n      case TUNNEL_SERVER_AUTH:\n           if (*data <= 0x1F)\n           {\n              if (length < 1)\n              {\n                 ND_PRINT((ndo, \"%s\", tstr));\n                 return;\n              }\n              if (*data)\n                ND_PRINT((ndo, \"Tag[%u] \", *data));\n              else\n                ND_PRINT((ndo, \"Tag[Unused] \"));\n              data++;\n              length--;\n           }\n        break;\n      case EGRESS_VLAN_NAME:\n           ND_PRINT((ndo, \"%s (0x%02x) \",\n                  tok2str(rfc4675_tagged,\"Unknown tag\",*data),\n                  *data));\n           data++;\n           length--;\n        break;\n   }\n\n   for (i=0; *data && i < length ; i++, data++)\n       ND_PRINT((ndo, \"%c\", (*data < 32 || *data > 126) ? '.' : *data));\n\n   return;\n\n   trunc:\n      ND_PRINT((ndo, \"%s\", tstr));\n}\n",
        "fix": null,
        "src_path": "1bc78d795cd5cad5525498658f414a11ea0a7e9c___print-radius.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/1bc78d795cd5cad5525498658f414a11ea0a7e9c",
        "commit_msg": "CVE-2017-13032/RADIUS: Check whether a byte exists before testing its value.\n\nReverse the test in a for loop to test the length before testing whether\nwe have a null byte.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.\n\nClean up other length tests while we're at it.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -541,6 +541,7 @@ pim_header_asan\t\tpim_header_asan.pcap\t\tpim_header_asan.out\t-v\n pim_header_asan-2\tpim_header_asan-2.pcap\t\tpim_header_asan-2.out\t-v\n pim_header_asan-3\tpim_header_asan-3.pcap\t\tpim_header_asan-3.out\t-v\n ip6_frag_asan\t\tip6_frag_asan.pcap\t\tip6_frag_asan.out\t-v\n+radius_attr_asan\tradius_attr_asan.pcap\t\tradius_attr_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/radius_attr_asan.out",
                "patch": "@@ -0,0 +1,9 @@\n+IP (tos 0x64, ttl 249, id 40192, offset 0, flags [+, DF, rsvd], proto UDP (17), length 299, options (unknown 235 [bad length 252]), bad cksum 8000 (->1faa)!)\n+    0.0.86.32.258 > 0.2.250.99.3799: RADIUS, length: 263\n+\tUnknown Command (58), id: 0x6a, Authenticator: 0901020ed7ff03edb63a0f00cb0f00cb\n+\t  NAS-Port Attribute (5), length: 5, Value: ERROR: length 3 != 4\n+\t  Unknown Attribute (127), length: 4, Value: \n+\t  NAS-IP-Address Attribute (4), length: 4, Value: ERROR: length 2 != 4\n+\t  NAS-IP-Address Attribute (4), length: 4, Value: ERROR: length 2 != 4\n+\t  NAS-IP-Address Attribute (4), length: 4, Value: ERROR: length 2 != 4\n+\t  Callback-Id Attribute (20), length: 4, Value: .. [|radius]"
            }
        ],
        "error_msg": "    radius_attr_asan                   : passed\n"
    },
    "da6f1a677bfa4476abaeaf9b1afe1c4390f51b41___print-pgm.c": {
        "start": 145,
        "end": 838,
        "buggy": "void\npgm_print(netdissect_options *ndo,\n          register const u_char *bp, register u_int length,\n          register const u_char *bp2)\n{\n\tregister const struct pgm_header *pgm;\n\tregister const struct ip *ip;\n\tregister char ch;\n\tuint16_t sport, dport;\n\tu_int nla_afnum;\n\tchar nla_buf[INET6_ADDRSTRLEN];\n\tregister const struct ip6_hdr *ip6;\n\tuint8_t opt_type, opt_len;\n\tuint32_t seq, opts_len, len, offset;\n\n\tpgm = (const struct pgm_header *)bp;\n\tip = (const struct ip *)bp2;\n\tif (IP_V(ip) == 6)\n\t\tip6 = (const struct ip6_hdr *)bp2;\n\telse\n\t\tip6 = NULL;\n\tch = '\\0';\n\tif (!ND_TTEST(pgm->pgm_dport)) {\n\t\tif (ip6) {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst)));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst)));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsport = EXTRACT_16BITS(&pgm->pgm_sport);\n\tdport = EXTRACT_16BITS(&pgm->pgm_dport);\n\n\tif (ip6) {\n\t\tif (ip6->ip6_nxt == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t} else {\n\t\tif (ip->ip_p == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t}\n\n\tND_TCHECK(*pgm);\n\n        ND_PRINT((ndo, \"PGM, length %u\", EXTRACT_16BITS(&pgm->pgm_length)));\n\n        if (!ndo->ndo_vflag)\n            return;\n\n\tND_PRINT((ndo, \" 0x%02x%02x%02x%02x%02x%02x \",\n\t\t     pgm->pgm_gsid[0],\n                     pgm->pgm_gsid[1],\n                     pgm->pgm_gsid[2],\n\t\t     pgm->pgm_gsid[3],\n                     pgm->pgm_gsid[4],\n                     pgm->pgm_gsid[5]));\n\tswitch (pgm->pgm_type) {\n\tcase PGM_SPM: {\n\t    const struct pgm_spm *spm;\n\n\t    spm = (const struct pgm_spm *)(pgm + 1);\n\t    ND_TCHECK(*spm);\n\t    bp = (const u_char *) (spm + 1);\n\n\t    switch (EXTRACT_16BITS(&spm->pgms_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_PRINT((ndo, \"SPM seq %u trail %u lead %u nla %s\",\n\t\t\t EXTRACT_32BITS(&spm->pgms_seq),\n                         EXTRACT_32BITS(&spm->pgms_trailseq),\n\t\t\t EXTRACT_32BITS(&spm->pgms_leadseq),\n                         nla_buf));\n\t    break;\n\t}\n\n\tcase PGM_POLL: {\n\t    const struct pgm_poll *poll_msg;\n\n\t    poll_msg = (const struct pgm_poll *)(pgm + 1);\n\t    ND_TCHECK(*poll_msg);\n\t    ND_PRINT((ndo, \"POLL seq %u round %u\",\n\t\t\t EXTRACT_32BITS(&poll_msg->pgmp_seq),\n                         EXTRACT_16BITS(&poll_msg->pgmp_round)));\n\t    bp = (const u_char *) (poll_msg + 1);\n\t    break;\n\t}\n\tcase PGM_POLR: {\n\t    const struct pgm_polr *polr;\n\t    uint32_t ivl, rnd, mask;\n\n\t    polr = (const struct pgm_polr *)(pgm + 1);\n\t    ND_TCHECK(*polr);\n\t    bp = (const u_char *) (polr + 1);\n\n\t    switch (EXTRACT_16BITS(&polr->pgmp_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    ivl = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    rnd = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    mask = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_PRINT((ndo, \"POLR seq %u round %u nla %s ivl %u rnd 0x%08x \"\n\t\t\t \"mask 0x%08x\", EXTRACT_32BITS(&polr->pgmp_seq),\n\t\t\t EXTRACT_16BITS(&polr->pgmp_round), nla_buf, ivl, rnd, mask));\n\t    break;\n\t}\n\tcase PGM_ODATA: {\n\t    const struct pgm_data *odata;\n\n\t    odata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*odata);\n\t    ND_PRINT((ndo, \"ODATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&odata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&odata->pgmd_seq)));\n\t    bp = (const u_char *) (odata + 1);\n\t    break;\n\t}\n\n\tcase PGM_RDATA: {\n\t    const struct pgm_data *rdata;\n\n\t    rdata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*rdata);\n\t    ND_PRINT((ndo, \"RDATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_seq)));\n\t    bp = (const u_char *) (rdata + 1);\n\t    break;\n\t}\n\n\tcase PGM_NAK:\n\tcase PGM_NULLNAK:\n\tcase PGM_NCF: {\n\t    const struct pgm_nak *nak;\n\t    char source_buf[INET6_ADDRSTRLEN], group_buf[INET6_ADDRSTRLEN];\n\n\t    nak = (const struct pgm_nak *)(pgm + 1);\n\t    ND_TCHECK(*nak);\n\t    bp = (const u_char *) (nak + 1);\n\n\t    /*\n\t     * Skip past the source, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    switch (EXTRACT_16BITS(&nak->pgmn_source_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Skip past the group, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    bp += (2 * sizeof(uint16_t));\n\t    switch (EXTRACT_16BITS(bp)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Options decoding can go here.\n\t     */\n\t    switch (pgm->pgm_type) {\n\t\tcase PGM_NAK:\n\t\t    ND_PRINT((ndo, \"NAK \"));\n\t\t    break;\n\t\tcase PGM_NULLNAK:\n\t\t    ND_PRINT((ndo, \"NNAK \"));\n\t\t    break;\n\t\tcase PGM_NCF:\n\t\t    ND_PRINT((ndo, \"NCF \"));\n\t\t    break;\n\t\tdefault:\n                    break;\n\t    }\n\t    ND_PRINT((ndo, \"(%s -> %s), seq %u\",\n\t\t\t source_buf, group_buf, EXTRACT_32BITS(&nak->pgmn_seq)));\n\t    break;\n\t}\n\n\tcase PGM_ACK: {\n\t    const struct pgm_ack *ack;\n\n\t    ack = (const struct pgm_ack *)(pgm + 1);\n\t    ND_TCHECK(*ack);\n\t    ND_PRINT((ndo, \"ACK seq %u\",\n\t\t\t EXTRACT_32BITS(&ack->pgma_rx_max_seq)));\n\t    bp = (const u_char *) (ack + 1);\n\t    break;\n\t}\n\n\tcase PGM_SPMR:\n\t    ND_PRINT((ndo, \"SPMR\"));\n\t    break;\n\n\tdefault:\n\t    ND_PRINT((ndo, \"UNKNOWN type 0x%02x\", pgm->pgm_type));\n\t    break;\n\n\t}\n\tif (pgm->pgm_options & PGM_OPT_BIT_PRESENT) {\n\n\t    /*\n\t     * make sure there's enough for the first option header\n\t     */\n\t    if (!ND_TTEST2(*bp, PGM_MIN_OPT_LEN)) {\n\t\tND_PRINT((ndo, \"[|OPT]\"));\n\t\treturn;\n\t    }\n\n\t    /*\n\t     * That option header MUST be an OPT_LENGTH option\n\t     * (see the first paragraph of section 9.1 in RFC 3208).\n\t     */\n\t    opt_type = *bp++;\n\t    if ((opt_type & PGM_OPT_MASK) != PGM_OPT_LENGTH) {\n\t\tND_PRINT((ndo, \"[First option bad, should be PGM_OPT_LENGTH, is %u]\", opt_type & PGM_OPT_MASK));\n\t\treturn;\n\t    }\n\t    opt_len = *bp++;\n\t    if (opt_len != 4) {\n\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != 4]\", opt_len));\n\t\treturn;\n\t    }\n\t    opts_len = EXTRACT_16BITS(bp);\n\t    if (opts_len < 4) {\n\t\tND_PRINT((ndo, \"[Bad total option length %u < 4]\", opts_len));\n\t\treturn;\n\t    }\n\t    bp += sizeof(uint16_t);\n\t    ND_PRINT((ndo, \" OPTS LEN %d\", opts_len));\n\t    opts_len -= 4;\n\n\t    while (opts_len) {\n\t\tif (opts_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n\t\tif (!ND_TTEST2(*bp, 2)) {\n\t\t    ND_PRINT((ndo, \" [|OPT]\"));\n\t\t    return;\n\t\t}\n\t\topt_type = *bp++;\n\t\topt_len = *bp++;\n\t\tif (opt_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Bad option, length %u < %u]\", opt_len,\n\t\t        PGM_MIN_OPT_LEN));\n\t\t    break;\n\t\t}\n\t\tif (opts_len < opt_len) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n\t\tif (!ND_TTEST2(*bp, opt_len - 2)) {\n\t\t    ND_PRINT((ndo, \" [|OPT]\"));\n\t\t    return;\n\t\t}\n\n\t\tswitch (opt_type & PGM_OPT_MASK) {\n\t\tcase PGM_OPT_LENGTH:\n#define PGM_OPT_LENGTH_LEN\t(2+2)\n\t\t    if (opt_len != PGM_OPT_LENGTH_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_LENGTH_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    ND_PRINT((ndo, \" OPTS LEN (extra?) %d\", EXTRACT_16BITS(bp)));\n\t\t    bp += 2;\n\t\t    opts_len -= PGM_OPT_LENGTH_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_FRAGMENT:\n#define PGM_OPT_FRAGMENT_LEN\t(2+2+4+4+4)\n\t\t    if (opt_len != PGM_OPT_FRAGMENT_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FRAGMENT option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_FRAGMENT_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    ND_PRINT((ndo, \" FRAG seq %u off %u len %u\", seq, offset, len));\n\t\t    opts_len -= PGM_OPT_FRAGMENT_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_LIST:\n\t\t    bp += 2;\n\t\t    opt_len -= 4;\t/* option header */\n\t\t    ND_PRINT((ndo, \" NAK LIST\"));\n\t\t    while (opt_len) {\n\t\t\tif (opt_len < 4) {\n\t\t\t    ND_PRINT((ndo, \"[Option length not a multiple of 4]\"));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, 4);\n\t\t\tND_PRINT((ndo, \" %u\", EXTRACT_32BITS(bp)));\n\t\t\tbp += 4;\n\t\t\topt_len -= 4;\n\t\t\topts_len -= 4;\n\t\t    }\n\t\t    break;\n\n\t\tcase PGM_OPT_JOIN:\n#define PGM_OPT_JOIN_LEN\t(2+2+4)\n\t\t    if (opt_len != PGM_OPT_JOIN_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_JOIN option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_JOIN_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    ND_PRINT((ndo, \" JOIN %u\", seq));\n\t\t    opts_len -= PGM_OPT_JOIN_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_BO_IVL:\n#define PGM_OPT_NAK_BO_IVL_LEN\t(2+2+4+4)\n\t\t    if (opt_len != PGM_OPT_NAK_BO_IVL_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_IVL option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_NAK_BO_IVL_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    ND_PRINT((ndo, \" BACKOFF ivl %u ivlseq %u\", offset, seq));\n\t\t    opts_len -= PGM_OPT_NAK_BO_IVL_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_BO_RNG:\n#define PGM_OPT_NAK_BO_RNG_LEN\t(2+2+4+4)\n\t\t    if (opt_len != PGM_OPT_NAK_BO_RNG_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_RNG option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_NAK_BO_RNG_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    ND_PRINT((ndo, \" BACKOFF max %u min %u\", offset, seq));\n\t\t    opts_len -= PGM_OPT_NAK_BO_RNG_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_REDIRECT:\n#define PGM_OPT_REDIRECT_FIXED_LEN\t(2+2+2+2)\n\t\t    if (opt_len < PGM_OPT_REDIRECT_FIXED_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u < %u]\",\n\t\t\t    opt_len, PGM_OPT_REDIRECT_FIXED_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += 2+2;\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != %u + address size]\",\n\t\t\t        opt_len, PGM_OPT_REDIRECT_FIXED_LEN));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != %u + address size]\",\n\t\t\t        PGM_OPT_REDIRECT_FIXED_LEN, opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" REDIRECT %s\",  nla_buf));\n\t\t    break;\n\n\t\tcase PGM_OPT_PARITY_PRM:\n#define PGM_OPT_PARITY_PRM_LEN\t(2+2+4)\n\t\t    if (opt_len != PGM_OPT_PARITY_PRM_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_PRM option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_PARITY_PRM_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    ND_PRINT((ndo, \" PARITY MAXTGS %u\", len));\n\t\t    opts_len -= PGM_OPT_PARITY_PRM_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_PARITY_GRP:\n#define PGM_OPT_PARITY_GRP_LEN\t(2+2+4)\n\t\t    if (opt_len != PGM_OPT_PARITY_GRP_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_GRP option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_PARITY_GRP_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    ND_PRINT((ndo, \" PARITY GROUP %u\", seq));\n\t\t    opts_len -= PGM_OPT_PARITY_GRP_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_CURR_TGSIZE:\n#define PGM_OPT_CURR_TGSIZE_LEN\t(2+2+4)\n\t\t    if (opt_len != PGM_OPT_CURR_TGSIZE_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CURR_TGSIZE option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_CURR_TGSIZE_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    ND_PRINT((ndo, \" PARITY ATGS %u\", len));\n\t\t    opts_len -= PGM_OPT_CURR_TGSIZE_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_NBR_UNREACH:\n#define PGM_OPT_NBR_UNREACH_LEN\t(2+2)\n\t\t    if (opt_len != PGM_OPT_NBR_UNREACH_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NBR_UNREACH option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_NBR_UNREACH_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" NBR_UNREACH\"));\n\t\t    opts_len -= PGM_OPT_NBR_UNREACH_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_PATH_NLA:\n\t\t    ND_PRINT((ndo, \" PATH_NLA [%d]\", opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\n\t\tcase PGM_OPT_SYN:\n#define PGM_OPT_SYN_LEN\t(2+2)\n\t\t    if (opt_len != PGM_OPT_SYN_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_SYN option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_SYN_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" SYN\"));\n\t\t    opts_len -= PGM_OPT_SYN_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_FIN:\n#define PGM_OPT_FIN_LEN\t(2+2)\n\t\t    if (opt_len != PGM_OPT_FIN_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FIN option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_FIN_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" FIN\"));\n\t\t    opts_len -= PGM_OPT_FIN_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_RST:\n#define PGM_OPT_RST_LEN\t(2+2)\n\t\t    if (opt_len != PGM_OPT_RST_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_RST option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_RST_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" RST\"));\n\t\t    opts_len -= PGM_OPT_RST_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_CR:\n\t\t    ND_PRINT((ndo, \" CR\"));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\n\t\tcase PGM_OPT_CRQST:\n#define PGM_OPT_CRQST_LEN\t(2+2)\n\t\t    if (opt_len != PGM_OPT_CRQST_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CRQST option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_CRQST_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" CRQST\"));\n\t\t    opts_len -= PGM_OPT_CRQST_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_PGMCC_DATA:\n#define PGM_OPT_PGMCC_DATA_FIXED_LEN\t(2+2+4+2+2)\n\t\t    if (opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u < %u]\",\n\t\t\t    opt_len, PGM_OPT_PGMCC_DATA_FIXED_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += 2+2;\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != %u + address size]\",\n\t\t\t        opt_len, PGM_OPT_PGMCC_DATA_FIXED_LEN));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != %u + address size]\",\n\t\t\t        opt_len, PGM_OPT_PGMCC_DATA_FIXED_LEN));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC DATA %u %s\", offset, nla_buf));\n\t\t    break;\n\n\t\tcase PGM_OPT_PGMCC_FEEDBACK:\n#define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN\t(2+2+4+2+2)\n\t\t    if (opt_len < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad PGM_OPT_PGMCC_FEEDBACK option, length %u < %u]\",\n\t\t\t    opt_len, PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += 2+2;\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_FEEDBACK option, length %u != %u + address size]\",\n\t\t\t        opt_len, PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_FEEDBACK option, length %u != %u + address size]\",\n\t\t\t        opt_len, PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC FEEDBACK %u %s\", offset, nla_buf));\n\t\t    break;\n\n\t\tdefault:\n\t\t    ND_PRINT((ndo, \" OPT_%02X [%d] \", opt_type, opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\t\t}\n\n\t\tif (opt_type & PGM_OPT_END)\n\t\t    break;\n\t     }\n\t}\n\n\tND_PRINT((ndo, \" [%u]\", length));\n\tif (ndo->ndo_packettype == PT_PGM_ZMTP1 &&\n\t    (pgm->pgm_type == PGM_ODATA || pgm->pgm_type == PGM_RDATA))\n\t\tzmtp1_print_datagram(ndo, bp, EXTRACT_16BITS(&pgm->pgm_length));\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pgm]\"));\n\tif (ch != '\\0')\n\t\tND_PRINT((ndo, \">\"));\n}\n",
        "fix": null,
        "src_path": "da6f1a677bfa4476abaeaf9b1afe1c4390f51b41___print-pgm.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/da6f1a677bfa4476abaeaf9b1afe1c4390f51b41",
        "commit_msg": "CVE-2017-13034/PGM: Add a bounds check.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.\n\nMove a return to make the code a bit cleaner (i.e., make it more obvious\nthat if we don't have enough of the PGM header, we just print the source\nand destination IP addresses, mark it as incomplete PGM, and don't try\nto look at the PGM header).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -522,6 +522,7 @@ dhcp6_reconf_asan\tdhcp6_reconf_asan.pcap\t\tdhcp6_reconf_asan.out\t-v\n pgm_opts_asan\t\tpgm_opts_asan.pcap\t\tpgm_opts_asan.out\t-v\n pgm_opts_asan_2\t\tpgm_opts_asan_2.pcap\t\tpgm_opts_asan_2.out\t-v\n pgm_opts_asan_3\t\tpgm_opts_asan_3.pcap\t\tpgm_opts_asan_3.out\t-v\n+pgm_group_addr_asan\tpgm_group_addr_asan.pcap\tpgm_group_addr_asan.out\t-v\n vtp_asan\t\tvtp_asan.pcap\t\t\tvtp_asan.out\t-v\n vtp_asan-2\t\tvtp_asan-2.pcap\t\t\tvtp_asan-2.out\t-v\n vtp_asan-3\t\tvtp_asan-3.pcap\t\t\tvtp_asan-3.out\t-v"
            },
            {
                "fn": "tests/pgm_group_addr_asan.out",
                "patch": "@@ -0,0 +1,2 @@\n+IP (tos 0x41,ECT(1), id 40256, offset 0, flags [none], proto PGM (113), length 768, options (unknown 89 [bad length 232]), bad cksum 5959 (->5afd)!)\n+    89.121.89.107 > 89.89.89.89: 89.121.89.107.32322 > 89.89.89.89.500: PGM, length 24818 0x00ff7f010347 [|pgm]"
            }
        ],
        "error_msg": "    pgm_group_addr_asan                : passed\n"
    },
    "f4b9e24c7384d882a7f434cc7413925bf871d63e___print-icmp6.c": {
        "start": 1566,
        "end": 1812,
        "buggy": "static void\nicmp6_nodeinfo_print(netdissect_options *ndo, u_int icmp6len, const u_char *bp, const u_char *ep)\n{\n\tconst struct icmp6_nodeinfo *ni6;\n\tconst struct icmp6_hdr *dp;\n\tconst u_char *cp;\n\tsize_t siz, i;\n\tint needcomma;\n\n\tif (ep < bp)\n\t\treturn;\n\tdp = (const struct icmp6_hdr *)bp;\n\tni6 = (const struct icmp6_nodeinfo *)bp;\n\tsiz = ep - bp;\n\n\tswitch (ni6->ni_type) {\n\tcase ICMP6_NI_QUERY:\n\t\tif (siz == sizeof(*dp) + 4) {\n\t\t\t/* KAME who-are-you */\n\t\t\tND_PRINT((ndo,\" who-are-you request\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo,\" node information query\"));\n\n\t\tND_TCHECK2(*dp, sizeof(*ni6));\n\t\tni6 = (const struct icmp6_nodeinfo *)dp;\n\t\tND_PRINT((ndo,\" (\"));\t/*)*/\n\t\tswitch (EXTRACT_16BITS(&ni6->ni_qtype)) {\n\t\tcase NI_QTYPE_NOOP:\n\t\t\tND_PRINT((ndo,\"noop\"));\n\t\t\tbreak;\n\t\tcase NI_QTYPE_SUPTYPES:\n\t\t\tND_PRINT((ndo,\"supported qtypes\"));\n\t\t\ti = EXTRACT_16BITS(&ni6->ni_flags);\n\t\t\tif (i)\n\t\t\t\tND_PRINT((ndo,\" [%s]\", (i & 0x01) ? \"C\" : \"\"));\n\t\t\tbreak;\n\t\tcase NI_QTYPE_FQDN:\n\t\t\tND_PRINT((ndo,\"DNS name\"));\n\t\t\tbreak;\n\t\tcase NI_QTYPE_NODEADDR:\n\t\t\tND_PRINT((ndo,\"node addresses\"));\n\t\t\ti = ni6->ni_flags;\n\t\t\tif (!i)\n\t\t\t\tbreak;\n\t\t\t/* NI_NODEADDR_FLAG_TRUNCATE undefined for query */\n\t\t\tND_PRINT((ndo,\" [%s%s%s%s%s%s]\",\n\t\t\t    (i & NI_NODEADDR_FLAG_ANYCAST) ? \"a\" : \"\",\n\t\t\t    (i & NI_NODEADDR_FLAG_GLOBAL) ? \"G\" : \"\",\n\t\t\t    (i & NI_NODEADDR_FLAG_SITELOCAL) ? \"S\" : \"\",\n\t\t\t    (i & NI_NODEADDR_FLAG_LINKLOCAL) ? \"L\" : \"\",\n\t\t\t    (i & NI_NODEADDR_FLAG_COMPAT) ? \"C\" : \"\",\n\t\t\t    (i & NI_NODEADDR_FLAG_ALL) ? \"A\" : \"\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tND_PRINT((ndo,\"unknown\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ni6->ni_qtype == NI_QTYPE_NOOP ||\n\t\t    ni6->ni_qtype == NI_QTYPE_SUPTYPES) {\n\t\t\tif (siz != sizeof(*ni6))\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", invalid len\"));\n\t\t\t/*(*/\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\t}\n\n\n\t\t/* XXX backward compat, icmp-name-lookup-03 */\n\t\tif (siz == sizeof(*ni6)) {\n\t\t\tND_PRINT((ndo,\", 03 draft\"));\n\t\t\t/*(*/\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ni6->ni_code) {\n\t\tcase ICMP6_NI_SUBJ_IPV6:\n\t\t\tif (!ND_TTEST2(*dp,\n\t\t\t    sizeof(*ni6) + sizeof(struct in6_addr)))\n\t\t\t\tbreak;\n\t\t\tif (siz != sizeof(*ni6) + sizeof(struct in6_addr)) {\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", invalid subject len\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_PRINT((ndo,\", subject=%s\",\n                                  ip6addr_string(ndo, ni6 + 1)));\n\t\t\tbreak;\n\t\tcase ICMP6_NI_SUBJ_FQDN:\n\t\t\tND_PRINT((ndo,\", subject=DNS name\"));\n\t\t\tcp = (const u_char *)(ni6 + 1);\n\t\t\tif (cp[0] == ep - cp - 1) {\n\t\t\t\t/* icmp-name-lookup-03, pascal string */\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", 03 draft\"));\n\t\t\t\tcp++;\n\t\t\t\tND_PRINT((ndo,\", \\\"\"));\n\t\t\t\twhile (cp < ep) {\n\t\t\t\t\tsafeputchar(ndo, *cp);\n\t\t\t\t\tcp++;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo,\"\\\"\"));\n\t\t\t} else\n\t\t\t\tdnsname_print(ndo, cp, ep);\n\t\t\tbreak;\n\t\tcase ICMP6_NI_SUBJ_IPV4:\n\t\t\tif (!ND_TTEST2(*dp, sizeof(*ni6) + sizeof(struct in_addr)))\n\t\t\t\tbreak;\n\t\t\tif (siz != sizeof(*ni6) + sizeof(struct in_addr)) {\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", invalid subject len\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_PRINT((ndo,\", subject=%s\",\n                                  ipaddr_string(ndo, ni6 + 1)));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tND_PRINT((ndo,\", unknown subject\"));\n\t\t\tbreak;\n\t\t}\n\n\t\t/*(*/\n\t\tND_PRINT((ndo,\")\"));\n\t\tbreak;\n\n\tcase ICMP6_NI_REPLY:\n\t\tif (icmp6len > siz) {\n\t\t\tND_PRINT((ndo,\"[|icmp6: node information reply]\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tneedcomma = 0;\n\n\t\tni6 = (const struct icmp6_nodeinfo *)dp;\n\t\tND_PRINT((ndo,\" node information reply\"));\n\t\tND_PRINT((ndo,\" (\"));\t/*)*/\n\t\tswitch (ni6->ni_code) {\n\t\tcase ICMP6_NI_SUCCESS:\n\t\t\tif (ndo->ndo_vflag) {\n\t\t\t\tND_PRINT((ndo,\"success\"));\n\t\t\t\tneedcomma++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ICMP6_NI_REFUSED:\n\t\t\tND_PRINT((ndo,\"refused\"));\n\t\t\tneedcomma++;\n\t\t\tif (siz != sizeof(*ni6))\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", invalid length\"));\n\t\t\tbreak;\n\t\tcase ICMP6_NI_UNKNOWN:\n\t\t\tND_PRINT((ndo,\"unknown\"));\n\t\t\tneedcomma++;\n\t\t\tif (siz != sizeof(*ni6))\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", invalid length\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ni6->ni_code != ICMP6_NI_SUCCESS) {\n\t\t\t/*(*/\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (EXTRACT_16BITS(&ni6->ni_qtype)) {\n\t\tcase NI_QTYPE_NOOP:\n\t\t\tif (needcomma)\n\t\t\t\tND_PRINT((ndo,\", \"));\n\t\t\tND_PRINT((ndo,\"noop\"));\n\t\t\tif (siz != sizeof(*ni6))\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", invalid length\"));\n\t\t\tbreak;\n\t\tcase NI_QTYPE_SUPTYPES:\n\t\t\tif (needcomma)\n\t\t\t\tND_PRINT((ndo,\", \"));\n\t\t\tND_PRINT((ndo,\"supported qtypes\"));\n\t\t\ti = EXTRACT_16BITS(&ni6->ni_flags);\n\t\t\tif (i)\n\t\t\t\tND_PRINT((ndo,\" [%s]\", (i & 0x01) ? \"C\" : \"\"));\n\t\t\tbreak;\n\t\tcase NI_QTYPE_FQDN:\n\t\t\tif (needcomma)\n\t\t\t\tND_PRINT((ndo,\", \"));\n\t\t\tND_PRINT((ndo,\"DNS name\"));\n\t\t\tcp = (const u_char *)(ni6 + 1) + 4;\n\t\t\tif (cp[0] == ep - cp - 1) {\n\t\t\t\t/* icmp-name-lookup-03, pascal string */\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", 03 draft\"));\n\t\t\t\tcp++;\n\t\t\t\tND_PRINT((ndo,\", \\\"\"));\n\t\t\t\twhile (cp < ep) {\n\t\t\t\t\tsafeputchar(ndo, *cp);\n\t\t\t\t\tcp++;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo,\"\\\"\"));\n\t\t\t} else\n\t\t\t\tdnsname_print(ndo, cp, ep);\n\t\t\tif ((EXTRACT_16BITS(&ni6->ni_flags) & 0x01) != 0)\n\t\t\t\tND_PRINT((ndo,\" [TTL=%u]\", EXTRACT_32BITS(ni6 + 1)));\n\t\t\tbreak;\n\t\tcase NI_QTYPE_NODEADDR:\n\t\t\tif (needcomma)\n\t\t\t\tND_PRINT((ndo,\", \"));\n\t\t\tND_PRINT((ndo,\"node addresses\"));\n\t\t\ti = sizeof(*ni6);\n\t\t\twhile (i < siz) {\n\t\t\t\tif (i + sizeof(struct in6_addr) + sizeof(int32_t) > siz)\n\t\t\t\t\tbreak;\n\t\t\t\tND_PRINT((ndo,\" %s\", ip6addr_string(ndo, bp + i)));\n\t\t\t\ti += sizeof(struct in6_addr);\n\t\t\t\tND_PRINT((ndo,\"(%d)\", (int32_t)EXTRACT_32BITS(bp + i)));\n\t\t\t\ti += sizeof(int32_t);\n\t\t\t}\n\t\t\ti = ni6->ni_flags;\n\t\t\tif (!i)\n\t\t\t\tbreak;\n\t\t\tND_PRINT((ndo,\" [%s%s%s%s%s%s%s]\",\n                                  (i & NI_NODEADDR_FLAG_ANYCAST) ? \"a\" : \"\",\n                                  (i & NI_NODEADDR_FLAG_GLOBAL) ? \"G\" : \"\",\n                                  (i & NI_NODEADDR_FLAG_SITELOCAL) ? \"S\" : \"\",\n                                  (i & NI_NODEADDR_FLAG_LINKLOCAL) ? \"L\" : \"\",\n                                  (i & NI_NODEADDR_FLAG_COMPAT) ? \"C\" : \"\",\n                                  (i & NI_NODEADDR_FLAG_ALL) ? \"A\" : \"\",\n                                  (i & NI_NODEADDR_FLAG_TRUNCATE) ? \"T\" : \"\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (needcomma)\n\t\t\t\tND_PRINT((ndo,\", \"));\n\t\t\tND_PRINT((ndo,\"unknown\"));\n\t\t\tbreak;\n\t\t}\n\n\t\t/*(*/\n\t\tND_PRINT((ndo,\")\"));\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|icmp6]\"));\n}\n",
        "fix": null,
        "src_path": "f4b9e24c7384d882a7f434cc7413925bf871d63e___print-icmp6.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/f4b9e24c7384d882a7f434cc7413925bf871d63e",
        "commit_msg": "CVE-2017-13041/ICMP6: Add more bounds checks.\n\nThis fixes a buffer over-read discovered by Kim Gwan Yeong.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -560,6 +560,7 @@ mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out\n \n # bad packets from Kim Gwan Yeong\n mptcp-dss-oobr\t\tmptcp-dss-oobr.pcap\t\tmptcp-dss-oobr.out\t-v\n+icmp6_nodeinfo_oobr\ticmp6_nodeinfo_oobr.pcap\ticmp6_nodeinfo_oobr.out\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/icmp6_nodeinfo_oobr.out",
                "patch": "@@ -0,0 +1 @@\n+IP6 a072:7f00:1:7f00:1:e01a:17:6785 > c903::a002:8018:fe30:0:204: ICMP6, who-are-you reply[|icmp6], length 4"
            }
        ],
        "error_msg": "    icmp6_nodeinfo_oobr                : TEST FAILED(exit 256)\n"
    },
    "39582c04cc5e34054b2936b423072fb9df2ff6ef___print-hncp.c": {
        "start": 311,
        "end": 358,
        "buggy": "static int\ndhcpv6_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint16_t type, optlen;\n\n    i = 0;\n    while (i < length) {\n        tlv = cp + i;\n        type = EXTRACT_16BITS(tlv);\n        optlen = EXTRACT_16BITS(tlv + 2);\n        value = tlv + 4;\n\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n\n        ND_PRINT((ndo, \"%s\", tok2str(dh6opt_str, \"Unknown\", type)));\n        ND_PRINT((ndo,\" (%u)\", optlen + 4 ));\n\n        switch (type) {\n            case DH6OPT_DNS_SERVERS:\n            case DH6OPT_SNTP_SERVERS: {\n                if (optlen % 16 != 0) {\n                    ND_PRINT((ndo, \" %s\", istr));\n                    return -1;\n                }\n                for (t = 0; t < optlen; t += 16)\n                    ND_PRINT((ndo, \" %s\", ip6addr_string(ndo, value + t)));\n            }\n                break;\n            case DH6OPT_DOMAIN_LIST: {\n                const u_char *tp = value;\n                while (tp < value + optlen) {\n                    ND_PRINT((ndo, \" \"));\n                    if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                        return -1;\n                }\n            }\n                break;\n        }\n\n        i += 4 + optlen;\n    }\n    return 0;\n}\n",
        "fix": null,
        "src_path": "39582c04cc5e34054b2936b423072fb9df2ff6ef___print-hncp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/39582c04cc5e34054b2936b423072fb9df2ff6ef",
        "commit_msg": "CVE-2017-13042/HNCP: add DHCPv6-Data bounds checks\n\nhncp_print_rec() validates each HNCP TLV to be within the declared as\nwell as the on-the-wire packet space. However, dhcpv6_print() in the same\nfile didn't do the same for the DHCPv6 options within the HNCP\nDHCPv6-Data TLV value, which could cause an out-of-bounds read when\ndecoding an invalid packet. Add missing checks to dhcpv6_print().\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -554,6 +554,12 @@ radius_attr_asan\tradius_attr_asan.pcap\t\tradius_attr_asan.out\t-v\n ospf6_decode_v3_asan\tospf6_decode_v3_asan.pcap\tospf6_decode_v3_asan.out -v\n ip_ts_opts_asan\t\tip_ts_opts_asan.pcap\t\tip_ts_opts_asan.out\t-v\n isakmpv1-attr-oobr\tisakmpv1-attr-oobr.pcap\t\tisakmpv1-attr-oobr.out\t-v\n+# The case below depends on the bug in print-hncp.c, which at the time of\n+# discovery had codepoints for DHCPv6-Data and DHCPv4-Data swapped around.\n+# After the bugfix the output will be different because of the different\n+# code path and will not test the vulnerability unless modified respectively.\n+# The .pcap file is truncated after the 1st packet.\n+hncp_dhcpv6data-oobr\thncp_dhcpv6data-oobr.pcap\thncp_dhcpv6data-oobr.out -v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/hncp_dhcpv6data-oobr.out",
                "patch": "@@ -0,0 +1,7 @@\n+IP6 (flowlabel 0x01cc3, hlim 234, next-header UDP (17) payload length: 11025) 400::e4ff:ffff:adf9:8900:0.1646 > 62:9de3:ff47:ebec:8206:ff00:ad:ff00.8231: hncp (11017)\n+\tFuture use: type=16384 (5)\n+\tDHCPv6-Data (25)\n+\t\tUnknown (4)\n+\t\tUnknown (4)\n+\t\tSNTP-servers (61956)  (invalid)\n+\t[|hncp]"
            }
        ],
        "error_msg": "    hncp_dhcpv6data-oobr               : TEST FAILED(exit 256)\n"
    },
    "c2f6833dddecf2d5fb89c9c898eee9981da342ed___print-hncp.c": {
        "start": 263,
        "end": 309,
        "buggy": "static int\ndhcpv4_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint8_t type, optlen;\n\n    i = 0;\n    while (i < length) {\n        tlv = cp + i;\n        type = (uint8_t)tlv[0];\n        optlen = (uint8_t)tlv[1];\n        value = tlv + 2;\n\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n\n        ND_PRINT((ndo, \"%s\", tok2str(dh4opt_str, \"Unknown\", type)));\n        ND_PRINT((ndo,\" (%u)\", optlen + 2 ));\n\n        switch (type) {\n        case DH4OPT_DNS_SERVERS:\n        case DH4OPT_NTP_SERVERS: {\n            if (optlen < 4 || optlen % 4 != 0) {\n                return -1;\n            }\n            for (t = 0; t < optlen; t += 4)\n                ND_PRINT((ndo, \" %s\", ipaddr_string(ndo, value + t)));\n        }\n            break;\n        case DH4OPT_DOMAIN_SEARCH: {\n            const u_char *tp = value;\n            while (tp < value + optlen) {\n                ND_PRINT((ndo, \" \"));\n                if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                    return -1;\n            }\n        }\n            break;\n        }\n\n        i += 2 + optlen;\n    }\n    return 0;\n}\n",
        "fix": null,
        "src_path": "c2f6833dddecf2d5fb89c9c898eee9981da342ed___print-hncp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/c2f6833dddecf2d5fb89c9c898eee9981da342ed",
        "commit_msg": "CVE-2017-13044/HNCP: add DHCPv4-Data bounds checks\n\ndhcpv4_print() in print-hncp.c had the same bug as dhcpv6_print(), apply\na fix along the same lines.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -560,6 +560,8 @@ isakmpv1-attr-oobr\tisakmpv1-attr-oobr.pcap\t\tisakmpv1-attr-oobr.out\t-v\n # code path and will not test the vulnerability unless modified respectively.\n # The .pcap file is truncated after the 1st packet.\n hncp_dhcpv6data-oobr\thncp_dhcpv6data-oobr.pcap\thncp_dhcpv6data-oobr.out -v -c1\n+# Same comments apply to the case below.\n+hncp_dhcpv4data-oobr\thncp_dhcpv4data-oobr.pcap\thncp_dhcpv4data-oobr.out -v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/hncp_dhcpv4data-oobr.out",
                "patch": "@@ -0,0 +1,4 @@\n+IP truncated-ip - 260 bytes missing! (tos 0x12,ECT(0), ttl 48, id 21323, offset 0, flags [+, DF, rsvd], proto UDP (17), length 296, bad cksum 8e0f (->cd08)!)\n+    1.2.7.0.1812 > 128.253.0.96.8231: hncp (268)\n+\tDHCPv4-Data (6)\n+\t\tDNS-server (98) (invalid)"
            }
        ],
        "error_msg": "    hncp_dhcpv4data-oobr               : TEST FAILED(exit 256)\n"
    },
    "d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514___print-bgp.c": {
        "start": 906,
        "end": 991,
        "buggy": "static int\ndecode_multicast_vpn(netdissect_options *ndo,\n                     const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t route_type, route_length, addr_length, sg_length;\n        u_int offset;\n\n\tND_TCHECK2(pptr[0], 2);\n        route_type = *pptr++;\n        route_length = *pptr++;\n\n        snprintf(buf, buflen, \"Route-Type: %s (%u), length: %u\",\n                 tok2str(bgp_multicast_vpn_route_type_values,\n                         \"Unknown\", route_type),\n                 route_type, route_length);\n\n        switch(route_type) {\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s, Originator %s\",\n                     bgp_vpn_rd_print(ndo, pptr),\n                     bgp_vpn_ip_print(ndo, pptr + BGP_VPN_RD_LEN,\n                                      (route_length - BGP_VPN_RD_LEN) << 3));\n            break;\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            sg_length = bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            addr_length =  route_length - sg_length;\n\n            ND_TCHECK2(pptr[0], addr_length);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", Originator %s\",\n                     bgp_vpn_ip_print(ndo, pptr, addr_length << 3));\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN: /* fall through */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            pptr += BGP_VPN_RD_LEN;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n            /*\n             * no per route-type printing yet.\n             */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF:\n        default:\n            break;\n        }\n\n        return route_length + 2;\n\ntrunc:\n\treturn -2;\n}\n",
        "fix": null,
        "src_path": "d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514___print-bgp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514",
        "commit_msg": "CVE-2017-13043/BGP: fix decoding of MVPN route types 6 and 7\n\nRFC 6514 Section 4.6 defines the structure for Shared Tree Join (6) and\nSource Tree Join (7) multicast VPN route types. decode_multicast_vpn()\ndidn't implement the Source AS field of that structure properly, adjust\nthe offsets to put it right.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -564,6 +564,7 @@ hncp_dhcpv6data-oobr\thncp_dhcpv6data-oobr.pcap\thncp_dhcpv6data-oobr.out -v -c1\n hncp_dhcpv4data-oobr\thncp_dhcpv4data-oobr.pcap\thncp_dhcpv4data-oobr.out -v -c1\n vqp-oobr\t\tvqp-oobr.pcap\t\t\tvqp-oobr.out\t\t-v -c1\n bgp_pmsi_tunnel-oobr\tbgp_pmsi_tunnel-oobr.pcap\tbgp_pmsi_tunnel-oobr.out -v -c1\n+bgp_mvpn_6_and_7\tbgp_mvpn_6_and_7.pcap\t\tbgp_mvpn_6_and_7.out\t-v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/bgp_mvpn_6_and_7.out",
                "patch": "@@ -0,0 +1,13 @@\n+IP (tos 0xc, ttl 254, id 21263, offset 0, flags [rsvd], proto TCP (6), length 517, bad cksum 8e15 (->99c9)!)\n+    241.0.93.20.179 > 255.247.0.1.200: Flags [none], seq 2146691977:2146692450, win 56026, options [unknown-161,eol], length 473: BGP\n+\tUpdate Message (2), length: 45\n+\t  Withdrawn routes: 3 bytes\n+\t  Attribute Set (128), length: 7, Flags [OTPE+f]: \n+\t    Origin AS: 148\n+\t      Multi-Protocol Reach NLRI (14), length: 71, Flags [T+6]: \n+\t    AFI: IPv4 (1), SAFI: Multicast VPN (5), nh-length: 0, no SNPA\n+\t      Route-Type: Intra-AS I-PMSI (1), length: 0, RD: 62209:33686018 (= 2.2.2.2), Originator bogus address length 4294967232\n+\t      Route-Type: Unknown (0), length: 0\n+\t      Route-Type: Unknown (243), length: 1\n+\t      Route-Type: Inter-AS I-PMSI (2), length: 2, RD: unknown RD format, Source-AS 368115805\n+\t      Route-Type: Inter-AS I-PMSI (2), length: 2, RD: unknown RD format, Source-AS 335544320[|BGP]"
            }
        ],
        "error_msg": "    bgp_mvpn_6_and_7                   : TEST FAILED(exit 256)\n"
    },
    "331530a4076c69bbd2e3214db6ccbe834fb75640___print-isoclns.c": {
        "start": 1089,
        "end": 1371,
        "buggy": "static void\nesis_print(netdissect_options *ndo,\n           const uint8_t *pptr, u_int length)\n{\n\tconst uint8_t *optr;\n\tu_int li,esis_pdu_type,source_address_length, source_address_number;\n\tconst struct esis_header_t *esis_header;\n\n\tif (!ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"ES-IS\"));\n\n\tif (length <= 2) {\n\t\tND_PRINT((ndo, ndo->ndo_qflag ? \"bad pkt!\" : \"no header at all!\"));\n\t\treturn;\n\t}\n\n\tesis_header = (const struct esis_header_t *) pptr;\n        ND_TCHECK(*esis_header);\n        li = esis_header->length_indicator;\n        optr = pptr;\n\n        /*\n         * Sanity checking of the header.\n         */\n\n        if (esis_header->nlpid != NLPID_ESIS) {\n            ND_PRINT((ndo, \" nlpid 0x%02x packet not supported\", esis_header->nlpid));\n            return;\n        }\n\n        if (esis_header->version != ESIS_VERSION) {\n            ND_PRINT((ndo, \" version %d packet not supported\", esis_header->version));\n            return;\n        }\n\n\tif (li > length) {\n            ND_PRINT((ndo, \" length indicator(%u) > PDU size (%u)!\", li, length));\n            return;\n\t}\n\n\tif (li < sizeof(struct esis_header_t) + 2) {\n            ND_PRINT((ndo, \" length indicator %u < min PDU size:\", li));\n            while (pptr < ndo->ndo_snapend)\n                ND_PRINT((ndo, \"%02X\", *pptr++));\n            return;\n\t}\n\n        esis_pdu_type = esis_header->type & ESIS_PDU_TYPE_MASK;\n\n        if (ndo->ndo_vflag < 1) {\n            ND_PRINT((ndo, \"%s%s, length %u\",\n                   ndo->ndo_eflag ? \"\" : \", \",\n                   tok2str(esis_pdu_values,\"unknown type (%u)\",esis_pdu_type),\n                   length));\n            return;\n        } else\n            ND_PRINT((ndo, \"%slength %u\\n\\t%s (%u)\",\n                   ndo->ndo_eflag ? \"\" : \", \",\n                   length,\n                   tok2str(esis_pdu_values,\"unknown type: %u\", esis_pdu_type),\n                   esis_pdu_type));\n\n        ND_PRINT((ndo, \", v: %u%s\", esis_header->version, esis_header->version == ESIS_VERSION ? \"\" : \"unsupported\" ));\n        ND_PRINT((ndo, \", checksum: 0x%04x\", EXTRACT_16BITS(esis_header->cksum)));\n\n        osi_print_cksum(ndo, pptr, EXTRACT_16BITS(esis_header->cksum), 7, li);\n\n        ND_PRINT((ndo, \", holding time: %us, length indicator: %u\",\n                  EXTRACT_16BITS(esis_header->holdtime), li));\n\n        if (ndo->ndo_vflag > 1)\n            print_unknown_data(ndo, optr, \"\\n\\t\", sizeof(struct esis_header_t));\n\n\tpptr += sizeof(struct esis_header_t);\n\tli -= sizeof(struct esis_header_t);\n\n\tswitch (esis_pdu_type) {\n\tcase ESIS_PDU_REDIRECT: {\n\t\tconst uint8_t *dst, *snpa, *neta;\n\t\tu_int dstl, snpal, netal;\n\n\t\tND_TCHECK(*pptr);\n\t\tif (li < 1) {\n\t\t\tND_PRINT((ndo, \", bad redirect/li\"));\n\t\t\treturn;\n\t\t}\n\t\tdstl = *pptr;\n\t\tpptr++;\n\t\tli--;\n\t\tND_TCHECK2(*pptr, dstl);\n\t\tif (li < dstl) {\n\t\t\tND_PRINT((ndo, \", bad redirect/li\"));\n\t\t\treturn;\n\t\t}\n\t\tdst = pptr;\n\t\tpptr += dstl;\n                li -= dstl;\n\t\tND_PRINT((ndo, \"\\n\\t  %s\", isonsap_string(ndo, dst, dstl)));\n\n\t\tND_TCHECK(*pptr);\n\t\tif (li < 1) {\n\t\t\tND_PRINT((ndo, \", bad redirect/li\"));\n\t\t\treturn;\n\t\t}\n\t\tsnpal = *pptr;\n\t\tpptr++;\n\t\tli--;\n\t\tND_TCHECK2(*pptr, snpal);\n\t\tif (li < snpal) {\n\t\t\tND_PRINT((ndo, \", bad redirect/li\"));\n\t\t\treturn;\n\t\t}\n\t\tsnpa = pptr;\n\t\tpptr += snpal;\n                li -= snpal;\n\t\tND_TCHECK(*pptr);\n\t\tif (li < 1) {\n\t\t\tND_PRINT((ndo, \", bad redirect/li\"));\n\t\t\treturn;\n\t\t}\n\t\tnetal = *pptr;\n\t\tpptr++;\n\t\tND_TCHECK2(*pptr, netal);\n\t\tif (li < netal) {\n\t\t\tND_PRINT((ndo, \", bad redirect/li\"));\n\t\t\treturn;\n\t\t}\n\t\tneta = pptr;\n\t\tpptr += netal;\n                li -= netal;\n\n\t\tif (snpal == 6)\n\t\t\tND_PRINT((ndo, \"\\n\\t  SNPA (length: %u): %s\",\n\t\t\t       snpal,\n\t\t\t       etheraddr_string(ndo, snpa)));\n\t\telse\n\t\t\tND_PRINT((ndo, \"\\n\\t  SNPA (length: %u): %s\",\n\t\t\t       snpal,\n\t\t\t       linkaddr_string(ndo, snpa, LINKADDR_OTHER, snpal)));\n\t\tif (netal != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  NET (length: %u) %s\",\n\t\t\t       netal,\n\t\t\t       isonsap_string(ndo, neta, netal)));\n\t\tbreak;\n\t}\n\n\tcase ESIS_PDU_ESH:\n            ND_TCHECK(*pptr);\n            if (li < 1) {\n                ND_PRINT((ndo, \", bad esh/li\"));\n                return;\n            }\n            source_address_number = *pptr;\n            pptr++;\n            li--;\n\n            ND_PRINT((ndo, \"\\n\\t  Number of Source Addresses: %u\", source_address_number));\n\n            while (source_address_number > 0) {\n                ND_TCHECK(*pptr);\n            \tif (li < 1) {\n                    ND_PRINT((ndo, \", bad esh/li\"));\n            \t    return;\n            \t}\n                source_address_length = *pptr;\n                pptr++;\n            \tli--;\n\n                ND_TCHECK2(*pptr, source_address_length);\n            \tif (li < source_address_length) {\n                    ND_PRINT((ndo, \", bad esh/li\"));\n            \t    return;\n            \t}\n                ND_PRINT((ndo, \"\\n\\t  NET (length: %u): %s\",\n                       source_address_length,\n                       isonsap_string(ndo, pptr, source_address_length)));\n                pptr += source_address_length;\n                li -= source_address_length;\n                source_address_number--;\n            }\n\n            break;\n\n\tcase ESIS_PDU_ISH: {\n            ND_TCHECK(*pptr);\n            if (li < 1) {\n                ND_PRINT((ndo, \", bad ish/li\"));\n                return;\n            }\n            source_address_length = *pptr;\n            pptr++;\n            li--;\n            ND_TCHECK2(*pptr, source_address_length);\n            if (li < source_address_length) {\n                ND_PRINT((ndo, \", bad ish/li\"));\n                return;\n            }\n            ND_PRINT((ndo, \"\\n\\t  NET (length: %u): %s\", source_address_length, isonsap_string(ndo, pptr, source_address_length)));\n            pptr += source_address_length;\n            li -= source_address_length;\n            break;\n\t}\n\n\tdefault:\n\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\tif (pptr < ndo->ndo_snapend)\n\t\t\t\tprint_unknown_data(ndo, pptr, \"\\n\\t  \", ndo->ndo_snapend - pptr);\n\t\t}\n\t\treturn;\n\t}\n\n        /* now walk the options */\n        while (li != 0) {\n            u_int op, opli;\n            const uint8_t *tptr;\n\n            if (li < 2) {\n                ND_PRINT((ndo, \", bad opts/li\"));\n                return;\n            }\n            ND_TCHECK2(*pptr, 2);\n            op = *pptr++;\n            opli = *pptr++;\n            li -= 2;\n            if (opli > li) {\n                ND_PRINT((ndo, \", opt (%d) too long\", op));\n                return;\n            }\n            li -= opli;\n            tptr = pptr;\n\n            ND_PRINT((ndo, \"\\n\\t  %s Option #%u, length %u, value: \",\n                   tok2str(esis_option_values,\"Unknown\",op),\n                   op,\n                   opli));\n\n            switch (op) {\n\n            case ESIS_OPTION_ES_CONF_TIME:\n                if (opli == 2) {\n                    ND_TCHECK2(*pptr, 2);\n                    ND_PRINT((ndo, \"%us\", EXTRACT_16BITS(tptr)));\n                } else\n                    ND_PRINT((ndo, \"(bad length)\"));\n                break;\n\n            case ESIS_OPTION_PROTOCOLS:\n                while (opli>0) {\n                    ND_TCHECK(*pptr);\n                    ND_PRINT((ndo, \"%s (0x%02x)\",\n                           tok2str(nlpid_values,\n                                   \"unknown\",\n                                   *tptr),\n                           *tptr));\n                    if (opli>1) /* further NPLIDs ? - put comma */\n                        ND_PRINT((ndo, \", \"));\n                    tptr++;\n                    opli--;\n                }\n                break;\n\n                /*\n                 * FIXME those are the defined Options that lack a decoder\n                 * you are welcome to contribute code ;-)\n                 */\n\n            case ESIS_OPTION_QOS_MAINTENANCE:\n            case ESIS_OPTION_SECURITY:\n            case ESIS_OPTION_PRIORITY:\n            case ESIS_OPTION_ADDRESS_MASK:\n            case ESIS_OPTION_SNPA_MASK:\n\n            default:\n                print_unknown_data(ndo, tptr, \"\\n\\t  \", opli);\n                break;\n            }\n            if (ndo->ndo_vflag > 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t  \", opli);\n            pptr += opli;\n        }\ntrunc:\n\treturn;\n}\n",
        "fix": null,
        "src_path": "331530a4076c69bbd2e3214db6ccbe834fb75640___print-isoclns.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/331530a4076c69bbd2e3214db6ccbe834fb75640",
        "commit_msg": "CVE-2017-13047/ES-IS: put an existing bounds check right\n\nThe bounds check in esis_print() tested one pointer at the beginning of\na loop that incremented another, make the trivial fix. While at it, make\nthe function print a standard marker when it detects truncated data and\nupdate some existing ES-IS tests respectively.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -566,6 +566,7 @@ vqp-oobr\t\tvqp-oobr.pcap\t\t\tvqp-oobr.out\t\t-v -c1\n bgp_pmsi_tunnel-oobr\tbgp_pmsi_tunnel-oobr.pcap\tbgp_pmsi_tunnel-oobr.out -v -c1\n bgp_mvpn_6_and_7\tbgp_mvpn_6_and_7.pcap\t\tbgp_mvpn_6_and_7.out\t-v -c1\n rsvp_fast_reroute-oobr\trsvp_fast_reroute-oobr.pcap\trsvp_fast_reroute-oobr.out -v -c1\n+esis_opt_prot-oobr\tesis_opt_prot-oobr.pcap\t\tesis_opt_prot-oobr.out\t-v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/esis_opt_prot-oobr.out",
                "patch": "@@ -0,0 +1,5 @@\n+ES-IS, length 33559803\n+\tredirect (6), v: 1, checksum: 0x00c6 (unverified), holding time: 2303s, length indicator: 54\n+\t  00.8e\n+\t  SNPA (length: 0): <empty>\n+\t  Protocols supported Option #129, length 11, value: CLNP (0x81), [|esis]"
            },
            {
                "fn": "tests/esis_snpa_asan-3.out",
                "patch": "@@ -4,4 +4,4 @@ UI 22! ES-IS, length 65565\n UI 22! ES-IS, length 2650865693\n \tredirect (6), v: 1, checksum: 0x0300 (incorrect should be 0xbce5), holding time: 21480s, length indicator: 17\n \t  ec.ff00.00\n-\t  SNPA (length: 0): <empty>\n+\t  SNPA (length: 0): <empty>[|esis]"
            },
            {
                "fn": "tests/esis_snpa_asan-4.out",
                "patch": "@@ -7,7 +7,7 @@ UI 22! ES-IS, length 65565\n \tredirect (6), v: 1, checksum: 0x7034 (incorrect should be 0x44ec), holding time: 21315s, length indicator: 16\n \t  02.0400\n \t  SNPA (length: 0): <empty>\n-\t  Unknown Option #0, length 0, value: \n+\t  Unknown Option #0, length 0, value: [|esis]\n UI 32! ES-IS, length 65565\n \tESH (2), v: 1, checksum: 0x70a1 (incorrect should be 0xfb4e), holding time: 21315s, length indicator: 17\n \t  Number of Source Addresses: 2\n@@ -17,5 +17,5 @@ UI 22! ES-IS, length 4244701213\n \tredirect (6), v: 1, checksum: 0x7034 (incorrect should be 0x36fe), holding time: 21315s, length indicator: 17\n \t  isonsap_string: illegal length\n \t  SNPA (length: 0): <empty>\n-\t  NET (length: 4) 00.0000.00\n+\t  NET (length: 4) 00.0000.00[|esis]\n Q.922, invalid address"
            },
            {
                "fn": "tests/esis_snpa_asan-5.out",
                "patch": "@@ -3,7 +3,7 @@ UI 22! ES-IS, length 65565\n \t  Number of Source Addresses: 3\n \t  NET (length: 0): isonsap_string: illegal length\n \t  NET (length: 4): ec.ff00.00\n-\t  NET (length: 0): isonsap_string: illegal length\n+\t  NET (length: 0): isonsap_string: illegal length[|esis]\n UI 22! ES-IS, length 65565\n \tredirect (6), v: 1, checksum: 0x7034 (incorrect should be 0x3ff0), holding time: 21315s, length indicator: 17\n \t  04"
            }
        ],
        "error_msg": "    esis_opt_prot-oobr                 : TEST FAILED(exit 256)\n"
    },
    "bd4e697ebd6c8457efa8f28f6831fc929b88a014___print-bgp.c": {
        "start": 758,
        "end": 796,
        "buggy": "static int\ndecode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n{\n\tuint8_t route_target[8];\n\tu_int plen;\n\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   /* get prefix length */\n\n\tif (0 == plen) {\n\t\tsnprintf(buf, buflen, \"default route target\");\n\t\treturn 1;\n\t}\n\n\tif (32 > plen)\n\t\treturn -1;\n\n        plen-=32; /* adjust prefix length */\n\n\tif (64 < plen)\n\t\treturn -1;\n\n\tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[1], (plen + 7) / 8);\n\tmemcpy(&route_target, &pptr[1], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),\n\t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n\n\treturn 5 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}\n",
        "fix": null,
        "src_path": "bd4e697ebd6c8457efa8f28f6831fc929b88a014___print-bgp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/bd4e697ebd6c8457efa8f28f6831fc929b88a014",
        "commit_msg": "CVE-2017-13053/BGP: fix VPN route target bounds checks\n\ndecode_rt_routing_info() didn't check bounds before fetching 4 octets of\nthe origin AS field and could over-read the input buffer, put it right.\n\nIt also fetched the varying number of octets of the route target field\nfrom 4 octets lower than the correct offset, put it right.\n\nIt also used the same temporary buffer explicitly through as_printf()\nand implicitly through bgp_vpn_rd_print() so the end result of snprintf()\nwas not what was originally intended.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -572,6 +572,7 @@ rsvp_uni-oobr-2\trsvp_uni-oobr-2.pcap\trsvp_uni-oobr-2.out\t-v -c1\n rsvp_uni-oobr-3\trsvp_uni-oobr-3.pcap\trsvp_uni-oobr-3.out\t-v -c3\n rpki-rtr-oob\t\trpki-rtr-oob.pcap\trpki-rtr-oob.out\t-v -c1\n lldp_8023_mtu-oobr\tlldp_8023_mtu-oobr.pcap\tlldp_8023_mtu-oobr.out\t-v -c1\n+bgp_vpn_rt-oobr\tbgp_vpn_rt-oobr.pcap\tbgp_vpn_rt-oobr.out\t-v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/bgp_vpn_rt-oobr.out",
                "patch": "@@ -0,0 +1,43 @@\n+IP (tos 0xc, ttl 254, id 21263, offset 0, flags [rsvd], proto TCP (6), length 60165, bad cksum 8e15 (->9eb8)!)\n+    241.0.128.19.179 > 239.8.0.1.0: Flags [none], seq 2146695561:2146755682, win 56026, options [unknown-161,eol], length 60121: BGP\n+\tUpdate Message (2), length: 45\n+\t  Withdrawn routes: 3 bytes\n+\t  Attribute Set (128), length: 7, Flags [OTPE+f]: \n+\t    Origin AS: 0\n+\t      Multi-Protocol Unreach NLRI (15), length: 227, Flags [T+6]: \n+\t    AFI: IPv6 (2), SAFI: Multicast VPN (5)\n+\t      Route-Type: Source-Active (5), length: 5, RD: unknown RD format, Group bogus address length 127\n+\t      Route-Type: Unknown (142), length: 142\n+\t      Route-Type: Unknown (0), length: 0\n+\t      Route-Type: Unknown (33), length: 0\n+\t      Route-Type: Unknown (0), length: 0[|BGP] [|BGP]\n+\tUpdate Message (2), length: 45[|BGP] [|BGP]\n+\tUpdate Message (2), length: 45\n+\t  Withdrawn routes: 3 bytes\n+\t  Attribute Set (128), length: 7, Flags [OTPE+f]: \n+\t    Origin AS: 0\n+\t      Multi-Protocol Reach NLRI (14), length: 227, Flags [T+6]: \n+\t    AFI: IPv4 (1), vendor specific SAFI: Route Target Routing Information (132)\n+\t    nexthop: invalid len, nh-length: 1, no SNPA\n+\t      origin AS: 0, route target 0:0 (= 0.0.0.0)\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target[|BGP]"
            }
        ],
        "error_msg": "    bgp_vpn_rt-oobr                    : TEST FAILED(exit 256)\n"
    },
    "0cb1b8a434b599b8d636db029aadb757c24e39d6___print-olsr.c": {
        "start": 309,
        "end": 709,
        "buggy": "void\nolsr_print(netdissect_options *ndo,\n           const u_char *pptr, u_int length, int is_ipv6)\n{\n    union {\n        const struct olsr_common *common;\n        const struct olsr_msg4 *msg4;\n        const struct olsr_msg6 *msg6;\n        const struct olsr_hello *hello;\n        const struct olsr_hello_link *hello_link;\n        const struct olsr_tc *tc;\n        const struct olsr_hna4 *hna;\n    } ptr;\n\n    u_int msg_type, msg_len, msg_tlen, hello_len;\n    uint16_t name_entry_type, name_entry_len;\n    u_int name_entry_padding;\n    uint8_t link_type, neighbor_type;\n    const u_char *tptr, *msg_data;\n\n    tptr = pptr;\n\n    if (length < sizeof(struct olsr_common)) {\n        goto trunc;\n    }\n\n    ND_TCHECK2(*tptr, sizeof(struct olsr_common));\n\n    ptr.common = (const struct olsr_common *)tptr;\n    length = min(length, EXTRACT_16BITS(ptr.common->packet_len));\n\n    ND_PRINT((ndo, \"OLSRv%i, seq 0x%04x, length %u\",\n            (is_ipv6 == 0) ? 4 : 6,\n            EXTRACT_16BITS(ptr.common->packet_seq),\n            length));\n\n    tptr += sizeof(struct olsr_common);\n\n    /*\n     * In non-verbose mode, just print version.\n     */\n    if (ndo->ndo_vflag < 1) {\n        return;\n    }\n\n    while (tptr < (pptr+length)) {\n        union\n        {\n            const struct olsr_msg4 *v4;\n            const struct olsr_msg6 *v6;\n        } msgptr;\n        int msg_len_valid = 0;\n\n        ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));\n\n        if (is_ipv6)\n        {\n            msgptr.v6 = (const struct olsr_msg6 *) tptr;\n            msg_type = msgptr.v6->msg_type;\n            msg_len = EXTRACT_16BITS(msgptr.v6->msg_len);\n            if ((msg_len >= sizeof (struct olsr_msg6))\n                    && (msg_len <= length))\n                msg_len_valid = 1;\n\n            /* infinite loop check */\n            if (msg_type == 0 || msg_len == 0) {\n                return;\n            }\n\n            ND_PRINT((ndo, \"\\n\\t%s Message (%#04x), originator %s, ttl %u, hop %u\"\n                    \"\\n\\t  vtime %.3fs, msg-seq 0x%04x, length %u%s\",\n                    tok2str(olsr_msg_values, \"Unknown\", msg_type),\n                    msg_type, ip6addr_string(ndo, msgptr.v6->originator),\n                    msgptr.v6->ttl,\n                    msgptr.v6->hopcount,\n                    ME_TO_DOUBLE(msgptr.v6->vtime),\n                    EXTRACT_16BITS(msgptr.v6->msg_seq),\n                    msg_len, (msg_len_valid == 0) ? \" (invalid)\" : \"\"));\n            if (!msg_len_valid) {\n                return;\n            }\n\n            msg_tlen = msg_len - sizeof(struct olsr_msg6);\n            msg_data = tptr + sizeof(struct olsr_msg6);\n        }\n        else /* (!is_ipv6) */\n        {\n            msgptr.v4 = (const struct olsr_msg4 *) tptr;\n            msg_type = msgptr.v4->msg_type;\n            msg_len = EXTRACT_16BITS(msgptr.v4->msg_len);\n            if ((msg_len >= sizeof (struct olsr_msg4))\n                    && (msg_len <= length))\n                msg_len_valid = 1;\n\n            /* infinite loop check */\n            if (msg_type == 0 || msg_len == 0) {\n                return;\n            }\n\n            ND_PRINT((ndo, \"\\n\\t%s Message (%#04x), originator %s, ttl %u, hop %u\"\n                    \"\\n\\t  vtime %.3fs, msg-seq 0x%04x, length %u%s\",\n                    tok2str(olsr_msg_values, \"Unknown\", msg_type),\n                    msg_type, ipaddr_string(ndo, msgptr.v4->originator),\n                    msgptr.v4->ttl,\n                    msgptr.v4->hopcount,\n                    ME_TO_DOUBLE(msgptr.v4->vtime),\n                    EXTRACT_16BITS(msgptr.v4->msg_seq),\n                    msg_len, (msg_len_valid == 0) ? \" (invalid)\" : \"\"));\n            if (!msg_len_valid) {\n                return;\n            }\n\n            msg_tlen = msg_len - sizeof(struct olsr_msg4);\n            msg_data = tptr + sizeof(struct olsr_msg4);\n        }\n\n        switch (msg_type) {\n        case OLSR_HELLO_MSG:\n        case OLSR_HELLO_LQ_MSG:\n            if (msg_tlen < sizeof(struct olsr_hello))\n                goto trunc;\n            ND_TCHECK2(*msg_data, sizeof(struct olsr_hello));\n\n            ptr.hello = (const struct olsr_hello *)msg_data;\n            ND_PRINT((ndo, \"\\n\\t  hello-time %.3fs, MPR willingness %u\",\n                   ME_TO_DOUBLE(ptr.hello->htime), ptr.hello->will));\n            msg_data += sizeof(struct olsr_hello);\n            msg_tlen -= sizeof(struct olsr_hello);\n\n            while (msg_tlen >= sizeof(struct olsr_hello_link)) {\n                int hello_len_valid = 0;\n\n                /*\n                 * link-type.\n                 */\n                ND_TCHECK2(*msg_data, sizeof(struct olsr_hello_link));\n\n                ptr.hello_link = (const struct olsr_hello_link *)msg_data;\n\n                hello_len = EXTRACT_16BITS(ptr.hello_link->len);\n                link_type = OLSR_EXTRACT_LINK_TYPE(ptr.hello_link->link_code);\n                neighbor_type = OLSR_EXTRACT_NEIGHBOR_TYPE(ptr.hello_link->link_code);\n\n                if ((hello_len <= msg_tlen)\n                        && (hello_len >= sizeof(struct olsr_hello_link)))\n                    hello_len_valid = 1;\n\n                ND_PRINT((ndo, \"\\n\\t    link-type %s, neighbor-type %s, len %u%s\",\n                       tok2str(olsr_link_type_values, \"Unknown\", link_type),\n                       tok2str(olsr_neighbor_type_values, \"Unknown\", neighbor_type),\n                       hello_len,\n                       (hello_len_valid == 0) ? \" (invalid)\" : \"\"));\n\n                if (hello_len_valid == 0)\n                    break;\n\n                msg_data += sizeof(struct olsr_hello_link);\n                msg_tlen -= sizeof(struct olsr_hello_link);\n                hello_len -= sizeof(struct olsr_hello_link);\n\n                ND_TCHECK2(*msg_data, hello_len);\n                if (msg_type == OLSR_HELLO_MSG) {\n                    if (olsr_print_neighbor(ndo, msg_data, hello_len) == -1)\n                        goto trunc;\n                } else {\n                    if (is_ipv6) {\n                        if (olsr_print_lq_neighbor6(ndo, msg_data, hello_len) == -1)\n                            goto trunc;\n                    } else {\n                        if (olsr_print_lq_neighbor4(ndo, msg_data, hello_len) == -1)\n                            goto trunc;\n                    }\n                }\n\n                msg_data += hello_len;\n                msg_tlen -= hello_len;\n            }\n            break;\n\n        case OLSR_TC_MSG:\n        case OLSR_TC_LQ_MSG:\n            if (msg_tlen < sizeof(struct olsr_tc))\n                goto trunc;\n            ND_TCHECK2(*msg_data, sizeof(struct olsr_tc));\n\n            ptr.tc = (const struct olsr_tc *)msg_data;\n            ND_PRINT((ndo, \"\\n\\t    advertised neighbor seq 0x%04x\",\n                   EXTRACT_16BITS(ptr.tc->ans_seq)));\n            msg_data += sizeof(struct olsr_tc);\n            msg_tlen -= sizeof(struct olsr_tc);\n\n            if (msg_type == OLSR_TC_MSG) {\n                if (olsr_print_neighbor(ndo, msg_data, msg_tlen) == -1)\n                    goto trunc;\n            } else {\n                if (is_ipv6) {\n                    if (olsr_print_lq_neighbor6(ndo, msg_data, msg_tlen) == -1)\n                        goto trunc;\n                } else {\n                    if (olsr_print_lq_neighbor4(ndo, msg_data, msg_tlen) == -1)\n                        goto trunc;\n                }\n            }\n            break;\n\n        case OLSR_MID_MSG:\n        {\n            size_t addr_size = sizeof(struct in_addr);\n\n            if (is_ipv6)\n                addr_size = sizeof(struct in6_addr);\n\n            while (msg_tlen >= addr_size) {\n                ND_TCHECK2(*msg_data, addr_size);\n                ND_PRINT((ndo, \"\\n\\t  interface address %s\",\n                        is_ipv6 ? ip6addr_string(ndo, msg_data) :\n                        ipaddr_string(ndo, msg_data)));\n\n                msg_data += addr_size;\n                msg_tlen -= addr_size;\n            }\n            break;\n        }\n\n        case OLSR_HNA_MSG:\n            if (is_ipv6)\n            {\n                int i = 0;\n\n                ND_PRINT((ndo, \"\\n\\t  Advertised networks (total %u)\",\n                        (unsigned int) (msg_tlen / sizeof(struct olsr_hna6))));\n\n                while (msg_tlen >= sizeof(struct olsr_hna6)) {\n                    const struct olsr_hna6 *hna6;\n\n                    ND_TCHECK2(*msg_data, sizeof(struct olsr_hna6));\n\n                    hna6 = (const struct olsr_hna6 *)msg_data;\n\n                    ND_PRINT((ndo, \"\\n\\t    #%i: %s/%u\",\n                            i, ip6addr_string(ndo, hna6->network),\n                            mask62plen (hna6->mask)));\n\n                    msg_data += sizeof(struct olsr_hna6);\n                    msg_tlen -= sizeof(struct olsr_hna6);\n                }\n            }\n            else\n            {\n                int col = 0;\n\n                ND_PRINT((ndo, \"\\n\\t  Advertised networks (total %u)\",\n                        (unsigned int) (msg_tlen / sizeof(struct olsr_hna4))));\n\n                while (msg_tlen >= sizeof(struct olsr_hna4)) {\n                    ND_TCHECK2(*msg_data, sizeof(struct olsr_hna4));\n\n                    ptr.hna = (const struct olsr_hna4 *)msg_data;\n\n                    /* print 4 prefixes per line */\n                    if (!ptr.hna->network[0] && !ptr.hna->network[1] &&\n                        !ptr.hna->network[2] && !ptr.hna->network[3] &&\n                        !ptr.hna->mask[GW_HNA_PAD] &&\n                        ptr.hna->mask[GW_HNA_FLAGS]) {\n                            /* smart gateway */\n                            ND_PRINT((ndo, \"%sSmart-Gateway:%s%s%s%s%s %u/%u\",\n                                col == 0 ? \"\\n\\t    \" : \", \", /* indent */\n                                /* sgw */\n                                /* LINKSPEED */\n                                (ptr.hna->mask[GW_HNA_FLAGS] &\n                                 GW_HNA_FLAG_LINKSPEED) ? \" LINKSPEED\" : \"\",\n                                /* IPV4 */\n                                (ptr.hna->mask[GW_HNA_FLAGS] &\n                                 GW_HNA_FLAG_IPV4) ? \" IPV4\" : \"\",\n                                /* IPV4-NAT */\n                                (ptr.hna->mask[GW_HNA_FLAGS] &\n                                 GW_HNA_FLAG_IPV4_NAT) ? \" IPV4-NAT\" : \"\",\n                                /* IPV6 */\n                                (ptr.hna->mask[GW_HNA_FLAGS] &\n                                 GW_HNA_FLAG_IPV6) ? \" IPV6\" : \"\",\n                                /* IPv6PREFIX */\n                                (ptr.hna->mask[GW_HNA_FLAGS] &\n                                 GW_HNA_FLAG_IPV6PREFIX) ? \" IPv6-PREFIX\" : \"\",\n                                /* uplink */\n                                (ptr.hna->mask[GW_HNA_FLAGS] &\n                                 GW_HNA_FLAG_LINKSPEED) ?\n                                 deserialize_gw_speed(ptr.hna->mask[GW_HNA_UPLINK]) : 0,\n                                /* downlink */\n                                (ptr.hna->mask[GW_HNA_FLAGS] &\n                                 GW_HNA_FLAG_LINKSPEED) ?\n                                 deserialize_gw_speed(ptr.hna->mask[GW_HNA_DOWNLINK]) : 0\n                                ));\n                    } else {\n                        /* normal route */\n                        ND_PRINT((ndo, \"%s%s/%u\",\n                                col == 0 ? \"\\n\\t    \" : \", \",\n                                ipaddr_string(ndo, ptr.hna->network),\n                                mask2plen(EXTRACT_32BITS(ptr.hna->mask))));\n                    }\n\n                    msg_data += sizeof(struct olsr_hna4);\n                    msg_tlen -= sizeof(struct olsr_hna4);\n\n                    col = (col + 1) % 4;\n                }\n            }\n            break;\n\n        case OLSR_NAMESERVICE_MSG:\n        {\n            u_int name_entries = EXTRACT_16BITS(msg_data+2);\n            u_int addr_size = 4;\n            int name_entries_valid = 0;\n            u_int i;\n\n            if (is_ipv6)\n                addr_size = 16;\n\n            if ((name_entries > 0)\n                    && ((name_entries * (4 + addr_size)) <= msg_tlen))\n                name_entries_valid = 1;\n\n            if (msg_tlen < 4)\n                goto trunc;\n            ND_TCHECK2(*msg_data, 4);\n\n            ND_PRINT((ndo, \"\\n\\t  Version %u, Entries %u%s\",\n                   EXTRACT_16BITS(msg_data),\n                   name_entries, (name_entries_valid == 0) ? \" (invalid)\" : \"\"));\n\n            if (name_entries_valid == 0)\n                break;\n\n            msg_data += 4;\n            msg_tlen -= 4;\n\n            for (i = 0; i < name_entries; i++) {\n                int name_entry_len_valid = 0;\n\n                if (msg_tlen < 4)\n                    break;\n                ND_TCHECK2(*msg_data, 4);\n\n                name_entry_type = EXTRACT_16BITS(msg_data);\n                name_entry_len = EXTRACT_16BITS(msg_data+2);\n\n                msg_data += 4;\n                msg_tlen -= 4;\n\n                if ((name_entry_len > 0) && ((addr_size + name_entry_len) <= msg_tlen))\n                    name_entry_len_valid = 1;\n\n                ND_PRINT((ndo, \"\\n\\t    #%u: type %#06x, length %u%s\",\n                        (unsigned int) i, name_entry_type,\n                        name_entry_len, (name_entry_len_valid == 0) ? \" (invalid)\" : \"\"));\n\n                if (name_entry_len_valid == 0)\n                    break;\n\n                /* 32-bit alignment */\n                name_entry_padding = 0;\n                if (name_entry_len%4 != 0)\n                    name_entry_padding = 4-(name_entry_len%4);\n\n                if (msg_tlen < addr_size + name_entry_len + name_entry_padding)\n                    goto trunc;\n\n                ND_TCHECK2(*msg_data, addr_size + name_entry_len + name_entry_padding);\n\n                if (is_ipv6)\n                    ND_PRINT((ndo, \", address %s, name \\\"\",\n                            ip6addr_string(ndo, msg_data)));\n                else\n                    ND_PRINT((ndo, \", address %s, name \\\"\",\n                            ipaddr_string(ndo, msg_data)));\n                (void)fn_printn(ndo, msg_data + addr_size, name_entry_len, NULL);\n                ND_PRINT((ndo, \"\\\"\"));\n\n                msg_data += addr_size + name_entry_len + name_entry_padding;\n                msg_tlen -= addr_size + name_entry_len + name_entry_padding;\n            } /* for (i = 0; i < name_entries; i++) */\n            break;\n        } /* case OLSR_NAMESERVICE_MSG */\n\n            /*\n             * FIXME those are the defined messages that lack a decoder\n             * you are welcome to contribute code ;-)\n             */\n        case OLSR_POWERINFO_MSG:\n        default:\n            print_unknown_data(ndo, msg_data, \"\\n\\t    \", msg_tlen);\n            break;\n        } /* switch (msg_type) */\n        tptr += msg_len;\n    } /* while (tptr < (pptr+length)) */\n\n    return;\n\n trunc:\n    ND_PRINT((ndo, \"[|olsr]\"));\n}\n",
        "fix": null,
        "src_path": "0cb1b8a434b599b8d636db029aadb757c24e39d6___print-olsr.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/0cb1b8a434b599b8d636db029aadb757c24e39d6",
        "commit_msg": "CVE-2017-13688/OLSR: Do bounds checks before we fetch data.\n\nWhile we're at it, clean up some other bounds checks, so we check that\nwe have a complete IPv4 message header if it's IPv4 and a complete IPv6\nmessage header if it's IPv6.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd tests using the capture files supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -575,6 +575,8 @@ lldp_8023_mtu-oobr\tlldp_8023_mtu-oobr.pcap\tlldp_8023_mtu-oobr.out\t-v -c1\n bgp_vpn_rt-oobr\tbgp_vpn_rt-oobr.pcap\tbgp_vpn_rt-oobr.out\t-v -c1\n cfm_sender_id-oobr\tcfm_sender_id-oobr.pcap\tcfm_sender_id-oobr.out\t-v -c1\n isis-extd-isreach-oobr\tisis-extd-isreach-oobr.pcap\tisis-extd-isreach-oobr.out -v -c4\n+olsr-oobr-1\t\tolsr-oobr-1.pcap\t\tolsr-oobr-1.out\t-v\n+olsr-oobr-2\t\tolsr-oobr-2.pcap\t\tolsr-oobr-2.out\t-v\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/olsr-oobr-1.out",
                "patch": "@@ -0,0 +1,16 @@\n+IP truncated-ip - 2315 bytes missing! (tos 0x0, ttl 18, id 4111, offset 0, flags [+, DF, rsvd], proto UDP (17), length 5373, bad cksum 8e7f (->9764)!)\n+    15.251.128.192.698 > 193.192.186.0.122: OLSRv4, seq 0x0800, length 2056\n+\tNameservice Message (0x82), originator 126.198.193.192, ttl 26, hop 145\n+\t  vtime 0.062s, msg-seq 0x0008, length 127[|olsr]\n+IP truncated-ip - 2315 bytes missing! (tos 0x0, ttl 18, id 4111, offset 0, flags [+, DF, rsvd], proto UDP (17), length 5373, bad cksum 8e7f (->975f)!)\n+    16.0.128.192.698 > 193.192.186.0.122: OLSRv4, seq 0x0400, length 512\n+\tPowerinfo Message (0x80), originator 0.1.0.0, ttl 255, hop 255\n+\t  vtime 0.500s, msg-seq 0x0000, length 9216 (invalid)\n+IP truncated-ip - 2315 bytes missing! (tos 0x0, ttl 18, id 4111, offset 0, flags [+, DF, rsvd], proto UDP (17), length 5373, bad cksum 8e7f (->9764)!)\n+    15.251.128.192.698 > 193.192.186.0.122: OLSRv4, seq 0x0800, length 2056\n+\tNameservice Message (0x82), originator 126.198.193.192, ttl 26, hop 145\n+\t  vtime 0.062s, msg-seq 0x0008, length 100[|olsr]\n+IP truncated-ip - 2315 bytes missing! (tos 0x0, ttl 18, id 4111, offset 0, flags [+, DF, rsvd], proto UDP (17), length 5373, bad cksum 8e7f (->975f)!)\n+    16.0.128.192.698 > 193.192.186.0.122: OLSRv4, seq 0x0800, length 2056\n+\tNameservice Message (0x82), originator 126.198.193.192, ttl 26, hop 145\n+\t  vtime 0.062s, msg-seq 0x5c50, length 185[|olsr]"
            },
            {
                "fn": "tests/olsr-oobr-2.out",
                "patch": "@@ -0,0 +1,3 @@\n+[|ether]\n+[|ether]\n+IP6 (flowlabel 0x06400, hlim 0, next-header UDP (17) payload length: 5401) 0:24::1e:a0a:141e.698 > 38fd:7f49:eaff:ffff:2025:7373:7562:2573.2: OLSRv6, seq 0x0201, length 5393[|olsr]"
            }
        ],
        "error_msg": "    olsr-oobr-2                        : TEST FAILED(exit 256)\n"
    },
    "522ebfa7cee96fb325a22ea3a2464a63485886a8___resolve.c": {
        "start": 202,
        "end": 594,
        "buggy": "static int lookupName(\n  Parse *pParse,       /* The parsing context */\n  const char *zDb,     /* Name of the database containing table, or NULL */\n  const char *zTab,    /* Name of table containing column, or NULL */\n  const char *zCol,    /* Name of the column. */\n  NameContext *pNC,    /* The name context used to resolve the name */\n  Expr *pExpr          /* Make this EXPR node point to the selected column */\n){\n  int i, j;                         /* Loop counters */\n  int cnt = 0;                      /* Number of matching column names */\n  int cntTab = 0;                   /* Number of matching table names */\n  int nSubquery = 0;                /* How many levels of subquery */\n  sqlite3 *db = pParse->db;         /* The database connection */\n  struct SrcList_item *pItem;       /* Use for looping over pSrcList items */\n  struct SrcList_item *pMatch = 0;  /* The matching pSrcList item */\n  NameContext *pTopNC = pNC;        /* First namecontext in the list */\n  Schema *pSchema = 0;              /* Schema of the expression */\n  int eNewExprOp = TK_COLUMN;       /* New value for pExpr->op on success */\n  Table *pTab = 0;                  /* Table hold the row */\n  Column *pCol;                     /* A column of pTab */\n\n  assert( pNC );     /* the name context cannot be NULL. */\n  assert( zCol );    /* The Z in X.Y.Z cannot be NULL */\n  assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );\n\n  /* Initialize the node to no-match */\n  pExpr->iTable = -1;\n  ExprSetVVAProperty(pExpr, EP_NoReduce);\n\n  /* Translate the schema name in zDb into a pointer to the corresponding\n  ** schema.  If not found, pSchema will remain NULL and nothing will match\n  ** resulting in an appropriate error message toward the end of this routine\n  */\n  if( zDb ){\n    testcase( pNC->ncFlags & NC_PartIdx );\n    testcase( pNC->ncFlags & NC_IsCheck );\n    if( (pNC->ncFlags & (NC_PartIdx|NC_IsCheck))!=0 ){\n      /* Silently ignore database qualifiers inside CHECK constraints and\n      ** partial indices.  Do not raise errors because that might break\n      ** legacy and because it does not hurt anything to just ignore the\n      ** database name. */\n      zDb = 0;\n    }else{\n      for(i=0; i<db->nDb; i++){\n        assert( db->aDb[i].zDbSName );\n        if( sqlite3StrICmp(db->aDb[i].zDbSName,zDb)==0 ){\n          pSchema = db->aDb[i].pSchema;\n          break;\n        }\n      }\n    }\n  }\n\n  /* Start at the inner-most context and move outward until a match is found */\n  assert( pNC && cnt==0 );\n  do{\n    ExprList *pEList;\n    SrcList *pSrcList = pNC->pSrcList;\n\n    if( pSrcList ){\n      for(i=0, pItem=pSrcList->a; i<pSrcList->nSrc; i++, pItem++){\n        pTab = pItem->pTab;\n        assert( pTab!=0 && pTab->zName!=0 );\n        assert( pTab->nCol>0 );\n        if( pItem->pSelect && (pItem->pSelect->selFlags & SF_NestedFrom)!=0 ){\n          int hit = 0;\n          pEList = pItem->pSelect->pEList;\n          for(j=0; j<pEList->nExpr; j++){\n            if( sqlite3MatchSpanName(pEList->a[j].zSpan, zCol, zTab, zDb) ){\n              cnt++;\n              cntTab = 2;\n              pMatch = pItem;\n              pExpr->iColumn = j;\n              hit = 1;\n            }\n          }\n          if( hit || zTab==0 ) continue;\n        }\n        if( zDb && pTab->pSchema!=pSchema ){\n          continue;\n        }\n        if( zTab ){\n          const char *zTabName = pItem->zAlias ? pItem->zAlias : pTab->zName;\n          assert( zTabName!=0 );\n          if( sqlite3StrICmp(zTabName, zTab)!=0 ){\n            continue;\n          }\n          if( IN_RENAME_OBJECT && pItem->zAlias ){\n            sqlite3RenameTokenRemap(pParse, 0, (void*)&pExpr->y.pTab);\n          }\n        }\n        if( 0==(cntTab++) ){\n          pMatch = pItem;\n        }\n        for(j=0, pCol=pTab->aCol; j<pTab->nCol; j++, pCol++){\n          if( sqlite3StrICmp(pCol->zName, zCol)==0 ){\n            /* If there has been exactly one prior match and this match\n            ** is for the right-hand table of a NATURAL JOIN or is in a \n            ** USING clause, then skip this match.\n            */\n            if( cnt==1 ){\n              if( pItem->fg.jointype & JT_NATURAL ) continue;\n              if( nameInUsingClause(pItem->pUsing, zCol) ) continue;\n            }\n            cnt++;\n            pMatch = pItem;\n            /* Substitute the rowid (column -1) for the INTEGER PRIMARY KEY */\n            pExpr->iColumn = j==pTab->iPKey ? -1 : (i16)j;\n            break;\n          }\n        }\n      }\n      if( pMatch ){\n        pExpr->iTable = pMatch->iCursor;\n        pExpr->y.pTab = pMatch->pTab;\n        /* RIGHT JOIN not (yet) supported */\n        assert( (pMatch->fg.jointype & JT_RIGHT)==0 );\n        if( (pMatch->fg.jointype & JT_LEFT)!=0 ){\n          ExprSetProperty(pExpr, EP_CanBeNull);\n        }\n        pSchema = pExpr->y.pTab->pSchema;\n      }\n    } /* if( pSrcList ) */\n\n#if !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT)\n    /* If we have not already resolved the name, then maybe \n    ** it is a new.* or old.* trigger argument reference.  Or\n    ** maybe it is an excluded.* from an upsert.\n    */\n    if( zDb==0 && zTab!=0 && cntTab==0 ){\n      pTab = 0;\n#ifndef SQLITE_OMIT_TRIGGER\n      if( pParse->pTriggerTab!=0 ){\n        int op = pParse->eTriggerOp;\n        assert( op==TK_DELETE || op==TK_UPDATE || op==TK_INSERT );\n        if( op!=TK_DELETE && sqlite3StrICmp(\"new\",zTab) == 0 ){\n          pExpr->iTable = 1;\n          pTab = pParse->pTriggerTab;\n        }else if( op!=TK_INSERT && sqlite3StrICmp(\"old\",zTab)==0 ){\n          pExpr->iTable = 0;\n          pTab = pParse->pTriggerTab;\n        }\n      }\n#endif /* SQLITE_OMIT_TRIGGER */\n#ifndef SQLITE_OMIT_UPSERT\n      if( (pNC->ncFlags & NC_UUpsert)!=0 ){\n        Upsert *pUpsert = pNC->uNC.pUpsert;\n        if( pUpsert && sqlite3StrICmp(\"excluded\",zTab)==0 ){\n          pTab = pUpsert->pUpsertSrc->a[0].pTab;\n          pExpr->iTable = 2;\n        }\n      }\n#endif /* SQLITE_OMIT_UPSERT */\n\n      if( pTab ){ \n        int iCol;\n        pSchema = pTab->pSchema;\n        cntTab++;\n        for(iCol=0, pCol=pTab->aCol; iCol<pTab->nCol; iCol++, pCol++){\n          if( sqlite3StrICmp(pCol->zName, zCol)==0 ){\n            if( iCol==pTab->iPKey ){\n              iCol = -1;\n            }\n            break;\n          }\n        }\n        if( iCol>=pTab->nCol && sqlite3IsRowid(zCol) && VisibleRowid(pTab) ){\n          /* IMP: R-51414-32910 */\n          iCol = -1;\n        }\n        if( iCol<pTab->nCol ){\n          cnt++;\n#ifndef SQLITE_OMIT_UPSERT\n          if( pExpr->iTable==2 ){\n            testcase( iCol==(-1) );\n            if( IN_RENAME_OBJECT ){\n              pExpr->iColumn = iCol;\n              pExpr->y.pTab = pTab;\n              eNewExprOp = TK_COLUMN;\n            }else{\n              pExpr->iTable = pNC->uNC.pUpsert->regData + iCol;\n              eNewExprOp = TK_REGISTER;\n              ExprSetProperty(pExpr, EP_Alias);\n            }\n          }else\n#endif /* SQLITE_OMIT_UPSERT */\n          {\n#ifndef SQLITE_OMIT_TRIGGER\n            if( iCol<0 ){\n              pExpr->affExpr = SQLITE_AFF_INTEGER;\n            }else if( pExpr->iTable==0 ){\n              testcase( iCol==31 );\n              testcase( iCol==32 );\n              pParse->oldmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));\n            }else{\n              testcase( iCol==31 );\n              testcase( iCol==32 );\n              pParse->newmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));\n            }\n            pExpr->y.pTab = pTab;\n            pExpr->iColumn = (i16)iCol;\n            eNewExprOp = TK_TRIGGER;\n#endif /* SQLITE_OMIT_TRIGGER */\n          }\n        }\n      }\n    }\n#endif /* !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT) */\n\n    /*\n    ** Perhaps the name is a reference to the ROWID\n    */\n    if( cnt==0\n     && cntTab==1\n     && pMatch\n     && (pNC->ncFlags & (NC_IdxExpr|NC_GenCol))==0\n     && sqlite3IsRowid(zCol)\n     && VisibleRowid(pMatch->pTab)\n    ){\n      cnt = 1;\n      pExpr->iColumn = -1;\n      pExpr->affExpr = SQLITE_AFF_INTEGER;\n    }\n\n    /*\n    ** If the input is of the form Z (not Y.Z or X.Y.Z) then the name Z\n    ** might refer to an result-set alias.  This happens, for example, when\n    ** we are resolving names in the WHERE clause of the following command:\n    **\n    **     SELECT a+b AS x FROM table WHERE x<10;\n    **\n    ** In cases like this, replace pExpr with a copy of the expression that\n    ** forms the result set entry (\"a+b\" in the example) and return immediately.\n    ** Note that the expression in the result set should have already been\n    ** resolved by the time the WHERE clause is resolved.\n    **\n    ** The ability to use an output result-set column in the WHERE, GROUP BY,\n    ** or HAVING clauses, or as part of a larger expression in the ORDER BY\n    ** clause is not standard SQL.  This is a (goofy) SQLite extension, that\n    ** is supported for backwards compatibility only. Hence, we issue a warning\n    ** on sqlite3_log() whenever the capability is used.\n    */\n    if( (pNC->ncFlags & NC_UEList)!=0\n     && cnt==0\n     && zTab==0\n    ){\n      pEList = pNC->uNC.pEList;\n      assert( pEList!=0 );\n      for(j=0; j<pEList->nExpr; j++){\n        char *zAs = pEList->a[j].zName;\n        if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){\n          Expr *pOrig;\n          assert( pExpr->pLeft==0 && pExpr->pRight==0 );\n          assert( pExpr->x.pList==0 );\n          assert( pExpr->x.pSelect==0 );\n          pOrig = pEList->a[j].pExpr;\n          if( (pNC->ncFlags&NC_AllowAgg)==0 && ExprHasProperty(pOrig, EP_Agg) ){\n            sqlite3ErrorMsg(pParse, \"misuse of aliased aggregate %s\", zAs);\n            return WRC_Abort;\n          }\n          if( (pNC->ncFlags&NC_AllowWin)==0 && ExprHasProperty(pOrig, EP_Win) ){\n            sqlite3ErrorMsg(pParse, \"misuse of aliased window function %s\",zAs);\n            return WRC_Abort;\n          }\n          if( sqlite3ExprVectorSize(pOrig)!=1 ){\n            sqlite3ErrorMsg(pParse, \"row value misused\");\n            return WRC_Abort;\n          }\n          resolveAlias(pParse, pEList, j, pExpr, \"\", nSubquery);\n          cnt = 1;\n          pMatch = 0;\n          assert( zTab==0 && zDb==0 );\n          if( IN_RENAME_OBJECT ){\n            sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);\n          }\n          goto lookupname_end;\n        }\n      } \n    }\n\n    /* Advance to the next name context.  The loop will exit when either\n    ** we have a match (cnt>0) or when we run out of name contexts.\n    */\n    if( cnt ) break;\n    pNC = pNC->pNext;\n    nSubquery++;\n  }while( pNC );\n\n\n  /*\n  ** If X and Y are NULL (in other words if only the column name Z is\n  ** supplied) and the value of Z is enclosed in double-quotes, then\n  ** Z is a string literal if it doesn't match any column names.  In that\n  ** case, we need to return right away and not make any changes to\n  ** pExpr.\n  **\n  ** Because no reference was made to outer contexts, the pNC->nRef\n  ** fields are not changed in any context.\n  */\n  if( cnt==0 && zTab==0 ){\n    assert( pExpr->op==TK_ID );\n    if( ExprHasProperty(pExpr,EP_DblQuoted)\n     && areDoubleQuotedStringsEnabled(db, pTopNC)\n    ){\n      /* If a double-quoted identifier does not match any known column name,\n      ** then treat it as a string.\n      **\n      ** This hack was added in the early days of SQLite in a misguided attempt\n      ** to be compatible with MySQL 3.x, which used double-quotes for strings.\n      ** I now sorely regret putting in this hack. The effect of this hack is\n      ** that misspelled identifier names are silently converted into strings\n      ** rather than causing an error, to the frustration of countless\n      ** programmers. To all those frustrated programmers, my apologies.\n      **\n      ** Someday, I hope to get rid of this hack. Unfortunately there is\n      ** a huge amount of legacy SQL that uses it. So for now, we just\n      ** issue a warning.\n      */\n      sqlite3_log(SQLITE_WARNING,\n        \"double-quoted string literal: \\\"%w\\\"\", zCol);\n#ifdef SQLITE_ENABLE_NORMALIZE\n      sqlite3VdbeAddDblquoteStr(db, pParse->pVdbe, zCol);\n#endif\n      pExpr->op = TK_STRING;\n      pExpr->y.pTab = 0;\n      return WRC_Prune;\n    }\n    if( sqlite3ExprIdToTrueFalse(pExpr) ){\n      return WRC_Prune;\n    }\n  }\n\n  /*\n  ** cnt==0 means there was not match.  cnt>1 means there were two or\n  ** more matches.  Either way, we have an error.\n  */\n  if( cnt!=1 ){\n    const char *zErr;\n    zErr = cnt==0 ? \"no such column\" : \"ambiguous column name\";\n    if( zDb ){\n      sqlite3ErrorMsg(pParse, \"%s: %s.%s.%s\", zErr, zDb, zTab, zCol);\n    }else if( zTab ){\n      sqlite3ErrorMsg(pParse, \"%s: %s.%s\", zErr, zTab, zCol);\n    }else{\n      sqlite3ErrorMsg(pParse, \"%s: %s\", zErr, zCol);\n    }\n    pParse->checkSchema = 1;\n    pTopNC->nErr++;\n  }\n\n  /* If a column from a table in pSrcList is referenced, then record\n  ** this fact in the pSrcList.a[].colUsed bitmask.  Column 0 causes\n  ** bit 0 to be set.  Column 1 sets bit 1.  And so forth.  If the\n  ** column number is greater than the number of bits in the bitmask\n  ** then set the high-order bit of the bitmask.\n  */\n  if( pExpr->iColumn>=0 && pMatch!=0 ){\n    int n = pExpr->iColumn;\n    testcase( n==BMS-1 );\n    if( n>=BMS ){\n      n = BMS-1;\n    }\n    assert( pMatch->iCursor==pExpr->iTable );\n    pMatch->colUsed |= ((Bitmask)1)<<n;\n  }\n\n  /* Clean up and return\n  */\n  sqlite3ExprDelete(db, pExpr->pLeft);\n  pExpr->pLeft = 0;\n  sqlite3ExprDelete(db, pExpr->pRight);\n  pExpr->pRight = 0;\n  pExpr->op = eNewExprOp;\n  ExprSetProperty(pExpr, EP_Leaf);\nlookupname_end:\n  if( cnt==1 ){\n    assert( pNC!=0 );\n    if( !ExprHasProperty(pExpr, EP_Alias) ){\n      sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);\n    }\n    /* Increment the nRef value on all name contexts from TopNC up to\n    ** the point where the name matched. */\n    for(;;){\n      assert( pTopNC!=0 );\n      pTopNC->nRef++;\n      if( pTopNC==pNC ) break;\n      pTopNC = pTopNC->pNext;\n    }\n    return WRC_Prune;\n  } else {\n    return WRC_Abort;\n  }\n}\n",
        "fix": null,
        "src_path": "522ebfa7cee96fb325a22ea3a2464a63485886a8___resolve.c",
        "uri": "https://api.github.com/repos/sqlite/sqlite/commits/522ebfa7cee96fb325a22ea3a2464a63485886a8",
        "commit_msg": "Whenever a generated column is used, assume that all columns are used.\n\nFossilOrigin-Name: 6601da58032d18ae00b466c0f2077fb2b1ecd84225b56e1787724bea478eedc9",
        "test_func_diff": [
            {
                "fn": "test/gencol1.test",
                "patch": "@@ -246,14 +246,19 @@ do_catchsql_test gencol1-8.20 {\n # 2019-11-21 Problems in the new generated column logic\n # reported by Yongheng Chen and Rui Zhong\n do_execsql_test gencol1-9.10 {\n-  DROP TABLE IF EXISTS t1;\n-  DROP TABLE IF EXISTS t2;\n+  DROP TABLE t1;\n   CREATE TABLE t1(aa , bb AS (17) UNIQUE);\n   INSERT INTO t1 VALUES(17);\n   CREATE TABLE t2(cc);\n   INSERT INTO t2 VALUES(41);\n   SELECT * FROM t2 JOIN t1 WHERE t1.bb=t1.aa AND t1.bb=17;\n } {41 17 17}\n-\n+do_execsql_test gencol1-9.20 {\n+  CREATE TABLE t3(aa INT PRIMARY KEY, bb UNIQUE AS(aa));\n+  INSERT INTO t3 VALUES(1);\n+  SELECT 100, * FROM t3;\n+  DELETE FROM t3 WHERE (SELECT bb FROM t3);\n+  SELECT 200, * FROM t3;\n+} {100 1 1}\n \n finish_test"
            }
        ],
        "error_msg": "warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\ngencol1-9.20...\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000559e4f188c8f in sqlite3VdbeCursorMoveto ()\n"
    },
    "926f796e8feec15f3836aa0a060ed906f8ae04d3___resolve.c": {
        "start": 623,
        "end": 639,
        "buggy": "Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){\n  Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);\n  if( p ){\n    struct SrcList_item *pItem = &pSrc->a[iSrc];\n    p->y.pTab = pItem->pTab;\n    p->iTable = pItem->iCursor;\n    if( p->y.pTab->iPKey==iCol ){\n      p->iColumn = -1;\n    }else{\n      p->iColumn = (ynVar)iCol;\n      testcase( iCol==BMS );\n      testcase( iCol==BMS-1 );\n      pItem->colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);\n    }\n  }\n  return p;\n}\n",
        "fix": null,
        "src_path": "926f796e8feec15f3836aa0a060ed906f8ae04d3___resolve.c",
        "uri": "https://api.github.com/repos/sqlite/sqlite/commits/926f796e8feec15f3836aa0a060ed906f8ae04d3",
        "commit_msg": "Ensure that the SrcList_item.colUsed field is set correctly (set to have a\n1 for all columns of the table) when a generated column appears in the USING\nclause of a join.\n\nFossilOrigin-Name: 1923efb283e8840fa7436eb20b9d2174ef7cace1690d3b97b572a0db2048b8e3",
        "test_func_diff": [
            {
                "fn": "test/gencol1.test",
                "patch": "@@ -342,4 +342,19 @@ do_execsql_test gencol1-12.10 {\n   PRAGMA integrity_check;\n } {ok}\n \n+# 2019-12-09 but report from Yongheng Chen\n+# Ensure that the SrcList_item.colUsed field is set correctly when a\n+# generated column appears in the USING clause of a join.\n+#\n+do_execsql_test gencol1-13.10 {\n+  CREATE TABLE t1(x, y AS(x+1));\n+  INSERT INTO t1 VALUES(10);\n+  SELECT y FROM t1 JOIN t1 USING (y,y);\n+} {11}\n+do_execsql_test gencol1-13.11 {\n+  CREATE INDEX t1y ON t1(y);\n+  SELECT y FROM t1 JOIN t1 USING (y,y);\n+} {11}\n+\n+\n finish_test"
            }
        ],
        "error_msg": "warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\ngencol1-13.10...\n! gencol1-13.10 expected: [11]\n! gencol1-13.10 got:      []\n[Detaching after fork from child process 76627]\nSQLite 2019-12-09 17:14:48 1923efb283e8840fa7436eb20b9d2174ef7cace1690d3b97b572a0db2048b8e3\n1 errors out of 103 tests on deef54515472 Linux 64-bit little-endian\n!Failures on these tests: gencol1-13.10\nAll memory allocations freed - no leaks\nMemory used:          now          0  max     342200  max-size     120000\nAllocation count:     now          0  max        382\nPage-cache used:      now          0  max          0  max-size       1288\nPage-cache overflow:  now          0  max      14688\nMaximum memory usage: 342200 bytes\nCurrent memory usage: 0 bytes\nNumber of malloc()  : -1 calls\n[Inferior 1 (process 76444) exited with code 01]\n"
    },
    "f25486c3d4aa472fec79150f2c41ed4333395d3d___jpc_t2cod.c": {
        "start": 223,
        "end": 323,
        "buggy": "static int jpc_pi_nextrpcl(register jpc_pi_t *pi)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_pchg_t *pchg;\n\tint prchind;\n\tint prcvind;\n\tint *prclyrno;\n\tint compno;\n\tjpc_picomp_t *picomp;\n\tint xstep;\n\tint ystep;\n\tuint_fast32_t r;\n\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\tuint_fast32_t trx0;\n\tuint_fast32_t try0;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->xstep = 0;\n\t\tpi->ystep = 0;\n\t\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t\t  ++compno, ++picomp) {\n\t\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\t\t// Check for the potential for overflow problems.\n\t\t\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >\n\t\t\t\t  JAS_UINTFAST32_NUMBITS - 2 ||\n\t\t\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >\n\t\t\t\t  JAS_UINTFAST32_NUMBITS - 2) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\txstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t\t\t  (pirlvl->prcwidthexpn + picomp->numrlvls - rlvlno - 1));\n\t\t\t\tystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t\t\t  (pirlvl->prcheightexpn + picomp->numrlvls - rlvlno - 1));\n\t\t\t\tpi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);\n\t\t\t\tpi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);\n\t\t\t}\n\t\t}\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pchg->rlvlnoend &&\n\t  pi->rlvlno < pi->maxrlvls; ++pi->rlvlno) {\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend; pi->y +=\n\t\t  pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend; pi->x +=\n\t\t\t  pi->xstep - (pi->x % pi->xstep)) {\n\t\t\t\tfor (pi->compno = pchg->compnostart,\n\t\t\t\t  pi->picomp = &pi->picomps[pi->compno];\n\t\t\t\t  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno <\n\t\t\t\t  pi->numcomps; ++pi->compno, ++pi->picomp) {\n\t\t\t\t\tif (pi->rlvlno >= pi->picomp->numrlvls) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\tif (((pi->x == pi->xstart &&\n\t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx)))\n\t\t\t\t\t  || !(pi->x % (JAS_CAST(uint_fast32_t, 1) << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart &&\n\t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy)))\n\t\t\t\t\t  || !(pi->y % (JAS_CAST(uint_fast32_t, 1) << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,\n\t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,\n\t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;\n\n\t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <\n\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int,\n\t\t\t\t\t\t  pchg->lyrnoend); ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n",
        "fix": null,
        "src_path": "f25486c3d4aa472fec79150f2c41ed4333395d3d___jpc_t2cod.c",
        "uri": "https://api.github.com/repos/mdadams/jasper/commits/f25486c3d4aa472fec79150f2c41ed4333395d3d",
        "commit_msg": "Fixed a bug in the packet iterator code.\nAdded a new regression test case.",
        "test_func_diff": [],
        "error_msg": "AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==30069==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7f802242cf64 bp 0x7ffe608ad2f0 sp 0x7ffe608acb40 T0)\n==30069==The signal is caused by a READ memory access.\n==30069==Hint: address points to the zero page.\n    #0 0x7f802242cf64 in jpc_pi_nextrpcl jpc_t2cod.c\n    #1 0x7f802242a790 in jpc_pi_next (/out/mdadams___jasper/git_repo_dir_f25486c3d4aa472fec79150f2c41ed4333395d3d/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/libjasper/libjasper.so.4+0x116790)\n    #2 0x7f8022436681 in jpc_dec_decodepkts (/out/mdadams___jasper/git_repo_dir_f25486c3d4aa472fec79150f2c41ed4333395d3d/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/libjasper/libjasper.so.4+0x122681)\n    #3 0x7f802239dd16 in jpc_dec_process_sod jpc_dec.c\n    #4 0x7f80223a431f in jpc_dec_decode jpc_dec.c\n    #5 0x7f80223a2ddb in jpc_decode (/out/mdadams___jasper/git_repo_dir_f25486c3d4aa472fec79150f2c41ed4333395d3d/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/libjasper/libjasper.so.4+0x8eddb)\n    #6 0x7f8022353581 in jas_image_decode (/out/mdadams___jasper/git_repo_dir_f25486c3d4aa472fec79150f2c41ed4333395d3d/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/libjasper/libjasper.so.4+0x3f581)\n    #7 0x559ee05c49e5 in main (/out/mdadams___jasper/git_repo_dir_f25486c3d4aa472fec79150f2c41ed4333395d3d/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/appl/imginfo+0xf29e5)\n    #8 0x7f8021ef2082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #9 0x559ee04f13dd in _start (/out/mdadams___jasper/git_repo_dir_f25486c3d4aa472fec79150f2c41ed4333395d3d/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/appl/imginfo+0x1f3dd)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV jpc_t2cod.c in jpc_pi_nextrpcl\n==30069==ABORTING\n"
    },
    "fb0e0cce0b9f25389ab56604c3547351617e1415___gd_tga.c": {
        "start": 206,
        "end": 336,
        "buggy": "int read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tint* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint encoded_pixels;\n\tint rle_size;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\trle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);\n\t\tif (rle_size <= 0) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < rle_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n\t\t\t\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));\n\t\t\t\t\tbitmap_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));\n\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n",
        "fix": null,
        "src_path": "fb0e0cce0b9f25389ab56604c3547351617e1415___gd_tga.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/fb0e0cce0b9f25389ab56604c3547351617e1415",
        "commit_msg": "Fix OOB reads of the TGA decompression buffer\n\nIt is possible to craft TGA files which will overflow the decompression\nbuffer, but not the image's bitmap. Therefore we augment the check for the\nbitmap's overflow with a check for the buffer's overflow.\n\nThis issue had been reported by Ibrahim El-Sayed to security@libgd.org.\n\nCVE-2016-6906",
        "test_func_diff": [
            {
                "fn": "tests/tga/.gitignore",
                "patch": "@@ -3,5 +3,6 @@\n /bug00247a\n /bug00248\n /bug00248a\n+/heap_overflow\n /tga_null\n /tga_read"
            },
            {
                "fn": "tests/tga/CMakeLists.txt",
                "patch": "@@ -5,6 +5,7 @@ LIST(APPEND TESTS_FILES\n \tbug00247a\n \tbug00248\n \tbug00248a\n+\theap_overflow\n \ttga_read\n )\n "
            },
            {
                "fn": "tests/tga/Makemodule.am",
                "patch": "@@ -4,6 +4,7 @@ libgd_test_programs += \\\n \ttga/bug00247a \\\n \ttga/bug00248 \\\n \ttga/bug00248a \\\n+\ttga/heap_overflow \\\n \ttga/tga_null \\\n \ttga/tga_read\n \n@@ -14,6 +15,7 @@ EXTRA_DIST += \\\n \ttga/bug00247a.tga \\\n \ttga/bug00248.tga \\\n \ttga/bug00248a.tga \\\n+\ttga/heap_overflow.tga \\\n \ttga/tga_read_rgb.png \\\n \ttga/tga_read_rgb.tga \\\n \ttga/tga_read_rgb_rle.tga"
            },
            {
                "fn": "tests/tga/heap_overflow.c",
                "patch": "@@ -0,0 +1,51 @@\n+/**\n+ * Test that the crafted TGA file doesn't trigger OOB reads.\n+ */\n+\n+\n+#include \"gd.h\"\n+#include \"gdtest.h\"\n+\n+\n+static size_t read_test_file(char **buffer, char *basename);\n+\n+\n+int main()\n+{\n+    gdImagePtr im;\n+    char *buffer;\n+    size_t size;\n+\n+    size = read_test_file(&buffer, \"heap_overflow.tga\");\n+    im = gdImageCreateFromTgaPtr(size, (void *) buffer);\n+    gdTestAssert(im == NULL);\n+    free(buffer);\n+\n+    return gdNumFailures();\n+}\n+\n+\n+static size_t read_test_file(char **buffer, char *basename)\n+{\n+    char *filename;\n+    FILE *fp;\n+    size_t exp_size, act_size;\n+\n+    filename = gdTestFilePath2(\"tga\", basename);\n+    fp = fopen(filename, \"rb\");\n+    gdTestAssert(fp != NULL);\n+\n+\tfseek(fp, 0, SEEK_END);\n+\texp_size = ftell(fp);\n+\tfseek(fp, 0, SEEK_SET);\n+\n+    *buffer = malloc(exp_size);\n+    gdTestAssert(*buffer != NULL);\n+    act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);\n+    gdTestAssert(act_size == exp_size);\n+\n+    fclose(fp);\n+    free(filename);\n+\n+    return act_size;\n+}"
            }
        ],
        "error_msg": "========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 152\n# PASS:  149\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  3\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:31: Total pixels changed: 9 with a maximum channel difference of 255.\nfreetype/bug00132.c:33: Reference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\ngdimagestringft/gdimagestringft_bbox.c:56: (491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\nFAIL: tga/heap_overflow\n=======================\n\ntga/heap_overflow.c:21: Assert failed in <tga/heap_overflow.c:21>\nFAIL tga/heap_overflow (exit status: 2)\n\n"
    },
    "fe9ed49dafa993e3af96b6a5a589efeea9bfb36f___gd_gd2.c": {
        "start": 405,
        "end": 566,
        "buggy": "BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)\n{\n\tint sx, sy;\n\tint i;\n\tint ncx, ncy, nc, cs, cx, cy;\n\tint x, y, ylo, yhi, xlo, xhi;\n\tint vers, fmt;\n\tt_chunk_info *chunkIdx = NULL;\t/* So we can gdFree it with impunity. */\n\tunsigned char *chunkBuf = NULL;\t/* So we can gdFree it with impunity. */\n\tint chunkNum = 0;\n\tint chunkMax = 0;\n\tuLongf chunkLen;\n\tint chunkPos = 0;\n\tint compMax = 0;\n\tint bytesPerPixel;\n\tchar *compBuf = NULL;\t\t/* So we can gdFree it with impunity. */\n\n\tgdImagePtr im;\n\n\t/* Get the header */\n\tim =\n\t    _gd2CreateFromFile (in, &sx, &sy, &cs, &vers, &fmt, &ncx, &ncy,\n\t                        &chunkIdx);\n\tif (im == NULL) {\n\t\t/* No need to free chunkIdx as _gd2CreateFromFile does it for us. */\n\t\treturn 0;\n\t}\n\n\tbytesPerPixel = im->trueColor ? 4 : 1;\n\tnc = ncx * ncy;\n\n\tif (gd2_compressed (fmt)) {\n\t\t/* Find the maximum compressed chunk size. */\n\t\tcompMax = 0;\n\t\tfor (i = 0; (i < nc); i++) {\n\t\t\tif (chunkIdx[i].size > compMax) {\n\t\t\t\tcompMax = chunkIdx[i].size;\n\t\t\t};\n\t\t};\n\t\tcompMax++;\n\n\t\t/* Allocate buffers */\n\t\tchunkMax = cs * bytesPerPixel * cs;\n\t\tchunkBuf = gdCalloc (chunkMax, 1);\n\t\tif (!chunkBuf) {\n\t\t\tgoto fail;\n\t\t}\n\t\tcompBuf = gdCalloc (compMax, 1);\n\t\tif (!compBuf) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tGD2_DBG (printf (\"Largest compressed chunk is %d bytes\\n\", compMax));\n\t};\n\n\t/*      if ( (ncx != sx / cs) || (ncy != sy / cs)) { */\n\t/*              goto fail2; */\n\t/*      }; */\n\n\t/* Read the data... */\n\tfor (cy = 0; (cy < ncy); cy++) {\n\t\tfor (cx = 0; (cx < ncx); cx++) {\n\n\t\t\tylo = cy * cs;\n\t\t\tyhi = ylo + cs;\n\t\t\tif (yhi > im->sy) {\n\t\t\t\tyhi = im->sy;\n\t\t\t};\n\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"Processing Chunk %d (%d, %d), y from %d to %d\\n\",\n\t\t\t          chunkNum, cx, cy, ylo, yhi));\n\n\t\t\tif (gd2_compressed (fmt)) {\n\n\t\t\t\tchunkLen = chunkMax;\n\n\t\t\t\tif (!_gd2ReadChunk (chunkIdx[chunkNum].offset,\n\t\t\t\t                    compBuf,\n\t\t\t\t                    chunkIdx[chunkNum].size,\n\t\t\t\t                    (char *) chunkBuf, &chunkLen, in)) {\n\t\t\t\t\tGD2_DBG (printf (\"Error reading comproessed chunk\\n\"));\n\t\t\t\t\tgoto fail;\n\t\t\t\t};\n\n\t\t\t\tchunkPos = 0;\n\t\t\t};\n\n\t\t\tfor (y = ylo; (y < yhi); y++) {\n\n\t\t\t\txlo = cx * cs;\n\t\t\t\txhi = xlo + cs;\n\t\t\t\tif (xhi > im->sx) {\n\t\t\t\t\txhi = im->sx;\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"y=%d: \",y)); */\n\t\t\t\tif (!gd2_compressed (fmt)) {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tif (!gdGetInt (&im->tpixels[y][x], in)) {\n\t\t\t\t\t\t\t\t/*printf(\"EOF while reading\\n\"); */\n\t\t\t\t\t\t\t\t/*gdImageDestroy(im); */\n\t\t\t\t\t\t\t\t/*return 0; */\n\t\t\t\t\t\t\t\tim->tpixels[y][x] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint ch;\n\t\t\t\t\t\t\tif (!gdGetByte (&ch, in)) {\n\t\t\t\t\t\t\t\t/*printf(\"EOF while reading\\n\"); */\n\t\t\t\t\t\t\t\t/*gdImageDestroy(im); */\n\t\t\t\t\t\t\t\t/*return 0; */\n\t\t\t\t\t\t\t\tch = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tim->pixels[y][x] = ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\t/* 2.0.1: work around a gcc bug by being verbose.\n\t\t\t\t\t\t\t   TBB */\n\t\t\t\t\t\t\tint a = chunkBuf[chunkPos++] << 24;\n\t\t\t\t\t\t\tint r = chunkBuf[chunkPos++] << 16;\n\t\t\t\t\t\t\tint g = chunkBuf[chunkPos++] << 8;\n\t\t\t\t\t\t\tint b = chunkBuf[chunkPos++];\n\t\t\t\t\t\t\t/* 2.0.11: tpixels */\n\t\t\t\t\t\t\tim->tpixels[y][x] = a + r + g + b;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tim->pixels[y][x] = chunkBuf[chunkPos++];\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"\\n\")); */\n\t\t\t};\n\t\t\tchunkNum++;\n\t\t};\n\t};\n\n\tGD2_DBG (printf (\"Freeing memory\\n\"));\n\n\tgdFree (chunkBuf);\n\tgdFree (compBuf);\n\tgdFree (chunkIdx);\n\n\tGD2_DBG (printf (\"Done\\n\"));\n\n\treturn im;\n\nfail:\n\tgdImageDestroy (im);\n\tif (chunkBuf) {\n\t\tgdFree (chunkBuf);\n\t}\n\tif (compBuf) {\n\t\tgdFree (compBuf);\n\t}\n\tif (chunkIdx) {\n\t\tgdFree (chunkIdx);\n\t}\n\treturn 0;\n}\n",
        "fix": null,
        "src_path": "fe9ed49dafa993e3af96b6a5a589efeea9bfb36f___gd_gd2.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/fe9ed49dafa993e3af96b6a5a589efeea9bfb36f",
        "commit_msg": "Fix DOS vulnerability in gdImageCreateFromGd2Ctx()\n\nWe must not pretend that there are image data if there are none. Instead\nwe fail reading the image file gracefully.",
        "test_func_diff": [
            {
                "fn": "tests/gd2/.gitignore",
                "patch": "@@ -6,3 +6,4 @@\n /gd2_read\n /gd2_read_corrupt\n /php_bug_72339\n+/too_few_image_data"
            },
            {
                "fn": "tests/gd2/CMakeLists.txt",
                "patch": "@@ -7,6 +7,7 @@ LIST(APPEND TESTS_FILES\n \tphp_bug_72339\n \tgd2_read\n \tgd2_read_corrupt\n+\ttoo_few_image_data\n )\n \n ADD_GD_TESTS()"
            },
            {
                "fn": "tests/gd2/Makemodule.am",
                "patch": "@@ -3,7 +3,8 @@ libgd_test_programs += \\\n \tgd2/bug00309 \\\n \tgd2/gd2_empty_file \\\n \tgd2/php_bug_72339 \\\n-\tgd2/gd2_read_corrupt\n+\tgd2/gd2_read_corrupt \\\n+\tgd2/too_few_image_data\n \n if HAVE_LIBZ\n libgd_test_programs += \\\n@@ -23,4 +24,6 @@ EXTRA_DIST += \\\n \tgd2/conv_test_exp.png \\\n \tgd2/empty.gd2 \\\n \tgd2/invalid_header.gd2 \\\n-\tgd2/invalid_neg_size.gd2\n+\tgd2/invalid_neg_size.gd2 \\\n+\tgd2/php_bug_72339_exp.gd2 \\\n+\tgd2/too_few_image_data.gd2"
            },
            {
                "fn": "tests/gd2/too_few_image_data.c",
                "patch": "@@ -0,0 +1,22 @@\n+/*\n+too_few_image_data.gd2 claims to have a size of 12336x48 pixels, but doesn't\n+provide as much image data. We test that gdImageCreateFromGd2Ctx() returns NULL\n+in this case.\n+*/\n+\n+#include \"gd.h\"\n+#include \"gdtest.h\"\n+\n+int main()\n+{\n+    gdImagePtr im;\n+    FILE *fp;\n+\n+    fp = gdTestFileOpen2(\"gd2\", \"too_few_image_data.gd2\");\n+    gdTestAssert(fp != NULL);\n+    im = gdImageCreateFromGd2(fp);\n+    gdTestAssert(im == NULL);\n+    fclose(fp);\n+\n+    return gdNumFailures();\n+}"
            }
        ],
        "error_msg": "========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 155\n# PASS:  152\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  3\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:31: Total pixels changed: 9 with a maximum channel difference of 255.\nfreetype/bug00132.c:33: Reference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gd2/too_few_image_data\n============================\n\ngd2/too_few_image_data.c:18: Assert failed in <gd2/too_few_image_data.c:18>\nFAIL gd2/too_few_image_data (exit status: 2)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\ngdimagestringft/gdimagestringft_bbox.c:56: (491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\n"
    },
    "a93eac0e843148dc2d631c3ba80af17e9c8c860f___gd.c": {
        "start": 2832,
        "end": 2925,
        "buggy": "BGD_DECLARE(gdImagePtr) gdImageClone (gdImagePtr src) {\n\tgdImagePtr dst;\n\tregister int i, x;\n\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(src->sx , src->sy);\n\t} else {\n\t\tdst = gdImageCreate(src->sx , src->sy);\n\t}\n\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (src->trueColor == 0) {\n\t\tdst->colorsTotal = src->colorsTotal;\n\t\tfor (i = 0; i < gdMaxColors; i++) {\n\t\t\tdst->red[i]   = src->red[i];\n\t\t\tdst->green[i] = src->green[i];\n\t\t\tdst->blue[i]  = src->blue[i];\n\t\t\tdst->alpha[i] = src->alpha[i];\n\t\t\tdst->open[i]  = src->open[i];\n\t\t}\n\t\tfor (i = 0; i < src->sy; i++) {\n\t\t\tfor (x = 0; x < src->sx; x++) {\n\t\t\t\tdst->pixels[i][x] = src->pixels[i][x];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < src->sy; i++) {\n\t\t\tfor (x = 0; x < src->sx; x++) {\n\t\t\t\tdst->tpixels[i][x] = src->tpixels[i][x];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (src->styleLength > 0) {\n\t\tdst->styleLength = src->styleLength;\n\t\tdst->stylePos    = src->stylePos;\n\t\tfor (i = 0; i < src->styleLength; i++) {\n\t\t\tdst->style[i] = src->style[i];\n\t\t}\n\t}\n\n\tdst->interlace   = src->interlace;\n\n\tdst->alphaBlendingFlag = src->alphaBlendingFlag;\n\tdst->saveAlphaFlag     = src->saveAlphaFlag;\n\tdst->AA                = src->AA;\n\tdst->AA_color          = src->AA_color;\n\tdst->AA_dont_blend     = src->AA_dont_blend;\n\n\tdst->cx1 = src->cx1;\n\tdst->cy1 = src->cy1;\n\tdst->cx2 = src->cx2;\n\tdst->cy2 = src->cy2;\n\n\tdst->res_x = src->res_x;\n\tdst->res_y = src->res_y;\n\n\tdst->paletteQuantizationMethod     = src->paletteQuantizationMethod;\n\tdst->paletteQuantizationSpeed      = src->paletteQuantizationSpeed;\n\tdst->paletteQuantizationMinQuality = src->paletteQuantizationMinQuality;\n\tdst->paletteQuantizationMinQuality = src->paletteQuantizationMinQuality;\n\n\tdst->interpolation_id = src->interpolation_id;\n\tdst->interpolation    = src->interpolation;\n\n\tif (src->brush) {\n\t\tdst->brush = gdImageClone(src->brush);\n\t}\n\n\tif (src->tile) {\n\t\tdst->tile = gdImageClone(src->tile);\n\t}\n\n\tif (src->style) {\n\t\tgdImageSetStyle(dst, src->style, src->styleLength);\n\t}\n\n\tfor (i = 0; i < gdMaxColors; i++) {\n\t\tdst->brushColorMap[i] = src->brushColorMap[i];\n\t\tdst->tileColorMap[i] = src->tileColorMap[i];\n\t}\n\n\tif (src->polyAllocated > 0) {\n\t\tdst->polyAllocated = src->polyAllocated;\n\t\tfor (i = 0; i < src->polyAllocated; i++) {\n\t\t\tdst->polyInts[i] = src->polyInts[i];\n\t\t}\n\t}\n\n\treturn dst;\n}\n",
        "fix": null,
        "src_path": "a93eac0e843148dc2d631c3ba80af17e9c8c860f___gd.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/a93eac0e843148dc2d631c3ba80af17e9c8c860f",
        "commit_msg": "Fix potential NULL pointer dereference in gdImageClone()",
        "test_func_diff": [
            {
                "fn": "tests/gdimageclone/.gitignore",
                "patch": "@@ -1 +1,2 @@\n /bug00300\n+/style"
            },
            {
                "fn": "tests/gdimageclone/CMakeLists.txt",
                "patch": "@@ -1,5 +1,6 @@\n LIST(APPEND TESTS_FILES\n \tbug00300\n+\tstyle\n )\n \n ADD_GD_TESTS()"
            },
            {
                "fn": "tests/gdimageclone/Makemodule.am",
                "patch": "@@ -1,5 +1,6 @@\n libgd_test_programs += \\\n-\tgdimageclone/bug00300\n+\tgdimageclone/bug00300 \\\n+\tgdimageclone/style\n \n EXTRA_DIST += \\\n \tgdimageclone/CMakeLists.txt"
            },
            {
                "fn": "tests/gdimageclone/style.c",
                "patch": "@@ -0,0 +1,30 @@\n+/**\n+ * Cloning an image should exactly reproduce all style related data\n+ */\n+\n+\n+#include <string.h>\n+#include \"gd.h\"\n+#include \"gdtest.h\"\n+\n+\n+int main()\n+{\n+    gdImagePtr im, clone;\n+    int style[] = {0, 0, 0};\n+\n+    im = gdImageCreate(8, 8);\n+    gdImageSetStyle(im, style, sizeof(style)/sizeof(style[0]));\n+\n+    clone = gdImageClone(im);\n+    gdTestAssert(clone != NULL);\n+\n+    gdTestAssert(clone->styleLength == im->styleLength);\n+    gdTestAssert(clone->stylePos == im->stylePos);\n+    gdTestAssert(!memcmp(clone->style, im->style, sizeof(style)/sizeof(style[0])));\n+\n+    gdImageDestroy(clone);\n+    gdImageDestroy(im);\n+\n+    return gdNumFailures();\n+}"
            }
        ],
        "error_msg": "========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 191\n# PASS:  190\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  1\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: gdimageclone/style\n========================\n\nFAIL gdimageclone/style (exit status: 139)\n\n"
    },
    "a44c89e8af7c2410f4bfc5e097be2a5d0639a60c___wddx.c": {
        "start": 695,
        "end": 1370,
        "buggy": "static void php_wddx_add_var(wddx_packet *packet, zval *name_var)\n{\n\tzval **val;\n\tHashTable *target_hash;\n\tTSRMLS_FETCH();\n\n\tif (Z_TYPE_P(name_var) == IS_STRING) {\n\t\tif (!EG(active_symbol_table)) {\n\t\t\tzend_rebuild_symbol_table(TSRMLS_C);\n\t\t}\n\t\tif (zend_hash_find(EG(active_symbol_table), Z_STRVAL_P(name_var),\n\t\t\t\t\t\t\tZ_STRLEN_P(name_var)+1, (void**)&val) != FAILURE) {\n\t\t\tphp_wddx_serialize_var(packet, *val, Z_STRVAL_P(name_var), Z_STRLEN_P(name_var) TSRMLS_CC);\n\t\t}\n\t} else if (Z_TYPE_P(name_var) == IS_ARRAY || Z_TYPE_P(name_var) == IS_OBJECT)\t{\n\t\tint is_array = Z_TYPE_P(name_var) == IS_ARRAY;\n\n\t\ttarget_hash = HASH_OF(name_var);\n\n\t\tif (is_array && target_hash->nApplyCount > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"recursion detected\");\n\t\t\treturn;\n\t\t}\n\n\t\tzend_hash_internal_pointer_reset(target_hash);\n\n\t\twhile(zend_hash_get_current_data(target_hash, (void**)&val) == SUCCESS) {\n\t\t\tif (is_array) {\n\t\t\t\ttarget_hash->nApplyCount++;\n\t\t\t}\n\n\t\t\tphp_wddx_add_var(packet, *val);\n\n\t\t\tif (is_array) {\n\t\t\t\ttarget_hash->nApplyCount--;\n\t\t\t}\n\t\t\tzend_hash_move_forward(target_hash);\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_push_element\n */\nstatic void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)\n{\n\tst_entry ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\n\tif (!strcmp(name, EL_PACKET)) {\n\t\tint i;\n\n\t\tif (atts) for (i=0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VERSION)) {\n\t\t\t\t/* nothing for now */\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_STRING)) {\n\t\tent.type = ST_STRING;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BINARY)) {\n\t\tent.type = ST_BINARY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_CHAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_CHAR_CODE) && atts[++i] && atts[i][0]) {\n\t\t\t\tchar tmp_buf[2];\n\n\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i], NULL, 16));\n\t\t\t\tphp_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NUMBER)) {\n\t\tent.type = ST_NUMBER;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\tZ_LVAL_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BOOLEAN)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[++i] && atts[i][0]) {\n\t\t\t\tent.type = ST_BOOLEAN;\n\t\t\t\tSET_STACK_VARNAME;\n\n\t\t\t\tALLOC_ZVAL(ent.data);\n\t\t\t\tINIT_PZVAL(ent.data);\n\t\t\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n\t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t\t\tphp_wddx_process_data(user_data, atts[i], strlen(atts[i]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NULL)) {\n\t\tent.type = ST_NULL;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZVAL_NULL(ent.data);\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_ARRAY)) {\n\t\tent.type = ST_ARRAY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_STRUCT)) {\n\t\tent.type = ST_STRUCT;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_VAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tstack->varname = estrdup(atts[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_RECORDSET)) {\n\t\tint i;\n\n\t\tent.type = ST_RECORDSET;\n\t\tSET_STACK_VARNAME;\n\t\tMAKE_STD_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], \"fieldNames\") && atts[++i] && atts[i][0]) {\n\t\t\t\tzval *tmp;\n\t\t\t\tchar *key;\n\t\t\t\tchar *p1, *p2, *endp;\n\n\t\t\t\tendp = (char *)atts[i] + strlen(atts[i]);\n\t\t\t\tp1 = (char *)atts[i];\n\t\t\t\twhile ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {\n\t\t\t\t\tkey = estrndup(p1, p2 - p1);\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp);\n\t\t\t\t\tp1 = p2 + sizeof(\",\")-1;\n\t\t\t\t\tefree(key);\n\t\t\t\t}\n\n\t\t\t\tif (p1 <= endp) {\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tint i;\n\t\tst_entry ent;\n\n\t\tent.type = ST_FIELD;\n\t\tent.varname = NULL;\n\t\tent.data = NULL;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tst_entry *recordset;\n\t\t\t\tzval **field;\n\n\t\t\t\tif (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i], strlen(atts[i])+1, (void**)&field) == SUCCESS) {\n\t\t\t\t\tent.data = *field;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_DATETIME)) {\n\t\tent.type = ST_DATETIME;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_pop_element\n */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_process_data\n */\nstatic void php_wddx_process_data(void *user_data, const XML_Char *s, int len)\n{\n\tst_entry *ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\tTSRMLS_FETCH();\n\n\tif (!wddx_stack_is_empty(stack) && !stack->done) {\n\t\twddx_stack_top(stack, (void**)&ent);\n\t\tswitch (ent->type) {\n\t\t\tcase ST_STRING:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BINARY:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len + 1);\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t}\n\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase ST_NUMBER:\n\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\tconvert_scalar_to_number(ent->data TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BOOLEAN:\n\t\t\t\tif (!strcmp(s, \"true\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 1;\n\t\t\t\t} else if (!strcmp(s, \"false\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 0;\n\t\t\t\t} else {\n\t\t\t\t\tzval_ptr_dtor(&ent->data);\n\t\t\t\t\tif (ent->varname) {\n\t\t\t\t\t\tefree(ent->varname);\n\t\t\t\t\t}\n\t\t\t\t\tent->data = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_DATETIME: {\n\t\t\t\tchar *tmp;\n\n\t\t\t\ttmp = emalloc(len + 1);\n\t\t\t\tmemcpy(tmp, s, len);\n\t\t\t\ttmp[len] = '\\0';\n\n\t\t\t\tZ_LVAL_P(ent->data) = php_parse_date(tmp, NULL);\n\t\t\t\t/* date out of range < 1969 or > 2038 */\n\t\t\t\tif (Z_LVAL_P(ent->data) == -1) {\n\t\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t}\n\t\t\t\tefree(tmp);\n\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_deserialize_ex\n */\nint php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)\n{\n\twddx_stack stack;\n\tXML_Parser parser;\n\tst_entry *ent;\n\tint retval;\n\n\twddx_stack_init(&stack);\n\tparser = XML_ParserCreate(\"UTF-8\");\n\n\tXML_SetUserData(parser, &stack);\n\tXML_SetElementHandler(parser, php_wddx_push_element, php_wddx_pop_element);\n\tXML_SetCharacterDataHandler(parser, php_wddx_process_data);\n\n\tXML_Parse(parser, value, vallen, 1);\n\n\tXML_ParserFree(parser);\n\n\tif (stack.top == 1) {\n\t\twddx_stack_top(&stack, (void**)&ent);\n\t\t*return_value = *(ent->data);\n\t\tzval_copy_ctor(return_value);\n\t\tretval = SUCCESS;\n\t} else {\n\t\tretval = FAILURE;\n\t}\n\n\twddx_stack_destroy(&stack);\n\n\treturn retval;\n}\n/* }}} */\n\n/* {{{ proto string wddx_serialize_value(mixed var [, string comment])\n   Creates a new packet and serializes the given value */\nPHP_FUNCTION(wddx_serialize_value)\n{\n\tzval *var;\n\tchar *comment = NULL;\n\tint comment_len = 0;\n\twddx_packet *packet;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|s\", &var, &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, comment, comment_len);\n\tphp_wddx_serialize_var(packet, var, NULL, 0 TSRMLS_CC);\n\tphp_wddx_packet_end(packet);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ proto string wddx_serialize_vars(mixed var_name [, mixed ...])\n   Creates a new packet and serializes given variables into a struct */\nPHP_FUNCTION(wddx_serialize_vars)\n{\n\tint num_args, i;\n\twddx_packet *packet;\n\tzval ***args = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"+\", &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, NULL, 0);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, *args[i]);\n\t}\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\tphp_wddx_packet_end(packet);\n\n\tefree(args);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ php_wddx_constructor\n */\nwddx_packet *php_wddx_constructor(void)\n{\n\tsmart_str *packet;\n\n\tpacket = (smart_str *)emalloc(sizeof(smart_str));\n\tpacket->c = NULL;\n\n\treturn packet;\n}\n/* }}} */\n\n/* {{{ php_wddx_destructor\n */\nvoid php_wddx_destructor(wddx_packet *packet)\n{\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ proto resource wddx_packet_start([string comment])\n   Starts a WDDX packet with optional comment and returns the packet id */\nPHP_FUNCTION(wddx_packet_start)\n{\n\tchar *comment = NULL;\n\tint comment_len = 0;\n\twddx_packet *packet;\n\n\tcomment = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, comment, comment_len);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tZEND_REGISTER_RESOURCE(return_value, packet, le_wddx);\n}\n/* }}} */\n\n/* {{{ proto string wddx_packet_end(resource packet_id)\n   Ends specified WDDX packet and returns the string containing the packet */\nPHP_FUNCTION(wddx_packet_end)\n{\n\tzval *packet_id;\n\twddx_packet *packet = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &packet_id) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(packet, wddx_packet *, &packet_id, -1, \"WDDX packet ID\", le_wddx);\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\n\tphp_wddx_packet_end(packet);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\n\tzend_list_delete(Z_LVAL_P(packet_id));\n}\n/* }}} */\n\n/* {{{ proto int wddx_add_vars(resource packet_id,  mixed var_names [, mixed ...])\n   Serializes given variables and adds them to packet given by packet_id */\nPHP_FUNCTION(wddx_add_vars)\n{\n\tint num_args, i;\n\tzval ***args = NULL;\n\tzval *packet_id;\n\twddx_packet *packet = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r+\", &packet_id, &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!ZEND_FETCH_RESOURCE_NO_RETURN(packet, wddx_packet *, &packet_id, -1, \"WDDX packet ID\", le_wddx)) {\n\t\tefree(args);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!packet) {\n\t\tefree(args);\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, (*args[i]));\n\t}\n\n\tefree(args);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto mixed wddx_deserialize(mixed packet)\n   Deserializes given packet and returns a PHP value */\nPHP_FUNCTION(wddx_deserialize)\n{\n\tzval *packet;\n\tchar *payload;\n\tint payload_len;\n\tphp_stream *stream = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &packet) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (Z_TYPE_P(packet) == IS_STRING) {\n\t\tpayload \t= Z_STRVAL_P(packet);\n\t\tpayload_len = Z_STRLEN_P(packet);\n\t} else if (Z_TYPE_P(packet) == IS_RESOURCE) {\n\t\tphp_stream_from_zval(stream, &packet);\n\t\tif (stream) {\n\t\t\tpayload_len = php_stream_copy_to_mem(stream, &payload, PHP_STREAM_COPY_ALL, 0);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Expecting parameter 1 to be a string or a stream\");\n\t\treturn;\n\t}\n\n\tif (payload_len == 0) {\n\t\treturn;\n\t}\n\n\tphp_wddx_deserialize_ex(payload, payload_len, return_value);\n\n\tif (stream) {\n\t\tpefree(payload, 0);\n\t}\n}\n",
        "fix": null,
        "src_path": "a44c89e8af7c2410f4bfc5e097be2a5d0639a60c___wddx.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/a44c89e8af7c2410f4bfc5e097be2a5d0639a60c",
        "commit_msg": "Fix bug #72340: Double Free Courruption in wddx_deserialize",
        "test_func_diff": [
            {
                "fn": "ext/wddx/tests/bug72340.phpt",
                "patch": "@@ -0,0 +1,24 @@\n+--TEST--\n+Bug #72340: Double Free Courruption in wddx_deserialize\n+--SKIPIF--\n+<?php\n+if (!extension_loaded(\"wddx\")) print \"skip\";\n+?>\n+--FILE--\n+<?php\n+$xml = <<<EOF\n+<?xml version='1.0' ?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+\t<array><var name=\"XXXXXXXX\"><boolean value=\"none\">TEST</boolean></var>\n+\t\t<var name=\"YYYYYYYY\"><var name=\"ZZZZZZZZ\"><var name=\"EZEZEZEZ\">\n+\t\t</var></var></var>\n+\t</array>\n+</wddxPacket>\n+EOF;\n+$array = wddx_deserialize($xml);\n+var_dump($array);\n+?>\n+--EXPECT--\n+array(0) {\n+}"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.5.37-dev ZEND_VERSION: 2.5.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_a44c89e8af7c2410f4bfc5e097be2a5d0639a60c More .INIs : CWD : /out/php___php-src/git_repo_dir_a44c89e8af7c2410f4bfc5e097be2a5d0639a60c Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/wddx/tests/bug72340.phpt]\rFAIL Bug #72340: Double Free Courruption in wddx_deserialize [ext/wddx/tests/bug72340.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72340: Double Free Courruption in wddx_deserialize [ext/wddx/tests/bug72340.phpt] =====================================================================\n"
    },
    "7722455726bec8c53458a32851d2a87982cf0eac___gd_gd2.c": {
        "start": 54,
        "end": 169,
        "buggy": "static int _gd2GetHeader(gdIOCtxPtr in, int *sx, int *sy, int *cs, int *vers, int *fmt, int *ncx, int *ncy, t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG(php_gd_error(\"Reading gd2 header info\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC(in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tid[i] = ch;\n\t}\n\tid[4] = 0;\n\n\tGD2_DBG(php_gd_error(\"Got file code: %s\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp(id, GD2_ID) != 0) {\n\t\tGD2_DBG(php_gd_error(\"Not a valid gd2 file\"));\n\t\tgoto fail1;\n\t}\n\n\t/* Version */\n\tif (gdGetWord(vers, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Version: %d\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG(php_gd_error(\"Bad version: %d\", *vers));\n\t\tgoto fail1;\n\t}\n\n\t/* Image Size */\n\tif (!gdGetWord(sx, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get x-size\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord(sy, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get y-size\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Image is %dx%d\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord(cs, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"ChunkSize: %d\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG(php_gd_error(\"Bad chunk size: %d\", *cs));\n\t\tgoto fail1;\n\t}\n\n\t/* Data Format */\n\tif (gdGetWord(fmt, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Format: %d\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) && (*fmt != GD2_FMT_TRUECOLOR_RAW) && (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG(php_gd_error(\"Bad data format: %d\", *fmt));\n\t\tgoto fail1;\n\t}\n\n\t/* # of chunks wide */\n\tif (gdGetWord(ncx, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks Wide\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord(ncy, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks vertically\", *ncy));\n\n\tif (gd2_compressed(*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG(php_gd_error(\"Reading %d chunk index entries\", nc));\n\t\tsidx = sizeof(t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tcidx = gdCalloc(sidx, 1);\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt(&cidx[i].offset, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (gdGetInt(&cidx[i].size, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t*chunkIdx = cidx;\n\t}\n\n\tGD2_DBG(php_gd_error(\"gd2 header complete\"));\n\n\treturn 1;\n\nfail1:\n\treturn 0;\n}\n",
        "fix": null,
        "src_path": "7722455726bec8c53458a32851d2a87982cf0eac___gd_gd2.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/7722455726bec8c53458a32851d2a87982cf0eac",
        "commit_msg": "Fixed #72339 Integer Overflow in _gd2GetHeader() resulting in heap overflow",
        "test_func_diff": [
            {
                "fn": "ext/gd/tests/bug72339.phpt",
                "patch": "@@ -0,0 +1,11 @@\n+--TEST--\n+Bug #72339 Integer Overflow in _gd2GetHeader() resulting in heap overflow \n+--SKIPIF--\n+<?php if (!function_exists(\"imagecreatefromgd2\")) print \"skip\"; ?>\n+--FILE--\n+<?php imagecreatefromgd2(dirname(__FILE__) . DIRECTORY_SEPARATOR . \"bug72339.gd\"); ?>\n+--EXPECTF--\t\n+Warning: imagecreatefromgd2(): gd warning: product of memory allocation multiplication would exceed INT_MAX, failing operation gracefully\n+ in %sbug72339.php on line %d\n+\n+Warning: imagecreatefromgd2(): '%sbug72339.gd' is not a valid GD2 file in %sbug72339.php on line %d"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.5.37-dev ZEND_VERSION: 2.5.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_7722455726bec8c53458a32851d2a87982cf0eac More .INIs : CWD : /out/php___php-src/git_repo_dir_7722455726bec8c53458a32851d2a87982cf0eac Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/gd/tests/bug72339.phpt]\rFAIL Bug #72339 Integer Overflow in _gd2GetHeader() resulting in heap overflow [ext/gd/tests/bug72339.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 1 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72339 Integer Overflow in _gd2GetHeader() resulting in heap overflow [ext/gd/tests/bug72339.phpt] =====================================================================\n"
    },
    "426aeb2808955ee3d3f52e0cfb102834cdb836a5___wddx.c": {
        "start": 701,
        "end": 1381,
        "buggy": "static void php_wddx_add_var(wddx_packet *packet, zval *name_var)\n{\n\tzval **val;\n\tHashTable *target_hash;\n\tTSRMLS_FETCH();\n\n\tif (Z_TYPE_P(name_var) == IS_STRING) {\n\t\tif (!EG(active_symbol_table)) {\n\t\t\tzend_rebuild_symbol_table(TSRMLS_C);\n\t\t}\n\t\tif (zend_hash_find(EG(active_symbol_table), Z_STRVAL_P(name_var),\n\t\t\t\t\t\t\tZ_STRLEN_P(name_var)+1, (void**)&val) != FAILURE) {\n\t\t\tphp_wddx_serialize_var(packet, *val, Z_STRVAL_P(name_var), Z_STRLEN_P(name_var) TSRMLS_CC);\n\t\t}\n\t} else if (Z_TYPE_P(name_var) == IS_ARRAY || Z_TYPE_P(name_var) == IS_OBJECT)\t{\n\t\tint is_array = Z_TYPE_P(name_var) == IS_ARRAY;\n\n\t\ttarget_hash = HASH_OF(name_var);\n\n\t\tif (is_array && target_hash->nApplyCount > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"recursion detected\");\n\t\t\treturn;\n\t\t}\n\n\t\tzend_hash_internal_pointer_reset(target_hash);\n\n\t\twhile(zend_hash_get_current_data(target_hash, (void**)&val) == SUCCESS) {\n\t\t\tif (is_array) {\n\t\t\t\ttarget_hash->nApplyCount++;\n\t\t\t}\n\n\t\t\tphp_wddx_add_var(packet, *val);\n\n\t\t\tif (is_array) {\n\t\t\t\ttarget_hash->nApplyCount--;\n\t\t\t}\n\t\t\tzend_hash_move_forward(target_hash);\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_push_element\n */\nstatic void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)\n{\n\tst_entry ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\n\tif (!strcmp(name, EL_PACKET)) {\n\t\tint i;\n\n\t\tif (atts) for (i=0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VERSION)) {\n\t\t\t\t/* nothing for now */\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_STRING)) {\n\t\tent.type = ST_STRING;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BINARY)) {\n\t\tent.type = ST_BINARY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_CHAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_CHAR_CODE) && atts[++i] && atts[i][0]) {\n\t\t\t\tchar tmp_buf[2];\n\n\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i], NULL, 16));\n\t\t\t\tphp_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NUMBER)) {\n\t\tent.type = ST_NUMBER;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\tZ_LVAL_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BOOLEAN)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[++i] && atts[i][0]) {\n\t\t\t\tent.type = ST_BOOLEAN;\n\t\t\t\tSET_STACK_VARNAME;\n\n\t\t\t\tALLOC_ZVAL(ent.data);\n\t\t\t\tINIT_PZVAL(ent.data);\n\t\t\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n\t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t\t\tphp_wddx_process_data(user_data, atts[i], strlen(atts[i]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NULL)) {\n\t\tent.type = ST_NULL;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZVAL_NULL(ent.data);\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_ARRAY)) {\n\t\tent.type = ST_ARRAY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_STRUCT)) {\n\t\tent.type = ST_STRUCT;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_VAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tif (stack->varname) efree(stack->varname);\n\t\t\t\tstack->varname = estrdup(atts[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_RECORDSET)) {\n\t\tint i;\n\n\t\tent.type = ST_RECORDSET;\n\t\tSET_STACK_VARNAME;\n\t\tMAKE_STD_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], \"fieldNames\") && atts[++i] && atts[i][0]) {\n\t\t\t\tzval *tmp;\n\t\t\t\tchar *key;\n\t\t\t\tchar *p1, *p2, *endp;\n\n\t\t\t\tendp = (char *)atts[i] + strlen(atts[i]);\n\t\t\t\tp1 = (char *)atts[i];\n\t\t\t\twhile ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {\n\t\t\t\t\tkey = estrndup(p1, p2 - p1);\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp);\n\t\t\t\t\tp1 = p2 + sizeof(\",\")-1;\n\t\t\t\t\tefree(key);\n\t\t\t\t}\n\n\t\t\t\tif (p1 <= endp) {\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tint i;\n\t\tst_entry ent;\n\n\t\tent.type = ST_FIELD;\n\t\tent.varname = NULL;\n\t\tent.data = NULL;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tst_entry *recordset;\n\t\t\t\tzval **field;\n\n\t\t\t\tif (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i], strlen(atts[i])+1, (void**)&field) == SUCCESS) {\n\t\t\t\t\tent.data = *field;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_DATETIME)) {\n\t\tent.type = ST_DATETIME;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_pop_element\n */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_process_data\n */\nstatic void php_wddx_process_data(void *user_data, const XML_Char *s, int len)\n{\n\tst_entry *ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\tTSRMLS_FETCH();\n\n\tif (!wddx_stack_is_empty(stack) && !stack->done) {\n\t\twddx_stack_top(stack, (void**)&ent);\n\t\tswitch (ent->type) {\n\t\t\tcase ST_STRING:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BINARY:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len + 1);\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t}\n\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase ST_NUMBER:\n\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\tconvert_scalar_to_number(ent->data TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BOOLEAN:\n\t\t\t\tif(!ent->data) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(s, \"true\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 1;\n\t\t\t\t} else if (!strcmp(s, \"false\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 0;\n\t\t\t\t} else {\n\t\t\t\t\tzval_ptr_dtor(&ent->data);\n\t\t\t\t\tif (ent->varname) {\n\t\t\t\t\t\tefree(ent->varname);\n\t\t\t\t\t\tent->varname = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tent->data = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_DATETIME: {\n\t\t\t\tchar *tmp;\n\n\t\t\t\ttmp = emalloc(len + 1);\n\t\t\t\tmemcpy(tmp, s, len);\n\t\t\t\ttmp[len] = '\\0';\n\n\t\t\t\tZ_LVAL_P(ent->data) = php_parse_date(tmp, NULL);\n\t\t\t\t/* date out of range < 1969 or > 2038 */\n\t\t\t\tif (Z_LVAL_P(ent->data) == -1) {\n\t\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t}\n\t\t\t\tefree(tmp);\n\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_deserialize_ex\n */\nint php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)\n{\n\twddx_stack stack;\n\tXML_Parser parser;\n\tst_entry *ent;\n\tint retval;\n\n\twddx_stack_init(&stack);\n\tparser = XML_ParserCreate(\"UTF-8\");\n\n\tXML_SetUserData(parser, &stack);\n\tXML_SetElementHandler(parser, php_wddx_push_element, php_wddx_pop_element);\n\tXML_SetCharacterDataHandler(parser, php_wddx_process_data);\n\n\tXML_Parse(parser, value, vallen, 1);\n\n\tXML_ParserFree(parser);\n\n\tif (stack.top == 1) {\n\t\twddx_stack_top(&stack, (void**)&ent);\n\t\t*return_value = *(ent->data);\n\t\tzval_copy_ctor(return_value);\n\t\tretval = SUCCESS;\n\t} else {\n\t\tretval = FAILURE;\n\t}\n\n\twddx_stack_destroy(&stack);\n\n\treturn retval;\n}\n/* }}} */\n\n/* {{{ proto string wddx_serialize_value(mixed var [, string comment])\n   Creates a new packet and serializes the given value */\nPHP_FUNCTION(wddx_serialize_value)\n{\n\tzval *var;\n\tchar *comment = NULL;\n\tint comment_len = 0;\n\twddx_packet *packet;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|s\", &var, &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, comment, comment_len);\n\tphp_wddx_serialize_var(packet, var, NULL, 0 TSRMLS_CC);\n\tphp_wddx_packet_end(packet);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ proto string wddx_serialize_vars(mixed var_name [, mixed ...])\n   Creates a new packet and serializes given variables into a struct */\nPHP_FUNCTION(wddx_serialize_vars)\n{\n\tint num_args, i;\n\twddx_packet *packet;\n\tzval ***args = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"+\", &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, NULL, 0);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, *args[i]);\n\t}\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\tphp_wddx_packet_end(packet);\n\n\tefree(args);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ php_wddx_constructor\n */\nwddx_packet *php_wddx_constructor(void)\n{\n\tsmart_str *packet;\n\n\tpacket = (smart_str *)emalloc(sizeof(smart_str));\n\tpacket->c = NULL;\n\n\treturn packet;\n}\n/* }}} */\n\n/* {{{ php_wddx_destructor\n */\nvoid php_wddx_destructor(wddx_packet *packet)\n{\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ proto resource wddx_packet_start([string comment])\n   Starts a WDDX packet with optional comment and returns the packet id */\nPHP_FUNCTION(wddx_packet_start)\n{\n\tchar *comment = NULL;\n\tint comment_len = 0;\n\twddx_packet *packet;\n\n\tcomment = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, comment, comment_len);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tZEND_REGISTER_RESOURCE(return_value, packet, le_wddx);\n}\n/* }}} */\n\n/* {{{ proto string wddx_packet_end(resource packet_id)\n   Ends specified WDDX packet and returns the string containing the packet */\nPHP_FUNCTION(wddx_packet_end)\n{\n\tzval *packet_id;\n\twddx_packet *packet = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &packet_id) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(packet, wddx_packet *, &packet_id, -1, \"WDDX packet ID\", le_wddx);\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\n\tphp_wddx_packet_end(packet);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\n\tzend_list_delete(Z_LVAL_P(packet_id));\n}\n/* }}} */\n\n/* {{{ proto int wddx_add_vars(resource packet_id,  mixed var_names [, mixed ...])\n   Serializes given variables and adds them to packet given by packet_id */\nPHP_FUNCTION(wddx_add_vars)\n{\n\tint num_args, i;\n\tzval ***args = NULL;\n\tzval *packet_id;\n\twddx_packet *packet = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r+\", &packet_id, &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!ZEND_FETCH_RESOURCE_NO_RETURN(packet, wddx_packet *, &packet_id, -1, \"WDDX packet ID\", le_wddx)) {\n\t\tefree(args);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!packet) {\n\t\tefree(args);\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, (*args[i]));\n\t}\n\n\tefree(args);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto mixed wddx_deserialize(mixed packet)\n   Deserializes given packet and returns a PHP value */\nPHP_FUNCTION(wddx_deserialize)\n{\n\tzval *packet;\n\tchar *payload;\n\tint payload_len;\n\tphp_stream *stream = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &packet) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (Z_TYPE_P(packet) == IS_STRING) {\n\t\tpayload \t= Z_STRVAL_P(packet);\n\t\tpayload_len = Z_STRLEN_P(packet);\n\t} else if (Z_TYPE_P(packet) == IS_RESOURCE) {\n\t\tphp_stream_from_zval(stream, &packet);\n\t\tif (stream) {\n\t\t\tpayload_len = php_stream_copy_to_mem(stream, &payload, PHP_STREAM_COPY_ALL, 0);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Expecting parameter 1 to be a string or a stream\");\n\t\treturn;\n\t}\n\n\tif (payload_len == 0) {\n\t\treturn;\n\t}\n\n\tphp_wddx_deserialize_ex(payload, payload_len, return_value);\n\n\tif (stream) {\n\t\tpefree(payload, 0);\n\t}\n}\n",
        "fix": null,
        "src_path": "426aeb2808955ee3d3f52e0cfb102834cdb836a5___wddx.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/426aeb2808955ee3d3f52e0cfb102834cdb836a5",
        "commit_msg": "Fix bug #72749: wddx_deserialize allows illegal memory access",
        "test_func_diff": [
            {
                "fn": "ext/wddx/tests/bug72749.phpt",
                "patch": "@@ -0,0 +1,34 @@\n+--TEST--\n+Bug #72749: wddx_deserialize allows illegal memory access\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+$xml = <<<XML\n+<?xml version='1.0'?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+<header/>\n+        <data>\n+                <struct>\n+                     <var name='aDateTime3'>\n+                         <dateTime>2\\r2004-09-10T05:52:49+00</dateTime>\n+                     </var>\n+                 </struct>\n+        </data>\n+</wddxPacket>\n+XML;\n+\n+$array = wddx_deserialize($xml);\n+var_dump($array);\n+?>\n+--EXPECT--\n+array(1) {\n+  [\"aDateTime3\"]=>\n+  string(24) \"2\n+2004-09-10T05:52:49+00\"\n+}"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.26-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_426aeb2808955ee3d3f52e0cfb102834cdb836a5 More .INIs : CWD : /out/php___php-src/git_repo_dir_426aeb2808955ee3d3f52e0cfb102834cdb836a5 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/wddx/tests/bug72749.phpt]\rFAIL Bug #72749: wddx_deserialize allows illegal memory access [ext/wddx/tests/bug72749.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72749: wddx_deserialize allows illegal memory access [ext/wddx/tests/bug72749.phpt] =====================================================================\n"
    },
    "28022c9b1fd937436ab67bb3d61f652c108baf96___gd.c": {
        "start": 1525,
        "end": 1547,
        "buggy": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tzend_long ncolors;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tif ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), \"Image\", le_gd)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Number of colors has to be greater than zero\");\n\t\tRETURN_FALSE;\n\t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n\n\tRETURN_TRUE;\n}\n",
        "fix": null,
        "src_path": "28022c9b1fd937436ab67bb3d61f652c108baf96___gd.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/28022c9b1fd937436ab67bb3d61f652c108baf96",
        "commit_msg": "Fix bug#72697 - select_colors write out-of-bounds\n\n(cherry picked from commit b6f13a5ef9d6280cf984826a5de012a32c396cd4)\n\nConflicts:\n\text/gd/gd.c",
        "test_func_diff": [
            {
                "fn": "ext/gd/tests/bug72697.phpt",
                "patch": "@@ -0,0 +1,17 @@\n+--TEST--\n+Bug #72697: select_colors write out-of-bounds\n+--SKIPIF--\n+<?php \n+if (!function_exists(\"imagecreatetruecolor\")) die(\"skip\");\n+if (PHP_INT_MAX !== 9223372036854775807) die(\"skip for 64-bit long systems only\");\n+?>\n+--FILE--\n+<?php\n+\n+$img=imagecreatetruecolor(10, 10);\n+imagetruecolortopalette($img, false, PHP_INT_MAX / 8);\n+?>\n+DONE\n+--EXPECTF--\n+Warning: imagetruecolortopalette(): Number of colors has to be greater than zero and no more than 2147483647 in %sbug72697.php on line %d\n+DONE\n\\ No newline at end of file"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 7.0.11-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_28022c9b1fd937436ab67bb3d61f652c108baf96 More .INIs : CWD : /out/php___php-src/git_repo_dir_28022c9b1fd937436ab67bb3d61f652c108baf96 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. FAIL Bug #72697: select_colors write out-of-bounds [ext/gd/tests/bug72697.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72697: select_colors write out-of-bounds [ext/gd/tests/bug72697.phpt] =====================================================================\n"
    },
    "b2af4e8868726a040234de113436c6e4f6372d17___var.c": {
        "start": 1032,
        "end": 1092,
        "buggy": "PHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n\tconst unsigned char *p;\n\tphp_unserialize_data_t var_hash;\n\tzval *options = NULL, *classes = NULL;\n\tHashTable *class_hash = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t}\n\t}\n\n\tif (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\tif (class_hash) {\n\t\t\tzend_hash_destroy(class_hash);\n\t\t\tFREE_HASHTABLE(class_hash);\n\t\t}\n\t\tzval_ptr_dtor(return_value);\n\t\tif (!EG(exception)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",\n\t\t\t\t(zend_long)((char*)p - buf), buf_len);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\t/* We should keep an reference to return_value to prevent it from being dtor\n\t   in case nesting calls to unserialize */\n\tvar_push_dtor(&var_hash, return_value);\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}\n",
        "fix": null,
        "src_path": "b2af4e8868726a040234de113436c6e4f6372d17___var.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/b2af4e8868726a040234de113436c6e4f6372d17",
        "commit_msg": "Complete the fix of bug #70172 for PHP 7",
        "test_func_diff": [
            {
                "fn": "ext/standard/tests/serialize/bug70172_2.phpt",
                "patch": "@@ -1,7 +1,5 @@\n --TEST--\n Bug #70172 - Use After Free Vulnerability in unserialize()\n---XFAIL--\n-Unfinished merge, needs fix.\n --FILE--\n <?php\n class obj implements Serializable {\n@@ -61,10 +59,10 @@ array(2) {\n     [0]=>\n     array(1) {\n       [0]=>\n-      &object(obj2)#%d (1) {\n+      object(obj2)#%d (1) {\n         [\"ryat\"]=>\n         int(1)\n       }\n     }\n   }\n-}\n\\ No newline at end of file\n+}"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 7.0.14-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_b2af4e8868726a040234de113436c6e4f6372d17 More .INIs : CWD : /out/php___php-src/git_repo_dir_b2af4e8868726a040234de113436c6e4f6372d17 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. FAIL Bug #70172 - Use After Free Vulnerability in unserialize() [ext/standard/tests/serialize/bug70172_2.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #70172 - Use After Free Vulnerability in unserialize() [ext/standard/tests/serialize/bug70172_2.phpt] =====================================================================\n"
    },
    "ca46d0acbce55019b970fcd4c1e8a10edfdded93___phar.c": {
        "start": 529,
        "end": 3375,
        "buggy": "int phar_open_parsed_phar(char *fname, int fname_len, char *alias, int alias_len, int is_data, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *phar;\n#ifdef PHP_WIN32\n\tchar *unixfname;\n#endif\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n#ifdef PHP_WIN32\n\tunixfname = estrndup(fname, fname_len);\n\tphar_unixify_path_separators(unixfname, fname_len);\n\n\tif (SUCCESS == phar_get_archive(&phar, unixfname, fname_len, alias, alias_len, error TSRMLS_CC)\n\t\t&& ((alias && fname_len == phar->fname_len\n\t\t&& !strncmp(unixfname, phar->fname, fname_len)) || !alias)\n\t) {\n\t\tphar_entry_info *stub;\n\t\tefree(unixfname);\n#else\n\tif (SUCCESS == phar_get_archive(&phar, fname, fname_len, alias, alias_len, error TSRMLS_CC)\n\t\t&& ((alias && fname_len == phar->fname_len\n\t\t&& !strncmp(fname, phar->fname, fname_len)) || !alias)\n\t) {\n\t\tphar_entry_info *stub;\n#endif\n\t\t/* logic above is as follows:\n\t\t   If an explicit alias was requested, ensure the filename passed in\n\t\t   matches the phar's filename.\n\t\t   If no alias was passed in, then it can match either and be valid\n\t\t */\n\n\t\tif (!is_data) {\n\t\t\t/* prevent any \".phar\" without a stub getting through */\n\t\t\tif (!phar->halt_offset && !phar->is_brandnew && (phar->is_tar || phar->is_zip)) {\n\t\t\t\tif (PHAR_G(readonly) && FAILURE == zend_hash_find(&(phar->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1, (void **)&stub)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"'%s' is not a phar archive. Use PharData::__construct() for a standard zip or tar archive\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (pphar) {\n\t\t\t*pphar = phar;\n\t\t}\n\n\t\treturn SUCCESS;\n\t} else {\n#ifdef PHP_WIN32\n\t\tefree(unixfname);\n#endif\n\t\tif (pphar) {\n\t\t\t*pphar = NULL;\n\t\t}\n\n\t\tif (phar && error && !(options & REPORT_ERRORS)) {\n\t\t\tefree(error);\n\t\t}\n\n\t\treturn FAILURE;\n\t}\n}\n/* }}}*/\n\n/**\n * Parse out metadata from the manifest for a single file\n *\n * Meta-data is in this format:\n * [len32][data...]\n *\n * data is the serialized zval\n */\nint phar_parse_metadata(char **buffer, zval **metadata, php_uint32 zip_metadata_len TSRMLS_DC) /* {{{ */\n{\n\tphp_unserialize_data_t var_hash;\n\n\tif (zip_metadata_len) {\n\t\tconst unsigned char *p;\n\t\tunsigned char *p_buff = (unsigned char *)estrndup(*buffer, zip_metadata_len);\n\t\tp = p_buff;\n\t\tALLOC_ZVAL(*metadata);\n\t\tINIT_ZVAL(**metadata);\n\t\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\t\tif (!php_var_unserialize(metadata, &p, p + zip_metadata_len, &var_hash TSRMLS_CC)) {\n\t\t\tefree(p_buff);\n\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\t\tzval_ptr_dtor(metadata);\n\t\t\t*metadata = NULL;\n\t\t\treturn FAILURE;\n\t\t}\n\t\tefree(p_buff);\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\n\t\tif (PHAR_G(persist)) {\n\t\t\t/* lazy init metadata */\n\t\t\tzval_ptr_dtor(metadata);\n\t\t\t*metadata = (zval *) pemalloc(zip_metadata_len, 1);\n\t\t\tmemcpy(*metadata, *buffer, zip_metadata_len);\n\t\t\treturn SUCCESS;\n\t\t}\n\t} else {\n\t\t*metadata = NULL;\n\t}\n\n\treturn SUCCESS;\n}\n/* }}}*/\n\n/**\n * Does not check for a previously opened phar in the cache.\n *\n * Parse a new one and add it to the cache, returning either SUCCESS or\n * FAILURE, and setting pphar to the pointer to the manifest entry\n *\n * This is used by phar_open_from_filename to process the manifest, but can be called\n * directly.\n */\nstatic int phar_parse_pharfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, long halt_offset, phar_archive_data** pphar, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar b32[4], *buffer, *endbuffer, *savebuf;\n\tphar_archive_data *mydata = NULL;\n\tphar_entry_info entry;\n\tphp_uint32 manifest_len, manifest_count, manifest_flags, manifest_index, tmp_len, sig_flags;\n\tphp_uint16 manifest_ver;\n\tphp_uint32 len;\n\tlong offset;\n\tint sig_len, register_alias = 0, temp_alias = 0;\n\tchar *signature = NULL;\n\n\tif (pphar) {\n\t\t*pphar = NULL;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\t/* check for ?>\\n and increment accordingly */\n\tif (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot seek to __HALT_COMPILER(); location in phar \\\"%s\\\"\")\n\t}\n\n\tbuffer = b32;\n\n\tif (3 != php_stream_read(fp, buffer, 3)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t}\n\n\tif ((*buffer == ' ' || *buffer == '\\n') && *(buffer + 1) == '?' && *(buffer + 2) == '>') {\n\t\tint nextchar;\n\t\thalt_offset += 3;\n\t\tif (EOF == (nextchar = php_stream_getc(fp))) {\n\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t\t}\n\n\t\tif ((char) nextchar == '\\r') {\n\t\t\t/* if we have an \\r we require an \\n as well */\n\t\t\tif (EOF == (nextchar = php_stream_getc(fp)) || (char)nextchar != '\\n') {\n\t\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t\t\t}\n\t\t\t++halt_offset;\n\t\t}\n\n\t\tif ((char) nextchar == '\\n') {\n\t\t\t++halt_offset;\n\t\t}\n\t}\n\n\t/* make sure we are at the right location to read the manifest */\n\tif (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot seek to __HALT_COMPILER(); location in phar \\\"%s\\\"\")\n\t}\n\n\t/* read in manifest */\n\tbuffer = b32;\n\n\tif (4 != php_stream_read(fp, buffer, 4)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at manifest length)\")\n\t}\n\n\tPHAR_GET_32(buffer, manifest_len);\n\n\tif (manifest_len > 1048576 * 100) {\n\t\t/* prevent serious memory issues by limiting manifest to at most 100 MB in length */\n\t\tMAPPHAR_ALLOC_FAIL(\"manifest cannot be larger than 100 MB in phar \\\"%s\\\"\")\n\t}\n\n\tbuffer = (char *)emalloc(manifest_len);\n\tsavebuf = buffer;\n\tendbuffer = buffer + manifest_len;\n\n\tif (manifest_len < 10 || manifest_len != php_stream_read(fp, buffer, manifest_len)) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest header)\")\n\t}\n\n\t/* extract the number of entries */\n\tPHAR_GET_32(buffer, manifest_count);\n\n\tif (manifest_count == 0) {\n\t\tMAPPHAR_FAIL(\"in phar \\\"%s\\\", manifest claims to have zero entries.  Phars must have at least 1 entry\");\n\t}\n\n\t/* extract API version, lowest nibble currently unused */\n\tmanifest_ver = (((unsigned char)buffer[0]) << 8)\n\t\t\t\t + ((unsigned char)buffer[1]);\n\tbuffer += 2;\n\n\tif ((manifest_ver & PHAR_API_VER_MASK) < PHAR_API_MIN_READ) {\n\t\tefree(savebuf);\n\t\tphp_stream_close(fp);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" is API version %1.u.%1.u.%1.u, and cannot be processed\", fname, manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0x0F);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tPHAR_GET_32(buffer, manifest_flags);\n\n\tmanifest_flags &= ~PHAR_HDR_COMPRESSION_MASK;\n\tmanifest_flags &= ~PHAR_FILE_COMPRESSION_MASK;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmanifest_flags |= compression;\n\n\t/* The lowest nibble contains the phar wide flags. The compression flags can */\n\t/* be ignored on reading because it is being generated anyways. */\n\tif (manifest_flags & PHAR_HDR_SIGNATURE) {\n\t\tchar sig_buf[8], *sig_ptr = sig_buf;\n\t\toff_t read_len;\n\t\tsize_t end_of_phar;\n\n\t\tif (-1 == php_stream_seek(fp, -8, SEEK_END)\n\t\t|| (read_len = php_stream_tell(fp)) < 20\n\t\t|| 8 != php_stream_read(fp, sig_buf, 8)\n\t\t|| memcmp(sig_buf+4, \"GBMB\", 4)) {\n\t\t\tefree(savebuf);\n\t\t\tphp_stream_close(fp);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tPHAR_GET_32(sig_ptr, sig_flags);\n\n\t\tswitch(sig_flags) {\n\t\t\tcase PHAR_SIG_OPENSSL: {\n\t\t\t\tphp_uint32 signature_len;\n\t\t\t\tchar *sig;\n\t\t\t\toff_t whence;\n\n\t\t\t\t/* we store the signature followed by the signature length */\n\t\t\t\tif (-1 == php_stream_seek(fp, -12, SEEK_CUR)\n\t\t\t\t|| 4 != php_stream_read(fp, sig_buf, 4)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature length could not be read\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tsig_ptr = sig_buf;\n\t\t\t\tPHAR_GET_32(sig_ptr, signature_len);\n\t\t\t\tsig = (char *) emalloc(signature_len);\n\t\t\t\twhence = signature_len + 4;\n\t\t\t\twhence = -whence;\n\n\t\t\t\tif (-1 == php_stream_seek(fp, whence, SEEK_CUR)\n\t\t\t\t|| !(end_of_phar = php_stream_tell(fp))\n\t\t\t\t|| signature_len != php_stream_read(fp, sig, signature_len)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tefree(sig);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature could not be read\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, end_of_phar, PHAR_SIG_OPENSSL, sig, signature_len, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tefree(sig);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tefree(sig);\n\t\t\t}\n\t\t\tbreak;\n#if PHAR_HASH_OK\n\t\t\tcase PHAR_SIG_SHA512: {\n\t\t\t\tunsigned char digest[64];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 64), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA512, (char *)digest, 64, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA512 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PHAR_SIG_SHA256: {\n\t\t\t\tunsigned char digest[32];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 32), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA256, (char *)digest, 32, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA256 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#else\n\t\t\tcase PHAR_SIG_SHA512:\n\t\t\tcase PHAR_SIG_SHA256:\n\t\t\t\tefree(savebuf);\n\t\t\t\tphp_stream_close(fp);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a unsupported signature\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n#endif\n\t\t\tcase PHAR_SIG_SHA1: {\n\t\t\t\tunsigned char digest[20];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 20), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA1, (char *)digest, 20, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA1 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PHAR_SIG_MD5: {\n\t\t\t\tunsigned char digest[16];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 16), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_MD5, (char *)digest, 16, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" MD5 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tefree(savebuf);\n\t\t\t\tphp_stream_close(fp);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken or unsupported signature\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t}\n\t} else if (PHAR_G(require_hash)) {\n\t\tefree(savebuf);\n\t\tphp_stream_close(fp);\n\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t} else {\n\t\tsig_flags = 0;\n\t\tsig_len = 0;\n\t}\n\n\t/* extract alias */\n\tPHAR_GET_32(buffer, tmp_len);\n\n\tif (buffer + tmp_len > endbuffer) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (buffer overrun)\");\n\t}\n\n\tif (manifest_len < 10 + tmp_len) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest header)\")\n\t}\n\n\t/* tmp_len = 0 says alias length is 0, which means the alias is not stored in the phar */\n\tif (tmp_len) {\n\t\t/* if the alias is stored we enforce it (implicit overrides explicit) */\n\t\tif (alias && alias_len && (alias_len != (int)tmp_len || strncmp(alias, buffer, tmp_len)))\n\t\t{\n\t\t\tbuffer[tmp_len] = '\\0';\n\t\t\tphp_stream_close(fp);\n\n\t\t\tif (signature) {\n\t\t\t\tefree(signature);\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"cannot load phar \\\"%s\\\" with implicit alias \\\"%s\\\" under different alias \\\"%s\\\"\", fname, buffer, alias);\n\t\t\t}\n\n\t\t\tefree(savebuf);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\talias_len = tmp_len;\n\t\talias = buffer;\n\t\tbuffer += tmp_len;\n\t\tregister_alias = 1;\n\t} else if (!alias_len || !alias) {\n\t\t/* if we neither have an explicit nor an implicit alias, we use the filename */\n\t\talias = NULL;\n\t\talias_len = 0;\n\t\tregister_alias = 0;\n\t} else if (alias_len) {\n\t\tregister_alias = 1;\n\t\ttemp_alias = 1;\n\t}\n\n\t/* we have 5 32-bit items plus 1 byte at least */\n\tif (manifest_count > ((manifest_len - 10 - tmp_len) / (5 * 4 + 1))) {\n\t\t/* prevent serious memory issues */\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (too many manifest entries for size of manifest)\")\n\t}\n\n\tmydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmydata->is_persistent = PHAR_G(persist);\n\n\t/* check whether we have meta data, zero check works regardless of byte order */\n\tPHAR_GET_32(buffer, len);\n\tif (mydata->is_persistent) {\n\t\tmydata->metadata_len = len;\n\t\tif(!len) {\n\t\t\t/* FIXME: not sure why this is needed but removing it breaks tests */\n\t\t\tPHAR_GET_32(buffer, len);\n\t\t}\n\t}\n\tif(len > endbuffer - buffer) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (trying to read past buffer end)\");\n\t}\n\tif (phar_parse_metadata(&buffer, &mydata->metadata, len TSRMLS_CC) == FAILURE) {\n\t\tMAPPHAR_FAIL(\"unable to read phar metadata in .phar file \\\"%s\\\"\");\n\t}\n\tbuffer += len;\n\n\t/* set up our manifest */\n\tzend_hash_init(&mydata->manifest, manifest_count,\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->virtual_dirs, manifest_count * 2,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tmydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(mydata->fname, fname_len);\n#endif\n\tmydata->fname_len = fname_len;\n\toffset = halt_offset + manifest_len + 4;\n\tmemset(&entry, 0, sizeof(phar_entry_info));\n\tentry.phar = mydata;\n\tentry.fp_type = PHAR_FP;\n\tentry.is_persistent = mydata->is_persistent;\n\n\tfor (manifest_index = 0; manifest_index < manifest_count; ++manifest_index) {\n\t\tif (buffer + 4 > endbuffer) {\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\")\n\t\t}\n\n\t\tPHAR_GET_32(buffer, entry.filename_len);\n\n\t\tif (entry.filename_len == 0) {\n\t\t\tMAPPHAR_FAIL(\"zero-length filename encountered in phar \\\"%s\\\"\");\n\t\t}\n\n\t\tif (entry.is_persistent) {\n\t\t\tentry.manifest_pos = manifest_index;\n\t\t}\n\n\t\tif (entry.filename_len + 20 > endbuffer - buffer) {\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\");\n\t\t}\n\n\t\tif ((manifest_ver & PHAR_API_VER_MASK) >= PHAR_API_MIN_DIR && buffer[entry.filename_len - 1] == '/') {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tphar_add_virtual_dirs(mydata, buffer, entry.filename_len TSRMLS_CC);\n\t\tentry.filename = pestrndup(buffer, entry.filename_len, entry.is_persistent);\n\t\tbuffer += entry.filename_len;\n\t\tPHAR_GET_32(buffer, entry.uncompressed_filesize);\n\t\tPHAR_GET_32(buffer, entry.timestamp);\n\n\t\tif (offset == halt_offset + (int)manifest_len + 4) {\n\t\t\tmydata->min_timestamp = entry.timestamp;\n\t\t\tmydata->max_timestamp = entry.timestamp;\n\t\t} else {\n\t\t\tif (mydata->min_timestamp > entry.timestamp) {\n\t\t\t\tmydata->min_timestamp = entry.timestamp;\n\t\t\t} else if (mydata->max_timestamp < entry.timestamp) {\n\t\t\t\tmydata->max_timestamp = entry.timestamp;\n\t\t\t}\n\t\t}\n\n\t\tPHAR_GET_32(buffer, entry.compressed_filesize);\n\t\tPHAR_GET_32(buffer, entry.crc32);\n\t\tPHAR_GET_32(buffer, entry.flags);\n\n\t\tif (entry.is_dir) {\n\t\t\tentry.filename_len--;\n\t\t\tentry.flags |= PHAR_ENT_PERM_DEF_DIR;\n\t\t}\n\n\t\tPHAR_GET_32(buffer, len);\n\t\tif (entry.is_persistent) {\n\t\t\tentry.metadata_len = len;\n\t\t} else {\n\t\t\tentry.metadata_len = 0;\n\t\t}\n\t\tif (len > endbuffer - buffer) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\");\n\t\t}\n\t\tif (phar_parse_metadata(&buffer, &entry.metadata, len TSRMLS_CC) == FAILURE) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tMAPPHAR_FAIL(\"unable to read file metadata in .phar file \\\"%s\\\"\");\n\t\t}\n\t\tbuffer += len;\n\n\t\tentry.offset = entry.offset_abs = offset;\n\t\toffset += entry.compressed_filesize;\n\n\t\tswitch (entry.flags & PHAR_ENT_COMPRESSION_MASK) {\n\t\t\tcase PHAR_ENT_COMPRESSED_GZ:\n\t\t\t\tif (!PHAR_G(has_zlib)) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"zlib extension is required for gz compressed .phar file \\\"%s\\\"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHAR_ENT_COMPRESSED_BZ2:\n\t\t\t\tif (!PHAR_G(has_bz2)) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"bz2 extension is required for bzip2 compressed .phar file \\\"%s\\\"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (entry.uncompressed_filesize != entry.compressed_filesize) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (compressed and uncompressed size does not match for uncompressed entry)\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tmanifest_flags |= (entry.flags & PHAR_ENT_COMPRESSION_MASK);\n\t\t/* if signature matched, no need to check CRC32 for each file */\n\t\tentry.is_crc_checked = (manifest_flags & PHAR_HDR_SIGNATURE ? 1 : 0);\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&mydata->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), NULL);\n\t}\n\n\tsnprintf(mydata->version, sizeof(mydata->version), \"%u.%u.%u\", manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0xF);\n\tmydata->internal_file_start = halt_offset + manifest_len + 4;\n\tmydata->halt_offset = halt_offset;\n\tmydata->flags = manifest_flags;\n\tendbuffer = strrchr(mydata->fname, '/');\n\n\tif (endbuffer) {\n\t\tmydata->ext = memchr(endbuffer, '.', (mydata->fname + fname_len) - endbuffer);\n\t\tif (mydata->ext == endbuffer) {\n\t\t\tmydata->ext = memchr(endbuffer + 1, '.', (mydata->fname + fname_len) - endbuffer - 1);\n\t\t}\n\t\tif (mydata->ext) {\n\t\t\tmydata->ext_len = (mydata->fname + mydata->fname_len) - mydata->ext;\n\t\t}\n\t}\n\n\tmydata->alias = alias ?\n\t\tpestrndup(alias, alias_len, mydata->is_persistent) :\n\t\tpestrndup(mydata->fname, fname_len, mydata->is_persistent);\n\tmydata->alias_len = alias ? alias_len : fname_len;\n\tmydata->sig_flags = sig_flags;\n\tmydata->fp = fp;\n\tmydata->sig_len = sig_len;\n\tmydata->signature = signature;\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (register_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmydata->is_temporary_alias = temp_alias;\n\n\t\tif (!phar_validate_alias(mydata->alias, mydata->alias_len)) {\n\t\t\tsignature = NULL;\n\t\t\tfp = NULL;\n\t\t\tMAPPHAR_FAIL(\"Cannot open archive \\\"%s\\\", invalid alias\");\n\t\t}\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\tsignature = NULL;\n\t\t\t\tfp = NULL;\n\t\t\t\tMAPPHAR_FAIL(\"Cannot open archive \\\"%s\\\", alias is already in use by existing archive\");\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tmydata->is_temporary_alias = 1;\n\t}\n\n\tzend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*),  NULL);\n\tefree(savebuf);\n\n\tif (pphar) {\n\t\t*pphar = mydata;\n\t}\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/**\n * Create or open a phar for writing\n */\nint phar_open_or_create_filename(char *fname, int fname_len, char *alias, int alias_len, int is_data, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tconst char *ext_str, *z;\n\tchar *my_error;\n\tint ext_len;\n\tphar_archive_data **test, *unused = NULL;\n\n\ttest = &unused;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\t/* first try to open an existing file */\n\tif (phar_detect_phar_fname_ext(fname, fname_len, &ext_str, &ext_len, !is_data, 0, 1 TSRMLS_CC) == SUCCESS) {\n\t\tgoto check_file;\n\t}\n\n\t/* next try to create a new file */\n\tif (FAILURE == phar_detect_phar_fname_ext(fname, fname_len, &ext_str, &ext_len, !is_data, 1, 1 TSRMLS_CC)) {\n\t\tif (error) {\n\t\t\tif (ext_len == -2) {\n\t\t\t\tspprintf(error, 0, \"Cannot create a phar archive from a URL like \\\"%s\\\". Phar objects can only be created from local files\", fname);\n\t\t\t} else {\n\t\t\t\tspprintf(error, 0, \"Cannot create phar '%s', file extension (or combination) not recognised or the directory does not exist\", fname);\n\t\t\t}\n\t\t}\n\t\treturn FAILURE;\n\t}\ncheck_file:\n\tif (phar_open_parsed_phar(fname, fname_len, alias, alias_len, is_data, options, test, &my_error TSRMLS_CC) == SUCCESS) {\n\t\tif (pphar) {\n\t\t\t*pphar = *test;\n\t\t}\n\n\t\tif ((*test)->is_data && !(*test)->is_tar && !(*test)->is_zip) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"Cannot open '%s' as a PharData object. Use Phar::__construct() for executable archives\", fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tif (PHAR_G(readonly) && !(*test)->is_data && ((*test)->is_tar || (*test)->is_zip)) {\n\t\t\tphar_entry_info *stub;\n\t\t\tif (FAILURE == zend_hash_find(&((*test)->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1, (void **)&stub)) {\n\t\t\t\tspprintf(error, 0, \"'%s' is not a phar archive. Use PharData::__construct() for a standard zip or tar archive\", fname);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tif (!PHAR_G(readonly) || (*test)->is_data) {\n\t\t\t(*test)->is_writeable = 1;\n\t\t}\n\t\treturn SUCCESS;\n\t} else if (my_error) {\n\t\tif (error) {\n\t\t\t*error = my_error;\n\t\t} else {\n\t\t\tefree(my_error);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (ext_len > 3 && (z = memchr(ext_str, 'z', ext_len)) && ((ext_str + ext_len) - z >= 2) && !memcmp(z + 1, \"ip\", 2)) {\n\t\t/* assume zip-based phar */\n\t\treturn phar_open_or_create_zip(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC);\n\t}\n\n\tif (ext_len > 3 && (z = memchr(ext_str, 't', ext_len)) && ((ext_str + ext_len) - z >= 2) && !memcmp(z + 1, \"ar\", 2)) {\n\t\t/* assume tar-based phar */\n\t\treturn phar_open_or_create_tar(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC);\n\t}\n\n\treturn phar_create_or_parse_filename(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC);\n}\n/* }}} */\n\nint phar_create_or_parse_filename(char *fname, int fname_len, char *alias, int alias_len, int is_data, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *mydata;\n\tphp_stream *fp;\n\tchar *actual = NULL, *p;\n\n\tif (!pphar) {\n\t\tpphar = &mydata;\n\t}\n#if PHP_API_VERSION < 20100412\n\tif (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {\n\t\treturn FAILURE;\n\t}\n#endif\n\tif (php_check_open_basedir(fname TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\t/* first open readonly so it won't be created if not present */\n\tfp = php_stream_open_wrapper(fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK|0, &actual);\n\n\tif (actual) {\n\t\tfname = actual;\n\t\tfname_len = strlen(actual);\n\t}\n\n\tif (fp) {\n\t\tif (phar_open_from_fp(fp, fname, fname_len, alias, alias_len, options, pphar, is_data, error TSRMLS_CC) == SUCCESS) {\n\t\t\tif ((*pphar)->is_data || !PHAR_G(readonly)) {\n\t\t\t\t(*pphar)->is_writeable = 1;\n\t\t\t}\n\t\t\tif (actual) {\n\t\t\t\tefree(actual);\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\t} else {\n\t\t\t/* file exists, but is either corrupt or not a phar archive */\n\t\t\tif (actual) {\n\t\t\t\tefree(actual);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (actual) {\n\t\tefree(actual);\n\t}\n\n\tif (PHAR_G(readonly) && !is_data) {\n\t\tif (options & REPORT_ERRORS) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"creating archive \\\"%s\\\" disabled by the php.ini setting phar.readonly\", fname);\n\t\t\t}\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\t/* set up our manifest */\n\tmydata = ecalloc(1, sizeof(phar_archive_data));\n\tmydata->fname = expand_filepath(fname, NULL TSRMLS_CC);\n\tfname_len = strlen(mydata->fname);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(mydata->fname, fname_len);\n#endif\n\tp = strrchr(mydata->fname, '/');\n\n\tif (p) {\n\t\tmydata->ext = memchr(p, '.', (mydata->fname + fname_len) - p);\n\t\tif (mydata->ext == p) {\n\t\t\tmydata->ext = memchr(p + 1, '.', (mydata->fname + fname_len) - p - 1);\n\t\t}\n\t\tif (mydata->ext) {\n\t\t\tmydata->ext_len = (mydata->fname + fname_len) - mydata->ext;\n\t\t}\n\t}\n\n\tif (pphar) {\n\t\t*pphar = mydata;\n\t}\n\n\tzend_hash_init(&mydata->manifest, sizeof(phar_entry_info),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, 0);\n\tzend_hash_init(&mydata->mounted_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, 0);\n\tzend_hash_init(&mydata->virtual_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tmydata->fname_len = fname_len;\n\tsnprintf(mydata->version, sizeof(mydata->version), \"%s\", PHP_PHAR_API_VERSION);\n\tmydata->is_temporary_alias = alias ? 0 : 1;\n\tmydata->internal_file_start = -1;\n\tmydata->fp = NULL;\n\tmydata->is_writeable = 1;\n\tmydata->is_brandnew = 1;\n\tphar_request_initialize(TSRMLS_C);\n\tzend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*),  NULL);\n\n\tif (is_data) {\n\t\talias = NULL;\n\t\talias_len = 0;\n\t\tmydata->is_data = 1;\n\t\t/* assume tar format, PharData can specify other */\n\t\tmydata->is_tar = 1;\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias && SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: phar \\\"%s\\\" cannot set alias \\\"%s\\\", already in use by another phar archive\", mydata->fname, alias);\n\t\t\t\t}\n\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\n\t\t\t\tif (pphar) {\n\t\t\t\t\t*pphar = NULL;\n\t\t\t\t}\n\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tmydata->alias = alias ? estrndup(alias, alias_len) : estrndup(mydata->fname, fname_len);\n\t\tmydata->alias_len = alias ? alias_len : fname_len;\n\t}\n\n\tif (alias_len && alias) {\n\t\tif (FAILURE == zend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL)) {\n\t\t\tif (options & REPORT_ERRORS) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"archive \\\"%s\\\" cannot be associated with alias \\\"%s\\\", already in use\", fname, alias);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\n\t\t\tif (pphar) {\n\t\t\t\t*pphar = NULL;\n\t\t\t}\n\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\treturn SUCCESS;\n}\n/* }}}*/\n\n/**\n * Return an already opened filename.\n *\n * Or scan a phar file for the required __HALT_COMPILER(); ?> token and verify\n * that the manifest is proper, then pass it to phar_parse_pharfile().  SUCCESS\n * or FAILURE is returned and pphar is set to a pointer to the phar's manifest\n */\nint phar_open_from_filename(char *fname, int fname_len, char *alias, int alias_len, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphp_stream *fp;\n\tchar *actual;\n\tint ret, is_data = 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (!strstr(fname, \".phar\")) {\n\t\tis_data = 1;\n\t}\n\n\tif (phar_open_parsed_phar(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC) == SUCCESS) {\n\t\treturn SUCCESS;\n\t} else if (error && *error) {\n\t\treturn FAILURE;\n\t}\n#if PHP_API_VERSION < 20100412\n\tif (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {\n\t\treturn FAILURE;\n\t}\n#endif\n\tif (php_check_open_basedir(fname TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tfp = php_stream_open_wrapper(fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK, &actual);\n\n\tif (!fp) {\n\t\tif (options & REPORT_ERRORS) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to open phar for reading \\\"%s\\\"\", fname);\n\t\t\t}\n\t\t}\n\t\tif (actual) {\n\t\t\tefree(actual);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (actual) {\n\t\tfname = actual;\n\t\tfname_len = strlen(actual);\n\t}\n\n\tret =  phar_open_from_fp(fp, fname, fname_len, alias, alias_len, options, pphar, is_data, error TSRMLS_CC);\n\n\tif (actual) {\n\t\tefree(actual);\n\t}\n\n\treturn ret;\n}\n/* }}}*/\n\nstatic inline char *phar_strnstr(const char *buf, int buf_len, const char *search, int search_len) /* {{{ */\n{\n\tconst char *c;\n\tint so_far = 0;\n\n\tif (buf_len < search_len) {\n\t\treturn NULL;\n\t}\n\n\tc = buf - 1;\n\n\tdo {\n\t\tif (!(c = memchr(c + 1, search[0], buf_len - search_len - so_far))) {\n\t\t\treturn (char *) NULL;\n\t\t}\n\n\t\tso_far = c - buf;\n\n\t\tif (so_far >= (buf_len - search_len)) {\n\t\t\treturn (char *) NULL;\n\t\t}\n\n\t\tif (!memcmp(c, search, search_len)) {\n\t\t\treturn (char *) c;\n\t\t}\n\t} while (1);\n}\n/* }}} */\n\n/**\n * Scan an open fp for the required __HALT_COMPILER(); ?> token and verify\n * that the manifest is proper, then pass it to phar_parse_pharfile().  SUCCESS\n * or FAILURE is returned and pphar is set to a pointer to the phar's manifest\n */\nstatic int phar_open_from_fp(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, int options, phar_archive_data** pphar, int is_data, char **error TSRMLS_DC) /* {{{ */\n{\n\tconst char token[] = \"__HALT_COMPILER();\";\n\tconst char zip_magic[] = \"PK\\x03\\x04\";\n\tconst char gz_magic[] = \"\\x1f\\x8b\\x08\";\n\tconst char bz_magic[] = \"BZh\";\n\tchar *pos, test = '\\0';\n\tconst int window_size = 1024;\n\tchar buffer[1024 + sizeof(token)]; /* a 1024 byte window + the size of the halt_compiler token (moving window) */\n\tconst long readsize = sizeof(buffer) - sizeof(token);\n\tconst long tokenlen = sizeof(token) - 1;\n\tlong halt_offset;\n\tsize_t got;\n\tphp_uint32 compression = PHAR_FILE_COMPRESSED_NONE;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (-1 == php_stream_rewind(fp)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot rewind phar \\\"%s\\\"\")\n\t}\n\n\tbuffer[sizeof(buffer)-1] = '\\0';\n\tmemset(buffer, 32, sizeof(token));\n\thalt_offset = 0;\n\n\t/* Maybe it's better to compile the file instead of just searching,  */\n\t/* but we only want the offset. So we want a .re scanner to find it. */\n\twhile(!php_stream_eof(fp)) {\n\t\tif ((got = php_stream_read(fp, buffer+tokenlen, readsize)) < (size_t) tokenlen) {\n\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated entry)\")\n\t\t}\n\n\t\tif (!test) {\n\t\t\ttest = '\\1';\n\t\t\tpos = buffer+tokenlen;\n\t\t\tif (!memcmp(pos, gz_magic, 3)) {\n\t\t\t\tchar err = 0;\n\t\t\t\tphp_stream_filter *filter;\n\t\t\t\tphp_stream *temp;\n\t\t\t\t/* to properly decompress, we have to tell zlib to look for a zlib or gzip header */\n\t\t\t\tzval filterparams;\n\n\t\t\t\tif (!PHAR_G(has_zlib)) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\" to temporary file, enable zlib extension in php.ini\")\n\t\t\t\t}\n\t\t\t\tarray_init(&filterparams);\n/* this is defined in zlib's zconf.h */\n#ifndef MAX_WBITS\n#define MAX_WBITS 15\n#endif\n\t\t\t\tadd_assoc_long(&filterparams, \"window\", MAX_WBITS + 32);\n\n\t\t\t\t/* entire file is gzip-compressed, uncompress to temporary file */\n\t\t\t\tif (!(temp = php_stream_fopen_tmpfile())) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to create temporary file for decompression of gzipped phar archive \\\"%s\\\"\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tfilter = php_stream_filter_create(\"zlib.inflate\", &filterparams, php_stream_is_persistent(fp) TSRMLS_CC);\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\terr = 1;\n\t\t\t\t\tadd_assoc_long(&filterparams, \"window\", MAX_WBITS);\n\t\t\t\t\tfilter = php_stream_filter_create(\"zlib.inflate\", &filterparams, php_stream_is_persistent(fp) TSRMLS_CC);\n\t\t\t\t\tzval_dtor(&filterparams);\n\n\t\t\t\t\tif (!filter) {\n\t\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\", ext/zlib is buggy in PHP versions older than 5.2.6\")\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tzval_dtor(&filterparams);\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&temp->writefilters, filter);\n\n\t\t\t\tif (SUCCESS != php_stream_copy_to_stream_ex(fp, temp, PHP_STREAM_COPY_ALL, NULL)) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\", ext/zlib is buggy in PHP versions older than 5.2.6\")\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\" to temporary file\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tfp = temp;\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tcompression = PHAR_FILE_COMPRESSED_GZ;\n\n\t\t\t\t/* now, start over */\n\t\t\t\ttest = '\\0';\n\t\t\t\tcontinue;\n\t\t\t} else if (!memcmp(pos, bz_magic, 3)) {\n\t\t\t\tphp_stream_filter *filter;\n\t\t\t\tphp_stream *temp;\n\n\t\t\t\tif (!PHAR_G(has_bz2)) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress bzipped phar archive \\\"%s\\\" to temporary file, enable bz2 extension in php.ini\")\n\t\t\t\t}\n\n\t\t\t\t/* entire file is bzip-compressed, uncompress to temporary file */\n\t\t\t\tif (!(temp = php_stream_fopen_tmpfile())) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to create temporary file for decompression of bzipped phar archive \\\"%s\\\"\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tfilter = php_stream_filter_create(\"bzip2.decompress\", NULL, php_stream_is_persistent(fp) TSRMLS_CC);\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress bzipped phar archive \\\"%s\\\", filter creation failed\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&temp->writefilters, filter);\n\n\t\t\t\tif (SUCCESS != php_stream_copy_to_stream_ex(fp, temp, PHP_STREAM_COPY_ALL, NULL)) {\n\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress bzipped phar archive \\\"%s\\\" to temporary file\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tfp = temp;\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tcompression = PHAR_FILE_COMPRESSED_BZ2;\n\n\t\t\t\t/* now, start over */\n\t\t\t\ttest = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!memcmp(pos, zip_magic, 4)) {\n\t\t\t\tphp_stream_seek(fp, 0, SEEK_END);\n\t\t\t\treturn phar_parse_zipfile(fp, fname, fname_len, alias, alias_len, pphar, error TSRMLS_CC);\n\t\t\t}\n\n\t\t\tif (got > 512) {\n\t\t\t\tif (phar_is_tar(pos, fname)) {\n\t\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\t\treturn phar_parse_tarfile(fp, fname, fname_len, alias, alias_len, pphar, is_data, compression, error TSRMLS_CC);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (got > 0 && (pos = phar_strnstr(buffer, got + sizeof(token), token, sizeof(token)-1)) != NULL) {\n\t\t\thalt_offset += (pos - buffer); /* no -tokenlen+tokenlen here */\n\t\t\treturn phar_parse_pharfile(fp, fname, fname_len, alias, alias_len, halt_offset, pphar, compression, error TSRMLS_CC);\n\t\t}\n\n\t\thalt_offset += got;\n\t\tmemmove(buffer, buffer + window_size, tokenlen); /* move the memory buffer by the size of the window */\n\t}\n\n\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (__HALT_COMPILER(); not found)\")\n}\n/* }}} */\n\n/*\n * given the location of the file extension and the start of the file path,\n * determine the end of the portion of the path (i.e. /path/to/file.ext/blah\n * grabs \"/path/to/file.ext\" as does the straight /path/to/file.ext),\n * stat it to determine if it exists.\n * if so, check to see if it is a directory and fail if so\n * if not, check to see if its dirname() exists (i.e. \"/path/to\") and is a directory\n * succeed if we are creating the file, otherwise fail.\n */\nstatic int phar_analyze_path(const char *fname, const char *ext, int ext_len, int for_create TSRMLS_DC) /* {{{ */\n{\n\tphp_stream_statbuf ssb;\n\tchar *realpath;\n\tchar *filename = estrndup(fname, (ext - fname) + ext_len);\n\n\tif ((realpath = expand_filepath(filename, NULL TSRMLS_CC))) {\n#ifdef PHP_WIN32\n\t\tphar_unixify_path_separators(realpath, strlen(realpath));\n#endif\n\t\tif (zend_hash_exists(&(PHAR_GLOBALS->phar_fname_map), realpath, strlen(realpath))) {\n\t\t\tefree(realpath);\n\t\t\tefree(filename);\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && zend_hash_exists(&cached_phars, realpath, strlen(realpath))) {\n\t\t\tefree(realpath);\n\t\t\tefree(filename);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tefree(realpath);\n\t}\n\n\tif (SUCCESS == php_stream_stat_path((char *) filename, &ssb)) {\n\n\t\tefree(filename);\n\n\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tif (for_create == 1) {\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\treturn SUCCESS;\n\t} else {\n\t\tchar *slash;\n\n\t\tif (!for_create) {\n\t\t\tefree(filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tslash = (char *) strrchr(filename, '/');\n\n\t\tif (slash) {\n\t\t\t*slash = '\\0';\n\t\t}\n\n\t\tif (SUCCESS != php_stream_stat_path((char *) filename, &ssb)) {\n\t\t\tif (!slash) {\n\t\t\t\tif (!(realpath = expand_filepath(filename, NULL TSRMLS_CC))) {\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n#ifdef PHP_WIN32\n\t\t\t\tphar_unixify_path_separators(realpath, strlen(realpath));\n#endif\n\t\t\t\tslash = strstr(realpath, filename);\n\t\t\t\tif (slash) {\n\t\t\t\t\tslash += ((ext - fname) + ext_len);\n\t\t\t\t\t*slash = '\\0';\n\t\t\t\t}\n\t\t\t\tslash = strrchr(realpath, '/');\n\n\t\t\t\tif (slash) {\n\t\t\t\t\t*slash = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tefree(realpath);\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (SUCCESS != php_stream_stat_path(realpath, &ssb)) {\n\t\t\t\t\tefree(realpath);\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tefree(realpath);\n\n\t\t\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tefree(filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tefree(filename);\n\n\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\treturn FAILURE;\n\t}\n}\n/* }}} */\n\n/* check for \".phar\" in extension */\nstatic int phar_check_str(const char *fname, const char *ext_str, int ext_len, int executable, int for_create TSRMLS_DC) /* {{{ */\n{\n\tchar test[51];\n\tconst char *pos;\n\n\tif (ext_len >= 50) {\n\t\treturn FAILURE;\n\t}\n\n\tif (executable == 1) {\n\t\t/* copy \".\" as well */\n\t\tmemcpy(test, ext_str - 1, ext_len + 1);\n\t\ttest[ext_len + 1] = '\\0';\n\t\t/* executable phars must contain \".phar\" as a valid extension (phar://.pharmy/oops is invalid) */\n\t\t/* (phar://hi/there/.phar/oops is also invalid) */\n\t\tpos = strstr(test, \".phar\");\n\n\t\tif (pos && (*(pos - 1) != '/')\n\t\t\t\t&& (pos += 5) && (*pos == '\\0' || *pos == '/' || *pos == '.')) {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create TSRMLS_CC);\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\t/* data phars need only contain a single non-\".\" to be valid */\n\tif (!executable) {\n\t\tpos = strstr(ext_str, \".phar\");\n\t\tif (!(pos && (*(pos - 1) != '/')\n\t\t\t\t\t&& (pos += 5) && (*pos == '\\0' || *pos == '/' || *pos == '.')) && *(ext_str + 1) != '.' && *(ext_str + 1) != '/' && *(ext_str + 1) != '\\0') {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create TSRMLS_CC);\n\t\t}\n\t} else {\n\t\tif (*(ext_str + 1) != '.' && *(ext_str + 1) != '/' && *(ext_str + 1) != '\\0') {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create TSRMLS_CC);\n\t\t}\n\t}\n\n\treturn FAILURE;\n}\n/* }}} */\n\n/*\n * if executable is 1, only returns SUCCESS if the extension is one of the tar/zip .phar extensions\n * if executable is 0, it returns SUCCESS only if the filename does *not* contain \".phar\" anywhere, and treats\n * the first extension as the filename extension\n *\n * if an extension is found, it sets ext_str to the location of the file extension in filename,\n * and ext_len to the length of the extension.\n * for urls like \"phar://alias/oops\" it instead sets ext_len to -1 and returns FAILURE, which tells\n * the calling function to use \"alias\" as the phar alias\n *\n * the last parameter should be set to tell the thing to assume that filename is the full path, and only to check the\n * extension rules, not to iterate.\n */\nint phar_detect_phar_fname_ext(const char *filename, int filename_len, const char **ext_str, int *ext_len, int executable, int for_create, int is_complete TSRMLS_DC) /* {{{ */\n{\n\tconst char *pos, *slash;\n\n\t*ext_str = NULL;\n\t*ext_len = 0;\n\n\tif (!filename_len || filename_len == 1) {\n\t\treturn FAILURE;\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\t/* first check for alias in first segment */\n\tpos = memchr(filename, '/', filename_len);\n\n\tif (pos && pos != filename) {\n\t\t/* check for url like http:// or phar:// */\n\t\tif (*(pos - 1) == ':' && (pos - filename) < filename_len - 1 && *(pos + 1) == '/') {\n\t\t\t*ext_len = -2;\n\t\t\t*ext_str = NULL;\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (zend_hash_exists(&(PHAR_GLOBALS->phar_alias_map), (char *) filename, pos - filename)) {\n\t\t\t*ext_str = pos;\n\t\t\t*ext_len = -1;\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && zend_hash_exists(&cached_alias, (char *) filename, pos - filename)) {\n\t\t\t*ext_str = pos;\n\t\t\t*ext_len = -1;\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (zend_hash_num_elements(&(PHAR_GLOBALS->phar_fname_map)) || PHAR_G(manifest_cached)) {\n\t\tphar_archive_data **pphar;\n\n\t\tif (is_complete) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), (char *) filename, filename_len, (void **)&pphar)) {\n\t\t\t\t*ext_str = filename + (filename_len - (*pphar)->ext_len);\nwoohoo:\n\t\t\t\t*ext_len = (*pphar)->ext_len;\n\n\t\t\t\tif (executable == 2) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\n\t\t\t\tif (executable == 1 && !(*pphar)->is_data) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\n\t\t\t\tif (!executable && (*pphar)->is_data) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, (char *) filename, filename_len, (void **)&pphar)) {\n\t\t\t\t*ext_str = filename + (filename_len - (*pphar)->ext_len);\n\t\t\t\tgoto woohoo;\n\t\t\t}\n\t\t} else {\n\t\t\tchar *str_key;\n\t\t\tuint keylen;\n\t\t\tulong unused;\n\n\t\t\tfor (zend_hash_internal_pointer_reset(&(PHAR_GLOBALS->phar_fname_map));\n\t\t\t\tHASH_KEY_NON_EXISTENT != zend_hash_get_current_key_ex(&(PHAR_GLOBALS->phar_fname_map), &str_key, &keylen, &unused, 0, NULL);\n\t\t\t\tzend_hash_move_forward(&(PHAR_GLOBALS->phar_fname_map))\n\t\t\t) {\n\t\t\t\tif (keylen > (uint) filename_len) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!memcmp(filename, str_key, keylen) && ((uint)filename_len == keylen\n\t\t\t\t\t|| filename[keylen] == '/' || filename[keylen] == '\\0')) {\n\t\t\t\t\tif (FAILURE == zend_hash_get_current_data(&(PHAR_GLOBALS->phar_fname_map), (void **) &pphar)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*ext_str = filename + (keylen - (*pphar)->ext_len);\n\t\t\t\t\tgoto woohoo;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (PHAR_G(manifest_cached)) {\n\t\t\t\tfor (zend_hash_internal_pointer_reset(&cached_phars);\n\t\t\t\t\tHASH_KEY_NON_EXISTENT != zend_hash_get_current_key_ex(&cached_phars, &str_key, &keylen, &unused, 0, NULL);\n\t\t\t\t\tzend_hash_move_forward(&cached_phars)\n\t\t\t\t) {\n\t\t\t\t\tif (keylen > (uint) filename_len) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!memcmp(filename, str_key, keylen) && ((uint)filename_len == keylen\n\t\t\t\t\t\t|| filename[keylen] == '/' || filename[keylen] == '\\0')) {\n\t\t\t\t\t\tif (FAILURE == zend_hash_get_current_data(&cached_phars, (void **) &pphar)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*ext_str = filename + (keylen - (*pphar)->ext_len);\n\t\t\t\t\t\tgoto woohoo;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpos = memchr(filename + 1, '.', filename_len);\nnext_extension:\n\tif (!pos) {\n\t\treturn FAILURE;\n\t}\n\n\twhile (pos != filename && (*(pos - 1) == '/' || *(pos - 1) == '\\0')) {\n\t\tpos = memchr(pos + 1, '.', filename_len - (pos - filename) + 1);\n\t\tif (!pos) {\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tslash = memchr(pos, '/', filename_len - (pos - filename));\n\n\tif (!slash) {\n\t\t/* this is a url like \"phar://blah.phar\" with no directory */\n\t\t*ext_str = pos;\n\t\t*ext_len = strlen(pos);\n\n\t\t/* file extension must contain \"phar\" */\n\t\tswitch (phar_check_str(filename, *ext_str, *ext_len, executable, for_create TSRMLS_CC)) {\n\t\t\tcase SUCCESS:\n\t\t\t\treturn SUCCESS;\n\t\t\tcase FAILURE:\n\t\t\t\t/* we are at the end of the string, so we fail */\n\t\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\t/* we've found an extension that ends at a directory separator */\n\t*ext_str = pos;\n\t*ext_len = slash - pos;\n\n\tswitch (phar_check_str(filename, *ext_str, *ext_len, executable, for_create TSRMLS_CC)) {\n\t\tcase SUCCESS:\n\t\t\treturn SUCCESS;\n\t\tcase FAILURE:\n\t\t\t/* look for more extensions */\n\t\t\tpos = strchr(pos + 1, '.');\n\t\t\tif (pos) {\n\t\t\t\t*ext_str = NULL;\n\t\t\t\t*ext_len = 0;\n\t\t\t}\n\t\t\tgoto next_extension;\n\t}\n\n\treturn FAILURE;\n}\n/* }}} */\n\nstatic int php_check_dots(const char *element, int n) /* {{{ */\n{\n\tfor(n--; n >= 0; --n) {\n\t\tif (element[n] != '.') {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n/* }}} */\n\n#define IS_DIRECTORY_UP(element, len) \\\n\t(len >= 2 && !php_check_dots(element, len))\n\n#define IS_DIRECTORY_CURRENT(element, len) \\\n\t(len == 1 && element[0] == '.')\n\n#define IS_BACKSLASH(c) ((c) == '/')\n\n#ifdef COMPILE_DL_PHAR\n/* stupid-ass non-extern declaration in tsrm_strtok.h breaks dumbass MS compiler */\nstatic inline int in_character_class(char ch, const char *delim) /* {{{ */\n{\n\twhile (*delim) {\n\t\tif (*delim == ch) {\n\t\t\treturn 1;\n\t\t}\n\t\t++delim;\n\t}\n\treturn 0;\n}\n/* }}} */\n\nchar *tsrm_strtok_r(char *s, const char *delim, char **last) /* {{{ */\n{\n\tchar *token;\n\n\tif (s == NULL) {\n\t\ts = *last;\n\t}\n\n\twhile (*s && in_character_class(*s, delim)) {\n\t\t++s;\n\t}\n\n\tif (!*s) {\n\t\treturn NULL;\n\t}\n\n\ttoken = s;\n\n\twhile (*s && !in_character_class(*s, delim)) {\n\t\t++s;\n\t}\n\n\tif (!*s) {\n\t\t*last = s;\n\t} else {\n\t\t*s = '\\0';\n\t\t*last = s + 1;\n\t}\n\n\treturn token;\n}\n/* }}} */\n#endif\n\n/**\n * Remove .. and . references within a phar filename\n */\nchar *phar_fix_filepath(char *path, int *new_len, int use_cwd TSRMLS_DC) /* {{{ */\n{\n\tchar *newpath;\n\tint newpath_len;\n\tchar *ptr;\n\tchar *tok;\n\tint ptr_length, path_length = *new_len;\n\n\tif (PHAR_G(cwd_len) && use_cwd && path_length > 2 && path[0] == '.' && path[1] == '/') {\n\t\tnewpath_len = PHAR_G(cwd_len);\n\t\tnewpath = emalloc(strlen(path) + newpath_len + 1);\n\t\tmemcpy(newpath, PHAR_G(cwd), newpath_len);\n\t} else {\n\t\tnewpath = emalloc(strlen(path) + 2);\n\t\tnewpath[0] = '/';\n\t\tnewpath_len = 1;\n\t}\n\n\tptr = path;\n\n\tif (*ptr == '/') {\n\t\t++ptr;\n\t}\n\n\ttok = ptr;\n\n\tdo {\n\t\tptr = memchr(ptr, '/', path_length - (ptr - path));\n\t} while (ptr && ptr - tok == 0 && *ptr == '/' && ++ptr && ++tok);\n\n\tif (!ptr && (path_length - (tok - path))) {\n\t\tswitch (path_length - (tok - path)) {\n\t\t\tcase 1:\n\t\t\t\tif (*tok == '.') {\n\t\t\t\t\tefree(path);\n\t\t\t\t\t*new_len = 1;\n\t\t\t\t\tefree(newpath);\n\t\t\t\t\treturn estrndup(\"/\", 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (tok[0] == '.' && tok[1] == '.') {\n\t\t\t\t\tefree(path);\n\t\t\t\t\t*new_len = 1;\n\t\t\t\t\tefree(newpath);\n\t\t\t\t\treturn estrndup(\"/\", 1);\n\t\t\t\t}\n\t\t}\n\t\tefree(newpath);\n\t\treturn path;\n\t}\n\n\twhile (ptr) {\n\t\tptr_length = ptr - tok;\nlast_time:\n\t\tif (IS_DIRECTORY_UP(tok, ptr_length)) {\n#define PREVIOUS newpath[newpath_len - 1]\n\n\t\t\twhile (newpath_len > 1 && !IS_BACKSLASH(PREVIOUS)) {\n\t\t\t\tnewpath_len--;\n\t\t\t}\n\n\t\t\tif (newpath[0] != '/') {\n\t\t\t\tnewpath[newpath_len] = '\\0';\n\t\t\t} else if (newpath_len > 1) {\n\t\t\t\t--newpath_len;\n\t\t\t}\n\t\t} else if (!IS_DIRECTORY_CURRENT(tok, ptr_length)) {\n\t\t\tif (newpath_len > 1) {\n\t\t\t\tnewpath[newpath_len++] = '/';\n\t\t\t\tmemcpy(newpath + newpath_len, tok, ptr_length+1);\n\t\t\t} else {\n\t\t\t\tmemcpy(newpath + newpath_len, tok, ptr_length+1);\n\t\t\t}\n\n\t\t\tnewpath_len += ptr_length;\n\t\t}\n\n\t\tif (ptr == path + path_length) {\n\t\t\tbreak;\n\t\t}\n\n\t\ttok = ++ptr;\n\n\t\tdo {\n\t\t\tptr = memchr(ptr, '/', path_length - (ptr - path));\n\t\t} while (ptr && ptr - tok == 0 && *ptr == '/' && ++ptr && ++tok);\n\n\t\tif (!ptr && (path_length - (tok - path))) {\n\t\t\tptr_length = path_length - (tok - path);\n\t\t\tptr = path + path_length;\n\t\t\tgoto last_time;\n\t\t}\n\t}\n\n\tefree(path);\n\t*new_len = newpath_len;\n\tnewpath[newpath_len] = '\\0';\n\treturn erealloc(newpath, newpath_len + 1);\n}\n/* }}} */\n\n/**\n * Process a phar stream name, ensuring we can handle any of:\n *\n * - whatever.phar\n * - whatever.phar.gz\n * - whatever.phar.bz2\n * - whatever.phar.php\n *\n * Optionally the name might start with 'phar://'\n *\n * This is used by phar_parse_url()\n */\nint phar_split_fname(const char *filename, int filename_len, char **arch, int *arch_len, char **entry, int *entry_len, int executable, int for_create TSRMLS_DC) /* {{{ */\n{\n\tconst char *ext_str;\n#ifdef PHP_WIN32\n\tchar *save;\n#endif\n\tint ext_len;\n\n\tif (CHECK_NULL_PATH(filename, filename_len)) {\n\t\treturn FAILURE;\n\t}\n\n\tif (!strncasecmp(filename, \"phar://\", 7)) {\n\t\tfilename += 7;\n\t\tfilename_len -= 7;\n\t}\n\n\text_len = 0;\n#ifdef PHP_WIN32\n\tsave = filename;\n\tfilename = estrndup(filename, filename_len);\n\tphar_unixify_path_separators(filename, filename_len);\n#endif\n\tif (phar_detect_phar_fname_ext(filename, filename_len, &ext_str, &ext_len, executable, for_create, 0 TSRMLS_CC) == FAILURE) {\n\t\tif (ext_len != -1) {\n\t\t\tif (!ext_str) {\n\t\t\t\t/* no / detected, restore arch for error message */\n#ifdef PHP_WIN32\n\t\t\t\t*arch = save;\n#else\n\t\t\t\t*arch = filename;\n#endif\n\t\t\t}\n\n#ifdef PHP_WIN32\n\t\t\tefree(filename);\n#endif\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\text_len = 0;\n\t\t/* no extension detected - instead we are dealing with an alias */\n\t}\n\n\t*arch_len = ext_str - filename + ext_len;\n\t*arch = estrndup(filename, *arch_len);\n\n\tif (ext_str[ext_len]) {\n\t\t*entry_len = filename_len - *arch_len;\n\t\t*entry = estrndup(ext_str+ext_len, *entry_len);\n#ifdef PHP_WIN32\n\t\tphar_unixify_path_separators(*entry, *entry_len);\n#endif\n\t\t*entry = phar_fix_filepath(*entry, entry_len, 0 TSRMLS_CC);\n\t} else {\n\t\t*entry_len = 1;\n\t\t*entry = estrndup(\"/\", 1);\n\t}\n\n#ifdef PHP_WIN32\n\tefree(filename);\n#endif\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/**\n * Invoked when a user calls Phar::mapPhar() from within an executing .phar\n * to set up its manifest directly\n */\nint phar_open_executed_filename(char *alias, int alias_len, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar *fname;\n\tzval *halt_constant;\n\tphp_stream *fp;\n\tint fname_len;\n\tchar *actual = NULL;\n\tint ret;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tfname = (char*)zend_get_executed_filename(TSRMLS_C);\n\tfname_len = strlen(fname);\n\n\tif (phar_open_parsed_phar(fname, fname_len, alias, alias_len, 0, REPORT_ERRORS, NULL, 0 TSRMLS_CC) == SUCCESS) {\n\t\treturn SUCCESS;\n\t}\n\n\tif (!strcmp(fname, \"[no active file]\")) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"cannot initialize a phar outside of PHP execution\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tMAKE_STD_ZVAL(halt_constant);\n\n\tif (0 == zend_get_constant(\"__COMPILER_HALT_OFFSET__\", 24, halt_constant TSRMLS_CC)) {\n\t\tFREE_ZVAL(halt_constant);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"__HALT_COMPILER(); must be declared in a phar\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tFREE_ZVAL(halt_constant);\n\n#if PHP_API_VERSION < 20100412\n\tif (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {\n\t\treturn FAILURE;\n\t}\n#endif\n\n\tif (php_check_open_basedir(fname TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tfp = php_stream_open_wrapper(fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK|REPORT_ERRORS, &actual);\n\n\tif (!fp) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to open phar for reading \\\"%s\\\"\", fname);\n\t\t}\n\t\tif (actual) {\n\t\t\tefree(actual);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (actual) {\n\t\tfname = actual;\n\t\tfname_len = strlen(actual);\n\t}\n\n\tret = phar_open_from_fp(fp, fname, fname_len, alias, alias_len, REPORT_ERRORS, NULL, 0, error TSRMLS_CC);\n\n\tif (actual) {\n\t\tefree(actual);\n\t}\n\n\treturn ret;\n}\n/* }}} */\n\n/**\n * Validate the CRC32 of a file opened from within the phar\n */\nint phar_postprocess_file(phar_entry_data *idata, php_uint32 crc32, char **error, int process_zip TSRMLS_DC) /* {{{ */\n{\n\tphp_uint32 crc = ~0;\n\tint len = idata->internal_file->uncompressed_filesize;\n\tphp_stream *fp = idata->fp;\n\tphar_entry_info *entry = idata->internal_file;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (entry->is_zip && process_zip > 0) {\n\t\t/* verify local file header */\n\t\tphar_zip_file_header local;\n\t\tphar_zip_data_desc desc;\n\n\t\tif (SUCCESS != phar_open_archive_fp(idata->phar TSRMLS_CC)) {\n\t\t\tspprintf(error, 0, \"phar error: unable to open zip-based phar archive \\\"%s\\\" to verify local file header for file \\\"%s\\\"\", idata->phar->fname, entry->filename);\n\t\t\treturn FAILURE;\n\t\t}\n\t\tphp_stream_seek(phar_get_entrypfp(idata->internal_file TSRMLS_CC), entry->header_offset, SEEK_SET);\n\n\t\tif (sizeof(local) != php_stream_read(phar_get_entrypfp(idata->internal_file TSRMLS_CC), (char *) &local, sizeof(local))) {\n\n\t\t\tspprintf(error, 0, \"phar error: internal corruption of zip-based phar \\\"%s\\\" (cannot read local file header for file \\\"%s\\\")\", idata->phar->fname, entry->filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\t/* check for data descriptor */\n\t\tif (((PHAR_ZIP_16(local.flags)) & 0x8) == 0x8) {\n\t\t\tphp_stream_seek(phar_get_entrypfp(idata->internal_file TSRMLS_CC),\n\t\t\t\t\tentry->header_offset + sizeof(local) +\n\t\t\t\t\tPHAR_ZIP_16(local.filename_len) +\n\t\t\t\t\tPHAR_ZIP_16(local.extra_len) +\n\t\t\t\t\tentry->compressed_filesize, SEEK_SET);\n\t\t\tif (sizeof(desc) != php_stream_read(phar_get_entrypfp(idata->internal_file TSRMLS_CC),\n\t\t\t\t\t\t\t    (char *) &desc, sizeof(desc))) {\n\t\t\t\tspprintf(error, 0, \"phar error: internal corruption of zip-based phar \\\"%s\\\" (cannot read local data descriptor for file \\\"%s\\\")\", idata->phar->fname, entry->filename);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tif (desc.signature[0] == 'P' && desc.signature[1] == 'K') {\n\t\t\t\tmemcpy(&(local.crc32), &(desc.crc32), 12);\n\t\t\t} else {\n\t\t\t\t/* old data descriptors have no signature */\n\t\t\t\tmemcpy(&(local.crc32), &desc, 12);\n\t\t\t}\n\t\t}\n\t\t/* verify local header */\n\t\tif (entry->filename_len != PHAR_ZIP_16(local.filename_len) || entry->crc32 != PHAR_ZIP_32(local.crc32) || entry->uncompressed_filesize != PHAR_ZIP_32(local.uncompsize) || entry->compressed_filesize != PHAR_ZIP_32(local.compsize)) {\n\t\t\tspprintf(error, 0, \"phar error: internal corruption of zip-based phar \\\"%s\\\" (local header of file \\\"%s\\\" does not match central directory)\", idata->phar->fname, entry->filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\t/* construct actual offset to file start - local extra_len can be different from central extra_len */\n\t\tentry->offset = entry->offset_abs =\n\t\t\tsizeof(local) + entry->header_offset + PHAR_ZIP_16(local.filename_len) + PHAR_ZIP_16(local.extra_len);\n\n\t\tif (idata->zero && idata->zero != entry->offset_abs) {\n\t\t\tidata->zero = entry->offset_abs;\n\t\t}\n\t}\n\n\tif (process_zip == 1) {\n\t\treturn SUCCESS;\n\t}\n\n\tphp_stream_seek(fp, idata->zero, SEEK_SET);\n\n\twhile (len--) {\n\t\tCRC32(crc, php_stream_getc(fp));\n\t}\n\n\tphp_stream_seek(fp, idata->zero, SEEK_SET);\n\n\tif (~crc == crc32) {\n\t\tentry->is_crc_checked = 1;\n\t\treturn SUCCESS;\n\t} else {\n\t\tspprintf(error, 0, \"phar error: internal corruption of phar \\\"%s\\\" (crc32 mismatch on file \\\"%s\\\")\", idata->phar->fname, entry->filename);\n\t\treturn FAILURE;\n\t}\n}\n/* }}} */\n\nstatic inline void phar_set_32(char *buffer, int var) /* {{{ */\n{\n#ifdef WORDS_BIGENDIAN\n\t*((buffer) + 3) = (unsigned char) (((var) >> 24) & 0xFF);\n\t*((buffer) + 2) = (unsigned char) (((var) >> 16) & 0xFF);\n\t*((buffer) + 1) = (unsigned char) (((var) >> 8) & 0xFF);\n\t*((buffer) + 0) = (unsigned char) ((var) & 0xFF);\n#else\n\t memcpy(buffer, &var, sizeof(var));\n#endif\n} /* }}} */\n\nstatic int phar_flush_clean_deleted_apply(void *data TSRMLS_DC) /* {{{ */\n{\n\tphar_entry_info *entry = (phar_entry_info *)data;\n\n\tif (entry->fp_refcount <= 0 && entry->is_deleted) {\n\t\treturn ZEND_HASH_APPLY_REMOVE;\n\t} else {\n\t\treturn ZEND_HASH_APPLY_KEEP;\n\t}\n}\n/* }}} */\n\n#include \"stub.h\"\n\nchar *phar_create_default_stub(const char *index_php, const char *web_index, size_t *len, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar *stub = NULL;\n\tint index_len, web_len;\n\tsize_t dummy;\n\n\tif (!len) {\n\t\tlen = &dummy;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (!index_php) {\n\t\tindex_php = \"index.php\";\n\t}\n\n\tif (!web_index) {\n\t\tweb_index = \"index.php\";\n\t}\n\n\tindex_len = strlen(index_php);\n\tweb_len = strlen(web_index);\n\n\tif (index_len > 400) {\n\t\t/* ridiculous size not allowed for index.php startup filename */\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"Illegal filename passed in for stub creation, was %d characters long, and only 400 or less is allowed\", index_len);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (web_len > 400) {\n\t\t/* ridiculous size not allowed for index.php startup filename */\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"Illegal web filename passed in for stub creation, was %d characters long, and only 400 or less is allowed\", web_len);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tphar_get_stub(index_php, web_index, len, &stub, index_len+1, web_len+1 TSRMLS_CC);\n\treturn stub;\n}\n/* }}} */\n\n/**\n * Save phar contents to disk\n *\n * user_stub contains either a string, or a resource pointer, if len is a negative length.\n * user_stub and len should be both 0 if the default or existing stub should be used\n */\nint phar_flush(phar_archive_data *phar, char *user_stub, long len, int convert, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar halt_stub[] = \"__HALT_COMPILER();\";\n\tchar *newstub, *tmp;\n\tphar_entry_info *entry, *newentry;\n\tint halt_offset, restore_alias_len, global_flags = 0, closeoldfile;\n\tchar *pos, has_dirs = 0;\n\tchar manifest[18], entry_buffer[24];\n\toff_t manifest_ftell;\n\tlong offset;\n\tsize_t wrote;\n\tphp_uint32 manifest_len, mytime, loc, new_manifest_count;\n\tphp_uint32 newcrc32;\n\tphp_stream *file, *oldfile, *newfile, *stubfile;\n\tphp_stream_filter *filter;\n\tphp_serialize_data_t metadata_hash;\n\tsmart_str main_metadata_str = {0};\n\tint free_user_stub, free_fp = 1, free_ufp = 1;\n\tint manifest_hack = 0;\n\n\tif (phar->is_persistent) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"internal error: attempt to flush cached zip-based phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\t\treturn EOF;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (!zend_hash_num_elements(&phar->manifest) && !user_stub) {\n\t\treturn EOF;\n\t}\n\n\tzend_hash_clean(&phar->virtual_dirs);\n\n\tif (phar->is_zip) {\n\t\treturn phar_zip_flush(phar, user_stub, len, convert, error TSRMLS_CC);\n\t}\n\n\tif (phar->is_tar) {\n\t\treturn phar_tar_flush(phar, user_stub, len, convert, error TSRMLS_CC);\n\t}\n\n\tif (PHAR_G(readonly)) {\n\t\treturn EOF;\n\t}\n\n\tif (phar->fp && !phar->is_brandnew) {\n\t\toldfile = phar->fp;\n\t\tcloseoldfile = 0;\n\t\tphp_stream_rewind(oldfile);\n\t} else {\n\t\toldfile = php_stream_open_wrapper(phar->fname, \"rb\", 0, NULL);\n\t\tcloseoldfile = oldfile != NULL;\n\t}\n\tnewfile = php_stream_fopen_tmpfile();\n\tif (!newfile) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to create temporary file\");\n\t\t}\n\t\tif (closeoldfile) {\n\t\t\tphp_stream_close(oldfile);\n\t\t}\n\t\treturn EOF;\n\t}\n\n\tif (user_stub) {\n\t\tif (len < 0) {\n\t\t\t/* resource passed in */\n\t\t\tif (!(php_stream_from_zval_no_verify(stubfile, (zval **)user_stub))) {\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to access resource to copy stub to new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\tif (len == -1) {\n\t\t\t\tlen = PHP_STREAM_COPY_ALL;\n\t\t\t} else {\n\t\t\t\tlen = -len;\n\t\t\t}\n\t\t\tuser_stub = 0;\n\n\t\t\tif (!(len = php_stream_copy_to_mem(stubfile, &user_stub, len, 0)) || !user_stub) {\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to read resource to copy stub to new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\tfree_user_stub = 1;\n\t\t} else {\n\t\t\tfree_user_stub = 0;\n\t\t}\n\t\ttmp = estrndup(user_stub, len);\n\t\tif ((pos = php_stristr(tmp, halt_stub, len, sizeof(halt_stub) - 1)) == NULL) {\n\t\t\tefree(tmp);\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"illegal stub for phar \\\"%s\\\"\", phar->fname);\n\t\t\t}\n\t\t\tif (free_user_stub) {\n\t\t\t\tefree(user_stub);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tpos = user_stub + (pos - tmp);\n\t\tefree(tmp);\n\t\tlen = pos - user_stub + 18;\n\t\tif ((size_t)len != php_stream_write(newfile, user_stub, len)\n\t\t||\t\t\t  5 != php_stream_write(newfile, \" ?>\\r\\n\", 5)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to create stub from string in new phar \\\"%s\\\"\", phar->fname);\n\t\t\t}\n\t\t\tif (free_user_stub) {\n\t\t\t\tefree(user_stub);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tphar->halt_offset = len + 5;\n\t\tif (free_user_stub) {\n\t\t\tefree(user_stub);\n\t\t}\n\t} else {\n\t\tsize_t written;\n\n\t\tif (!user_stub && phar->halt_offset && oldfile && !phar->is_brandnew) {\n\t\t\tphp_stream_copy_to_stream_ex(oldfile, newfile, phar->halt_offset, &written);\n\t\t\tnewstub = NULL;\n\t\t} else {\n\t\t\t/* this is either a brand new phar or a default stub overwrite */\n\t\t\tnewstub = phar_create_default_stub(NULL, NULL, &(phar->halt_offset), NULL TSRMLS_CC);\n\t\t\twritten = php_stream_write(newfile, newstub, phar->halt_offset);\n\t\t}\n\t\tif (phar->halt_offset != written) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tif (newstub) {\n\t\t\t\t\tspprintf(error, 0, \"unable to create stub in new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t} else {\n\t\t\t\t\tspprintf(error, 0, \"unable to copy stub of old phar to new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newstub) {\n\t\t\t\tefree(newstub);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tif (newstub) {\n\t\t\tefree(newstub);\n\t\t}\n\t}\n\tmanifest_ftell = php_stream_tell(newfile);\n\thalt_offset = manifest_ftell;\n\n\t/* Check whether we can get rid of some of the deleted entries which are\n\t * unused. However some might still be in use so even after this clean-up\n\t * we need to skip entries marked is_deleted. */\n\tzend_hash_apply(&phar->manifest, phar_flush_clean_deleted_apply TSRMLS_CC);\n\n\t/* compress as necessary, calculate crcs, serialize meta-data, manifest size, and file sizes */\n\tmain_metadata_str.c = 0;\n\tif (phar->metadata) {\n\t\tPHP_VAR_SERIALIZE_INIT(metadata_hash);\n\t\tphp_var_serialize(&main_metadata_str, &phar->metadata, &metadata_hash TSRMLS_CC);\n\t\tPHP_VAR_SERIALIZE_DESTROY(metadata_hash);\n\t} else {\n\t\tmain_metadata_str.len = 0;\n\t}\n\tnew_manifest_count = 0;\n\toffset = 0;\n\tfor (zend_hash_internal_pointer_reset(&phar->manifest);\n\t\tzend_hash_has_more_elements(&phar->manifest) == SUCCESS;\n\t\tzend_hash_move_forward(&phar->manifest)) {\n\t\tif (zend_hash_get_current_data(&phar->manifest, (void **)&entry) == FAILURE) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->cfp) {\n\t\t\t/* did we forget to get rid of cfp last time? */\n\t\t\tphp_stream_close(entry->cfp);\n\t\t\tentry->cfp = 0;\n\t\t}\n\t\tif (entry->is_deleted || entry->is_mounted) {\n\t\t\t/* remove this from the new phar */\n\t\t\tcontinue;\n\t\t}\n\t\tif (!entry->is_modified && entry->fp_refcount) {\n\t\t\t/* open file pointers refer to this fp, do not free the stream */\n\t\t\tswitch (entry->fp_type) {\n\t\t\t\tcase PHAR_FP:\n\t\t\t\t\tfree_fp = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PHAR_UFP:\n\t\t\t\t\tfree_ufp = 0;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* after excluding deleted files, calculate manifest size in bytes and number of entries */\n\t\t++new_manifest_count;\n\t\tphar_add_virtual_dirs(phar, entry->filename, entry->filename_len TSRMLS_CC);\n\n\t\tif (entry->is_dir) {\n\t\t\t/* we use this to calculate API version, 1.1.1 is used for phars with directories */\n\t\t\thas_dirs = 1;\n\t\t}\n\t\tif (entry->metadata) {\n\t\t\tif (entry->metadata_str.c) {\n\t\t\t\tsmart_str_free(&entry->metadata_str);\n\t\t\t}\n\t\t\tentry->metadata_str.c = 0;\n\t\t\tentry->metadata_str.len = 0;\n\t\t\tPHP_VAR_SERIALIZE_INIT(metadata_hash);\n\t\t\tphp_var_serialize(&entry->metadata_str, &entry->metadata, &metadata_hash TSRMLS_CC);\n\t\t\tPHP_VAR_SERIALIZE_DESTROY(metadata_hash);\n\t\t} else {\n\t\t\tif (entry->metadata_str.c) {\n\t\t\t\tsmart_str_free(&entry->metadata_str);\n\t\t\t}\n\t\t\tentry->metadata_str.c = 0;\n\t\t\tentry->metadata_str.len = 0;\n\t\t}\n\n\t\t/* 32 bits for filename length, length of filename, manifest + metadata, and add 1 for trailing / if a directory */\n\t\toffset += 4 + entry->filename_len + sizeof(entry_buffer) + entry->metadata_str.len + (entry->is_dir ? 1 : 0);\n\n\t\t/* compress and rehash as necessary */\n\t\tif ((oldfile && !entry->is_modified) || entry->is_dir) {\n\t\t\tif (entry->fp_type == PHAR_UFP) {\n\t\t\t\t/* reset so we can copy the compressed data over */\n\t\t\t\tentry->fp_type = PHAR_FP;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!phar_get_efp(entry, 0 TSRMLS_CC)) {\n\t\t\t/* re-open internal file pointer just-in-time */\n\t\t\tnewentry = phar_open_jit(phar, entry, error TSRMLS_CC);\n\t\t\tif (!newentry) {\n\t\t\t\t/* major problem re-opening, so we ignore this file and the error */\n\t\t\t\tefree(*error);\n\t\t\t\t*error = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tentry = newentry;\n\t\t}\n\t\tfile = phar_get_efp(entry, 0 TSRMLS_CC);\n\t\tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tnewcrc32 = ~0;\n\t\tmytime = entry->uncompressed_filesize;\n\t\tfor (loc = 0;loc < mytime; ++loc) {\n\t\t\tCRC32(newcrc32, php_stream_getc(file));\n\t\t}\n\t\tentry->crc32 = ~newcrc32;\n\t\tentry->is_crc_checked = 1;\n\t\tif (!(entry->flags & PHAR_ENT_COMPRESSION_MASK)) {\n\t\t\t/* not compressed */\n\t\t\tentry->compressed_filesize = entry->uncompressed_filesize;\n\t\t\tcontinue;\n\t\t}\n\t\tfilter = php_stream_filter_create(phar_compress_filter(entry, 0), NULL, 0 TSRMLS_CC);\n\t\tif (!filter) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (entry->flags & PHAR_ENT_COMPRESSED_GZ) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to gzip compress file \\\"%s\\\" to new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to bzip2 compress file \\\"%s\\\" to new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\t/* create new file that holds the compressed version */\n\t\t/* work around inability to specify freedom in write and strictness\n\t\tin read count */\n\t\tentry->cfp = php_stream_fopen_tmpfile();\n\t\tif (!entry->cfp) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to create temporary file\");\n\t\t\t}\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\treturn EOF;\n\t\t}\n\t\tphp_stream_flush(file);\n\t\tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 0 TSRMLS_CC)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tphp_stream_filter_append((&entry->cfp->writefilters), filter);\n\t\tif (SUCCESS != php_stream_copy_to_stream_ex(file, entry->cfp, entry->uncompressed_filesize, NULL)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to copy compressed file contents of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tphp_stream_filter_flush(filter, 1);\n\t\tphp_stream_flush(entry->cfp);\n\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\tphp_stream_seek(entry->cfp, 0, SEEK_END);\n\t\tentry->compressed_filesize = (php_uint32) php_stream_tell(entry->cfp);\n\t\t/* generate crc on compressed file */\n\t\tphp_stream_rewind(entry->cfp);\n\t\tentry->old_flags = entry->flags;\n\t\tentry->is_modified = 1;\n\t\tglobal_flags |= (entry->flags & PHAR_ENT_COMPRESSION_MASK);\n\t}\n\tglobal_flags |= PHAR_HDR_SIGNATURE;\n\n\t/* write out manifest pre-header */\n\t/*  4: manifest length\n\t *  4: manifest entry count\n\t *  2: phar version\n\t *  4: phar global flags\n\t *  4: alias length\n\t *  ?: the alias itself\n\t *  4: phar metadata length\n\t *  ?: phar metadata\n\t */\n\trestore_alias_len = phar->alias_len;\n\tif (phar->is_temporary_alias) {\n\t\tphar->alias_len = 0;\n\t}\n\n\tmanifest_len = offset + phar->alias_len + sizeof(manifest) + main_metadata_str.len;\n\tphar_set_32(manifest, manifest_len);\n\t/* Hack - see bug #65028, add padding byte to the end of the manifest */\n\tif(manifest[0] == '\\r' || manifest[0] == '\\n') {\n\t\tmanifest_len++;\n\t\tphar_set_32(manifest, manifest_len);\n\t\tmanifest_hack = 1;\n\t}\n\tphar_set_32(manifest+4, new_manifest_count);\n\tif (has_dirs) {\n\t\t*(manifest + 8) = (unsigned char) (((PHAR_API_VERSION) >> 8) & 0xFF);\n\t\t*(manifest + 9) = (unsigned char) (((PHAR_API_VERSION) & 0xF0));\n\t} else {\n\t\t*(manifest + 8) = (unsigned char) (((PHAR_API_VERSION_NODIR) >> 8) & 0xFF);\n\t\t*(manifest + 9) = (unsigned char) (((PHAR_API_VERSION_NODIR) & 0xF0));\n\t}\n\tphar_set_32(manifest+10, global_flags);\n\tphar_set_32(manifest+14, phar->alias_len);\n\n\t/* write the manifest header */\n\tif (sizeof(manifest) != php_stream_write(newfile, manifest, sizeof(manifest))\n\t|| (size_t)phar->alias_len != php_stream_write(newfile, phar->alias, phar->alias_len)) {\n\n\t\tif (closeoldfile) {\n\t\t\tphp_stream_close(oldfile);\n\t\t}\n\n\t\tphp_stream_close(newfile);\n\t\tphar->alias_len = restore_alias_len;\n\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to write manifest header of new phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\n\t\treturn EOF;\n\t}\n\n\tphar->alias_len = restore_alias_len;\n\n\tphar_set_32(manifest, main_metadata_str.len);\n\tif (4 != php_stream_write(newfile, manifest, 4) || (main_metadata_str.len\n\t&& main_metadata_str.len != php_stream_write(newfile, main_metadata_str.c, main_metadata_str.len))) {\n\t\tsmart_str_free(&main_metadata_str);\n\n\t\tif (closeoldfile) {\n\t\t\tphp_stream_close(oldfile);\n\t\t}\n\n\t\tphp_stream_close(newfile);\n\t\tphar->alias_len = restore_alias_len;\n\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to write manifest meta-data of new phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\n\t\treturn EOF;\n\t}\n\tsmart_str_free(&main_metadata_str);\n\n\t/* re-calculate the manifest location to simplify later code */\n\tmanifest_ftell = php_stream_tell(newfile);\n\n\t/* now write the manifest */\n\tfor (zend_hash_internal_pointer_reset(&phar->manifest);\n\t\tzend_hash_has_more_elements(&phar->manifest) == SUCCESS;\n\t\tzend_hash_move_forward(&phar->manifest)) {\n\n\t\tif (zend_hash_get_current_data(&phar->manifest, (void **)&entry) == FAILURE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->is_deleted || entry->is_mounted) {\n\t\t\t/* remove this from the new phar if deleted, ignore if mounted */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->is_dir) {\n\t\t\t/* add 1 for trailing slash */\n\t\t\tphar_set_32(entry_buffer, entry->filename_len + 1);\n\t\t} else {\n\t\t\tphar_set_32(entry_buffer, entry->filename_len);\n\t\t}\n\n\t\tif (4 != php_stream_write(newfile, entry_buffer, 4)\n\t\t|| entry->filename_len != php_stream_write(newfile, entry->filename, entry->filename_len)\n\t\t|| (entry->is_dir && 1 != php_stream_write(newfile, \"/\", 1))) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tif (entry->is_dir) {\n\t\t\t\t\tspprintf(error, 0, \"unable to write filename of directory \\\"%s\\\" to manifest of new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t} else {\n\t\t\t\t\tspprintf(error, 0, \"unable to write filename of file \\\"%s\\\" to manifest of new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\t/* set the manifest meta-data:\n\t\t\t4: uncompressed filesize\n\t\t\t4: creation timestamp\n\t\t\t4: compressed filesize\n\t\t\t4: crc32\n\t\t\t4: flags\n\t\t\t4: metadata-len\n\t\t\t+: metadata\n\t\t*/\n\t\tmytime = time(NULL);\n\t\tphar_set_32(entry_buffer, entry->uncompressed_filesize);\n\t\tphar_set_32(entry_buffer+4, mytime);\n\t\tphar_set_32(entry_buffer+8, entry->compressed_filesize);\n\t\tphar_set_32(entry_buffer+12, entry->crc32);\n\t\tphar_set_32(entry_buffer+16, entry->flags);\n\t\tphar_set_32(entry_buffer+20, entry->metadata_str.len);\n\n\t\tif (sizeof(entry_buffer) != php_stream_write(newfile, entry_buffer, sizeof(entry_buffer))\n\t\t|| entry->metadata_str.len != php_stream_write(newfile, entry->metadata_str.c, entry->metadata_str.len)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\n\t\t\tphp_stream_close(newfile);\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to write temporary manifest of file \\\"%s\\\" to manifest of new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\n\t\t\treturn EOF;\n\t\t}\n\t}\n\t/* Hack - see bug #65028, add padding byte to the end of the manifest */\n\tif(manifest_hack) {\n\t\tif(1 != php_stream_write(newfile, manifest, 1)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\n\t\t\tphp_stream_close(newfile);\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to write manifest padding byte\");\n\t\t\t}\n\n\t\t\treturn EOF;\n\t\t}\n\t}\n\n\t/* now copy the actual file data to the new phar */\n\toffset = php_stream_tell(newfile);\n\tfor (zend_hash_internal_pointer_reset(&phar->manifest);\n\t\tzend_hash_has_more_elements(&phar->manifest) == SUCCESS;\n\t\tzend_hash_move_forward(&phar->manifest)) {\n\n\t\tif (zend_hash_get_current_data(&phar->manifest, (void **)&entry) == FAILURE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->is_deleted || entry->is_dir || entry->is_mounted) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->cfp) {\n\t\t\tfile = entry->cfp;\n\t\t\tphp_stream_rewind(file);\n\t\t} else {\n\t\t\tfile = phar_get_efp(entry, 0 TSRMLS_CC);\n\t\t\tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 0 TSRMLS_CC)) {\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t}\n\n\t\tif (!file) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\t/* this will have changed for all files that have either changed compression or been modified */\n\t\tentry->offset = entry->offset_abs = offset;\n\t\toffset += entry->compressed_filesize;\n\t\tif (php_stream_copy_to_stream_ex(file, newfile, entry->compressed_filesize, &wrote) == FAILURE) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\n\t\t\tphp_stream_close(newfile);\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to write contents of file \\\"%s\\\" to new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\n\t\t\treturn EOF;\n\t\t}\n\n\t\tentry->is_modified = 0;\n\n\t\tif (entry->cfp) {\n\t\t\tphp_stream_close(entry->cfp);\n\t\t\tentry->cfp = NULL;\n\t\t}\n\n\t\tif (entry->fp_type == PHAR_MOD) {\n\t\t\t/* this fp is in use by a phar_entry_data returned by phar_get_entry_data, it will be closed when the phar_entry_data is phar_entry_delref'ed */\n\t\t\tif (entry->fp_refcount == 0 && entry->fp != phar->fp && entry->fp != phar->ufp) {\n\t\t\t\tphp_stream_close(entry->fp);\n\t\t\t}\n\n\t\t\tentry->fp = NULL;\n\t\t\tentry->fp_type = PHAR_FP;\n\t\t} else if (entry->fp_type == PHAR_UFP) {\n\t\t\tentry->fp_type = PHAR_FP;\n\t\t}\n\t}\n\n\t/* append signature */\n\tif (global_flags & PHAR_HDR_SIGNATURE) {\n\t\tchar sig_buf[4];\n\n\t\tphp_stream_rewind(newfile);\n\n\t\tif (phar->signature) {\n\t\t\tefree(phar->signature);\n\t\t\tphar->signature = NULL;\n\t\t}\n\n\t\tswitch(phar->sig_flags) {\n#ifndef PHAR_HASH_OK\n\t\t\tcase PHAR_SIG_SHA512:\n\t\t\tcase PHAR_SIG_SHA256:\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to write contents of file \\\"%s\\\" to new phar \\\"%s\\\" with requested hash type\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n#endif\n\t\t\tdefault: {\n\t\t\t\tchar *digest = NULL;\n\t\t\t\tint digest_len;\n\n\t\t\t\tif (FAILURE == phar_create_signature(phar, newfile, &digest, &digest_len, error TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar error: unable to write signature: %s\", save);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\tif (digest) {\n\t\t\t\t\t\tefree(digest);\n\t\t\t\t\t}\n\t\t\t\t\tif (closeoldfile) {\n\t\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(newfile);\n\t\t\t\t\treturn EOF;\n\t\t\t\t}\n\n\t\t\t\tphp_stream_write(newfile, digest, digest_len);\n\t\t\t\tefree(digest);\n\t\t\t\tif (phar->sig_flags == PHAR_SIG_OPENSSL) {\n\t\t\t\t\tphar_set_32(sig_buf, digest_len);\n\t\t\t\t\tphp_stream_write(newfile, sig_buf, 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tphar_set_32(sig_buf, phar->sig_flags);\n\t\tphp_stream_write(newfile, sig_buf, 4);\n\t\tphp_stream_write(newfile, \"GBMB\", 4);\n\t}\n\n\t/* finally, close the temp file, rename the original phar,\n\t   move the temp to the old phar, unlink the old phar, and reload it into memory\n\t*/\n\tif (phar->fp && free_fp) {\n\t\tphp_stream_close(phar->fp);\n\t}\n\n\tif (phar->ufp) {\n\t\tif (free_ufp) {\n\t\t\tphp_stream_close(phar->ufp);\n\t\t}\n\t\tphar->ufp = NULL;\n\t}\n\n\tif (closeoldfile) {\n\t\tphp_stream_close(oldfile);\n\t}\n\n\tphar->internal_file_start = halt_offset + manifest_len + 4;\n\tphar->halt_offset = halt_offset;\n\tphar->is_brandnew = 0;\n\n\tphp_stream_rewind(newfile);\n\n\tif (phar->donotflush) {\n\t\t/* deferred flush */\n\t\tphar->fp = newfile;\n\t} else {\n\t\tphar->fp = php_stream_open_wrapper(phar->fname, \"w+b\", IGNORE_URL|STREAM_MUST_SEEK|REPORT_ERRORS, NULL);\n\t\tif (!phar->fp) {\n\t\t\tphar->fp = newfile;\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"unable to open new phar \\\"%s\\\" for writing\", phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\tif (phar->flags & PHAR_FILE_COMPRESSED_GZ) {\n\t\t\t/* to properly compress, we have to tell zlib to add a zlib header */\n\t\t\tzval filterparams;\n\n\t\t\tarray_init(&filterparams);\n\t\t\tadd_assoc_long(&filterparams, \"window\", MAX_WBITS+16);\n\t\t\tfilter = php_stream_filter_create(\"zlib.deflate\", &filterparams, php_stream_is_persistent(phar->fp) TSRMLS_CC);\n\t\t\tzval_dtor(&filterparams);\n\n\t\t\tif (!filter) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"unable to compress all contents of phar \\\"%s\\\" using zlib, PHP versions older than 5.2.6 have a buggy zlib\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\n\t\t\tphp_stream_filter_append(&phar->fp->writefilters, filter);\n\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\tphp_stream_close(phar->fp);\n\t\t\t/* use the temp stream as our base */\n\t\t\tphar->fp = newfile;\n\t\t} else if (phar->flags & PHAR_FILE_COMPRESSED_BZ2) {\n\t\t\tfilter = php_stream_filter_create(\"bzip2.compress\", NULL, php_stream_is_persistent(phar->fp) TSRMLS_CC);\n\t\t\tphp_stream_filter_append(&phar->fp->writefilters, filter);\n\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\tphp_stream_close(phar->fp);\n\t\t\t/* use the temp stream as our base */\n\t\t\tphar->fp = newfile;\n\t\t} else {\n\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\t/* we could also reopen the file in \"rb\" mode but there is no need for that */\n\t\t\tphp_stream_close(newfile);\n\t\t}\n\t}\n\n\tif (-1 == php_stream_seek(phar->fp, phar->halt_offset, SEEK_SET)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to seek to __HALT_COMPILER(); in new phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\t\treturn EOF;\n\t}\n\n\treturn EOF;\n}\n/* }}} */\n\n#ifdef COMPILE_DL_PHAR\nZEND_GET_MODULE(phar)\n#endif\n\n/* {{{ phar_functions[]\n *\n * Every user visible function must have an entry in phar_functions[].\n */\nzend_function_entry phar_functions[] = {\n\tPHP_FE_END\n};\n/* }}}*/\n\nstatic size_t phar_zend_stream_reader(void *handle, char *buf, size_t len TSRMLS_DC) /* {{{ */\n{\n\treturn php_stream_read(phar_get_pharfp((phar_archive_data*)handle TSRMLS_CC), buf, len);\n}\n/* }}} */\n\nstatic size_t phar_zend_stream_fsizer(void *handle TSRMLS_DC) /* {{{ */\n{\n\treturn ((phar_archive_data*)handle)->halt_offset + 32;\n} /* }}} */\n\nzend_op_array *(*phar_orig_compile_file)(zend_file_handle *file_handle, int type TSRMLS_DC);\n#define phar_orig_zend_open zend_stream_open_function\n\nstatic char *phar_resolve_path(const char *filename, int filename_len TSRMLS_DC)\n{\n\treturn phar_find_in_include_path((char *) filename, filename_len, NULL TSRMLS_CC);\n}\n\nstatic zend_op_array *phar_compile_file(zend_file_handle *file_handle, int type TSRMLS_DC) /* {{{ */\n{\n\tzend_op_array *res;\n\tchar *name = NULL;\n\tint failed;\n\tphar_archive_data *phar;\n\n\tif (!file_handle || !file_handle->filename) {\n\t\treturn phar_orig_compile_file(file_handle, type TSRMLS_CC);\n\t}\n\tif (strstr(file_handle->filename, \".phar\") && !strstr(file_handle->filename, \"://\")) {\n\t\tif (SUCCESS == phar_open_from_filename((char*)file_handle->filename, strlen(file_handle->filename), NULL, 0, 0, &phar, NULL TSRMLS_CC)) {\n\t\t\tif (phar->is_zip || phar->is_tar) {\n\t\t\t\tzend_file_handle f = *file_handle;\n\n\t\t\t\t/* zip or tar-based phar */\n\t\t\t\tspprintf(&name, 4096, \"phar://%s/%s\", file_handle->filename, \".phar/stub.php\");\n\t\t\t\tif (SUCCESS == phar_orig_zend_open((const char *)name, file_handle TSRMLS_CC)) {\n\t\t\t\t\tefree(name);\n\t\t\t\t\tname = NULL;\n\t\t\t\t\tfile_handle->filename = f.filename;\n\t\t\t\t\tif (file_handle->opened_path) {\n\t\t\t\t\t\tefree(file_handle->opened_path);\n\t\t\t\t\t}\n\t\t\t\t\tfile_handle->opened_path = f.opened_path;\n\t\t\t\t\tfile_handle->free_filename = f.free_filename;\n\t\t\t\t} else {\n\t\t\t\t\t*file_handle = f;\n\t\t\t\t}\n\t\t\t} else if (phar->flags & PHAR_FILE_COMPRESSION_MASK) {\n\t\t\t\t/* compressed phar */\n\t\t\t\tfile_handle->type = ZEND_HANDLE_STREAM;\n\t\t\t\t/* we do our own reading directly from the phar, don't change the next line */\n\t\t\t\tfile_handle->handle.stream.handle  = phar;\n\t\t\t\tfile_handle->handle.stream.reader  = phar_zend_stream_reader;\n\t\t\t\tfile_handle->handle.stream.closer  = NULL;\n\t\t\t\tfile_handle->handle.stream.fsizer  = phar_zend_stream_fsizer;\n\t\t\t\tfile_handle->handle.stream.isatty  = 0;\n\t\t\t\tphar->is_persistent ?\n\t\t\t\t\tphp_stream_rewind(PHAR_GLOBALS->cached_fp[phar->phar_pos].fp) :\n\t\t\t\t\tphp_stream_rewind(phar->fp);\n\t\t\t\tmemset(&file_handle->handle.stream.mmap, 0, sizeof(file_handle->handle.stream.mmap));\n\t\t\t}\n\t\t}\n\t}\n\n\tzend_try {\n\t\tfailed = 0;\n\t\tCG(zend_lineno) = 0;\n\t\tres = phar_orig_compile_file(file_handle, type TSRMLS_CC);\n\t} zend_catch {\n\t\tfailed = 1;\n\t\tres = NULL;\n\t} zend_end_try();\n",
        "fix": null,
        "src_path": "ca46d0acbce55019b970fcd4c1e8a10edfdded93___phar.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/ca46d0acbce55019b970fcd4c1e8a10edfdded93",
        "commit_msg": "Fix int overflows in phar (bug #73764)",
        "test_func_diff": [
            {
                "fn": "ext/phar/tests/bug73764.phpt",
                "patch": "@@ -0,0 +1,16 @@\n+--TEST--\n+Phar: PHP bug #73764: Crash while loading hostile phar archive\n+--SKIPIF--\n+<?php if (!extension_loaded(\"phar\")) die(\"skip\"); ?>\n+--FILE--\n+<?php\n+chdir(__DIR__);\n+try {\n+$p = Phar::LoadPhar('bug73764.phar', 'alias.phar');\n+echo \"OK\\n\";\n+} catch(PharException $e) {\n+\techo $e->getMessage();\n+}\n+?>\n+--EXPECTF--\n+internal corruption of phar \"%sbug73764.phar\" (truncated manifest entry)\n\\ No newline at end of file"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.30-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_ca46d0acbce55019b970fcd4c1e8a10edfdded93 More .INIs : CWD : /out/php___php-src/git_repo_dir_ca46d0acbce55019b970fcd4c1e8a10edfdded93 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/phar/tests/bug73764.phpt]\rFAIL Phar: PHP bug #73764: Crash while loading hostile phar archive [ext/phar/tests/bug73764.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Phar: PHP bug #73764: Crash while loading hostile phar archive [ext/phar/tests/bug73764.phpt] =====================================================================\n"
    },
    "b28b8b2fee6dfa6fcd13305c581bb835689ac3be___phar.c": {
        "start": 529,
        "end": 3375,
        "buggy": "int phar_open_parsed_phar(char *fname, int fname_len, char *alias, int alias_len, int is_data, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *phar;\n#ifdef PHP_WIN32\n\tchar *unixfname;\n#endif\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n#ifdef PHP_WIN32\n\tunixfname = estrndup(fname, fname_len);\n\tphar_unixify_path_separators(unixfname, fname_len);\n\n\tif (SUCCESS == phar_get_archive(&phar, unixfname, fname_len, alias, alias_len, error TSRMLS_CC)\n\t\t&& ((alias && fname_len == phar->fname_len\n\t\t&& !strncmp(unixfname, phar->fname, fname_len)) || !alias)\n\t) {\n\t\tphar_entry_info *stub;\n\t\tefree(unixfname);\n#else\n\tif (SUCCESS == phar_get_archive(&phar, fname, fname_len, alias, alias_len, error TSRMLS_CC)\n\t\t&& ((alias && fname_len == phar->fname_len\n\t\t&& !strncmp(fname, phar->fname, fname_len)) || !alias)\n\t) {\n\t\tphar_entry_info *stub;\n#endif\n\t\t/* logic above is as follows:\n\t\t   If an explicit alias was requested, ensure the filename passed in\n\t\t   matches the phar's filename.\n\t\t   If no alias was passed in, then it can match either and be valid\n\t\t */\n\n\t\tif (!is_data) {\n\t\t\t/* prevent any \".phar\" without a stub getting through */\n\t\t\tif (!phar->halt_offset && !phar->is_brandnew && (phar->is_tar || phar->is_zip)) {\n\t\t\t\tif (PHAR_G(readonly) && FAILURE == zend_hash_find(&(phar->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1, (void **)&stub)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"'%s' is not a phar archive. Use PharData::__construct() for a standard zip or tar archive\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (pphar) {\n\t\t\t*pphar = phar;\n\t\t}\n\n\t\treturn SUCCESS;\n\t} else {\n#ifdef PHP_WIN32\n\t\tefree(unixfname);\n#endif\n\t\tif (pphar) {\n\t\t\t*pphar = NULL;\n\t\t}\n\n\t\tif (phar && error && !(options & REPORT_ERRORS)) {\n\t\t\tefree(error);\n\t\t}\n\n\t\treturn FAILURE;\n\t}\n}\n/* }}}*/\n\n/**\n * Parse out metadata from the manifest for a single file\n *\n * Meta-data is in this format:\n * [len32][data...]\n *\n * data is the serialized zval\n */\nint phar_parse_metadata(char **buffer, zval **metadata, php_uint32 zip_metadata_len TSRMLS_DC) /* {{{ */\n{\n\tphp_unserialize_data_t var_hash;\n\n\tif (zip_metadata_len) {\n\t\tconst unsigned char *p;\n\t\tunsigned char *p_buff = (unsigned char *)estrndup(*buffer, zip_metadata_len);\n\t\tp = p_buff;\n\t\tALLOC_ZVAL(*metadata);\n\t\tINIT_ZVAL(**metadata);\n\t\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\t\tif (!php_var_unserialize(metadata, &p, p + zip_metadata_len, &var_hash TSRMLS_CC)) {\n\t\t\tefree(p_buff);\n\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\t\tzval_ptr_dtor(metadata);\n\t\t\t*metadata = NULL;\n\t\t\treturn FAILURE;\n\t\t}\n\t\tefree(p_buff);\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\n\t\tif (PHAR_G(persist)) {\n\t\t\t/* lazy init metadata */\n\t\t\tzval_ptr_dtor(metadata);\n\t\t\t*metadata = (zval *) pemalloc(zip_metadata_len, 1);\n\t\t\tmemcpy(*metadata, *buffer, zip_metadata_len);\n\t\t\treturn SUCCESS;\n\t\t}\n\t} else {\n\t\t*metadata = NULL;\n\t}\n\n\treturn SUCCESS;\n}\n/* }}}*/\n\n/**\n * Does not check for a previously opened phar in the cache.\n *\n * Parse a new one and add it to the cache, returning either SUCCESS or\n * FAILURE, and setting pphar to the pointer to the manifest entry\n *\n * This is used by phar_open_from_filename to process the manifest, but can be called\n * directly.\n */\nstatic int phar_parse_pharfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, long halt_offset, phar_archive_data** pphar, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar b32[4], *buffer, *endbuffer, *savebuf;\n\tphar_archive_data *mydata = NULL;\n\tphar_entry_info entry;\n\tphp_uint32 manifest_len, manifest_count, manifest_flags, manifest_index, tmp_len, sig_flags;\n\tphp_uint16 manifest_ver;\n\tphp_uint32 len;\n\tlong offset;\n\tint sig_len, register_alias = 0, temp_alias = 0;\n\tchar *signature = NULL;\n\n\tif (pphar) {\n\t\t*pphar = NULL;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\t/* check for ?>\\n and increment accordingly */\n\tif (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot seek to __HALT_COMPILER(); location in phar \\\"%s\\\"\")\n\t}\n\n\tbuffer = b32;\n\n\tif (3 != php_stream_read(fp, buffer, 3)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t}\n\n\tif ((*buffer == ' ' || *buffer == '\\n') && *(buffer + 1) == '?' && *(buffer + 2) == '>') {\n\t\tint nextchar;\n\t\thalt_offset += 3;\n\t\tif (EOF == (nextchar = php_stream_getc(fp))) {\n\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t\t}\n\n\t\tif ((char) nextchar == '\\r') {\n\t\t\t/* if we have an \\r we require an \\n as well */\n\t\t\tif (EOF == (nextchar = php_stream_getc(fp)) || (char)nextchar != '\\n') {\n\t\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t\t\t}\n\t\t\t++halt_offset;\n\t\t}\n\n\t\tif ((char) nextchar == '\\n') {\n\t\t\t++halt_offset;\n\t\t}\n\t}\n\n\t/* make sure we are at the right location to read the manifest */\n\tif (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot seek to __HALT_COMPILER(); location in phar \\\"%s\\\"\")\n\t}\n\n\t/* read in manifest */\n\tbuffer = b32;\n\n\tif (4 != php_stream_read(fp, buffer, 4)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at manifest length)\")\n\t}\n\n\tPHAR_GET_32(buffer, manifest_len);\n\n\tif (manifest_len > 1048576 * 100) {\n\t\t/* prevent serious memory issues by limiting manifest to at most 100 MB in length */\n\t\tMAPPHAR_ALLOC_FAIL(\"manifest cannot be larger than 100 MB in phar \\\"%s\\\"\")\n\t}\n\n\tbuffer = (char *)emalloc(manifest_len);\n\tsavebuf = buffer;\n\tendbuffer = buffer + manifest_len;\n\n\tif (manifest_len < 10 || manifest_len != php_stream_read(fp, buffer, manifest_len)) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest header)\")\n\t}\n\n\t/* extract the number of entries */\n\tPHAR_GET_32(buffer, manifest_count);\n\n\tif (manifest_count == 0) {\n\t\tMAPPHAR_FAIL(\"in phar \\\"%s\\\", manifest claims to have zero entries.  Phars must have at least 1 entry\");\n\t}\n\n\t/* extract API version, lowest nibble currently unused */\n\tmanifest_ver = (((unsigned char)buffer[0]) << 8)\n\t\t\t\t + ((unsigned char)buffer[1]);\n\tbuffer += 2;\n\n\tif ((manifest_ver & PHAR_API_VER_MASK) < PHAR_API_MIN_READ) {\n\t\tefree(savebuf);\n\t\tphp_stream_close(fp);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" is API version %1.u.%1.u.%1.u, and cannot be processed\", fname, manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0x0F);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tPHAR_GET_32(buffer, manifest_flags);\n\n\tmanifest_flags &= ~PHAR_HDR_COMPRESSION_MASK;\n\tmanifest_flags &= ~PHAR_FILE_COMPRESSION_MASK;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmanifest_flags |= compression;\n\n\t/* The lowest nibble contains the phar wide flags. The compression flags can */\n\t/* be ignored on reading because it is being generated anyways. */\n\tif (manifest_flags & PHAR_HDR_SIGNATURE) {\n\t\tchar sig_buf[8], *sig_ptr = sig_buf;\n\t\toff_t read_len;\n\t\tsize_t end_of_phar;\n\n\t\tif (-1 == php_stream_seek(fp, -8, SEEK_END)\n\t\t|| (read_len = php_stream_tell(fp)) < 20\n\t\t|| 8 != php_stream_read(fp, sig_buf, 8)\n\t\t|| memcmp(sig_buf+4, \"GBMB\", 4)) {\n\t\t\tefree(savebuf);\n\t\t\tphp_stream_close(fp);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tPHAR_GET_32(sig_ptr, sig_flags);\n\n\t\tswitch(sig_flags) {\n\t\t\tcase PHAR_SIG_OPENSSL: {\n\t\t\t\tphp_uint32 signature_len;\n\t\t\t\tchar *sig;\n\t\t\t\toff_t whence;\n\n\t\t\t\t/* we store the signature followed by the signature length */\n\t\t\t\tif (-1 == php_stream_seek(fp, -12, SEEK_CUR)\n\t\t\t\t|| 4 != php_stream_read(fp, sig_buf, 4)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature length could not be read\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tsig_ptr = sig_buf;\n\t\t\t\tPHAR_GET_32(sig_ptr, signature_len);\n\t\t\t\tsig = (char *) emalloc(signature_len);\n\t\t\t\twhence = signature_len + 4;\n\t\t\t\twhence = -whence;\n\n\t\t\t\tif (-1 == php_stream_seek(fp, whence, SEEK_CUR)\n\t\t\t\t|| !(end_of_phar = php_stream_tell(fp))\n\t\t\t\t|| signature_len != php_stream_read(fp, sig, signature_len)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tefree(sig);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature could not be read\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, end_of_phar, PHAR_SIG_OPENSSL, sig, signature_len, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tefree(sig);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tefree(sig);\n\t\t\t}\n\t\t\tbreak;\n#if PHAR_HASH_OK\n\t\t\tcase PHAR_SIG_SHA512: {\n\t\t\t\tunsigned char digest[64];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 64), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA512, (char *)digest, 64, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA512 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PHAR_SIG_SHA256: {\n\t\t\t\tunsigned char digest[32];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 32), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA256, (char *)digest, 32, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA256 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#else\n\t\t\tcase PHAR_SIG_SHA512:\n\t\t\tcase PHAR_SIG_SHA256:\n\t\t\t\tefree(savebuf);\n\t\t\t\tphp_stream_close(fp);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a unsupported signature\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n#endif\n\t\t\tcase PHAR_SIG_SHA1: {\n\t\t\t\tunsigned char digest[20];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 20), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA1, (char *)digest, 20, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA1 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PHAR_SIG_MD5: {\n\t\t\t\tunsigned char digest[16];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 16), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_MD5, (char *)digest, 16, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" MD5 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tefree(savebuf);\n\t\t\t\tphp_stream_close(fp);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken or unsupported signature\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t}\n\t} else if (PHAR_G(require_hash)) {\n\t\tefree(savebuf);\n\t\tphp_stream_close(fp);\n\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t} else {\n\t\tsig_flags = 0;\n\t\tsig_len = 0;\n\t}\n\n\t/* extract alias */\n\tPHAR_GET_32(buffer, tmp_len);\n\n\tif (buffer + tmp_len > endbuffer) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (buffer overrun)\");\n\t}\n\n\tif (manifest_len < 10 + tmp_len) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest header)\")\n\t}\n\n\t/* tmp_len = 0 says alias length is 0, which means the alias is not stored in the phar */\n\tif (tmp_len) {\n\t\t/* if the alias is stored we enforce it (implicit overrides explicit) */\n\t\tif (alias && alias_len && (alias_len != (int)tmp_len || strncmp(alias, buffer, tmp_len)))\n\t\t{\n\t\t\tbuffer[tmp_len] = '\\0';\n\t\t\tphp_stream_close(fp);\n\n\t\t\tif (signature) {\n\t\t\t\tefree(signature);\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"cannot load phar \\\"%s\\\" with implicit alias \\\"%s\\\" under different alias \\\"%s\\\"\", fname, buffer, alias);\n\t\t\t}\n\n\t\t\tefree(savebuf);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\talias_len = tmp_len;\n\t\talias = buffer;\n\t\tbuffer += tmp_len;\n\t\tregister_alias = 1;\n\t} else if (!alias_len || !alias) {\n\t\t/* if we neither have an explicit nor an implicit alias, we use the filename */\n\t\talias = NULL;\n\t\talias_len = 0;\n\t\tregister_alias = 0;\n\t} else if (alias_len) {\n\t\tregister_alias = 1;\n\t\ttemp_alias = 1;\n\t}\n\n\t/* we have 5 32-bit items plus 1 byte at least */\n\tif (manifest_count > ((manifest_len - 10 - tmp_len) / (5 * 4 + 1))) {\n\t\t/* prevent serious memory issues */\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (too many manifest entries for size of manifest)\")\n\t}\n\n\tmydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmydata->is_persistent = PHAR_G(persist);\n\n\t/* check whether we have meta data, zero check works regardless of byte order */\n\tPHAR_GET_32(buffer, len);\n\tif (mydata->is_persistent) {\n\t\tmydata->metadata_len = len;\n\t\tif(!len) {\n\t\t\t/* FIXME: not sure why this is needed but removing it breaks tests */\n\t\t\tPHAR_GET_32(buffer, len);\n\t\t}\n\t}\n\tif(len > endbuffer - buffer) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (trying to read past buffer end)\");\n\t}\n\tif (phar_parse_metadata(&buffer, &mydata->metadata, len TSRMLS_CC) == FAILURE) {\n\t\tMAPPHAR_FAIL(\"unable to read phar metadata in .phar file \\\"%s\\\"\");\n\t}\n\tbuffer += len;\n\n\t/* set up our manifest */\n\tzend_hash_init(&mydata->manifest, manifest_count,\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->virtual_dirs, manifest_count * 2,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tmydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(mydata->fname, fname_len);\n#endif\n\tmydata->fname_len = fname_len;\n\toffset = halt_offset + manifest_len + 4;\n\tmemset(&entry, 0, sizeof(phar_entry_info));\n\tentry.phar = mydata;\n\tentry.fp_type = PHAR_FP;\n\tentry.is_persistent = mydata->is_persistent;\n\n\tfor (manifest_index = 0; manifest_index < manifest_count; ++manifest_index) {\n\t\tif (buffer + 24 > endbuffer) {\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\")\n\t\t}\n\n\t\tPHAR_GET_32(buffer, entry.filename_len);\n\n\t\tif (entry.filename_len == 0) {\n\t\t\tMAPPHAR_FAIL(\"zero-length filename encountered in phar \\\"%s\\\"\");\n\t\t}\n\n\t\tif (entry.is_persistent) {\n\t\t\tentry.manifest_pos = manifest_index;\n\t\t}\n\n\t\tif (entry.filename_len > endbuffer - buffer - 20) {\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\");\n\t\t}\n\n\t\tif ((manifest_ver & PHAR_API_VER_MASK) >= PHAR_API_MIN_DIR && buffer[entry.filename_len - 1] == '/') {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tphar_add_virtual_dirs(mydata, buffer, entry.filename_len TSRMLS_CC);\n\t\tentry.filename = pestrndup(buffer, entry.filename_len, entry.is_persistent);\n\t\tbuffer += entry.filename_len;\n\t\tPHAR_GET_32(buffer, entry.uncompressed_filesize);\n\t\tPHAR_GET_32(buffer, entry.timestamp);\n\n\t\tif (offset == halt_offset + (int)manifest_len + 4) {\n\t\t\tmydata->min_timestamp = entry.timestamp;\n\t\t\tmydata->max_timestamp = entry.timestamp;\n\t\t} else {\n\t\t\tif (mydata->min_timestamp > entry.timestamp) {\n\t\t\t\tmydata->min_timestamp = entry.timestamp;\n\t\t\t} else if (mydata->max_timestamp < entry.timestamp) {\n\t\t\t\tmydata->max_timestamp = entry.timestamp;\n\t\t\t}\n\t\t}\n\n\t\tPHAR_GET_32(buffer, entry.compressed_filesize);\n\t\tPHAR_GET_32(buffer, entry.crc32);\n\t\tPHAR_GET_32(buffer, entry.flags);\n\n\t\tif (entry.is_dir) {\n\t\t\tentry.filename_len--;\n\t\t\tentry.flags |= PHAR_ENT_PERM_DEF_DIR;\n\t\t}\n\n\t\tPHAR_GET_32(buffer, len);\n\t\tif (entry.is_persistent) {\n\t\t\tentry.metadata_len = len;\n\t\t} else {\n\t\t\tentry.metadata_len = 0;\n\t\t}\n\t\tif (len > endbuffer - buffer) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\");\n\t\t}\n\t\tif (phar_parse_metadata(&buffer, &entry.metadata, len TSRMLS_CC) == FAILURE) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tMAPPHAR_FAIL(\"unable to read file metadata in .phar file \\\"%s\\\"\");\n\t\t}\n\t\tbuffer += len;\n\n\t\tentry.offset = entry.offset_abs = offset;\n\t\toffset += entry.compressed_filesize;\n\n\t\tswitch (entry.flags & PHAR_ENT_COMPRESSION_MASK) {\n\t\t\tcase PHAR_ENT_COMPRESSED_GZ:\n\t\t\t\tif (!PHAR_G(has_zlib)) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"zlib extension is required for gz compressed .phar file \\\"%s\\\"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHAR_ENT_COMPRESSED_BZ2:\n\t\t\t\tif (!PHAR_G(has_bz2)) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"bz2 extension is required for bzip2 compressed .phar file \\\"%s\\\"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (entry.uncompressed_filesize != entry.compressed_filesize) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (compressed and uncompressed size does not match for uncompressed entry)\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tmanifest_flags |= (entry.flags & PHAR_ENT_COMPRESSION_MASK);\n\t\t/* if signature matched, no need to check CRC32 for each file */\n\t\tentry.is_crc_checked = (manifest_flags & PHAR_HDR_SIGNATURE ? 1 : 0);\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&mydata->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), NULL);\n\t}\n\n\tsnprintf(mydata->version, sizeof(mydata->version), \"%u.%u.%u\", manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0xF);\n\tmydata->internal_file_start = halt_offset + manifest_len + 4;\n\tmydata->halt_offset = halt_offset;\n\tmydata->flags = manifest_flags;\n\tendbuffer = strrchr(mydata->fname, '/');\n\n\tif (endbuffer) {\n\t\tmydata->ext = memchr(endbuffer, '.', (mydata->fname + fname_len) - endbuffer);\n\t\tif (mydata->ext == endbuffer) {\n\t\t\tmydata->ext = memchr(endbuffer + 1, '.', (mydata->fname + fname_len) - endbuffer - 1);\n\t\t}\n\t\tif (mydata->ext) {\n\t\t\tmydata->ext_len = (mydata->fname + mydata->fname_len) - mydata->ext;\n\t\t}\n\t}\n\n\tmydata->alias = alias ?\n\t\tpestrndup(alias, alias_len, mydata->is_persistent) :\n\t\tpestrndup(mydata->fname, fname_len, mydata->is_persistent);\n\tmydata->alias_len = alias ? alias_len : fname_len;\n\tmydata->sig_flags = sig_flags;\n\tmydata->fp = fp;\n\tmydata->sig_len = sig_len;\n\tmydata->signature = signature;\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (register_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmydata->is_temporary_alias = temp_alias;\n\n\t\tif (!phar_validate_alias(mydata->alias, mydata->alias_len)) {\n\t\t\tsignature = NULL;\n\t\t\tfp = NULL;\n\t\t\tMAPPHAR_FAIL(\"Cannot open archive \\\"%s\\\", invalid alias\");\n\t\t}\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\tsignature = NULL;\n\t\t\t\tfp = NULL;\n\t\t\t\tMAPPHAR_FAIL(\"Cannot open archive \\\"%s\\\", alias is already in use by existing archive\");\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tmydata->is_temporary_alias = 1;\n\t}\n\n\tzend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*),  NULL);\n\tefree(savebuf);\n\n\tif (pphar) {\n\t\t*pphar = mydata;\n\t}\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/**\n * Create or open a phar for writing\n */\nint phar_open_or_create_filename(char *fname, int fname_len, char *alias, int alias_len, int is_data, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tconst char *ext_str, *z;\n\tchar *my_error;\n\tint ext_len;\n\tphar_archive_data **test, *unused = NULL;\n\n\ttest = &unused;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\t/* first try to open an existing file */\n\tif (phar_detect_phar_fname_ext(fname, fname_len, &ext_str, &ext_len, !is_data, 0, 1 TSRMLS_CC) == SUCCESS) {\n\t\tgoto check_file;\n\t}\n\n\t/* next try to create a new file */\n\tif (FAILURE == phar_detect_phar_fname_ext(fname, fname_len, &ext_str, &ext_len, !is_data, 1, 1 TSRMLS_CC)) {\n\t\tif (error) {\n\t\t\tif (ext_len == -2) {\n\t\t\t\tspprintf(error, 0, \"Cannot create a phar archive from a URL like \\\"%s\\\". Phar objects can only be created from local files\", fname);\n\t\t\t} else {\n\t\t\t\tspprintf(error, 0, \"Cannot create phar '%s', file extension (or combination) not recognised or the directory does not exist\", fname);\n\t\t\t}\n\t\t}\n\t\treturn FAILURE;\n\t}\ncheck_file:\n\tif (phar_open_parsed_phar(fname, fname_len, alias, alias_len, is_data, options, test, &my_error TSRMLS_CC) == SUCCESS) {\n\t\tif (pphar) {\n\t\t\t*pphar = *test;\n\t\t}\n\n\t\tif ((*test)->is_data && !(*test)->is_tar && !(*test)->is_zip) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"Cannot open '%s' as a PharData object. Use Phar::__construct() for executable archives\", fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tif (PHAR_G(readonly) && !(*test)->is_data && ((*test)->is_tar || (*test)->is_zip)) {\n\t\t\tphar_entry_info *stub;\n\t\t\tif (FAILURE == zend_hash_find(&((*test)->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1, (void **)&stub)) {\n\t\t\t\tspprintf(error, 0, \"'%s' is not a phar archive. Use PharData::__construct() for a standard zip or tar archive\", fname);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tif (!PHAR_G(readonly) || (*test)->is_data) {\n\t\t\t(*test)->is_writeable = 1;\n\t\t}\n\t\treturn SUCCESS;\n\t} else if (my_error) {\n\t\tif (error) {\n\t\t\t*error = my_error;\n\t\t} else {\n\t\t\tefree(my_error);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (ext_len > 3 && (z = memchr(ext_str, 'z', ext_len)) && ((ext_str + ext_len) - z >= 2) && !memcmp(z + 1, \"ip\", 2)) {\n\t\t/* assume zip-based phar */\n\t\treturn phar_open_or_create_zip(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC);\n\t}\n\n\tif (ext_len > 3 && (z = memchr(ext_str, 't', ext_len)) && ((ext_str + ext_len) - z >= 2) && !memcmp(z + 1, \"ar\", 2)) {\n\t\t/* assume tar-based phar */\n\t\treturn phar_open_or_create_tar(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC);\n\t}\n\n\treturn phar_create_or_parse_filename(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC);\n}\n/* }}} */\n\nint phar_create_or_parse_filename(char *fname, int fname_len, char *alias, int alias_len, int is_data, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *mydata;\n\tphp_stream *fp;\n\tchar *actual = NULL, *p;\n\n\tif (!pphar) {\n\t\tpphar = &mydata;\n\t}\n#if PHP_API_VERSION < 20100412\n\tif (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {\n\t\treturn FAILURE;\n\t}\n#endif\n\tif (php_check_open_basedir(fname TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\t/* first open readonly so it won't be created if not present */\n\tfp = php_stream_open_wrapper(fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK|0, &actual);\n\n\tif (actual) {\n\t\tfname = actual;\n\t\tfname_len = strlen(actual);\n\t}\n\n\tif (fp) {\n\t\tif (phar_open_from_fp(fp, fname, fname_len, alias, alias_len, options, pphar, is_data, error TSRMLS_CC) == SUCCESS) {\n\t\t\tif ((*pphar)->is_data || !PHAR_G(readonly)) {\n\t\t\t\t(*pphar)->is_writeable = 1;\n\t\t\t}\n\t\t\tif (actual) {\n\t\t\t\tefree(actual);\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\t} else {\n\t\t\t/* file exists, but is either corrupt or not a phar archive */\n\t\t\tif (actual) {\n\t\t\t\tefree(actual);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (actual) {\n\t\tefree(actual);\n\t}\n\n\tif (PHAR_G(readonly) && !is_data) {\n\t\tif (options & REPORT_ERRORS) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"creating archive \\\"%s\\\" disabled by the php.ini setting phar.readonly\", fname);\n\t\t\t}\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\t/* set up our manifest */\n\tmydata = ecalloc(1, sizeof(phar_archive_data));\n\tmydata->fname = expand_filepath(fname, NULL TSRMLS_CC);\n\tfname_len = strlen(mydata->fname);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(mydata->fname, fname_len);\n#endif\n\tp = strrchr(mydata->fname, '/');\n\n\tif (p) {\n\t\tmydata->ext = memchr(p, '.', (mydata->fname + fname_len) - p);\n\t\tif (mydata->ext == p) {\n\t\t\tmydata->ext = memchr(p + 1, '.', (mydata->fname + fname_len) - p - 1);\n\t\t}\n\t\tif (mydata->ext) {\n\t\t\tmydata->ext_len = (mydata->fname + fname_len) - mydata->ext;\n\t\t}\n\t}\n\n\tif (pphar) {\n\t\t*pphar = mydata;\n\t}\n\n\tzend_hash_init(&mydata->manifest, sizeof(phar_entry_info),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, 0);\n\tzend_hash_init(&mydata->mounted_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, 0);\n\tzend_hash_init(&mydata->virtual_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tmydata->fname_len = fname_len;\n\tsnprintf(mydata->version, sizeof(mydata->version), \"%s\", PHP_PHAR_API_VERSION);\n\tmydata->is_temporary_alias = alias ? 0 : 1;\n\tmydata->internal_file_start = -1;\n\tmydata->fp = NULL;\n\tmydata->is_writeable = 1;\n\tmydata->is_brandnew = 1;\n\tphar_request_initialize(TSRMLS_C);\n\tzend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*),  NULL);\n\n\tif (is_data) {\n\t\talias = NULL;\n\t\talias_len = 0;\n\t\tmydata->is_data = 1;\n\t\t/* assume tar format, PharData can specify other */\n\t\tmydata->is_tar = 1;\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias && SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: phar \\\"%s\\\" cannot set alias \\\"%s\\\", already in use by another phar archive\", mydata->fname, alias);\n\t\t\t\t}\n\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\n\t\t\t\tif (pphar) {\n\t\t\t\t\t*pphar = NULL;\n\t\t\t\t}\n\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tmydata->alias = alias ? estrndup(alias, alias_len) : estrndup(mydata->fname, fname_len);\n\t\tmydata->alias_len = alias ? alias_len : fname_len;\n\t}\n\n\tif (alias_len && alias) {\n\t\tif (FAILURE == zend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL)) {\n\t\t\tif (options & REPORT_ERRORS) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"archive \\\"%s\\\" cannot be associated with alias \\\"%s\\\", already in use\", fname, alias);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\n\t\t\tif (pphar) {\n\t\t\t\t*pphar = NULL;\n\t\t\t}\n\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\treturn SUCCESS;\n}\n/* }}}*/\n\n/**\n * Return an already opened filename.\n *\n * Or scan a phar file for the required __HALT_COMPILER(); ?> token and verify\n * that the manifest is proper, then pass it to phar_parse_pharfile().  SUCCESS\n * or FAILURE is returned and pphar is set to a pointer to the phar's manifest\n */\nint phar_open_from_filename(char *fname, int fname_len, char *alias, int alias_len, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphp_stream *fp;\n\tchar *actual;\n\tint ret, is_data = 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (!strstr(fname, \".phar\")) {\n\t\tis_data = 1;\n\t}\n\n\tif (phar_open_parsed_phar(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC) == SUCCESS) {\n\t\treturn SUCCESS;\n\t} else if (error && *error) {\n\t\treturn FAILURE;\n\t}\n#if PHP_API_VERSION < 20100412\n\tif (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {\n\t\treturn FAILURE;\n\t}\n#endif\n\tif (php_check_open_basedir(fname TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tfp = php_stream_open_wrapper(fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK, &actual);\n\n\tif (!fp) {\n\t\tif (options & REPORT_ERRORS) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to open phar for reading \\\"%s\\\"\", fname);\n\t\t\t}\n\t\t}\n\t\tif (actual) {\n\t\t\tefree(actual);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (actual) {\n\t\tfname = actual;\n\t\tfname_len = strlen(actual);\n\t}\n\n\tret =  phar_open_from_fp(fp, fname, fname_len, alias, alias_len, options, pphar, is_data, error TSRMLS_CC);\n\n\tif (actual) {\n\t\tefree(actual);\n\t}\n\n\treturn ret;\n}\n/* }}}*/\n\nstatic inline char *phar_strnstr(const char *buf, int buf_len, const char *search, int search_len) /* {{{ */\n{\n\tconst char *c;\n\tint so_far = 0;\n\n\tif (buf_len < search_len) {\n\t\treturn NULL;\n\t}\n\n\tc = buf - 1;\n\n\tdo {\n\t\tif (!(c = memchr(c + 1, search[0], buf_len - search_len - so_far))) {\n\t\t\treturn (char *) NULL;\n\t\t}\n\n\t\tso_far = c - buf;\n\n\t\tif (so_far >= (buf_len - search_len)) {\n\t\t\treturn (char *) NULL;\n\t\t}\n\n\t\tif (!memcmp(c, search, search_len)) {\n\t\t\treturn (char *) c;\n\t\t}\n\t} while (1);\n}\n/* }}} */\n\n/**\n * Scan an open fp for the required __HALT_COMPILER(); ?> token and verify\n * that the manifest is proper, then pass it to phar_parse_pharfile().  SUCCESS\n * or FAILURE is returned and pphar is set to a pointer to the phar's manifest\n */\nstatic int phar_open_from_fp(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, int options, phar_archive_data** pphar, int is_data, char **error TSRMLS_DC) /* {{{ */\n{\n\tconst char token[] = \"__HALT_COMPILER();\";\n\tconst char zip_magic[] = \"PK\\x03\\x04\";\n\tconst char gz_magic[] = \"\\x1f\\x8b\\x08\";\n\tconst char bz_magic[] = \"BZh\";\n\tchar *pos, test = '\\0';\n\tconst int window_size = 1024;\n\tchar buffer[1024 + sizeof(token)]; /* a 1024 byte window + the size of the halt_compiler token (moving window) */\n\tconst long readsize = sizeof(buffer) - sizeof(token);\n\tconst long tokenlen = sizeof(token) - 1;\n\tlong halt_offset;\n\tsize_t got;\n\tphp_uint32 compression = PHAR_FILE_COMPRESSED_NONE;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (-1 == php_stream_rewind(fp)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot rewind phar \\\"%s\\\"\")\n\t}\n\n\tbuffer[sizeof(buffer)-1] = '\\0';\n\tmemset(buffer, 32, sizeof(token));\n\thalt_offset = 0;\n\n\t/* Maybe it's better to compile the file instead of just searching,  */\n\t/* but we only want the offset. So we want a .re scanner to find it. */\n\twhile(!php_stream_eof(fp)) {\n\t\tif ((got = php_stream_read(fp, buffer+tokenlen, readsize)) < (size_t) tokenlen) {\n\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated entry)\")\n\t\t}\n\n\t\tif (!test) {\n\t\t\ttest = '\\1';\n\t\t\tpos = buffer+tokenlen;\n\t\t\tif (!memcmp(pos, gz_magic, 3)) {\n\t\t\t\tchar err = 0;\n\t\t\t\tphp_stream_filter *filter;\n\t\t\t\tphp_stream *temp;\n\t\t\t\t/* to properly decompress, we have to tell zlib to look for a zlib or gzip header */\n\t\t\t\tzval filterparams;\n\n\t\t\t\tif (!PHAR_G(has_zlib)) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\" to temporary file, enable zlib extension in php.ini\")\n\t\t\t\t}\n\t\t\t\tarray_init(&filterparams);\n/* this is defined in zlib's zconf.h */\n#ifndef MAX_WBITS\n#define MAX_WBITS 15\n#endif\n\t\t\t\tadd_assoc_long(&filterparams, \"window\", MAX_WBITS + 32);\n\n\t\t\t\t/* entire file is gzip-compressed, uncompress to temporary file */\n\t\t\t\tif (!(temp = php_stream_fopen_tmpfile())) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to create temporary file for decompression of gzipped phar archive \\\"%s\\\"\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tfilter = php_stream_filter_create(\"zlib.inflate\", &filterparams, php_stream_is_persistent(fp) TSRMLS_CC);\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\terr = 1;\n\t\t\t\t\tadd_assoc_long(&filterparams, \"window\", MAX_WBITS);\n\t\t\t\t\tfilter = php_stream_filter_create(\"zlib.inflate\", &filterparams, php_stream_is_persistent(fp) TSRMLS_CC);\n\t\t\t\t\tzval_dtor(&filterparams);\n\n\t\t\t\t\tif (!filter) {\n\t\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\", ext/zlib is buggy in PHP versions older than 5.2.6\")\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tzval_dtor(&filterparams);\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&temp->writefilters, filter);\n\n\t\t\t\tif (SUCCESS != php_stream_copy_to_stream_ex(fp, temp, PHP_STREAM_COPY_ALL, NULL)) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\", ext/zlib is buggy in PHP versions older than 5.2.6\")\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\" to temporary file\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tfp = temp;\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tcompression = PHAR_FILE_COMPRESSED_GZ;\n\n\t\t\t\t/* now, start over */\n\t\t\t\ttest = '\\0';\n\t\t\t\tcontinue;\n\t\t\t} else if (!memcmp(pos, bz_magic, 3)) {\n\t\t\t\tphp_stream_filter *filter;\n\t\t\t\tphp_stream *temp;\n\n\t\t\t\tif (!PHAR_G(has_bz2)) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress bzipped phar archive \\\"%s\\\" to temporary file, enable bz2 extension in php.ini\")\n\t\t\t\t}\n\n\t\t\t\t/* entire file is bzip-compressed, uncompress to temporary file */\n\t\t\t\tif (!(temp = php_stream_fopen_tmpfile())) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to create temporary file for decompression of bzipped phar archive \\\"%s\\\"\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tfilter = php_stream_filter_create(\"bzip2.decompress\", NULL, php_stream_is_persistent(fp) TSRMLS_CC);\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress bzipped phar archive \\\"%s\\\", filter creation failed\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&temp->writefilters, filter);\n\n\t\t\t\tif (SUCCESS != php_stream_copy_to_stream_ex(fp, temp, PHP_STREAM_COPY_ALL, NULL)) {\n\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress bzipped phar archive \\\"%s\\\" to temporary file\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tfp = temp;\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tcompression = PHAR_FILE_COMPRESSED_BZ2;\n\n\t\t\t\t/* now, start over */\n\t\t\t\ttest = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!memcmp(pos, zip_magic, 4)) {\n\t\t\t\tphp_stream_seek(fp, 0, SEEK_END);\n\t\t\t\treturn phar_parse_zipfile(fp, fname, fname_len, alias, alias_len, pphar, error TSRMLS_CC);\n\t\t\t}\n\n\t\t\tif (got > 512) {\n\t\t\t\tif (phar_is_tar(pos, fname)) {\n\t\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\t\treturn phar_parse_tarfile(fp, fname, fname_len, alias, alias_len, pphar, is_data, compression, error TSRMLS_CC);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (got > 0 && (pos = phar_strnstr(buffer, got + sizeof(token), token, sizeof(token)-1)) != NULL) {\n\t\t\thalt_offset += (pos - buffer); /* no -tokenlen+tokenlen here */\n\t\t\treturn phar_parse_pharfile(fp, fname, fname_len, alias, alias_len, halt_offset, pphar, compression, error TSRMLS_CC);\n\t\t}\n\n\t\thalt_offset += got;\n\t\tmemmove(buffer, buffer + window_size, tokenlen); /* move the memory buffer by the size of the window */\n\t}\n\n\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (__HALT_COMPILER(); not found)\")\n}\n/* }}} */\n\n/*\n * given the location of the file extension and the start of the file path,\n * determine the end of the portion of the path (i.e. /path/to/file.ext/blah\n * grabs \"/path/to/file.ext\" as does the straight /path/to/file.ext),\n * stat it to determine if it exists.\n * if so, check to see if it is a directory and fail if so\n * if not, check to see if its dirname() exists (i.e. \"/path/to\") and is a directory\n * succeed if we are creating the file, otherwise fail.\n */\nstatic int phar_analyze_path(const char *fname, const char *ext, int ext_len, int for_create TSRMLS_DC) /* {{{ */\n{\n\tphp_stream_statbuf ssb;\n\tchar *realpath;\n\tchar *filename = estrndup(fname, (ext - fname) + ext_len);\n\n\tif ((realpath = expand_filepath(filename, NULL TSRMLS_CC))) {\n#ifdef PHP_WIN32\n\t\tphar_unixify_path_separators(realpath, strlen(realpath));\n#endif\n\t\tif (zend_hash_exists(&(PHAR_GLOBALS->phar_fname_map), realpath, strlen(realpath))) {\n\t\t\tefree(realpath);\n\t\t\tefree(filename);\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && zend_hash_exists(&cached_phars, realpath, strlen(realpath))) {\n\t\t\tefree(realpath);\n\t\t\tefree(filename);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tefree(realpath);\n\t}\n\n\tif (SUCCESS == php_stream_stat_path((char *) filename, &ssb)) {\n\n\t\tefree(filename);\n\n\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tif (for_create == 1) {\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\treturn SUCCESS;\n\t} else {\n\t\tchar *slash;\n\n\t\tif (!for_create) {\n\t\t\tefree(filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tslash = (char *) strrchr(filename, '/');\n\n\t\tif (slash) {\n\t\t\t*slash = '\\0';\n\t\t}\n\n\t\tif (SUCCESS != php_stream_stat_path((char *) filename, &ssb)) {\n\t\t\tif (!slash) {\n\t\t\t\tif (!(realpath = expand_filepath(filename, NULL TSRMLS_CC))) {\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n#ifdef PHP_WIN32\n\t\t\t\tphar_unixify_path_separators(realpath, strlen(realpath));\n#endif\n\t\t\t\tslash = strstr(realpath, filename);\n\t\t\t\tif (slash) {\n\t\t\t\t\tslash += ((ext - fname) + ext_len);\n\t\t\t\t\t*slash = '\\0';\n\t\t\t\t}\n\t\t\t\tslash = strrchr(realpath, '/');\n\n\t\t\t\tif (slash) {\n\t\t\t\t\t*slash = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tefree(realpath);\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (SUCCESS != php_stream_stat_path(realpath, &ssb)) {\n\t\t\t\t\tefree(realpath);\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tefree(realpath);\n\n\t\t\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tefree(filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tefree(filename);\n\n\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\treturn FAILURE;\n\t}\n}\n/* }}} */\n\n/* check for \".phar\" in extension */\nstatic int phar_check_str(const char *fname, const char *ext_str, int ext_len, int executable, int for_create TSRMLS_DC) /* {{{ */\n{\n\tchar test[51];\n\tconst char *pos;\n\n\tif (ext_len >= 50) {\n\t\treturn FAILURE;\n\t}\n\n\tif (executable == 1) {\n\t\t/* copy \".\" as well */\n\t\tmemcpy(test, ext_str - 1, ext_len + 1);\n\t\ttest[ext_len + 1] = '\\0';\n\t\t/* executable phars must contain \".phar\" as a valid extension (phar://.pharmy/oops is invalid) */\n\t\t/* (phar://hi/there/.phar/oops is also invalid) */\n\t\tpos = strstr(test, \".phar\");\n\n\t\tif (pos && (*(pos - 1) != '/')\n\t\t\t\t&& (pos += 5) && (*pos == '\\0' || *pos == '/' || *pos == '.')) {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create TSRMLS_CC);\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\t/* data phars need only contain a single non-\".\" to be valid */\n\tif (!executable) {\n\t\tpos = strstr(ext_str, \".phar\");\n\t\tif (!(pos && (*(pos - 1) != '/')\n\t\t\t\t\t&& (pos += 5) && (*pos == '\\0' || *pos == '/' || *pos == '.')) && *(ext_str + 1) != '.' && *(ext_str + 1) != '/' && *(ext_str + 1) != '\\0') {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create TSRMLS_CC);\n\t\t}\n\t} else {\n\t\tif (*(ext_str + 1) != '.' && *(ext_str + 1) != '/' && *(ext_str + 1) != '\\0') {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create TSRMLS_CC);\n\t\t}\n\t}\n\n\treturn FAILURE;\n}\n/* }}} */\n\n/*\n * if executable is 1, only returns SUCCESS if the extension is one of the tar/zip .phar extensions\n * if executable is 0, it returns SUCCESS only if the filename does *not* contain \".phar\" anywhere, and treats\n * the first extension as the filename extension\n *\n * if an extension is found, it sets ext_str to the location of the file extension in filename,\n * and ext_len to the length of the extension.\n * for urls like \"phar://alias/oops\" it instead sets ext_len to -1 and returns FAILURE, which tells\n * the calling function to use \"alias\" as the phar alias\n *\n * the last parameter should be set to tell the thing to assume that filename is the full path, and only to check the\n * extension rules, not to iterate.\n */\nint phar_detect_phar_fname_ext(const char *filename, int filename_len, const char **ext_str, int *ext_len, int executable, int for_create, int is_complete TSRMLS_DC) /* {{{ */\n{\n\tconst char *pos, *slash;\n\n\t*ext_str = NULL;\n\t*ext_len = 0;\n\n\tif (!filename_len || filename_len == 1) {\n\t\treturn FAILURE;\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\t/* first check for alias in first segment */\n\tpos = memchr(filename, '/', filename_len);\n\n\tif (pos && pos != filename) {\n\t\t/* check for url like http:// or phar:// */\n\t\tif (*(pos - 1) == ':' && (pos - filename) < filename_len - 1 && *(pos + 1) == '/') {\n\t\t\t*ext_len = -2;\n\t\t\t*ext_str = NULL;\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (zend_hash_exists(&(PHAR_GLOBALS->phar_alias_map), (char *) filename, pos - filename)) {\n\t\t\t*ext_str = pos;\n\t\t\t*ext_len = -1;\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && zend_hash_exists(&cached_alias, (char *) filename, pos - filename)) {\n\t\t\t*ext_str = pos;\n\t\t\t*ext_len = -1;\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (zend_hash_num_elements(&(PHAR_GLOBALS->phar_fname_map)) || PHAR_G(manifest_cached)) {\n\t\tphar_archive_data **pphar;\n\n\t\tif (is_complete) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), (char *) filename, filename_len, (void **)&pphar)) {\n\t\t\t\t*ext_str = filename + (filename_len - (*pphar)->ext_len);\nwoohoo:\n\t\t\t\t*ext_len = (*pphar)->ext_len;\n\n\t\t\t\tif (executable == 2) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\n\t\t\t\tif (executable == 1 && !(*pphar)->is_data) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\n\t\t\t\tif (!executable && (*pphar)->is_data) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, (char *) filename, filename_len, (void **)&pphar)) {\n\t\t\t\t*ext_str = filename + (filename_len - (*pphar)->ext_len);\n\t\t\t\tgoto woohoo;\n\t\t\t}\n\t\t} else {\n\t\t\tchar *str_key;\n\t\t\tuint keylen;\n\t\t\tulong unused;\n\n\t\t\tfor (zend_hash_internal_pointer_reset(&(PHAR_GLOBALS->phar_fname_map));\n\t\t\t\tHASH_KEY_NON_EXISTENT != zend_hash_get_current_key_ex(&(PHAR_GLOBALS->phar_fname_map), &str_key, &keylen, &unused, 0, NULL);\n\t\t\t\tzend_hash_move_forward(&(PHAR_GLOBALS->phar_fname_map))\n\t\t\t) {\n\t\t\t\tif (keylen > (uint) filename_len) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!memcmp(filename, str_key, keylen) && ((uint)filename_len == keylen\n\t\t\t\t\t|| filename[keylen] == '/' || filename[keylen] == '\\0')) {\n\t\t\t\t\tif (FAILURE == zend_hash_get_current_data(&(PHAR_GLOBALS->phar_fname_map), (void **) &pphar)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*ext_str = filename + (keylen - (*pphar)->ext_len);\n\t\t\t\t\tgoto woohoo;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (PHAR_G(manifest_cached)) {\n\t\t\t\tfor (zend_hash_internal_pointer_reset(&cached_phars);\n\t\t\t\t\tHASH_KEY_NON_EXISTENT != zend_hash_get_current_key_ex(&cached_phars, &str_key, &keylen, &unused, 0, NULL);\n\t\t\t\t\tzend_hash_move_forward(&cached_phars)\n\t\t\t\t) {\n\t\t\t\t\tif (keylen > (uint) filename_len) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!memcmp(filename, str_key, keylen) && ((uint)filename_len == keylen\n\t\t\t\t\t\t|| filename[keylen] == '/' || filename[keylen] == '\\0')) {\n\t\t\t\t\t\tif (FAILURE == zend_hash_get_current_data(&cached_phars, (void **) &pphar)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*ext_str = filename + (keylen - (*pphar)->ext_len);\n\t\t\t\t\t\tgoto woohoo;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpos = memchr(filename + 1, '.', filename_len);\nnext_extension:\n\tif (!pos) {\n\t\treturn FAILURE;\n\t}\n\n\twhile (pos != filename && (*(pos - 1) == '/' || *(pos - 1) == '\\0')) {\n\t\tpos = memchr(pos + 1, '.', filename_len - (pos - filename) + 1);\n\t\tif (!pos) {\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tslash = memchr(pos, '/', filename_len - (pos - filename));\n\n\tif (!slash) {\n\t\t/* this is a url like \"phar://blah.phar\" with no directory */\n\t\t*ext_str = pos;\n\t\t*ext_len = strlen(pos);\n\n\t\t/* file extension must contain \"phar\" */\n\t\tswitch (phar_check_str(filename, *ext_str, *ext_len, executable, for_create TSRMLS_CC)) {\n\t\t\tcase SUCCESS:\n\t\t\t\treturn SUCCESS;\n\t\t\tcase FAILURE:\n\t\t\t\t/* we are at the end of the string, so we fail */\n\t\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\t/* we've found an extension that ends at a directory separator */\n\t*ext_str = pos;\n\t*ext_len = slash - pos;\n\n\tswitch (phar_check_str(filename, *ext_str, *ext_len, executable, for_create TSRMLS_CC)) {\n\t\tcase SUCCESS:\n\t\t\treturn SUCCESS;\n\t\tcase FAILURE:\n\t\t\t/* look for more extensions */\n\t\t\tpos = strchr(pos + 1, '.');\n\t\t\tif (pos) {\n\t\t\t\t*ext_str = NULL;\n\t\t\t\t*ext_len = 0;\n\t\t\t}\n\t\t\tgoto next_extension;\n\t}\n\n\treturn FAILURE;\n}\n/* }}} */\n\nstatic int php_check_dots(const char *element, int n) /* {{{ */\n{\n\tfor(n--; n >= 0; --n) {\n\t\tif (element[n] != '.') {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n/* }}} */\n\n#define IS_DIRECTORY_UP(element, len) \\\n\t(len >= 2 && !php_check_dots(element, len))\n\n#define IS_DIRECTORY_CURRENT(element, len) \\\n\t(len == 1 && element[0] == '.')\n\n#define IS_BACKSLASH(c) ((c) == '/')\n\n#ifdef COMPILE_DL_PHAR\n/* stupid-ass non-extern declaration in tsrm_strtok.h breaks dumbass MS compiler */\nstatic inline int in_character_class(char ch, const char *delim) /* {{{ */\n{\n\twhile (*delim) {\n\t\tif (*delim == ch) {\n\t\t\treturn 1;\n\t\t}\n\t\t++delim;\n\t}\n\treturn 0;\n}\n/* }}} */\n\nchar *tsrm_strtok_r(char *s, const char *delim, char **last) /* {{{ */\n{\n\tchar *token;\n\n\tif (s == NULL) {\n\t\ts = *last;\n\t}\n\n\twhile (*s && in_character_class(*s, delim)) {\n\t\t++s;\n\t}\n\n\tif (!*s) {\n\t\treturn NULL;\n\t}\n\n\ttoken = s;\n\n\twhile (*s && !in_character_class(*s, delim)) {\n\t\t++s;\n\t}\n\n\tif (!*s) {\n\t\t*last = s;\n\t} else {\n\t\t*s = '\\0';\n\t\t*last = s + 1;\n\t}\n\n\treturn token;\n}\n/* }}} */\n#endif\n\n/**\n * Remove .. and . references within a phar filename\n */\nchar *phar_fix_filepath(char *path, int *new_len, int use_cwd TSRMLS_DC) /* {{{ */\n{\n\tchar *newpath;\n\tint newpath_len;\n\tchar *ptr;\n\tchar *tok;\n\tint ptr_length, path_length = *new_len;\n\n\tif (PHAR_G(cwd_len) && use_cwd && path_length > 2 && path[0] == '.' && path[1] == '/') {\n\t\tnewpath_len = PHAR_G(cwd_len);\n\t\tnewpath = emalloc(strlen(path) + newpath_len + 1);\n\t\tmemcpy(newpath, PHAR_G(cwd), newpath_len);\n\t} else {\n\t\tnewpath = emalloc(strlen(path) + 2);\n\t\tnewpath[0] = '/';\n\t\tnewpath_len = 1;\n\t}\n\n\tptr = path;\n\n\tif (*ptr == '/') {\n\t\t++ptr;\n\t}\n\n\ttok = ptr;\n\n\tdo {\n\t\tptr = memchr(ptr, '/', path_length - (ptr - path));\n\t} while (ptr && ptr - tok == 0 && *ptr == '/' && ++ptr && ++tok);\n\n\tif (!ptr && (path_length - (tok - path))) {\n\t\tswitch (path_length - (tok - path)) {\n\t\t\tcase 1:\n\t\t\t\tif (*tok == '.') {\n\t\t\t\t\tefree(path);\n\t\t\t\t\t*new_len = 1;\n\t\t\t\t\tefree(newpath);\n\t\t\t\t\treturn estrndup(\"/\", 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (tok[0] == '.' && tok[1] == '.') {\n\t\t\t\t\tefree(path);\n\t\t\t\t\t*new_len = 1;\n\t\t\t\t\tefree(newpath);\n\t\t\t\t\treturn estrndup(\"/\", 1);\n\t\t\t\t}\n\t\t}\n\t\tefree(newpath);\n\t\treturn path;\n\t}\n\n\twhile (ptr) {\n\t\tptr_length = ptr - tok;\nlast_time:\n\t\tif (IS_DIRECTORY_UP(tok, ptr_length)) {\n#define PREVIOUS newpath[newpath_len - 1]\n\n\t\t\twhile (newpath_len > 1 && !IS_BACKSLASH(PREVIOUS)) {\n\t\t\t\tnewpath_len--;\n\t\t\t}\n\n\t\t\tif (newpath[0] != '/') {\n\t\t\t\tnewpath[newpath_len] = '\\0';\n\t\t\t} else if (newpath_len > 1) {\n\t\t\t\t--newpath_len;\n\t\t\t}\n\t\t} else if (!IS_DIRECTORY_CURRENT(tok, ptr_length)) {\n\t\t\tif (newpath_len > 1) {\n\t\t\t\tnewpath[newpath_len++] = '/';\n\t\t\t\tmemcpy(newpath + newpath_len, tok, ptr_length+1);\n\t\t\t} else {\n\t\t\t\tmemcpy(newpath + newpath_len, tok, ptr_length+1);\n\t\t\t}\n\n\t\t\tnewpath_len += ptr_length;\n\t\t}\n\n\t\tif (ptr == path + path_length) {\n\t\t\tbreak;\n\t\t}\n\n\t\ttok = ++ptr;\n\n\t\tdo {\n\t\t\tptr = memchr(ptr, '/', path_length - (ptr - path));\n\t\t} while (ptr && ptr - tok == 0 && *ptr == '/' && ++ptr && ++tok);\n\n\t\tif (!ptr && (path_length - (tok - path))) {\n\t\t\tptr_length = path_length - (tok - path);\n\t\t\tptr = path + path_length;\n\t\t\tgoto last_time;\n\t\t}\n\t}\n\n\tefree(path);\n\t*new_len = newpath_len;\n\tnewpath[newpath_len] = '\\0';\n\treturn erealloc(newpath, newpath_len + 1);\n}\n/* }}} */\n\n/**\n * Process a phar stream name, ensuring we can handle any of:\n *\n * - whatever.phar\n * - whatever.phar.gz\n * - whatever.phar.bz2\n * - whatever.phar.php\n *\n * Optionally the name might start with 'phar://'\n *\n * This is used by phar_parse_url()\n */\nint phar_split_fname(const char *filename, int filename_len, char **arch, int *arch_len, char **entry, int *entry_len, int executable, int for_create TSRMLS_DC) /* {{{ */\n{\n\tconst char *ext_str;\n#ifdef PHP_WIN32\n\tchar *save;\n#endif\n\tint ext_len;\n\n\tif (CHECK_NULL_PATH(filename, filename_len)) {\n\t\treturn FAILURE;\n\t}\n\n\tif (!strncasecmp(filename, \"phar://\", 7)) {\n\t\tfilename += 7;\n\t\tfilename_len -= 7;\n\t}\n\n\text_len = 0;\n#ifdef PHP_WIN32\n\tsave = filename;\n\tfilename = estrndup(filename, filename_len);\n\tphar_unixify_path_separators(filename, filename_len);\n#endif\n\tif (phar_detect_phar_fname_ext(filename, filename_len, &ext_str, &ext_len, executable, for_create, 0 TSRMLS_CC) == FAILURE) {\n\t\tif (ext_len != -1) {\n\t\t\tif (!ext_str) {\n\t\t\t\t/* no / detected, restore arch for error message */\n#ifdef PHP_WIN32\n\t\t\t\t*arch = save;\n#else\n\t\t\t\t*arch = filename;\n#endif\n\t\t\t}\n\n#ifdef PHP_WIN32\n\t\t\tefree(filename);\n#endif\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\text_len = 0;\n\t\t/* no extension detected - instead we are dealing with an alias */\n\t}\n\n\t*arch_len = ext_str - filename + ext_len;\n\t*arch = estrndup(filename, *arch_len);\n\n\tif (ext_str[ext_len]) {\n\t\t*entry_len = filename_len - *arch_len;\n\t\t*entry = estrndup(ext_str+ext_len, *entry_len);\n#ifdef PHP_WIN32\n\t\tphar_unixify_path_separators(*entry, *entry_len);\n#endif\n\t\t*entry = phar_fix_filepath(*entry, entry_len, 0 TSRMLS_CC);\n\t} else {\n\t\t*entry_len = 1;\n\t\t*entry = estrndup(\"/\", 1);\n\t}\n\n#ifdef PHP_WIN32\n\tefree(filename);\n#endif\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/**\n * Invoked when a user calls Phar::mapPhar() from within an executing .phar\n * to set up its manifest directly\n */\nint phar_open_executed_filename(char *alias, int alias_len, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar *fname;\n\tzval *halt_constant;\n\tphp_stream *fp;\n\tint fname_len;\n\tchar *actual = NULL;\n\tint ret;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tfname = (char*)zend_get_executed_filename(TSRMLS_C);\n\tfname_len = strlen(fname);\n\n\tif (phar_open_parsed_phar(fname, fname_len, alias, alias_len, 0, REPORT_ERRORS, NULL, 0 TSRMLS_CC) == SUCCESS) {\n\t\treturn SUCCESS;\n\t}\n\n\tif (!strcmp(fname, \"[no active file]\")) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"cannot initialize a phar outside of PHP execution\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tMAKE_STD_ZVAL(halt_constant);\n\n\tif (0 == zend_get_constant(\"__COMPILER_HALT_OFFSET__\", 24, halt_constant TSRMLS_CC)) {\n\t\tFREE_ZVAL(halt_constant);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"__HALT_COMPILER(); must be declared in a phar\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tFREE_ZVAL(halt_constant);\n\n#if PHP_API_VERSION < 20100412\n\tif (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {\n\t\treturn FAILURE;\n\t}\n#endif\n\n\tif (php_check_open_basedir(fname TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tfp = php_stream_open_wrapper(fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK|REPORT_ERRORS, &actual);\n\n\tif (!fp) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to open phar for reading \\\"%s\\\"\", fname);\n\t\t}\n\t\tif (actual) {\n\t\t\tefree(actual);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (actual) {\n\t\tfname = actual;\n\t\tfname_len = strlen(actual);\n\t}\n\n\tret = phar_open_from_fp(fp, fname, fname_len, alias, alias_len, REPORT_ERRORS, NULL, 0, error TSRMLS_CC);\n\n\tif (actual) {\n\t\tefree(actual);\n\t}\n\n\treturn ret;\n}\n/* }}} */\n\n/**\n * Validate the CRC32 of a file opened from within the phar\n */\nint phar_postprocess_file(phar_entry_data *idata, php_uint32 crc32, char **error, int process_zip TSRMLS_DC) /* {{{ */\n{\n\tphp_uint32 crc = ~0;\n\tint len = idata->internal_file->uncompressed_filesize;\n\tphp_stream *fp = idata->fp;\n\tphar_entry_info *entry = idata->internal_file;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (entry->is_zip && process_zip > 0) {\n\t\t/* verify local file header */\n\t\tphar_zip_file_header local;\n\t\tphar_zip_data_desc desc;\n\n\t\tif (SUCCESS != phar_open_archive_fp(idata->phar TSRMLS_CC)) {\n\t\t\tspprintf(error, 0, \"phar error: unable to open zip-based phar archive \\\"%s\\\" to verify local file header for file \\\"%s\\\"\", idata->phar->fname, entry->filename);\n\t\t\treturn FAILURE;\n\t\t}\n\t\tphp_stream_seek(phar_get_entrypfp(idata->internal_file TSRMLS_CC), entry->header_offset, SEEK_SET);\n\n\t\tif (sizeof(local) != php_stream_read(phar_get_entrypfp(idata->internal_file TSRMLS_CC), (char *) &local, sizeof(local))) {\n\n\t\t\tspprintf(error, 0, \"phar error: internal corruption of zip-based phar \\\"%s\\\" (cannot read local file header for file \\\"%s\\\")\", idata->phar->fname, entry->filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\t/* check for data descriptor */\n\t\tif (((PHAR_ZIP_16(local.flags)) & 0x8) == 0x8) {\n\t\t\tphp_stream_seek(phar_get_entrypfp(idata->internal_file TSRMLS_CC),\n\t\t\t\t\tentry->header_offset + sizeof(local) +\n\t\t\t\t\tPHAR_ZIP_16(local.filename_len) +\n\t\t\t\t\tPHAR_ZIP_16(local.extra_len) +\n\t\t\t\t\tentry->compressed_filesize, SEEK_SET);\n\t\t\tif (sizeof(desc) != php_stream_read(phar_get_entrypfp(idata->internal_file TSRMLS_CC),\n\t\t\t\t\t\t\t    (char *) &desc, sizeof(desc))) {\n\t\t\t\tspprintf(error, 0, \"phar error: internal corruption of zip-based phar \\\"%s\\\" (cannot read local data descriptor for file \\\"%s\\\")\", idata->phar->fname, entry->filename);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tif (desc.signature[0] == 'P' && desc.signature[1] == 'K') {\n\t\t\t\tmemcpy(&(local.crc32), &(desc.crc32), 12);\n\t\t\t} else {\n\t\t\t\t/* old data descriptors have no signature */\n\t\t\t\tmemcpy(&(local.crc32), &desc, 12);\n\t\t\t}\n\t\t}\n\t\t/* verify local header */\n\t\tif (entry->filename_len != PHAR_ZIP_16(local.filename_len) || entry->crc32 != PHAR_ZIP_32(local.crc32) || entry->uncompressed_filesize != PHAR_ZIP_32(local.uncompsize) || entry->compressed_filesize != PHAR_ZIP_32(local.compsize)) {\n\t\t\tspprintf(error, 0, \"phar error: internal corruption of zip-based phar \\\"%s\\\" (local header of file \\\"%s\\\" does not match central directory)\", idata->phar->fname, entry->filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\t/* construct actual offset to file start - local extra_len can be different from central extra_len */\n\t\tentry->offset = entry->offset_abs =\n\t\t\tsizeof(local) + entry->header_offset + PHAR_ZIP_16(local.filename_len) + PHAR_ZIP_16(local.extra_len);\n\n\t\tif (idata->zero && idata->zero != entry->offset_abs) {\n\t\t\tidata->zero = entry->offset_abs;\n\t\t}\n\t}\n\n\tif (process_zip == 1) {\n\t\treturn SUCCESS;\n\t}\n\n\tphp_stream_seek(fp, idata->zero, SEEK_SET);\n\n\twhile (len--) {\n\t\tCRC32(crc, php_stream_getc(fp));\n\t}\n\n\tphp_stream_seek(fp, idata->zero, SEEK_SET);\n\n\tif (~crc == crc32) {\n\t\tentry->is_crc_checked = 1;\n\t\treturn SUCCESS;\n\t} else {\n\t\tspprintf(error, 0, \"phar error: internal corruption of phar \\\"%s\\\" (crc32 mismatch on file \\\"%s\\\")\", idata->phar->fname, entry->filename);\n\t\treturn FAILURE;\n\t}\n}\n/* }}} */\n\nstatic inline void phar_set_32(char *buffer, int var) /* {{{ */\n{\n#ifdef WORDS_BIGENDIAN\n\t*((buffer) + 3) = (unsigned char) (((var) >> 24) & 0xFF);\n\t*((buffer) + 2) = (unsigned char) (((var) >> 16) & 0xFF);\n\t*((buffer) + 1) = (unsigned char) (((var) >> 8) & 0xFF);\n\t*((buffer) + 0) = (unsigned char) ((var) & 0xFF);\n#else\n\t memcpy(buffer, &var, sizeof(var));\n#endif\n} /* }}} */\n\nstatic int phar_flush_clean_deleted_apply(void *data TSRMLS_DC) /* {{{ */\n{\n\tphar_entry_info *entry = (phar_entry_info *)data;\n\n\tif (entry->fp_refcount <= 0 && entry->is_deleted) {\n\t\treturn ZEND_HASH_APPLY_REMOVE;\n\t} else {\n\t\treturn ZEND_HASH_APPLY_KEEP;\n\t}\n}\n/* }}} */\n\n#include \"stub.h\"\n\nchar *phar_create_default_stub(const char *index_php, const char *web_index, size_t *len, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar *stub = NULL;\n\tint index_len, web_len;\n\tsize_t dummy;\n\n\tif (!len) {\n\t\tlen = &dummy;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (!index_php) {\n\t\tindex_php = \"index.php\";\n\t}\n\n\tif (!web_index) {\n\t\tweb_index = \"index.php\";\n\t}\n\n\tindex_len = strlen(index_php);\n\tweb_len = strlen(web_index);\n\n\tif (index_len > 400) {\n\t\t/* ridiculous size not allowed for index.php startup filename */\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"Illegal filename passed in for stub creation, was %d characters long, and only 400 or less is allowed\", index_len);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (web_len > 400) {\n\t\t/* ridiculous size not allowed for index.php startup filename */\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"Illegal web filename passed in for stub creation, was %d characters long, and only 400 or less is allowed\", web_len);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tphar_get_stub(index_php, web_index, len, &stub, index_len+1, web_len+1 TSRMLS_CC);\n\treturn stub;\n}\n/* }}} */\n\n/**\n * Save phar contents to disk\n *\n * user_stub contains either a string, or a resource pointer, if len is a negative length.\n * user_stub and len should be both 0 if the default or existing stub should be used\n */\nint phar_flush(phar_archive_data *phar, char *user_stub, long len, int convert, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar halt_stub[] = \"__HALT_COMPILER();\";\n\tchar *newstub, *tmp;\n\tphar_entry_info *entry, *newentry;\n\tint halt_offset, restore_alias_len, global_flags = 0, closeoldfile;\n\tchar *pos, has_dirs = 0;\n\tchar manifest[18], entry_buffer[24];\n\toff_t manifest_ftell;\n\tlong offset;\n\tsize_t wrote;\n\tphp_uint32 manifest_len, mytime, loc, new_manifest_count;\n\tphp_uint32 newcrc32;\n\tphp_stream *file, *oldfile, *newfile, *stubfile;\n\tphp_stream_filter *filter;\n\tphp_serialize_data_t metadata_hash;\n\tsmart_str main_metadata_str = {0};\n\tint free_user_stub, free_fp = 1, free_ufp = 1;\n\tint manifest_hack = 0;\n\n\tif (phar->is_persistent) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"internal error: attempt to flush cached zip-based phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\t\treturn EOF;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (!zend_hash_num_elements(&phar->manifest) && !user_stub) {\n\t\treturn EOF;\n\t}\n\n\tzend_hash_clean(&phar->virtual_dirs);\n\n\tif (phar->is_zip) {\n\t\treturn phar_zip_flush(phar, user_stub, len, convert, error TSRMLS_CC);\n\t}\n\n\tif (phar->is_tar) {\n\t\treturn phar_tar_flush(phar, user_stub, len, convert, error TSRMLS_CC);\n\t}\n\n\tif (PHAR_G(readonly)) {\n\t\treturn EOF;\n\t}\n\n\tif (phar->fp && !phar->is_brandnew) {\n\t\toldfile = phar->fp;\n\t\tcloseoldfile = 0;\n\t\tphp_stream_rewind(oldfile);\n\t} else {\n\t\toldfile = php_stream_open_wrapper(phar->fname, \"rb\", 0, NULL);\n\t\tcloseoldfile = oldfile != NULL;\n\t}\n\tnewfile = php_stream_fopen_tmpfile();\n\tif (!newfile) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to create temporary file\");\n\t\t}\n\t\tif (closeoldfile) {\n\t\t\tphp_stream_close(oldfile);\n\t\t}\n\t\treturn EOF;\n\t}\n\n\tif (user_stub) {\n\t\tif (len < 0) {\n\t\t\t/* resource passed in */\n\t\t\tif (!(php_stream_from_zval_no_verify(stubfile, (zval **)user_stub))) {\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to access resource to copy stub to new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\tif (len == -1) {\n\t\t\t\tlen = PHP_STREAM_COPY_ALL;\n\t\t\t} else {\n\t\t\t\tlen = -len;\n\t\t\t}\n\t\t\tuser_stub = 0;\n\n\t\t\tif (!(len = php_stream_copy_to_mem(stubfile, &user_stub, len, 0)) || !user_stub) {\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to read resource to copy stub to new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\tfree_user_stub = 1;\n\t\t} else {\n\t\t\tfree_user_stub = 0;\n\t\t}\n\t\ttmp = estrndup(user_stub, len);\n\t\tif ((pos = php_stristr(tmp, halt_stub, len, sizeof(halt_stub) - 1)) == NULL) {\n\t\t\tefree(tmp);\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"illegal stub for phar \\\"%s\\\"\", phar->fname);\n\t\t\t}\n\t\t\tif (free_user_stub) {\n\t\t\t\tefree(user_stub);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tpos = user_stub + (pos - tmp);\n\t\tefree(tmp);\n\t\tlen = pos - user_stub + 18;\n\t\tif ((size_t)len != php_stream_write(newfile, user_stub, len)\n\t\t||\t\t\t  5 != php_stream_write(newfile, \" ?>\\r\\n\", 5)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to create stub from string in new phar \\\"%s\\\"\", phar->fname);\n\t\t\t}\n\t\t\tif (free_user_stub) {\n\t\t\t\tefree(user_stub);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tphar->halt_offset = len + 5;\n\t\tif (free_user_stub) {\n\t\t\tefree(user_stub);\n\t\t}\n\t} else {\n\t\tsize_t written;\n\n\t\tif (!user_stub && phar->halt_offset && oldfile && !phar->is_brandnew) {\n\t\t\tphp_stream_copy_to_stream_ex(oldfile, newfile, phar->halt_offset, &written);\n\t\t\tnewstub = NULL;\n\t\t} else {\n\t\t\t/* this is either a brand new phar or a default stub overwrite */\n\t\t\tnewstub = phar_create_default_stub(NULL, NULL, &(phar->halt_offset), NULL TSRMLS_CC);\n\t\t\twritten = php_stream_write(newfile, newstub, phar->halt_offset);\n\t\t}\n\t\tif (phar->halt_offset != written) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tif (newstub) {\n\t\t\t\t\tspprintf(error, 0, \"unable to create stub in new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t} else {\n\t\t\t\t\tspprintf(error, 0, \"unable to copy stub of old phar to new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newstub) {\n\t\t\t\tefree(newstub);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tif (newstub) {\n\t\t\tefree(newstub);\n\t\t}\n\t}\n\tmanifest_ftell = php_stream_tell(newfile);\n\thalt_offset = manifest_ftell;\n\n\t/* Check whether we can get rid of some of the deleted entries which are\n\t * unused. However some might still be in use so even after this clean-up\n\t * we need to skip entries marked is_deleted. */\n\tzend_hash_apply(&phar->manifest, phar_flush_clean_deleted_apply TSRMLS_CC);\n\n\t/* compress as necessary, calculate crcs, serialize meta-data, manifest size, and file sizes */\n\tmain_metadata_str.c = 0;\n\tif (phar->metadata) {\n\t\tPHP_VAR_SERIALIZE_INIT(metadata_hash);\n\t\tphp_var_serialize(&main_metadata_str, &phar->metadata, &metadata_hash TSRMLS_CC);\n\t\tPHP_VAR_SERIALIZE_DESTROY(metadata_hash);\n\t} else {\n\t\tmain_metadata_str.len = 0;\n\t}\n\tnew_manifest_count = 0;\n\toffset = 0;\n\tfor (zend_hash_internal_pointer_reset(&phar->manifest);\n\t\tzend_hash_has_more_elements(&phar->manifest) == SUCCESS;\n\t\tzend_hash_move_forward(&phar->manifest)) {\n\t\tif (zend_hash_get_current_data(&phar->manifest, (void **)&entry) == FAILURE) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->cfp) {\n\t\t\t/* did we forget to get rid of cfp last time? */\n\t\t\tphp_stream_close(entry->cfp);\n\t\t\tentry->cfp = 0;\n\t\t}\n\t\tif (entry->is_deleted || entry->is_mounted) {\n\t\t\t/* remove this from the new phar */\n\t\t\tcontinue;\n\t\t}\n\t\tif (!entry->is_modified && entry->fp_refcount) {\n\t\t\t/* open file pointers refer to this fp, do not free the stream */\n\t\t\tswitch (entry->fp_type) {\n\t\t\t\tcase PHAR_FP:\n\t\t\t\t\tfree_fp = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PHAR_UFP:\n\t\t\t\t\tfree_ufp = 0;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* after excluding deleted files, calculate manifest size in bytes and number of entries */\n\t\t++new_manifest_count;\n\t\tphar_add_virtual_dirs(phar, entry->filename, entry->filename_len TSRMLS_CC);\n\n\t\tif (entry->is_dir) {\n\t\t\t/* we use this to calculate API version, 1.1.1 is used for phars with directories */\n\t\t\thas_dirs = 1;\n\t\t}\n\t\tif (entry->metadata) {\n\t\t\tif (entry->metadata_str.c) {\n\t\t\t\tsmart_str_free(&entry->metadata_str);\n\t\t\t}\n\t\t\tentry->metadata_str.c = 0;\n\t\t\tentry->metadata_str.len = 0;\n\t\t\tPHP_VAR_SERIALIZE_INIT(metadata_hash);\n\t\t\tphp_var_serialize(&entry->metadata_str, &entry->metadata, &metadata_hash TSRMLS_CC);\n\t\t\tPHP_VAR_SERIALIZE_DESTROY(metadata_hash);\n\t\t} else {\n\t\t\tif (entry->metadata_str.c) {\n\t\t\t\tsmart_str_free(&entry->metadata_str);\n\t\t\t}\n\t\t\tentry->metadata_str.c = 0;\n\t\t\tentry->metadata_str.len = 0;\n\t\t}\n\n\t\t/* 32 bits for filename length, length of filename, manifest + metadata, and add 1 for trailing / if a directory */\n\t\toffset += 4 + entry->filename_len + sizeof(entry_buffer) + entry->metadata_str.len + (entry->is_dir ? 1 : 0);\n\n\t\t/* compress and rehash as necessary */\n\t\tif ((oldfile && !entry->is_modified) || entry->is_dir) {\n\t\t\tif (entry->fp_type == PHAR_UFP) {\n\t\t\t\t/* reset so we can copy the compressed data over */\n\t\t\t\tentry->fp_type = PHAR_FP;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!phar_get_efp(entry, 0 TSRMLS_CC)) {\n\t\t\t/* re-open internal file pointer just-in-time */\n\t\t\tnewentry = phar_open_jit(phar, entry, error TSRMLS_CC);\n\t\t\tif (!newentry) {\n\t\t\t\t/* major problem re-opening, so we ignore this file and the error */\n\t\t\t\tefree(*error);\n\t\t\t\t*error = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tentry = newentry;\n\t\t}\n\t\tfile = phar_get_efp(entry, 0 TSRMLS_CC);\n\t\tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tnewcrc32 = ~0;\n\t\tmytime = entry->uncompressed_filesize;\n\t\tfor (loc = 0;loc < mytime; ++loc) {\n\t\t\tCRC32(newcrc32, php_stream_getc(file));\n\t\t}\n\t\tentry->crc32 = ~newcrc32;\n\t\tentry->is_crc_checked = 1;\n\t\tif (!(entry->flags & PHAR_ENT_COMPRESSION_MASK)) {\n\t\t\t/* not compressed */\n\t\t\tentry->compressed_filesize = entry->uncompressed_filesize;\n\t\t\tcontinue;\n\t\t}\n\t\tfilter = php_stream_filter_create(phar_compress_filter(entry, 0), NULL, 0 TSRMLS_CC);\n\t\tif (!filter) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (entry->flags & PHAR_ENT_COMPRESSED_GZ) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to gzip compress file \\\"%s\\\" to new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to bzip2 compress file \\\"%s\\\" to new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\t/* create new file that holds the compressed version */\n\t\t/* work around inability to specify freedom in write and strictness\n\t\tin read count */\n\t\tentry->cfp = php_stream_fopen_tmpfile();\n\t\tif (!entry->cfp) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to create temporary file\");\n\t\t\t}\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\treturn EOF;\n\t\t}\n\t\tphp_stream_flush(file);\n\t\tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 0 TSRMLS_CC)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tphp_stream_filter_append((&entry->cfp->writefilters), filter);\n\t\tif (SUCCESS != php_stream_copy_to_stream_ex(file, entry->cfp, entry->uncompressed_filesize, NULL)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to copy compressed file contents of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tphp_stream_filter_flush(filter, 1);\n\t\tphp_stream_flush(entry->cfp);\n\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\tphp_stream_seek(entry->cfp, 0, SEEK_END);\n\t\tentry->compressed_filesize = (php_uint32) php_stream_tell(entry->cfp);\n\t\t/* generate crc on compressed file */\n\t\tphp_stream_rewind(entry->cfp);\n\t\tentry->old_flags = entry->flags;\n\t\tentry->is_modified = 1;\n\t\tglobal_flags |= (entry->flags & PHAR_ENT_COMPRESSION_MASK);\n\t}\n\tglobal_flags |= PHAR_HDR_SIGNATURE;\n\n\t/* write out manifest pre-header */\n\t/*  4: manifest length\n\t *  4: manifest entry count\n\t *  2: phar version\n\t *  4: phar global flags\n\t *  4: alias length\n\t *  ?: the alias itself\n\t *  4: phar metadata length\n\t *  ?: phar metadata\n\t */\n\trestore_alias_len = phar->alias_len;\n\tif (phar->is_temporary_alias) {\n\t\tphar->alias_len = 0;\n\t}\n\n\tmanifest_len = offset + phar->alias_len + sizeof(manifest) + main_metadata_str.len;\n\tphar_set_32(manifest, manifest_len);\n\t/* Hack - see bug #65028, add padding byte to the end of the manifest */\n\tif(manifest[0] == '\\r' || manifest[0] == '\\n') {\n\t\tmanifest_len++;\n\t\tphar_set_32(manifest, manifest_len);\n\t\tmanifest_hack = 1;\n\t}\n\tphar_set_32(manifest+4, new_manifest_count);\n\tif (has_dirs) {\n\t\t*(manifest + 8) = (unsigned char) (((PHAR_API_VERSION) >> 8) & 0xFF);\n\t\t*(manifest + 9) = (unsigned char) (((PHAR_API_VERSION) & 0xF0));\n\t} else {\n\t\t*(manifest + 8) = (unsigned char) (((PHAR_API_VERSION_NODIR) >> 8) & 0xFF);\n\t\t*(manifest + 9) = (unsigned char) (((PHAR_API_VERSION_NODIR) & 0xF0));\n\t}\n\tphar_set_32(manifest+10, global_flags);\n\tphar_set_32(manifest+14, phar->alias_len);\n\n\t/* write the manifest header */\n\tif (sizeof(manifest) != php_stream_write(newfile, manifest, sizeof(manifest))\n\t|| (size_t)phar->alias_len != php_stream_write(newfile, phar->alias, phar->alias_len)) {\n\n\t\tif (closeoldfile) {\n\t\t\tphp_stream_close(oldfile);\n\t\t}\n\n\t\tphp_stream_close(newfile);\n\t\tphar->alias_len = restore_alias_len;\n\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to write manifest header of new phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\n\t\treturn EOF;\n\t}\n\n\tphar->alias_len = restore_alias_len;\n\n\tphar_set_32(manifest, main_metadata_str.len);\n\tif (4 != php_stream_write(newfile, manifest, 4) || (main_metadata_str.len\n\t&& main_metadata_str.len != php_stream_write(newfile, main_metadata_str.c, main_metadata_str.len))) {\n\t\tsmart_str_free(&main_metadata_str);\n\n\t\tif (closeoldfile) {\n\t\t\tphp_stream_close(oldfile);\n\t\t}\n\n\t\tphp_stream_close(newfile);\n\t\tphar->alias_len = restore_alias_len;\n\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to write manifest meta-data of new phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\n\t\treturn EOF;\n\t}\n\tsmart_str_free(&main_metadata_str);\n\n\t/* re-calculate the manifest location to simplify later code */\n\tmanifest_ftell = php_stream_tell(newfile);\n\n\t/* now write the manifest */\n\tfor (zend_hash_internal_pointer_reset(&phar->manifest);\n\t\tzend_hash_has_more_elements(&phar->manifest) == SUCCESS;\n\t\tzend_hash_move_forward(&phar->manifest)) {\n\n\t\tif (zend_hash_get_current_data(&phar->manifest, (void **)&entry) == FAILURE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->is_deleted || entry->is_mounted) {\n\t\t\t/* remove this from the new phar if deleted, ignore if mounted */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->is_dir) {\n\t\t\t/* add 1 for trailing slash */\n\t\t\tphar_set_32(entry_buffer, entry->filename_len + 1);\n\t\t} else {\n\t\t\tphar_set_32(entry_buffer, entry->filename_len);\n\t\t}\n\n\t\tif (4 != php_stream_write(newfile, entry_buffer, 4)\n\t\t|| entry->filename_len != php_stream_write(newfile, entry->filename, entry->filename_len)\n\t\t|| (entry->is_dir && 1 != php_stream_write(newfile, \"/\", 1))) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tif (entry->is_dir) {\n\t\t\t\t\tspprintf(error, 0, \"unable to write filename of directory \\\"%s\\\" to manifest of new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t} else {\n\t\t\t\t\tspprintf(error, 0, \"unable to write filename of file \\\"%s\\\" to manifest of new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\t/* set the manifest meta-data:\n\t\t\t4: uncompressed filesize\n\t\t\t4: creation timestamp\n\t\t\t4: compressed filesize\n\t\t\t4: crc32\n\t\t\t4: flags\n\t\t\t4: metadata-len\n\t\t\t+: metadata\n\t\t*/\n\t\tmytime = time(NULL);\n\t\tphar_set_32(entry_buffer, entry->uncompressed_filesize);\n\t\tphar_set_32(entry_buffer+4, mytime);\n\t\tphar_set_32(entry_buffer+8, entry->compressed_filesize);\n\t\tphar_set_32(entry_buffer+12, entry->crc32);\n\t\tphar_set_32(entry_buffer+16, entry->flags);\n\t\tphar_set_32(entry_buffer+20, entry->metadata_str.len);\n\n\t\tif (sizeof(entry_buffer) != php_stream_write(newfile, entry_buffer, sizeof(entry_buffer))\n\t\t|| entry->metadata_str.len != php_stream_write(newfile, entry->metadata_str.c, entry->metadata_str.len)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\n\t\t\tphp_stream_close(newfile);\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to write temporary manifest of file \\\"%s\\\" to manifest of new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\n\t\t\treturn EOF;\n\t\t}\n\t}\n\t/* Hack - see bug #65028, add padding byte to the end of the manifest */\n\tif(manifest_hack) {\n\t\tif(1 != php_stream_write(newfile, manifest, 1)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\n\t\t\tphp_stream_close(newfile);\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to write manifest padding byte\");\n\t\t\t}\n\n\t\t\treturn EOF;\n\t\t}\n\t}\n\n\t/* now copy the actual file data to the new phar */\n\toffset = php_stream_tell(newfile);\n\tfor (zend_hash_internal_pointer_reset(&phar->manifest);\n\t\tzend_hash_has_more_elements(&phar->manifest) == SUCCESS;\n\t\tzend_hash_move_forward(&phar->manifest)) {\n\n\t\tif (zend_hash_get_current_data(&phar->manifest, (void **)&entry) == FAILURE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->is_deleted || entry->is_dir || entry->is_mounted) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->cfp) {\n\t\t\tfile = entry->cfp;\n\t\t\tphp_stream_rewind(file);\n\t\t} else {\n\t\t\tfile = phar_get_efp(entry, 0 TSRMLS_CC);\n\t\t\tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 0 TSRMLS_CC)) {\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t}\n\n\t\tif (!file) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\t/* this will have changed for all files that have either changed compression or been modified */\n\t\tentry->offset = entry->offset_abs = offset;\n\t\toffset += entry->compressed_filesize;\n\t\tif (php_stream_copy_to_stream_ex(file, newfile, entry->compressed_filesize, &wrote) == FAILURE) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\n\t\t\tphp_stream_close(newfile);\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to write contents of file \\\"%s\\\" to new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\n\t\t\treturn EOF;\n\t\t}\n\n\t\tentry->is_modified = 0;\n\n\t\tif (entry->cfp) {\n\t\t\tphp_stream_close(entry->cfp);\n\t\t\tentry->cfp = NULL;\n\t\t}\n\n\t\tif (entry->fp_type == PHAR_MOD) {\n\t\t\t/* this fp is in use by a phar_entry_data returned by phar_get_entry_data, it will be closed when the phar_entry_data is phar_entry_delref'ed */\n\t\t\tif (entry->fp_refcount == 0 && entry->fp != phar->fp && entry->fp != phar->ufp) {\n\t\t\t\tphp_stream_close(entry->fp);\n\t\t\t}\n\n\t\t\tentry->fp = NULL;\n\t\t\tentry->fp_type = PHAR_FP;\n\t\t} else if (entry->fp_type == PHAR_UFP) {\n\t\t\tentry->fp_type = PHAR_FP;\n\t\t}\n\t}\n\n\t/* append signature */\n\tif (global_flags & PHAR_HDR_SIGNATURE) {\n\t\tchar sig_buf[4];\n\n\t\tphp_stream_rewind(newfile);\n\n\t\tif (phar->signature) {\n\t\t\tefree(phar->signature);\n\t\t\tphar->signature = NULL;\n\t\t}\n\n\t\tswitch(phar->sig_flags) {\n#ifndef PHAR_HASH_OK\n\t\t\tcase PHAR_SIG_SHA512:\n\t\t\tcase PHAR_SIG_SHA256:\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to write contents of file \\\"%s\\\" to new phar \\\"%s\\\" with requested hash type\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n#endif\n\t\t\tdefault: {\n\t\t\t\tchar *digest = NULL;\n\t\t\t\tint digest_len;\n\n\t\t\t\tif (FAILURE == phar_create_signature(phar, newfile, &digest, &digest_len, error TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar error: unable to write signature: %s\", save);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\tif (digest) {\n\t\t\t\t\t\tefree(digest);\n\t\t\t\t\t}\n\t\t\t\t\tif (closeoldfile) {\n\t\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(newfile);\n\t\t\t\t\treturn EOF;\n\t\t\t\t}\n\n\t\t\t\tphp_stream_write(newfile, digest, digest_len);\n\t\t\t\tefree(digest);\n\t\t\t\tif (phar->sig_flags == PHAR_SIG_OPENSSL) {\n\t\t\t\t\tphar_set_32(sig_buf, digest_len);\n\t\t\t\t\tphp_stream_write(newfile, sig_buf, 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tphar_set_32(sig_buf, phar->sig_flags);\n\t\tphp_stream_write(newfile, sig_buf, 4);\n\t\tphp_stream_write(newfile, \"GBMB\", 4);\n\t}\n\n\t/* finally, close the temp file, rename the original phar,\n\t   move the temp to the old phar, unlink the old phar, and reload it into memory\n\t*/\n\tif (phar->fp && free_fp) {\n\t\tphp_stream_close(phar->fp);\n\t}\n\n\tif (phar->ufp) {\n\t\tif (free_ufp) {\n\t\t\tphp_stream_close(phar->ufp);\n\t\t}\n\t\tphar->ufp = NULL;\n\t}\n\n\tif (closeoldfile) {\n\t\tphp_stream_close(oldfile);\n\t}\n\n\tphar->internal_file_start = halt_offset + manifest_len + 4;\n\tphar->halt_offset = halt_offset;\n\tphar->is_brandnew = 0;\n\n\tphp_stream_rewind(newfile);\n\n\tif (phar->donotflush) {\n\t\t/* deferred flush */\n\t\tphar->fp = newfile;\n\t} else {\n\t\tphar->fp = php_stream_open_wrapper(phar->fname, \"w+b\", IGNORE_URL|STREAM_MUST_SEEK|REPORT_ERRORS, NULL);\n\t\tif (!phar->fp) {\n\t\t\tphar->fp = newfile;\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"unable to open new phar \\\"%s\\\" for writing\", phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\tif (phar->flags & PHAR_FILE_COMPRESSED_GZ) {\n\t\t\t/* to properly compress, we have to tell zlib to add a zlib header */\n\t\t\tzval filterparams;\n\n\t\t\tarray_init(&filterparams);\n\t\t\tadd_assoc_long(&filterparams, \"window\", MAX_WBITS+16);\n\t\t\tfilter = php_stream_filter_create(\"zlib.deflate\", &filterparams, php_stream_is_persistent(phar->fp) TSRMLS_CC);\n\t\t\tzval_dtor(&filterparams);\n\n\t\t\tif (!filter) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"unable to compress all contents of phar \\\"%s\\\" using zlib, PHP versions older than 5.2.6 have a buggy zlib\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\n\t\t\tphp_stream_filter_append(&phar->fp->writefilters, filter);\n\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\tphp_stream_close(phar->fp);\n\t\t\t/* use the temp stream as our base */\n\t\t\tphar->fp = newfile;\n\t\t} else if (phar->flags & PHAR_FILE_COMPRESSED_BZ2) {\n\t\t\tfilter = php_stream_filter_create(\"bzip2.compress\", NULL, php_stream_is_persistent(phar->fp) TSRMLS_CC);\n\t\t\tphp_stream_filter_append(&phar->fp->writefilters, filter);\n\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\tphp_stream_close(phar->fp);\n\t\t\t/* use the temp stream as our base */\n\t\t\tphar->fp = newfile;\n\t\t} else {\n\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\t/* we could also reopen the file in \"rb\" mode but there is no need for that */\n\t\t\tphp_stream_close(newfile);\n\t\t}\n\t}\n\n\tif (-1 == php_stream_seek(phar->fp, phar->halt_offset, SEEK_SET)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to seek to __HALT_COMPILER(); in new phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\t\treturn EOF;\n\t}\n\n\treturn EOF;\n}\n/* }}} */\n\n#ifdef COMPILE_DL_PHAR\nZEND_GET_MODULE(phar)\n#endif\n\n/* {{{ phar_functions[]\n *\n * Every user visible function must have an entry in phar_functions[].\n */\nzend_function_entry phar_functions[] = {\n\tPHP_FE_END\n};\n/* }}}*/\n\nstatic size_t phar_zend_stream_reader(void *handle, char *buf, size_t len TSRMLS_DC) /* {{{ */\n{\n\treturn php_stream_read(phar_get_pharfp((phar_archive_data*)handle TSRMLS_CC), buf, len);\n}\n/* }}} */\n\nstatic size_t phar_zend_stream_fsizer(void *handle TSRMLS_DC) /* {{{ */\n{\n\treturn ((phar_archive_data*)handle)->halt_offset + 32;\n} /* }}} */\n\nzend_op_array *(*phar_orig_compile_file)(zend_file_handle *file_handle, int type TSRMLS_DC);\n#define phar_orig_zend_open zend_stream_open_function\n\nstatic char *phar_resolve_path(const char *filename, int filename_len TSRMLS_DC)\n{\n\treturn phar_find_in_include_path((char *) filename, filename_len, NULL TSRMLS_CC);\n}\n\nstatic zend_op_array *phar_compile_file(zend_file_handle *file_handle, int type TSRMLS_DC) /* {{{ */\n{\n\tzend_op_array *res;\n\tchar *name = NULL;\n\tint failed;\n\tphar_archive_data *phar;\n\n\tif (!file_handle || !file_handle->filename) {\n\t\treturn phar_orig_compile_file(file_handle, type TSRMLS_CC);\n\t}\n\tif (strstr(file_handle->filename, \".phar\") && !strstr(file_handle->filename, \"://\")) {\n\t\tif (SUCCESS == phar_open_from_filename((char*)file_handle->filename, strlen(file_handle->filename), NULL, 0, 0, &phar, NULL TSRMLS_CC)) {\n\t\t\tif (phar->is_zip || phar->is_tar) {\n\t\t\t\tzend_file_handle f = *file_handle;\n\n\t\t\t\t/* zip or tar-based phar */\n\t\t\t\tspprintf(&name, 4096, \"phar://%s/%s\", file_handle->filename, \".phar/stub.php\");\n\t\t\t\tif (SUCCESS == phar_orig_zend_open((const char *)name, file_handle TSRMLS_CC)) {\n\t\t\t\t\tefree(name);\n\t\t\t\t\tname = NULL;\n\t\t\t\t\tfile_handle->filename = f.filename;\n\t\t\t\t\tif (file_handle->opened_path) {\n\t\t\t\t\t\tefree(file_handle->opened_path);\n\t\t\t\t\t}\n\t\t\t\t\tfile_handle->opened_path = f.opened_path;\n\t\t\t\t\tfile_handle->free_filename = f.free_filename;\n\t\t\t\t} else {\n\t\t\t\t\t*file_handle = f;\n\t\t\t\t}\n\t\t\t} else if (phar->flags & PHAR_FILE_COMPRESSION_MASK) {\n\t\t\t\t/* compressed phar */\n\t\t\t\tfile_handle->type = ZEND_HANDLE_STREAM;\n\t\t\t\t/* we do our own reading directly from the phar, don't change the next line */\n\t\t\t\tfile_handle->handle.stream.handle  = phar;\n\t\t\t\tfile_handle->handle.stream.reader  = phar_zend_stream_reader;\n\t\t\t\tfile_handle->handle.stream.closer  = NULL;\n\t\t\t\tfile_handle->handle.stream.fsizer  = phar_zend_stream_fsizer;\n\t\t\t\tfile_handle->handle.stream.isatty  = 0;\n\t\t\t\tphar->is_persistent ?\n\t\t\t\t\tphp_stream_rewind(PHAR_GLOBALS->cached_fp[phar->phar_pos].fp) :\n\t\t\t\t\tphp_stream_rewind(phar->fp);\n\t\t\t\tmemset(&file_handle->handle.stream.mmap, 0, sizeof(file_handle->handle.stream.mmap));\n\t\t\t}\n\t\t}\n\t}\n\n\tzend_try {\n\t\tfailed = 0;\n\t\tCG(zend_lineno) = 0;\n\t\tres = phar_orig_compile_file(file_handle, type TSRMLS_CC);\n\t} zend_catch {\n\t\tfailed = 1;\n\t\tres = NULL;\n\t} zend_end_try();\n",
        "fix": null,
        "src_path": "b28b8b2fee6dfa6fcd13305c581bb835689ac3be___phar.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/b28b8b2fee6dfa6fcd13305c581bb835689ac3be",
        "commit_msg": "Fix bug #73768 - Memory corruption when loading hostile phar",
        "test_func_diff": [
            {
                "fn": "ext/phar/tests/bug73768.phpt",
                "patch": "@@ -0,0 +1,16 @@\n+--TEST--\n+Phar: PHP bug #73768: Memory corruption when loading hostile phar\n+--SKIPIF--\n+<?php if (!extension_loaded(\"phar\")) die(\"skip\"); ?>\n+--FILE--\n+<?php\n+chdir(__DIR__);\n+try {\n+$p = Phar::LoadPhar('bug73768.phar', 'alias.phar');\n+echo \"OK\\n\";\n+} catch(PharException $e) {\n+\techo $e->getMessage();\n+}\n+?>\n+--EXPECTF--\n+cannot load phar \"%sbug73768.phar\" with implicit alias \"\" under different alias \"alias.phar\""
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.30-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_b28b8b2fee6dfa6fcd13305c581bb835689ac3be More .INIs : CWD : /out/php___php-src/git_repo_dir_b28b8b2fee6dfa6fcd13305c581bb835689ac3be Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/phar/tests/bug73768.phpt]\rFAIL Phar: PHP bug #73768: Memory corruption when loading hostile phar [ext/phar/tests/bug73768.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Phar: PHP bug #73768: Memory corruption when loading hostile phar [ext/phar/tests/bug73768.phpt] =====================================================================\n"
    },
    "8d2539fa0faf3f63e1d1e7635347c5b9e777d47b___wddx.c": {
        "start": 879,
        "end": 1018,
        "buggy": "static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t*pce;\n\tzval\t\t\t\tobj;\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp((char *)name, EL_STRING) || !strcmp((char *)name, EL_NUMBER) ||\n\t\t!strcmp((char *)name, EL_BOOLEAN) || !strcmp((char *)name, EL_NULL) ||\n\t  \t!strcmp((char *)name, EL_ARRAY) || !strcmp((char *)name, EL_STRUCT) ||\n\t\t!strcmp((char *)name, EL_RECORDSET) || !strcmp((char *)name, EL_BINARY) ||\n\t\t!strcmp((char *)name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (Z_TYPE(ent1->data) == IS_UNDEF) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t\tefree(ent1);\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp((char *)name, EL_BINARY)) {\n\t\t\tzend_string *new_str = NULL;\n\t\t\t\n\t\t\tif (ZSTR_EMPTY_ALLOC() != Z_STR(ent1->data)) {\n\t\t\t\tnew_str = php_base64_decode(\n\t\t\t\t\t(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t}\n\n\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\tif (new_str) {\n\t\t\t\tZVAL_STR(&ent1->data, new_str);\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(&ent1->data);\n\t\t\t}\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE(ent1->data) == IS_OBJECT) {\n\t\t\tzval fname, retval;\n\n\t\t\tZVAL_STRING(&fname, \"__wakeup\");\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, &fname, &retval, 0, 0, 0, NULL);\n\n\t\t\tzval_ptr_dtor(&fname);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (Z_ISUNDEF(ent2->data)) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE(ent2->data) == IS_ARRAY || Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(&ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE(ent1->data) == IS_STRING && Z_STRLEN(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\tzend_string_forget_hash_val(Z_STR(ent1->data));\n\t\t\t\t\t\tif ((pce = zend_hash_find_ptr(EG(class_table), Z_STR(ent1->data))) == NULL) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (pce != PHP_IC_ENTRY && (pce->serialize || pce->unserialize)) {\n\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\t\t\t\t\t\t\tZVAL_UNDEF(&ent2->data);\n\t\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Class %s can not be unserialized\", Z_STRVAL(ent1->data));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\t\tobject_init_ex(&obj, pce);\n\n\t\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP(obj),\n\t\t\t\t\t\t\t\t\t\t\tZ_ARRVAL(ent2->data),\n\t\t\t\t\t\t\t\t\t\t\tzval_add_ref, 0);\n\n\t\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\t\tphp_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\t\tZVAL_COPY_VALUE(&ent2->data, &obj);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE(ent2->data);\n\t\t\t\t\t\tadd_property_zval(&ent2->data, ent1->varname, &ent1->data);\n\t\t\t\t\t\tif Z_REFCOUNTED(ent1->data) Z_DELREF(ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_str_update(target_hash, ent1->varname, strlen(ent1->varname), &ent1->data);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp((char *)name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp((char *)name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}\n}\n",
        "fix": null,
        "src_path": "8d2539fa0faf3f63e1d1e7635347c5b9e777d47b___wddx.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/8d2539fa0faf3f63e1d1e7635347c5b9e777d47b",
        "commit_msg": "Fix bug #73831 - NULL Pointer Dereference while unserialize php object",
        "test_func_diff": [
            {
                "fn": "ext/wddx/tests/bug73831.phpt",
                "patch": "@@ -0,0 +1,23 @@\n+--TEST--\n+Bug #73831 (NULL Pointer Dereference while unserialize php object)\n+--SKIPIF--\n+<?php if (!extension_loaded(\"wddx\")) print \"skip\"; ?>\n+--FILE--\n+<?php\n+$xml = <<<EOF\n+<?xml version=\"1.0\" ?>\n+<wddxPacket version=\"1.0\">\n+\t<struct>\n+\t\t<var name=\"php_class_name\">\n+\t\t\t<string>Throwable</string>\n+                </var>\n+        </struct>\n+</wddxPacket>\n+EOF;\n+try {\n+\t$wddx = wddx_deserialize($xml);\n+} catch(Error $e) { echo $e->getMessage(); }\n+?>\n+--EXPECTF--\n+Warning: wddx_deserialize(): Class throwable can not be instantiated in %sbug73831.php on line %d\n+Cannot instantiate interface Throwable"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 7.0.15-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_8d2539fa0faf3f63e1d1e7635347c5b9e777d47b More .INIs : --------------------------------------------------------------------- PHP : /out/php___php-src/git_repo_dir_8d2539fa0faf3f63e1d1e7635347c5b9e777d47b/sapi/phpdbg/phpdbg PHP_SAPI : phpdbg PHP_VERSION : 7.0.15-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_8d2539fa0faf3f63e1d1e7635347c5b9e777d47b More .INIs : --------------------------------------------------------------------- CWD : /out/php___php-src/git_repo_dir_8d2539fa0faf3f63e1d1e7635347c5b9e777d47b Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. FAIL Bug #73831 (NULL Pointer Dereference while unserialize php object) [ext/wddx/tests/bug73831.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 1 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #73831 (NULL Pointer Dereference while unserialize php object) [ext/wddx/tests/bug73831.phpt] =====================================================================\n"
    },
    "bab0b99f376dac9170ac81382a5ed526938d595a___xp_socket.c": {
        "start": 568,
        "end": 605,
        "buggy": "static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)\n{\n\tchar *colon;\n\tchar *host = NULL;\n\n#ifdef HAVE_IPV6\n\tchar *p;\n\n\tif (*(str) == '[' && str_len > 1) {\n\t\t/* IPV6 notation to specify raw address with port (i.e. [fe80::1]:80) */\n\t\tp = memchr(str + 1, ']', str_len - 2);\n\t\tif (!p || *(p + 1) != ':') {\n\t\t\tif (get_err) {\n\t\t\t\t*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\t*portno = atoi(p + 2);\n\t\treturn estrndup(str + 1, p - str - 1);\n\t}\n#endif\n\tif (str_len) {\n\t\tcolon = memchr(str, ':', str_len - 1);\n\t} else {\n\t\tcolon = NULL;\n\t}\n\tif (colon) {\n\t\t*portno = atoi(colon + 1);\n\t\thost = estrndup(str, colon - str);\n\t} else {\n\t\tif (get_err) {\n\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\treturn host;\n}\n",
        "fix": null,
        "src_path": "bab0b99f376dac9170ac81382a5ed526938d595a___xp_socket.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/bab0b99f376dac9170ac81382a5ed526938d595a",
        "commit_msg": "Detect invalid port in xp_socket parse ip address\n\nFor historical reasons, fsockopen() accepts the port and hostname\nseparately: fsockopen('127.0.0.1', 80)\n\nHowever, with the introdcution of stream transports in PHP 4.3,\nit became possible to include the port in the hostname specifier:\n\nfsockopen('127.0.0.1:80')\nOr more formally: fsockopen('tcp://127.0.0.1:80')\n\nConfusing results when these two forms are combined, however.\nfsockopen('127.0.0.1:80', 443) results in fsockopen() attempting\nto connect to '127.0.0.1:80:443' which any reasonable stack would\nconsider invalid.\n\nUnfortunately, PHP parses the address looking for the first colon\n(with special handling for IPv6, don't worry) and calls atoi()\nfrom there.  atoi() in turn, simply stops parsing at the first\nnon-numeric character and returns the value so far.\n\nThe end result is that the explicitly supplied port is treated\nas ignored garbage, rather than producing an error.\n\nThis diff replaces atoi() with strtol() and inspects the\nstop character.  If additional \"garbage\" of any kind is found,\nit fails and returns an error.",
        "test_func_diff": [
            {
                "fn": "ext/standard/tests/streams/parseip-001.phpt",
                "patch": "@@ -0,0 +1,37 @@\n+--TEST--\n+Use of double-port in fsockopen()\n+--FILE--\n+<?php\n+\n+$try = [\n+  '127.0.0.1:80',\n+  'tcp://127.0.0.1:80',\n+  '[::1]:80',\n+  'tcp://[::1]:80',\n+  'localhost:80',\n+  'tcp://localhost:80',\n+];\n+\n+foreach ($try as $addr) {\n+  echo \"== $addr ==\\n\";\n+  var_dump(@fsockopen($addr, 81, $errno, $errstr), $errstr);\n+}\n+--EXPECTF--\n+== 127.0.0.1:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"127.0.0.1:80:81\"\"\n+== tcp://127.0.0.1:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"127.0.0.1:80:81\"\"\n+== [::1]:80 ==\n+bool(false)\n+string(37) \"Failed to parse address \"[::1]:80:81\"\"\n+== tcp://[::1]:80 ==\n+bool(false)\n+string(37) \"Failed to parse address \"[::1]:80:81\"\"\n+== localhost:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"localhost:80:81\"\"\n+== tcp://localhost:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"localhost:80:81\"\"\n\\ No newline at end of file"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 7.0.18-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_bab0b99f376dac9170ac81382a5ed526938d595a More .INIs : --------------------------------------------------------------------- PHP : /out/php___php-src/git_repo_dir_bab0b99f376dac9170ac81382a5ed526938d595a/sapi/phpdbg/phpdbg PHP_SAPI : phpdbg PHP_VERSION : 7.0.18-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_bab0b99f376dac9170ac81382a5ed526938d595a More .INIs : --------------------------------------------------------------------- CWD : /out/php___php-src/git_repo_dir_bab0b99f376dac9170ac81382a5ed526938d595a Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. FAIL Use of double-port in fsockopen() [ext/standard/tests/streams/parseip-001.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Use of double-port in fsockopen() [ext/standard/tests/streams/parseip-001.phpt] =====================================================================\n"
    },
    "523f230c831d7b33353203fa34aee4e92ac12bba___http_fopen_wrapper.c": {
        "start": 112,
        "end": 976,
        "buggy": "php_stream *php_stream_url_wrap_http_ex(php_stream_wrapper *wrapper, \n\t\tconst char *path, const char *mode, int options, char **opened_path, \n\t\tphp_stream_context *context, int redirect_max, int flags STREAMS_DC TSRMLS_DC) /* {{{ */\n{\n\tphp_stream *stream = NULL;\n\tphp_url *resource = NULL;\n\tint use_ssl;\n\tint use_proxy = 0;\n\tchar *scratch = NULL;\n\tchar *tmp = NULL;\n\tchar *ua_str = NULL;\n\tzval **ua_zval = NULL, **tmpzval = NULL, *ssl_proxy_peer_name = NULL;\n\tint scratch_len = 0;\n\tint body = 0;\n\tchar location[HTTP_HEADER_BLOCK_SIZE];\n\tzval *response_header = NULL;\n\tint reqok = 0;\n\tchar *http_header_line = NULL;\n\tchar tmp_line[128];\n\tsize_t chunk_size = 0, file_size = 0;\n\tint eol_detect = 0;\n\tchar *transport_string, *errstr = NULL;\n\tint transport_len, have_header = 0, request_fulluri = 0, ignore_errors = 0;\n\tchar *protocol_version = NULL;\n\tint protocol_version_len = 3; /* Default: \"1.0\" */\n\tstruct timeval timeout;\n\tchar *user_headers = NULL;\n\tint header_init = ((flags & HTTP_WRAPPER_HEADER_INIT) != 0);\n\tint redirected = ((flags & HTTP_WRAPPER_REDIRECTED) != 0);\n\tint follow_location = 1;\n\tphp_stream_filter *transfer_encoding = NULL;\n\tint response_code;\n\n\ttmp_line[0] = '\\0';\n\n\tif (redirect_max < 1) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Redirection limit reached, aborting\");\n\t\treturn NULL;\n\t}\n\n\tresource = php_url_parse(path);\n\tif (resource == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (strncasecmp(resource->scheme, \"http\", sizeof(\"http\")) && strncasecmp(resource->scheme, \"https\", sizeof(\"https\"))) {\n\t\tif (!context ||\n\t\t\tphp_stream_context_get_option(context, wrapper->wops->label, \"proxy\", &tmpzval) == FAILURE ||\n\t\t\tZ_TYPE_PP(tmpzval) != IS_STRING ||\n\t\t\tZ_STRLEN_PP(tmpzval) <= 0) {\n\t\t\tphp_url_free(resource);\n\t\t\treturn php_stream_open_wrapper_ex(path, mode, REPORT_ERRORS, NULL, context);\n\t\t}\n\t\t/* Called from a non-http wrapper with http proxying requested (i.e. ftp) */\n\t\trequest_fulluri = 1;\n\t\tuse_ssl = 0;\n\t\tuse_proxy = 1;\n\n\t\ttransport_len = Z_STRLEN_PP(tmpzval);\n\t\ttransport_string = estrndup(Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval));\n\t} else {\n\t\t/* Normal http request (possibly with proxy) */\n\n\t\tif (strpbrk(mode, \"awx+\")) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP wrapper does not support writeable connections\");\n\t\t\tphp_url_free(resource);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuse_ssl = resource->scheme && (strlen(resource->scheme) > 4) && resource->scheme[4] == 's';\n\t\t/* choose default ports */\n\t\tif (use_ssl && resource->port == 0)\n\t\t\tresource->port = 443;\n\t\telse if (resource->port == 0)\n\t\t\tresource->port = 80;\n\n\t\tif (context &&\n\t\t\tphp_stream_context_get_option(context, wrapper->wops->label, \"proxy\", &tmpzval) == SUCCESS &&\n\t\t\tZ_TYPE_PP(tmpzval) == IS_STRING &&\n\t\t\tZ_STRLEN_PP(tmpzval) > 0) {\n\t\t\tuse_proxy = 1;\n\t\t\ttransport_len = Z_STRLEN_PP(tmpzval);\n\t\t\ttransport_string = estrndup(Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval));\n\t\t} else {\n\t\t\ttransport_len = spprintf(&transport_string, 0, \"%s://%s:%d\", use_ssl ? \"ssl\" : \"tcp\", resource->host, resource->port);\n\t\t}\n\t}\n\n\tif (context && php_stream_context_get_option(context, wrapper->wops->label, \"timeout\", &tmpzval) == SUCCESS) {\n\t\tSEPARATE_ZVAL(tmpzval);\n\t\tconvert_to_double_ex(tmpzval);\n\t\ttimeout.tv_sec = (time_t) Z_DVAL_PP(tmpzval);\n\t\ttimeout.tv_usec = (size_t) ((Z_DVAL_PP(tmpzval) - timeout.tv_sec) * 1000000);\n\t} else {\n\t\ttimeout.tv_sec = FG(default_socket_timeout);\n\t\ttimeout.tv_usec = 0;\n\t}\n\n\tstream = php_stream_xport_create(transport_string, transport_len, options,\n\t\t\tSTREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT,\n\t\t\tNULL, &timeout, context, &errstr, NULL);\n\n\tif (stream) {\n\t\tphp_stream_set_option(stream, PHP_STREAM_OPTION_READ_TIMEOUT, 0, &timeout);\n\t}\n\n\tif (errstr) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"%s\", errstr);\n\t\tefree(errstr);\n\t\terrstr = NULL;\n\t}\n\n\tefree(transport_string);\n\n\tif (stream && use_proxy && use_ssl) {\n\t\tsmart_str header = {0};\n\n\t\t/* Set peer_name or name verification will try to use the proxy server name */\n\t\tif (!context || php_stream_context_get_option(context, \"ssl\", \"peer_name\", &tmpzval) == FAILURE) {\n\t\t\tMAKE_STD_ZVAL(ssl_proxy_peer_name);\n\t\t\tZVAL_STRING(ssl_proxy_peer_name, resource->host, 1);\n\t\t\tphp_stream_context_set_option(stream->context, \"ssl\", \"peer_name\", ssl_proxy_peer_name);\n\t\t}\n\n\t\tsmart_str_appendl(&header, \"CONNECT \", sizeof(\"CONNECT \")-1);\n\t\tsmart_str_appends(&header, resource->host);\n\t\tsmart_str_appendc(&header, ':');\n\t\tsmart_str_append_unsigned(&header, resource->port);\n\t\tsmart_str_appendl(&header, \" HTTP/1.0\\r\\n\", sizeof(\" HTTP/1.0\\r\\n\")-1);\n\n\t    /* check if we have Proxy-Authorization header */\n\t\tif (context && php_stream_context_get_option(context, \"http\", \"header\", &tmpzval) == SUCCESS) {\n\t\t\tchar *s, *p;\n\n\t\t\tif (Z_TYPE_PP(tmpzval) == IS_ARRAY) {\n\t\t\t\tHashPosition pos;\n\t\t\t\tzval **tmpheader = NULL;\n\n\t\t\t\tfor (zend_hash_internal_pointer_reset_ex(Z_ARRVAL_PP(tmpzval), &pos);\n\t\t\t\t\tSUCCESS == zend_hash_get_current_data_ex(Z_ARRVAL_PP(tmpzval), (void *)&tmpheader, &pos);\n\t\t\t\t\tzend_hash_move_forward_ex(Z_ARRVAL_PP(tmpzval), &pos)) {\n\t\t\t\t\tif (Z_TYPE_PP(tmpheader) == IS_STRING) {\n\t\t\t\t\t\ts = Z_STRVAL_PP(tmpheader);\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\twhile (*s == ' ' || *s == '\\t') s++;\n\t\t\t\t\t\t\tp = s;\n\t\t\t\t\t\t\twhile (*p != 0 && *p != ':' && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\tif (*p == ':') {\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\tif (p - s == sizeof(\"Proxy-Authorization:\") - 1 &&\n\t\t\t\t\t\t\t\t    zend_binary_strcasecmp(s, sizeof(\"Proxy-Authorization:\") - 1,\n\t\t\t\t\t\t\t\t        \"Proxy-Authorization:\", sizeof(\"Proxy-Authorization:\") - 1) == 0) {\n\t\t\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\t\t\tsmart_str_appendl(&header, s, p - s);\n\t\t\t\t\t\t\t\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\t\t\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts = p;\n\t\t\t\t\t\t\twhile (*s == '\\r' || *s == '\\n') s++;\n\t\t\t\t\t\t} while (*s != 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (Z_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval)) {\n\t\t\t\ts = Z_STRVAL_PP(tmpzval);\n\t\t\t\tdo {\n\t\t\t\t\twhile (*s == ' ' || *s == '\\t') s++;\n\t\t\t\t\tp = s;\n\t\t\t\t\twhile (*p != 0 && *p != ':' && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\tif (*p == ':') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tif (p - s == sizeof(\"Proxy-Authorization:\") - 1 &&\n\t\t\t\t\t\t    zend_binary_strcasecmp(s, sizeof(\"Proxy-Authorization:\") - 1,\n\t\t\t\t\t\t        \"Proxy-Authorization:\", sizeof(\"Proxy-Authorization:\") - 1) == 0) {\n\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\tsmart_str_appendl(&header, s, p - s);\n\t\t\t\t\t\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ts = p;\n\t\t\t\t\twhile (*s == '\\r' || *s == '\\n') s++;\n\t\t\t\t} while (*s != 0);\n\t\t\t}\n\t\t}\nfinish:\n\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\n\t\tif (php_stream_write(stream, header.c, header.len) != header.len) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Cannot connect to HTTPS server through proxy\");\n\t\t\tphp_stream_close(stream);\n\t\t\tstream = NULL;\n\t\t}\n \t \tsmart_str_free(&header);\n\n \t \tif (stream) {\n \t \t\tchar header_line[HTTP_HEADER_BLOCK_SIZE];\n\n\t\t\t/* get response header */\n\t\t\twhile (php_stream_gets(stream, header_line, HTTP_HEADER_BLOCK_SIZE-1) != NULL) {\n\t\t\t\tif (header_line[0] == '\\n' ||\n\t\t\t\t    header_line[0] == '\\r' ||\n\t\t\t\t    header_line[0] == '\\0') {\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* enable SSL transport layer */\n\t\tif (stream) {\n\t\t\tif (php_stream_xport_crypto_setup(stream, STREAM_CRYPTO_METHOD_SSLv23_CLIENT, NULL TSRMLS_CC) < 0 ||\n\t\t\t    php_stream_xport_crypto_enable(stream, 1 TSRMLS_CC) < 0) {\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Cannot connect to HTTPS server through proxy\");\n\t\t\t\tphp_stream_close(stream);\n\t\t\t\tstream = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stream == NULL)\n\t\tgoto out;\n\n\t/* avoid buffering issues while reading header */\n\tif (options & STREAM_WILL_CAST)\n\t\tchunk_size = php_stream_set_chunk_size(stream, 1);\n\n\t/* avoid problems with auto-detecting when reading the headers -> the headers\n\t * are always in canonical \\r\\n format */\n\teol_detect = stream->flags & (PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC);\n\tstream->flags &= ~(PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC);\n\n\tphp_stream_context_set(stream, context);\n\n\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_CONNECT, NULL, 0);\n\n\tif (header_init && context && php_stream_context_get_option(context, \"http\", \"max_redirects\", &tmpzval) == SUCCESS) {\n\t\tSEPARATE_ZVAL(tmpzval);\n\t\tconvert_to_long_ex(tmpzval);\n\t\tredirect_max = Z_LVAL_PP(tmpzval);\n\t}\n\n\tif (context && php_stream_context_get_option(context, \"http\", \"method\", &tmpzval) == SUCCESS) {\n\t\tif (Z_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval) > 0) {\n\t\t\t/* As per the RFC, automatically redirected requests MUST NOT use other methods than\n\t\t\t * GET and HEAD unless it can be confirmed by the user */\n\t\t\tif (!redirected\n\t\t\t\t|| (Z_STRLEN_PP(tmpzval) == 3 && memcmp(\"GET\", Z_STRVAL_PP(tmpzval), 3) == 0)\n\t\t\t\t|| (Z_STRLEN_PP(tmpzval) == 4 && memcmp(\"HEAD\",Z_STRVAL_PP(tmpzval), 4) == 0)\n\t\t\t) {\n\t\t\t\tscratch_len = strlen(path) + 29 + Z_STRLEN_PP(tmpzval);\n\t\t\t\tscratch = emalloc(scratch_len);\n\t\t\t\tstrlcpy(scratch, Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval) + 1);\n\t\t\t\tstrncat(scratch, \" \", 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (context && php_stream_context_get_option(context, \"http\", \"protocol_version\", &tmpzval) == SUCCESS) {\n\t\tSEPARATE_ZVAL(tmpzval);\n\t\tconvert_to_double_ex(tmpzval);\n\t\tprotocol_version_len = spprintf(&protocol_version, 0, \"%.1F\", Z_DVAL_PP(tmpzval));\n\t}\n\n\tif (!scratch) {\n\t\tscratch_len = strlen(path) + 29 + protocol_version_len;\n\t\tscratch = emalloc(scratch_len);\n\t\tstrncpy(scratch, \"GET \", scratch_len);\n\t}\n\n\t/* Should we send the entire path in the request line, default to no. */\n\tif (!request_fulluri &&\n\t\tcontext &&\n\t\tphp_stream_context_get_option(context, \"http\", \"request_fulluri\", &tmpzval) == SUCCESS) {\n\t\tzval ztmp = **tmpzval;\n\n\t\tzval_copy_ctor(&ztmp);\n\t\tconvert_to_boolean(&ztmp);\n\t\trequest_fulluri = Z_BVAL(ztmp) ? 1 : 0;\n\t\tzval_dtor(&ztmp);\n\t}\n\n\tif (request_fulluri) {\n\t\t/* Ask for everything */\n\t\tstrcat(scratch, path);\n\t} else {\n\t\t/* Send the traditional /path/to/file?query_string */\n\n\t\t/* file */\n\t\tif (resource->path && *resource->path) {\n\t\t\tstrlcat(scratch, resource->path, scratch_len);\n\t\t} else {\n\t\t\tstrlcat(scratch, \"/\", scratch_len);\n\t\t}\n\n\t\t/* query string */\n\t\tif (resource->query) {\n\t\t\tstrlcat(scratch, \"?\", scratch_len);\n\t\t\tstrlcat(scratch, resource->query, scratch_len);\n\t\t}\n\t}\n\n\t/* protocol version we are speaking */\n\tif (protocol_version) {\n\t\tstrlcat(scratch, \" HTTP/\", scratch_len);\n\t\tstrlcat(scratch, protocol_version, scratch_len);\n\t\tstrlcat(scratch, \"\\r\\n\", scratch_len);\n\t} else {\n\t\tstrlcat(scratch, \" HTTP/1.0\\r\\n\", scratch_len);\n\t}\n\n\t/* send it */\n\tphp_stream_write(stream, scratch, strlen(scratch));\n\n\tif (context && php_stream_context_get_option(context, \"http\", \"header\", &tmpzval) == SUCCESS) {\n\t\ttmp = NULL;\n\n\t\tif (Z_TYPE_PP(tmpzval) == IS_ARRAY) {\n\t\t\tHashPosition pos;\n\t\t\tzval **tmpheader = NULL;\n\t\t\tsmart_str tmpstr = {0};\n\n\t\t\tfor (zend_hash_internal_pointer_reset_ex(Z_ARRVAL_PP(tmpzval), &pos);\n\t\t\t\tSUCCESS == zend_hash_get_current_data_ex(Z_ARRVAL_PP(tmpzval), (void *)&tmpheader, &pos);\n\t\t\t\tzend_hash_move_forward_ex(Z_ARRVAL_PP(tmpzval), &pos)\n\t\t\t) {\n\t\t\t\tif (Z_TYPE_PP(tmpheader) == IS_STRING) {\n\t\t\t\t\tsmart_str_appendl(&tmpstr, Z_STRVAL_PP(tmpheader), Z_STRLEN_PP(tmpheader));\n\t\t\t\t\tsmart_str_appendl(&tmpstr, \"\\r\\n\", sizeof(\"\\r\\n\") - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsmart_str_0(&tmpstr);\n\t\t\t/* Remove newlines and spaces from start and end. there's at least one extra \\r\\n at the end that needs to go. */\n\t\t\tif (tmpstr.c) {\n\t\t\t\ttmp = php_trim(tmpstr.c, strlen(tmpstr.c), NULL, 0, NULL, 3 TSRMLS_CC);\n\t\t\t\tsmart_str_free(&tmpstr);\n\t\t\t}\n\t\t}\n\t\tif (Z_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval)) {\n\t\t\t/* Remove newlines and spaces from start and end php_trim will estrndup() */\n\t\t\ttmp = php_trim(Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval), NULL, 0, NULL, 3 TSRMLS_CC);\n\t\t}\n\t\tif (tmp && strlen(tmp) > 0) {\n\t\t\tchar *s;\n\n\t\t\tuser_headers = estrdup(tmp);\n\n\t\t\t/* Make lowercase for easy comparison against 'standard' headers */\n\t\t\tphp_strtolower(tmp, strlen(tmp));\n\n\t\t\tif (!header_init) {\n\t\t\t\t/* strip POST headers on redirect */\n\t\t\t\tstrip_header(user_headers, tmp, \"content-length:\");\n\t\t\t\tstrip_header(user_headers, tmp, \"content-type:\");\n\t\t\t}\n\n\t\t\tif ((s = strstr(tmp, \"user-agent:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_USER_AGENT;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"host:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_HOST;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"from:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_FROM;\n\t\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"authorization:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_AUTH;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"content-length:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_CONTENT_LENGTH;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"content-type:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_TYPE;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"connection:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' || \n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_CONNECTION;\n\t\t\t}\n\t\t\t/* remove Proxy-Authorization header */\n\t\t\tif (use_proxy && use_ssl && (s = strstr(tmp, \"proxy-authorization:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\tchar *p = s + sizeof(\"proxy-authorization:\") - 1;\n\n\t\t\t\twhile (s > tmp && (*(s-1) == ' ' || *(s-1) == '\\t')) s--;\n\t\t\t\twhile (*p != 0 && *p != '\\r' && *p != '\\n') p++;\n\t\t\t\twhile (*p == '\\r' || *p == '\\n') p++;\n\t\t\t\tif (*p == 0) {\n\t\t\t\t\tif (s == tmp) {\n\t\t\t\t\t\tefree(user_headers);\n\t\t\t\t\t\tuser_headers = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile (s > tmp && (*(s-1) == '\\r' || *(s-1) == '\\n')) s--;\n\t\t\t\t\t\tuser_headers[s - tmp] = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmemmove(user_headers + (s - tmp), user_headers + (p - tmp), strlen(p) + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (tmp) {\n\t\t\tefree(tmp);\n\t\t}\n\t}\n\n\t/* auth header if it was specified */\n\tif (((have_header & HTTP_HEADER_AUTH) == 0) && resource->user) {\n\t\t/* decode the strings first */\n\t\tphp_url_decode(resource->user, strlen(resource->user));\n\n\t\t/* scratch is large enough, since it was made large enough for the whole URL */\n\t\tstrcpy(scratch, resource->user);\n\t\tstrcat(scratch, \":\");\n\n\t\t/* Note: password is optional! */\n\t\tif (resource->pass) {\n\t\t\tphp_url_decode(resource->pass, strlen(resource->pass));\n\t\t\tstrcat(scratch, resource->pass);\n\t\t}\n\n\t\ttmp = (char*)php_base64_encode((unsigned char*)scratch, strlen(scratch), NULL);\n\n\t\tif (snprintf(scratch, scratch_len, \"Authorization: Basic %s\\r\\n\", tmp) > 0) {\n\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_AUTH_REQUIRED, NULL, 0);\n\t\t}\n\n\t\tefree(tmp);\n\t\ttmp = NULL;\n\t}\n\n\t/* if the user has configured who they are, send a From: line */\n\tif (((have_header & HTTP_HEADER_FROM) == 0) && FG(from_address)) {\n\t\tif (snprintf(scratch, scratch_len, \"From: %s\\r\\n\", FG(from_address)) > 0)\n\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t}\n\n\t/* Send Host: header so name-based virtual hosts work */\n\tif ((have_header & HTTP_HEADER_HOST) == 0) {\n\t\tif ((use_ssl && resource->port != 443 && resource->port != 0) ||\n\t\t\t(!use_ssl && resource->port != 80 && resource->port != 0)) {\n\t\t\tif (snprintf(scratch, scratch_len, \"Host: %s:%i\\r\\n\", resource->host, resource->port) > 0)\n\t\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t} else {\n\t\t\tif (snprintf(scratch, scratch_len, \"Host: %s\\r\\n\", resource->host) > 0) {\n\t\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Send a Connection: close header to avoid hanging when the server\n\t * interprets the RFC literally and establishes a keep-alive connection,\n\t * unless the user specifically requests something else by specifying a\n\t * Connection header in the context options. Send that header even for\n\t * HTTP/1.0 to avoid issues when the server respond with a HTTP/1.1\n\t * keep-alive response, which is the preferred response type. */\n\tif ((have_header & HTTP_HEADER_CONNECTION) == 0) {\n\t\tphp_stream_write_string(stream, \"Connection: close\\r\\n\");\n\t}\n\n\tif (context &&\n\t    php_stream_context_get_option(context, \"http\", \"user_agent\", &ua_zval) == SUCCESS &&\n\t\tZ_TYPE_PP(ua_zval) == IS_STRING) {\n\t\tua_str = Z_STRVAL_PP(ua_zval);\n\t} else if (FG(user_agent)) {\n\t\tua_str = FG(user_agent);\n\t}\n\n\tif (((have_header & HTTP_HEADER_USER_AGENT) == 0) && ua_str) {\n#define _UA_HEADER \"User-Agent: %s\\r\\n\"\n\t\tchar *ua;\n\t\tsize_t ua_len;\n\n\t\tua_len = sizeof(_UA_HEADER) + strlen(ua_str);\n\n\t\t/* ensure the header is only sent if user_agent is not blank */\n\t\tif (ua_len > sizeof(_UA_HEADER)) {\n\t\t\tua = emalloc(ua_len + 1);\n\t\t\tif ((ua_len = slprintf(ua, ua_len, _UA_HEADER, ua_str)) > 0) {\n\t\t\t\tua[ua_len] = 0;\n\t\t\t\tphp_stream_write(stream, ua, ua_len);\n\t\t\t} else {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot construct User-agent header\");\n\t\t\t}\n\n\t\t\tif (ua) {\n\t\t\t\tefree(ua);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (user_headers) {\n\t\t/* A bit weird, but some servers require that Content-Length be sent prior to Content-Type for POST\n\t\t * see bug #44603 for details. Since Content-Type maybe part of user's headers we need to do this check first.\n\t\t */\n\t\tif (\n\t\t\t\theader_init &&\n\t\t\t\tcontext &&\n\t\t\t\t!(have_header & HTTP_HEADER_CONTENT_LENGTH) &&\n\t\t\t\tphp_stream_context_get_option(context, \"http\", \"content\", &tmpzval) == SUCCESS &&\n\t\t\t\tZ_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval) > 0\n\t\t) {\n\t\t\tscratch_len = slprintf(scratch, scratch_len, \"Content-Length: %d\\r\\n\", Z_STRLEN_PP(tmpzval));\n\t\t\tphp_stream_write(stream, scratch, scratch_len);\n\t\t\thave_header |= HTTP_HEADER_CONTENT_LENGTH;\n\t\t}\n\n\t\tphp_stream_write(stream, user_headers, strlen(user_headers));\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\tefree(user_headers);\n\t}\n\n\t/* Request content, such as for POST requests */\n\tif (header_init && context &&\n\t\tphp_stream_context_get_option(context, \"http\", \"content\", &tmpzval) == SUCCESS &&\n\t\tZ_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval) > 0) {\n\t\tif (!(have_header & HTTP_HEADER_CONTENT_LENGTH)) {\n\t\t\tscratch_len = slprintf(scratch, scratch_len, \"Content-Length: %d\\r\\n\", Z_STRLEN_PP(tmpzval));\n\t\t\tphp_stream_write(stream, scratch, scratch_len);\n\t\t}\n\t\tif (!(have_header & HTTP_HEADER_TYPE)) {\n\t\t\tphp_stream_write(stream, \"Content-Type: application/x-www-form-urlencoded\\r\\n\",\n\t\t\t\tsizeof(\"Content-Type: application/x-www-form-urlencoded\\r\\n\") - 1);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Content-type not specified assuming application/x-www-form-urlencoded\");\n\t\t}\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\tphp_stream_write(stream, Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval));\n\t} else {\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t}\n\n\tlocation[0] = '\\0';\n\n\tif (!EG(active_symbol_table)) {\n\t\tzend_rebuild_symbol_table(TSRMLS_C);\n\t}\n\n\tif (header_init) {\n\t\tzval *ztmp;\n\t\tMAKE_STD_ZVAL(ztmp);\n\t\tarray_init(ztmp);\n\t\tZEND_SET_SYMBOL(EG(active_symbol_table), \"http_response_header\", ztmp);\n\t}\n\n\t{\n\t\tzval **rh;\n\t\tif(zend_hash_find(EG(active_symbol_table), \"http_response_header\", sizeof(\"http_response_header\"), (void **) &rh) != SUCCESS || Z_TYPE_PP(rh) != IS_ARRAY) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP request failed, http_response_header overwritten\");\n\t\t\tgoto out;\n\t\t}\n\t\tresponse_header = *rh;\n\t\tZ_ADDREF_P(response_header);\n\t}\n\n\tif (!php_stream_eof(stream)) {\n\t\tsize_t tmp_line_len;\n\t\t/* get response header */\n\n\t\tif (php_stream_get_line(stream, tmp_line, sizeof(tmp_line) - 1, &tmp_line_len) != NULL) {\n\t\t\tzval *http_response;\n\n\t\t\tif (tmp_line_len > 9) {\n\t\t\t\tresponse_code = atoi(tmp_line + 9);\n\t\t\t} else {\n\t\t\t\tresponse_code = 0;\n\t\t\t}\n\t\t\tif (context && SUCCESS==php_stream_context_get_option(context, \"http\", \"ignore_errors\", &tmpzval)) {\n\t\t\t\tignore_errors = zend_is_true(*tmpzval);\n\t\t\t}\n\t\t\t/* when we request only the header, don't fail even on error codes */\n\t\t\tif ((options & STREAM_ONLY_GET_HEADERS) || ignore_errors) {\n\t\t\t\treqok = 1;\n\t\t\t}\n\n\t\t\t/* status codes of 1xx are \"informational\", and will be followed by a real response\n\t\t\t * e.g \"100 Continue\". RFC 7231 states that unexpected 1xx status MUST be parsed,\n\t\t\t * and MAY be ignored. As such, we need to skip ahead to the \"real\" status*/\n\t\t\tif (response_code >= 100 && response_code < 200) {\n\t\t\t\t/* consume lines until we find a line starting 'HTTP/1' */\n\t\t\t\twhile (\n\t\t\t\t\t!php_stream_eof(stream)\n\t\t\t\t\t&& php_stream_get_line(stream, tmp_line, sizeof(tmp_line) - 1, &tmp_line_len) != NULL\n\t\t\t\t\t&& ( tmp_line_len < sizeof(\"HTTP/1\") - 1 || strncasecmp(tmp_line, \"HTTP/1\", sizeof(\"HTTP/1\") - 1) )\n\t\t\t\t);\n\n\t\t\t\tif (tmp_line_len > 9) {\n\t\t\t\t\tresponse_code = atoi(tmp_line + 9);\n\t\t\t\t} else {\n\t\t\t\t\tresponse_code = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* all status codes in the 2xx range are defined by the specification as successful;\n\t\t\t * all status codes in the 3xx range are for redirection, and so also should never\n\t\t\t * fail */\n\t\t\tif (response_code >= 200 && response_code < 400) {\n\t\t\t\treqok = 1;\n\t\t\t} else {\n\t\t\t\tswitch(response_code) {\n\t\t\t\t\tcase 403:\n\t\t\t\t\t\tphp_stream_notify_error(context, PHP_STREAM_NOTIFY_AUTH_RESULT,\n\t\t\t\t\t\t\t\ttmp_line, response_code);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* safety net in the event tmp_line == NULL */\n\t\t\t\t\t\tif (!tmp_line_len) {\n\t\t\t\t\t\t\ttmp_line[0] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tphp_stream_notify_error(context, PHP_STREAM_NOTIFY_FAILURE,\n\t\t\t\t\t\t\t\ttmp_line, response_code);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmp_line[tmp_line_len - 1] == '\\n') {\n\t\t\t\t--tmp_line_len;\n\t\t\t\tif (tmp_line[tmp_line_len - 1] == '\\r') {\n\t\t\t\t\t--tmp_line_len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tMAKE_STD_ZVAL(http_response);\n\t\t\tZVAL_STRINGL(http_response, tmp_line, tmp_line_len, 1);\n\t\t\tzend_hash_next_index_insert(Z_ARRVAL_P(response_header), &http_response, sizeof(zval *), NULL);\n\t\t}\n\t} else {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP request failed, unexpected end of socket!\");\n\t\tgoto out;\n\t}\n\n\t/* read past HTTP headers */\n\n\thttp_header_line = emalloc(HTTP_HEADER_BLOCK_SIZE);\n\n\twhile (!body && !php_stream_eof(stream)) {\n\t\tsize_t http_header_line_length;\n\t\tif (php_stream_get_line(stream, http_header_line, HTTP_HEADER_BLOCK_SIZE, &http_header_line_length) && *http_header_line != '\\n' && *http_header_line != '\\r') {\n\t\t\tchar *e = http_header_line + http_header_line_length - 1;\n\t\t\tif (*e != '\\n') {\n\t\t\t\tdo { /* partial header */\n\t\t\t\t\tif (php_stream_get_line(stream, http_header_line, HTTP_HEADER_BLOCK_SIZE, &http_header_line_length) == NULL) {\n\t\t\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Failed to read HTTP headers\");\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\te = http_header_line + http_header_line_length - 1;\n\t\t\t\t} while (*e != '\\n');\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (*e == '\\n' || *e == '\\r') {\n\t\t\t\te--;\n\t\t\t}\n\t\t\thttp_header_line_length = e - http_header_line + 1;\n\t\t\thttp_header_line[http_header_line_length] = '\\0';\n\n\t\t\tif (!strncasecmp(http_header_line, \"Location: \", 10)) {\n\t\t\t\tif (context && php_stream_context_get_option(context, \"http\", \"follow_location\", &tmpzval) == SUCCESS) {\n\t\t\t\t\tSEPARATE_ZVAL(tmpzval);\n\t\t\t\t\tconvert_to_long_ex(tmpzval);\n\t\t\t\t\tfollow_location = Z_LVAL_PP(tmpzval);\n\t\t\t\t} else if (!(response_code >= 300 && response_code < 304 || 307 == response_code || 308 == response_code)) {\n\t\t\t\t\t/* we shouldn't redirect automatically\n\t\t\t\t\tif follow_location isn't set and response_code not in (300, 301, 302, 303 and 307)\n\t\t\t\t\tsee http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.1\n\t\t\t\t\tRFC 7238 defines 308: http://tools.ietf.org/html/rfc7238 */\n\t\t\t\t\tfollow_location = 0;\n\t\t\t\t}\n\t\t\t\tstrlcpy(location, http_header_line + 10, sizeof(location));\n\t\t\t} else if (!strncasecmp(http_header_line, \"Content-Type: \", 14)) {\n\t\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_MIME_TYPE_IS, http_header_line + 14, 0);\n\t\t\t} else if (!strncasecmp(http_header_line, \"Content-Length: \", 16)) {\n\t\t\t\tfile_size = atoi(http_header_line + 16);\n\t\t\t\tphp_stream_notify_file_size(context, file_size, http_header_line, 0);\n\t\t\t} else if (!strncasecmp(http_header_line, \"Transfer-Encoding: chunked\", sizeof(\"Transfer-Encoding: chunked\"))) {\n\n\t\t\t\t/* create filter to decode response body */\n\t\t\t\tif (!(options & STREAM_ONLY_GET_HEADERS)) {\n\t\t\t\t\tlong decode = 1;\n\n\t\t\t\t\tif (context && php_stream_context_get_option(context, \"http\", \"auto_decode\", &tmpzval) == SUCCESS) {\n\t\t\t\t\t\tSEPARATE_ZVAL(tmpzval);\n\t\t\t\t\t\tconvert_to_boolean(*tmpzval);\n\t\t\t\t\t\tdecode = Z_LVAL_PP(tmpzval);\n\t\t\t\t\t}\n\t\t\t\t\tif (decode) {\n\t\t\t\t\t\ttransfer_encoding = php_stream_filter_create(\"dechunk\", NULL, php_stream_is_persistent(stream) TSRMLS_CC);\n\t\t\t\t\t\tif (transfer_encoding) {\n\t\t\t\t\t\t\t/* don't store transfer-encodeing header */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (http_header_line[0] == '\\0') {\n\t\t\t\tbody = 1;\n\t\t\t} else {\n\t\t\t\tzval *http_header;\n\n\t\t\t\tMAKE_STD_ZVAL(http_header);\n\n\t\t\t\tZVAL_STRINGL(http_header, http_header_line, http_header_line_length, 1);\n\n\t\t\t\tzend_hash_next_index_insert(Z_ARRVAL_P(response_header), &http_header, sizeof(zval *), NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!reqok || (location[0] != '\\0' && follow_location)) {\n\t\tif (!follow_location || (((options & STREAM_ONLY_GET_HEADERS) || ignore_errors) && redirect_max <= 1)) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (location[0] != '\\0')\n\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_REDIRECTED, location, 0);\n\n\t\tphp_stream_close(stream);\n\t\tstream = NULL;\n\n\t\tif (location[0] != '\\0') {\n\n\t\t\tchar new_path[HTTP_HEADER_BLOCK_SIZE];\n\t\t\tchar loc_path[HTTP_HEADER_BLOCK_SIZE];\n\n\t\t\t*new_path='\\0';\n\t\t\tif (strlen(location)<8 || (strncasecmp(location, \"http://\", sizeof(\"http://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"https://\", sizeof(\"https://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"ftp://\", sizeof(\"ftp://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"ftps://\", sizeof(\"ftps://\")-1)))\n\t\t\t{\n\t\t\t\tif (*location != '/') {\n\t\t\t\t\tif (*(location+1) != '\\0' && resource->path) {\n\t\t\t\t\t\tchar *s = strrchr(resource->path, '/');\n\t\t\t\t\t\tif (!s) {\n\t\t\t\t\t\t\ts = resource->path;\n\t\t\t\t\t\t\tif (!s[0]) {\n\t\t\t\t\t\t\t\tefree(s);\n\t\t\t\t\t\t\t\ts = resource->path = estrdup(\"/\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t*s = '/';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts[1] = '\\0';\n\t\t\t\t\t\tif (resource->path && *(resource->path) == '/' && *(resource->path + 1) == '\\0') {\n\t\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"%s%s\", resource->path, location);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"%s/%s\", resource->path, location);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"/%s\", location);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstrlcpy(loc_path, location, sizeof(loc_path));\n\t\t\t\t}\n\t\t\t\tif ((use_ssl && resource->port != 443) || (!use_ssl && resource->port != 80)) {\n\t\t\t\t\tsnprintf(new_path, sizeof(new_path) - 1, \"%s://%s:%d%s\", resource->scheme, resource->host, resource->port, loc_path);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(new_path, sizeof(new_path) - 1, \"%s://%s%s\", resource->scheme, resource->host, loc_path);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstrlcpy(new_path, location, sizeof(new_path));\n\t\t\t}\n\n\t\t\tphp_url_free(resource);\n\t\t\t/* check for invalid redirection URLs */\n\t\t\tif ((resource = php_url_parse(new_path)) == NULL) {\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Invalid redirect URL! %s\", new_path);\n\t\t\t\tgoto out;\n\t\t\t}\n\n#define CHECK_FOR_CNTRL_CHARS(val) { \\\n\tif (val) { \\\n\t\tunsigned char *s, *e; \\\n\t\tint l; \\\n\t\tl = php_url_decode(val, strlen(val)); \\\n\t\ts = (unsigned char*)val; e = s + l; \\\n\t\twhile (s < e) { \\\n\t\t\tif (iscntrl(*s)) { \\\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Invalid redirect URL! %s\", new_path); \\\n\t\t\t\tgoto out; \\\n\t\t\t} \\\n\t\t\ts++; \\\n\t\t} \\\n\t} \\\n}\n\t\t\t/* check for control characters in login, password & path */\n\t\t\tif (strncasecmp(new_path, \"http://\", sizeof(\"http://\") - 1) || strncasecmp(new_path, \"https://\", sizeof(\"https://\") - 1)) {\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->user)\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->pass)\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->path)\n\t\t\t}\n\t\t\tstream = php_stream_url_wrap_http_ex(wrapper, new_path, mode, options, opened_path, context, --redirect_max, HTTP_WRAPPER_REDIRECTED STREAMS_CC TSRMLS_CC);\n\t\t} else {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP request failed! %s\", tmp_line);\n\t\t}\n\t}\nout:\n\tif (protocol_version) {\n\t\tefree(protocol_version);\n\t}\n\n\tif (http_header_line) {\n\t\tefree(http_header_line);\n\t}\n\n\tif (scratch) {\n\t\tefree(scratch);\n\t}\n\n\tif (resource) {\n\t\tphp_url_free(resource);\n\t}\n\n\tif (stream) {\n\t\tif (header_init) {\n\t\t\tstream->wrapperdata = response_header;\n\t\t} else {\n\t\t\tif(response_header) {\n\t\t\t\tZ_DELREF_P(response_header);\n\t\t\t}\n\t\t}\n\t\tphp_stream_notify_progress_init(context, 0, file_size);\n\n\t\t/* Restore original chunk size now that we're done with headers */\n\t\tif (options & STREAM_WILL_CAST)\n\t\t\tphp_stream_set_chunk_size(stream, chunk_size);\n\n\t\t/* restore the users auto-detect-line-endings setting */\n\t\tstream->flags |= eol_detect;\n\n\t\t/* as far as streams are concerned, we are now at the start of\n\t\t * the stream */\n\t\tstream->position = 0;\n\n\t\t/* restore mode */\n\t\tstrlcpy(stream->mode, mode, sizeof(stream->mode));\n\n\t\tif (transfer_encoding) {\n\t\t\tphp_stream_filter_append(&stream->readfilters, transfer_encoding);\n\t\t}\n\t} else {\n\t\tif(response_header) {\n\t\t\tZ_DELREF_P(response_header);\n\t\t}\n\t\tif (transfer_encoding) {\n\t\t\tphp_stream_filter_free(transfer_encoding TSRMLS_CC);\n\t\t}\n\t}\n\n\treturn stream;\n}\n",
        "fix": null,
        "src_path": "523f230c831d7b33353203fa34aee4e92ac12bba___http_fopen_wrapper.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/523f230c831d7b33353203fa34aee4e92ac12bba",
        "commit_msg": "Fix bug #75981: prevent reading beyond buffer start",
        "test_func_diff": [
            {
                "fn": "ext/standard/tests/http/bug75981.phpt",
                "patch": "@@ -0,0 +1,32 @@\n+--TEST--\n+Bug #75981 (stack-buffer-overflow while parsing HTTP response)\n+--INI--\n+allow_url_fopen=1\n+--SKIPIF--\n+<?php require 'server.inc'; http_server_skipif('tcp://127.0.0.1:12342'); ?>\n+--FILE--\n+<?php\n+require 'server.inc';\n+\n+$options = [\n+  'http' => [\n+    'protocol_version' => '1.1',\n+    'header' => 'Connection: Close'\n+  ],\n+];\n+\n+$ctx = stream_context_create($options);\n+\n+$responses = [\n+\t\"data://text/plain,000000000100\\xA\\xA\"\n+];\n+$pid = http_server('tcp://127.0.0.1:12342', $responses);\n+\n+echo @file_get_contents('http://127.0.0.1:12342/', false, $ctx);\n+\n+http_server_kill($pid);\n+\n+?>\n+DONE\n+--EXPECT--\n+DONE"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.34-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_523f230c831d7b33353203fa34aee4e92ac12bba More .INIs : CWD : /out/php___php-src/git_repo_dir_523f230c831d7b33353203fa34aee4e92ac12bba Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/standard/tests/http/bug75981.phpt]\r \r===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 0 ( 0.0%) ( 0.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 1 (100.0%) (100.0%) --------------------------------------------------------------------- Time taken : 0 seconds =====================================================================\n"
    },
    "0f2d7e784a256b54b2385043438848047bc2a629___idna.c": {
        "start": 318,
        "end": 363,
        "buggy": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* \u3002 */\n        if (c != 0xFF0E)  /* \uff0e */\n          if (c != 0xFF61)  /* \uff61 */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d < de)\n    *d++ = '\\0';\n\n  return d - ds;  /* Number of bytes written. */\n}\n",
        "fix": null,
        "src_path": "0f2d7e784a256b54b2385043438848047bc2a629___idna.c",
        "uri": "https://api.github.com/repos/libuv/libuv/commits/0f2d7e784a256b54b2385043438848047bc2a629",
        "commit_msg": "fix: always zero-terminate idna output\n\nFixes: https://github.com/libuv/libuv/security/advisories/GHSA-f74f-cvh7-c6q6",
        "test_func_diff": [
            {
                "fn": "test/test-idna.c",
                "patch": "@@ -100,6 +100,7 @@ TEST_IMPL(utf8_decode1) {\n TEST_IMPL(utf8_decode1_overrun) {\n   const char* p;\n   char b[1];\n+  char c[1];\n \n   /* Single byte. */\n   p = b;\n@@ -113,6 +114,9 @@ TEST_IMPL(utf8_decode1_overrun) {\n   ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + 1));\n   ASSERT_PTR_EQ(p, b + 1);\n \n+  b[0] = 0x7F;\n+  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 1, c, c + 1));\n+\n   return 0;\n }\n "
            }
        ],
        "error_msg": "not ok 35 - fork_fs_events_child\n# exit code 134\n# Output from process `fork_fs_events_child`:\n# Assertion failed in test/test-fork.c on line 426: `r >= 0` (-13 >= 0)\nnot ok 36 - fork_fs_events_child_dir\n# exit code 134\n# Output from process `fork_fs_events_child_dir`:\n# Assertion failed in test/test-fork.c on line 426: `r >= 0` (-13 >= 0)\nnot ok 37 - fork_fs_events_file_parent_child\n# exit code 134\n# Output from process `fork_fs_events_file_parent_child`:\n# Assertion failed in test/test-fork.c on line 426: `r >= 0` (-13 >= 0)\nok 38 - fork_signal_to_child\nnot ok 44 - fs_access\n# exit code 134\n# Output from process `fs_access`:\n# Assertion failed in test/test-fs.c on line 1631: `r >= 0` (-13 >= 0)\nnot ok 45 - fs_async_dir\n# exit code 134\n# Output from process `fs_async_dir`:\n# Assertion failed in test/test-fs.c on line 511: `req->result == 0` (-13 == 0)\nnot ok 46 - fs_async_sendfile\n# exit code 134\n# Output from process `fs_async_sendfile`:\n# Assertion failed in test/test-fs.c on line 1218: `f != -1` (-1 != -1)\nnot ok 47 - fs_async_sendfile_nodata\n# exit code 134\n# Output from process `fs_async_sendfile_nodata`:\n# Assertion failed in test/test-fs.c on line 1218: `f != -1` (-1 != -1)\nnot ok 48 - fs_chmod\n# exit code 134\n# Output from process `fs_chmod`:\n# Assertion failed in test/test-fs.c on line 1692: `r >= 0` (-13 >= 0)\nnot ok 49 - fs_chown\n# exit code 134\n# Output from process `fs_chown`:\n# Assertion failed in test/test-fs.c on line 1904: `r >= 0` (-13 >= 0)\nnot ok 50 - fs_copyfile\n# exit code 134\n# Output from process `fs_copyfile`:\n# Assertion failed in test/test-fs-copyfile.c on line 81: `r >= 0` (-13 >= 0)\nnot ok 51 - fs_event_close_in_callback\n# exit code 134\n# Output from process `fs_event_close_in_callback`:\n# Assertion failed in test/test-fs-event.c on line 74: r == 0 || r == UV_EEXIST\nnot ok 52 - fs_event_close_with_pending_delete_event\n# exit code 134\n# Output from process `fs_event_close_with_pending_delete_event`:\n# Assertion failed in test/test-fs-event.c on line 74: r == 0 || r == UV_EEXIST\nnot o"
    },
    "39e8fa1b7db1680654527f8fa0e9ee93b334ecba___njs_function.c": {
        "start": 1366,
        "end": 1441,
        "buggy": "static njs_int_t\nnjs_function_prototype_apply(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t         i, length;\n    njs_int_t       ret;\n    njs_frame_t     *frame;\n    njs_value_t     *this, *arr_like;\n    njs_array_t     *arr;\n    njs_function_t  *func;\n\n    if (!njs_is_function(njs_argument(args, 0))) {\n        njs_type_error(vm, \"\\\"this\\\" argument is not a function\");\n        return NJS_ERROR;\n    }\n\n    func = njs_function(njs_argument(args, 0));\n    this = njs_arg(args, nargs, 1);\n    arr_like = njs_arg(args, nargs, 2);\n\n    if (njs_is_null_or_undefined(arr_like)) {\n        length = 0;\n\n        goto activate;\n\n    } else if (njs_is_array(arr_like)) {\n        arr = arr_like->data.u.array;\n\n        args = arr->start;\n        length = arr->length;\n\n        goto activate;\n\n    } else if (njs_slow_path(!njs_is_object(arr_like))) {\n        njs_type_error(vm, \"second argument is not an array-like object\");\n        return NJS_ERROR;\n    }\n\n    ret = njs_object_length(vm, arr_like, &length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    arr = njs_array_alloc(vm, 1, length, NJS_ARRAY_SPARE);\n    if (njs_slow_path(arr == NULL)) {\n        return NJS_ERROR;\n    }\n\n    args = arr->start;\n\n    for (i = 0; i < length; i++) {\n        ret = njs_value_property_i64(vm, arr_like, i, &args[i]);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return ret;\n        }\n    }\n\nactivate:\n\n    /* Skip the \"apply\" method frame. */\n    vm->top_frame->skip = 1;\n\n    frame = (njs_frame_t *) vm->top_frame;\n\n    ret = njs_function_frame(vm, func, this, args, length, 0);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_function_frame_invoke(vm, frame->native.retval);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    return NJS_DECLINED;\n}\n",
        "fix": null,
        "src_path": "39e8fa1b7db1680654527f8fa0e9ee93b334ecba___njs_function.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/39e8fa1b7db1680654527f8fa0e9ee93b334ecba",
        "commit_msg": "Fixed Function.prototype.apply() with slow arrays.\n\nPreviously, the function had two issues:\n   * array->start was referenced without checking for fast array flag\n   * the created arguments list was not sanity-checked for its length,\n     which can be very large.\n\nThe fix is to remove micro-optimization for arrays and introduce limit\nsize for arguments list.\n\nThis closes #449 issue in Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -10063,6 +10063,10 @@ static njs_unit_test_t  njs_test[] =\n                  \"f.apply(123, {})\"),\n       njs_str(\"123\") },\n \n+    { njs_str(\"(function(index, ...rest){ return rest[index];})\"\n+              \".apply({}, [1022].concat(Array(1023).fill(1).map((v,i)=>i.toString(16))))\"),\n+      njs_str(\"3fe\") },\n+\n     { njs_str(\"String.prototype.concat.apply('a', \"\n                  \"{length:2, 0:{toString:function() {return 'b'}}, 1:'c'})\"),\n       njs_str(\"abc\") },"
            }
        ],
        "error_msg": "script tests: PASSED [5112/5112]\nsafe script tests: PASSED [5/5]\ndenormals tests: PASSED [9/9]\ndisabled denormals tests: PASSED [7/7]\nwebcrypto tests: PASSED [1/1]\nmodule tests: PASSED [5/5]\nfs module tests: PASSED [54/54]\ncrypto module tests: PASSED [36/36]\nquerystring module tests: PASSED [75/75]\nbuffer module tests: PASSED [196/196]\nexternals tests: PASSED [93/93]\nasync handler tests: PASSED [2/2]\nshared tests: PASSED [30/30]\ninteractive tests: PASSED [26/26]\nbacktraces tests: PASSED [34/34]\ntimezone tests: PASSED [28/28]\nregexp optional tests: PASSED [13/13]\nvm_json tests: PASSED [6/6]\nvm_value tests: PASSED [8/8]\nvm_internal_api tests: PASSED [67/67]\nTOTAL: PASSED [5807/5807]\nscript tests: PASSED [5112/5112]\nsafe script tests: PASSED [5/5]\ndenormals tests: PASSED [9/9]\ndisabled denormals tests: PASSED [7/7]\nwebcrypto tests: PASSED [1/1]\nmodule tests: PASSED [5/5]\nfs module tests: PASSED [54/54]\ncrypto module tests: PASSED [36/36]\nquerystring module tests: PASSED [75/75]\nbuffer module tests: PASSED [196/196]\nexternals tests: PASSED [93/93]\nasync handler tests: PASSED [2/2]\nshared tests: PASSED [30/30]\ninteractive tests: PASSED [26/26]\nbacktraces tests: PASSED [34/34]\ntimezone tests: PASSED [28/28]\nregexp optional tests: PASSED [13/13]\nvm_json tests: PASSED [6/6]\nvm_value tests: PASSED [8/8]\nvm_internal_api tests: PASSED [67/67]\nTOTAL: PASSED [5807/5807]\nscript tests: PASSED [5112/5112]\nsafe script tests: PASSED [5/5]\ndenormals tests: PASSED [9/9]\ndisabled denormals tests: PASSED [7/7]\nwebcrypto tests: PASSED [1/1]\nmodule tests: PASSED [5/5]\nfs module tests: PASSED [54/54]\ncrypto module tests: PASSED [36/36]\nquerystring module tests: PASSED [75/75]\nbuffer module tests: PASSED [196/196]\nexternals tests: PASSED [93/93]\nasync handler tests: PASSED [2/2]\nshared tests: PASSED [30/30]\ninteractive tests: PASSED [26/26]\nbacktraces tests: PASSED [34/34]\ntimezone tests: PASSED [28/28]\nregexp optional tests: PASSED [13/13]\nvm_json tests: PASSED [6/6]\nvm_value tests: PASSED [8/8]\nvm_internal_api tests: PASSED [67/67]\nTOT"
    },
    "ad48705bf1f04b4221a5f5b07715ac48b3160d53___njs_function.c": {
        "start": 805,
        "end": 939,
        "buggy": "njs_int_t\nnjs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n\n    native = &frame->native;\n\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n\n    function = active->function;\n\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n\n\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n\n    /* Move all arguments. */\n\n    p = native->arguments;\n    local = native->local + function->args_offset;\n\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n\n        *local++ = p++;\n    }\n\n    return NJS_OK;\n}\n\n\nnjs_object_type_t\nnjs_function_object_type(njs_vm_t *vm, njs_function_t *function)\n{\n    if (function->object.shared_hash.slot\n        == vm->shared->async_function_instance_hash.slot)\n    {\n        return NJS_OBJ_TYPE_ASYNC_FUNCTION;\n    }\n\n    return NJS_OBJ_TYPE_FUNCTION;\n}\n\n\nnjs_int_t\nnjs_function_capture_closure(njs_vm_t *vm, njs_function_t *function,\n    njs_function_lambda_t *lambda)\n{\n    void                *start, *end;\n    uint32_t            n;\n    njs_value_t         *value, **closure;\n    njs_native_frame_t  *frame;\n\n    if (lambda->nclosures == 0) {\n        return NJS_OK;\n    }\n\n    frame = &vm->active_frame->native;\n\n    while (frame->native) {\n        frame = frame->previous;\n    }\n\n    start = frame;\n    end = frame->free;\n\n    closure = njs_function_closures(function);\n    n = lambda->nclosures;\n\n    do {\n        n--;\n\n        value = njs_scope_value(vm, lambda->closures[n]);\n\n        if (start <= (void *) value && (void *) value < end) {\n            value = njs_scope_value_clone(vm, lambda->closures[n], value);\n            if (njs_slow_path(value == NULL)) {\n                return NJS_ERROR;\n            }\n        }\n\n        closure[n] = value;\n\n    } while (n != 0);\n\n    return NJS_OK;\n}\n\n\nnjs_inline njs_value_t *\nnjs_function_closure_value(njs_vm_t *vm, njs_value_t **scope, njs_index_t index,\n    void *start, void *end)\n{\n    njs_value_t  *value, *newval;\n\n    value = scope[njs_scope_index_value(index)];\n\n    if (start <= (void *) value && end > (void *) value) {\n        newval = njs_mp_alloc(vm->mem_pool, sizeof(njs_value_t));\n        if (njs_slow_path(newval == NULL)) {\n            njs_memory_error(vm);\n            return NULL;\n        }\n\n        *newval = *value;\n        value = newval;\n    }\n\n    scope[njs_scope_index_value(index)] = value;\n\n    return value;\n}\n",
        "fix": null,
        "src_path": "ad48705bf1f04b4221a5f5b07715ac48b3160d53___njs_function.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/ad48705bf1f04b4221a5f5b07715ac48b3160d53",
        "commit_msg": "Fixed frame allocation from an awaited frame.\n\nnjs_function_frame_save() is used to save the awaited frame when \"await\"\ninstruction is encountered. The saving was done as a memcpy() of\nexisting runtime frame.\n\nnjs_function_frame_alloc() is used to alloc a new function frame, this\nfunction tries to use a spare preallocated memory from the previous\nframe first.  Previously, this function might result in \"use-after-free\"\nwhen invoked from a restored frame saved with njs_function_frame_save().\nBecause njs_function_frame_save() left pointers to the spare memory of\nthe original frame which may be already free when saved frame is\nrestored.\n\nThe fix is to erase fields for the spare memory from the saved frame.\n\nThis closes #469 issue on Github.",
        "test_func_diff": [
            {
                "fn": "test/js/async_recursive_large.t.js",
                "patch": "@@ -0,0 +1,26 @@\n+/*---\n+includes: [compareArray.js]\n+flags: [async]\n+---*/\n+\n+let stages = [];\n+\n+async function f(v) {\n+    if (v == 1000) {\n+        return;\n+    }\n+\n+    stages.push(`f>${v}`);\n+\n+    await \"X\";\n+\n+    await f(v + 1);\n+\n+    stages.push(`f<${v}`);\n+}\n+\n+f(0)\n+.then(v => {\n+    assert.sameValue(stages.length, 2000);\n+})\n+.then($DONE, $DONE);"
            },
            {
                "fn": "test/js/async_recursive_mid.t.js",
                "patch": "@@ -6,7 +6,7 @@ flags: [async]\n let stages = [];\n \n async function f(v) {\n-    if (v == 3) {\n+    if (v == 1000) {\n         return;\n     }\n "
            }
        ],
        "error_msg": "Thrown:\nReferenceError: \"$DONE\" is not defined\n    at Promise.prototype.then (native)\n    at main (test/js/async_recursive_large.t.js:26)\n\nThrown:\nReferenceError: \"$DONE\" is not defined\n    at Promise.prototype.then (native)\n    at main (test/js/async_recursive_mid.t.js:26)\n\nThrown:\nReferenceError: \"$DONE\" is not defined\n    at Promise.prototype.then (native)\n    at main (test/js/async_recursive_large.t.js:26)\n\nThrown:\nReferenceError: \"$DONE\" is not defined\n    at Promise.prototype.then (native)\n    at main (test/js/async_recursive_mid.t.js:26)\n\nThrown:\nReferenceError: \"$DONE\" is not defined\n    at Promise.prototype.then (native)\n    at main (test/js/async_recursive_large.t.js:26)\n\nThrown:\nReferenceError: \"$DONE\" is not defined\n    at Promise.prototype.then (native)\n    at main (test/js/async_recursive_mid.t.js:26)\n\n"
    },
    "222d6fdcf0c6485ec8e175f3a7b70d650c234b4e___njs_vmcode.c": {
        "start": 87,
        "end": 1058,
        "buggy": "njs_int_t\nnjs_vmcode_interpreter(njs_vm_t *vm, u_char *pc, void *promise_cap,\n    void *async_ctx)\n{\n    u_char                       *catch;\n    double                       num, exponent;\n    int32_t                      i32;\n    uint32_t                     u32;\n    njs_str_t                    string;\n    njs_uint_t                   hint;\n    njs_bool_t                   valid, lambda_call;\n    njs_value_t                  *retval, *value1, *value2;\n    njs_value_t                  *src, *s1, *s2, dst;\n    njs_value_t                  *function, name;\n    njs_value_t                  numeric1, numeric2, primitive1, primitive2;\n    njs_frame_t                  *frame;\n    njs_jump_off_t               ret;\n    njs_vmcode_await_t           *await;\n    njs_native_frame_t           *previous, *native;\n    njs_property_next_t          *next;\n    njs_vmcode_import_t          *import;\n    njs_vmcode_finally_t         *finally;\n    njs_vmcode_generic_t         *vmcode;\n    njs_vmcode_variable_t        *var;\n    njs_vmcode_move_arg_t        *move_arg;\n    njs_vmcode_prop_get_t        *get;\n    njs_vmcode_prop_set_t        *set;\n    njs_vmcode_operation_t       op;\n    njs_vmcode_prop_next_t       *pnext;\n    njs_vmcode_test_jump_t       *test_jump;\n    njs_vmcode_equal_jump_t      *equal;\n    njs_vmcode_try_return_t      *try_return;\n    njs_vmcode_method_frame_t    *method_frame;\n    njs_vmcode_function_copy_t   *fcopy;\n    njs_vmcode_prop_accessor_t   *accessor;\n    njs_vmcode_try_trampoline_t  *try_trampoline;\n    njs_vmcode_function_frame_t  *function_frame;\n\n#ifdef NJS_OPCODE_DEBUG\n    njs_vmcode_debug(vm, pc, \"ENTER\");\n#endif\n\nnext:\n\n    for ( ;; ) {\n\n        vmcode = (njs_vmcode_generic_t *) pc;\n\n        /*\n         * The first operand is passed as is in value2 to\n         *   NJS_VMCODE_JUMP,\n         *   NJS_VMCODE_IF_TRUE_JUMP,\n         *   NJS_VMCODE_IF_FALSE_JUMP,\n         *   NJS_VMCODE_FUNCTION_FRAME,\n         *   NJS_VMCODE_FUNCTION_CALL,\n         *   NJS_VMCODE_RETURN,\n         *   NJS_VMCODE_TRY_START,\n         *   NJS_VMCODE_TRY_CONTINUE,\n         *   NJS_VMCODE_TRY_BREAK,\n         *   NJS_VMCODE_TRY_END,\n         *   NJS_VMCODE_CATCH,\n         *   NJS_VMCODE_THROW,\n         *   NJS_VMCODE_STOP.\n         */\n        value2 = (njs_value_t *) vmcode->operand1;\n        value1 = NULL;\n\n        switch (vmcode->code.operands) {\n\n        case NJS_VMCODE_3OPERANDS:\n            njs_vmcode_operand(vm, vmcode->operand3, value2);\n\n            /* Fall through. */\n\n        case NJS_VMCODE_2OPERANDS:\n            njs_vmcode_operand(vm, vmcode->operand2, value1);\n        }\n\n        op = vmcode->code.operation;\n\n        /*\n         * On success an operation returns size of the bytecode,\n         * a jump offset or zero after the call or return operations.\n         * Jumps can return a negative offset.  Compilers can generate\n         *    (ret < 0 && ret >= NJS_PREEMPT)\n         * as a single unsigned comparision.\n         */\n\n#ifdef NJS_OPCODE_DEBUG\n        njs_disassemble(pc, NULL, 1, NULL);\n#endif\n\n        if (op > NJS_VMCODE_NORET) {\n\n            if (op == NJS_VMCODE_MOVE) {\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n                *retval = *value1;\n\n                pc += sizeof(njs_vmcode_move_t);\n                goto next;\n            }\n\n            if (op == NJS_VMCODE_PROPERTY_GET) {\n                get = (njs_vmcode_prop_get_t *) pc;\n                njs_vmcode_operand(vm, get->value, retval);\n\n                ret = njs_value_property(vm, value1, value2, retval);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                pc += sizeof(njs_vmcode_prop_get_t);\n                goto next;\n            }\n\n            switch (op) {\n            case NJS_VMCODE_INCREMENT:\n            case NJS_VMCODE_POST_INCREMENT:\n            case NJS_VMCODE_DECREMENT:\n            case NJS_VMCODE_POST_DECREMENT:\n                if (njs_slow_path(!njs_is_numeric(value2))) {\n                    ret = njs_value_to_numeric(vm, value2, &numeric1);\n                    if (njs_slow_path(ret != NJS_OK)) {\n                        goto error;\n                    }\n\n                    num = njs_number(&numeric1);\n\n                } else {\n                    num = njs_number(value2);\n                }\n\n                njs_set_number(value1,\n                           num + (1 - 2 * ((op - NJS_VMCODE_INCREMENT) >> 1)));\n\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n\n                if (op & 1) {\n                    njs_set_number(retval, num);\n\n                } else {\n                    *retval = *value1;\n                }\n\n                pc += sizeof(njs_vmcode_3addr_t);\n                goto next;\n\n            case NJS_VMCODE_GLOBAL_GET:\n                get = (njs_vmcode_prop_get_t *) pc;\n                njs_vmcode_operand(vm, get->value, retval);\n\n                ret = njs_value_property(vm, value1, value2, retval);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                pc += sizeof(njs_vmcode_prop_get_t);\n\n                if (ret == NJS_OK) {\n                    pc += sizeof(njs_vmcode_error_t);\n                }\n\n                goto next;\n\n            /*\n             * njs_vmcode_try_return() saves a return value to use it later by\n             * njs_vmcode_finally(), and jumps to the nearest try_break block.\n             */\n            case NJS_VMCODE_TRY_RETURN:\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n                *retval = *value1;\n\n                try_return = (njs_vmcode_try_return_t *) pc;\n                pc += try_return->offset;\n                goto next;\n\n            case NJS_VMCODE_LESS:\n            case NJS_VMCODE_GREATER:\n            case NJS_VMCODE_LESS_OR_EQUAL:\n            case NJS_VMCODE_GREATER_OR_EQUAL:\n            case NJS_VMCODE_ADDITION:\n                if (njs_slow_path(!njs_is_primitive(value1))) {\n                    hint = (op == NJS_VMCODE_ADDITION) && njs_is_date(value1);\n                    ret = njs_value_to_primitive(vm, &primitive1, value1, hint);\n                    if (ret != NJS_OK) {\n                        goto error;\n                    }\n\n                    value1 = &primitive1;\n                }\n\n                if (njs_slow_path(!njs_is_primitive(value2))) {\n                    hint = (op == NJS_VMCODE_ADDITION) && njs_is_date(value2);\n                    ret = njs_value_to_primitive(vm, &primitive2, value2, hint);\n                    if (ret != NJS_OK) {\n                        goto error;\n                    }\n\n                    value2 = &primitive2;\n                }\n\n                if (njs_slow_path(njs_is_symbol(value1)\n                                  || njs_is_symbol(value2)))\n                {\n                    njs_symbol_conversion_failed(vm,\n                        (op == NJS_VMCODE_ADDITION) &&\n                        (njs_is_string(value1) || njs_is_string(value2)));\n\n                    goto error;\n                }\n\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n\n                if (op == NJS_VMCODE_ADDITION) {\n                    if (njs_fast_path(njs_is_numeric(value1)\n                                      && njs_is_numeric(value2)))\n                    {\n                        njs_set_number(retval, njs_number(value1)\n                                               + njs_number(value2));\n                        pc += sizeof(njs_vmcode_3addr_t);\n                        goto next;\n                    }\n\n                    if (njs_is_string(value1)) {\n                        s1 = value1;\n                        s2 = &dst;\n                        src = value2;\n\n                    } else {\n                        s1 = &dst;\n                        s2 = value2;\n                        src = value1;\n                    }\n\n                    ret = njs_primitive_value_to_string(vm, &dst, src);\n                    if (njs_slow_path(ret != NJS_OK)) {\n                        goto error;\n                    }\n\n                    ret = njs_string_concat(vm, s1, s2);\n                    if (njs_slow_path(ret == NJS_ERROR)) {\n                        goto error;\n                    }\n\n                    *retval = vm->retval;\n\n                    pc += ret;\n                    goto next;\n                }\n\n                if ((uint8_t) (op - NJS_VMCODE_GREATER) < 2) {\n                    /* NJS_VMCODE_GREATER, NJS_VMCODE_LESS_OR_EQUAL */\n                    src = value1;\n                    value1 = value2;\n                    value2 = src;\n                }\n\n                ret = njs_primitive_values_compare(vm, value1, value2);\n\n                if (op < NJS_VMCODE_LESS_OR_EQUAL) {\n                    ret = ret > 0;\n\n                } else {\n                    ret = ret == 0;\n                }\n\n                njs_set_boolean(retval, ret);\n\n                pc += sizeof(njs_vmcode_3addr_t);\n                goto next;\n\n            case NJS_VMCODE_EQUAL:\n            case NJS_VMCODE_NOT_EQUAL:\n                ret = njs_values_equal(vm, value1, value2);\n                if (njs_slow_path(ret < 0)) {\n                    goto error;\n                }\n\n                ret ^= op - NJS_VMCODE_EQUAL;\n\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n                njs_set_boolean(retval, ret);\n\n                pc += sizeof(njs_vmcode_3addr_t);\n                goto next;\n\n            case NJS_VMCODE_SUBSTRACTION:\n            case NJS_VMCODE_MULTIPLICATION:\n            case NJS_VMCODE_EXPONENTIATION:\n            case NJS_VMCODE_DIVISION:\n            case NJS_VMCODE_REMAINDER:\n            case NJS_VMCODE_BITWISE_AND:\n            case NJS_VMCODE_BITWISE_OR:\n            case NJS_VMCODE_BITWISE_XOR:\n            case NJS_VMCODE_LEFT_SHIFT:\n            case NJS_VMCODE_RIGHT_SHIFT:\n            case NJS_VMCODE_UNSIGNED_RIGHT_SHIFT:\n                if (njs_slow_path(!njs_is_numeric(value1))) {\n                    ret = njs_value_to_numeric(vm, value1, &numeric1);\n                    if (njs_slow_path(ret != NJS_OK)) {\n                        goto error;\n                    }\n\n                    value1 = &numeric1;\n                }\n\n                if (njs_slow_path(!njs_is_numeric(value2))) {\n                    ret = njs_value_to_numeric(vm, value2, &numeric2);\n                    if (njs_slow_path(ret != NJS_OK)) {\n                        goto error;\n                    }\n\n                    value2 = &numeric2;\n                }\n\n                num = njs_number(value1);\n\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n                pc += sizeof(njs_vmcode_3addr_t);\n\n                switch (op) {\n                case NJS_VMCODE_SUBSTRACTION:\n                    num -= njs_number(value2);\n                    break;\n\n                case NJS_VMCODE_MULTIPLICATION:\n                    num *= njs_number(value2);\n                    break;\n\n                case NJS_VMCODE_EXPONENTIATION:\n                    exponent = njs_number(value2);\n\n                    /*\n                     * According to ES7:\n                     *  1. If exponent is NaN, the result should be NaN;\n                     *  2. The result of +/-1 ** +/-Infinity should be NaN.\n                     */\n                    valid = njs_expect(1, fabs(num) != 1\n                                          || (!isnan(exponent)\n                                              && !isinf(exponent)));\n\n                    num = valid ? pow(num, exponent) : NAN;\n                    break;\n\n                case NJS_VMCODE_DIVISION:\n                    num /= njs_number(value2);\n                    break;\n\n                case NJS_VMCODE_REMAINDER:\n                    num = fmod(num, njs_number(value2));\n                    break;\n\n                case NJS_VMCODE_BITWISE_AND:\n                case NJS_VMCODE_BITWISE_OR:\n                case NJS_VMCODE_BITWISE_XOR:\n                    i32 = njs_number_to_int32(njs_number(value2));\n\n                    switch (op) {\n                    case NJS_VMCODE_BITWISE_AND:\n                        i32 &= njs_number_to_int32(num);\n                        break;\n\n                    case NJS_VMCODE_BITWISE_OR:\n                        i32 |= njs_number_to_int32(num);\n                        break;\n\n                    case NJS_VMCODE_BITWISE_XOR:\n                        i32 ^= njs_number_to_int32(num);\n                        break;\n                    }\n\n                    njs_set_int32(retval, i32);\n                    goto next;\n\n                default:\n                    u32 = njs_number_to_uint32(njs_number(value2)) & 0x1f;\n\n                    switch (op) {\n                    case NJS_VMCODE_LEFT_SHIFT:\n                    case NJS_VMCODE_RIGHT_SHIFT:\n                        i32 = njs_number_to_int32(num);\n\n                        if (op == NJS_VMCODE_LEFT_SHIFT) {\n                            /* Shifting of negative numbers is undefined. */\n                            i32 = (uint32_t) i32 << u32;\n                        } else {\n                            i32 >>= u32;\n                        }\n\n                        njs_set_int32(retval, i32);\n                        break;\n\n                    default: /* NJS_VMCODE_UNSIGNED_RIGHT_SHIFT */\n                        njs_set_uint32(retval,\n                                       njs_number_to_uint32(num) >> u32);\n                    }\n\n                    goto next;\n                }\n\n                njs_set_number(retval, num);\n                goto next;\n\n            case NJS_VMCODE_OBJECT_COPY:\n                ret = njs_vmcode_object_copy(vm, value1, value2);\n                break;\n\n            case NJS_VMCODE_TEMPLATE_LITERAL:\n                ret = njs_vmcode_template_literal(vm, value1, value2);\n                break;\n\n            case NJS_VMCODE_PROPERTY_IN:\n                ret = njs_vmcode_property_in(vm, value1, value2);\n                break;\n\n            case NJS_VMCODE_PROPERTY_DELETE:\n                ret = njs_value_property_delete(vm, value1, value2, NULL);\n                if (njs_fast_path(ret != NJS_ERROR)) {\n                    vm->retval = njs_value_true;\n\n                    ret = sizeof(njs_vmcode_3addr_t);\n                }\n\n                break;\n\n            case NJS_VMCODE_PROPERTY_FOREACH:\n                ret = njs_vmcode_property_foreach(vm, value1, value2, pc);\n                break;\n\n            case NJS_VMCODE_STRICT_EQUAL:\n            case NJS_VMCODE_STRICT_NOT_EQUAL:\n                ret = njs_values_strict_equal(value1, value2);\n\n                ret ^= op - NJS_VMCODE_STRICT_EQUAL;\n\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n                njs_set_boolean(retval, ret);\n\n                pc += sizeof(njs_vmcode_3addr_t);\n                goto next;\n\n            case NJS_VMCODE_TEST_IF_TRUE:\n            case NJS_VMCODE_TEST_IF_FALSE:\n            case NJS_VMCODE_COALESCE:\n                if (op == NJS_VMCODE_COALESCE) {\n                    ret = !njs_is_null_or_undefined(value1);\n\n                } else {\n                    ret = njs_is_true(value1);\n                    ret ^= op - NJS_VMCODE_TEST_IF_TRUE;\n                }\n\n                if (ret) {\n                    test_jump = (njs_vmcode_test_jump_t *) pc;\n                    ret = test_jump->offset;\n\n                } else {\n                    ret = sizeof(njs_vmcode_3addr_t);\n                }\n\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n                *retval = *value1;\n\n                pc += ret;\n                goto next;\n\n            case NJS_VMCODE_UNARY_PLUS:\n            case NJS_VMCODE_UNARY_NEGATION:\n            case NJS_VMCODE_BITWISE_NOT:\n                if (njs_slow_path(!njs_is_numeric(value1))) {\n                    ret = njs_value_to_numeric(vm, value1, &numeric1);\n                    if (njs_slow_path(ret != NJS_OK)) {\n                        goto error;\n                    }\n\n                    value1 = &numeric1;\n                }\n\n                num = njs_number(value1);\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n\n                switch (op) {\n                case NJS_VMCODE_UNARY_NEGATION:\n                    num = -num;\n\n                    /* Fall through. */\n                case NJS_VMCODE_UNARY_PLUS:\n                    njs_set_number(retval, num);\n                    break;\n\n                case NJS_VMCODE_BITWISE_NOT:\n                    njs_set_int32(retval, ~njs_number_to_uint32(num));\n                }\n\n                pc += sizeof(njs_vmcode_2addr_t);\n                goto next;\n\n            case NJS_VMCODE_LOGICAL_NOT:\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n                njs_set_boolean(retval, !njs_is_true(value1));\n\n                pc += sizeof(njs_vmcode_2addr_t);\n                goto next;\n\n            case NJS_VMCODE_OBJECT:\n                ret = njs_vmcode_object(vm);\n                break;\n\n            case NJS_VMCODE_ARRAY:\n                ret = njs_vmcode_array(vm, pc);\n                break;\n\n            case NJS_VMCODE_FUNCTION:\n                ret = njs_vmcode_function(vm, pc);\n                break;\n\n            case NJS_VMCODE_REGEXP:\n                ret = njs_vmcode_regexp(vm, pc);\n                break;\n\n            case NJS_VMCODE_INSTANCE_OF:\n                ret = njs_vmcode_instance_of(vm, value1, value2);\n                break;\n\n            case NJS_VMCODE_TYPEOF:\n                ret = njs_vmcode_typeof(vm, value1, value2);\n                break;\n\n            case NJS_VMCODE_VOID:\n                njs_set_undefined(&vm->retval);\n\n                ret = sizeof(njs_vmcode_2addr_t);\n                break;\n\n            case NJS_VMCODE_DELETE:\n                njs_release(vm, value1);\n                vm->retval = njs_value_true;\n\n                ret = sizeof(njs_vmcode_2addr_t);\n                break;\n\n            case NJS_VMCODE_DEBUGGER:\n                ret = njs_vmcode_debugger(vm);\n                break;\n\n            default:\n                njs_internal_error(vm, \"%d has retval\", op);\n                goto error;\n            }\n\n            if (njs_slow_path(ret < 0 && ret >= NJS_PREEMPT)) {\n                break;\n            }\n\n            njs_vmcode_operand(vm, vmcode->operand1, retval);\n            njs_release(vm, retval);\n            *retval = vm->retval;\n\n        } else {\n\n            switch (op) {\n            case NJS_VMCODE_MOVE_ARG:\n                move_arg = (njs_vmcode_move_arg_t *) pc;\n                native = vm->top_frame;\n\n                hint = move_arg->dst;\n\n                value1 = &native->arguments_offset[hint];\n                njs_vmcode_operand(vm, move_arg->src, value2);\n\n                *value1 = *value2;\n\n                ret = sizeof(njs_vmcode_move_arg_t);\n                break;\n\n            case NJS_VMCODE_STOP:\n                njs_vmcode_operand(vm, (njs_index_t) value2, value2);\n                vm->retval = *value2;\n\n#ifdef NJS_OPCODE_DEBUG\n                njs_vmcode_debug(vm, pc, \"EXIT STOP\");\n#endif\n\n                return NJS_OK;\n\n            case NJS_VMCODE_JUMP:\n                ret = (njs_jump_off_t) value2;\n                break;\n\n            case NJS_VMCODE_PROPERTY_SET:\n                set = (njs_vmcode_prop_set_t *) pc;\n                njs_vmcode_operand(vm, set->value, retval);\n\n                ret = njs_value_property_set(vm, value1, value2, retval);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                ret = sizeof(njs_vmcode_prop_set_t);\n                break;\n\n            case NJS_VMCODE_PROPERTY_ACCESSOR:\n                accessor = (njs_vmcode_prop_accessor_t *) pc;\n                njs_vmcode_operand(vm, accessor->value, function);\n\n                ret = njs_value_to_key(vm, &name, value2);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    njs_internal_error(vm, \"failed conversion of type \\\"%s\\\" \"\n                                       \"to string while property define\",\n                                       njs_type_string(value2->type));\n                    goto error;\n                }\n\n                ret = njs_object_prop_define(vm, value1, &name, function,\n                                             accessor->type);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return NJS_ERROR;\n                }\n\n                ret = sizeof(njs_vmcode_prop_accessor_t);\n                break;\n\n            case NJS_VMCODE_IF_TRUE_JUMP:\n            case NJS_VMCODE_IF_FALSE_JUMP:\n                ret = njs_is_true(value1);\n\n                ret ^= op - NJS_VMCODE_IF_TRUE_JUMP;\n\n                ret = ret ? (njs_jump_off_t) value2\n                          : (njs_jump_off_t) sizeof(njs_vmcode_cond_jump_t);\n\n                break;\n\n            case NJS_VMCODE_IF_EQUAL_JUMP:\n                if (njs_values_strict_equal(value1, value2)) {\n                    equal = (njs_vmcode_equal_jump_t *) pc;\n                    ret = equal->offset;\n\n                } else {\n                    ret = sizeof(njs_vmcode_3addr_t);\n                }\n\n                break;\n\n            case NJS_VMCODE_PROPERTY_INIT:\n                set = (njs_vmcode_prop_set_t *) pc;\n                njs_vmcode_operand(vm, set->value, retval);\n                ret = njs_vmcode_property_init(vm, value1, value2, retval);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                break;\n\n            case NJS_VMCODE_RETURN:\n                njs_vmcode_operand(vm, (njs_index_t) value2, value2);\n\n#ifdef NJS_OPCODE_DEBUG\n                njs_vmcode_debug(vm, pc, \"EXIT RETURN\");\n#endif\n\n                return njs_vmcode_return(vm, NULL, value2);\n\n            case NJS_VMCODE_FUNCTION_COPY:\n                fcopy = (njs_vmcode_function_copy_t *) pc;\n                ret = njs_vmcode_function_copy(vm, fcopy->function,\n                                               fcopy->retval);\n                break;\n\n            case NJS_VMCODE_FUNCTION_FRAME:\n                function_frame = (njs_vmcode_function_frame_t *) pc;\n\n                /* TODO: external object instead of void this. */\n\n                ret = njs_function_frame_create(vm, value1,\n                                                &njs_value_undefined,\n                                                (uintptr_t) value2,\n                                                function_frame->ctor);\n\n                if (njs_slow_path(ret != NJS_OK)) {\n                    goto error;\n                }\n\n                ret = sizeof(njs_vmcode_function_frame_t);\n                break;\n\n            case NJS_VMCODE_METHOD_FRAME:\n                method_frame = (njs_vmcode_method_frame_t *) pc;\n\n                ret = njs_value_property(vm, value1, value2, &dst);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                if (njs_slow_path(!njs_is_function(&dst))) {\n                    ret = njs_value_to_key(vm, value2, value2);\n                    if (njs_slow_path(ret != NJS_OK)) {\n                        return NJS_ERROR;\n                    }\n\n                    njs_key_string_get(vm, value2, &string);\n                    njs_type_error(vm,\n                               \"(intermediate value)[\\\"%V\\\"] is not a function\",\n                               &string);\n                    goto error;\n                }\n\n                ret = njs_function_frame_create(vm, &dst, value1,\n                                                method_frame->nargs,\n                                                method_frame->ctor);\n\n                if (njs_slow_path(ret != NJS_OK)) {\n                    goto error;\n                }\n\n                ret = sizeof(njs_vmcode_method_frame_t);\n                break;\n\n            case NJS_VMCODE_FUNCTION_CALL:\n                vm->active_frame->native.pc = pc;\n\n                njs_vmcode_operand(vm, (njs_index_t) value2, value2);\n\n                ret = njs_function_frame_invoke(vm, value2);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                ret = sizeof(njs_vmcode_function_call_t);\n                break;\n\n            case NJS_VMCODE_PROPERTY_NEXT:\n                pnext = (njs_vmcode_prop_next_t *) pc;\n                retval = njs_scope_value(vm, pnext->retval);\n\n                next = value2->data.u.next;\n\n                if (next->index < next->array->length) {\n                    *retval = next->array->start[next->index++];\n\n                    ret = pnext->offset;\n                    break;\n                }\n\n                njs_mp_free(vm->mem_pool, next);\n\n                ret = sizeof(njs_vmcode_prop_next_t);\n                break;\n\n            case NJS_VMCODE_ARGUMENTS:\n                ret = njs_vmcode_arguments(vm, pc);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                break;\n\n            case NJS_VMCODE_PROTO_INIT:\n                set = (njs_vmcode_prop_set_t *) pc;\n                njs_vmcode_operand(vm, set->value, retval);\n                ret = njs_vmcode_proto_init(vm, value1, value2, retval);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                break;\n\n            case NJS_VMCODE_IMPORT:\n                import = (njs_vmcode_import_t *) pc;\n                retval = njs_scope_value(vm, import->retval);\n                ret = njs_vmcode_import(vm, import->module, retval);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                break;\n\n            case NJS_VMCODE_AWAIT:\n                await = (njs_vmcode_await_t *) pc;\n\n#ifdef NJS_OPCODE_DEBUG\n                njs_vmcode_debug(vm, pc, \"EXIT AWAIT\");\n#endif\n\n                return njs_vmcode_await(vm, await, promise_cap, async_ctx);\n\n            case NJS_VMCODE_TRY_START:\n                ret = njs_vmcode_try_start(vm, value1, value2, pc);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                break;\n\n            case NJS_VMCODE_THROW:\n                njs_vmcode_operand(vm, (njs_index_t) value2, value2);\n                vm->retval = *value2;\n                goto error;\n\n            case NJS_VMCODE_TRY_BREAK:\n                try_trampoline = (njs_vmcode_try_trampoline_t *) pc;\n                value1 = njs_scope_value(vm, try_trampoline->exit_value);\n\n                ret = njs_vmcode_try_break(vm, value1, value2);\n                break;\n\n            case NJS_VMCODE_TRY_CONTINUE:\n                try_trampoline = (njs_vmcode_try_trampoline_t *) pc;\n                value1 = njs_scope_value(vm, try_trampoline->exit_value);\n\n                ret = njs_vmcode_try_continue(vm, value1, value2);\n                break;\n\n            case NJS_VMCODE_TRY_END:\n                ret = njs_vmcode_try_end(vm, value1, value2);\n                break;\n\n            /*\n             * njs_vmcode_catch() is set on the start of a \"catch\" block to\n             * store exception and to remove a \"try\" block if there is no\n             * \"finally\" block or to update a catch address to the start of\n             * a \"finally\" block.\n             * njs_vmcode_catch() is set on the start of a \"finally\" block\n             * to store uncaught exception and to remove a \"try\" block.\n             */\n            case NJS_VMCODE_CATCH:\n                *value1 = vm->retval;\n\n                if ((njs_jump_off_t) value2 == sizeof(njs_vmcode_catch_t)) {\n                    ret = njs_vmcode_try_end(vm, value1, value2);\n\n                } else {\n                    frame = (njs_frame_t *) vm->top_frame;\n                    frame->exception.catch = pc + (njs_jump_off_t) value2;\n                    ret = sizeof(njs_vmcode_catch_t);\n                }\n\n                break;\n\n            case NJS_VMCODE_FINALLY:\n                finally = (njs_vmcode_finally_t *) pc;\n                value1 = njs_scope_value(vm, finally->exit_value);\n\n                ret = njs_vmcode_finally(vm, value1, value2, pc);\n\n                switch (ret) {\n                case NJS_OK:\n\n#ifdef NJS_OPCODE_DEBUG\n                    njs_vmcode_debug(vm, pc, \"EXIT FINALLY\");\n#endif\n\n                    return NJS_OK;\n                case NJS_ERROR:\n                    goto error;\n                }\n\n                break;\n\n            case NJS_VMCODE_LET:\n                var = (njs_vmcode_variable_t *) pc;\n                value1 = njs_scope_value(vm, var->dst);\n\n                if (njs_is_valid(value1)) {\n                    value1 = njs_mp_alloc(vm->mem_pool, sizeof(njs_value_t));\n                    if (njs_slow_path(value1 == NULL)) {\n                        return NJS_ERROR;\n                    }\n\n                    njs_scope_value_set(vm, var->dst, value1);\n                }\n\n                njs_set_undefined(value1);\n\n                ret = sizeof(njs_vmcode_variable_t);\n                break;\n\n            case NJS_VMCODE_LET_UPDATE:\n                var = (njs_vmcode_variable_t *) pc;\n                value2 = njs_scope_value(vm, var->dst);\n\n                value1 = njs_mp_alloc(vm->mem_pool, sizeof(njs_value_t));\n                if (njs_slow_path(value1 == NULL)) {\n                    return NJS_ERROR;\n                }\n\n                *value1 = *value2;\n\n                njs_scope_value_set(vm, var->dst, value1);\n\n                ret = sizeof(njs_vmcode_variable_t);\n                break;\n\n            case NJS_VMCODE_INITIALIZATION_TEST:\n                var = (njs_vmcode_variable_t *) pc;\n                value1 = njs_scope_value(vm, var->dst);\n\n                if (njs_is_valid(value1)) {\n                    ret = sizeof(njs_vmcode_variable_t);\n                    break;\n                }\n\n                /* Fall through. */\n\n            case NJS_VMCODE_NOT_INITIALIZED:\n                njs_reference_error(vm, \"cannot access variable \"\n                                        \"before initialization\");\n                goto error;\n\n            case NJS_VMCODE_ERROR:\n                njs_vmcode_error(vm, pc);\n                goto error;\n\n            case NJS_VMCODE_ASSIGNMENT_ERROR:\n                njs_type_error(vm, \"assignment to constant variable\");\n                goto error;\n\n            default:\n                njs_internal_error(vm, \"%d has NO retval\", op);\n                goto error;\n            }\n        }\n\n        pc += ret;\n    }\n\nerror:\n\n    if (njs_is_error(&vm->retval)) {\n        vm->active_frame->native.pc = pc;\n        (void) njs_error_stack_attach(vm, &vm->retval);\n    }\n\n    for ( ;; ) {\n        native = vm->top_frame;\n\n        if (!native->native) {\n            frame = (njs_frame_t *) native;\n            catch = frame->exception.catch;\n\n            if (catch != NULL) {\n                pc = catch;\n\n                goto next;\n            }\n        }\n\n        previous = native->previous;\n        if (previous == NULL) {\n            break;\n        }\n\n        lambda_call = (native == &vm->active_frame->native);\n\n        njs_vm_scopes_restore(vm, native, previous);\n\n        if (native->size != 0) {\n            vm->stack_size -= native->size;\n            njs_mp_free(vm->mem_pool, native);\n        }\n\n        if (lambda_call) {\n            break;\n        }\n    }\n\n#ifdef NJS_OPCODE_DEBUG\n    njs_vmcode_debug(vm, pc, \"EXIT ERROR\");\n#endif\n\n    return NJS_ERROR;\n}\n",
        "fix": null,
        "src_path": "222d6fdcf0c6485ec8e175f3a7b70d650c234b4e___njs_vmcode.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/222d6fdcf0c6485ec8e175f3a7b70d650c234b4e",
        "commit_msg": "Fixed njs_vmcode_interpreter() when \"toString\" conversion fails.\n\nPreviously, while interpreting a user function, njs_vmcode_interpreter()\nmight return prematurely when an error happens.  This is not correct\nbecause the current frame has to be unwound (or exception caught)\nfirst.\n\nThe fix is exit through only 5 appropriate exit points to ensure\nproper unwinding.\n\nThis closes #467 issue on Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -3409,6 +3409,11 @@ static njs_unit_test_t  njs_test[] =\n \n     /**/\n \n+    { njs_str(\"function f() { Object.prototype.toString = 1; };\"\n+              \"Object.prototype.toString = f;\"\n+              \"(function () { try { 's'[{}](); } catch (e) { throw e; } })()\"),\n+      njs_str(\"TypeError: Cannot convert object to primitive value\") },\n+\n     { njs_str(\"var i; for (i = 0; i < 10; i++) { i += 1 } i\"),\n       njs_str(\"10\") },\n "
            }
        ],
        "error_msg": "AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==32123==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000008 (pc 0x564e67ce582c bp 0x7ffe71676420 sp 0x7ffe71676180 T0)\n==32123==The signal is caused by a READ memory access.\n==32123==Hint: address points to the zero page.\n    #0 0x564e67ce582c in njs_scope_value /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/njs_scope.h:73:12\n    #1 0x564e67ce582c in njs_scope_valid_value /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/njs_scope.h:83:13\n    #2 0x564e67ce582c in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/njs_vmcode.c:162:13\n    #3 0x564e67ce1caa in njs_vm_start /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/njs_vm.c:553:11\n    #4 0x564e67cc8fb0 in njs_process_test /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/test/njs_unit_test.c:21963:15\n    #5 0x564e67cc8fb0 in njs_unit_test /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/test/njs_unit_test.c:22115:23\n    #6 0x564e67cc8261 in main /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/test/njs_unit_test.c:23605:15\n    #7 0x7f70f7010082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #8 0x564e67bf2acd in _start (/out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/build_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/njs_unit_test+0x11eacd)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/njs_scope.h:73:12 in njs_scope_value\n==32123==ABORTING\nAddressSanitizer:DEADLYSIGNAL\n=================================================================\n==32354==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000008 (pc 0x55d0d693e82c bp 0x7fff99f3e5e0 sp 0x7fff99f3e340 T0)\n==32354==The signal is "
    },
    "eafe4c7a326b163612f10861392622b5da5b1792___njs_iterator.c": {
        "start": 460,
        "end": 634,
        "buggy": "njs_int_t\nnjs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_iterator_handler_t handler)\n{\n    double              idx;\n    int64_t             i, from, to, length;\n    njs_int_t           ret;\n    njs_array_t         *array, *keys;\n    njs_value_t         *entry, *value, prop, character, string_obj;\n    const u_char        *p, *end, *pos;\n    njs_string_prop_t   string_prop;\n    njs_object_value_t  *object;\n\n    value = args->value;\n    from = args->from;\n    to = args->to;\n\n    if (njs_is_array(value)) {\n        array = njs_array(value);\n\n        from += 1;\n\n        while (from-- > to) {\n            if (njs_slow_path(!array->object.fast_array)) {\n                goto process_object;\n            }\n\n            if (njs_fast_path(from < array->length\n                              && njs_is_valid(&array->start[from])))\n            {\n                ret = handler(vm, args, &array->start[from], from);\n\n            } else {\n                entry = njs_value_arg(&njs_value_invalid);\n                ret = njs_value_property_i64(vm, value, from, &prop);\n                if (njs_slow_path(ret != NJS_DECLINED)) {\n                    if (ret == NJS_ERROR) {\n                        return NJS_ERROR;\n                    }\n\n                    entry = &prop;\n                }\n\n                ret = handler(vm, args, entry, from);\n            }\n\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DONE) {\n                    return NJS_DONE;\n                }\n\n                return NJS_ERROR;\n            }\n        }\n\n        return NJS_OK;\n    }\n\n    if (njs_is_string(value) || njs_is_object_string(value)) {\n\n        if (njs_is_string(value)) {\n            object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value);\n            if (njs_slow_path(object == NULL)) {\n                return NJS_ERROR;\n            }\n\n            njs_set_object_value(&string_obj, object);\n\n            args->value = &string_obj;\n        }\n        else {\n            value = njs_object_value(value);\n        }\n\n        length = njs_string_prop(&string_prop, value);\n        end = string_prop.start + string_prop.size;\n\n        if ((size_t) length == string_prop.size) {\n            /* Byte or ASCII string. */\n\n            p = string_prop.start + from;\n\n            i = from + 1;\n\n            while (i-- > to) {\n                /* This cannot fail. */\n                (void) njs_string_new(vm, &character, p, 1, 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n\n                    return NJS_ERROR;\n                }\n\n                p--;\n            }\n\n        } else {\n            /* UTF-8 string. */\n\n            p = njs_string_offset(string_prop.start, end, from);\n            p = njs_utf8_next(p, end);\n\n            i = from + 1;\n\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n\n                /* This cannot fail. */\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n\n                    return NJS_ERROR;\n                }\n\n                p = pos;\n            }\n        }\n\n        return NJS_OK;\n    }\n\n    if (!njs_is_object(value)) {\n        return NJS_OK;\n    }\n\nprocess_object:\n\n    if (!njs_fast_object(from - to)) {\n        keys = njs_array_indices(vm, value);\n        if (njs_slow_path(keys == NULL)) {\n            return NJS_ERROR;\n        }\n\n        i = keys->length;\n\n        while (i > 0) {\n            idx = njs_string_to_index(&keys->start[--i]);\n\n            if (idx < to || idx > from) {\n                continue;\n            }\n\n            ret = njs_iterator_object_handler(vm, handler, args,\n                                              &keys->start[i], idx);\n            if (njs_slow_path(ret != NJS_OK)) {\n                njs_array_destroy(vm, keys);\n                return ret;\n            }\n        }\n\n        njs_array_destroy(vm, keys);\n\n        return NJS_OK;\n    }\n\n    i = from + 1;\n\n    while (i-- > to) {\n        ret = njs_iterator_object_handler(vm, handler, args, NULL, i);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    return NJS_OK;\n}\n",
        "fix": null,
        "src_path": "eafe4c7a326b163612f10861392622b5da5b1792___njs_iterator.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/eafe4c7a326b163612f10861392622b5da5b1792",
        "commit_msg": "Fixed Array.prototype.lastIndexOf() with unicode string as \"this\".\n\nPreviously, when lastIndexOf() was called with unicode string as \"this\"\nargument and a negative \"fromIndex\" argument null-pointer dererence\nmight occur because njs_string_offset() was called with invalid index\nvalue whereas njs_string_offset() should always be called with valid\nindex argument.\n\nThe fix is to verify that from index is valid.\n\nThis closes #482 issue on Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -5103,6 +5103,9 @@ static njs_unit_test_t  njs_test[] =\n     { njs_str(\"Array.prototype.lastIndexOf.call({0:'undefined', length:0}, 'undefined')\"),\n       njs_str(\"-1\") },\n \n+    { njs_str(\"[1,0,-1,-2].map(v => Array.prototype.lastIndexOf.call('\u0424', '\u0424', v))\"),\n+      njs_str(\"0,0,0,-1\") },\n+\n     { njs_str(\"[''].lastIndexOf.call('00000000000000000000000000000\u043000')\"),\n       njs_str(\"-1\") },\n "
            }
        ],
        "error_msg": "AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==41021==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x556463e9ee30 bp 0x7ffe85b0f150 sp 0x7ffe85b0f140 T0)\n==41021==The signal is caused by a READ memory access.\n==41021==Hint: this fault was caused by a dereference of a high value address (see register values below).  Disassemble the provided pc to learn which register was used.\n    #0 0x556463e9ee30 in njs_string_offset /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_string.c:2535:18\n    #1 0x556463fa2206 in njs_object_iterate_reverse /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_iterator.c:563:17\n    #2 0x556463ecd0ec in njs_array_prototype_reverse_iterator /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_array.c:2424:11\n    #3 0x556463ee4291 in njs_function_native_call /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_function.c:739:11\n    #4 0x556463ee65c2 in njs_function_frame_invoke /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_function.c:777:16\n    #5 0x556463ee65c2 in njs_function_prototype_call /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_function.c:1351:11\n    #6 0x556463ee4291 in njs_function_native_call /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_function.c:739:11\n    #7 0x556463e9138f in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_vmcode.c:810:23\n    #8 0x556463ee372d in njs_function_lambda_call /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_function.c:703:11\n    #9 0x556463ee2962 in njs_function_frame_invoke /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_function.c:780:16\n    #10 0x556463ee2962 in njs_function_call2 /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_function."
    },
    "b3b29ce8f3acf3a32733d930105a17d7b0ba347e___peglib.h": {
        "start": 178,
        "end": 192,
        "buggy": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}\n",
        "fix": null,
        "src_path": "b3b29ce8f3acf3a32733d930105a17d7b0ba347e___peglib.h",
        "uri": "https://api.github.com/repos/yhirose/cpp-peglib/commits/b3b29ce8f3acf3a32733d930105a17d7b0ba347e",
        "commit_msg": "Fix #122",
        "test_func_diff": [
            {
                "fn": "test/test1.cc",
                "patch": "@@ -45,6 +45,17 @@ TEST_CASE(\"Start rule with ignore operator test\", \"[general]\")\n     REQUIRE(ret == false);\n }\n \n+TEST_CASE(\"Invalid UTF-8 text test\", \"[general]\")\n+{\n+    std::string s = \"a <- '\";\n+    s += static_cast<char>(0xe8); // Make invalid utf8 text...\n+\n+    parser parser(s.c_str());\n+\n+    bool ret = parser;\n+    REQUIRE(ret == false);\n+}\n+\n TEST_CASE(\"Backslash escape sequence test\", \"[general]\")\n {\n     parser parser(R\"("
            }
        ],
        "error_msg": "==70966==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fa942648440 at pc 0x560a6a8dcc6f bp 0x7ffdafe72c70 sp 0x7ffdafe72c68\nREAD of size 1 at 0x7fa942648440 thread T0\n[Detaching after fork from child process 70970]\n    #0 0x560a6a8dcc6e in peg::decode_codepoint(char const*, unsigned long, unsigned long&, char32_t&) /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:234:35\n    #1 0x560a6a8dcb49 in peg::decode_codepoint(char const*, unsigned long, char32_t&) /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:270:7\n    #2 0x560a6a87c0a6 in peg::CharacterClass::parse_core(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:1293:16\n    #3 0x560a6a870519 in peg::Ope::parse(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:2438:10\n    #4 0x560a6a87ba23 in peg::NotPredicate::parse_core(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:1211:22\n    #5 0x560a6a870519 in peg::Ope::parse(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:2438:10\n    #6 0x560a6a8796a8 in peg::Sequence::parse_core(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:1010:23\n    #7 0x560a6a870519 in peg::Ope::parse(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:2438:10\n    #8 0x560a6"
    },
    "c9a51565214eece8f1053089739aea73145bfd6b___jv.c": {
        "start": 737,
        "end": 766,
        "buggy": "int jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    decNumber res;\n    decNumberCompare(&res,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res)) {\n      return 0;\n    } else if (decNumberIsNegative(&res)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n",
        "fix": null,
        "src_path": "c9a51565214eece8f1053089739aea73145bfd6b___jv.c",
        "uri": "https://api.github.com/repos/jqlang/jq/commits/c9a51565214eece8f1053089739aea73145bfd6b",
        "commit_msg": "Merge pull request from GHSA-7hmr-442f-qc8j\n\nThe unit allocated for decNumberCompare was accidentally removed by\ncommit 680baeffeb7983e7570b5e68db07fe47f94db8c7 (PR #2804)\n\nThis caused a stack overflow when comparing a nan with a payload of 1000\nor more.\n\nThis bug was found by OSS-fuzz.\nRef: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=64771\nFixes GHSA-7hmr-442f-qc8j\n\nIt also fixes 1e999999999 > 1e-1147483646   triggering UBSAN errors\nFixes #2968",
        "test_func_diff": [
            {
                "fn": "tests/shtest",
                "patch": "@@ -594,6 +594,11 @@ if ! x=$($JQ -n \"1 # foo$cr + 2\") || [ \"$x\" != 1 ]; then\n   exit 1\n fi\n \n+# CVE-2023-50268: No stack overflow comparing a nan with a large payload\n+$VALGRIND $Q $JQ '1 != .' <<\\EOF >/dev/null\n+Nan4000\n+EOF\n+\n # Allow passing the inline jq script before -- #2919\n if ! r=$($JQ --args -rn -- '$ARGS.positional[0]' bar) || [ \"$r\" != bar ]; then\n     echo \"passing the inline script after -- didn't work\""
            }
        ],
        "error_msg": "+ . ./setup\n+ [ -n  ]\n+ set -eu\n+ dirname ./ytest.sh\n+ cd .\n+ pwd\n+ JQTESTDIR=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests\n+ JQBASEDIR=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/..\n+ JQ=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/../jq\n+ [ -z  ]\n+ which valgrind\n+ VALGRIND=valgrind --error-exitcode=1 --leak-check=full                        --suppressions=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/onig.supp                        --suppressions=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/local.supp\n+ VG_EXIT0=--error-exitcode=0\n+ Q=-q\n+ mods=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/modules\n+ clean=true\n+ d=\n+ trap clean EXIT\n+ mktemp -d -t jqXXXXXX\n+ d=/tmp/jqJQa0r1\n+ [ -z /tmp/jqJQa0r1 ]\n+ msys=false\n+ mingw=false\n+ uname -s\n+ JQ_NO_B=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/../jq\n+ JQ=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/../jq -b\n+ valgrind --error-exitcode=1 --leak-check=full --suppressions=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/onig.supp --suppressions=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/local.supp -q /out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/../jq -b 1 != .\n+ exit 0\n+ clean\n+ true\n+ [ -n /tmp/jqJQa0r1 ]\n+ rm -rf /tmp/jqJQa0r1\n"
    },
    "d15795acd5074e0b44e71f7ede8bdfe1b48591fc___x509_crt.c": {
        "start": 2189,
        "end": 2313,
        "buggy": "int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const mbedtls_x509_crt_profile *profile,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy )\n{\n    size_t cn_len;\n    int ret;\n    int pathlen = 0, selfsigned = 0;\n    mbedtls_x509_crt *parent;\n    mbedtls_x509_name *name;\n    mbedtls_x509_sequence *cur = NULL;\n    mbedtls_pk_type_t pk_type;\n\n    if( profile == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    *flags = 0;\n\n    if( cn != NULL )\n    {\n        name = &crt->subject;\n        cn_len = strlen( cn );\n\n        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n        {\n            cur = &crt->subject_alt_names;\n\n            while( cur != NULL )\n            {\n                if( cur->buf.len == cn_len &&\n                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )\n                    break;\n\n                if( cur->buf.len > 2 &&\n                    memcmp( cur->buf.p, \"*.\", 2 ) == 0 &&\n                    x509_check_wildcard( cn, &cur->buf ) == 0 )\n                {\n                    break;\n                }\n\n                cur = cur->next;\n            }\n\n            if( cur == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n        else\n        {\n            while( name != NULL )\n            {\n                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )\n                {\n                    if( name->val.len == cn_len &&\n                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )\n                        break;\n\n                    if( name->val.len > 2 &&\n                        memcmp( name->val.p, \"*.\", 2 ) == 0 &&\n                        x509_check_wildcard( cn, &name->val ) == 0 )\n                        break;\n                }\n\n                name = name->next;\n            }\n\n            if( name == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n    }\n\n    /* Check the type and size of the key */\n    pk_type = mbedtls_pk_get_type( &crt->pk );\n\n    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n    /* Look for a parent in trusted CAs */\n    for( parent = trust_ca; parent != NULL; parent = parent->next )\n    {\n        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n            break;\n    }\n\n    if( parent != NULL )\n    {\n        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            return( ret );\n    }\n    else\n    {\n        /* Look for a parent upwards the chain */\n        for( parent = crt->next; parent != NULL; parent = parent->next )\n            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n                break;\n\n        /* Are we part of the chain or at the top? */\n        if( parent != NULL )\n        {\n            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n        {\n            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n\n    return( 0 );\n}\n",
        "fix": null,
        "src_path": "d15795acd5074e0b44e71f7ede8bdfe1b48591fc___x509_crt.c",
        "uri": "https://api.github.com/repos/ARMmbed/mbedtls/commits/d15795acd5074e0b44e71f7ede8bdfe1b48591fc",
        "commit_msg": "Improve behaviour on fatal errors\n\nIf we didn't walk the whole chain, then there may be any kind of errors in the\npart of the chain we didn't check, so setting all flags looks like the safe\nthing to do.",
        "test_func_diff": [
            {
                "fn": "tests/suites/test_suite_x509parse.data",
                "patch": "@@ -1204,7 +1204,7 @@ mbedtls_x509_crt_verify_max:\"data_files/test-ca2.crt\":\"data_files/dir-maxpath\":M\n \n X509 CRT verify long chain (max intermediate CA + 1)\n depends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\n-mbedtls_x509_crt_verify_max:\"data_files/dir-maxpath/00.crt\":\"data_files/dir-maxpath\":MBEDTLS_X509_MAX_INTERMEDIATE_CA+1:MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:0\n+mbedtls_x509_crt_verify_max:\"data_files/dir-maxpath/00.crt\":\"data_files/dir-maxpath\":MBEDTLS_X509_MAX_INTERMEDIATE_CA+1:MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:-1\n \n X509 CRT verify chain #1 (zero pathlen intermediate)\n depends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C"
            }
        ],
        "error_msg": "  flags == (uint32_t) flags_chk\n  at line 534, /out/ARMmbed___mbedtls/git_repo_dir_d15795acd5074e0b44e71f7ede8bdfe1b48591fc/tests/suites/test_suite_x509parse.function\n\n"
    },
    "5e7b9ec688d79e7b16ec7064e1d37e8481a31e72___QuotedString.cpp": {
        "start": 58,
        "end": 58,
        "buggy": "static inline bool isQuote(char c) { return c == '\\\"' || c == '\\''; }\n",
        "fix": null,
        "src_path": "5e7b9ec688d79e7b16ec7064e1d37e8481a31e72___QuotedString.cpp",
        "uri": "https://api.github.com/repos/bblanchon/ArduinoJson/commits/5e7b9ec688d79e7b16ec7064e1d37e8481a31e72",
        "commit_msg": "Fix buffer overflow (pull request #81)",
        "test_func_diff": [
            {
                "fn": "test/QuotedString_ExtractFrom_Tests.cpp",
                "patch": "@@ -16,6 +16,11 @@ class QuotedString_ExtractFrom_Tests : public testing::Test {\n     _result = QuotedString::extractFrom(_jsonString, &_trailing);\n   }\n \n+  void whenInputIs(const char *json, size_t len) {\n+    memcpy(_jsonString, json, len);\n+    _result = QuotedString::extractFrom(_jsonString, &_trailing);\n+  }\n+\n   void resultMustBe(const char *expected) { EXPECT_STREQ(expected, _result); }\n \n   void trailingMustBe(const char *expected) {\n@@ -134,3 +139,8 @@ TEST_F(QuotedString_ExtractFrom_Tests, AllEscapedCharsTogether) {\n   whenInputIs(\"\\\"1\\\\\\\"2\\\\\\\\3\\\\/4\\\\b5\\\\f6\\\\n7\\\\r8\\\\t9\\\"\");\n   resultMustBe(\"1\\\"2\\\\3/4\\b5\\f6\\n7\\r8\\t9\");\n }\n+\n+TEST_F(QuotedString_ExtractFrom_Tests, UnterminatedEscapeSequence) {\n+  whenInputIs(\"\\\"\\\\\\0\\\"\", 4);\n+  resultMustBe(0);\n+}"
            }
        ],
        "error_msg": "Running main() from gtest_main.cc\nNote: Google Test filter = QuotedString_ExtractFrom_Tests.UnterminatedEscapeSequence\n[==========] Running 1 test from 1 test case.\n[----------] Global test environment set-up.\n[----------] 1 test from QuotedString_ExtractFrom_Tests\n[ RUN      ] QuotedString_ExtractFrom_Tests.UnterminatedEscapeSequence\n/out/bblanchon___ArduinoJson/git_repo_dir_5e7b9ec688d79e7b16ec7064e1d37e8481a31e72/test/QuotedString_ExtractFrom_Tests.cpp:24: Failure\nValue of: _result\n  Actual: \"\"\nExpected: expected\nWhich is: NULL\n[  FAILED  ] QuotedString_ExtractFrom_Tests.UnterminatedEscapeSequence (0 ms)\n[----------] 1 test from QuotedString_ExtractFrom_Tests (0 ms total)\n\n[----------] Global test environment tear-down\n[==========] 1 test from 1 test case ran. (0 ms total)\n[  PASSED  ] 0 tests.\n[  FAILED  ] 1 test, listed below:\n[  FAILED  ] QuotedString_ExtractFrom_Tests.UnterminatedEscapeSequence\n\n 1 FAILED TEST\n"
    },
    "1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7___TarFileReader.cpp": {
        "start": 99,
        "end": 109,
        "buggy": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();\n\n  LOG_DEBUG(5, \"Extracting: \" << path);\n\n  return extract(*SystemUtilities::oopen(path));\n}\n",
        "fix": null,
        "src_path": "1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7___TarFileReader.cpp",
        "uri": "https://api.github.com/repos/CauldronDevelopmentLLC/cbang/commits/1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7",
        "commit_msg": "Don't allow extraction of tar files outside of the target directory, added tar tests",
        "test_func_diff": [
            {
                "fn": "tests/tarTests/.gitignore",
                "patch": "@@ -0,0 +1 @@\n+/path"
            },
            {
                "fn": "tests/tarTests/BadExtractTest/data/args",
                "patch": "@@ -0,0 +1 @@\n+--extract test.tar"
            },
            {
                "fn": "tests/tarTests/BadExtractTest/expect/return",
                "patch": "@@ -0,0 +1 @@\n+1"
            },
            {
                "fn": "tests/tarTests/BadExtractTest/expect/stderr",
                "patch": "@@ -0,0 +1 @@\n+Tar path points outside of the extraction directory: ./../hello.txt\n\\ No newline at end of file"
            },
            {
                "fn": "tests/tarTests/CompressedExtractTest/data/args",
                "patch": "@@ -0,0 +1 @@\n+--extract test.tar.bz2"
            },
            {
                "fn": "tests/tarTests/CompressedExtractTest/expect/return",
                "patch": "@@ -0,0 +1 @@\n+0"
            },
            {
                "fn": "tests/tarTests/CompressedExtractTest/expect/stdout",
                "patch": "@@ -0,0 +1 @@\n+hello.txt"
            },
            {
                "fn": "tests/tarTests/ExtractTest/data/args",
                "patch": "@@ -0,0 +1 @@\n+--extract test.tar"
            },
            {
                "fn": "tests/tarTests/ExtractTest/expect/return",
                "patch": "@@ -0,0 +1 @@\n+0"
            },
            {
                "fn": "tests/tarTests/ExtractTest/expect/stdout",
                "patch": "@@ -0,0 +1 @@\n+hello.txt"
            },
            {
                "fn": "tests/tarTests/SConscript",
                "patch": "@@ -0,0 +1,8 @@\n+Import('*')\n+\n+# Local includes\n+env.Append(CPPPATH = ['#'])\n+\n+prog = env.Program('tar', 'tar.cpp')\n+\n+Return('prog')"
            },
            {
                "fn": "tests/tarTests/tar.cpp",
                "patch": "@@ -0,0 +1,61 @@\n+/******************************************************************************\\\n+\n+          This file is part of the C! library.  A.K.A the cbang library.\n+\n+                Copyright (c) 2003-2019, Cauldron Development LLC\n+                   Copyright (c) 2003-2017, Stanford University\n+                               All rights reserved.\n+\n+         The C! library is free software: you can redistribute it and/or\n+        modify it under the terms of the GNU Lesser General Public License\n+       as published by the Free Software Foundation, either version 2.1 of\n+               the License, or (at your option) any later version.\n+\n+        The C! library is distributed in the hope that it will be useful,\n+          but WITHOUT ANY WARRANTY; without even the implied warranty of\n+        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+                 Lesser General Public License for more details.\n+\n+         You should have received a copy of the GNU Lesser General Public\n+                 License along with the C! library.  If not, see\n+                         <http://www.gnu.org/licenses/>.\n+\n+        In addition, BSD licensing may be granted on a case by case basis\n+        by written permission from at least one of the copyright holders.\n+           You may request written permission by emailing the authors.\n+\n+                  For information regarding this software email:\n+                                 Joseph Coffland\n+                          joseph@cauldrondevelopment.com\n+\n+\\******************************************************************************/\n+\n+#include <cbang/tar/TarFileReader.h>\n+#include <cbang/Catch.h>\n+\n+#include <iostream>\n+\n+using namespace cb;\n+using namespace std;\n+\n+\n+int main(int argc, char *argv[]) {\n+  try {\n+    for (int i = 1; i < argc; i++) {\n+      string arg = argv[i];\n+\n+      if (arg == \"--extract\" && i < argc - 1) {\n+        TarFileReader reader(argv[++i]);\n+\n+        while (reader.hasMore())\n+          cout << reader.extract() << endl;\n+\n+      } else THROWS(\"Invalid arg '\" << arg << \"'\");\n+    }\n+\n+    return 0;\n+\n+  } catch (const Exception &e) {cerr << e.getMessage();}\n+\n+  return 1;\n+}"
            },
            {
                "fn": "tests/tarTests/test.json",
                "patch": "@@ -0,0 +1,3 @@\n+{\n+  \"command\": \"%(suite-dir)s/tar\"\n+}"
            }
        ],
        "error_msg": "scons: Reading SConscript files ...\n   Compiler: gcc (gnu)\n   Platform: posix\n       Mode: gnu\n       Arch: x86\nGCC Version: 9\n       Jobs: 79\nChecking for C library pthread... (cached) yes\nChecking for C header file zlib.h... (cached) yes\nChecking for C library z... (cached) yes\nChecking for C header file bzlib.h... (cached) yes\nChecking for C library bz2... (cached) yes\nChecking for C header file expat.h... (cached) yes\nChecking for C library expat... (cached) yes\nChecking for C header file pthread.h... (cached) yes\nChecking for C library pthread... (cached) yes\nChecking for C library dl... (cached) yes\nChecking for C library sqlite3... (cached) yes\nChecking for C header file sqlite3.h... (cached) yes\nChecking for C function sqlite3_backup_init()... (cached) yes\nChecking for C header file yaml.h... (cached) yes\nChecking for C library yaml... (cached) yes\nChecking for C library snappy... (cached) yes\nChecking for C library leveldb... no\nNeed library leveldb(cached) error: no result\nChecking for C header file mysql/mysql.h... no\nChecking for C function clock_gettime()... (cached) yes\nChecking for C header file event.h... (cached) yes\nChecking for C library event... (cached) yes\nChecking for C++ header file re2/re2.h... (cached) yes\nChecking for C library re2... (cached) yes\nChecking for C function epoll_create1()... (cached) yes\nChecking for C library dl... (cached) yes\nChecking for C header file openssl/ssl.h... (cached) yes\nChecking for C library crypto... (cached) yes\nChecking for C library ssl... (cached) yes\nChecking for openssl version >= 1.1.0...(cached) yes\nChecking for C++ header file ChakraCore.h... no\nNeed C++ header ChakraCore.h(cached) error: no result\nChecking for C++ header file v8.h... (cached) yes\nChecking for C++ header file libplatform/libplatform.h... (cached) yes\nChecking for C library v8... (cached) yes\nChecking for C header file pthread.h... (cached) yes\nChecking for C library pthread... (cached) yes\nChecking for C header file valgrind/valgrind.h... (cached) yes\nChecking for C header file "
    },
    "92cc8517fcb85dcfbb93842758571f721c49c9cb___tree_schema_compile.c": {
        "start": 1959,
        "end": 2155,
        "buggy": "static LY_ERR\nlys_compile_leafref_predicate_validate(struct lysc_ctx *ctx, const char **predicate, const struct lysc_node *start_node,\n                                       const struct lysc_node_list *context_node, const struct lys_module *path_context)\n{\n    LY_ERR ret = LY_EVALID;\n    const struct lys_module *mod;\n    const struct lysc_node *src_node, *dst_node;\n    const char *path_key_expr, *pke_start, *src, *src_prefix, *dst, *dst_prefix;\n    size_t src_len, src_prefix_len, dst_len, dst_prefix_len;\n    unsigned int dest_parent_times, c, u;\n    const char *start, *end, *pke_end;\n    struct ly_set keys = {0};\n    int i;\n\n    assert(path_context);\n\n    while (**predicate == '[') {\n        start = (*predicate)++;\n\n        while (isspace(**predicate)) {\n            ++(*predicate);\n        }\n        LY_CHECK_GOTO(lys_parse_nodeid(predicate, &src_prefix, &src_prefix_len, &src, &src_len), cleanup);\n        while (isspace(**predicate)) {\n            ++(*predicate);\n        }\n        if (**predicate != '=') {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - missing \\\"=\\\" after node-identifier.\",\n                   *predicate - start + 1, start);\n            goto cleanup;\n        }\n        ++(*predicate);\n        while (isspace(**predicate)) {\n            ++(*predicate);\n        }\n\n        if ((end = pke_end = strchr(*predicate, ']')) == NULL) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%s\\\" - missing predicate termination.\", start);\n            goto cleanup;\n        }\n        --pke_end;\n        while (isspace(*pke_end)) {\n            --pke_end;\n        }\n        ++pke_end;\n        /* localize path-key-expr */\n        pke_start = path_key_expr = *predicate;\n        /* move after the current predicate */\n        *predicate = end + 1;\n\n        /* source (must be leaf or leaf-list) */\n        if (src_prefix) {\n            mod = lys_module_find_prefix(path_context, src_prefix, src_prefix_len);\n            if (!mod) {\n                LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                       \"Invalid leafref path predicate \\\"%.*s\\\" - prefix \\\"%.*s\\\" not defined in module \\\"%s\\\".\",\n                       *predicate - start, start, src_prefix_len, src_prefix, path_context->name);\n                goto cleanup;\n            }\n        } else {\n            mod = start_node->module;\n        }\n        src_node = NULL;\n        if (context_node->keys) {\n            for (u = 0; u < LY_ARRAY_SIZE(context_node->keys); ++u) {\n                if (!strncmp(src, context_node->keys[u]->name, src_len) && context_node->keys[u]->name[src_len] == '\\0') {\n                    src_node = (const struct lysc_node*)context_node->keys[u];\n                    break;\n                }\n            }\n        }\n        if (!src_node) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - predicate's key node \\\"%.*s\\\" not found.\",\n                   *predicate - start, start, src_len, src, mod->name);\n            goto cleanup;\n        }\n\n        /* check that there is only one predicate for the */\n        c = keys.count;\n        i = ly_set_add(&keys, (void*)src_node, 0);\n        LY_CHECK_GOTO(i == -1, cleanup);\n        if (keys.count == c) { /* node was already present in the set */\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - multiple equality tests for the key \\\"%s\\\".\",\n                   *predicate - start, start, src_node->name);\n            goto cleanup;\n        }\n\n        /* destination */\n        dest_parent_times = 0;\n        dst_node = start_node;\n\n        /* current-function-invocation *WSP \"/\" *WSP rel-path-keyexpr */\n        if (strncmp(path_key_expr, \"current()\", 9)) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - missing current-function-invocation.\",\n                   *predicate - start, start);\n            goto cleanup;\n        }\n        path_key_expr += 9;\n        while (isspace(*path_key_expr)) {\n            ++path_key_expr;\n        }\n\n        if (*path_key_expr != '/') {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - missing \\\"/\\\" after current-function-invocation.\",\n                   *predicate - start, start);\n            goto cleanup;\n        }\n        ++path_key_expr;\n        while (isspace(*path_key_expr)) {\n            ++path_key_expr;\n        }\n\n        /* rel-path-keyexpr:\n         * 1*(\"..\" *WSP \"/\" *WSP) *(node-identifier *WSP \"/\" *WSP) node-identifier */\n        while (!strncmp(path_key_expr, \"..\", 2)) {\n            ++dest_parent_times;\n            path_key_expr += 2;\n            while (isspace(*path_key_expr)) {\n                ++path_key_expr;\n            }\n            if (*path_key_expr != '/') {\n                LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                       \"Invalid leafref path predicate \\\"%.*s\\\" - missing \\\"/\\\" in \\\"../\\\" rel-path-keyexpr pattern.\",\n                       *predicate - start, start);\n                goto cleanup;\n            }\n            ++path_key_expr;\n            while (isspace(*path_key_expr)) {\n                ++path_key_expr;\n            }\n\n            /* path is supposed to be evaluated in data tree, so we have to skip\n             * all schema nodes that cannot be instantiated in data tree */\n            MOVE_PATH_PARENT(dst_node, !strncmp(path_key_expr, \"..\", 2), goto cleanup,\n                             \"Invalid leafref path predicate \\\"%.*s\\\" - too many \\\"..\\\" in rel-path-keyexpr.\",\n                             *predicate - start, start);\n        }\n        if (!dest_parent_times) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - at least one \\\"..\\\" is expected in rel-path-keyexpr.\",\n                   *predicate - start, start);\n            goto cleanup;\n        }\n        if (path_key_expr == pke_end) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - at least one node-identifier is expected in rel-path-keyexpr.\",\n                   *predicate - start, start);\n            goto cleanup;\n        }\n\n        while(path_key_expr != pke_end) {\n            if (lys_parse_nodeid(&path_key_expr, &dst_prefix, &dst_prefix_len, &dst, &dst_len)) {\n                LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_SYNTAX_YANG,\n                       \"Invalid node identifier in leafref path predicate - character %d (of %.*s).\",\n                       path_key_expr - start + 1, *predicate - start, start);\n                goto cleanup;\n            }\n\n            if (dst_prefix) {\n                mod = lys_module_find_prefix(path_context, dst_prefix, dst_prefix_len);\n            } else {\n                mod = start_node->module;\n            }\n            if (!mod) {\n                LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                       \"Invalid leafref path predicate \\\"%.*s\\\" - unable to find module of the node \\\"%.*s\\\" in rel-path_keyexpr.\",\n                       *predicate - start, start, dst_len, dst);\n                goto cleanup;\n            }\n\n            dst_node = lys_child(dst_node, mod, dst, dst_len, 0, LYS_GETNEXT_NOSTATECHECK);\n            if (!dst_node) {\n                LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                       \"Invalid leafref path predicate \\\"%.*s\\\" - unable to find node \\\"%.*s\\\" in the rel-path_keyexpr.\",\n                       *predicate - start, start, path_key_expr - pke_start, pke_start);\n                goto cleanup;\n            }\n        }\n        if (!(dst_node->nodetype & (dst_node->module->version < LYS_VERSION_1_1 ? LYS_LEAF : LYS_LEAF | LYS_LEAFLIST))) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - rel-path_keyexpr \\\"%.*s\\\" refers %s instead of leaf.\",\n                   *predicate - start, start, path_key_expr - pke_start, pke_start, lys_nodetype2str(dst_node->nodetype));\n            goto cleanup;\n        }\n    }\n\n    ret = LY_SUCCESS;\ncleanup:\n    ly_set_erase(&keys, NULL);\n    return ret;\n}\n",
        "fix": null,
        "src_path": "92cc8517fcb85dcfbb93842758571f721c49c9cb___tree_schema_compile.c",
        "uri": "https://api.github.com/repos/CESNET/libyang/commits/92cc8517fcb85dcfbb93842758571f721c49c9cb",
        "commit_msg": "schema compilation BUGFIX nodes mentioned in leafref path's predicates must be implemented\n\nNot only the nodes directly used in the leafref's path make their module\nimplemented, but also the nodes referenced in the path's predicates\nwork this way.",
        "test_func_diff": [
            {
                "fn": "tests/src/test_tree_schema_compile.c",
                "patch": "@@ -1905,6 +1905,20 @@ test_type_leafref(void **state)\n     assert_non_null(mod->compiled->data);\n     assert_string_equal(\"h\", mod->compiled->data->name);\n \n+    ly_ctx_set_module_imp_clb(ctx, test_imp_clb, \"module j {namespace urn:j;prefix j; leaf j  {type string;}}\");\n+    assert_non_null(mod = lys_parse_mem(ctx, \"module k {namespace urn:k;prefix k;import j {prefix j;}\"\n+                                        \"leaf i {type leafref {path \\\"/ilist[name = current()/../j:j]/value\\\";}}\"\n+                                        \"list ilist {key name; leaf name {type string;} leaf value {type uint16;}}}\", LYS_IN_YANG));\n+    type = ((struct lysc_node_leaf*)mod->compiled->data)->type;\n+    assert_non_null(type);\n+    assert_int_equal(LY_TYPE_LEAFREF, type->basetype);\n+    assert_non_null(((struct lysc_type_leafref*)type)->realtype);\n+    assert_int_equal(LY_TYPE_UINT16, ((struct lysc_type_leafref*)type)->realtype->basetype);\n+    assert_non_null(mod = ly_ctx_get_module_implemented(ctx, \"j\"));\n+    assert_int_equal(1, mod->implemented);\n+    assert_non_null(mod->compiled->data);\n+    assert_string_equal(\"j\", mod->compiled->data->name);\n+\n     /* invalid paths */\n     assert_null(lys_parse_mem(ctx, \"module aa {namespace urn:aa;prefix aa;container a {leaf target2 {type uint8;}}\"\n                                         \"leaf ref1 {type leafref {path ../a/invalid;}}}\", LYS_IN_YANG));\n@@ -2030,21 +2044,21 @@ test_type_leafref(void **state)\n                                         \"leaf ifname{type leafref{ path \\\"../interface/name\\\";}}\"\n                                         \"leaf address {type leafref{ path \\\"/interface[name=current()/../x:ifname]/ip\\\";}}}\",\n                                         LYS_IN_YANG));\n-    logbuf_assert(\"Invalid leafref path predicate \\\"[name=current()/../x:ifname]\\\" - unable to find module of the node \\\"ifname\\\" in rel-path_keyexpr.\");\n+    logbuf_assert(\"Invalid leafref path predicate \\\"[name=current()/../x:ifname]\\\" - unable to find module of the node \\\"ifname\\\" in rel-path-keyexpr.\");\n \n     assert_null(lys_parse_mem(ctx, \"module zz {namespace urn:zz;prefix zz;\"\n                                         \"list interface{key name;leaf name{type string;}leaf ip {type string;}}\"\n                                         \"leaf ifname{type leafref{ path \\\"../interface/name\\\";}}\"\n                                         \"leaf address {type leafref{ path \\\"/interface[name=current()/../xxx]/ip\\\";}}}\",\n                                         LYS_IN_YANG));\n-    logbuf_assert(\"Invalid leafref path predicate \\\"[name=current()/../xxx]\\\" - unable to find node \\\"current()/../xxx\\\" in the rel-path_keyexpr.\");\n+    logbuf_assert(\"Invalid leafref path predicate \\\"[name=current()/../xxx]\\\" - unable to find node \\\"current()/../xxx\\\" in the rel-path-keyexpr.\");\n \n     assert_null(lys_parse_mem(ctx, \"module zza {namespace urn:zza;prefix zza;\"\n                                         \"list interface{key name;leaf name{type string;}leaf ip {type string;}}\"\n                                         \"leaf ifname{type leafref{ path \\\"../interface/name\\\";}}container c;\"\n                                         \"leaf address {type leafref{ path \\\"/interface[name=current()/../c]/ip\\\";}}}\",\n                                         LYS_IN_YANG));\n-    logbuf_assert(\"Invalid leafref path predicate \\\"[name=current()/../c]\\\" - rel-path_keyexpr \\\"current()/../c\\\" refers container instead of leaf.\");\n+    logbuf_assert(\"Invalid leafref path predicate \\\"[name=current()/../c]\\\" - rel-path-keyexpr \\\"current()/../c\\\" refers container instead of leaf.\");\n \n     assert_null(lys_parse_mem(ctx, \"module zzb {namespace urn:zzb;prefix zzb;\"\n                                         \"list interface{key name;leaf name{type string;}leaf ip {type string;}container c;}\""
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_92cc8517fcb85dcfbb93842758571f721c49c9cb/build_92cc8517fcb85dcfbb93842758571f721c49c9cb\nTest project /out/CESNET___libyang/git_repo_dir_92cc8517fcb85dcfbb93842758571f721c49c9cb/build_92cc8517fcb85dcfbb93842758571f721c49c9cb\n    Start 8: src_tree_schema_compile\n1/1 Test #8: src_tree_schema_compile ..........***Failed    0.11 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.11 sec\n\nThe following tests FAILED:\n\t  8 - src_tree_schema_compile (Failed)\n"
    },
    "f128972045a5d4a36854ddc0a75d99803ff81f6d___plugins_types.c": {
        "start": 149,
        "end": 173,
        "buggy": "LIBYANG_API_DEF const struct lys_module *\nlyplg_type_identity_module(const struct ly_ctx *ctx, const struct lysc_node *ctx_node,\n        const char *prefix, size_t prefix_len, LY_VALUE_FORMAT format, const void *prefix_data)\n{\n    if (prefix_len) {\n        return ly_resolve_prefix(ctx, prefix, prefix_len, format, prefix_data);\n    } else {\n        switch (format) {\n        case LY_VALUE_SCHEMA:\n        case LY_VALUE_SCHEMA_RESOLVED:\n            /* use context node module, handles augments */\n            return ctx_node->module;\n        case LY_VALUE_CANON:\n        case LY_VALUE_JSON:\n        case LY_VALUE_LYB:\n            /* use context node module (as specified) */\n            return ctx_node->module;\n        case LY_VALUE_XML:\n            /* use the default namespace */\n            return ly_xml_resolve_prefix(ctx, NULL, 0, prefix_data);\n        }\n    }\n\n    return NULL;\n}\n",
        "fix": null,
        "src_path": "f128972045a5d4a36854ddc0a75d99803ff81f6d___plugins_types.c",
        "uri": "https://api.github.com/repos/CESNET/libyang/commits/f128972045a5d4a36854ddc0a75d99803ff81f6d",
        "commit_msg": "plugins types BUGFIX local module of dflt ident without prefix\n\nTest included.\nFixes #1777",
        "test_func_diff": [
            {
                "fn": "tests/utests/schema/test_tree_schema_compile.c",
                "patch": "@@ -2354,6 +2354,17 @@ test_grouping(void **state)\n             \"  list mylist {key \\\"name\\\"; unique \\\"value\\\"; uses z2:leafs_group;}\"\n             \"}\"\n             \"augment /z1:root { uses list_group;} }\", LYS_IN_YANG, NULL));\n+\n+    /* identity */\n+    assert_int_equal(LY_SUCCESS, lys_parse_mem(UTEST_LYCTX, \"module y1 {namespace urn:y1;prefix y1;\"\n+            \"identity base_identity;\"\n+            \"identity id1 {base \\\"base_identity\\\";}\"\n+            \"grouping attrs_group {\"\n+            \"  leaf name {type identityref {base \\\"base_identity\\\";} default \\\"id1\\\";}\"\n+            \"}}\", LYS_IN_YANG, NULL));\n+    assert_int_equal(LY_SUCCESS, lys_parse_mem(UTEST_LYCTX, \"module y2 {namespace urn:y2;prefix y2;\"\n+            \"import y1 {prefix y1;}\"\n+            \"container root {uses y1:attrs_group;}}\", LYS_IN_YANG, NULL));\n }\n \n static void"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_f128972045a5d4a36854ddc0a75d99803ff81f6d/build_f128972045a5d4a36854ddc0a75d99803ff81f6d\nTest project /out/CESNET___libyang/git_repo_dir_f128972045a5d4a36854ddc0a75d99803ff81f6d/build_f128972045a5d4a36854ddc0a75d99803ff81f6d\n    Start 38: utest_tree_schema_compile\n1/1 Test #38: utest_tree_schema_compile ........***Failed    0.22 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.22 sec\n\nThe following tests FAILED:\n\t 38 - utest_tree_schema_compile (Failed)\n"
    },
    "4da9f87ccbe71edb3b3aaf74b8b64d7e9c41dcaf___evdns.c": {
        "start": 4098,
        "end": 4157,
        "buggy": "static void\nevdns_base_free_and_unlock(struct evdns_base *base, int fail_requests)\n{\n\tstruct nameserver *server, *server_next;\n\tstruct search_domain *dom, *dom_next;\n\tint i;\n\n\t/* Requires that we hold the lock. */\n\n\t/* TODO(nickm) we might need to refcount here. */\n\n\tfor (i = 0; i < base->n_req_heads; ++i) {\n\t\twhile (base->req_heads[i]) {\n\t\t\tif (fail_requests)\n\t\t\t\treply_schedule_callback(base->req_heads[i], 0, DNS_ERR_SHUTDOWN, NULL);\n\t\t\trequest_finished(base->req_heads[i], &REQ_HEAD(base, base->req_heads[i]->trans_id), 1);\n\t\t}\n\t}\n\twhile (base->req_waiting_head) {\n\t\tif (fail_requests)\n\t\t\treply_schedule_callback(base->req_waiting_head, 0, DNS_ERR_SHUTDOWN, NULL);\n\t\trequest_finished(base->req_waiting_head, &base->req_waiting_head, 1);\n\t}\n\tbase->global_requests_inflight = base->global_requests_waiting = 0;\n\n\tfor (server = base->server_head; server; server = server_next) {\n\t\tserver_next = server->next;\n\t\t/** already done something before */\n\t\tserver->probe_request = NULL;\n\t\tevdns_nameserver_free(server);\n\t\tif (server_next == base->server_head)\n\t\t\tbreak;\n\t}\n\tbase->server_head = NULL;\n\tbase->global_good_nameservers = 0;\n\n\tif (base->global_search_state) {\n\t\tfor (dom = base->global_search_state->head; dom; dom = dom_next) {\n\t\t\tdom_next = dom->next;\n\t\t\tmm_free(dom);\n\t\t}\n\t\tmm_free(base->global_search_state);\n\t\tbase->global_search_state = NULL;\n\t}\n\n\t{\n\t\tstruct hosts_entry *victim;\n\t\twhile ((victim = TAILQ_FIRST(&base->hostsdb))) {\n\t\t\tTAILQ_REMOVE(&base->hostsdb, victim, next);\n\t\t\tmm_free(victim);\n\t\t}\n\t}\n\n\tmm_free(base->req_heads);\n\n\tEVDNS_UNLOCK(base);\n\tEVTHREAD_FREE_LOCK(base->lock, EVTHREAD_LOCKTYPE_RECURSIVE);\n\n\tmm_free(base);\n}\n",
        "fix": null,
        "src_path": "4da9f87ccbe71edb3b3aaf74b8b64d7e9c41dcaf___evdns.c",
        "uri": "https://api.github.com/repos/libevent/libevent/commits/4da9f87ccbe71edb3b3aaf74b8b64d7e9c41dcaf",
        "commit_msg": "evdns: fix a crash when evdns_base with waiting requests is freed\n\nFix undefined behaviour and application crash that might take\nplace in some rare cases after calling evdns_base_free when\nthere are requests in the waiting queue.\n\nCurrent cleanup procedure in evdns_base_free_and_unlock\nfunction includes 2 steps:\n1. Finish all inflight requests.\n2. Finish all waiting requests.\nDuring the first step we iterate over each list in req_heads\nstructure and finish all requests in these lists. With current\nlogic finishing an inflight request (function request_finished)\nremoves it from the inflight requests container and forces\na wating connection to be sent (by calling\nevdns_requests_pump_waiting_queue). When these new requests are\nsent it is possible that they will be inserted to the list in\nreq_heads that we've already cleaned.\nSo in some cases container of the inflight requests is not empty\nafter this procedure and some requests are not finished and\ndeleted. When timeouts for these requests expire\nevdns_request_timeout_callback is called but corresponding\nevdns_base has been already deleted which causes undefined\nbehaviour and possible applicaton crash.\n\nIt is interesting to note that in old versions of libevent such\nsituation was not possible. This bug was introduced by the commit\n14f84bbdc77d90b1d936076661443cdbf516c593. Before this commit\nnameservers were deleted before finishing the requests. Therefore\nit was not possible that requests from the waiting queue be sent\nwhile we finish the inflight requests.",
        "test_func_diff": [
            {
                "fn": "test/regress_dns.c",
                "patch": "@@ -2127,6 +2127,7 @@ dns_client_fail_requests_test(void *arg)\n {\n \tstruct basic_test_data *data = arg;\n \tstruct event_base *base = data->base;\n+\tint limit_inflight = data->setup_data && !strcmp(data->setup_data, \"limit-inflight\");\n \tstruct evdns_base *dns = NULL;\n \tstruct evdns_server_port *dns_port = NULL;\n \tev_uint16_t portnum = 0;\n@@ -2144,6 +2145,9 @@ dns_client_fail_requests_test(void *arg)\n \tdns = evdns_base_new(base, EVDNS_BASE_DISABLE_WHEN_INACTIVE);\n \ttt_assert(!evdns_base_nameserver_ip_add(dns, buf));\n \n+\tif (limit_inflight)\n+\t\ttt_assert(!evdns_base_set_option(dns, \"max-inflight:\", \"11\"));\n+\n \tfor (i = 0; i < 20; ++i)\n \t\tevdns_base_resolve_ipv4(dns, \"foof.example.com\", 0, generic_dns_callback, &r[i]);\n \n@@ -2437,6 +2441,8 @@ struct testcase_t dns_testcases[] = {\n \n \t{ \"client_fail_requests\", dns_client_fail_requests_test,\n \t  TT_FORK|TT_NEED_BASE|TT_NO_LOGS, &basic_setup, NULL },\n+\t{ \"client_fail_waiting_requests\", dns_client_fail_requests_test,\n+\t  TT_FORK|TT_NEED_BASE|TT_NO_LOGS, &basic_setup, (char*)\"limit-inflight\" },\n \t{ \"client_fail_requests_getaddrinfo\",\n \t  dns_client_fail_requests_getaddrinfo_test,\n \t  TT_FORK|TT_NEED_BASE|TT_NO_LOGS, &basic_setup, NULL },"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/libevent___libevent/git_repo_dir_4da9f87ccbe71edb3b3aaf74b8b64d7e9c41dcaf/build_4da9f87ccbe71edb3b3aaf74b8b64d7e9c41dcaf\nTest project /out/libevent___libevent/git_repo_dir_4da9f87ccbe71edb3b3aaf74b8b64d7e9c41dcaf/build_4da9f87ccbe71edb3b3aaf74b8b64d7e9c41dcaf\n    Start 17: regress__changelist_EPOLL\n1/5 Test #17: regress__changelist_EPOLL .........***Failed   97.94 sec\n    Start 18: regress__changelist_EPOLL_debug\n2/5 Test #18: regress__changelist_EPOLL_debug ...***Failed   96.05 sec\n    Start 35: regress__SELECT\n3/5 Test #35: regress__SELECT ...................***Failed   98.57 sec\n    Start 36: regress__SELECT_debug\n4/5 Test #36: regress__SELECT_debug .............   Passed   94.45 sec\n    Start 45: regress__POLL_debug\n5/5 Test #45: regress__POLL_debug ...............***Failed   99.21 sec\n\n20% tests passed, 4 tests failed out of 5\n\nTotal Test time (real) = 486.22 sec\n\nThe following tests FAILED:\n\t 17 - regress__changelist_EPOLL (Failed)\n\t 18 - regress__changelist_EPOLL_debug (Failed)\n\t 35 - regress__SELECT (Failed)\n\t 45 - regress__POLL_debug (Failed)\n"
    },
    "3d0a9d58b6fe29dcb208c3fa244c789449517988___basic_decimal.h": {
        "start": 43,
        "end": 158,
        "buggy": "class ARROW_EXPORT BasicDecimal128 {\n public:\n  /// \\brief Create a BasicDecimal128 from the two's complement representation.\n  constexpr BasicDecimal128(int64_t high, uint64_t low) noexcept\n      : low_bits_(low), high_bits_(high) {}\n\n  /// \\brief Empty constructor creates a BasicDecimal128 with a value of 0.\n  constexpr BasicDecimal128() noexcept : BasicDecimal128(0, 0) {}\n\n  /// \\brief Convert any integer value into a BasicDecimal128.\n  template <typename T,\n            typename = typename std::enable_if<std::is_integral<T>::value, T>::type>\n  constexpr BasicDecimal128(T value) noexcept\n      : BasicDecimal128(static_cast<int64_t>(value) >= 0 ? 0 : -1,\n                        static_cast<uint64_t>(value)) {}\n\n  /// \\brief Create a BasicDecimal128 from an array of bytes. Bytes are assumed to be in\n  /// native-endian byte order.\n  explicit BasicDecimal128(const uint8_t* bytes);\n\n  /// \\brief Negate the current value (in-place)\n  BasicDecimal128& Negate();\n\n  /// \\brief Absolute value (in-place)\n  BasicDecimal128& Abs();\n\n  /// \\brief Absolute value\n  static BasicDecimal128 Abs(const BasicDecimal128& left);\n\n  /// \\brief Add a number to this one. The result is truncated to 128 bits.\n  BasicDecimal128& operator+=(const BasicDecimal128& right);\n\n  /// \\brief Subtract a number from this one. The result is truncated to 128 bits.\n  BasicDecimal128& operator-=(const BasicDecimal128& right);\n\n  /// \\brief Multiply this number by another number. The result is truncated to 128 bits.\n  BasicDecimal128& operator*=(const BasicDecimal128& right);\n\n  /// Divide this number by right and return the result.\n  ///\n  /// This operation is not destructive.\n  /// The answer rounds to zero. Signs work like:\n  ///   21 /  5 ->  4,  1\n  ///  -21 /  5 -> -4, -1\n  ///   21 / -5 -> -4,  1\n  ///  -21 / -5 ->  4, -1\n  /// \\param[in] divisor the number to divide by\n  /// \\param[out] result the quotient\n  /// \\param[out] remainder the remainder after the division\n  DecimalStatus Divide(const BasicDecimal128& divisor, BasicDecimal128* result,\n                       BasicDecimal128* remainder) const;\n\n  /// \\brief In-place division.\n  BasicDecimal128& operator/=(const BasicDecimal128& right);\n\n  /// \\brief Bitwise \"or\" between two BasicDecimal128.\n  BasicDecimal128& operator|=(const BasicDecimal128& right);\n\n  /// \\brief Bitwise \"and\" between two BasicDecimal128.\n  BasicDecimal128& operator&=(const BasicDecimal128& right);\n\n  /// \\brief Shift left by the given number of bits.\n  BasicDecimal128& operator<<=(uint32_t bits);\n\n  /// \\brief Shift right by the given number of bits. Negative values will\n  BasicDecimal128& operator>>=(uint32_t bits);\n\n  /// \\brief Get the high bits of the two's complement representation of the number.\n  inline int64_t high_bits() const { return high_bits_; }\n\n  /// \\brief Get the low bits of the two's complement representation of the number.\n  inline uint64_t low_bits() const { return low_bits_; }\n\n  /// \\brief Return the raw bytes of the value in native-endian byte order.\n  std::array<uint8_t, 16> ToBytes() const;\n  void ToBytes(uint8_t* out) const;\n\n  /// \\brief separate the integer and fractional parts for the given scale.\n  void GetWholeAndFraction(int32_t scale, BasicDecimal128* whole,\n                           BasicDecimal128* fraction) const;\n\n  /// \\brief Scale multiplier for given scale value.\n  static const BasicDecimal128& GetScaleMultiplier(int32_t scale);\n\n  /// \\brief Convert BasicDecimal128 from one scale to another\n  DecimalStatus Rescale(int32_t original_scale, int32_t new_scale,\n                        BasicDecimal128* out) const;\n\n  /// \\brief Scale up.\n  BasicDecimal128 IncreaseScaleBy(int32_t increase_by) const;\n\n  /// \\brief Scale down.\n  /// - If 'round' is true, the right-most digits are dropped and the result value is\n  ///   rounded up (+1 for +ve, -1 for -ve) based on the value of the dropped digits\n  ///   (>= 10^reduce_by / 2).\n  /// - If 'round' is false, the right-most digits are simply dropped.\n  BasicDecimal128 ReduceScaleBy(int32_t reduce_by, bool round = true) const;\n\n  /// \\brief Whether this number fits in the given precision\n  ///\n  /// Return true if the number of significant digits is less or equal to `precision`.\n  bool FitsInPrecision(int32_t precision) const;\n\n  // returns 1 for positive and zero decimal values, -1 for negative decimal values.\n  inline int64_t Sign() const { return 1 | (high_bits_ >> 63); }\n\n  /// \\brief count the number of leading binary zeroes.\n  int32_t CountLeadingBinaryZeros() const;\n\n  /// \\brief Get the maximum valid unscaled decimal value.\n  static const BasicDecimal128& GetMaxValue();\n\n private:\n  uint64_t low_bits_;\n  int64_t high_bits_;\n};\n",
        "fix": null,
        "src_path": "3d0a9d58b6fe29dcb208c3fa244c789449517988___basic_decimal.h",
        "uri": "https://api.github.com/repos/apache/arrow/commits/3d0a9d58b6fe29dcb208c3fa244c789449517988",
        "commit_msg": "ARROW-9671: [C++] Fix a bug in BasicDecimal128 constructor that interprets uint64_t integers with highest bit set as negative.\n\nCloses #7915 from MingyuZhong/bn\n\nLead-authored-by: Mingyu Zhong <myzhong@google.com>\nCo-authored-by: Micah Kornfield <micahk@google.com>\nSigned-off-by: Micah Kornfield <emkornfield@gmail.com>",
        "test_func_diff": [
            {
                "fn": "cpp/src/arrow/util/decimal_test.cc",
                "patch": "@@ -218,8 +218,7 @@ TEST(DecimalZerosTest, NoLeadingZerosDecimalPoint) {\n template <typename T>\n class Decimal128Test : public ::testing::Test {\n  public:\n-  Decimal128Test() : value_(42) {}\n-  const T value_;\n+  Decimal128Test() {}\n };\n \n using Decimal128Types =\n@@ -231,18 +230,29 @@ using Decimal128Types =\n TYPED_TEST_SUITE(Decimal128Test, Decimal128Types);\n \n TYPED_TEST(Decimal128Test, ConstructibleFromAnyIntegerType) {\n-  Decimal128 value(this->value_);\n-  ASSERT_EQ(42, value.low_bits());\n+  Decimal128 value(TypeParam{42});\n+  EXPECT_EQ(42, value.low_bits());\n+  EXPECT_EQ(0, value.high_bits());\n+\n+  Decimal128 max_value(std::numeric_limits<TypeParam>::max());\n+  EXPECT_EQ(std::numeric_limits<TypeParam>::max(), max_value.low_bits());\n+  EXPECT_EQ(0, max_value.high_bits());\n+\n+  Decimal128 min_value(std::numeric_limits<TypeParam>::min());\n+  EXPECT_EQ(std::numeric_limits<TypeParam>::min(), min_value.low_bits());\n+  EXPECT_EQ((std::is_signed<TypeParam>::value ? -1 : 0), min_value.high_bits());\n }\n \n TEST(Decimal128TestTrue, ConstructibleFromBool) {\n   Decimal128 value(true);\n-  ASSERT_EQ(1, value.low_bits());\n+  EXPECT_EQ(1, value.low_bits());\n+  EXPECT_EQ(0, value.high_bits());\n }\n \n TEST(Decimal128TestFalse, ConstructibleFromBool) {\n   Decimal128 value(false);\n-  ASSERT_EQ(0, value.low_bits());\n+  EXPECT_EQ(0, value.low_bits());\n+  EXPECT_EQ(0, value.high_bits());\n }\n \n TEST(Decimal128Test, Division) {"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_3d0a9d58b6fe29dcb208c3fa244c789449517988/build_3d0a9d58b6fe29dcb208c3fa244c789449517988\nTest project /out/apache___arrow/git_repo_dir_3d0a9d58b6fe29dcb208c3fa244c789449517988/build_3d0a9d58b6fe29dcb208c3fa244c789449517988\n    Start 20: arrow-utility-test\n1/1 Test #20: arrow-utility-test ...............***Failed    0.53 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow-tests    =   0.53 sec*proc (1 test)\nunittest       =   0.53 sec*proc (1 test)\n\nTotal Test time (real) =   0.54 sec\n\nThe following tests FAILED:\n\t 20 - arrow-utility-test (Failed)\n"
    },
    "c4f8436e2532524c2a2f9cc26f73c6b7dfababaa___compare.cc": {
        "start": 49,
        "end": 119,
        "buggy": "namespace arrow {\n\nusing internal::BitmapEquals;\nusing internal::checked_cast;\n\n// ----------------------------------------------------------------------\n// Public method implementations\n\nnamespace {\n\n// These helper functions assume we already checked the arrays have equal\n// sizes and null bitmaps.\n\ntemplate <typename ArrowType, typename EqualityFunc>\ninline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n                               const NumericArray<ArrowType>& right,\n                               EqualityFunc&& equals) {\n  using T = typename ArrowType::c_type;\n\n  const T* left_data = left.raw_values();\n  const T* right_data = right.raw_values();\n\n  if (left.null_count() > 0) {\n    for (int64_t i = 0; i < left.length(); ++i) {\n      if (left.IsNull(i)) continue;\n      if (!equals(left_data[i], right_data[i])) {\n        return false;\n      }\n    }\n  } else {\n    for (int64_t i = 0; i < left.length(); ++i) {\n      if (!equals(left_data[i], right_data[i])) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\ntemplate <typename ArrowType>\ninline bool FloatingEquals(const NumericArray<ArrowType>& left,\n                           const NumericArray<ArrowType>& right,\n                           const EqualOptions& opts) {\n  using T = typename ArrowType::c_type;\n\n  if (opts.nans_equal()) {\n    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n      return (x == y) || (std::isnan(x) && std::isnan(y));\n    });\n  } else {\n    return BaseFloatingEquals<ArrowType>(left, right,\n                                         [](T x, T y) -> bool { return x == y; });\n  }\n}\n\ntemplate <typename ArrowType>\ninline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n                                 const NumericArray<ArrowType>& right,\n                                 const EqualOptions& opts) {\n  using T = typename ArrowType::c_type;\n  const T epsilon = static_cast<T>(opts.atol());\n\n  if (opts.nans_equal()) {\n    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n      return (fabs(x - y) <= epsilon) || (std::isnan(x) && std::isnan(y));\n    });\n  } else {\n    return BaseFloatingEquals<ArrowType>(\n        left, right, [epsilon](T x, T y) -> bool { return fabs(x - y) <= epsilon; });\n  }\n}\n",
        "fix": null,
        "src_path": "c4f8436e2532524c2a2f9cc26f73c6b7dfababaa___compare.cc",
        "uri": "https://api.github.com/repos/apache/arrow/commits/c4f8436e2532524c2a2f9cc26f73c6b7dfababaa",
        "commit_msg": "ARROW-9495: [C++] Equality assertions don't handle Inf / -Inf properly\n\nSee https://issues.apache.org/jira/browse/ARROW-9495\n\nCloses #7826 from liyafan82/fly_0724_eq\n\nAuthored-by: liyafan82 <fan_li_ya@foxmail.com>\nSigned-off-by: Antoine Pitrou <antoine@python.org>",
        "test_func_diff": [
            {
                "fn": "cpp/src/arrow/array/array_test.cc",
                "patch": "@@ -1501,7 +1501,7 @@ void CheckFloatingNanEquality() {\n \n   // NaN != non-NaN\n   ArrayFromVector<TYPE>(type, {false, true}, {0.5, nan_value}, &a);\n-  ArrayFromVector<TYPE>(type, {false, true}, {0.5, 0.0}, &a);\n+  ArrayFromVector<TYPE>(type, {false, true}, {0.5, 0.0}, &b);\n   ASSERT_FALSE(a->Equals(b));\n   ASSERT_FALSE(b->Equals(a));\n   ASSERT_FALSE(a->Equals(b, EqualOptions().nans_equal(true)));\n@@ -1520,6 +1520,73 @@ void CheckFloatingNanEquality() {\n   ASSERT_TRUE(b->RangeEquals(a, 0, 1, 0));\n }\n \n+template <typename TYPE>\n+void CheckFloatingInfinityEquality() {\n+  std::shared_ptr<Array> a, b;\n+  std::shared_ptr<DataType> type = TypeTraits<TYPE>::type_singleton();\n+\n+  const auto infinity = std::numeric_limits<typename TYPE::c_type>::infinity();\n+\n+  for (auto nans_equal : {false, true}) {\n+    // Infinity in a null entry\n+    ArrayFromVector<TYPE>(type, {true, false}, {0.5, infinity}, &a);\n+    ArrayFromVector<TYPE>(type, {true, false}, {0.5, -infinity}, &b);\n+    ASSERT_TRUE(a->Equals(b));\n+    ASSERT_TRUE(b->Equals(a));\n+    ASSERT_TRUE(a->ApproxEquals(b, EqualOptions().atol(1e-5).nans_equal(nans_equal)));\n+    ASSERT_TRUE(b->ApproxEquals(a, EqualOptions().atol(1e-5).nans_equal(nans_equal)));\n+    ASSERT_TRUE(a->RangeEquals(b, 0, 2, 0));\n+    ASSERT_TRUE(b->RangeEquals(a, 0, 2, 0));\n+    ASSERT_TRUE(a->RangeEquals(b, 1, 2, 1));\n+    ASSERT_TRUE(b->RangeEquals(a, 1, 2, 1));\n+\n+    // Infinity in a valid entry\n+    ArrayFromVector<TYPE>(type, {false, true}, {0.5, infinity}, &a);\n+    ArrayFromVector<TYPE>(type, {false, true}, {0.5, infinity}, &b);\n+    ASSERT_TRUE(a->Equals(b));\n+    ASSERT_TRUE(b->Equals(a));\n+    ASSERT_TRUE(a->ApproxEquals(b, EqualOptions().atol(1e-5).nans_equal(nans_equal)));\n+    ASSERT_TRUE(b->ApproxEquals(a, EqualOptions().atol(1e-5).nans_equal(nans_equal)));\n+    ASSERT_TRUE(a->ApproxEquals(b, EqualOptions().atol(1e-5).nans_equal(nans_equal)));\n+    ASSERT_TRUE(b->ApproxEquals(a, EqualOptions().atol(1e-5).nans_equal(nans_equal)));\n+    // Infinity in tested range\n+    ASSERT_TRUE(a->RangeEquals(b, 0, 2, 0));\n+    ASSERT_TRUE(b->RangeEquals(a, 0, 2, 0));\n+    ASSERT_TRUE(a->RangeEquals(b, 1, 2, 1));\n+    ASSERT_TRUE(b->RangeEquals(a, 1, 2, 1));\n+    // Infinity not in tested range\n+    ASSERT_TRUE(a->RangeEquals(b, 0, 1, 0));\n+    ASSERT_TRUE(b->RangeEquals(a, 0, 1, 0));\n+\n+    // Infinity != non-infinity\n+    ArrayFromVector<TYPE>(type, {false, true}, {0.5, -infinity}, &a);\n+    ArrayFromVector<TYPE>(type, {false, true}, {0.5, 0.0}, &b);\n+    ASSERT_FALSE(a->Equals(b));\n+    ASSERT_FALSE(b->Equals(a));\n+    ASSERT_FALSE(a->ApproxEquals(b, EqualOptions().atol(1e-5).nans_equal(nans_equal)));\n+    ASSERT_FALSE(b->ApproxEquals(a));\n+    ASSERT_FALSE(a->ApproxEquals(b, EqualOptions().atol(1e-5).nans_equal(nans_equal)));\n+    ASSERT_FALSE(b->ApproxEquals(a, EqualOptions().atol(1e-5).nans_equal(nans_equal)));\n+    // Infinity != Negative infinity\n+    ArrayFromVector<TYPE>(type, {true, true}, {0.5, -infinity}, &a);\n+    ArrayFromVector<TYPE>(type, {true, true}, {0.5, infinity}, &b);\n+    ASSERT_FALSE(a->Equals(b));\n+    ASSERT_FALSE(b->Equals(a));\n+    ASSERT_FALSE(a->ApproxEquals(b));\n+    ASSERT_FALSE(b->ApproxEquals(a));\n+    ASSERT_FALSE(a->ApproxEquals(b, EqualOptions().atol(1e-5).nans_equal(nans_equal)));\n+    ASSERT_FALSE(b->ApproxEquals(a, EqualOptions().atol(1e-5).nans_equal(nans_equal)));\n+    // Infinity in tested range\n+    ASSERT_FALSE(a->RangeEquals(b, 0, 2, 0));\n+    ASSERT_FALSE(b->RangeEquals(a, 0, 2, 0));\n+    ASSERT_FALSE(a->RangeEquals(b, 1, 2, 1));\n+    ASSERT_FALSE(b->RangeEquals(a, 1, 2, 1));\n+    // Infinity not in tested range\n+    ASSERT_TRUE(a->RangeEquals(b, 0, 1, 0));\n+    ASSERT_TRUE(b->RangeEquals(a, 0, 1, 0));\n+  }\n+}\n+\n TEST(TestPrimitiveAdHoc, FloatingApproxEquals) {\n   CheckApproxEquals<FloatType>();\n   CheckApproxEquals<DoubleType>();\n@@ -1535,6 +1602,11 @@ TEST(TestPrimitiveAdHoc, FloatingNanEquality) {\n   CheckFloatingNanEquality<DoubleType>();\n }\n \n+TEST(TestPrimitiveAdHoc, FloatingInfinityEquality) {\n+  CheckFloatingInfinityEquality<FloatType>();\n+  CheckFloatingInfinityEquality<DoubleType>();\n+}\n+\n // ----------------------------------------------------------------------\n // FixedSizeBinary tests\n "
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_c4f8436e2532524c2a2f9cc26f73c6b7dfababaa/build_c4f8436e2532524c2a2f9cc26f73c6b7dfababaa\nTest project /out/apache___arrow/git_repo_dir_c4f8436e2532524c2a2f9cc26f73c6b7dfababaa/build_c4f8436e2532524c2a2f9cc26f73c6b7dfababaa\n    Start 1: arrow-array-test\n1/1 Test #1: arrow-array-test .................***Failed    6.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow-tests    =   6.02 sec*proc (1 test)\nunittest       =   6.02 sec*proc (1 test)\n\nTotal Test time (real) =   6.03 sec\n\nThe following tests FAILED:\n\t  1 - arrow-array-test (Failed)\n"
    },
    "48a36c72e4d358ed9f0a5e53fe775a7ebb2f8f2b___folding_rules.cpp": {
        "start": 2304,
        "end": 2429,
        "buggy": "FoldingRule VectorShuffleFeedingShuffle() {\n  return [](IRContext* context, Instruction* inst,\n            const std::vector<const analysis::Constant*>&) {\n    assert(inst->opcode() == SpvOpVectorShuffle &&\n           \"Wrong opcode.  Should be OpVectorShuffle.\");\n\n    analysis::DefUseManager* def_use_mgr = context->get_def_use_mgr();\n    analysis::TypeManager* type_mgr = context->get_type_mgr();\n\n    Instruction* feeding_shuffle_inst =\n        def_use_mgr->GetDef(inst->GetSingleWordInOperand(0));\n    analysis::Vector* op0_type =\n        type_mgr->GetType(feeding_shuffle_inst->type_id())->AsVector();\n    uint32_t op0_length = op0_type->element_count();\n\n    bool feeder_is_op0 = true;\n    if (feeding_shuffle_inst->opcode() != SpvOpVectorShuffle) {\n      feeding_shuffle_inst =\n          def_use_mgr->GetDef(inst->GetSingleWordInOperand(1));\n      feeder_is_op0 = false;\n    }\n\n    if (feeding_shuffle_inst->opcode() != SpvOpVectorShuffle) {\n      return false;\n    }\n\n    Instruction* feeder2 =\n        def_use_mgr->GetDef(feeding_shuffle_inst->GetSingleWordInOperand(0));\n    analysis::Vector* feeder_op0_type =\n        type_mgr->GetType(feeder2->type_id())->AsVector();\n    uint32_t feeder_op0_length = feeder_op0_type->element_count();\n\n    uint32_t new_feeder_id = 0;\n    std::vector<Operand> new_operands;\n    new_operands.resize(\n        2, {SPV_OPERAND_TYPE_ID, {0}});  // Place holders for vector operands.\n    const uint32_t undef_literal = 0xffffffff;\n    for (uint32_t op = 2; op < inst->NumInOperands(); ++op) {\n      uint32_t component_index = inst->GetSingleWordInOperand(op);\n\n      // Do not interpret the undefined value literal as coming from operand 1.\n      if (component_index != undef_literal &&\n          feeder_is_op0 == (component_index < op0_length)) {\n        // This component comes from the feeding_shuffle_inst.  Update\n        // |component_index| to be the index into the operand of the feeder.\n\n        // Adjust component_index to get the index into the operands of the\n        // feeding_shuffle_inst.\n        if (component_index >= op0_length) {\n          component_index -= op0_length;\n        }\n        component_index =\n            feeding_shuffle_inst->GetSingleWordInOperand(component_index + 2);\n\n        // Check if we are using a component from the first or second operand of\n        // the feeding instruction.\n        if (component_index < feeder_op0_length) {\n          if (new_feeder_id == 0) {\n            // First time through, save the id of the operand the element comes\n            // from.\n            new_feeder_id = feeding_shuffle_inst->GetSingleWordInOperand(0);\n          } else if (new_feeder_id !=\n                     feeding_shuffle_inst->GetSingleWordInOperand(0)) {\n            // We need both elements of the feeding_shuffle_inst, so we cannot\n            // fold.\n            return false;\n          }\n        } else {\n          if (new_feeder_id == 0) {\n            // First time through, save the id of the operand the element comes\n            // from.\n            new_feeder_id = feeding_shuffle_inst->GetSingleWordInOperand(1);\n          } else if (new_feeder_id !=\n                     feeding_shuffle_inst->GetSingleWordInOperand(1)) {\n            // We need both elements of the feeding_shuffle_inst, so we cannot\n            // fold.\n            return false;\n          }\n          component_index -= feeder_op0_length;\n        }\n\n        if (!feeder_is_op0) {\n          component_index += op0_length;\n        }\n      }\n      new_operands.push_back(\n          {SPV_OPERAND_TYPE_LITERAL_INTEGER, {component_index}});\n    }\n\n    if (new_feeder_id == 0) {\n      analysis::ConstantManager* const_mgr = context->get_constant_mgr();\n      const analysis::Type* type =\n          type_mgr->GetType(feeding_shuffle_inst->type_id());\n      const analysis::Constant* null_const = const_mgr->GetConstant(type, {});\n      new_feeder_id =\n          const_mgr->GetDefiningInstruction(null_const, 0)->result_id();\n    }\n\n    if (feeder_is_op0) {\n      // If the size of the first vector operand changed then the indices\n      // referring to the second operand need to be adjusted.\n      Instruction* new_feeder_inst = def_use_mgr->GetDef(new_feeder_id);\n      analysis::Type* new_feeder_type =\n          type_mgr->GetType(new_feeder_inst->type_id());\n      uint32_t new_op0_size = new_feeder_type->AsVector()->element_count();\n      int32_t adjustment = op0_length - new_op0_size;\n\n      if (adjustment != 0) {\n        for (uint32_t i = 2; i < new_operands.size(); i++) {\n          if (inst->GetSingleWordInOperand(i) >= op0_length) {\n            new_operands[i].words[0] -= adjustment;\n          }\n        }\n      }\n\n      new_operands[0].words[0] = new_feeder_id;\n      new_operands[1] = inst->GetInOperand(1);\n    } else {\n      new_operands[1].words[0] = new_feeder_id;\n      new_operands[0] = inst->GetInOperand(0);\n    }\n\n    inst->SetInOperands(std::move(new_operands));\n    return true;\n  };\n}\n",
        "fix": null,
        "src_path": "48a36c72e4d358ed9f0a5e53fe775a7ebb2f8f2b___folding_rules.cpp",
        "uri": "https://api.github.com/repos/KhronosGroup/SPIRV-Tools/commits/48a36c72e4d358ed9f0a5e53fe775a7ebb2f8f2b",
        "commit_msg": "Better handling of 0xFFFFFFFF when folding vector shuffle (#4743)\n\nWhen folding a vector shuffle feeding a vector shuffle, we do not\r\npropagate an 0xFFFFFFFF, which has a special meaning, correctly.  We\r\nadjust the value making it lose it meaning as an undefined value.\r\n\r\nFixes #4581",
        "test_func_diff": [
            {
                "fn": "test/opt/fold_test.cpp",
                "patch": "@@ -7087,6 +7087,27 @@ ::testing::Values(\n         3, true)\n ));\n \n+INSTANTIATE_TEST_SUITE_P(VectorShuffleMatchingTest, MatchingInstructionFoldingTest,\n+::testing::Values(\n+    // Test case 0: Using OpDot to extract last element.\n+    InstructionFoldingCase<bool>(\n+        Header() +\n+            \"; CHECK: [[int:%\\\\w+]] = OpTypeInt 32 1\\n\" +\n+            \"; CHECK: [[v2int:%\\\\w+]] = OpTypeVector [[int]] 2{{[[:space:]]}}\\n\" +\n+            \"; CHECK: [[null:%\\\\w+]] = OpConstantNull [[v2int]]\\n\" +\n+            \"; CHECK: OpVectorShuffle\\n\" +\n+            \"; CHECK: %3 = OpVectorShuffle [[v2int]] [[null]] {{%\\\\w+}} 4294967295 2\\n\" +\n+            \"%main = OpFunction %void None %void_func\\n\" +\n+            \"%main_lab = OpLabel\\n\" +\n+            \"%n = OpVariable %_ptr_int Function\\n\" +\n+            \"%load = OpLoad %int %n\\n\" +\n+            \"%2 = OpVectorShuffle %v2int %v2int_null %v2int_2_3 3 0xFFFFFFFF \\n\" +\n+            \"%3 = OpVectorShuffle %v2int %2 %v2int_2_3 1 2 \\n\" +\n+            \"OpReturn\\n\" +\n+            \"OpFunctionEnd\",\n+        3, true)\n+ ));\n+\n using MatchingInstructionWithNoResultFoldingTest =\n ::testing::TestWithParam<InstructionFoldingCase<bool>>;\n "
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_48a36c72e4d358ed9f0a5e53fe775a7ebb2f8f2b/build_48a36c72e4d358ed9f0a5e53fe775a7ebb2f8f2b\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_48a36c72e4d358ed9f0a5e53fe775a7ebb2f8f2b/build_48a36c72e4d358ed9f0a5e53fe775a7ebb2f8f2b\n    Start 18: spirv-tools-test_opt\n1/2 Test #18: spirv-tools-test_opt .............***Exception: SegFault 43.52 sec\n    Start 20: spirv-tools-test_opt_loops\n2/2 Test #20: spirv-tools-test_opt_loops .......   Passed    5.09 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  48.62 sec\n\nThe following tests FAILED:\n\t 18 - spirv-tools-test_opt (SEGFAULT)\n"
    },
    "452c17abfd19fdefff52d3f3d4e2b76af809c93d___decode.c": {
        "start": 1589,
        "end": 1786,
        "buggy": "static bool\ndecode_modrm(decode_info_t *di, byte optype, opnd_size_t opsize, opnd_t *reg_opnd,\n             opnd_t *rm_opnd)\n{\n    /* for x64, addr prefix affects only base/index and truncates final addr:\n     * modrm + sib table is the same\n     */\n    bool addr16 = !X64_MODE(di) && TEST(PREFIX_ADDR, di->prefixes);\n\n    if (reg_opnd != NULL) {\n        reg_id_t reg = decode_reg(DECODE_REG_REG, di, optype, opsize);\n        if (reg == REG_NULL)\n            return false;\n        *reg_opnd = opnd_create_reg(reg);\n        opnd_set_size(reg_opnd, resolve_variable_size(di, opsize, true /*is reg*/));\n    }\n\n    if (rm_opnd != NULL) {\n        reg_id_t base_reg = REG_NULL;\n        int disp = 0;\n        reg_id_t index_reg = REG_NULL;\n        int scale = 0;\n        char memtype = (optype == TYPE_VSIB ? TYPE_VSIB : TYPE_M);\n        opnd_size_t memsize = resolve_addr_size(di);\n        bool encode_zero_disp, force_full_disp;\n        if (di->has_disp)\n            disp = di->disp;\n        else\n            disp = 0;\n        if (di->has_sib) {\n            CLIENT_ASSERT(!addr16, \"decode error: x86 addr16 cannot have a SIB byte\");\n            if (di->index == 4 &&\n                /* rex.x enables r12 as index */\n                (!X64_MODE(di) || !TEST(PREFIX_REX_X, di->prefixes)) &&\n                optype != TYPE_VSIB) {\n                /* no scale/index */\n                index_reg = REG_NULL;\n            } else {\n                index_reg = decode_reg(DECODE_REG_INDEX, di, memtype, memsize);\n                if (index_reg == REG_NULL) {\n                    CLIENT_ASSERT(false, \"decode error: !index: internal modrm error\");\n                    return false;\n                }\n                if (di->scale == 0)\n                    scale = 1;\n                else if (di->scale == 1)\n                    scale = 2;\n                else if (di->scale == 2)\n                    scale = 4;\n                else if (di->scale == 3)\n                    scale = 8;\n            }\n            if (di->base == 5 && di->mod == 0) {\n                /* no base */\n                base_reg = REG_NULL;\n            } else {\n                base_reg = decode_reg(DECODE_REG_BASE, di, TYPE_M, memsize);\n                if (base_reg == REG_NULL) {\n                    CLIENT_ASSERT(false, \"decode error: internal modrm decode error\");\n                    return false;\n                }\n            }\n        } else {\n            if (optype == TYPE_VSIB)\n                return false; /* invalid w/o vsib byte */\n            if ((!addr16 && di->mod == 0 && di->rm == 5) ||\n                (addr16 && di->mod == 0 && di->rm == 6)) {\n                /* just absolute displacement, or rip-relative for x64 */\n#ifdef X64\n                if (X64_MODE(di)) {\n                    /* rip-relative: convert from relative offset to absolute target pc */\n                    byte *addr;\n                    CLIENT_ASSERT(di->start_pc != NULL,\n                                  \"internal decode error: start pc not set\");\n                    if (di->orig_pc != di->start_pc)\n                        addr = di->orig_pc + di->len + di->disp;\n                    else\n                        addr = di->start_pc + di->len + di->disp;\n                    if (TEST(PREFIX_ADDR, di->prefixes)) {\n                        /* Need to clear upper 32 bits.\n                         * Debuggers do not display this truncation, though\n                         * both Intel and AMD manuals describe it.\n                         * I did verify it w/ actual execution.\n                         */\n                        ASSERT_NOT_TESTED();\n                        addr = (byte *)((ptr_uint_t)addr & 0xffffffff);\n                    }\n                    *rm_opnd = opnd_create_far_rel_addr(\n                        di->seg_override, (void *)addr,\n                        resolve_variable_size(di, opsize, false));\n                    return true;\n                } else\n#endif\n                    base_reg = REG_NULL;\n                index_reg = REG_NULL;\n            } else if (di->mod == 3) {\n                /* register */\n                reg_id_t rm_reg = decode_reg(DECODE_REG_RM, di, optype, opsize);\n                if (rm_reg == REG_NULL) /* no assert since happens, e.g., ff d9 */\n                    return false;\n                else {\n                    *rm_opnd = opnd_create_reg(rm_reg);\n                    opnd_set_size(rm_opnd,\n                                  resolve_variable_size(di, opsize, true /*is reg*/));\n                    return true;\n                }\n            } else {\n                /* non-sib reg-based memory address */\n                if (addr16) {\n                    /* funny order requiring custom decode */\n                    switch (di->rm) {\n                    case 0:\n                        base_reg = REG_BX;\n                        index_reg = REG_SI;\n                        scale = 1;\n                        break;\n                    case 1:\n                        base_reg = REG_BX;\n                        index_reg = REG_DI;\n                        scale = 1;\n                        break;\n                    case 2:\n                        base_reg = REG_BP;\n                        index_reg = REG_SI;\n                        scale = 1;\n                        break;\n                    case 3:\n                        base_reg = REG_BP;\n                        index_reg = REG_DI;\n                        scale = 1;\n                        break;\n                    case 4: base_reg = REG_SI; break;\n                    case 5: base_reg = REG_DI; break;\n                    case 6:\n                        base_reg = REG_BP;\n                        CLIENT_ASSERT(di->mod != 0,\n                                      \"decode error: %bp cannot have mod 0\");\n                        break;\n                    case 7: base_reg = REG_BX; break;\n                    default:\n                        CLIENT_ASSERT(false, \"decode error: unknown modrm rm\");\n                        break;\n                    }\n                } else {\n                    /* single base reg */\n                    base_reg = decode_reg(DECODE_REG_RM, di, memtype, memsize);\n                    if (base_reg == REG_NULL) {\n                        CLIENT_ASSERT(false,\n                                      \"decode error: !base: internal modrm decode error\");\n                        return false;\n                    }\n                }\n            }\n        }\n        /* We go ahead and preserve the force bools if the original really had a 0\n         * disp; up to user to unset bools when changing disp value (FIXME: should\n         * we auto-unset on first mod?)\n         */\n        encode_zero_disp = di->has_disp && disp == 0 &&\n            /* there is no bp base without a disp */\n            (!addr16 || base_reg != REG_BP);\n        /* With evex encoding, disp8 is subject to compression and a scale factor.\n         * Hence, displacments not divisible by the scale factor need to be encoded\n         * with full displacement, no need (and actually incorrect) to \"force\" it.\n         */\n        bool needs_full_disp = false;\n        int compressed_disp_scale = 0;\n        if (di->evex_encoded) {\n            compressed_disp_scale = decode_get_compressed_disp_scale(di);\n            if (compressed_disp_scale == -1)\n                return false;\n            needs_full_disp = disp % compressed_disp_scale != 0;\n        }\n        force_full_disp = !needs_full_disp && di->has_disp && disp >= INT8_MIN &&\n            disp <= INT8_MAX && di->mod == 2;\n        if (di->seg_override != REG_NULL) {\n            *rm_opnd = opnd_create_far_base_disp_ex(\n                di->seg_override, base_reg, index_reg, scale, disp,\n                resolve_variable_size(di, opsize, false), encode_zero_disp,\n                force_full_disp, TEST(PREFIX_ADDR, di->prefixes));\n        } else {\n            /* Note that OP_{jmp,call}_far_ind does NOT have a far base disp\n             * operand: it is a regular base disp containing 6 bytes that\n             * specify a segment selector and address.  The opcode must be\n             * examined to know how to interpret those 6 bytes.\n             */\n            if (di->evex_encoded) {\n                if (di->mod == 1)\n                    disp *= compressed_disp_scale;\n            }\n            *rm_opnd = opnd_create_base_disp_ex(base_reg, index_reg, scale, disp,\n                                                resolve_variable_size(di, opsize, false),\n                                                encode_zero_disp, force_full_disp,\n                                                TEST(PREFIX_ADDR, di->prefixes));\n        }\n    }\n    return true;\n}\n",
        "fix": null,
        "src_path": "452c17abfd19fdefff52d3f3d4e2b76af809c93d___decode.c",
        "uri": "https://api.github.com/repos/DynamoRIO/dynamorio/commits/452c17abfd19fdefff52d3f3d4e2b76af809c93d",
        "commit_msg": "i#5644 Apply EVEX compressed disp when segment prefixes are present (#5647)\n\nThe current behavior is simply a bug, the compressed displacement\r\nadjustment needs to be performed whether segment prefixes are present\r\nor not.\r\n\r\nFixes #5644",
        "test_func_diff": [
            {
                "fn": "suite/tests/api/ir_x86.c",
                "patch": "@@ -2707,6 +2707,27 @@ test_simd_zeroes_upper(void *dc)\n     instr_destroy(dc, instr);\n }\n \n+static void\n+test_evex_compressed_disp_with_segment_prefix(void *dc)\n+{\n+#ifdef X64\n+    byte *pc;\n+    const byte b[] = { 0x2e, 0x67, 0x62, 0x01, 0xc5, 0x00, 0xc4, 0x62, 0x21, 0x00 };\n+    char dbuf[512];\n+    int len;\n+\n+    pc =\n+        disassemble_to_buffer(dc, (byte *)b, (byte *)b, false /*no pc*/,\n+                              false /*no bytes*/, dbuf, BUFFER_SIZE_ELEMENTS(dbuf), &len);\n+    ASSERT(pc == &b[0] + sizeof(b));\n+    ASSERT(\n+        strcmp(\n+            dbuf,\n+            \"addr32 vpinsrw %xmm23[14byte] %cs:0x42(%r10d)[2byte] $0x00 -> %xmm28\\n\") ==\n+        0);\n+#endif\n+}\n+\n int\n main(int argc, char *argv[])\n {\n@@ -2794,6 +2815,8 @@ main(int argc, char *argv[])\n \n     test_simd_zeroes_upper(dcontext);\n \n+    test_evex_compressed_disp_with_segment_prefix(dcontext);\n+\n #ifndef STANDALONE_DECODER /* speed up compilation */\n     test_all_opcodes_2_avx512_vex(dcontext);\n     test_all_opcodes_3_avx512_vex(dcontext);"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/DynamoRIO___dynamorio/git_repo_dir_452c17abfd19fdefff52d3f3d4e2b76af809c93d/build_452c17abfd19fdefff52d3f3d4e2b76af809c93d\nTest project /out/DynamoRIO___dynamorio/git_repo_dir_452c17abfd19fdefff52d3f3d4e2b76af809c93d/build_452c17abfd19fdefff52d3f3d4e2b76af809c93d\n    Start 367: code_api|api.ir\n1/3 Test #367: code_api|api.ir ..................***Failed  Required regular expression not found. Regex=[^(<Invalid VSIB register encoding encountered>\n<Invalid AVX-512 vector length encountered.>\n)?(<Application .*api\\.ir.*AVX-512 was detected at PC 0x[0-9a-f]+. AVX-512 is not fully supported yet.>\n)?all done\n$\n]  0.03 sec\n    Start 368: code_api|api.ir-static\n2/3 Test #368: code_api|api.ir-static ...........***Failed  Required regular expression not found. Regex=[^(<Invalid VSIB register encoding encountered>\n<Invalid AVX-512 vector length encountered.>\n)?(<Application .*api\\.ir.*AVX-512 was detected at PC 0x[0-9a-f]+. AVX-512 is not fully supported yet.>\n)?all done\n$\n]  0.24 sec\n    Start 384: code_api|api.ibl-stress\n3/3 Test #384: code_api|api.ibl-stress ..........   Passed    1.51 sec\n\n33% tests passed, 2 tests failed out of 3\n\nTotal Test time (real) =   1.94 sec\n\nThe following tests FAILED:\n\t367 - code_api|api.ir (Failed)\n\t368 - code_api|api.ir-static (Failed)\n"
    },
    "0c3518e84b668975df03ac8b9620d7bf181bd349___SimplifyCFG.cpp": {
        "start": 1438,
        "end": 1470,
        "buggy": "static Value *isSafeToSpeculateStore(Instruction *I, BasicBlock *BrBB,\n                                     BasicBlock *StoreBB, BasicBlock *EndBB) {\n  StoreInst *StoreToHoist = dyn_cast<StoreInst>(I);\n  if (!StoreToHoist)\n    return nullptr;\n\n  // Volatile or atomic.\n  if (!StoreToHoist->isSimple())\n    return nullptr;\n\n  Value *StorePtr = StoreToHoist->getPointerOperand();\n\n  // Look for a store to the same pointer in BrBB.\n  unsigned MaxNumInstToLookAt = 10;\n  for (BasicBlock::reverse_iterator RI = BrBB->rbegin(),\n       RE = BrBB->rend(); RI != RE && (--MaxNumInstToLookAt); ++RI) {\n    Instruction *CurI = &*RI;\n\n    // Could be calling an instruction that effects memory like free().\n    if (CurI->mayHaveSideEffects() && !isa<StoreInst>(CurI))\n      return nullptr;\n\n    StoreInst *SI = dyn_cast<StoreInst>(CurI);\n    // Found the previous store make sure it stores to the same location.\n    if (SI && SI->getPointerOperand() == StorePtr)\n      // Found the previous store, return its value operand.\n      return SI->getValueOperand();\n    else if (SI)\n      return nullptr; // Unknown store.\n  }\n\n  return nullptr;\n}\n",
        "fix": null,
        "src_path": "0c3518e84b668975df03ac8b9620d7bf181bd349___SimplifyCFG.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/0c3518e84b668975df03ac8b9620d7bf181bd349",
        "commit_msg": "[SimplifyCFG] isSafeToSpeculateStore now ignores debug info\n\nThis patch fixes PR27615.\n\n@llvm.dbg.value instructions no longer count towards the maximum number of\ninstructions to look back at in the instruction list when searching for a\nstore instruction. This should make the output consistent between debug and\nnon-debug build.\n\nPatch by Henric Karlsson <henric.karlsson@ericsson.com>!\n\nDifferential Revision: http://reviews.llvm.org/D19912\n\nllvm-svn: 268512",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/SimplifyCFG/PR27615-simplify-cond-br.ll",
                "patch": "@@ -0,0 +1,68 @@\n+; RUN: opt -S -simplifycfg -strip-debug < %s | FileCheck %s\n+; RUN: opt -S -simplifycfg < %s | FileCheck %s\n+\n+; Test case for BUG-27615\n+; Test that simplify cond branch produce same result for debug and non-debug builds\n+; CHECK: select i1 %or.cond, i32 -1, i32 5\n+; CHECK-NOT: bb1:\n+\n+; ModuleID = './csmith107.i.debug.ll'\n+source_filename = \"./csmith107.i.debug.ll\"\n+\n+@a = global i16 0\n+@b = global i32 0\n+@c = global i16* null\n+\n+\n+; Function Attrs: nounwind\n+define i16 @fn1() #3 !dbg !15 {\n+bb2:\n+  store i32 -1, i32* @b, align 1\n+  %_tmp1.pre = load i16, i16* @a, align 1, !dbg !19\n+  %_tmp2.pre = load i16*, i16** @c, align 1\n+  tail call void @llvm.dbg.value(metadata i16 6, i64 0, metadata !22, metadata !23), !dbg !24\n+  tail call void @llvm.dbg.value(metadata i16 %_tmp1.pre, i64 0, metadata !25, metadata !23), !dbg !19\n+  %_tmp3 = load i16, i16* %_tmp2.pre, align 1\n+  %_tmp4 = icmp ne i16 %_tmp3, 0\n+  %_tmp6 = icmp ne i16 %_tmp1.pre, 0\n+  %or.cond = and i1 %_tmp6, %_tmp4\n+  br i1 %or.cond, label %bb5, label %bb1\n+\n+bb1:                                              ; preds = %bb2\n+  store i32 5, i32* @b, align 1\n+  br label %bb5\n+\n+bb5:                                              ; preds = %bb1, %bb2\n+  ret i16 0\n+}\n+\n+; Function Attrs: nounwind readnone\n+declare void @llvm.dbg.value(metadata, i64, metadata, metadata) #4\n+\n+!llvm.dbg.cu = !{!0}\n+!llvm.module.flags = !{!12, !13}\n+\n+!0 = distinct !DICompileUnit(language: DW_LANG_C, file: !1, producer: \"FlexC Compiler v6.36 (LLVM)\", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, retainedTypes: !2, globals: !3)\n+!1 = !DIFile(filename: \"csmith107.i.c\", directory: \"/tmp\")\n+!2 = !{}\n+!3 = !{!4, !6, !10}\n+!4 = !DIGlobalVariable(name: \"a\", scope: null, file: !1, line: 2, type: !5, isLocal: false, isDefinition: true, variable: i16* @a)\n+!5 = !DIBasicType(name: \"int\", size: 16, align: 16, encoding: DW_ATE_signed)\n+!6 = !DIGlobalVariable(name: \"b\", scope: null, file: !1, line: 3, type: !7, isLocal: false, isDefinition: true, variable: i32* @b)\n+!7 = !DIDerivedType(tag: DW_TAG_typedef, name: \"uint32_t\", file: !1, line: 1, baseType: !8)\n+!8 = !DIDerivedType(tag: DW_TAG_typedef, name: \"__u32_t\", file: !1, baseType: !9)\n+!9 = !DIBasicType(name: \"unsigned long\", size: 32, align: 16, encoding: DW_ATE_unsigned)\n+!10 = !DIGlobalVariable(name: \"c\", scope: null, file: !1, line: 4, type: !11, isLocal: false, isDefinition: true, variable: i16** @c)\n+!11 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !5, size: 16, align: 16)\n+!12 = !{i32 2, !\"Dwarf Version\", i32 4}\n+!13 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!15 = distinct !DISubprogram(name: \"fn1\", scope: !1, file: !1, line: 5, type: !16, isLocal: false, isDefinition: true, scopeLine: 5, isOptimized: false, unit: !0, variables: !2)\n+!16 = !DISubroutineType(types: !17)\n+!17 = !{!5}\n+!19 = !DILocation(line: 8, column: 16, scope: !20)\n+!20 = !DILexicalBlock(scope: !15, file: !1, line: 7, column: 29)\n+!22 = !DILocalVariable(name: \"d\", scope: !20, line: 8, type: !5)\n+!23 = !DIExpression()\n+!24 = !DILocation(line: 8, column: 9, scope: !20)\n+!25 = !DILocalVariable(name: \"e\", scope: !20, line: 8, type: !5)\n+"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/SimplifyCFG/PR27615-simplify-cond-br.ll (1 of 1)\nTesting Time: 0.19s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/SimplifyCFG/PR27615-simplify-cond-br.ll\n\n  Unexpected Failures: 1\n"
    },
    "7aa34c8cbb7f81737666d08217769d6ef81181d5___DwarfUnit.cpp": {
        "start": 1363,
        "end": 1458,
        "buggy": "void DwarfUnit::constructMemberDIE(DIE &Buffer, const DIDerivedType *DT) {\n  DIE &MemberDie = createAndAddDIE(DT->getTag(), Buffer);\n  StringRef Name = DT->getName();\n  if (!Name.empty())\n    addString(MemberDie, dwarf::DW_AT_name, Name);\n\n  addType(MemberDie, resolve(DT->getBaseType()));\n\n  addSourceLine(MemberDie, DT);\n\n  if (DT->getTag() == dwarf::DW_TAG_inheritance && DT->isVirtual()) {\n\n    // For C++, virtual base classes are not at fixed offset. Use following\n    // expression to extract appropriate offset from vtable.\n    // BaseAddr = ObAddr + *((*ObAddr) - Offset)\n\n    DIELoc *VBaseLocationDie = new (DIEValueAllocator) DIELoc;\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_dup);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_constu);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_udata, DT->getOffsetInBits());\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_minus);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus);\n\n    addBlock(MemberDie, dwarf::DW_AT_data_member_location, VBaseLocationDie);\n  } else {\n    uint64_t Size = DT->getSizeInBits();\n    uint64_t FieldSize = getBaseTypeSize(DD, DT);\n    uint64_t OffsetInBytes;\n\n    if (FieldSize && Size != FieldSize) {\n      // Handle bitfield, assume bytes are 8 bits.\n      if (DD->getDwarfVersion() < 4)\n        addUInt(MemberDie, dwarf::DW_AT_byte_size, None, FieldSize/8);\n      addUInt(MemberDie, dwarf::DW_AT_bit_size, None, Size);\n\n      uint64_t Offset = DT->getOffsetInBits();\n      uint64_t Align = DT->getAlignInBits() ? DT->getAlignInBits() : FieldSize;\n      uint64_t AlignMask = ~(Align - 1);\n      // The bits from the start of the storage unit to the start of the field.\n      uint64_t StartBitOffset = Offset - (Offset & AlignMask);\n      // The byte offset of the field's aligned storage unit inside the struct.\n      OffsetInBytes = (Offset - StartBitOffset) / 8;\n\n      if (DD->getDwarfVersion() >= 4)\n        addUInt(MemberDie, dwarf::DW_AT_data_bit_offset, None, Offset);\n      else {\n        uint64_t HiMark = (Offset + FieldSize) & AlignMask;\n        uint64_t FieldOffset = (HiMark - FieldSize);\n        Offset -= FieldOffset;\n\n        // Maybe we need to work from the other end.\n        if (Asm->getDataLayout().isLittleEndian())\n          Offset = FieldSize - (Offset + Size);\n\n        addUInt(MemberDie, dwarf::DW_AT_bit_offset, None, Offset);\n        OffsetInBytes = FieldOffset >> 3;\n      }\n    } else\n      // This is not a bitfield.\n      OffsetInBytes = DT->getOffsetInBits() / 8;\n\n    if (DD->getDwarfVersion() <= 2) {\n      DIELoc *MemLocationDie = new (DIEValueAllocator) DIELoc;\n      addUInt(*MemLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus_uconst);\n      addUInt(*MemLocationDie, dwarf::DW_FORM_udata, OffsetInBytes);\n      addBlock(MemberDie, dwarf::DW_AT_data_member_location, MemLocationDie);\n    } else\n      addUInt(MemberDie, dwarf::DW_AT_data_member_location, None,\n              OffsetInBytes);\n  }\n\n  if (DT->isProtected())\n    addUInt(MemberDie, dwarf::DW_AT_accessibility, dwarf::DW_FORM_data1,\n            dwarf::DW_ACCESS_protected);\n  else if (DT->isPrivate())\n    addUInt(MemberDie, dwarf::DW_AT_accessibility, dwarf::DW_FORM_data1,\n            dwarf::DW_ACCESS_private);\n  // Otherwise C++ member and base classes are considered public.\n  else if (DT->isPublic())\n    addUInt(MemberDie, dwarf::DW_AT_accessibility, dwarf::DW_FORM_data1,\n            dwarf::DW_ACCESS_public);\n  if (DT->isVirtual())\n    addUInt(MemberDie, dwarf::DW_AT_virtuality, dwarf::DW_FORM_data1,\n            dwarf::DW_VIRTUALITY_virtual);\n\n  // Objective-C properties.\n  if (DINode *PNode = DT->getObjCProperty())\n    if (DIE *PDie = getDIE(PNode))\n      MemberDie.addValue(DIEValueAllocator, dwarf::DW_AT_APPLE_property,\n                         dwarf::DW_FORM_ref4, DIEEntry(*PDie));\n\n  if (DT->isArtificial())\n    addFlag(MemberDie, dwarf::DW_AT_artificial);\n}\n",
        "fix": null,
        "src_path": "7aa34c8cbb7f81737666d08217769d6ef81181d5___DwarfUnit.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/7aa34c8cbb7f81737666d08217769d6ef81181d5",
        "commit_msg": "Debug Info: Don't emit a DW_AT_data_member_location for DWARF bitfields.\nThe DWARF spec states that a member entry may have either a\nDW_AT_data_member_location or a DW_AT_data_bit_offset, but not both.\n\nThis fixes a bug found in PR 27758.\n\nllvm-svn: 269731",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/ARM/big-endian-bitfield.ll",
                "patch": "@@ -29,26 +29,22 @@ target datalayout = \"E-m:e-p:32:32-i64:64-v128:64:128-n32-S64\"\n ; CHECK-NEXT: DW_AT_name{{.*}}\"j\"\n ; CHECK-NOT:  DW_TAG\n ; CHECK:      DW_AT_data_bit_offset      [DW_FORM_data1]\t(0x00)\n-; CHECK:      DW_AT_data_member_location [DW_FORM_data1]\t(0x00)\n !7 = !DIDerivedType(tag: DW_TAG_member, name: \"j\", scope: !5, file: !1, line: 2, baseType: !8, size: 5, align: 32)\n !8 = !DIBasicType(name: \"int\", size: 32, align: 32, encoding: DW_ATE_signed)\n ; CHECK: DW_TAG_member\n ; CHECK-NEXT: DW_AT_name{{.*}}\"k\"\n ; CHECK-NOT:  DW_TAG\n ; CHECK:      DW_AT_data_bit_offset      [DW_FORM_data1]\t(0x05)\n-; CHECK:      DW_AT_data_member_location [DW_FORM_data1]\t(0x00)\n !9 = !DIDerivedType(tag: DW_TAG_member, name: \"k\", scope: !5, file: !1, line: 3, baseType: !8, size: 6, align: 32, offset: 5)\n ; CHECK: DW_TAG_member\n ; CHECK-NEXT: DW_AT_name{{.*}}\"m\"\n ; CHECK-NOT:  DW_TAG\n ; CHECK:      DW_AT_data_bit_offset      [DW_FORM_data1]\t(0x0b)\n-; CHECK:      DW_AT_data_member_location [DW_FORM_data1]\t(0x00)\n !10 = !DIDerivedType(tag: DW_TAG_member, name: \"m\", scope: !5, file: !1, line: 4, baseType: !8, size: 5, align: 32, offset: 11)\n ; CHECK: DW_TAG_member\n ; CHECK-NEXT: DW_AT_name{{.*}}\"n\"\n ; CHECK-NOT:  DW_TAG\n ; CHECK:      DW_AT_data_bit_offset      [DW_FORM_data1]\t(0x10)\n-; CHECK:      DW_AT_data_member_location [DW_FORM_data1]\t(0x00)\n !11 = !DIDerivedType(tag: DW_TAG_member, name: \"n\", scope: !5, file: !1, line: 5, baseType: !8, size: 8, align: 32, offset: 16)\n !12 = !{i32 2, !\"Dwarf Version\", i32 4}\n !13 = !{i32 2, !\"Debug Info Version\", i32 3}"
            },
            {
                "fn": "llvm/test/DebugInfo/X86/bitfields-dwarf4.ll",
                "patch": "@@ -50,7 +50,7 @@ target triple = \"x86_64-apple-macosx\"\n ; CHECK:      DW_AT_bit_size             [DW_FORM_data1]\t(0x05)\n ; CHECK-NOT:  DW_AT_byte_size\n ; CHECK-NEXT: DW_AT_data_bit_offset      [DW_FORM_data1]\t(0x08)\n-; CHECK-NEXT: DW_AT_data_member_location [DW_FORM_data1]\t(0x00)\n+; CHECK-NOT:  DW_AT_data_member_location\n !9 = !DIDerivedType(tag: DW_TAG_member, name: \"b\", scope: !5, file: !1, line: 6, baseType: !10, size: 5, align: 32, offset: 8)\n \n !10 = !DIDerivedType(tag: DW_TAG_typedef, name: \"uint32_t\", file: !11, line: 183, baseType: !12)\n@@ -64,7 +64,8 @@ target triple = \"x86_64-apple-macosx\"\n ; CHECK-NOT:  DW_AT_byte_size\n ; CHECK:      DW_AT_bit_size             [DW_FORM_data1]\t(0x1b)\n ; CHECK-NEXT: DW_AT_data_bit_offset      [DW_FORM_data1]\t(0x0d)\n-; CHECK-NEXT: DW_AT_data_member_location [DW_FORM_data1]\t(0x00)\n+; CHECK-NOT:  DW_AT_data_member_location\n+; CHECK: DW_TAG\n !13 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !5, file: !1, line: 7, baseType: !10, size: 27, align: 32, offset: 13)\n \n !14 = !{i32 2, !\"Dwarf Version\", i32 4}"
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/X86/bitfields-dwarf4.ll (1 of 1)\nTesting Time: 0.07s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/bitfields-dwarf4.ll\n\n  Unexpected Failures: 1\n"
    },
    "596a3bd9ece335303c14cd3d33cbc4cb1717db88___DeadStoreElimination.cpp": {
        "start": 292,
        "end": 446,
        "buggy": "static OverwriteResult isOverwrite(const MemoryLocation &Later,\n                                   const MemoryLocation &Earlier,\n                                   const DataLayout &DL,\n                                   const TargetLibraryInfo &TLI,\n                                   int64_t &EarlierOff, int64_t &LaterOff,\n                                   Instruction *DepWrite,\n                                   InstOverlapIntervalsTy &IOL) {\n  // If we don't know the sizes of either access, then we can't do a comparison.\n  if (Later.Size == MemoryLocation::UnknownSize ||\n      Earlier.Size == MemoryLocation::UnknownSize)\n    return OverwriteUnknown;\n\n  const Value *P1 = Earlier.Ptr->stripPointerCasts();\n  const Value *P2 = Later.Ptr->stripPointerCasts();\n\n  // If the start pointers are the same, we just have to compare sizes to see if\n  // the later store was larger than the earlier store.\n  if (P1 == P2) {\n    // Make sure that the Later size is >= the Earlier size.\n    if (Later.Size >= Earlier.Size)\n      return OverwriteComplete;\n  }\n\n  // Check to see if the later store is to the entire object (either a global,\n  // an alloca, or a byval/inalloca argument).  If so, then it clearly\n  // overwrites any other store to the same object.\n  const Value *UO1 = GetUnderlyingObject(P1, DL),\n              *UO2 = GetUnderlyingObject(P2, DL);\n\n  // If we can't resolve the same pointers to the same object, then we can't\n  // analyze them at all.\n  if (UO1 != UO2)\n    return OverwriteUnknown;\n\n  // If the \"Later\" store is to a recognizable object, get its size.\n  uint64_t ObjectSize = getPointerSize(UO2, DL, TLI);\n  if (ObjectSize != MemoryLocation::UnknownSize)\n    if (ObjectSize == Later.Size && ObjectSize >= Earlier.Size)\n      return OverwriteComplete;\n\n  // Okay, we have stores to two completely different pointers.  Try to\n  // decompose the pointer into a \"base + constant_offset\" form.  If the base\n  // pointers are equal, then we can reason about the two stores.\n  EarlierOff = 0;\n  LaterOff = 0;\n  const Value *BP1 = GetPointerBaseWithConstantOffset(P1, EarlierOff, DL);\n  const Value *BP2 = GetPointerBaseWithConstantOffset(P2, LaterOff, DL);\n\n  // If the base pointers still differ, we have two completely different stores.\n  if (BP1 != BP2)\n    return OverwriteUnknown;\n\n  // The later store completely overlaps the earlier store if:\n  //\n  // 1. Both start at the same offset and the later one's size is greater than\n  //    or equal to the earlier one's, or\n  //\n  //      |--earlier--|\n  //      |--   later   --|\n  //\n  // 2. The earlier store has an offset greater than the later offset, but which\n  //    still lies completely within the later store.\n  //\n  //        |--earlier--|\n  //    |-----  later  ------|\n  //\n  // We have to be careful here as *Off is signed while *.Size is unsigned.\n  if (EarlierOff >= LaterOff &&\n      Later.Size >= Earlier.Size &&\n      uint64_t(EarlierOff - LaterOff) + Earlier.Size <= Later.Size)\n    return OverwriteComplete;\n\n  // We may now overlap, although the overlap is not complete. There might also\n  // be other incomplete overlaps, and together, they might cover the complete\n  // earlier write.\n  // Note: The correctness of this logic depends on the fact that this function\n  // is not even called providing DepWrite when there are any intervening reads.\n  if (EnablePartialOverwriteTracking &&\n      LaterOff < int64_t(EarlierOff + Earlier.Size) &&\n      int64_t(LaterOff + Later.Size) >= EarlierOff) {\n\n    // Insert our part of the overlap into the map.\n    auto &IM = IOL[DepWrite];\n    DEBUG(dbgs() << \"DSE: Partial overwrite: Earlier [\" << EarlierOff << \", \" <<\n                    int64_t(EarlierOff + Earlier.Size) << \") Later [\" <<\n                    LaterOff << \", \" << int64_t(LaterOff + Later.Size) << \")\\n\");\n\n    // Make sure that we only insert non-overlapping intervals and combine\n    // adjacent intervals. The intervals are stored in the map with the ending\n    // offset as the key (in the half-open sense) and the starting offset as\n    // the value.\n    int64_t LaterIntStart = LaterOff, LaterIntEnd = LaterOff + Later.Size;\n\n    // Find any intervals ending at, or after, LaterIntStart which start\n    // before LaterIntEnd.\n    auto ILI = IM.lower_bound(LaterIntStart);\n    if (ILI != IM.end() && ILI->second < LaterIntEnd) {\n      // This existing interval ends in the middle of\n      // [LaterIntStart, LaterIntEnd), erase it adjusting our start.\n      LaterIntStart = std::min(LaterIntStart, ILI->second);\n      LaterIntEnd = std::max(LaterIntEnd, ILI->first);\n      ILI = IM.erase(ILI);\n\n      while (ILI != IM.end() && ILI->first <= LaterIntEnd)\n        ILI = IM.erase(ILI);\n\n      if (ILI != IM.end() && ILI->second < LaterIntEnd)\n        LaterIntEnd = std::max(LaterIntEnd, ILI->first);\n    }\n\n    IM[LaterIntEnd] = LaterIntStart;\n\n    ILI = IM.begin();\n    if (ILI->second <= EarlierOff &&\n        ILI->first >= int64_t(EarlierOff + Earlier.Size)) {\n      DEBUG(dbgs() << \"DSE: Full overwrite from partials: Earlier [\" <<\n                      EarlierOff << \", \" <<\n                      int64_t(EarlierOff + Earlier.Size) <<\n                      \") Composite Later [\" <<\n                      ILI->second << \", \" << ILI->first << \")\\n\");\n      ++NumCompletePartials;\n      return OverwriteComplete;\n    }\n  }\n\n  // Another interesting case is if the later store overwrites the end of the\n  // earlier store.\n  //\n  //      |--earlier--|\n  //                |--   later   --|\n  //\n  // In this case we may want to trim the size of earlier to avoid generating\n  // writes to addresses which will definitely be overwritten later\n  if (LaterOff > EarlierOff &&\n      LaterOff < int64_t(EarlierOff + Earlier.Size) &&\n      int64_t(LaterOff + Later.Size) >= int64_t(EarlierOff + Earlier.Size))\n    return OverwriteEnd;\n\n  // Finally, we also need to check if the later store overwrites the beginning\n  // of the earlier store.\n  //\n  //                |--earlier--|\n  //      |--   later   --|\n  //\n  // In this case we may want to move the destination address and trim the size\n  // of earlier to avoid generating writes to addresses which will definitely\n  // be overwritten later.\n  if (LaterOff <= EarlierOff && int64_t(LaterOff + Later.Size) > EarlierOff) {\n    assert (int64_t(LaterOff + Later.Size) < int64_t(EarlierOff + Earlier.Size)\n            && \"Expect to be handled as OverwriteComplete\" );\n    return OverwriteBegin;\n  }\n  // Otherwise, they don't completely overlap.\n  return OverwriteUnknown;\n}\n",
        "fix": null,
        "src_path": "596a3bd9ece335303c14cd3d33cbc4cb1717db88___DeadStoreElimination.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/596a3bd9ece335303c14cd3d33cbc4cb1717db88",
        "commit_msg": "[DSE] Fix bug in partial overwrite tracking\n\nSummary:\nFound cases where DSE incorrectly add partially-overwritten intervals.\nPlease see the test case for details.\n\nReviewers: mcrosier, eeckstein, hfinkel\n\nSubscribers: mcrosier, llvm-commits\n\nDifferential Revision: http://reviews.llvm.org/D21859\n\nllvm-svn: 274237",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/DeadStoreElimination/combined-partial-overwrites.ll",
                "patch": "@@ -198,3 +198,42 @@ entry:\n   ret i8 0\n }\n \n+define signext i8 @test6(i32 *%ptr) {\n+entry:\n+; CHECK-LABEL: @test6\n+\n+  store i32 0, i32* %ptr\n+\n+  %bptr = bitcast i32* %ptr to i16*\n+  %bptr1 = getelementptr inbounds i16, i16* %bptr, i64 0\n+  %bptr2 = getelementptr inbounds i16, i16* %bptr, i64 1\n+\n+  store i16 1456, i16* %bptr2, align 1\n+  store i16 65535, i16* %bptr1, align 1\n+\n+; CHECK-NOT: store i32 0, i32* %ptr\n+\n+  ret i8 0\n+}\n+\n+define signext i8 @test7(i64 *%ptr) {\n+entry:\n+; CHECK-LABEL: @test7\n+\n+  store i64 0, i64* %ptr\n+\n+  %bptr = bitcast i64* %ptr to i16*\n+  %bptr1 = getelementptr inbounds i16, i16* %bptr, i64 0\n+  %bptr2 = getelementptr inbounds i16, i16* %bptr, i64 1\n+  %bptr3 = getelementptr inbounds i16, i16* %bptr, i64 2\n+  %bptr4 = getelementptr inbounds i16, i16* %bptr, i64 3\n+\n+  store i16 1346, i16* %bptr1, align 1\n+  store i16 1756, i16* %bptr3, align 1\n+  store i16 1456, i16* %bptr2, align 1\n+  store i16 5656, i16* %bptr4, align 1\n+\n+; CHECK-NOT: store i64 0, i64* %ptr\n+\n+  ret i8 0\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/DeadStoreElimination/combined-partial-overwrites.ll (1 of 1)\nTesting Time: 0.11s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/DeadStoreElimination/combined-partial-overwrites.ll\n\n  Unexpected Failures: 1\n"
    },
    "b53b62eb69cd5768423786c5ced700bc2d1d2e20___AutoUpgrade.cpp": {
        "start": 1570,
        "end": 1599,
        "buggy": "bool llvm::UpgradeModuleFlags(Module &M) {\n  const NamedMDNode *ModFlags = M.getModuleFlagsMetadata();\n  if (!ModFlags)\n    return false;\n\n  bool HasObjCFlag = false, HasClassProperties = false;\n  for (unsigned I = 0, E = ModFlags->getNumOperands(); I != E; ++I) {\n    MDNode *Op = ModFlags->getOperand(I);\n    if (Op->getNumOperands() < 2)\n      continue;\n    MDString *ID = dyn_cast_or_null<MDString>(Op->getOperand(1));\n    if (!ID)\n      continue;\n    if (ID->getString() == \"Objective-C Image Info Version\")\n      HasObjCFlag = true;\n    if (ID->getString() == \"Objective-C Class Properties\")\n      HasClassProperties = true;\n  }\n  // \"Objective-C Class Properties\" is recently added for Objective-C. We\n  // upgrade ObjC bitcodes to contain a \"Objective-C Class Properties\" module\n  // flag of value 0, so we can correclty report error when trying to link\n  // an ObjC bitcode without this module flag with an ObjC bitcode with this\n  // module flag.\n  if (HasObjCFlag && !HasClassProperties) {\n    M.addModuleFlag(llvm::Module::Error, \"Objective-C Class Properties\",\n                    (uint32_t)0);\n    return true;\n  }\n  return false;\n}\n",
        "fix": null,
        "src_path": "b53b62eb69cd5768423786c5ced700bc2d1d2e20___AutoUpgrade.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/b53b62eb69cd5768423786c5ced700bc2d1d2e20",
        "commit_msg": "Fix autoupgrade logic for Objective-C class properties module flag\n\nPrevious we were issuing an error when linking a module containing\nthe new Objective-C metadata structure for class properties with an\n\"old\" one.\nNow instead we downgrade the module flag so that the Objective-C\nruntime does not expect the new metadata structure.\n\nThis is consistent with what ld64 is doing on binary files.\n\nDifferential Revision: https://reviews.llvm.org/D24620\n\nllvm-svn: 281685",
        "test_func_diff": [
            {
                "fn": "llvm/test/Bitcode/upgrade-module-flag.ll",
                "patch": "@@ -6,4 +6,4 @@\n !0 = !{i32 1, !\"Objective-C Image Info Version\", i32 0}\n \n ; CHECK: !0 = !{i32 1, !\"Objective-C Image Info Version\", i32 0}\n-; CHECK: !1 = !{i32 1, !\"Objective-C Class Properties\", i32 0}\n+; CHECK: !1 = !{i32 4, !\"Objective-C Class Properties\", i32 0}"
            },
            {
                "fn": "llvm/test/Linker/Inputs/objectivec-class-property-flag-mismatch.ll",
                "patch": "@@ -0,0 +1,5 @@\n+\n+!llvm.module.flags = !{!0, !1}\n+\n+!0 = !{i32 1, !\"Objective-C Image Info Version\", i32 0}\n+!1 = !{i32 1, !\"Objective-C Class Properties\", i32 64}"
            },
            {
                "fn": "llvm/test/Linker/objectivec-class-property-flag-mismatch.ll",
                "patch": "@@ -0,0 +1,16 @@\n+; RUN: llvm-as < %s -o %t1.bc\n+; RUN: llvm-as < %p/Inputs/objectivec-class-property-flag-mismatch.ll -o %t2.bc\n+\n+\n+; RUN: llvm-link %t1.bc %t2.bc -S | FileCheck %s\n+; RUN: llvm-link %t2.bc %t1.bc -S | FileCheck %s\n+\n+\n+; CHECK: !0 = !{i32 1, !\"Objective-C Image Info Version\", i32 0}\n+; CHECK: !1 = !{i32 4, !\"Objective-C Class Properties\", i32 0}\n+\n+\n+\n+!llvm.module.flags = !{!0}\n+\n+!0 = !{i32 1, !\"Objective-C Image Info Version\", i32 0}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Bitcode/upgrade-module-flag.ll (1 of 1)\nTesting Time: 0.26s\n********************\nFailing Tests (1):\n    LLVM :: Bitcode/upgrade-module-flag.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Linker/objectivec-class-property-flag-mismatch.ll (1 of 1)\nTesting Time: 0.45s\n********************\nFailing Tests (1):\n    LLVM :: Linker/objectivec-class-property-flag-mismatch.ll\n\n  Unexpected Failures: 1\n"
    },
    "0efb96a8ee1b57c39fb732a098f88b3410fc4aeb___SimplifyCFG.cpp": {
        "start": 1473,
        "end": 1551,
        "buggy": "static bool sinkLastInstruction(ArrayRef<BasicBlock*> Blocks) {\n  auto *BBEnd = Blocks[0]->getTerminator()->getSuccessor(0);\n\n  // canSinkLastInstruction returning true guarantees that every block has at\n  // least one non-terminator instruction.\n  SmallVector<Instruction*,4> Insts;\n  for (auto *BB : Blocks)\n    Insts.push_back(BB->getTerminator()->getPrevNode());\n\n  // The only checking we need to do now is that all users of all instructions\n  // are the same PHI node. canSinkLastInstruction should have checked this but\n  // it is slightly over-aggressive - it gets confused by commutative instructions\n  // so double-check it here.\n  Instruction *I0 = Insts.front();\n  if (!isa<StoreInst>(I0)) {\n    auto *PNUse = dyn_cast<PHINode>(*I0->user_begin());\n    if (!all_of(Insts, [&PNUse](const Instruction *I) -> bool {\n          auto *U = cast<Instruction>(*I->user_begin());\n          return U == PNUse;\n        }))\n      return false;\n  }\n  \n  // We don't need to do any more checking here; canSinkLastInstruction should\n  // have done it all for us.\n  SmallVector<Value*, 4> NewOperands;\n  for (unsigned O = 0, E = I0->getNumOperands(); O != E; ++O) {\n    // This check is different to that in canSinkLastInstruction. There, we\n    // cared about the global view once simplifycfg (and instcombine) have\n    // completed - it takes into account PHIs that become trivially\n    // simplifiable.  However here we need a more local view; if an operand\n    // differs we create a PHI and rely on instcombine to clean up the very\n    // small mess we may make.\n    bool NeedPHI = any_of(Insts, [&I0, O](const Instruction *I) {\n      return I->getOperand(O) != I0->getOperand(O);\n    });\n    if (!NeedPHI) {\n      NewOperands.push_back(I0->getOperand(O));\n      continue;\n    }\n\n    // Create a new PHI in the successor block and populate it.\n    auto *Op = I0->getOperand(O);\n    assert(!Op->getType()->isTokenTy() && \"Can't PHI tokens!\");\n    auto *PN = PHINode::Create(Op->getType(), Insts.size(),\n                               Op->getName() + \".sink\", &BBEnd->front());\n    for (auto *I : Insts)\n      PN->addIncoming(I->getOperand(O), I->getParent());\n    NewOperands.push_back(PN);\n  }\n\n  // Arbitrarily use I0 as the new \"common\" instruction; remap its operands\n  // and move it to the start of the successor block.\n  for (unsigned O = 0, E = I0->getNumOperands(); O != E; ++O)\n    I0->getOperandUse(O).set(NewOperands[O]);\n  I0->moveBefore(&*BBEnd->getFirstInsertionPt());\n\n  // Update metadata.\n  for (auto *I : Insts)\n    if (I != I0)\n      combineMetadataForCSE(I0, I);\n\n  if (!isa<StoreInst>(I0)) {\n    // canSinkLastInstruction checked that all instructions were used by\n    // one and only one PHI node. Find that now, RAUW it to our common\n    // instruction and nuke it.\n    assert(I0->hasOneUse());\n    auto *PN = cast<PHINode>(*I0->user_begin());\n    PN->replaceAllUsesWith(I0);\n    PN->eraseFromParent();\n  }\n\n  // Finally nuke all instructions apart from the common instruction.\n  for (auto *I : Insts)\n    if (I != I0)\n      I->eraseFromParent();\n\n  return true;\n}\n",
        "fix": null,
        "src_path": "0efb96a8ee1b57c39fb732a098f88b3410fc4aeb___SimplifyCFG.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/0efb96a8ee1b57c39fb732a098f88b3410fc4aeb",
        "commit_msg": "[SimplifyCFG] Update (AND) IR flags when CSE'ing instructions\n\nWe were updating metadata but not IR flags. Because we pick an arbitrary instruction to be the CSE candidate, it comes down to luck (50% or less chance) if this results in broken codegen or not, which is why PR30373 which is actually not the fault of the commit it was bisected down to.\n\nFixes PR30373.\n\nllvm-svn: 281889",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/SimplifyCFG/sink-common-code.ll",
                "patch": "@@ -699,6 +699,62 @@ if.end:\n ; CHECK: store\n ; CHECK: store\n \n+define i32 @test_pr30373a(i1 zeroext %flag, i32 %x, i32 %y) {\n+entry:\n+  br i1 %flag, label %if.then, label %if.else\n+\n+if.then:\n+  %x0 = call i32 @foo(i32 %x, i32 0) nounwind readnone\n+  %y0 = call i32 @foo(i32 %x, i32 1) nounwind readnone\n+  %z0 = lshr i32 %y0, 8\n+  br label %if.end\n+\n+if.else:\n+  %x1 = call i32 @foo(i32 %y, i32 0) nounwind readnone\n+  %y1 = call i32 @foo(i32 %y, i32 1) nounwind readnone\n+  %z1 = lshr exact i32 %y1, 8\n+  br label %if.end\n+\n+if.end:\n+  %xx = phi i32 [ %x0, %if.then ], [ %x1, %if.else ]\n+  %yy = phi i32 [ %z0, %if.then ], [ %z1, %if.else ]\n+  %ret = add i32 %xx, %yy\n+  ret i32 %ret\n+}\n+\n+; CHECK-LABEL: test_pr30373a\n+; CHECK: lshr\n+; CHECK-NOT: exact\n+; CHECK: }\n+\n+define i32 @test_pr30373b(i1 zeroext %flag, i32 %x, i32 %y) {\n+entry:\n+  br i1 %flag, label %if.then, label %if.else\n+\n+if.then:\n+  %x0 = call i32 @foo(i32 %x, i32 0) nounwind readnone\n+  %y0 = call i32 @foo(i32 %x, i32 1) nounwind readnone\n+  %z0 = lshr exact i32 %y0, 8\n+  br label %if.end\n+\n+if.else:\n+  %x1 = call i32 @foo(i32 %y, i32 0) nounwind readnone\n+  %y1 = call i32 @foo(i32 %y, i32 1) nounwind readnone\n+  %z1 = lshr i32 %y1, 8\n+  br label %if.end\n+\n+if.end:\n+  %xx = phi i32 [ %x0, %if.then ], [ %x1, %if.else ]\n+  %yy = phi i32 [ %z0, %if.then ], [ %z1, %if.else ]\n+  %ret = add i32 %xx, %yy\n+  ret i32 %ret\n+}\n+\n+; CHECK-LABEL: test_pr30373b\n+; CHECK: lshr\n+; CHECK-NOT: exact\n+; CHECK: }\n+\n ; CHECK: !0 = !{!1, !1, i64 0}\n ; CHECK: !1 = !{!\"float\", !2}\n ; CHECK: !2 = !{!\"an example type tree\"}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/SimplifyCFG/sink-common-code.ll (1 of 1)\nTesting Time: 0.15s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/SimplifyCFG/sink-common-code.ll\n\n  Unexpected Failures: 1\n"
    },
    "fd0d7b21e0b974dcb8ee6257ae4ef4fa7398e80b___InstructionCombining.cpp": {
        "start": 2239,
        "end": 2298,
        "buggy": "Instruction *InstCombiner::visitSwitchInst(SwitchInst &SI) {\n  Value *Cond = SI.getCondition();\n  unsigned BitWidth = cast<IntegerType>(Cond->getType())->getBitWidth();\n  APInt KnownZero(BitWidth, 0), KnownOne(BitWidth, 0);\n  computeKnownBits(Cond, KnownZero, KnownOne, 0, &SI);\n  unsigned LeadingKnownZeros = KnownZero.countLeadingOnes();\n  unsigned LeadingKnownOnes = KnownOne.countLeadingOnes();\n\n  // Compute the number of leading bits we can ignore.\n  // TODO: A better way to determine this would use ComputeNumSignBits().\n  for (auto &C : SI.cases()) {\n    LeadingKnownZeros = std::min(\n        LeadingKnownZeros, C.getCaseValue()->getValue().countLeadingZeros());\n    LeadingKnownOnes = std::min(\n        LeadingKnownOnes, C.getCaseValue()->getValue().countLeadingOnes());\n  }\n\n  unsigned NewWidth = BitWidth - std::max(LeadingKnownZeros, LeadingKnownOnes);\n\n  // Shrink the condition operand if the new type is smaller than the old type.\n  // This may produce a non-standard type for the switch, but that's ok because\n  // the backend should extend back to a legal type for the target.\n  bool TruncCond = false;\n  if (NewWidth > 0 && NewWidth < BitWidth) {\n    TruncCond = true;\n    IntegerType *Ty = IntegerType::get(SI.getContext(), NewWidth);\n    Builder->SetInsertPoint(&SI);\n    Value *NewCond = Builder->CreateTrunc(Cond, Ty, \"trunc\");\n    SI.setCondition(NewCond);\n\n    for (auto &C : SI.cases())\n      static_cast<SwitchInst::CaseIt *>(&C)->setValue(ConstantInt::get(\n          SI.getContext(), C.getCaseValue()->getValue().trunc(NewWidth)));\n  }\n\n  ConstantInt *AddRHS = nullptr;\n  if (match(Cond, m_Add(m_Value(), m_ConstantInt(AddRHS)))) {\n    Instruction *I = cast<Instruction>(Cond);\n    // Change 'switch (X+4) case 1:' into 'switch (X) case -3'.\n    for (SwitchInst::CaseIt i = SI.case_begin(), e = SI.case_end(); i != e;\n         ++i) {\n      ConstantInt *CaseVal = i.getCaseValue();\n      Constant *LHS = CaseVal;\n      if (TruncCond) {\n        LHS = LeadingKnownZeros\n                  ? ConstantExpr::getZExt(CaseVal, Cond->getType())\n                  : ConstantExpr::getSExt(CaseVal, Cond->getType());\n      }\n      Constant *NewCaseVal = ConstantExpr::getSub(LHS, AddRHS);\n      assert(isa<ConstantInt>(NewCaseVal) &&\n             \"Result of expression should be constant\");\n      i.setValue(cast<ConstantInt>(NewCaseVal));\n    }\n    SI.setCondition(I->getOperand(0));\n    Worklist.Add(I);\n    return &SI;\n  }\n\n  return TruncCond ? &SI : nullptr;\n}\n",
        "fix": null,
        "src_path": "fd0d7b21e0b974dcb8ee6257ae4ef4fa7398e80b___InstructionCombining.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/fd0d7b21e0b974dcb8ee6257ae4ef4fa7398e80b",
        "commit_msg": "[InstCombine] Fix constexpr issue in select combining\n\nAs discussed by Andrea on PR30486, we have an unsafe cast to an Instruction type in the select combine which doesn't take into account that it could be a ConstantExpr instead.\n\nDifferential Revision: https://reviews.llvm.org/D25466\n\nllvm-svn: 284000",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/switch-constant-expr.ll",
                "patch": "@@ -0,0 +1,44 @@\n+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py\n+; RUN: opt < %s -instcombine -S | FileCheck %s\n+\n+@g = global i32 0\n+\n+; PR30486\n+define i32 @single_case() {\n+; CHECK-LABEL: @single_case(\n+; CHECK-NEXT:    switch i32 ptrtoint (i32* @g to i32), label %x [\n+; CHECK-NEXT:    ]\n+; CHECK:       x:\n+; CHECK-NEXT:    ret i32 0\n+;\n+  switch i32 add (i32 ptrtoint (i32* @g to i32), i32 -1), label %x []\n+x:\n+  ret i32 0\n+}\n+\n+define i32 @multiple_cases() {\n+; CHECK-LABEL: @multiple_cases(\n+; CHECK-NEXT:    switch i32 ptrtoint (i32* @g to i32), label %x [\n+; CHECK-NEXT:    i32 2, label %one\n+; CHECK-NEXT:    i32 3, label %two\n+; CHECK-NEXT:    ]\n+; CHECK:       x:\n+; CHECK-NEXT:    ret i32 0\n+; CHECK:       one:\n+; CHECK-NEXT:    ret i32 1\n+; CHECK:       two:\n+; CHECK-NEXT:    ret i32 2\n+;\n+  switch i32 add (i32 ptrtoint (i32* @g to i32), i32 -1), label %x [\n+  i32 1, label %one\n+  i32 2, label %two\n+  ]\n+x:\n+  ret i32 0\n+\n+one:\n+  ret i32 1\n+\n+two:\n+  ret i32 2\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/switch-constant-expr.ll (1 of 1)\nTesting Time: 0.39s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/switch-constant-expr.ll\n\n  Unexpected Failures: 1\n"
    },
    "89af112cf590e76fbb1fd964086a3882b7f935f9___CodeViewDebug.cpp": {
        "start": 1259,
        "end": 1300,
        "buggy": "TypeIndex CodeViewDebug::lowerTypeArray(const DICompositeType *Ty) {\n  DITypeRef ElementTypeRef = Ty->getBaseType();\n  TypeIndex ElementTypeIndex = getTypeIndex(ElementTypeRef);\n  // IndexType is size_t, which depends on the bitness of the target.\n  TypeIndex IndexType = Asm->TM.getPointerSize() == 8\n                            ? TypeIndex(SimpleTypeKind::UInt64Quad)\n                            : TypeIndex(SimpleTypeKind::UInt32Long);\n\n  uint64_t ElementSize = getBaseTypeSize(ElementTypeRef) / 8;\n\n  // Add subranges to array type.\n  DINodeArray Elements = Ty->getElements();\n  for (int i = Elements.size() - 1; i >= 0; --i) {\n    const DINode *Element = Elements[i];\n    assert(Element->getTag() == dwarf::DW_TAG_subrange_type);\n\n    const DISubrange *Subrange = cast<DISubrange>(Element);\n    assert(Subrange->getLowerBound() == 0 &&\n           \"codeview doesn't support subranges with lower bounds\");\n    int64_t Count = Subrange->getCount();\n\n    // Variable Length Array (VLA) has Count equal to '-1'.\n    // Replace with Count '1', assume it is the minimum VLA length.\n    // FIXME: Make front-end support VLA subrange and emit LF_DIMVARLU.\n    if (Count == -1)\n      Count = 1;\n\n    // Update the element size and element type index for subsequent subranges.\n    ElementSize *= Count;\n\n    // If this is the outermost array, use the size from the array. It will be\n    // more accurate if we had a VLA or an incomplete element type size.\n    uint64_t ArraySize =\n        (i == 0 && ElementSize == 0) ? Ty->getSizeInBits() / 8 : ElementSize;\n\n    StringRef Name = (i == 0) ? Ty->getName() : \"\";\n    ArrayRecord AR(ElementTypeIndex, IndexType, ArraySize, Name);\n    ElementTypeIndex = TypeTable.writeKnownType(AR);\n  }\n\n  return ElementTypeIndex;\n}\n",
        "fix": null,
        "src_path": "89af112cf590e76fbb1fd964086a3882b7f935f9___CodeViewDebug.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/89af112cf590e76fbb1fd964086a3882b7f935f9",
        "commit_msg": "[codeview] VLAs and unsized arrays should use a size of zero\n\nPreviously we used a size of '1' for VLAs because we weren't sure what\nMSVC did. However, MSVC does support declaring an array without a size,\nfor which it emits an array type with a size of zero. Clang emits the\nsame DI metadata for VLAs and arrays without bound, so we would describe\narrays without bound as having one element. This lead to Microsoft\ndebuggers only printing a single element.\n\nEmitting a size of zero appears to cause these debuggers to search the\nsymbol information to find a definition of the variable with accurate\narray bounds.\n\nFixes http://crbug.com/763580\n\nllvm-svn: 313203",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/COFF/types-array-advanced.ll",
                "patch": "@@ -47,7 +47,7 @@\n ; CHECK:     TypeLeafKind: LF_ARRAY (0x1503)\n ; CHECK:     ElementType: int (0x74)\n ; CHECK:     IndexType: unsigned long (0x22)\n-; CHECK:     SizeOf: 4\n+; CHECK:     SizeOf: 0\n ; CHECK:     Name: \n ; CHECK:   }\n ; CHECK:   Pointer (0x1004) {"
            },
            {
                "fn": "llvm/test/DebugInfo/COFF/types-array-unsized.ll",
                "patch": "@@ -0,0 +1,84 @@\n+; RUN: llc -filetype=obj < %s | llvm-readobj -codeview | FileCheck %s\n+\n+; We should emit two array types: one used to describe the static data member,\n+; and the other used by the S_GDATA32 for the definition.\n+\n+; C++ source:\n+; struct Foo {\n+;   static const char str[];\n+; };\n+; const char Foo::str[] = \"asdf\";\n+; Foo f; // FIXME: only needed to force emit 'Foo'\n+\n+; CHECK:      CodeViewTypes [\n+; CHECK:        Array ([[ARRAY_COMPLETE:0x.*]]) {\n+; CHECK-NEXT:     TypeLeafKind: LF_ARRAY (0x1503)\n+; CHECK-NEXT:     ElementType: const char ({{.*}})\n+; CHECK-NEXT:     IndexType: unsigned __int64 (0x23)\n+; CHECK-NEXT:     SizeOf: 5\n+; CHECK-NEXT:     Name: \n+; CHECK-NEXT:   }\n+; CHECK:        Array ([[ARRAY_FWD:0x.*]]) {\n+; CHECK-NEXT:     TypeLeafKind: LF_ARRAY (0x1503)\n+; CHECK-NEXT:     ElementType: const char ({{.*}})\n+; CHECK-NEXT:     IndexType: unsigned __int64 (0x23)\n+; CHECK-NEXT:     SizeOf: 0\n+; CHECK-NEXT:     Name: \n+; CHECK-NEXT:   }\n+; CHECK:        FieldList (0x1004) {\n+; CHECK-NEXT:     TypeLeafKind: LF_FIELDLIST (0x1203)\n+; CHECK-NEXT:     StaticDataMember {\n+; CHECK-NEXT:       TypeLeafKind: LF_STMEMBER (0x150E)\n+; CHECK-NEXT:       AccessSpecifier: Public (0x3)\n+; CHECK-NEXT:       Type: [[ARRAY_FWD]]\n+; CHECK-NEXT:       Name: str\n+; CHECK-NEXT:     }\n+; CHECK-NEXT:   }\n+; CHECK:      ]\n+\n+; CHECK:          GlobalData {\n+; CHECK-NEXT:       Kind: S_GDATA32 (0x110D)\n+; CHECK-NEXT:       DataOffset: ?str@Foo@@2QBDB+0x0\n+; CHECK-NEXT:       Type: [[ARRAY_COMPLETE]]\n+; CHECK-NEXT:       DisplayName: str\n+; CHECK-NEXT:       LinkageName: ?str@Foo@@2QBDB\n+; CHECK-NEXT:     }\n+\n+; ModuleID = 't.cpp'\n+source_filename = \"t.cpp\"\n+target datalayout = \"e-m:w-i64:64-f80:128-n8:16:32:64-S128\"\n+target triple = \"x86_64-pc-windows-msvc19.0.24215\"\n+\n+%struct.Foo = type { i8 }\n+\n+@\"\\01?str@Foo@@2QBDB\" = constant [5 x i8] c\"asdf\\00\", align 1, !dbg !0\n+@\"\\01?f@@3UFoo@@A\" = global %struct.Foo zeroinitializer, align 1, !dbg !6\n+\n+!llvm.dbg.cu = !{!2}\n+!llvm.module.flags = !{!19, !20, !21, !22}\n+!llvm.ident = !{!23}\n+\n+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())\n+!1 = distinct !DIGlobalVariable(name: \"str\", linkageName: \"\\01?str@Foo@@2QBDB\", scope: !2, file: !3, line: 4, type: !16, isLocal: false, isDefinition: true, declaration: !10)\n+!2 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !3, producer: \"clang version 6.0.0 \", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !4, globals: !5)\n+!3 = !DIFile(filename: \"t.cpp\", directory: \"C:\\5Csrc\\5Cllvm-project\\5Cbuild\", checksumkind: CSK_MD5, checksum: \"15aa843c5a80301928caf03e71f87a54\")\n+!4 = !{}\n+!5 = !{!0, !6}\n+!6 = !DIGlobalVariableExpression(var: !7, expr: !DIExpression())\n+!7 = distinct !DIGlobalVariable(name: \"f\", linkageName: \"\\01?f@@3UFoo@@A\", scope: !2, file: !3, line: 5, type: !8, isLocal: false, isDefinition: true)\n+!8 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: \"Foo\", file: !3, line: 1, size: 8, elements: !9, identifier: \".?AUFoo@@\")\n+!9 = !{!10}\n+!10 = !DIDerivedType(tag: DW_TAG_member, name: \"str\", scope: !8, file: !3, line: 2, baseType: !11, flags: DIFlagStaticMember)\n+!11 = !DICompositeType(tag: DW_TAG_array_type, baseType: !12, elements: !14)\n+!12 = !DIDerivedType(tag: DW_TAG_const_type, baseType: !13)\n+!13 = !DIBasicType(name: \"char\", size: 8, encoding: DW_ATE_signed_char)\n+!14 = !{!15}\n+!15 = !DISubrange(count: -1)\n+!16 = !DICompositeType(tag: DW_TAG_array_type, baseType: !12, size: 40, elements: !17)\n+!17 = !{!18}\n+!18 = !DISubrange(count: 5)\n+!19 = !{i32 2, !\"CodeView\", i32 1}\n+!20 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!21 = !{i32 1, !\"wchar_size\", i32 2}\n+!22 = !{i32 7, !\"PIC Level\", i32 2}\n+!23 = !{!\"clang version 6.0.0 \"}"
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/COFF/types-array-advanced.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/COFF/types-array-advanced.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: DebugInfo/COFF/types-array-unsized.ll (1 of 1)\nTesting Time: 0.11s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/COFF/types-array-unsized.ll\n\n  Unexpected Failures: 1\n"
    },
    "f3cefdd3505ebba0bd2c1625228033f2d3745564___X86DomainReassignment.cpp": {
        "start": 70,
        "end": 83,
        "buggy": "static const TargetRegisterClass *getDstRC(const TargetRegisterClass *SrcRC,\n                                           RegDomain Domain) {\n  assert(Domain == MaskDomain && \"add domain\");\n  if (SrcRC == &X86::GR8RegClass)\n    return &X86::VK8RegClass;\n  if (SrcRC == &X86::GR16RegClass)\n    return &X86::VK16RegClass;\n  if (SrcRC == &X86::GR32RegClass)\n    return &X86::VK32RegClass;\n  if (SrcRC == &X86::GR64RegClass)\n    return &X86::VK64RegClass;\n  llvm_unreachable(\"add register class\");\n  return nullptr;\n}\n",
        "fix": null,
        "src_path": "f3cefdd3505ebba0bd2c1625228033f2d3745564___X86DomainReassignment.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/f3cefdd3505ebba0bd2c1625228033f2d3745564",
        "commit_msg": "[X86] Fix a bug in handling GRXX subclasses in Domain Reassignment pass\n\nWhen trying to determine the correct Mask register class corresponding\nto a GPR register class, not all register classes were handled.\nThis caused an assertion to be raised on some scenarios.\n\nDifferential Revision:\nhttps://reviews.llvm.org/D40290\n\nllvm-svn: 319745",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/gpr-to-mask.ll",
                "patch": "@@ -1,20 +1,40 @@\n ; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py\n-; RUN: llc -mtriple=x86_64-unknown-unknown -mattr=+avx512f,+avx512bw,+avx512dq < %s | FileCheck %s\n+; RUN: llc -mtriple=x86_64-unknown-unknown -mattr=+avx512f,+avx512bw,+avx512dq < %s | FileCheck %s --check-prefix=X86-64\n+; RUN: llc -mtriple=i386-unknown-unknown -mattr=+avx512f,+avx512bw,+avx512dq < %s | FileCheck %s --check-prefix=X86-32\n \n define void @test_fcmp_storefloat(i1 %cond, float* %fptr, float %f1, float %f2, float %f3, float %f4, float %f5, float %f6) {\n-; CHECK-LABEL: test_fcmp_storefloat:\n-; CHECK:       # %bb.0: # %entry\n-; CHECK-NEXT:    testb $1, %dil\n-; CHECK-NEXT:    je .LBB0_2\n-; CHECK-NEXT:  # %bb.1: # %if\n-; CHECK-NEXT:    vcmpeqss %xmm3, %xmm2, %k1\n-; CHECK-NEXT:    jmp .LBB0_3\n-; CHECK-NEXT:  .LBB0_2: # %else\n-; CHECK-NEXT:    vcmpeqss %xmm5, %xmm4, %k1\n-; CHECK-NEXT:  .LBB0_3: # %exit\n-; CHECK-NEXT:    vmovss %xmm0, %xmm0, %xmm1 {%k1}\n-; CHECK-NEXT:    vmovss %xmm1, (%rsi)\n-; CHECK-NEXT:    retq\n+; X86-64-LABEL: test_fcmp_storefloat:\n+; X86-64:       # %bb.0: # %entry\n+; X86-64-NEXT:    testb $1, %dil\n+; X86-64-NEXT:    je .LBB0_2\n+; X86-64-NEXT:  # %bb.1: # %if\n+; X86-64-NEXT:    vcmpeqss %xmm3, %xmm2, %k1\n+; X86-64-NEXT:    jmp .LBB0_3\n+; X86-64-NEXT:  .LBB0_2: # %else\n+; X86-64-NEXT:    vcmpeqss %xmm5, %xmm4, %k1\n+; X86-64-NEXT:  .LBB0_3: # %exit\n+; X86-64-NEXT:    vmovss %xmm0, %xmm0, %xmm1 {%k1}\n+; X86-64-NEXT:    vmovss %xmm1, (%rsi)\n+; X86-64-NEXT:    retq\n+;\n+; X86-32-LABEL: test_fcmp_storefloat:\n+; X86-32:       # %bb.0: # %entry\n+; X86-32-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero\n+; X86-32-NEXT:    vmovss {{.*#+}} xmm1 = mem[0],zero,zero,zero\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %eax\n+; X86-32-NEXT:    testb $1, {{[0-9]+}}(%esp)\n+; X86-32-NEXT:    je .LBB0_2\n+; X86-32-NEXT:  # %bb.1: # %if\n+; X86-32-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero\n+; X86-32-NEXT:    vcmpeqss {{[0-9]+}}(%esp), %xmm2, %k1\n+; X86-32-NEXT:    jmp .LBB0_3\n+; X86-32-NEXT:  .LBB0_2: # %else\n+; X86-32-NEXT:    vmovss {{.*#+}} xmm2 = mem[0],zero,zero,zero\n+; X86-32-NEXT:    vcmpeqss {{[0-9]+}}(%esp), %xmm2, %k1\n+; X86-32-NEXT:  .LBB0_3: # %exit\n+; X86-32-NEXT:    vmovss %xmm1, %xmm0, %xmm0 {%k1}\n+; X86-32-NEXT:    vmovss %xmm0, (%eax)\n+; X86-32-NEXT:    retl\n entry:\n   br i1 %cond, label %if, label %else\n \n@@ -34,20 +54,38 @@ exit:\n }\n \n define void @test_fcmp_storei1(i1 %cond, float* %fptr, i1* %iptr, float %f1, float %f2, float %f3, float %f4) {\n-; CHECK-LABEL: test_fcmp_storei1:\n-; CHECK:       # %bb.0: # %entry\n-; CHECK-NEXT:    testb $1, %dil\n-; CHECK-NEXT:    je .LBB1_2\n-; CHECK-NEXT:  # %bb.1: # %if\n-; CHECK-NEXT:    vcmpeqss %xmm1, %xmm0, %k0\n-; CHECK-NEXT:    jmp .LBB1_3\n-; CHECK-NEXT:  .LBB1_2: # %else\n-; CHECK-NEXT:    vcmpeqss %xmm3, %xmm2, %k0\n-; CHECK-NEXT:  .LBB1_3: # %exit\n-; CHECK-NEXT:    kmovd %k0, %eax\n-; CHECK-NEXT:    andb $1, %al\n-; CHECK-NEXT:    movb %al, (%rdx)\n-; CHECK-NEXT:    retq\n+; X86-64-LABEL: test_fcmp_storei1:\n+; X86-64:       # %bb.0: # %entry\n+; X86-64-NEXT:    testb $1, %dil\n+; X86-64-NEXT:    je .LBB1_2\n+; X86-64-NEXT:  # %bb.1: # %if\n+; X86-64-NEXT:    vcmpeqss %xmm1, %xmm0, %k0\n+; X86-64-NEXT:    jmp .LBB1_3\n+; X86-64-NEXT:  .LBB1_2: # %else\n+; X86-64-NEXT:    vcmpeqss %xmm3, %xmm2, %k0\n+; X86-64-NEXT:  .LBB1_3: # %exit\n+; X86-64-NEXT:    kmovd %k0, %eax\n+; X86-64-NEXT:    andb $1, %al\n+; X86-64-NEXT:    movb %al, (%rdx)\n+; X86-64-NEXT:    retq\n+;\n+; X86-32-LABEL: test_fcmp_storei1:\n+; X86-32:       # %bb.0: # %entry\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %eax\n+; X86-32-NEXT:    testb $1, {{[0-9]+}}(%esp)\n+; X86-32-NEXT:    je .LBB1_2\n+; X86-32-NEXT:  # %bb.1: # %if\n+; X86-32-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero\n+; X86-32-NEXT:    vcmpeqss {{[0-9]+}}(%esp), %xmm0, %k0\n+; X86-32-NEXT:    jmp .LBB1_3\n+; X86-32-NEXT:  .LBB1_2: # %else\n+; X86-32-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero\n+; X86-32-NEXT:    vcmpeqss {{[0-9]+}}(%esp), %xmm0, %k0\n+; X86-32-NEXT:  .LBB1_3: # %exit\n+; X86-32-NEXT:    kmovd %k0, %ecx\n+; X86-32-NEXT:    andb $1, %cl\n+; X86-32-NEXT:    movb %cl, (%eax)\n+; X86-32-NEXT:    retl\n entry:\n   br i1 %cond, label %if, label %else\n \n@@ -66,21 +104,42 @@ exit:\n }\n \n define void @test_load_add(i1 %cond, float* %fptr, i1* %iptr1, i1* %iptr2, float %f1, float %f2)  {\n-; CHECK-LABEL: test_load_add:\n-; CHECK:       # %bb.0: # %entry\n-; CHECK-NEXT:    testb $1, %dil\n-; CHECK-NEXT:    je .LBB2_2\n-; CHECK-NEXT:  # %bb.1: # %if\n-; CHECK-NEXT:    kmovb (%rdx), %k0\n-; CHECK-NEXT:    kmovb (%rcx), %k1\n-; CHECK-NEXT:    kaddb %k1, %k0, %k1\n-; CHECK-NEXT:    jmp .LBB2_3\n-; CHECK-NEXT:  .LBB2_2: # %else\n-; CHECK-NEXT:    kmovb (%rcx), %k1\n-; CHECK-NEXT:  .LBB2_3: # %exit\n-; CHECK-NEXT:    vmovss %xmm0, %xmm0, %xmm1 {%k1}\n-; CHECK-NEXT:    vmovss %xmm1, (%rsi)\n-; CHECK-NEXT:    retq\n+; X86-64-LABEL: test_load_add:\n+; X86-64:       # %bb.0: # %entry\n+; X86-64-NEXT:    testb $1, %dil\n+; X86-64-NEXT:    je .LBB2_2\n+; X86-64-NEXT:  # %bb.1: # %if\n+; X86-64-NEXT:    kmovb (%rdx), %k0\n+; X86-64-NEXT:    kmovb (%rcx), %k1\n+; X86-64-NEXT:    kaddb %k1, %k0, %k1\n+; X86-64-NEXT:    jmp .LBB2_3\n+; X86-64-NEXT:  .LBB2_2: # %else\n+; X86-64-NEXT:    kmovb (%rcx), %k1\n+; X86-64-NEXT:  .LBB2_3: # %exit\n+; X86-64-NEXT:    vmovss %xmm0, %xmm0, %xmm1 {%k1}\n+; X86-64-NEXT:    vmovss %xmm1, (%rsi)\n+; X86-64-NEXT:    retq\n+;\n+; X86-32-LABEL: test_load_add:\n+; X86-32:       # %bb.0: # %entry\n+; X86-32-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero\n+; X86-32-NEXT:    vmovss {{.*#+}} xmm1 = mem[0],zero,zero,zero\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %eax\n+; X86-32-NEXT:    testb $1, {{[0-9]+}}(%esp)\n+; X86-32-NEXT:    je .LBB2_2\n+; X86-32-NEXT:  # %bb.1: # %if\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %edx\n+; X86-32-NEXT:    kmovb (%edx), %k0\n+; X86-32-NEXT:    kmovb (%ecx), %k1\n+; X86-32-NEXT:    kaddb %k1, %k0, %k1\n+; X86-32-NEXT:    jmp .LBB2_3\n+; X86-32-NEXT:  .LBB2_2: # %else\n+; X86-32-NEXT:    kmovb (%ecx), %k1\n+; X86-32-NEXT:  .LBB2_3: # %exit\n+; X86-32-NEXT:    vmovss %xmm1, %xmm0, %xmm0 {%k1}\n+; X86-32-NEXT:    vmovss %xmm0, (%eax)\n+; X86-32-NEXT:    retl\n entry:\n   br i1 %cond, label %if, label %else\n \n@@ -102,19 +161,37 @@ exit:\n }\n \n define void @test_load_i1(i1 %cond, float* %fptr, i1* %iptr1, i1* %iptr2, float %f1, float %f2)  {\n-; CHECK-LABEL: test_load_i1:\n-; CHECK:       # %bb.0: # %entry\n-; CHECK-NEXT:    testb $1, %dil\n-; CHECK-NEXT:    je .LBB3_2\n-; CHECK-NEXT:  # %bb.1: # %if\n-; CHECK-NEXT:    kmovb (%rdx), %k1\n-; CHECK-NEXT:    jmp .LBB3_3\n-; CHECK-NEXT:  .LBB3_2: # %else\n-; CHECK-NEXT:    kmovb (%rcx), %k1\n-; CHECK-NEXT:  .LBB3_3: # %exit\n-; CHECK-NEXT:    vmovss %xmm0, %xmm0, %xmm1 {%k1}\n-; CHECK-NEXT:    vmovss %xmm1, (%rsi)\n-; CHECK-NEXT:    retq\n+; X86-64-LABEL: test_load_i1:\n+; X86-64:       # %bb.0: # %entry\n+; X86-64-NEXT:    testb $1, %dil\n+; X86-64-NEXT:    je .LBB3_2\n+; X86-64-NEXT:  # %bb.1: # %if\n+; X86-64-NEXT:    kmovb (%rdx), %k1\n+; X86-64-NEXT:    jmp .LBB3_3\n+; X86-64-NEXT:  .LBB3_2: # %else\n+; X86-64-NEXT:    kmovb (%rcx), %k1\n+; X86-64-NEXT:  .LBB3_3: # %exit\n+; X86-64-NEXT:    vmovss %xmm0, %xmm0, %xmm1 {%k1}\n+; X86-64-NEXT:    vmovss %xmm1, (%rsi)\n+; X86-64-NEXT:    retq\n+;\n+; X86-32-LABEL: test_load_i1:\n+; X86-32:       # %bb.0: # %entry\n+; X86-32-NEXT:    vmovss {{.*#+}} xmm0 = mem[0],zero,zero,zero\n+; X86-32-NEXT:    vmovss {{.*#+}} xmm1 = mem[0],zero,zero,zero\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %eax\n+; X86-32-NEXT:    testb $1, {{[0-9]+}}(%esp)\n+; X86-32-NEXT:    je .LBB3_2\n+; X86-32-NEXT:  # %bb.1: # %if\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n+; X86-32-NEXT:    jmp .LBB3_3\n+; X86-32-NEXT:  .LBB3_2: # %else\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n+; X86-32-NEXT:  .LBB3_3: # %exit\n+; X86-32-NEXT:    kmovb (%ecx), %k1\n+; X86-32-NEXT:    vmovss %xmm1, %xmm0, %xmm0 {%k1}\n+; X86-32-NEXT:    vmovss %xmm0, (%eax)\n+; X86-32-NEXT:    retl\n entry:\n   br i1 %cond, label %if, label %else\n \n@@ -134,19 +211,35 @@ exit:\n }\n \n define void @test_loadi1_storei1(i1 %cond, i1* %iptr1, i1* %iptr2, i1* %iptr3)  {\n-; CHECK-LABEL: test_loadi1_storei1:\n-; CHECK:       # %bb.0: # %entry\n-; CHECK-NEXT:    testb $1, %dil\n-; CHECK-NEXT:    je .LBB4_2\n-; CHECK-NEXT:  # %bb.1: # %if\n-; CHECK-NEXT:    movb (%rsi), %al\n-; CHECK-NEXT:    jmp .LBB4_3\n-; CHECK-NEXT:  .LBB4_2: # %else\n-; CHECK-NEXT:    movb (%rdx), %al\n-; CHECK-NEXT:  .LBB4_3: # %exit\n-; CHECK-NEXT:    andb $1, %al\n-; CHECK-NEXT:    movb %al, (%rcx)\n-; CHECK-NEXT:    retq\n+; X86-64-LABEL: test_loadi1_storei1:\n+; X86-64:       # %bb.0: # %entry\n+; X86-64-NEXT:    testb $1, %dil\n+; X86-64-NEXT:    je .LBB4_2\n+; X86-64-NEXT:  # %bb.1: # %if\n+; X86-64-NEXT:    movb (%rsi), %al\n+; X86-64-NEXT:    jmp .LBB4_3\n+; X86-64-NEXT:  .LBB4_2: # %else\n+; X86-64-NEXT:    movb (%rdx), %al\n+; X86-64-NEXT:  .LBB4_3: # %exit\n+; X86-64-NEXT:    andb $1, %al\n+; X86-64-NEXT:    movb %al, (%rcx)\n+; X86-64-NEXT:    retq\n+;\n+; X86-32-LABEL: test_loadi1_storei1:\n+; X86-32:       # %bb.0: # %entry\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %eax\n+; X86-32-NEXT:    testb $1, {{[0-9]+}}(%esp)\n+; X86-32-NEXT:    je .LBB4_2\n+; X86-32-NEXT:  # %bb.1: # %if\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n+; X86-32-NEXT:    jmp .LBB4_3\n+; X86-32-NEXT:  .LBB4_2: # %else\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n+; X86-32-NEXT:  .LBB4_3: # %exit\n+; X86-32-NEXT:    movb (%ecx), %cl\n+; X86-32-NEXT:    andb $1, %cl\n+; X86-32-NEXT:    movb %cl, (%eax)\n+; X86-32-NEXT:    retl\n entry:\n   br i1 %cond, label %if, label %else\n \n@@ -165,23 +258,44 @@ exit:\n }\n \n define void @test_shl1(i1 %cond, i8* %ptr1, i8* %ptr2, <8 x float> %fvec1, <8 x float> %fvec2, <8 x float>* %fptrvec) {\n-; CHECK-LABEL: test_shl1:\n-; CHECK:       # %bb.0: # %entry\n-; CHECK-NEXT:    # kill: %ymm1<def> %ymm1<kill> %zmm1<def>\n-; CHECK-NEXT:    # kill: %ymm0<def> %ymm0<kill> %zmm0<def>\n-; CHECK-NEXT:    testb $1, %dil\n-; CHECK-NEXT:    je .LBB5_2\n-; CHECK-NEXT:  # %bb.1: # %if\n-; CHECK-NEXT:    kmovb (%rsi), %k0\n-; CHECK-NEXT:    kaddb %k0, %k0, %k1\n-; CHECK-NEXT:    jmp .LBB5_3\n-; CHECK-NEXT:  .LBB5_2: # %else\n-; CHECK-NEXT:    kmovb (%rdx), %k1\n-; CHECK-NEXT:  .LBB5_3: # %exit\n-; CHECK-NEXT:    vmovaps %zmm0, %zmm1 {%k1}\n-; CHECK-NEXT:    vmovaps %ymm1, (%rcx)\n-; CHECK-NEXT:    vzeroupper\n-; CHECK-NEXT:    retq\n+; X86-64-LABEL: test_shl1:\n+; X86-64:       # %bb.0: # %entry\n+; X86-64-NEXT:    # kill: %ymm1<def> %ymm1<kill> %zmm1<def>\n+; X86-64-NEXT:    # kill: %ymm0<def> %ymm0<kill> %zmm0<def>\n+; X86-64-NEXT:    testb $1, %dil\n+; X86-64-NEXT:    je .LBB5_2\n+; X86-64-NEXT:  # %bb.1: # %if\n+; X86-64-NEXT:    kmovb (%rsi), %k0\n+; X86-64-NEXT:    kaddb %k0, %k0, %k1\n+; X86-64-NEXT:    jmp .LBB5_3\n+; X86-64-NEXT:  .LBB5_2: # %else\n+; X86-64-NEXT:    kmovb (%rdx), %k1\n+; X86-64-NEXT:  .LBB5_3: # %exit\n+; X86-64-NEXT:    vmovaps %zmm0, %zmm1 {%k1}\n+; X86-64-NEXT:    vmovaps %ymm1, (%rcx)\n+; X86-64-NEXT:    vzeroupper\n+; X86-64-NEXT:    retq\n+;\n+; X86-32-LABEL: test_shl1:\n+; X86-32:       # %bb.0: # %entry\n+; X86-32-NEXT:    # kill: %ymm1<def> %ymm1<kill> %zmm1<def>\n+; X86-32-NEXT:    # kill: %ymm0<def> %ymm0<kill> %zmm0<def>\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %eax\n+; X86-32-NEXT:    testb $1, {{[0-9]+}}(%esp)\n+; X86-32-NEXT:    je .LBB5_2\n+; X86-32-NEXT:  # %bb.1: # %if\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n+; X86-32-NEXT:    kmovb (%ecx), %k0\n+; X86-32-NEXT:    kaddb %k0, %k0, %k1\n+; X86-32-NEXT:    jmp .LBB5_3\n+; X86-32-NEXT:  .LBB5_2: # %else\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n+; X86-32-NEXT:    kmovb (%ecx), %k1\n+; X86-32-NEXT:  .LBB5_3: # %exit\n+; X86-32-NEXT:    vmovaps %zmm0, %zmm1 {%k1}\n+; X86-32-NEXT:    vmovaps %ymm1, (%eax)\n+; X86-32-NEXT:    vzeroupper\n+; X86-32-NEXT:    retl\n entry:\n   br i1 %cond, label %if, label %else\n \n@@ -203,24 +317,46 @@ exit:\n }\n \n define void @test_shr1(i1 %cond, i8* %ptr1, i8* %ptr2, <8 x float> %fvec1, <8 x float> %fvec2, <8 x float>* %fptrvec) {\n-; CHECK-LABEL: test_shr1:\n-; CHECK:       # %bb.0: # %entry\n-; CHECK-NEXT:    # kill: %ymm1<def> %ymm1<kill> %zmm1<def>\n-; CHECK-NEXT:    # kill: %ymm0<def> %ymm0<kill> %zmm0<def>\n-; CHECK-NEXT:    testb $1, %dil\n-; CHECK-NEXT:    je .LBB6_2\n-; CHECK-NEXT:  # %bb.1: # %if\n-; CHECK-NEXT:    movb (%rsi), %al\n-; CHECK-NEXT:    shrb %al\n-; CHECK-NEXT:    jmp .LBB6_3\n-; CHECK-NEXT:  .LBB6_2: # %else\n-; CHECK-NEXT:    movb (%rdx), %al\n-; CHECK-NEXT:  .LBB6_3: # %exit\n-; CHECK-NEXT:    kmovd %eax, %k1\n-; CHECK-NEXT:    vmovaps %zmm0, %zmm1 {%k1}\n-; CHECK-NEXT:    vmovaps %ymm1, (%rcx)\n-; CHECK-NEXT:    vzeroupper\n-; CHECK-NEXT:    retq\n+; X86-64-LABEL: test_shr1:\n+; X86-64:       # %bb.0: # %entry\n+; X86-64-NEXT:    # kill: %ymm1<def> %ymm1<kill> %zmm1<def>\n+; X86-64-NEXT:    # kill: %ymm0<def> %ymm0<kill> %zmm0<def>\n+; X86-64-NEXT:    testb $1, %dil\n+; X86-64-NEXT:    je .LBB6_2\n+; X86-64-NEXT:  # %bb.1: # %if\n+; X86-64-NEXT:    movb (%rsi), %al\n+; X86-64-NEXT:    shrb %al\n+; X86-64-NEXT:    jmp .LBB6_3\n+; X86-64-NEXT:  .LBB6_2: # %else\n+; X86-64-NEXT:    movb (%rdx), %al\n+; X86-64-NEXT:  .LBB6_3: # %exit\n+; X86-64-NEXT:    kmovd %eax, %k1\n+; X86-64-NEXT:    vmovaps %zmm0, %zmm1 {%k1}\n+; X86-64-NEXT:    vmovaps %ymm1, (%rcx)\n+; X86-64-NEXT:    vzeroupper\n+; X86-64-NEXT:    retq\n+;\n+; X86-32-LABEL: test_shr1:\n+; X86-32:       # %bb.0: # %entry\n+; X86-32-NEXT:    # kill: %ymm1<def> %ymm1<kill> %zmm1<def>\n+; X86-32-NEXT:    # kill: %ymm0<def> %ymm0<kill> %zmm0<def>\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %eax\n+; X86-32-NEXT:    testb $1, {{[0-9]+}}(%esp)\n+; X86-32-NEXT:    je .LBB6_2\n+; X86-32-NEXT:  # %bb.1: # %if\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n+; X86-32-NEXT:    movb (%ecx), %cl\n+; X86-32-NEXT:    shrb %cl\n+; X86-32-NEXT:    jmp .LBB6_3\n+; X86-32-NEXT:  .LBB6_2: # %else\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n+; X86-32-NEXT:    movb (%ecx), %cl\n+; X86-32-NEXT:  .LBB6_3: # %exit\n+; X86-32-NEXT:    kmovd %ecx, %k1\n+; X86-32-NEXT:    vmovaps %zmm0, %zmm1 {%k1}\n+; X86-32-NEXT:    vmovaps %ymm1, (%eax)\n+; X86-32-NEXT:    vzeroupper\n+; X86-32-NEXT:    retl\n entry:\n   br i1 %cond, label %if, label %else\n \n@@ -242,23 +378,44 @@ exit:\n }\n \n define void @test_shr2(i1 %cond, i8* %ptr1, i8* %ptr2, <8 x float> %fvec1, <8 x float> %fvec2, <8 x float>* %fptrvec) {\n-; CHECK-LABEL: test_shr2:\n-; CHECK:       # %bb.0: # %entry\n-; CHECK-NEXT:    # kill: %ymm1<def> %ymm1<kill> %zmm1<def>\n-; CHECK-NEXT:    # kill: %ymm0<def> %ymm0<kill> %zmm0<def>\n-; CHECK-NEXT:    testb $1, %dil\n-; CHECK-NEXT:    je .LBB7_2\n-; CHECK-NEXT:  # %bb.1: # %if\n-; CHECK-NEXT:    kmovb (%rsi), %k0\n-; CHECK-NEXT:    kshiftrb $2, %k0, %k1\n-; CHECK-NEXT:    jmp .LBB7_3\n-; CHECK-NEXT:  .LBB7_2: # %else\n-; CHECK-NEXT:    kmovb (%rdx), %k1\n-; CHECK-NEXT:  .LBB7_3: # %exit\n-; CHECK-NEXT:    vmovaps %zmm0, %zmm1 {%k1}\n-; CHECK-NEXT:    vmovaps %ymm1, (%rcx)\n-; CHECK-NEXT:    vzeroupper\n-; CHECK-NEXT:    retq\n+; X86-64-LABEL: test_shr2:\n+; X86-64:       # %bb.0: # %entry\n+; X86-64-NEXT:    # kill: %ymm1<def> %ymm1<kill> %zmm1<def>\n+; X86-64-NEXT:    # kill: %ymm0<def> %ymm0<kill> %zmm0<def>\n+; X86-64-NEXT:    testb $1, %dil\n+; X86-64-NEXT:    je .LBB7_2\n+; X86-64-NEXT:  # %bb.1: # %if\n+; X86-64-NEXT:    kmovb (%rsi), %k0\n+; X86-64-NEXT:    kshiftrb $2, %k0, %k1\n+; X86-64-NEXT:    jmp .LBB7_3\n+; X86-64-NEXT:  .LBB7_2: # %else\n+; X86-64-NEXT:    kmovb (%rdx), %k1\n+; X86-64-NEXT:  .LBB7_3: # %exit\n+; X86-64-NEXT:    vmovaps %zmm0, %zmm1 {%k1}\n+; X86-64-NEXT:    vmovaps %ymm1, (%rcx)\n+; X86-64-NEXT:    vzeroupper\n+; X86-64-NEXT:    retq\n+;\n+; X86-32-LABEL: test_shr2:\n+; X86-32:       # %bb.0: # %entry\n+; X86-32-NEXT:    # kill: %ymm1<def> %ymm1<kill> %zmm1<def>\n+; X86-32-NEXT:    # kill: %ymm0<def> %ymm0<kill> %zmm0<def>\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %eax\n+; X86-32-NEXT:    testb $1, {{[0-9]+}}(%esp)\n+; X86-32-NEXT:    je .LBB7_2\n+; X86-32-NEXT:  # %bb.1: # %if\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n+; X86-32-NEXT:    kmovb (%ecx), %k0\n+; X86-32-NEXT:    kshiftrb $2, %k0, %k1\n+; X86-32-NEXT:    jmp .LBB7_3\n+; X86-32-NEXT:  .LBB7_2: # %else\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n+; X86-32-NEXT:    kmovb (%ecx), %k1\n+; X86-32-NEXT:  .LBB7_3: # %exit\n+; X86-32-NEXT:    vmovaps %zmm0, %zmm1 {%k1}\n+; X86-32-NEXT:    vmovaps %ymm1, (%eax)\n+; X86-32-NEXT:    vzeroupper\n+; X86-32-NEXT:    retl\n entry:\n   br i1 %cond, label %if, label %else\n \n@@ -280,23 +437,44 @@ exit:\n }\n \n define void @test_shl(i1 %cond, i8* %ptr1, i8* %ptr2, <8 x float> %fvec1, <8 x float> %fvec2, <8 x float>* %fptrvec) {\n-; CHECK-LABEL: test_shl:\n-; CHECK:       # %bb.0: # %entry\n-; CHECK-NEXT:    # kill: %ymm1<def> %ymm1<kill> %zmm1<def>\n-; CHECK-NEXT:    # kill: %ymm0<def> %ymm0<kill> %zmm0<def>\n-; CHECK-NEXT:    testb $1, %dil\n-; CHECK-NEXT:    je .LBB8_2\n-; CHECK-NEXT:  # %bb.1: # %if\n-; CHECK-NEXT:    kmovb (%rsi), %k0\n-; CHECK-NEXT:    kshiftlb $6, %k0, %k1\n-; CHECK-NEXT:    jmp .LBB8_3\n-; CHECK-NEXT:  .LBB8_2: # %else\n-; CHECK-NEXT:    kmovb (%rdx), %k1\n-; CHECK-NEXT:  .LBB8_3: # %exit\n-; CHECK-NEXT:    vmovaps %zmm0, %zmm1 {%k1}\n-; CHECK-NEXT:    vmovaps %ymm1, (%rcx)\n-; CHECK-NEXT:    vzeroupper\n-; CHECK-NEXT:    retq\n+; X86-64-LABEL: test_shl:\n+; X86-64:       # %bb.0: # %entry\n+; X86-64-NEXT:    # kill: %ymm1<def> %ymm1<kill> %zmm1<def>\n+; X86-64-NEXT:    # kill: %ymm0<def> %ymm0<kill> %zmm0<def>\n+; X86-64-NEXT:    testb $1, %dil\n+; X86-64-NEXT:    je .LBB8_2\n+; X86-64-NEXT:  # %bb.1: # %if\n+; X86-64-NEXT:    kmovb (%rsi), %k0\n+; X86-64-NEXT:    kshiftlb $6, %k0, %k1\n+; X86-64-NEXT:    jmp .LBB8_3\n+; X86-64-NEXT:  .LBB8_2: # %else\n+; X86-64-NEXT:    kmovb (%rdx), %k1\n+; X86-64-NEXT:  .LBB8_3: # %exit\n+; X86-64-NEXT:    vmovaps %zmm0, %zmm1 {%k1}\n+; X86-64-NEXT:    vmovaps %ymm1, (%rcx)\n+; X86-64-NEXT:    vzeroupper\n+; X86-64-NEXT:    retq\n+;\n+; X86-32-LABEL: test_shl:\n+; X86-32:       # %bb.0: # %entry\n+; X86-32-NEXT:    # kill: %ymm1<def> %ymm1<kill> %zmm1<def>\n+; X86-32-NEXT:    # kill: %ymm0<def> %ymm0<kill> %zmm0<def>\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %eax\n+; X86-32-NEXT:    testb $1, {{[0-9]+}}(%esp)\n+; X86-32-NEXT:    je .LBB8_2\n+; X86-32-NEXT:  # %bb.1: # %if\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n+; X86-32-NEXT:    kmovb (%ecx), %k0\n+; X86-32-NEXT:    kshiftlb $6, %k0, %k1\n+; X86-32-NEXT:    jmp .LBB8_3\n+; X86-32-NEXT:  .LBB8_2: # %else\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n+; X86-32-NEXT:    kmovb (%ecx), %k1\n+; X86-32-NEXT:  .LBB8_3: # %exit\n+; X86-32-NEXT:    vmovaps %zmm0, %zmm1 {%k1}\n+; X86-32-NEXT:    vmovaps %ymm1, (%eax)\n+; X86-32-NEXT:    vzeroupper\n+; X86-32-NEXT:    retl\n entry:\n   br i1 %cond, label %if, label %else\n \n@@ -318,24 +496,46 @@ exit:\n }\n \n define void @test_add(i1 %cond, i8* %ptr1, i8* %ptr2, <8 x float> %fvec1, <8 x float> %fvec2, <8 x float>* %fptrvec) {\n-; CHECK-LABEL: test_add:\n-; CHECK:       # %bb.0: # %entry\n-; CHECK-NEXT:    # kill: %ymm1<def> %ymm1<kill> %zmm1<def>\n-; CHECK-NEXT:    # kill: %ymm0<def> %ymm0<kill> %zmm0<def>\n-; CHECK-NEXT:    kmovb (%rsi), %k0\n-; CHECK-NEXT:    kmovb (%rdx), %k1\n-; CHECK-NEXT:    testb $1, %dil\n-; CHECK-NEXT:    je .LBB9_2\n-; CHECK-NEXT:  # %bb.1: # %if\n-; CHECK-NEXT:    kandb %k1, %k0, %k1\n-; CHECK-NEXT:    jmp .LBB9_3\n-; CHECK-NEXT:  .LBB9_2: # %else\n-; CHECK-NEXT:    kaddb %k1, %k0, %k1\n-; CHECK-NEXT:  .LBB9_3: # %exit\n-; CHECK-NEXT:    vmovaps %zmm0, %zmm1 {%k1}\n-; CHECK-NEXT:    vmovaps %ymm1, (%rcx)\n-; CHECK-NEXT:    vzeroupper\n-; CHECK-NEXT:    retq\n+; X86-64-LABEL: test_add:\n+; X86-64:       # %bb.0: # %entry\n+; X86-64-NEXT:    # kill: %ymm1<def> %ymm1<kill> %zmm1<def>\n+; X86-64-NEXT:    # kill: %ymm0<def> %ymm0<kill> %zmm0<def>\n+; X86-64-NEXT:    kmovb (%rsi), %k0\n+; X86-64-NEXT:    kmovb (%rdx), %k1\n+; X86-64-NEXT:    testb $1, %dil\n+; X86-64-NEXT:    je .LBB9_2\n+; X86-64-NEXT:  # %bb.1: # %if\n+; X86-64-NEXT:    kandb %k1, %k0, %k1\n+; X86-64-NEXT:    jmp .LBB9_3\n+; X86-64-NEXT:  .LBB9_2: # %else\n+; X86-64-NEXT:    kaddb %k1, %k0, %k1\n+; X86-64-NEXT:  .LBB9_3: # %exit\n+; X86-64-NEXT:    vmovaps %zmm0, %zmm1 {%k1}\n+; X86-64-NEXT:    vmovaps %ymm1, (%rcx)\n+; X86-64-NEXT:    vzeroupper\n+; X86-64-NEXT:    retq\n+;\n+; X86-32-LABEL: test_add:\n+; X86-32:       # %bb.0: # %entry\n+; X86-32-NEXT:    # kill: %ymm1<def> %ymm1<kill> %zmm1<def>\n+; X86-32-NEXT:    # kill: %ymm0<def> %ymm0<kill> %zmm0<def>\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %eax\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n+; X86-32-NEXT:    movl {{[0-9]+}}(%esp), %edx\n+; X86-32-NEXT:    kmovb (%edx), %k0\n+; X86-32-NEXT:    kmovb (%ecx), %k1\n+; X86-32-NEXT:    testb $1, {{[0-9]+}}(%esp)\n+; X86-32-NEXT:    je .LBB9_2\n+; X86-32-NEXT:  # %bb.1: # %if\n+; X86-32-NEXT:    kandb %k1, %k0, %k1\n+; X86-32-NEXT:    jmp .LBB9_3\n+; X86-32-NEXT:  .LBB9_2: # %else\n+; X86-32-NEXT:    kaddb %k1, %k0, %k1\n+; X86-32-NEXT:  .LBB9_3: # %exit\n+; X86-32-NEXT:    vmovaps %zmm0, %zmm1 {%k1}\n+; X86-32-NEXT:    vmovaps %ymm1, (%eax)\n+; X86-32-NEXT:    vzeroupper\n+; X86-32-NEXT:    retl\n entry:\n   %loaded1 = load i8, i8* %ptr1\n   %loaded2 = load i8, i8* %ptr2"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/gpr-to-mask.ll (1 of 1)\nTesting Time: 0.71s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/gpr-to-mask.ll\n\n  Unexpected Failures: 1\n"
    },
    "b69e5b739352d75f8adce23c3230e3be304ad89a___GlobalOpt.cpp": {
        "start": 486,
        "end": 633,
        "buggy": "static GlobalVariable *SRAGlobal(GlobalVariable *GV, const DataLayout &DL) {\n  // Make sure this global only has simple uses that we can SRA.\n  if (!GlobalUsersSafeToSRA(GV))\n    return nullptr;\n\n  assert(GV->hasLocalLinkage());\n  Constant *Init = GV->getInitializer();\n  Type *Ty = Init->getType();\n\n  std::vector<GlobalVariable *> NewGlobals;\n  Module::GlobalListType &Globals = GV->getParent()->getGlobalList();\n\n  // Get the alignment of the global, either explicit or target-specific.\n  unsigned StartAlignment = GV->getAlignment();\n  if (StartAlignment == 0)\n    StartAlignment = DL.getABITypeAlignment(GV->getType());\n\n  if (StructType *STy = dyn_cast<StructType>(Ty)) {\n    unsigned NumElements = STy->getNumElements();\n    NewGlobals.reserve(NumElements);\n    const StructLayout &Layout = *DL.getStructLayout(STy);\n    for (unsigned i = 0, e = NumElements; i != e; ++i) {\n      Constant *In = Init->getAggregateElement(i);\n      assert(In && \"Couldn't get element of initializer?\");\n      GlobalVariable *NGV = new GlobalVariable(STy->getElementType(i), false,\n                                               GlobalVariable::InternalLinkage,\n                                               In, GV->getName()+\".\"+Twine(i),\n                                               GV->getThreadLocalMode(),\n                                              GV->getType()->getAddressSpace());\n      NGV->setExternallyInitialized(GV->isExternallyInitialized());\n      NGV->copyAttributesFrom(GV);\n      Globals.push_back(NGV);\n      NewGlobals.push_back(NGV);\n\n      // Calculate the known alignment of the field.  If the original aggregate\n      // had 256 byte alignment for example, something might depend on that:\n      // propagate info to each field.\n      uint64_t FieldOffset = Layout.getElementOffset(i);\n      unsigned NewAlign = (unsigned)MinAlign(StartAlignment, FieldOffset);\n      if (NewAlign > DL.getABITypeAlignment(STy->getElementType(i)))\n        NGV->setAlignment(NewAlign);\n\n      // Copy over the debug info for the variable.\n      uint64_t Size = DL.getTypeSizeInBits(NGV->getValueType());\n      uint64_t FragmentOffsetInBits = Layout.getElementOffsetInBits(i);\n      transferSRADebugInfo(GV, NGV, FragmentOffsetInBits, Size, NumElements);\n    }\n  } else if (SequentialType *STy = dyn_cast<SequentialType>(Ty)) {\n    unsigned NumElements = STy->getNumElements();\n    if (NumElements > 16 && GV->hasNUsesOrMore(16))\n      return nullptr; // It's not worth it.\n    NewGlobals.reserve(NumElements);\n    auto ElTy = STy->getElementType();\n    uint64_t EltSize = DL.getTypeAllocSize(ElTy);\n    unsigned EltAlign = DL.getABITypeAlignment(ElTy);\n    uint64_t FragmentSizeInBits = DL.getTypeSizeInBits(ElTy);\n    for (unsigned i = 0, e = NumElements; i != e; ++i) {\n      Constant *In = Init->getAggregateElement(i);\n      assert(In && \"Couldn't get element of initializer?\");\n\n      GlobalVariable *NGV = new GlobalVariable(STy->getElementType(), false,\n                                               GlobalVariable::InternalLinkage,\n                                               In, GV->getName()+\".\"+Twine(i),\n                                               GV->getThreadLocalMode(),\n                                              GV->getType()->getAddressSpace());\n      NGV->setExternallyInitialized(GV->isExternallyInitialized());\n      NGV->copyAttributesFrom(GV);\n      Globals.push_back(NGV);\n      NewGlobals.push_back(NGV);\n\n      // Calculate the known alignment of the field.  If the original aggregate\n      // had 256 byte alignment for example, something might depend on that:\n      // propagate info to each field.\n      unsigned NewAlign = (unsigned)MinAlign(StartAlignment, EltSize*i);\n      if (NewAlign > EltAlign)\n        NGV->setAlignment(NewAlign);\n      transferSRADebugInfo(GV, NGV, FragmentSizeInBits * i, FragmentSizeInBits,\n                           NumElements);\n    }\n  }\n\n  if (NewGlobals.empty())\n    return nullptr;\n\n  DEBUG(dbgs() << \"PERFORMING GLOBAL SRA ON: \" << *GV << \"\\n\");\n\n  Constant *NullInt =Constant::getNullValue(Type::getInt32Ty(GV->getContext()));\n\n  // Loop over all of the uses of the global, replacing the constantexpr geps,\n  // with smaller constantexpr geps or direct references.\n  while (!GV->use_empty()) {\n    User *GEP = GV->user_back();\n    assert(((isa<ConstantExpr>(GEP) &&\n             cast<ConstantExpr>(GEP)->getOpcode()==Instruction::GetElementPtr)||\n            isa<GetElementPtrInst>(GEP)) && \"NonGEP CE's are not SRAable!\");\n\n    // Ignore the 1th operand, which has to be zero or else the program is quite\n    // broken (undefined).  Get the 2nd operand, which is the structure or array\n    // index.\n    unsigned Val = cast<ConstantInt>(GEP->getOperand(2))->getZExtValue();\n    if (Val >= NewGlobals.size()) Val = 0; // Out of bound array access.\n\n    Value *NewPtr = NewGlobals[Val];\n    Type *NewTy = NewGlobals[Val]->getValueType();\n\n    // Form a shorter GEP if needed.\n    if (GEP->getNumOperands() > 3) {\n      if (ConstantExpr *CE = dyn_cast<ConstantExpr>(GEP)) {\n        SmallVector<Constant*, 8> Idxs;\n        Idxs.push_back(NullInt);\n        for (unsigned i = 3, e = CE->getNumOperands(); i != e; ++i)\n          Idxs.push_back(CE->getOperand(i));\n        NewPtr =\n            ConstantExpr::getGetElementPtr(NewTy, cast<Constant>(NewPtr), Idxs);\n      } else {\n        GetElementPtrInst *GEPI = cast<GetElementPtrInst>(GEP);\n        SmallVector<Value*, 8> Idxs;\n        Idxs.push_back(NullInt);\n        for (unsigned i = 3, e = GEPI->getNumOperands(); i != e; ++i)\n          Idxs.push_back(GEPI->getOperand(i));\n        NewPtr = GetElementPtrInst::Create(\n            NewTy, NewPtr, Idxs, GEPI->getName() + \".\" + Twine(Val), GEPI);\n      }\n    }\n    GEP->replaceAllUsesWith(NewPtr);\n\n    if (GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(GEP))\n      GEPI->eraseFromParent();\n    else\n      cast<ConstantExpr>(GEP)->destroyConstant();\n  }\n\n  // Delete the old global, now that it is dead.\n  Globals.erase(GV);\n  ++NumSRA;\n\n  // Loop over the new globals array deleting any globals that are obviously\n  // dead.  This can arise due to scalarization of a structure or an array that\n  // has elements that are dead.\n  unsigned FirstGlobal = 0;\n  for (unsigned i = 0, e = NewGlobals.size(); i != e; ++i)\n    if (NewGlobals[i]->use_empty()) {\n      Globals.erase(NewGlobals[i]);\n      if (FirstGlobal == i) ++FirstGlobal;\n    }\n\n  return FirstGlobal != NewGlobals.size() ? NewGlobals[FirstGlobal] : nullptr;\n}\n",
        "fix": null,
        "src_path": "b69e5b739352d75f8adce23c3230e3be304ad89a___GlobalOpt.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/b69e5b739352d75f8adce23c3230e3be304ad89a",
        "commit_msg": "[GlobalOpt] Include padding in debug fragments\n\nSummary:\nWhen creating the debug fragments for a SRA'd variable, use the types'\nallocation sizes. This fixes issues where the pass would emit too small\nfragments, placed at the wrong offset, for padded types.\n\nAn example of this is long double on x86. The type is represented using\nx86_fp80, which is 10 bytes, but the value is aligned to 12/16 bytes.\nThe padding is included in the type's DW_AT_byte_size attribute;\ntherefore, the fragments should also include that. Newer GCC releases\n(I tested 7.2.0) emit 12/16-byte pieces for long double. Earlier\nreleases, e.g. GCC 5.5.0, behaved as LLVM did, i.e. by emitting a\n10-byte piece, followed by an empty 2/6-byte piece for the padding.\n\nFailing to cover all `DW_AT_byte_size' bytes of a value with non-empty\npieces results in the value being printed as <optimized out> by GDB.\n\nPatch by: David Stenberg\n\nReviewers: aprantl, JDevlieghere\n\nReviewed By: aprantl, JDevlieghere\n\nSubscribers: llvm-commits\n\nTags: #debug-info\n\nDifferential Revision: https://reviews.llvm.org/D42807\n\nllvm-svn: 324066",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/X86/global-sra-fp80-array.ll",
                "patch": "@@ -0,0 +1,129 @@\n+; RUN: opt -S -globalopt < %s | FileCheck %s\n+source_filename = \"array.c\"\n+target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n+target triple = \"x86_64-unknown-linux-gnu\"\n+\n+%struct.mystruct = type { i32, i64 }\n+\n+; Generated from:\n+;\n+; static long double array[2];\n+; void __attribute__((nodebug)) foo(int in) { array[0] = in; }\n+; void __attribute__((nodebug)) bar(int in) { array[1] = in; }\n+; int main(int argc, char **argv)\n+; {\n+;   foo(argv[0][1]);\n+;   bar(argv[0][1]);\n+;   return (array[0] + array[1]) > 0;\n+; }\n+;\n+; using clang -O0 -g2 -S -emit-llvm\n+\n+@array = internal global [2 x x86_fp80] zeroinitializer, align 16, !dbg !0\n+\n+; CHECK: @array.0 = internal unnamed_addr global x86_fp80 0xK00000000000000000000, align 16, !dbg ![[EL0:.*]]\n+; CHECK: @array.1 = internal unnamed_addr global x86_fp80 0xK00000000000000000000, align 16, !dbg ![[EL1:.*]]\n+;\n+; CHECK: ![[EL0]] = !DIGlobalVariableExpression(var: ![[VAR:.*]], expr: !DIExpression(DW_OP_LLVM_fragment, 0, 128))\n+; CHECK: ![[VAR]] = distinct !DIGlobalVariable(name: \"array\"\n+; CHECK: ![[EL1]] = !DIGlobalVariableExpression(var: ![[VAR]], expr: !DIExpression(DW_OP_LLVM_fragment, 128, 128))\n+\n+; Function Attrs: noinline nounwind optnone uwtable\n+define void @foo(i32 %in) #0 {\n+entry:\n+  %in.addr = alloca i32, align 4\n+  store i32 %in, i32* %in.addr, align 4\n+  %0 = load i32, i32* %in.addr, align 4\n+  %conv = sitofp i32 %0 to x86_fp80\n+  store x86_fp80 %conv, x86_fp80* getelementptr inbounds ([2 x x86_fp80], [2 x x86_fp80]* @array, i64 0, i64 0), align 16\n+  ret void\n+}\n+\n+; Function Attrs: noinline nounwind optnone uwtable\n+define void @bar(i32 %in) #0 {\n+entry:\n+  %in.addr = alloca i32, align 4\n+  store i32 %in, i32* %in.addr, align 4\n+  %0 = load i32, i32* %in.addr, align 4\n+  %conv = sitofp i32 %0 to x86_fp80\n+  store x86_fp80 %conv, x86_fp80* getelementptr inbounds ([2 x x86_fp80], [2 x x86_fp80]* @array, i64 0, i64 1), align 16\n+  ret void\n+}\n+\n+; Function Attrs: noinline nounwind optnone uwtable\n+define i32 @main(i32 %argc, i8** %argv) #0 !dbg !14 {\n+entry:\n+  %retval = alloca i32, align 4\n+  %argc.addr = alloca i32, align 4\n+  %argv.addr = alloca i8**, align 8\n+  store i32 0, i32* %retval, align 4\n+  store i32 %argc, i32* %argc.addr, align 4\n+  call void @llvm.dbg.declare(metadata i32* %argc.addr, metadata !21, metadata !DIExpression()), !dbg !22\n+  store i8** %argv, i8*** %argv.addr, align 8\n+  call void @llvm.dbg.declare(metadata i8*** %argv.addr, metadata !23, metadata !DIExpression()), !dbg !24\n+  %0 = load i8**, i8*** %argv.addr, align 8, !dbg !25\n+  %arrayidx = getelementptr inbounds i8*, i8** %0, i64 0, !dbg !25\n+  %1 = load i8*, i8** %arrayidx, align 8, !dbg !25\n+  %arrayidx1 = getelementptr inbounds i8, i8* %1, i64 1, !dbg !25\n+  %2 = load i8, i8* %arrayidx1, align 1, !dbg !25\n+  %conv = sext i8 %2 to i32, !dbg !25\n+  call void @foo(i32 %conv), !dbg !26\n+  %3 = load i8**, i8*** %argv.addr, align 8, !dbg !27\n+  %arrayidx2 = getelementptr inbounds i8*, i8** %3, i64 0, !dbg !27\n+  %4 = load i8*, i8** %arrayidx2, align 8, !dbg !27\n+  %arrayidx3 = getelementptr inbounds i8, i8* %4, i64 1, !dbg !27\n+  %5 = load i8, i8* %arrayidx3, align 1, !dbg !27\n+  %conv4 = sext i8 %5 to i32, !dbg !27\n+  call void @bar(i32 %conv4), !dbg !28\n+  %6 = load x86_fp80, x86_fp80* getelementptr inbounds ([2 x x86_fp80], [2 x x86_fp80]* @array, i64 0, i64 0), align 16, !dbg !29\n+  %7 = load x86_fp80, x86_fp80* getelementptr inbounds ([2 x x86_fp80], [2 x x86_fp80]* @array, i64 0, i64 1), align 16, !dbg !30\n+  %add = fadd x86_fp80 %6, %7, !dbg !31\n+  %cmp = fcmp ogt x86_fp80 %add, 0xK00000000000000000000, !dbg !32\n+  %conv5 = zext i1 %cmp to i32, !dbg !32\n+  ret i32 %conv5, !dbg !33\n+}\n+\n+; Function Attrs: nounwind readnone speculatable\n+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1\n+\n+attributes #0 = { noinline nounwind optnone uwtable }\n+attributes #1 = { nounwind readnone speculatable }\n+\n+!llvm.dbg.cu = !{!2}\n+!llvm.module.flags = !{!10, !11, !12}\n+!llvm.ident = !{!13}\n+\n+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())\n+!1 = distinct !DIGlobalVariable(name: \"array\", scope: !2, file: !3, line: 1, type: !6, isLocal: true, isDefinition: true)\n+!2 = distinct !DICompileUnit(language: DW_LANG_C99, file: !3, producer: \"clang version 7.0.0\", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !4, globals: !5)\n+!3 = !DIFile(filename: \"array.c\", directory: \"/\")\n+!4 = !{}\n+!5 = !{!0}\n+!6 = !DICompositeType(tag: DW_TAG_array_type, baseType: !7, size: 256, elements: !8)\n+!7 = !DIBasicType(name: \"long double\", size: 128, encoding: DW_ATE_float)\n+!8 = !{!9}\n+!9 = !DISubrange(count: 2)\n+!10 = !{i32 2, !\"Dwarf Version\", i32 4}\n+!11 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!12 = !{i32 1, !\"wchar_size\", i32 4}\n+!13 = !{!\"clang version 7.0.0\"}\n+!14 = distinct !DISubprogram(name: \"main\", scope: !3, file: !3, line: 4, type: !15, isLocal: false, isDefinition: true, scopeLine: 5, flags: DIFlagPrototyped, isOptimized: false, unit: !2, variables: !4)\n+!15 = !DISubroutineType(types: !16)\n+!16 = !{!17, !17, !18}\n+!17 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n+!18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64)\n+!19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64)\n+!20 = !DIBasicType(name: \"char\", size: 8, encoding: DW_ATE_signed_char)\n+!21 = !DILocalVariable(name: \"argc\", arg: 1, scope: !14, file: !3, line: 4, type: !17)\n+!22 = !DILocation(line: 4, column: 14, scope: !14)\n+!23 = !DILocalVariable(name: \"argv\", arg: 2, scope: !14, file: !3, line: 4, type: !18)\n+!24 = !DILocation(line: 4, column: 27, scope: !14)\n+!25 = !DILocation(line: 6, column: 7, scope: !14)\n+!26 = !DILocation(line: 6, column: 3, scope: !14)\n+!27 = !DILocation(line: 7, column: 7, scope: !14)\n+!28 = !DILocation(line: 7, column: 3, scope: !14)\n+!29 = !DILocation(line: 8, column: 11, scope: !14)\n+!30 = !DILocation(line: 8, column: 22, scope: !14)\n+!31 = !DILocation(line: 8, column: 20, scope: !14)\n+!32 = !DILocation(line: 8, column: 32, scope: !14)\n+!33 = !DILocation(line: 8, column: 3, scope: !14)"
            },
            {
                "fn": "llvm/test/DebugInfo/X86/global-sra-fp80-struct.ll",
                "patch": "@@ -0,0 +1,134 @@\n+; RUN: opt -S -globalopt < %s | FileCheck %s\n+source_filename = \"struct.c\"\n+target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n+target triple = \"x86_64-unknown-linux-gnu\"\n+\n+%struct.mystruct = type { x86_fp80, i32, [12 x i8] }\n+\n+; Generated from:\n+;\n+; static struct mystruct {\n+;     long double a;\n+;     int b;\n+; } static_struct;\n+; void __attribute__((nodebug)) foo(int in) { static_struct.a = in; }\n+; void __attribute__((nodebug)) bar(int in) { static_struct.b = in; }\n+; int main(int argc, char **argv)\n+; {\n+;     foo(argv[0][1]);\n+;     bar(argv[0][1]);\n+;     return (static_struct.a + static_struct.b) > 0;\n+; }\n+;\n+; using clang -O0 -g2 -S -emit-llvm\n+\n+@static_struct = internal global %struct.mystruct zeroinitializer, align 16, !dbg !0\n+\n+; CHECK: @static_struct.0 = internal unnamed_addr global x86_fp80 0xK00000000000000000000, align 16, !dbg ![[EL0:.*]]\n+; CHECK: @static_struct.1 = internal unnamed_addr global i32 0, align 16, !dbg ![[EL1:.*]]\n+\n+; CHECK: ![[EL0]] = !DIGlobalVariableExpression(var: ![[VAR:.*]], expr: !DIExpression(DW_OP_LLVM_fragment, 0, 128))\n+; CHECK: ![[VAR]] = distinct !DIGlobalVariable(name: \"static_struct\"\n+; CHECK: ![[EL1]] = !DIGlobalVariableExpression(var: ![[VAR]], expr: !DIExpression(DW_OP_LLVM_fragment, 128, 32))\n+\n+; Function Attrs: noinline nounwind optnone uwtable\n+define void @foo(i32 %in) #0 {\n+entry:\n+  %in.addr = alloca i32, align 4\n+  store i32 %in, i32* %in.addr, align 4\n+  %0 = load i32, i32* %in.addr, align 4\n+  %conv = sitofp i32 %0 to x86_fp80\n+  store x86_fp80 %conv, x86_fp80* getelementptr inbounds (%struct.mystruct, %struct.mystruct* @static_struct, i32 0, i32 0), align 16\n+  ret void\n+}\n+\n+; Function Attrs: noinline nounwind optnone uwtable\n+define void @bar(i32 %in) #0 {\n+entry:\n+  %in.addr = alloca i32, align 4\n+  store i32 %in, i32* %in.addr, align 4\n+  %0 = load i32, i32* %in.addr, align 4\n+  store i32 %0, i32* getelementptr inbounds (%struct.mystruct, %struct.mystruct* @static_struct, i32 0, i32 1), align 16\n+  ret void\n+}\n+\n+; Function Attrs: noinline nounwind optnone uwtable\n+define i32 @main(i32 %argc, i8** %argv) #0 !dbg !16 {\n+entry:\n+  %retval = alloca i32, align 4\n+  %argc.addr = alloca i32, align 4\n+  %argv.addr = alloca i8**, align 8\n+  store i32 0, i32* %retval, align 4\n+  store i32 %argc, i32* %argc.addr, align 4\n+  call void @llvm.dbg.declare(metadata i32* %argc.addr, metadata !22, metadata !DIExpression()), !dbg !23\n+  store i8** %argv, i8*** %argv.addr, align 8\n+  call void @llvm.dbg.declare(metadata i8*** %argv.addr, metadata !24, metadata !DIExpression()), !dbg !25\n+  %0 = load i8**, i8*** %argv.addr, align 8, !dbg !26\n+  %arrayidx = getelementptr inbounds i8*, i8** %0, i64 0, !dbg !26\n+  %1 = load i8*, i8** %arrayidx, align 8, !dbg !26\n+  %arrayidx1 = getelementptr inbounds i8, i8* %1, i64 1, !dbg !26\n+  %2 = load i8, i8* %arrayidx1, align 1, !dbg !26\n+  %conv = sext i8 %2 to i32, !dbg !26\n+  call void @foo(i32 %conv), !dbg !27\n+  %3 = load i8**, i8*** %argv.addr, align 8, !dbg !28\n+  %arrayidx2 = getelementptr inbounds i8*, i8** %3, i64 0, !dbg !28\n+  %4 = load i8*, i8** %arrayidx2, align 8, !dbg !28\n+  %arrayidx3 = getelementptr inbounds i8, i8* %4, i64 1, !dbg !28\n+  %5 = load i8, i8* %arrayidx3, align 1, !dbg !28\n+  %conv4 = sext i8 %5 to i32, !dbg !28\n+  call void @bar(i32 %conv4), !dbg !29\n+  %6 = load x86_fp80, x86_fp80* getelementptr inbounds (%struct.mystruct, %struct.mystruct* @static_struct, i32 0, i32 0), align 16, !dbg !30\n+  %7 = load i32, i32* getelementptr inbounds (%struct.mystruct, %struct.mystruct* @static_struct, i32 0, i32 1), align 16, !dbg !31\n+  %conv5 = sitofp i32 %7 to x86_fp80, !dbg !32\n+  %add = fadd x86_fp80 %6, %conv5, !dbg !33\n+  %cmp = fcmp ogt x86_fp80 %add, 0xK00000000000000000000, !dbg !34\n+  %conv6 = zext i1 %cmp to i32, !dbg !34\n+  ret i32 %conv6, !dbg !35\n+}\n+\n+; Function Attrs: nounwind readnone speculatable\n+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1\n+\n+attributes #0 = { noinline nounwind optnone uwtable }\n+attributes #1 = { nounwind readnone speculatable }\n+\n+!llvm.dbg.cu = !{!2}\n+!llvm.module.flags = !{!12, !13, !14}\n+!llvm.ident = !{!15}\n+\n+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())\n+!1 = distinct !DIGlobalVariable(name: \"static_struct\", scope: !2, file: !3, line: 4, type: !6, isLocal: true, isDefinition: true)\n+!2 = distinct !DICompileUnit(language: DW_LANG_C99, file: !3, producer: \"clang version 7.0.0\", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !4, globals: !5)\n+!3 = !DIFile(filename: \"struct.c\", directory: \"/\")\n+!4 = !{}\n+!5 = !{!0}\n+!6 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: \"mystruct\", file: !3, line: 1, size: 256, elements: !7)\n+!7 = !{!8, !10}\n+!8 = !DIDerivedType(tag: DW_TAG_member, name: \"a\", scope: !6, file: !3, line: 2, baseType: !9, size: 128)\n+!9 = !DIBasicType(name: \"long double\", size: 128, encoding: DW_ATE_float)\n+!10 = !DIDerivedType(tag: DW_TAG_member, name: \"b\", scope: !6, file: !3, line: 3, baseType: !11, size: 32, offset: 128)\n+!11 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n+!12 = !{i32 2, !\"Dwarf Version\", i32 4}\n+!13 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!14 = !{i32 1, !\"wchar_size\", i32 4}\n+!15 = !{!\"clang version 7.0.0\"}\n+!16 = distinct !DISubprogram(name: \"main\", scope: !3, file: !3, line: 7, type: !17, isLocal: false, isDefinition: true, scopeLine: 8, flags: DIFlagPrototyped, isOptimized: false, unit: !2, variables: !4)\n+!17 = !DISubroutineType(types: !18)\n+!18 = !{!11, !11, !19}\n+!19 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !20, size: 64)\n+!20 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !21, size: 64)\n+!21 = !DIBasicType(name: \"char\", size: 8, encoding: DW_ATE_signed_char)\n+!22 = !DILocalVariable(name: \"argc\", arg: 1, scope: !16, file: !3, line: 7, type: !11)\n+!23 = !DILocation(line: 7, column: 14, scope: !16)\n+!24 = !DILocalVariable(name: \"argv\", arg: 2, scope: !16, file: !3, line: 7, type: !19)\n+!25 = !DILocation(line: 7, column: 27, scope: !16)\n+!26 = !DILocation(line: 9, column: 9, scope: !16)\n+!27 = !DILocation(line: 9, column: 5, scope: !16)\n+!28 = !DILocation(line: 10, column: 9, scope: !16)\n+!29 = !DILocation(line: 10, column: 5, scope: !16)\n+!30 = !DILocation(line: 11, column: 27, scope: !16)\n+!31 = !DILocation(line: 11, column: 45, scope: !16)\n+!32 = !DILocation(line: 11, column: 31, scope: !16)\n+!33 = !DILocation(line: 11, column: 29, scope: !16)\n+!34 = !DILocation(line: 11, column: 48, scope: !16)\n+!35 = !DILocation(line: 11, column: 5, scope: !16)"
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/X86/global-sra-fp80-array.ll (1 of 1)\nTesting Time: 0.53s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/global-sra-fp80-array.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: DebugInfo/X86/global-sra-fp80-struct.ll (1 of 1)\nTesting Time: 0.41s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/global-sra-fp80-struct.ll\n\n  Unexpected Failures: 1\n"
    },
    "40e7663b1fca58b099c1cb1d5278f368494ea46d___BasicAliasAnalysis.cpp": {
        "start": 797,
        "end": 964,
        "buggy": "ModRefInfo BasicAAResult::getModRefInfo(ImmutableCallSite CS,\n                                        const MemoryLocation &Loc) {\n  assert(notDifferentParent(CS.getInstruction(), Loc.Ptr) &&\n         \"AliasAnalysis query involving multiple functions!\");\n\n  const Value *Object = GetUnderlyingObject(Loc.Ptr, DL);\n\n  // If this is a tail call and Loc.Ptr points to a stack location, we know that\n  // the tail call cannot access or modify the local stack.\n  // We cannot exclude byval arguments here; these belong to the caller of\n  // the current function not to the current function, and a tail callee\n  // may reference them.\n  if (isa<AllocaInst>(Object))\n    if (const CallInst *CI = dyn_cast<CallInst>(CS.getInstruction()))\n      if (CI->isTailCall())\n        return ModRefInfo::NoModRef;\n\n  // If the pointer is to a locally allocated object that does not escape,\n  // then the call can not mod/ref the pointer unless the call takes the pointer\n  // as an argument, and itself doesn't capture it.\n  if (!isa<Constant>(Object) && CS.getInstruction() != Object &&\n      isNonEscapingLocalObject(Object)) {\n\n    // Optimistically assume that call doesn't touch Object and check this\n    // assumption in the following loop.\n    ModRefInfo Result = ModRefInfo::NoModRef;\n    bool IsMustAlias = true;\n\n    unsigned OperandNo = 0;\n    for (auto CI = CS.data_operands_begin(), CE = CS.data_operands_end();\n         CI != CE; ++CI, ++OperandNo) {\n      // Only look at the no-capture or byval pointer arguments.  If this\n      // pointer were passed to arguments that were neither of these, then it\n      // couldn't be no-capture.\n      if (!(*CI)->getType()->isPointerTy() ||\n          (!CS.doesNotCapture(OperandNo) &&\n           OperandNo < CS.getNumArgOperands() && !CS.isByValArgument(OperandNo)))\n        continue;\n\n      // Call doesn't access memory through this operand, so we don't care\n      // if it aliases with Object.\n      if (CS.doesNotAccessMemory(OperandNo))\n        continue;\n\n      // If this is a no-capture pointer argument, see if we can tell that it\n      // is impossible to alias the pointer we're checking.\n      AliasResult AR =\n          getBestAAResults().alias(MemoryLocation(*CI), MemoryLocation(Object));\n      if (AR != MustAlias)\n        IsMustAlias = false;\n      // Operand doesnt alias 'Object', continue looking for other aliases\n      if (AR == NoAlias)\n        continue;\n      // Operand aliases 'Object', but call doesn't modify it. Strengthen\n      // initial assumption and keep looking in case if there are more aliases.\n      if (CS.onlyReadsMemory(OperandNo)) {\n        Result = setRef(Result);\n        continue;\n      }\n      // Operand aliases 'Object' but call only writes into it.\n      if (CS.doesNotReadMemory(OperandNo)) {\n        Result = setMod(Result);\n        continue;\n      }\n      // This operand aliases 'Object' and call reads and writes into it.\n      // Setting ModRef will not yield an early return below, MustAlias is not\n      // used further.\n      Result = ModRefInfo::ModRef;\n      break;\n    }\n\n    // No operand aliases, reset Must bit. Add below if at least one aliases\n    // and all aliases found are MustAlias.\n    if (isNoModRef(Result))\n      IsMustAlias = false;\n\n    // Early return if we improved mod ref information\n    if (!isModAndRefSet(Result)) {\n      if (isNoModRef(Result))\n        return ModRefInfo::NoModRef;\n      return IsMustAlias ? setMust(Result) : clearMust(Result);\n    }\n  }\n\n  // If the CallSite is to malloc or calloc, we can assume that it doesn't\n  // modify any IR visible value.  This is only valid because we assume these\n  // routines do not read values visible in the IR.  TODO: Consider special\n  // casing realloc and strdup routines which access only their arguments as\n  // well.  Or alternatively, replace all of this with inaccessiblememonly once\n  // that's implemented fully.\n  auto *Inst = CS.getInstruction();\n  if (isMallocOrCallocLikeFn(Inst, &TLI)) {\n    // Be conservative if the accessed pointer may alias the allocation -\n    // fallback to the generic handling below.\n    if (getBestAAResults().alias(MemoryLocation(Inst), Loc) == NoAlias)\n      return ModRefInfo::NoModRef;\n  }\n\n  // The semantics of memcpy intrinsics forbid overlap between their respective\n  // operands, i.e., source and destination of any given memcpy must no-alias.\n  // If Loc must-aliases either one of these two locations, then it necessarily\n  // no-aliases the other.\n  if (auto *Inst = dyn_cast<AnyMemCpyInst>(CS.getInstruction())) {\n    AliasResult SrcAA, DestAA;\n\n    if ((SrcAA = getBestAAResults().alias(MemoryLocation::getForSource(Inst),\n                                          Loc)) == MustAlias)\n      // Loc is exactly the memcpy source thus disjoint from memcpy dest.\n      return ModRefInfo::Ref;\n    if ((DestAA = getBestAAResults().alias(MemoryLocation::getForDest(Inst),\n                                           Loc)) == MustAlias)\n      // The converse case.\n      return ModRefInfo::Mod;\n\n    // It's also possible for Loc to alias both src and dest, or neither.\n    ModRefInfo rv = ModRefInfo::NoModRef;\n    if (SrcAA != NoAlias)\n      rv = setRef(rv);\n    if (DestAA != NoAlias)\n      rv = setMod(rv);\n    return rv;\n  }\n\n  // While the assume intrinsic is marked as arbitrarily writing so that\n  // proper control dependencies will be maintained, it never aliases any\n  // particular memory location.\n  if (isIntrinsicCall(CS, Intrinsic::assume))\n    return ModRefInfo::NoModRef;\n\n  // Like assumes, guard intrinsics are also marked as arbitrarily writing so\n  // that proper control dependencies are maintained but they never mods any\n  // particular memory location.\n  //\n  // *Unlike* assumes, guard intrinsics are modeled as reading memory since the\n  // heap state at the point the guard is issued needs to be consistent in case\n  // the guard invokes the \"deopt\" continuation.\n  if (isIntrinsicCall(CS, Intrinsic::experimental_guard))\n    return ModRefInfo::Ref;\n\n  // Like assumes, invariant.start intrinsics were also marked as arbitrarily\n  // writing so that proper control dependencies are maintained but they never\n  // mod any particular memory location visible to the IR.\n  // *Unlike* assumes (which are now modeled as NoModRef), invariant.start\n  // intrinsic is now modeled as reading memory. This prevents hoisting the\n  // invariant.start intrinsic over stores. Consider:\n  // *ptr = 40;\n  // *ptr = 50;\n  // invariant_start(ptr)\n  // int val = *ptr;\n  // print(val);\n  //\n  // This cannot be transformed to:\n  //\n  // *ptr = 40;\n  // invariant_start(ptr)\n  // *ptr = 50;\n  // int val = *ptr;\n  // print(val);\n  //\n  // The transformation will cause the second store to be ignored (based on\n  // rules of invariant.start)  and print 40, while the first program always\n  // prints 50.\n  if (isIntrinsicCall(CS, Intrinsic::invariant_start))\n    return ModRefInfo::Ref;\n\n  // The AAResultBase base class has some smarts, lets use them.\n  return AAResultBase::getModRefInfo(CS, Loc);\n}\n",
        "fix": null,
        "src_path": "40e7663b1fca58b099c1cb1d5278f368494ea46d___BasicAliasAnalysis.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/40e7663b1fca58b099c1cb1d5278f368494ea46d",
        "commit_msg": "[BasicAA] Don't assume tail calls with byval don't alias allocas\n\nSummary:\nCalls marked 'tail' cannot read or write allocas from the current frame\nbecause the current frame might be destroyed by the time they run.\nHowever, a tail call may use an alloca with byval. Calling with byval\ncopies the contents of the alloca into argument registers or stack\nslots, so there is no lifetime issue. Tail calls never modify allocas,\nso we can return just ModRefInfo::Ref.\n\nFixes PR38466, a longstanding bug.\n\nReviewers: hfinkel, nlewycky, gbiv, george.burgess.iv\n\nSubscribers: hiraditya, llvm-commits\n\nDifferential Revision: https://reviews.llvm.org/D50679\n\nllvm-svn: 339636",
        "test_func_diff": [
            {
                "fn": "llvm/test/Analysis/BasicAA/tail-byval.ll",
                "patch": "@@ -0,0 +1,15 @@\n+; RUN: opt -basicaa -aa-eval -print-all-alias-modref-info -disable-output < %s 2>&1 | FileCheck %s\n+\n+declare void @takebyval(i32* byval %p)\n+\n+define i32 @tailbyval() {\n+entry:\n+  %p = alloca i32\n+  store i32 42, i32* %p\n+  tail call void @takebyval(i32* byval %p)\n+  %rv = load i32, i32* %p\n+  ret i32 %rv\n+}\n+; FIXME: This should be Just Ref.\n+; CHECK-LABEL: Function: tailbyval: 1 pointers, 1 call sites\n+; CHECK-NEXT:   Both ModRef:  Ptr: i32* %p       <->  tail call void @takebyval(i32* byval %p)"
            },
            {
                "fn": "llvm/test/Transforms/DeadStoreElimination/tail-byval.ll",
                "patch": "@@ -0,0 +1,23 @@\n+; RUN: opt -dse -S < %s | FileCheck %s\n+\n+; Don't eliminate stores to allocas before tail calls to functions that use\n+; byval. It's correct to mark calls like these as 'tail'. To implement this tail\n+; call, the backend should copy the bytes from the alloca into the argument area\n+; before clearing the stack.\n+\n+target datalayout = \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\"\n+target triple = \"i386-unknown-linux-gnu\"\n+\n+declare void @g(i32* byval %p)\n+\n+define void @f(i32* byval %x) {\n+entry:\n+  %p = alloca i32\n+  %v = load i32, i32* %x\n+  store i32 %v, i32* %p\n+  tail call void @g(i32* byval %p)\n+  ret void\n+}\n+; CHECK-LABEL: define void @f(i32* byval %x)\n+; CHECK:   store i32 %v, i32* %p\n+; CHECK:   tail call void @g(i32* byval %p)"
            }
        ],
        "error_msg": "FAIL: LLVM :: Analysis/BasicAA/tail-byval.ll (1 of 1)\nTesting Time: 1.14s\n********************\nFailing Tests (1):\n    LLVM :: Analysis/BasicAA/tail-byval.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Transforms/DeadStoreElimination/tail-byval.ll (1 of 1)\nTesting Time: 0.32s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/DeadStoreElimination/tail-byval.ll\n\n  Unexpected Failures: 1\n"
    },
    "bfee5a9b42d3b4190d6a41d848303d1fea1bdbf2___X86ISelLowering.cpp": {
        "start": 39992,
        "end": 40153,
        "buggy": "static SDValue combineInsertSubvector(SDNode *N, SelectionDAG &DAG,\n                                      TargetLowering::DAGCombinerInfo &DCI,\n                                      const X86Subtarget &Subtarget) {\n  if (DCI.isBeforeLegalizeOps())\n    return SDValue();\n\n  MVT OpVT = N->getSimpleValueType(0);\n\n  bool IsI1Vector = OpVT.getVectorElementType() == MVT::i1;\n\n  SDLoc dl(N);\n  SDValue Vec = N->getOperand(0);\n  SDValue SubVec = N->getOperand(1);\n\n  unsigned IdxVal = N->getConstantOperandVal(2);\n  MVT SubVecVT = SubVec.getSimpleValueType();\n\n  if (ISD::isBuildVectorAllZeros(Vec.getNode())) {\n    // Inserting zeros into zeros is a nop.\n    if (ISD::isBuildVectorAllZeros(SubVec.getNode()))\n      return getZeroVector(OpVT, Subtarget, DAG, dl);\n\n    // If we're inserting into a zero vector and then into a larger zero vector,\n    // just insert into the larger zero vector directly.\n    if (SubVec.getOpcode() == ISD::INSERT_SUBVECTOR &&\n        ISD::isBuildVectorAllZeros(SubVec.getOperand(0).getNode())) {\n      unsigned Idx2Val = SubVec.getConstantOperandVal(2);\n      return DAG.getNode(ISD::INSERT_SUBVECTOR, dl, OpVT,\n                         getZeroVector(OpVT, Subtarget, DAG, dl),\n                         SubVec.getOperand(1),\n                         DAG.getIntPtrConstant(IdxVal + Idx2Val, dl));\n    }\n\n    // If we're inserting into a zero vector and our input was extracted from an\n    // insert into a zero vector of the same type and the extraction was at\n    // least as large as the original insertion. Just insert the original\n    // subvector into a zero vector.\n    if (SubVec.getOpcode() == ISD::EXTRACT_SUBVECTOR && IdxVal == 0 &&\n        SubVec.getConstantOperandVal(1) == 0 &&\n        SubVec.getOperand(0).getOpcode() == ISD::INSERT_SUBVECTOR) {\n      SDValue Ins = SubVec.getOperand(0);\n      if (Ins.getConstantOperandVal(2) == 0 &&\n          ISD::isBuildVectorAllZeros(Ins.getOperand(0).getNode()) &&\n          Ins.getOperand(1).getValueSizeInBits() <= SubVecVT.getSizeInBits())\n        return DAG.getNode(ISD::INSERT_SUBVECTOR, dl, OpVT,\n                           getZeroVector(OpVT, Subtarget, DAG, dl),\n                           Ins.getOperand(1), N->getOperand(2));\n    }\n\n    // If we're inserting a bitcast into zeros, rewrite the insert and move the\n    // bitcast to the other side. This helps with detecting zero extending\n    // during isel.\n    // TODO: Is this useful for other indices than 0?\n    if (!IsI1Vector && SubVec.getOpcode() == ISD::BITCAST && IdxVal == 0) {\n      MVT CastVT = SubVec.getOperand(0).getSimpleValueType();\n      unsigned NumElems = OpVT.getSizeInBits() / CastVT.getScalarSizeInBits();\n      MVT NewVT = MVT::getVectorVT(CastVT.getVectorElementType(), NumElems);\n      SDValue Insert = DAG.getNode(ISD::INSERT_SUBVECTOR, dl, NewVT,\n                                   DAG.getBitcast(NewVT, Vec),\n                                   SubVec.getOperand(0), N->getOperand(2));\n      return DAG.getBitcast(OpVT, Insert);\n    }\n  }\n\n  // Stop here if this is an i1 vector.\n  if (IsI1Vector)\n    return SDValue();\n\n  // If this is an insert of an extract, combine to a shuffle. Don't do this\n  // if the insert or extract can be represented with a subregister operation.\n  if (SubVec.getOpcode() == ISD::EXTRACT_SUBVECTOR &&\n      SubVec.getOperand(0).getSimpleValueType() == OpVT &&\n      (IdxVal != 0 || !Vec.isUndef())) {\n    int ExtIdxVal = SubVec.getConstantOperandVal(1);\n    if (ExtIdxVal != 0) {\n      int VecNumElts = OpVT.getVectorNumElements();\n      int SubVecNumElts = SubVecVT.getVectorNumElements();\n      SmallVector<int, 64> Mask(VecNumElts);\n      // First create an identity shuffle mask.\n      for (int i = 0; i != VecNumElts; ++i)\n        Mask[i] = i;\n      // Now insert the extracted portion.\n      for (int i = 0; i != SubVecNumElts; ++i)\n        Mask[i + IdxVal] = i + ExtIdxVal + VecNumElts;\n\n      return DAG.getVectorShuffle(OpVT, dl, Vec, SubVec.getOperand(0), Mask);\n    }\n  }\n\n  // Fold two 16-byte or 32-byte subvector loads into one 32-byte or 64-byte\n  // load:\n  // (insert_subvector (insert_subvector undef, (load16 addr), 0),\n  //                   (load16 addr + 16), Elts/2)\n  // --> load32 addr\n  // or:\n  // (insert_subvector (insert_subvector undef, (load32 addr), 0),\n  //                   (load32 addr + 32), Elts/2)\n  // --> load64 addr\n  // or a 16-byte or 32-byte broadcast:\n  // (insert_subvector (insert_subvector undef, (load16 addr), 0),\n  //                   (load16 addr), Elts/2)\n  // --> X86SubVBroadcast(load16 addr)\n  // or:\n  // (insert_subvector (insert_subvector undef, (load32 addr), 0),\n  //                   (load32 addr), Elts/2)\n  // --> X86SubVBroadcast(load32 addr)\n  if ((IdxVal == OpVT.getVectorNumElements() / 2) &&\n      Vec.getOpcode() == ISD::INSERT_SUBVECTOR &&\n      OpVT.getSizeInBits() == SubVecVT.getSizeInBits() * 2) {\n    if (isNullConstant(Vec.getOperand(2))) {\n      SDValue SubVec2 = Vec.getOperand(1);\n      // If needed, look through bitcasts to get to the load.\n      if (auto *FirstLd = dyn_cast<LoadSDNode>(peekThroughBitcasts(SubVec2))) {\n        bool Fast;\n        unsigned Alignment = FirstLd->getAlignment();\n        unsigned AS = FirstLd->getAddressSpace();\n        const X86TargetLowering *TLI = Subtarget.getTargetLowering();\n        if (TLI->allowsMemoryAccess(*DAG.getContext(), DAG.getDataLayout(),\n                                    OpVT, AS, Alignment, &Fast) && Fast) {\n          SDValue Ops[] = {SubVec2, SubVec};\n          if (SDValue Ld = EltsFromConsecutiveLoads(OpVT, Ops, dl, DAG,\n                                                    Subtarget, false))\n            return Ld;\n        }\n      }\n      // If lower/upper loads are the same and the only users of the load, then\n      // lower to a VBROADCASTF128/VBROADCASTI128/etc.\n      if (auto *Ld = dyn_cast<LoadSDNode>(peekThroughOneUseBitcasts(SubVec2)))\n        if (SubVec2 == SubVec && ISD::isNormalLoad(Ld) &&\n            SDNode::areOnlyUsersOf({N, Vec.getNode()}, SubVec2.getNode()))\n          return DAG.getNode(X86ISD::SUBV_BROADCAST, dl, OpVT, SubVec);\n\n      // If this is subv_broadcast insert into both halves, use a larger\n      // subv_broadcast.\n      if (SubVec.getOpcode() == X86ISD::SUBV_BROADCAST && SubVec == SubVec2)\n        return DAG.getNode(X86ISD::SUBV_BROADCAST, dl, OpVT,\n                           SubVec.getOperand(0));\n\n      // If we're inserting all zeros into the upper half, change this to\n      // an insert into an all zeros vector. We will match this to a move\n      // with implicit upper bit zeroing during isel.\n      if (ISD::isBuildVectorAllZeros(SubVec.getNode()))\n        return DAG.getNode(ISD::INSERT_SUBVECTOR, dl, OpVT,\n                           getZeroVector(OpVT, Subtarget, DAG, dl), SubVec2,\n                           Vec.getOperand(2));\n\n      // If we are inserting into both halves of the vector, the starting\n      // vector should be undef. If it isn't, make it so. Only do this if the\n      // the early insert has no other uses.\n      // TODO: Should this be a generic DAG combine?\n      if (!Vec.getOperand(0).isUndef() && Vec.hasOneUse()) {\n        Vec = DAG.getNode(ISD::INSERT_SUBVECTOR, dl, OpVT, DAG.getUNDEF(OpVT),\n                          SubVec2, Vec.getOperand(2));\n        return DAG.getNode(ISD::INSERT_SUBVECTOR, dl, OpVT, Vec, SubVec,\n                           N->getOperand(2));\n\n      }\n    }\n  }\n\n  return SDValue();\n}\n",
        "fix": null,
        "src_path": "bfee5a9b42d3b4190d6a41d848303d1fea1bdbf2___X86ISelLowering.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/bfee5a9b42d3b4190d6a41d848303d1fea1bdbf2",
        "commit_msg": "[x86] fix uses check in broadcast transform (PR38949)\n\nhttps://bugs.llvm.org/show_bug.cgi?id=38949\n\nIt's not clear to me that we even need a one-use check in this fold.\nIe, 2 independent loads might be better than a load+dependent shuffle.\n\nNote that the existing re-use tests are not affected. We actually do form a\nbroadcast node in those tests now because there's no extra use of the \ninsert_subvector node in those cases. But something later in isel pattern \nmatching decides that it is not worth using a broadcast for the full load in \nthose tests:\n\nLegalized selection DAG: %bb.0 'test_broadcast_2f64_4f64_reuse:'\n  t7: v2f64,ch = load<(load 16 from %ir.p0)> t0, t2, undef:i64\n      t4: i64,ch = CopyFromReg t0, Register:i64 %1\n    t10: ch = store<(store 16 into %ir.p1)> t7:1, t7, t4, undef:i64\n      t18: v4f64 = insert_subvector undef:v4f64, t7, Constant:i64<0>\n    t20: v4f64 = insert_subvector t18, t7, Constant:i64<2>\n\nBecomes:\n  t7: v2f64,ch = load<(load 16 from %ir.p0)> t0, t2, undef:i64\n      t4: i64,ch = CopyFromReg t0, Register:i64 %1\n    t10: ch = store<(store 16 into %ir.p1)> t7:1, t7, t4, undef:i64\n    t21: v4f64 = X86ISD::SUBV_BROADCAST t7\n\nISEL: Starting selection on root node: t21: v4f64 = X86ISD::SUBV_BROADCAST t7\n...\n  Created node: t27: v4f64 = INSERT_SUBREG IMPLICIT_DEF:v4f64, t7, TargetConstant:i32<7>\n  Morphed node: t21: v4f64 = VINSERTF128rr t27, t7, TargetConstant:i8<1>\n\nllvm-svn: 342347",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/avx-vbroadcastf128.ll",
                "patch": "@@ -106,16 +106,14 @@ define void @subv_reuse_is_ok(<4 x float>* %a, <8 x float>* %b) {\n ; X32:       # %bb.0:\n ; X32-NEXT:    movl {{[0-9]+}}(%esp), %eax\n ; X32-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n-; X32-NEXT:    vmovups (%ecx), %xmm0\n-; X32-NEXT:    vinsertf128 $1, %xmm0, %ymm0, %ymm0\n+; X32-NEXT:    vbroadcastf128 {{.*#+}} ymm0 = mem[0,1,0,1]\n ; X32-NEXT:    vmovups %ymm0, (%eax)\n ; X32-NEXT:    vzeroupper\n ; X32-NEXT:    retl\n ;\n ; X64-LABEL: subv_reuse_is_ok:\n ; X64:       # %bb.0:\n-; X64-NEXT:    vmovups (%rdi), %xmm0\n-; X64-NEXT:    vinsertf128 $1, %xmm0, %ymm0, %ymm0\n+; X64-NEXT:    vbroadcastf128 {{.*#+}} ymm0 = mem[0,1,0,1]\n ; X64-NEXT:    vmovups %ymm0, (%rsi)\n ; X64-NEXT:    vzeroupper\n ; X64-NEXT:    retq"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/avx-vbroadcastf128.ll (1 of 1)\nTesting Time: 0.22s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/avx-vbroadcastf128.ll\n\n  Unexpected Failures: 1\n"
    },
    "6cca8af2270be8bc5494b44bb8856af591d0385b___X86ISelLowering.cpp": {
        "start": 36938,
        "end": 37045,
        "buggy": "static bool isHorizontalBinOp(SDValue &LHS, SDValue &RHS, bool IsCommutative) {\n  // If either operand is undef, bail out. The binop should be simplified.\n  if (LHS.isUndef() || RHS.isUndef())\n    return false;\n\n  // Look for the following pattern:\n  //   A = < float a0, float a1, float a2, float a3 >\n  //   B = < float b0, float b1, float b2, float b3 >\n  // and\n  //   LHS = VECTOR_SHUFFLE A, B, <0, 2, 4, 6>\n  //   RHS = VECTOR_SHUFFLE A, B, <1, 3, 5, 7>\n  // then LHS op RHS = < a0 op a1, a2 op a3, b0 op b1, b2 op b3 >\n  // which is A horizontal-op B.\n\n  // At least one of the operands should be a vector shuffle.\n  if (LHS.getOpcode() != ISD::VECTOR_SHUFFLE &&\n      RHS.getOpcode() != ISD::VECTOR_SHUFFLE)\n    return false;\n\n  MVT VT = LHS.getSimpleValueType();\n  assert((VT.is128BitVector() || VT.is256BitVector()) &&\n         \"Unsupported vector type for horizontal add/sub\");\n\n  // View LHS in the form\n  //   LHS = VECTOR_SHUFFLE A, B, LMask\n  // If LHS is not a shuffle, then pretend it is the identity shuffle:\n  //   LHS = VECTOR_SHUFFLE LHS, undef, <0, 1, ..., N-1>\n  // NOTE: A default initialized SDValue represents an UNDEF of type VT.\n  unsigned NumElts = VT.getVectorNumElements();\n  SDValue A, B;\n  SmallVector<int, 16> LMask(NumElts);\n  if (LHS.getOpcode() == ISD::VECTOR_SHUFFLE) {\n    if (!LHS.getOperand(0).isUndef())\n      A = LHS.getOperand(0);\n    if (!LHS.getOperand(1).isUndef())\n      B = LHS.getOperand(1);\n    ArrayRef<int> Mask = cast<ShuffleVectorSDNode>(LHS.getNode())->getMask();\n    std::copy(Mask.begin(), Mask.end(), LMask.begin());\n  } else {\n    A = LHS;\n    for (unsigned i = 0; i != NumElts; ++i)\n      LMask[i] = i;\n  }\n\n  // Likewise, view RHS in the form\n  //   RHS = VECTOR_SHUFFLE C, D, RMask\n  SDValue C, D;\n  SmallVector<int, 16> RMask(NumElts);\n  if (RHS.getOpcode() == ISD::VECTOR_SHUFFLE) {\n    if (!RHS.getOperand(0).isUndef())\n      C = RHS.getOperand(0);\n    if (!RHS.getOperand(1).isUndef())\n      D = RHS.getOperand(1);\n    ArrayRef<int> Mask = cast<ShuffleVectorSDNode>(RHS.getNode())->getMask();\n    std::copy(Mask.begin(), Mask.end(), RMask.begin());\n  } else {\n    C = RHS;\n    for (unsigned i = 0; i != NumElts; ++i)\n      RMask[i] = i;\n  }\n\n  // If A and B occur in reverse order in RHS, then canonicalize by commuting\n  // RHS operands and shuffle mask.\n  if (A != C) {\n    std::swap(C, D);\n    ShuffleVectorSDNode::commuteMask(RMask);\n  }\n  // Check that the shuffles are both shuffling the same vectors.\n  if (!(A == C && B == D))\n    return false;\n\n  // LHS and RHS are now:\n  //   LHS = shuffle A, B, LMask\n  //   RHS = shuffle A, B, RMask\n  // Check that the masks correspond to performing a horizontal operation.\n  // AVX defines horizontal add/sub to operate independently on 128-bit lanes,\n  // so we just repeat the inner loop if this is a 256-bit op.\n  unsigned Num128BitChunks = VT.getSizeInBits() / 128;\n  unsigned NumEltsPer128BitChunk = NumElts / Num128BitChunks;\n  assert((NumEltsPer128BitChunk % 2 == 0) &&\n         \"Vector type should have an even number of elements in each lane\");\n  for (unsigned j = 0; j != NumElts; j += NumEltsPer128BitChunk) {\n    for (unsigned i = 0; i != NumEltsPer128BitChunk; ++i) {\n      // Ignore undefined components.\n      int LIdx = LMask[i + j], RIdx = RMask[i + j];\n      if (LIdx < 0 || RIdx < 0 ||\n          (!A.getNode() && (LIdx < (int)NumElts || RIdx < (int)NumElts)) ||\n          (!B.getNode() && (LIdx >= (int)NumElts || RIdx >= (int)NumElts)))\n        continue;\n\n      // The  low half of the 128-bit result must choose from A.\n      // The high half of the 128-bit result must choose from B.\n      unsigned NumEltsPer64BitChunk = NumEltsPer128BitChunk / 2;\n      unsigned Src = i >= NumEltsPer64BitChunk;\n\n      // Check that successive elements are being operated on. If not, this is\n      // not a horizontal operation.\n      int Index = 2 * (i % NumEltsPer64BitChunk) + NumElts * Src + j;\n      if (!(LIdx == Index && RIdx == Index + 1) &&\n          !(IsCommutative && LIdx == Index + 1 && RIdx == Index))\n        return false;\n    }\n  }\n\n  LHS = A.getNode() ? A : B; // If A is 'UNDEF', use B for it.\n  RHS = B.getNode() ? B : A; // If B is 'UNDEF', use A for it.\n  return true;\n}\n",
        "fix": null,
        "src_path": "6cca8af2270be8bc5494b44bb8856af591d0385b___X86ISelLowering.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/6cca8af2270be8bc5494b44bb8856af591d0385b",
        "commit_msg": "[x86] allow single source horizontal op matching (PR39195)\n\nThis is intended to restore horizontal codegen to what it looked like before IR demanded elements improved in:\nrL343727\n\nAs noted in PR39195:\nhttps://bugs.llvm.org/show_bug.cgi?id=39195\n...horizontal ops can be worse for performance than a shuffle+regular binop, so I've added a TODO. Ideally, we'd \nsolve that in a machine instruction pass, but a quicker solution will be adding a 'HasFastHorizontalOp' feature\nbit to deal with it here in the DAG.\n\nDifferential Revision: https://reviews.llvm.org/D52997\n\nllvm-svn: 344141",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/avx512-intrinsics-fast-isel.ll",
                "patch": "@@ -7210,8 +7210,7 @@ define double @test_mm512_reduce_add_pd(<8 x double> %__W) {\n ; X86-NEXT:    vaddpd %ymm1, %ymm0, %ymm0\n ; X86-NEXT:    vextractf128 $1, %ymm0, %xmm1\n ; X86-NEXT:    vaddpd %xmm1, %xmm0, %xmm0\n-; X86-NEXT:    vpermilpd {{.*#+}} xmm1 = xmm0[1,0]\n-; X86-NEXT:    vaddpd %xmm1, %xmm0, %xmm0\n+; X86-NEXT:    vhaddpd %xmm0, %xmm0, %xmm0\n ; X86-NEXT:    vmovlpd %xmm0, (%esp)\n ; X86-NEXT:    fldl (%esp)\n ; X86-NEXT:    movl %ebp, %esp\n@@ -7226,8 +7225,7 @@ define double @test_mm512_reduce_add_pd(<8 x double> %__W) {\n ; X64-NEXT:    vaddpd %ymm1, %ymm0, %ymm0\n ; X64-NEXT:    vextractf128 $1, %ymm0, %xmm1\n ; X64-NEXT:    vaddpd %xmm1, %xmm0, %xmm0\n-; X64-NEXT:    vpermilpd {{.*#+}} xmm1 = xmm0[1,0]\n-; X64-NEXT:    vaddpd %xmm1, %xmm0, %xmm0\n+; X64-NEXT:    vhaddpd %xmm0, %xmm0, %xmm0\n ; X64-NEXT:    vzeroupper\n ; X64-NEXT:    retq\n entry:\n@@ -7407,8 +7405,7 @@ define double @test_mm512_mask_reduce_add_pd(i8 zeroext %__M, <8 x double> %__W)\n ; X86-NEXT:    vaddpd %ymm1, %ymm0, %ymm0\n ; X86-NEXT:    vextractf128 $1, %ymm0, %xmm1\n ; X86-NEXT:    vaddpd %xmm1, %xmm0, %xmm0\n-; X86-NEXT:    vpermilpd {{.*#+}} xmm1 = xmm0[1,0]\n-; X86-NEXT:    vaddpd %xmm1, %xmm0, %xmm0\n+; X86-NEXT:    vhaddpd %xmm0, %xmm0, %xmm0\n ; X86-NEXT:    vmovlpd %xmm0, (%esp)\n ; X86-NEXT:    fldl (%esp)\n ; X86-NEXT:    movl %ebp, %esp\n@@ -7425,8 +7422,7 @@ define double @test_mm512_mask_reduce_add_pd(i8 zeroext %__M, <8 x double> %__W)\n ; X64-NEXT:    vaddpd %ymm1, %ymm0, %ymm0\n ; X64-NEXT:    vextractf128 $1, %ymm0, %xmm1\n ; X64-NEXT:    vaddpd %xmm1, %xmm0, %xmm0\n-; X64-NEXT:    vpermilpd {{.*#+}} xmm1 = xmm0[1,0]\n-; X64-NEXT:    vaddpd %xmm1, %xmm0, %xmm0\n+; X64-NEXT:    vhaddpd %xmm0, %xmm0, %xmm0\n ; X64-NEXT:    vzeroupper\n ; X64-NEXT:    retq\n entry:"
            },
            {
                "fn": "llvm/test/CodeGen/X86/haddsub-undef.ll",
                "patch": "@@ -453,14 +453,12 @@ define <8 x i32> @test17_undef(<8 x i32> %a, <8 x i32> %b) {\n define <2 x double> @add_pd_003(<2 x double> %x) {\n ; SSE-LABEL: add_pd_003:\n ; SSE:       # %bb.0:\n-; SSE-NEXT:    movddup {{.*#+}} xmm1 = xmm0[0,0]\n-; SSE-NEXT:    addpd %xmm1, %xmm0\n+; SSE-NEXT:    haddpd %xmm0, %xmm0\n ; SSE-NEXT:    retq\n ;\n ; AVX-LABEL: add_pd_003:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vmovddup {{.*#+}} xmm1 = xmm0[0,0]\n-; AVX-NEXT:    vaddpd %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vhaddpd %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    retq\n   %l = shufflevector <2 x double> %x, <2 x double> undef, <2 x i32> <i32 undef, i32 0>\n   %add = fadd <2 x double> %l, %x\n@@ -472,16 +470,12 @@ define <2 x double> @add_pd_003(<2 x double> %x) {\n define <2 x double> @add_pd_003_2(<2 x double> %x) {\n ; SSE-LABEL: add_pd_003_2:\n ; SSE:       # %bb.0:\n-; SSE-NEXT:    movapd %xmm0, %xmm1\n-; SSE-NEXT:    shufpd {{.*#+}} xmm1 = xmm1[1],xmm0[0]\n-; SSE-NEXT:    addpd %xmm0, %xmm1\n-; SSE-NEXT:    movapd %xmm1, %xmm0\n+; SSE-NEXT:    haddpd %xmm0, %xmm0\n ; SSE-NEXT:    retq\n ;\n ; AVX-LABEL: add_pd_003_2:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vpermilpd {{.*#+}} xmm1 = xmm0[1,0]\n-; AVX-NEXT:    vaddpd %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vhaddpd %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    retq\n   %l = shufflevector <2 x double> %x, <2 x double> undef, <2 x i32> <i32 1, i32 0>\n   %add = fadd <2 x double> %l, %x\n@@ -491,16 +485,12 @@ define <2 x double> @add_pd_003_2(<2 x double> %x) {\n define <2 x double> @add_pd_010(<2 x double> %x) {\n ; SSE-LABEL: add_pd_010:\n ; SSE:       # %bb.0:\n-; SSE-NEXT:    movddup {{.*#+}} xmm1 = xmm0[0,0]\n-; SSE-NEXT:    addpd %xmm0, %xmm1\n-; SSE-NEXT:    unpckhpd {{.*#+}} xmm1 = xmm1[1,1]\n-; SSE-NEXT:    movapd %xmm1, %xmm0\n+; SSE-NEXT:    haddpd %xmm0, %xmm0\n ; SSE-NEXT:    retq\n ;\n ; AVX-LABEL: add_pd_010:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vmovddup {{.*#+}} xmm1 = xmm0[0,0]\n-; AVX-NEXT:    vaddpd %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vhaddpd %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    vpermilpd {{.*#+}} xmm0 = xmm0[1,0]\n ; AVX-NEXT:    retq\n   %l = shufflevector <2 x double> %x, <2 x double> undef, <2 x i32> <i32 undef, i32 0>\n@@ -512,17 +502,12 @@ define <2 x double> @add_pd_010(<2 x double> %x) {\n define <4 x float> @add_ps_007(<4 x float> %x) {\n ; SSE-LABEL: add_ps_007:\n ; SSE:       # %bb.0:\n-; SSE-NEXT:    movaps %xmm0, %xmm1\n-; SSE-NEXT:    shufps {{.*#+}} xmm1 = xmm1[0,1],xmm0[0,2]\n-; SSE-NEXT:    shufps {{.*#+}} xmm0 = xmm0[0,1,1,3]\n-; SSE-NEXT:    addps %xmm1, %xmm0\n+; SSE-NEXT:    haddps %xmm0, %xmm0\n ; SSE-NEXT:    retq\n ;\n ; AVX-LABEL: add_ps_007:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vpermilps {{.*#+}} xmm1 = xmm0[0,1,0,2]\n-; AVX-NEXT:    vpermilps {{.*#+}} xmm0 = xmm0[0,1,1,3]\n-; AVX-NEXT:    vaddps %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vhaddps %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    retq\n   %l = shufflevector <4 x float> %x, <4 x float> undef, <4 x i32> <i32 undef, i32 undef, i32 0, i32 2>\n   %r = shufflevector <4 x float> %x, <4 x float> undef, <4 x i32> <i32 undef, i32 undef, i32 1, i32 3>\n@@ -533,18 +518,13 @@ define <4 x float> @add_ps_007(<4 x float> %x) {\n define <4 x float> @add_ps_030(<4 x float> %x) {\n ; SSE-LABEL: add_ps_030:\n ; SSE:       # %bb.0:\n-; SSE-NEXT:    movaps %xmm0, %xmm1\n-; SSE-NEXT:    shufps {{.*#+}} xmm1 = xmm1[0,1],xmm0[0,2]\n-; SSE-NEXT:    shufps {{.*#+}} xmm0 = xmm0[0,1,1,3]\n-; SSE-NEXT:    addps %xmm1, %xmm0\n+; SSE-NEXT:    haddps %xmm0, %xmm0\n ; SSE-NEXT:    shufps {{.*#+}} xmm0 = xmm0[3,2,2,3]\n ; SSE-NEXT:    retq\n ;\n ; AVX-LABEL: add_ps_030:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vpermilps {{.*#+}} xmm1 = xmm0[0,1,0,2]\n-; AVX-NEXT:    vpermilps {{.*#+}} xmm0 = xmm0[0,1,1,3]\n-; AVX-NEXT:    vaddps %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vhaddps %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    vpermilps {{.*#+}} xmm0 = xmm0[3,2,2,3]\n ; AVX-NEXT:    retq\n   %l = shufflevector <4 x float> %x, <4 x float> undef, <4 x i32> <i32 undef, i32 undef, i32 0, i32 2>\n@@ -557,16 +537,12 @@ define <4 x float> @add_ps_030(<4 x float> %x) {\n define <4 x float> @add_ps_007_2(<4 x float> %x) {\n ; SSE-LABEL: add_ps_007_2:\n ; SSE:       # %bb.0:\n-; SSE-NEXT:    movddup {{.*#+}} xmm1 = xmm0[0,0]\n-; SSE-NEXT:    shufps {{.*#+}} xmm0 = xmm0[0,1,1,3]\n-; SSE-NEXT:    addps %xmm1, %xmm0\n+; SSE-NEXT:    haddps %xmm0, %xmm0\n ; SSE-NEXT:    retq\n ;\n ; AVX-LABEL: add_ps_007_2:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vmovddup {{.*#+}} xmm1 = xmm0[0,0]\n-; AVX-NEXT:    vpermilps {{.*#+}} xmm0 = xmm0[0,1,1,3]\n-; AVX-NEXT:    vaddps %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vhaddps %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    retq\n   %l = shufflevector <4 x float> %x, <4 x float> undef, <4 x i32> <i32 undef, i32 undef, i32 0, i32 undef>\n   %r = shufflevector <4 x float> %x, <4 x float> undef, <4 x i32> <i32 undef, i32 undef, i32 1, i32 undef>\n@@ -577,14 +553,12 @@ define <4 x float> @add_ps_007_2(<4 x float> %x) {\n define <4 x float> @add_ps_008(<4 x float> %x) {\n ; SSE-LABEL: add_ps_008:\n ; SSE:       # %bb.0:\n-; SSE-NEXT:    movsldup {{.*#+}} xmm1 = xmm0[0,0,2,2]\n-; SSE-NEXT:    addps %xmm1, %xmm0\n+; SSE-NEXT:    haddps %xmm0, %xmm0\n ; SSE-NEXT:    retq\n ;\n ; AVX-LABEL: add_ps_008:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vmovsldup {{.*#+}} xmm1 = xmm0[0,0,2,2]\n-; AVX-NEXT:    vaddps %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vhaddps %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    retq\n   %l = shufflevector <4 x float> %x, <4 x float> undef, <4 x i32> <i32 undef, i32 undef, i32 undef, i32 2>\n   %add = fadd <4 x float> %l, %x\n@@ -594,16 +568,13 @@ define <4 x float> @add_ps_008(<4 x float> %x) {\n define <4 x float> @add_ps_017(<4 x float> %x) {\n ; SSE-LABEL: add_ps_017:\n ; SSE:       # %bb.0:\n-; SSE-NEXT:    movsldup {{.*#+}} xmm1 = xmm0[0,0,2,2]\n-; SSE-NEXT:    addps %xmm0, %xmm1\n-; SSE-NEXT:    shufps {{.*#+}} xmm1 = xmm1[3,1,2,3]\n-; SSE-NEXT:    movaps %xmm1, %xmm0\n+; SSE-NEXT:    haddps %xmm0, %xmm0\n+; SSE-NEXT:    shufps {{.*#+}} xmm0 = xmm0[3,1,2,3]\n ; SSE-NEXT:    retq\n ;\n ; AVX-LABEL: add_ps_017:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vmovsldup {{.*#+}} xmm1 = xmm0[0,0,2,2]\n-; AVX-NEXT:    vaddps %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vhaddps %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    vpermilps {{.*#+}} xmm0 = xmm0[3,1,2,3]\n ; AVX-NEXT:    retq\n   %l = shufflevector <4 x float> %x, <4 x float> undef, <4 x i32> <i32 undef, i32 undef, i32 undef, i32 2>\n@@ -615,17 +586,13 @@ define <4 x float> @add_ps_017(<4 x float> %x) {\n define <4 x float> @add_ps_018(<4 x float> %x) {\n ; SSE-LABEL: add_ps_018:\n ; SSE:       # %bb.0:\n-; SSE-NEXT:    movddup {{.*#+}} xmm1 = xmm0[0,0]\n-; SSE-NEXT:    shufps {{.*#+}} xmm0 = xmm0[0,1,1,3]\n-; SSE-NEXT:    addps %xmm1, %xmm0\n+; SSE-NEXT:    haddps %xmm0, %xmm0\n ; SSE-NEXT:    shufps {{.*#+}} xmm0 = xmm0[0,2,2,3]\n ; SSE-NEXT:    retq\n ;\n ; AVX-LABEL: add_ps_018:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vmovddup {{.*#+}} xmm1 = xmm0[0,0]\n-; AVX-NEXT:    vpermilps {{.*#+}} xmm0 = xmm0[0,1,1,3]\n-; AVX-NEXT:    vaddps %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vhaddps %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    vpermilps {{.*#+}} xmm0 = xmm0[0,2,2,3]\n ; AVX-NEXT:    retq\n   %l = shufflevector <4 x float> %x, <4 x float> undef, <4 x i32> <i32 undef, i32 undef, i32 0, i32 undef>"
            },
            {
                "fn": "llvm/test/CodeGen/X86/phaddsub.ll",
                "patch": "@@ -286,16 +286,12 @@ define <4 x i32> @phsubd1_reverse(<4 x i32> %x, <4 x i32> %y) {\n define <4 x i32> @phaddd_single_source1(<4 x i32> %x) {\n ; SSSE3-LABEL: phaddd_single_source1:\n ; SSSE3:       # %bb.0:\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm1 = xmm0[0,1,0,2]\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm0 = xmm0[0,1,1,3]\n-; SSSE3-NEXT:    paddd %xmm1, %xmm0\n+; SSSE3-NEXT:    phaddd %xmm0, %xmm0\n ; SSSE3-NEXT:    retq\n ;\n ; AVX-LABEL: phaddd_single_source1:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vpshufd {{.*#+}} xmm1 = xmm0[0,1,0,2]\n-; AVX-NEXT:    vpshufd {{.*#+}} xmm0 = xmm0[0,1,1,3]\n-; AVX-NEXT:    vpaddd %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vphaddd %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    retq\n   %l = shufflevector <4 x i32> %x, <4 x i32> undef, <4 x i32> <i32 undef, i32 undef, i32 0, i32 2>\n   %r = shufflevector <4 x i32> %x, <4 x i32> undef, <4 x i32> <i32 undef, i32 undef, i32 1, i32 3>\n@@ -306,17 +302,13 @@ define <4 x i32> @phaddd_single_source1(<4 x i32> %x) {\n define <4 x i32> @phaddd_single_source2(<4 x i32> %x) {\n ; SSSE3-LABEL: phaddd_single_source2:\n ; SSSE3:       # %bb.0:\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm1 = xmm0[0,1,0,2]\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm0 = xmm0[0,1,1,3]\n-; SSSE3-NEXT:    paddd %xmm1, %xmm0\n+; SSSE3-NEXT:    phaddd %xmm0, %xmm0\n ; SSSE3-NEXT:    pshufd {{.*#+}} xmm0 = xmm0[3,2,2,3]\n ; SSSE3-NEXT:    retq\n ;\n ; AVX-LABEL: phaddd_single_source2:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vpshufd {{.*#+}} xmm1 = xmm0[0,1,0,2]\n-; AVX-NEXT:    vpshufd {{.*#+}} xmm0 = xmm0[0,1,1,3]\n-; AVX-NEXT:    vpaddd %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vphaddd %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    vpshufd {{.*#+}} xmm0 = xmm0[3,2,2,3]\n ; AVX-NEXT:    retq\n   %l = shufflevector <4 x i32> %x, <4 x i32> undef, <4 x i32> <i32 undef, i32 undef, i32 0, i32 2>\n@@ -329,16 +321,12 @@ define <4 x i32> @phaddd_single_source2(<4 x i32> %x) {\n define <4 x i32> @phaddd_single_source3(<4 x i32> %x) {\n ; SSSE3-LABEL: phaddd_single_source3:\n ; SSSE3:       # %bb.0:\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm1 = xmm0[0,1,0,1]\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm0 = xmm0[0,1,1,3]\n-; SSSE3-NEXT:    paddd %xmm1, %xmm0\n+; SSSE3-NEXT:    phaddd %xmm0, %xmm0\n ; SSSE3-NEXT:    retq\n ;\n ; AVX-LABEL: phaddd_single_source3:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vpshufd {{.*#+}} xmm1 = xmm0[0,1,0,1]\n-; AVX-NEXT:    vpmovzxdq {{.*#+}} xmm0 = xmm0[0],zero,xmm0[1],zero\n-; AVX-NEXT:    vpaddd %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vphaddd %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    retq\n   %l = shufflevector <4 x i32> %x, <4 x i32> undef, <4 x i32> <i32 undef, i32 undef, i32 0, i32 undef>\n   %r = shufflevector <4 x i32> %x, <4 x i32> undef, <4 x i32> <i32 undef, i32 undef, i32 1, i32 undef>\n@@ -349,14 +337,12 @@ define <4 x i32> @phaddd_single_source3(<4 x i32> %x) {\n define <4 x i32> @phaddd_single_source4(<4 x i32> %x) {\n ; SSSE3-LABEL: phaddd_single_source4:\n ; SSSE3:       # %bb.0:\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm1 = xmm0[0,1,2,2]\n-; SSSE3-NEXT:    paddd %xmm1, %xmm0\n+; SSSE3-NEXT:    phaddd %xmm0, %xmm0\n ; SSSE3-NEXT:    retq\n ;\n ; AVX-LABEL: phaddd_single_source4:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vpshufd {{.*#+}} xmm1 = xmm0[0,1,2,2]\n-; AVX-NEXT:    vpaddd %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vphaddd %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    retq\n   %l = shufflevector <4 x i32> %x, <4 x i32> undef, <4 x i32> <i32 undef, i32 undef, i32 undef, i32 2>\n   %add = add <4 x i32> %l, %x\n@@ -366,15 +352,13 @@ define <4 x i32> @phaddd_single_source4(<4 x i32> %x) {\n define <4 x i32> @phaddd_single_source5(<4 x i32> %x) {\n ; SSSE3-LABEL: phaddd_single_source5:\n ; SSSE3:       # %bb.0:\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm1 = xmm0[0,1,2,2]\n-; SSSE3-NEXT:    paddd %xmm0, %xmm1\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm0 = xmm1[3,1,2,3]\n+; SSSE3-NEXT:    phaddd %xmm0, %xmm0\n+; SSSE3-NEXT:    pshufd {{.*#+}} xmm0 = xmm0[3,1,2,3]\n ; SSSE3-NEXT:    retq\n ;\n ; AVX-LABEL: phaddd_single_source5:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vpshufd {{.*#+}} xmm1 = xmm0[0,1,2,2]\n-; AVX-NEXT:    vpaddd %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vphaddd %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    vpshufd {{.*#+}} xmm0 = xmm0[3,1,2,3]\n ; AVX-NEXT:    retq\n   %l = shufflevector <4 x i32> %x, <4 x i32> undef, <4 x i32> <i32 undef, i32 undef, i32 undef, i32 2>\n@@ -386,17 +370,13 @@ define <4 x i32> @phaddd_single_source5(<4 x i32> %x) {\n define <4 x i32> @phaddd_single_source6(<4 x i32> %x) {\n ; SSSE3-LABEL: phaddd_single_source6:\n ; SSSE3:       # %bb.0:\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm1 = xmm0[0,1,0,1]\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm0 = xmm0[0,1,1,3]\n-; SSSE3-NEXT:    paddd %xmm1, %xmm0\n+; SSSE3-NEXT:    phaddd %xmm0, %xmm0\n ; SSSE3-NEXT:    pshufd {{.*#+}} xmm0 = xmm0[2,2,3,3]\n ; SSSE3-NEXT:    retq\n ;\n ; AVX-LABEL: phaddd_single_source6:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vpshufd {{.*#+}} xmm1 = xmm0[0,1,0,1]\n-; AVX-NEXT:    vpmovzxdq {{.*#+}} xmm0 = xmm0[0],zero,xmm0[1],zero\n-; AVX-NEXT:    vpaddd %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vphaddd %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    vpshufd {{.*#+}} xmm0 = xmm0[2,2,3,3]\n ; AVX-NEXT:    retq\n   %l = shufflevector <4 x i32> %x, <4 x i32> undef, <4 x i32> <i32 undef, i32 undef, i32 0, i32 undef>\n@@ -409,17 +389,12 @@ define <4 x i32> @phaddd_single_source6(<4 x i32> %x) {\n define <8 x i16> @phaddw_single_source1(<8 x i16> %x) {\n ; SSSE3-LABEL: phaddw_single_source1:\n ; SSSE3:       # %bb.0:\n-; SSSE3-NEXT:    movdqa %xmm0, %xmm1\n-; SSSE3-NEXT:    pshufb {{.*#+}} xmm1 = xmm1[0,1,4,5,4,5,6,7,0,1,4,5,8,9,12,13]\n-; SSSE3-NEXT:    pshufb {{.*#+}} xmm0 = xmm0[6,7,2,3,4,5,6,7,2,3,6,7,10,11,14,15]\n-; SSSE3-NEXT:    paddw %xmm1, %xmm0\n+; SSSE3-NEXT:    phaddw %xmm0, %xmm0\n ; SSSE3-NEXT:    retq\n ;\n ; AVX-LABEL: phaddw_single_source1:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vpshufb {{.*#+}} xmm1 = xmm0[0,1,4,5,4,5,6,7,0,1,4,5,8,9,12,13]\n-; AVX-NEXT:    vpshufb {{.*#+}} xmm0 = xmm0[6,7,2,3,4,5,6,7,2,3,6,7,10,11,14,15]\n-; AVX-NEXT:    vpaddw %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vphaddw %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    retq\n   %l = shufflevector <8 x i16> %x, <8 x i16> undef, <8 x i32> <i32 undef, i32 undef, i32 undef, i32 undef, i32 0, i32 2, i32 4, i32 6>\n   %r = shufflevector <8 x i16> %x, <8 x i16> undef, <8 x i32> <i32 undef, i32 undef, i32 undef, i32 undef, i32 1, i32 3, i32 5, i32 7>\n@@ -430,22 +405,14 @@ define <8 x i16> @phaddw_single_source1(<8 x i16> %x) {\n define <8 x i16> @phaddw_single_source2(<8 x i16> %x) {\n ; SSSE3-LABEL: phaddw_single_source2:\n ; SSSE3:       # %bb.0:\n-; SSSE3-NEXT:    pshuflw {{.*#+}} xmm1 = xmm0[0,2,2,3,4,5,6,7]\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm1 = xmm1[0,1,0,3]\n-; SSSE3-NEXT:    pshuflw {{.*#+}} xmm0 = xmm0[1,3,2,3,4,5,6,7]\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm0 = xmm0[0,1,0,3]\n-; SSSE3-NEXT:    paddw %xmm1, %xmm0\n+; SSSE3-NEXT:    phaddw %xmm0, %xmm0\n ; SSSE3-NEXT:    pshufhw {{.*#+}} xmm0 = xmm0[0,1,2,3,5,4,6,7]\n ; SSSE3-NEXT:    pshufd {{.*#+}} xmm0 = xmm0[2,1,2,3]\n ; SSSE3-NEXT:    retq\n ;\n ; AVX-LABEL: phaddw_single_source2:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vpshuflw {{.*#+}} xmm1 = xmm0[0,2,2,3,4,5,6,7]\n-; AVX-NEXT:    vpshufd {{.*#+}} xmm1 = xmm1[0,1,0,3]\n-; AVX-NEXT:    vpshuflw {{.*#+}} xmm0 = xmm0[1,3,2,3,4,5,6,7]\n-; AVX-NEXT:    vpshufd {{.*#+}} xmm0 = xmm0[0,1,0,3]\n-; AVX-NEXT:    vpaddw %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vphaddw %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    vpshufhw {{.*#+}} xmm0 = xmm0[0,1,2,3,5,4,6,7]\n ; AVX-NEXT:    vpshufd {{.*#+}} xmm0 = xmm0[2,1,2,3]\n ; AVX-NEXT:    retq\n@@ -459,20 +426,12 @@ define <8 x i16> @phaddw_single_source2(<8 x i16> %x) {\n define <8 x i16> @phaddw_single_source3(<8 x i16> %x) {\n ; SSSE3-LABEL: phaddw_single_source3:\n ; SSSE3:       # %bb.0:\n-; SSSE3-NEXT:    pshuflw {{.*#+}} xmm1 = xmm0[0,2,2,3,4,5,6,7]\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm1 = xmm1[0,1,0,3]\n-; SSSE3-NEXT:    pshuflw {{.*#+}} xmm0 = xmm0[1,3,2,3,4,5,6,7]\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm0 = xmm0[0,1,0,3]\n-; SSSE3-NEXT:    paddw %xmm1, %xmm0\n+; SSSE3-NEXT:    phaddw %xmm0, %xmm0\n ; SSSE3-NEXT:    retq\n ;\n ; AVX-LABEL: phaddw_single_source3:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vpshuflw {{.*#+}} xmm1 = xmm0[0,2,2,3,4,5,6,7]\n-; AVX-NEXT:    vpshufd {{.*#+}} xmm1 = xmm1[0,1,0,3]\n-; AVX-NEXT:    vpshuflw {{.*#+}} xmm0 = xmm0[1,3,2,3,4,5,6,7]\n-; AVX-NEXT:    vpshufd {{.*#+}} xmm0 = xmm0[0,1,0,3]\n-; AVX-NEXT:    vpaddw %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vphaddw %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    retq\n   %l = shufflevector <8 x i16> %x, <8 x i16> undef, <8 x i32> <i32 undef, i32 undef, i32 undef, i32 undef, i32 0, i32 2, i32 undef, i32 undef>\n   %r = shufflevector <8 x i16> %x, <8 x i16> undef, <8 x i32> <i32 undef, i32 undef, i32 undef, i32 undef, i32 1, i32 3, i32 undef, i32 undef>\n@@ -483,16 +442,12 @@ define <8 x i16> @phaddw_single_source3(<8 x i16> %x) {\n define <8 x i16> @phaddw_single_source4(<8 x i16> %x) {\n ; SSSE3-LABEL: phaddw_single_source4:\n ; SSSE3:       # %bb.0:\n-; SSSE3-NEXT:    movdqa %xmm0, %xmm1\n-; SSSE3-NEXT:    pslld $16, %xmm1\n-; SSSE3-NEXT:    paddw %xmm0, %xmm1\n-; SSSE3-NEXT:    movdqa %xmm1, %xmm0\n+; SSSE3-NEXT:    phaddw %xmm0, %xmm0\n ; SSSE3-NEXT:    retq\n ;\n ; AVX-LABEL: phaddw_single_source4:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vpslld $16, %xmm0, %xmm1\n-; AVX-NEXT:    vpaddw %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vphaddw %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    retq\n   %l = shufflevector <8 x i16> %x, <8 x i16> undef, <8 x i32> <i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 6>\n   %add = add <8 x i16> %l, %x\n@@ -502,18 +457,13 @@ define <8 x i16> @phaddw_single_source4(<8 x i16> %x) {\n define <8 x i16> @phaddw_single_source6(<8 x i16> %x) {\n ; SSSE3-LABEL: phaddw_single_source6:\n ; SSSE3:       # %bb.0:\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm1 = xmm0[0,1,0,1]\n-; SSSE3-NEXT:    pshufd {{.*#+}} xmm0 = xmm0[0,1,0,3]\n-; SSSE3-NEXT:    pshufhw {{.*#+}} xmm0 = xmm0[0,1,2,3,5,5,6,7]\n-; SSSE3-NEXT:    paddw %xmm1, %xmm0\n+; SSSE3-NEXT:    phaddw %xmm0, %xmm0\n ; SSSE3-NEXT:    psrldq {{.*#+}} xmm0 = xmm0[6,7,8,9,10,11,12,13,14,15],zero,zero,zero,zero,zero,zero\n ; SSSE3-NEXT:    retq\n ;\n ; AVX-LABEL: phaddw_single_source6:\n ; AVX:       # %bb.0:\n-; AVX-NEXT:    vpshufd {{.*#+}} xmm1 = xmm0[0,1,0,1]\n-; AVX-NEXT:    vpmovzxwq {{.*#+}} xmm0 = xmm0[0],zero,zero,zero,xmm0[1],zero,zero,zero\n-; AVX-NEXT:    vpaddw %xmm0, %xmm1, %xmm0\n+; AVX-NEXT:    vphaddw %xmm0, %xmm0, %xmm0\n ; AVX-NEXT:    vpsrldq {{.*#+}} xmm0 = xmm0[6,7,8,9,10,11,12,13,14,15],zero,zero,zero,zero,zero,zero\n ; AVX-NEXT:    retq\n   %l = shufflevector <8 x i16> %x, <8 x i16> undef, <8 x i32> <i32 undef, i32 undef, i32 undef, i32 undef, i32 0, i32 undef, i32 undef, i32 undef>"
            },
            {
                "fn": "llvm/test/CodeGen/X86/vector-shuffle-combining.ll",
                "patch": "@@ -2700,21 +2700,36 @@ define <4 x i32> @combine_constant_insertion_v4i32(i32 %f) {\n }\n \n define <4 x float> @PR22377(<4 x float> %a, <4 x float> %b) {\n-; SSE-LABEL: PR22377:\n-; SSE:       # %bb.0: # %entry\n-; SSE-NEXT:    movaps %xmm0, %xmm1\n-; SSE-NEXT:    shufps {{.*#+}} xmm1 = xmm1[1,3],xmm0[1,3]\n-; SSE-NEXT:    shufps {{.*#+}} xmm0 = xmm0[0,2,0,2]\n-; SSE-NEXT:    addps %xmm0, %xmm1\n-; SSE-NEXT:    unpcklps {{.*#+}} xmm0 = xmm0[0],xmm1[0],xmm0[1],xmm1[1]\n-; SSE-NEXT:    retq\n+; SSE2-LABEL: PR22377:\n+; SSE2:       # %bb.0: # %entry\n+; SSE2-NEXT:    movaps %xmm0, %xmm1\n+; SSE2-NEXT:    shufps {{.*#+}} xmm1 = xmm1[1,3],xmm0[1,3]\n+; SSE2-NEXT:    shufps {{.*#+}} xmm0 = xmm0[0,2,0,2]\n+; SSE2-NEXT:    addps %xmm0, %xmm1\n+; SSE2-NEXT:    unpcklps {{.*#+}} xmm0 = xmm0[0],xmm1[0],xmm0[1],xmm1[1]\n+; SSE2-NEXT:    retq\n+;\n+; SSSE3-LABEL: PR22377:\n+; SSSE3:       # %bb.0: # %entry\n+; SSSE3-NEXT:    movaps %xmm0, %xmm1\n+; SSSE3-NEXT:    haddps %xmm0, %xmm1\n+; SSSE3-NEXT:    shufps {{.*#+}} xmm0 = xmm0[0,2],xmm1[0,1]\n+; SSSE3-NEXT:    shufps {{.*#+}} xmm0 = xmm0[0,2,1,3]\n+; SSSE3-NEXT:    retq\n+;\n+; SSE41-LABEL: PR22377:\n+; SSE41:       # %bb.0: # %entry\n+; SSE41-NEXT:    movaps %xmm0, %xmm1\n+; SSE41-NEXT:    haddps %xmm0, %xmm1\n+; SSE41-NEXT:    shufps {{.*#+}} xmm0 = xmm0[0,2],xmm1[0,1]\n+; SSE41-NEXT:    shufps {{.*#+}} xmm0 = xmm0[0,2,1,3]\n+; SSE41-NEXT:    retq\n ;\n ; AVX-LABEL: PR22377:\n ; AVX:       # %bb.0: # %entry\n-; AVX-NEXT:    vpermilps {{.*#+}} xmm1 = xmm0[1,3,1,3]\n-; AVX-NEXT:    vpermilps {{.*#+}} xmm0 = xmm0[0,2,0,2]\n-; AVX-NEXT:    vaddps %xmm0, %xmm1, %xmm1\n-; AVX-NEXT:    vunpcklps {{.*#+}} xmm0 = xmm0[0],xmm1[0],xmm0[1],xmm1[1]\n+; AVX-NEXT:    vhaddps %xmm0, %xmm0, %xmm1\n+; AVX-NEXT:    vshufps {{.*#+}} xmm0 = xmm0[0,2],xmm1[0,1]\n+; AVX-NEXT:    vpermilps {{.*#+}} xmm0 = xmm0[0,2,1,3]\n ; AVX-NEXT:    retq\n entry:\n   %s1 = shufflevector <4 x float> %a, <4 x float> undef, <4 x i32> <i32 1, i32 3, i32 1, i32 3>"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/avx512-intrinsics-fast-isel.ll (1 of 1)\nTesting Time: 5.14s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/avx512-intrinsics-fast-isel.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/haddsub-undef.ll (1 of 1)\nTesting Time: 0.62s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/haddsub-undef.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/phaddsub.ll (1 of 1)\nTesting Time: 0.54s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/phaddsub.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/vector-shuffle-combining.ll (1 of 1)\nTesting Time: 2.83s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/vector-shuffle-combining.ll\n\n  Unexpected Failures: 1\n"
    },
    "d47eac59efb1de3a4fe797c54e116de55c6559e2___CodeGenPrepare.cpp": {
        "start": 1160,
        "end": 1207,
        "buggy": "static bool replaceMathCmpWithIntrinsic(BinaryOperator *BO, CmpInst *Cmp,\n                                        Intrinsic::ID IID, DominatorTree &DT) {\n  // We allow matching the canonical IR (add X, C) back to (usubo X, -C).\n  Value *Arg0 = BO->getOperand(0);\n  Value *Arg1 = BO->getOperand(1);\n  if (BO->getOpcode() == Instruction::Add &&\n      IID == Intrinsic::usub_with_overflow) {\n    assert(isa<Constant>(Arg1) && \"Unexpected input for usubo\");\n    Arg1 = ConstantExpr::getNeg(cast<Constant>(Arg1));\n  }\n\n  Instruction *InsertPt;\n  if (BO->hasOneUse() && BO->user_back() == Cmp) {\n    // If the math is only used by the compare, insert at the compare to keep\n    // the condition in the same block as its users. (CGP aggressively sinks\n    // compares to help out SDAG.)\n    InsertPt = Cmp;\n  } else {\n    // The math and compare may be independent instructions. Check dominance to\n    // determine the insertion point for the intrinsic.\n    bool MathDominates = DT.dominates(BO, Cmp);\n    if (!MathDominates && !DT.dominates(Cmp, BO))\n      return false;\n\n    // Check that the insertion doesn't create a value that is live across more\n    // than two blocks, so to minimise the increase in register pressure.\n    BasicBlock *MathBB = BO->getParent(), *CmpBB = Cmp->getParent();\n    if (MathBB != CmpBB) {\n      BasicBlock *Dominator = MathDominates ? MathBB : CmpBB;\n      BasicBlock *Dominated = MathDominates ? CmpBB : MathBB;\n      auto Successors = successors(Dominator);\n      if (llvm::find(Successors, Dominated) == Successors.end())\n        return false;\n    }\n\n    InsertPt = MathDominates ? cast<Instruction>(BO) : cast<Instruction>(Cmp);\n  }\n\n  IRBuilder<> Builder(InsertPt);\n  Value *MathOV = Builder.CreateBinaryIntrinsic(IID, Arg0, Arg1);\n  Value *Math = Builder.CreateExtractValue(MathOV, 0, \"math\");\n  Value *OV = Builder.CreateExtractValue(MathOV, 1, \"ov\");\n  BO->replaceAllUsesWith(Math);\n  Cmp->replaceAllUsesWith(OV);\n  BO->eraseFromParent();\n  Cmp->eraseFromParent();\n  return true;\n}\n",
        "fix": null,
        "src_path": "d47eac59efb1de3a4fe797c54e116de55c6559e2___CodeGenPrepare.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/d47eac59efb1de3a4fe797c54e116de55c6559e2",
        "commit_msg": "[CodeGenPrepare] limit formation of overflow intrinsics (PR41129)\n\nThis is probably a bigger limitation than necessary, but since we don't have any evidence yet\nthat this transform led to real-world perf improvements rather than regressions, I'm making a\nquick, blunt fix.\n\nIn the motivating x86 example from:\nhttps://bugs.llvm.org/show_bug.cgi?id=41129\n...and shown in the regression test, we want to avoid an extra instruction in the dominating\nblock because that could be costly.\n\nThe x86 LSR test diff is reversing the changes from D57789. There's no evidence that 1 version\nis any better than the other yet.\n\nDifferential Revision: https://reviews.llvm.org/D59602\n\nllvm-svn: 356665",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/cgp-usubo.ll",
                "patch": "@@ -211,16 +211,16 @@ define void @PR41129(i64* %p64) {\n ; CHECK-LABEL: PR41129:\n ; CHECK:       # %bb.0: # %entry\n ; CHECK-NEXT:    movq (%rdi), %rax\n-; CHECK-NEXT:    movq %rax, %rcx\n-; CHECK-NEXT:    subq $1, %rcx\n-; CHECK-NEXT:    jae .LBB10_1\n-; CHECK-NEXT:  # %bb.2: # %true\n-; CHECK-NEXT:    movq %rcx, (%rdi)\n-; CHECK-NEXT:    retq\n-; CHECK-NEXT:  .LBB10_1: # %false\n+; CHECK-NEXT:    testq %rax, %rax\n+; CHECK-NEXT:    je .LBB10_2\n+; CHECK-NEXT:  # %bb.1: # %false\n ; CHECK-NEXT:    andl $7, %eax\n ; CHECK-NEXT:    movq %rax, (%rdi)\n ; CHECK-NEXT:    retq\n+; CHECK-NEXT:  .LBB10_2: # %true\n+; CHECK-NEXT:    decq %rax\n+; CHECK-NEXT:    movq %rax, (%rdi)\n+; CHECK-NEXT:    retq\n entry:\n   %key = load i64, i64* %p64, align 8\n   %cond17 = icmp eq i64 %key, 0"
            },
            {
                "fn": "llvm/test/CodeGen/X86/lsr-loop-exit-cond.ll",
                "patch": "@@ -16,11 +16,11 @@ define void @t(i8* nocapture %in, i8* nocapture %out, i32* nocapture %rk, i32 %r\n ; GENERIC-NEXT:    movl (%rdx), %eax\n ; GENERIC-NEXT:    movl 4(%rdx), %ebx\n ; GENERIC-NEXT:    decl %ecx\n-; GENERIC-NEXT:    leaq 20(%rdx), %r11\n+; GENERIC-NEXT:    leaq 20(%rdx), %r14\n ; GENERIC-NEXT:    movq _Te0@{{.*}}(%rip), %r9\n ; GENERIC-NEXT:    movq _Te1@{{.*}}(%rip), %r8\n ; GENERIC-NEXT:    movq _Te3@{{.*}}(%rip), %r10\n-; GENERIC-NEXT:    movq %rcx, %r14\n+; GENERIC-NEXT:    movq %rcx, %r11\n ; GENERIC-NEXT:    jmp LBB0_1\n ; GENERIC-NEXT:    .p2align 4, 0x90\n ; GENERIC-NEXT:  LBB0_2: ## %bb1\n@@ -29,13 +29,14 @@ define void @t(i8* nocapture %in, i8* nocapture %out, i32* nocapture %rk, i32 %r\n ; GENERIC-NEXT:    shrl $16, %ebx\n ; GENERIC-NEXT:    movzbl %bl, %ebx\n ; GENERIC-NEXT:    xorl (%r8,%rbx,4), %eax\n-; GENERIC-NEXT:    xorl -4(%r11), %eax\n+; GENERIC-NEXT:    xorl -4(%r14), %eax\n ; GENERIC-NEXT:    shrl $24, %edi\n ; GENERIC-NEXT:    movzbl %bpl, %ebx\n ; GENERIC-NEXT:    movl (%r10,%rbx,4), %ebx\n ; GENERIC-NEXT:    xorl (%r9,%rdi,4), %ebx\n-; GENERIC-NEXT:    xorl (%r11), %ebx\n-; GENERIC-NEXT:    addq $16, %r11\n+; GENERIC-NEXT:    xorl (%r14), %ebx\n+; GENERIC-NEXT:    decq %r11\n+; GENERIC-NEXT:    addq $16, %r14\n ; GENERIC-NEXT:  LBB0_1: ## %bb\n ; GENERIC-NEXT:    ## =>This Inner Loop Header: Depth=1\n ; GENERIC-NEXT:    movzbl %al, %edi\n@@ -46,16 +47,16 @@ define void @t(i8* nocapture %in, i8* nocapture %out, i32* nocapture %rk, i32 %r\n ; GENERIC-NEXT:    movzbl %bpl, %ebp\n ; GENERIC-NEXT:    movl (%r8,%rbp,4), %ebp\n ; GENERIC-NEXT:    xorl (%r9,%rax,4), %ebp\n-; GENERIC-NEXT:    xorl -12(%r11), %ebp\n+; GENERIC-NEXT:    xorl -12(%r14), %ebp\n ; GENERIC-NEXT:    shrl $24, %ebx\n ; GENERIC-NEXT:    movl (%r10,%rdi,4), %edi\n ; GENERIC-NEXT:    xorl (%r9,%rbx,4), %edi\n-; GENERIC-NEXT:    xorl -8(%r11), %edi\n+; GENERIC-NEXT:    xorl -8(%r14), %edi\n ; GENERIC-NEXT:    movl %ebp, %eax\n ; GENERIC-NEXT:    shrl $24, %eax\n ; GENERIC-NEXT:    movl (%r9,%rax,4), %eax\n-; GENERIC-NEXT:    subq $1, %r14\n-; GENERIC-NEXT:    jae LBB0_2\n+; GENERIC-NEXT:    testq %r11, %r11\n+; GENERIC-NEXT:    jne LBB0_2\n ; GENERIC-NEXT:  ## %bb.3: ## %bb2\n ; GENERIC-NEXT:    shlq $4, %rcx\n ; GENERIC-NEXT:    andl $-16777216, %eax ## imm = 0xFF000000\n@@ -98,26 +99,27 @@ define void @t(i8* nocapture %in, i8* nocapture %out, i32* nocapture %rk, i32 %r\n ; ATOM-NEXT:    ## kill: def $ecx killed $ecx def $rcx\n ; ATOM-NEXT:    movl (%rdx), %r15d\n ; ATOM-NEXT:    movl 4(%rdx), %eax\n-; ATOM-NEXT:    leaq 20(%rdx), %r11\n+; ATOM-NEXT:    leaq 20(%rdx), %r14\n ; ATOM-NEXT:    movq _Te0@{{.*}}(%rip), %r9\n ; ATOM-NEXT:    movq _Te1@{{.*}}(%rip), %r8\n ; ATOM-NEXT:    movq _Te3@{{.*}}(%rip), %r10\n ; ATOM-NEXT:    decl %ecx\n-; ATOM-NEXT:    movq %rcx, %r14\n+; ATOM-NEXT:    movq %rcx, %r11\n ; ATOM-NEXT:    jmp LBB0_1\n ; ATOM-NEXT:    .p2align 4, 0x90\n ; ATOM-NEXT:  LBB0_2: ## %bb1\n ; ATOM-NEXT:    ## in Loop: Header=BB0_1 Depth=1\n ; ATOM-NEXT:    shrl $16, %eax\n ; ATOM-NEXT:    shrl $24, %edi\n-; ATOM-NEXT:    movzbl %al, %eax\n-; ATOM-NEXT:    xorl (%r8,%rax,4), %r15d\n+; ATOM-NEXT:    decq %r11\n+; ATOM-NEXT:    movzbl %al, %ebp\n ; ATOM-NEXT:    movzbl %bl, %eax\n ; ATOM-NEXT:    movl (%r10,%rax,4), %eax\n-; ATOM-NEXT:    xorl -4(%r11), %r15d\n+; ATOM-NEXT:    xorl (%r8,%rbp,4), %r15d\n ; ATOM-NEXT:    xorl (%r9,%rdi,4), %eax\n-; ATOM-NEXT:    xorl (%r11), %eax\n-; ATOM-NEXT:    addq $16, %r11\n+; ATOM-NEXT:    xorl -4(%r14), %r15d\n+; ATOM-NEXT:    xorl (%r14), %eax\n+; ATOM-NEXT:    addq $16, %r14\n ; ATOM-NEXT:  LBB0_1: ## %bb\n ; ATOM-NEXT:    ## =>This Inner Loop Header: Depth=1\n ; ATOM-NEXT:    movl %eax, %edi\n@@ -130,15 +132,15 @@ define void @t(i8* nocapture %in, i8* nocapture %out, i32* nocapture %rk, i32 %r\n ; ATOM-NEXT:    movzbl %r15b, %edi\n ; ATOM-NEXT:    xorl (%r9,%rbp,4), %ebx\n ; ATOM-NEXT:    movl (%r10,%rdi,4), %edi\n-; ATOM-NEXT:    xorl -12(%r11), %ebx\n+; ATOM-NEXT:    xorl -12(%r14), %ebx\n ; ATOM-NEXT:    xorl (%r9,%rax,4), %edi\n ; ATOM-NEXT:    movl %ebx, %eax\n-; ATOM-NEXT:    xorl -8(%r11), %edi\n+; ATOM-NEXT:    xorl -8(%r14), %edi\n ; ATOM-NEXT:    shrl $24, %eax\n ; ATOM-NEXT:    movl (%r9,%rax,4), %r15d\n-; ATOM-NEXT:    subq $1, %r14\n+; ATOM-NEXT:    testq %r11, %r11\n ; ATOM-NEXT:    movl %edi, %eax\n-; ATOM-NEXT:    jae LBB0_2\n+; ATOM-NEXT:    jne LBB0_2\n ; ATOM-NEXT:  ## %bb.3: ## %bb2\n ; ATOM-NEXT:    shrl $16, %eax\n ; ATOM-NEXT:    shrl $8, %edi"
            },
            {
                "fn": "llvm/test/Transforms/CodeGenPrepare/X86/overflow-intrinsics.ll",
                "patch": "@@ -475,23 +475,22 @@ define i64 @foo2(i8 *%p) {\n   ret i64 %sub\n }\n \n-; When the compare operand has uses besides add/sub,\n-; the transform may not be profitable.\n+; Avoid hoisting a math op into a dominating block which would\n+; increase the critical path.\n \n define void @PR41129(i64* %p64) {\n ; CHECK-LABEL: @PR41129(\n ; CHECK-NEXT:  entry:\n ; CHECK-NEXT:    [[KEY:%.*]] = load i64, i64* [[P64:%.*]], align 8\n-; CHECK-NEXT:    [[TMP0:%.*]] = call { i64, i1 } @llvm.usub.with.overflow.i64(i64 [[KEY]], i64 1)\n-; CHECK-NEXT:    [[MATH:%.*]] = extractvalue { i64, i1 } [[TMP0]], 0\n-; CHECK-NEXT:    [[OV:%.*]] = extractvalue { i64, i1 } [[TMP0]], 1\n-; CHECK-NEXT:    br i1 [[OV]], label [[TRUE:%.*]], label [[FALSE:%.*]]\n+; CHECK-NEXT:    [[COND17:%.*]] = icmp eq i64 [[KEY]], 0\n+; CHECK-NEXT:    br i1 [[COND17]], label [[TRUE:%.*]], label [[FALSE:%.*]]\n ; CHECK:       false:\n ; CHECK-NEXT:    [[ANDVAL:%.*]] = and i64 [[KEY]], 7\n ; CHECK-NEXT:    store i64 [[ANDVAL]], i64* [[P64]]\n ; CHECK-NEXT:    br label [[EXIT:%.*]]\n ; CHECK:       true:\n-; CHECK-NEXT:    store i64 [[MATH]], i64* [[P64]]\n+; CHECK-NEXT:    [[SVALUE:%.*]] = add i64 [[KEY]], -1\n+; CHECK-NEXT:    store i64 [[SVALUE]], i64* [[P64]]\n ; CHECK-NEXT:    br label [[EXIT]]\n ; CHECK:       exit:\n ; CHECK-NEXT:    ret void"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/cgp-usubo.ll (1 of 1)\nTesting Time: 0.26s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/cgp-usubo.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/lsr-loop-exit-cond.ll (1 of 1)\nTesting Time: 0.14s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/lsr-loop-exit-cond.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Transforms/CodeGenPrepare/X86/overflow-intrinsics.ll (1 of 1)\nTesting Time: 0.13s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/CodeGenPrepare/X86/overflow-intrinsics.ll\n\n  Unexpected Failures: 1\n"
    },
    "2f6ef2fc92955a5b77f302294ba97aa51dbaec4c___DwarfDebug.cpp": {
        "start": 840,
        "end": 948,
        "buggy": "void DwarfDebug::finalizeModuleInfo() {\n  const TargetLoweringObjectFile &TLOF = Asm->getObjFileLowering();\n\n  finishSubprogramDefinitions();\n\n  finishEntityDefinitions();\n\n  // Include the DWO file name in the hash if there's more than one CU.\n  // This handles ThinLTO's situation where imported CUs may very easily be\n  // duplicate with the same CU partially imported into another ThinLTO unit.\n  StringRef DWOName;\n  if (CUMap.size() > 1)\n    DWOName = Asm->TM.Options.MCOptions.SplitDwarfFile;\n\n  // Handle anything that needs to be done on a per-unit basis after\n  // all other generation.\n  for (const auto &P : CUMap) {\n    auto &TheCU = *P.second;\n    if (TheCU.getCUNode()->isDebugDirectivesOnly())\n      continue;\n    // Emit DW_AT_containing_type attribute to connect types with their\n    // vtable holding type.\n    TheCU.constructContainingTypeDIEs();\n\n    // Add CU specific attributes if we need to add any.\n    // If we're splitting the dwarf out now that we've got the entire\n    // CU then add the dwo id to it.\n    auto *SkCU = TheCU.getSkeleton();\n    if (useSplitDwarf() && !empty(TheCU.getUnitDie().children())) {\n      finishUnitAttributes(TheCU.getCUNode(), TheCU);\n      TheCU.addString(TheCU.getUnitDie(), dwarf::DW_AT_GNU_dwo_name,\n                      Asm->TM.Options.MCOptions.SplitDwarfFile);\n      SkCU->addString(SkCU->getUnitDie(), dwarf::DW_AT_GNU_dwo_name,\n                      Asm->TM.Options.MCOptions.SplitDwarfFile);\n      // Emit a unique identifier for this CU.\n      uint64_t ID =\n          DIEHash(Asm).computeCUSignature(DWOName, TheCU.getUnitDie());\n      if (getDwarfVersion() >= 5) {\n        TheCU.setDWOId(ID);\n        SkCU->setDWOId(ID);\n      } else {\n        TheCU.addUInt(TheCU.getUnitDie(), dwarf::DW_AT_GNU_dwo_id,\n                      dwarf::DW_FORM_data8, ID);\n        SkCU->addUInt(SkCU->getUnitDie(), dwarf::DW_AT_GNU_dwo_id,\n                      dwarf::DW_FORM_data8, ID);\n      }\n\n      if (getDwarfVersion() < 5 && !SkeletonHolder.getRangeLists().empty()) {\n        const MCSymbol *Sym = TLOF.getDwarfRangesSection()->getBeginSymbol();\n        SkCU->addSectionLabel(SkCU->getUnitDie(), dwarf::DW_AT_GNU_ranges_base,\n                              Sym, Sym);\n      }\n    } else if (SkCU) {\n      finishUnitAttributes(SkCU->getCUNode(), *SkCU);\n    }\n\n    // If we have code split among multiple sections or non-contiguous\n    // ranges of code then emit a DW_AT_ranges attribute on the unit that will\n    // remain in the .o file, otherwise add a DW_AT_low_pc.\n    // FIXME: We should use ranges allow reordering of code ala\n    // .subsections_via_symbols in mach-o. This would mean turning on\n    // ranges for all subprogram DIEs for mach-o.\n    DwarfCompileUnit &U = SkCU ? *SkCU : TheCU;\n\n    // We don't keep track of which addresses are used in which CU so this\n    // is a bit pessimistic under LTO.\n    if (!AddrPool.isEmpty() &&\n        (getDwarfVersion() >= 5 ||\n         (SkCU && !empty(TheCU.getUnitDie().children()))))\n      U.addAddrTableBase();\n\n    if (unsigned NumRanges = TheCU.getRanges().size()) {\n      if (NumRanges > 1 && useRangesSection())\n        // A DW_AT_low_pc attribute may also be specified in combination with\n        // DW_AT_ranges to specify the default base address for use in\n        // location lists (see Section 2.6.2) and range lists (see Section\n        // 2.17.3).\n        U.addUInt(U.getUnitDie(), dwarf::DW_AT_low_pc, dwarf::DW_FORM_addr, 0);\n      else\n        U.setBaseAddress(TheCU.getRanges().front().getStart());\n      U.attachRangesOrLowHighPC(U.getUnitDie(), TheCU.takeRanges());\n    }\n\n    if (getDwarfVersion() >= 5) {\n      if (U.hasRangeLists())\n        U.addRnglistsBase();\n\n      if (!DebugLocs.getLists().empty() && !useSplitDwarf())\n        U.addLoclistsBase();\n    }\n\n    auto *CUNode = cast<DICompileUnit>(P.first);\n    // If compile Unit has macros, emit \"DW_AT_macro_info\" attribute.\n    if (CUNode->getMacros())\n      U.addSectionLabel(U.getUnitDie(), dwarf::DW_AT_macro_info,\n                        U.getMacroLabelBegin(),\n                        TLOF.getDwarfMacinfoSection()->getBeginSymbol());\n  }\n\n  // Emit all frontend-produced Skeleton CUs, i.e., Clang modules.\n  for (auto *CUNode : MMI->getModule()->debug_compile_units())\n    if (CUNode->getDWOId())\n      getOrCreateDwarfCompileUnit(CUNode);\n\n  // Compute DIE offsets and sizes.\n  InfoHolder.computeSizeAndOffsets();\n  if (useSplitDwarf())\n    SkeletonHolder.computeSizeAndOffsets();\n}\n",
        "fix": null,
        "src_path": "2f6ef2fc92955a5b77f302294ba97aa51dbaec4c___DwarfDebug.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/2f6ef2fc92955a5b77f302294ba97aa51dbaec4c",
        "commit_msg": "DWARF v5: emit DW_AT_addr_base if DW_AT_low_pc references .debug_addr\n\nThe condition !AddrPool.empty() is tested before attachRangesOrLowHighPC(), which may add an entry to AddrPool. We emit DW_AT_low_pc (DW_FORM_addrx) but may incorrectly omit DW_AT_addr_base for LineTablesOnly. This can be easily reproduced:\n\nclang -gdwarf-5 -gmlt -c a.cc\n\nFix this by moving !AddrPool.empty() below.\n\nThis was discovered while investigating an lld crash (fixed by D61889) on such object files: ld.lld --gdb-index a.o\n\nReviewed By: probinson\n\nDifferential Revision: https://reviews.llvm.org/D61891\n\nllvm-svn: 360678",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/Generic/line-table-addrx.ll",
                "patch": "@@ -0,0 +1,21 @@\n+; RUN: %llc_dwarf -filetype=obj %s -o - | llvm-dwarfdump -v -debug-info - | FileCheck %s\n+\n+;; In DWARF v5, emit DW_AT_addr_base as DW_AT_addr_base is used for DW_AT_low_pc.\n+; CHECK: DW_AT_low_pc [DW_FORM_addrx]\n+; CHECK: DW_AT_addr_base\n+\n+define i64 @foo() !dbg !7 {\n+entry:\n+  ret i64 0\n+}\n+\n+!llvm.dbg.cu = !{!0}\n+!llvm.module.flags = !{!3, !4}\n+\n+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, emissionKind: LineTablesOnly, enums: !2, nameTableKind: None)\n+!1 = !DIFile(filename: \"a.cc\", directory: \"/tmp\")\n+!2 = !{}\n+!3 = !{i32 2, !\"Dwarf Version\", i32 5}\n+!4 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!7 = distinct !DISubprogram(name: \"a\", scope: !1, file: !1, line: 22, type: !8, scopeLine: 22, unit: !0, retainedNodes: !2)\n+!8 = !DISubroutineType(types: !2)"
            },
            {
                "fn": "llvm/test/DebugInfo/X86/convert-debugloc.ll",
                "patch": "@@ -11,9 +11,9 @@\n ; DW5-CHECK-NEXT:               DW_AT_str_offsets_base\t(0x00000008)\n ; DW5-CHECK-NEXT:               DW_AT_stmt_list\t(0x00000000)\n ; DW5-CHECK-NEXT:               DW_AT_comp_dir {{.*}}\n-; DW5-CHECK-NEXT:               DW_AT_addr_base\t(0x00000008)\n ; DW5-CHECK-NEXT:               DW_AT_low_pc\t(0x0000000000000000)\n ; DW5-CHECK-NEXT:               DW_AT_high_pc\t(0x0000000000000007)\n+; DW5-CHECK-NEXT:               DW_AT_addr_base\t(0x00000008)\n ; DW5-CHECK-NEXT:               DW_AT_loclists_base\t(0x0000000c)\n ; DW5-CHECK-EMPTY:\n ; DW5-CHECK-NEXT: 0x00000027:   DW_TAG_base_type"
            },
            {
                "fn": "llvm/test/DebugInfo/X86/fission-ranges.ll",
                "patch": "@@ -12,6 +12,8 @@\n ; CHECK-NEXT: DW_AT_GNU_dwo_name\n ; CHECK-NEXT: DW_AT_GNU_dwo_id\n ; CHECK-NEXT: DW_AT_GNU_ranges_base\n+; CHECK-NEXT: DW_AT_low_pc\n+; CHECK-NEXT: DW_AT_high_pc\n ; CHECK-NEXT: DW_AT_GNU_addr_base [DW_FORM_sec_offset]                   (0x00000000)\n \n ; CHECK: .debug_info.dwo contents:"
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/Generic/line-table-addrx.ll (1 of 1)\nTesting Time: 0.11s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/Generic/line-table-addrx.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: DebugInfo/X86/convert-debugloc.ll (1 of 1)\nTesting Time: 0.08s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/convert-debugloc.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: DebugInfo/X86/fission-ranges.ll (1 of 1)\nTesting Time: 0.10s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/fission-ranges.ll\n\n  Unexpected Failures: 1\n"
    },
    "101915cfdaba9284b5bb8dedbbca2b7788f68da4___LoopPredication.cpp": {
        "start": 843,
        "end": 908,
        "buggy": "Optional<LoopICmp> LoopPredication::parseLoopLatchICmp() {\n  using namespace PatternMatch;\n\n  BasicBlock *LoopLatch = L->getLoopLatch();\n  if (!LoopLatch) {\n    LLVM_DEBUG(dbgs() << \"The loop doesn't have a single latch!\\n\");\n    return None;\n  }\n\n  auto *BI = dyn_cast<BranchInst>(LoopLatch->getTerminator());\n  if (!BI) {\n    LLVM_DEBUG(dbgs() << \"Failed to match the latch terminator!\\n\");\n    return None;\n  }\n  BasicBlock *TrueDest = BI->getSuccessor(0);\n  assert(\n      (TrueDest == L->getHeader() || BI->getSuccessor(1) == L->getHeader()) &&\n      \"One of the latch's destinations must be the header\");\n\n  auto *ICI = dyn_cast<ICmpInst>(BI->getCondition());\n  if (!ICI || !BI->isConditional()) {\n    LLVM_DEBUG(dbgs() << \"Failed to match the latch condition!\\n\");\n    return None;\n  }\n  auto Result = parseLoopICmp(ICI);\n  if (!Result) {\n    LLVM_DEBUG(dbgs() << \"Failed to parse the loop latch condition!\\n\");\n    return None;\n  }\n\n  if (TrueDest != L->getHeader())\n    Result->Pred = ICmpInst::getInversePredicate(Result->Pred);\n\n  // Check affine first, so if it's not we don't try to compute the step\n  // recurrence.\n  if (!Result->IV->isAffine()) {\n    LLVM_DEBUG(dbgs() << \"The induction variable is not affine!\\n\");\n    return None;\n  }\n\n  auto *Step = Result->IV->getStepRecurrence(*SE);\n  if (!isSupportedStep(Step)) {\n    LLVM_DEBUG(dbgs() << \"Unsupported loop stride(\" << *Step << \")!\\n\");\n    return None;\n  }\n\n  auto IsUnsupportedPredicate = [](const SCEV *Step, ICmpInst::Predicate Pred) {\n    if (Step->isOne()) {\n      return Pred != ICmpInst::ICMP_ULT && Pred != ICmpInst::ICMP_SLT &&\n             Pred != ICmpInst::ICMP_ULE && Pred != ICmpInst::ICMP_SLE;\n    } else {\n      assert(Step->isAllOnesValue() && \"Step should be -1!\");\n      return Pred != ICmpInst::ICMP_UGT && Pred != ICmpInst::ICMP_SGT &&\n             Pred != ICmpInst::ICMP_UGE && Pred != ICmpInst::ICMP_SGE;\n    }\n  };\n\n  normalizePredicate(SE, L, *Result);\n  if (IsUnsupportedPredicate(Step, Result->Pred)) {\n    LLVM_DEBUG(dbgs() << \"Unsupported loop latch predicate(\" << Result->Pred\n                      << \")!\\n\");\n    return None;\n  }\n\n  return Result;\n}\n",
        "fix": null,
        "src_path": "101915cfdaba9284b5bb8dedbbca2b7788f68da4___LoopPredication.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/101915cfdaba9284b5bb8dedbbca2b7788f68da4",
        "commit_msg": "[LoopPred] Fix a bug in unconditional latch bailout introduced in r362284\n\nThis is a really silly bug that even a simple test w/an unconditional latch would have caught.  I tried to guard against the case, but put it in the wrong if check.  Oops.\n\nllvm-svn: 362727",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/LoopPredication/basic.ll",
                "patch": "@@ -1853,3 +1853,29 @@ exit:\n   ret i32 0\n }\n \n+; Negative test, make sure we don't crash on unconditional latches\n+; TODO: there's no reason we shouldn't be able to predicate the\n+; condition for an statically infinite loop.\n+define i32 @unconditional_latch(i32* %a, i32 %length) {\n+; CHECK-LABEL: @unconditional_latch(\n+; CHECK-NEXT:  loop.preheader:\n+; CHECK-NEXT:    br label [[LOOP:%.*]]\n+; CHECK:       loop:\n+; CHECK-NEXT:    [[I:%.*]] = phi i32 [ [[I_NEXT:%.*]], [[LOOP]] ], [ 400, [[LOOP_PREHEADER:%.*]] ]\n+; CHECK-NEXT:    [[WITHIN_BOUNDS:%.*]] = icmp ult i32 [[I]], [[LENGTH:%.*]]\n+; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 [[WITHIN_BOUNDS]], i32 9) [ \"deopt\"() ]\n+; CHECK-NEXT:    store volatile i32 0, i32* [[A:%.*]]\n+; CHECK-NEXT:    [[I_NEXT]] = add i32 [[I]], 1\n+; CHECK-NEXT:    br label [[LOOP]]\n+;\n+loop.preheader:\n+  br label %loop\n+\n+loop:\n+  %i = phi i32 [ %i.next, %loop ], [ 400, %loop.preheader ]\n+  %within.bounds = icmp ult i32 %i, %length\n+  call void (i1, ...) @llvm.experimental.guard(i1 %within.bounds, i32 9) [ \"deopt\"() ]\n+  store volatile i32 0, i32* %a\n+  %i.next = add i32 %i, 1\n+  br label %loop\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/LoopPredication/basic.ll (1 of 1)\nTesting Time: 2.20s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LoopPredication/basic.ll\n\n  Unexpected Failures: 1\n"
    },
    "ea5c94b497cfc43f9ec513f721e03aa5c669249a___IndVarSimplify.cpp": {
        "start": 2627,
        "end": 2730,
        "buggy": "bool IndVarSimplify::optimizeLoopExits(Loop *L) {\n  SmallVector<BasicBlock*, 16> ExitingBlocks;\n  L->getExitingBlocks(ExitingBlocks);\n\n  // Form an expression for the maximum exit count possible for this loop. We\n  // merge the max and exact information to approximate a version of\n  // getMaxBackedgeTakenInfo which isn't restricted to just constants.\n  // TODO: factor this out as a version of getMaxBackedgeTakenCount which\n  // isn't guaranteed to return a constant.\n  SmallVector<const SCEV*, 4> ExitCounts;\n  const SCEV *MaxConstEC = SE->getMaxBackedgeTakenCount(L);\n  if (!isa<SCEVCouldNotCompute>(MaxConstEC))\n    ExitCounts.push_back(MaxConstEC);\n  for (BasicBlock *ExitingBB : ExitingBlocks) {\n    const SCEV *ExitCount = SE->getExitCount(L, ExitingBB);\n    if (!isa<SCEVCouldNotCompute>(ExitCount)) {\n      assert(DT->dominates(ExitingBB, L->getLoopLatch()) &&\n             \"We should only have known counts for exiting blocks that \"\n             \"dominate latch!\");\n      ExitCounts.push_back(ExitCount);\n    }\n  }\n  if (ExitCounts.empty())\n    return false;\n  const SCEV *MaxExitCount = SE->getUMinFromMismatchedTypes(ExitCounts);\n\n  bool Changed = false;\n  for (BasicBlock *ExitingBB : ExitingBlocks) {\n    // If our exitting block exits multiple loops, we can only rewrite the\n    // innermost one.  Otherwise, we're changing how many times the innermost\n    // loop runs before it exits. \n    if (LI->getLoopFor(ExitingBB) != L)\n      continue;\n\n    // Can't rewrite non-branch yet.\n    BranchInst *BI = dyn_cast<BranchInst>(ExitingBB->getTerminator());\n    if (!BI)\n      continue;\n\n    // If already constant, nothing to do.\n    if (isa<Constant>(BI->getCondition()))\n      continue;\n    \n    const SCEV *ExitCount = SE->getExitCount(L, ExitingBB);\n    if (isa<SCEVCouldNotCompute>(ExitCount))\n      continue;\n\n    // If we know we'd exit on the first iteration, rewrite the exit to\n    // reflect this.  This does not imply the loop must exit through this\n    // exit; there may be an earlier one taken on the first iteration.\n    // TODO: Given we know the backedge can't be taken, we should go ahead\n    // and break it.  Or at least, kill all the header phis and simplify.\n    if (ExitCount->isZero()) {\n      bool ExitIfTrue = !L->contains(*succ_begin(ExitingBB));\n      auto *OldCond = BI->getCondition();\n      auto *NewCond = ExitIfTrue ? ConstantInt::getTrue(OldCond->getType()) :\n        ConstantInt::getFalse(OldCond->getType());\n      BI->setCondition(NewCond);\n      if (OldCond->use_empty())\n        DeadInsts.push_back(OldCond);\n      Changed = true;\n      continue;\n    }\n\n    // If we end up with a pointer exit count, bail.\n    if (!ExitCount->getType()->isIntegerTy() ||\n        !MaxExitCount->getType()->isIntegerTy())\n      return false;\n    \n    Type *WiderType =\n      SE->getWiderType(MaxExitCount->getType(), ExitCount->getType());\n    ExitCount = SE->getNoopOrZeroExtend(ExitCount, WiderType);\n    MaxExitCount = SE->getNoopOrZeroExtend(MaxExitCount, WiderType);\n    assert(MaxExitCount->getType() == ExitCount->getType());\n    \n    // Can we prove that some other exit must be taken strictly before this\n    // one?  TODO: handle cases where ule is known, and equality is covered\n    // by a dominating exit\n    if (SE->isLoopEntryGuardedByCond(L, CmpInst::ICMP_ULT,\n                                     MaxExitCount, ExitCount)) {\n      bool ExitIfTrue = !L->contains(*succ_begin(ExitingBB));\n      auto *OldCond = BI->getCondition();\n      auto *NewCond = ExitIfTrue ? ConstantInt::getFalse(OldCond->getType()) :\n        ConstantInt::getTrue(OldCond->getType());\n      BI->setCondition(NewCond);\n      if (OldCond->use_empty())\n        DeadInsts.push_back(OldCond);\n      Changed = true;\n      continue;\n    }\n\n    // TODO: If we can prove that the exiting iteration is equal to the exit\n    // count for this exit and that no previous exit oppurtunities exist within\n    // the loop, then we can discharge all other exits.  (May fall out of\n    // previous TODO.) \n    \n    // TODO: If we can't prove any relation between our exit count and the\n    // loops exit count, but taking this exit doesn't require actually running\n    // the loop (i.e. no side effects, no computed values used in exit), then\n    // we can replace the exit test with a loop invariant test which exits on\n    // the first iteration.  \n  }\n  return Changed;\n}\n",
        "fix": null,
        "src_path": "ea5c94b497cfc43f9ec513f721e03aa5c669249a___IndVarSimplify.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/ea5c94b497cfc43f9ec513f721e03aa5c669249a",
        "commit_msg": "[IndVars] Fix a subtle bug in optimizeLoopExits\n\nThe original code failed to account for the fact that one exit can have a pointer exit count without all of them having pointer exit counts.  This could cause two separate bugs:\n1) We might exit the loop early, and leave optimizations undone.  This is what triggered the assertion failure in the reported test case.\n2) We might optimize one exit, then exit without indicating a change.  This could result in an analysis invalidaton bug if no other transform is done by the rest of indvars.\n\nNote that the pointer exit counts are a really fragile concept.  They show up only when we have a pointer IV w/o a datalayout to provide their size.  It's really questionable to me whether the complexity implied is worth it.\n\nllvm-svn: 366829",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/IndVarSimplify/eliminate-exit-no-dl.ll",
                "patch": "@@ -0,0 +1,45 @@\n+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py\n+; RUN: opt -indvars -S < %s | FileCheck %s\n+\n+; Check the case where one exit has a pointer EC, and the other doesn't.\n+; Note that this test case is really really fragile.  Removing any\n+; instruction in the below causes the result to differ.  Note that the lack\n+; of a data layout (with pointer size info) is critical to getting a pointer\n+; EC returned by SCEV.\n+\n+@global = external global [0 x i8], align 1\n+\n+define void @foo() {\n+; CHECK-LABEL: @foo(\n+; CHECK-NEXT:  bb:\n+; CHECK-NEXT:    br label [[BB3:%.*]]\n+; CHECK:       bb3:\n+; CHECK-NEXT:    [[TMP:%.*]] = phi i8* [ [[TMP4:%.*]], [[BB7:%.*]] ], [ getelementptr inbounds ([0 x i8], [0 x i8]* @global, i64 0, i64 2), [[BB:%.*]] ]\n+; CHECK-NEXT:    [[TMP4]] = getelementptr inbounds i8, i8* [[TMP]], i64 -1\n+; CHECK-NEXT:    [[TMP6:%.*]] = load i8, i8* [[TMP4]], align 1\n+; CHECK-NEXT:    [[TMP5:%.*]] = icmp ugt i8* [[TMP4]], getelementptr inbounds ([0 x i8], [0 x i8]* @global, i64 0, i64 500)\n+; CHECK-NEXT:    br i1 [[TMP5]], label [[BB7]], label [[BB11:%.*]]\n+; CHECK:       bb7:\n+; CHECK-NEXT:    [[TMP8:%.*]] = zext i8 [[TMP6]] to i64\n+; CHECK-NEXT:    br i1 true, label [[BB11]], label [[BB3]]\n+; CHECK:       bb11:\n+; CHECK-NEXT:    ret void\n+;\n+bb:\n+  br label %bb3\n+\n+bb3:                                              ; preds = %bb7, %bb2\n+  %tmp = phi i8* [ %tmp4, %bb7 ], [ getelementptr inbounds ([0 x i8], [0 x i8]* @global, i64 0, i64 2), %bb ]\n+  %tmp4 = getelementptr inbounds i8, i8* %tmp, i64 -1\n+  %tmp6 = load i8, i8* %tmp4, align 1\n+  %tmp5 = icmp ugt i8* %tmp4, getelementptr inbounds ([0 x i8], [0 x i8]* @global, i64 0, i64 500)\n+  br i1 %tmp5, label %bb7, label %bb11\n+\n+bb7:                                              ; preds = %bb3\n+  %tmp8 = zext i8 %tmp6 to i64\n+  %tmp10 = icmp eq i16 0, 0\n+  br i1 %tmp10, label %bb11, label %bb3\n+\n+bb11:                                             ; preds = %bb7, %bb3\n+  ret void\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/IndVarSimplify/eliminate-exit-no-dl.ll (1 of 1)\nTesting Time: 0.25s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/IndVarSimplify/eliminate-exit-no-dl.ll\n\n  Unexpected Failures: 1\n"
    },
    "991834a51616799456a5e65cefde2f41c350aca2___GlobalOpt.cpp": {
        "start": 1603,
        "end": 1753,
        "buggy": "static bool TryToShrinkGlobalToBoolean(GlobalVariable *GV, Constant *OtherVal) {\n  Type *GVElType = GV->getValueType();\n\n  // If GVElType is already i1, it is already shrunk.  If the type of the GV is\n  // an FP value, pointer or vector, don't do this optimization because a select\n  // between them is very expensive and unlikely to lead to later\n  // simplification.  In these cases, we typically end up with \"cond ? v1 : v2\"\n  // where v1 and v2 both require constant pool loads, a big loss.\n  if (GVElType == Type::getInt1Ty(GV->getContext()) ||\n      GVElType->isFloatingPointTy() ||\n      GVElType->isPointerTy() || GVElType->isVectorTy())\n    return false;\n\n  // Walk the use list of the global seeing if all the uses are load or store.\n  // If there is anything else, bail out.\n  for (User *U : GV->users())\n    if (!isa<LoadInst>(U) && !isa<StoreInst>(U))\n      return false;\n\n  LLVM_DEBUG(dbgs() << \"   *** SHRINKING TO BOOL: \" << *GV << \"\\n\");\n\n  // Create the new global, initializing it to false.\n  GlobalVariable *NewGV = new GlobalVariable(Type::getInt1Ty(GV->getContext()),\n                                             false,\n                                             GlobalValue::InternalLinkage,\n                                        ConstantInt::getFalse(GV->getContext()),\n                                             GV->getName()+\".b\",\n                                             GV->getThreadLocalMode(),\n                                             GV->getType()->getAddressSpace());\n  NewGV->copyAttributesFrom(GV);\n  GV->getParent()->getGlobalList().insert(GV->getIterator(), NewGV);\n\n  Constant *InitVal = GV->getInitializer();\n  assert(InitVal->getType() != Type::getInt1Ty(GV->getContext()) &&\n         \"No reason to shrink to bool!\");\n\n  SmallVector<DIGlobalVariableExpression *, 1> GVs;\n  GV->getDebugInfo(GVs);\n\n  // If initialized to zero and storing one into the global, we can use a cast\n  // instead of a select to synthesize the desired value.\n  bool IsOneZero = false;\n  bool EmitOneOrZero = true;\n  if (ConstantInt *CI = dyn_cast<ConstantInt>(OtherVal)){\n    IsOneZero = InitVal->isNullValue() && CI->isOne();\n\n    if (ConstantInt *CIInit = dyn_cast<ConstantInt>(GV->getInitializer())){\n      uint64_t ValInit = CIInit->getZExtValue();\n      uint64_t ValOther = CI->getZExtValue();\n      uint64_t ValMinus = ValOther - ValInit;\n\n      for(auto *GVe : GVs){\n        DIGlobalVariable *DGV = GVe->getVariable();\n        DIExpression *E = GVe->getExpression();\n        const DataLayout &DL = GV->getParent()->getDataLayout();\n        unsigned SizeInOctets =\n          DL.getTypeAllocSizeInBits(NewGV->getType()->getElementType()) / 8;\n\n        // It is expected that the address of global optimized variable is on\n        // top of the stack. After optimization, value of that variable will\n        // be ether 0 for initial value or 1 for other value. The following\n        // expression should return constant integer value depending on the\n        // value at global object address:\n        // val * (ValOther - ValInit) + ValInit:\n        // DW_OP_deref DW_OP_constu <ValMinus>\n        // DW_OP_mul DW_OP_constu <ValInit> DW_OP_plus DW_OP_stack_value\n        SmallVector<uint64_t, 12> Ops = {\n            dwarf::DW_OP_deref_size, SizeInOctets,\n            dwarf::DW_OP_constu, ValMinus,\n            dwarf::DW_OP_mul, dwarf::DW_OP_constu, ValInit,\n            dwarf::DW_OP_plus};\n        bool WithStackValue = true;\n        E = DIExpression::prependOpcodes(E, Ops, WithStackValue);\n        DIGlobalVariableExpression *DGVE =\n          DIGlobalVariableExpression::get(NewGV->getContext(), DGV, E);\n        NewGV->addDebugInfo(DGVE);\n     }\n     EmitOneOrZero = false;\n    }\n  }\n\n  if (EmitOneOrZero) {\n     // FIXME: This will only emit address for debugger on which will\n     // be written only 0 or 1.\n     for(auto *GV : GVs)\n       NewGV->addDebugInfo(GV);\n   }\n\n  while (!GV->use_empty()) {\n    Instruction *UI = cast<Instruction>(GV->user_back());\n    if (StoreInst *SI = dyn_cast<StoreInst>(UI)) {\n      // Change the store into a boolean store.\n      bool StoringOther = SI->getOperand(0) == OtherVal;\n      // Only do this if we weren't storing a loaded value.\n      Value *StoreVal;\n      if (StoringOther || SI->getOperand(0) == InitVal) {\n        StoreVal = ConstantInt::get(Type::getInt1Ty(GV->getContext()),\n                                    StoringOther);\n      } else {\n        // Otherwise, we are storing a previously loaded copy.  To do this,\n        // change the copy from copying the original value to just copying the\n        // bool.\n        Instruction *StoredVal = cast<Instruction>(SI->getOperand(0));\n\n        // If we've already replaced the input, StoredVal will be a cast or\n        // select instruction.  If not, it will be a load of the original\n        // global.\n        if (LoadInst *LI = dyn_cast<LoadInst>(StoredVal)) {\n          assert(LI->getOperand(0) == GV && \"Not a copy!\");\n          // Insert a new load, to preserve the saved value.\n          StoreVal = new LoadInst(NewGV->getValueType(), NewGV,\n                                  LI->getName() + \".b\", false, 0,\n                                  LI->getOrdering(), LI->getSyncScopeID(), LI);\n        } else {\n          assert((isa<CastInst>(StoredVal) || isa<SelectInst>(StoredVal)) &&\n                 \"This is not a form that we understand!\");\n          StoreVal = StoredVal->getOperand(0);\n          assert(isa<LoadInst>(StoreVal) && \"Not a load of NewGV!\");\n        }\n      }\n      StoreInst *NSI =\n          new StoreInst(StoreVal, NewGV, false, 0, SI->getOrdering(),\n                        SI->getSyncScopeID(), SI);\n      NSI->setDebugLoc(SI->getDebugLoc());\n    } else {\n      // Change the load into a load of bool then a select.\n      LoadInst *LI = cast<LoadInst>(UI);\n      LoadInst *NLI =\n          new LoadInst(NewGV->getValueType(), NewGV, LI->getName() + \".b\",\n                       false, 0, LI->getOrdering(), LI->getSyncScopeID(), LI);\n      Instruction *NSI;\n      if (IsOneZero)\n        NSI = new ZExtInst(NLI, LI->getType(), \"\", LI);\n      else\n        NSI = SelectInst::Create(NLI, OtherVal, InitVal, \"\", LI);\n      NSI->takeName(LI);\n      // Since LI is split into two instructions, NLI and NSI both inherit the\n      // same DebugLoc\n      NLI->setDebugLoc(LI->getDebugLoc());\n      NSI->setDebugLoc(LI->getDebugLoc());\n      LI->replaceAllUsesWith(NSI);\n    }\n    UI->eraseFromParent();\n  }\n\n  // Retain the name of the old global variable. People who are debugging their\n  // programs may expect these variables to be named the same.\n  NewGV->takeName(GV);\n  GV->eraseFromParent();\n  return true;\n}\n",
        "fix": null,
        "src_path": "991834a51616799456a5e65cefde2f41c350aca2___GlobalOpt.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/991834a51616799456a5e65cefde2f41c350aca2",
        "commit_msg": "[GlobalOpt] prevent crashing on large integer types (PR42932)\n\nThis is a minimal fix (copy the predicate for the assert) to\nprevent the crashing seen in:\nhttps://bugs.llvm.org/show_bug.cgi?id=42932\n...when converting a constant integer of arbitrary width to uint64_t.\n\nDifferential Revision: https://reviews.llvm.org/D65970\n\nllvm-svn: 368437",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/GlobalOpt/large-int-crash.ll",
                "patch": "@@ -0,0 +1,23 @@\n+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py\n+; RUN: opt < %s -globalopt -S | FileCheck %s\n+\n+@X = internal global i128 0\n+\n+define void @foo() {\n+; CHECK-LABEL: @foo(\n+; CHECK-NEXT:    [[T0_B:%.*]] = load i1, i1* @X\n+; CHECK-NEXT:    [[T0:%.*]] = select i1 [[T0_B]], i128 18446744073709551616, i128 0\n+; CHECK-NEXT:    ret void\n+;\n+  %t0 = load i128, i128* @X, align 8\n+  ret void\n+}\n+\n+define void @store() {\n+; CHECK-LABEL: @store(\n+; CHECK-NEXT:    store i1 true, i1* @X\n+; CHECK-NEXT:    ret void\n+;\n+  store i128 18446744073709551616, i128* @X, align 8\n+  ret void\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/GlobalOpt/large-int-crash.ll (1 of 1)\nTesting Time: 1.11s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/GlobalOpt/large-int-crash.ll\n\n  Unexpected Failures: 1\n"
    },
    "036e636aa7fc6d367ac19197936f3320f28214b0___LoopUnrollPeel.cpp": {
        "start": 578,
        "end": 765,
        "buggy": "bool llvm::peelLoop(Loop *L, unsigned PeelCount, LoopInfo *LI,\n                    ScalarEvolution *SE, DominatorTree *DT,\n                    AssumptionCache *AC, bool PreserveLCSSA) {\n  assert(PeelCount > 0 && \"Attempt to peel out zero iterations?\");\n  assert(canPeel(L) && \"Attempt to peel a loop which is not peelable?\");\n\n  LoopBlocksDFS LoopBlocks(L);\n  LoopBlocks.perform(LI);\n\n  BasicBlock *Header = L->getHeader();\n  BasicBlock *PreHeader = L->getLoopPreheader();\n  BasicBlock *Latch = L->getLoopLatch();\n  SmallVector<std::pair<BasicBlock *, BasicBlock *>, 4> ExitEdges;\n  L->getExitEdges(ExitEdges);\n\n  DenseMap<BasicBlock *, BasicBlock *> ExitIDom;\n  if (DT) {\n    // We'd like to determine the idom of exit block after peeling one\n    // iteration.\n    // Let Exit is exit block.\n    // Let ExitingSet - is a set of predecessors of Exit block. They are exiting\n    // blocks.\n    // Let Latch' and ExitingSet' are copies after a peeling.\n    // We'd like to find an idom'(Exit) - idom of Exit after peeling.\n    // It is an evident that idom'(Exit) will be the nearest common dominator\n    // of ExitingSet and ExitingSet'.\n    // idom(Exit) is a nearest common dominator of ExitingSet.\n    // idom(Exit)' is a nearest common dominator of ExitingSet'.\n    // Taking into account that we have a single Latch, Latch' will dominate\n    // Header and idom(Exit).\n    // So the idom'(Exit) is nearest common dominator of idom(Exit)' and Latch'.\n    // All these basic blocks are in the same loop, so what we find is\n    // (nearest common dominator of idom(Exit) and Latch)'.\n    // In the loop below we remember nearest common dominator of idom(Exit) and\n    // Latch to update idom of Exit later.\n    assert(L->hasDedicatedExits() && \"No dedicated exits?\");\n    for (auto Edge : ExitEdges) {\n      if (ExitIDom.count(Edge.second))\n        continue;\n      BasicBlock *BB = DT->findNearestCommonDominator(\n          DT->getNode(Edge.second)->getIDom()->getBlock(), Latch);\n      assert(L->contains(BB) && \"IDom is not in a loop\");\n      ExitIDom[Edge.second] = BB;\n    }\n  }\n\n  Function *F = Header->getParent();\n\n  // Set up all the necessary basic blocks. It is convenient to split the\n  // preheader into 3 parts - two blocks to anchor the peeled copy of the loop\n  // body, and a new preheader for the \"real\" loop.\n\n  // Peeling the first iteration transforms.\n  //\n  // PreHeader:\n  // ...\n  // Header:\n  //   LoopBody\n  //   If (cond) goto Header\n  // Exit:\n  //\n  // into\n  //\n  // InsertTop:\n  //   LoopBody\n  //   If (!cond) goto Exit\n  // InsertBot:\n  // NewPreHeader:\n  // ...\n  // Header:\n  //  LoopBody\n  //  If (cond) goto Header\n  // Exit:\n  //\n  // Each following iteration will split the current bottom anchor in two,\n  // and put the new copy of the loop body between these two blocks. That is,\n  // after peeling another iteration from the example above, we'll split\n  // InsertBot, and get:\n  //\n  // InsertTop:\n  //   LoopBody\n  //   If (!cond) goto Exit\n  // InsertBot:\n  //   LoopBody\n  //   If (!cond) goto Exit\n  // InsertBot.next:\n  // NewPreHeader:\n  // ...\n  // Header:\n  //  LoopBody\n  //  If (cond) goto Header\n  // Exit:\n\n  BasicBlock *InsertTop = SplitEdge(PreHeader, Header, DT, LI);\n  BasicBlock *InsertBot =\n      SplitBlock(InsertTop, InsertTop->getTerminator(), DT, LI);\n  BasicBlock *NewPreHeader =\n      SplitBlock(InsertBot, InsertBot->getTerminator(), DT, LI);\n\n  InsertTop->setName(Header->getName() + \".peel.begin\");\n  InsertBot->setName(Header->getName() + \".peel.next\");\n  NewPreHeader->setName(PreHeader->getName() + \".peel.newph\");\n\n  ValueToValueMapTy LVMap;\n\n  // If we have branch weight information, we'll want to update it for the\n  // newly created branches.\n  BranchInst *LatchBR =\n      cast<BranchInst>(cast<BasicBlock>(Latch)->getTerminator());\n  uint64_t ExitWeight = 0, FallThroughWeight = 0;\n  initBranchWeights(Header, LatchBR, ExitWeight, FallThroughWeight);\n\n  // For each peeled-off iteration, make a copy of the loop.\n  for (unsigned Iter = 0; Iter < PeelCount; ++Iter) {\n    SmallVector<BasicBlock *, 8> NewBlocks;\n    ValueToValueMapTy VMap;\n\n    cloneLoopBlocks(L, Iter, InsertTop, InsertBot, ExitEdges, NewBlocks,\n                    LoopBlocks, VMap, LVMap, DT, LI);\n\n    // Remap to use values from the current iteration instead of the\n    // previous one.\n    remapInstructionsInBlocks(NewBlocks, VMap);\n\n    if (DT) {\n      // Latches of the cloned loops dominate over the loop exit, so idom of the\n      // latter is the first cloned loop body, as original PreHeader dominates\n      // the original loop body.\n      if (Iter == 0)\n        for (auto Exit : ExitIDom)\n          DT->changeImmediateDominator(Exit.first,\n                                       cast<BasicBlock>(LVMap[Exit.second]));\n#ifdef EXPENSIVE_CHECKS\n      assert(DT->verify(DominatorTree::VerificationLevel::Fast));\n#endif\n    }\n\n    auto *LatchBRCopy = cast<BranchInst>(VMap[LatchBR]);\n    updateBranchWeights(InsertBot, LatchBRCopy, ExitWeight, FallThroughWeight);\n    // Remove Loop metadata from the latch branch instruction\n    // because it is not the Loop's latch branch anymore.\n    LatchBRCopy->setMetadata(LLVMContext::MD_loop, nullptr);\n\n    InsertTop = InsertBot;\n    InsertBot = SplitBlock(InsertBot, InsertBot->getTerminator(), DT, LI);\n    InsertBot->setName(Header->getName() + \".peel.next\");\n\n    F->getBasicBlockList().splice(InsertTop->getIterator(),\n                                  F->getBasicBlockList(),\n                                  NewBlocks[0]->getIterator(), F->end());\n  }\n\n  // Now adjust the phi nodes in the loop header to get their initial values\n  // from the last peeled-off iteration instead of the preheader.\n  for (BasicBlock::iterator I = Header->begin(); isa<PHINode>(I); ++I) {\n    PHINode *PHI = cast<PHINode>(I);\n    Value *NewVal = PHI->getIncomingValueForBlock(Latch);\n    Instruction *LatchInst = dyn_cast<Instruction>(NewVal);\n    if (LatchInst && L->contains(LatchInst))\n      NewVal = LVMap[LatchInst];\n\n    PHI->setIncomingValueForBlock(NewPreHeader, NewVal);\n  }\n\n  fixupBranchWeights(Header, LatchBR, ExitWeight, FallThroughWeight);\n\n  if (Loop *ParentLoop = L->getParentLoop())\n    L = ParentLoop;\n\n  // We modified the loop, update SE.\n  SE->forgetTopmostLoop(L);\n\n  // Finally DomtTree must be correct.\n  assert(DT->verify(DominatorTree::VerificationLevel::Fast));\n\n  // FIXME: Incrementally update loop-simplify\n  simplifyLoop(L, DT, LI, SE, AC, nullptr, PreserveLCSSA);\n\n  NumPeeled++;\n\n  // Update Metadata for count of peeled off iterations.\n  unsigned AlreadyPeeled = 0;\n  if (auto Peeled = getOptionalIntLoopAttribute(L, PeeledCountMetaData))\n    AlreadyPeeled = *Peeled;\n  addStringMetadataToLoop(L, PeeledCountMetaData, AlreadyPeeled + PeelCount);\n\n  return true;\n}\n",
        "fix": null,
        "src_path": "036e636aa7fc6d367ac19197936f3320f28214b0___LoopUnrollPeel.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/036e636aa7fc6d367ac19197936f3320f28214b0",
        "commit_msg": "[Loop Peeling] Fix silly bug in metadata update.\n\nWe must update loop metedata before we moved to parent loop if\nit is present.\n\nllvm-svn: 369637",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/LoopUnroll/peel-loop-inner.ll",
                "patch": "@@ -0,0 +1,50 @@\n+; RUN: opt < %s -S -passes='require<opt-remark-emit>,unroll<peeling;no-runtime>,simplify-cfg,instcombine' -unroll-force-peel-count=3 -verify-dom-info | FileCheck %s\n+\n+define void @basic(i32 %K, i32 %N) {\n+; CHECK-LABEL: @basic(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    br label [[OUTER:%.*]]\n+; CHECK:       outer:\n+; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[I_INC:%.*]], [[OUTER_BACKEDGE:%.*]] ]\n+; CHECK-NEXT:    [[CMP_INNER_PEEL:%.*]] = icmp sgt i32 [[K:%.*]], 1\n+; CHECK-NEXT:    br i1 [[CMP_INNER_PEEL]], label [[INNER_PEEL2:%.*]], label [[OUTER_BACKEDGE]]\n+; CHECK:       inner.peel2:\n+; CHECK-NEXT:    [[CMP_INNER_PEEL4:%.*]] = icmp eq i32 [[K]], 2\n+; CHECK-NEXT:    br i1 [[CMP_INNER_PEEL4]], label [[OUTER_BACKEDGE]], label [[INNER_PEEL6:%.*]]\n+; CHECK:       inner.peel6:\n+; CHECK-NEXT:    [[CMP_INNER_PEEL8:%.*]] = icmp sgt i32 [[K]], 3\n+; CHECK-NEXT:    br i1 [[CMP_INNER_PEEL8]], label [[INNER:%.*]], label [[OUTER_BACKEDGE]]\n+; CHECK:       inner:\n+; CHECK-NEXT:    [[J:%.*]] = phi i32 [ [[J_INC:%.*]], [[INNER]] ], [ 3, [[INNER_PEEL6]] ]\n+; CHECK-NEXT:    [[J_INC]] = add nuw nsw i32 [[J]], 1\n+; CHECK-NEXT:    [[CMP_INNER:%.*]] = icmp slt i32 [[J_INC]], [[K]]\n+; CHECK-NEXT:    br i1 [[CMP_INNER]], label [[INNER]], label [[OUTER_BACKEDGE]], !llvm.loop !0\n+; CHECK:       outer.backedge:\n+; CHECK-NEXT:    [[I_INC]] = add i32 [[I]], 1\n+; CHECK-NEXT:    [[CMP_OUTER:%.*]] = icmp slt i32 [[I_INC]], [[N:%.*]]\n+; CHECK-NOT:    !llvm.loop\n+; CHECK:       end:\n+;\n+entry:\n+  br label %outer\n+\n+outer:\n+  %i = phi i32 [ 0, %entry ], [ %i.inc, %outer.backedge ]\n+  br label %inner\n+\n+inner:\n+  %j = phi i32 [ 0, %outer ], [ %j.inc, %inner ]\n+  %j.inc = add i32 %j, 1\n+  %cmp.inner = icmp slt i32 %j.inc, %K\n+  br i1 %cmp.inner, label %inner, label %outer.backedge, !llvm.loop !1\n+\n+outer.backedge:\n+  %i.inc = add i32 %i, 1\n+  %cmp.outer = icmp slt i32 %i.inc, %N\n+  br i1 %cmp.outer, label %outer, label %end\n+\n+end:\n+  ret void\n+}\n+\n+!1 = distinct !{!1}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/LoopUnroll/peel-loop-inner.ll (1 of 1)\nTesting Time: 0.33s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LoopUnroll/peel-loop-inner.ll\n\n  Unexpected Failures: 1\n"
    },
    "b6a0faaa0c793aede7911be241b1895a9ebea41c___SLPVectorizer.cpp": {
        "start": 181,
        "end": 195,
        "buggy": "static bool allSameBlock(ArrayRef<Value *> VL) {\n  Instruction *I0 = dyn_cast<Instruction>(VL[0]);\n  if (!I0)\n    return false;\n  BasicBlock *BB = I0->getParent();\n  for (int i = 1, e = VL.size(); i < e; i++) {\n    Instruction *I = dyn_cast<Instruction>(VL[i]);\n    if (!I)\n      return false;\n\n    if (BB != I->getParent())\n      return false;\n  }\n  return true;\n}\n",
        "fix": null,
        "src_path": "b6a0faaa0c793aede7911be241b1895a9ebea41c___SLPVectorizer.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/b6a0faaa0c793aede7911be241b1895a9ebea41c",
        "commit_msg": "[SLP] limit vectorization of Constant subclasses (PR33958)\n\nThis is a fix for:\nhttps://bugs.llvm.org/show_bug.cgi?id=33958\n\nIt seems universally true that we would not want to transform this kind of\nsequence on any target, but if that's not correct, then we could view this\nas a target-specific cost model problem. We could also white-list ConstantInt,\nConstantFP, etc. rather than blacklist Global and ConstantExpr.\n\nDifferential Revision: https://reviews.llvm.org/D67362\n\nllvm-svn: 371931",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/SLPVectorizer/X86/consecutive-access.ll",
                "patch": "@@ -549,14 +549,17 @@ for.body:                                         ; preds = %entry, %for.body\n   br i1 %cmp, label %for.body, label %for.cond.cleanup\n }\n \n+; Globals/constant expressions are not normal constants.\n+; They should not be treated as the usual vectorization candidates.\n+\n @g1 = external global i32, align 4\n @g2 = external global i32, align 4\n \n define void @PR33958(i32** nocapture %p) {\n ; CHECK-LABEL: @PR33958(\n-; CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds i32*, i32** [[P:%.*]], i64 1\n-; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32** [[P]] to <2 x i32*>*\n-; CHECK-NEXT:    store <2 x i32*> <i32* @g1, i32* @g2>, <2 x i32*>* [[TMP1]], align 8\n+; CHECK-NEXT:    store i32* @g1, i32** [[P:%.*]], align 8\n+; CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds i32*, i32** [[P]], i64 1\n+; CHECK-NEXT:    store i32* @g2, i32** [[ARRAYIDX1]], align 8\n ; CHECK-NEXT:    ret void\n ;\n   store i32* @g1, i32** %p, align 8\n@@ -567,9 +570,9 @@ define void @PR33958(i32** nocapture %p) {\n \n define void @store_constant_expression(i64* %p) {\n ; CHECK-LABEL: @store_constant_expression(\n-; CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds i64, i64* [[P:%.*]], i64 1\n-; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i64* [[P]] to <2 x i64>*\n-; CHECK-NEXT:    store <2 x i64> <i64 ptrtoint (i32* @g1 to i64), i64 ptrtoint (i32* @g2 to i64)>, <2 x i64>* [[TMP1]], align 8\n+; CHECK-NEXT:    store i64 ptrtoint (i32* @g1 to i64), i64* [[P:%.*]], align 8\n+; CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds i64, i64* [[P]], i64 1\n+; CHECK-NEXT:    store i64 ptrtoint (i32* @g2 to i64), i64* [[ARRAYIDX1]], align 8\n ; CHECK-NEXT:    ret void\n ;\n   store i64 ptrtoint (i32* @g1 to i64), i64* %p, align 8"
            }
        ],
        "error_msg": ""
    },
    "07d16424f28482a852a35bd817189d4dfb1701ef___Attributor.cpp": {
        "start": 961,
        "end": 1017,
        "buggy": "ChangeStatus AAReturnedValuesImpl::manifest(Attributor &A) {\n  ChangeStatus Changed = ChangeStatus::UNCHANGED;\n\n  // Bookkeeping.\n  assert(isValidState());\n  STATS_DECLTRACK(KnownReturnValues, FunctionReturn,\n                  \"Number of function with known return values\");\n\n  // Check if we have an assumed unique return value that we could manifest.\n  Optional<Value *> UniqueRV = getAssumedUniqueReturnValue(A);\n\n  if (!UniqueRV.hasValue() || !UniqueRV.getValue())\n    return Changed;\n\n  // Bookkeeping.\n  STATS_DECLTRACK(UniqueReturnValue, FunctionReturn,\n                  \"Number of function with unique return\");\n\n  // Callback to replace the uses of CB with the constant C.\n  auto ReplaceCallSiteUsersWith = [](CallBase &CB, Constant &C) {\n    if (CB.getNumUses() == 0 || CB.isMustTailCall())\n      return ChangeStatus::UNCHANGED;\n    CB.replaceAllUsesWith(&C);\n    return ChangeStatus::CHANGED;\n  };\n\n  // If the assumed unique return value is an argument, annotate it.\n  if (auto *UniqueRVArg = dyn_cast<Argument>(UniqueRV.getValue())) {\n    // TODO: This should be handled differently!\n    this->AnchorVal = UniqueRVArg;\n    this->KindOrArgNo = UniqueRVArg->getArgNo();\n    Changed = IRAttribute::manifest(A);\n  } else if (auto *RVC = dyn_cast<Constant>(UniqueRV.getValue())) {\n    // We can replace the returned value with the unique returned constant.\n    Value &AnchorValue = getAnchorValue();\n    if (Function *F = dyn_cast<Function>(&AnchorValue)) {\n      for (const Use &U : F->uses())\n        if (CallBase *CB = dyn_cast<CallBase>(U.getUser()))\n          if (CB->isCallee(&U)) {\n            Constant *RVCCast =\n                ConstantExpr::getTruncOrBitCast(RVC, CB->getType());\n            Changed = ReplaceCallSiteUsersWith(*CB, *RVCCast) | Changed;\n          }\n    } else {\n      assert(isa<CallBase>(AnchorValue) &&\n             \"Expcected a function or call base anchor!\");\n      Constant *RVCCast =\n          ConstantExpr::getTruncOrBitCast(RVC, AnchorValue.getType());\n      Changed = ReplaceCallSiteUsersWith(cast<CallBase>(AnchorValue), *RVCCast);\n    }\n    if (Changed == ChangeStatus::CHANGED)\n      STATS_DECLTRACK(UniqueConstantReturnValue, FunctionReturn,\n                      \"Number of function returns replaced by constant return\");\n  }\n\n  return Changed;\n}\n",
        "fix": null,
        "src_path": "07d16424f28482a852a35bd817189d4dfb1701ef___Attributor.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/07d16424f28482a852a35bd817189d4dfb1701ef",
        "commit_msg": "[Attributor][FIX] Do not try to cast if a cast is not required\n\nWhen we replace constant returns at the call site we did issue a cast in\nthe hopes it would be a no-op if the types are equal. Turns out that is\nnot the case and we have to check it ourselves first.\n\nReused an IPConstantProp test for coverage. No functional change to the\ntest wrt. IPConstantProp.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/IPConstantProp/PR43857.ll",
                "patch": "@@ -1,26 +1,32 @@\n ; NOTE: Assertions have been autogenerated by utils/update_test_checks.py\n-; RUN: opt < %s -S -ipconstprop | FileCheck %s\n+; RUN: opt < %s -S -ipconstprop | FileCheck %s --check-prefixes=ALL,IPCP\n+; RUN: opt -S -passes=attributor -attributor-disable=false -attributor-max-iterations-verify -attributor-max-iterations=1 < %s | FileCheck %s --check-prefixes=ALL,ATTRIBUTOR\n \n %struct.wobble = type { i32 }\n %struct.zot = type { %struct.wobble, %struct.wobble, %struct.wobble }\n \n declare dso_local fastcc float @bar(%struct.wobble* noalias, <8 x i32>) unnamed_addr\n \n define %struct.zot @widget(<8 x i32> %arg) local_unnamed_addr {\n-; CHECK-LABEL: define {{[^@]+}}@widget(\n-; CHECK-NEXT:  bb:\n-; CHECK-NEXT:    ret [[STRUCT_ZOT:%.*]] undef\n+; ALL-LABEL: @widget(\n+; ALL-NEXT:  bb:\n+; ALL-NEXT:    ret [[STRUCT_ZOT:%.*]] undef\n ;\n bb:\n   ret %struct.zot undef\n }\n \n define void @baz(<8 x i32> %arg) local_unnamed_addr {\n-; CHECK-LABEL: define {{[^@]+}}@baz(\n-; CHECK-NEXT:  bb:\n-; CHECK-NEXT:    [[TMP:%.*]] = call [[STRUCT_ZOT:%.*]] @widget(<8 x i32> [[ARG:%.*]])\n-; CHECK-NEXT:    [[TMP1:%.*]] = extractvalue [[STRUCT_ZOT]] %tmp, 0, 0\n-; CHECK-NEXT:    ret void\n+; IPCP-LABEL: @baz(\n+; IPCP-NEXT:  bb:\n+; IPCP-NEXT:    [[TMP:%.*]] = call [[STRUCT_ZOT:%.*]] @widget(<8 x i32> [[ARG:%.*]])\n+; IPCP-NEXT:    [[TMP1:%.*]] = extractvalue [[STRUCT_ZOT]] %tmp, 0, 0\n+; IPCP-NEXT:    ret void\n+;\n+; ATTRIBUTOR-LABEL: @baz(\n+; ATTRIBUTOR-NEXT:  bb:\n+; ATTRIBUTOR-NEXT:    [[TMP1:%.*]] = extractvalue [[STRUCT_ZOT:%.*]] undef, 0, 0\n+; ATTRIBUTOR-NEXT:    ret void\n ;\n bb:\n   %tmp = call %struct.zot @widget(<8 x i32> %arg)"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/IPConstantProp/PR43857.ll (1 of 1)\n\nTesting Time: 1.38s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/IPConstantProp/PR43857.ll\n\n  Unexpected Failures: 1\n"
    },
    "0f22e783a038b6983f0fe161eef6cf2add3a4156___InstCombineCompares.cpp": {
        "start": 2556,
        "end": 2620,
        "buggy": "Instruction *InstCombiner::foldICmpAddConstant(ICmpInst &Cmp,\n                                               BinaryOperator *Add,\n                                               const APInt &C) {\n  Value *Y = Add->getOperand(1);\n  const APInt *C2;\n  if (Cmp.isEquality() || !match(Y, m_APInt(C2)))\n    return nullptr;\n\n  // Fold icmp pred (add X, C2), C.\n  Value *X = Add->getOperand(0);\n  Type *Ty = Add->getType();\n  CmpInst::Predicate Pred = Cmp.getPredicate();\n\n  if (!Add->hasOneUse())\n    return nullptr;\n\n  // If the add does not wrap, we can always adjust the compare by subtracting\n  // the constants. Equality comparisons are handled elsewhere. SGE/SLE/UGE/ULE\n  // are canonicalized to SGT/SLT/UGT/ULT.\n  if ((Add->hasNoSignedWrap() &&\n       (Pred == ICmpInst::ICMP_SGT || Pred == ICmpInst::ICMP_SLT)) ||\n      (Add->hasNoUnsignedWrap() &&\n       (Pred == ICmpInst::ICMP_UGT || Pred == ICmpInst::ICMP_ULT))) {\n    bool Overflow;\n    APInt NewC =\n        Cmp.isSigned() ? C.ssub_ov(*C2, Overflow) : C.usub_ov(*C2, Overflow);\n    // If there is overflow, the result must be true or false.\n    // TODO: Can we assert there is no overflow because InstSimplify always\n    // handles those cases?\n    if (!Overflow)\n      // icmp Pred (add nsw X, C2), C --> icmp Pred X, (C - C2)\n      return new ICmpInst(Pred, X, ConstantInt::get(Ty, NewC));\n  }\n\n  auto CR = ConstantRange::makeExactICmpRegion(Pred, C).subtract(*C2);\n  const APInt &Upper = CR.getUpper();\n  const APInt &Lower = CR.getLower();\n  if (Cmp.isSigned()) {\n    if (Lower.isSignMask())\n      return new ICmpInst(ICmpInst::ICMP_SLT, X, ConstantInt::get(Ty, Upper));\n    if (Upper.isSignMask())\n      return new ICmpInst(ICmpInst::ICMP_SGE, X, ConstantInt::get(Ty, Lower));\n  } else {\n    if (Lower.isMinValue())\n      return new ICmpInst(ICmpInst::ICMP_ULT, X, ConstantInt::get(Ty, Upper));\n    if (Upper.isMinValue())\n      return new ICmpInst(ICmpInst::ICMP_UGE, X, ConstantInt::get(Ty, Lower));\n  }\n\n  // X+C <u C2 -> (X & -C2) == C\n  //   iff C & (C2-1) == 0\n  //       C2 is a power of 2\n  if (Pred == ICmpInst::ICMP_ULT && C.isPowerOf2() && (*C2 & (C - 1)) == 0)\n    return new ICmpInst(ICmpInst::ICMP_EQ, Builder.CreateAnd(X, -C),\n                        ConstantExpr::getNeg(cast<Constant>(Y)));\n\n  // X+C >u C2 -> (X & ~C2) != C\n  //   iff C & C2 == 0\n  //       C2+1 is a power of 2\n  if (Pred == ICmpInst::ICMP_UGT && (C + 1).isPowerOf2() && (*C2 & C) == 0)\n    return new ICmpInst(ICmpInst::ICMP_NE, Builder.CreateAnd(X, ~C),\n                        ConstantExpr::getNeg(cast<Constant>(Y)));\n\n  return nullptr;\n}\n",
        "fix": null,
        "src_path": "0f22e783a038b6983f0fe161eef6cf2add3a4156___InstCombineCompares.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/0f22e783a038b6983f0fe161eef6cf2add3a4156",
        "commit_msg": "[InstCombine] Revert rL341831: relax one-use check in foldICmpAddConstant() (PR44100)\n\nrL341831 moved one-use check higher up, restricting a few folds\nthat produced a single instruction from two instructions to the case\nwhere the inner instruction would go away.\n\nOriginal commit message:\n> InstCombine: move hasOneUse check to the top of foldICmpAddConstant\n>\n> There were two combines not covered by the check before now,\n> neither of which actually differed from normal in the benefit analysis.\n>\n> The most recent seems to be because it was just added at the top of the\n> function (naturally). The older is from way back in 2008 (r46687)\n> when we just didn't put those checks in so routinely, and has been\n> diligently maintained since.\n\nFrom the commit message alone, there doesn't seem to be a\ndeeper motivation, deeper problem that was trying to solve,\nother than 'fixing the wrong one-use check'.\n\nAs i have briefly discusses in IRC with Tim, the original motivation\ncan no longer be recovered, too much time has passed.\n\nHowever i believe that the original fold was doing the right thing,\nwe should be performing such a transformation even if the inner `add`\nwill not go away - that will still unchain the comparison from `add`,\nit will no longer need to wait for `add` to compute.\n\nDoing so doesn't seem to break any particular idioms,\nas least as far as i can see.\n\nReferences https://bugs.llvm.org/show_bug.cgi?id=44100",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/icmp-add.ll",
                "patch": "@@ -77,14 +77,14 @@ define i1 @test4(i32 %a) {\n \n define { i32, i1 } @test4multiuse(i32 %a) {\n ; CHECK-LABEL: @test4multiuse(\n-; CHECK-NEXT:    [[B:%.*]] = add i32 [[A:%.*]], -2147483644\n-; CHECK-NEXT:    [[C:%.*]] = icmp slt i32 [[B]], -4\n+; CHECK-NEXT:    [[B:%.*]] = add nsw i32 [[A:%.*]], -2147483644\n+; CHECK-NEXT:    [[C:%.*]] = icmp slt i32 [[A]], 2147483640\n ; CHECK-NEXT:    [[TMP:%.*]] = insertvalue { i32, i1 } undef, i32 [[B]], 0\n ; CHECK-NEXT:    [[RES:%.*]] = insertvalue { i32, i1 } [[TMP]], i1 [[C]], 1\n ; CHECK-NEXT:    ret { i32, i1 } [[RES]]\n ;\n \n-  %b = add i32 %a, -2147483644\n+  %b = add nsw i32 %a, -2147483644\n   %c = icmp slt i32 %b, -4\n \n   %tmp = insertvalue { i32, i1 } undef, i32 %b, 0"
            },
            {
                "fn": "llvm/test/Transforms/LoopUnroll/runtime-loop-multiple-exits.ll",
                "patch": "@@ -578,10 +578,10 @@ define void @test8() {\n ; PROLOG:      %lcmp.mod = icmp eq i64\n ; PROLOG-NEXT: br i1 %lcmp.mod, label %innerH.prol.loopexit, label %innerH.prol.preheader\n ; PROLOG: latch.6:\n-; PROLOG-NEXT: %tmp4.7 = add nuw nsw i64 %tmp3, 8\n ; PROLOG-NEXT: br i1 false, label %outerloop.loopexit.loopexit, label %latch.7\n-; PROLOG: latch.7\n-; PROLOG-NEXT: %tmp6.7 = icmp ult i64 %tmp4.7, 100\n+; PROLOG: latch.7:\n+; PROLOG-NEXT: %tmp4.7 = add nuw nsw i64 %tmp3, 8\n+; PROLOG-NEXT: %tmp6.7 = icmp ult i64 %tmp3, 92\n ; PROLOG-NEXT: br i1 %tmp6.7, label %innerH, label %exit.unr-lcssa\n bb:\n   br label %outerloop"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/if-conversion-nest.ll",
                "patch": "@@ -12,7 +12,7 @@ define i32 @foo(i32* nocapture %A, i32* nocapture %B, i32 %n) {\n ; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1\n ; CHECK-NEXT:    [[TMP1:%.*]] = zext i32 [[TMP0]] to i64\n ; CHECK-NEXT:    [[TMP2:%.*]] = add nuw nsw i64 [[TMP1]], 1\n-; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[TMP2]], 4\n+; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i32 [[TMP0]], 3\n ; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_MEMCHECK:%.*]]\n ; CHECK:       vector.memcheck:\n ; CHECK-NEXT:    [[TMP3:%.*]] = add i32 [[N]], -1\n@@ -22,33 +22,33 @@ define i32 @foo(i32* nocapture %A, i32* nocapture %B, i32 %n) {\n ; CHECK-NEXT:    [[SCEVGEP4:%.*]] = getelementptr i32, i32* [[B:%.*]], i64 [[TMP5]]\n ; CHECK-NEXT:    [[BOUND0:%.*]] = icmp ugt i32* [[SCEVGEP4]], [[A]]\n ; CHECK-NEXT:    [[BOUND1:%.*]] = icmp ugt i32* [[SCEVGEP]], [[B]]\n-; CHECK-NEXT:    [[MEMCHECK_CONFLICT:%.*]] = and i1 [[BOUND0]], [[BOUND1]]\n-; CHECK-NEXT:    br i1 [[MEMCHECK_CONFLICT]], label [[SCALAR_PH]], label [[VECTOR_PH:%.*]]\n+; CHECK-NEXT:    [[FOUND_CONFLICT:%.*]] = and i1 [[BOUND0]], [[BOUND1]]\n+; CHECK-NEXT:    br i1 [[FOUND_CONFLICT]], label [[SCALAR_PH]], label [[VECTOR_PH:%.*]]\n ; CHECK:       vector.ph:\n ; CHECK-NEXT:    [[N_VEC:%.*]] = and i64 [[TMP2]], 8589934588\n ; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]\n ; CHECK:       vector.body:\n ; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]\n-; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, i32* [[A]], i64 [[INDEX]]\n-; CHECK-NEXT:    [[TMP8:%.*]] = bitcast i32* [[TMP7]] to <4 x i32>*\n-; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i32>, <4 x i32>* [[TMP8]], align 4, !alias.scope !0, !noalias !3\n-; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i32, i32* [[B]], i64 [[INDEX]]\n-; CHECK-NEXT:    [[TMP10:%.*]] = bitcast i32* [[TMP9]] to <4 x i32>*\n-; CHECK-NEXT:    [[WIDE_LOAD6:%.*]] = load <4 x i32>, <4 x i32>* [[TMP10]], align 4, !alias.scope !3\n-; CHECK-NEXT:    [[TMP11:%.*]] = icmp sgt <4 x i32> [[WIDE_LOAD]], [[WIDE_LOAD6]]\n-; CHECK-NEXT:    [[TMP12:%.*]] = icmp sgt <4 x i32> [[WIDE_LOAD]], <i32 19, i32 19, i32 19, i32 19>\n-; CHECK-NEXT:    [[TMP13:%.*]] = icmp slt <4 x i32> [[WIDE_LOAD6]], <i32 4, i32 4, i32 4, i32 4>\n-; CHECK-NEXT:    [[TMP14:%.*]] = select <4 x i1> [[TMP13]], <4 x i32> <i32 4, i32 4, i32 4, i32 4>, <4 x i32> <i32 5, i32 5, i32 5, i32 5>\n-; CHECK-NEXT:    [[TMP15:%.*]] = and <4 x i1> [[TMP12]], [[TMP11]]\n-; CHECK-NEXT:    [[TMP16:%.*]] = xor <4 x i1> [[TMP12]], <i1 true, i1 true, i1 true, i1 true>\n-; CHECK-NEXT:    [[TMP17:%.*]] = and <4 x i1> [[TMP11]], [[TMP16]]\n-; CHECK-NEXT:    [[PREDPHI:%.*]] = select <4 x i1> [[TMP15]], <4 x i32> <i32 3, i32 3, i32 3, i32 3>, <4 x i32> <i32 9, i32 9, i32 9, i32 9>\n-; CHECK-NEXT:    [[PREDPHI7:%.*]] = select <4 x i1> [[TMP17]], <4 x i32> [[TMP14]], <4 x i32> [[PREDPHI]]\n-; CHECK-NEXT:    [[TMP18:%.*]] = bitcast i32* [[TMP7]] to <4 x i32>*\n-; CHECK-NEXT:    store <4 x i32> [[PREDPHI7]], <4 x i32>* [[TMP18]], align 4, !alias.scope !0, !noalias !3\n+; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds i32, i32* [[A]], i64 [[INDEX]]\n+; CHECK-NEXT:    [[TMP7:%.*]] = bitcast i32* [[TMP6]] to <4 x i32>*\n+; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i32>, <4 x i32>* [[TMP7]], align 4, !alias.scope !0, !noalias !3\n+; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i32, i32* [[B]], i64 [[INDEX]]\n+; CHECK-NEXT:    [[TMP9:%.*]] = bitcast i32* [[TMP8]] to <4 x i32>*\n+; CHECK-NEXT:    [[WIDE_LOAD6:%.*]] = load <4 x i32>, <4 x i32>* [[TMP9]], align 4, !alias.scope !3\n+; CHECK-NEXT:    [[TMP10:%.*]] = icmp sgt <4 x i32> [[WIDE_LOAD]], [[WIDE_LOAD6]]\n+; CHECK-NEXT:    [[TMP11:%.*]] = icmp sgt <4 x i32> [[WIDE_LOAD]], <i32 19, i32 19, i32 19, i32 19>\n+; CHECK-NEXT:    [[TMP12:%.*]] = icmp slt <4 x i32> [[WIDE_LOAD6]], <i32 4, i32 4, i32 4, i32 4>\n+; CHECK-NEXT:    [[TMP13:%.*]] = select <4 x i1> [[TMP12]], <4 x i32> <i32 4, i32 4, i32 4, i32 4>, <4 x i32> <i32 5, i32 5, i32 5, i32 5>\n+; CHECK-NEXT:    [[TMP14:%.*]] = and <4 x i1> [[TMP11]], [[TMP10]]\n+; CHECK-NEXT:    [[TMP15:%.*]] = xor <4 x i1> [[TMP11]], <i1 true, i1 true, i1 true, i1 true>\n+; CHECK-NEXT:    [[TMP16:%.*]] = and <4 x i1> [[TMP10]], [[TMP15]]\n+; CHECK-NEXT:    [[PREDPHI:%.*]] = select <4 x i1> [[TMP14]], <4 x i32> <i32 3, i32 3, i32 3, i32 3>, <4 x i32> <i32 9, i32 9, i32 9, i32 9>\n+; CHECK-NEXT:    [[PREDPHI7:%.*]] = select <4 x i1> [[TMP16]], <4 x i32> [[TMP13]], <4 x i32> [[PREDPHI]]\n+; CHECK-NEXT:    [[TMP17:%.*]] = bitcast i32* [[TMP6]] to <4 x i32>*\n+; CHECK-NEXT:    store <4 x i32> [[PREDPHI7]], <4 x i32>* [[TMP17]], align 4, !alias.scope !0, !noalias !3\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[INDEX]], 4\n-; CHECK-NEXT:    [[TMP19:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n-; CHECK-NEXT:    br i1 [[TMP19]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop !5\n+; CHECK-NEXT:    [[TMP18:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n+; CHECK-NEXT:    br i1 [[TMP18]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop !5\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[TMP2]], [[N_VEC]]\n ; CHECK-NEXT:    br i1 [[CMP_N]], label [[FOR_END_LOOPEXIT:%.*]], label [[SCALAR_PH]]\n@@ -58,16 +58,16 @@ define i32 @foo(i32* nocapture %A, i32* nocapture %B, i32 %n) {\n ; CHECK:       for.body:\n ; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[IF_END14:%.*]] ], [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ]\n ; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, i32* [[A]], i64 [[INDVARS_IV]]\n-; CHECK-NEXT:    [[TMP20:%.*]] = load i32, i32* [[ARRAYIDX]], align 4\n+; CHECK-NEXT:    [[TMP19:%.*]] = load i32, i32* [[ARRAYIDX]], align 4\n ; CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, i32* [[B]], i64 [[INDVARS_IV]]\n-; CHECK-NEXT:    [[TMP21:%.*]] = load i32, i32* [[ARRAYIDX2]], align 4\n-; CHECK-NEXT:    [[CMP3:%.*]] = icmp sgt i32 [[TMP20]], [[TMP21]]\n+; CHECK-NEXT:    [[TMP20:%.*]] = load i32, i32* [[ARRAYIDX2]], align 4\n+; CHECK-NEXT:    [[CMP3:%.*]] = icmp sgt i32 [[TMP19]], [[TMP20]]\n ; CHECK-NEXT:    br i1 [[CMP3]], label [[IF_THEN:%.*]], label [[IF_END14]]\n ; CHECK:       if.then:\n-; CHECK-NEXT:    [[CMP6:%.*]] = icmp sgt i32 [[TMP20]], 19\n+; CHECK-NEXT:    [[CMP6:%.*]] = icmp sgt i32 [[TMP19]], 19\n ; CHECK-NEXT:    br i1 [[CMP6]], label [[IF_END14]], label [[IF_ELSE:%.*]]\n ; CHECK:       if.else:\n-; CHECK-NEXT:    [[CMP10:%.*]] = icmp slt i32 [[TMP21]], 4\n+; CHECK-NEXT:    [[CMP10:%.*]] = icmp slt i32 [[TMP20]], 4\n ; CHECK-NEXT:    [[DOT:%.*]] = select i1 [[CMP10]], i32 4, i32 5\n ; CHECK-NEXT:    br label [[IF_END14]]\n ; CHECK:       if.end14:"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/runtime-check.ll",
                "patch": "@@ -19,7 +19,7 @@ define i32 @foo(float* nocapture %a, float* nocapture %b, i32 %n) nounwind uwtab\n ; CHECK-NEXT:    [[TMP0:%.*]] = add i32 [[N]], -1, !dbg !9\n ; CHECK-NEXT:    [[TMP1:%.*]] = zext i32 [[TMP0]] to i64, !dbg !9\n ; CHECK-NEXT:    [[TMP2:%.*]] = add nuw nsw i64 [[TMP1]], 1, !dbg !9\n-; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i64 [[TMP2]], 4, !dbg !9\n+; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i32 [[TMP0]], 3, !dbg !9\n ; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[SCALAR_PH:%.*]], label [[VECTOR_MEMCHECK:%.*]], !dbg !9\n ; CHECK:       vector.memcheck:\n ; CHECK-NEXT:    [[TMP3:%.*]] = add i32 [[N]], -1, !dbg !9\n@@ -29,34 +29,34 @@ define i32 @foo(float* nocapture %a, float* nocapture %b, i32 %n) nounwind uwtab\n ; CHECK-NEXT:    [[SCEVGEP4:%.*]] = getelementptr float, float* [[B:%.*]], i64 [[TMP5]], !dbg !9\n ; CHECK-NEXT:    [[BOUND0:%.*]] = icmp ugt float* [[SCEVGEP4]], [[A]], !dbg !9\n ; CHECK-NEXT:    [[BOUND1:%.*]] = icmp ugt float* [[SCEVGEP]], [[B]], !dbg !9\n-; CHECK-NEXT:    [[MEMCHECK_CONFLICT:%.*]] = and i1 [[BOUND0]], [[BOUND1]], !dbg !9\n-; CHECK-NEXT:    br i1 [[MEMCHECK_CONFLICT]], label [[SCALAR_PH]], label [[VECTOR_PH:%.*]], !dbg !9\n+; CHECK-NEXT:    [[FOUND_CONFLICT:%.*]] = and i1 [[BOUND0]], [[BOUND1]], !dbg !9\n+; CHECK-NEXT:    br i1 [[FOUND_CONFLICT]], label [[SCALAR_PH]], label [[VECTOR_PH:%.*]], !dbg !9\n ; CHECK:       vector.ph:\n ; CHECK-NEXT:    [[N_VEC:%.*]] = and i64 [[TMP2]], 8589934588, !dbg !9\n ; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]], !dbg !9\n ; CHECK:       vector.body:\n ; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ], !dbg !9\n-; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds float, float* [[B]], i64 [[INDEX]], !dbg !9\n-; CHECK-NEXT:    [[TMP8:%.*]] = bitcast float* [[TMP7]] to <4 x float>*, !dbg !9\n-; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x float>, <4 x float>* [[TMP8]], align 4, !dbg !9, !alias.scope !10\n-; CHECK-NEXT:    [[TMP9:%.*]] = fmul <4 x float> [[WIDE_LOAD]], <float 3.000000e+00, float 3.000000e+00, float 3.000000e+00, float 3.000000e+00>, !dbg !9\n-; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds float, float* [[A]], i64 [[INDEX]], !dbg !9\n-; CHECK-NEXT:    [[TMP11:%.*]] = bitcast float* [[TMP10]] to <4 x float>*, !dbg !9\n-; CHECK-NEXT:    store <4 x float> [[TMP9]], <4 x float>* [[TMP11]], align 4, !dbg !9, !alias.scope !13, !noalias !10\n+; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds float, float* [[B]], i64 [[INDEX]], !dbg !9\n+; CHECK-NEXT:    [[TMP7:%.*]] = bitcast float* [[TMP6]] to <4 x float>*, !dbg !9\n+; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x float>, <4 x float>* [[TMP7]], align 4, !dbg !9, !alias.scope !10\n+; CHECK-NEXT:    [[TMP8:%.*]] = fmul <4 x float> [[WIDE_LOAD]], <float 3.000000e+00, float 3.000000e+00, float 3.000000e+00, float 3.000000e+00>, !dbg !9\n+; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds float, float* [[A]], i64 [[INDEX]], !dbg !9\n+; CHECK-NEXT:    [[TMP10:%.*]] = bitcast float* [[TMP9]] to <4 x float>*, !dbg !9\n+; CHECK-NEXT:    store <4 x float> [[TMP8]], <4 x float>* [[TMP10]], align 4, !dbg !9, !alias.scope !13, !noalias !10\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add i64 [[INDEX]], 4, !dbg !9\n-; CHECK-NEXT:    [[TMP12:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]], !dbg !9\n-; CHECK-NEXT:    br i1 [[TMP12]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !dbg !9, !llvm.loop !15\n+; CHECK-NEXT:    [[TMP11:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]], !dbg !9\n+; CHECK-NEXT:    br i1 [[TMP11]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !dbg !9, !llvm.loop !15\n ; CHECK:       middle.block:\n-; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[TMP2]], [[N_VEC]]\n+; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[TMP2]], [[N_VEC]], !dbg !9\n ; CHECK-NEXT:    br i1 [[CMP_N]], label [[FOR_END_LOOPEXIT:%.*]], label [[SCALAR_PH]], !dbg !9\n ; CHECK:       scalar.ph:\n-; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ], [ 0, [[VECTOR_MEMCHECK]] ]\n+; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i64 [ [[N_VEC]], [[MIDDLE_BLOCK]] ], [ 0, [[FOR_BODY_PREHEADER]] ], [ 0, [[VECTOR_MEMCHECK]] ], !dbg !9\n ; CHECK-NEXT:    br label [[FOR_BODY:%.*]], !dbg !9\n ; CHECK:       for.body:\n ; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ], [ [[BC_RESUME_VAL]], [[SCALAR_PH]] ], !dbg !9\n ; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, float* [[B]], i64 [[INDVARS_IV]], !dbg !9\n-; CHECK-NEXT:    [[TMP13:%.*]] = load float, float* [[ARRAYIDX]], align 4, !dbg !9\n-; CHECK-NEXT:    [[MUL:%.*]] = fmul float [[TMP13]], 3.000000e+00, !dbg !9\n+; CHECK-NEXT:    [[TMP12:%.*]] = load float, float* [[ARRAYIDX]], align 4, !dbg !9\n+; CHECK-NEXT:    [[MUL:%.*]] = fmul float [[TMP12]], 3.000000e+00, !dbg !9\n ; CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, float* [[A]], i64 [[INDVARS_IV]], !dbg !9\n ; CHECK-NEXT:    store float [[MUL]], float* [[ARRAYIDX2]], align 4, !dbg !9\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add i64 [[INDVARS_IV]], 1, !dbg !9"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/icmp-add.ll (1 of 1)\n\nTesting Time: 0.22s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/icmp-add.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Transforms/LoopUnroll/runtime-loop-multiple-exits.ll (1 of 1)\n\nTesting Time: 0.82s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LoopUnroll/runtime-loop-multiple-exits.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Transforms/LoopVectorize/if-conversion-nest.ll (1 of 1)\n\nTesting Time: 0.12s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LoopVectorize/if-conversion-nest.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Transforms/LoopVectorize/runtime-check.ll (1 of 1)\n\nTesting Time: 0.16s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LoopVectorize/runtime-check.ll\n\n  Unexpected Failures: 1\n"
    },
    "5b3b21f0258899d03f6299fba6b4c78d7e730353___CodeViewDebug.cpp": {
        "start": 410,
        "end": 434,
        "buggy": "static FunctionOptions\ngetFunctionOptions(const DISubroutineType *Ty,\n                   const DICompositeType *ClassTy = nullptr,\n                   StringRef SPName = StringRef(\"\")) {\n  FunctionOptions FO = FunctionOptions::None;\n  const DIType *ReturnTy = nullptr;\n  if (auto TypeArray = Ty->getTypeArray()) {\n    if (TypeArray.size())\n      ReturnTy = TypeArray[0];\n  }\n\n  if (auto *ReturnDCTy = dyn_cast_or_null<DICompositeType>(ReturnTy)) {\n    if (isNonTrivial(ReturnDCTy))\n      FO |= FunctionOptions::CxxReturnUdt;\n  }\n\n  // DISubroutineType is unnamed. Use DISubprogram's i.e. SPName in comparison.\n  if (ClassTy && isNonTrivial(ClassTy) && SPName == ClassTy->getName()) {\n    FO |= FunctionOptions::Constructor;\n\n  // TODO: put the FunctionOptions::ConstructorWithVirtualBases flag.\n\n  }\n  return FO;\n}\n",
        "fix": null,
        "src_path": "5b3b21f0258899d03f6299fba6b4c78d7e730353___CodeViewDebug.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/5b3b21f0258899d03f6299fba6b4c78d7e730353",
        "commit_msg": "[DebugInfo] Fix for adding \"returns cxx udt\" option to functions in CodeView.\n\nSummary:\nThis change checks for the return type in the frontend and adds a flag\nto the DISubroutineType to indicate that the option should be added in\nCodeViewDebug.\n\nPreviously function types sometimes appeared twice in the PDB: once with\n\"returns cxx udt\" and once without.\nSee https://bugs.llvm.org/show_bug.cgi?id=44785.\n\nReviewers: rnk, asmith\n\nSubscribers: hiraditya, cfe-commits, llvm-commits\n\nTags: #clang, #llvm\n\nDifferential Revision: https://reviews.llvm.org/D75215",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/COFF/function-options.ll",
                "patch": "@@ -4,7 +4,6 @@\n ; Command to generate function-options.ll\n ; $ clang++ function-options.cpp -S -emit-llvm -g -gcodeview -o function-options.ll\n ;\n-;\n ; #define DEFINE_FUNCTION(T) \\\n ;   T Func_##T(T &arg) { return arg; }\n ;\n@@ -32,7 +31,11 @@\n ; class DClass : public BClass {}; // Note: MSVC yields one compiler-generated ctor for DClass while clang doesn't.\n ; DEFINE_FUNCTION(DClass); // Expect: FO = CxxReturnUdt\n ;\n-; class FClass { static int x; };\n+; class FClass {\n+;   static int x;\n+;   AClass Member_AClass(AClass &);\n+;   BClass Member_BClass(BClass &);\n+; };\n ; DEFINE_FUNCTION(FClass); // Expect FO = None\n ; \n ; struct AStruct {};\n@@ -54,7 +57,7 @@\n ; CHECK: CodeViewTypes [\n ; CHECK:   Section: .debug$T ({{.*}})\n ; CHECK:   Magic: 0x4\n-; CHECK:   Procedure ([[SP1:.*]]) {\n+; CHECK:   Procedure ([[SP_A:.*]]) {\n ; CHECK:     TypeLeafKind: LF_PROCEDURE (0x1008)\n ; CHECK:     ReturnType: AClass ({{.*}})\n ; CHECK:     CallingConvention: NearC (0x0)\n@@ -66,10 +69,10 @@\n ; CHECK:   FuncId ({{.*}}) {\n ; CHECK:     TypeLeafKind: LF_FUNC_ID (0x1601)\n ; CHECK:     ParentScope: 0x0\n-; CHECK:     FunctionType: AClass (AClass&) ([[SP1]])\n+; CHECK:     FunctionType: AClass (AClass&) ([[SP_A]])\n ; CHECK:     Name: Func_AClass\n ; CHECK:   }\n-; CHECK:   Procedure ([[SP2:.*]]) {\n+; CHECK:   Procedure ([[SP_B:.*]]) {\n ; CHECK:     TypeLeafKind: LF_PROCEDURE (0x1008)\n ; CHECK:     ReturnType: BClass ({{.*}})\n ; CHECK:     CallingConvention: NearC (0x0)\n@@ -79,11 +82,11 @@\n ; CHECK:     NumParameters: 1\n ; CHECK:     ArgListType: (BClass&) ({{.*}})\n ; CHECK:   }\n-; CHECK:   MemberFunction ([[MF1:.*]]) {\n+; CHECK:   MemberFunction ([[CTOR_B:.*]]) {\n ; CHECK:     TypeLeafKind: LF_MFUNCTION (0x1009)\n ; CHECK:     ReturnType: void (0x3)\n ; CHECK:     ClassType: BClass ({{.*}})\n-; CHECK:     ThisType: BClass* const ({{.*}})\n+; CHECK:     ThisType: BClass* {{.*}}\n ; CHECK:     CallingConvention: NearC (0x0)\n ; CHECK:     FunctionOptions [ (0x2)\n ; CHECK:       Constructor (0x2)\n@@ -97,17 +100,17 @@\n ; CHECK:     OneMethod {\n ; CHECK:       TypeLeafKind: LF_ONEMETHOD (0x1511)\n ; CHECK:       AccessSpecifier: Private (0x1)\n-; CHECK:       Type: void BClass::() ([[MF1]])\n+; CHECK:       Type: void BClass::() ([[CTOR_B]])\n ; CHECK:       Name: BClass\n ; CHECK:     }\n ; CHECK:   }\n ; CHECK:   FuncId ({{.*}}) {\n ; CHECK:     TypeLeafKind: LF_FUNC_ID (0x1601)\n ; CHECK:     ParentScope: 0x0\n-; CHECK:     FunctionType: BClass (BClass&) ([[SP2]])\n+; CHECK:     FunctionType: BClass (BClass&) ([[SP_B]])\n ; CHECK:     Name: Func_BClass\n ; CHECK:   }\n-; CHECK:   Procedure ([[SP3:.*]]) {\n+; CHECK:   Procedure ([[SP_C1:.*]]) {\n ; CHECK:     TypeLeafKind: LF_PROCEDURE (0x1008)\n ; CHECK:     ReturnType: C1Class ({{.*}})\n ; CHECK:     CallingConvention: NearC (0x0)\n@@ -116,11 +119,11 @@\n ; CHECK:     NumParameters: 1\n ; CHECK:     ArgListType: (C1Class&) ({{.*}})\n ; CHECK:   }\n-; CHECK:   MemberFunction ([[MF2:.*]]) {\n+; CHECK:   MemberFunction ([[CTOR_C1:.*]]) {\n ; CHECK:     TypeLeafKind: LF_MFUNCTION (0x1009)\n ; CHECK:     ReturnType: void (0x3)\n ; CHECK:     ClassType: C1Class ({{.*}})\n-; CHECK:     ThisType: C1Class* const ({{.*}})\n+; CHECK:     ThisType: C1Class* {{.*}}\n ; CHECK:     CallingConvention: NearC (0x0)\n ; CHECK:     FunctionOptions [ (0x0)\n ; CHECK:     ]\n@@ -133,17 +136,17 @@\n ; CHECK:     OneMethod {\n ; CHECK:       TypeLeafKind: LF_ONEMETHOD (0x1511)\n ; CHECK:       AccessSpecifier: Public (0x3)\n-; CHECK:       Type: void C1Class::() ([[MF2]])\n+; CHECK:       Type: void C1Class::() ([[CTOR_C1]])\n ; CHECK:       Name: C1Class\n ; CHECK:     }\n ; CHECK:   }\n ; CHECK:   FuncId ({{.*}}) {\n ; CHECK:     TypeLeafKind: LF_FUNC_ID (0x1601)\n ; CHECK:     ParentScope: 0x0\n-; CHECK:     FunctionType: C1Class (C1Class&) ([[SP3]])\n+; CHECK:     FunctionType: C1Class (C1Class&) ([[SP_C1]])\n ; CHECK:     Name: Func_C1Class\n ; CHECK:   }\n-; CHECK:   Procedure ([[SP4:.*]]) {\n+; CHECK:   Procedure ([[SP_C2:.*]]) {\n ; CHECK:     TypeLeafKind: LF_PROCEDURE (0x1008)\n ; CHECK:     ReturnType: C2Class ({{.*}})\n ; CHECK:     CallingConvention: NearC (0x0)\n@@ -153,11 +156,11 @@\n ; CHECK:     NumParameters: 1\n ; CHECK:     ArgListType: (C2Class&) ({{.*}})\n ; CHECK:   }\n-; CHECK:   MemberFunction ([[MF3:.*]]) {\n+; CHECK:   MemberFunction ([[CTOR_C2:.*]]) {\n ; CHECK:     TypeLeafKind: LF_MFUNCTION (0x1009)\n ; CHECK:     ReturnType: void (0x3)\n ; CHECK:     ClassType: C2Class ({{.*}})\n-; CHECK:     ThisType: C2Class* const ({{.*}})\n+; CHECK:     ThisType: C2Class* {{.*}}\n ; CHECK:     CallingConvention: NearC (0x0)\n ; CHECK:     FunctionOptions [ (0x0)\n ; CHECK:     ]\n@@ -170,17 +173,17 @@\n ; CHECK:     OneMethod {\n ; CHECK:       TypeLeafKind: LF_ONEMETHOD (0x1511)\n ; CHECK:       AccessSpecifier: Public (0x3)\n-; CHECK:       Type: void C2Class::() ([[MF3]])\n+; CHECK:       Type: void C2Class::() ([[CTOR_C2]])\n ; CHECK:       Name: ~C2Class\n ; CHECK:     }\n ; CHECK:   }\n ; CHECK:   FuncId ({{.*}}) {\n ; CHECK:     TypeLeafKind: LF_FUNC_ID (0x1601)\n ; CHECK:     ParentScope: 0x0\n-; CHECK:     FunctionType: C2Class (C2Class&) ([[SP4]])\n+; CHECK:     FunctionType: C2Class (C2Class&) ([[SP_C2]])\n ; CHECK:     Name: Func_C2Class\n ; CHECK:   }\n-; CHECK:   Procedure ([[SP5:.*]]) {\n+; CHECK:   Procedure ([[SP_D:.*]]) {\n ; CHECK:     TypeLeafKind: LF_PROCEDURE (0x1008)\n ; CHECK:     ReturnType: DClass ({{.*}})\n ; CHECK:     CallingConvention: NearC (0x0)\n@@ -202,10 +205,10 @@\n ; CHECK:   FuncId ({{.*}}) {\n ; CHECK:     TypeLeafKind: LF_FUNC_ID (0x1601)\n ; CHECK:     ParentScope: 0x0\n-; CHECK:     FunctionType: DClass (DClass&) ([[SP5]])\n+; CHECK:     FunctionType: DClass (DClass&) ([[SP_D]])\n ; CHECK:     Name: Func_DClass\n ; CHECK:   }\n-; CHECK:   Procedure ([[SP6:.*]]) {\n+; CHECK:   Procedure ([[SP_F:.*]]) {\n ; CHECK:     TypeLeafKind: LF_PROCEDURE (0x1008)\n ; CHECK:     ReturnType: FClass ({{.*}})\n ; CHECK:     CallingConvention: NearC (0x0)\n@@ -214,6 +217,32 @@\n ; CHECK:     NumParameters: 1\n ; CHECK:     ArgListType: (FClass&) ({{.*}})\n ; CHECK:   }\n+; CHECK:   MemberFunction ([[MF_A:.*]]) {\n+; CHECK:     TypeLeafKind: LF_MFUNCTION (0x1009)\n+; CHECK:     ReturnType: AClass ({{.*}})\n+; CHECK:     ClassType: FClass ({{.*}})\n+; CHECK:     ThisType: FClass* {{.*}}\n+; CHECK:     CallingConvention: NearC (0x0)\n+; CHECK:     FunctionOptions [ (0x1)\n+; CHECK:       CxxReturnUdt (0x1)\n+; CHECK:     ]\n+; CHECK:     NumParameters: 1\n+; CHECK:     ArgListType: (AClass&) ({{.*}})\n+; CHECK:     ThisAdjustment: 0\n+; CHECK:   }\n+; CHECK:   MemberFunction ([[MF_B:.*]]) {\n+; CHECK:     TypeLeafKind: LF_MFUNCTION (0x1009)\n+; CHECK:     ReturnType: BClass ({{.*}})\n+; CHECK:     ClassType: FClass ({{.*}})\n+; CHECK:     ThisType: FClass* {{.*}}\n+; CHECK:     CallingConvention: NearC (0x0)\n+; CHECK:     FunctionOptions [ (0x1)\n+; CHECK:       CxxReturnUdt (0x1)\n+; CHECK:     ]\n+; CHECK:     NumParameters: 1\n+; CHECK:     ArgListType: (BClass&) ({{.*}})\n+; CHECK:     ThisAdjustment: 0\n+; CHECK:   }\n ; CHECK:   FieldList ({{.*}}) {\n ; CHECK:     TypeLeafKind: LF_FIELDLIST (0x1203)\n ; CHECK:     StaticDataMember {\n@@ -222,14 +251,26 @@\n ; CHECK:       Type: int (0x74)\n ; CHECK:       Name: x\n ; CHECK:     }\n+; CHECK:     OneMethod {\n+; CHECK:       TypeLeafKind: LF_ONEMETHOD (0x1511)\n+; CHECK:       AccessSpecifier: Private (0x1)\n+; CHECK:       Type: AClass FClass::(AClass&) ([[MF_A]])\n+; CHECK:       Name: Member_AClass\n+; CHECK:     }\n+; CHECK:     OneMethod {\n+; CHECK:       TypeLeafKind: LF_ONEMETHOD (0x1511)\n+; CHECK:       AccessSpecifier: Private (0x1)\n+; CHECK:       Type: BClass FClass::(BClass&) ([[MF_B]])\n+; CHECK:       Name: Member_BClass\n+; CHECK:     }\n ; CHECK:   }\n ; CHECK:   FuncId ({{.*}}) {\n ; CHECK:     TypeLeafKind: LF_FUNC_ID (0x1601)\n ; CHECK:     ParentScope: 0x0\n-; CHECK:     FunctionType: FClass (FClass&) ([[SP6]])\n+; CHECK:     FunctionType: FClass (FClass&) ([[SP_F]])\n ; CHECK:     Name: Func_FClass\n ; CHECK:   }\n-; CHECK:   Procedure ([[SP7:.*]]) {\n+; CHECK:   Procedure ([[SP_AS:.*]]) {\n ; CHECK:     TypeLeafKind: LF_PROCEDURE (0x1008)\n ; CHECK:     ReturnType: AStruct ({{.*}})\n ; CHECK:     CallingConvention: NearC (0x0)\n@@ -241,10 +282,10 @@\n ; CHECK:   FuncId ({{.*}}) {\n ; CHECK:     TypeLeafKind: LF_FUNC_ID (0x1601)\n ; CHECK:     ParentScope: 0x0\n-; CHECK:     FunctionType: AStruct (AStruct&) ([[SP7]])\n+; CHECK:     FunctionType: AStruct (AStruct&) ([[SP_AS]])\n ; CHECK:     Name: Func_AStruct\n ; CHECK:   }\n-; CHECK:   Procedure ([[SP8:.*]]) {\n+; CHECK:   Procedure ([[SP_BS:.*]]) {\n ; CHECK:     TypeLeafKind: LF_PROCEDURE (0x1008)\n ; CHECK:     ReturnType: BStruct ({{.*}})\n ; CHECK:     CallingConvention: NearC (0x0)\n@@ -254,11 +295,11 @@\n ; CHECK:     NumParameters: 1\n ; CHECK:     ArgListType: (BStruct&) ({{.*}})\n ; CHECK:   }\n-; CHECK:   MemberFunction ([[MF4:.*]]) {\n+; CHECK:   MemberFunction ([[CTOR_BS:.*]]) {\n ; CHECK:     TypeLeafKind: LF_MFUNCTION (0x1009)\n ; CHECK:     ReturnType: void (0x3)\n ; CHECK:     ClassType: BStruct ({{.*}})\n-; CHECK:     ThisType: BStruct* const ({{.*}})\n+; CHECK:     ThisType: BStruct* {{.*}}\n ; CHECK:     CallingConvention: NearC (0x0)\n ; CHECK:     FunctionOptions [ (0x2)\n ; CHECK:       Constructor (0x2)\n@@ -272,17 +313,17 @@\n ; CHECK:     OneMethod {\n ; CHECK:       TypeLeafKind: LF_ONEMETHOD (0x1511)\n ; CHECK:       AccessSpecifier: Public (0x3)\n-; CHECK:       Type: void BStruct::() ([[MF4]])\n+; CHECK:       Type: void BStruct::() ([[CTOR_BS]])\n ; CHECK:       Name: BStruct\n ; CHECK:     }\n ; CHECK:   }\n ; CHECK:   FuncId ({{.*}}) {\n ; CHECK:     TypeLeafKind: LF_FUNC_ID (0x1601)\n ; CHECK:     ParentScope: 0x0\n-; CHECK:     FunctionType: BStruct (BStruct&) ([[SP8]])\n+; CHECK:     FunctionType: BStruct (BStruct&) ([[SP_BS]])\n ; CHECK:     Name: Func_BStruct\n ; CHECK:   }\n-; CHECK:   Procedure ([[SP9:.*]]) {\n+; CHECK:   Procedure ([[SP_AU:.*]]) {\n ; CHECK:     TypeLeafKind: LF_PROCEDURE (0x1008)\n ; CHECK:     ReturnType: AUnion ({{.*}})\n ; CHECK:     CallingConvention: NearC (0x0)\n@@ -294,10 +335,10 @@\n ; CHECK:   FuncId ({{.*}}) {\n ; CHECK:     TypeLeafKind: LF_FUNC_ID (0x1601)\n ; CHECK:     ParentScope: 0x0\n-; CHECK:     FunctionType: AUnion (AUnion&) ([[SP9]])\n+; CHECK:     FunctionType: AUnion (AUnion&) ([[SP_AU]])\n ; CHECK:     Name: Func_AUnion\n ; CHECK:   }\n-; CHECK:   Procedure ([[SP10:.*]]) {\n+; CHECK:   Procedure ([[SP_BU:.*]]) {\n ; CHECK:     TypeLeafKind: LF_PROCEDURE (0x1008)\n ; CHECK:     ReturnType: BUnion ({{.*}})\n ; CHECK:     CallingConvention: NearC (0x0)\n@@ -306,11 +347,11 @@\n ; CHECK:     NumParameters: 1\n ; CHECK:     ArgListType: (BUnion&) ({{.*}})\n ; CHECK:   }\n-; CHECK:   MemberFunction ([[MF5:.*]]) {\n+; CHECK:   MemberFunction ([[CTOR_BU:.*]]) {\n ; CHECK:     TypeLeafKind: LF_MFUNCTION (0x1009)\n ; CHECK:     ReturnType: void (0x3)\n ; CHECK:     ClassType: BUnion ({{.*}})\n-; CHECK:     ThisType: BUnion* const ({{.*}})\n+; CHECK:     ThisType: BUnion* {{.*}}\n ; CHECK:     CallingConvention: NearC (0x0)\n ; CHECK:     FunctionOptions [ (0x0)\n ; CHECK:     ]\n@@ -323,23 +364,22 @@\n ; CHECK:     OneMethod {\n ; CHECK:       TypeLeafKind: LF_ONEMETHOD (0x1511)\n ; CHECK:       AccessSpecifier: Public (0x3)\n-; CHECK:       Type: void BUnion::() ([[MF5]])\n+; CHECK:       Type: void BUnion::() ([[CTOR_BU]])\n ; CHECK:       Name: BUnion\n ; CHECK:     }\n ; CHECK:   }\n ; CHECK:   FuncId ({{.*}}) {\n ; CHECK:     TypeLeafKind: LF_FUNC_ID (0x1601)\n ; CHECK:     ParentScope: 0x0\n-; CHECK:     FunctionType: BUnion (BUnion&) ([[SP10]])\n+; CHECK:     FunctionType: BUnion (BUnion&) ([[SP_BU]])\n ; CHECK:     Name: Func_BUnion\n ; CHECK:   }\n ; CHECK: ]\n \n-\n-; ModuleID = 'function-options.cpp'\n-source_filename = \"function-options.cpp\"\n-target datalayout = \"e-m:w-i64:64-f80:128-n8:16:32:64-S128\"\n-target triple = \"x86_64-pc-windows-msvc19.15.26729\"\n+; ModuleID = 't.cpp'\n+source_filename = \"t.cpp\"\n+target datalayout = \"e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n+target triple = \"x86_64-pc-windows-msvc19.23.28106\"\n \n %class.AClass = type { i8 }\n %class.BClass = type { i8 }\n@@ -358,228 +398,265 @@ entry:\n   %retval = alloca %class.AClass, align 1\n   %arg.addr = alloca %class.AClass*, align 8\n   store %class.AClass* %arg, %class.AClass** %arg.addr, align 8\n-  call void @llvm.dbg.declare(metadata %class.AClass** %arg.addr, metadata !14, metadata !DIExpression()), !dbg !15\n-  %0 = load %class.AClass*, %class.AClass** %arg.addr, align 8, !dbg !15\n-  %coerce.dive = getelementptr inbounds %class.AClass, %class.AClass* %retval, i32 0, i32 0, !dbg !15\n-  %1 = load i8, i8* %coerce.dive, align 1, !dbg !15\n-  ret i8 %1, !dbg !15\n+  call void @llvm.dbg.declare(metadata %class.AClass** %arg.addr, metadata !13, metadata !DIExpression()), !dbg !14\n+  %0 = load %class.AClass*, %class.AClass** %arg.addr, align 8, !dbg !14\n+  %coerce.dive = getelementptr inbounds %class.AClass, %class.AClass* %retval, i32 0, i32 0, !dbg !14\n+  %1 = load i8, i8* %coerce.dive, align 1, !dbg !14\n+  ret i8 %1, !dbg !14\n }\n \n-; Function Attrs: nounwind readnone speculatable\n+; Function Attrs: nounwind readnone speculatable willreturn\n declare void @llvm.dbg.declare(metadata, metadata, metadata) #1\n \n ; Function Attrs: noinline nounwind optnone uwtable\n-define dso_local void @\"?Func_BClass@@YA?AVBClass@@AEAV1@@Z\"(%class.BClass* noalias sret %agg.result, %class.BClass* dereferenceable(1) %arg) #0 !dbg !16 {\n+define dso_local void @\"?Func_BClass@@YA?AVBClass@@AEAV1@@Z\"(%class.BClass* noalias sret %agg.result, %class.BClass* dereferenceable(1) %arg) #0 !dbg !15 {\n entry:\n+  %result.ptr = alloca i8*, align 8\n   %arg.addr = alloca %class.BClass*, align 8\n+  %0 = bitcast %class.BClass* %agg.result to i8*\n+  store i8* %0, i8** %result.ptr, align 8\n   store %class.BClass* %arg, %class.BClass** %arg.addr, align 8\n-  call void @llvm.dbg.declare(metadata %class.BClass** %arg.addr, metadata !26, metadata !DIExpression()), !dbg !27\n-  %0 = load %class.BClass*, %class.BClass** %arg.addr, align 8, !dbg !27\n-  ret void, !dbg !27\n+  call void @llvm.dbg.declare(metadata %class.BClass** %arg.addr, metadata !25, metadata !DIExpression()), !dbg !26\n+  %1 = load %class.BClass*, %class.BClass** %arg.addr, align 8, !dbg !26\n+  ret void, !dbg !26\n }\n \n ; Function Attrs: noinline nounwind optnone uwtable\n-define dso_local void @\"?Func_C1Class@@YA?AVC1Class@@AEAV1@@Z\"(%class.C1Class* noalias sret %agg.result, %class.C1Class* dereferenceable(1) %arg) #0 !dbg !28 {\n+define dso_local void @\"?Func_C1Class@@YA?AVC1Class@@AEAV1@@Z\"(%class.C1Class* noalias sret %agg.result, %class.C1Class* dereferenceable(1) %arg) #0 !dbg !27 {\n entry:\n+  %result.ptr = alloca i8*, align 8\n   %arg.addr = alloca %class.C1Class*, align 8\n+  %0 = bitcast %class.C1Class* %agg.result to i8*\n+  store i8* %0, i8** %result.ptr, align 8\n   store %class.C1Class* %arg, %class.C1Class** %arg.addr, align 8\n-  call void @llvm.dbg.declare(metadata %class.C1Class** %arg.addr, metadata !38, metadata !DIExpression()), !dbg !39\n-  %0 = load %class.C1Class*, %class.C1Class** %arg.addr, align 8, !dbg !39\n-  ret void, !dbg !39\n+  call void @llvm.dbg.declare(metadata %class.C1Class** %arg.addr, metadata !37, metadata !DIExpression()), !dbg !38\n+  %1 = load %class.C1Class*, %class.C1Class** %arg.addr, align 8, !dbg !38\n+  ret void, !dbg !38\n }\n \n ; Function Attrs: noinline nounwind optnone uwtable\n-define dso_local void @\"?Func_C2Class@@YA?AVC2Class@@AEAV1@@Z\"(%class.C2Class* noalias sret %agg.result, %class.C2Class* dereferenceable(1) %arg) #0 !dbg !40 {\n+define dso_local void @\"?Func_C2Class@@YA?AVC2Class@@AEAV1@@Z\"(%class.C2Class* noalias sret %agg.result, %class.C2Class* dereferenceable(1) %arg) #0 !dbg !39 {\n entry:\n+  %result.ptr = alloca i8*, align 8\n   %arg.addr = alloca %class.C2Class*, align 8\n+  %0 = bitcast %class.C2Class* %agg.result to i8*\n+  store i8* %0, i8** %result.ptr, align 8\n   store %class.C2Class* %arg, %class.C2Class** %arg.addr, align 8\n-  call void @llvm.dbg.declare(metadata %class.C2Class** %arg.addr, metadata !50, metadata !DIExpression()), !dbg !51\n-  %0 = load %class.C2Class*, %class.C2Class** %arg.addr, align 8, !dbg !51\n-  ret void, !dbg !51\n+  call void @llvm.dbg.declare(metadata %class.C2Class** %arg.addr, metadata !49, metadata !DIExpression()), !dbg !50\n+  %1 = load %class.C2Class*, %class.C2Class** %arg.addr, align 8, !dbg !50\n+  ret void, !dbg !50\n }\n \n ; Function Attrs: noinline nounwind optnone uwtable\n-define dso_local void @\"?Func_DClass@@YA?AVDClass@@AEAV1@@Z\"(%class.DClass* noalias sret %agg.result, %class.DClass* dereferenceable(1) %arg) #0 !dbg !52 {\n+define dso_local void @\"?Func_DClass@@YA?AVDClass@@AEAV1@@Z\"(%class.DClass* noalias sret %agg.result, %class.DClass* dereferenceable(1) %arg) #0 !dbg !51 {\n entry:\n+  %result.ptr = alloca i8*, align 8\n   %arg.addr = alloca %class.DClass*, align 8\n+  %0 = bitcast %class.DClass* %agg.result to i8*\n+  store i8* %0, i8** %result.ptr, align 8\n   store %class.DClass* %arg, %class.DClass** %arg.addr, align 8\n-  call void @llvm.dbg.declare(metadata %class.DClass** %arg.addr, metadata !59, metadata !DIExpression()), !dbg !60\n-  %0 = load %class.DClass*, %class.DClass** %arg.addr, align 8, !dbg !60\n-  ret void, !dbg !60\n+  call void @llvm.dbg.declare(metadata %class.DClass** %arg.addr, metadata !58, metadata !DIExpression()), !dbg !59\n+  %1 = load %class.DClass*, %class.DClass** %arg.addr, align 8, !dbg !59\n+  ret void, !dbg !59\n }\n \n ; Function Attrs: noinline nounwind optnone uwtable\n-define dso_local i8 @\"?Func_FClass@@YA?AVFClass@@AEAV1@@Z\"(%class.FClass* dereferenceable(1) %arg) #0 !dbg !61 {\n+define dso_local i8 @\"?Func_FClass@@YA?AVFClass@@AEAV1@@Z\"(%class.FClass* dereferenceable(1) %arg) #0 !dbg !60 {\n entry:\n   %retval = alloca %class.FClass, align 1\n   %arg.addr = alloca %class.FClass*, align 8\n   store %class.FClass* %arg, %class.FClass** %arg.addr, align 8\n-  call void @llvm.dbg.declare(metadata %class.FClass** %arg.addr, metadata !69, metadata !DIExpression()), !dbg !70\n-  %0 = load %class.FClass*, %class.FClass** %arg.addr, align 8, !dbg !70\n-  %coerce.dive = getelementptr inbounds %class.FClass, %class.FClass* %retval, i32 0, i32 0, !dbg !70\n-  %1 = load i8, i8* %coerce.dive, align 1, !dbg !70\n-  ret i8 %1, !dbg !70\n+  call void @llvm.dbg.declare(metadata %class.FClass** %arg.addr, metadata !75, metadata !DIExpression()), !dbg !76\n+  %0 = load %class.FClass*, %class.FClass** %arg.addr, align 8, !dbg !76\n+  %coerce.dive = getelementptr inbounds %class.FClass, %class.FClass* %retval, i32 0, i32 0, !dbg !76\n+  %1 = load i8, i8* %coerce.dive, align 1, !dbg !76\n+  ret i8 %1, !dbg !76\n }\n \n ; Function Attrs: noinline nounwind optnone uwtable\n-define dso_local i8 @\"?Func_AStruct@@YA?AUAStruct@@AEAU1@@Z\"(%struct.AStruct* dereferenceable(1) %arg) #0 !dbg !71 {\n+define dso_local i8 @\"?Func_AStruct@@YA?AUAStruct@@AEAU1@@Z\"(%struct.AStruct* dereferenceable(1) %arg) #0 !dbg !77 {\n entry:\n   %retval = alloca %struct.AStruct, align 1\n   %arg.addr = alloca %struct.AStruct*, align 8\n   store %struct.AStruct* %arg, %struct.AStruct** %arg.addr, align 8\n-  call void @llvm.dbg.declare(metadata %struct.AStruct** %arg.addr, metadata !76, metadata !DIExpression()), !dbg !77\n-  %0 = load %struct.AStruct*, %struct.AStruct** %arg.addr, align 8, !dbg !77\n-  %coerce.dive = getelementptr inbounds %struct.AStruct, %struct.AStruct* %retval, i32 0, i32 0, !dbg !77\n-  %1 = load i8, i8* %coerce.dive, align 1, !dbg !77\n-  ret i8 %1, !dbg !77\n+  call void @llvm.dbg.declare(metadata %struct.AStruct** %arg.addr, metadata !82, metadata !DIExpression()), !dbg !83\n+  %0 = load %struct.AStruct*, %struct.AStruct** %arg.addr, align 8, !dbg !83\n+  %coerce.dive = getelementptr inbounds %struct.AStruct, %struct.AStruct* %retval, i32 0, i32 0, !dbg !83\n+  %1 = load i8, i8* %coerce.dive, align 1, !dbg !83\n+  ret i8 %1, !dbg !83\n }\n \n ; Function Attrs: noinline nounwind optnone uwtable\n-define dso_local void @\"?Func_BStruct@@YA?AUBStruct@@AEAU1@@Z\"(%struct.BStruct* noalias sret %agg.result, %struct.BStruct* dereferenceable(1) %arg) #0 !dbg !78 {\n+define dso_local void @\"?Func_BStruct@@YA?AUBStruct@@AEAU1@@Z\"(%struct.BStruct* noalias sret %agg.result, %struct.BStruct* dereferenceable(1) %arg) #0 !dbg !84 {\n entry:\n+  %result.ptr = alloca i8*, align 8\n   %arg.addr = alloca %struct.BStruct*, align 8\n+  %0 = bitcast %struct.BStruct* %agg.result to i8*\n+  store i8* %0, i8** %result.ptr, align 8\n   store %struct.BStruct* %arg, %struct.BStruct** %arg.addr, align 8\n-  call void @llvm.dbg.declare(metadata %struct.BStruct** %arg.addr, metadata !88, metadata !DIExpression()), !dbg !89\n-  %0 = load %struct.BStruct*, %struct.BStruct** %arg.addr, align 8, !dbg !89\n-  ret void, !dbg !89\n+  call void @llvm.dbg.declare(metadata %struct.BStruct** %arg.addr, metadata !94, metadata !DIExpression()), !dbg !95\n+  %1 = load %struct.BStruct*, %struct.BStruct** %arg.addr, align 8, !dbg !95\n+  ret void, !dbg !95\n }\n \n ; Function Attrs: noinline nounwind optnone uwtable\n-define dso_local i8 @\"?Func_AUnion@@YA?ATAUnion@@AEAT1@@Z\"(%union.AUnion* dereferenceable(1) %arg) #0 !dbg !90 {\n+define dso_local i8 @\"?Func_AUnion@@YA?ATAUnion@@AEAT1@@Z\"(%union.AUnion* dereferenceable(1) %arg) #0 !dbg !96 {\n entry:\n   %retval = alloca %union.AUnion, align 1\n   %arg.addr = alloca %union.AUnion*, align 8\n   store %union.AUnion* %arg, %union.AUnion** %arg.addr, align 8\n-  call void @llvm.dbg.declare(metadata %union.AUnion** %arg.addr, metadata !95, metadata !DIExpression()), !dbg !96\n-  %0 = load %union.AUnion*, %union.AUnion** %arg.addr, align 8, !dbg !96\n-  %coerce.dive = getelementptr inbounds %union.AUnion, %union.AUnion* %retval, i32 0, i32 0, !dbg !96\n-  %1 = load i8, i8* %coerce.dive, align 1, !dbg !96\n-  ret i8 %1, !dbg !96\n+  call void @llvm.dbg.declare(metadata %union.AUnion** %arg.addr, metadata !101, metadata !DIExpression()), !dbg !102\n+  %0 = load %union.AUnion*, %union.AUnion** %arg.addr, align 8, !dbg !102\n+  %coerce.dive = getelementptr inbounds %union.AUnion, %union.AUnion* %retval, i32 0, i32 0, !dbg !102\n+  %1 = load i8, i8* %coerce.dive, align 1, !dbg !102\n+  ret i8 %1, !dbg !102\n }\n \n ; Function Attrs: noinline nounwind optnone uwtable\n-define dso_local void @\"?Func_BUnion@@YA?ATBUnion@@AEAT1@@Z\"(%union.BUnion* noalias sret %agg.result, %union.BUnion* dereferenceable(1) %arg) #0 !dbg !97 {\n+define dso_local void @\"?Func_BUnion@@YA?ATBUnion@@AEAT1@@Z\"(%union.BUnion* noalias sret %agg.result, %union.BUnion* dereferenceable(1) %arg) #0 !dbg !103 {\n entry:\n+  %result.ptr = alloca i8*, align 8\n   %arg.addr = alloca %union.BUnion*, align 8\n+  %0 = bitcast %union.BUnion* %agg.result to i8*\n+  store i8* %0, i8** %result.ptr, align 8\n   store %union.BUnion* %arg, %union.BUnion** %arg.addr, align 8\n-  call void @llvm.dbg.declare(metadata %union.BUnion** %arg.addr, metadata !107, metadata !DIExpression()), !dbg !108\n-  %0 = load %union.BUnion*, %union.BUnion** %arg.addr, align 8, !dbg !108\n-  ret void, !dbg !108\n+  call void @llvm.dbg.declare(metadata %union.BUnion** %arg.addr, metadata !113, metadata !DIExpression()), !dbg !114\n+  %1 = load %union.BUnion*, %union.BUnion** %arg.addr, align 8, !dbg !114\n+  ret void, !dbg !114\n+}\n+\n+; Function Attrs: noinline norecurse nounwind optnone uwtable\n+define dso_local i32 @main() #2 !dbg !115 {\n+entry:\n+  %retval = alloca i32, align 4\n+  store i32 0, i32* %retval, align 4\n+  ret i32 0, !dbg !118\n }\n \n-attributes #0 = { noinline nounwind optnone uwtable \"correctly-rounded-divide-sqrt-fp-math\"=\"false\" \"disable-tail-calls\"=\"false\" \"less-precise-fpmad\"=\"false\" \"min-legal-vector-width\"=\"0\" \"frame-pointer\"=\"none\" \"no-infs-fp-math\"=\"false\" \"no-jump-tables\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"false\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+fxsr,+mmx,+sse,+sse2,+x87\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" }\n-attributes #1 = { nounwind readnone speculatable }\n+attributes #0 = { noinline nounwind optnone uwtable \"correctly-rounded-divide-sqrt-fp-math\"=\"false\" \"disable-tail-calls\"=\"false\" \"frame-pointer\"=\"none\" \"less-precise-fpmad\"=\"false\" \"min-legal-vector-width\"=\"0\" \"no-infs-fp-math\"=\"false\" \"no-jump-tables\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"false\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" }\n+attributes #1 = { nounwind readnone speculatable willreturn }\n+attributes #2 = { noinline norecurse nounwind optnone uwtable \"correctly-rounded-divide-sqrt-fp-math\"=\"false\" \"disable-tail-calls\"=\"false\" \"frame-pointer\"=\"none\" \"less-precise-fpmad\"=\"false\" \"min-legal-vector-width\"=\"0\" \"no-infs-fp-math\"=\"false\" \"no-jump-tables\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"false\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" }\n \n !llvm.dbg.cu = !{!0}\n !llvm.module.flags = !{!3, !4, !5, !6}\n !llvm.ident = !{!7}\n \n-!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: \"clang version 8.0.0\", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, nameTableKind: None)\n-!1 = !DIFile(filename: \"function-options.cpp\", directory: \"\\5Ctest\\5CDebugInfo\\5CCOFF\", checksumkind: CSK_MD5, checksum: \"e73e74ea0bd81174051f0a4746343e00\")\n+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus_14, file: !1, producer: \"clang version 11.0.0 (https://github.com/llvm/llvm-project.git 48992717b0e3466cf8814a188e9568c9d71b59c2)\", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, nameTableKind: None)\n+!1 = !DIFile(filename: \"t.cpp\", directory: \"C:\\\\src\\\\tests\\\\duplicate-types\\\\llvm-test\", checksumkind: CSK_MD5, checksum: \"c4c61c0e2135d713d0c99a1ba9ab568b\")\n !2 = !{}\n !3 = !{i32 2, !\"CodeView\", i32 1}\n !4 = !{i32 2, !\"Debug Info Version\", i32 3}\n !5 = !{i32 1, !\"wchar_size\", i32 2}\n !6 = !{i32 7, !\"PIC Level\", i32 2}\n-!7 = !{!\"clang version 8.0.0\"}\n-!8 = distinct !DISubprogram(name: \"Func_AClass\", linkageName: \"?Func_AClass@@YA?AVAClass@@AEAV1@@Z\", scope: !9, file: !9, line: 6, type: !10, isLocal: false, isDefinition: true, scopeLine: 6, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)\n-!9 = !DIFile(filename: \"function-options.cpp\", directory: \"D:\\5Cupstream\\5Cllvm\\5Ctest\\5CDebugInfo\\5CCOFF\")\n-!10 = !DISubroutineType(types: !11)\n-!11 = !{!12, !13}\n-!12 = distinct !DICompositeType(tag: DW_TAG_class_type, name: \"AClass\", file: !9, line: 5, size: 8, flags: DIFlagTypePassByValue, elements: !2, identifier: \".?AVAClass@@\")\n-!13 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !12, size: 64)\n-!14 = !DILocalVariable(name: \"arg\", arg: 1, scope: !8, file: !9, line: 6, type: !13)\n-!15 = !DILocation(line: 6, scope: !8)\n-!16 = distinct !DISubprogram(name: \"Func_BClass\", linkageName: \"?Func_BClass@@YA?AVBClass@@AEAV1@@Z\", scope: !9, file: !9, line: 12, type: !17, isLocal: false, isDefinition: true, scopeLine: 12, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)\n-!17 = !DISubroutineType(types: !18)\n-!18 = !{!19, !25}\n-!19 = distinct !DICompositeType(tag: DW_TAG_class_type, name: \"BClass\", file: !9, line: 8, size: 8, flags: DIFlagTypePassByValue | DIFlagNonTrivial, elements: !20, identifier: \".?AVBClass@@\")\n-!20 = !{!21}\n-!21 = !DISubprogram(name: \"BClass\", scope: !19, file: !9, line: 10, type: !22, isLocal: false, isDefinition: false, scopeLine: 10, flags: DIFlagExplicit | DIFlagPrototyped, isOptimized: false)\n-!22 = !DISubroutineType(types: !23)\n-!23 = !{null, !24}\n-!24 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !19, size: 64, flags: DIFlagArtificial | DIFlagObjectPointer)\n-!25 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !19, size: 64)\n-!26 = !DILocalVariable(name: \"arg\", arg: 1, scope: !16, file: !9, line: 12, type: !25)\n-!27 = !DILocation(line: 12, scope: !16)\n-!28 = distinct !DISubprogram(name: \"Func_C1Class\", linkageName: \"?Func_C1Class@@YA?AVC1Class@@AEAV1@@Z\", scope: !9, file: !9, line: 18, type: !29, isLocal: false, isDefinition: true, scopeLine: 18, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)\n-!29 = !DISubroutineType(types: !30)\n-!30 = !{!31, !37}\n-!31 = distinct !DICompositeType(tag: DW_TAG_class_type, name: \"C1Class\", file: !9, line: 14, size: 8, flags: DIFlagTypePassByValue, elements: !32, identifier: \".?AVC1Class@@\")\n-!32 = !{!33}\n-!33 = !DISubprogram(name: \"C1Class\", scope: !31, file: !9, line: 16, type: !34, isLocal: false, isDefinition: false, scopeLine: 16, flags: DIFlagPublic | DIFlagPrototyped, isOptimized: false)\n-!34 = !DISubroutineType(types: !35)\n-!35 = !{null, !36}\n-!36 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !31, size: 64, flags: DIFlagArtificial | DIFlagObjectPointer)\n-!37 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !31, size: 64)\n-!38 = !DILocalVariable(name: \"arg\", arg: 1, scope: !28, file: !9, line: 18, type: !37)\n-!39 = !DILocation(line: 18, scope: !28)\n-!40 = distinct !DISubprogram(name: \"Func_C2Class\", linkageName: \"?Func_C2Class@@YA?AVC2Class@@AEAV1@@Z\", scope: !9, file: !9, line: 24, type: !41, isLocal: false, isDefinition: true, scopeLine: 24, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)\n-!41 = !DISubroutineType(types: !42)\n-!42 = !{!43, !49}\n-!43 = distinct !DICompositeType(tag: DW_TAG_class_type, name: \"C2Class\", file: !9, line: 20, size: 8, flags: DIFlagTypePassByValue | DIFlagNonTrivial, elements: !44, identifier: \".?AVC2Class@@\")\n-!44 = !{!45}\n-!45 = !DISubprogram(name: \"~C2Class\", scope: !43, file: !9, line: 22, type: !46, isLocal: false, isDefinition: false, scopeLine: 22, flags: DIFlagPublic | DIFlagPrototyped, isOptimized: false)\n-!46 = !DISubroutineType(types: !47)\n-!47 = !{null, !48}\n-!48 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !43, size: 64, flags: DIFlagArtificial | DIFlagObjectPointer)\n-!49 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !43, size: 64)\n-!50 = !DILocalVariable(name: \"arg\", arg: 1, scope: !40, file: !9, line: 24, type: !49)\n-!51 = !DILocation(line: 24, scope: !40)\n-!52 = distinct !DISubprogram(name: \"Func_DClass\", linkageName: \"?Func_DClass@@YA?AVDClass@@AEAV1@@Z\", scope: !9, file: !9, line: 27, type: !53, isLocal: false, isDefinition: true, scopeLine: 27, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)\n-!53 = !DISubroutineType(types: !54)\n-!54 = !{!55, !58}\n-!55 = distinct !DICompositeType(tag: DW_TAG_class_type, name: \"DClass\", file: !9, line: 26, size: 8, flags: DIFlagTypePassByValue | DIFlagNonTrivial, elements: !56, identifier: \".?AVDClass@@\")\n-!56 = !{!57}\n-!57 = !DIDerivedType(tag: DW_TAG_inheritance, scope: !55, baseType: !19, flags: DIFlagPublic, extraData: i32 0)\n-!58 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !55, size: 64)\n-!59 = !DILocalVariable(name: \"arg\", arg: 1, scope: !52, file: !9, line: 27, type: !58)\n-!60 = !DILocation(line: 27, scope: !52)\n-!61 = distinct !DISubprogram(name: \"Func_FClass\", linkageName: \"?Func_FClass@@YA?AVFClass@@AEAV1@@Z\", scope: !9, file: !9, line: 30, type: !62, isLocal: false, isDefinition: true, scopeLine: 30, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)\n-!62 = !DISubroutineType(types: !63)\n-!63 = !{!64, !68}\n-!64 = distinct !DICompositeType(tag: DW_TAG_class_type, name: \"FClass\", file: !9, line: 29, size: 8, flags: DIFlagTypePassByValue, elements: !65, identifier: \".?AVFClass@@\")\n-!65 = !{!66}\n-!66 = !DIDerivedType(tag: DW_TAG_member, name: \"x\", scope: !64, file: !9, line: 29, baseType: !67, flags: DIFlagStaticMember)\n-!67 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n-!68 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !64, size: 64)\n-!69 = !DILocalVariable(name: \"arg\", arg: 1, scope: !61, file: !9, line: 30, type: !68)\n-!70 = !DILocation(line: 30, scope: !61)\n-!71 = distinct !DISubprogram(name: \"Func_AStruct\", linkageName: \"?Func_AStruct@@YA?AUAStruct@@AEAU1@@Z\", scope: !9, file: !9, line: 33, type: !72, isLocal: false, isDefinition: true, scopeLine: 33, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)\n+!7 = !{!\"clang version 11.0.0 (https://github.com/llvm/llvm-project.git 48992717b0e3466cf8814a188e9568c9d71b59c2)\"}\n+!8 = distinct !DISubprogram(name: \"Func_AClass\", linkageName: \"?Func_AClass@@YA?AVAClass@@AEAV1@@Z\", scope: !1, file: !1, line: 5, type: !9, scopeLine: 5, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)\n+!9 = !DISubroutineType(types: !10)\n+!10 = !{!11, !12}\n+!11 = distinct !DICompositeType(tag: DW_TAG_class_type, name: \"AClass\", file: !1, line: 4, size: 8, flags: DIFlagTypePassByValue, elements: !2, identifier: \".?AVAClass@@\")\n+!12 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !11, size: 64)\n+!13 = !DILocalVariable(name: \"arg\", arg: 1, scope: !8, file: !1, line: 5, type: !12)\n+!14 = !DILocation(line: 5, scope: !8)\n+!15 = distinct !DISubprogram(name: \"Func_BClass\", linkageName: \"?Func_BClass@@YA?AVBClass@@AEAV1@@Z\", scope: !1, file: !1, line: 11, type: !16, scopeLine: 11, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)\n+!16 = !DISubroutineType(types: !17)\n+!17 = !{!18, !24}\n+!18 = distinct !DICompositeType(tag: DW_TAG_class_type, name: \"BClass\", file: !1, line: 7, size: 8, flags: DIFlagTypePassByValue | DIFlagNonTrivial, elements: !19, identifier: \".?AVBClass@@\")\n+!19 = !{!20}\n+!20 = !DISubprogram(name: \"BClass\", scope: !18, file: !1, line: 9, type: !21, scopeLine: 9, flags: DIFlagExplicit | DIFlagPrototyped, spFlags: 0)\n+!21 = !DISubroutineType(types: !22)\n+!22 = !{null, !23}\n+!23 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !18, size: 64, flags: DIFlagArtificial | DIFlagObjectPointer)\n+!24 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !18, size: 64)\n+!25 = !DILocalVariable(name: \"arg\", arg: 1, scope: !15, file: !1, line: 11, type: !24)\n+!26 = !DILocation(line: 11, scope: !15)\n+!27 = distinct !DISubprogram(name: \"Func_C1Class\", linkageName: \"?Func_C1Class@@YA?AVC1Class@@AEAV1@@Z\", scope: !1, file: !1, line: 17, type: !28, scopeLine: 17, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)\n+!28 = !DISubroutineType(types: !29)\n+!29 = !{!30, !36}\n+!30 = distinct !DICompositeType(tag: DW_TAG_class_type, name: \"C1Class\", file: !1, line: 13, size: 8, flags: DIFlagTypePassByValue, elements: !31, identifier: \".?AVC1Class@@\")\n+!31 = !{!32}\n+!32 = !DISubprogram(name: \"C1Class\", scope: !30, file: !1, line: 15, type: !33, scopeLine: 15, flags: DIFlagPublic | DIFlagPrototyped, spFlags: 0)\n+!33 = !DISubroutineType(types: !34)\n+!34 = !{null, !35}\n+!35 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !30, size: 64, flags: DIFlagArtificial | DIFlagObjectPointer)\n+!36 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !30, size: 64)\n+!37 = !DILocalVariable(name: \"arg\", arg: 1, scope: !27, file: !1, line: 17, type: !36)\n+!38 = !DILocation(line: 17, scope: !27)\n+!39 = distinct !DISubprogram(name: \"Func_C2Class\", linkageName: \"?Func_C2Class@@YA?AVC2Class@@AEAV1@@Z\", scope: !1, file: !1, line: 23, type: !40, scopeLine: 23, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)\n+!40 = !DISubroutineType(types: !41)\n+!41 = !{!42, !48}\n+!42 = distinct !DICompositeType(tag: DW_TAG_class_type, name: \"C2Class\", file: !1, line: 19, size: 8, flags: DIFlagTypePassByValue | DIFlagNonTrivial, elements: !43, identifier: \".?AVC2Class@@\")\n+!43 = !{!44}\n+!44 = !DISubprogram(name: \"~C2Class\", scope: !42, file: !1, line: 21, type: !45, scopeLine: 21, flags: DIFlagPublic | DIFlagPrototyped, spFlags: 0)\n+!45 = !DISubroutineType(types: !46)\n+!46 = !{null, !47}\n+!47 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !42, size: 64, flags: DIFlagArtificial | DIFlagObjectPointer)\n+!48 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !42, size: 64)\n+!49 = !DILocalVariable(name: \"arg\", arg: 1, scope: !39, file: !1, line: 23, type: !48)\n+!50 = !DILocation(line: 23, scope: !39)\n+!51 = distinct !DISubprogram(name: \"Func_DClass\", linkageName: \"?Func_DClass@@YA?AVDClass@@AEAV1@@Z\", scope: !1, file: !1, line: 26, type: !52, scopeLine: 26, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)\n+!52 = !DISubroutineType(types: !53)\n+!53 = !{!54, !57}\n+!54 = distinct !DICompositeType(tag: DW_TAG_class_type, name: \"DClass\", file: !1, line: 25, size: 8, flags: DIFlagTypePassByValue | DIFlagNonTrivial, elements: !55, identifier: \".?AVDClass@@\")\n+!55 = !{!56}\n+!56 = !DIDerivedType(tag: DW_TAG_inheritance, scope: !54, baseType: !18, flags: DIFlagPublic, extraData: i32 0)\n+!57 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !54, size: 64)\n+!58 = !DILocalVariable(name: \"arg\", arg: 1, scope: !51, file: !1, line: 26, type: !57)\n+!59 = !DILocation(line: 26, scope: !51)\n+!60 = distinct !DISubprogram(name: \"Func_FClass\", linkageName: \"?Func_FClass@@YA?AVFClass@@AEAV1@@Z\", scope: !1, file: !1, line: 33, type: !61, scopeLine: 33, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)\n+!61 = !DISubroutineType(types: !62)\n+!62 = !{!63, !74}\n+!63 = distinct !DICompositeType(tag: DW_TAG_class_type, name: \"FClass\", file: !1, line: 28, size: 8, flags: DIFlagTypePassByValue, elements: !64, identifier: \".?AVFClass@@\")\n+!64 = !{!65, !67, !71}\n+!65 = !DIDerivedType(tag: DW_TAG_member, name: \"x\", scope: !63, file: !1, line: 29, baseType: !66, flags: DIFlagStaticMember)\n+!66 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n+!67 = !DISubprogram(name: \"Member_AClass\", linkageName: \"?Member_AClass@FClass@@AEAA?AVAClass@@AEAV2@@Z\", scope: !63, file: !1, line: 30, type: !68, scopeLine: 30, flags: DIFlagPrototyped, spFlags: 0)\n+!68 = !DISubroutineType(types: !69)\n+!69 = !{!11, !70, !12}\n+!70 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !63, size: 64, flags: DIFlagArtificial | DIFlagObjectPointer)\n+!71 = !DISubprogram(name: \"Member_BClass\", linkageName: \"?Member_BClass@FClass@@AEAA?AVBClass@@AEAV2@@Z\", scope: !63, file: !1, line: 31, type: !72, scopeLine: 31, flags: DIFlagPrototyped, spFlags: 0)\n !72 = !DISubroutineType(types: !73)\n-!73 = !{!74, !75}\n-!74 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: \"AStruct\", file: !9, line: 32, size: 8, flags: DIFlagTypePassByValue, elements: !2, identifier: \".?AUAStruct@@\")\n-!75 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !74, size: 64)\n-!76 = !DILocalVariable(name: \"arg\", arg: 1, scope: !71, file: !9, line: 33, type: !75)\n-!77 = !DILocation(line: 33, scope: !71)\n-!78 = distinct !DISubprogram(name: \"Func_BStruct\", linkageName: \"?Func_BStruct@@YA?AUBStruct@@AEAU1@@Z\", scope: !9, file: !9, line: 36, type: !79, isLocal: false, isDefinition: true, scopeLine: 36, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)\n-!79 = !DISubroutineType(types: !80)\n-!80 = !{!81, !87}\n-!81 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: \"BStruct\", file: !9, line: 35, size: 8, flags: DIFlagTypePassByValue | DIFlagNonTrivial, elements: !82, identifier: \".?AUBStruct@@\")\n-!82 = !{!83}\n-!83 = !DISubprogram(name: \"BStruct\", scope: !81, file: !9, line: 35, type: !84, isLocal: false, isDefinition: false, scopeLine: 35, flags: DIFlagPrototyped, isOptimized: false)\n-!84 = !DISubroutineType(types: !85)\n-!85 = !{null, !86}\n-!86 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !81, size: 64, flags: DIFlagArtificial | DIFlagObjectPointer)\n-!87 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !81, size: 64)\n-!88 = !DILocalVariable(name: \"arg\", arg: 1, scope: !78, file: !9, line: 36, type: !87)\n-!89 = !DILocation(line: 36, scope: !78)\n-!90 = distinct !DISubprogram(name: \"Func_AUnion\", linkageName: \"?Func_AUnion@@YA?ATAUnion@@AEAT1@@Z\", scope: !9, file: !9, line: 39, type: !91, isLocal: false, isDefinition: true, scopeLine: 39, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)\n-!91 = !DISubroutineType(types: !92)\n-!92 = !{!93, !94}\n-!93 = distinct !DICompositeType(tag: DW_TAG_union_type, name: \"AUnion\", file: !9, line: 38, size: 8, flags: DIFlagTypePassByValue, elements: !2, identifier: \".?ATAUnion@@\")\n-!94 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !93, size: 64)\n-!95 = !DILocalVariable(name: \"arg\", arg: 1, scope: !90, file: !9, line: 39, type: !94)\n-!96 = !DILocation(line: 39, scope: !90)\n-!97 = distinct !DISubprogram(name: \"Func_BUnion\", linkageName: \"?Func_BUnion@@YA?ATBUnion@@AEAT1@@Z\", scope: !9, file: !9, line: 42, type: !98, isLocal: false, isDefinition: true, scopeLine: 42, flags: DIFlagPrototyped, isOptimized: false, unit: !0, retainedNodes: !2)\n-!98 = !DISubroutineType(types: !99)\n-!99 = !{!100, !106}\n-!100 = distinct !DICompositeType(tag: DW_TAG_union_type, name: \"BUnion\", file: !9, line: 41, size: 8, flags: DIFlagTypePassByValue, elements: !101, identifier: \".?ATBUnion@@\")\n-!101 = !{!102}\n-!102 = !DISubprogram(name: \"BUnion\", scope: !100, file: !9, line: 41, type: !103, isLocal: false, isDefinition: false, scopeLine: 41, flags: DIFlagPrototyped, isOptimized: false)\n-!103 = !DISubroutineType(types: !104)\n-!104 = !{null, !105}\n-!105 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !100, size: 64, flags: DIFlagArtificial | DIFlagObjectPointer)\n-!106 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !100, size: 64)\n-!107 = !DILocalVariable(name: \"arg\", arg: 1, scope: !97, file: !9, line: 42, type: !106)\n-!108 = !DILocation(line: 42, scope: !97)\n+!73 = !{!18, !70, !24}\n+!74 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !63, size: 64)\n+!75 = !DILocalVariable(name: \"arg\", arg: 1, scope: !60, file: !1, line: 33, type: !74)\n+!76 = !DILocation(line: 33, scope: !60)\n+!77 = distinct !DISubprogram(name: \"Func_AStruct\", linkageName: \"?Func_AStruct@@YA?AUAStruct@@AEAU1@@Z\", scope: !1, file: !1, line: 36, type: !78, scopeLine: 36, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)\n+!78 = !DISubroutineType(types: !79)\n+!79 = !{!80, !81}\n+!80 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: \"AStruct\", file: !1, line: 35, size: 8, flags: DIFlagTypePassByValue, elements: !2, identifier: \".?AUAStruct@@\")\n+!81 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !80, size: 64)\n+!82 = !DILocalVariable(name: \"arg\", arg: 1, scope: !77, file: !1, line: 36, type: !81)\n+!83 = !DILocation(line: 36, scope: !77)\n+!84 = distinct !DISubprogram(name: \"Func_BStruct\", linkageName: \"?Func_BStruct@@YA?AUBStruct@@AEAU1@@Z\", scope: !1, file: !1, line: 39, type: !85, scopeLine: 39, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)\n+!85 = !DISubroutineType(types: !86)\n+!86 = !{!87, !93}\n+!87 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: \"BStruct\", file: !1, line: 38, size: 8, flags: DIFlagTypePassByValue | DIFlagNonTrivial, elements: !88, identifier: \".?AUBStruct@@\")\n+!88 = !{!89}\n+!89 = !DISubprogram(name: \"BStruct\", scope: !87, file: !1, line: 38, type: !90, scopeLine: 38, flags: DIFlagPrototyped, spFlags: 0)\n+!90 = !DISubroutineType(types: !91)\n+!91 = !{null, !92}\n+!92 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !87, size: 64, flags: DIFlagArtificial | DIFlagObjectPointer)\n+!93 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !87, size: 64)\n+!94 = !DILocalVariable(name: \"arg\", arg: 1, scope: !84, file: !1, line: 39, type: !93)\n+!95 = !DILocation(line: 39, scope: !84)\n+!96 = distinct !DISubprogram(name: \"Func_AUnion\", linkageName: \"?Func_AUnion@@YA?ATAUnion@@AEAT1@@Z\", scope: !1, file: !1, line: 42, type: !97, scopeLine: 42, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)\n+!97 = !DISubroutineType(types: !98)\n+!98 = !{!99, !100}\n+!99 = distinct !DICompositeType(tag: DW_TAG_union_type, name: \"AUnion\", file: !1, line: 41, size: 8, flags: DIFlagTypePassByValue, elements: !2, identifier: \".?ATAUnion@@\")\n+!100 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !99, size: 64)\n+!101 = !DILocalVariable(name: \"arg\", arg: 1, scope: !96, file: !1, line: 42, type: !100)\n+!102 = !DILocation(line: 42, scope: !96)\n+!103 = distinct !DISubprogram(name: \"Func_BUnion\", linkageName: \"?Func_BUnion@@YA?ATBUnion@@AEAT1@@Z\", scope: !1, file: !1, line: 45, type: !104, scopeLine: 45, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)\n+!104 = !DISubroutineType(types: !105)\n+!105 = !{!106, !112}\n+!106 = distinct !DICompositeType(tag: DW_TAG_union_type, name: \"BUnion\", file: !1, line: 44, size: 8, flags: DIFlagTypePassByValue, elements: !107, identifier: \".?ATBUnion@@\")\n+!107 = !{!108}\n+!108 = !DISubprogram(name: \"BUnion\", scope: !106, file: !1, line: 44, type: !109, scopeLine: 44, flags: DIFlagPrototyped, spFlags: 0)\n+!109 = !DISubroutineType(types: !110)\n+!110 = !{null, !111}\n+!111 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !106, size: 64, flags: DIFlagArtificial | DIFlagObjectPointer)\n+!112 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !106, size: 64)\n+!113 = !DILocalVariable(name: \"arg\", arg: 1, scope: !103, file: !1, line: 45, type: !112)\n+!114 = !DILocation(line: 45, scope: !103)\n+!115 = distinct !DISubprogram(name: \"main\", scope: !1, file: !1, line: 47, type: !116, scopeLine: 47, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !0, retainedNodes: !2)\n+!116 = !DISubroutineType(types: !117)\n+!117 = !{!66}\n+!118 = !DILocation(line: 48, scope: !115)"
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/COFF/function-options.ll (1 of 1)\n\nTesting Time: 0.25s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/COFF/function-options.ll\n\n  Unexpected Failures: 1\n"
    },
    "d291bd510e6a4e62594186cb8f3ddc18acf2ee1a___WholeProgramDevirt.cpp": {
        "start": 1710,
        "end": 1754,
        "buggy": "void DevirtModule::scanTypeTestUsers(Function *TypeTestFunc) {\n  // Find all virtual calls via a virtual table pointer %p under an assumption\n  // of the form llvm.assume(llvm.type.test(%p, %md)). This indicates that %p\n  // points to a member of the type identifier %md. Group calls by (type ID,\n  // offset) pair (effectively the identity of the virtual function) and store\n  // to CallSlots.\n  DenseSet<CallBase *> SeenCallSites;\n  for (auto I = TypeTestFunc->use_begin(), E = TypeTestFunc->use_end();\n       I != E;) {\n    auto CI = dyn_cast<CallInst>(I->getUser());\n    ++I;\n    if (!CI)\n      continue;\n\n    // Search for virtual calls based on %p and add them to DevirtCalls.\n    SmallVector<DevirtCallSite, 1> DevirtCalls;\n    SmallVector<CallInst *, 1> Assumes;\n    auto &DT = LookupDomTree(*CI->getFunction());\n    findDevirtualizableCallsForTypeTest(DevirtCalls, Assumes, CI, DT);\n\n    // If we found any, add them to CallSlots.\n    if (!Assumes.empty()) {\n      Metadata *TypeId =\n          cast<MetadataAsValue>(CI->getArgOperand(1))->getMetadata();\n      Value *Ptr = CI->getArgOperand(0)->stripPointerCasts();\n      for (DevirtCallSite Call : DevirtCalls) {\n        // Only add this CallSite if we haven't seen it before. The vtable\n        // pointer may have been CSE'd with pointers from other call sites,\n        // and we don't want to process call sites multiple times. We can't\n        // just skip the vtable Ptr if it has been seen before, however, since\n        // it may be shared by type tests that dominate different calls.\n        if (SeenCallSites.insert(&Call.CB).second)\n          CallSlots[{TypeId, Call.Offset}].addCallSite(Ptr, Call.CB, nullptr);\n      }\n    }\n\n    // We no longer need the assumes or the type test.\n    for (auto Assume : Assumes)\n      Assume->eraseFromParent();\n    // We can't use RecursivelyDeleteTriviallyDeadInstructions here because we\n    // may use the vtable argument later.\n    if (CI->use_empty())\n      CI->eraseFromParent();\n  }\n}\n",
        "fix": null,
        "src_path": "d291bd510e6a4e62594186cb8f3ddc18acf2ee1a___WholeProgramDevirt.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/d291bd510e6a4e62594186cb8f3ddc18acf2ee1a",
        "commit_msg": "[WPD] Allow virtual calls to be analyzed with multiple type tests\n\nSummary:\nIn D52514 I had fixed a bug with WPD after indirect call promotion, by\nchecking that a type test being analyzed dominates potential virtual\ncalls. With that fix I included a small effiency enhancement to avoid\nprocessing a devirt candidate multiple times (when there are multiple\ntype tests). This latter change wasn't in response to any measured\nefficiency issues, it was merely theoretical. Unfortuantely, it turns\nout to limit optimization opportunities after inlining.\n\nSpecifically, consider code that looks like:\n\nclass A {\n  virtual void foo();\n};\nclass B : public A {\n  void foo();\n}\nvoid callee(A *a) {\n  a->foo(); // Call 1\n}\nvoid caller(B *b) {\n  b->foo(); // Call 2\n  callee(b);\n}\n\nAfter inlining callee into caller, because of the existing call to\nb->foo() in caller there will be 2 type tests in caller for the vtable\npointer of b: the original type test against B from Call 2, and the\ninlined type test against A from Call 1. If the code was compiled with\n-fstrict-vtable-pointers, then after optimization WPD will see that\nboth type tests are associated with the inlined virtual Call 1.\nWith my earlier change to only process a virtual call against one type\ntest, we may only consider virtual Call 1 against the base class A type\ntest, which can't be devirtualized. With my change here to remove this\nrestriction, it also gets considered for the type test against the\nderived class B type test, where it can be devirtualized.\n\nNote that if caller didn't include it's own earlier virtual call\nb->foo() we will not be able to devirtualize after inlining callee even\nafter this fix, since there would not be a type test against B in the\nIR. As a future enhancement we can consider inserting type tests at call\nsites that pass pointers to classes with virtual calls, to enable\ncontext-sensitive devirtualization after inlining.\n\nReviewers: pcc, vitalybuka, evgeny777\n\nSubscribers: Prazek, hiraditya, steven_wu, dexonsmith, llvm-commits\n\nTags: #llvm\n\nDifferential Revision: https://reviews.llvm.org/D79235",
        "test_func_diff": [
            {
                "fn": "llvm/test/ThinLTO/X86/devirt_multiple_type_test.ll",
                "patch": "@@ -0,0 +1,80 @@\n+; Test to ensure that devirtualization will succeed when there is an earlier\n+; type test also corresponding to the same vtable (when indicated by invariant\n+; load metadata), that provides a more refined type. This could happen in\n+; after inlining into a caller passing a derived type.\n+\n+; RUN: opt -module-summary %s -o %t.o\n+; RUN: llvm-lto2 run -o %t.out %t.o \\\n+; RUN:\t -pass-remarks=wholeprogramdevirt \\\n+; RUN:\t -r %t.o,_ZN1A3fooEv,px \\\n+; RUN:\t -r %t.o,_ZN1B3fooEv,px \\\n+; RUN:\t -r %t.o,_Z6callerP1B,px \\\n+; RUN:\t -r %t.o,_ZTV1A,px \\\n+; RUN:\t -r %t.o,_ZTV1B,px \\\n+; RUN:\t -save-temps 2>&1 | FileCheck %s\n+\n+; CHECK-COUNT-2: single-impl: devirtualized a call to _ZN1B3fooEv\n+\n+; RUN: llvm-dis %t.out.1.4.opt.bc -o - | FileCheck %s --check-prefix=IR\n+; IR-NOT: tail call void %\n+\n+; ModuleID = 'devirt_multiple_type_test.o'\n+source_filename = \"devirt_multiple_type_test.cc\"\n+target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n+target triple = \"x86_64-unknown-linux-gnu\"\n+\n+%class.A = type { i32 (...)** }\n+%class.B = type { %class.A }\n+\n+@_ZTV1A = hidden unnamed_addr constant { [3 x i8*] } { [3 x i8*] [i8* null, i8* undef, i8* bitcast (void (%class.A*)* @_ZN1A3fooEv to i8*)] }, align 8, !type !0, !vcall_visibility !2\n+@_ZTV1B = hidden unnamed_addr constant { [3 x i8*] } { [3 x i8*] [i8* null, i8* undef, i8* bitcast (void (%class.B*)* @_ZN1B3fooEv to i8*)] }, align 8, !type !0, !type !3, !vcall_visibility !2\n+\n+declare void @_ZN1A3fooEv(%class.A* nocapture %this)\n+\n+define hidden void @_ZN1B3fooEv(%class.B* nocapture %this) {\n+entry:\n+  ret void\n+}\n+\n+; Function Attrs: nounwind readnone willreturn\n+declare i1 @llvm.type.test(i8*, metadata)\n+\n+; Function Attrs: nounwind willreturn\n+declare void @llvm.assume(i1)\n+\n+; Function Attrs: uwtable\n+define hidden void @_Z6callerP1B(%class.B* %b) local_unnamed_addr {\n+entry:\n+  %0 = bitcast %class.B* %b to void (%class.B*)***\n+  %vtable = load void (%class.B*)**, void (%class.B*)*** %0, align 8, !tbaa !12, !invariant.group !15\n+  %1 = bitcast void (%class.B*)** %vtable to i8*\n+  %2 = tail call i1 @llvm.type.test(i8* %1, metadata !\"_ZTS1B\")\n+  tail call void @llvm.assume(i1 %2)\n+  %3 = load void (%class.B*)*, void (%class.B*)** %vtable, align 8, !invariant.load !15\n+  tail call void %3(%class.B* %b)\n+  %4 = getelementptr %class.B, %class.B* %b, i64 0, i32 0\n+  %5 = bitcast void (%class.B*)** %vtable to i8*\n+  %6 = tail call i1 @llvm.type.test(i8* nonnull %5, metadata !\"_ZTS1A\")\n+  tail call void @llvm.assume(i1 %6)\n+  %7 = bitcast void (%class.B*)* %3 to void (%class.A*)*\n+  tail call void %7(%class.A* %4)\n+  ret void\n+}\n+\n+!llvm.module.flags = !{!5, !6, !8, !9, !10}\n+!llvm.ident = !{!11}\n+\n+!0 = !{i64 16, !\"_ZTS1A\"}\n+!2 = !{i64 1}\n+!3 = !{i64 16, !\"_ZTS1B\"}\n+!5 = !{i32 1, !\"StrictVTablePointers\", i32 1}\n+!6 = !{i32 3, !\"StrictVTablePointersRequirement\", !7}\n+!7 = !{!\"StrictVTablePointers\", i32 1}\n+!8 = !{i32 1, !\"wchar_size\", i32 4}\n+!9 = !{i32 1, !\"Virtual Function Elim\", i32 0}\n+!10 = !{i32 1, !\"EnableSplitLTOUnit\", i32 0}\n+!11 = !{!\"clang version 11.0.0 (https://github.com/llvm/llvm-project.git 85247c1e898f88d65154b9a437b4bd83fcad8d52)\"}\n+!12 = !{!13, !13, i64 0}\n+!13 = !{!\"vtable pointer\", !14, i64 0}\n+!14 = !{!\"Simple C++ TBAA\"}\n+!15 = !{}"
            }
        ],
        "error_msg": "FAIL: LLVM :: ThinLTO/X86/devirt_multiple_type_test.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: ThinLTO/X86/devirt_multiple_type_test.ll\n\n\nTesting Time: 0.41s\n  Failed: 1\n"
    },
    "66055230bf6673b76e7330fef76d752a1ea8638e___TargetLoweringObjectFileImpl.cpp": {
        "start": 593,
        "end": 624,
        "buggy": "static SmallString<128>\ngetELFSectionNameForGlobal(const GlobalObject *GO, SectionKind Kind,\n                           Mangler &Mang, const TargetMachine &TM,\n                           unsigned EntrySize, bool UniqueSectionName) {\n  SmallString<128> Name;\n  if (Kind.isMergeableCString()) {\n    // We also need alignment here.\n    // FIXME: this is getting the alignment of the character, not the\n    // alignment of the global!\n    unsigned Align = GO->getParent()->getDataLayout().getPreferredAlignment(\n        cast<GlobalVariable>(GO));\n\n    std::string SizeSpec = \".rodata.str\" + utostr(EntrySize) + \".\";\n    Name = SizeSpec + utostr(Align);\n  } else if (Kind.isMergeableConst()) {\n    Name = \".rodata.cst\";\n    Name += utostr(EntrySize);\n  } else {\n    Name = getSectionPrefixForGlobal(Kind);\n  }\n\n  if (const auto *F = dyn_cast<Function>(GO)) {\n    if (Optional<StringRef> Prefix = F->getSectionPrefix())\n      Name += *Prefix;\n  }\n\n  if (UniqueSectionName) {\n    Name.push_back('.');\n    TM.getNameWithPrefix(Name, GO, Mang, /*MayAlwaysUsePrivate*/true);\n  }\n  return Name;\n}\n",
        "fix": null,
        "src_path": "66055230bf6673b76e7330fef76d752a1ea8638e___TargetLoweringObjectFileImpl.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/66055230bf6673b76e7330fef76d752a1ea8638e",
        "commit_msg": "[TargetLoweringObjectFileImpl] Produce .text.hot. instead of .text.hot for -fno-unique-section-names\n\nGNU ld's internal linker script uses (https://sourceware.org/git/?p=binutils-gdb.git;a=commit;h=add44f8d5c5c05e08b11e033127a744d61c26aee)\n\n  .text           :\n  {\n    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n    *(.text.exit .text.exit.*)\n    *(.text.startup .text.startup.*)\n    *(.text.hot .text.hot.*)\n    *(SORT(.text.sorted.*))\n    *(.text .stub .text.* .gnu.linkonce.t.*)\n    /* .gnu.warning sections are handled specially by elf.em.  */\n    *(.gnu.warning)\n  }\n\nBecause `*(.text.exit .text.exit.*)` is ordered before `*(.text .text.*)`, in a -ffunction-sections build, the C library function `exit` will be placed before other functions.\ngold's `-z keep-text-section-prefix` has the same problem.\n\nIn lld, `-z keep-text-section-prefix` recognizes `.text.{exit,hot,startup,unlikely,unknown}.*`, but not `.text.{exit,hot,startup,unlikely,unknown}`, to avoid the strange placement problem.\n\nIn -fno-function-sections or -fno-unique-section-names mode, a function whose `function_section_prefix` is set to `.exit\"`\nwill go to the output section `.text` instead of `.text.exit` when linked by lld.\nTo address the problem, append a dot to become `.text.exit.`\n\nReviewed By: grimar\n\nDifferential Revision: https://reviews.llvm.org/D79600",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/CodeGenPrepare/X86/section.ll",
                "patch": "@@ -1,10 +1,14 @@\n ; RUN: opt < %s -codegenprepare -S | FileCheck %s\n+; RUN: llc < %s | FileCheck --check-prefix=ASM1 %s\n+; RUN: llc < %s -function-sections | FileCheck --check-prefix=ASM2 %s\n \n target triple = \"x86_64-pc-linux-gnu\"\n \n ; This tests that hot/cold functions get correct section prefix assigned\n \n ; CHECK: hot_func1{{.*}}!section_prefix ![[HOT_ID:[0-9]+]]\n+; ASM1: .section .text.hot.,\"ax\",@progbits\n+; ASM2: .section .text.hot.hot_func1,\"ax\",@progbits\n ; The entry is hot\n define void @hot_func1() !prof !15 {\n   ret void\n@@ -40,6 +44,8 @@ for.end:\n ; not call site VP metadata (which can exist on value profiled memcpy,\n ; or possibly left behind after static analysis based devirtualization).\n ; CHECK: cold_func1{{.*}}!section_prefix ![[COLD_ID:[0-9]+]]\n+; ASM1: .section .text.unlikely.,\"ax\",@progbits\n+; ASM2: .section .text.unlikely.cold_func1,\"ax\",@progbits\n define void @cold_func1() !prof !16 {\n   call void @hot_func1(), !prof !17\n   call void @hot_func1(), !prof !17"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/CodeGenPrepare/X86/section.ll (1 of 1)\n********************\nFailing Tests (1):\n  LLVM :: Transforms/CodeGenPrepare/X86/section.ll\n\n\nTesting Time: 1.15s\n  Unexpected Failures: 1\n"
    },
    "cfdc96714bdfeabea31b1f4d2e0c65e424933994___InstructionCombining.cpp": {
        "start": 700,
        "end": 812,
        "buggy": "Value *InstCombinerImpl::SimplifyUsingDistributiveLaws(BinaryOperator &I) {\n  Value *LHS = I.getOperand(0), *RHS = I.getOperand(1);\n  BinaryOperator *Op0 = dyn_cast<BinaryOperator>(LHS);\n  BinaryOperator *Op1 = dyn_cast<BinaryOperator>(RHS);\n  Instruction::BinaryOps TopLevelOpcode = I.getOpcode();\n\n  {\n    // Factorization.\n    Value *A, *B, *C, *D;\n    Instruction::BinaryOps LHSOpcode, RHSOpcode;\n    if (Op0)\n      LHSOpcode = getBinOpsForFactorization(TopLevelOpcode, Op0, A, B);\n    if (Op1)\n      RHSOpcode = getBinOpsForFactorization(TopLevelOpcode, Op1, C, D);\n\n    // The instruction has the form \"(A op' B) op (C op' D)\".  Try to factorize\n    // a common term.\n    if (Op0 && Op1 && LHSOpcode == RHSOpcode)\n      if (Value *V = tryFactorization(I, LHSOpcode, A, B, C, D))\n        return V;\n\n    // The instruction has the form \"(A op' B) op (C)\".  Try to factorize common\n    // term.\n    if (Op0)\n      if (Value *Ident = getIdentityValue(LHSOpcode, RHS))\n        if (Value *V = tryFactorization(I, LHSOpcode, A, B, RHS, Ident))\n          return V;\n\n    // The instruction has the form \"(B) op (C op' D)\".  Try to factorize common\n    // term.\n    if (Op1)\n      if (Value *Ident = getIdentityValue(RHSOpcode, LHS))\n        if (Value *V = tryFactorization(I, RHSOpcode, LHS, Ident, C, D))\n          return V;\n  }\n\n  // Expansion.\n  if (Op0 && rightDistributesOverLeft(Op0->getOpcode(), TopLevelOpcode)) {\n    // The instruction has the form \"(A op' B) op C\".  See if expanding it out\n    // to \"(A op C) op' (B op C)\" results in simplifications.\n    Value *A = Op0->getOperand(0), *B = Op0->getOperand(1), *C = RHS;\n    Instruction::BinaryOps InnerOpcode = Op0->getOpcode(); // op'\n\n    Value *L = SimplifyBinOp(TopLevelOpcode, A, C, SQ.getWithInstruction(&I));\n    Value *R = SimplifyBinOp(TopLevelOpcode, B, C, SQ.getWithInstruction(&I));\n\n    // Do \"A op C\" and \"B op C\" both simplify?\n    if (L && R) {\n      // They do! Return \"L op' R\".\n      ++NumExpand;\n      C = Builder.CreateBinOp(InnerOpcode, L, R);\n      C->takeName(&I);\n      return C;\n    }\n\n    // Does \"A op C\" simplify to the identity value for the inner opcode?\n    if (L && L == ConstantExpr::getBinOpIdentity(InnerOpcode, L->getType())) {\n      // They do! Return \"B op C\".\n      ++NumExpand;\n      C = Builder.CreateBinOp(TopLevelOpcode, B, C);\n      C->takeName(&I);\n      return C;\n    }\n\n    // Does \"B op C\" simplify to the identity value for the inner opcode?\n    if (R && R == ConstantExpr::getBinOpIdentity(InnerOpcode, R->getType())) {\n      // They do! Return \"A op C\".\n      ++NumExpand;\n      C = Builder.CreateBinOp(TopLevelOpcode, A, C);\n      C->takeName(&I);\n      return C;\n    }\n  }\n\n  if (Op1 && leftDistributesOverRight(TopLevelOpcode, Op1->getOpcode())) {\n    // The instruction has the form \"A op (B op' C)\".  See if expanding it out\n    // to \"(A op B) op' (A op C)\" results in simplifications.\n    Value *A = LHS, *B = Op1->getOperand(0), *C = Op1->getOperand(1);\n    Instruction::BinaryOps InnerOpcode = Op1->getOpcode(); // op'\n\n    Value *L = SimplifyBinOp(TopLevelOpcode, A, B, SQ.getWithInstruction(&I));\n    Value *R = SimplifyBinOp(TopLevelOpcode, A, C, SQ.getWithInstruction(&I));\n\n    // Do \"A op B\" and \"A op C\" both simplify?\n    if (L && R) {\n      // They do! Return \"L op' R\".\n      ++NumExpand;\n      A = Builder.CreateBinOp(InnerOpcode, L, R);\n      A->takeName(&I);\n      return A;\n    }\n\n    // Does \"A op B\" simplify to the identity value for the inner opcode?\n    if (L && L == ConstantExpr::getBinOpIdentity(InnerOpcode, L->getType())) {\n      // They do! Return \"A op C\".\n      ++NumExpand;\n      A = Builder.CreateBinOp(TopLevelOpcode, A, C);\n      A->takeName(&I);\n      return A;\n    }\n\n    // Does \"A op C\" simplify to the identity value for the inner opcode?\n    if (R && R == ConstantExpr::getBinOpIdentity(InnerOpcode, R->getType())) {\n      // They do! Return \"A op B\".\n      ++NumExpand;\n      A = Builder.CreateBinOp(TopLevelOpcode, A, B);\n      A->takeName(&I);\n      return A;\n    }\n  }\n\n  return SimplifySelectsFeedingBinaryOp(I, LHS, RHS);\n}\n",
        "fix": null,
        "src_path": "cfdc96714bdfeabea31b1f4d2e0c65e424933994___InstructionCombining.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/cfdc96714bdfeabea31b1f4d2e0c65e424933994",
        "commit_msg": "[Instcombine] Fix uses of undef (PR46940)\n\nWithout this patch, we attempt to distribute And over Xor even in\nunsafe circumstances like so:\n\n  undef & (true ^ true)  ==>  (undef & true) ^ (undef & true)\n\nand evaluate it to undef instead of false.  Note that \"true ^ true\"\nmay show up implicitly with one true being part of a PHI node.\n\nThis patch fixes the problem by teaching SimplifyUsingDistributiveLaws\nto not use undef as part of simplifications.\n\nReviewers: spatel, aqjune, nikic, lebedev.ri, fhahn, jdoerfert\n\nDifferential Revision: https://reviews.llvm.org/D85687",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/dont-distribute-phi.ll",
                "patch": "@@ -0,0 +1,33 @@\n+; RUN: opt < %s -instcombine -S | FileCheck %s\n+;\n+; This test ensures that InstCombine does not distribute And over Xor\n+; using simplifications involving undef.\n+\n+define zeroext i1 @foo(i32 %arg) {\n+; CHECK-LABEL: @foo(\n+\n+entry:\n+  %cmp1 = icmp eq i32 %arg, 37\n+  br i1 %cmp1, label %bb_then, label %bb_else\n+\n+bb_then:\n+  call void @bar()\n+  br label %bb_exit\n+\n+bb_else:\n+  %cmp2 = icmp slt i32 %arg, 17\n+  br label %bb_exit\n+\n+; CHECK:       bb_exit:\n+; CHECK-NEXT:    [[PHI1:%.*]] = phi i1 [ [[CMP2:%.*]], [[BB_ELSE:%.*]] ], [ undef, [[BB_THEN:%.*]] ]\n+; CHECK-NEXT:    [[XOR1:%.*]] = xor i1 [[CMP1:%.*]], true\n+; CHECK-NEXT:    [[AND1:%.*]] = and i1 [[PHI1]], [[XOR1]]\n+; CHECK-NEXT:    ret i1 [[AND1]]\n+bb_exit:\n+  %phi1 = phi i1 [ %cmp2, %bb_else ], [ undef, %bb_then ]\n+  %xor1 = xor i1 %cmp1, true\n+  %and1 = and i1 %phi1, %xor1\n+  ret i1 %and1\n+}\n+\n+declare void @bar()"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/dont-distribute-phi.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/dont-distribute-phi.ll\n\n\nTesting Time: 0.25s\n  Failed: 1\n"
    },
    "de3cb9548d77726186db2d384193e0565cb0afc5___LoopIdiomRecognize.cpp": {
        "start": 449,
        "end": 556,
        "buggy": "LoopIdiomRecognize::LegalStoreKind\nLoopIdiomRecognize::isLegalStore(StoreInst *SI) {\n  // Don't touch volatile stores.\n  if (SI->isVolatile())\n    return LegalStoreKind::None;\n  // We only want simple or unordered-atomic stores.\n  if (!SI->isUnordered())\n    return LegalStoreKind::None;\n\n  // Don't convert stores of non-integral pointer types to memsets (which stores\n  // integers).\n  if (DL->isNonIntegralPointerType(SI->getValueOperand()->getType()))\n    return LegalStoreKind::None;\n\n  // Avoid merging nontemporal stores.\n  if (SI->getMetadata(LLVMContext::MD_nontemporal))\n    return LegalStoreKind::None;\n\n  Value *StoredVal = SI->getValueOperand();\n  Value *StorePtr = SI->getPointerOperand();\n\n  // Reject stores that are so large that they overflow an unsigned.\n  // When storing out scalable vectors we bail out for now, since the code\n  // below currently only works for constant strides.\n  TypeSize SizeInBits = DL->getTypeSizeInBits(StoredVal->getType());\n  if (SizeInBits.isScalable() || (SizeInBits.getFixedSize() & 7) ||\n      (SizeInBits.getFixedSize() >> 32) != 0)\n    return LegalStoreKind::None;\n\n  // See if the pointer expression is an AddRec like {base,+,1} on the current\n  // loop, which indicates a strided store.  If we have something else, it's a\n  // random store we can't handle.\n  const SCEVAddRecExpr *StoreEv =\n      dyn_cast<SCEVAddRecExpr>(SE->getSCEV(StorePtr));\n  if (!StoreEv || StoreEv->getLoop() != CurLoop || !StoreEv->isAffine())\n    return LegalStoreKind::None;\n\n  // Check to see if we have a constant stride.\n  if (!isa<SCEVConstant>(StoreEv->getOperand(1)))\n    return LegalStoreKind::None;\n\n  // See if the store can be turned into a memset.\n\n  // If the stored value is a byte-wise value (like i32 -1), then it may be\n  // turned into a memset of i8 -1, assuming that all the consecutive bytes\n  // are stored.  A store of i32 0x01020304 can never be turned into a memset,\n  // but it can be turned into memset_pattern if the target supports it.\n  Value *SplatValue = isBytewiseValue(StoredVal, *DL);\n  Constant *PatternValue = nullptr;\n\n  // Note: memset and memset_pattern on unordered-atomic is yet not supported\n  bool UnorderedAtomic = SI->isUnordered() && !SI->isSimple();\n\n  // If we're allowed to form a memset, and the stored value would be\n  // acceptable for memset, use it.\n  if (!UnorderedAtomic && HasMemset && SplatValue && !DisableLIRP::Memset &&\n      // Verify that the stored value is loop invariant.  If not, we can't\n      // promote the memset.\n      CurLoop->isLoopInvariant(SplatValue)) {\n    // It looks like we can use SplatValue.\n    return LegalStoreKind::Memset;\n  } else if (!UnorderedAtomic && HasMemsetPattern && !DisableLIRP::Memset &&\n             // Don't create memset_pattern16s with address spaces.\n             StorePtr->getType()->getPointerAddressSpace() == 0 &&\n             (PatternValue = getMemSetPatternValue(StoredVal, DL))) {\n    // It looks like we can use PatternValue!\n    return LegalStoreKind::MemsetPattern;\n  }\n\n  // Otherwise, see if the store can be turned into a memcpy.\n  if (HasMemcpy && !DisableLIRP::Memcpy) {\n    // Check to see if the stride matches the size of the store.  If so, then we\n    // know that every byte is touched in the loop.\n    APInt Stride = getStoreStride(StoreEv);\n    unsigned StoreSize = DL->getTypeStoreSize(SI->getValueOperand()->getType());\n    if (StoreSize != Stride && StoreSize != -Stride)\n      return LegalStoreKind::None;\n\n    // The store must be feeding a non-volatile load.\n    LoadInst *LI = dyn_cast<LoadInst>(SI->getValueOperand());\n\n    // Only allow non-volatile loads\n    if (!LI || LI->isVolatile())\n      return LegalStoreKind::None;\n    // Only allow simple or unordered-atomic loads\n    if (!LI->isUnordered())\n      return LegalStoreKind::None;\n\n    // See if the pointer expression is an AddRec like {base,+,1} on the current\n    // loop, which indicates a strided load.  If we have something else, it's a\n    // random load we can't handle.\n    const SCEVAddRecExpr *LoadEv =\n        dyn_cast<SCEVAddRecExpr>(SE->getSCEV(LI->getPointerOperand()));\n    if (!LoadEv || LoadEv->getLoop() != CurLoop || !LoadEv->isAffine())\n      return LegalStoreKind::None;\n\n    // The store and load must share the same stride.\n    if (StoreEv->getOperand(1) != LoadEv->getOperand(1))\n      return LegalStoreKind::None;\n\n    // Success.  This store can be converted into a memcpy.\n    UnorderedAtomic = UnorderedAtomic || LI->isAtomic();\n    return UnorderedAtomic ? LegalStoreKind::UnorderedAtomicMemcpy\n                           : LegalStoreKind::Memcpy;\n  }\n  // This store can't be transformed into a memset/memcpy.\n  return LegalStoreKind::None;\n}\n",
        "fix": null,
        "src_path": "de3cb9548d77726186db2d384193e0565cb0afc5___LoopIdiomRecognize.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/de3cb9548d77726186db2d384193e0565cb0afc5",
        "commit_msg": "Fix a bug in memset formation with vectors of non-integral pointers\n\nWe were converting the non-integral store into a integer store which is not legal.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/LoopIdiom/non-integral-pointers.ll",
                "patch": "@@ -3,13 +3,12 @@\n target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128-ni:4\"\n target triple = \"x86_64-unknown-linux-gnu\"\n \n+; LIR'ing stores of pointers with address space 3 is fine, since\n+; they're integral pointers.\n define void @f_0(i8 addrspace(3)** %ptr) {\n ; CHECK-LABEL: @f_0(\n ; CHECK: call{{.*}}memset\n \n-; LIR'ing stores of pointers with address space 3 is fine, since\n-; they're integral pointers.\n-\n entry:\n   br label %for.body\n \n@@ -25,13 +24,14 @@ for.end:\n   ret void\n }\n \n+; LIR'ing stores of pointers with address space 4 is not ok, since\n+; they're non-integral pointers. NOTE: Zero is special value which\n+; can be converted, if we add said handling here, convert this test\n+; to use any non-null pointer.\n define void @f_1(i8 addrspace(4)** %ptr) {\n ; CHECK-LABEL: @f_1(\n ; CHECK-NOT: call{{.*}}memset\n \n-; LIR'ing stores of pointers with address space 4 is not ok, since\n-; they're non-integral pointers.\n-\n entry:\n   br label %for.body\n \n@@ -46,3 +46,23 @@ for.body:\n for.end:\n   ret void\n }\n+\n+; Same as previous case, but vector of non-integral pointers\n+define void @f_2(i8 addrspace(4)** %ptr) {\n+; CHECK-LABEL: @f_2(\n+; CHECK-NOT: call{{.*}}memset\n+entry:\n+  br label %for.body\n+\n+for.body:\n+  %indvar = phi i64 [ 0, %entry ], [ %indvar.next, %for.body ]\n+  %arrayidx = getelementptr i8 addrspace(4)*, i8 addrspace(4)** %ptr, i64 %indvar\n+  %addr = bitcast i8 addrspace(4)** %arrayidx to <2 x i8 addrspace(4)*>*\n+  store <2 x i8 addrspace(4)*> zeroinitializer, <2 x i8 addrspace(4)*>* %addr, align 8\n+  %indvar.next = add i64 %indvar, 2\n+  %exitcond = icmp eq i64 %indvar.next, 10000\n+  br i1 %exitcond, label %for.end, label %for.body\n+\n+for.end:\n+  ret void\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/LoopIdiom/non-integral-pointers.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopIdiom/non-integral-pointers.ll\n\n\nTesting Time: 0.31s\n  Failed: 1\n"
    },
    "00928a1956a1618f394ffe99fc63b0d81e1f88c7___SROA.cpp": {
        "start": 3522,
        "end": 3568,
        "buggy": "  bool foldGEPPhi(GetElementPtrInst &GEPI) {\n    if (!GEPI.hasAllConstantIndices())\n      return false;\n\n    PHINode *PHI = cast<PHINode>(GEPI.getPointerOperand());\n    if (GEPI.getParent() != PHI->getParent() ||\n        llvm::any_of(PHI->incoming_values(), [](Value *In)\n          { Instruction *I = dyn_cast<Instruction>(In);\n            return !I || isa<GetElementPtrInst>(I) || isa<PHINode>(I) ||\n                   succ_empty(I->getParent()) ||\n                   !I->getParent()->isLegalToHoistInto();\n          }))\n      return false;\n\n    LLVM_DEBUG(dbgs() << \"  Rewriting gep(phi) -> phi(gep):\"\n                      << \"\\n    original: \" << *PHI\n                      << \"\\n              \" << GEPI\n                      << \"\\n          to: \");\n\n    SmallVector<Value *, 4> Index(GEPI.idx_begin(), GEPI.idx_end());\n    bool IsInBounds = GEPI.isInBounds();\n    IRBuilderTy PHIBuilder(GEPI.getParent()->getFirstNonPHI());\n    PHINode *NewPN = PHIBuilder.CreatePHI(GEPI.getType(),\n                                          PHI->getNumIncomingValues(),\n                                          PHI->getName() + \".sroa.phi\");\n    for (unsigned I = 0, E = PHI->getNumIncomingValues(); I != E; ++I) {\n      Instruction *In = cast<Instruction>(PHI->getIncomingValue(I));\n\n      IRBuilderTy B(In->getParent(), std::next(In->getIterator()));\n      Value *NewVal = IsInBounds\n          ? B.CreateInBoundsGEP(In, Index, In->getName() + \".sroa.gep\")\n          : B.CreateGEP(In, Index, In->getName() + \".sroa.gep\");\n      NewPN->addIncoming(NewVal, PHI->getIncomingBlock(I));\n    }\n\n    Visited.erase(&GEPI);\n    GEPI.replaceAllUsesWith(NewPN);\n    GEPI.eraseFromParent();\n    Visited.insert(NewPN);\n    enqueueUsers(*NewPN);\n\n    LLVM_DEBUG(for (Value *In : NewPN->incoming_values())\n                 dbgs() << \"\\n              \" << *In;\n               dbgs() << \"\\n              \" << *NewPN << '\\n');\n\n    return true;\n  }\n",
        "fix": null,
        "src_path": "00928a1956a1618f394ffe99fc63b0d81e1f88c7___SROA.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/00928a1956a1618f394ffe99fc63b0d81e1f88c7",
        "commit_msg": "Fix SROA with a PHI mergig values from a same block\n\nThis fixes the bug 47945. It is legal to have a PHI with values\nfrom from the same block, but values must stay the same. In this\ncase it is illegal to merge different values.\n\nDifferential Revision: https://reviews.llvm.org/D89978",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/SROA/phi-gep.ll",
                "patch": "@@ -452,6 +452,75 @@ bb2:\n   ret void\n }\n \n+define void @constant_value_phi() {\n+; CHECK-LABEL: @constant_value_phi(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    br label [[LAND_LHS_TRUE_I:%.*]]\n+; CHECK:       land.lhs.true.i:\n+; CHECK-NEXT:    br i1 undef, label [[COND_END_I:%.*]], label [[COND_END_I]]\n+; CHECK:       cond.end.i:\n+; CHECK-NEXT:    unreachable\n+;\n+entry:\n+  %s1 = alloca [3 x i16]\n+  %s = alloca [3 x i16]\n+  %cast = bitcast [3 x i16]* %s1 to i16*\n+  br label %land.lhs.true.i\n+\n+land.lhs.true.i:                                  ; preds = %entry\n+  br i1 undef, label %cond.end.i, label %cond.end.i\n+\n+cond.end.i:                                       ; preds = %land.lhs.true.i, %land.lhs.true.i\n+  %.pre-phi1 = phi i16* [ %cast, %land.lhs.true.i ], [ %cast, %land.lhs.true.i ]\n+  %cast2 = bitcast [3 x i16]* %s to i16*\n+  call void @llvm.memcpy.p0i16.p0i16.i64(i16* %.pre-phi1, i16* %cast2, i64 3, i1 false)\n+  %gep = getelementptr inbounds [3 x i16], [3 x i16]* %s, i32 0, i32 0\n+  %load = load i16, i16* %gep\n+  unreachable\n+}\n+\n+define i32 @test_sroa_phi_gep_multiple_values_from_same_block(i32 %arg) {\n+; CHECK-LABEL: @test_sroa_phi_gep_multiple_values_from_same_block(\n+; CHECK-NEXT:  bb.1:\n+; CHECK-NEXT:    switch i32 [[ARG:%.*]], label [[BB_3:%.*]] [\n+; CHECK-NEXT:    i32 1, label [[BB_2:%.*]]\n+; CHECK-NEXT:    i32 2, label [[BB_2]]\n+; CHECK-NEXT:    i32 3, label [[BB_4:%.*]]\n+; CHECK-NEXT:    i32 4, label [[BB_4]]\n+; CHECK-NEXT:    ]\n+; CHECK:       bb.2:\n+; CHECK-NEXT:    br label [[BB_4]]\n+; CHECK:       bb.3:\n+; CHECK-NEXT:    br label [[BB_4]]\n+; CHECK:       bb.4:\n+; CHECK-NEXT:    [[PHI_SROA_PHI_SROA_SPECULATED:%.*]] = phi i32 [ undef, [[BB_3]] ], [ undef, [[BB_2]] ], [ undef, [[BB_1:%.*]] ], [ undef, [[BB_1]] ]\n+; CHECK-NEXT:    ret i32 [[PHI_SROA_PHI_SROA_SPECULATED]]\n+;\n+bb.1:\n+  %a = alloca %pair, align 4\n+  %b = alloca %pair, align 4\n+  switch i32 %arg, label %bb.3 [\n+  i32 1, label %bb.2\n+  i32 2, label %bb.2\n+  i32 3, label %bb.4\n+  i32 4, label %bb.4\n+  ]\n+\n+bb.2:                                                ; preds = %bb.1, %bb.1\n+  br label %bb.4\n+\n+bb.3:                                                ; preds = %bb.1\n+  br label %bb.4\n+\n+bb.4:                                                ; preds = %bb.1, %bb.1, %bb.3, %bb.2\n+  %phi = phi %pair* [ %a, %bb.3 ], [ %a, %bb.2 ], [ %b, %bb.1 ], [ %b, %bb.1 ]\n+  %gep = getelementptr inbounds %pair, %pair* %phi, i32 0, i32 1\n+  %load = load i32, i32* %gep, align 4\n+  ret i32 %load\n+}\n+\n declare %pair* @foo()\n \n declare i32 @__gxx_personality_v0(...)\n+\n+declare void @llvm.memcpy.p0i16.p0i16.i64(i16* noalias nocapture writeonly, i16* noalias nocapture readonly, i64, i1 immarg)"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/SROA/phi-gep.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SROA/phi-gep.ll\n\n\nTesting Time: 1.41s\n  Failed: 1\n"
    },
    "6d5132b426fbe23c5bc3e591ca2ca09a315d459b___SampleProfile.cpp": {
        "start": 837,
        "end": 896,
        "buggy": "bool SampleProfileLoader::tryPromoteAndInlineCandidate(\n    Function &F, InlineCandidate &Candidate, uint64_t SumOrigin, uint64_t &Sum,\n    SmallVector<CallBase *, 8> *InlinedCallSite) {\n  auto CalleeFunctionName = Candidate.CalleeSamples->getFuncName();\n  auto R = SymbolMap.find(CalleeFunctionName);\n  if (R == SymbolMap.end() || !R->getValue())\n    return false;\n\n  auto &CI = *Candidate.CallInstr;\n  if (!doesHistoryAllowICP(CI, R->getValue()->getName()))\n    return false;\n\n  const char *Reason = \"Callee function not available\";\n  // R->getValue() != &F is to prevent promoting a recursive call.\n  // If it is a recursive call, we do not inline it as it could bloat\n  // the code exponentially. There is way to better handle this, e.g.\n  // clone the caller first, and inline the cloned caller if it is\n  // recursive. As llvm does not inline recursive calls, we will\n  // simply ignore it instead of handling it explicitly.\n  if (!R->getValue()->isDeclaration() && R->getValue()->getSubprogram() &&\n      R->getValue()->hasFnAttribute(\"use-sample-profile\") &&\n      R->getValue() != &F && isLegalToPromote(CI, R->getValue(), &Reason)) {\n    // For promoted target, set its value with NOMORE_ICP_MAGICNUM count\n    // in the value profile metadata so the target won't be promoted again.\n    SmallVector<InstrProfValueData, 1> SortedCallTargets = {InstrProfValueData{\n        Function::getGUID(R->getValue()->getName()), NOMORE_ICP_MAGICNUM}};\n    updateIDTMetaData(CI, SortedCallTargets, 0);\n\n    auto *DI = &pgo::promoteIndirectCall(\n        CI, R->getValue(), Candidate.CallsiteCount, Sum, false, ORE);\n    if (DI) {\n      Sum -= Candidate.CallsiteCount;\n      // Prorate the indirect callsite distribution.\n      // Do not update the promoted direct callsite distribution at this\n      // point since the original distribution combined with the callee\n      // profile will be used to prorate callsites from the callee if\n      // inlined. Once not inlined, the direct callsite distribution should\n      // be prorated so that the it will reflect the real callsite counts.\n      setProbeDistributionFactor(CI, Candidate.CallsiteDistribution * Sum /\n                                         SumOrigin);\n      Candidate.CallInstr = DI;\n      if (isa<CallInst>(DI) || isa<InvokeInst>(DI)) {\n        bool Inlined = tryInlineCandidate(Candidate, InlinedCallSite);\n        if (!Inlined) {\n          // Prorate the direct callsite distribution so that it reflects real\n          // callsite counts.\n          setProbeDistributionFactor(*DI, Candidate.CallsiteDistribution *\n                                              Candidate.CallsiteCount /\n                                              SumOrigin);\n        }\n        return Inlined;\n      }\n    }\n  } else {\n    LLVM_DEBUG(dbgs() << \"\\nFailed to promote indirect call to \"\n                      << Candidate.CalleeSamples->getFuncName() << \" because \"\n                      << Reason << \"\\n\");\n  }\n  return false;\n}\n",
        "fix": null,
        "src_path": "6d5132b426fbe23c5bc3e591ca2ca09a315d459b___SampleProfile.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/6d5132b426fbe23c5bc3e591ca2ca09a315d459b",
        "commit_msg": "[CSSPGO] Fix incorrect probe distribution factor computation in top-down inliner\n\nWe see a regression related to low probe factor(0.01) which prevents some callsites being promoted in ICPPass and later cause the missing inline in CGSCC inliner. The root cause is due to redundant(the second) multiplication of the probe factor and this change try to fix it.\n\n`Sum` does multiply a factor right after findCallSamples but later when using as the parameter in setProbeDistributionFactor, it multiplies one again.\n\nThis change could get ~2% perf back on mcf benchmark. In mcf, previously the corresponding factor is 1 and it's the recent feature introducing the <1 factor then trigger this bug.\n\nReviewed By: hoy, wenlei\n\nDifferential Revision: https://reviews.llvm.org/D99787",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/SampleProfile/Inputs/pseudo-probe-icp-factor.prof",
                "patch": "@@ -0,0 +1,18 @@\n+[main]:1059900:0\n+ 2: 224540\n+ 4: 224540\n+ 7: 193140\n+ 8: 224540\n+ 10: 193140 foo:193140\n+ !CFGChecksum: 563125815542069\n+[main:10 @ foo]:386280:193140\n+ 1: 193140\n+ 2: 193140 baz:171881 bar:11259\n+ !CFGChecksum: 281479271677951\n+[main:10 @ foo:2 @ baz]:171881:171881\n+ 1: 101881\n+ 2: 12344\n+ !CFGChecksum: 4294967295\n+[main:10 @ foo:2 @ bar]:11259:11259\n+ 1: 11259\n+ !CFGChecksum: 4294967295"
            },
            {
                "fn": "llvm/test/Transforms/SampleProfile/pseudo-probe-icp-factor.ll",
                "patch": "@@ -0,0 +1,252 @@\n+; RUN: opt < %s -passes=sample-profile -sample-profile-file=%S/Inputs/pseudo-probe-icp-factor.prof -S -sample-profile-prioritized-inline=1 2>&1 | FileCheck %s\n+\n+target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n+target triple = \"x86_64-unknown-linux-gnu\"\n+\n+@.str = private unnamed_addr constant [4 x i8] c\"%d\\0A\\00\", align 1\n+\n+; Function Attrs: nounwind uwtable\n+define dso_local i32 @bar(i32 %0) #0 !dbg !13 {\n+  %2 = alloca i32, align 4\n+  store i32 %0, i32* %2, align 4, !tbaa !19\n+  call void @llvm.dbg.declare(metadata i32* %2, metadata !18, metadata !DIExpression()), !dbg !23\n+  call void @llvm.pseudoprobe(i64 -2012135647395072713, i64 1, i32 0, i64 -1), !dbg !24\n+  %3 = load i32, i32* %2, align 4, !dbg !24, !tbaa !19\n+  %4 = add nsw i32 %3, 1, !dbg !24\n+  store i32 %4, i32* %2, align 4, !dbg !24, !tbaa !19\n+  %5 = load i32, i32* %2, align 4, !dbg !25, !tbaa !19\n+  %6 = add nsw i32 %5, 1, !dbg !26\n+  ret i32 %6, !dbg !27\n+}\n+\n+; Function Attrs: nofree nosync nounwind readnone speculatable willreturn\n+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1\n+\n+; Function Attrs: nounwind uwtable\n+define dso_local i32 @baz(i32 %0) #0 !dbg !28 {\n+  %2 = alloca i32, align 4\n+  store i32 %0, i32* %2, align 4, !tbaa !19\n+  call void @llvm.dbg.declare(metadata i32* %2, metadata !30, metadata !DIExpression()), !dbg !31\n+  call void @llvm.pseudoprobe(i64 7546896869197086323, i64 1, i32 0, i64 -1), !dbg !32\n+  %3 = load i32, i32* %2, align 4, !dbg !32, !tbaa !19\n+  %4 = add nsw i32 %3, 10, !dbg !33\n+  ret i32 %4, !dbg !34\n+}\n+\n+; Function Attrs: nounwind uwtable\n+define dso_local i32 @foo(i32 %0, i32 (...)* %1) #0 !dbg !35 {\n+  %3 = alloca i32, align 4\n+  %4 = alloca i32 (...)*, align 8\n+  store i32 %0, i32* %3, align 4, !tbaa !19\n+  call void @llvm.dbg.declare(metadata i32* %3, metadata !42, metadata !DIExpression()), !dbg !44\n+  store i32 (...)* %1, i32 (...)** %4, align 8, !tbaa !45\n+  call void @llvm.dbg.declare(metadata i32 (...)** %4, metadata !43, metadata !DIExpression()), !dbg !47\n+  call void @llvm.pseudoprobe(i64 6699318081062747564, i64 1, i32 0, i64 -1), !dbg !48\n+  %5 = load i32 (...)*, i32 (...)** %4, align 8, !dbg !48, !tbaa !45\n+  %6 = load i32, i32* %3, align 4, !dbg !49, !tbaa !19\n+  %7 = bitcast i32 (...)* %5 to i32 (i32, ...)*, !dbg !48\n+  %8 = call i32 (i32, ...) %7(i32 %6), !dbg !50\n+  ret i32 %8, !dbg !52\n+}\n+\n+; Function Attrs: nounwind uwtable\n+define dso_local i32 @main() #0 !dbg !53 {\n+  %1 = alloca i32, align 4\n+  %2 = alloca i32 (i32)*, align 8\n+  %3 = alloca i32, align 4\n+  %4 = alloca i32, align 4\n+  store i32 0, i32* %1, align 4\n+  call void @llvm.pseudoprobe(i64 -2624081020897602054, i64 1, i32 0, i64 -1), !dbg !62\n+  %5 = bitcast i32 (i32)** %2 to i8*, !dbg !62\n+  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #5, !dbg !62\n+  call void @llvm.dbg.declare(metadata i32 (i32)** %2, metadata !57, metadata !DIExpression()), !dbg !63\n+  %6 = bitcast i32* %3 to i8*, !dbg !64\n+  call void @llvm.lifetime.start.p0i8(i64 4, i8* %6) #5, !dbg !64\n+  call void @llvm.dbg.declare(metadata i32* %3, metadata !59, metadata !DIExpression()), !dbg !65\n+  store i32 0, i32* %3, align 4, !dbg !65, !tbaa !19\n+  %7 = bitcast i32* %4 to i8*, !dbg !66\n+  call void @llvm.lifetime.start.p0i8(i64 4, i8* %7) #5, !dbg !66\n+  call void @llvm.dbg.declare(metadata i32* %4, metadata !60, metadata !DIExpression()), !dbg !67\n+  store i32 0, i32* %4, align 4, !dbg !67, !tbaa !19\n+  br label %8, !dbg !66\n+\n+8:                                                ; preds = %26, %0\n+  call void @llvm.pseudoprobe(i64 -2624081020897602054, i64 2, i32 0, i64 -1), !dbg !68\n+  %9 = load i32, i32* %4, align 4, !dbg !68, !tbaa !19\n+  %10 = icmp slt i32 %9, 1000000000, !dbg !70\n+  br i1 %10, label %13, label %11, !dbg !71\n+\n+11:                                               ; preds = %8\n+  call void @llvm.pseudoprobe(i64 -2624081020897602054, i64 3, i32 0, i64 -1), !dbg !72\n+  %12 = bitcast i32* %4 to i8*, !dbg !72\n+  call void @llvm.lifetime.end.p0i8(i64 4, i8* %12) #5, !dbg !72\n+  br label %29\n+\n+13:                                               ; preds = %8\n+  call void @llvm.pseudoprobe(i64 -2624081020897602054, i64 4, i32 0, i64 -1), !dbg !73\n+  %14 = load i32, i32* %4, align 4, !dbg !73, !tbaa !19\n+  %15 = srem i32 %14, 100, !dbg !76\n+  %16 = icmp eq i32 %15, 0, !dbg !77\n+  br i1 %16, label %17, label %18, !dbg !78\n+\n+17:                                               ; preds = %13\n+  call void @llvm.pseudoprobe(i64 -2624081020897602054, i64 5, i32 0, i64 -1), !dbg !79\n+  store i32 (i32)* @bar, i32 (i32)** %2, align 8, !dbg !79, !tbaa !45\n+  br label %19, !dbg !80\n+\n+18:                                               ; preds = %13\n+  call void @llvm.pseudoprobe(i64 -2624081020897602054, i64 6, i32 0, i64 -1), !dbg !81\n+  store i32 (i32)* @baz, i32 (i32)** %2, align 8, !dbg !81, !tbaa !45\n+  br label %19\n+\n+19:                                               ; preds = %18, %17\n+  call void @llvm.pseudoprobe(i64 -2624081020897602054, i64 7, i32 0, i64 -1), !dbg !82\n+  %20 = load i32, i32* %4, align 4, !dbg !82, !tbaa !19\n+  %21 = load i32 (i32)*, i32 (i32)** %2, align 8, !dbg !83, !tbaa !45\n+  %22 = bitcast i32 (i32)* %21 to i32 (...)*, !dbg !83\n+  %23 = call i32 @foo(i32 %20, i32 (...)* %22), !dbg !84\n+  %24 = load i32, i32* %3, align 4, !dbg !86, !tbaa !19\n+  %25 = add nsw i32 %24, %23, !dbg !86\n+  store i32 %25, i32* %3, align 4, !dbg !86, !tbaa !19\n+  br label %26, !dbg !87\n+\n+26:                                               ; preds = %19\n+  call void @llvm.pseudoprobe(i64 -2624081020897602054, i64 8, i32 0, i64 -1), !dbg !88\n+  %27 = load i32, i32* %4, align 4, !dbg !88, !tbaa !19\n+  %28 = add nsw i32 %27, 1, !dbg !88\n+  store i32 %28, i32* %4, align 4, !dbg !88, !tbaa !19\n+  br label %8, !dbg !72, !llvm.loop !89\n+\n+29:                                               ; preds = %11\n+  call void @llvm.pseudoprobe(i64 -2624081020897602054, i64 9, i32 0, i64 -1), !dbg !92\n+  %30 = load i32, i32* %3, align 4, !dbg !92, !tbaa !19\n+  %31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 %30), !dbg !93\n+  %32 = bitcast i32* %3 to i8*, !dbg !95\n+  call void @llvm.lifetime.end.p0i8(i64 4, i8* %32) #5, !dbg !95\n+  %33 = bitcast i32 (i32)** %2 to i8*, !dbg !95\n+  call void @llvm.lifetime.end.p0i8(i64 8, i8* %33) #5, !dbg !95\n+  ret i32 0, !dbg !96\n+}\n+\n+; Function Attrs: argmemonly nofree nosync nounwind willreturn\n+declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #2\n+\n+; Function Attrs: argmemonly nofree nosync nounwind willreturn\n+declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #2\n+\n+declare dso_local i32 @printf(i8*, ...) #3\n+\n+; Function Attrs: inaccessiblememonly nounwind willreturn\n+declare void @llvm.pseudoprobe(i64, i64, i32, i64) #4\n+\n+attributes #0 = { nounwind uwtable \"disable-tail-calls\"=\"true\" \"frame-pointer\"=\"all\" \"less-precise-fpmad\"=\"false\" \"min-legal-vector-width\"=\"0\" \"no-infs-fp-math\"=\"false\" \"no-jump-tables\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" \"unsafe-fp-math\"=\"false\" \"use-sample-profile\" \"use-soft-float\"=\"false\" }\n+\n+!llvm.dbg.cu = !{!0}\n+!llvm.module.flags = !{!3, !4, !5, !6, !7}\n+!llvm.ident = !{!8}\n+!llvm.pseudo_probe_desc = !{!9, !10, !11, !12}\n+\n+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: \"clang version 13.0.06)\", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, splitDebugInlining: false, nameTableKind: None)\n+!1 = !DIFile(filename: \"test.c\", directory: \"\")\n+!2 = !{}\n+!3 = !{i32 7, !\"Dwarf Version\", i32 4}\n+!4 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!5 = !{i32 1, !\"wchar_size\", i32 4}\n+!6 = !{i32 1, !\"ThinLTO\", i32 0}\n+!7 = !{i32 1, !\"EnableSplitLTOUnit\", i32 1}\n+!8 = !{!\"clang version 13.0.0 \"}\n+!9 = !{i64 -2012135647395072713, i64 4294967295, !\"bar\", null}\n+!10 = !{i64 7546896869197086323, i64 4294967295, !\"baz\", null}\n+!11 = !{i64 6699318081062747564, i64 281479271677951, !\"foo\", null}\n+!12 = !{i64 -2624081020897602054, i64 563125815542069, !\"main\", null}\n+!13 = distinct !DISubprogram(name: \"bar\", scope: !1, file: !1, line: 2, type: !14, scopeLine: 3, flags: DIFlagPrototyped | DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !17)\n+!14 = !DISubroutineType(types: !15)\n+!15 = !{!16, !16}\n+!16 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n+!17 = !{!18}\n+!18 = !DILocalVariable(name: \"x\", arg: 1, scope: !13, file: !1, line: 2, type: !16)\n+!19 = !{!20, !20, i64 0}\n+!20 = !{!\"int\", !21, i64 0}\n+!21 = !{!\"omnipotent char\", !22, i64 0}\n+!22 = !{!\"Simple C/C++ TBAA\"}\n+!23 = !DILocation(line: 2, column: 13, scope: !13)\n+!24 = !DILocation(line: 4, column: 7, scope: !13)\n+!25 = !DILocation(line: 5, column: 12, scope: !13)\n+!26 = !DILocation(line: 5, column: 14, scope: !13)\n+!27 = !DILocation(line: 5, column: 5, scope: !13)\n+!28 = distinct !DISubprogram(name: \"baz\", scope: !1, file: !1, line: 9, type: !14, scopeLine: 9, flags: DIFlagPrototyped | DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !29)\n+!29 = !{!30}\n+!30 = !DILocalVariable(name: \"x\", arg: 1, scope: !28, file: !1, line: 9, type: !16)\n+!31 = !DILocation(line: 9, column: 13, scope: !28)\n+!32 = !DILocation(line: 10, column: 10, scope: !28)\n+!33 = !DILocation(line: 10, column: 12, scope: !28)\n+!34 = !DILocation(line: 10, column: 3, scope: !28)\n+!35 = distinct !DISubprogram(name: \"foo\", scope: !1, file: !1, line: 13, type: !36, scopeLine: 13, flags: DIFlagPrototyped | DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !41)\n+!36 = !DISubroutineType(types: !37)\n+!37 = !{!16, !16, !38}\n+!38 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !39, size: 64)\n+!39 = !DISubroutineType(types: !40)\n+!40 = !{!16, null}\n+!41 = !{!42, !43}\n+!42 = !DILocalVariable(name: \"x\", arg: 1, scope: !35, file: !1, line: 13, type: !16)\n+!43 = !DILocalVariable(name: \"f\", arg: 2, scope: !35, file: !1, line: 13, type: !38)\n+!44 = !DILocation(line: 13, column: 13, scope: !35)\n+!45 = !{!46, !46, i64 0}\n+!46 = !{!\"any pointer\", !21, i64 0}\n+!47 = !DILocation(line: 13, column: 22, scope: !35)\n+!48 = !DILocation(line: 14, column: 10, scope: !35)\n+!49 = !DILocation(line: 14, column: 12, scope: !35)\n+!50 = !DILocation(line: 14, column: 10, scope: !51)\n+!51 = !DILexicalBlockFile(scope: !35, file: !1, discriminator: 108527639)\n+!52 = !DILocation(line: 14, column: 3, scope: !35)\n+!53 = distinct !DISubprogram(name: \"main\", scope: !1, file: !1, line: 17, type: !54, scopeLine: 18, flags: DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !56)\n+!54 = !DISubroutineType(types: !55)\n+!55 = !{!16}\n+!56 = !{!57, !59, !60}\n+!57 = !DILocalVariable(name: \"x\", scope: !53, file: !1, line: 19, type: !58)\n+!58 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !14, size: 64)\n+!59 = !DILocalVariable(name: \"sum\", scope: !53, file: !1, line: 25, type: !16)\n+!60 = !DILocalVariable(name: \"i\", scope: !61, file: !1, line: 26, type: !16)\n+!61 = distinct !DILexicalBlock(scope: !53, file: !1, line: 26, column: 5)\n+!62 = !DILocation(line: 19, column: 3, scope: !53)\n+!63 = !DILocation(line: 19, column: 9, scope: !53)\n+!64 = !DILocation(line: 25, column: 5, scope: !53)\n+!65 = !DILocation(line: 25, column: 9, scope: !53)\n+!66 = !DILocation(line: 26, column: 10, scope: !61)\n+!67 = !DILocation(line: 26, column: 14, scope: !61)\n+!68 = !DILocation(line: 26, column: 21, scope: !69)\n+!69 = distinct !DILexicalBlock(scope: !61, file: !1, line: 26, column: 5)\n+!70 = !DILocation(line: 26, column: 23, scope: !69)\n+!71 = !DILocation(line: 26, column: 5, scope: !61)\n+!72 = !DILocation(line: 26, column: 5, scope: !69)\n+!73 = !DILocation(line: 27, column: 10, scope: !74)\n+!74 = distinct !DILexicalBlock(scope: !75, file: !1, line: 27, column: 10)\n+!75 = distinct !DILexicalBlock(scope: !69, file: !1, line: 26, column: 45)\n+!76 = !DILocation(line: 27, column: 12, scope: !74)\n+!77 = !DILocation(line: 27, column: 19, scope: !74)\n+!78 = !DILocation(line: 27, column: 10, scope: !75)\n+!79 = !DILocation(line: 28, column: 11, scope: !74)\n+!80 = !DILocation(line: 28, column: 9, scope: !74)\n+!81 = !DILocation(line: 30, column: 11, scope: !74)\n+!82 = !DILocation(line: 32, column: 17, scope: !75)\n+!83 = !DILocation(line: 32, column: 20, scope: !75)\n+!84 = !DILocation(line: 32, column: 13, scope: !85)\n+!85 = !DILexicalBlockFile(scope: !75, file: !1, discriminator: 116916311)\n+!86 = !DILocation(line: 32, column: 11, scope: !75)\n+!87 = !DILocation(line: 33, column: 5, scope: !75)\n+!88 = !DILocation(line: 26, column: 41, scope: !69)\n+!89 = distinct !{!89, !71, !90, !91}\n+!90 = !DILocation(line: 33, column: 5, scope: !61)\n+!91 = !{!\"llvm.loop.mustprogress\"}\n+!92 = !DILocation(line: 34, column: 21, scope: !53)\n+!93 = !DILocation(line: 34, column: 5, scope: !94)\n+!94 = !DILexicalBlockFile(scope: !53, file: !1, discriminator: 104333335)\n+!95 = !DILocation(line: 36, column: 1, scope: !53)\n+!96 = !DILocation(line: 35, column: 5, scope: !53)\n+\n+; CHECK: %[[#]] = call i32 (i32, ...) %30(i32 %[[#]]) #[[#]], !dbg ![[#DBGID:]], !prof ![[#]]\n+\n+;; A discriminator of 69206039 which is 0x4200017 in hexdecimal, stands for an indirect call probe\n+;; with an index of 2 and probe factor of 0.04.\n+; CHECK: ![[#DBGID]] = !DILocation(line: [[#]], column: [[#]], scope: ![[#SCOPE:]], inlinedAt: ![[#]])\n+; CHECK: ![[#SCOPE]] = !DILexicalBlockFile(scope: ![[#]], file: ![[#]], discriminator: 69206039)"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/SampleProfile/pseudo-probe-icp-factor.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SampleProfile/pseudo-probe-icp-factor.ll\n\n\nTesting Time: 0.21s\n  Failed: 1\n"
    },
    "f5645ea65f0dfdef2ae9c74075cc4b44f05dcb82___LoopInterchange.cpp": {
        "start": 1488,
        "end": 1639,
        "buggy": "bool LoopInterchangeTransform::adjustLoopBranches() {\n  LLVM_DEBUG(dbgs() << \"adjustLoopBranches called\\n\");\n  std::vector<DominatorTree::UpdateType> DTUpdates;\n\n  BasicBlock *OuterLoopPreHeader = OuterLoop->getLoopPreheader();\n  BasicBlock *InnerLoopPreHeader = InnerLoop->getLoopPreheader();\n\n  assert(OuterLoopPreHeader != OuterLoop->getHeader() &&\n         InnerLoopPreHeader != InnerLoop->getHeader() && OuterLoopPreHeader &&\n         InnerLoopPreHeader && \"Guaranteed by loop-simplify form\");\n  // Ensure that both preheaders do not contain PHI nodes and have single\n  // predecessors. This allows us to move them easily. We use\n  // InsertPreHeaderForLoop to create an 'extra' preheader, if the existing\n  // preheaders do not satisfy those conditions.\n  if (isa<PHINode>(OuterLoopPreHeader->begin()) ||\n      !OuterLoopPreHeader->getUniquePredecessor())\n    OuterLoopPreHeader =\n        InsertPreheaderForLoop(OuterLoop, DT, LI, nullptr, true);\n  if (InnerLoopPreHeader == OuterLoop->getHeader())\n    InnerLoopPreHeader =\n        InsertPreheaderForLoop(InnerLoop, DT, LI, nullptr, true);\n\n  // Adjust the loop preheader\n  BasicBlock *InnerLoopHeader = InnerLoop->getHeader();\n  BasicBlock *OuterLoopHeader = OuterLoop->getHeader();\n  BasicBlock *InnerLoopLatch = InnerLoop->getLoopLatch();\n  BasicBlock *OuterLoopLatch = OuterLoop->getLoopLatch();\n  BasicBlock *OuterLoopPredecessor = OuterLoopPreHeader->getUniquePredecessor();\n  BasicBlock *InnerLoopLatchPredecessor =\n      InnerLoopLatch->getUniquePredecessor();\n  BasicBlock *InnerLoopLatchSuccessor;\n  BasicBlock *OuterLoopLatchSuccessor;\n\n  BranchInst *OuterLoopLatchBI =\n      dyn_cast<BranchInst>(OuterLoopLatch->getTerminator());\n  BranchInst *InnerLoopLatchBI =\n      dyn_cast<BranchInst>(InnerLoopLatch->getTerminator());\n  BranchInst *OuterLoopHeaderBI =\n      dyn_cast<BranchInst>(OuterLoopHeader->getTerminator());\n  BranchInst *InnerLoopHeaderBI =\n      dyn_cast<BranchInst>(InnerLoopHeader->getTerminator());\n\n  if (!OuterLoopPredecessor || !InnerLoopLatchPredecessor ||\n      !OuterLoopLatchBI || !InnerLoopLatchBI || !OuterLoopHeaderBI ||\n      !InnerLoopHeaderBI)\n    return false;\n\n  BranchInst *InnerLoopLatchPredecessorBI =\n      dyn_cast<BranchInst>(InnerLoopLatchPredecessor->getTerminator());\n  BranchInst *OuterLoopPredecessorBI =\n      dyn_cast<BranchInst>(OuterLoopPredecessor->getTerminator());\n\n  if (!OuterLoopPredecessorBI || !InnerLoopLatchPredecessorBI)\n    return false;\n  BasicBlock *InnerLoopHeaderSuccessor = InnerLoopHeader->getUniqueSuccessor();\n  if (!InnerLoopHeaderSuccessor)\n    return false;\n\n  // Adjust Loop Preheader and headers.\n  // The branches in the outer loop predecessor and the outer loop header can\n  // be unconditional branches or conditional branches with duplicates. Consider\n  // this when updating the successors.\n  updateSuccessor(OuterLoopPredecessorBI, OuterLoopPreHeader,\n                  InnerLoopPreHeader, DTUpdates, /*MustUpdateOnce=*/false);\n  // The outer loop header might or might not branch to the outer latch.\n  // We are guaranteed to branch to the inner loop preheader.\n  if (llvm::is_contained(OuterLoopHeaderBI->successors(), OuterLoopLatch))\n    updateSuccessor(OuterLoopHeaderBI, OuterLoopLatch, LoopExit, DTUpdates,\n                    /*MustUpdateOnce=*/false);\n  updateSuccessor(OuterLoopHeaderBI, InnerLoopPreHeader,\n                  InnerLoopHeaderSuccessor, DTUpdates,\n                  /*MustUpdateOnce=*/false);\n\n  // Adjust reduction PHI's now that the incoming block has changed.\n  InnerLoopHeaderSuccessor->replacePhiUsesWith(InnerLoopHeader,\n                                               OuterLoopHeader);\n\n  updateSuccessor(InnerLoopHeaderBI, InnerLoopHeaderSuccessor,\n                  OuterLoopPreHeader, DTUpdates);\n\n  // -------------Adjust loop latches-----------\n  if (InnerLoopLatchBI->getSuccessor(0) == InnerLoopHeader)\n    InnerLoopLatchSuccessor = InnerLoopLatchBI->getSuccessor(1);\n  else\n    InnerLoopLatchSuccessor = InnerLoopLatchBI->getSuccessor(0);\n\n  updateSuccessor(InnerLoopLatchPredecessorBI, InnerLoopLatch,\n                  InnerLoopLatchSuccessor, DTUpdates);\n\n\n  if (OuterLoopLatchBI->getSuccessor(0) == OuterLoopHeader)\n    OuterLoopLatchSuccessor = OuterLoopLatchBI->getSuccessor(1);\n  else\n    OuterLoopLatchSuccessor = OuterLoopLatchBI->getSuccessor(0);\n\n  updateSuccessor(InnerLoopLatchBI, InnerLoopLatchSuccessor,\n                  OuterLoopLatchSuccessor, DTUpdates);\n  updateSuccessor(OuterLoopLatchBI, OuterLoopLatchSuccessor, InnerLoopLatch,\n                  DTUpdates);\n\n  DT->applyUpdates(DTUpdates);\n  restructureLoops(OuterLoop, InnerLoop, InnerLoopPreHeader,\n                   OuterLoopPreHeader);\n\n  moveLCSSAPhis(InnerLoopLatchSuccessor, InnerLoopHeader, InnerLoopLatch,\n                OuterLoopHeader, OuterLoopLatch, InnerLoop->getExitBlock(),\n                InnerLoop, LI);\n  // For PHIs in the exit block of the outer loop, outer's latch has been\n  // replaced by Inners'.\n  OuterLoopLatchSuccessor->replacePhiUsesWith(OuterLoopLatch, InnerLoopLatch);\n\n  // Now update the reduction PHIs in the inner and outer loop headers.\n  SmallVector<PHINode *, 4> InnerLoopPHIs, OuterLoopPHIs;\n  for (PHINode &PHI : drop_begin(InnerLoopHeader->phis()))\n    InnerLoopPHIs.push_back(cast<PHINode>(&PHI));\n  for (PHINode &PHI : drop_begin(OuterLoopHeader->phis()))\n    OuterLoopPHIs.push_back(cast<PHINode>(&PHI));\n\n  auto &OuterInnerReductions = LIL.getOuterInnerReductions();\n  (void)OuterInnerReductions;\n\n  // Now move the remaining reduction PHIs from outer to inner loop header and\n  // vice versa. The PHI nodes must be part of a reduction across the inner and\n  // outer loop and all the remains to do is and updating the incoming blocks.\n  for (PHINode *PHI : OuterLoopPHIs) {\n    PHI->moveBefore(InnerLoopHeader->getFirstNonPHI());\n    assert(OuterInnerReductions.count(PHI) && \"Expected a reduction PHI node\");\n  }\n  for (PHINode *PHI : InnerLoopPHIs) {\n    PHI->moveBefore(OuterLoopHeader->getFirstNonPHI());\n    assert(OuterInnerReductions.count(PHI) && \"Expected a reduction PHI node\");\n  }\n\n  // Update the incoming blocks for moved PHI nodes.\n  OuterLoopHeader->replacePhiUsesWith(InnerLoopPreHeader, OuterLoopPreHeader);\n  OuterLoopHeader->replacePhiUsesWith(InnerLoopLatch, OuterLoopLatch);\n  InnerLoopHeader->replacePhiUsesWith(OuterLoopPreHeader, InnerLoopPreHeader);\n  InnerLoopHeader->replacePhiUsesWith(OuterLoopLatch, InnerLoopLatch);\n\n  // Values defined in the outer loop header could be used in the inner loop\n  // latch. In that case, we need to create LCSSA phis for them, because after\n  // interchanging they will be defined in the new inner loop and used in the\n  // new outer loop.\n  IRBuilder<> Builder(OuterLoopHeader->getContext());\n  SmallVector<Instruction *, 4> MayNeedLCSSAPhis;\n  for (Instruction &I :\n       make_range(OuterLoopHeader->begin(), std::prev(OuterLoopHeader->end())))\n    MayNeedLCSSAPhis.push_back(&I);\n  formLCSSAForInstructions(MayNeedLCSSAPhis, *DT, *LI, SE, Builder);\n\n  return true;\n}\n",
        "fix": null,
        "src_path": "f5645ea65f0dfdef2ae9c74075cc4b44f05dcb82___LoopInterchange.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/f5645ea65f0dfdef2ae9c74075cc4b44f05dcb82",
        "commit_msg": "[LoopInterchange] Fix transformation bugs in loop interchange\n\nAfter loop interchange, the (old) outer loop header should not jump to\n`LoopExit`. Note that the old outer loop becomes the new inner loop\nafter interchange. If we branched to `LoopExit` then after interchange\nwe would jump directly from the (new) inner loop header to `LoopExit`\nwithout executing the rest of (new) outer loop.\n\nThis patch modifies adjustLoopBranches() such that the old outer\nloop header (which becomes the new inner loop header) jumps to the\nold inner loop latch which becomes the new outer loop latch after\ninterchange.\n\nReviewed By: bmahjour\n\nDifferential Revision: https://reviews.llvm.org/D98475",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/LoopInterchange/lcssa-preheader.ll",
                "patch": "@@ -25,12 +25,12 @@ define void @lcssa_08(i32 %n, i32 %m) {\n ; CHECK-NEXT:    [[INDVARS_IV27:%.*]] = phi i64 [ 0, [[OUTER_PREHEADER:%.*]] ], [ [[INDVARS_IV_NEXT28:%.*]], [[OUTER_LATCH:%.*]] ]\n ; CHECK-NEXT:    [[CMP222:%.*]] = icmp sgt i32 [[M:%.*]], 0\n ; CHECK-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[M]] to i64\n-; CHECK-NEXT:    br i1 [[CMP222]], label [[INNER_FOR_BODY_SPLIT1:%.*]], label [[OUTER_CRIT_EDGE:%.*]]\n+; CHECK-NEXT:    br i1 [[CMP222]], label [[INNER_FOR_BODY_SPLIT1:%.*]], label [[INNER_FOR_BODY_SPLIT:%.*]]\n ; CHECK:       inner.preheader:\n ; CHECK-NEXT:    [[WIDE_TRIP_COUNT29:%.*]] = zext i32 [[N]] to i64\n ; CHECK-NEXT:    br label [[INNER_FOR_BODY:%.*]]\n ; CHECK:       inner.for.body:\n-; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[INNER_PREHEADER]] ], [ [[TMP1:%.*]], [[INNER_FOR_BODY_SPLIT:%.*]] ]\n+; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[INNER_PREHEADER]] ], [ [[TMP1:%.*]], [[INNER_FOR_BODY_SPLIT]] ]\n ; CHECK-NEXT:    br label [[OUTER_PREHEADER]]\n ; CHECK:       inner.for.body.split1:\n ; CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds [16 x [16 x i32]], [16 x [16 x i32]]* [[TEMP]], i64 0, i64 [[INDVARS_IV]], i64 [[INDVARS_IV27]]\n@@ -41,10 +41,10 @@ define void @lcssa_08(i32 %n, i32 %m) {\n ; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]\n ; CHECK-NEXT:    br label [[INNER_CRIT_EDGE:%.*]]\n ; CHECK:       inner.for.body.split:\n-; CHECK-NEXT:    [[WIDE_TRIP_COUNT_LCSSA2:%.*]] = phi i64 [ [[WIDE_TRIP_COUNT]], [[OUTER_LATCH]] ]\n+; CHECK-NEXT:    [[WIDE_TRIP_COUNT_LCSSA:%.*]] = phi i64 [ [[WIDE_TRIP_COUNT]], [[OUTER_LATCH]] ], [ [[WIDE_TRIP_COUNT]], [[OUTER_HEADER]] ]\n ; CHECK-NEXT:    [[TMP1]] = add nuw nsw i64 [[INDVARS_IV]], 1\n-; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i64 [[TMP1]], [[WIDE_TRIP_COUNT_LCSSA2]]\n-; CHECK-NEXT:    br i1 [[TMP2]], label [[INNER_FOR_BODY]], label [[OUTER_CRIT_EDGE]]\n+; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i64 [[TMP1]], [[WIDE_TRIP_COUNT_LCSSA]]\n+; CHECK-NEXT:    br i1 [[TMP2]], label [[INNER_FOR_BODY]], label [[OUTER_CRIT_EDGE:%.*]]\n ; CHECK:       inner.crit_edge:\n ; CHECK-NEXT:    br label [[OUTER_LATCH]]\n ; CHECK:       outer.latch:"
            },
            {
                "fn": "llvm/test/Transforms/LoopInterchange/outer-header-jump-to-inner-latch.ll",
                "patch": "@@ -0,0 +1,202 @@\n+; RUN: opt -basic-aa -loop-interchange -verify-dom-info -verify-loop-info -verify-loop-lcssa -S %s | FileCheck %s\n+\n+@b = global [3 x [5 x [8 x i16]]] [[5 x [8 x i16]] zeroinitializer, [5 x [8 x i16]] [[8 x i16] zeroinitializer, [8 x i16] [i16 0, i16 0, i16 0, i16 6, i16 1, i16 6, i16 0, i16 0], [8 x i16] zeroinitializer, [8 x i16] zeroinitializer, [8 x i16] zeroinitializer], [5 x [8 x i16]] zeroinitializer], align 2\n+@a = common global i32 0, align 4\n+@d = common dso_local local_unnamed_addr global [1 x [6 x i32]] zeroinitializer, align 4\n+\n+\n+;  Doubly nested loop\n+;; C test case:\n+;; int a;\n+;; short b[3][5][8] = {{}, {{}, 0, 0, 0, 6, 1, 6}};\n+;; void test1() {\n+;;   int c = 0, d;\n+;;   for (; c <= 2; c++) {\n+;;     if (c)\n+;;       continue;\n+;;     d = 0;\n+;;     for (; d <= 2; d++)\n+;;       a |= b[d][d][c + 5];\n+;;   }\n+;; }\n+\n+define void @test1() {\n+;CHECK-LABEL: @test1(\n+;CHECK:          entry:\n+;CHECK-NEXT:       br label [[FOR_COND1_PREHEADER:%.*]]\n+;CHECK:          for.body.preheader:\n+;CHECK-NEXT:       br label  [[FOR_BODY:%.*]]\n+;CHECK:          for.body:\n+;CHECK-NEXT:       [[INDVARS_IV22:%.*]] = phi i64 [ [[INDVARS_IV_NEXT23:%.*]], [[FOR_INC8:%.*]] ], [ 0, [[FOR_BODY_PREHEADER:%.*]] ]\n+;CHECK-NEXT:       [[TOBOOL:%.*]] = icmp eq i64 [[INDVARS_IV22:%.*]], 0\n+;CHECK-NEXT:       br i1 [[TOBOOL]], label [[FOR_BODY3_SPLIT1:%.*]], label [[FOR_BODY3_SPLIT:%.*]]\n+;CHECK:          for.cond1.preheader:\n+;CHECK-NEXT:       br label [[FOR_BODY3:%.*]]\n+;CHECK:          for.body3:\n+;CHECK-NEXT:       [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_COND1_PREHEADER]] ], [ %3, [[FOR_BODY3_SPLIT]] ]\n+;CHECK-NEXT:        br label [[FOR_BODY_PREHEADER]]\n+;CHECK:          for.body3.split1:\n+;CHECK-NEXT:       [[TMP0:%.*]] = add nuw nsw i64 [[INDVARS_IV22]], 5\n+;CHECK-NEXT:       [[ARRAYIDX7:%.*]] = getelementptr inbounds [3 x [5 x [8 x i16]]], [3 x [5 x [8 x i16]]]* @b, i64 0, i64 [[INDVARS_IV]], i64 [[INDVARS_IV]], i64 [[TMP0]]\n+;CHECK-NEXT:       [[TMP1:%.*]] = load i16, i16* [[ARRAYIDX7]]\n+;CHECK-NEXT:       [[CONV:%.*]] = sext i16 [[TMP1]] to i32\n+;CHECK-NEXT:       [[TMP2:%.*]] = load i32, i32* @a\n+;CHECK-NEXT:       [[TMP_OR:%.*]] = or i32 [[TMP2]], [[CONV]]\n+;CHECK-NEXT:       store i32 [[TMP_OR]], i32* @a\n+;CHECK-NEXT:       [[INDVARS_IV_NEXT:%.*]] = add nuw nsw i64 [[INDVARS_IV]], 1\n+;CHECK-NEXT:       [[EXITCOND:%.*]] = icmp ne i64 [[INDVARS_IV_NEXT]], 3\n+;CHECK-NEXT:       br label [[FOR_INC8_LOOPEXIT:%.*]]\n+;CHECK:          for.body3.split:\n+;CHECK-NEXT:       [[TMP3:%.*]] = add nuw nsw i64 [[INDVARS_IV]], 1\n+;CHECK-NEXT:       [[TMP4:%.*]] = icmp ne i64 [[TMP3]], 3\n+;CHECK-NEXT:       br i1 %4, label [[FOR_BODY3]], label [[FOR_END10:%.*]]\n+;CHECK:          for.inc8.loopexit:\n+;CHECK-NEXT:       br label [[FOR_INC8]]\n+;CHECK:          for.inc8:\n+;CHECK-NEXT:       [[INDVARS_IV_NEXT23]] = add nuw nsw i64 [[INDVARS_IV22]], 1\n+;CHECK-NEXT:       [[EXITCOND25:%.*]] = icmp ne i64 [[INDVARS_IV_NEXT23]], 3\n+;CHECK-NEXT:       br i1 [[EXITCOND25]], label [[FOR_BODY]], label [[FOR_BODY3_SPLIT]]\n+;CHECK:         for.end10:\n+;CHECK-NEXT:       [[TMP5:%.*]] = load i32, i32* @a\n+;CHECK-NEXT:       ret void\n+\n+entry:\n+  br label %for.body\n+\n+for.body:                                         ; preds = %entry, %for.inc8\n+  %indvars.iv22 = phi i64 [ 0, %entry ], [ %indvars.iv.next23, %for.inc8 ]\n+  %tobool = icmp eq i64 %indvars.iv22, 0\n+  br i1 %tobool, label %for.cond1.preheader, label %for.inc8\n+\n+for.cond1.preheader:                              ; preds = %for.body\n+  br label %for.body3\n+\n+for.body3:                                        ; preds = %for.cond1.preheader, %for.body3\n+  %indvars.iv = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next, %for.body3 ]\n+  %0 = add nuw nsw i64 %indvars.iv22, 5\n+  %arrayidx7 = getelementptr inbounds [3 x [5 x [8 x i16]]], [3 x [5 x [8 x i16]]]* @b, i64 0, i64 %indvars.iv, i64 %indvars.iv, i64 %0\n+  %1 = load i16, i16* %arrayidx7\n+  %conv = sext i16 %1 to i32\n+  %2 = load i32, i32* @a\n+  %or = or i32 %2, %conv\n+  store i32 %or, i32* @a\n+  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1\n+  %exitcond = icmp ne i64 %indvars.iv.next, 3\n+  br i1 %exitcond, label %for.body3, label %for.inc8.loopexit\n+\n+for.inc8.loopexit:                                ; preds = %for.body3\n+  br label %for.inc8\n+\n+for.inc8:                                         ; preds = %for.inc8.loopexit, %for.body\n+  %indvars.iv.next23 = add nuw nsw i64 %indvars.iv22, 1\n+  %exitcond25 = icmp ne i64 %indvars.iv.next23, 3\n+  br i1 %exitcond25, label %for.body, label %for.end10\n+\n+for.end10:                                        ; preds = %for.inc8\n+  %3 = load i32, i32* @a\n+  ret void\n+}\n+\n+; Triply nested loop\n+; The innermost and the middle loop are interchanged.\n+; C test case:\n+;; a;\n+;; d[][6];\n+;; void test2() {\n+;;   int g = 10;\n+;;   for (; g; g = g - 5) {\n+;;     short c = 4;\n+;;     for (; c; c--) {\n+;;       int i = 4;\n+;;       for (; i; i--) {\n+;;         if (a)\n+;;           break;\n+;;         d[i][c] = 0;\n+;;       }\n+;;     }\n+;;   }\n+;; }\n+\n+define void @test2() {\n+; CHECK-LABEL: @test2(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    br label [[OUTERMOST_HEADER:%.*]]\n+; CHECK:       outermost.header:\n+; CHECK-NEXT:    [[INDVAR_OUTERMOST:%.*]] = phi i32 [ 10, [[ENTRY:%.*]] ], [ [[INDVAR_OUTERMOST_NEXT:%.*]], [[OUTERMOST_LATCH:%.*]] ]\n+; CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* @a, align 4\n+; CHECK-NEXT:    [[TOBOOL71_I:%.*]] = icmp eq i32 [[TMP0]], 0\n+; CHECK-NEXT:    br label [[INNERMOST_PREHEADER:%.*]]\n+; CHECK:       middle.header.preheader:\n+; CHECK-NEXT:    br label [[MIDDLE_HEADER:%.*]]\n+; CHECK:       middle.header:\n+; CHECK-NEXT:    [[INDVAR_MIDDLE:%.*]] = phi i64 [ [[INDVAR_MIDDLE_NEXT:%.*]], [[MIDDLE_LATCH:%.*]] ], [ 4, [[MIDDLE_HEADER_PREHEADER:%.*]] ]\n+; CHECK-NEXT:    br i1 [[TOBOOL71_I]], label [[INNERMOST_BODY_SPLIT1:%.*]], label [[INNERMOST_BODY_SPLIT:%.*]]\n+; CHECK:       innermost.preheader:\n+; CHECK-NEXT:    br label [[INNERMOST_BODY:%.*]]\n+; CHECK:       innermost.body:\n+; CHECK-NEXT:    [[INDVAR_INNERMOST:%.*]] = phi i64 [ [[TMP1:%.*]], [[INNERMOST_BODY_SPLIT]] ], [ 4, [[INNERMOST_PREHEADER]] ]\n+; CHECK-NEXT:    br label [[MIDDLE_HEADER_PREHEADER]]\n+; CHECK:       innermost.body.split1:\n+; CHECK-NEXT:    [[ARRAYIDX9_I:%.*]] = getelementptr inbounds [1 x [6 x i32]], [1 x [6 x i32]]* @d, i64 0, i64 [[INDVAR_INNERMOST]], i64 [[INDVAR_MIDDLE]]\n+; CHECK-NEXT:    store i32 0, i32* [[ARRAYIDX9_I]], align 4\n+; CHECK-NEXT:    [[INDVAR_INNERMOST_NEXT:%.*]] = add nsw i64 [[INDVAR_INNERMOST]], -1\n+; CHECK-NEXT:    [[TOBOOL5_I:%.*]] = icmp eq i64 [[INDVAR_INNERMOST_NEXT]], 0\n+; CHECK-NEXT:    br label [[MIDDLE_LATCH_LOOPEXIT:%.*]]\n+; CHECK:       innermost.body.split:\n+; CHECK-NEXT:    [[TMP1]] = add nsw i64 [[INDVAR_INNERMOST]], -1\n+; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq i64 [[TMP1]], 0\n+; CHECK-NEXT:    br i1 [[TMP2]], label [[OUTERMOST_LATCH]], label [[INNERMOST_BODY]]\n+; CHECK:       innermost.loopexit:\n+; CHECK-NEXT:    br label [[MIDDLE_LATCH]]\n+; CHECK:       middle.latch:\n+; CHECK-NEXT:    [[INDVAR_MIDDLE_NEXT]] = add nsw i64 [[INDVAR_MIDDLE]], -1\n+; CHECK-NEXT:    [[TOBOOL2_I:%.*]] = icmp eq i64 [[INDVAR_MIDDLE_NEXT]], 0\n+; CHECK-NEXT:    br i1 [[TOBOOL2_I]], label [[INNERMOST_BODY_SPLIT]], label [[MIDDLE_HEADER]]\n+; CHECK:       outermost.latch:\n+; CHECK-NEXT:    [[INDVAR_OUTERMOST_NEXT]] = add nsw i32 [[INDVAR_OUTERMOST]], -5\n+; CHECK-NEXT:    [[TOBOOL_I:%.*]] = icmp eq i32 [[INDVAR_OUTERMOST_NEXT]], 0\n+; CHECK-NEXT:    br i1 [[TOBOOL_I]], label [[OUTERMOST_EXIT:%.*]], label [[OUTERMOST_HEADER]]\n+; CHECK:       outermost.exit:\n+; CHECK-NEXT:    ret void\n+;\n+\n+entry:\n+  br label %outermost.header\n+\n+outermost.header:                      ; preds = %outermost.latch, %entry\n+  %indvar.outermost = phi i32 [ 10, %entry ], [ %indvar.outermost.next, %outermost.latch ]\n+  %0 = load i32, i32* @a, align 4\n+  %tobool71.i = icmp eq i32 %0, 0\n+  br label %middle.header\n+\n+middle.header:                            ; preds = %middle.latch, %outermost.header\n+  %indvar.middle = phi i64 [ 4, %outermost.header ], [ %indvar.middle.next, %middle.latch ]\n+  br i1 %tobool71.i, label %innermost.preheader, label %middle.latch\n+\n+innermost.preheader:                               ; preds = %middle.header\n+  br label %innermost.body\n+\n+innermost.body:                                         ; preds = %innermost.preheader, %innermost.body\n+  %indvar.innermost = phi i64 [ %indvar.innermost.next, %innermost.body ], [ 4, %innermost.preheader ]\n+  %arrayidx9.i = getelementptr inbounds [1 x [6 x i32]], [1 x [6 x i32]]* @d, i64 0, i64 %indvar.innermost, i64 %indvar.middle\n+  store i32 0, i32* %arrayidx9.i, align 4\n+  %indvar.innermost.next = add nsw i64 %indvar.innermost, -1\n+  %tobool5.i = icmp eq i64 %indvar.innermost.next, 0\n+  br i1 %tobool5.i, label %innermost.loopexit, label %innermost.body\n+\n+innermost.loopexit:                             ; preds = %innermost.body\n+  br label %middle.latch\n+\n+middle.latch:                                      ; preds = %middle.latch.loopexit, %middle.header\n+  %indvar.middle.next = add nsw i64 %indvar.middle, -1\n+  %tobool2.i = icmp eq i64 %indvar.middle.next, 0\n+  br i1 %tobool2.i, label %outermost.latch, label %middle.header\n+\n+outermost.latch:                                      ; preds = %middle.latch\n+  %indvar.outermost.next = add nsw i32 %indvar.outermost, -5\n+  %tobool.i = icmp eq i32 %indvar.outermost.next, 0\n+  br i1 %tobool.i, label %outermost.exit, label %outermost.header\n+\n+outermost.exit:                                           ; preds = %outermost.latch\n+  ret void\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/LoopInterchange/lcssa-preheader.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopInterchange/lcssa-preheader.ll\n\n\nTesting Time: 1.33s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopInterchange/outer-header-jump-to-inner-latch.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopInterchange/outer-header-jump-to-inner-latch.ll\n\n\nTesting Time: 0.27s\n  Failed: 1\n"
    },
    "ea817d79be2686d1d5fad04d429dbe392ee22b5f___SimplifyCFG.cpp": {
        "start": 6613,
        "end": 6690,
        "buggy": "static bool passingValueIsAlwaysUndefined(Value *V, Instruction *I, bool PtrValueMayBeModified) {\n  Constant *C = dyn_cast<Constant>(V);\n  if (!C)\n    return false;\n\n  if (I->use_empty())\n    return false;\n\n  if (C->isNullValue() || isa<UndefValue>(C)) {\n    // Only look at the first use, avoid hurting compile time with long uselists\n    User *Use = *I->user_begin();\n\n    // Now make sure that there are no instructions in between that can alter\n    // control flow (eg. calls)\n    for (BasicBlock::iterator\n             i = ++BasicBlock::iterator(I),\n             UI = BasicBlock::iterator(dyn_cast<Instruction>(Use));\n         i != UI; ++i)\n      if (i == I->getParent()->end() || i->mayHaveSideEffects())\n        return false;\n\n    // Look through GEPs. A load from a GEP derived from NULL is still undefined\n    if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(Use))\n      if (GEP->getPointerOperand() == I) {\n        if (!GEP->isInBounds() || !GEP->hasAllZeroIndices())\n          PtrValueMayBeModified = true;\n        return passingValueIsAlwaysUndefined(V, GEP, PtrValueMayBeModified);\n      }\n\n    // Look through bitcasts.\n    if (BitCastInst *BC = dyn_cast<BitCastInst>(Use))\n      return passingValueIsAlwaysUndefined(V, BC, PtrValueMayBeModified);\n\n    // Load from null is undefined.\n    if (LoadInst *LI = dyn_cast<LoadInst>(Use))\n      if (!LI->isVolatile())\n        return !NullPointerIsDefined(LI->getFunction(),\n                                     LI->getPointerAddressSpace());\n\n    // Store to null is undefined.\n    if (StoreInst *SI = dyn_cast<StoreInst>(Use))\n      if (!SI->isVolatile())\n        return (!NullPointerIsDefined(SI->getFunction(),\n                                      SI->getPointerAddressSpace())) &&\n               SI->getPointerOperand() == I;\n\n    if (auto *CB = dyn_cast<CallBase>(Use)) {\n      if (C->isNullValue() && NullPointerIsDefined(CB->getFunction()))\n        return false;\n      // A call to null is undefined.\n      if (CB->getCalledOperand() == I)\n        return true;\n\n      if (C->isNullValue()) {\n        for (const llvm::Use &Arg : CB->args())\n          if (Arg == I) {\n            unsigned ArgIdx = CB->getArgOperandNo(&Arg);\n            if (CB->isPassingUndefUB(ArgIdx) &&\n                CB->paramHasAttr(ArgIdx, Attribute::NonNull)) {\n              // Passing null to a nonnnull+noundef argument is undefined.\n              return !PtrValueMayBeModified;\n            }\n          }\n      } else if (isa<UndefValue>(C)) {\n        // Passing undef to a noundef argument is undefined.\n        for (const llvm::Use &Arg : CB->args())\n          if (Arg == I) {\n            unsigned ArgIdx = CB->getArgOperandNo(&Arg);\n            if (CB->isPassingUndefUB(ArgIdx)) {\n              // Passing undef to a noundef argument is undefined.\n              return true;\n            }\n          }\n      }\n    }\n  }\n  return false;\n}\n",
        "fix": null,
        "src_path": "ea817d79be2686d1d5fad04d429dbe392ee22b5f___SimplifyCFG.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/ea817d79be2686d1d5fad04d429dbe392ee22b5f",
        "commit_msg": "[SimplifyCFG] Look for control flow changes instead of side effects.\n\nWhen passingValueIsAlwaysUndefined scans for an instruction between an\ninst with a null or undef argument and its first use, it was checking\nfor instructions that may have side effects, which is a superset of the\ninstructions it intended to find (as per the comments, control flow\nchanging instructions that would prevent reaching the uses). Switch\nto using isGuaranteedToTransferExecutionToSuccessor() instead.\n\nWithout this change, when enabling -fwhole-program-vtables, which causes\nassumes to be inserted by clang, we can get different simplification\ndecisions. In particular, when building with instrumentation FDO it can\naffect the optimizations decisions before FDO matching, leading to some\nmismatches.\n\nI had to modify d83507-knowledge-retention-bug.ll since this fix enables\nmore aggressive optimization of that code such that it no longer tested\nthe original bug it was meant to test. I removed the undef which still\nprovokes the original failure (confirmed by temporarily reverting the\nfix) and also changed it to just invoke the passes of interest to narrow\nthe testing.\n\nSimilarly I needed to adjust code for UnreachableEliminate.ll to avoid\nan undef which was causing the function body to get optimized away with\nthis fix.\n\nDifferential Revision: https://reviews.llvm.org/D101507",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/Thumb2/LowOverheadLoops/while-loops.ll",
                "patch": "@@ -153,7 +153,7 @@ declare i32 @llvm.arm.mve.addv.predicated.v4i32.v4i1(<4 x i32>, i32, <4 x i1>)\n \n \n ; Long test that was spilling lr between t2LoopDec and End\n-define dso_local i32 @b(i32* %c, i32 %d, i32 %e) \"frame-pointer\"=\"all\" {\n+define dso_local i32 @b(i32* %c, i32 %d, i32 %e, i32* %n) \"frame-pointer\"=\"all\" {\n ; CHECK-LABEL: b:\n ; CHECK:       @ %bb.0: @ %entry\n ; CHECK-NEXT:    .save {r4, r5, r6, r7, lr}\n@@ -162,79 +162,80 @@ define dso_local i32 @b(i32* %c, i32 %d, i32 %e) \"frame-pointer\"=\"all\" {\n ; CHECK-NEXT:    add r7, sp, #12\n ; CHECK-NEXT:    .save {r8, r9, r10, r11}\n ; CHECK-NEXT:    push.w {r8, r9, r10, r11}\n-; CHECK-NEXT:    .pad #8\n-; CHECK-NEXT:    sub sp, #8\n+; CHECK-NEXT:    .pad #12\n+; CHECK-NEXT:    sub sp, #12\n ; CHECK-NEXT:    wls lr, r1, .LBB2_3\n ; CHECK-NEXT:  @ %bb.1: @ %while.body.preheader\n-; CHECK-NEXT:    adds r1, r0, #4\n-; CHECK-NEXT:    mvn r3, #1\n-; CHECK-NEXT:    @ implicit-def: $r9\n-; CHECK-NEXT:    @ implicit-def: $r10\n+; CHECK-NEXT:    mov r4, r2\n+; CHECK-NEXT:    adds r2, r3, #4\n+; CHECK-NEXT:    add.w r9, r0, #4\n+; CHECK-NEXT:    mvn r11, #1\n ; CHECK-NEXT:    @ implicit-def: $r6\n-; CHECK-NEXT:    @ implicit-def: $r4\n-; CHECK-NEXT:    str r2, [sp] @ 4-byte Spill\n+; CHECK-NEXT:    @ implicit-def: $r12\n+; CHECK-NEXT:    str r4, [sp] @ 4-byte Spill\n ; CHECK-NEXT:  .LBB2_2: @ %while.body\n ; CHECK-NEXT:    @ =>This Inner Loop Header: Depth=1\n-; CHECK-NEXT:    str r1, [sp, #4] @ 4-byte Spill\n-; CHECK-NEXT:    ldr r1, [sp, #4] @ 4-byte Reload\n-; CHECK-NEXT:    ldr.w r8, [r10]\n-; CHECK-NEXT:    ldr r1, [r1, #-4]\n-; CHECK-NEXT:    mul r11, r8, r0\n-; CHECK-NEXT:    adds r0, #4\n-; CHECK-NEXT:    mul r1, r1, r9\n-; CHECK-NEXT:    adds.w r12, r1, #-2147483648\n+; CHECK-NEXT:    ldr r1, [r9, #-4]\n+; CHECK-NEXT:    ldr.w r10, [r2]\n+; CHECK-NEXT:    str r0, [sp, #4] @ 4-byte Spill\n+; CHECK-NEXT:    muls r1, r3, r1\n+; CHECK-NEXT:    adds.w r8, r1, #-2147483648\n ; CHECK-NEXT:    asr.w r5, r1, #31\n-; CHECK-NEXT:    add.w r1, r11, #-2147483648\n-; CHECK-NEXT:    adc r5, r5, #0\n-; CHECK-NEXT:    asrl r12, r5, r1\n-; CHECK-NEXT:    smull r2, r1, r8, r12\n-; CHECK-NEXT:    lsll r2, r1, #30\n-; CHECK-NEXT:    asrs r5, r1, #31\n-; CHECK-NEXT:    mov r2, r1\n-; CHECK-NEXT:    lsll r2, r5, r8\n-; CHECK-NEXT:    lsll r2, r5, #30\n-; CHECK-NEXT:    ldrd r2, r11, [r3]\n+; CHECK-NEXT:    adc r1, r5, #0\n+; CHECK-NEXT:    mul r5, r10, r0\n+; CHECK-NEXT:    mov r0, r2\n+; CHECK-NEXT:    ldr.w r2, [r11, #4]\n+; CHECK-NEXT:    str r2, [sp, #8] @ 4-byte Spill\n+; CHECK-NEXT:    ldr r2, [sp, #8] @ 4-byte Reload\n+; CHECK-NEXT:    add.w r5, r5, #-2147483648\n+; CHECK-NEXT:    asrl r8, r1, r5\n+; CHECK-NEXT:    smull r4, r5, r10, r8\n+; CHECK-NEXT:    lsll r4, r5, #30\n ; CHECK-NEXT:    asrs r1, r5, #31\n-; CHECK-NEXT:    mov r12, r5\n-; CHECK-NEXT:    asrs r5, r4, #31\n-; CHECK-NEXT:    muls r2, r6, r2\n-; CHECK-NEXT:    adds r2, #2\n-; CHECK-NEXT:    lsll r12, r1, r2\n-; CHECK-NEXT:    ldr r2, [sp, #4] @ 4-byte Reload\n-; CHECK-NEXT:    add.w r1, r12, #-2147483648\n-; CHECK-NEXT:    ldr r2, [r2]\n-; CHECK-NEXT:    mul r2, r2, r9\n-; CHECK-NEXT:    add.w r9, r9, #4\n-; CHECK-NEXT:    adds r4, r4, r2\n-; CHECK-NEXT:    adc.w r2, r5, r2, asr #31\n-; CHECK-NEXT:    adds.w r5, r4, #-2147483648\n-; CHECK-NEXT:    smull r6, r4, r11, r6\n-; CHECK-NEXT:    adc r2, r2, #0\n-; CHECK-NEXT:    asrs r5, r2, #31\n-; CHECK-NEXT:    subs r6, r2, r6\n+; CHECK-NEXT:    mov r4, r5\n+; CHECK-NEXT:    lsll r4, r1, r10\n+; CHECK-NEXT:    lsll r4, r1, #30\n+; CHECK-NEXT:    ldr.w r4, [r11]\n+; CHECK-NEXT:    asrs r5, r1, #31\n+; CHECK-NEXT:    mov r8, r1\n+; CHECK-NEXT:    muls r4, r6, r4\n+; CHECK-NEXT:    adds r4, #2\n+; CHECK-NEXT:    lsll r8, r5, r4\n+; CHECK-NEXT:    ldr r4, [r9], #4\n+; CHECK-NEXT:    asr.w r5, r12, #31\n+; CHECK-NEXT:    add.w r8, r8, #-2147483648\n+; CHECK-NEXT:    muls r4, r3, r4\n+; CHECK-NEXT:    adds r3, #4\n+; CHECK-NEXT:    adds.w r1, r12, r4\n+; CHECK-NEXT:    adc.w r5, r5, r4, asr #31\n+; CHECK-NEXT:    smull r6, r4, r2, r6\n+; CHECK-NEXT:    adds.w r1, r1, #-2147483648\n+; CHECK-NEXT:    adc r1, r5, #0\n+; CHECK-NEXT:    mov r2, r0\n+; CHECK-NEXT:    asrs r5, r1, #31\n+; CHECK-NEXT:    subs r6, r1, r6\n ; CHECK-NEXT:    sbcs r5, r4\n ; CHECK-NEXT:    adds.w r6, r6, #-2147483648\n ; CHECK-NEXT:    adc r5, r5, #0\n-; CHECK-NEXT:    asrl r6, r5, r1\n-; CHECK-NEXT:    movs r1, #2\n+; CHECK-NEXT:    asrl r6, r5, r8\n ; CHECK-NEXT:    lsrl r6, r5, #2\n-; CHECK-NEXT:    str r6, [r1]\n-; CHECK-NEXT:    ldr r1, [r3], #-4\n-; CHECK-NEXT:    mls r1, r1, r8, r2\n-; CHECK-NEXT:    adds.w r4, r1, #-2147483648\n-; CHECK-NEXT:    asr.w r2, r1, #31\n-; CHECK-NEXT:    adc r1, r2, #0\n-; CHECK-NEXT:    ldr r2, [sp] @ 4-byte Reload\n-; CHECK-NEXT:    lsrl r4, r1, #2\n-; CHECK-NEXT:    rsbs r1, r4, #0\n-; CHECK-NEXT:    str r1, [r10, #-4]\n-; CHECK-NEXT:    add.w r10, r10, #4\n-; CHECK-NEXT:    str r1, [r2]\n-; CHECK-NEXT:    ldr r1, [sp, #4] @ 4-byte Reload\n-; CHECK-NEXT:    adds r1, #4\n+; CHECK-NEXT:    movs r5, #2\n+; CHECK-NEXT:    str r6, [r5]\n+; CHECK-NEXT:    ldr r5, [r11], #-4\n+; CHECK-NEXT:    mls r1, r5, r10, r1\n+; CHECK-NEXT:    adds.w r12, r1, #-2147483648\n+; CHECK-NEXT:    asr.w r4, r1, #31\n+; CHECK-NEXT:    adc r1, r4, #0\n+; CHECK-NEXT:    ldrd r4, r0, [sp] @ 8-byte Folded Reload\n+; CHECK-NEXT:    lsrl r12, r1, #2\n+; CHECK-NEXT:    rsb.w r1, r12, #0\n+; CHECK-NEXT:    adds r0, #4\n+; CHECK-NEXT:    str r1, [r4]\n+; CHECK-NEXT:    str r1, [r2, #-4]\n+; CHECK-NEXT:    adds r2, #4\n ; CHECK-NEXT:    le lr, .LBB2_2\n ; CHECK-NEXT:  .LBB2_3: @ %while.end\n-; CHECK-NEXT:    add sp, #8\n+; CHECK-NEXT:    add sp, #12\n ; CHECK-NEXT:    pop.w {r8, r9, r10, r11}\n ; CHECK-NEXT:    pop {r4, r5, r6, r7, pc}\n entry:\n@@ -245,7 +246,7 @@ entry:\n while.body:                                       ; preds = %entry, %while.body\n   %p.077 = phi i32* [ %incdec.ptr22, %while.body ], [ inttoptr (i32 2 to i32*), %entry ]\n   %c.addr.076 = phi i32* [ %incdec.ptr1, %while.body ], [ %c, %entry ]\n-  %n.075 = phi i32* [ %incdec.ptr43, %while.body ], [ undef, %entry ]\n+  %n.075 = phi i32* [ %incdec.ptr43, %while.body ], [ %n, %entry ]\n   %m.074 = phi i32 [ %conv35, %while.body ], [ undef, %entry ]\n   %d.addr.073 = phi i32 [ %dec, %while.body ], [ %d, %entry ]\n   %h.072 = phi i32 [ %conv41, %while.body ], [ undef, %entry ]"
            },
            {
                "fn": "llvm/test/Transforms/PhaseOrdering/d83507-knowledge-retention-bug.ll",
                "patch": "@@ -1,15 +1,15 @@\n ; NOTE: Assertions have been autogenerated by utils/update_test_checks.py\n-; RUN: opt -O1                   -enable-knowledge-retention -S < %s  | FileCheck %s\n-; RUN: opt -passes='default<O1>' -enable-knowledge-retention -S < %s  | FileCheck %s\n+; RUN: opt -loop-rotate -instcombine -enable-knowledge-retention -S < %s  | FileCheck %s\n+; RUN: opt -passes='loop(loop-rotate),instcombine' -enable-knowledge-retention -S < %s  | FileCheck %s\n \n %0 = type { %0* }\n \n-define %0* @f1() local_unnamed_addr {\n+define %0* @f1(%0* %i0) local_unnamed_addr {\n ; CHECK-LABEL: @f1(\n ; CHECK-NEXT:  bb:\n-; CHECK-NEXT:    br label [[BB3:%.*]]\n+; CHECK:         br label [[BB3:%.*]]\n ; CHECK:       bb3:\n-; CHECK-NEXT:    [[I1:%.*]] = phi %0* [ [[I5:%.*]], [[BB3]] ], [ undef, [[BB:%.*]] ]\n+; CHECK-NEXT:    [[I1:%.*]] = phi %0* [ %i0, [[BB:%.*]] ], [ [[I5:%.*]], [[BB3]] ]\n ; CHECK-NEXT:    call void @llvm.assume(i1 true) [ \"nonnull\"(%0* [[I1]]) ]\n ; CHECK-NEXT:    [[I4:%.*]] = getelementptr inbounds [[TMP0:%.*]], %0* [[I1]], i64 0, i32 0\n ; CHECK-NEXT:    [[I5]] = load %0*, %0** [[I4]], align 8\n@@ -22,7 +22,7 @@ bb:\n   br label %bb1\n \n bb1:\n-  %i = phi %0* [ undef, %bb ], [ %i5, %bb3 ]\n+  %i = phi %0* [ %i0, %bb ], [ %i5, %bb3 ]\n   %i2 = icmp eq %0* %i, null\n   br i1 %i2, label %bb6, label %bb3\n "
            },
            {
                "fn": "llvm/test/Transforms/SimplifyCFG/UnreachableEliminate.ll",
                "patch": "@@ -84,6 +84,41 @@ bb2:\n   ret void\n }\n \n+declare void @llvm.assume(i1)\n+declare i1 @llvm.type.test(i8*, metadata) nounwind readnone\n+\n+;; Same as the above test but make sure the unreachable control flow is still\n+;; removed in the presence of a type test / assume sequence.\n+\n+define void @test5_type_test_assume(i1 %cond, i8* %ptr, [3 x i8*]* %vtable) {\n+; CHECK-LABEL: @test5_type_test_assume(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    [[TMP0:%.*]] = xor i1 [[COND:%.*]], true\n+; CHECK-NEXT:    call void @llvm.assume(i1 [[TMP0]])\n+; CHECK-NEXT:    [[VTABLE:%.*]] = bitcast [3 x i8*]* %vtable to i8*\n+; CHECK-NEXT:    [[P:%.*]] = call i1 @llvm.type.test(i8* [[VTABLE]], metadata !\"foo\")\n+; CHECK-NEXT:    tail call void @llvm.assume(i1 [[P]])\n+; CHECK-NEXT:    store i8 2, i8* [[PTR:%.*]], align 8\n+; CHECK-NEXT:    ret void\n+;\n+entry:\n+  br i1 %cond, label %bb1, label %bb3\n+\n+bb3:\n+  br label %bb2\n+\n+bb1:\n+  br label %bb2\n+\n+bb2:\n+  %ptr.2 = phi i8* [ %ptr, %bb3 ], [ null, %bb1 ]\n+  %vtablei8 = bitcast [3 x i8*]* %vtable to i8*\n+  %p = call i1 @llvm.type.test(i8* %vtablei8, metadata !\"foo\")\n+  tail call void @llvm.assume(i1 %p)\n+  store i8 2, i8* %ptr.2, align 8\n+  ret void\n+}\n+\n define void @test5_no_null_opt(i1 %cond, i8* %ptr) #0 {\n ; CHECK-LABEL: @test5_no_null_opt(\n ; CHECK-NEXT:  entry:"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/SimplifyCFG/UnreachableEliminate.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SimplifyCFG/UnreachableEliminate.ll\n\n\nTesting Time: 0.12s\n  Failed: 1\n"
    },
    "01c90bbd4fd12aa86db4a47577addb47e6e84289___Debugify.cpp": {
        "start": 592,
        "end": 684,
        "buggy": "bool checkDebugifyMetadata(Module &M,\n                           iterator_range<Module::iterator> Functions,\n                           StringRef NameOfWrappedPass, StringRef Banner,\n                           bool Strip, DebugifyStatsMap *StatsMap) {\n  // Skip modules without debugify metadata.\n  NamedMDNode *NMD = M.getNamedMetadata(\"llvm.debugify\");\n  if (!NMD) {\n    dbg() << Banner << \": Skipping module without debugify metadata\\n\";\n    return false;\n  }\n\n  auto getDebugifyOperand = [&](unsigned Idx) -> unsigned {\n    return mdconst::extract<ConstantInt>(NMD->getOperand(Idx)->getOperand(0))\n        ->getZExtValue();\n  };\n  assert(NMD->getNumOperands() == 2 &&\n         \"llvm.debugify should have exactly 2 operands!\");\n  unsigned OriginalNumLines = getDebugifyOperand(0);\n  unsigned OriginalNumVars = getDebugifyOperand(1);\n  bool HasErrors = false;\n\n  // Track debug info loss statistics if able.\n  DebugifyStatistics *Stats = nullptr;\n  if (StatsMap && !NameOfWrappedPass.empty())\n    Stats = &StatsMap->operator[](NameOfWrappedPass);\n\n  BitVector MissingLines{OriginalNumLines, true};\n  BitVector MissingVars{OriginalNumVars, true};\n  for (Function &F : Functions) {\n    if (isFunctionSkipped(F))\n      continue;\n\n    // Find missing lines.\n    for (Instruction &I : instructions(F)) {\n      if (isa<DbgValueInst>(&I) || isa<PHINode>(&I))\n        continue;\n\n      auto DL = I.getDebugLoc();\n      if (DL && DL.getLine() != 0) {\n        MissingLines.reset(DL.getLine() - 1);\n        continue;\n      }\n\n      if (!DL) {\n        dbg() << \"WARNING: Instruction with empty DebugLoc in function \";\n        dbg() << F.getName() << \" --\";\n        I.print(dbg());\n        dbg() << \"\\n\";\n      }\n    }\n\n    // Find missing variables and mis-sized debug values.\n    for (Instruction &I : instructions(F)) {\n      auto *DVI = dyn_cast<DbgValueInst>(&I);\n      if (!DVI)\n        continue;\n\n      unsigned Var = ~0U;\n      (void)to_integer(DVI->getVariable()->getName(), Var, 10);\n      assert(Var <= OriginalNumVars && \"Unexpected name for DILocalVariable\");\n      bool HasBadSize = diagnoseMisSizedDbgValue(M, DVI);\n      if (!HasBadSize)\n        MissingVars.reset(Var - 1);\n      HasErrors |= HasBadSize;\n    }\n  }\n\n  // Print the results.\n  for (unsigned Idx : MissingLines.set_bits())\n    dbg() << \"WARNING: Missing line \" << Idx + 1 << \"\\n\";\n\n  for (unsigned Idx : MissingVars.set_bits())\n    dbg() << \"WARNING: Missing variable \" << Idx + 1 << \"\\n\";\n\n  // Update DI loss statistics.\n  if (Stats) {\n    Stats->NumDbgLocsExpected += OriginalNumLines;\n    Stats->NumDbgLocsMissing += MissingLines.count();\n    Stats->NumDbgValuesExpected += OriginalNumVars;\n    Stats->NumDbgValuesMissing += MissingVars.count();\n  }\n\n  dbg() << Banner;\n  if (!NameOfWrappedPass.empty())\n    dbg() << \" [\" << NameOfWrappedPass << \"]\";\n  dbg() << \": \" << (HasErrors ? \"FAIL\" : \"PASS\") << '\\n';\n\n  // Strip debugify metadata if required.\n  if (Strip)\n    return stripDebugifyMetadata(M);\n\n  return false;\n}\n",
        "fix": null,
        "src_path": "01c90bbd4fd12aa86db4a47577addb47e6e84289___Debugify.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/01c90bbd4fd12aa86db4a47577addb47e6e84289",
        "commit_msg": "[Transforms][Debugify] Fix \"Missing line\" false alarm on PHI nodes\n\nThis is a fix for https://bugs.llvm.org/show_bug.cgi?id=49959\n\nThe \"Missing line\" false alarm was introduced in D75242.\n\nPatch by Yilong Guo<yilong.guo@intel.com>\n\nDifferential Revision: https://reviews.llvm.org/D100446",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/debugify-ignore-phi.ll",
                "patch": "@@ -0,0 +1,38 @@\n+; RUN: opt -check-debugify < %s -S 2>&1 | FileCheck %s\n+\n+define void @test_phi(i1 %cond) !dbg !6 {\n+  br i1 %cond, label %1, label %2, !dbg !11\n+\n+1:                                                ; preds = %0\n+  br label %2, !dbg !12\n+\n+2:                                                ; preds = %1, %0\n+  %v = phi i32 [ 0, %0 ], [ 1, %1 ], !dbg !13\n+  call void @llvm.dbg.value(metadata i32 %v, metadata !9, metadata !DIExpression()), !dbg !13\n+  ret void, !dbg !14\n+}\n+\n+declare void @llvm.dbg.value(metadata, metadata, metadata)\n+\n+!llvm.dbg.cu = !{!0}\n+!llvm.debugify = !{!3, !4}\n+!llvm.module.flags = !{!5}\n+\n+!0 = distinct !DICompileUnit(language: DW_LANG_C, file: !1, producer: \"debugify\", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2)\n+!1 = !DIFile(filename: \"<stdin>\", directory: \"/\")\n+!2 = !{}\n+!3 = !{i32 4}\n+!4 = !{i32 1}\n+!5 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!6 = distinct !DISubprogram(name: \"test_phi\", linkageName: \"test_phi\", scope: null, file: !1, line: 1, type: !7, scopeLine: 1, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !8)\n+!7 = !DISubroutineType(types: !2)\n+!8 = !{!9}\n+!9 = !DILocalVariable(name: \"1\", scope: !6, file: !1, line: 3, type: !10)\n+!10 = !DIBasicType(name: \"ty32\", size: 32, encoding: DW_ATE_unsigned)\n+!11 = !DILocation(line: 1, column: 1, scope: !6)\n+!12 = !DILocation(line: 2, column: 1, scope: !6)\n+!13 = !DILocation(line: 3, column: 1, scope: !6)\n+!14 = !DILocation(line: 4, column: 1, scope: !6)\n+\n+; CHECK-NOT: WARNING: Missing line 3\n+; CHECK: CheckModuleDebugify: PASS"
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/debugify-ignore-phi.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: DebugInfo/debugify-ignore-phi.ll\n\n\nTesting Time: 0.34s\n  Failed: 1\n"
    },
    "34cccdaed7e7952a9191231ffa62b1b22eac35c8___BitcodeReader.cpp": {
        "start": 3285,
        "end": 3424,
        "buggy": "Error BitcodeReader::parseFunctionRecord(ArrayRef<uint64_t> Record) {\n  // v1: [type, callingconv, isproto, linkage, paramattr, alignment, section,\n  // visibility, gc, unnamed_addr, prologuedata, dllstorageclass, comdat,\n  // prefixdata,  personalityfn, preemption specifier, addrspace] (name in VST)\n  // v2: [strtab_offset, strtab_size, v1]\n  StringRef Name;\n  std::tie(Name, Record) = readNameFromStrtab(Record);\n\n  if (Record.size() < 8)\n    return error(\"Invalid record\");\n  Type *FTy = getTypeByID(Record[0]);\n  if (!FTy)\n    return error(\"Invalid record\");\n  if (auto *PTy = dyn_cast<PointerType>(FTy))\n    FTy = PTy->getElementType();\n\n  if (!isa<FunctionType>(FTy))\n    return error(\"Invalid type for value\");\n  auto CC = static_cast<CallingConv::ID>(Record[1]);\n  if (CC & ~CallingConv::MaxID)\n    return error(\"Invalid calling convention ID\");\n\n  unsigned AddrSpace = TheModule->getDataLayout().getProgramAddressSpace();\n  if (Record.size() > 16)\n    AddrSpace = Record[16];\n\n  Function *Func =\n      Function::Create(cast<FunctionType>(FTy), GlobalValue::ExternalLinkage,\n                       AddrSpace, Name, TheModule);\n\n  assert(Func->getFunctionType() == FTy &&\n         \"Incorrect fully specified type provided for function\");\n  FunctionTypes[Func] = cast<FunctionType>(FTy);\n\n  Func->setCallingConv(CC);\n  bool isProto = Record[2];\n  uint64_t RawLinkage = Record[3];\n  Func->setLinkage(getDecodedLinkage(RawLinkage));\n  Func->setAttributes(getAttributes(Record[4]));\n\n  // Upgrade any old-style byval or sret without a type by propagating the\n  // argument's pointee type. There should be no opaque pointers where the byval\n  // type is implicit.\n  for (unsigned i = 0; i != Func->arg_size(); ++i) {\n    for (Attribute::AttrKind Kind : {Attribute::ByVal, Attribute::StructRet,\n                                     Attribute::InAlloca}) {\n      if (!Func->hasParamAttribute(i, Kind))\n        continue;\n\n      Func->removeParamAttr(i, Kind);\n\n      Type *PTy = cast<FunctionType>(FTy)->getParamType(i);\n      Type *PtrEltTy = cast<PointerType>(PTy)->getElementType();\n      Attribute NewAttr;\n      switch (Kind) {\n      case Attribute::ByVal:\n        NewAttr = Attribute::getWithByValType(Context, PtrEltTy);\n        break;\n      case Attribute::StructRet:\n        NewAttr = Attribute::getWithStructRetType(Context, PtrEltTy);\n        break;\n      case Attribute::InAlloca:\n        NewAttr = Attribute::getWithInAllocaType(Context, PtrEltTy);\n        break;\n      default:\n        llvm_unreachable(\"not an upgraded type attribute\");\n      }\n\n      Func->addParamAttr(i, NewAttr);\n    }\n  }\n\n  MaybeAlign Alignment;\n  if (Error Err = parseAlignmentValue(Record[5], Alignment))\n    return Err;\n  Func->setAlignment(Alignment);\n  if (Record[6]) {\n    if (Record[6] - 1 >= SectionTable.size())\n      return error(\"Invalid ID\");\n    Func->setSection(SectionTable[Record[6] - 1]);\n  }\n  // Local linkage must have default visibility.\n  // auto-upgrade `hidden` and `protected` for old bitcode.\n  if (!Func->hasLocalLinkage())\n    Func->setVisibility(getDecodedVisibility(Record[7]));\n  if (Record.size() > 8 && Record[8]) {\n    if (Record[8] - 1 >= GCTable.size())\n      return error(\"Invalid ID\");\n    Func->setGC(GCTable[Record[8] - 1]);\n  }\n  GlobalValue::UnnamedAddr UnnamedAddr = GlobalValue::UnnamedAddr::None;\n  if (Record.size() > 9)\n    UnnamedAddr = getDecodedUnnamedAddrType(Record[9]);\n  Func->setUnnamedAddr(UnnamedAddr);\n  if (Record.size() > 10 && Record[10] != 0)\n    FunctionPrologues.push_back(std::make_pair(Func, Record[10] - 1));\n\n  if (Record.size() > 11)\n    Func->setDLLStorageClass(getDecodedDLLStorageClass(Record[11]));\n  else\n    upgradeDLLImportExportLinkage(Func, RawLinkage);\n\n  if (Record.size() > 12) {\n    if (unsigned ComdatID = Record[12]) {\n      if (ComdatID > ComdatList.size())\n        return error(\"Invalid function comdat ID\");\n      Func->setComdat(ComdatList[ComdatID - 1]);\n    }\n  } else if (hasImplicitComdat(RawLinkage)) {\n    Func->setComdat(reinterpret_cast<Comdat *>(1));\n  }\n\n  if (Record.size() > 13 && Record[13] != 0)\n    FunctionPrefixes.push_back(std::make_pair(Func, Record[13] - 1));\n\n  if (Record.size() > 14 && Record[14] != 0)\n    FunctionPersonalityFns.push_back(std::make_pair(Func, Record[14] - 1));\n\n  if (Record.size() > 15) {\n    Func->setDSOLocal(getDecodedDSOLocal(Record[15]));\n  }\n  inferDSOLocal(Func);\n\n  // Record[16] is the address space number.\n\n  // Check whether we have enough values to read a partition name.\n  if (Record.size() > 18)\n    Func->setPartition(StringRef(Strtab.data() + Record[17], Record[18]));\n\n  ValueList.push_back(Func);\n\n  // If this is a function with a body, remember the prototype we are\n  // creating now, so that we can match up the body with them later.\n  if (!isProto) {\n    Func->setIsMaterializable(true);\n    FunctionsWithBodies.push_back(Func);\n    DeferredFunctionInfo[Func] = 0;\n  }\n  return Error::success();\n}\n",
        "fix": null,
        "src_path": "34cccdaed7e7952a9191231ffa62b1b22eac35c8___BitcodeReader.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/34cccdaed7e7952a9191231ffa62b1b22eac35c8",
        "commit_msg": "[BitcodeReader] Validate Strtab before accessing.\n\nThis fixes a crash with invalid bitcode files that have records\nreferencing names in Strtab, but Strtab is not present or the index is\nout-of-bounds.\n\nThis fixes the following clusterfuzz issue:\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=29895\n\nReviewed By: arsenm\n\nDifferential Revision: https://reviews.llvm.org/D95554",
        "test_func_diff": [
            {
                "fn": "llvm/test/Bitcode/invalid-record-strtab.ll",
                "patch": "@@ -0,0 +1,5 @@\n+; Bitcode with an invalid record that indexes a name outside of strtab.\n+\n+; RUN: not llvm-dis %s.bc -o - 2>&1 | FileCheck %s\n+\n+; CHECK: error: Invalid record"
            }
        ],
        "error_msg": "FAIL: LLVM :: Bitcode/invalid-record-strtab.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Bitcode/invalid-record-strtab.ll\n\n\nTesting Time: 1.98s\n  Failed: 1\n"
    },
    "9eb613b2de3163686b1a4bd1160f15ac56a4b083___InstructionSimplify.cpp": {
        "start": 185,
        "end": 207,
        "buggy": "static Value *handleOtherCmpSelSimplifications(Value *TCmp, Value *FCmp,\n                                               Value *Cond,\n                                               const SimplifyQuery &Q,\n                                               unsigned MaxRecurse) {\n  // If the false value simplified to false, then the result of the compare\n  // is equal to \"Cond && TCmp\".  This also catches the case when the false\n  // value simplified to false and the true value to true, returning \"Cond\".\n  if (match(FCmp, m_Zero()))\n    if (Value *V = SimplifyAndInst(Cond, TCmp, Q, MaxRecurse))\n      return V;\n  // If the true value simplified to true, then the result of the compare\n  // is equal to \"Cond || FCmp\".\n  if (match(TCmp, m_One()))\n    if (Value *V = SimplifyOrInst(Cond, FCmp, Q, MaxRecurse))\n      return V;\n  // Finally, if the false value simplified to true and the true value to\n  // false, then the result of the compare is equal to \"!Cond\".\n  if (match(FCmp, m_One()) && match(TCmp, m_Zero()))\n    if (Value *V = SimplifyXorInst(\n            Cond, Constant::getAllOnesValue(Cond->getType()), Q, MaxRecurse))\n      return V;\n  return nullptr;\n}\n",
        "fix": null,
        "src_path": "9eb613b2de3163686b1a4bd1160f15ac56a4b083___InstructionSimplify.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/9eb613b2de3163686b1a4bd1160f15ac56a4b083",
        "commit_msg": "[InstSimplify] do not propagate poison from select arm to icmp user\n\nThis is the cause of the miscompile in:\nhttps://llvm.org/PR50944\n\nThe problem has likely existed for some time, but it was made visible with:\n5af8bacc94024 ( D104661 )\nhandleOtherCmpSelSimplifications() assumed it can convert select of\nconstants to bool logic ops, but that does not work with poison.\nWe had a very similar construct in InstCombine, so the fix here\nmimics the fix there.\n\nThe bug is in instsimplify, but I'm not sure how to reproduce it outside of\ninstcombine. The reason this is visible in instcombine is because we have a\nhack (FIXME) to bypass simplification of a select when it has an icmp user:\nhttps://github.com/llvm/llvm-project/blob/955f12589940634acc6c9901e8b25534808f691c/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp#L2632\n\nSo we get to an unusual case where we are trying to simplify an instruction\nthat has an operand that would have already simplified if we had processed\nit in normal order.\n\nDifferential Revision: https://reviews.llvm.org/D105298",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/icmp.ll",
                "patch": "@@ -3935,7 +3935,7 @@ bb:\n \n define i1 @thread_cmp_over_select_with_poison_trueval(i1 %b) {\n ; CHECK-LABEL: @thread_cmp_over_select_with_poison_trueval(\n-; CHECK-NEXT:    ret i1 poison\n+; CHECK-NEXT:    ret i1 false\n ;\n   %s = select i1 %b, i32 poison, i32 0\n   %tobool = icmp ne i32 %s, 0\n@@ -3944,7 +3944,7 @@ define i1 @thread_cmp_over_select_with_poison_trueval(i1 %b) {\n \n define i1 @thread_cmp_over_select_with_poison_falseval(i1 %b) {\n ; CHECK-LABEL: @thread_cmp_over_select_with_poison_falseval(\n-; CHECK-NEXT:    ret i1 poison\n+; CHECK-NEXT:    ret i1 true\n ;\n   %s = select i1 %b, i32 1, i32 poison\n   %tobool = icmp ne i32 %s, 0"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/icmp.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/icmp.ll\n\n\nTesting Time: 0.66s\n  Failed: 1\n"
    },
    "e2b838dd913200702f2eee29100a788c0573bc50___MachineFunction.cpp": {
        "start": 1008,
        "end": 1165,
        "buggy": "auto MachineFunction::salvageCopySSA(MachineInstr &MI)\n    -> DebugInstrOperandPair {\n  MachineRegisterInfo &MRI = getRegInfo();\n  const TargetRegisterInfo &TRI = *MRI.getTargetRegisterInfo();\n  const TargetInstrInfo &TII = *getSubtarget().getInstrInfo();\n\n  // Chase the value read by a copy-like instruction back to the instruction\n  // that ultimately _defines_ that value. This may pass:\n  //  * Through multiple intermediate copies, including subregister moves /\n  //    copies,\n  //  * Copies from physical registers that must then be traced back to the\n  //    defining instruction,\n  //  * Or, physical registers may be live-in to (only) the entry block, which\n  //    requires a DBG_PHI to be created.\n  // We can pursue this problem in that order: trace back through copies,\n  // optionally through a physical register, to a defining instruction. We\n  // should never move from physreg to vreg. As we're still in SSA form, no need\n  // to worry about partial definitions of registers.\n\n  // Helper lambda to interpret a copy-like instruction. Takes instruction,\n  // returns the register read and any subregister identifying which part is\n  // read.\n  auto GetRegAndSubreg =\n      [&](const MachineInstr &Cpy) -> std::pair<Register, unsigned> {\n    Register NewReg, OldReg;\n    unsigned SubReg;\n    if (Cpy.isCopy()) {\n      OldReg = Cpy.getOperand(0).getReg();\n      NewReg = Cpy.getOperand(1).getReg();\n      SubReg = Cpy.getOperand(1).getSubReg();\n    } else if (Cpy.isSubregToReg()) {\n      OldReg = Cpy.getOperand(0).getReg();\n      NewReg = Cpy.getOperand(2).getReg();\n      SubReg = Cpy.getOperand(3).getImm();\n    } else {\n      auto CopyDetails = *TII.isCopyInstr(Cpy);\n      const MachineOperand &Src = *CopyDetails.Source;\n      const MachineOperand &Dest = *CopyDetails.Destination;\n      OldReg = Dest.getReg();\n      NewReg = Src.getReg();\n      SubReg = Src.getSubReg();\n    }\n\n    return {NewReg, SubReg};\n  };\n\n  // First seek either the defining instruction, or a copy from a physreg.\n  // During search, the current state is the current copy instruction, and which\n  // register we've read. Accumulate qualifying subregisters into SubregsSeen;\n  // deal with those later.\n  auto State = GetRegAndSubreg(MI);\n  auto CurInst = MI.getIterator();\n  SmallVector<unsigned, 4> SubregsSeen;\n  while (true) {\n    // If we've found a copy from a physreg, first portion of search is over.\n    if (!State.first.isVirtual())\n      break;\n\n    // Record any subregister qualifier.\n    if (State.second)\n      SubregsSeen.push_back(State.second);\n\n    assert(MRI.hasOneDef(State.first));\n    MachineInstr &Inst = *MRI.def_begin(State.first)->getParent();\n    CurInst = Inst.getIterator();\n\n    // Any non-copy instruction is the defining instruction we're seeking.\n    if (!Inst.isCopyLike() && !TII.isCopyInstr(Inst))\n      break;\n    State = GetRegAndSubreg(Inst);\n  };\n\n  // Helper lambda to apply additional subregister substitutions to a known\n  // instruction/operand pair. Adds new (fake) substitutions so that we can\n  // record the subregister. FIXME: this isn't very space efficient if multiple\n  // values are tracked back through the same copies; cache something later.\n  auto ApplySubregisters =\n      [&](DebugInstrOperandPair P) -> DebugInstrOperandPair {\n    for (unsigned Subreg : reverse(SubregsSeen)) {\n      // Fetch a new instruction number, not attached to an actual instruction.\n      unsigned NewInstrNumber = getNewDebugInstrNum();\n      // Add a substitution from the \"new\" number to the known one, with a\n      // qualifying subreg.\n      makeDebugValueSubstitution({NewInstrNumber, 0}, P, Subreg);\n      // Return the new number; to find the underlying value, consumers need to\n      // deal with the qualifying subreg.\n      P = {NewInstrNumber, 0};\n    }\n    return P;\n  };\n\n  // If we managed to find the defining instruction after COPYs, return an\n  // instruction / operand pair after adding subregister qualifiers.\n  if (State.first.isVirtual()) {\n    // Virtual register def -- we can just look up where this happens.\n    MachineInstr *Inst = MRI.def_begin(State.first)->getParent();\n    for (auto &MO : Inst->operands()) {\n      if (!MO.isReg() || !MO.isDef() || MO.getReg() != State.first)\n        continue;\n      return ApplySubregisters(\n          {Inst->getDebugInstrNum(), Inst->getOperandNo(&MO)});\n    }\n\n    llvm_unreachable(\"Vreg def with no corresponding operand?\");\n  }\n\n  // Our search ended in a copy from a physreg: walk back up the function\n  // looking for whatever defines the physreg.\n  assert(CurInst->isCopyLike() || TII.isCopyInstr(*CurInst));\n  State = GetRegAndSubreg(*CurInst);\n  Register RegToSeek = State.first;\n\n  auto RMII = CurInst->getReverseIterator();\n  auto PrevInstrs = make_range(RMII, CurInst->getParent()->instr_rend());\n  for (auto &ToExamine : PrevInstrs) {\n    for (auto &MO : ToExamine.operands()) {\n      // Test for operand that defines something aliasing RegToSeek.\n      if (!MO.isReg() || !MO.isDef() ||\n          !TRI.regsOverlap(RegToSeek, MO.getReg()))\n        continue;\n\n      return ApplySubregisters(\n          {ToExamine.getDebugInstrNum(), ToExamine.getOperandNo(&MO)});\n    }\n  }\n\n  MachineBasicBlock &InsertBB = *CurInst->getParent();\n\n  // We reached the start of the block before finding a defining instruction.\n  // It could be from a constant register, otherwise it must be an argument.\n  if (TRI.isConstantPhysReg(State.first)) {\n    // We can produce a DBG_PHI that identifies the constant physreg. Doesn't\n    // matter where we put it, as it's constant valued.\n    assert(CurInst->isCopy());\n  } else if (State.first == TRI.getFrameRegister(*this)) {\n    // LLVM IR is allowed to read the framepointer by calling a\n    // llvm.frameaddress.* intrinsic. We can support this by emitting a\n    // DBG_PHI $fp. This isn't ideal, because it extends the behaviours /\n    // position that DBG_PHIs appear at, limiting what can be done later.\n    // TODO: see if there's a better way of expressing these variable\n    // locations.\n    ;\n  } else {\n    // Assert that this is the entry block. If it isn't, then there is some\n    // code construct we don't recognise that deals with physregs across\n    // blocks.\n    assert(!State.first.isVirtual());\n    assert(&*InsertBB.getParent()->begin() == &InsertBB);\n  }\n\n  // Create DBG_PHI for specified physreg.\n  auto Builder = BuildMI(InsertBB, InsertBB.getFirstNonPHI(), DebugLoc(),\n                         TII.get(TargetOpcode::DBG_PHI));\n  Builder.addReg(State.first, RegState::Debug);\n  unsigned NewNum = getNewDebugInstrNum();\n  Builder.addImm(NewNum);\n  return ApplySubregisters({NewNum, 0u});\n}\n",
        "fix": null,
        "src_path": "e2b838dd913200702f2eee29100a788c0573bc50___MachineFunction.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/e2b838dd913200702f2eee29100a788c0573bc50",
        "commit_msg": "[DebugInfo][InstrRef] Accept landingpad block arguments\n\nThis patch makes instruction-referencing accepts an additional scenario\nwhere values can be read from physical registers at the start of blocks. As\nfar as I was aware, this only happened:\n * With arguments in the entry block,\n * With constant physical registers,\n\nTo which this patch adds a third case:\n * With exception-handling landing-pad blocks\n\nIn the attached test: the operand of the dbg.value traces back to the\n\"landingpad\" instruction, which becomes some copies from physregs. Right\nnow, that's deemed unacceptable, and the assertion fires. The fix is to\njust accept this scenario; this is a case where the value in question is\ndefined by a register and a position, not by an instruction that defines\nit. Reading it with a DBG_PHI is the correct behaviour, there isn't a\nnon-copy instruction that we can refer to.\n\nDifferential Revision: https://reviews.llvm.org/D109005",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/X86/instr-ref-eh-landing-pad.ll",
                "patch": "@@ -0,0 +1,92 @@\n+; RUN: llc %s -stop-before=finalize-isel -o -\\\n+; RUN:     -experimental-debug-variable-locations \\\n+; RUN:   | FileCheck %s\n+;\n+; Test that instruction referencing variable locations can cope with exception\n+; landing pads. Variable locations can be derived from the ABI-defined arguments\n+; to landing-pad blocks, which should be treated much like argument locations.\n+; This gloriously simple piece of C++:\n+;\n+;    void a() try { a(); } catch (int *&) { }\n+;\n+; Produces the code below. A nameless variable is attached to the landing-pad\n+; record %0 (via %3), which salvages back to the entry to the landing pad. We\n+; should place a DBG_PHI at that point. Instead of crashing.\n+;\n+; CHECK-LABEL: bb.1.lpad (landing-pad):\n+; CHECK:       DBG_PHI $rax, 1\n+; CHECK-NEXT:  EH_LABEL\n+\n+target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n+target triple = \"x86_64-unknown-linux-gnu\"\n+\n+@_ZTIPi = external dso_local constant i8*\n+\n+define dso_local void @_Z1av() local_unnamed_addr #0 personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) !dbg !8 {\n+entry:\n+  invoke void @_Z1av()\n+          to label %try.cont unwind label %lpad, !dbg !17\n+\n+lpad:                                             ; preds = %entry\n+  %0 = landingpad { i8*, i32 }\n+          catch i8* bitcast (i8** @_ZTIPi to i8*), !dbg !19\n+  %1 = extractvalue { i8*, i32 } %0, 1, !dbg !19\n+  %2 = tail call i32 @llvm.eh.typeid.for(i8* bitcast (i8** @_ZTIPi to i8*)) #3, !dbg !20\n+  %matches = icmp eq i32 %1, %2, !dbg !20\n+  br i1 %matches, label %catch, label %eh.resume, !dbg !20\n+\n+catch:                                            ; preds = %lpad\n+  %3 = extractvalue { i8*, i32 } %0, 0, !dbg !19\n+  %4 = tail call i8* @__cxa_begin_catch(i8* %3) #3, !dbg !20\n+  call void @llvm.dbg.value(metadata i8* %3, metadata !13, metadata !DIExpression(DW_OP_plus_uconst, 32, DW_OP_stack_value)), !dbg !21\n+  tail call void @__cxa_end_catch() #3, !dbg !22\n+  br label %try.cont, !dbg !22\n+\n+try.cont:                                         ; preds = %entry, %catch\n+  ret void, !dbg !24\n+\n+eh.resume:                                        ; preds = %lpad\n+  resume { i8*, i32 } %0, !dbg !20\n+}\n+\n+declare dso_local i32 @__gxx_personality_v0(...)\n+\n+; Function Attrs: nofree nosync nounwind readnone\n+declare i32 @llvm.eh.typeid.for(i8*) #1\n+\n+declare dso_local i8* @__cxa_begin_catch(i8*) local_unnamed_addr\n+\n+declare dso_local void @__cxa_end_catch() local_unnamed_addr\n+\n+; Function Attrs: mustprogress nofree nosync nounwind readnone speculatable willreturn\n+declare void @llvm.dbg.value(metadata, metadata, metadata) #2\n+\n+!llvm.dbg.cu = !{!0}\n+!llvm.module.flags = !{!3, !4, !5, !6}\n+!llvm.ident = !{!7}\n+\n+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus_14, file: !1, producer: \"clang\", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, splitDebugInlining: false, nameTableKind: None)\n+!1 = !DIFile(filename: \"test.cpp\", directory: \".\")\n+!2 = !{}\n+!3 = !{i32 7, !\"Dwarf Version\", i32 4}\n+!4 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!5 = !{i32 1, !\"wchar_size\", i32 4}\n+!6 = !{i32 7, !\"uwtable\", i32 1}\n+!7 = !{!\"clang\"}\n+!8 = distinct !DISubprogram(name: \"a\", linkageName: \"_Z1av\", scope: !9, file: !9, line: 1, type: !10, scopeLine: 1, flags: DIFlagPrototyped | DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !12)\n+!9 = !DIFile(filename: \"test.cpp\", directory: \"\")\n+!10 = !DISubroutineType(types: !11)\n+!11 = !{null}\n+!12 = !{!13}\n+!13 = !DILocalVariable(scope: !8, file: !9, line: 1, type: !14)\n+!14 = !DIDerivedType(tag: DW_TAG_reference_type, baseType: !15, size: 64)\n+!15 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !16, size: 64)\n+!16 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n+!17 = !DILocation(line: 1, column: 16, scope: !18)\n+!18 = distinct !DILexicalBlock(scope: !8, file: !9, line: 1, column: 14)\n+!19 = !DILocation(line: 2, column: 1, scope: !18)\n+!20 = !DILocation(line: 1, column: 21, scope: !18)\n+!21 = !DILocation(line: 0, scope: !8)\n+!22 = !DILocation(line: 2, column: 1, scope: !23)\n+!23 = distinct !DILexicalBlock(scope: !8, file: !9, line: 1, column: 38)\n+!24 = !DILocation(line: 2, column: 1, scope: !8)"
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/X86/instr-ref-eh-landing-pad.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: DebugInfo/X86/instr-ref-eh-landing-pad.ll\n\n\nTesting Time: 7.27s\n  Failed: 1\n"
    },
    "733d7cf9649968c05f41480747ed91c7b0c3a82f___CoroFrame.cpp": {
        "start": 2552,
        "end": 2643,
        "buggy": "void coro::salvageDebugInfo(\n    SmallDenseMap<llvm::Value *, llvm::AllocaInst *, 4> &DbgPtrAllocaCache,\n    DbgVariableIntrinsic *DVI, bool OptimizeFrame) {\n  Function *F = DVI->getFunction();\n  IRBuilder<> Builder(F->getContext());\n  auto InsertPt = F->getEntryBlock().getFirstInsertionPt();\n  while (isa<IntrinsicInst>(InsertPt))\n    ++InsertPt;\n  Builder.SetInsertPoint(&F->getEntryBlock(), InsertPt);\n  DIExpression *Expr = DVI->getExpression();\n  // Follow the pointer arithmetic all the way to the incoming\n  // function argument and convert into a DIExpression.\n  bool SkipOutermostLoad = !isa<DbgValueInst>(DVI);\n  Value *Storage = DVI->getVariableLocationOp(0);\n  Value *OriginalStorage = Storage;\n  while (auto *Inst = dyn_cast_or_null<Instruction>(Storage)) {\n    if (auto *LdInst = dyn_cast<LoadInst>(Inst)) {\n      Storage = LdInst->getOperand(0);\n      // FIXME: This is a heuristic that works around the fact that\n      // LLVM IR debug intrinsics cannot yet distinguish between\n      // memory and value locations: Because a dbg.declare(alloca) is\n      // implicitly a memory location no DW_OP_deref operation for the\n      // last direct load from an alloca is necessary.  This condition\n      // effectively drops the *last* DW_OP_deref in the expression.\n      if (!SkipOutermostLoad)\n        Expr = DIExpression::prepend(Expr, DIExpression::DerefBefore);\n    } else if (auto *StInst = dyn_cast<StoreInst>(Inst)) {\n      Storage = StInst->getOperand(0);\n    } else {\n      SmallVector<uint64_t, 16> Ops;\n      SmallVector<Value *, 0> AdditionalValues;\n      Value *Op = llvm::salvageDebugInfoImpl(\n          *Inst, Expr ? Expr->getNumLocationOperands() : 0, Ops,\n          AdditionalValues);\n      if (!Op || !AdditionalValues.empty()) {\n        // If salvaging failed or salvaging produced more than one location\n        // operand, give up.\n        break;\n      }\n      Storage = Op;\n      Expr = DIExpression::appendOpsToArg(Expr, Ops, 0, /*StackValue*/ false);\n    }\n    SkipOutermostLoad = false;\n  }\n  if (!Storage)\n    return;\n\n  // Store a pointer to the coroutine frame object in an alloca so it\n  // is available throughout the function when producing unoptimized\n  // code. Extending the lifetime this way is correct because the\n  // variable has been declared by a dbg.declare intrinsic.\n  //\n  // Avoid to create the alloca would be eliminated by optimization\n  // passes and the corresponding dbg.declares would be invalid.\n  if (!OptimizeFrame)\n    if (auto *Arg = dyn_cast<llvm::Argument>(Storage)) {\n      auto &Cached = DbgPtrAllocaCache[Storage];\n      if (!Cached) {\n        Cached = Builder.CreateAlloca(Storage->getType(), 0, nullptr,\n                                      Arg->getName() + \".debug\");\n        Builder.CreateStore(Storage, Cached);\n      }\n      Storage = Cached;\n      // FIXME: LLVM lacks nuanced semantics to differentiate between\n      // memory and direct locations at the IR level. The backend will\n      // turn a dbg.declare(alloca, ..., DIExpression()) into a memory\n      // location. Thus, if there are deref and offset operations in the\n      // expression, we need to add a DW_OP_deref at the *start* of the\n      // expression to first load the contents of the alloca before\n      // adjusting it with the expression.\n      if (Expr && Expr->isComplex())\n        Expr = DIExpression::prepend(Expr, DIExpression::DerefBefore);\n    }\n\n  DVI->replaceVariableLocationOp(OriginalStorage, Storage);\n  DVI->setExpression(Expr);\n  // We only hoist dbg.declare today since it doesn't make sense to hoist\n  // dbg.value or dbg.addr since they do not have the same function wide\n  // guarantees that dbg.declare does.\n  if (!isa<DbgValueInst>(DVI) && !isa<DbgAddrIntrinsic>(DVI)) {\n    if (auto *II = dyn_cast<InvokeInst>(Storage))\n      DVI->moveBefore(II->getNormalDest()->getFirstNonPHI());\n    else if (auto *CBI = dyn_cast<CallBrInst>(Storage))\n      DVI->moveBefore(CBI->getDefaultDest()->getFirstNonPHI());\n    else if (auto *InsertPt = dyn_cast<Instruction>(Storage)) {\n      assert(!InsertPt->isTerminator() &&\n             \"Unimaged terminator that could return a storage.\");\n      DVI->moveAfter(InsertPt);\n    } else if (isa<Argument>(Storage))\n      DVI->moveAfter(F->getEntryBlock().getFirstNonPHI());\n  }\n}\n",
        "fix": null,
        "src_path": "733d7cf9649968c05f41480747ed91c7b0c3a82f___CoroFrame.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/733d7cf9649968c05f41480747ed91c7b0c3a82f",
        "commit_msg": "[Debug] [Coroutines] Add deref operator for non complex expression\n\nBackground:\n\nWhen we construct coroutine frame, we would insert a dbg.declare\nintrinsic for it:\n```\n%hdl = call void @llvm.coro.begin() ; would return coroutine handle\ncall void @llvm.dbg.declare(metadata ptr %hdl, metadata\n![[DEBUG_VARIABLE: __coro_frame]], metadata !DIExpression())\n```\n\nAnd in the splitted coroutine, it looks like:\n```\ndefine void @coro_func.resume(ptr *hdl) {\nentry.resume:\n    call void @llvm.dbg.declare(metadata ptr %hdl, metadata\n![[DEBUG_VARIABLE: __coro_frame]], metadata !DIExpression())\n}\n```\n\nAnd we would salvage the debug info by inserting a new alloca here:\n```\ndefine void @coro_func.resume(ptr %hdl) {\nentry.resume:\n    %frame.debug = alloca ptr\n    call void @llvm.dbg.declare(metadata ptr %frame.debug, metadata\n![[DEBUG_VARIABLE: __coro_frame]], metadata !DIExpression())\n    store ptr %hdl, %frame.debug\n}\n```\n\nBut now, the problem comes since the `dbg.declare` refers to the address\nof that alloca instead of actual coroutine handle. I saw there are codes\nto solve the problem but it only applies to complex expression only. I\nfeel if it is OK to relax the condition to make it work for\n`__coro_frame`.\n\nReviewed By: jmorse\n\nDifferential Revision: https://reviews.llvm.org/D126277",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/Coroutines/coro-debug-coro-frame.ll",
                "patch": "@@ -10,7 +10,8 @@\n ;\n ; CHECK:       define internal fastcc void @f.resume(\n ; CHECK:       entry.resume:\n-; CHECK:            call void @llvm.dbg.declare(metadata %f.Frame** %[[FramePtr_RESUME:.*]], metadata ![[CORO_FRAME_IN_RESUME:[0-9]+]], metadata !DIExpression()\n+; CHECK:            %[[FramePtr_RESUME:.*]] = alloca %f.Frame*\n+; CHECK:            call void @llvm.dbg.declare(metadata %f.Frame** %[[FramePtr_RESUME]], metadata ![[CORO_FRAME_IN_RESUME:[0-9]+]], metadata !DIExpression(DW_OP_deref)\n ;\n ; CHECK-DAG: ![[FILE:[0-9]+]] = !DIFile(filename: \"coro-debug.cpp\"\n ; CHECK-DAG: ![[RAMP:[0-9]+]] = distinct !DISubprogram(name: \"foo\", linkageName: \"_Z3foov\","
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/Coroutines/coro-debug-coro-frame.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/Coroutines/coro-debug-coro-frame.ll\n\n\nTesting Time: 0.50s\n  Failed: 1\n"
    },
    "534b9246a20498e2cd4d2b9a512e7c5e75c83bc7___LoopInfo.cpp": {
        "start": 482,
        "end": 498,
        "buggy": "bool Loop::isSafeToClone() const {\n  // Return false if any loop blocks contain indirectbrs, or there are any calls\n  // to noduplicate functions.\n  // FIXME: it should be ok to clone CallBrInst's if we correctly update the\n  // operand list to reflect the newly cloned labels.\n  for (BasicBlock *BB : this->blocks()) {\n    if (isa<IndirectBrInst>(BB->getTerminator()) ||\n        isa<CallBrInst>(BB->getTerminator()))\n      return false;\n\n    for (Instruction &I : *BB)\n      if (auto *CB = dyn_cast<CallBase>(&I))\n        if (CB->cannotDuplicate())\n          return false;\n  }\n  return true;\n}\n",
        "fix": null,
        "src_path": "534b9246a20498e2cd4d2b9a512e7c5e75c83bc7___LoopInfo.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/534b9246a20498e2cd4d2b9a512e7c5e75c83bc7",
        "commit_msg": "[LoopInfo] Allow cloning of callbr\n\nAfter D129288, callbr is safe to clone without special handling.\nThis permits optimizations like loop unroll and loop unswitch on\nloops containing callbrs.\n\nFixes https://github.com/llvm/llvm-project/issues/41834.\n\nDifferential Revision: https://reviews.llvm.org/D129993",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/LoopUnroll/callbr.ll",
                "patch": "@@ -1,19 +1,13 @@\n ; NOTE: Assertions have been autogenerated by utils/update_test_checks.py\n ; RUN: opt -loop-unroll -S %s | FileCheck %s\n \n-; Check that the loop body does not get unrolled.  We could modify this test in\n-; the future to support loop unrolling callbr's IFF we checked that the callbr\n-; operands were unrolled/updated correctly, as today they are not.\n+; Check that the loop body containing callbr is correctly unrolled.\n define dso_local void @d() {\n ; CHECK-LABEL: @d(\n ; CHECK-NEXT:  entry:\n ; CHECK-NEXT:    br label [[FOR_BODY:%.*]]\n-; CHECK:       for.cond.cleanup:\n-; CHECK-NEXT:    ret void\n ; CHECK:       for.body:\n-; CHECK-NEXT:    [[E_04:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_INC:%.*]] ]\n-; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp eq i32 [[E_04]], 0\n-; CHECK-NEXT:    br i1 [[TOBOOL]], label [[FOR_INC]], label [[IF_THEN:%.*]]\n+; CHECK-NEXT:    br i1 true, label [[FOR_INC:%.*]], label [[IF_THEN:%.*]]\n ; CHECK:       if.then:\n ; CHECK-NEXT:    callbr void asm sideeffect \"1: nop\\0A\\09.quad b, ${0:l}, $$5\\0A\\09\", \"!i,~{dirflag},~{fpsr},~{flags}\"()\n ; CHECK-NEXT:    to label [[ASM_FALLTHROUGH:%.*]] [label %l_yes]\n@@ -23,9 +17,27 @@ define dso_local void @d() {\n ; CHECK-NEXT:    [[CALL:%.*]] = tail call i32 (...) @g()\n ; CHECK-NEXT:    br label [[FOR_INC]]\n ; CHECK:       for.inc:\n-; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[E_04]], 1\n-; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[INC]], 3\n-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY]]\n+; CHECK-NEXT:    br i1 false, label [[FOR_INC_1:%.*]], label [[IF_THEN_1:%.*]]\n+; CHECK:       if.then.1:\n+; CHECK-NEXT:    callbr void asm sideeffect \"1: nop\\0A\\09.quad b, ${0:l}, $$5\\0A\\09\", \"!i,~{dirflag},~{fpsr},~{flags}\"()\n+; CHECK-NEXT:    to label [[ASM_FALLTHROUGH_1:%.*]] [label %l_yes.1]\n+; CHECK:       asm.fallthrough.1:\n+; CHECK-NEXT:    br label [[L_YES_1:%.*]]\n+; CHECK:       l_yes.1:\n+; CHECK-NEXT:    [[CALL_1:%.*]] = tail call i32 (...) @g()\n+; CHECK-NEXT:    br label [[FOR_INC_1]]\n+; CHECK:       for.inc.1:\n+; CHECK-NEXT:    br i1 false, label [[FOR_INC_2:%.*]], label [[IF_THEN_2:%.*]]\n+; CHECK:       if.then.2:\n+; CHECK-NEXT:    callbr void asm sideeffect \"1: nop\\0A\\09.quad b, ${0:l}, $$5\\0A\\09\", \"!i,~{dirflag},~{fpsr},~{flags}\"()\n+; CHECK-NEXT:    to label [[ASM_FALLTHROUGH_2:%.*]] [label %l_yes.2]\n+; CHECK:       asm.fallthrough.2:\n+; CHECK-NEXT:    br label [[L_YES_2:%.*]]\n+; CHECK:       l_yes.2:\n+; CHECK-NEXT:    [[CALL_2:%.*]] = tail call i32 (...) @g()\n+; CHECK-NEXT:    br label [[FOR_INC_2]]\n+; CHECK:       for.inc.2:\n+; CHECK-NEXT:    ret void\n ;\n entry:\n   br label %for.body"
            },
            {
                "fn": "llvm/test/Transforms/SimpleLoopUnswitch/callbr.ll",
                "patch": "@@ -6,12 +6,20 @@ declare i1 @foo()\n define i32 @mem_cgroup_node_nr_lru_pages(i1 %tree) {\n ; CHECK-LABEL: @mem_cgroup_node_nr_lru_pages(\n ; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    br i1 [[TREE:%.*]], label [[ENTRY_SPLIT_US:%.*]], label [[ENTRY_SPLIT:%.*]]\n+; CHECK:       entry.split.us:\n+; CHECK-NEXT:    br label [[FOR_COND_US:%.*]]\n+; CHECK:       for.cond.us:\n+; CHECK-NEXT:    br label [[IF_END8_US:%.*]]\n+; CHECK:       if.end8.us:\n+; CHECK-NEXT:    br label [[FOR_COND_US]]\n+; CHECK:       entry.split:\n ; CHECK-NEXT:    br label [[FOR_COND:%.*]]\n ; CHECK:       for.cond:\n-; CHECK-NEXT:    br i1 [[TREE:%.*]], label [[IF_END8:%.*]], label [[IF_ELSE:%.*]]\n+; CHECK-NEXT:    br label [[IF_ELSE:%.*]]\n ; CHECK:       if.else:\n ; CHECK-NEXT:    callbr void asm sideeffect \".pushsection __jump_table, \\22aw\\22 \\0A\\09.popsection \\0A\\09\", \"!i,~{dirflag},~{fpsr},~{flags}\"()\n-; CHECK-NEXT:    to label [[IF_END8]] [label %for.cond5.preheader]\n+; CHECK-NEXT:    to label [[IF_END8:%.*]] [label %for.cond5.preheader]\n ; CHECK:       for.cond5.preheader:\n ; CHECK-NEXT:    br label [[FOR_COND5:%.*]]\n ; CHECK:       for.cond5:"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/LoopUnroll/callbr.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopUnroll/callbr.ll\n\n\nTesting Time: 1.40s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/SimpleLoopUnswitch/callbr.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SimpleLoopUnswitch/callbr.ll\n\n\nTesting Time: 0.25s\n  Failed: 1\n"
    },
    "51d4c7ceea61b5d83ba52398b5ca6d58d7551044___GlobalOpt.cpp": {
        "start": 1812,
        "end": 1840,
        "buggy": "static bool\nhasOnlyColdCalls(Function &F,\n                 function_ref<BlockFrequencyInfo &(Function &)> GetBFI) {\n  for (BasicBlock &BB : F) {\n    for (Instruction &I : BB) {\n      if (CallInst *CI = dyn_cast<CallInst>(&I)) {\n        // Skip over isline asm instructions since they aren't function calls.\n        if (CI->isInlineAsm())\n          continue;\n        Function *CalledFn = CI->getCalledFunction();\n        if (!CalledFn)\n          return false;\n        if (!CalledFn->hasLocalLinkage())\n          return false;\n        // Skip over intrinsics since they won't remain as function calls.\n        if (CalledFn->getIntrinsicID() != Intrinsic::not_intrinsic)\n          continue;\n        // Check if it's valid to use coldcc calling convention.\n        if (!hasChangeableCC(CalledFn) || CalledFn->isVarArg() ||\n            CalledFn->hasAddressTaken())\n          return false;\n        BlockFrequencyInfo &CallerBFI = GetBFI(F);\n        if (!isColdCallSite(*CI, CallerBFI))\n          return false;\n      }\n    }\n  }\n  return true;\n}\n",
        "fix": null,
        "src_path": "51d4c7ceea61b5d83ba52398b5ca6d58d7551044___GlobalOpt.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/51d4c7ceea61b5d83ba52398b5ca6d58d7551044",
        "commit_msg": "[GlobalOpt] Fix debug variance problem in hasOnlyColdCalls\n\nhasOnlyColdCalls skipped over calls to intrinsics, but it did so after\nchecking the linkage of the called function. This meant that the presence\nof a call to a debug intrinsic could affect the outcome of the\noptimization.\n\nIn my original reproducer (for an out of tree target) it was particularly\ninteresting, because the actual IR after GlobalOpt was not different with\ndebug instrinsics present, so -print-after-all printouts didn't show\nanything there.\n\nHowever, without debuginfo, GlobalOpt went further and ran\nBlockFrequencyAnalysis and (more importanly) LoopAnalysis, and later on in\nthe pipeline, instcombine behaved in different ways when LoopInfo was\npresent.\n\nSo a call to a dbg.declare prevented running LoopAnalysis in\nGlobalOpt, which later prevented InstCombine from doing an optimization.\n\nThe dbg-intrinsic-loopanalysis.ll testcase tries to expose this.\n\nThen I also noted that adding a dbg.declare actually made the existing\ntestcase colccc_coldsites.ll generate different code, so I modified that\nto now test it behaves the same way with and without the dbg.declare.\n\nReviewed By: nikic, fhahn\n\nDifferential Revision: https://reviews.llvm.org/D133193",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/GlobalOpt/PowerPC/coldcc_coldsites.ll",
                "patch": "@@ -1,7 +1,9 @@\n+; RUN: opt -strip-debug -S < %s | opt -passes=globalopt -mtriple=powerpc64le-unknown-linux-gnu -ppc-enable-coldcc -S | FileCheck %s -check-prefix=COLDCC\n+; RUN: opt -strip-debug -S < %s | opt -passes=globalopt -S | FileCheck %s -check-prefix=CHECK\n ; RUN: opt -passes=globalopt -mtriple=powerpc64le-unknown-linux-gnu -ppc-enable-coldcc -S < %s | FileCheck %s -check-prefix=COLDCC\n ; RUN: opt -passes=globalopt -S < %s | FileCheck %s -check-prefix=CHECK\n \n-define signext i32 @caller(i32 signext %a, i32 signext %b, i32 signext %lim, i32 signext %i) local_unnamed_addr #0 !prof !30 {\n+define signext i32 @caller(i32 signext %a, i32 signext %b, i32 signext %lim, i32 signext %i, ptr %k) local_unnamed_addr #0 !prof !30 {\n entry:\n ; COLDCC: call coldcc signext i32 @callee\n ; CHECK: call fastcc signext i32 @callee\n@@ -11,6 +13,7 @@ entry:\n   br i1 %cmp, label %if.then, label %if.end, !prof !31\n \n if.then:                                          ; preds = %entry\n+  call void @llvm.dbg.declare(metadata ptr %k, metadata !101, metadata !DIExpression()), !dbg !122\n   %call = tail call signext i32 @callee(i32 signext %a, i32 signext %b)\n   br label %if.end\n \n@@ -45,7 +48,15 @@ for.body:                                         ; preds = %for.body, %entry\n   %exitcond = icmp eq i32 %inc, 10000000\n   br i1 %exitcond, label %for.cond.cleanup, label %for.body, !prof !34\n }\n+\n+; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn\n+declare void @llvm.dbg.declare(metadata, metadata, metadata)  #2\n+\n attributes #0 = { noinline }\n+attributes #2 = { nocallback nofree nosync nounwind readnone speculatable willreturn }\n+\n+!llvm.dbg.cu = !{!117}\n+!llvm.module.flags = !{!100}\n \n !0 = !{i32 1, !\"ProfileSummary\", !1}\n !1 = !{!2, !3, !4, !5, !6, !7, !8, !9}\n@@ -79,3 +90,16 @@ attributes #0 = { noinline }\n !32 = !{i32 59}\n !33 = !{!\"function_entry_count\", i64 1}\n !34 = !{!\"branch_weights\", i32 2, i32 10000001}\n+\n+!100 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!101 = !DILocalVariable(name: \"k\", arg: 1, scope: !102, file: !103, line: 13, type: !119)\n+!102 = distinct !DISubprogram(name: \"h\", scope: !103, file: !103, line: 13, type: !104, scopeLine: 13, flags: DIFlagAllCallsDescribed, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition | DISPFlagOptimized, unit: !117, retainedNodes: !121)\n+!103 = !DIFile(filename: \"foo2.c\", directory: \"/bar\")\n+!104 = !DISubroutineType(types: !105)\n+!105 = !{!119}\n+!117 = distinct !DICompileUnit(language: DW_LANG_C99, file: !103, producer: \"clang version 16\", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, retainedTypes: !118, globals: !120, splitDebugInlining: false, nameTableKind: None)\n+!118 = !{!119}\n+!119 = !DIBasicType(name: \"int\", size: 16, encoding: DW_ATE_signed)\n+!120 = !{}\n+!121 = !{!101}\n+!122 = !DILocation(line: 13, column: 27, scope: !102)"
            },
            {
                "fn": "llvm/test/Transforms/GlobalOpt/dbg-intrinsic-loopanalysis.ll",
                "patch": "@@ -0,0 +1,46 @@\n+; RUN: opt -passes=\"globalopt\" < %s -o /dev/null -debug-pass-manager 2>&1 | FileCheck %s\n+; RUN: opt -strip-debug -S < %s | opt -passes=\"globalopt\" -o /dev/null -debug-pass-manager 2>&1 | FileCheck %s\n+\n+; Make sure that the call to dbg.declare does not prevent running BlockFrequency\n+; and (especially) Loop Analysis.\n+; Later passes (e.g. instcombine) may behave in different ways depending on if\n+; LoopInfo is available or not. Therefore, letting GlobalOpt run or not run\n+; LoopAnalysis depending on the presence of a dbg.declare may make the compiler\n+; generate different code with and without debug info.\n+\n+; CHECK: Running pass: GlobalOptPass on [module]\n+; CHECK: Running analysis: BlockFrequencyAnalysis on h\n+; CHECK: Running analysis: LoopAnalysis on h\n+\n+define i16 @h(ptr %k) {\n+entry:\n+  call void @llvm.dbg.declare(metadata ptr %k, metadata !1, metadata !DIExpression()), !dbg !22\n+  %call = call i16 @gaz()\n+  ret i16 %call\n+}\n+\n+; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn\n+declare void @llvm.dbg.declare(metadata, metadata, metadata)  #0\n+\n+define internal i16 @gaz() {\n+entry:\n+  ret i16 0\n+}\n+\n+attributes #0 = { nocallback nofree nosync nounwind readnone speculatable willreturn }\n+\n+!llvm.dbg.cu = !{!17}\n+!llvm.module.flags = !{!0}\n+\n+!0 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!1 = !DILocalVariable(name: \"k\", arg: 1, scope: !2, file: !3, line: 13, type: !19)\n+!2 = distinct !DISubprogram(name: \"h\", scope: !3, file: !3, line: 13, type: !4, scopeLine: 13, flags: DIFlagAllCallsDescribed, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition | DISPFlagOptimized, unit: !17, retainedNodes: !21)\n+!3 = !DIFile(filename: \"foo2.c\", directory: \"/bar\")\n+!4 = !DISubroutineType(types: !5)\n+!5 = !{!19}\n+!17 = distinct !DICompileUnit(language: DW_LANG_C99, file: !3, producer: \"clang version 16\", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, retainedTypes: !18, globals: !20, splitDebugInlining: false, nameTableKind: None)\n+!18 = !{!19}\n+!19 = !DIBasicType(name: \"int\", size: 16, encoding: DW_ATE_signed)\n+!20 = !{}\n+!21 = !{!1}\n+!22 = !DILocation(line: 13, column: 27, scope: !2)"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/GlobalOpt/dbg-intrinsic-loopanalysis.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/GlobalOpt/dbg-intrinsic-loopanalysis.ll\n\n\nTesting Time: 0.22s\n  Failed: 1\n"
    },
    "8df376db7282b955e7990cb8887ee9dcd3565040___InstCombineCasts.cpp": {
        "start": 989,
        "end": 1105,
        "buggy": "Instruction *InstCombinerImpl::transformZExtICmp(ICmpInst *Cmp, ZExtInst &Zext) {\n  // If we are just checking for a icmp eq of a single bit and zext'ing it\n  // to an integer, then shift the bit to the appropriate place and then\n  // cast to integer to avoid the comparison.\n\n  // FIXME: This set of transforms does not check for extra uses and/or creates\n  //        an extra instruction (an optional final cast is not included\n  //        in the transform comments). We may also want to favor icmp over\n  //        shifts in cases of equal instructions because icmp has better\n  //        analysis in general (invert the transform).\n\n  const APInt *Op1CV;\n  if (match(Cmp->getOperand(1), m_APInt(Op1CV))) {\n\n    // zext (x <s  0) to i32 --> x>>u31      true if signbit set.\n    if (Cmp->getPredicate() == ICmpInst::ICMP_SLT && Op1CV->isZero()) {\n      Value *In = Cmp->getOperand(0);\n      Value *Sh = ConstantInt::get(In->getType(),\n                                   In->getType()->getScalarSizeInBits() - 1);\n      In = Builder.CreateLShr(In, Sh, In->getName() + \".lobit\");\n      if (In->getType() != Zext.getType())\n        In = Builder.CreateIntCast(In, Zext.getType(), false /*ZExt*/);\n\n      return replaceInstUsesWith(Zext, In);\n    }\n\n    // zext (X == 0) to i32 --> X^1      iff X has only the low bit set.\n    // zext (X == 0) to i32 --> (X>>1)^1 iff X has only the 2nd bit set.\n    // zext (X == 1) to i32 --> X        iff X has only the low bit set.\n    // zext (X == 2) to i32 --> X>>1     iff X has only the 2nd bit set.\n    // zext (X != 0) to i32 --> X        iff X has only the low bit set.\n    // zext (X != 0) to i32 --> X>>1     iff X has only the 2nd bit set.\n    // zext (X != 1) to i32 --> X^1      iff X has only the low bit set.\n    // zext (X != 2) to i32 --> (X>>1)^1 iff X has only the 2nd bit set.\n    if ((Op1CV->isZero() || Op1CV->isPowerOf2()) &&\n        // This only works for EQ and NE\n        Cmp->isEquality()) {\n      // If Op1C some other power of two, convert:\n      KnownBits Known = computeKnownBits(Cmp->getOperand(0), 0, &Zext);\n\n      APInt KnownZeroMask(~Known.Zero);\n      if (KnownZeroMask.isPowerOf2()) { // Exactly 1 possible 1?\n        bool isNE = Cmp->getPredicate() == ICmpInst::ICMP_NE;\n        uint32_t ShAmt = KnownZeroMask.logBase2();\n        Value *In = Cmp->getOperand(0);\n        if (ShAmt) {\n          // Perform a logical shr by shiftamt.\n          // Insert the shift to put the result in the low bit.\n          In = Builder.CreateLShr(In, ConstantInt::get(In->getType(), ShAmt),\n                                  In->getName() + \".lobit\");\n        }\n\n        if (!Op1CV->isZero() == isNE) { // Toggle the low bit.\n          Constant *One = ConstantInt::get(In->getType(), 1);\n          In = Builder.CreateXor(In, One);\n        }\n\n        if (Zext.getType() == In->getType())\n          return replaceInstUsesWith(Zext, In);\n\n        Value *IntCast = Builder.CreateIntCast(In, Zext.getType(), false);\n        return replaceInstUsesWith(Zext, IntCast);\n      }\n    }\n  }\n\n  if (Cmp->isEquality() && Zext.getType() == Cmp->getOperand(0)->getType()) {\n    // Test if a bit is clear/set using a shifted-one mask:\n    // zext (icmp eq (and X, (1 << ShAmt)), 0) --> and (lshr (not X), ShAmt), 1\n    // zext (icmp ne (and X, (1 << ShAmt)), 0) --> and (lshr X, ShAmt), 1\n    Value *X, *ShAmt;\n    if (Cmp->hasOneUse() && match(Cmp->getOperand(1), m_ZeroInt()) &&\n        match(Cmp->getOperand(0),\n              m_OneUse(m_c_And(m_Shl(m_One(), m_Value(ShAmt)), m_Value(X))))) {\n      if (Cmp->getPredicate() == ICmpInst::ICMP_EQ)\n        X = Builder.CreateNot(X);\n      Value *Lshr = Builder.CreateLShr(X, ShAmt);\n      Value *And1 = Builder.CreateAnd(Lshr, ConstantInt::get(X->getType(), 1));\n      return replaceInstUsesWith(Zext, And1);\n    }\n\n    // icmp ne A, B is equal to xor A, B when A and B only really have one bit.\n    // It is also profitable to transform icmp eq into not(xor(A, B)) because\n    // that may lead to additional simplifications.\n    if (IntegerType *ITy = dyn_cast<IntegerType>(Zext.getType())) {\n      Value *LHS = Cmp->getOperand(0);\n      Value *RHS = Cmp->getOperand(1);\n\n      KnownBits KnownLHS = computeKnownBits(LHS, 0, &Zext);\n      KnownBits KnownRHS = computeKnownBits(RHS, 0, &Zext);\n\n      if (KnownLHS == KnownRHS) {\n        APInt KnownBits = KnownLHS.Zero | KnownLHS.One;\n        APInt UnknownBit = ~KnownBits;\n        if (UnknownBit.countPopulation() == 1) {\n          Value *Result = Builder.CreateXor(LHS, RHS);\n\n          // Mask off any bits that are set and won't be shifted away.\n          if (KnownLHS.One.uge(UnknownBit))\n            Result = Builder.CreateAnd(Result,\n                                        ConstantInt::get(ITy, UnknownBit));\n\n          // Shift the bit we're testing down to the lsb.\n          Result = Builder.CreateLShr(\n               Result, ConstantInt::get(ITy, UnknownBit.countTrailingZeros()));\n\n          if (Cmp->getPredicate() == ICmpInst::ICMP_EQ)\n            Result = Builder.CreateXor(Result, ConstantInt::get(ITy, 1));\n          Result->takeName(Cmp);\n          return replaceInstUsesWith(Zext, Result);\n        }\n      }\n    }\n  }\n\n  return nullptr;\n}\n",
        "fix": null,
        "src_path": "8df376db7282b955e7990cb8887ee9dcd3565040___InstCombineCasts.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/8df376db7282b955e7990cb8887ee9dcd3565040",
        "commit_msg": "[InstCombine] Remove buggy zext of icmp eq with pow2 fold (PR57899)\n\nFor the case where the constant is a power of two rather than zero,\nthe fold is incorrect, because it fails to check that the bit set\nin the LHS matches the bit in the RHS.\n\nRather than fixing this, remove the power of two handling entirely,\nas a different fold will already canonicalize such comparisons to\nuse a zero constant.\n\nFixes https://github.com/llvm/llvm-project/issues/57899.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/zext.ll",
                "patch": "@@ -511,15 +511,14 @@ define i8 @disguised_signbit_clear_test(i64 %x) {\n   ret i8 %t6\n }\n \n-; FIXME: Currently miscompiled.\n define i16 @pr57899(i1 %c, i32 %x) {\n ; CHECK-LABEL: @pr57899(\n ; CHECK-NEXT:  entry:\n ; CHECK-NEXT:    br i1 [[C:%.*]], label [[IF:%.*]], label [[JOIN:%.*]]\n ; CHECK:       if:\n ; CHECK-NEXT:    br label [[JOIN]]\n ; CHECK:       join:\n-; CHECK-NEXT:    ret i16 0\n+; CHECK-NEXT:    ret i16 1\n ;\n entry:\n   br i1 %c, label %if, label %join"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/zext.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/zext.ll\n\n\nTesting Time: 0.31s\n  Failed: 1\n"
    },
    "d8f541efe7b40fe49664054ad0e7306641762131___DAGCombiner.cpp": {
        "start": 14243,
        "end": 14306,
        "buggy": "SDValue DAGCombiner::visitFREEZE(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n\n  if (DAG.isGuaranteedNotToBeUndefOrPoison(N0, /*PoisonOnly*/ false))\n    return N0;\n\n  // Fold freeze(op(x, ...)) -> op(freeze(x), ...).\n  // Try to push freeze through instructions that propagate but don't produce\n  // poison as far as possible. If an operand of freeze follows three\n  // conditions 1) one-use, 2) does not produce poison, and 3) has all but one\n  // guaranteed-non-poison operands (or is a BUILD_VECTOR or similar) then push\n  // the freeze through to the operands that are not guaranteed non-poison.\n  if (DAG.canCreateUndefOrPoison(N0, /*PoisonOnly*/ false,\n                                 /*ConsiderFlags*/ false) ||\n      N0->getNumValues() != 1 || !N0->hasOneUse())\n    return SDValue();\n\n  bool AllowMultipleMaybePoisonOperands = N0.getOpcode() == ISD::BUILD_VECTOR;\n\n  SmallSetVector<SDValue, 8> MaybePoisonOperands;\n  for (SDValue Op : N0->ops()) {\n    if (DAG.isGuaranteedNotToBeUndefOrPoison(Op, /*PoisonOnly*/ false,\n                                             /*Depth*/ 1))\n      continue;\n    bool HadMaybePoisonOperands = !MaybePoisonOperands.empty();\n    bool IsNewMaybePoisonOperand = MaybePoisonOperands.insert(Op);\n    if (!HadMaybePoisonOperands)\n      continue;\n    if (IsNewMaybePoisonOperand && !AllowMultipleMaybePoisonOperands) {\n      // Multiple maybe-poison ops when not allowed - bail out.\n      return SDValue();\n    }\n  }\n  if (MaybePoisonOperands.empty())\n    return SDValue();\n\n  for (SDValue MaybePoisonOperand : MaybePoisonOperands) {\n    // Don't replace every single UNDEF everywhere with frozen UNDEF, though.\n    if (MaybePoisonOperand.getOpcode() == ISD::UNDEF)\n      continue;\n    // First, freeze each offending operand.\n    SDValue FrozenMaybePoisonOperand = DAG.getFreeze(MaybePoisonOperand);\n    // Then, change all other uses of unfrozen operand to use frozen operand.\n    DAG.ReplaceAllUsesOfValueWith(MaybePoisonOperand, FrozenMaybePoisonOperand);\n    // But, that also updated the use in the freeze we just created, thus\n    // creating a cycle in a DAG. Let's undo that by mutating the freeze.\n    DAG.UpdateNodeOperands(FrozenMaybePoisonOperand.getNode(),\n                           MaybePoisonOperand);\n  }\n\n  // Finally, recreate the node, it's operands were updated to use\n  // frozen operands, so we just need to use it's \"original\" operands.\n  SmallVector<SDValue> Ops(N0->op_begin(), N0->op_end());\n  // Special-handle ISD::UNDEF, each single one of them can be it's own thing.\n  for (SDValue &Op : Ops) {\n    if (Op.getOpcode() == ISD::UNDEF)\n      Op = DAG.getFreeze(Op);\n  }\n  // TODO: Just strip poison generating flags?\n  SDValue R = DAG.getNode(N0.getOpcode(), SDLoc(N0), N0->getVTList(), Ops);\n  assert(DAG.isGuaranteedNotToBeUndefOrPoison(R, /*PoisonOnly*/ false) &&\n         \"Can't create node that may be undef/poison!\");\n  return R;\n}\n",
        "fix": null,
        "src_path": "d8f541efe7b40fe49664054ad0e7306641762131___DAGCombiner.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/d8f541efe7b40fe49664054ad0e7306641762131",
        "commit_msg": "[DAGCombiner] `visitFREEZE()`: fix handling of no maybe-poison ops\n\nThe original code was confusing. It was stripping poison-generating flags,\nbut the comments were saying that doing so was a TODO.\n\nIf the poison-generating flags are present, then even if all operands\nare guaranteed not to be undef or poison, the whole operation may still\nproduce undef or poison. We can still deal with that case,\nand we already do deal with it in fact, by also dropping those flags.\n\nRefs. https://github.com/llvm/llvm-project/issues/59676",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/freeze-binary.ll",
                "patch": "@@ -836,10 +836,9 @@ define void @pr59676_nsw_frozen(ptr %dst, i32 %x.orig) {\n ; X86-LABEL: pr59676_nsw_frozen:\n ; X86:       # %bb.0:\n ; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n-; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx\n-; X86-NEXT:    imull $42, %edx, %eax\n-; X86-NEXT:    imull %edx, %eax\n-; X86-NEXT:    addl %eax, %eax\n+; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax\n+; X86-NEXT:    imull %eax, %eax\n+; X86-NEXT:    imull $84, %eax, %eax\n ; X86-NEXT:    movl $818089009, %edx # imm = 0x30C30C31\n ; X86-NEXT:    imull %edx\n ; X86-NEXT:    movl %edx, %eax\n@@ -851,9 +850,8 @@ define void @pr59676_nsw_frozen(ptr %dst, i32 %x.orig) {\n ;\n ; X64-LABEL: pr59676_nsw_frozen:\n ; X64:       # %bb.0:\n-; X64-NEXT:    imull $42, %esi, %eax\n-; X64-NEXT:    imull %esi, %eax\n-; X64-NEXT:    addl %eax, %eax\n+; X64-NEXT:    imull %esi, %esi\n+; X64-NEXT:    imull $84, %esi, %eax\n ; X64-NEXT:    cltq\n ; X64-NEXT:    imulq $818089009, %rax, %rax # imm = 0x30C30C31\n ; X64-NEXT:    movq %rax, %rcx\n@@ -875,11 +873,10 @@ define void @pr59676_nsw_frozen(ptr %dst, i32 %x.orig) {\n define void @pr59676_nsw(ptr %dst, i32 %x) {\n ; X86-LABEL: pr59676_nsw:\n ; X86:       # %bb.0:\n-; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx\n+; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax\n ; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n-; X86-NEXT:    imull $42, %edx, %eax\n-; X86-NEXT:    imull %edx, %eax\n-; X86-NEXT:    addl %eax, %eax\n+; X86-NEXT:    imull %eax, %eax\n+; X86-NEXT:    imull $84, %eax, %eax\n ; X86-NEXT:    movl $818089009, %edx # imm = 0x30C30C31\n ; X86-NEXT:    imull %edx\n ; X86-NEXT:    movl %edx, %eax\n@@ -891,9 +888,8 @@ define void @pr59676_nsw(ptr %dst, i32 %x) {\n ;\n ; X64-LABEL: pr59676_nsw:\n ; X64:       # %bb.0:\n-; X64-NEXT:    imull $42, %esi, %eax\n-; X64-NEXT:    imull %esi, %eax\n-; X64-NEXT:    addl %eax, %eax\n+; X64-NEXT:    imull %esi, %esi\n+; X64-NEXT:    imull $84, %esi, %eax\n ; X64-NEXT:    cltq\n ; X64-NEXT:    imulq $818089009, %rax, %rax # imm = 0x30C30C31\n ; X64-NEXT:    movq %rax, %rcx"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/freeze-binary.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/freeze-binary.ll\n\n\nTesting Time: 0.50s\n  Failed: 1\n"
    },
    "3f1e2b42700a1eb1466d4200eb87265defd962f6___symboldatabase.cpp": {
        "start": 3722,
        "end": 3909,
        "buggy": "const Function* Scope::findFunction(const Token *tok, bool requireConst) const\n{\n    // make sure this is a function call\n    const Token *end = tok->linkAt(1);\n    if (!end)\n        return nullptr;\n\n    std::vector<const Token *> arguments;\n\n    // find all the arguments for this function call\n    const Token *arg = tok->tokAt(2);\n    while (arg && arg != end) {\n        arguments.push_back(arg);\n        arg = arg->nextArgument();\n    }\n\n    std::vector<const Function *> matches;\n\n    // find all the possible functions that could match\n    const std::size_t args = arguments.size();\n    for (std::multimap<std::string, const Function *>::const_iterator it = functionMap.find(tok->str()); it != functionMap.end() && it->first == tok->str(); ++it) {\n        const Function *func = it->second;\n        if (args == func->argCount() ||\n            (func->isVariadic() && args >= (func->argCount() - 1)) ||\n            (args < func->argCount() && args >= func->minArgCount())) {\n            matches.push_back(func);\n        }\n    }\n\n    // check in base classes\n    findFunctionInBase(tok->str(), args, matches);\n\n    // check each function against the arguments in the function call for a match\n    for (std::size_t i = 0; i < matches.size();) {\n        bool erased = false;\n        const Function * func = matches[i];\n        size_t same = 0;\n        for (std::size_t j = 0; j < args; ++j) {\n            // don't check variadic arguments\n            if (func->isVariadic() && j > (func->argCount() - 1)) {\n                break;\n            }\n            const Variable *funcarg = func->getArgumentVar(j);\n            // check for a match with a variable\n            if (Token::Match(arguments[j], \"%var% ,|)\")) {\n                const Variable * callarg = check->getVariableFromVarId(arguments[j]->varId());\n                if (callarg &&\n                    callarg->typeStartToken()->str() == funcarg->typeStartToken()->str() &&\n                    callarg->typeStartToken()->isUnsigned() == funcarg->typeStartToken()->isUnsigned() &&\n                    callarg->typeStartToken()->isLong() == funcarg->typeStartToken()->isLong()) {\n                    same++;\n                }\n            }\n\n            // check for a match with address of a variable\n            else if (Token::Match(arguments[j], \"& %var% ,|)\")) {\n                const Variable * callarg = check->getVariableFromVarId(arguments[j]->next()->varId());\n                if (callarg) {\n                    if (funcarg->typeEndToken()->str() == \"*\" &&\n                        (funcarg->typeStartToken()->str() == \"void\" ||\n                         (callarg->typeStartToken()->str() == funcarg->typeStartToken()->str() &&\n                          callarg->typeStartToken()->isUnsigned() == funcarg->typeStartToken()->isUnsigned() &&\n                          callarg->typeStartToken()->isLong() == funcarg->typeStartToken()->isLong()))) {\n                        same++;\n                    } else {\n                        // can't match so remove this function from possible matches\n                        matches.erase(matches.begin() + i);\n                        erased = true;\n                        break;\n                    }\n                }\n            }\n\n            // check for a match with a numeric literal\n            else if (Token::Match(arguments[j], \"%num% ,|)\")) {\n                if (MathLib::isInt(arguments[j]->str())) {\n                    if (arguments[j]->str().find(\"ll\") != std::string::npos ||\n                        arguments[j]->str().find(\"LL\") != std::string::npos) {\n                        if (arguments[j]->str().find('u') != std::string::npos ||\n                            arguments[j]->str().find('U') != std::string::npos) {\n                            if (funcarg->typeStartToken()->str() == \"long\" &&\n                                funcarg->typeStartToken()->isLong() &&\n                                funcarg->typeStartToken()->isUnsigned()) {\n                                same++;\n                            }\n                        } else {\n                            if (funcarg->typeStartToken()->str() == \"long\" &&\n                                funcarg->typeStartToken()->isLong() &&\n                                !funcarg->typeStartToken()->isUnsigned()) {\n                                same++;\n                            }\n                        }\n                    } else if (arguments[j]->str().find('l') != std::string::npos ||\n                               arguments[j]->str().find('L') != std::string::npos) {\n                        if (arguments[j]->str().find('u') != std::string::npos ||\n                            arguments[j]->str().find('U') != std::string::npos) {\n                            if (funcarg->typeStartToken()->str() == \"long\" &&\n                                !funcarg->typeStartToken()->isLong() &&\n                                funcarg->typeStartToken()->isUnsigned()) {\n                                same++;\n                            }\n                        } else {\n                            if (funcarg->typeStartToken()->str() == \"long\" &&\n                                !funcarg->typeStartToken()->isLong() &&\n                                !funcarg->typeStartToken()->isUnsigned()) {\n                                same++;\n                            }\n                        }\n                    } else if (arguments[j]->str().find('u') != std::string::npos ||\n                               arguments[j]->str().find('U') != std::string::npos) {\n                        if (funcarg->typeStartToken()->str() == \"int\" &&\n                            funcarg->typeStartToken()->isUnsigned()) {\n                            same++;\n                        } else if (Token::Match(funcarg->typeStartToken(), \"char|short\")) {\n                            same++;\n                        }\n                    } else {\n                        if (Token::Match(funcarg->typeStartToken(), \"char|short|int|long\")) {\n                            same++;\n                        }\n                    }\n                } else {\n                    if (arguments[j]->str().find('f') != std::string::npos ||\n                        arguments[j]->str().find('F') != std::string::npos) {\n                        if (funcarg->typeStartToken()->str() == \"float\") {\n                            same++;\n                        }\n                    } else if (arguments[j]->str().find('l') != std::string::npos ||\n                               arguments[j]->str().find('L') != std::string::npos) {\n                        if (funcarg->typeStartToken()->str() == \"double\" &&\n                            funcarg->typeStartToken()->isLong())  {\n                            same++;\n                        }\n                    } else {\n                        if (funcarg->typeStartToken()->str() == \"double\" &&\n                            !funcarg->typeStartToken()->isLong()) {\n                            same++;\n                        }\n                    }\n                }\n            }\n\n            // check for a match with a string literal\n            else if (Token::Match(arguments[j], \"%str% ,|)\") &&\n                     funcarg->typeStartToken() != funcarg->typeEndToken() &&\n                     ((!arguments[j]->isLong() && Token::simpleMatch(funcarg->typeStartToken(), \"char *\")) ||\n                      (arguments[j]->isLong() && Token::simpleMatch(funcarg->typeStartToken(), \"wchar_t *\")))) {\n                same++;\n            }\n\n            // check that function argument type is not mismatching\n            else if (arguments[j]->str() == \"&\" && funcarg && funcarg->isReference()) {\n                // can't match so remove this function from possible matches\n                matches.erase(matches.begin() + i);\n                erased = true;\n                break;\n            }\n        }\n\n        // check if all arguments matched\n        if ((func->isVariadic() && same == (func->argCount() - 1)) ||\n            (!func->isVariadic() && same == args)) {\n            if (requireConst && func->isConst())\n                return func;\n\n            // get the function this call is in\n            const Scope * scope = tok->scope();\n\n            // check if this function is a member function\n            if (scope && scope->functionOf && scope->functionOf->isClassOrStruct()) {\n                // check if isConst match\n                if (scope->function && scope->function->isConst() == func->isConst())\n                    return func;\n            } else\n                return func;\n        }\n\n        if (!erased)\n            ++i;\n    }\n\n    // no exact match so just return first function found\n    if (!matches.empty()) {\n        return matches[0];\n    }\n\n    return nullptr;\n}\n",
        "fix": null,
        "src_path": "3f1e2b42700a1eb1466d4200eb87265defd962f6___symboldatabase.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/3f1e2b42700a1eb1466d4200eb87265defd962f6",
        "commit_msg": "More conservative fallback for function overload matching",
        "test_func_diff": [
            {
                "fn": "test/testsymboldatabase.cpp",
                "patch": "@@ -3495,12 +3495,16 @@ class TestSymbolDatabase: public TestFixture {\n                       \"void foo(long long a) { }\\n\"\n                       \"void foo() {\\n\"\n                       \"    foo(0);\\n\"\n+                      \"    foo(bar());\\n\"\n                       \"}\");\n \n         ASSERT_EQUALS(\"\", errout.str());\n \n         const Token *f = Token::findsimplematch(tokenizer.tokens(), \"foo ( 0 ) ;\");\n         ASSERT_EQUALS(true, db && f && f->function() && f->function()->tokenDef->linenr() == 2);\n+\n+        f = Token::findsimplematch(tokenizer.tokens(), \"foo ( bar ( ) ) ;\");\n+        ASSERT_EQUALS(true, db && f && f->function() == nullptr);\n     }\n \n #define FUNC(x) const Function *x = findFunctionByName(#x, &db->scopeList.front()); \\"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_3f1e2b42700a1eb1466d4200eb87265defd962f6/build_3f1e2b42700a1eb1466d4200eb87265defd962f6\nTest project /out/danmar___cppcheck/git_repo_dir_3f1e2b42700a1eb1466d4200eb87265defd962f6/build_3f1e2b42700a1eb1466d4200eb87265defd962f6\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   11.77 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  11.78 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n"
    },
    "6a81b4c17c87241c6f205e9d47ebc9b5af7f0f38___valueflow.cpp": {
        "start": 3504,
        "end": 3532,
        "buggy": "static void valueFlowLifetimeConstructor(Token* tok, TokenList* tokenlist, ErrorLogger* errorLogger, const Settings* settings)\n{\n    if (!Token::Match(tok, \"(|{\"))\n        return;\n    Token* parent = tok->astParent();\n    while (Token::simpleMatch(parent, \",\"))\n        parent = parent->astParent();\n    if (Token::simpleMatch(parent, \"{\") && hasInitList(parent->astParent())) {\n        valueFlowLifetimeConstructor(tok, Token::typeOf(parent->previous()), tokenlist, errorLogger, settings);\n    } else if (Token::simpleMatch(tok, \"{\") && hasInitList(parent)) {\n        std::vector<const Token *> args = getArguments(tok);\n        // Assume range constructor if passed a pair of iterators\n        if (astIsContainer(parent) && args.size() == 2 && astIsIterator(args[0]) && astIsIterator(args[1])) {\n            LifetimeStore::forEach(\n            args, \"Passed to initializer list.\", ValueFlow::Value::LifetimeKind::Object, [&](const LifetimeStore& ls) {\n                ls.byDerefCopy(tok, tokenlist, errorLogger, settings);\n            });\n        } else {\n            LifetimeStore::forEach(args,\n                                   \"Passed to initializer list.\",\n                                   ValueFlow::Value::LifetimeKind::Object,\n            [&](const LifetimeStore& ls) {\n                ls.byVal(tok, tokenlist, errorLogger, settings);\n            });\n        }\n    } else {\n        valueFlowLifetimeConstructor(tok, Token::typeOf(tok->previous()), tokenlist, errorLogger, settings);\n    }\n}\n",
        "fix": null,
        "src_path": "6a81b4c17c87241c6f205e9d47ebc9b5af7f0f38___valueflow.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/6a81b4c17c87241c6f205e9d47ebc9b5af7f0f38",
        "commit_msg": "Fix 10264: FP invalidContainer when address of container is passed inside struct (#3368)",
        "test_func_diff": [
            {
                "fn": "test/teststl.cpp",
                "patch": "@@ -4768,6 +4768,22 @@ class TestStl : public TestFixture {\n               \"  Parse(i);\\n\"\n               \"}\\n\",true);\n         ASSERT_EQUALS(\"\", errout.str());\n+\n+        check(\"void f() {\\n\"\n+              \"  std::string x;\\n\"\n+              \"  struct V {\\n\"\n+              \"    std::string* pStr{};\\n\"\n+              \"  };\\n\"\n+              \"  struct I {\\n\"\n+              \"    std::vector<V> v;\\n\"\n+              \"  };\\n\"\n+              \"  I b[] = {{{{ &x }}}};\\n\"\n+              \"  x = \\\"Arial\\\";\\n\"\n+              \"  I cb[1];\\n\"\n+              \"  for (long i = 0; i < 1; ++i)\\n\"\n+              \"    cb[i] = b[i];\\n\"\n+              \"}\\n\",true);\n+        ASSERT_EQUALS(\"\", errout.str());\n     }\n \n     void invalidContainerLoop() {"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_6a81b4c17c87241c6f205e9d47ebc9b5af7f0f38/build_6a81b4c17c87241c6f205e9d47ebc9b5af7f0f38\nTest project /out/danmar___cppcheck/git_repo_dir_6a81b4c17c87241c6f205e9d47ebc9b5af7f0f38/build_6a81b4c17c87241c6f205e9d47ebc9b5af7f0f38\n    Start 44: TestStl\n1/1 Test #44: TestStl ..........................***Failed    1.71 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.72 sec\n\nThe following tests FAILED:\n\t 44 - TestStl (Failed)\n"
    },
    "a0c37ceba27179496fa2f44072f85e2a5448216e___valueflow.cpp": {
        "start": 4519,
        "end": 4593,
        "buggy": "static std::vector<ValueFlow::Value> infer(const ValuePtr<InferModel>& model,\n                                           const std::string& op,\n                                           std::list<ValueFlow::Value> lhsValues,\n                                           std::list<ValueFlow::Value> rhsValues)\n{\n    std::vector<ValueFlow::Value> result;\n    auto notMatch = [&](const ValueFlow::Value& value) {\n        return !model->match(value);\n    };\n    lhsValues.remove_if(notMatch);\n    rhsValues.remove_if(notMatch);\n    if (lhsValues.empty() || rhsValues.empty())\n        return result;\n\n    Interval lhs = Interval::fromValues(lhsValues);\n    Interval rhs = Interval::fromValues(rhsValues);\n\n    if (op == \"-\") {\n        Interval diff = lhs - rhs;\n        if (diff.isScalar()) {\n            std::vector<const ValueFlow::Value*> refs = diff.getScalarRef();\n            ValueFlow::Value value(diff.getScalar());\n            addToErrorPath(value, refs);\n            setValueKind(value, refs);\n            result.push_back(value);\n        } else {\n            if (!diff.minvalue.empty()) {\n                ValueFlow::Value value(diff.minvalue.front() - 1);\n                value.setImpossible();\n                value.bound = ValueFlow::Value::Bound::Lower;\n                addToErrorPath(value, diff.minRef);\n                result.push_back(value);\n            }\n            if (!diff.maxvalue.empty()) {\n                ValueFlow::Value value(diff.maxvalue.front() + 1);\n                value.setImpossible();\n                value.bound = ValueFlow::Value::Bound::Upper;\n                addToErrorPath(value, diff.maxRef);\n                result.push_back(value);\n            }\n        }\n    } else if ((op == \"!=\" || op == \"==\") && lhs.isScalarOrEmpty() && rhs.isScalarOrEmpty()) {\n        if (lhs.isScalar() && rhs.isScalar()) {\n            std::vector<const ValueFlow::Value*> refs = Interval::merge(lhs.getScalarRef(), rhs.getScalarRef());\n            ValueFlow::Value value(calculate(op, lhs.getScalar(), rhs.getScalar()));\n            addToErrorPath(value, refs);\n            setValueKind(value, refs);\n            result.push_back(value);\n        } else {\n            std::vector<const ValueFlow::Value*> refs;\n            if (lhs.isScalar() && inferNotEqual(rhsValues, lhs.getScalar()))\n                refs = lhs.getScalarRef();\n            else if (rhs.isScalar() && inferNotEqual(lhsValues, rhs.getScalar()))\n                refs = rhs.getScalarRef();\n            if (!refs.empty()) {\n                ValueFlow::Value value(op == \"!=\");\n                addToErrorPath(value, refs);\n                setValueKind(value, refs);\n                result.push_back(value);\n            }\n        }\n    } else {\n        std::vector<const ValueFlow::Value*> refs;\n        std::vector<int> r = Interval::compare(lhs, rhs, &refs);\n        if (!r.empty()) {\n            int x = r.front();\n            ValueFlow::Value value(calculate(op, x, 0));\n            addToErrorPath(value, refs);\n            setValueKind(value, refs);\n            result.push_back(value);\n        }\n    }\n\n    return result;\n}\n",
        "fix": null,
        "src_path": "a0c37ceba27179496fa2f44072f85e2a5448216e___valueflow.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/a0c37ceba27179496fa2f44072f85e2a5448216e",
        "commit_msg": "Fix FP: Set correct bounds for interval (#3411)",
        "test_func_diff": [
            {
                "fn": "test/testcondition.cpp",
                "patch": "@@ -3787,6 +3787,14 @@ class TestCondition : public TestFixture {\n         check(\"bool f(bool a, bool b) { if(a && b && (!a)){} }\");\n         ASSERT_EQUALS(\"[test.cpp:1] -> [test.cpp:1]: (style) Condition '!a' is always false\\n\", errout.str());\n \n+        check(\"void f(int x, int y) {\\n\"\n+              \"  if (x < y) {\\n\"\n+              \"    auto z = y - x;\\n\"\n+              \"    if (z < 1) {}\\n\"\n+              \"  }\\n\"\n+              \"}\\n\");\n+        ASSERT_EQUALS(\"[test.cpp:4]: (style) Condition 'z<1' is always false\\n\", errout.str());\n+\n         check(\"struct a {\\n\"\n               \"  a *b() const;\\n\"\n               \"} c;\\n\""
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_a0c37ceba27179496fa2f44072f85e2a5448216e/build_a0c37ceba27179496fa2f44072f85e2a5448216e\nTest project /out/danmar___cppcheck/git_repo_dir_a0c37ceba27179496fa2f44072f85e2a5448216e/build_a0c37ceba27179496fa2f44072f85e2a5448216e\n    Start 14: TestCondition\n1/1 Test #14: TestCondition ....................***Failed    2.25 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   2.25 sec\n\nThe following tests FAILED:\n\t 14 - TestCondition (Failed)\n"
    },
    "fd3cb2497364d350632c288ce3771738499f718e___checkmemoryleak.cpp": {
        "start": 983,
        "end": 1023,
        "buggy": "void CheckMemoryLeakNoVar::checkForUnreleasedInputArgument(const Scope *scope)\n{\n    // parse the executable scope until tok is reached...\n    for (const Token *tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {\n        // allocating memory in parameter for function call..\n        if (!Token::Match(tok, \"%name% (\"))\n            continue;\n\n        // check if the output of the function is assigned\n        const Token* tok2 = tok->next()->astParent();\n        while (tok2 && tok2->isCast())\n            tok2 = tok2->astParent();\n        if (tok2 && tok2->isAssignmentOp())\n            continue;\n\n        const std::string& functionName = tok->str();\n        if ((mTokenizer->isCPP() && functionName == \"delete\") ||\n            functionName == \"free\" ||\n            functionName == \"fclose\" ||\n            functionName == \"realloc\")\n            break;\n\n        if (!CheckMemoryLeakInFunction::test_white_list(functionName, mSettings, mTokenizer->isCPP()))\n            continue;\n\n        const std::vector<const Token *> args = getArguments(tok);\n        for (const Token* arg : args) {\n            if (arg->isOp())\n                continue;\n            while (arg->astOperand1())\n                arg = arg->astOperand1();\n            if (getAllocationType(arg, 0) == No)\n                continue;\n            if (isReopenStandardStream(arg))\n                continue;\n            functionCallLeak(arg, arg->str(), functionName);\n            break;\n        }\n\n    }\n}\n",
        "fix": null,
        "src_path": "fd3cb2497364d350632c288ce3771738499f718e___checkmemoryleak.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/fd3cb2497364d350632c288ce3771738499f718e",
        "commit_msg": "leakNoReturnVar: Don't break early (#2095)\n\nThere seems to be no reason for stopping checking the scope if a call to\r\nfree() is seen (or fclose() or realloc()), so just continue checking.\r\nAlso, if there are multiple arguments, check all, perhaps there are more\r\nmemory leaks to warn about.",
        "test_func_diff": [
            {
                "fn": "test/testmemleak.cpp",
                "patch": "@@ -2159,6 +2159,18 @@ class TestMemleakNoVar : public TestFixture {\n               \"    return ret;\\n\"\n               \"}\");\n         ASSERT_EQUALS(\"\", errout.str());\n+\n+        check(\"void f() {\\n\"\n+              \"    free(malloc(1));\\n\"\n+              \"    strcpy(a, strdup(p));\\n\"\n+              \"}\");\n+        ASSERT_EQUALS(\"[test.cpp:3]: (error) Allocation with strdup, strcpy doesn't release it.\\n\", errout.str());\n+\n+        check(\"void f() {\\n\"\n+              \"    memcmp(calloc(10, 10), strdup(q), 100);\\n\"\n+              \"}\");\n+        ASSERT_EQUALS(\"[test.cpp:2]: (error) Allocation with calloc, memcmp doesn't release it.\\n\"\n+                      \"[test.cpp:2]: (error) Allocation with strdup, memcmp doesn't release it.\\n\", errout.str());\n     }\n \n     void missingAssignment() {"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_fd3cb2497364d350632c288ce3771738499f718e/build_fd3cb2497364d350632c288ce3771738499f718e\nTest project /out/danmar___cppcheck/git_repo_dir_fd3cb2497364d350632c288ce3771738499f718e/build_fd3cb2497364d350632c288ce3771738499f718e\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   57.17 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  57.22 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n"
    },
    "cf0da32fd0d0c9fe6ac322f18a8b6176407f7679___meta.hpp": {
        "start": 2034,
        "end": 2053,
        "buggy": "class meta_associative_container::meta_iterator {\n    enum operation { INCR, DEREF };\n\n    using vtable_type = void(const operation, const any &, void *);\n\n    template<bool KeyOnly, typename It>\n    static void basic_vtable(const operation op, const any &from, void *to) {\n        switch(op) {\n        case operation::INCR:\n            ++any_cast<It &>(const_cast<any &>(from));\n            break;\n        case operation::DEREF:\n            if constexpr(KeyOnly) {\n                static_cast<std::pair<meta_any, meta_any> *>(to)->first = *any_cast<const It &>(from);\n            } else {\n                *static_cast<std::pair<meta_any, meta_any> *>(to) = std::make_pair<meta_any, meta_any>(any_cast<const It &>(from)->first, std::reference_wrapper{any_cast<const It &>(from)->second});\n            }\n            break;\n        }\n    }\n",
        "fix": null,
        "src_path": "cf0da32fd0d0c9fe6ac322f18a8b6176407f7679___meta.hpp",
        "uri": "https://api.github.com/repos/skypjack/entt/commits/cf0da32fd0d0c9fe6ac322f18a8b6176407f7679",
        "commit_msg": "meta: iterators of meta associative containers return keys by const reference rather than by copy",
        "test_func_diff": [
            {
                "fn": "test/entt/meta/meta_container.cpp",
                "patch": "@@ -259,9 +259,9 @@ TEST_F(MetaContainer, StdSet) {\n     ASSERT_EQ(view.size(), 4u);\n     ASSERT_EQ(view.find(0), view.end());\n \n-    (*view.find(1)).first.cast<int &>() = 42;\n-\n-    ASSERT_EQ((*view.find(1)).first.cast<int>(), 1);\n+    ASSERT_EQ((*view.find(1)).first.try_cast<int>(), nullptr);\n+    ASSERT_NE((*view.find(1)).first.try_cast<const int>(), nullptr);\n+    ASSERT_EQ((*view.find(1)).first.cast<const int &>(), 1);\n \n     ASSERT_TRUE(view.erase(1.));\n     ASSERT_TRUE(view.clear());\n@@ -365,8 +365,9 @@ TEST_F(MetaContainer, ConstKeyOnlyAssociativeContainer) {\n     ASSERT_EQ(view.size(), 1u);\n     ASSERT_NE(view.begin(), view.end());\n \n+    ASSERT_EQ((*view.find(2)).first.try_cast<int>(), nullptr);\n+    ASSERT_NE((*view.find(2)).first.try_cast<const int>(), nullptr);\n     ASSERT_EQ((*view.find(2)).first.cast<int>(), 2);\n-    ASSERT_EQ((*view.find(2)).first.cast<int &>(), 2);\n     ASSERT_EQ((*view.find(2)).first.cast<const int &>(), 2);\n \n     ASSERT_FALSE(view.insert(0));\n@@ -422,8 +423,10 @@ TEST_F(MetaContainer, KeyOnlyAssociativeContainerConstMetaAny) {\n \n         ASSERT_TRUE(view);\n         ASSERT_EQ(view.value_type(), (entt::resolve<int>()));\n+\n+        ASSERT_EQ((*view.find(2)).first.try_cast<int>(), nullptr);\n+        ASSERT_NE((*view.find(2)).first.try_cast<const int>(), nullptr);\n         ASSERT_EQ((*view.find(2)).first.cast<int>(), 2);\n-        ASSERT_EQ((*view.find(2)).first.cast<int &>(), 2);\n         ASSERT_EQ((*view.find(2)).first.cast<const int &>(), 2);\n     };\n "
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/skypjack___entt/git_repo_dir_cf0da32fd0d0c9fe6ac322f18a8b6176407f7679/build_cf0da32fd0d0c9fe6ac322f18a8b6176407f7679\nTest project /out/skypjack___entt/git_repo_dir_cf0da32fd0d0c9fe6ac322f18a8b6176407f7679/build_cf0da32fd0d0c9fe6ac322f18a8b6176407f7679\n    Start 27: meta_container\n1/1 Test #27: meta_container ...................***Failed    5.16 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   5.16 sec\n\nThe following tests FAILED:\n\t 27 - meta_container (Failed)\n"
    },
    "6a59b15fba1085432c4c18952680e14d80dd134a___nng.c": {
        "start": 85,
        "end": 119,
        "buggy": "int\nnng_recv(nng_socket s, void *buf, size_t *szp, int flags)\n{\n\tnng_msg *msg;\n\tint      rv;\n\n\t// Note that while it would be nice to make this a zero copy operation,\n\t// its not normally possible if a size was specified.\n\tif ((rv = nng_recvmsg(s, &msg, flags & ~(NNG_FLAG_ALLOC))) != 0) {\n\t\treturn (rv);\n\t}\n\tif (!(flags & NNG_FLAG_ALLOC)) {\n\t\tmemcpy(buf, nng_msg_body(msg),\n\t\t    *szp > nng_msg_len(msg) ? nng_msg_len(msg) : *szp);\n\t\t*szp = nng_msg_len(msg);\n\t} else {\n\t\t// We'd really like to avoid a separate data copy, but since\n\t\t// we have allocated messages with headroom, we can't really\n\t\t// make free() work on the base pointer.  We'd have to have\n\t\t// some other API for this.  Folks that want zero copy had\n\t\t// better use nng_recvmsg() instead.\n\t\tvoid *nbuf;\n\n\t\tif ((nbuf = nni_alloc(nng_msg_len(msg))) == NULL) {\n\t\t\tnng_msg_free(msg);\n\t\t\treturn (NNG_ENOMEM);\n\t\t}\n\n\t\t*(void **) buf = nbuf;\n\t\tmemcpy(nbuf, nni_msg_body(msg), nni_msg_len(msg));\n\t\t*szp = nng_msg_len(msg);\n\t}\n\tnni_msg_free(msg);\n\treturn (0);\n}\n",
        "fix": null,
        "src_path": "6a59b15fba1085432c4c18952680e14d80dd134a___nng.c",
        "uri": "https://api.github.com/repos/nanomsg/nng/commits/6a59b15fba1085432c4c18952680e14d80dd134a",
        "commit_msg": "fixes #1201 Unexpected error return code: NNG_ENOMEM",
        "test_func_diff": [
            {
                "fn": "tests/sock.c",
                "patch": "@@ -1,5 +1,5 @@\n //\n-// Copyright 2019 Staysail Systems, Inc. <info@staysail.tech>\n+// Copyright 2020 Staysail Systems, Inc. <info@staysail.tech>\n // Copyright 2018 Capitar IT Group BV <info@capitar.com>\n //\n // This software is supplied under the terms of the MIT License, a\n@@ -216,6 +216,45 @@ test_send_recv(void)\n \tTEST_CHECK(nng_close(s2) == 0);\n }\n \n+void\n+test_send_recv_zero_length(void)\n+{\n+\tnng_socket   s1;\n+\tnng_socket   s2;\n+\tint          len;\n+\tsize_t       sz;\n+\tnng_duration to = 3000; // 3 seconds\n+\tchar *       buf;\n+\tchar *       a = \"inproc://send-recv-zero-length\";\n+\n+\tTEST_NNG_PASS(nng_pair1_open(&s1));\n+\tTEST_NNG_PASS(nng_pair1_open(&s2));\n+\n+\tTEST_NNG_PASS(nng_setopt_int(s1, NNG_OPT_RECVBUF, 1));\n+\tTEST_NNG_PASS(nng_getopt_int(s1, NNG_OPT_RECVBUF, &len));\n+\tTEST_CHECK(len == 1);\n+\n+\tTEST_NNG_PASS(nng_setopt_int(s1, NNG_OPT_SENDBUF, 1));\n+\tTEST_NNG_PASS(nng_setopt_int(s2, NNG_OPT_SENDBUF, 1));\n+\n+\tTEST_NNG_PASS(nng_setopt_ms(s1, NNG_OPT_SENDTIMEO, to));\n+\tTEST_NNG_PASS(nng_setopt_ms(s1, NNG_OPT_RECVTIMEO, to));\n+\tTEST_NNG_PASS(nng_setopt_ms(s2, NNG_OPT_SENDTIMEO, to));\n+\tTEST_NNG_PASS(nng_setopt_ms(s2, NNG_OPT_RECVTIMEO, to));\n+\n+\tTEST_NNG_PASS(nng_listen(s1, a, NULL, 0));\n+\tTEST_NNG_PASS(nng_dial(s2, a, NULL, 0));\n+\n+\tTEST_NNG_PASS(nng_send(s1, \"\", 0, 0));\n+\tTEST_NNG_PASS(nng_recv(s2, &buf, &sz, NNG_FLAG_ALLOC));\n+\tTEST_CHECK(buf == NULL);\n+\tTEST_CHECK(sz == 0);\n+\tnng_free(buf, sz);\n+\n+\tTEST_NNG_PASS(nng_close(s1));\n+\tTEST_NNG_PASS(nng_close(s2));\n+}\n+\n void\n test_connection_refused(void)\n {\n@@ -611,6 +650,7 @@ TEST_LIST = {\n \t{ \"socket name\", test_socket_name },\n \t{ \"socket name oversize\", test_socket_name_oversize },\n \t{ \"send recv\", test_send_recv },\n+\t{ \"send recv zero length\", test_send_recv_zero_length },\n \t{ \"connection refused\", test_connection_refused },\n \t{ \"late connection\", test_late_connection },\n \t{ \"address busy\", test_address_busy },"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/nanomsg___nng/git_repo_dir_6a59b15fba1085432c4c18952680e14d80dd134a/build_6a59b15fba1085432c4c18952680e14d80dd134a\nTest project /out/nanomsg___nng/git_repo_dir_6a59b15fba1085432c4c18952680e14d80dd134a/build_6a59b15fba1085432c4c18952680e14d80dd134a\n    Start 17: websocket_test\n1/2 Test #17: websocket_test ...................   Passed    0.30 sec\n    Start 22: sock\n2/2 Test #22: sock .............................***Failed    0.41 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =   0.71 sec\n\nThe following tests FAILED:\n\t 22 - sock (Failed)\n"
    },
    "287eaab3b2777daa5d0d0cf72d977196ba54efb7___format.h": {
        "start": 2755,
        "end": 2755,
        "buggy": "  void write(long double value) { write_double(value, format_specs()); }\n",
        "fix": null,
        "src_path": "287eaab3b2777daa5d0d0cf72d977196ba54efb7___format.h",
        "uri": "https://api.github.com/repos/fmtlib/fmt/commits/287eaab3b2777daa5d0d0cf72d977196ba54efb7",
        "commit_msg": "Increment output iterator in basic_writer::write for character types (#1056)",
        "test_func_diff": [
            {
                "fn": "test/format-test.cc",
                "patch": "@@ -2040,6 +2040,17 @@ TEST(FormatTest, FormatToN) {\n   EXPECT_EQ(6u, result.size);\n   EXPECT_EQ(buffer + 3, result.out);\n   EXPECT_EQ(\"foox\", fmt::string_view(buffer, 4));\n+  buffer[0] = 'x';\n+  buffer[1] = 'x';\n+  buffer[2] = 'x';\n+  result = fmt::format_to_n(buffer, 3, \"{}\", 'A');\n+  EXPECT_EQ(1u, result.size);\n+  EXPECT_EQ(buffer + 1, result.out);\n+  EXPECT_EQ(\"Axxx\", fmt::string_view(buffer, 4));\n+  result = fmt::format_to_n(buffer, 3, \"{}{} \", 'B', 'C');\n+  EXPECT_EQ(3u, result.size);\n+  EXPECT_EQ(buffer + 3, result.out);\n+  EXPECT_EQ(\"BC x\", fmt::string_view(buffer, 4));\n }\n \n TEST(FormatTest, WideFormatToN) {\n@@ -2049,6 +2060,17 @@ TEST(FormatTest, WideFormatToN) {\n   EXPECT_EQ(5u, result.size);\n   EXPECT_EQ(buffer + 3, result.out);\n   EXPECT_EQ(L\"123x\", fmt::wstring_view(buffer, 4));\n+  buffer[0] = L'x';\n+  buffer[1] = L'x';\n+  buffer[2] = L'x';\n+  result = fmt::format_to_n(buffer, 3, L\"{}\", L'A');\n+  EXPECT_EQ(1u, result.size);\n+  EXPECT_EQ(buffer + 1, result.out);\n+  EXPECT_EQ(L\"Axxx\", fmt::wstring_view(buffer, 4));\n+  result = fmt::format_to_n(buffer, 3, L\"{}{} \", L'B', L'C');\n+  EXPECT_EQ(3u, result.size);\n+  EXPECT_EQ(buffer + 3, result.out);\n+  EXPECT_EQ(L\"BC x\", fmt::wstring_view(buffer, 4));\n }\n \n #if FMT_USE_CONSTEXPR"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_287eaab3b2777daa5d0d0cf72d977196ba54efb7/build_287eaab3b2777daa5d0d0cf72d977196ba54efb7\nTest project /out/fmtlib___fmt/git_repo_dir_287eaab3b2777daa5d0d0cf72d977196ba54efb7/build_287eaab3b2777daa5d0d0cf72d977196ba54efb7\n    Start 6: format-test\n1/1 Test #6: format-test ......................***Failed    0.12 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.12 sec\n\nThe following tests FAILED:\n\t  6 - format-test (Failed)\n"
    },
    "e6b37b4aff1a673cb735b9b287aa637142120f6d___format-inl.h": {
        "start": 1274,
        "end": 1300,
        "buggy": "FMT_FUNC internal::utf8_to_utf16::utf8_to_utf16(string_view s) {\n  auto transcode = [this](const char* p) {\n    auto cp = uint32_t();\n    auto error = 0;\n    p = utf8_decode(p, &cp, &error);\n    if (error != 0) FMT_THROW(std::runtime_error(\"invalid utf8\"));\n    if (cp <= 0xFFFF) {\n      buffer_.push_back(static_cast<wchar_t>(cp));\n    } else {\n      cp -= 0x10000;\n      buffer_.push_back(static_cast<wchar_t>(0xD800 + (cp >> 10)));\n      buffer_.push_back(static_cast<wchar_t>(0xDC00 + (cp & 0x3FF)));\n    }\n    return p;\n  };\n  auto p = s.data();\n  const size_t block_size = 4;  // utf8_decode always reads blocks of 4 chars.\n  if (s.size() >= block_size) {\n    for (auto end = p + s.size() - block_size + 1; p < end;) p = transcode(p);\n  }\n  if (auto num_chars_left = s.data() + s.size() - p) {\n    char buf[4] = {};\n    memcpy(buf, p, num_chars_left);\n    transcode(buf);\n  }\n  buffer_.push_back(0);\n}\n",
        "fix": null,
        "src_path": "e6b37b4aff1a673cb735b9b287aa637142120f6d___format-inl.h",
        "uri": "https://api.github.com/repos/fmtlib/fmt/commits/e6b37b4aff1a673cb735b9b287aa637142120f6d",
        "commit_msg": "Handle block boundaries in utf8_to_utf16",
        "test_func_diff": [
            {
                "fn": "test/format-test.cc",
                "patch": "@@ -410,6 +410,7 @@ TEST(UtilTest, UTF8ToUTF16) {\n                    \"invalid utf8\");\n   EXPECT_THROW_MSG(fmt::internal::utf8_to_utf16(fmt::string_view(\"\u043b\", 1)),\n                    std::runtime_error, \"invalid utf8\");\n+  EXPECT_EQ(L\"123456\", fmt::internal::utf8_to_utf16(\"123456\").str());\n }\n \n TEST(UtilTest, UTF8ToUTF16EmptyString) {"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_e6b37b4aff1a673cb735b9b287aa637142120f6d/build_e6b37b4aff1a673cb735b9b287aa637142120f6d\nTest project /out/fmtlib___fmt/git_repo_dir_e6b37b4aff1a673cb735b9b287aa637142120f6d/build_e6b37b4aff1a673cb735b9b287aa637142120f6d\n    Start 7: format-test\n1/1 Test #7: format-test ......................***Failed    0.08 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.08 sec\n\nThe following tests FAILED:\n\t  7 - format-test (Failed)\n"
    },
    "ecc63d0d3b0e1a62c90b58b1ccdb5ac16cb2400a___v3_1_encoder.cpp": {
        "start": 23,
        "end": 71,
        "buggy": "void zmq::v3_1_encoder_t::message_ready ()\n{\n    //  Encode flags.\n    size_t size = in_progress ()->size ();\n    size_t header_size = 2; // flags byte + size byte\n    unsigned char &protocol_flags = _tmp_buf[0];\n    protocol_flags = 0;\n    if (in_progress ()->flags () & msg_t::more)\n        protocol_flags |= v2_protocol_t::more_flag;\n    if (in_progress ()->size () > UCHAR_MAX)\n        protocol_flags |= v2_protocol_t::large_flag;\n    if (in_progress ()->flags () & msg_t::command\n        || in_progress ()->is_subscribe () || in_progress ()->is_cancel ()) {\n        protocol_flags |= v2_protocol_t::command_flag;\n        if (in_progress ()->is_subscribe ())\n            size += zmq::msg_t::sub_cmd_name_size;\n        else if (in_progress ()->is_cancel ())\n            size += zmq::msg_t::cancel_cmd_name_size;\n    }\n\n    //  Encode the message length. For messages less then 256 bytes,\n    //  the length is encoded as 8-bit unsigned integer. For larger\n    //  messages, 64-bit unsigned integer in network byte order is used.\n    if (unlikely (size > UCHAR_MAX)) {\n        put_uint64 (_tmp_buf + 1, size);\n        header_size = 9; // flags byte + size 8 bytes\n    } else {\n        _tmp_buf[1] = static_cast<uint8_t> (size);\n    }\n\n    //  Encode the sub/cancel command string. This is done in the encoder as\n    //  opposed to when the subscribe message is created to allow different\n    //  protocol behaviour on the wire in the v3.1 and legacy encoders.\n    //  It results in the work being done multiple times in case the sub\n    //  is sending the subscription/cancel to multiple pubs, but it cannot\n    //  be avoided. This processing can be moved to xsub once support for\n    //  ZMTP < 3.1 is dropped.\n    if (in_progress ()->is_subscribe ()) {\n        memcpy (_tmp_buf + header_size, zmq::sub_cmd_name,\n                zmq::msg_t::sub_cmd_name_size);\n        header_size += zmq::msg_t::sub_cmd_name_size;\n    } else if (in_progress ()->is_cancel ()) {\n        memcpy (_tmp_buf + header_size, zmq::cancel_cmd_name,\n                zmq::msg_t::cancel_cmd_name_size);\n        header_size += zmq::msg_t::cancel_cmd_name_size;\n    }\n\n    next_step (_tmp_buf, header_size, &v3_1_encoder_t::size_ready, false);\n}\n",
        "fix": null,
        "src_path": "ecc63d0d3b0e1a62c90b58b1ccdb5ac16cb2400a___v3_1_encoder.cpp",
        "uri": "https://api.github.com/repos/zeromq/libzmq/commits/ecc63d0d3b0e1a62c90b58b1ccdb5ac16cb2400a",
        "commit_msg": "Problem: long flag isn't set for subscriptions if topic has between 246 and 255 characters (#4564)\n\n* Problem: long flag isn't set for subscriptions if topic has between 246 and 255 characters\r\n\r\nSolution: fix V3.1 encoder to calculate long flag after evaluating the subscribe and cancel commands",
        "test_func_diff": [
            {
                "fn": "tests/CMakeLists.txt",
                "patch": "@@ -64,6 +64,7 @@ set(tests\n   test_srcfd\n   test_stream_timeout\n   test_xpub_manual\n+  test_xpub_topic\n   test_xpub_welcome_msg\n   test_xpub_verbose\n   test_base85"
            },
            {
                "fn": "tests/test_xpub_topic.cpp",
                "patch": "@@ -0,0 +1,85 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n+#include \"testutil.hpp\"\n+#include \"testutil_unity.hpp\"\n+\n+SETUP_TEARDOWN_TESTCONTEXT\n+\n+const char bind_address[] = \"tcp://127.0.0.1:*\";\n+char connect_address[MAX_SOCKET_STRING];\n+\n+// 245 chars + 10 chars for subscribe command = 255 chars\n+const char short_topic[] =\n+  \"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP\"\n+  \"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP\"\n+  \"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP\"\n+  \"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDE\";\n+\n+// 246 chars + 10 chars for subscribe command = 256 chars\n+const char long_topic[] =\n+  \"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP\"\n+  \"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP\"\n+  \"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOP\"\n+  \"ABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEFGHIJKLMNOPABCDEF\";\n+\n+\n+template <size_t SIZE>\n+void test_subscribe_cancel (void *xpub, void *sub, const char (&topic)[SIZE])\n+{\n+    // Ignore '\\0' terminating the topic string.\n+    const size_t topic_len = SIZE - 1;\n+\n+    //  Subscribe for topic\n+    TEST_ASSERT_SUCCESS_ERRNO (\n+      zmq_setsockopt (sub, ZMQ_SUBSCRIBE, topic, topic_len));\n+\n+    // Allow receiving more than the expected number of bytes\n+    char buffer[topic_len + 5];\n+\n+    // Receive subscription\n+    int rc =\n+      TEST_ASSERT_SUCCESS_ERRNO (zmq_recv (xpub, buffer, sizeof (buffer), 0));\n+    TEST_ASSERT_EQUAL_INT (topic_len + 1, rc);\n+    TEST_ASSERT_EQUAL_UINT8 (1, buffer[0]);\n+    TEST_ASSERT_EQUAL_UINT8_ARRAY (topic, buffer + 1, topic_len);\n+\n+    // Unsubscribe from topic\n+    TEST_ASSERT_SUCCESS_ERRNO (\n+      zmq_setsockopt (sub, ZMQ_UNSUBSCRIBE, topic, topic_len));\n+\n+    // Receive unsubscription\n+    rc =\n+      TEST_ASSERT_SUCCESS_ERRNO (zmq_recv (xpub, buffer, sizeof (buffer), 0));\n+    TEST_ASSERT_EQUAL_INT (topic_len + 1, rc);\n+    TEST_ASSERT_EQUAL_UINT8 (0, buffer[0]);\n+    TEST_ASSERT_EQUAL_UINT8_ARRAY (topic, buffer + 1, topic_len);\n+}\n+\n+void test_xpub_subscribe_long_topic ()\n+{\n+    void *xpub = test_context_socket (ZMQ_XPUB);\n+    TEST_ASSERT_SUCCESS_ERRNO (zmq_bind (xpub, bind_address));\n+    size_t len = MAX_SOCKET_STRING;\n+    TEST_ASSERT_SUCCESS_ERRNO (\n+      zmq_getsockopt (xpub, ZMQ_LAST_ENDPOINT, connect_address, &len));\n+\n+    void *sub = test_context_socket (ZMQ_SUB);\n+    TEST_ASSERT_SUCCESS_ERRNO (zmq_connect (sub, connect_address));\n+\n+    test_subscribe_cancel (xpub, sub, short_topic);\n+    test_subscribe_cancel (xpub, sub, long_topic);\n+\n+    //  Clean up.\n+    test_context_socket_close (xpub);\n+    test_context_socket_close (sub);\n+}\n+\n+int main ()\n+{\n+    setup_test_environment ();\n+\n+    UNITY_BEGIN ();\n+    RUN_TEST (test_xpub_subscribe_long_topic);\n+\n+    return UNITY_END ();\n+}"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/zeromq___libzmq/git_repo_dir_ecc63d0d3b0e1a62c90b58b1ccdb5ac16cb2400a/build_ecc63d0d3b0e1a62c90b58b1ccdb5ac16cb2400a\nTest project /out/zeromq___libzmq/git_repo_dir_ecc63d0d3b0e1a62c90b58b1ccdb5ac16cb2400a/build_ecc63d0d3b0e1a62c90b58b1ccdb5ac16cb2400a\n    Start 60: test_xpub_topic\n1/1 Test #60: test_xpub_topic ..................***Failed    0.01 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.01 sec\n\nThe following tests FAILED:\n\t 60 - test_xpub_topic (Failed)\n"
    }
}