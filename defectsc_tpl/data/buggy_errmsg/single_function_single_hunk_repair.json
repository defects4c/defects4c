{
    "1f3c6f4534c6411313361697d98d1145a1f030fa___lparser.c": {
        "prefix": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  /* global name? */\n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */\n    lua_assert(var->k != VVOID);  /* this one must exist */\n",
        "suffix": "    luaK_indexed(fs, var, &key);  /* env[varname] */\n  }\n}\n",
        "start": 463,
        "end": 474,
        "buggy": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  /* global name? */\n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */\n    lua_assert(var->k != VVOID);  /* this one must exist */\n    codestring(&key, varname);  /* key is variable name */\n    luaK_indexed(fs, var, &key);  /* env[varname] */\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    codestring(&key, varname);  /* key is variable name */\n",
        "src_path": "1f3c6f4534c6411313361697d98d1145a1f030fa___lparser.c",
        "uri": "https://api.github.com/repos/lua/lua/commits/1f3c6f4534c6411313361697d98d1145a1f030fa",
        "commit_msg": "Bug: Lua can generate wrong code when _ENV is <const>",
        "test_func_diff": [
            {
                "fn": "testes/attrib.lua",
                "patch": "@@ -434,6 +434,16 @@ a.aVeryLongName012345678901234567890123456789012345678901234567890123456789 ==\n 10)\n \n \n+do\n+  -- _ENV constant\n+  local function foo ()\n+    local _ENV <const> = 11\n+    X = \"hi\"\n+  end\n+  local st, msg = pcall(foo)\n+  assert(not st and string.find(msg, \"number\"))\n+end\n+\n \n -- test of large float/integer indices \n "
            }
        ],
        "error_msg": "testing require\npackage config: /|;|?|!|-|\ntesting 'require' message\n+\n+\ntesting assignments, logical operators, and constructors\n+\n../lua: attrib.lua:444: assertion failed!\nstack traceback:\n\t[C]: in function 'assert'\n\tattrib.lua:444: in main chunk\n\t[C]: in ?\n"
    },
    "f8d9a433fe22ab2fa15c00179048ab02ae23d583___address.c": {
        "prefix": "struct Address *\nnew_address(const char *hostname_or_ip) {\n    union {\n        struct sockaddr a;\n        struct sockaddr_in in;\n        struct sockaddr_in6 in6;\n        struct sockaddr_un un;\n        struct sockaddr_storage s;\n    } s;\n    char ip_buf[ADDRESS_BUFFER_SIZE];\n    char *port;\n    size_t len;\n\n    if (hostname_or_ip == NULL)\n        return NULL;\n\n    /* IPv6 address */\n    /* we need to test for raw IPv6 address for IPv4 port combinations since a\n     * colon would give false positives\n     */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET6, hostname_or_ip,\n                &s.in6.sin6_addr) == 1) {\n        s.in6.sin6_family = AF_INET6;\n\n        return new_address_sa(&s.a, sizeof(s.in6));\n    }\n\n    /* Unix socket */\n    memset(&s, 0, sizeof(s));\n    if (strncmp(\"unix:\", hostname_or_ip, 5) == 0) {\n        if (strlen(hostname_or_ip) >=\n                sizeof(s.un.sun_path))\n            return NULL;\n\n        /* XXX: only supporting pathname unix sockets */\n        s.un.sun_family = AF_UNIX;\n        strncpy(s.un.sun_path,\n                hostname_or_ip + 5,\n                sizeof(s.un.sun_path) - 1);\n\n        return new_address_sa(&s.a, offsetof(struct sockaddr_un, sun_path) +\n                              strlen(s.un.sun_path) + 1);\n    }\n\n    /* Trailing port */\n    if ((port = strrchr(hostname_or_ip, ':')) != NULL &&\n            is_numeric(port + 1)) {\n        len = (size_t)(port - hostname_or_ip);\n        int port_num = atoi(port + 1);\n\n        if (len < sizeof(ip_buf) && port_num >= 0 && port_num <= 65535) {\n            strncpy(ip_buf, hostname_or_ip, len);\n            ip_buf[len] = '\\0';\n\n            struct Address *addr = new_address(ip_buf);\n            if (addr != NULL)\n                address_set_port(addr, (uint16_t) port_num);\n\n            return addr;\n        }\n    }\n\n    /* Wildcard */\n    if (strcmp(\"*\", hostname_or_ip) == 0) {\n        struct Address *addr = malloc(sizeof(struct Address));\n        if (addr != NULL) {\n            addr->type = WILDCARD;\n            addr->len = 0;\n            address_set_port(addr, 0);\n        }\n        return addr;\n    }\n\n    /* IPv4 address */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET, hostname_or_ip,\n                  &s.in.sin_addr) == 1) {\n        s.in.sin_family = AF_INET;\n\n        return new_address_sa(&s.a, sizeof(s.in));\n    }\n\n    /* [IPv6 address] */\n    memset(&s, 0, sizeof(s));\n    if (hostname_or_ip[0] == '[' &&\n            (port = strchr(hostname_or_ip, ']')) != NULL) {\n        len = (size_t)(port - hostname_or_ip - 1);\n",
        "suffix": "        /* inet_pton() will not parse the IP correctly unless it is in a\n         * separate string.\n         */\n        strncpy(ip_buf, hostname_or_ip + 1, len);\n        ip_buf[len] = '\\0';\n\n        if (inet_pton(AF_INET6, ip_buf,\n                      &s.in6.sin6_addr) == 1) {\n            s.in6.sin6_family = AF_INET6;\n\n            return new_address_sa(&s.a, sizeof(s.in6));\n        }\n    }\n\n    /* hostname */\n    if (valid_hostname(hostname_or_ip)) {\n        len = strlen(hostname_or_ip);\n        struct Address *addr = malloc(\n                offsetof(struct Address, data) + len + 1);\n        if (addr != NULL) {\n            addr->type = HOSTNAME;\n            addr->port = 0;\n            addr->len = len;\n            memcpy(addr->data, hostname_or_ip, len);\n            addr->data[addr->len] = '\\0';\n\n            /* Store address in lower case */\n            for (char *c = addr->data; *c != '\\0'; c++)\n                *c = tolower(*c);\n        }\n\n        return addr;\n    }\n\n    return NULL;\n}\n",
        "start": 63,
        "end": 187,
        "buggy": "struct Address *\nnew_address(const char *hostname_or_ip) {\n    union {\n        struct sockaddr a;\n        struct sockaddr_in in;\n        struct sockaddr_in6 in6;\n        struct sockaddr_un un;\n        struct sockaddr_storage s;\n    } s;\n    char ip_buf[ADDRESS_BUFFER_SIZE];\n    char *port;\n    size_t len;\n\n    if (hostname_or_ip == NULL)\n        return NULL;\n\n    /* IPv6 address */\n    /* we need to test for raw IPv6 address for IPv4 port combinations since a\n     * colon would give false positives\n     */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET6, hostname_or_ip,\n                &s.in6.sin6_addr) == 1) {\n        s.in6.sin6_family = AF_INET6;\n\n        return new_address_sa(&s.a, sizeof(s.in6));\n    }\n\n    /* Unix socket */\n    memset(&s, 0, sizeof(s));\n    if (strncmp(\"unix:\", hostname_or_ip, 5) == 0) {\n        if (strlen(hostname_or_ip) >=\n                sizeof(s.un.sun_path))\n            return NULL;\n\n        /* XXX: only supporting pathname unix sockets */\n        s.un.sun_family = AF_UNIX;\n        strncpy(s.un.sun_path,\n                hostname_or_ip + 5,\n                sizeof(s.un.sun_path) - 1);\n\n        return new_address_sa(&s.a, offsetof(struct sockaddr_un, sun_path) +\n                              strlen(s.un.sun_path) + 1);\n    }\n\n    /* Trailing port */\n    if ((port = strrchr(hostname_or_ip, ':')) != NULL &&\n            is_numeric(port + 1)) {\n        len = (size_t)(port - hostname_or_ip);\n        int port_num = atoi(port + 1);\n\n        if (len < sizeof(ip_buf) && port_num >= 0 && port_num <= 65535) {\n            strncpy(ip_buf, hostname_or_ip, len);\n            ip_buf[len] = '\\0';\n\n            struct Address *addr = new_address(ip_buf);\n            if (addr != NULL)\n                address_set_port(addr, (uint16_t) port_num);\n\n            return addr;\n        }\n    }\n\n    /* Wildcard */\n    if (strcmp(\"*\", hostname_or_ip) == 0) {\n        struct Address *addr = malloc(sizeof(struct Address));\n        if (addr != NULL) {\n            addr->type = WILDCARD;\n            addr->len = 0;\n            address_set_port(addr, 0);\n        }\n        return addr;\n    }\n\n    /* IPv4 address */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET, hostname_or_ip,\n                  &s.in.sin_addr) == 1) {\n        s.in.sin_family = AF_INET;\n\n        return new_address_sa(&s.a, sizeof(s.in));\n    }\n\n    /* [IPv6 address] */\n    memset(&s, 0, sizeof(s));\n    if (hostname_or_ip[0] == '[' &&\n            (port = strchr(hostname_or_ip, ']')) != NULL) {\n        len = (size_t)(port - hostname_or_ip - 1);\n\n        /* inet_pton() will not parse the IP correctly unless it is in a\n         * separate string.\n         */\n        strncpy(ip_buf, hostname_or_ip + 1, len);\n        ip_buf[len] = '\\0';\n\n        if (inet_pton(AF_INET6, ip_buf,\n                      &s.in6.sin6_addr) == 1) {\n            s.in6.sin6_family = AF_INET6;\n\n            return new_address_sa(&s.a, sizeof(s.in6));\n        }\n    }\n\n    /* hostname */\n    if (valid_hostname(hostname_or_ip)) {\n        len = strlen(hostname_or_ip);\n        struct Address *addr = malloc(\n                offsetof(struct Address, data) + len + 1);\n        if (addr != NULL) {\n            addr->type = HOSTNAME;\n            addr->port = 0;\n            addr->len = len;\n            memcpy(addr->data, hostname_or_ip, len);\n            addr->data[addr->len] = '\\0';\n\n            /* Store address in lower case */\n            for (char *c = addr->data; *c != '\\0'; c++)\n                *c = tolower(*c);\n        }\n\n        return addr;\n    }\n\n    return NULL;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\n",
        "src_path": "f8d9a433fe22ab2fa15c00179048ab02ae23d583___address.c",
        "uri": "https://api.github.com/repos/dlundquist/sniproxy/commits/f8d9a433fe22ab2fa15c00179048ab02ae23d583",
        "commit_msg": "address: fix buffer overflow\n\nUpdate tests to work on Debian 11.",
        "test_func_diff": [
            {
                "fn": "tests/Makefile.am",
                "patch": "@@ -1,6 +1,8 @@\n AM_CPPFLAGS = -I$(top_srcdir)/src -g $(LIBEV_CFLAGS) $(LIBPCRE_CFLAGS) $(LIBUDNS_CFLAGS)\n AM_CFLAGS = -fno-strict-aliasing -Wall -Wextra -Wpedantic -Wwrite-strings\n \n+.NOTPARALLEL:\n+\n TESTS = address_test \\\n         buffer_test \\\n         cfg_tokenizer_test \\"
            },
            {
                "fn": "tests/bad_dns_request_test",
                "patch": "@@ -35,6 +35,11 @@ my $bad_requests = [\n         request => \"GET / HTTP/1.1\\r\\nHost: \\0example.com\\r\\n\\r\\n\",\n         client => \\&http_client,\n     },\n+    {\n+        # Exceed hostname buffer size\n+        request => \"GET / HTTP/1.1\\r\\nHost: [\" . 'long.' x 60 . \"example.com]\\r\\n\\r\\n\",\n+        client => \\&http_client,\n+    },\n     {\n         # Test client aborting connection before DNS response received\n         request => \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\","
            },
            {
                "fn": "tests/slow_client_test",
                "patch": "@@ -31,11 +31,16 @@ sub slow_client($$) {\n     my $socket = IO::Socket::INET->new(PeerAddr => '127.0.0.1',\n             PeerPort => $port,\n             Proto => \"tcp\",\n-            Type => SOCK_STREAM)\n+            Type => SOCK_STREAM,\n+            Timeout => 5)\n         or die \"couldn't connect $!\";\n \n     $socket->send($request);\n     foreach (split(\"\\r\\n\", $request)) {\n+        unless ($socket->connected()) {\n+            print \"Disconnected\\n\";\n+            exit(0);\n+        }\n         $socket->send(\"$_\\r\\n\");\n         sleep(1);\n     }"
            }
        ],
        "error_msg": "Test failed.\nserver died with signal 11, with coredump\nworker failed with exit code 111\nworker failed with exit code 111\nworker failed with exit code 111\nLibVEX; rerun with -h for copyright info\n==55383== Command: ../src/sniproxy -f -c /tmp/yoldJo0egL\n==55383== \n--55383-- WARNING: Serious error when reading debug info\n--55383-- When reading debug info from /out/dlundquist___sniproxy/git_repo_dir_f8d9a433fe22ab2fa15c00179048ab02ae23d583/src/sniproxy:\n--55383-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--55383-- WARNING: Serious error when reading debug info\n--55383-- When reading debug info from /out/dlundquist___sniproxy/git_repo_dir_f8d9a433fe22ab2fa15c00179048ab02ae23d583/src/sniproxy:\n--55383-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--55383-- WARNING: Serious error when reading debug info\n--55383-- When reading debug info from /out/dlundquist___sniproxy/git_repo_dir_f8d9a433fe22ab2fa15c00179048ab02ae23d583/src/sniproxy:\n--55383-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--55383-- WARNING: Serious error when reading debug info\n--55383-- When reading debug info from /out/dlundquist___sniproxy/git_repo_dir_f8d9a433fe22ab2fa15c00179048ab02ae23d583/src/sniproxy:\n--55383-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--55383-- WARNING: Serious error when reading debug info\n--55383-- When reading debug info from /out/dlundquist___sniproxy/git_repo_dir_f8d9a433fe22ab2fa15c00179048ab02ae23d583/src/sniproxy:\n--55383-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--55383-- WARNING: Serious error when reading debug info\n--55383-- When reading debug info from /out/dlundquist___sniproxy/git_repo_dir_f8d9a433fe22ab2fa15c00179048ab02ae23d583/src/sniproxy:\n--55383-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--55383-- WARNING: Serious error when reading debug info\n--55383-- When reading debug info from /out/dlundquist___sniproxy/git_repo_dir_f8d9a433fe22ab2fa15c00179048ab02ae23d583/src/sniproxy:\n--55383-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--55383-- WARNING: Serious error when reading debug info\n--553"
    },
    "6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45___smbutil.c": {
        "prefix": "static int\nname_len(netdissect_options *ndo,\n         const unsigned char *s, const unsigned char *maxbuf)\n{\n    const unsigned char *s0 = s;\n    unsigned char c;\n\n    if (s >= maxbuf)\n\treturn(-1);\t/* name goes past the end of the buffer */\n    ND_TCHECK2(*s, 1);\n    c = *s;\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (*s) {\n\tif (s >= maxbuf)\n\t    return(-1);\t/* name goes past the end of the buffer */\n\tND_TCHECK2(*s, 1);\n\ts += (*s) + 1;\n",
        "suffix": "    return(PTR_DIFF(s, s0) + 1);\n\ntrunc:\n    return(-1);\t/* name goes past the end of the buffer */\n}\n",
        "start": 222,
        "end": 245,
        "buggy": "static int\nname_len(netdissect_options *ndo,\n         const unsigned char *s, const unsigned char *maxbuf)\n{\n    const unsigned char *s0 = s;\n    unsigned char c;\n\n    if (s >= maxbuf)\n\treturn(-1);\t/* name goes past the end of the buffer */\n    ND_TCHECK2(*s, 1);\n    c = *s;\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (*s) {\n\tif (s >= maxbuf)\n\t    return(-1);\t/* name goes past the end of the buffer */\n\tND_TCHECK2(*s, 1);\n\ts += (*s) + 1;\n    }\n    return(PTR_DIFF(s, s0) + 1);\n\ntrunc:\n    return(-1);\t/* name goes past the end of the buffer */\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    }\n",
        "src_path": "6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45___smbutil.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45",
        "commit_msg": "CVE-2017-12893/SMB/CIFS: Add a bounds check in name_len().\n\nAfter we advance the pointer by the length value in the buffer, make\nsure it points to something in the captured data.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -449,6 +449,9 @@ decnet-oobr\t\tdecnet-oobr.pcap\t\tdecnet-oobr.out\n # bad packets from Wilfried Kirsch\n slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve\n \n+# bad packets from Otto Airamo and Antti Levom\u00e4ki\n+nbns-valgrind\t\tnbns-valgrind.pcap\t\tnbns-valgrind.out\t-vvv -e\n+\n # RTP tests\n # fuzzed pcap\n rtp-seg-fault-1  rtp-seg-fault-1.pcap  rtp-seg-fault-1.out  -v -T rtp"
            },
            {
                "fn": "tests/nbns-valgrind.out",
                "patch": "@@ -0,0 +1,16 @@\n+00:0c:85:0e:a5:ff > 00:00:0c:07:ac:f0, ethertype IPv4 (0x0800), length 92: (tos 0x0, ttl 127, id 38615, offset 0, flags [none], proto UDP (17), length 78)\n+    10.49.248.228.137 > 10.48.161.241.137: \n+>>> NBT UDP PACKET(137): QUERY; REQUEST; UNICAST\n+TrnID=0x8D40\n+OpCode=0\n+NmFlags=0x10\n+Rcode=0\n+QueryCount=1\n+AnswerCount=0\n+AuthorityCount=0\n+AddressRecCount=0\n+QuestionRecords:\n+Name=\n+WARNING: Short packet. Try increasing the snap length\n+\n+"
            }
        ],
        "error_msg": "    nbns-valgrind                      : TEST FAILED(exit 256)\n"
    },
    "8934a7d6307267d301182f19ed162563717e29e3___print-telnet.c": {
        "prefix": "static int\ntelnet_parse(netdissect_options *ndo, const u_char *sp, u_int length, int print)\n{\n\tint i, x;\n\tu_int c;\n\tconst u_char *osp, *p;\n#define FETCH(c, sp, length) \\\n\tdo { \\\n\t\tif (length < 1) \\\n\t\t\tgoto pktend; \\\n\t\tND_TCHECK(*sp); \\\n\t\tc = *sp++; \\\n\t\tlength--; \\\n\t} while (0)\n\n\tosp = sp;\n\n\tFETCH(c, sp, length);\n\tif (c != IAC)\n\t\tgoto pktend;\n\tFETCH(c, sp, length);\n\tif (c == IAC) {\t\t/* <IAC><IAC>! */\n\t\tif (print)\n\t\t\tND_PRINT((ndo, \"IAC IAC\"));\n\t\tgoto done;\n\t}\n\n\ti = c - TELCMD_FIRST;\n\tif (i < 0 || i > IAC - TELCMD_FIRST)\n\t\tgoto pktend;\n\n\tswitch (c) {\n\tcase DONT:\n\tcase DO:\n\tcase WONT:\n\tcase WILL:\n\tcase SB:\n\t\t/* DONT/DO/WONT/WILL x */\n\t\tFETCH(x, sp, length);\n\t\tif (x >= 0 && x < NTELOPTS) {\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \"%s %s\", telcmds[i], telopts[x]));\n\t\t} else {\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \"%s %#x\", telcmds[i], x));\n\t\t}\n\t\tif (c != SB)\n\t\t\tbreak;\n\t\t/* IAC SB .... IAC SE */\n\t\tp = sp;\n\t\twhile (length > (u_int)(p + 1 - sp)) {\n\t\t\tND_TCHECK2(*p, 2);\n\t\t\tif (p[0] == IAC && p[1] == SE)\n\t\t\t\tbreak;\n\t\t\tp++;\n\t\t}\n",
        "suffix": "\t\t\tgoto pktend;\n\n\t\tswitch (x) {\n\t\tcase TELOPT_AUTHENTICATION:\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, authcmd)));\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, authtype)));\n\t\t\tbreak;\n\t\tcase TELOPT_ENCRYPT:\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, enccmd)));\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, enctype)));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, cmds)));\n\t\t\tbreak;\n\t\t}\n\t\twhile (p > sp) {\n\t\t\tFETCH(x, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %#x\", x));\n\t\t}\n\t\t/* terminating IAC SE */\n\t\tif (print)\n\t\t\tND_PRINT((ndo, \" SE\"));\n\t\tsp += 2;\n\t\tbreak;\n\tdefault:\n\t\tif (print)\n\t\t\tND_PRINT((ndo, \"%s\", telcmds[i]));\n\t\tgoto done;\n\t}\n\ndone:\n\treturn sp - osp;\n\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\npktend:\n\treturn -1;\n#undef FETCH\n}\n",
        "start": 389,
        "end": 505,
        "buggy": "static int\ntelnet_parse(netdissect_options *ndo, const u_char *sp, u_int length, int print)\n{\n\tint i, x;\n\tu_int c;\n\tconst u_char *osp, *p;\n#define FETCH(c, sp, length) \\\n\tdo { \\\n\t\tif (length < 1) \\\n\t\t\tgoto pktend; \\\n\t\tND_TCHECK(*sp); \\\n\t\tc = *sp++; \\\n\t\tlength--; \\\n\t} while (0)\n\n\tosp = sp;\n\n\tFETCH(c, sp, length);\n\tif (c != IAC)\n\t\tgoto pktend;\n\tFETCH(c, sp, length);\n\tif (c == IAC) {\t\t/* <IAC><IAC>! */\n\t\tif (print)\n\t\t\tND_PRINT((ndo, \"IAC IAC\"));\n\t\tgoto done;\n\t}\n\n\ti = c - TELCMD_FIRST;\n\tif (i < 0 || i > IAC - TELCMD_FIRST)\n\t\tgoto pktend;\n\n\tswitch (c) {\n\tcase DONT:\n\tcase DO:\n\tcase WONT:\n\tcase WILL:\n\tcase SB:\n\t\t/* DONT/DO/WONT/WILL x */\n\t\tFETCH(x, sp, length);\n\t\tif (x >= 0 && x < NTELOPTS) {\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \"%s %s\", telcmds[i], telopts[x]));\n\t\t} else {\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \"%s %#x\", telcmds[i], x));\n\t\t}\n\t\tif (c != SB)\n\t\t\tbreak;\n\t\t/* IAC SB .... IAC SE */\n\t\tp = sp;\n\t\twhile (length > (u_int)(p + 1 - sp)) {\n\t\t\tND_TCHECK2(*p, 2);\n\t\t\tif (p[0] == IAC && p[1] == SE)\n\t\t\t\tbreak;\n\t\t\tp++;\n\t\t}\n\t\tif (*p != IAC)\n\t\t\tgoto pktend;\n\n\t\tswitch (x) {\n\t\tcase TELOPT_AUTHENTICATION:\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, authcmd)));\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, authtype)));\n\t\t\tbreak;\n\t\tcase TELOPT_ENCRYPT:\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, enccmd)));\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, enctype)));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, cmds)));\n\t\t\tbreak;\n\t\t}\n\t\twhile (p > sp) {\n\t\t\tFETCH(x, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %#x\", x));\n\t\t}\n\t\t/* terminating IAC SE */\n\t\tif (print)\n\t\t\tND_PRINT((ndo, \" SE\"));\n\t\tsp += 2;\n\t\tbreak;\n\tdefault:\n\t\tif (print)\n\t\t\tND_PRINT((ndo, \"%s\", telcmds[i]));\n\t\tgoto done;\n\t}\n\ndone:\n\treturn sp - osp;\n\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\npktend:\n\treturn -1;\n#undef FETCH\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\tif (*p != IAC)\n",
        "src_path": "8934a7d6307267d301182f19ed162563717e29e3___print-telnet.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/8934a7d6307267d301182f19ed162563717e29e3",
        "commit_msg": "CVE-2017-12988/TELNET: Add a missing bounds check.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -466,6 +466,7 @@ eigrp-tlv-oobr\t\teigrp-tlv-oobr.pcap\t\teigrp-tlv-oobr.out\t-vvv -e\n zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n bgp-as-path-oobr\tbgp-as-path-oobr.pcap\t\tbgp-as-path-oobr.out\t-vvv -e\n isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n+telnet-iac-check-oobr\ttelnet-iac-check-oobr.pcap\ttelnet-iac-check-oobr.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap"
            }
        ],
        "error_msg": "    telnet-iac-check-oobr              : TEST FAILED(exit 256)\n"
    },
    "3b32029db354cbc875127869d9b12a9addc75b50___print-isoclns.c": {
        "prefix": "static int\nisis_print(netdissect_options *ndo,\n           const uint8_t *p, u_int length)\n{\n    const struct isis_common_header *isis_header;\n\n    const struct isis_iih_lan_header *header_iih_lan;\n    const struct isis_iih_ptp_header *header_iih_ptp;\n    const struct isis_lsp_header *header_lsp;\n    const struct isis_csnp_header *header_csnp;\n    const struct isis_psnp_header *header_psnp;\n\n    const struct isis_tlv_lsp *tlv_lsp;\n    const struct isis_tlv_ptp_adj *tlv_ptp_adj;\n    const struct isis_tlv_is_reach *tlv_is_reach;\n    const struct isis_tlv_es_reach *tlv_es_reach;\n\n    uint8_t pdu_type, max_area, id_length, tlv_type, tlv_len, tmp, alen, lan_alen, prefix_len;\n    uint8_t ext_is_len, ext_ip_len, mt_len;\n    const uint8_t *optr, *pptr, *tptr;\n    u_short packet_len,pdu_len, key_id;\n    u_int i,vendor_id;\n    int sigcheck;\n\n    packet_len=length;\n    optr = p; /* initialize the _o_riginal pointer to the packet start -\n                 need it for parsing the checksum TLV and authentication\n                 TLV verification */\n    isis_header = (const struct isis_common_header *)p;\n    ND_TCHECK(*isis_header);\n    if (length < ISIS_COMMON_HEADER_SIZE)\n        goto trunc;\n    pptr = p+(ISIS_COMMON_HEADER_SIZE);\n    header_iih_lan = (const struct isis_iih_lan_header *)pptr;\n    header_iih_ptp = (const struct isis_iih_ptp_header *)pptr;\n    header_lsp = (const struct isis_lsp_header *)pptr;\n    header_csnp = (const struct isis_csnp_header *)pptr;\n    header_psnp = (const struct isis_psnp_header *)pptr;\n\n    if (!ndo->ndo_eflag)\n        ND_PRINT((ndo, \"IS-IS\"));\n\n    /*\n     * Sanity checking of the header.\n     */\n\n    if (isis_header->version != ISIS_VERSION) {\n\tND_PRINT((ndo, \"version %d packet not supported\", isis_header->version));\n\treturn (0);\n    }\n\n    if ((isis_header->id_length != SYSTEM_ID_LEN) && (isis_header->id_length != 0)) {\n\tND_PRINT((ndo, \"system ID length of %d is not supported\",\n\t       isis_header->id_length));\n\treturn (0);\n    }\n\n    if (isis_header->pdu_version != ISIS_VERSION) {\n\tND_PRINT((ndo, \"version %d packet not supported\", isis_header->pdu_version));\n\treturn (0);\n    }\n\n    if (length < isis_header->fixed_len) {\n\tND_PRINT((ndo, \"fixed header length %u > packet length %u\", isis_header->fixed_len, length));\n\treturn (0);\n    }\n\n    if (isis_header->fixed_len < ISIS_COMMON_HEADER_SIZE) {\n\tND_PRINT((ndo, \"fixed header length %u < minimum header size %u\", isis_header->fixed_len, (u_int)ISIS_COMMON_HEADER_SIZE));\n\treturn (0);\n    }\n\n    max_area = isis_header->max_area;\n    switch(max_area) {\n    case 0:\n\tmax_area = 3;\t /* silly shit */\n\tbreak;\n    case 255:\n\tND_PRINT((ndo, \"bad packet -- 255 areas\"));\n\treturn (0);\n    default:\n\tbreak;\n    }\n\n    id_length = isis_header->id_length;\n    switch(id_length) {\n    case 0:\n        id_length = 6;\t /* silly shit again */\n\tbreak;\n    case 1:              /* 1-8 are valid sys-ID lenghts */\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n    case 6:\n    case 7:\n    case 8:\n        break;\n    case 255:\n        id_length = 0;   /* entirely useless */\n\tbreak;\n    default:\n        break;\n    }\n\n    /* toss any non 6-byte sys-ID len PDUs */\n    if (id_length != 6 ) {\n\tND_PRINT((ndo, \"bad packet -- illegal sys-ID length (%u)\", id_length));\n\treturn (0);\n    }\n\n    pdu_type=isis_header->pdu_type;\n\n    /* in non-verbose mode print the basic PDU Type plus PDU specific brief information*/\n    if (ndo->ndo_vflag == 0) {\n        ND_PRINT((ndo, \"%s%s\",\n               ndo->ndo_eflag ? \"\" : \", \",\n               tok2str(isis_pdu_values, \"unknown PDU-Type %u\", pdu_type)));\n    } else {\n        /* ok they seem to want to know everything - lets fully decode it */\n        ND_PRINT((ndo, \"%slength %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\n        ND_PRINT((ndo, \"\\n\\t%s, hlen: %u, v: %u, pdu-v: %u, sys-id-len: %u (%u), max-area: %u (%u)\",\n               tok2str(isis_pdu_values,\n                       \"unknown, type %u\",\n                       pdu_type),\n               isis_header->fixed_len,\n               isis_header->version,\n               isis_header->pdu_version,\n               id_length,\n               isis_header->id_length,\n               max_area,\n               isis_header->max_area));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, optr, \"\\n\\t\", 8)) /* provide the _o_riginal pointer */\n                return (0);                         /* for optionally debugging the common header */\n        }\n    }\n\n    switch (pdu_type) {\n\n    case ISIS_PDU_L1_LAN_IIH:\n    case ISIS_PDU_L2_LAN_IIH:\n        if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)) {\n            ND_PRINT((ndo, \", bogus fixed header length %u should be %lu\",\n                     isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)));\n            return (0);\n        }\n        ND_TCHECK(*header_iih_lan);\n        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)\n            goto trunc;\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", src-id %s\",\n                      isis_print_id(header_iih_lan->source_id, SYSTEM_ID_LEN)));\n            ND_PRINT((ndo, \", lan-id %s, prio %u\",\n                      isis_print_id(header_iih_lan->lan_id,NODE_ID_LEN),\n                      header_iih_lan->priority));\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n        pdu_len=EXTRACT_16BITS(header_iih_lan->pdu_len);\n        if (packet_len>pdu_len) {\n           packet_len=pdu_len; /* do TLV decoding as long as it makes sense */\n           length=pdu_len;\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  source-id: %s,  holding time: %us, Flags: [%s]\",\n                  isis_print_id(header_iih_lan->source_id,SYSTEM_ID_LEN),\n                  EXTRACT_16BITS(header_iih_lan->holding_time),\n                  tok2str(isis_iih_circuit_type_values,\n                          \"unknown circuit type 0x%02x\",\n                          header_iih_lan->circuit_type)));\n\n        ND_PRINT((ndo, \"\\n\\t  lan-id:    %s, Priority: %u, PDU length: %u\",\n                  isis_print_id(header_iih_lan->lan_id, NODE_ID_LEN),\n                  (header_iih_lan->priority) & ISIS_LAN_PRIORITY_MASK,\n                  pdu_len));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, pptr, \"\\n\\t  \", ISIS_IIH_LAN_HEADER_SIZE))\n                return (0);\n        }\n\n        packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE);\n        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE);\n        break;\n\n    case ISIS_PDU_PTP_IIH:\n        if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)) {\n            ND_PRINT((ndo, \", bogus fixed header length %u should be %lu\",\n                      isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)));\n            return (0);\n        }\n        ND_TCHECK(*header_iih_ptp);\n        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)\n            goto trunc;\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", src-id %s\", isis_print_id(header_iih_ptp->source_id, SYSTEM_ID_LEN)));\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n        pdu_len=EXTRACT_16BITS(header_iih_ptp->pdu_len);\n        if (packet_len>pdu_len) {\n            packet_len=pdu_len; /* do TLV decoding as long as it makes sense */\n            length=pdu_len;\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  source-id: %s, holding time: %us, Flags: [%s]\",\n                  isis_print_id(header_iih_ptp->source_id,SYSTEM_ID_LEN),\n                  EXTRACT_16BITS(header_iih_ptp->holding_time),\n                  tok2str(isis_iih_circuit_type_values,\n                          \"unknown circuit type 0x%02x\",\n                          header_iih_ptp->circuit_type)));\n\n        ND_PRINT((ndo, \"\\n\\t  circuit-id: 0x%02x, PDU length: %u\",\n                  header_iih_ptp->circuit_id,\n                  pdu_len));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, pptr, \"\\n\\t  \", ISIS_IIH_PTP_HEADER_SIZE))\n                return (0);\n        }\n\n        packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE);\n        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE);\n        break;\n\n    case ISIS_PDU_L1_LSP:\n    case ISIS_PDU_L2_LSP:\n        if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE)) {\n            ND_PRINT((ndo, \", bogus fixed header length %u should be %lu\",\n                   isis_header->fixed_len, (unsigned long)ISIS_LSP_HEADER_SIZE));\n            return (0);\n        }\n        ND_TCHECK(*header_lsp);\n        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE)\n            goto trunc;\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", lsp-id %s, seq 0x%08x, lifetime %5us\",\n                      isis_print_id(header_lsp->lsp_id, LSP_ID_LEN),\n                      EXTRACT_32BITS(header_lsp->sequence_number),\n                      EXTRACT_16BITS(header_lsp->remaining_lifetime)));\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n        pdu_len=EXTRACT_16BITS(header_lsp->pdu_len);\n        if (packet_len>pdu_len) {\n            packet_len=pdu_len; /* do TLV decoding as long as it makes sense */\n            length=pdu_len;\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  lsp-id: %s, seq: 0x%08x, lifetime: %5us\\n\\t  chksum: 0x%04x\",\n               isis_print_id(header_lsp->lsp_id, LSP_ID_LEN),\n               EXTRACT_32BITS(header_lsp->sequence_number),\n               EXTRACT_16BITS(header_lsp->remaining_lifetime),\n               EXTRACT_16BITS(header_lsp->checksum)));\n\n        osi_print_cksum(ndo, (const uint8_t *)header_lsp->lsp_id,\n                        EXTRACT_16BITS(header_lsp->checksum),\n                        12, length-12);\n\n        ND_PRINT((ndo, \", PDU length: %u, Flags: [ %s\",\n               pdu_len,\n               ISIS_MASK_LSP_OL_BIT(header_lsp->typeblock) ? \"Overload bit set, \" : \"\"));\n\n        if (ISIS_MASK_LSP_ATT_BITS(header_lsp->typeblock)) {\n            ND_PRINT((ndo, \"%s\", ISIS_MASK_LSP_ATT_DEFAULT_BIT(header_lsp->typeblock) ? \"default \" : \"\"));\n            ND_PRINT((ndo, \"%s\", ISIS_MASK_LSP_ATT_DELAY_BIT(header_lsp->typeblock) ? \"delay \" : \"\"));\n            ND_PRINT((ndo, \"%s\", ISIS_MASK_LSP_ATT_EXPENSE_BIT(header_lsp->typeblock) ? \"expense \" : \"\"));\n            ND_PRINT((ndo, \"%s\", ISIS_MASK_LSP_ATT_ERROR_BIT(header_lsp->typeblock) ? \"error \" : \"\"));\n            ND_PRINT((ndo, \"ATT bit set, \"));\n        }\n        ND_PRINT((ndo, \"%s\", ISIS_MASK_LSP_PARTITION_BIT(header_lsp->typeblock) ? \"P bit set, \" : \"\"));\n        ND_PRINT((ndo, \"%s ]\", tok2str(isis_lsp_istype_values, \"Unknown(0x%x)\",\n                  ISIS_MASK_LSP_ISTYPE_BITS(header_lsp->typeblock))));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, pptr, \"\\n\\t  \", ISIS_LSP_HEADER_SIZE))\n                return (0);\n        }\n\n        packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE);\n        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE);\n        break;\n\n    case ISIS_PDU_L1_CSNP:\n    case ISIS_PDU_L2_CSNP:\n        if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)) {\n            ND_PRINT((ndo, \", bogus fixed header length %u should be %lu\",\n                      isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)));\n            return (0);\n        }\n        ND_TCHECK(*header_csnp);\n        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)\n            goto trunc;\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", src-id %s\", isis_print_id(header_csnp->source_id, NODE_ID_LEN)));\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n        pdu_len=EXTRACT_16BITS(header_csnp->pdu_len);\n        if (packet_len>pdu_len) {\n            packet_len=pdu_len; /* do TLV decoding as long as it makes sense */\n            length=pdu_len;\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  source-id:    %s, PDU length: %u\",\n               isis_print_id(header_csnp->source_id, NODE_ID_LEN),\n               pdu_len));\n        ND_PRINT((ndo, \"\\n\\t  start lsp-id: %s\",\n               isis_print_id(header_csnp->start_lsp_id, LSP_ID_LEN)));\n        ND_PRINT((ndo, \"\\n\\t  end lsp-id:   %s\",\n               isis_print_id(header_csnp->end_lsp_id, LSP_ID_LEN)));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, pptr, \"\\n\\t  \", ISIS_CSNP_HEADER_SIZE))\n                return (0);\n        }\n\n        packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE);\n        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE);\n        break;\n\n    case ISIS_PDU_L1_PSNP:\n    case ISIS_PDU_L2_PSNP:\n        if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)) {\n            ND_PRINT((ndo, \"- bogus fixed header length %u should be %lu\",\n                   isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)));\n            return (0);\n        }\n        ND_TCHECK(*header_psnp);\n        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)\n            goto trunc;\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", src-id %s\", isis_print_id(header_psnp->source_id, NODE_ID_LEN)));\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n        pdu_len=EXTRACT_16BITS(header_psnp->pdu_len);\n        if (packet_len>pdu_len) {\n            packet_len=pdu_len; /* do TLV decoding as long as it makes sense */\n            length=pdu_len;\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  source-id:    %s, PDU length: %u\",\n               isis_print_id(header_psnp->source_id, NODE_ID_LEN),\n               pdu_len));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, pptr, \"\\n\\t  \", ISIS_PSNP_HEADER_SIZE))\n                return (0);\n        }\n\n        packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE);\n        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE);\n        break;\n\n    default:\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n\t(void)print_unknown_data(ndo, pptr, \"\\n\\t  \", length);\n\treturn (0);\n    }\n\n    /*\n     * Now print the TLV's.\n     */\n\n    while (packet_len > 0) {\n\tND_TCHECK2(*pptr, 2);\n\tif (packet_len < 2)\n\t    goto trunc;\n\ttlv_type = *pptr++;\n\ttlv_len = *pptr++;\n        tmp =tlv_len; /* copy temporary len & pointer to packet data */\n        tptr = pptr;\n\tpacket_len -= 2;\n\n        /* first lets see if we know the TLVs name*/\n\tND_PRINT((ndo, \"\\n\\t    %s TLV #%u, length: %u\",\n               tok2str(isis_tlv_values,\n                       \"unknown\",\n                       tlv_type),\n               tlv_type,\n               tlv_len));\n\n        if (tlv_len == 0) /* something is invalid */\n\t    continue;\n\n\tif (packet_len < tlv_len)\n\t    goto trunc;\n\n        /* now check if we have a decoder otherwise do a hexdump at the end*/\n\tswitch (tlv_type) {\n\tcase ISIS_TLV_AREA_ADDR:\n\t    ND_TCHECK2(*tptr, 1);\n\t    alen = *tptr++;\n\t    while (tmp && alen < tmp) {\n",
        "suffix": "                       alen,\n                       isonsap_string(ndo, tptr, alen)));\n\t\ttptr += alen;\n\t\ttmp -= alen + 1;\n\t\tif (tmp==0) /* if this is the last area address do not attemt a boundary check */\n                    break;\n\t\tND_TCHECK2(*tptr, 1);\n\t\talen = *tptr++;\n\t    }\n\t    break;\n\tcase ISIS_TLV_ISNEIGH:\n\t    while (tmp >= ETHER_ADDR_LEN) {\n                ND_TCHECK2(*tptr, ETHER_ADDR_LEN);\n                ND_PRINT((ndo, \"\\n\\t      SNPA: %s\", isis_print_id(tptr, ETHER_ADDR_LEN)));\n                tmp -= ETHER_ADDR_LEN;\n                tptr += ETHER_ADDR_LEN;\n\t    }\n\t    break;\n\n        case ISIS_TLV_ISNEIGH_VARLEN:\n            if (!ND_TTEST2(*tptr, 1) || tmp < 3) /* min. TLV length */\n\t\tgoto trunctlv;\n\t    lan_alen = *tptr++; /* LAN address length */\n\t    if (lan_alen == 0) {\n                ND_PRINT((ndo, \"\\n\\t      LAN address length 0 bytes (invalid)\"));\n                break;\n            }\n            tmp --;\n            ND_PRINT((ndo, \"\\n\\t      LAN address length %u bytes \", lan_alen));\n\t    while (tmp >= lan_alen) {\n                ND_TCHECK2(*tptr, lan_alen);\n                ND_PRINT((ndo, \"\\n\\t\\tIS Neighbor: %s\", isis_print_id(tptr, lan_alen)));\n                tmp -= lan_alen;\n                tptr +=lan_alen;\n            }\n            break;\n\n\tcase ISIS_TLV_PADDING:\n\t    break;\n\n        case ISIS_TLV_MT_IS_REACH:\n            mt_len = isis_print_mtid(ndo, tptr, \"\\n\\t      \");\n            if (mt_len == 0) /* did something go wrong ? */\n                goto trunctlv;\n            tptr+=mt_len;\n            tmp-=mt_len;\n            while (tmp >= 2+NODE_ID_LEN+3+1) {\n                ext_is_len = isis_print_ext_is_reach(ndo, tptr, \"\\n\\t      \", tlv_type);\n                if (ext_is_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n\n                tmp-=ext_is_len;\n                tptr+=ext_is_len;\n            }\n            break;\n\n        case ISIS_TLV_IS_ALIAS_ID:\n\t    while (tmp >= NODE_ID_LEN+1) { /* is it worth attempting a decode ? */\n\t        ext_is_len = isis_print_ext_is_reach(ndo, tptr, \"\\n\\t      \", tlv_type);\n\t\tif (ext_is_len == 0) /* did something go wrong ? */\n\t            goto trunctlv;\n\t\ttmp-=ext_is_len;\n\t\ttptr+=ext_is_len;\n\t    }\n\t    break;\n\n        case ISIS_TLV_EXT_IS_REACH:\n            while (tmp >= NODE_ID_LEN+3+1) { /* is it worth attempting a decode ? */\n                ext_is_len = isis_print_ext_is_reach(ndo, tptr, \"\\n\\t      \", tlv_type);\n                if (ext_is_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n                tmp-=ext_is_len;\n                tptr+=ext_is_len;\n            }\n            break;\n        case ISIS_TLV_IS_REACH:\n\t    ND_TCHECK2(*tptr,1);  /* check if there is one byte left to read out the virtual flag */\n            ND_PRINT((ndo, \"\\n\\t      %s\",\n                   tok2str(isis_is_reach_virtual_values,\n                           \"bogus virtual flag 0x%02x\",\n                           *tptr++)));\n\t    tlv_is_reach = (const struct isis_tlv_is_reach *)tptr;\n            while (tmp >= sizeof(struct isis_tlv_is_reach)) {\n\t\tND_TCHECK(*tlv_is_reach);\n\t\tND_PRINT((ndo, \"\\n\\t      IS Neighbor: %s\",\n\t\t       isis_print_id(tlv_is_reach->neighbor_nodeid, NODE_ID_LEN)));\n\t\tisis_print_metric_block(ndo, &tlv_is_reach->isis_metric_block);\n\t\ttmp -= sizeof(struct isis_tlv_is_reach);\n\t\ttlv_is_reach++;\n\t    }\n            break;\n\n        case ISIS_TLV_ESNEIGH:\n\t    tlv_es_reach = (const struct isis_tlv_es_reach *)tptr;\n            while (tmp >= sizeof(struct isis_tlv_es_reach)) {\n\t\tND_TCHECK(*tlv_es_reach);\n\t\tND_PRINT((ndo, \"\\n\\t      ES Neighbor: %s\",\n                       isis_print_id(tlv_es_reach->neighbor_sysid, SYSTEM_ID_LEN)));\n\t\tisis_print_metric_block(ndo, &tlv_es_reach->isis_metric_block);\n\t\ttmp -= sizeof(struct isis_tlv_es_reach);\n\t\ttlv_es_reach++;\n\t    }\n            break;\n\n            /* those two TLVs share the same format */\n\tcase ISIS_TLV_INT_IP_REACH:\n\tcase ISIS_TLV_EXT_IP_REACH:\n\t\tif (!isis_print_tlv_ip_reach(ndo, pptr, \"\\n\\t      \", tlv_len))\n\t\t\treturn (1);\n\t\tbreak;\n\n\tcase ISIS_TLV_EXTD_IP_REACH:\n\t    while (tmp>0) {\n                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, \"\\n\\t      \", AF_INET);\n                if (ext_ip_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n                tptr+=ext_ip_len;\n\t\ttmp-=ext_ip_len;\n\t    }\n\t    break;\n\n        case ISIS_TLV_MT_IP_REACH:\n            mt_len = isis_print_mtid(ndo, tptr, \"\\n\\t      \");\n            if (mt_len == 0) { /* did something go wrong ? */\n                goto trunctlv;\n            }\n            tptr+=mt_len;\n            tmp-=mt_len;\n\n            while (tmp>0) {\n                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, \"\\n\\t      \", AF_INET);\n                if (ext_ip_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n                tptr+=ext_ip_len;\n\t\ttmp-=ext_ip_len;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_IP6_REACH:\n\t    while (tmp>0) {\n                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, \"\\n\\t      \", AF_INET6);\n                if (ext_ip_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n                tptr+=ext_ip_len;\n\t\ttmp-=ext_ip_len;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_MT_IP6_REACH:\n            mt_len = isis_print_mtid(ndo, tptr, \"\\n\\t      \");\n            if (mt_len == 0) { /* did something go wrong ? */\n                goto trunctlv;\n            }\n            tptr+=mt_len;\n            tmp-=mt_len;\n\n\t    while (tmp>0) {\n                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, \"\\n\\t      \", AF_INET6);\n                if (ext_ip_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n                tptr+=ext_ip_len;\n\t\ttmp-=ext_ip_len;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_IP6ADDR:\n\t    while (tmp>=sizeof(struct in6_addr)) {\n\t\tND_TCHECK2(*tptr, sizeof(struct in6_addr));\n\n                ND_PRINT((ndo, \"\\n\\t      IPv6 interface address: %s\",\n\t\t       ip6addr_string(ndo, tptr)));\n\n\t\ttptr += sizeof(struct in6_addr);\n\t\ttmp -= sizeof(struct in6_addr);\n\t    }\n\t    break;\n\tcase ISIS_TLV_AUTH:\n\t    ND_TCHECK2(*tptr, 1);\n\n            ND_PRINT((ndo, \"\\n\\t      %s: \",\n                   tok2str(isis_subtlv_auth_values,\n                           \"unknown Authentication type 0x%02x\",\n                           *tptr)));\n\n\t    switch (*tptr) {\n\t    case ISIS_SUBTLV_AUTH_SIMPLE:\n\t\tif (fn_printzp(ndo, tptr + 1, tlv_len - 1, ndo->ndo_snapend))\n\t\t    goto trunctlv;\n\t\tbreak;\n\t    case ISIS_SUBTLV_AUTH_MD5:\n\t\tfor(i=1;i<tlv_len;i++) {\n\t\t    ND_TCHECK2(*(tptr + i), 1);\n\t\t    ND_PRINT((ndo, \"%02x\", *(tptr + i)));\n\t\t}\n\t\tif (tlv_len != ISIS_SUBTLV_AUTH_MD5_LEN+1)\n                    ND_PRINT((ndo, \", (invalid subTLV) \"));\n\n                sigcheck = signature_verify(ndo, optr, length, tptr + 1,\n                                            isis_clear_checksum_lifetime,\n                                            header_lsp);\n                ND_PRINT((ndo, \" (%s)\", tok2str(signature_check_values, \"Unknown\", sigcheck)));\n\n\t\tbreak;\n            case ISIS_SUBTLV_AUTH_GENERIC:\n\t\tND_TCHECK2(*(tptr + 1), 2);\n                key_id = EXTRACT_16BITS((tptr+1));\n                ND_PRINT((ndo, \"%u, password: \", key_id));\n                for(i=1 + sizeof(uint16_t);i<tlv_len;i++) {\n                    ND_TCHECK2(*(tptr + i), 1);\n                    ND_PRINT((ndo, \"%02x\", *(tptr + i)));\n                }\n                break;\n\t    case ISIS_SUBTLV_AUTH_PRIVATE:\n\t    default:\n\t\tif (!print_unknown_data(ndo, tptr + 1, \"\\n\\t\\t  \", tlv_len - 1))\n\t\t    return(0);\n\t\tbreak;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_PTP_ADJ:\n\t    tlv_ptp_adj = (const struct isis_tlv_ptp_adj *)tptr;\n\t    if(tmp>=1) {\n\t\tND_TCHECK2(*tptr, 1);\n\t\tND_PRINT((ndo, \"\\n\\t      Adjacency State: %s (%u)\",\n\t\t       tok2str(isis_ptp_adjancey_values, \"unknown\", *tptr),\n                        *tptr));\n\t\ttmp--;\n\t    }\n\t    if(tmp>sizeof(tlv_ptp_adj->extd_local_circuit_id)) {\n\t\tND_TCHECK(tlv_ptp_adj->extd_local_circuit_id);\n\t\tND_PRINT((ndo, \"\\n\\t      Extended Local circuit-ID: 0x%08x\",\n\t\t       EXTRACT_32BITS(tlv_ptp_adj->extd_local_circuit_id)));\n\t\ttmp-=sizeof(tlv_ptp_adj->extd_local_circuit_id);\n\t    }\n\t    if(tmp>=SYSTEM_ID_LEN) {\n\t\tND_TCHECK2(tlv_ptp_adj->neighbor_sysid, SYSTEM_ID_LEN);\n\t\tND_PRINT((ndo, \"\\n\\t      Neighbor System-ID: %s\",\n\t\t       isis_print_id(tlv_ptp_adj->neighbor_sysid, SYSTEM_ID_LEN)));\n\t\ttmp-=SYSTEM_ID_LEN;\n\t    }\n\t    if(tmp>=sizeof(tlv_ptp_adj->neighbor_extd_local_circuit_id)) {\n\t\tND_TCHECK(tlv_ptp_adj->neighbor_extd_local_circuit_id);\n\t\tND_PRINT((ndo, \"\\n\\t      Neighbor Extended Local circuit-ID: 0x%08x\",\n\t\t       EXTRACT_32BITS(tlv_ptp_adj->neighbor_extd_local_circuit_id)));\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_PROTOCOLS:\n\t    ND_PRINT((ndo, \"\\n\\t      NLPID(s): \"));\n\t    while (tmp>0) {\n\t\tND_TCHECK2(*(tptr), 1);\n\t\tND_PRINT((ndo, \"%s (0x%02x)\",\n                       tok2str(nlpid_values,\n                               \"unknown\",\n                               *tptr),\n                       *tptr));\n\t\tif (tmp>1) /* further NPLIDs ? - put comma */\n\t\t    ND_PRINT((ndo, \", \"));\n                tptr++;\n                tmp--;\n\t    }\n\t    break;\n\n    case ISIS_TLV_MT_PORT_CAP:\n    {\n      ND_TCHECK2(*(tptr), 2);\n\n      ND_PRINT((ndo, \"\\n\\t       RES: %d, MTID(s): %d\",\n              (EXTRACT_16BITS (tptr) >> 12),\n              (EXTRACT_16BITS (tptr) & 0x0fff)));\n\n      tmp = tmp-2;\n      tptr = tptr+2;\n\n      if (tmp)\n        isis_print_mt_port_cap_subtlv(ndo, tptr, tmp);\n\n      break;\n    }\n\n    case ISIS_TLV_MT_CAPABILITY:\n\n      ND_TCHECK2(*(tptr), 2);\n\n      ND_PRINT((ndo, \"\\n\\t      O: %d, RES: %d, MTID(s): %d\",\n                (EXTRACT_16BITS(tptr) >> 15) & 0x01,\n                (EXTRACT_16BITS(tptr) >> 12) & 0x07,\n                EXTRACT_16BITS(tptr) & 0x0fff));\n\n      tmp = tmp-2;\n      tptr = tptr+2;\n\n      if (tmp)\n        isis_print_mt_capability_subtlv(ndo, tptr, tmp);\n\n      break;\n\n\tcase ISIS_TLV_TE_ROUTER_ID:\n\t    ND_TCHECK2(*pptr, sizeof(struct in_addr));\n\t    ND_PRINT((ndo, \"\\n\\t      Traffic Engineering Router ID: %s\", ipaddr_string(ndo, pptr)));\n\t    break;\n\n\tcase ISIS_TLV_IPADDR:\n\t    while (tmp>=sizeof(struct in_addr)) {\n\t\tND_TCHECK2(*tptr, sizeof(struct in_addr));\n\t\tND_PRINT((ndo, \"\\n\\t      IPv4 interface address: %s\", ipaddr_string(ndo, tptr)));\n\t\ttptr += sizeof(struct in_addr);\n\t\ttmp -= sizeof(struct in_addr);\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_HOSTNAME:\n\t    ND_PRINT((ndo, \"\\n\\t      Hostname: \"));\n\t    if (fn_printzp(ndo, tptr, tmp, ndo->ndo_snapend))\n\t\tgoto trunctlv;\n\t    break;\n\n\tcase ISIS_TLV_SHARED_RISK_GROUP:\n\t    if (tmp < NODE_ID_LEN)\n\t        break;\n\t    ND_TCHECK2(*tptr, NODE_ID_LEN);\n\t    ND_PRINT((ndo, \"\\n\\t      IS Neighbor: %s\", isis_print_id(tptr, NODE_ID_LEN)));\n\t    tptr+=(NODE_ID_LEN);\n\t    tmp-=(NODE_ID_LEN);\n\n\t    if (tmp < 1)\n\t        break;\n\t    ND_TCHECK2(*tptr, 1);\n\t    ND_PRINT((ndo, \", Flags: [%s]\", ISIS_MASK_TLV_SHARED_RISK_GROUP(*tptr++) ? \"numbered\" : \"unnumbered\"));\n\t    tmp--;\n\n\t    if (tmp < sizeof(struct in_addr))\n\t        break;\n\t    ND_TCHECK2(*tptr, sizeof(struct in_addr));\n\t    ND_PRINT((ndo, \"\\n\\t      IPv4 interface address: %s\", ipaddr_string(ndo, tptr)));\n\t    tptr+=sizeof(struct in_addr);\n\t    tmp-=sizeof(struct in_addr);\n\n\t    if (tmp < sizeof(struct in_addr))\n\t        break;\n\t    ND_TCHECK2(*tptr, sizeof(struct in_addr));\n\t    ND_PRINT((ndo, \"\\n\\t      IPv4 neighbor address: %s\", ipaddr_string(ndo, tptr)));\n\t    tptr+=sizeof(struct in_addr);\n\t    tmp-=sizeof(struct in_addr);\n\n\t    while (tmp>=4) {\n                ND_TCHECK2(*tptr, 4);\n                ND_PRINT((ndo, \"\\n\\t      Link-ID: 0x%08x\", EXTRACT_32BITS(tptr)));\n                tptr+=4;\n                tmp-=4;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_LSP:\n\t    tlv_lsp = (const struct isis_tlv_lsp *)tptr;\n\t    while(tmp>=sizeof(struct isis_tlv_lsp)) {\n\t\tND_TCHECK((tlv_lsp->lsp_id)[LSP_ID_LEN-1]);\n\t\tND_PRINT((ndo, \"\\n\\t      lsp-id: %s\",\n                       isis_print_id(tlv_lsp->lsp_id, LSP_ID_LEN)));\n\t\tND_TCHECK2(tlv_lsp->sequence_number, 4);\n\t\tND_PRINT((ndo, \", seq: 0x%08x\", EXTRACT_32BITS(tlv_lsp->sequence_number)));\n\t\tND_TCHECK2(tlv_lsp->remaining_lifetime, 2);\n\t\tND_PRINT((ndo, \", lifetime: %5ds\", EXTRACT_16BITS(tlv_lsp->remaining_lifetime)));\n\t\tND_TCHECK2(tlv_lsp->checksum, 2);\n\t\tND_PRINT((ndo, \", chksum: 0x%04x\", EXTRACT_16BITS(tlv_lsp->checksum)));\n\t\ttmp-=sizeof(struct isis_tlv_lsp);\n\t\ttlv_lsp++;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_CHECKSUM:\n\t    if (tmp < ISIS_TLV_CHECKSUM_MINLEN)\n\t        break;\n\t    ND_TCHECK2(*tptr, ISIS_TLV_CHECKSUM_MINLEN);\n\t    ND_PRINT((ndo, \"\\n\\t      checksum: 0x%04x \", EXTRACT_16BITS(tptr)));\n            /* do not attempt to verify the checksum if it is zero\n             * most likely a HMAC-MD5 TLV is also present and\n             * to avoid conflicts the checksum TLV is zeroed.\n             * see rfc3358 for details\n             */\n            osi_print_cksum(ndo, optr, EXTRACT_16BITS(tptr), tptr-optr,\n                length);\n\t    break;\n\n\tcase ISIS_TLV_POI:\n\t    if (tlv_len >= SYSTEM_ID_LEN + 1) {\n\t\tND_TCHECK2(*tptr, SYSTEM_ID_LEN + 1);\n\t\tND_PRINT((ndo, \"\\n\\t      Purge Originator System-ID: %s\",\n\t\t       isis_print_id(tptr + 1, SYSTEM_ID_LEN)));\n\t    }\n\n\t    if (tlv_len == 2 * SYSTEM_ID_LEN + 1) {\n\t\tND_TCHECK2(*tptr, 2 * SYSTEM_ID_LEN + 1);\n\t\tND_PRINT((ndo, \"\\n\\t      Received from System-ID: %s\",\n\t\t       isis_print_id(tptr + SYSTEM_ID_LEN + 1, SYSTEM_ID_LEN)));\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_MT_SUPPORTED:\n            if (tmp < ISIS_TLV_MT_SUPPORTED_MINLEN)\n                break;\n\t    while (tmp>1) {\n\t\t/* length can only be a multiple of 2, otherwise there is\n\t\t   something broken -> so decode down until length is 1 */\n\t\tif (tmp!=1) {\n                    mt_len = isis_print_mtid(ndo, tptr, \"\\n\\t      \");\n                    if (mt_len == 0) /* did something go wrong ? */\n                        goto trunctlv;\n                    tptr+=mt_len;\n                    tmp-=mt_len;\n\t\t} else {\n\t\t    ND_PRINT((ndo, \"\\n\\t      invalid MT-ID\"));\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_RESTART_SIGNALING:\n            /* first attempt to decode the flags */\n            if (tmp < ISIS_TLV_RESTART_SIGNALING_FLAGLEN)\n                break;\n            ND_TCHECK2(*tptr, ISIS_TLV_RESTART_SIGNALING_FLAGLEN);\n            ND_PRINT((ndo, \"\\n\\t      Flags [%s]\",\n                   bittok2str(isis_restart_flag_values, \"none\", *tptr)));\n            tptr+=ISIS_TLV_RESTART_SIGNALING_FLAGLEN;\n            tmp-=ISIS_TLV_RESTART_SIGNALING_FLAGLEN;\n\n            /* is there anything other than the flags field? */\n            if (tmp == 0)\n                break;\n\n            if (tmp < ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN)\n                break;\n            ND_TCHECK2(*tptr, ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN);\n\n            ND_PRINT((ndo, \", Remaining holding time %us\", EXTRACT_16BITS(tptr)));\n            tptr+=ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN;\n            tmp-=ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN;\n\n            /* is there an additional sysid field present ?*/\n            if (tmp == SYSTEM_ID_LEN) {\n                    ND_TCHECK2(*tptr, SYSTEM_ID_LEN);\n                    ND_PRINT((ndo, \", for %s\", isis_print_id(tptr,SYSTEM_ID_LEN)));\n            }\n\t    break;\n\n        case ISIS_TLV_IDRP_INFO:\n\t    if (tmp < ISIS_TLV_IDRP_INFO_MINLEN)\n\t        break;\n            ND_TCHECK2(*tptr, ISIS_TLV_IDRP_INFO_MINLEN);\n            ND_PRINT((ndo, \"\\n\\t      Inter-Domain Information Type: %s\",\n                   tok2str(isis_subtlv_idrp_values,\n                           \"Unknown (0x%02x)\",\n                           *tptr)));\n            switch (*tptr++) {\n            case ISIS_SUBTLV_IDRP_ASN:\n                ND_TCHECK2(*tptr, 2); /* fetch AS number */\n                ND_PRINT((ndo, \"AS Number: %u\", EXTRACT_16BITS(tptr)));\n                break;\n            case ISIS_SUBTLV_IDRP_LOCAL:\n            case ISIS_SUBTLV_IDRP_RES:\n            default:\n                if (!print_unknown_data(ndo, tptr, \"\\n\\t      \", tlv_len - 1))\n                    return(0);\n                break;\n            }\n            break;\n\n        case ISIS_TLV_LSP_BUFFERSIZE:\n\t    if (tmp < ISIS_TLV_LSP_BUFFERSIZE_MINLEN)\n\t        break;\n            ND_TCHECK2(*tptr, ISIS_TLV_LSP_BUFFERSIZE_MINLEN);\n            ND_PRINT((ndo, \"\\n\\t      LSP Buffersize: %u\", EXTRACT_16BITS(tptr)));\n            break;\n\n        case ISIS_TLV_PART_DIS:\n            while (tmp >= SYSTEM_ID_LEN) {\n                ND_TCHECK2(*tptr, SYSTEM_ID_LEN);\n                ND_PRINT((ndo, \"\\n\\t      %s\", isis_print_id(tptr, SYSTEM_ID_LEN)));\n                tptr+=SYSTEM_ID_LEN;\n                tmp-=SYSTEM_ID_LEN;\n            }\n            break;\n\n        case ISIS_TLV_PREFIX_NEIGH:\n\t    if (tmp < sizeof(struct isis_metric_block))\n\t        break;\n            ND_TCHECK2(*tptr, sizeof(struct isis_metric_block));\n            ND_PRINT((ndo, \"\\n\\t      Metric Block\"));\n            isis_print_metric_block(ndo, (const struct isis_metric_block *)tptr);\n            tptr+=sizeof(struct isis_metric_block);\n            tmp-=sizeof(struct isis_metric_block);\n\n            while(tmp>0) {\n                ND_TCHECK2(*tptr, 1);\n                prefix_len=*tptr++; /* read out prefix length in semioctets*/\n                if (prefix_len < 2) {\n                    ND_PRINT((ndo, \"\\n\\t\\tAddress: prefix length %u < 2\", prefix_len));\n                    break;\n                }\n                tmp--;\n                if (tmp < prefix_len/2)\n                    break;\n                ND_TCHECK2(*tptr, prefix_len / 2);\n                ND_PRINT((ndo, \"\\n\\t\\tAddress: %s/%u\",\n                       isonsap_string(ndo, tptr, prefix_len / 2), prefix_len * 4));\n                tptr+=prefix_len/2;\n                tmp-=prefix_len/2;\n            }\n            break;\n\n        case ISIS_TLV_IIH_SEQNR:\n\t    if (tmp < ISIS_TLV_IIH_SEQNR_MINLEN)\n\t        break;\n            ND_TCHECK2(*tptr, ISIS_TLV_IIH_SEQNR_MINLEN); /* check if four bytes are on the wire */\n            ND_PRINT((ndo, \"\\n\\t      Sequence number: %u\", EXTRACT_32BITS(tptr)));\n            break;\n\n        case ISIS_TLV_VENDOR_PRIVATE:\n\t    if (tmp < ISIS_TLV_VENDOR_PRIVATE_MINLEN)\n\t        break;\n            ND_TCHECK2(*tptr, ISIS_TLV_VENDOR_PRIVATE_MINLEN); /* check if enough byte for a full oui */\n            vendor_id = EXTRACT_24BITS(tptr);\n            ND_PRINT((ndo, \"\\n\\t      Vendor: %s (%u)\",\n                   tok2str(oui_values, \"Unknown\", vendor_id),\n                   vendor_id));\n            tptr+=3;\n            tmp-=3;\n            if (tmp > 0) /* hexdump the rest */\n                if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t\", tmp))\n                    return(0);\n            break;\n            /*\n             * FIXME those are the defined TLVs that lack a decoder\n             * you are welcome to contribute code ;-)\n             */\n\n        case ISIS_TLV_DECNET_PHASE4:\n        case ISIS_TLV_LUCENT_PRIVATE:\n        case ISIS_TLV_IPAUTH:\n        case ISIS_TLV_NORTEL_PRIVATE1:\n        case ISIS_TLV_NORTEL_PRIVATE2:\n\n\tdefault:\n\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\tif (!print_unknown_data(ndo, pptr, \"\\n\\t\\t\", tlv_len))\n\t\t\t\treturn(0);\n\t\t}\n\t\tbreak;\n\t}\n        /* do we want to see an additionally hexdump ? */\n\tif (ndo->ndo_vflag> 1) {\n\t\tif (!print_unknown_data(ndo, pptr, \"\\n\\t      \", tlv_len))\n\t\t\treturn(0);\n\t}\n\n\tpptr += tlv_len;\n\tpacket_len -= tlv_len;\n    }\n\n    if (packet_len != 0) {\n\tND_PRINT((ndo, \"\\n\\t      %u straggler bytes\", packet_len));\n    }\n    return (1);\n\n trunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n    return (1);\n\n trunctlv:\n    ND_PRINT((ndo, \"\\n\\t\\t\"));\n    ND_PRINT((ndo, \"%s\", tstr));\n    return(1);\n}\n",
        "start": 2134,
        "end": 3110,
        "buggy": "static int\nisis_print(netdissect_options *ndo,\n           const uint8_t *p, u_int length)\n{\n    const struct isis_common_header *isis_header;\n\n    const struct isis_iih_lan_header *header_iih_lan;\n    const struct isis_iih_ptp_header *header_iih_ptp;\n    const struct isis_lsp_header *header_lsp;\n    const struct isis_csnp_header *header_csnp;\n    const struct isis_psnp_header *header_psnp;\n\n    const struct isis_tlv_lsp *tlv_lsp;\n    const struct isis_tlv_ptp_adj *tlv_ptp_adj;\n    const struct isis_tlv_is_reach *tlv_is_reach;\n    const struct isis_tlv_es_reach *tlv_es_reach;\n\n    uint8_t pdu_type, max_area, id_length, tlv_type, tlv_len, tmp, alen, lan_alen, prefix_len;\n    uint8_t ext_is_len, ext_ip_len, mt_len;\n    const uint8_t *optr, *pptr, *tptr;\n    u_short packet_len,pdu_len, key_id;\n    u_int i,vendor_id;\n    int sigcheck;\n\n    packet_len=length;\n    optr = p; /* initialize the _o_riginal pointer to the packet start -\n                 need it for parsing the checksum TLV and authentication\n                 TLV verification */\n    isis_header = (const struct isis_common_header *)p;\n    ND_TCHECK(*isis_header);\n    if (length < ISIS_COMMON_HEADER_SIZE)\n        goto trunc;\n    pptr = p+(ISIS_COMMON_HEADER_SIZE);\n    header_iih_lan = (const struct isis_iih_lan_header *)pptr;\n    header_iih_ptp = (const struct isis_iih_ptp_header *)pptr;\n    header_lsp = (const struct isis_lsp_header *)pptr;\n    header_csnp = (const struct isis_csnp_header *)pptr;\n    header_psnp = (const struct isis_psnp_header *)pptr;\n\n    if (!ndo->ndo_eflag)\n        ND_PRINT((ndo, \"IS-IS\"));\n\n    /*\n     * Sanity checking of the header.\n     */\n\n    if (isis_header->version != ISIS_VERSION) {\n\tND_PRINT((ndo, \"version %d packet not supported\", isis_header->version));\n\treturn (0);\n    }\n\n    if ((isis_header->id_length != SYSTEM_ID_LEN) && (isis_header->id_length != 0)) {\n\tND_PRINT((ndo, \"system ID length of %d is not supported\",\n\t       isis_header->id_length));\n\treturn (0);\n    }\n\n    if (isis_header->pdu_version != ISIS_VERSION) {\n\tND_PRINT((ndo, \"version %d packet not supported\", isis_header->pdu_version));\n\treturn (0);\n    }\n\n    if (length < isis_header->fixed_len) {\n\tND_PRINT((ndo, \"fixed header length %u > packet length %u\", isis_header->fixed_len, length));\n\treturn (0);\n    }\n\n    if (isis_header->fixed_len < ISIS_COMMON_HEADER_SIZE) {\n\tND_PRINT((ndo, \"fixed header length %u < minimum header size %u\", isis_header->fixed_len, (u_int)ISIS_COMMON_HEADER_SIZE));\n\treturn (0);\n    }\n\n    max_area = isis_header->max_area;\n    switch(max_area) {\n    case 0:\n\tmax_area = 3;\t /* silly shit */\n\tbreak;\n    case 255:\n\tND_PRINT((ndo, \"bad packet -- 255 areas\"));\n\treturn (0);\n    default:\n\tbreak;\n    }\n\n    id_length = isis_header->id_length;\n    switch(id_length) {\n    case 0:\n        id_length = 6;\t /* silly shit again */\n\tbreak;\n    case 1:              /* 1-8 are valid sys-ID lenghts */\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n    case 6:\n    case 7:\n    case 8:\n        break;\n    case 255:\n        id_length = 0;   /* entirely useless */\n\tbreak;\n    default:\n        break;\n    }\n\n    /* toss any non 6-byte sys-ID len PDUs */\n    if (id_length != 6 ) {\n\tND_PRINT((ndo, \"bad packet -- illegal sys-ID length (%u)\", id_length));\n\treturn (0);\n    }\n\n    pdu_type=isis_header->pdu_type;\n\n    /* in non-verbose mode print the basic PDU Type plus PDU specific brief information*/\n    if (ndo->ndo_vflag == 0) {\n        ND_PRINT((ndo, \"%s%s\",\n               ndo->ndo_eflag ? \"\" : \", \",\n               tok2str(isis_pdu_values, \"unknown PDU-Type %u\", pdu_type)));\n    } else {\n        /* ok they seem to want to know everything - lets fully decode it */\n        ND_PRINT((ndo, \"%slength %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\n        ND_PRINT((ndo, \"\\n\\t%s, hlen: %u, v: %u, pdu-v: %u, sys-id-len: %u (%u), max-area: %u (%u)\",\n               tok2str(isis_pdu_values,\n                       \"unknown, type %u\",\n                       pdu_type),\n               isis_header->fixed_len,\n               isis_header->version,\n               isis_header->pdu_version,\n               id_length,\n               isis_header->id_length,\n               max_area,\n               isis_header->max_area));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, optr, \"\\n\\t\", 8)) /* provide the _o_riginal pointer */\n                return (0);                         /* for optionally debugging the common header */\n        }\n    }\n\n    switch (pdu_type) {\n\n    case ISIS_PDU_L1_LAN_IIH:\n    case ISIS_PDU_L2_LAN_IIH:\n        if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)) {\n            ND_PRINT((ndo, \", bogus fixed header length %u should be %lu\",\n                     isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)));\n            return (0);\n        }\n        ND_TCHECK(*header_iih_lan);\n        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)\n            goto trunc;\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", src-id %s\",\n                      isis_print_id(header_iih_lan->source_id, SYSTEM_ID_LEN)));\n            ND_PRINT((ndo, \", lan-id %s, prio %u\",\n                      isis_print_id(header_iih_lan->lan_id,NODE_ID_LEN),\n                      header_iih_lan->priority));\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n        pdu_len=EXTRACT_16BITS(header_iih_lan->pdu_len);\n        if (packet_len>pdu_len) {\n           packet_len=pdu_len; /* do TLV decoding as long as it makes sense */\n           length=pdu_len;\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  source-id: %s,  holding time: %us, Flags: [%s]\",\n                  isis_print_id(header_iih_lan->source_id,SYSTEM_ID_LEN),\n                  EXTRACT_16BITS(header_iih_lan->holding_time),\n                  tok2str(isis_iih_circuit_type_values,\n                          \"unknown circuit type 0x%02x\",\n                          header_iih_lan->circuit_type)));\n\n        ND_PRINT((ndo, \"\\n\\t  lan-id:    %s, Priority: %u, PDU length: %u\",\n                  isis_print_id(header_iih_lan->lan_id, NODE_ID_LEN),\n                  (header_iih_lan->priority) & ISIS_LAN_PRIORITY_MASK,\n                  pdu_len));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, pptr, \"\\n\\t  \", ISIS_IIH_LAN_HEADER_SIZE))\n                return (0);\n        }\n\n        packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE);\n        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE);\n        break;\n\n    case ISIS_PDU_PTP_IIH:\n        if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)) {\n            ND_PRINT((ndo, \", bogus fixed header length %u should be %lu\",\n                      isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)));\n            return (0);\n        }\n        ND_TCHECK(*header_iih_ptp);\n        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)\n            goto trunc;\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", src-id %s\", isis_print_id(header_iih_ptp->source_id, SYSTEM_ID_LEN)));\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n        pdu_len=EXTRACT_16BITS(header_iih_ptp->pdu_len);\n        if (packet_len>pdu_len) {\n            packet_len=pdu_len; /* do TLV decoding as long as it makes sense */\n            length=pdu_len;\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  source-id: %s, holding time: %us, Flags: [%s]\",\n                  isis_print_id(header_iih_ptp->source_id,SYSTEM_ID_LEN),\n                  EXTRACT_16BITS(header_iih_ptp->holding_time),\n                  tok2str(isis_iih_circuit_type_values,\n                          \"unknown circuit type 0x%02x\",\n                          header_iih_ptp->circuit_type)));\n\n        ND_PRINT((ndo, \"\\n\\t  circuit-id: 0x%02x, PDU length: %u\",\n                  header_iih_ptp->circuit_id,\n                  pdu_len));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, pptr, \"\\n\\t  \", ISIS_IIH_PTP_HEADER_SIZE))\n                return (0);\n        }\n\n        packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE);\n        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE);\n        break;\n\n    case ISIS_PDU_L1_LSP:\n    case ISIS_PDU_L2_LSP:\n        if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE)) {\n            ND_PRINT((ndo, \", bogus fixed header length %u should be %lu\",\n                   isis_header->fixed_len, (unsigned long)ISIS_LSP_HEADER_SIZE));\n            return (0);\n        }\n        ND_TCHECK(*header_lsp);\n        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE)\n            goto trunc;\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", lsp-id %s, seq 0x%08x, lifetime %5us\",\n                      isis_print_id(header_lsp->lsp_id, LSP_ID_LEN),\n                      EXTRACT_32BITS(header_lsp->sequence_number),\n                      EXTRACT_16BITS(header_lsp->remaining_lifetime)));\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n        pdu_len=EXTRACT_16BITS(header_lsp->pdu_len);\n        if (packet_len>pdu_len) {\n            packet_len=pdu_len; /* do TLV decoding as long as it makes sense */\n            length=pdu_len;\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  lsp-id: %s, seq: 0x%08x, lifetime: %5us\\n\\t  chksum: 0x%04x\",\n               isis_print_id(header_lsp->lsp_id, LSP_ID_LEN),\n               EXTRACT_32BITS(header_lsp->sequence_number),\n               EXTRACT_16BITS(header_lsp->remaining_lifetime),\n               EXTRACT_16BITS(header_lsp->checksum)));\n\n        osi_print_cksum(ndo, (const uint8_t *)header_lsp->lsp_id,\n                        EXTRACT_16BITS(header_lsp->checksum),\n                        12, length-12);\n\n        ND_PRINT((ndo, \", PDU length: %u, Flags: [ %s\",\n               pdu_len,\n               ISIS_MASK_LSP_OL_BIT(header_lsp->typeblock) ? \"Overload bit set, \" : \"\"));\n\n        if (ISIS_MASK_LSP_ATT_BITS(header_lsp->typeblock)) {\n            ND_PRINT((ndo, \"%s\", ISIS_MASK_LSP_ATT_DEFAULT_BIT(header_lsp->typeblock) ? \"default \" : \"\"));\n            ND_PRINT((ndo, \"%s\", ISIS_MASK_LSP_ATT_DELAY_BIT(header_lsp->typeblock) ? \"delay \" : \"\"));\n            ND_PRINT((ndo, \"%s\", ISIS_MASK_LSP_ATT_EXPENSE_BIT(header_lsp->typeblock) ? \"expense \" : \"\"));\n            ND_PRINT((ndo, \"%s\", ISIS_MASK_LSP_ATT_ERROR_BIT(header_lsp->typeblock) ? \"error \" : \"\"));\n            ND_PRINT((ndo, \"ATT bit set, \"));\n        }\n        ND_PRINT((ndo, \"%s\", ISIS_MASK_LSP_PARTITION_BIT(header_lsp->typeblock) ? \"P bit set, \" : \"\"));\n        ND_PRINT((ndo, \"%s ]\", tok2str(isis_lsp_istype_values, \"Unknown(0x%x)\",\n                  ISIS_MASK_LSP_ISTYPE_BITS(header_lsp->typeblock))));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, pptr, \"\\n\\t  \", ISIS_LSP_HEADER_SIZE))\n                return (0);\n        }\n\n        packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE);\n        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE);\n        break;\n\n    case ISIS_PDU_L1_CSNP:\n    case ISIS_PDU_L2_CSNP:\n        if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)) {\n            ND_PRINT((ndo, \", bogus fixed header length %u should be %lu\",\n                      isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)));\n            return (0);\n        }\n        ND_TCHECK(*header_csnp);\n        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)\n            goto trunc;\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", src-id %s\", isis_print_id(header_csnp->source_id, NODE_ID_LEN)));\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n        pdu_len=EXTRACT_16BITS(header_csnp->pdu_len);\n        if (packet_len>pdu_len) {\n            packet_len=pdu_len; /* do TLV decoding as long as it makes sense */\n            length=pdu_len;\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  source-id:    %s, PDU length: %u\",\n               isis_print_id(header_csnp->source_id, NODE_ID_LEN),\n               pdu_len));\n        ND_PRINT((ndo, \"\\n\\t  start lsp-id: %s\",\n               isis_print_id(header_csnp->start_lsp_id, LSP_ID_LEN)));\n        ND_PRINT((ndo, \"\\n\\t  end lsp-id:   %s\",\n               isis_print_id(header_csnp->end_lsp_id, LSP_ID_LEN)));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, pptr, \"\\n\\t  \", ISIS_CSNP_HEADER_SIZE))\n                return (0);\n        }\n\n        packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE);\n        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE);\n        break;\n\n    case ISIS_PDU_L1_PSNP:\n    case ISIS_PDU_L2_PSNP:\n        if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)) {\n            ND_PRINT((ndo, \"- bogus fixed header length %u should be %lu\",\n                   isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)));\n            return (0);\n        }\n        ND_TCHECK(*header_psnp);\n        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)\n            goto trunc;\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", src-id %s\", isis_print_id(header_psnp->source_id, NODE_ID_LEN)));\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n        pdu_len=EXTRACT_16BITS(header_psnp->pdu_len);\n        if (packet_len>pdu_len) {\n            packet_len=pdu_len; /* do TLV decoding as long as it makes sense */\n            length=pdu_len;\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  source-id:    %s, PDU length: %u\",\n               isis_print_id(header_psnp->source_id, NODE_ID_LEN),\n               pdu_len));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, pptr, \"\\n\\t  \", ISIS_PSNP_HEADER_SIZE))\n                return (0);\n        }\n\n        packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE);\n        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE);\n        break;\n\n    default:\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n\t(void)print_unknown_data(ndo, pptr, \"\\n\\t  \", length);\n\treturn (0);\n    }\n\n    /*\n     * Now print the TLV's.\n     */\n\n    while (packet_len > 0) {\n\tND_TCHECK2(*pptr, 2);\n\tif (packet_len < 2)\n\t    goto trunc;\n\ttlv_type = *pptr++;\n\ttlv_len = *pptr++;\n        tmp =tlv_len; /* copy temporary len & pointer to packet data */\n        tptr = pptr;\n\tpacket_len -= 2;\n\n        /* first lets see if we know the TLVs name*/\n\tND_PRINT((ndo, \"\\n\\t    %s TLV #%u, length: %u\",\n               tok2str(isis_tlv_values,\n                       \"unknown\",\n                       tlv_type),\n               tlv_type,\n               tlv_len));\n\n        if (tlv_len == 0) /* something is invalid */\n\t    continue;\n\n\tif (packet_len < tlv_len)\n\t    goto trunc;\n\n        /* now check if we have a decoder otherwise do a hexdump at the end*/\n\tswitch (tlv_type) {\n\tcase ISIS_TLV_AREA_ADDR:\n\t    ND_TCHECK2(*tptr, 1);\n\t    alen = *tptr++;\n\t    while (tmp && alen < tmp) {\n\t\tND_PRINT((ndo, \"\\n\\t      Area address (length: %u): %s\",\n                       alen,\n                       isonsap_string(ndo, tptr, alen)));\n\t\ttptr += alen;\n\t\ttmp -= alen + 1;\n\t\tif (tmp==0) /* if this is the last area address do not attemt a boundary check */\n                    break;\n\t\tND_TCHECK2(*tptr, 1);\n\t\talen = *tptr++;\n\t    }\n\t    break;\n\tcase ISIS_TLV_ISNEIGH:\n\t    while (tmp >= ETHER_ADDR_LEN) {\n                ND_TCHECK2(*tptr, ETHER_ADDR_LEN);\n                ND_PRINT((ndo, \"\\n\\t      SNPA: %s\", isis_print_id(tptr, ETHER_ADDR_LEN)));\n                tmp -= ETHER_ADDR_LEN;\n                tptr += ETHER_ADDR_LEN;\n\t    }\n\t    break;\n\n        case ISIS_TLV_ISNEIGH_VARLEN:\n            if (!ND_TTEST2(*tptr, 1) || tmp < 3) /* min. TLV length */\n\t\tgoto trunctlv;\n\t    lan_alen = *tptr++; /* LAN address length */\n\t    if (lan_alen == 0) {\n                ND_PRINT((ndo, \"\\n\\t      LAN address length 0 bytes (invalid)\"));\n                break;\n            }\n            tmp --;\n            ND_PRINT((ndo, \"\\n\\t      LAN address length %u bytes \", lan_alen));\n\t    while (tmp >= lan_alen) {\n                ND_TCHECK2(*tptr, lan_alen);\n                ND_PRINT((ndo, \"\\n\\t\\tIS Neighbor: %s\", isis_print_id(tptr, lan_alen)));\n                tmp -= lan_alen;\n                tptr +=lan_alen;\n            }\n            break;\n\n\tcase ISIS_TLV_PADDING:\n\t    break;\n\n        case ISIS_TLV_MT_IS_REACH:\n            mt_len = isis_print_mtid(ndo, tptr, \"\\n\\t      \");\n            if (mt_len == 0) /* did something go wrong ? */\n                goto trunctlv;\n            tptr+=mt_len;\n            tmp-=mt_len;\n            while (tmp >= 2+NODE_ID_LEN+3+1) {\n                ext_is_len = isis_print_ext_is_reach(ndo, tptr, \"\\n\\t      \", tlv_type);\n                if (ext_is_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n\n                tmp-=ext_is_len;\n                tptr+=ext_is_len;\n            }\n            break;\n\n        case ISIS_TLV_IS_ALIAS_ID:\n\t    while (tmp >= NODE_ID_LEN+1) { /* is it worth attempting a decode ? */\n\t        ext_is_len = isis_print_ext_is_reach(ndo, tptr, \"\\n\\t      \", tlv_type);\n\t\tif (ext_is_len == 0) /* did something go wrong ? */\n\t            goto trunctlv;\n\t\ttmp-=ext_is_len;\n\t\ttptr+=ext_is_len;\n\t    }\n\t    break;\n\n        case ISIS_TLV_EXT_IS_REACH:\n            while (tmp >= NODE_ID_LEN+3+1) { /* is it worth attempting a decode ? */\n                ext_is_len = isis_print_ext_is_reach(ndo, tptr, \"\\n\\t      \", tlv_type);\n                if (ext_is_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n                tmp-=ext_is_len;\n                tptr+=ext_is_len;\n            }\n            break;\n        case ISIS_TLV_IS_REACH:\n\t    ND_TCHECK2(*tptr,1);  /* check if there is one byte left to read out the virtual flag */\n            ND_PRINT((ndo, \"\\n\\t      %s\",\n                   tok2str(isis_is_reach_virtual_values,\n                           \"bogus virtual flag 0x%02x\",\n                           *tptr++)));\n\t    tlv_is_reach = (const struct isis_tlv_is_reach *)tptr;\n            while (tmp >= sizeof(struct isis_tlv_is_reach)) {\n\t\tND_TCHECK(*tlv_is_reach);\n\t\tND_PRINT((ndo, \"\\n\\t      IS Neighbor: %s\",\n\t\t       isis_print_id(tlv_is_reach->neighbor_nodeid, NODE_ID_LEN)));\n\t\tisis_print_metric_block(ndo, &tlv_is_reach->isis_metric_block);\n\t\ttmp -= sizeof(struct isis_tlv_is_reach);\n\t\ttlv_is_reach++;\n\t    }\n            break;\n\n        case ISIS_TLV_ESNEIGH:\n\t    tlv_es_reach = (const struct isis_tlv_es_reach *)tptr;\n            while (tmp >= sizeof(struct isis_tlv_es_reach)) {\n\t\tND_TCHECK(*tlv_es_reach);\n\t\tND_PRINT((ndo, \"\\n\\t      ES Neighbor: %s\",\n                       isis_print_id(tlv_es_reach->neighbor_sysid, SYSTEM_ID_LEN)));\n\t\tisis_print_metric_block(ndo, &tlv_es_reach->isis_metric_block);\n\t\ttmp -= sizeof(struct isis_tlv_es_reach);\n\t\ttlv_es_reach++;\n\t    }\n            break;\n\n            /* those two TLVs share the same format */\n\tcase ISIS_TLV_INT_IP_REACH:\n\tcase ISIS_TLV_EXT_IP_REACH:\n\t\tif (!isis_print_tlv_ip_reach(ndo, pptr, \"\\n\\t      \", tlv_len))\n\t\t\treturn (1);\n\t\tbreak;\n\n\tcase ISIS_TLV_EXTD_IP_REACH:\n\t    while (tmp>0) {\n                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, \"\\n\\t      \", AF_INET);\n                if (ext_ip_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n                tptr+=ext_ip_len;\n\t\ttmp-=ext_ip_len;\n\t    }\n\t    break;\n\n        case ISIS_TLV_MT_IP_REACH:\n            mt_len = isis_print_mtid(ndo, tptr, \"\\n\\t      \");\n            if (mt_len == 0) { /* did something go wrong ? */\n                goto trunctlv;\n            }\n            tptr+=mt_len;\n            tmp-=mt_len;\n\n            while (tmp>0) {\n                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, \"\\n\\t      \", AF_INET);\n                if (ext_ip_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n                tptr+=ext_ip_len;\n\t\ttmp-=ext_ip_len;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_IP6_REACH:\n\t    while (tmp>0) {\n                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, \"\\n\\t      \", AF_INET6);\n                if (ext_ip_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n                tptr+=ext_ip_len;\n\t\ttmp-=ext_ip_len;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_MT_IP6_REACH:\n            mt_len = isis_print_mtid(ndo, tptr, \"\\n\\t      \");\n            if (mt_len == 0) { /* did something go wrong ? */\n                goto trunctlv;\n            }\n            tptr+=mt_len;\n            tmp-=mt_len;\n\n\t    while (tmp>0) {\n                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, \"\\n\\t      \", AF_INET6);\n                if (ext_ip_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n                tptr+=ext_ip_len;\n\t\ttmp-=ext_ip_len;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_IP6ADDR:\n\t    while (tmp>=sizeof(struct in6_addr)) {\n\t\tND_TCHECK2(*tptr, sizeof(struct in6_addr));\n\n                ND_PRINT((ndo, \"\\n\\t      IPv6 interface address: %s\",\n\t\t       ip6addr_string(ndo, tptr)));\n\n\t\ttptr += sizeof(struct in6_addr);\n\t\ttmp -= sizeof(struct in6_addr);\n\t    }\n\t    break;\n\tcase ISIS_TLV_AUTH:\n\t    ND_TCHECK2(*tptr, 1);\n\n            ND_PRINT((ndo, \"\\n\\t      %s: \",\n                   tok2str(isis_subtlv_auth_values,\n                           \"unknown Authentication type 0x%02x\",\n                           *tptr)));\n\n\t    switch (*tptr) {\n\t    case ISIS_SUBTLV_AUTH_SIMPLE:\n\t\tif (fn_printzp(ndo, tptr + 1, tlv_len - 1, ndo->ndo_snapend))\n\t\t    goto trunctlv;\n\t\tbreak;\n\t    case ISIS_SUBTLV_AUTH_MD5:\n\t\tfor(i=1;i<tlv_len;i++) {\n\t\t    ND_TCHECK2(*(tptr + i), 1);\n\t\t    ND_PRINT((ndo, \"%02x\", *(tptr + i)));\n\t\t}\n\t\tif (tlv_len != ISIS_SUBTLV_AUTH_MD5_LEN+1)\n                    ND_PRINT((ndo, \", (invalid subTLV) \"));\n\n                sigcheck = signature_verify(ndo, optr, length, tptr + 1,\n                                            isis_clear_checksum_lifetime,\n                                            header_lsp);\n                ND_PRINT((ndo, \" (%s)\", tok2str(signature_check_values, \"Unknown\", sigcheck)));\n\n\t\tbreak;\n            case ISIS_SUBTLV_AUTH_GENERIC:\n\t\tND_TCHECK2(*(tptr + 1), 2);\n                key_id = EXTRACT_16BITS((tptr+1));\n                ND_PRINT((ndo, \"%u, password: \", key_id));\n                for(i=1 + sizeof(uint16_t);i<tlv_len;i++) {\n                    ND_TCHECK2(*(tptr + i), 1);\n                    ND_PRINT((ndo, \"%02x\", *(tptr + i)));\n                }\n                break;\n\t    case ISIS_SUBTLV_AUTH_PRIVATE:\n\t    default:\n\t\tif (!print_unknown_data(ndo, tptr + 1, \"\\n\\t\\t  \", tlv_len - 1))\n\t\t    return(0);\n\t\tbreak;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_PTP_ADJ:\n\t    tlv_ptp_adj = (const struct isis_tlv_ptp_adj *)tptr;\n\t    if(tmp>=1) {\n\t\tND_TCHECK2(*tptr, 1);\n\t\tND_PRINT((ndo, \"\\n\\t      Adjacency State: %s (%u)\",\n\t\t       tok2str(isis_ptp_adjancey_values, \"unknown\", *tptr),\n                        *tptr));\n\t\ttmp--;\n\t    }\n\t    if(tmp>sizeof(tlv_ptp_adj->extd_local_circuit_id)) {\n\t\tND_TCHECK(tlv_ptp_adj->extd_local_circuit_id);\n\t\tND_PRINT((ndo, \"\\n\\t      Extended Local circuit-ID: 0x%08x\",\n\t\t       EXTRACT_32BITS(tlv_ptp_adj->extd_local_circuit_id)));\n\t\ttmp-=sizeof(tlv_ptp_adj->extd_local_circuit_id);\n\t    }\n\t    if(tmp>=SYSTEM_ID_LEN) {\n\t\tND_TCHECK2(tlv_ptp_adj->neighbor_sysid, SYSTEM_ID_LEN);\n\t\tND_PRINT((ndo, \"\\n\\t      Neighbor System-ID: %s\",\n\t\t       isis_print_id(tlv_ptp_adj->neighbor_sysid, SYSTEM_ID_LEN)));\n\t\ttmp-=SYSTEM_ID_LEN;\n\t    }\n\t    if(tmp>=sizeof(tlv_ptp_adj->neighbor_extd_local_circuit_id)) {\n\t\tND_TCHECK(tlv_ptp_adj->neighbor_extd_local_circuit_id);\n\t\tND_PRINT((ndo, \"\\n\\t      Neighbor Extended Local circuit-ID: 0x%08x\",\n\t\t       EXTRACT_32BITS(tlv_ptp_adj->neighbor_extd_local_circuit_id)));\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_PROTOCOLS:\n\t    ND_PRINT((ndo, \"\\n\\t      NLPID(s): \"));\n\t    while (tmp>0) {\n\t\tND_TCHECK2(*(tptr), 1);\n\t\tND_PRINT((ndo, \"%s (0x%02x)\",\n                       tok2str(nlpid_values,\n                               \"unknown\",\n                               *tptr),\n                       *tptr));\n\t\tif (tmp>1) /* further NPLIDs ? - put comma */\n\t\t    ND_PRINT((ndo, \", \"));\n                tptr++;\n                tmp--;\n\t    }\n\t    break;\n\n    case ISIS_TLV_MT_PORT_CAP:\n    {\n      ND_TCHECK2(*(tptr), 2);\n\n      ND_PRINT((ndo, \"\\n\\t       RES: %d, MTID(s): %d\",\n              (EXTRACT_16BITS (tptr) >> 12),\n              (EXTRACT_16BITS (tptr) & 0x0fff)));\n\n      tmp = tmp-2;\n      tptr = tptr+2;\n\n      if (tmp)\n        isis_print_mt_port_cap_subtlv(ndo, tptr, tmp);\n\n      break;\n    }\n\n    case ISIS_TLV_MT_CAPABILITY:\n\n      ND_TCHECK2(*(tptr), 2);\n\n      ND_PRINT((ndo, \"\\n\\t      O: %d, RES: %d, MTID(s): %d\",\n                (EXTRACT_16BITS(tptr) >> 15) & 0x01,\n                (EXTRACT_16BITS(tptr) >> 12) & 0x07,\n                EXTRACT_16BITS(tptr) & 0x0fff));\n\n      tmp = tmp-2;\n      tptr = tptr+2;\n\n      if (tmp)\n        isis_print_mt_capability_subtlv(ndo, tptr, tmp);\n\n      break;\n\n\tcase ISIS_TLV_TE_ROUTER_ID:\n\t    ND_TCHECK2(*pptr, sizeof(struct in_addr));\n\t    ND_PRINT((ndo, \"\\n\\t      Traffic Engineering Router ID: %s\", ipaddr_string(ndo, pptr)));\n\t    break;\n\n\tcase ISIS_TLV_IPADDR:\n\t    while (tmp>=sizeof(struct in_addr)) {\n\t\tND_TCHECK2(*tptr, sizeof(struct in_addr));\n\t\tND_PRINT((ndo, \"\\n\\t      IPv4 interface address: %s\", ipaddr_string(ndo, tptr)));\n\t\ttptr += sizeof(struct in_addr);\n\t\ttmp -= sizeof(struct in_addr);\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_HOSTNAME:\n\t    ND_PRINT((ndo, \"\\n\\t      Hostname: \"));\n\t    if (fn_printzp(ndo, tptr, tmp, ndo->ndo_snapend))\n\t\tgoto trunctlv;\n\t    break;\n\n\tcase ISIS_TLV_SHARED_RISK_GROUP:\n\t    if (tmp < NODE_ID_LEN)\n\t        break;\n\t    ND_TCHECK2(*tptr, NODE_ID_LEN);\n\t    ND_PRINT((ndo, \"\\n\\t      IS Neighbor: %s\", isis_print_id(tptr, NODE_ID_LEN)));\n\t    tptr+=(NODE_ID_LEN);\n\t    tmp-=(NODE_ID_LEN);\n\n\t    if (tmp < 1)\n\t        break;\n\t    ND_TCHECK2(*tptr, 1);\n\t    ND_PRINT((ndo, \", Flags: [%s]\", ISIS_MASK_TLV_SHARED_RISK_GROUP(*tptr++) ? \"numbered\" : \"unnumbered\"));\n\t    tmp--;\n\n\t    if (tmp < sizeof(struct in_addr))\n\t        break;\n\t    ND_TCHECK2(*tptr, sizeof(struct in_addr));\n\t    ND_PRINT((ndo, \"\\n\\t      IPv4 interface address: %s\", ipaddr_string(ndo, tptr)));\n\t    tptr+=sizeof(struct in_addr);\n\t    tmp-=sizeof(struct in_addr);\n\n\t    if (tmp < sizeof(struct in_addr))\n\t        break;\n\t    ND_TCHECK2(*tptr, sizeof(struct in_addr));\n\t    ND_PRINT((ndo, \"\\n\\t      IPv4 neighbor address: %s\", ipaddr_string(ndo, tptr)));\n\t    tptr+=sizeof(struct in_addr);\n\t    tmp-=sizeof(struct in_addr);\n\n\t    while (tmp>=4) {\n                ND_TCHECK2(*tptr, 4);\n                ND_PRINT((ndo, \"\\n\\t      Link-ID: 0x%08x\", EXTRACT_32BITS(tptr)));\n                tptr+=4;\n                tmp-=4;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_LSP:\n\t    tlv_lsp = (const struct isis_tlv_lsp *)tptr;\n\t    while(tmp>=sizeof(struct isis_tlv_lsp)) {\n\t\tND_TCHECK((tlv_lsp->lsp_id)[LSP_ID_LEN-1]);\n\t\tND_PRINT((ndo, \"\\n\\t      lsp-id: %s\",\n                       isis_print_id(tlv_lsp->lsp_id, LSP_ID_LEN)));\n\t\tND_TCHECK2(tlv_lsp->sequence_number, 4);\n\t\tND_PRINT((ndo, \", seq: 0x%08x\", EXTRACT_32BITS(tlv_lsp->sequence_number)));\n\t\tND_TCHECK2(tlv_lsp->remaining_lifetime, 2);\n\t\tND_PRINT((ndo, \", lifetime: %5ds\", EXTRACT_16BITS(tlv_lsp->remaining_lifetime)));\n\t\tND_TCHECK2(tlv_lsp->checksum, 2);\n\t\tND_PRINT((ndo, \", chksum: 0x%04x\", EXTRACT_16BITS(tlv_lsp->checksum)));\n\t\ttmp-=sizeof(struct isis_tlv_lsp);\n\t\ttlv_lsp++;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_CHECKSUM:\n\t    if (tmp < ISIS_TLV_CHECKSUM_MINLEN)\n\t        break;\n\t    ND_TCHECK2(*tptr, ISIS_TLV_CHECKSUM_MINLEN);\n\t    ND_PRINT((ndo, \"\\n\\t      checksum: 0x%04x \", EXTRACT_16BITS(tptr)));\n            /* do not attempt to verify the checksum if it is zero\n             * most likely a HMAC-MD5 TLV is also present and\n             * to avoid conflicts the checksum TLV is zeroed.\n             * see rfc3358 for details\n             */\n            osi_print_cksum(ndo, optr, EXTRACT_16BITS(tptr), tptr-optr,\n                length);\n\t    break;\n\n\tcase ISIS_TLV_POI:\n\t    if (tlv_len >= SYSTEM_ID_LEN + 1) {\n\t\tND_TCHECK2(*tptr, SYSTEM_ID_LEN + 1);\n\t\tND_PRINT((ndo, \"\\n\\t      Purge Originator System-ID: %s\",\n\t\t       isis_print_id(tptr + 1, SYSTEM_ID_LEN)));\n\t    }\n\n\t    if (tlv_len == 2 * SYSTEM_ID_LEN + 1) {\n\t\tND_TCHECK2(*tptr, 2 * SYSTEM_ID_LEN + 1);\n\t\tND_PRINT((ndo, \"\\n\\t      Received from System-ID: %s\",\n\t\t       isis_print_id(tptr + SYSTEM_ID_LEN + 1, SYSTEM_ID_LEN)));\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_MT_SUPPORTED:\n            if (tmp < ISIS_TLV_MT_SUPPORTED_MINLEN)\n                break;\n\t    while (tmp>1) {\n\t\t/* length can only be a multiple of 2, otherwise there is\n\t\t   something broken -> so decode down until length is 1 */\n\t\tif (tmp!=1) {\n                    mt_len = isis_print_mtid(ndo, tptr, \"\\n\\t      \");\n                    if (mt_len == 0) /* did something go wrong ? */\n                        goto trunctlv;\n                    tptr+=mt_len;\n                    tmp-=mt_len;\n\t\t} else {\n\t\t    ND_PRINT((ndo, \"\\n\\t      invalid MT-ID\"));\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_RESTART_SIGNALING:\n            /* first attempt to decode the flags */\n            if (tmp < ISIS_TLV_RESTART_SIGNALING_FLAGLEN)\n                break;\n            ND_TCHECK2(*tptr, ISIS_TLV_RESTART_SIGNALING_FLAGLEN);\n            ND_PRINT((ndo, \"\\n\\t      Flags [%s]\",\n                   bittok2str(isis_restart_flag_values, \"none\", *tptr)));\n            tptr+=ISIS_TLV_RESTART_SIGNALING_FLAGLEN;\n            tmp-=ISIS_TLV_RESTART_SIGNALING_FLAGLEN;\n\n            /* is there anything other than the flags field? */\n            if (tmp == 0)\n                break;\n\n            if (tmp < ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN)\n                break;\n            ND_TCHECK2(*tptr, ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN);\n\n            ND_PRINT((ndo, \", Remaining holding time %us\", EXTRACT_16BITS(tptr)));\n            tptr+=ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN;\n            tmp-=ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN;\n\n            /* is there an additional sysid field present ?*/\n            if (tmp == SYSTEM_ID_LEN) {\n                    ND_TCHECK2(*tptr, SYSTEM_ID_LEN);\n                    ND_PRINT((ndo, \", for %s\", isis_print_id(tptr,SYSTEM_ID_LEN)));\n            }\n\t    break;\n\n        case ISIS_TLV_IDRP_INFO:\n\t    if (tmp < ISIS_TLV_IDRP_INFO_MINLEN)\n\t        break;\n            ND_TCHECK2(*tptr, ISIS_TLV_IDRP_INFO_MINLEN);\n            ND_PRINT((ndo, \"\\n\\t      Inter-Domain Information Type: %s\",\n                   tok2str(isis_subtlv_idrp_values,\n                           \"Unknown (0x%02x)\",\n                           *tptr)));\n            switch (*tptr++) {\n            case ISIS_SUBTLV_IDRP_ASN:\n                ND_TCHECK2(*tptr, 2); /* fetch AS number */\n                ND_PRINT((ndo, \"AS Number: %u\", EXTRACT_16BITS(tptr)));\n                break;\n            case ISIS_SUBTLV_IDRP_LOCAL:\n            case ISIS_SUBTLV_IDRP_RES:\n            default:\n                if (!print_unknown_data(ndo, tptr, \"\\n\\t      \", tlv_len - 1))\n                    return(0);\n                break;\n            }\n            break;\n\n        case ISIS_TLV_LSP_BUFFERSIZE:\n\t    if (tmp < ISIS_TLV_LSP_BUFFERSIZE_MINLEN)\n\t        break;\n            ND_TCHECK2(*tptr, ISIS_TLV_LSP_BUFFERSIZE_MINLEN);\n            ND_PRINT((ndo, \"\\n\\t      LSP Buffersize: %u\", EXTRACT_16BITS(tptr)));\n            break;\n\n        case ISIS_TLV_PART_DIS:\n            while (tmp >= SYSTEM_ID_LEN) {\n                ND_TCHECK2(*tptr, SYSTEM_ID_LEN);\n                ND_PRINT((ndo, \"\\n\\t      %s\", isis_print_id(tptr, SYSTEM_ID_LEN)));\n                tptr+=SYSTEM_ID_LEN;\n                tmp-=SYSTEM_ID_LEN;\n            }\n            break;\n\n        case ISIS_TLV_PREFIX_NEIGH:\n\t    if (tmp < sizeof(struct isis_metric_block))\n\t        break;\n            ND_TCHECK2(*tptr, sizeof(struct isis_metric_block));\n            ND_PRINT((ndo, \"\\n\\t      Metric Block\"));\n            isis_print_metric_block(ndo, (const struct isis_metric_block *)tptr);\n            tptr+=sizeof(struct isis_metric_block);\n            tmp-=sizeof(struct isis_metric_block);\n\n            while(tmp>0) {\n                ND_TCHECK2(*tptr, 1);\n                prefix_len=*tptr++; /* read out prefix length in semioctets*/\n                if (prefix_len < 2) {\n                    ND_PRINT((ndo, \"\\n\\t\\tAddress: prefix length %u < 2\", prefix_len));\n                    break;\n                }\n                tmp--;\n                if (tmp < prefix_len/2)\n                    break;\n                ND_TCHECK2(*tptr, prefix_len / 2);\n                ND_PRINT((ndo, \"\\n\\t\\tAddress: %s/%u\",\n                       isonsap_string(ndo, tptr, prefix_len / 2), prefix_len * 4));\n                tptr+=prefix_len/2;\n                tmp-=prefix_len/2;\n            }\n            break;\n\n        case ISIS_TLV_IIH_SEQNR:\n\t    if (tmp < ISIS_TLV_IIH_SEQNR_MINLEN)\n\t        break;\n            ND_TCHECK2(*tptr, ISIS_TLV_IIH_SEQNR_MINLEN); /* check if four bytes are on the wire */\n            ND_PRINT((ndo, \"\\n\\t      Sequence number: %u\", EXTRACT_32BITS(tptr)));\n            break;\n\n        case ISIS_TLV_VENDOR_PRIVATE:\n\t    if (tmp < ISIS_TLV_VENDOR_PRIVATE_MINLEN)\n\t        break;\n            ND_TCHECK2(*tptr, ISIS_TLV_VENDOR_PRIVATE_MINLEN); /* check if enough byte for a full oui */\n            vendor_id = EXTRACT_24BITS(tptr);\n            ND_PRINT((ndo, \"\\n\\t      Vendor: %s (%u)\",\n                   tok2str(oui_values, \"Unknown\", vendor_id),\n                   vendor_id));\n            tptr+=3;\n            tmp-=3;\n            if (tmp > 0) /* hexdump the rest */\n                if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t\", tmp))\n                    return(0);\n            break;\n            /*\n             * FIXME those are the defined TLVs that lack a decoder\n             * you are welcome to contribute code ;-)\n             */\n\n        case ISIS_TLV_DECNET_PHASE4:\n        case ISIS_TLV_LUCENT_PRIVATE:\n        case ISIS_TLV_IPAUTH:\n        case ISIS_TLV_NORTEL_PRIVATE1:\n        case ISIS_TLV_NORTEL_PRIVATE2:\n\n\tdefault:\n\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\tif (!print_unknown_data(ndo, pptr, \"\\n\\t\\t\", tlv_len))\n\t\t\t\treturn(0);\n\t\t}\n\t\tbreak;\n\t}\n        /* do we want to see an additionally hexdump ? */\n\tif (ndo->ndo_vflag> 1) {\n\t\tif (!print_unknown_data(ndo, pptr, \"\\n\\t      \", tlv_len))\n\t\t\treturn(0);\n\t}\n\n\tpptr += tlv_len;\n\tpacket_len -= tlv_len;\n    }\n\n    if (packet_len != 0) {\n\tND_PRINT((ndo, \"\\n\\t      %u straggler bytes\", packet_len));\n    }\n    return (1);\n\n trunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n    return (1);\n\n trunctlv:\n    ND_PRINT((ndo, \"\\n\\t\\t\"));\n    ND_PRINT((ndo, \"%s\", tstr));\n    return(1);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\tND_PRINT((ndo, \"\\n\\t      Area address (length: %u): %s\",\n",
        "src_path": "3b32029db354cbc875127869d9b12a9addc75b50___print-isoclns.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/3b32029db354cbc875127869d9b12a9addc75b50",
        "commit_msg": "CVE-2017-12999/IS-IS: Add a missing length check.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd tests using the capture files supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -476,6 +476,8 @@ isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n telnet-iac-check-oobr\ttelnet-iac-check-oobr.pcap\ttelnet-iac-check-oobr.out\t-vvv -e\n resp_4_infiniteloop\tresp_4_infiniteloop.pcap\tresp_4_infiniteloop.out\t-vvv -e\n dns_fwdptr\t\tdns_fwdptr.pcap\t\t\tdns_fwdptr.out\t\t-vvv -e\n+isis-areaaddr-oobr-1\tisis-areaaddr-oobr-1.pcap\tisis-areaaddr-oobr-1.out\t\t-vvv -e\n+isis-areaaddr-oobr-2\tisis-areaaddr-oobr-2.pcap\tisis-areaaddr-oobr-2.out\t\t-vvv -e\n \n # RTP tests\n # fuzzed pcap"
            }
        ],
        "error_msg": "    isis-areaaddr-oobr-1               : TEST FAILED(exit 256)\n    isis-areaaddr-oobr-2               : TEST FAILED(exit 256)\n"
    },
    "42073d54c53a496be40ae84152bbfe2c923ac7bc___print-juniper.c": {
        "prefix": "static int\njuniper_parse_header(netdissect_options *ndo,\n                     const u_char *p, const struct pcap_pkthdr *h, struct juniper_l2info_t *l2info)\n{\n    const struct juniper_cookie_table_t *lp = juniper_cookie_table;\n    u_int idx, jnx_ext_len, jnx_header_len = 0;\n    uint8_t tlv_type,tlv_len;\n    uint32_t control_word;\n    int tlv_value;\n    const u_char *tptr;\n\n\n    l2info->header_len = 0;\n    l2info->cookie_len = 0;\n    l2info->proto = 0;\n\n\n    l2info->length = h->len;\n    l2info->caplen = h->caplen;\n    ND_TCHECK2(p[0], 4);\n    l2info->flags = p[3];\n    l2info->direction = p[3]&JUNIPER_BPF_PKT_IN;\n\n    if (EXTRACT_24BITS(p) != JUNIPER_MGC_NUMBER) { /* magic number found ? */\n        ND_PRINT((ndo, \"no magic-number found!\"));\n        return 0;\n    }\n\n    if (ndo->ndo_eflag) /* print direction */\n        ND_PRINT((ndo, \"%3s \", tok2str(juniper_direction_values, \"---\", l2info->direction)));\n\n    /* magic number + flags */\n    jnx_header_len = 4;\n\n    if (ndo->ndo_vflag > 1)\n        ND_PRINT((ndo, \"\\n\\tJuniper PCAP Flags [%s]\",\n               bittok2str(jnx_flag_values, \"none\", l2info->flags)));\n\n    /* extensions present ?  - calculate how much bytes to skip */\n    if ((l2info->flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) {\n\n        tptr = p+jnx_header_len;\n\n        /* ok to read extension length ? */\n        ND_TCHECK2(tptr[0], 2);\n        jnx_ext_len = EXTRACT_16BITS(tptr);\n        jnx_header_len += 2;\n        tptr +=2;\n\n        /* nail up the total length -\n         * just in case something goes wrong\n         * with TLV parsing */\n        jnx_header_len += jnx_ext_len;\n\n        if (ndo->ndo_vflag > 1)\n            ND_PRINT((ndo, \", PCAP Extension(s) total length %u\", jnx_ext_len));\n\n        ND_TCHECK2(tptr[0], jnx_ext_len);\n        while (jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD) {\n            tlv_type = *(tptr++);\n            tlv_len = *(tptr++);\n            tlv_value = 0;\n\n            /* sanity checks */\n            if (tlv_type == 0 || tlv_len == 0)\n                break;\n            if (tlv_len+JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len)\n                goto trunc;\n\n            if (ndo->ndo_vflag > 1)\n                ND_PRINT((ndo, \"\\n\\t  %s Extension TLV #%u, length %u, value \",\n                       tok2str(jnx_ext_tlv_values,\"Unknown\",tlv_type),\n                       tlv_type,\n                       tlv_len));\n\n            tlv_value = juniper_read_tlv_value(tptr, tlv_type, tlv_len);\n            switch (tlv_type) {\n            case JUNIPER_EXT_TLV_IFD_NAME:\n                /* FIXME */\n                break;\n            case JUNIPER_EXT_TLV_IFD_MEDIATYPE:\n            case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%s (%u)\",\n                               tok2str(juniper_ifmt_values, \"Unknown\", tlv_value),\n                               tlv_value));\n                }\n                break;\n            case JUNIPER_EXT_TLV_IFL_ENCAPS:\n            case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%s (%u)\",\n                               tok2str(juniper_ifle_values, \"Unknown\", tlv_value),\n                               tlv_value));\n                }\n                break;\n            case JUNIPER_EXT_TLV_IFL_IDX: /* fall through */\n            case JUNIPER_EXT_TLV_IFL_UNIT:\n            case JUNIPER_EXT_TLV_IFD_IDX:\n            default:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%u\", tlv_value));\n                }\n                break;\n            }\n\n            tptr+=tlv_len;\n            jnx_ext_len -= tlv_len+JUNIPER_EXT_TLV_OVERHEAD;\n        }\n\n        if (ndo->ndo_vflag > 1)\n            ND_PRINT((ndo, \"\\n\\t-----original packet-----\\n\\t\"));\n    }\n\n    if ((l2info->flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) {\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"no-L2-hdr, \"));\n\n        /* there is no link-layer present -\n         * perform the v4/v6 heuristics\n         * to figure out what it is\n         */\n        ND_TCHECK2(p[jnx_header_len + 4], 1);\n        if (ip_heuristic_guess(ndo, p + jnx_header_len + 4,\n                               l2info->length - (jnx_header_len + 4)) == 0)\n            ND_PRINT((ndo, \"no IP-hdr found!\"));\n\n        l2info->header_len=jnx_header_len+4;\n        return 0; /* stop parsing the output further */\n\n    }\n    l2info->header_len = jnx_header_len;\n    p+=l2info->header_len;\n    l2info->length -= l2info->header_len;\n    l2info->caplen -= l2info->header_len;\n\n    /* search through the cookie table and copy values matching for our PIC type */\n    ND_TCHECK(p[0]);\n    while (lp->s != NULL) {\n        if (lp->pictype == l2info->pictype) {\n\n            l2info->cookie_len += lp->cookie_len;\n\n            switch (p[0]) {\n            case LS_COOKIE_ID:\n                l2info->cookie_type = LS_COOKIE_ID;\n                l2info->cookie_len += 2;\n                break;\n            case AS_COOKIE_ID:\n                l2info->cookie_type = AS_COOKIE_ID;\n                l2info->cookie_len = 8;\n                break;\n\n            default:\n                l2info->bundle = l2info->cookie[0];\n                break;\n            }\n\n\n#ifdef DLT_JUNIPER_MFR\n            /* MFR child links don't carry cookies */\n            if (l2info->pictype == DLT_JUNIPER_MFR &&\n                (p[0] & MFR_BE_MASK) == MFR_BE_MASK) {\n                l2info->cookie_len = 0;\n            }\n#endif\n\n            l2info->header_len += l2info->cookie_len;\n            l2info->length -= l2info->cookie_len;\n            l2info->caplen -= l2info->cookie_len;\n\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"%s-PIC, cookie-len %u\",\n                       lp->s,\n                       l2info->cookie_len));\n\n            if (l2info->cookie_len > 0) {\n                ND_TCHECK2(p[0], l2info->cookie_len);\n                if (ndo->ndo_eflag)\n                    ND_PRINT((ndo, \", cookie 0x\"));\n                for (idx = 0; idx < l2info->cookie_len; idx++) {\n                    l2info->cookie[idx] = p[idx]; /* copy cookie data */\n                    if (ndo->ndo_eflag) ND_PRINT((ndo, \"%02x\", p[idx]));\n                }\n            }\n\n            if (ndo->ndo_eflag) ND_PRINT((ndo, \": \")); /* print demarc b/w L2/L3*/\n\n\n",
        "suffix": "            break;\n        }\n        ++lp;\n    }\n    p+=l2info->cookie_len;\n\n    /* DLT_ specific parsing */\n    switch(l2info->pictype) {\n#ifdef DLT_JUNIPER_MLPPP\n    case DLT_JUNIPER_MLPPP:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            l2info->bundle = l2info->cookie[1];\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_MLFR\n    case DLT_JUNIPER_MLFR:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            ND_TCHECK2(p[0], 2);\n            l2info->bundle = l2info->cookie[1];\n            l2info->proto = EXTRACT_16BITS(p);\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_MFR\n    case DLT_JUNIPER_MFR:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            ND_TCHECK2(p[0], 2);\n            l2info->bundle = l2info->cookie[1];\n            l2info->proto = EXTRACT_16BITS(p);\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_ATM2\n    case DLT_JUNIPER_ATM2:\n        ND_TCHECK2(p[0], 4);\n        /* ATM cell relay control word present ? */\n        if (l2info->cookie[7] & ATM2_PKT_TYPE_MASK) {\n            control_word = EXTRACT_32BITS(p);\n            /* some control word heuristics */\n            switch(control_word) {\n            case 0: /* zero control word */\n            case 0x08000000: /* < JUNOS 7.4 control-word */\n            case 0x08380000: /* cntl word plus cell length (56) >= JUNOS 7.4*/\n                l2info->header_len += 4;\n                break;\n            default:\n                break;\n            }\n\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"control-word 0x%08x \", control_word));\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_GGSN\n    case DLT_JUNIPER_GGSN:\n        break;\n#endif\n#ifdef DLT_JUNIPER_ATM1\n    case DLT_JUNIPER_ATM1:\n        break;\n#endif\n#ifdef DLT_JUNIPER_PPP\n    case DLT_JUNIPER_PPP:\n        break;\n#endif\n#ifdef DLT_JUNIPER_CHDLC\n    case DLT_JUNIPER_CHDLC:\n        break;\n#endif\n#ifdef DLT_JUNIPER_ETHER\n    case DLT_JUNIPER_ETHER:\n        break;\n#endif\n#ifdef DLT_JUNIPER_FRELAY\n    case DLT_JUNIPER_FRELAY:\n        break;\n#endif\n\n    default:\n        ND_PRINT((ndo, \"Unknown Juniper DLT_ type %u: \", l2info->pictype));\n        break;\n    }\n\n    if (ndo->ndo_eflag > 1)\n        ND_PRINT((ndo, \"hlen %u, proto 0x%04x, \", l2info->header_len, l2info->proto));\n\n    return 1; /* everything went ok so far. continue parsing */\n trunc:\n    ND_PRINT((ndo, \"[|juniper_hdr], length %u\", h->len));\n    return 0;\n}\n",
        "start": 1178,
        "end": 1499,
        "buggy": "static int\njuniper_parse_header(netdissect_options *ndo,\n                     const u_char *p, const struct pcap_pkthdr *h, struct juniper_l2info_t *l2info)\n{\n    const struct juniper_cookie_table_t *lp = juniper_cookie_table;\n    u_int idx, jnx_ext_len, jnx_header_len = 0;\n    uint8_t tlv_type,tlv_len;\n    uint32_t control_word;\n    int tlv_value;\n    const u_char *tptr;\n\n\n    l2info->header_len = 0;\n    l2info->cookie_len = 0;\n    l2info->proto = 0;\n\n\n    l2info->length = h->len;\n    l2info->caplen = h->caplen;\n    ND_TCHECK2(p[0], 4);\n    l2info->flags = p[3];\n    l2info->direction = p[3]&JUNIPER_BPF_PKT_IN;\n\n    if (EXTRACT_24BITS(p) != JUNIPER_MGC_NUMBER) { /* magic number found ? */\n        ND_PRINT((ndo, \"no magic-number found!\"));\n        return 0;\n    }\n\n    if (ndo->ndo_eflag) /* print direction */\n        ND_PRINT((ndo, \"%3s \", tok2str(juniper_direction_values, \"---\", l2info->direction)));\n\n    /* magic number + flags */\n    jnx_header_len = 4;\n\n    if (ndo->ndo_vflag > 1)\n        ND_PRINT((ndo, \"\\n\\tJuniper PCAP Flags [%s]\",\n               bittok2str(jnx_flag_values, \"none\", l2info->flags)));\n\n    /* extensions present ?  - calculate how much bytes to skip */\n    if ((l2info->flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) {\n\n        tptr = p+jnx_header_len;\n\n        /* ok to read extension length ? */\n        ND_TCHECK2(tptr[0], 2);\n        jnx_ext_len = EXTRACT_16BITS(tptr);\n        jnx_header_len += 2;\n        tptr +=2;\n\n        /* nail up the total length -\n         * just in case something goes wrong\n         * with TLV parsing */\n        jnx_header_len += jnx_ext_len;\n\n        if (ndo->ndo_vflag > 1)\n            ND_PRINT((ndo, \", PCAP Extension(s) total length %u\", jnx_ext_len));\n\n        ND_TCHECK2(tptr[0], jnx_ext_len);\n        while (jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD) {\n            tlv_type = *(tptr++);\n            tlv_len = *(tptr++);\n            tlv_value = 0;\n\n            /* sanity checks */\n            if (tlv_type == 0 || tlv_len == 0)\n                break;\n            if (tlv_len+JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len)\n                goto trunc;\n\n            if (ndo->ndo_vflag > 1)\n                ND_PRINT((ndo, \"\\n\\t  %s Extension TLV #%u, length %u, value \",\n                       tok2str(jnx_ext_tlv_values,\"Unknown\",tlv_type),\n                       tlv_type,\n                       tlv_len));\n\n            tlv_value = juniper_read_tlv_value(tptr, tlv_type, tlv_len);\n            switch (tlv_type) {\n            case JUNIPER_EXT_TLV_IFD_NAME:\n                /* FIXME */\n                break;\n            case JUNIPER_EXT_TLV_IFD_MEDIATYPE:\n            case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%s (%u)\",\n                               tok2str(juniper_ifmt_values, \"Unknown\", tlv_value),\n                               tlv_value));\n                }\n                break;\n            case JUNIPER_EXT_TLV_IFL_ENCAPS:\n            case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%s (%u)\",\n                               tok2str(juniper_ifle_values, \"Unknown\", tlv_value),\n                               tlv_value));\n                }\n                break;\n            case JUNIPER_EXT_TLV_IFL_IDX: /* fall through */\n            case JUNIPER_EXT_TLV_IFL_UNIT:\n            case JUNIPER_EXT_TLV_IFD_IDX:\n            default:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%u\", tlv_value));\n                }\n                break;\n            }\n\n            tptr+=tlv_len;\n            jnx_ext_len -= tlv_len+JUNIPER_EXT_TLV_OVERHEAD;\n        }\n\n        if (ndo->ndo_vflag > 1)\n            ND_PRINT((ndo, \"\\n\\t-----original packet-----\\n\\t\"));\n    }\n\n    if ((l2info->flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) {\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"no-L2-hdr, \"));\n\n        /* there is no link-layer present -\n         * perform the v4/v6 heuristics\n         * to figure out what it is\n         */\n        ND_TCHECK2(p[jnx_header_len + 4], 1);\n        if (ip_heuristic_guess(ndo, p + jnx_header_len + 4,\n                               l2info->length - (jnx_header_len + 4)) == 0)\n            ND_PRINT((ndo, \"no IP-hdr found!\"));\n\n        l2info->header_len=jnx_header_len+4;\n        return 0; /* stop parsing the output further */\n\n    }\n    l2info->header_len = jnx_header_len;\n    p+=l2info->header_len;\n    l2info->length -= l2info->header_len;\n    l2info->caplen -= l2info->header_len;\n\n    /* search through the cookie table and copy values matching for our PIC type */\n    ND_TCHECK(p[0]);\n    while (lp->s != NULL) {\n        if (lp->pictype == l2info->pictype) {\n\n            l2info->cookie_len += lp->cookie_len;\n\n            switch (p[0]) {\n            case LS_COOKIE_ID:\n                l2info->cookie_type = LS_COOKIE_ID;\n                l2info->cookie_len += 2;\n                break;\n            case AS_COOKIE_ID:\n                l2info->cookie_type = AS_COOKIE_ID;\n                l2info->cookie_len = 8;\n                break;\n\n            default:\n                l2info->bundle = l2info->cookie[0];\n                break;\n            }\n\n\n#ifdef DLT_JUNIPER_MFR\n            /* MFR child links don't carry cookies */\n            if (l2info->pictype == DLT_JUNIPER_MFR &&\n                (p[0] & MFR_BE_MASK) == MFR_BE_MASK) {\n                l2info->cookie_len = 0;\n            }\n#endif\n\n            l2info->header_len += l2info->cookie_len;\n            l2info->length -= l2info->cookie_len;\n            l2info->caplen -= l2info->cookie_len;\n\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"%s-PIC, cookie-len %u\",\n                       lp->s,\n                       l2info->cookie_len));\n\n            if (l2info->cookie_len > 0) {\n                ND_TCHECK2(p[0], l2info->cookie_len);\n                if (ndo->ndo_eflag)\n                    ND_PRINT((ndo, \", cookie 0x\"));\n                for (idx = 0; idx < l2info->cookie_len; idx++) {\n                    l2info->cookie[idx] = p[idx]; /* copy cookie data */\n                    if (ndo->ndo_eflag) ND_PRINT((ndo, \"%02x\", p[idx]));\n                }\n            }\n\n            if (ndo->ndo_eflag) ND_PRINT((ndo, \": \")); /* print demarc b/w L2/L3*/\n\n\n            l2info->proto = EXTRACT_16BITS(p+l2info->cookie_len);\n            break;\n        }\n        ++lp;\n    }\n    p+=l2info->cookie_len;\n\n    /* DLT_ specific parsing */\n    switch(l2info->pictype) {\n#ifdef DLT_JUNIPER_MLPPP\n    case DLT_JUNIPER_MLPPP:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            l2info->bundle = l2info->cookie[1];\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_MLFR\n    case DLT_JUNIPER_MLFR:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            ND_TCHECK2(p[0], 2);\n            l2info->bundle = l2info->cookie[1];\n            l2info->proto = EXTRACT_16BITS(p);\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_MFR\n    case DLT_JUNIPER_MFR:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            ND_TCHECK2(p[0], 2);\n            l2info->bundle = l2info->cookie[1];\n            l2info->proto = EXTRACT_16BITS(p);\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_ATM2\n    case DLT_JUNIPER_ATM2:\n        ND_TCHECK2(p[0], 4);\n        /* ATM cell relay control word present ? */\n        if (l2info->cookie[7] & ATM2_PKT_TYPE_MASK) {\n            control_word = EXTRACT_32BITS(p);\n            /* some control word heuristics */\n            switch(control_word) {\n            case 0: /* zero control word */\n            case 0x08000000: /* < JUNOS 7.4 control-word */\n            case 0x08380000: /* cntl word plus cell length (56) >= JUNOS 7.4*/\n                l2info->header_len += 4;\n                break;\n            default:\n                break;\n            }\n\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"control-word 0x%08x \", control_word));\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_GGSN\n    case DLT_JUNIPER_GGSN:\n        break;\n#endif\n#ifdef DLT_JUNIPER_ATM1\n    case DLT_JUNIPER_ATM1:\n        break;\n#endif\n#ifdef DLT_JUNIPER_PPP\n    case DLT_JUNIPER_PPP:\n        break;\n#endif\n#ifdef DLT_JUNIPER_CHDLC\n    case DLT_JUNIPER_CHDLC:\n        break;\n#endif\n#ifdef DLT_JUNIPER_ETHER\n    case DLT_JUNIPER_ETHER:\n        break;\n#endif\n#ifdef DLT_JUNIPER_FRELAY\n    case DLT_JUNIPER_FRELAY:\n        break;\n#endif\n\n    default:\n        ND_PRINT((ndo, \"Unknown Juniper DLT_ type %u: \", l2info->pictype));\n        break;\n    }\n\n    if (ndo->ndo_eflag > 1)\n        ND_PRINT((ndo, \"hlen %u, proto 0x%04x, \", l2info->header_len, l2info->proto));\n\n    return 1; /* everything went ok so far. continue parsing */\n trunc:\n    ND_PRINT((ndo, \"[|juniper_hdr], length %u\", h->len));\n    return 0;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            l2info->proto = EXTRACT_16BITS(p+l2info->cookie_len);\n",
        "src_path": "42073d54c53a496be40ae84152bbfe2c923ac7bc___print-juniper.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/42073d54c53a496be40ae84152bbfe2c923ac7bc",
        "commit_msg": "CVE-2017-13004/Juniper: Add a bounds check.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd tests using the capture files supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -493,6 +493,8 @@ pimv2-oobr-4\t\tpimv2-oobr-4.pcap\t\tpimv2-oobr-4.out\t\t-vvv -e\n 802_15_4-data\t\t802_15_4-data.pcap\t\t802_15_4-data.out\t-vvv -e\n 802_15_4_beacon\t\t802_15_4_beacon.pcap\t\t802_15_4_beacon.out\t-vvv -e\n lmpv1_busyloop\t\tlmpv1_busyloop.pcap\t\tlmpv1_busyloop.out\t-vvv -e\n+juniper_atm1\t\tjuniper_atm1.pcap\t\tjuniper_atm1.out\t-vvv -e\n+juniper_es\t\tjuniper_es.pcap\t\t\tjuniper_es.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/juniper_atm1.out",
                "patch": "@@ -0,0 +1,2 @@\n+Out \n+\tJuniper PCAP Flags [none]ATM1-PIC, cookie-len 4, cookie 0x30303030: [|juniper_hdr], length 808464432"
            },
            {
                "fn": "tests/juniper_es.out",
                "patch": "@@ -0,0 +1,2 @@\n+Out \n+\tJuniper PCAP Flags [none]ES-PIC, cookie-len 0: [|juniper_hdr], length 808464432"
            }
        ],
        "error_msg": "    juniper_atm1                       : TEST FAILED(exit 256)\n    juniper_es                         : TEST FAILED(exit 256)\n"
    },
    "8509ef02eceb2bbb479cea10fe4a7ec6395f1a8b___print-icmp.c": {
        "prefix": "void\nicmp_print(netdissect_options *ndo, const u_char *bp, u_int plen, const u_char *bp2,\n           int fragmented)\n{\n\tchar *cp;\n\tconst struct icmp *dp;\n        const struct icmp_ext_t *ext_dp;\n\tconst struct ip *ip;\n\tconst char *str, *fmt;\n\tconst struct ip *oip;\n\tconst struct udphdr *ouh;\n        const uint8_t *obj_tptr;\n        uint32_t raw_label;\n        const u_char *snapend_save;\n\tconst struct icmp_mpls_ext_object_header_t *icmp_mpls_ext_object_header;\n\tu_int hlen, dport, mtu, obj_tlen, obj_class_num, obj_ctype;\n\tchar buf[MAXHOSTNAMELEN + 100];\n\tstruct cksum_vec vec[1];\n\n\tdp = (const struct icmp *)bp;\n        ext_dp = (const struct icmp_ext_t *)bp;\n\tip = (const struct ip *)bp2;\n\tstr = buf;\n\n\tND_TCHECK(dp->icmp_code);\n\tswitch (dp->icmp_type) {\n\n\tcase ICMP_ECHO:\n\tcase ICMP_ECHOREPLY:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf), \"echo %s, id %u, seq %u\",\n                               dp->icmp_type == ICMP_ECHO ?\n                               \"request\" : \"reply\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_UNREACH:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_UNREACH_PROTOCOL:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"%s protocol %d unreachable\",\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t\t    dp->icmp_ip.ip_p);\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_PORT:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\toip = &dp->icmp_ip;\n\t\t\thlen = IP_HL(oip) * 4;\n\t\t\touh = (const struct udphdr *)(((const u_char *)oip) + hlen);\n\t\t\tND_TCHECK(ouh->uh_dport);\n\t\t\tdport = EXTRACT_16BITS(&ouh->uh_dport);\n\t\t\tswitch (oip->ip_p) {\n\n\t\t\tcase IPPROTO_TCP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s tcp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\ttcpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tcase IPPROTO_UDP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s udp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\tudpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s protocol %d port %d unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\toip->ip_p, dport);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_NEEDFRAG:\n\t\t    {\n\t\t\tregister const struct mtu_discovery *mp;\n\t\t\tmp = (const struct mtu_discovery *)(const u_char *)&dp->icmp_void;\n\t\t\tmtu = EXTRACT_16BITS(&mp->nexthopmtu);\n\t\t\tif (mtu) {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag (mtu %d)\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst), mtu);\n\t\t\t} else {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\t}\n\t\t    }\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmt = tok2str(unreach2str, \"#%d %%s unreachable\",\n\t\t\t    dp->icmp_code);\n\t\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_REDIRECT:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tfmt = tok2str(type2str, \"redirect-#%d %%s to net %%s\",\n\t\t    dp->icmp_code);\n\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t    ipaddr_string(ndo, &dp->icmp_gwaddr));\n\t\tbreak;\n\n\tcase ICMP_ROUTERADVERT:\n\t    {\n\t\tregister const struct ih_rdiscovery *ihp;\n\t\tregister const struct id_rdiscovery *idp;\n\t\tu_int lifetime, num, size;\n\n\t\t(void)snprintf(buf, sizeof(buf), \"router advertisement\");\n\t\tcp = buf + strlen(buf);\n\n\t\tihp = (const struct ih_rdiscovery *)&dp->icmp_void;\n\t\tND_TCHECK(*ihp);\n\t\t(void)strncpy(cp, \" lifetime \", sizeof(buf) - (cp - buf));\n\t\tcp = buf + strlen(buf);\n\t\tlifetime = EXTRACT_16BITS(&ihp->ird_lifetime);\n\t\tif (lifetime < 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u\",\n\t\t\t    lifetime);\n\t\t} else if (lifetime < 60 * 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u:%02u\",\n\t\t\t    lifetime / 60, lifetime % 60);\n\t\t} else {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \"%u:%02u:%02u\",\n\t\t\t    lifetime / 3600,\n\t\t\t    (lifetime % 3600) / 60,\n\t\t\t    lifetime % 60);\n\t\t}\n\t\tcp = buf + strlen(buf);\n\n\t\tnum = ihp->ird_addrnum;\n\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" %d:\", num);\n\t\tcp = buf + strlen(buf);\n\n\t\tsize = ihp->ird_addrsiz;\n\t\tif (size != 2) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \" [size %d]\", size);\n\t\t\tbreak;\n\t\t}\n\t\tidp = (const struct id_rdiscovery *)&dp->icmp_data;\n\t\twhile (num-- > 0) {\n\t\t\tND_TCHECK(*idp);\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" {%s %u}\",\n\t\t\t    ipaddr_string(ndo, &idp->ird_addr),\n\t\t\t    EXTRACT_32BITS(&idp->ird_pref));\n\t\t\tcp = buf + strlen(buf);\n\t\t\t++idp;\n\t\t}\n\t    }\n\t\tbreak;\n\n\tcase ICMP_TIMXCEED:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_TIMXCEED_INTRANS:\n\t\t\tstr = \"time exceeded in-transit\";\n\t\t\tbreak;\n\n\t\tcase ICMP_TIMXCEED_REASS:\n\t\t\tstr = \"ip reassembly time exceeded\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"time exceeded-#%d\",\n\t\t\t    dp->icmp_code);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_PARAMPROB:\n\t\tif (dp->icmp_code)\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - code %d\", dp->icmp_code);\n\t\telse {\n\t\t\tND_TCHECK(dp->icmp_pptr);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - octet %d\", dp->icmp_pptr);\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_MASKREPLY:\n\t\tND_TCHECK(dp->icmp_mask);\n\t\t(void)snprintf(buf, sizeof(buf), \"address mask is 0x%08x\",\n\t\t    EXTRACT_32BITS(&dp->icmp_mask));\n\t\tbreak;\n\n\tcase ICMP_TSTAMP:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp query id %u seq %u\",\n\t\t    EXTRACT_16BITS(&dp->icmp_id),\n\t\t    EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_TSTAMPREPLY:\n\t\tND_TCHECK(dp->icmp_ttime);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp reply id %u seq %u: org %s\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq),\n                               icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_otime)));\n\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", recv %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_rtime)));\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", xmit %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_ttime)));\n                break;\n\n\tdefault:\n\t\tstr = tok2str(icmp2str, \"type-#%d\", dp->icmp_type);\n\t\tbreak;\n\t}\n\tND_PRINT((ndo, \"ICMP %s, length %u\", str, plen));\n\tif (ndo->ndo_vflag && !fragmented) { /* don't attempt checksumming if this is a frag */\n\t\tuint16_t sum, icmp_sum;\n\n\t\tif (ND_TTEST2(*bp, plen)) {\n\t\t\tvec[0].ptr = (const uint8_t *)(const void *)dp;\n\t\t\tvec[0].len = plen;\n\t\t\tsum = in_cksum(vec, 1);\n\t\t\tif (sum != 0) {\n\t\t\t\ticmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);\n\t\t\t\tND_PRINT((ndo, \" (wrong icmp cksum %x (->%x)!)\",\n\t\t\t\t\t     icmp_sum,\n\t\t\t\t\t     in_cksum_shouldbe(icmp_sum, sum)));\n\t\t\t}\n\t\t}\n\t}\n\n        /*\n         * print the remnants of the IP packet.\n         * save the snaplength as this may get overidden in the IP printer.\n         */\n\tif (ndo->ndo_vflag >= 1 && ICMP_ERRTYPE(dp->icmp_type)) {\n\t\tbp += 8;\n\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\tip = (const struct ip *)bp;\n                snapend_save = ndo->ndo_snapend;\n",
        "suffix": "                ndo->ndo_snapend = snapend_save;\n\t}\n\n        /*\n         * Attempt to decode the MPLS extensions only for some ICMP types.\n         */\n        if (ndo->ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE(dp->icmp_type)) {\n\n            ND_TCHECK(*ext_dp);\n\n            /*\n             * Check first if the mpls extension header shows a non-zero length.\n             * If the length field is not set then silently verify the checksum\n             * to check if an extension header is present. This is expedient,\n             * however not all implementations set the length field proper.\n             */\n            if (!ext_dp->icmp_length &&\n                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = plen - ICMP_EXTD_MINLEN;\n                if (in_cksum(vec, 1)) {\n                    return;\n                }\n            }\n\n            ND_PRINT((ndo, \"\\n\\tMPLS extension v%u\",\n                   ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res))));\n\n            /*\n             * Sanity checking of the header.\n             */\n            if (ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res)) !=\n                ICMP_MPLS_EXT_VERSION) {\n                ND_PRINT((ndo, \" packet not supported\"));\n                return;\n            }\n\n            hlen = plen - ICMP_EXTD_MINLEN;\n            if (ND_TTEST2(ext_dp->icmp_ext_version_res, hlen)) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = hlen;\n                ND_PRINT((ndo, \", checksum 0x%04x (%scorrect), length %u\",\n                       EXTRACT_16BITS(ext_dp->icmp_ext_checksum),\n                       in_cksum(vec, 1) ? \"in\" : \"\",\n                       hlen));\n            }\n\n            hlen -= 4; /* subtract common header size */\n            obj_tptr = (const uint8_t *)ext_dp->icmp_ext_data;\n\n            while (hlen > sizeof(struct icmp_mpls_ext_object_header_t)) {\n\n                icmp_mpls_ext_object_header = (const struct icmp_mpls_ext_object_header_t *)obj_tptr;\n                ND_TCHECK(*icmp_mpls_ext_object_header);\n                obj_tlen = EXTRACT_16BITS(icmp_mpls_ext_object_header->length);\n                obj_class_num = icmp_mpls_ext_object_header->class_num;\n                obj_ctype = icmp_mpls_ext_object_header->ctype;\n                obj_tptr += sizeof(struct icmp_mpls_ext_object_header_t);\n\n                ND_PRINT((ndo, \"\\n\\t  %s Object (%u), Class-Type: %u, length %u\",\n                       tok2str(icmp_mpls_ext_obj_values,\"unknown\",obj_class_num),\n                       obj_class_num,\n                       obj_ctype,\n                       obj_tlen));\n\n                hlen-=sizeof(struct icmp_mpls_ext_object_header_t); /* length field includes tlv header */\n\n                /* infinite loop protection */\n                if ((obj_class_num == 0) ||\n                    (obj_tlen < sizeof(struct icmp_mpls_ext_object_header_t))) {\n                    return;\n                }\n                obj_tlen-=sizeof(struct icmp_mpls_ext_object_header_t);\n\n                switch (obj_class_num) {\n                case 1:\n                    switch(obj_ctype) {\n                    case 1:\n                        ND_TCHECK2(*obj_tptr, 4);\n                        raw_label = EXTRACT_32BITS(obj_tptr);\n                        ND_PRINT((ndo, \"\\n\\t    label %u, exp %u\", MPLS_LABEL(raw_label), MPLS_EXP(raw_label)));\n                        if (MPLS_STACK(raw_label))\n                            ND_PRINT((ndo, \", [S]\"));\n                        ND_PRINT((ndo, \", ttl %u\", MPLS_TTL(raw_label)));\n                        break;\n                    default:\n                        print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    }\n                    break;\n\n               /*\n                *  FIXME those are the defined objects that lack a decoder\n                *  you are welcome to contribute code ;-)\n                */\n                case 2:\n                default:\n                    print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    break;\n                }\n                if (hlen < obj_tlen)\n                    break;\n                hlen -= obj_tlen;\n                obj_tptr += obj_tlen;\n            }\n        }\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"[|icmp]\"));\n}\n",
        "start": 329,
        "end": 694,
        "buggy": "void\nicmp_print(netdissect_options *ndo, const u_char *bp, u_int plen, const u_char *bp2,\n           int fragmented)\n{\n\tchar *cp;\n\tconst struct icmp *dp;\n        const struct icmp_ext_t *ext_dp;\n\tconst struct ip *ip;\n\tconst char *str, *fmt;\n\tconst struct ip *oip;\n\tconst struct udphdr *ouh;\n        const uint8_t *obj_tptr;\n        uint32_t raw_label;\n        const u_char *snapend_save;\n\tconst struct icmp_mpls_ext_object_header_t *icmp_mpls_ext_object_header;\n\tu_int hlen, dport, mtu, obj_tlen, obj_class_num, obj_ctype;\n\tchar buf[MAXHOSTNAMELEN + 100];\n\tstruct cksum_vec vec[1];\n\n\tdp = (const struct icmp *)bp;\n        ext_dp = (const struct icmp_ext_t *)bp;\n\tip = (const struct ip *)bp2;\n\tstr = buf;\n\n\tND_TCHECK(dp->icmp_code);\n\tswitch (dp->icmp_type) {\n\n\tcase ICMP_ECHO:\n\tcase ICMP_ECHOREPLY:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf), \"echo %s, id %u, seq %u\",\n                               dp->icmp_type == ICMP_ECHO ?\n                               \"request\" : \"reply\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_UNREACH:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_UNREACH_PROTOCOL:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"%s protocol %d unreachable\",\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t\t    dp->icmp_ip.ip_p);\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_PORT:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\toip = &dp->icmp_ip;\n\t\t\thlen = IP_HL(oip) * 4;\n\t\t\touh = (const struct udphdr *)(((const u_char *)oip) + hlen);\n\t\t\tND_TCHECK(ouh->uh_dport);\n\t\t\tdport = EXTRACT_16BITS(&ouh->uh_dport);\n\t\t\tswitch (oip->ip_p) {\n\n\t\t\tcase IPPROTO_TCP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s tcp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\ttcpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tcase IPPROTO_UDP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s udp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\tudpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s protocol %d port %d unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\toip->ip_p, dport);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_NEEDFRAG:\n\t\t    {\n\t\t\tregister const struct mtu_discovery *mp;\n\t\t\tmp = (const struct mtu_discovery *)(const u_char *)&dp->icmp_void;\n\t\t\tmtu = EXTRACT_16BITS(&mp->nexthopmtu);\n\t\t\tif (mtu) {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag (mtu %d)\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst), mtu);\n\t\t\t} else {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\t}\n\t\t    }\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmt = tok2str(unreach2str, \"#%d %%s unreachable\",\n\t\t\t    dp->icmp_code);\n\t\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_REDIRECT:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tfmt = tok2str(type2str, \"redirect-#%d %%s to net %%s\",\n\t\t    dp->icmp_code);\n\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t    ipaddr_string(ndo, &dp->icmp_gwaddr));\n\t\tbreak;\n\n\tcase ICMP_ROUTERADVERT:\n\t    {\n\t\tregister const struct ih_rdiscovery *ihp;\n\t\tregister const struct id_rdiscovery *idp;\n\t\tu_int lifetime, num, size;\n\n\t\t(void)snprintf(buf, sizeof(buf), \"router advertisement\");\n\t\tcp = buf + strlen(buf);\n\n\t\tihp = (const struct ih_rdiscovery *)&dp->icmp_void;\n\t\tND_TCHECK(*ihp);\n\t\t(void)strncpy(cp, \" lifetime \", sizeof(buf) - (cp - buf));\n\t\tcp = buf + strlen(buf);\n\t\tlifetime = EXTRACT_16BITS(&ihp->ird_lifetime);\n\t\tif (lifetime < 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u\",\n\t\t\t    lifetime);\n\t\t} else if (lifetime < 60 * 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u:%02u\",\n\t\t\t    lifetime / 60, lifetime % 60);\n\t\t} else {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \"%u:%02u:%02u\",\n\t\t\t    lifetime / 3600,\n\t\t\t    (lifetime % 3600) / 60,\n\t\t\t    lifetime % 60);\n\t\t}\n\t\tcp = buf + strlen(buf);\n\n\t\tnum = ihp->ird_addrnum;\n\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" %d:\", num);\n\t\tcp = buf + strlen(buf);\n\n\t\tsize = ihp->ird_addrsiz;\n\t\tif (size != 2) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \" [size %d]\", size);\n\t\t\tbreak;\n\t\t}\n\t\tidp = (const struct id_rdiscovery *)&dp->icmp_data;\n\t\twhile (num-- > 0) {\n\t\t\tND_TCHECK(*idp);\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" {%s %u}\",\n\t\t\t    ipaddr_string(ndo, &idp->ird_addr),\n\t\t\t    EXTRACT_32BITS(&idp->ird_pref));\n\t\t\tcp = buf + strlen(buf);\n\t\t\t++idp;\n\t\t}\n\t    }\n\t\tbreak;\n\n\tcase ICMP_TIMXCEED:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_TIMXCEED_INTRANS:\n\t\t\tstr = \"time exceeded in-transit\";\n\t\t\tbreak;\n\n\t\tcase ICMP_TIMXCEED_REASS:\n\t\t\tstr = \"ip reassembly time exceeded\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"time exceeded-#%d\",\n\t\t\t    dp->icmp_code);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_PARAMPROB:\n\t\tif (dp->icmp_code)\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - code %d\", dp->icmp_code);\n\t\telse {\n\t\t\tND_TCHECK(dp->icmp_pptr);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - octet %d\", dp->icmp_pptr);\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_MASKREPLY:\n\t\tND_TCHECK(dp->icmp_mask);\n\t\t(void)snprintf(buf, sizeof(buf), \"address mask is 0x%08x\",\n\t\t    EXTRACT_32BITS(&dp->icmp_mask));\n\t\tbreak;\n\n\tcase ICMP_TSTAMP:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp query id %u seq %u\",\n\t\t    EXTRACT_16BITS(&dp->icmp_id),\n\t\t    EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_TSTAMPREPLY:\n\t\tND_TCHECK(dp->icmp_ttime);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp reply id %u seq %u: org %s\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq),\n                               icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_otime)));\n\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", recv %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_rtime)));\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", xmit %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_ttime)));\n                break;\n\n\tdefault:\n\t\tstr = tok2str(icmp2str, \"type-#%d\", dp->icmp_type);\n\t\tbreak;\n\t}\n\tND_PRINT((ndo, \"ICMP %s, length %u\", str, plen));\n\tif (ndo->ndo_vflag && !fragmented) { /* don't attempt checksumming if this is a frag */\n\t\tuint16_t sum, icmp_sum;\n\n\t\tif (ND_TTEST2(*bp, plen)) {\n\t\t\tvec[0].ptr = (const uint8_t *)(const void *)dp;\n\t\t\tvec[0].len = plen;\n\t\t\tsum = in_cksum(vec, 1);\n\t\t\tif (sum != 0) {\n\t\t\t\ticmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);\n\t\t\t\tND_PRINT((ndo, \" (wrong icmp cksum %x (->%x)!)\",\n\t\t\t\t\t     icmp_sum,\n\t\t\t\t\t     in_cksum_shouldbe(icmp_sum, sum)));\n\t\t\t}\n\t\t}\n\t}\n\n        /*\n         * print the remnants of the IP packet.\n         * save the snaplength as this may get overidden in the IP printer.\n         */\n\tif (ndo->ndo_vflag >= 1 && ICMP_ERRTYPE(dp->icmp_type)) {\n\t\tbp += 8;\n\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\tip = (const struct ip *)bp;\n                snapend_save = ndo->ndo_snapend;\n\t\tip_print(ndo, bp, EXTRACT_16BITS(&ip->ip_len));\n                ndo->ndo_snapend = snapend_save;\n\t}\n\n        /*\n         * Attempt to decode the MPLS extensions only for some ICMP types.\n         */\n        if (ndo->ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE(dp->icmp_type)) {\n\n            ND_TCHECK(*ext_dp);\n\n            /*\n             * Check first if the mpls extension header shows a non-zero length.\n             * If the length field is not set then silently verify the checksum\n             * to check if an extension header is present. This is expedient,\n             * however not all implementations set the length field proper.\n             */\n            if (!ext_dp->icmp_length &&\n                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = plen - ICMP_EXTD_MINLEN;\n                if (in_cksum(vec, 1)) {\n                    return;\n                }\n            }\n\n            ND_PRINT((ndo, \"\\n\\tMPLS extension v%u\",\n                   ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res))));\n\n            /*\n             * Sanity checking of the header.\n             */\n            if (ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res)) !=\n                ICMP_MPLS_EXT_VERSION) {\n                ND_PRINT((ndo, \" packet not supported\"));\n                return;\n            }\n\n            hlen = plen - ICMP_EXTD_MINLEN;\n            if (ND_TTEST2(ext_dp->icmp_ext_version_res, hlen)) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = hlen;\n                ND_PRINT((ndo, \", checksum 0x%04x (%scorrect), length %u\",\n                       EXTRACT_16BITS(ext_dp->icmp_ext_checksum),\n                       in_cksum(vec, 1) ? \"in\" : \"\",\n                       hlen));\n            }\n\n            hlen -= 4; /* subtract common header size */\n            obj_tptr = (const uint8_t *)ext_dp->icmp_ext_data;\n\n            while (hlen > sizeof(struct icmp_mpls_ext_object_header_t)) {\n\n                icmp_mpls_ext_object_header = (const struct icmp_mpls_ext_object_header_t *)obj_tptr;\n                ND_TCHECK(*icmp_mpls_ext_object_header);\n                obj_tlen = EXTRACT_16BITS(icmp_mpls_ext_object_header->length);\n                obj_class_num = icmp_mpls_ext_object_header->class_num;\n                obj_ctype = icmp_mpls_ext_object_header->ctype;\n                obj_tptr += sizeof(struct icmp_mpls_ext_object_header_t);\n\n                ND_PRINT((ndo, \"\\n\\t  %s Object (%u), Class-Type: %u, length %u\",\n                       tok2str(icmp_mpls_ext_obj_values,\"unknown\",obj_class_num),\n                       obj_class_num,\n                       obj_ctype,\n                       obj_tlen));\n\n                hlen-=sizeof(struct icmp_mpls_ext_object_header_t); /* length field includes tlv header */\n\n                /* infinite loop protection */\n                if ((obj_class_num == 0) ||\n                    (obj_tlen < sizeof(struct icmp_mpls_ext_object_header_t))) {\n                    return;\n                }\n                obj_tlen-=sizeof(struct icmp_mpls_ext_object_header_t);\n\n                switch (obj_class_num) {\n                case 1:\n                    switch(obj_ctype) {\n                    case 1:\n                        ND_TCHECK2(*obj_tptr, 4);\n                        raw_label = EXTRACT_32BITS(obj_tptr);\n                        ND_PRINT((ndo, \"\\n\\t    label %u, exp %u\", MPLS_LABEL(raw_label), MPLS_EXP(raw_label)));\n                        if (MPLS_STACK(raw_label))\n                            ND_PRINT((ndo, \", [S]\"));\n                        ND_PRINT((ndo, \", ttl %u\", MPLS_TTL(raw_label)));\n                        break;\n                    default:\n                        print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    }\n                    break;\n\n               /*\n                *  FIXME those are the defined objects that lack a decoder\n                *  you are welcome to contribute code ;-)\n                */\n                case 2:\n                default:\n                    print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    break;\n                }\n                if (hlen < obj_tlen)\n                    break;\n                hlen -= obj_tlen;\n                obj_tptr += obj_tlen;\n            }\n        }\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"[|icmp]\"));\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\tip_print(ndo, bp, EXTRACT_16BITS(&ip->ip_len));\n",
        "src_path": "8509ef02eceb2bbb479cea10fe4a7ec6395f1a8b___print-icmp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/8509ef02eceb2bbb479cea10fe4a7ec6395f1a8b",
        "commit_msg": "CVE-2017-13012/ICMP: Add a missing bounds check.\n\nCheck before fetching the length from the included packet's IPv4 header.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -509,6 +509,7 @@ pktap-heap-overflow\tpktap-heap-overflow.pcap\tpktap-heap-overflow.out\t-v\n \n # bad packets from Bhargava Shastry\n lldp_asan\t\tlldp_asan.pcap\t\t\tlldp_asan.out\t-v\n+extract_read2_asan\textract_read2_asan.pcap\t\textract_read2_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/extract_read2_asan.out",
                "patch": "@@ -0,0 +1,3 @@\n+IP (tos 0x14, id 1, offset 0, flags [none], proto ICMP (1), length 512, options (unknown 3,unknown 3,unknown 3 [bad length 3]), bad cksum 3ff (->b4bd)!)\n+    240.25.0.0 > 3.3.3.3: ICMP source quench, length 484\n+\t[|icmp]"
            }
        ],
        "error_msg": "    extract_read2_asan                 : TEST FAILED(exit 256)\n"
    },
    "11b426ee05eb62ed103218526f1fa616851c43ce___print-dhcp6.c": {
        "prefix": "static void\ndhcp6opt_print(netdissect_options *ndo,\n               const u_char *cp, const u_char *ep)\n{\n\tconst struct dhcp6opt *dh6o;\n\tconst u_char *tp;\n\tsize_t i;\n\tuint16_t opttype;\n\tsize_t optlen;\n\tuint8_t auth_proto;\n\tu_int authinfolen, authrealmlen;\n\tint remain_len;  /* Length of remaining options */\n\tint label_len;   /* Label length */\n\tuint16_t subopt_code;\n\tuint16_t subopt_len;\n\n\tif (cp == ep)\n\t\treturn;\n\twhile (cp < ep) {\n\t\tif (ep < cp + sizeof(*dh6o))\n\t\t\tgoto trunc;\n\t\tdh6o = (const struct dhcp6opt *)cp;\n\t\tND_TCHECK(*dh6o);\n\t\toptlen = EXTRACT_16BITS(&dh6o->dh6opt_len);\n\t\tif (ep < cp + sizeof(*dh6o) + optlen)\n\t\t\tgoto trunc;\n\t\topttype = EXTRACT_16BITS(&dh6o->dh6opt_type);\n\t\tND_PRINT((ndo, \" (%s\", tok2str(dh6opt_str, \"opt_%u\", opttype)));\n\t\tND_TCHECK2(*(cp + sizeof(*dh6o)), optlen);\n\t\tswitch (opttype) {\n\t\tcase DH6OPT_CLIENTID:\n\t\tcase DH6OPT_SERVERID:\n\t\t\tif (optlen < 2) {\n\t\t\t\t/*(*/\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tswitch (EXTRACT_16BITS(tp)) {\n\t\t\tcase 1:\n\t\t\t\tif (optlen >= 2 + 6) {\n\t\t\t\t\tND_PRINT((ndo, \" hwaddr/time type %u time %u \",\n\t\t\t\t\t    EXTRACT_16BITS(&tp[2]),\n\t\t\t\t\t    EXTRACT_32BITS(&tp[4])));\n\t\t\t\t\tfor (i = 8; i < optlen; i++)\n\t\t\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \")\"));\n\t\t\t\t} else {\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (optlen >= 2 + 8) {\n\t\t\t\t\tND_PRINT((ndo, \" vid \"));\n\t\t\t\t\tfor (i = 2; i < 2 + 8; i++)\n\t\t\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \")\"));\n\t\t\t\t} else {\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (optlen >= 2 + 2) {\n\t\t\t\t\tND_PRINT((ndo, \" hwaddr type %u \",\n\t\t\t\t\t    EXTRACT_16BITS(&tp[2])));\n\t\t\t\t\tfor (i = 4; i < optlen; i++)\n\t\t\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \")\"));\n\t\t\t\t} else {\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" type %d)\", EXTRACT_16BITS(tp)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_ADDR:\n\t\t\tif (optlen < 24) {\n\t\t\t\t/*(*/\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[0])));\n\t\t\tND_PRINT((ndo, \" pltime:%u vltime:%u\",\n\t\t\t    EXTRACT_32BITS(&tp[16]),\n\t\t\t    EXTRACT_32BITS(&tp[20])));\n\t\t\tif (optlen > 24) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 24, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_ORO:\n\t\tcase DH6OPT_ERO:\n\t\t\tif (optlen % 2) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tfor (i = 0; i < optlen; i += 2) {\n\t\t\t\tND_PRINT((ndo, \" %s\",\n\t\t\t\t    tok2str(dh6opt_str, \"opt_%u\", EXTRACT_16BITS(&tp[i]))));\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_PREFERENCE:\n\t\t\tif (optlen != 1) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d)\", *tp));\n\t\t\tbreak;\n\t\tcase DH6OPT_ELAPSED_TIME:\n\t\t\tif (optlen != 2) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d)\", EXTRACT_16BITS(tp)));\n\t\t\tbreak;\n\t\tcase DH6OPT_RELAY_MSG:\n\t\t\tND_PRINT((ndo, \" (\"));\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tdhcp6_print(ndo, tp, optlen);\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_AUTH:\n\t\t\tif (optlen < 11) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tauth_proto = *tp;\n\t\t\tswitch (auth_proto) {\n\t\t\tcase DH6OPT_AUTHPROTO_DELAYED:\n\t\t\t\tND_PRINT((ndo, \" proto: delayed\"));\n\t\t\t\tbreak;\n\t\t\tcase DH6OPT_AUTHPROTO_RECONFIG:\n\t\t\t\tND_PRINT((ndo, \" proto: reconfigure\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" proto: %d\", auth_proto));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp++;\n\t\t\tswitch (*tp) {\n\t\t\tcase DH6OPT_AUTHALG_HMACMD5:\n\t\t\t\t/* XXX: may depend on the protocol */\n\t\t\t\tND_PRINT((ndo, \", alg: HMAC-MD5\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \", alg: %d\", *tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp++;\n\t\t\tswitch (*tp) {\n\t\t\tcase DH6OPT_AUTHRDM_MONOCOUNTER:\n\t\t\t\tND_PRINT((ndo, \", RDM: mono\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \", RDM: %d\", *tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp++;\n\t\t\tND_PRINT((ndo, \", RD:\"));\n\t\t\tfor (i = 0; i < 4; i++, tp += 2)\n\t\t\t\tND_PRINT((ndo, \" %04x\", EXTRACT_16BITS(tp)));\n\n\t\t\t/* protocol dependent part */\n\t\t\tauthinfolen = optlen - 11;\n\t\t\tswitch (auth_proto) {\n\t\t\tcase DH6OPT_AUTHPROTO_DELAYED:\n\t\t\t\tif (authinfolen == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (authinfolen < 20) {\n\t\t\t\t\tND_PRINT((ndo, \" ??\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tauthrealmlen = authinfolen - 20;\n\t\t\t\tif (authrealmlen > 0) {\n\t\t\t\t\tND_PRINT((ndo, \", realm: \"));\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < authrealmlen; i++, tp++)\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", *tp));\n\t\t\t\tND_PRINT((ndo, \", key ID: %08x\", EXTRACT_32BITS(tp)));\n\t\t\t\ttp += 4;\n\t\t\t\tND_PRINT((ndo, \", HMAC-MD5:\"));\n\t\t\t\tfor (i = 0; i < 4; i++, tp+= 4)\n\t\t\t\t\tND_PRINT((ndo, \" %08x\", EXTRACT_32BITS(tp)));\n\t\t\t\tbreak;\n\t\t\tcase DH6OPT_AUTHPROTO_RECONFIG:\n\t\t\t\tif (authinfolen != 17) {\n\t\t\t\t\tND_PRINT((ndo, \" ??\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (*tp++) {\n\t\t\t\tcase DH6OPT_AUTHRECONFIG_KEY:\n\t\t\t\t\tND_PRINT((ndo, \" reconfig-key\"));\n\t\t\t\t\tbreak;\n\t\t\t\tcase DH6OPT_AUTHRECONFIG_HMACMD5:\n\t\t\t\t\tND_PRINT((ndo, \" type: HMAC-MD5\"));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tND_PRINT((ndo, \" type: ??\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, \" value:\"));\n\t\t\t\tfor (i = 0; i < 4; i++, tp+= 4)\n\t\t\t\t\tND_PRINT((ndo, \" %08x\", EXTRACT_32BITS(tp)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" ??\"));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_RAPID_COMMIT: /* nothing todo */\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_INTERFACE_ID:\n\t\tcase DH6OPT_SUBSCRIBER_ID:\n\t\t\t/*\n\t\t\t * Since we cannot predict the encoding, print hex dump\n\t\t\t * at most 10 characters.\n\t\t\t */\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" \"));\n\t\t\tfor (i = 0; i < optlen && i < 10; i++)\n\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_RECONF_MSG:\n",
        "suffix": "\t\t\tswitch (*tp) {\n\t\t\tcase DH6_RENEW:\n\t\t\t\tND_PRINT((ndo, \" for renew)\"));\n\t\t\t\tbreak;\n\t\t\tcase DH6_INFORM_REQ:\n\t\t\t\tND_PRINT((ndo, \" for inf-req)\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" for ?\\?\\?(%02x))\", *tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DH6OPT_RECONF_ACCEPT: /* nothing todo */\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_SIP_SERVER_A:\n\t\tcase DH6OPT_DNS_SERVERS:\n\t\tcase DH6OPT_SNTP_SERVERS:\n\t\tcase DH6OPT_NIS_SERVERS:\n\t\tcase DH6OPT_NISP_SERVERS:\n\t\tcase DH6OPT_BCMCS_SERVER_A:\n\t\tcase DH6OPT_PANA_AGENT:\n\t\tcase DH6OPT_LQ_CLIENT_LINK:\n\t\t\tif (optlen % 16) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tfor (i = 0; i < optlen; i += 16)\n\t\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[i])));\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_SIP_SERVER_D:\n\t\tcase DH6OPT_DOMAIN_LIST:\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\twhile (tp < cp + sizeof(*dh6o) + optlen) {\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\t\tif ((tp = ns_nprint(ndo, tp, cp + sizeof(*dh6o) + optlen)) == NULL)\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_STATUS_CODE:\n\t\t\tif (optlen < 2) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s)\", dhcp6stcode(EXTRACT_16BITS(&tp[0]))));\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_NA:\n\t\tcase DH6OPT_IA_PD:\n\t\t\tif (optlen < 12) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" IAID:%u T1:%u T2:%u\",\n\t\t\t    EXTRACT_32BITS(&tp[0]),\n\t\t\t    EXTRACT_32BITS(&tp[4]),\n\t\t\t    EXTRACT_32BITS(&tp[8])));\n\t\t\tif (optlen > 12) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 12, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_TA:\n\t\t\tif (optlen < 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" IAID:%u\", EXTRACT_32BITS(tp)));\n\t\t\tif (optlen > 4) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 4, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_PD_PREFIX:\n\t\t\tif (optlen < 25) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s/%d\", ip6addr_string(ndo, &tp[9]), tp[8]));\n\t\t\tND_PRINT((ndo, \" pltime:%u vltime:%u\",\n\t\t\t    EXTRACT_32BITS(&tp[0]),\n\t\t\t    EXTRACT_32BITS(&tp[4])));\n\t\t\tif (optlen > 25) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 25, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_LIFETIME:\n\t\tcase DH6OPT_CLT_TIME:\n\t\t\tif (optlen != 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d)\", EXTRACT_32BITS(tp)));\n\t\t\tbreak;\n\t\tcase DH6OPT_REMOTE_ID:\n\t\t\tif (optlen < 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d \", EXTRACT_32BITS(tp)));\n\t\t\t/*\n\t\t\t * Print hex dump first 10 characters.\n\t\t\t */\n\t\t\tfor (i = 4; i < optlen && i < 14; i++)\n\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_LQ_QUERY:\n\t\t\tif (optlen < 17) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tswitch (*tp) {\n\t\t\tcase 1:\n\t\t\t\tND_PRINT((ndo, \" by-address\"));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tND_PRINT((ndo, \" by-clientID\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" type_%d\", (int)*tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[1])));\n\t\t\tif (optlen > 17) {\n\t\t\t\t/* there are query-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 17, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_CLIENT_DATA:\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tif (optlen > 0) {\n\t\t\t\t/* there are encapsulated options */\n\t\t\t\tdhcp6opt_print(ndo, tp, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_LQ_RELAY_DATA:\n\t\t\tif (optlen < 16) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s \", ip6addr_string(ndo, &tp[0])));\n\t\t\t/*\n\t\t\t * Print hex dump first 10 characters.\n\t\t\t */\n\t\t\tfor (i = 16; i < optlen && i < 26; i++)\n\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_NTP_SERVER:\n\t\t\tif (optlen < 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\twhile (tp < cp + sizeof(*dh6o) + optlen - 4) {\n\t\t\t\tsubopt_code = EXTRACT_16BITS(tp);\n\t\t\t\ttp += 2;\n\t\t\t\tsubopt_len = EXTRACT_16BITS(tp);\n\t\t\t\ttp += 2;\n\t\t\t\tif (tp + subopt_len > cp + sizeof(*dh6o) + optlen)\n\t\t\t\t\tgoto trunc;\n\t\t\t\tND_PRINT((ndo, \" subopt:%d\", subopt_code));\n\t\t\t\tswitch (subopt_code) {\n\t\t\t\tcase DH6OPT_NTP_SUBOPTION_SRV_ADDR:\n\t\t\t\tcase DH6OPT_NTP_SUBOPTION_MC_ADDR:\n\t\t\t\t\tif (subopt_len != 16) {\n\t\t\t\t\t\tND_PRINT((ndo, \" ?\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[0])));\n\t\t\t\t\tbreak;\n\t\t\t\tcase DH6OPT_NTP_SUBOPTION_SRV_FQDN:\n\t\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\t\t\tif (ns_nprint(ndo, tp, tp + subopt_len) == NULL)\n\t\t\t\t\t\tgoto trunc;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tND_PRINT((ndo, \" ?\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttp += subopt_len;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_AFTR_NAME:\n\t\t\tif (optlen < 3) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tremain_len = optlen;\n\t\t\tND_PRINT((ndo, \" \"));\n\t\t\t/* Encoding is described in section 3.1 of RFC 1035 */\n\t\t\twhile (remain_len && *tp) {\n\t\t\t\tlabel_len =  *tp++;\n\t\t\t\tif (label_len < remain_len - 1) {\n\t\t\t\t\t(void)fn_printn(ndo, tp, label_len, NULL);\n\t\t\t\t\ttp += label_len;\n\t\t\t\t\tremain_len -= (label_len + 1);\n\t\t\t\t\tif(*tp) ND_PRINT((ndo, \".\"));\n\t\t\t\t} else {\n\t\t\t\t\tND_PRINT((ndo, \" ?\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_NEW_POSIX_TIMEZONE: /* all three of these options */\n\t\tcase DH6OPT_NEW_TZDB_TIMEZONE:\t/* are encoded similarly */\n\t\tcase DH6OPT_MUDURL:\t\t/* although GMT might not work */\n\t\t        if (optlen < 5) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \"=\"));\n\t\t\t(void)fn_printn(ndo, tp, (u_int)optlen, NULL);\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tcp += sizeof(*dh6o) + optlen;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|dhcp6ext]\"));\n}\n",
        "start": 279,
        "end": 770,
        "buggy": "static void\ndhcp6opt_print(netdissect_options *ndo,\n               const u_char *cp, const u_char *ep)\n{\n\tconst struct dhcp6opt *dh6o;\n\tconst u_char *tp;\n\tsize_t i;\n\tuint16_t opttype;\n\tsize_t optlen;\n\tuint8_t auth_proto;\n\tu_int authinfolen, authrealmlen;\n\tint remain_len;  /* Length of remaining options */\n\tint label_len;   /* Label length */\n\tuint16_t subopt_code;\n\tuint16_t subopt_len;\n\n\tif (cp == ep)\n\t\treturn;\n\twhile (cp < ep) {\n\t\tif (ep < cp + sizeof(*dh6o))\n\t\t\tgoto trunc;\n\t\tdh6o = (const struct dhcp6opt *)cp;\n\t\tND_TCHECK(*dh6o);\n\t\toptlen = EXTRACT_16BITS(&dh6o->dh6opt_len);\n\t\tif (ep < cp + sizeof(*dh6o) + optlen)\n\t\t\tgoto trunc;\n\t\topttype = EXTRACT_16BITS(&dh6o->dh6opt_type);\n\t\tND_PRINT((ndo, \" (%s\", tok2str(dh6opt_str, \"opt_%u\", opttype)));\n\t\tND_TCHECK2(*(cp + sizeof(*dh6o)), optlen);\n\t\tswitch (opttype) {\n\t\tcase DH6OPT_CLIENTID:\n\t\tcase DH6OPT_SERVERID:\n\t\t\tif (optlen < 2) {\n\t\t\t\t/*(*/\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tswitch (EXTRACT_16BITS(tp)) {\n\t\t\tcase 1:\n\t\t\t\tif (optlen >= 2 + 6) {\n\t\t\t\t\tND_PRINT((ndo, \" hwaddr/time type %u time %u \",\n\t\t\t\t\t    EXTRACT_16BITS(&tp[2]),\n\t\t\t\t\t    EXTRACT_32BITS(&tp[4])));\n\t\t\t\t\tfor (i = 8; i < optlen; i++)\n\t\t\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \")\"));\n\t\t\t\t} else {\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (optlen >= 2 + 8) {\n\t\t\t\t\tND_PRINT((ndo, \" vid \"));\n\t\t\t\t\tfor (i = 2; i < 2 + 8; i++)\n\t\t\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \")\"));\n\t\t\t\t} else {\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (optlen >= 2 + 2) {\n\t\t\t\t\tND_PRINT((ndo, \" hwaddr type %u \",\n\t\t\t\t\t    EXTRACT_16BITS(&tp[2])));\n\t\t\t\t\tfor (i = 4; i < optlen; i++)\n\t\t\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \")\"));\n\t\t\t\t} else {\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" type %d)\", EXTRACT_16BITS(tp)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_ADDR:\n\t\t\tif (optlen < 24) {\n\t\t\t\t/*(*/\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[0])));\n\t\t\tND_PRINT((ndo, \" pltime:%u vltime:%u\",\n\t\t\t    EXTRACT_32BITS(&tp[16]),\n\t\t\t    EXTRACT_32BITS(&tp[20])));\n\t\t\tif (optlen > 24) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 24, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_ORO:\n\t\tcase DH6OPT_ERO:\n\t\t\tif (optlen % 2) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tfor (i = 0; i < optlen; i += 2) {\n\t\t\t\tND_PRINT((ndo, \" %s\",\n\t\t\t\t    tok2str(dh6opt_str, \"opt_%u\", EXTRACT_16BITS(&tp[i]))));\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_PREFERENCE:\n\t\t\tif (optlen != 1) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d)\", *tp));\n\t\t\tbreak;\n\t\tcase DH6OPT_ELAPSED_TIME:\n\t\t\tif (optlen != 2) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d)\", EXTRACT_16BITS(tp)));\n\t\t\tbreak;\n\t\tcase DH6OPT_RELAY_MSG:\n\t\t\tND_PRINT((ndo, \" (\"));\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tdhcp6_print(ndo, tp, optlen);\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_AUTH:\n\t\t\tif (optlen < 11) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tauth_proto = *tp;\n\t\t\tswitch (auth_proto) {\n\t\t\tcase DH6OPT_AUTHPROTO_DELAYED:\n\t\t\t\tND_PRINT((ndo, \" proto: delayed\"));\n\t\t\t\tbreak;\n\t\t\tcase DH6OPT_AUTHPROTO_RECONFIG:\n\t\t\t\tND_PRINT((ndo, \" proto: reconfigure\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" proto: %d\", auth_proto));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp++;\n\t\t\tswitch (*tp) {\n\t\t\tcase DH6OPT_AUTHALG_HMACMD5:\n\t\t\t\t/* XXX: may depend on the protocol */\n\t\t\t\tND_PRINT((ndo, \", alg: HMAC-MD5\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \", alg: %d\", *tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp++;\n\t\t\tswitch (*tp) {\n\t\t\tcase DH6OPT_AUTHRDM_MONOCOUNTER:\n\t\t\t\tND_PRINT((ndo, \", RDM: mono\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \", RDM: %d\", *tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp++;\n\t\t\tND_PRINT((ndo, \", RD:\"));\n\t\t\tfor (i = 0; i < 4; i++, tp += 2)\n\t\t\t\tND_PRINT((ndo, \" %04x\", EXTRACT_16BITS(tp)));\n\n\t\t\t/* protocol dependent part */\n\t\t\tauthinfolen = optlen - 11;\n\t\t\tswitch (auth_proto) {\n\t\t\tcase DH6OPT_AUTHPROTO_DELAYED:\n\t\t\t\tif (authinfolen == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (authinfolen < 20) {\n\t\t\t\t\tND_PRINT((ndo, \" ??\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tauthrealmlen = authinfolen - 20;\n\t\t\t\tif (authrealmlen > 0) {\n\t\t\t\t\tND_PRINT((ndo, \", realm: \"));\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < authrealmlen; i++, tp++)\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", *tp));\n\t\t\t\tND_PRINT((ndo, \", key ID: %08x\", EXTRACT_32BITS(tp)));\n\t\t\t\ttp += 4;\n\t\t\t\tND_PRINT((ndo, \", HMAC-MD5:\"));\n\t\t\t\tfor (i = 0; i < 4; i++, tp+= 4)\n\t\t\t\t\tND_PRINT((ndo, \" %08x\", EXTRACT_32BITS(tp)));\n\t\t\t\tbreak;\n\t\t\tcase DH6OPT_AUTHPROTO_RECONFIG:\n\t\t\t\tif (authinfolen != 17) {\n\t\t\t\t\tND_PRINT((ndo, \" ??\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (*tp++) {\n\t\t\t\tcase DH6OPT_AUTHRECONFIG_KEY:\n\t\t\t\t\tND_PRINT((ndo, \" reconfig-key\"));\n\t\t\t\t\tbreak;\n\t\t\t\tcase DH6OPT_AUTHRECONFIG_HMACMD5:\n\t\t\t\t\tND_PRINT((ndo, \" type: HMAC-MD5\"));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tND_PRINT((ndo, \" type: ??\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, \" value:\"));\n\t\t\t\tfor (i = 0; i < 4; i++, tp+= 4)\n\t\t\t\t\tND_PRINT((ndo, \" %08x\", EXTRACT_32BITS(tp)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" ??\"));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_RAPID_COMMIT: /* nothing todo */\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_INTERFACE_ID:\n\t\tcase DH6OPT_SUBSCRIBER_ID:\n\t\t\t/*\n\t\t\t * Since we cannot predict the encoding, print hex dump\n\t\t\t * at most 10 characters.\n\t\t\t */\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" \"));\n\t\t\tfor (i = 0; i < optlen && i < 10; i++)\n\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_RECONF_MSG:\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tswitch (*tp) {\n\t\t\tcase DH6_RENEW:\n\t\t\t\tND_PRINT((ndo, \" for renew)\"));\n\t\t\t\tbreak;\n\t\t\tcase DH6_INFORM_REQ:\n\t\t\t\tND_PRINT((ndo, \" for inf-req)\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" for ?\\?\\?(%02x))\", *tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DH6OPT_RECONF_ACCEPT: /* nothing todo */\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_SIP_SERVER_A:\n\t\tcase DH6OPT_DNS_SERVERS:\n\t\tcase DH6OPT_SNTP_SERVERS:\n\t\tcase DH6OPT_NIS_SERVERS:\n\t\tcase DH6OPT_NISP_SERVERS:\n\t\tcase DH6OPT_BCMCS_SERVER_A:\n\t\tcase DH6OPT_PANA_AGENT:\n\t\tcase DH6OPT_LQ_CLIENT_LINK:\n\t\t\tif (optlen % 16) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tfor (i = 0; i < optlen; i += 16)\n\t\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[i])));\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_SIP_SERVER_D:\n\t\tcase DH6OPT_DOMAIN_LIST:\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\twhile (tp < cp + sizeof(*dh6o) + optlen) {\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\t\tif ((tp = ns_nprint(ndo, tp, cp + sizeof(*dh6o) + optlen)) == NULL)\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_STATUS_CODE:\n\t\t\tif (optlen < 2) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s)\", dhcp6stcode(EXTRACT_16BITS(&tp[0]))));\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_NA:\n\t\tcase DH6OPT_IA_PD:\n\t\t\tif (optlen < 12) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" IAID:%u T1:%u T2:%u\",\n\t\t\t    EXTRACT_32BITS(&tp[0]),\n\t\t\t    EXTRACT_32BITS(&tp[4]),\n\t\t\t    EXTRACT_32BITS(&tp[8])));\n\t\t\tif (optlen > 12) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 12, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_TA:\n\t\t\tif (optlen < 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" IAID:%u\", EXTRACT_32BITS(tp)));\n\t\t\tif (optlen > 4) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 4, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_PD_PREFIX:\n\t\t\tif (optlen < 25) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s/%d\", ip6addr_string(ndo, &tp[9]), tp[8]));\n\t\t\tND_PRINT((ndo, \" pltime:%u vltime:%u\",\n\t\t\t    EXTRACT_32BITS(&tp[0]),\n\t\t\t    EXTRACT_32BITS(&tp[4])));\n\t\t\tif (optlen > 25) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 25, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_LIFETIME:\n\t\tcase DH6OPT_CLT_TIME:\n\t\t\tif (optlen != 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d)\", EXTRACT_32BITS(tp)));\n\t\t\tbreak;\n\t\tcase DH6OPT_REMOTE_ID:\n\t\t\tif (optlen < 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d \", EXTRACT_32BITS(tp)));\n\t\t\t/*\n\t\t\t * Print hex dump first 10 characters.\n\t\t\t */\n\t\t\tfor (i = 4; i < optlen && i < 14; i++)\n\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_LQ_QUERY:\n\t\t\tif (optlen < 17) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tswitch (*tp) {\n\t\t\tcase 1:\n\t\t\t\tND_PRINT((ndo, \" by-address\"));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tND_PRINT((ndo, \" by-clientID\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" type_%d\", (int)*tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[1])));\n\t\t\tif (optlen > 17) {\n\t\t\t\t/* there are query-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 17, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_CLIENT_DATA:\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tif (optlen > 0) {\n\t\t\t\t/* there are encapsulated options */\n\t\t\t\tdhcp6opt_print(ndo, tp, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_LQ_RELAY_DATA:\n\t\t\tif (optlen < 16) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s \", ip6addr_string(ndo, &tp[0])));\n\t\t\t/*\n\t\t\t * Print hex dump first 10 characters.\n\t\t\t */\n\t\t\tfor (i = 16; i < optlen && i < 26; i++)\n\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_NTP_SERVER:\n\t\t\tif (optlen < 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\twhile (tp < cp + sizeof(*dh6o) + optlen - 4) {\n\t\t\t\tsubopt_code = EXTRACT_16BITS(tp);\n\t\t\t\ttp += 2;\n\t\t\t\tsubopt_len = EXTRACT_16BITS(tp);\n\t\t\t\ttp += 2;\n\t\t\t\tif (tp + subopt_len > cp + sizeof(*dh6o) + optlen)\n\t\t\t\t\tgoto trunc;\n\t\t\t\tND_PRINT((ndo, \" subopt:%d\", subopt_code));\n\t\t\t\tswitch (subopt_code) {\n\t\t\t\tcase DH6OPT_NTP_SUBOPTION_SRV_ADDR:\n\t\t\t\tcase DH6OPT_NTP_SUBOPTION_MC_ADDR:\n\t\t\t\t\tif (subopt_len != 16) {\n\t\t\t\t\t\tND_PRINT((ndo, \" ?\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[0])));\n\t\t\t\t\tbreak;\n\t\t\t\tcase DH6OPT_NTP_SUBOPTION_SRV_FQDN:\n\t\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\t\t\tif (ns_nprint(ndo, tp, tp + subopt_len) == NULL)\n\t\t\t\t\t\tgoto trunc;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tND_PRINT((ndo, \" ?\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttp += subopt_len;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_AFTR_NAME:\n\t\t\tif (optlen < 3) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tremain_len = optlen;\n\t\t\tND_PRINT((ndo, \" \"));\n\t\t\t/* Encoding is described in section 3.1 of RFC 1035 */\n\t\t\twhile (remain_len && *tp) {\n\t\t\t\tlabel_len =  *tp++;\n\t\t\t\tif (label_len < remain_len - 1) {\n\t\t\t\t\t(void)fn_printn(ndo, tp, label_len, NULL);\n\t\t\t\t\ttp += label_len;\n\t\t\t\t\tremain_len -= (label_len + 1);\n\t\t\t\t\tif(*tp) ND_PRINT((ndo, \".\"));\n\t\t\t\t} else {\n\t\t\t\t\tND_PRINT((ndo, \" ?\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_NEW_POSIX_TIMEZONE: /* all three of these options */\n\t\tcase DH6OPT_NEW_TZDB_TIMEZONE:\t/* are encoded similarly */\n\t\tcase DH6OPT_MUDURL:\t\t/* although GMT might not work */\n\t\t        if (optlen < 5) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \"=\"));\n\t\t\t(void)fn_printn(ndo, tp, (u_int)optlen, NULL);\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tcp += sizeof(*dh6o) + optlen;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|dhcp6ext]\"));\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\ttp = (const u_char *)(dh6o + 1);\n",
        "src_path": "11b426ee05eb62ed103218526f1fa616851c43ce___print-dhcp6.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/11b426ee05eb62ed103218526f1fa616851c43ce",
        "commit_msg": "CVE-2017-13017/DHCPv6: Add a missing option length check.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -518,6 +518,7 @@ esis_snpa_asan-2\tesis_snpa_asan-2.pcap\t\tesis_snpa_asan-2.out\t-v\n esis_snpa_asan-3\tesis_snpa_asan-3.pcap\t\tesis_snpa_asan-3.out\t-v\n esis_snpa_asan-4\tesis_snpa_asan-4.pcap\t\tesis_snpa_asan-4.out\t-v\n esis_snpa_asan-5\tesis_snpa_asan-5.pcap\t\tesis_snpa_asan-5.out\t-v\n+dhcp6_reconf_asan\tdhcp6_reconf_asan.pcap\t\tdhcp6_reconf_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/dhcp6_reconf_asan.out",
                "patch": "@@ -0,0 +1,2 @@\n+IP (tos 0x60, ttl 254, id 21519, offset 0, flags [+, DF, rsvd], proto UDP (17), length 768, options (EOL), bad cksum 9615 (->c6f)!)\n+    251.73.86.150.514 > 126.172.217.192.546: dhcp6 relay-reply (linkaddr=300:10ed:ff:f01:f:0:7f:7f peeraddr=ffb6:3a64::c1:2300:581c:d00 (reconfigure-message ?) (reconfigure-message ?))"
            }
        ],
        "error_msg": "    dhcp6_reconf_asan                  : TEST FAILED(exit 256)\n"
    },
    "26a6799b9ca80508c05cac7a9a3bef922991520b___print-pgm.c": {
        "prefix": "void\npgm_print(netdissect_options *ndo,\n          register const u_char *bp, register u_int length,\n          register const u_char *bp2)\n{\n\tregister const struct pgm_header *pgm;\n\tregister const struct ip *ip;\n\tregister char ch;\n\tuint16_t sport, dport;\n\tu_int nla_afnum;\n\tchar nla_buf[INET6_ADDRSTRLEN];\n\tregister const struct ip6_hdr *ip6;\n\tuint8_t opt_type, opt_len;\n\tuint32_t seq, opts_len, len, offset;\n\n\tpgm = (const struct pgm_header *)bp;\n\tip = (const struct ip *)bp2;\n\tif (IP_V(ip) == 6)\n\t\tip6 = (const struct ip6_hdr *)bp2;\n\telse\n\t\tip6 = NULL;\n\tch = '\\0';\n\tif (!ND_TTEST(pgm->pgm_dport)) {\n\t\tif (ip6) {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst)));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst)));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsport = EXTRACT_16BITS(&pgm->pgm_sport);\n\tdport = EXTRACT_16BITS(&pgm->pgm_dport);\n\n\tif (ip6) {\n\t\tif (ip6->ip6_nxt == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t} else {\n\t\tif (ip->ip_p == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t}\n\n\tND_TCHECK(*pgm);\n\n        ND_PRINT((ndo, \"PGM, length %u\", EXTRACT_16BITS(&pgm->pgm_length)));\n\n        if (!ndo->ndo_vflag)\n            return;\n\n\tND_PRINT((ndo, \" 0x%02x%02x%02x%02x%02x%02x \",\n\t\t     pgm->pgm_gsid[0],\n                     pgm->pgm_gsid[1],\n                     pgm->pgm_gsid[2],\n\t\t     pgm->pgm_gsid[3],\n                     pgm->pgm_gsid[4],\n                     pgm->pgm_gsid[5]));\n\tswitch (pgm->pgm_type) {\n\tcase PGM_SPM: {\n\t    const struct pgm_spm *spm;\n\n\t    spm = (const struct pgm_spm *)(pgm + 1);\n\t    ND_TCHECK(*spm);\n\t    bp = (const u_char *) (spm + 1);\n\n\t    switch (EXTRACT_16BITS(&spm->pgms_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_PRINT((ndo, \"SPM seq %u trail %u lead %u nla %s\",\n\t\t\t EXTRACT_32BITS(&spm->pgms_seq),\n                         EXTRACT_32BITS(&spm->pgms_trailseq),\n\t\t\t EXTRACT_32BITS(&spm->pgms_leadseq),\n                         nla_buf));\n\t    break;\n\t}\n\n\tcase PGM_POLL: {\n\t    const struct pgm_poll *poll_msg;\n\n\t    poll_msg = (const struct pgm_poll *)(pgm + 1);\n\t    ND_TCHECK(*poll_msg);\n\t    ND_PRINT((ndo, \"POLL seq %u round %u\",\n\t\t\t EXTRACT_32BITS(&poll_msg->pgmp_seq),\n                         EXTRACT_16BITS(&poll_msg->pgmp_round)));\n\t    bp = (const u_char *) (poll_msg + 1);\n\t    break;\n\t}\n\tcase PGM_POLR: {\n\t    const struct pgm_polr *polr;\n\t    uint32_t ivl, rnd, mask;\n\n\t    polr = (const struct pgm_polr *)(pgm + 1);\n\t    ND_TCHECK(*polr);\n\t    bp = (const u_char *) (polr + 1);\n\n\t    switch (EXTRACT_16BITS(&polr->pgmp_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    ivl = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    rnd = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    mask = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_PRINT((ndo, \"POLR seq %u round %u nla %s ivl %u rnd 0x%08x \"\n\t\t\t \"mask 0x%08x\", EXTRACT_32BITS(&polr->pgmp_seq),\n\t\t\t EXTRACT_16BITS(&polr->pgmp_round), nla_buf, ivl, rnd, mask));\n\t    break;\n\t}\n\tcase PGM_ODATA: {\n\t    const struct pgm_data *odata;\n\n\t    odata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*odata);\n\t    ND_PRINT((ndo, \"ODATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&odata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&odata->pgmd_seq)));\n\t    bp = (const u_char *) (odata + 1);\n\t    break;\n\t}\n\n\tcase PGM_RDATA: {\n\t    const struct pgm_data *rdata;\n\n\t    rdata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*rdata);\n\t    ND_PRINT((ndo, \"RDATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_seq)));\n\t    bp = (const u_char *) (rdata + 1);\n\t    break;\n\t}\n\n\tcase PGM_NAK:\n\tcase PGM_NULLNAK:\n\tcase PGM_NCF: {\n\t    const struct pgm_nak *nak;\n\t    char source_buf[INET6_ADDRSTRLEN], group_buf[INET6_ADDRSTRLEN];\n\n\t    nak = (const struct pgm_nak *)(pgm + 1);\n\t    ND_TCHECK(*nak);\n\t    bp = (const u_char *) (nak + 1);\n\n\t    /*\n\t     * Skip past the source, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    switch (EXTRACT_16BITS(&nak->pgmn_source_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Skip past the group, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    bp += (2 * sizeof(uint16_t));\n\t    switch (EXTRACT_16BITS(bp)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Options decoding can go here.\n\t     */\n\t    switch (pgm->pgm_type) {\n\t\tcase PGM_NAK:\n\t\t    ND_PRINT((ndo, \"NAK \"));\n\t\t    break;\n\t\tcase PGM_NULLNAK:\n\t\t    ND_PRINT((ndo, \"NNAK \"));\n\t\t    break;\n\t\tcase PGM_NCF:\n\t\t    ND_PRINT((ndo, \"NCF \"));\n\t\t    break;\n\t\tdefault:\n                    break;\n\t    }\n\t    ND_PRINT((ndo, \"(%s -> %s), seq %u\",\n\t\t\t source_buf, group_buf, EXTRACT_32BITS(&nak->pgmn_seq)));\n\t    break;\n\t}\n\n\tcase PGM_ACK: {\n\t    const struct pgm_ack *ack;\n\n\t    ack = (const struct pgm_ack *)(pgm + 1);\n\t    ND_TCHECK(*ack);\n\t    ND_PRINT((ndo, \"ACK seq %u\",\n\t\t\t EXTRACT_32BITS(&ack->pgma_rx_max_seq)));\n\t    bp = (const u_char *) (ack + 1);\n\t    break;\n\t}\n\n\tcase PGM_SPMR:\n\t    ND_PRINT((ndo, \"SPMR\"));\n\t    break;\n\n\tdefault:\n\t    ND_PRINT((ndo, \"UNKNOWN type 0x%02x\", pgm->pgm_type));\n\t    break;\n\n\t}\n\tif (pgm->pgm_options & PGM_OPT_BIT_PRESENT) {\n\n\t    /*\n\t     * make sure there's enough for the first option header\n\t     */\n\t    if (!ND_TTEST2(*bp, PGM_MIN_OPT_LEN)) {\n\t\tND_PRINT((ndo, \"[|OPT]\"));\n\t\treturn;\n\t    }\n\n\t    /*\n\t     * That option header MUST be an OPT_LENGTH option\n\t     * (see the first paragraph of section 9.1 in RFC 3208).\n\t     */\n\t    opt_type = *bp++;\n\t    if ((opt_type & PGM_OPT_MASK) != PGM_OPT_LENGTH) {\n\t\tND_PRINT((ndo, \"[First option bad, should be PGM_OPT_LENGTH, is %u]\", opt_type & PGM_OPT_MASK));\n\t\treturn;\n\t    }\n\t    opt_len = *bp++;\n\t    if (opt_len != 4) {\n\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != 4]\", opt_len));\n\t\treturn;\n\t    }\n\t    opts_len = EXTRACT_16BITS(bp);\n\t    if (opts_len < 4) {\n\t\tND_PRINT((ndo, \"[Bad total option length %u < 4]\", opts_len));\n\t\treturn;\n\t    }\n\t    bp += sizeof(uint16_t);\n\t    ND_PRINT((ndo, \" OPTS LEN %d\", opts_len));\n\t    opts_len -= 4;\n\n\t    while (opts_len) {\n\t\tif (opts_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n",
        "suffix": "\t\topt_len = *bp++;\n\t\tif (opt_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Bad option, length %u < %u]\", opt_len,\n\t\t        PGM_MIN_OPT_LEN));\n\t\t    break;\n\t\t}\n\t\tif (opts_len < opt_len) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n\t\tif (!ND_TTEST2(*bp, opt_len - 2)) {\n\t\t    ND_PRINT((ndo, \" [|OPT]\"));\n\t\t    return;\n\t\t}\n\n\t\tswitch (opt_type & PGM_OPT_MASK) {\n\t\tcase PGM_OPT_LENGTH:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    ND_PRINT((ndo, \" OPTS LEN (extra?) %d\", EXTRACT_16BITS(bp)));\n\t\t    bp += sizeof(uint16_t);\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_FRAGMENT:\n\t\t    if (opt_len != 16) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FRAGMENT option, length %u != 16]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" FRAG seq %u off %u len %u\", seq, offset, len));\n\t\t    opts_len -= 16;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_LIST:\n\t\t    bp += 2;\n\t\t    opt_len -= sizeof(uint32_t);\t/* option header */\n\t\t    ND_PRINT((ndo, \" NAK LIST\"));\n\t\t    while (opt_len) {\n\t\t\tif (opt_len < sizeof(uint32_t)) {\n\t\t\t    ND_PRINT((ndo, \"[Option length not a multiple of 4]\"));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(uint32_t));\n\t\t\tND_PRINT((ndo, \" %u\", EXTRACT_32BITS(bp)));\n\t\t\tbp += sizeof(uint32_t);\n\t\t\topt_len -= sizeof(uint32_t);\n\t\t\topts_len -= sizeof(uint32_t);\n\t\t    }\n\t\t    break;\n\n\t\tcase PGM_OPT_JOIN:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_JOIN option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" JOIN %u\", seq));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_BO_IVL:\n\t\t    if (opt_len != 12) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_IVL option, length %u != 12]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" BACKOFF ivl %u ivlseq %u\", offset, seq));\n\t\t    opts_len -= 12;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_BO_RNG:\n\t\t    if (opt_len != 12) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_RNG option, length %u != 12]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" BACKOFF max %u min %u\", offset, seq));\n\t\t    opts_len -= 12;\n\t\t    break;\n\n\t\tcase PGM_OPT_REDIRECT:\n\t\t    bp += 2;\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 4 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != 4 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 4 + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 4 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != 4 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 4 + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" REDIRECT %s\",  nla_buf));\n\t\t    break;\n\n\t\tcase PGM_OPT_PARITY_PRM:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_PRM option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" PARITY MAXTGS %u\", len));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_PARITY_GRP:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_GRP option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" PARITY GROUP %u\", seq));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_CURR_TGSIZE:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CURR_TGSIZE option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" PARITY ATGS %u\", len));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_NBR_UNREACH:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NBR_UNREACH option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" NBR_UNREACH\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_PATH_NLA:\n\t\t    ND_PRINT((ndo, \" PATH_NLA [%d]\", opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\n\t\tcase PGM_OPT_SYN:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_SYN option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" SYN\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_FIN:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FIN option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" FIN\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_RST:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_RST option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" RST\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_CR:\n\t\t    ND_PRINT((ndo, \" CR\"));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\n\t\tcase PGM_OPT_CRQST:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CRQST option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" CRQST\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_PGMCC_DATA:\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 12 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 12 + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 12 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 12 + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC DATA %u %s\", offset, nla_buf));\n\t\t    break;\n\n\t\tcase PGM_OPT_PGMCC_FEEDBACK:\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 12 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 12 + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 12 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 12 + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC FEEDBACK %u %s\", offset, nla_buf));\n\t\t    break;\n\n\t\tdefault:\n\t\t    ND_PRINT((ndo, \" OPT_%02X [%d] \", opt_type, opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\t\t}\n\n\t\tif (opt_type & PGM_OPT_END)\n\t\t    break;\n\t     }\n\t}\n\n\tND_PRINT((ndo, \" [%u]\", length));\n\tif (ndo->ndo_packettype == PT_PGM_ZMTP1 &&\n\t    (pgm->pgm_type == PGM_ODATA || pgm->pgm_type == PGM_RDATA))\n\t\tzmtp1_print_datagram(ndo, bp, EXTRACT_16BITS(&pgm->pgm_length));\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pgm]\"));\n\tif (ch != '\\0')\n\t\tND_PRINT((ndo, \">\"));\n}\n",
        "start": 145,
        "end": 784,
        "buggy": "void\npgm_print(netdissect_options *ndo,\n          register const u_char *bp, register u_int length,\n          register const u_char *bp2)\n{\n\tregister const struct pgm_header *pgm;\n\tregister const struct ip *ip;\n\tregister char ch;\n\tuint16_t sport, dport;\n\tu_int nla_afnum;\n\tchar nla_buf[INET6_ADDRSTRLEN];\n\tregister const struct ip6_hdr *ip6;\n\tuint8_t opt_type, opt_len;\n\tuint32_t seq, opts_len, len, offset;\n\n\tpgm = (const struct pgm_header *)bp;\n\tip = (const struct ip *)bp2;\n\tif (IP_V(ip) == 6)\n\t\tip6 = (const struct ip6_hdr *)bp2;\n\telse\n\t\tip6 = NULL;\n\tch = '\\0';\n\tif (!ND_TTEST(pgm->pgm_dport)) {\n\t\tif (ip6) {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst)));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst)));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsport = EXTRACT_16BITS(&pgm->pgm_sport);\n\tdport = EXTRACT_16BITS(&pgm->pgm_dport);\n\n\tif (ip6) {\n\t\tif (ip6->ip6_nxt == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t} else {\n\t\tif (ip->ip_p == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t}\n\n\tND_TCHECK(*pgm);\n\n        ND_PRINT((ndo, \"PGM, length %u\", EXTRACT_16BITS(&pgm->pgm_length)));\n\n        if (!ndo->ndo_vflag)\n            return;\n\n\tND_PRINT((ndo, \" 0x%02x%02x%02x%02x%02x%02x \",\n\t\t     pgm->pgm_gsid[0],\n                     pgm->pgm_gsid[1],\n                     pgm->pgm_gsid[2],\n\t\t     pgm->pgm_gsid[3],\n                     pgm->pgm_gsid[4],\n                     pgm->pgm_gsid[5]));\n\tswitch (pgm->pgm_type) {\n\tcase PGM_SPM: {\n\t    const struct pgm_spm *spm;\n\n\t    spm = (const struct pgm_spm *)(pgm + 1);\n\t    ND_TCHECK(*spm);\n\t    bp = (const u_char *) (spm + 1);\n\n\t    switch (EXTRACT_16BITS(&spm->pgms_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_PRINT((ndo, \"SPM seq %u trail %u lead %u nla %s\",\n\t\t\t EXTRACT_32BITS(&spm->pgms_seq),\n                         EXTRACT_32BITS(&spm->pgms_trailseq),\n\t\t\t EXTRACT_32BITS(&spm->pgms_leadseq),\n                         nla_buf));\n\t    break;\n\t}\n\n\tcase PGM_POLL: {\n\t    const struct pgm_poll *poll_msg;\n\n\t    poll_msg = (const struct pgm_poll *)(pgm + 1);\n\t    ND_TCHECK(*poll_msg);\n\t    ND_PRINT((ndo, \"POLL seq %u round %u\",\n\t\t\t EXTRACT_32BITS(&poll_msg->pgmp_seq),\n                         EXTRACT_16BITS(&poll_msg->pgmp_round)));\n\t    bp = (const u_char *) (poll_msg + 1);\n\t    break;\n\t}\n\tcase PGM_POLR: {\n\t    const struct pgm_polr *polr;\n\t    uint32_t ivl, rnd, mask;\n\n\t    polr = (const struct pgm_polr *)(pgm + 1);\n\t    ND_TCHECK(*polr);\n\t    bp = (const u_char *) (polr + 1);\n\n\t    switch (EXTRACT_16BITS(&polr->pgmp_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    ivl = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    rnd = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    mask = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_PRINT((ndo, \"POLR seq %u round %u nla %s ivl %u rnd 0x%08x \"\n\t\t\t \"mask 0x%08x\", EXTRACT_32BITS(&polr->pgmp_seq),\n\t\t\t EXTRACT_16BITS(&polr->pgmp_round), nla_buf, ivl, rnd, mask));\n\t    break;\n\t}\n\tcase PGM_ODATA: {\n\t    const struct pgm_data *odata;\n\n\t    odata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*odata);\n\t    ND_PRINT((ndo, \"ODATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&odata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&odata->pgmd_seq)));\n\t    bp = (const u_char *) (odata + 1);\n\t    break;\n\t}\n\n\tcase PGM_RDATA: {\n\t    const struct pgm_data *rdata;\n\n\t    rdata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*rdata);\n\t    ND_PRINT((ndo, \"RDATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_seq)));\n\t    bp = (const u_char *) (rdata + 1);\n\t    break;\n\t}\n\n\tcase PGM_NAK:\n\tcase PGM_NULLNAK:\n\tcase PGM_NCF: {\n\t    const struct pgm_nak *nak;\n\t    char source_buf[INET6_ADDRSTRLEN], group_buf[INET6_ADDRSTRLEN];\n\n\t    nak = (const struct pgm_nak *)(pgm + 1);\n\t    ND_TCHECK(*nak);\n\t    bp = (const u_char *) (nak + 1);\n\n\t    /*\n\t     * Skip past the source, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    switch (EXTRACT_16BITS(&nak->pgmn_source_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Skip past the group, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    bp += (2 * sizeof(uint16_t));\n\t    switch (EXTRACT_16BITS(bp)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Options decoding can go here.\n\t     */\n\t    switch (pgm->pgm_type) {\n\t\tcase PGM_NAK:\n\t\t    ND_PRINT((ndo, \"NAK \"));\n\t\t    break;\n\t\tcase PGM_NULLNAK:\n\t\t    ND_PRINT((ndo, \"NNAK \"));\n\t\t    break;\n\t\tcase PGM_NCF:\n\t\t    ND_PRINT((ndo, \"NCF \"));\n\t\t    break;\n\t\tdefault:\n                    break;\n\t    }\n\t    ND_PRINT((ndo, \"(%s -> %s), seq %u\",\n\t\t\t source_buf, group_buf, EXTRACT_32BITS(&nak->pgmn_seq)));\n\t    break;\n\t}\n\n\tcase PGM_ACK: {\n\t    const struct pgm_ack *ack;\n\n\t    ack = (const struct pgm_ack *)(pgm + 1);\n\t    ND_TCHECK(*ack);\n\t    ND_PRINT((ndo, \"ACK seq %u\",\n\t\t\t EXTRACT_32BITS(&ack->pgma_rx_max_seq)));\n\t    bp = (const u_char *) (ack + 1);\n\t    break;\n\t}\n\n\tcase PGM_SPMR:\n\t    ND_PRINT((ndo, \"SPMR\"));\n\t    break;\n\n\tdefault:\n\t    ND_PRINT((ndo, \"UNKNOWN type 0x%02x\", pgm->pgm_type));\n\t    break;\n\n\t}\n\tif (pgm->pgm_options & PGM_OPT_BIT_PRESENT) {\n\n\t    /*\n\t     * make sure there's enough for the first option header\n\t     */\n\t    if (!ND_TTEST2(*bp, PGM_MIN_OPT_LEN)) {\n\t\tND_PRINT((ndo, \"[|OPT]\"));\n\t\treturn;\n\t    }\n\n\t    /*\n\t     * That option header MUST be an OPT_LENGTH option\n\t     * (see the first paragraph of section 9.1 in RFC 3208).\n\t     */\n\t    opt_type = *bp++;\n\t    if ((opt_type & PGM_OPT_MASK) != PGM_OPT_LENGTH) {\n\t\tND_PRINT((ndo, \"[First option bad, should be PGM_OPT_LENGTH, is %u]\", opt_type & PGM_OPT_MASK));\n\t\treturn;\n\t    }\n\t    opt_len = *bp++;\n\t    if (opt_len != 4) {\n\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != 4]\", opt_len));\n\t\treturn;\n\t    }\n\t    opts_len = EXTRACT_16BITS(bp);\n\t    if (opts_len < 4) {\n\t\tND_PRINT((ndo, \"[Bad total option length %u < 4]\", opts_len));\n\t\treturn;\n\t    }\n\t    bp += sizeof(uint16_t);\n\t    ND_PRINT((ndo, \" OPTS LEN %d\", opts_len));\n\t    opts_len -= 4;\n\n\t    while (opts_len) {\n\t\tif (opts_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n\t\topt_type = *bp++;\n\t\topt_len = *bp++;\n\t\tif (opt_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Bad option, length %u < %u]\", opt_len,\n\t\t        PGM_MIN_OPT_LEN));\n\t\t    break;\n\t\t}\n\t\tif (opts_len < opt_len) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n\t\tif (!ND_TTEST2(*bp, opt_len - 2)) {\n\t\t    ND_PRINT((ndo, \" [|OPT]\"));\n\t\t    return;\n\t\t}\n\n\t\tswitch (opt_type & PGM_OPT_MASK) {\n\t\tcase PGM_OPT_LENGTH:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    ND_PRINT((ndo, \" OPTS LEN (extra?) %d\", EXTRACT_16BITS(bp)));\n\t\t    bp += sizeof(uint16_t);\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_FRAGMENT:\n\t\t    if (opt_len != 16) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FRAGMENT option, length %u != 16]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" FRAG seq %u off %u len %u\", seq, offset, len));\n\t\t    opts_len -= 16;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_LIST:\n\t\t    bp += 2;\n\t\t    opt_len -= sizeof(uint32_t);\t/* option header */\n\t\t    ND_PRINT((ndo, \" NAK LIST\"));\n\t\t    while (opt_len) {\n\t\t\tif (opt_len < sizeof(uint32_t)) {\n\t\t\t    ND_PRINT((ndo, \"[Option length not a multiple of 4]\"));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(uint32_t));\n\t\t\tND_PRINT((ndo, \" %u\", EXTRACT_32BITS(bp)));\n\t\t\tbp += sizeof(uint32_t);\n\t\t\topt_len -= sizeof(uint32_t);\n\t\t\topts_len -= sizeof(uint32_t);\n\t\t    }\n\t\t    break;\n\n\t\tcase PGM_OPT_JOIN:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_JOIN option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" JOIN %u\", seq));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_BO_IVL:\n\t\t    if (opt_len != 12) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_IVL option, length %u != 12]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" BACKOFF ivl %u ivlseq %u\", offset, seq));\n\t\t    opts_len -= 12;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_BO_RNG:\n\t\t    if (opt_len != 12) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_RNG option, length %u != 12]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" BACKOFF max %u min %u\", offset, seq));\n\t\t    opts_len -= 12;\n\t\t    break;\n\n\t\tcase PGM_OPT_REDIRECT:\n\t\t    bp += 2;\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 4 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != 4 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 4 + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 4 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != 4 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 4 + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" REDIRECT %s\",  nla_buf));\n\t\t    break;\n\n\t\tcase PGM_OPT_PARITY_PRM:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_PRM option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" PARITY MAXTGS %u\", len));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_PARITY_GRP:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_GRP option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" PARITY GROUP %u\", seq));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_CURR_TGSIZE:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CURR_TGSIZE option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" PARITY ATGS %u\", len));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_NBR_UNREACH:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NBR_UNREACH option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" NBR_UNREACH\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_PATH_NLA:\n\t\t    ND_PRINT((ndo, \" PATH_NLA [%d]\", opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\n\t\tcase PGM_OPT_SYN:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_SYN option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" SYN\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_FIN:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FIN option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" FIN\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_RST:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_RST option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" RST\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_CR:\n\t\t    ND_PRINT((ndo, \" CR\"));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\n\t\tcase PGM_OPT_CRQST:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CRQST option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" CRQST\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_PGMCC_DATA:\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 12 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 12 + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 12 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 12 + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC DATA %u %s\", offset, nla_buf));\n\t\t    break;\n\n\t\tcase PGM_OPT_PGMCC_FEEDBACK:\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 12 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 12 + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 12 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 12 + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC FEEDBACK %u %s\", offset, nla_buf));\n\t\t    break;\n\n\t\tdefault:\n\t\t    ND_PRINT((ndo, \" OPT_%02X [%d] \", opt_type, opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\t\t}\n\n\t\tif (opt_type & PGM_OPT_END)\n\t\t    break;\n\t     }\n\t}\n\n\tND_PRINT((ndo, \" [%u]\", length));\n\tif (ndo->ndo_packettype == PT_PGM_ZMTP1 &&\n\t    (pgm->pgm_type == PGM_ODATA || pgm->pgm_type == PGM_RDATA))\n\t\tzmtp1_print_datagram(ndo, bp, EXTRACT_16BITS(&pgm->pgm_length));\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pgm]\"));\n\tif (ch != '\\0')\n\t\tND_PRINT((ndo, \">\"));\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\topt_type = *bp++;\n",
        "src_path": "26a6799b9ca80508c05cac7a9a3bef922991520b___print-pgm.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/26a6799b9ca80508c05cac7a9a3bef922991520b",
        "commit_msg": "CVE-2017-13018/PGM: Add a missing bounds check.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -519,6 +519,7 @@ esis_snpa_asan-3\tesis_snpa_asan-3.pcap\t\tesis_snpa_asan-3.out\t-v\n esis_snpa_asan-4\tesis_snpa_asan-4.pcap\t\tesis_snpa_asan-4.out\t-v\n esis_snpa_asan-5\tesis_snpa_asan-5.pcap\t\tesis_snpa_asan-5.out\t-v\n dhcp6_reconf_asan\tdhcp6_reconf_asan.pcap\t\tdhcp6_reconf_asan.out\t-v\n+pgm_opts_asan\t\tpgm_opts_asan.pcap\t\tpgm_opts_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/pgm_opts_asan.out",
                "patch": "@@ -0,0 +1,2 @@\n+IP (tos 0x41,ECT(1), id 0, offset 0, flags [none], proto PGM (113), length 32639, options (unknown 89 [bad length 232]), bad cksum 5959 (->9eb9)!)\n+    128.121.89.107 > 89.89.16.63: 128.121.89.107.4 > 89.89.16.63.225: PGM, length 0 0x3414eb1f0022 UNKNOWN type 0x1f OPTS LEN 225 OPT_1F [13]  OPT_06 [26]  PATH_NLA [4] [|OPT]"
            }
        ],
        "error_msg": "    pgm_opts_asan                      : TEST FAILED(exit 256)\n"
    },
    "67c7126062d59729cd421bb38f9594015c9907ba___print-icmp6.c": {
        "prefix": "void\nicmp6_print(netdissect_options *ndo,\n            const u_char *bp, u_int length, const u_char *bp2, int fragmented)\n{\n\tconst struct icmp6_hdr *dp;\n\tconst struct ip6_hdr *ip;\n\tconst struct ip6_hdr *oip;\n\tconst struct udphdr *ouh;\n\tint dport;\n\tconst u_char *ep;\n\tu_int prot;\n\n\tdp = (const struct icmp6_hdr *)bp;\n\tip = (const struct ip6_hdr *)bp2;\n\toip = (const struct ip6_hdr *)(dp + 1);\n\t/* 'ep' points to the end of available data. */\n\tep = ndo->ndo_snapend;\n\n\tND_TCHECK(dp->icmp6_cksum);\n\n\tif (ndo->ndo_vflag && !fragmented) {\n\t\tuint16_t sum, udp_sum;\n\n\t\tif (ND_TTEST2(bp[0], length)) {\n\t\t\tudp_sum = EXTRACT_16BITS(&dp->icmp6_cksum);\n\t\t\tsum = icmp6_cksum(ndo, ip, dp, length);\n\t\t\tif (sum != 0)\n\t\t\t\tND_PRINT((ndo,\"[bad icmp6 cksum 0x%04x -> 0x%04x!] \",\n                                                udp_sum,\n                                                in_cksum_shouldbe(udp_sum, sum)));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo,\"[icmp6 sum ok] \"));\n\t\t}\n\t}\n\n        ND_PRINT((ndo,\"ICMP6, %s\", tok2str(icmp6_type_values,\"unknown icmp6 type (%u)\",dp->icmp6_type)));\n\n        /* display cosmetics: print the packet length for printer that use the vflag now */\n        if (ndo->ndo_vflag && (dp->icmp6_type == ND_ROUTER_SOLICIT ||\n                      dp->icmp6_type == ND_ROUTER_ADVERT ||\n                      dp->icmp6_type == ND_NEIGHBOR_ADVERT ||\n                      dp->icmp6_type == ND_NEIGHBOR_SOLICIT ||\n                      dp->icmp6_type == ND_REDIRECT ||\n                      dp->icmp6_type == ICMP6_HADISCOV_REPLY ||\n                      dp->icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ))\n                ND_PRINT((ndo,\", length %u\", length));\n\n\tswitch (dp->icmp6_type) {\n\tcase ICMP6_DST_UNREACH:\n\t\tND_TCHECK(oip->ip6_dst);\n                ND_PRINT((ndo,\", %s\", tok2str(icmp6_dst_unreach_code_values,\"unknown unreach code (%u)\",dp->icmp6_code)));\n\t\tswitch (dp->icmp6_code) {\n\n\t\tcase ICMP6_DST_UNREACH_NOROUTE: /* fall through */\n\t\tcase ICMP6_DST_UNREACH_ADMIN:\n\t\tcase ICMP6_DST_UNREACH_ADDR:\n                        ND_PRINT((ndo,\" %s\",ip6addr_string(ndo, &oip->ip6_dst)));\n                        break;\n\t\tcase ICMP6_DST_UNREACH_BEYONDSCOPE:\n\t\t\tND_PRINT((ndo,\" %s, source address %s\",\n\t\t\t       ip6addr_string(ndo, &oip->ip6_dst),\n                                  ip6addr_string(ndo, &oip->ip6_src)));\n\t\t\tbreak;\n\t\tcase ICMP6_DST_UNREACH_NOPORT:\n\t\t\tif ((ouh = get_upperlayer(ndo, (const u_char *)oip, &prot))\n\t\t\t    == NULL)\n\t\t\t\tgoto trunc;\n\n\t\t\tdport = EXTRACT_16BITS(&ouh->uh_dport);\n\t\t\tswitch (prot) {\n\t\t\tcase IPPROTO_TCP:\n\t\t\t\tND_PRINT((ndo,\", %s tcp port %s\",\n\t\t\t\t\tip6addr_string(ndo, &oip->ip6_dst),\n                                          tcpport_string(ndo, dport)));\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_UDP:\n\t\t\t\tND_PRINT((ndo,\", %s udp port %s\",\n\t\t\t\t\tip6addr_string(ndo, &oip->ip6_dst),\n                                          udpport_string(ndo, dport)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo,\", %s protocol %d port %d unreachable\",\n\t\t\t\t\tip6addr_string(ndo, &oip->ip6_dst),\n                                          oip->ip6_nxt, dport));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n                  if (ndo->ndo_vflag <= 1) {\n                    print_unknown_data(ndo, bp,\"\\n\\t\",length);\n                    return;\n                  }\n                    break;\n\t\t}\n\t\tbreak;\n\tcase ICMP6_PACKET_TOO_BIG:\n\t\tND_TCHECK(dp->icmp6_mtu);\n\t\tND_PRINT((ndo,\", mtu %u\", EXTRACT_32BITS(&dp->icmp6_mtu)));\n\t\tbreak;\n\tcase ICMP6_TIME_EXCEEDED:\n\t\tND_TCHECK(oip->ip6_dst);\n\t\tswitch (dp->icmp6_code) {\n\t\tcase ICMP6_TIME_EXCEED_TRANSIT:\n\t\t\tND_PRINT((ndo,\" for %s\",\n                                  ip6addr_string(ndo, &oip->ip6_dst)));\n\t\t\tbreak;\n\t\tcase ICMP6_TIME_EXCEED_REASSEMBLY:\n\t\t\tND_PRINT((ndo,\" (reassembly)\"));\n\t\t\tbreak;\n\t\tdefault:\n                        ND_PRINT((ndo,\", unknown code (%u)\", dp->icmp6_code));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMP6_PARAM_PROB:\n\t\tND_TCHECK(oip->ip6_dst);\n\t\tswitch (dp->icmp6_code) {\n\t\tcase ICMP6_PARAMPROB_HEADER:\n                        ND_PRINT((ndo,\", erroneous - octet %u\", EXTRACT_32BITS(&dp->icmp6_pptr)));\n                        break;\n\t\tcase ICMP6_PARAMPROB_NEXTHEADER:\n                        ND_PRINT((ndo,\", next header - octet %u\", EXTRACT_32BITS(&dp->icmp6_pptr)));\n                        break;\n\t\tcase ICMP6_PARAMPROB_OPTION:\n                        ND_PRINT((ndo,\", option - octet %u\", EXTRACT_32BITS(&dp->icmp6_pptr)));\n                        break;\n\t\tdefault:\n                        ND_PRINT((ndo,\", code-#%d\",\n                                  dp->icmp6_code));\n                        break;\n\t\t}\n\t\tbreak;\n\tcase ICMP6_ECHO_REQUEST:\n\tcase ICMP6_ECHO_REPLY:\n                ND_TCHECK(dp->icmp6_seq);\n                ND_PRINT((ndo,\", seq %u\", EXTRACT_16BITS(&dp->icmp6_seq)));\n\t\tbreak;\n\tcase ICMP6_MEMBERSHIP_QUERY:\n\t\tif (length == MLD_MINLEN) {\n\t\t\tmld6_print(ndo, (const u_char *)dp);\n\t\t} else if (length >= MLDV2_MINLEN) {\n\t\t\tND_PRINT((ndo,\" v2\"));\n\t\t\tmldv2_query_print(ndo, (const u_char *)dp, length);\n\t\t} else {\n                        ND_PRINT((ndo,\" unknown-version (len %u) \", length));\n\t\t}\n\t\tbreak;\n\tcase ICMP6_MEMBERSHIP_REPORT:\n\t\tmld6_print(ndo, (const u_char *)dp);\n\t\tbreak;\n\tcase ICMP6_MEMBERSHIP_REDUCTION:\n\t\tmld6_print(ndo, (const u_char *)dp);\n\t\tbreak;\n\tcase ND_ROUTER_SOLICIT:\n#define RTSOLLEN 8\n\t\tif (ndo->ndo_vflag) {\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + RTSOLLEN,\n\t\t\t\t\tlength - RTSOLLEN);\n\t\t}\n\t\tbreak;\n\tcase ND_ROUTER_ADVERT:\n#define RTADVLEN 16\n\t\tif (ndo->ndo_vflag) {\n\t\t\tconst struct nd_router_advert *p;\n\n\t\t\tp = (const struct nd_router_advert *)dp;\n\t\t\tND_TCHECK(p->nd_ra_retransmit);\n\t\t\tND_PRINT((ndo,\"\\n\\thop limit %u, Flags [%s]\" \\\n                                  \", pref %s, router lifetime %us, reachable time %us, retrans time %us\",\n                                  (u_int)p->nd_ra_curhoplimit,\n                                  bittok2str(icmp6_opt_ra_flag_values,\"none\",(p->nd_ra_flags_reserved)),\n                                  get_rtpref(p->nd_ra_flags_reserved),\n                                  EXTRACT_16BITS(&p->nd_ra_router_lifetime),\n                                  EXTRACT_32BITS(&p->nd_ra_reachable),\n                                  EXTRACT_32BITS(&p->nd_ra_retransmit)));\n\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + RTADVLEN,\n\t\t\t\t\tlength - RTADVLEN);\n\t\t}\n\t\tbreak;\n\tcase ND_NEIGHBOR_SOLICIT:\n\t    {\n\t\tconst struct nd_neighbor_solicit *p;\n\t\tp = (const struct nd_neighbor_solicit *)dp;\n\t\tND_TCHECK(p->nd_ns_target);\n\t\tND_PRINT((ndo,\", who has %s\", ip6addr_string(ndo, &p->nd_ns_target)));\n\t\tif (ndo->ndo_vflag) {\n#define NDSOLLEN 24\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + NDSOLLEN,\n\t\t\t\t\tlength - NDSOLLEN);\n\t\t}\n\t    }\n\t\tbreak;\n\tcase ND_NEIGHBOR_ADVERT:\n\t    {\n\t\tconst struct nd_neighbor_advert *p;\n\n\t\tp = (const struct nd_neighbor_advert *)dp;\n\t\tND_TCHECK(p->nd_na_target);\n\t\tND_PRINT((ndo,\", tgt is %s\",\n                          ip6addr_string(ndo, &p->nd_na_target)));\n\t\tif (ndo->ndo_vflag) {\n                        ND_PRINT((ndo,\", Flags [%s]\",\n                                  bittok2str(icmp6_nd_na_flag_values,\n                                             \"none\",\n                                             EXTRACT_32BITS(&p->nd_na_flags_reserved))));\n#define NDADVLEN 24\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + NDADVLEN,\n\t\t\t\t\tlength - NDADVLEN);\n#undef NDADVLEN\n\t\t}\n\t    }\n\t\tbreak;\n\tcase ND_REDIRECT:\n#define RDR(i) ((const struct nd_redirect *)(i))\n                         ND_TCHECK(RDR(dp)->nd_rd_dst);\n                         ND_PRINT((ndo,\", %s\", ip6addr_string(ndo, &RDR(dp)->nd_rd_dst)));\n\t\tND_TCHECK(RDR(dp)->nd_rd_target);\n\t\tND_PRINT((ndo,\" to %s\",\n                          ip6addr_string(ndo, &RDR(dp)->nd_rd_target)));\n#define REDIRECTLEN 40\n\t\tif (ndo->ndo_vflag) {\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + REDIRECTLEN,\n\t\t\t\t\tlength - REDIRECTLEN);\n\t\t}\n\t\tbreak;\n#undef REDIRECTLEN\n#undef RDR\n\tcase ICMP6_ROUTER_RENUMBERING:\n\t\ticmp6_rrenum_print(ndo, bp, ep);\n\t\tbreak;\n\tcase ICMP6_NI_QUERY:\n\tcase ICMP6_NI_REPLY:\n\t\ticmp6_nodeinfo_print(ndo, length, bp, ep);\n\t\tbreak;\n\tcase IND_SOLICIT:\n\tcase IND_ADVERT:\n\t\tbreak;\n\tcase ICMP6_V2_MEMBERSHIP_REPORT:\n\t\tmldv2_report_print(ndo, (const u_char *) dp, length);\n\t\tbreak;\n\tcase ICMP6_MOBILEPREFIX_SOLICIT: /* fall through */\n\tcase ICMP6_HADISCOV_REQUEST:\n                ND_TCHECK(dp->icmp6_data16[0]);\n                ND_PRINT((ndo,\", id 0x%04x\", EXTRACT_16BITS(&dp->icmp6_data16[0])));\n                break;\n\tcase ICMP6_HADISCOV_REPLY:\n\t\tif (ndo->ndo_vflag) {\n\t\t\tconst struct in6_addr *in6;\n\t\t\tconst u_char *cp;\n\n\t\t\tND_TCHECK(dp->icmp6_data16[0]);\n\t\t\tND_PRINT((ndo,\", id 0x%04x\", EXTRACT_16BITS(&dp->icmp6_data16[0])));\n\t\t\tcp = (const u_char *)dp + length;\n\t\t\tin6 = (const struct in6_addr *)(dp + 1);\n\t\t\tfor (; (const u_char *)in6 < cp; in6++) {\n\t\t\t\tND_TCHECK(*in6);\n\t\t\t\tND_PRINT((ndo,\", %s\", ip6addr_string(ndo, in6)));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ICMP6_MOBILEPREFIX_ADVERT:\n\t\tif (ndo->ndo_vflag) {\n\t\t\tND_TCHECK(dp->icmp6_data16[0]);\n\t\t\tND_PRINT((ndo,\", id 0x%04x\", EXTRACT_16BITS(&dp->icmp6_data16[0])));\n",
        "suffix": "\t\t\t\tND_PRINT((ndo,\" \"));\n\t\t\tif (dp->icmp6_data16[1] & 0x80)\n\t\t\t\tND_PRINT((ndo,\"M\"));\n\t\t\tif (dp->icmp6_data16[1] & 0x40)\n\t\t\t\tND_PRINT((ndo,\"O\"));\n#define MPADVLEN 8\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + MPADVLEN,\n\t\t\t\t\tlength - MPADVLEN);\n\t\t}\n\t\tbreak;\n        case ND_RPL_MESSAGE:\n                /* plus 4, because struct icmp6_hdr contains 4 bytes of icmp payload */\n                rpl_print(ndo, dp, &dp->icmp6_data8[0], length-sizeof(struct icmp6_hdr)+4);\n                break;\n\tdefault:\n                ND_PRINT((ndo,\", length %u\", length));\n                if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, bp,\"\\n\\t\", length);\n                return;\n        }\n        if (!ndo->ndo_vflag)\n                ND_PRINT((ndo,\", length %u\", length));\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"[|icmp6]\"));\n}\n",
        "start": 869,
        "end": 1160,
        "buggy": "void\nicmp6_print(netdissect_options *ndo,\n            const u_char *bp, u_int length, const u_char *bp2, int fragmented)\n{\n\tconst struct icmp6_hdr *dp;\n\tconst struct ip6_hdr *ip;\n\tconst struct ip6_hdr *oip;\n\tconst struct udphdr *ouh;\n\tint dport;\n\tconst u_char *ep;\n\tu_int prot;\n\n\tdp = (const struct icmp6_hdr *)bp;\n\tip = (const struct ip6_hdr *)bp2;\n\toip = (const struct ip6_hdr *)(dp + 1);\n\t/* 'ep' points to the end of available data. */\n\tep = ndo->ndo_snapend;\n\n\tND_TCHECK(dp->icmp6_cksum);\n\n\tif (ndo->ndo_vflag && !fragmented) {\n\t\tuint16_t sum, udp_sum;\n\n\t\tif (ND_TTEST2(bp[0], length)) {\n\t\t\tudp_sum = EXTRACT_16BITS(&dp->icmp6_cksum);\n\t\t\tsum = icmp6_cksum(ndo, ip, dp, length);\n\t\t\tif (sum != 0)\n\t\t\t\tND_PRINT((ndo,\"[bad icmp6 cksum 0x%04x -> 0x%04x!] \",\n                                                udp_sum,\n                                                in_cksum_shouldbe(udp_sum, sum)));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo,\"[icmp6 sum ok] \"));\n\t\t}\n\t}\n\n        ND_PRINT((ndo,\"ICMP6, %s\", tok2str(icmp6_type_values,\"unknown icmp6 type (%u)\",dp->icmp6_type)));\n\n        /* display cosmetics: print the packet length for printer that use the vflag now */\n        if (ndo->ndo_vflag && (dp->icmp6_type == ND_ROUTER_SOLICIT ||\n                      dp->icmp6_type == ND_ROUTER_ADVERT ||\n                      dp->icmp6_type == ND_NEIGHBOR_ADVERT ||\n                      dp->icmp6_type == ND_NEIGHBOR_SOLICIT ||\n                      dp->icmp6_type == ND_REDIRECT ||\n                      dp->icmp6_type == ICMP6_HADISCOV_REPLY ||\n                      dp->icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ))\n                ND_PRINT((ndo,\", length %u\", length));\n\n\tswitch (dp->icmp6_type) {\n\tcase ICMP6_DST_UNREACH:\n\t\tND_TCHECK(oip->ip6_dst);\n                ND_PRINT((ndo,\", %s\", tok2str(icmp6_dst_unreach_code_values,\"unknown unreach code (%u)\",dp->icmp6_code)));\n\t\tswitch (dp->icmp6_code) {\n\n\t\tcase ICMP6_DST_UNREACH_NOROUTE: /* fall through */\n\t\tcase ICMP6_DST_UNREACH_ADMIN:\n\t\tcase ICMP6_DST_UNREACH_ADDR:\n                        ND_PRINT((ndo,\" %s\",ip6addr_string(ndo, &oip->ip6_dst)));\n                        break;\n\t\tcase ICMP6_DST_UNREACH_BEYONDSCOPE:\n\t\t\tND_PRINT((ndo,\" %s, source address %s\",\n\t\t\t       ip6addr_string(ndo, &oip->ip6_dst),\n                                  ip6addr_string(ndo, &oip->ip6_src)));\n\t\t\tbreak;\n\t\tcase ICMP6_DST_UNREACH_NOPORT:\n\t\t\tif ((ouh = get_upperlayer(ndo, (const u_char *)oip, &prot))\n\t\t\t    == NULL)\n\t\t\t\tgoto trunc;\n\n\t\t\tdport = EXTRACT_16BITS(&ouh->uh_dport);\n\t\t\tswitch (prot) {\n\t\t\tcase IPPROTO_TCP:\n\t\t\t\tND_PRINT((ndo,\", %s tcp port %s\",\n\t\t\t\t\tip6addr_string(ndo, &oip->ip6_dst),\n                                          tcpport_string(ndo, dport)));\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_UDP:\n\t\t\t\tND_PRINT((ndo,\", %s udp port %s\",\n\t\t\t\t\tip6addr_string(ndo, &oip->ip6_dst),\n                                          udpport_string(ndo, dport)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo,\", %s protocol %d port %d unreachable\",\n\t\t\t\t\tip6addr_string(ndo, &oip->ip6_dst),\n                                          oip->ip6_nxt, dport));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n                  if (ndo->ndo_vflag <= 1) {\n                    print_unknown_data(ndo, bp,\"\\n\\t\",length);\n                    return;\n                  }\n                    break;\n\t\t}\n\t\tbreak;\n\tcase ICMP6_PACKET_TOO_BIG:\n\t\tND_TCHECK(dp->icmp6_mtu);\n\t\tND_PRINT((ndo,\", mtu %u\", EXTRACT_32BITS(&dp->icmp6_mtu)));\n\t\tbreak;\n\tcase ICMP6_TIME_EXCEEDED:\n\t\tND_TCHECK(oip->ip6_dst);\n\t\tswitch (dp->icmp6_code) {\n\t\tcase ICMP6_TIME_EXCEED_TRANSIT:\n\t\t\tND_PRINT((ndo,\" for %s\",\n                                  ip6addr_string(ndo, &oip->ip6_dst)));\n\t\t\tbreak;\n\t\tcase ICMP6_TIME_EXCEED_REASSEMBLY:\n\t\t\tND_PRINT((ndo,\" (reassembly)\"));\n\t\t\tbreak;\n\t\tdefault:\n                        ND_PRINT((ndo,\", unknown code (%u)\", dp->icmp6_code));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMP6_PARAM_PROB:\n\t\tND_TCHECK(oip->ip6_dst);\n\t\tswitch (dp->icmp6_code) {\n\t\tcase ICMP6_PARAMPROB_HEADER:\n                        ND_PRINT((ndo,\", erroneous - octet %u\", EXTRACT_32BITS(&dp->icmp6_pptr)));\n                        break;\n\t\tcase ICMP6_PARAMPROB_NEXTHEADER:\n                        ND_PRINT((ndo,\", next header - octet %u\", EXTRACT_32BITS(&dp->icmp6_pptr)));\n                        break;\n\t\tcase ICMP6_PARAMPROB_OPTION:\n                        ND_PRINT((ndo,\", option - octet %u\", EXTRACT_32BITS(&dp->icmp6_pptr)));\n                        break;\n\t\tdefault:\n                        ND_PRINT((ndo,\", code-#%d\",\n                                  dp->icmp6_code));\n                        break;\n\t\t}\n\t\tbreak;\n\tcase ICMP6_ECHO_REQUEST:\n\tcase ICMP6_ECHO_REPLY:\n                ND_TCHECK(dp->icmp6_seq);\n                ND_PRINT((ndo,\", seq %u\", EXTRACT_16BITS(&dp->icmp6_seq)));\n\t\tbreak;\n\tcase ICMP6_MEMBERSHIP_QUERY:\n\t\tif (length == MLD_MINLEN) {\n\t\t\tmld6_print(ndo, (const u_char *)dp);\n\t\t} else if (length >= MLDV2_MINLEN) {\n\t\t\tND_PRINT((ndo,\" v2\"));\n\t\t\tmldv2_query_print(ndo, (const u_char *)dp, length);\n\t\t} else {\n                        ND_PRINT((ndo,\" unknown-version (len %u) \", length));\n\t\t}\n\t\tbreak;\n\tcase ICMP6_MEMBERSHIP_REPORT:\n\t\tmld6_print(ndo, (const u_char *)dp);\n\t\tbreak;\n\tcase ICMP6_MEMBERSHIP_REDUCTION:\n\t\tmld6_print(ndo, (const u_char *)dp);\n\t\tbreak;\n\tcase ND_ROUTER_SOLICIT:\n#define RTSOLLEN 8\n\t\tif (ndo->ndo_vflag) {\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + RTSOLLEN,\n\t\t\t\t\tlength - RTSOLLEN);\n\t\t}\n\t\tbreak;\n\tcase ND_ROUTER_ADVERT:\n#define RTADVLEN 16\n\t\tif (ndo->ndo_vflag) {\n\t\t\tconst struct nd_router_advert *p;\n\n\t\t\tp = (const struct nd_router_advert *)dp;\n\t\t\tND_TCHECK(p->nd_ra_retransmit);\n\t\t\tND_PRINT((ndo,\"\\n\\thop limit %u, Flags [%s]\" \\\n                                  \", pref %s, router lifetime %us, reachable time %us, retrans time %us\",\n                                  (u_int)p->nd_ra_curhoplimit,\n                                  bittok2str(icmp6_opt_ra_flag_values,\"none\",(p->nd_ra_flags_reserved)),\n                                  get_rtpref(p->nd_ra_flags_reserved),\n                                  EXTRACT_16BITS(&p->nd_ra_router_lifetime),\n                                  EXTRACT_32BITS(&p->nd_ra_reachable),\n                                  EXTRACT_32BITS(&p->nd_ra_retransmit)));\n\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + RTADVLEN,\n\t\t\t\t\tlength - RTADVLEN);\n\t\t}\n\t\tbreak;\n\tcase ND_NEIGHBOR_SOLICIT:\n\t    {\n\t\tconst struct nd_neighbor_solicit *p;\n\t\tp = (const struct nd_neighbor_solicit *)dp;\n\t\tND_TCHECK(p->nd_ns_target);\n\t\tND_PRINT((ndo,\", who has %s\", ip6addr_string(ndo, &p->nd_ns_target)));\n\t\tif (ndo->ndo_vflag) {\n#define NDSOLLEN 24\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + NDSOLLEN,\n\t\t\t\t\tlength - NDSOLLEN);\n\t\t}\n\t    }\n\t\tbreak;\n\tcase ND_NEIGHBOR_ADVERT:\n\t    {\n\t\tconst struct nd_neighbor_advert *p;\n\n\t\tp = (const struct nd_neighbor_advert *)dp;\n\t\tND_TCHECK(p->nd_na_target);\n\t\tND_PRINT((ndo,\", tgt is %s\",\n                          ip6addr_string(ndo, &p->nd_na_target)));\n\t\tif (ndo->ndo_vflag) {\n                        ND_PRINT((ndo,\", Flags [%s]\",\n                                  bittok2str(icmp6_nd_na_flag_values,\n                                             \"none\",\n                                             EXTRACT_32BITS(&p->nd_na_flags_reserved))));\n#define NDADVLEN 24\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + NDADVLEN,\n\t\t\t\t\tlength - NDADVLEN);\n#undef NDADVLEN\n\t\t}\n\t    }\n\t\tbreak;\n\tcase ND_REDIRECT:\n#define RDR(i) ((const struct nd_redirect *)(i))\n                         ND_TCHECK(RDR(dp)->nd_rd_dst);\n                         ND_PRINT((ndo,\", %s\", ip6addr_string(ndo, &RDR(dp)->nd_rd_dst)));\n\t\tND_TCHECK(RDR(dp)->nd_rd_target);\n\t\tND_PRINT((ndo,\" to %s\",\n                          ip6addr_string(ndo, &RDR(dp)->nd_rd_target)));\n#define REDIRECTLEN 40\n\t\tif (ndo->ndo_vflag) {\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + REDIRECTLEN,\n\t\t\t\t\tlength - REDIRECTLEN);\n\t\t}\n\t\tbreak;\n#undef REDIRECTLEN\n#undef RDR\n\tcase ICMP6_ROUTER_RENUMBERING:\n\t\ticmp6_rrenum_print(ndo, bp, ep);\n\t\tbreak;\n\tcase ICMP6_NI_QUERY:\n\tcase ICMP6_NI_REPLY:\n\t\ticmp6_nodeinfo_print(ndo, length, bp, ep);\n\t\tbreak;\n\tcase IND_SOLICIT:\n\tcase IND_ADVERT:\n\t\tbreak;\n\tcase ICMP6_V2_MEMBERSHIP_REPORT:\n\t\tmldv2_report_print(ndo, (const u_char *) dp, length);\n\t\tbreak;\n\tcase ICMP6_MOBILEPREFIX_SOLICIT: /* fall through */\n\tcase ICMP6_HADISCOV_REQUEST:\n                ND_TCHECK(dp->icmp6_data16[0]);\n                ND_PRINT((ndo,\", id 0x%04x\", EXTRACT_16BITS(&dp->icmp6_data16[0])));\n                break;\n\tcase ICMP6_HADISCOV_REPLY:\n\t\tif (ndo->ndo_vflag) {\n\t\t\tconst struct in6_addr *in6;\n\t\t\tconst u_char *cp;\n\n\t\t\tND_TCHECK(dp->icmp6_data16[0]);\n\t\t\tND_PRINT((ndo,\", id 0x%04x\", EXTRACT_16BITS(&dp->icmp6_data16[0])));\n\t\t\tcp = (const u_char *)dp + length;\n\t\t\tin6 = (const struct in6_addr *)(dp + 1);\n\t\t\tfor (; (const u_char *)in6 < cp; in6++) {\n\t\t\t\tND_TCHECK(*in6);\n\t\t\t\tND_PRINT((ndo,\", %s\", ip6addr_string(ndo, in6)));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ICMP6_MOBILEPREFIX_ADVERT:\n\t\tif (ndo->ndo_vflag) {\n\t\t\tND_TCHECK(dp->icmp6_data16[0]);\n\t\t\tND_PRINT((ndo,\", id 0x%04x\", EXTRACT_16BITS(&dp->icmp6_data16[0])));\n\t\t\tif (dp->icmp6_data16[1] & 0xc0)\n\t\t\t\tND_PRINT((ndo,\" \"));\n\t\t\tif (dp->icmp6_data16[1] & 0x80)\n\t\t\t\tND_PRINT((ndo,\"M\"));\n\t\t\tif (dp->icmp6_data16[1] & 0x40)\n\t\t\t\tND_PRINT((ndo,\"O\"));\n#define MPADVLEN 8\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + MPADVLEN,\n\t\t\t\t\tlength - MPADVLEN);\n\t\t}\n\t\tbreak;\n        case ND_RPL_MESSAGE:\n                /* plus 4, because struct icmp6_hdr contains 4 bytes of icmp payload */\n                rpl_print(ndo, dp, &dp->icmp6_data8[0], length-sizeof(struct icmp6_hdr)+4);\n                break;\n\tdefault:\n                ND_PRINT((ndo,\", length %u\", length));\n                if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, bp,\"\\n\\t\", length);\n                return;\n        }\n        if (!ndo->ndo_vflag)\n                ND_PRINT((ndo,\", length %u\", length));\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"[|icmp6]\"));\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tif (dp->icmp6_data16[1] & 0xc0)\n",
        "src_path": "67c7126062d59729cd421bb38f9594015c9907ba___print-icmp6.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/67c7126062d59729cd421bb38f9594015c9907ba",
        "commit_msg": "CVE-2017-13021/ICMP6: Add a missing bounds check.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -522,6 +522,7 @@ dhcp6_reconf_asan\tdhcp6_reconf_asan.pcap\t\tdhcp6_reconf_asan.out\t-v\n pgm_opts_asan\t\tpgm_opts_asan.pcap\t\tpgm_opts_asan.out\t-v\n pgm_opts_asan_2\t\tpgm_opts_asan_2.pcap\t\tpgm_opts_asan_2.out\t-v\n vtp_asan\t\tvtp_asan.pcap\t\t\tvtp_asan.out\t-v\n+icmp6_mobileprefix_asan\ticmp6_mobileprefix_asan.pcap\ticmp6_mobileprefix_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/icmp6_mobileprefix_asan.out",
                "patch": "@@ -0,0 +1,2 @@\n+IP6 (class 0x50, flowlabel 0x0002c, hlim 0, next-header ICMPv6 (58) payload length: 7168) 4f:f829:c:1a1a:1a1a:1a1a:1a37:0 > 16:0:400:0:64fb:9303:f293:8200: ICMP6, mobile router advertisement, length 7168, id 0x9393[|icmp6]\n+[|ether]"
            }
        ],
        "error_msg": "    icmp6_mobileprefix_asan            : TEST FAILED(exit 256)\n"
    },
    "b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00___print-mobility.c": {
        "prefix": "static int\nmobility_opt_print(netdissect_options *ndo,\n                   const u_char *bp, const unsigned len)\n{\n\tunsigned i, optlen;\n\n\tfor (i = 0; i < len; i += optlen) {\n\t\tND_TCHECK(bp[i]);\n\t\tif (bp[i] == IP6MOPT_PAD1)\n\t\t\toptlen = 1;\n\t\telse {\n\t\t\tif (i + 1 < len) {\n\t\t\t\tND_TCHECK(bp[i + 1]);\n\t\t\t\toptlen = bp[i + 1] + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto trunc;\n\t\t}\n\t\tif (i + optlen > len)\n\t\t\tgoto trunc;\n\t\tND_TCHECK(bp[i + optlen]);\n\n\t\tswitch (bp[i]) {\n\t\tcase IP6MOPT_PAD1:\n\t\t\tND_PRINT((ndo, \"(pad1)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_PADN:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(padn: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(padn)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_REFRESH:\n\t\t\tif (len - i < IP6MOPT_REFRESH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(refresh: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\t/* units of 4 secs */\n",
        "suffix": "\t\t\t\tEXTRACT_16BITS(&bp[i+2]) << 2));\n\t\t\tbreak;\n\t\tcase IP6MOPT_ALTCOA:\n\t\t\tif (len - i < IP6MOPT_ALTCOA_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(altcoa: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(alt-CoA: %s)\", ip6addr_string(ndo, &bp[i+2])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_NONCEID:\n\t\t\tif (len - i < IP6MOPT_NONCEID_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(ni: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(ni: ho=0x%04x co=0x%04x)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]),\n\t\t\t\tEXTRACT_16BITS(&bp[i+4])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_AUTH:\n\t\t\tif (len - i < IP6MOPT_AUTH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(auth: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(auth)\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(sopt_type %u: trunc)\", bp[i]));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(type-0x%02x: len=%u)\", bp[i], bp[i + 1]));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n\ntrunc:\n\treturn 1;\n}\n",
        "start": 114,
        "end": 192,
        "buggy": "static int\nmobility_opt_print(netdissect_options *ndo,\n                   const u_char *bp, const unsigned len)\n{\n\tunsigned i, optlen;\n\n\tfor (i = 0; i < len; i += optlen) {\n\t\tND_TCHECK(bp[i]);\n\t\tif (bp[i] == IP6MOPT_PAD1)\n\t\t\toptlen = 1;\n\t\telse {\n\t\t\tif (i + 1 < len) {\n\t\t\t\tND_TCHECK(bp[i + 1]);\n\t\t\t\toptlen = bp[i + 1] + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto trunc;\n\t\t}\n\t\tif (i + optlen > len)\n\t\t\tgoto trunc;\n\t\tND_TCHECK(bp[i + optlen]);\n\n\t\tswitch (bp[i]) {\n\t\tcase IP6MOPT_PAD1:\n\t\t\tND_PRINT((ndo, \"(pad1)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_PADN:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(padn: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(padn)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_REFRESH:\n\t\t\tif (len - i < IP6MOPT_REFRESH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(refresh: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\t/* units of 4 secs */\n\t\t\tND_PRINT((ndo, \"(refresh: %u)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]) << 2));\n\t\t\tbreak;\n\t\tcase IP6MOPT_ALTCOA:\n\t\t\tif (len - i < IP6MOPT_ALTCOA_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(altcoa: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(alt-CoA: %s)\", ip6addr_string(ndo, &bp[i+2])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_NONCEID:\n\t\t\tif (len - i < IP6MOPT_NONCEID_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(ni: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(ni: ho=0x%04x co=0x%04x)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]),\n\t\t\t\tEXTRACT_16BITS(&bp[i+4])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_AUTH:\n\t\t\tif (len - i < IP6MOPT_AUTH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(auth: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(auth)\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(sopt_type %u: trunc)\", bp[i]));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(type-0x%02x: len=%u)\", bp[i], bp[i + 1]));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n\ntrunc:\n\treturn 1;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tND_PRINT((ndo, \"(refresh: %u)\",\n",
        "src_path": "b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00___print-mobility.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00",
        "commit_msg": "CVE-2017-13023/IPv6 mobility: Add a bounds check before fetching data\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't cause 'tcpdump: pcap_loop: truncated dump file'",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -524,6 +524,7 @@ pgm_opts_asan_2\t\tpgm_opts_asan_2.pcap\t\tpgm_opts_asan_2.out\t-v\n vtp_asan\t\tvtp_asan.pcap\t\t\tvtp_asan.out\t-v\n icmp6_mobileprefix_asan\ticmp6_mobileprefix_asan.pcap\ticmp6_mobileprefix_asan.out\t-v\n ip_printroute_asan\tip_printroute_asan.pcap\t\tip_printroute_asan.out\t-v\n+mobility_opt_asan\tmobility_opt_asan.pcap\t\tmobility_opt_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/mobility_opt_asan.out",
                "patch": "@@ -0,0 +1,2 @@\n+IP6 (class 0x50, flowlabel 0x00004, hlim 0, next-header Mobile IP (old) (62) payload length: 7168) d400:7fa1:0:400::6238:2949 > 9675:86dd:7300:2c:1c7f:ffff:ffc3:b2a1: mobility: BU seq#=116 A lifetime=15872(pad1)[|MOBILITY]\n+IP6 (class 0x50, flowlabel 0x00004, hlim 0, next-header Mobile IP (old) (62) payload length: 7168) d4c3:b2a1:200:400::6238:2949 > 9675:86dd:73f0:2c:1c7f:ffff:ebc3:b291: mobility: BU seq#=116 A lifetime=15360[|MOBILITY]"
            }
        ],
        "error_msg": "    mobility_opt_asan                  : TEST FAILED(exit 256)\n"
    },
    "7d3aba9f06899d0128ef46e8a2fa143c6fad8f62___print-mobility.c": {
        "prefix": "static int\nmobility_opt_print(netdissect_options *ndo,\n                   const u_char *bp, const unsigned len)\n{\n\tunsigned i, optlen;\n\n\tfor (i = 0; i < len; i += optlen) {\n\t\tND_TCHECK(bp[i]);\n\t\tif (bp[i] == IP6MOPT_PAD1)\n\t\t\toptlen = 1;\n\t\telse {\n\t\t\tif (i + 1 < len) {\n\t\t\t\tND_TCHECK(bp[i + 1]);\n\t\t\t\toptlen = bp[i + 1] + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto trunc;\n\t\t}\n\t\tif (i + optlen > len)\n\t\t\tgoto trunc;\n\t\tND_TCHECK(bp[i + optlen]);\n\n\t\tswitch (bp[i]) {\n\t\tcase IP6MOPT_PAD1:\n\t\t\tND_PRINT((ndo, \"(pad1)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_PADN:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(padn: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(padn)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_REFRESH:\n\t\t\tif (len - i < IP6MOPT_REFRESH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(refresh: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\t/* units of 4 secs */\n\t\t\tND_TCHECK_16BITS(&bp[i+2]);\n\t\t\tND_PRINT((ndo, \"(refresh: %u)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]) << 2));\n\t\t\tbreak;\n\t\tcase IP6MOPT_ALTCOA:\n\t\t\tif (len - i < IP6MOPT_ALTCOA_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(altcoa: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(alt-CoA: %s)\", ip6addr_string(ndo, &bp[i+2])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_NONCEID:\n\t\t\tif (len - i < IP6MOPT_NONCEID_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(ni: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n",
        "suffix": "\t\t\t\tEXTRACT_16BITS(&bp[i+2]),\n\t\t\t\tEXTRACT_16BITS(&bp[i+4])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_AUTH:\n\t\t\tif (len - i < IP6MOPT_AUTH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(auth: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(auth)\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(sopt_type %u: trunc)\", bp[i]));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(type-0x%02x: len=%u)\", bp[i], bp[i + 1]));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n\ntrunc:\n\treturn 1;\n}\n",
        "start": 114,
        "end": 193,
        "buggy": "static int\nmobility_opt_print(netdissect_options *ndo,\n                   const u_char *bp, const unsigned len)\n{\n\tunsigned i, optlen;\n\n\tfor (i = 0; i < len; i += optlen) {\n\t\tND_TCHECK(bp[i]);\n\t\tif (bp[i] == IP6MOPT_PAD1)\n\t\t\toptlen = 1;\n\t\telse {\n\t\t\tif (i + 1 < len) {\n\t\t\t\tND_TCHECK(bp[i + 1]);\n\t\t\t\toptlen = bp[i + 1] + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto trunc;\n\t\t}\n\t\tif (i + optlen > len)\n\t\t\tgoto trunc;\n\t\tND_TCHECK(bp[i + optlen]);\n\n\t\tswitch (bp[i]) {\n\t\tcase IP6MOPT_PAD1:\n\t\t\tND_PRINT((ndo, \"(pad1)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_PADN:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(padn: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(padn)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_REFRESH:\n\t\t\tif (len - i < IP6MOPT_REFRESH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(refresh: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\t/* units of 4 secs */\n\t\t\tND_TCHECK_16BITS(&bp[i+2]);\n\t\t\tND_PRINT((ndo, \"(refresh: %u)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]) << 2));\n\t\t\tbreak;\n\t\tcase IP6MOPT_ALTCOA:\n\t\t\tif (len - i < IP6MOPT_ALTCOA_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(altcoa: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(alt-CoA: %s)\", ip6addr_string(ndo, &bp[i+2])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_NONCEID:\n\t\t\tif (len - i < IP6MOPT_NONCEID_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(ni: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(ni: ho=0x%04x co=0x%04x)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]),\n\t\t\t\tEXTRACT_16BITS(&bp[i+4])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_AUTH:\n\t\t\tif (len - i < IP6MOPT_AUTH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(auth: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(auth)\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(sopt_type %u: trunc)\", bp[i]));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(type-0x%02x: len=%u)\", bp[i], bp[i + 1]));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n\ntrunc:\n\treturn 1;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tND_PRINT((ndo, \"(ni: ho=0x%04x co=0x%04x)\",\n",
        "src_path": "7d3aba9f06899d0128ef46e8a2fa143c6fad8f62___print-mobility.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/7d3aba9f06899d0128ef46e8a2fa143c6fad8f62",
        "commit_msg": "CVE-2017-13024/IPv6 mobility: Add a bounds check before fetching data\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't cause 'tcpdump: pcap_loop: truncated dump file'",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -525,6 +525,7 @@ vtp_asan\t\tvtp_asan.pcap\t\t\tvtp_asan.out\t-v\n icmp6_mobileprefix_asan\ticmp6_mobileprefix_asan.pcap\ticmp6_mobileprefix_asan.out\t-v\n ip_printroute_asan\tip_printroute_asan.pcap\t\tip_printroute_asan.out\t-v\n mobility_opt_asan\tmobility_opt_asan.pcap\t\tmobility_opt_asan.out\t-v\n+mobility_opt_asan_2\tmobility_opt_asan_2.pcap\tmobility_opt_asan_2.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/mobility_opt_asan_2.out",
                "patch": "@@ -0,0 +1 @@\n+IP6 (class 0x50, flowlabel 0x0002c, hlim 0, next-header Mobile IP (old) (62) payload length: 7168) ff:7f0f:40:0:ee00:0:b658:5203 > 205:20:1:b00:0:2200:af01:e000: mobility: BRR(type-0x06: len=0)[|MOBILITY]"
            }
        ],
        "error_msg": "    mobility_opt_asan_2                : TEST FAILED(exit 256)\n"
    },
    "29e5470e6ab84badbc31f4532bb7554a796d9d52___print-bootp.c": {
        "prefix": "void\nbootp_print(netdissect_options *ndo,\n\t    register const u_char *cp, u_int length)\n{\n\tregister const struct bootp *bp;\n\tstatic const u_char vm_cmu[4] = VM_CMU;\n\tstatic const u_char vm_rfc1048[4] = VM_RFC1048;\n\n\tbp = (const struct bootp *)cp;\n\tND_TCHECK(bp->bp_op);\n\n\tND_PRINT((ndo, \"BOOTP/DHCP, %s\",\n\t\t  tok2str(bootp_op_values, \"unknown (0x%02x)\", bp->bp_op)));\n\n\tND_TCHECK(bp->bp_hlen);\n\tif (bp->bp_htype == 1 && bp->bp_hlen == 6 && bp->bp_op == BOOTPREQUEST) {\n\t\tND_TCHECK2(bp->bp_chaddr[0], 6);\n\t\tND_PRINT((ndo, \" from %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n\t}\n\n\tND_PRINT((ndo, \", length %u\", length));\n\n\tif (!ndo->ndo_vflag)\n\t\treturn;\n\n\tND_TCHECK(bp->bp_secs);\n\n\t/* The usual hardware address type is 1 (10Mb Ethernet) */\n\tif (bp->bp_htype != 1)\n\t\tND_PRINT((ndo, \", htype %d\", bp->bp_htype));\n\n\t/* The usual length for 10Mb Ethernet address is 6 bytes */\n\tif (bp->bp_htype != 1 || bp->bp_hlen != 6)\n\t\tND_PRINT((ndo, \", hlen %d\", bp->bp_hlen));\n\n\t/* Only print interesting fields */\n\tif (bp->bp_hops)\n\t\tND_PRINT((ndo, \", hops %d\", bp->bp_hops));\n\tif (EXTRACT_32BITS(&bp->bp_xid))\n\t\tND_PRINT((ndo, \", xid 0x%x\", EXTRACT_32BITS(&bp->bp_xid)));\n\tif (EXTRACT_16BITS(&bp->bp_secs))\n\t\tND_PRINT((ndo, \", secs %d\", EXTRACT_16BITS(&bp->bp_secs)));\n\n",
        "suffix": "\t\t  bittok2str(bootp_flag_values, \"none\", EXTRACT_16BITS(&bp->bp_flags))));\n\tif (ndo->ndo_vflag > 1)\n\t\tND_PRINT((ndo, \" (0x%04x)\", EXTRACT_16BITS(&bp->bp_flags)));\n\n\t/* Client's ip address */\n\tND_TCHECK(bp->bp_ciaddr);\n\tif (EXTRACT_32BITS(&bp->bp_ciaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Client-IP %s\", ipaddr_string(ndo, &bp->bp_ciaddr)));\n\n\t/* 'your' ip address (bootp client) */\n\tND_TCHECK(bp->bp_yiaddr);\n\tif (EXTRACT_32BITS(&bp->bp_yiaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Your-IP %s\", ipaddr_string(ndo, &bp->bp_yiaddr)));\n\n\t/* Server's ip address */\n\tND_TCHECK(bp->bp_siaddr);\n\tif (EXTRACT_32BITS(&bp->bp_siaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Server-IP %s\", ipaddr_string(ndo, &bp->bp_siaddr)));\n\n\t/* Gateway's ip address */\n\tND_TCHECK(bp->bp_giaddr);\n\tif (EXTRACT_32BITS(&bp->bp_giaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Gateway-IP %s\", ipaddr_string(ndo, &bp->bp_giaddr)));\n\n\t/* Client's Ethernet address */\n\tif (bp->bp_htype == 1 && bp->bp_hlen == 6) {\n\t\tND_TCHECK2(bp->bp_chaddr[0], 6);\n\t\tND_PRINT((ndo, \"\\n\\t  Client-Ethernet-Address %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n\t}\n\n\tND_TCHECK2(bp->bp_sname[0], 1);\t\t/* check first char only */\n\tif (*bp->bp_sname) {\n\t\tND_PRINT((ndo, \"\\n\\t  sname \\\"\"));\n\t\tif (fn_printztn(ndo, bp->bp_sname, (u_int)sizeof bp->bp_sname,\n\t\t    ndo->ndo_snapend)) {\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tND_PRINT((ndo, \"%s\", tstr + 1));\n\t\t\treturn;\n\t\t}\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\tND_TCHECK2(bp->bp_file[0], 1);\t\t/* check first char only */\n\tif (*bp->bp_file) {\n\t\tND_PRINT((ndo, \"\\n\\t  file \\\"\"));\n\t\tif (fn_printztn(ndo, bp->bp_file, (u_int)sizeof bp->bp_file,\n\t\t    ndo->ndo_snapend)) {\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tND_PRINT((ndo, \"%s\", tstr + 1));\n\t\t\treturn;\n\t\t}\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\n\t/* Decode the vendor buffer */\n\tND_TCHECK(bp->bp_vend[0]);\n\tif (memcmp((const char *)bp->bp_vend, vm_rfc1048,\n\t\t    sizeof(uint32_t)) == 0)\n\t\trfc1048_print(ndo, bp->bp_vend);\n\telse if (memcmp((const char *)bp->bp_vend, vm_cmu,\n\t\t\tsizeof(uint32_t)) == 0)\n\t\tcmu_print(ndo, bp->bp_vend);\n\telse {\n\t\tuint32_t ul;\n\n\t\tul = EXTRACT_32BITS(&bp->bp_vend);\n\t\tif (ul != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  Vendor-#0x%x\", ul));\n\t}\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n",
        "start": 282,
        "end": 398,
        "buggy": "void\nbootp_print(netdissect_options *ndo,\n\t    register const u_char *cp, u_int length)\n{\n\tregister const struct bootp *bp;\n\tstatic const u_char vm_cmu[4] = VM_CMU;\n\tstatic const u_char vm_rfc1048[4] = VM_RFC1048;\n\n\tbp = (const struct bootp *)cp;\n\tND_TCHECK(bp->bp_op);\n\n\tND_PRINT((ndo, \"BOOTP/DHCP, %s\",\n\t\t  tok2str(bootp_op_values, \"unknown (0x%02x)\", bp->bp_op)));\n\n\tND_TCHECK(bp->bp_hlen);\n\tif (bp->bp_htype == 1 && bp->bp_hlen == 6 && bp->bp_op == BOOTPREQUEST) {\n\t\tND_TCHECK2(bp->bp_chaddr[0], 6);\n\t\tND_PRINT((ndo, \" from %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n\t}\n\n\tND_PRINT((ndo, \", length %u\", length));\n\n\tif (!ndo->ndo_vflag)\n\t\treturn;\n\n\tND_TCHECK(bp->bp_secs);\n\n\t/* The usual hardware address type is 1 (10Mb Ethernet) */\n\tif (bp->bp_htype != 1)\n\t\tND_PRINT((ndo, \", htype %d\", bp->bp_htype));\n\n\t/* The usual length for 10Mb Ethernet address is 6 bytes */\n\tif (bp->bp_htype != 1 || bp->bp_hlen != 6)\n\t\tND_PRINT((ndo, \", hlen %d\", bp->bp_hlen));\n\n\t/* Only print interesting fields */\n\tif (bp->bp_hops)\n\t\tND_PRINT((ndo, \", hops %d\", bp->bp_hops));\n\tif (EXTRACT_32BITS(&bp->bp_xid))\n\t\tND_PRINT((ndo, \", xid 0x%x\", EXTRACT_32BITS(&bp->bp_xid)));\n\tif (EXTRACT_16BITS(&bp->bp_secs))\n\t\tND_PRINT((ndo, \", secs %d\", EXTRACT_16BITS(&bp->bp_secs)));\n\n\tND_PRINT((ndo, \", Flags [%s]\",\n\t\t  bittok2str(bootp_flag_values, \"none\", EXTRACT_16BITS(&bp->bp_flags))));\n\tif (ndo->ndo_vflag > 1)\n\t\tND_PRINT((ndo, \" (0x%04x)\", EXTRACT_16BITS(&bp->bp_flags)));\n\n\t/* Client's ip address */\n\tND_TCHECK(bp->bp_ciaddr);\n\tif (EXTRACT_32BITS(&bp->bp_ciaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Client-IP %s\", ipaddr_string(ndo, &bp->bp_ciaddr)));\n\n\t/* 'your' ip address (bootp client) */\n\tND_TCHECK(bp->bp_yiaddr);\n\tif (EXTRACT_32BITS(&bp->bp_yiaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Your-IP %s\", ipaddr_string(ndo, &bp->bp_yiaddr)));\n\n\t/* Server's ip address */\n\tND_TCHECK(bp->bp_siaddr);\n\tif (EXTRACT_32BITS(&bp->bp_siaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Server-IP %s\", ipaddr_string(ndo, &bp->bp_siaddr)));\n\n\t/* Gateway's ip address */\n\tND_TCHECK(bp->bp_giaddr);\n\tif (EXTRACT_32BITS(&bp->bp_giaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Gateway-IP %s\", ipaddr_string(ndo, &bp->bp_giaddr)));\n\n\t/* Client's Ethernet address */\n\tif (bp->bp_htype == 1 && bp->bp_hlen == 6) {\n\t\tND_TCHECK2(bp->bp_chaddr[0], 6);\n\t\tND_PRINT((ndo, \"\\n\\t  Client-Ethernet-Address %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n\t}\n\n\tND_TCHECK2(bp->bp_sname[0], 1);\t\t/* check first char only */\n\tif (*bp->bp_sname) {\n\t\tND_PRINT((ndo, \"\\n\\t  sname \\\"\"));\n\t\tif (fn_printztn(ndo, bp->bp_sname, (u_int)sizeof bp->bp_sname,\n\t\t    ndo->ndo_snapend)) {\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tND_PRINT((ndo, \"%s\", tstr + 1));\n\t\t\treturn;\n\t\t}\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\tND_TCHECK2(bp->bp_file[0], 1);\t\t/* check first char only */\n\tif (*bp->bp_file) {\n\t\tND_PRINT((ndo, \"\\n\\t  file \\\"\"));\n\t\tif (fn_printztn(ndo, bp->bp_file, (u_int)sizeof bp->bp_file,\n\t\t    ndo->ndo_snapend)) {\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tND_PRINT((ndo, \"%s\", tstr + 1));\n\t\t\treturn;\n\t\t}\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\n\t/* Decode the vendor buffer */\n\tND_TCHECK(bp->bp_vend[0]);\n\tif (memcmp((const char *)bp->bp_vend, vm_rfc1048,\n\t\t    sizeof(uint32_t)) == 0)\n\t\trfc1048_print(ndo, bp->bp_vend);\n\telse if (memcmp((const char *)bp->bp_vend, vm_cmu,\n\t\t\tsizeof(uint32_t)) == 0)\n\t\tcmu_print(ndo, bp->bp_vend);\n\telse {\n\t\tuint32_t ul;\n\n\t\tul = EXTRACT_32BITS(&bp->bp_vend);\n\t\tif (ul != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  Vendor-#0x%x\", ul));\n\t}\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\tND_PRINT((ndo, \", Flags [%s]\",\n",
        "src_path": "29e5470e6ab84badbc31f4532bb7554a796d9d52___print-bootp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/29e5470e6ab84badbc31f4532bb7554a796d9d52",
        "commit_msg": "CVE-2017-13028/BOOTP: Add a bounds check before fetching data\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't cause 'tcpdump: pcap_loop: truncated dump file'",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -533,6 +533,7 @@ isis_stlv_asan-2\tisis_stlv_asan-2.pcap\t\tisis_stlv_asan-2.out\t-v\n isis_stlv_asan-3\tisis_stlv_asan-3.pcap\t\tisis_stlv_asan-3.out\t-v\n isis_stlv_asan-4\tisis_stlv_asan-4.pcap\t\tisis_stlv_asan-4.out\t-v\n lldp_mgmt_addr_tlv_asan\tlldp_mgmt_addr_tlv_asan.pcap\tlldp_mgmt_addr_tlv_asan.out\t-v\n+bootp_asan\t\tbootp_asan.pcap\t\t\tbootp_asan.out\t\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/bootp_asan.out",
                "patch": "@@ -0,0 +1,2 @@\n+IP (tos 0x0, ttl 252, id 40207, offset 0, flags [+, DF, rsvd], proto UDP (17), length 60951, bad cksum ff (->8336)!)\n+    18.0.0.15.16896 > 107.95.83.32.68: BOOTP/DHCP, unknown (0x00), length 59384, htype 0, hlen 0, hops 13, xid 0x14000000, secs 3328 [|bootp]"
            }
        ],
        "error_msg": "    bootp_asan                         : TEST FAILED(exit 256)\n"
    },
    "88b2dac837e81cf56dce05e6e7b5989332c0092d___print-ospf6.c": {
        "prefix": "static int\nospf6_decode_v3(netdissect_options *ndo,\n                register const struct ospf6hdr *op,\n                register const u_char *dataend)\n{\n\tregister const rtrid_t *ap;\n\tregister const struct lsr6 *lsrp;\n\tregister const struct lsa6_hdr *lshp;\n\tregister const struct lsa6 *lsap;\n\tregister int i;\n\n\tswitch (op->ospf6_type) {\n\n\tcase OSPF_TYPE_HELLO: {\n\t\tregister const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n",
        "suffix": "\t\t          bittok2str(ospf6_option_values, \"none\",\n\t\t          EXTRACT_32BITS(&hellop->hello_options))));\n\n\t\tND_TCHECK(hellop->hello_deadint);\n\t\tND_PRINT((ndo, \"\\n\\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u\",\n\t\t          EXTRACT_16BITS(&hellop->hello_helloint),\n\t\t          EXTRACT_16BITS(&hellop->hello_deadint),\n\t\t          ipaddr_string(ndo, &hellop->hello_ifid),\n\t\t          hellop->hello_priority));\n\n\t\tND_TCHECK(hellop->hello_dr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_dr) != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_dr)));\n\t\tND_TCHECK(hellop->hello_bdr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_bdr) != 0)\n\t\t\tND_PRINT((ndo, \", Backup Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_bdr)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  Neighbor List:\"));\n\t\t\tap = hellop->hello_neighbor;\n\t\t\twhile ((const u_char *)ap < dataend) {\n\t\t\t\tND_TCHECK(*ap);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t    %s\", ipaddr_string(ndo, ap)));\n\t\t\t\t++ap;\n\t\t\t}\n\t\t}\n\t\tbreak;\t/* HELLO */\n\t}\n\n\tcase OSPF_TYPE_DD: {\n\t\tregister const struct dd6 *ddp = (const struct dd6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\tND_TCHECK(ddp->db_options);\n\t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n\t\t          bittok2str(ospf6_option_values, \"none\",\n\t\t          EXTRACT_32BITS(&ddp->db_options))));\n\t\tND_TCHECK(ddp->db_flags);\n\t\tND_PRINT((ndo, \", DD Flags [%s]\",\n\t\t          bittok2str(ospf6_dd_flag_values,\"none\",ddp->db_flags)));\n\n\t\tND_TCHECK(ddp->db_seq);\n\t\tND_PRINT((ndo, \", MTU %u, DD-Sequence 0x%08x\",\n                       EXTRACT_16BITS(&ddp->db_mtu),\n                       EXTRACT_32BITS(&ddp->db_seq)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\t/* Print all the LS adv's */\n\t\t\tlshp = ddp->db_lshdr;\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase OSPF_TYPE_LS_REQ:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlsrp = (const struct lsr6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lsrp < dataend) {\n\t\t\t\tND_TCHECK(*lsrp);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s\",\n\t\t\t\t          ipaddr_string(ndo, &lsrp->ls_router)));\n\t\t\t\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lsrp->ls_type),\n                                                    &lsrp->ls_stateid);\n\t\t\t\t++lsrp;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_UPDATE:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tregister const struct lsu6 *lsup = (const struct lsu6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\t\tND_TCHECK(lsup->lsu_count);\n\t\t\ti = EXTRACT_32BITS(&lsup->lsu_count);\n\t\t\tlsap = lsup->lsu_lsa;\n\t\t\twhile ((const u_char *)lsap < dataend && i--) {\n\t\t\t\tif (ospf6_print_lsa(ndo, lsap, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tlsap = (const struct lsa6 *)((const u_char *)lsap +\n\t\t\t\t    EXTRACT_16BITS(&lsap->ls_hdr.ls_length));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_ACK:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlshp = (const struct lsa6_hdr *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn (0);\ntrunc:\n\treturn (1);\n}\n",
        "start": 722,
        "end": 841,
        "buggy": "static int\nospf6_decode_v3(netdissect_options *ndo,\n                register const struct ospf6hdr *op,\n                register const u_char *dataend)\n{\n\tregister const rtrid_t *ap;\n\tregister const struct lsr6 *lsrp;\n\tregister const struct lsa6_hdr *lshp;\n\tregister const struct lsa6 *lsap;\n\tregister int i;\n\n\tswitch (op->ospf6_type) {\n\n\tcase OSPF_TYPE_HELLO: {\n\t\tregister const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n\t\t          bittok2str(ospf6_option_values, \"none\",\n\t\t          EXTRACT_32BITS(&hellop->hello_options))));\n\n\t\tND_TCHECK(hellop->hello_deadint);\n\t\tND_PRINT((ndo, \"\\n\\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u\",\n\t\t          EXTRACT_16BITS(&hellop->hello_helloint),\n\t\t          EXTRACT_16BITS(&hellop->hello_deadint),\n\t\t          ipaddr_string(ndo, &hellop->hello_ifid),\n\t\t          hellop->hello_priority));\n\n\t\tND_TCHECK(hellop->hello_dr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_dr) != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_dr)));\n\t\tND_TCHECK(hellop->hello_bdr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_bdr) != 0)\n\t\t\tND_PRINT((ndo, \", Backup Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_bdr)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  Neighbor List:\"));\n\t\t\tap = hellop->hello_neighbor;\n\t\t\twhile ((const u_char *)ap < dataend) {\n\t\t\t\tND_TCHECK(*ap);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t    %s\", ipaddr_string(ndo, ap)));\n\t\t\t\t++ap;\n\t\t\t}\n\t\t}\n\t\tbreak;\t/* HELLO */\n\t}\n\n\tcase OSPF_TYPE_DD: {\n\t\tregister const struct dd6 *ddp = (const struct dd6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\tND_TCHECK(ddp->db_options);\n\t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n\t\t          bittok2str(ospf6_option_values, \"none\",\n\t\t          EXTRACT_32BITS(&ddp->db_options))));\n\t\tND_TCHECK(ddp->db_flags);\n\t\tND_PRINT((ndo, \", DD Flags [%s]\",\n\t\t          bittok2str(ospf6_dd_flag_values,\"none\",ddp->db_flags)));\n\n\t\tND_TCHECK(ddp->db_seq);\n\t\tND_PRINT((ndo, \", MTU %u, DD-Sequence 0x%08x\",\n                       EXTRACT_16BITS(&ddp->db_mtu),\n                       EXTRACT_32BITS(&ddp->db_seq)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\t/* Print all the LS adv's */\n\t\t\tlshp = ddp->db_lshdr;\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase OSPF_TYPE_LS_REQ:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlsrp = (const struct lsr6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lsrp < dataend) {\n\t\t\t\tND_TCHECK(*lsrp);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s\",\n\t\t\t\t          ipaddr_string(ndo, &lsrp->ls_router)));\n\t\t\t\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lsrp->ls_type),\n                                                    &lsrp->ls_stateid);\n\t\t\t\t++lsrp;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_UPDATE:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tregister const struct lsu6 *lsup = (const struct lsu6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\t\tND_TCHECK(lsup->lsu_count);\n\t\t\ti = EXTRACT_32BITS(&lsup->lsu_count);\n\t\t\tlsap = lsup->lsu_lsa;\n\t\t\twhile ((const u_char *)lsap < dataend && i--) {\n\t\t\t\tif (ospf6_print_lsa(ndo, lsap, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tlsap = (const struct lsa6 *)((const u_char *)lsap +\n\t\t\t\t    EXTRACT_16BITS(&lsap->ls_hdr.ls_length));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_ACK:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlshp = (const struct lsa6_hdr *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn (0);\ntrunc:\n\treturn (1);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n",
        "src_path": "88b2dac837e81cf56dce05e6e7b5989332c0092d___print-ospf6.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/88b2dac837e81cf56dce05e6e7b5989332c0092d",
        "commit_msg": "CVE-2017-13036/OSPFv3: Add a bounds check before fetching data\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -549,6 +549,7 @@ pim_header_asan-2\tpim_header_asan-2.pcap\t\tpim_header_asan-2.out\t-v\n pim_header_asan-3\tpim_header_asan-3.pcap\t\tpim_header_asan-3.out\t-v\n ip6_frag_asan\t\tip6_frag_asan.pcap\t\tip6_frag_asan.out\t-v\n radius_attr_asan\tradius_attr_asan.pcap\t\tradius_attr_asan.out\t-v\n+ospf6_decode_v3_asan\tospf6_decode_v3_asan.pcap\tospf6_decode_v3_asan.out -v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/ospf6_decode_v3_asan.out",
                "patch": "@@ -0,0 +1,2 @@\n+IP6 (class 0x76, flowlabel 0xf6701, hlim 109, next-header OSPF (89) payload length: 30311) 6767:6780:6767:a102:4:b6:5853:f040 > 1000:a32:8847:1::116: OSPFv3, Hello, length 30311\n+\tRouter-ID 1.1.0.34, Area 0.255.2.2, Instance 82 [|ospf3]"
            }
        ],
        "error_msg": "    ospf6_decode_v3_asan               : TEST FAILED(exit 256)\n"
    },
    "7335163a6ef82d46ff18f3e6099a157747241629___print-ppp.c": {
        "prefix": "static void\nhandle_mlppp(netdissect_options *ndo,\n             const u_char *p, int length)\n{\n    if (!ndo->ndo_eflag)\n        ND_PRINT((ndo, \"MLPPP, \"));\n\n",
        "suffix": "           (EXTRACT_16BITS(p))&0x0fff, /* only support 12-Bit sequence space for now */\n           bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0),\n           length));\n}\n",
        "start": 807,
        "end": 818,
        "buggy": "static void\nhandle_mlppp(netdissect_options *ndo,\n             const u_char *p, int length)\n{\n    if (!ndo->ndo_eflag)\n        ND_PRINT((ndo, \"MLPPP, \"));\n\n    ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\",\n           (EXTRACT_16BITS(p))&0x0fff, /* only support 12-Bit sequence space for now */\n           bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0),\n           length));\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\",\n",
        "src_path": "7335163a6ef82d46ff18f3e6099a157747241629___print-ppp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/7335163a6ef82d46ff18f3e6099a157747241629",
        "commit_msg": "CVE-2017-13038/PPP: Do bounds checking.\n\nThis fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.\n\nAdd a test using the capture file supplied by Katie Holly.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -554,6 +554,9 @@ radius_attr_asan\tradius_attr_asan.pcap\t\tradius_attr_asan.out\t-v\n ospf6_decode_v3_asan\tospf6_decode_v3_asan.pcap\tospf6_decode_v3_asan.out -v\n ip_ts_opts_asan\t\tip_ts_opts_asan.pcap\t\tip_ts_opts_asan.out\t-v\n \n+# bad packets from Katie Holly\n+mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out\n+\n # RTP tests\n # fuzzed pcap\n rtp-seg-fault-1  rtp-seg-fault-1.pcap  rtp-seg-fault-1.out  -v -T rtp"
            },
            {
                "fn": "tests/mlppp-oobr.out",
                "patch": "@@ -0,0 +1 @@\n+MLPPP, [|mlppp]"
            }
        ],
        "error_msg": "    mlppp-oobr                         : TEST FAILED(exit 256)\n"
    },
    "aa0858100096a3490edf93034a80e66a4d61aad5___print-rx.c": {
        "prefix": "static void\nubik_print(netdissect_options *ndo,\n           register const u_char *bp)\n{\n\tint ubik_op;\n\tint32_t temp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from ubik/ubik_int.xg\n\t */\n\n\tubik_op = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n\n\tND_PRINT((ndo, \" ubik call %s\", tok2str(ubik_req, \"op#%d\", ubik_op)));\n\n\t/*\n\t * Decode some of the arguments to the Ubik calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (ubik_op) {\n\t\tcase 10000:\t\t/* Beacon */\n\t\t\tND_TCHECK2(bp[0], 4);\n\t\t\ttemp = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\t\t\tND_PRINT((ndo, \" syncsite %s\", temp ? \"yes\" : \"no\"));\n\t\t\tND_PRINT((ndo, \" votestart\"));\n\t\t\tDATEOUT();\n\t\t\tND_PRINT((ndo, \" dbversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 10003:\t\t/* Get sync site */\n\t\t\tND_PRINT((ndo, \" site\"));\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 20000:\t\t/* Begin */\n\t\tcase 20001:\t\t/* Commit */\n\t\tcase 20007:\t\t/* Abort */\n\t\tcase 20008:\t\t/* Release locks */\n\t\tcase 20010:\t\t/* Writev */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20002:\t\t/* Lock */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" pos\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n",
        "suffix": "\t\t\tbp += sizeof(int32_t);\n\t\t\ttok2str(ubik_lock_types, \"type %d\", temp);\n\t\t\tbreak;\n\t\tcase 20003:\t\t/* Write */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" pos\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20005:\t\t/* Get file */\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20006:\t\t/* Send file */\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" dbversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20009:\t\t/* Truncate */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20012:\t\t/* Set version */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" oldversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" newversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|ubik]\"));\n}\n",
        "start": 2524,
        "end": 2628,
        "buggy": "static void\nubik_print(netdissect_options *ndo,\n           register const u_char *bp)\n{\n\tint ubik_op;\n\tint32_t temp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from ubik/ubik_int.xg\n\t */\n\n\tubik_op = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n\n\tND_PRINT((ndo, \" ubik call %s\", tok2str(ubik_req, \"op#%d\", ubik_op)));\n\n\t/*\n\t * Decode some of the arguments to the Ubik calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (ubik_op) {\n\t\tcase 10000:\t\t/* Beacon */\n\t\t\tND_TCHECK2(bp[0], 4);\n\t\t\ttemp = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\t\t\tND_PRINT((ndo, \" syncsite %s\", temp ? \"yes\" : \"no\"));\n\t\t\tND_PRINT((ndo, \" votestart\"));\n\t\t\tDATEOUT();\n\t\t\tND_PRINT((ndo, \" dbversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 10003:\t\t/* Get sync site */\n\t\t\tND_PRINT((ndo, \" site\"));\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 20000:\t\t/* Begin */\n\t\tcase 20001:\t\t/* Commit */\n\t\tcase 20007:\t\t/* Abort */\n\t\tcase 20008:\t\t/* Release locks */\n\t\tcase 20010:\t\t/* Writev */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20002:\t\t/* Lock */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" pos\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\t\t\ttemp = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\t\t\ttok2str(ubik_lock_types, \"type %d\", temp);\n\t\t\tbreak;\n\t\tcase 20003:\t\t/* Write */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" pos\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20005:\t\t/* Get file */\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20006:\t\t/* Send file */\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" dbversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20009:\t\t/* Truncate */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20012:\t\t/* Set version */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" oldversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" newversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|ubik]\"));\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\ttemp = EXTRACT_32BITS(bp);\n",
        "src_path": "aa0858100096a3490edf93034a80e66a4d61aad5___print-rx.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/aa0858100096a3490edf93034a80e66a4d61aad5",
        "commit_msg": "CVE-2017-13049/Rx: add a missing bounds check for Ubik\n\nOne of the case blocks in ubik_print() didn't check bounds before\nfetching 32 bits of packet data and could overread past the captured\npacket data by that amount.\n\nThis fixes a buffer over-read discovered by Henri Salo from Nixu\nCorporation.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -573,6 +573,9 @@ mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out\n mptcp-dss-oobr\t\tmptcp-dss-oobr.pcap\t\tmptcp-dss-oobr.out\t-v\n icmp6_nodeinfo_oobr\ticmp6_nodeinfo_oobr.pcap\ticmp6_nodeinfo_oobr.out\n \n+# bad packets from Henri Salo\n+rx_ubik-oobr\t\trx_ubik-oobr.pcap\t\trx_ubik-oobr.out -c1\n+\n # RTP tests\n # fuzzed pcap\n rtp-seg-fault-1  rtp-seg-fault-1.pcap  rtp-seg-fault-1.out  -v -T rtp"
            },
            {
                "fn": "tests/rx_ubik-oobr.out",
                "patch": "@@ -0,0 +1 @@\n+IP truncated-ip - 2598 bytes missing! 222.241.104.198.3503 > 131.63.241.146.7002:  rx data pt ubik call disk-lock tid 50266112.32382 file 2122216448 pos 545160708 length 1087685554 [|ubik] (2632)"
            }
        ],
        "error_msg": "    rx_ubik-oobr                       : TEST FAILED(exit 256)\n"
    },
    "e6511cc1a950fe1566b2236329d6b4bd0826cc7a___print-lldp.c": {
        "prefix": "static int\nlldp_private_8023_print(netdissect_options *ndo,\n                        const u_char *tptr, u_int tlv_len)\n{\n    int subtype, hexdump = FALSE;\n\n    if (tlv_len < 4) {\n        return hexdump;\n    }\n    subtype = *(tptr+3);\n\n    ND_PRINT((ndo, \"\\n\\t  %s Subtype (%u)\",\n           tok2str(lldp_8023_subtype_values, \"unknown\", subtype),\n           subtype));\n\n    switch (subtype) {\n    case LLDP_PRIVATE_8023_SUBTYPE_MACPHY:\n        if (tlv_len < 9) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    autonegotiation [%s] (0x%02x)\",\n               bittok2str(lldp_8023_autonegotiation_values, \"none\", *(tptr+4)),\n               *(tptr + 4)));\n        ND_PRINT((ndo, \"\\n\\t    PMD autoneg capability [%s] (0x%04x)\",\n               bittok2str(lldp_pmd_capability_values,\"unknown\", EXTRACT_16BITS(tptr+5)),\n               EXTRACT_16BITS(tptr + 5)));\n        ND_PRINT((ndo, \"\\n\\t    MAU type %s (0x%04x)\",\n               tok2str(lldp_mau_types_values, \"unknown\", EXTRACT_16BITS(tptr+7)),\n               EXTRACT_16BITS(tptr + 7)));\n        break;\n\n    case LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER:\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    MDI power support [%s], power pair %s, power class %s\",\n               bittok2str(lldp_mdi_values, \"none\", *(tptr+4)),\n               tok2str(lldp_mdi_power_pairs_values, \"unknown\", *(tptr+5)),\n               tok2str(lldp_mdi_power_class_values, \"unknown\", *(tptr + 6))));\n        break;\n\n    case LLDP_PRIVATE_8023_SUBTYPE_LINKAGGR:\n        if (tlv_len < 9) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    aggregation status [%s], aggregation port ID %u\",\n               bittok2str(lldp_aggregation_values, \"none\", *(tptr+4)),\n               EXTRACT_32BITS(tptr + 5)));\n        break;\n\n    case LLDP_PRIVATE_8023_SUBTYPE_MTU:\n",
        "suffix": "        break;\n\n    default:\n        hexdump = TRUE;\n        break;\n    }\n\n    return hexdump;\n}\n",
        "start": 850,
        "end": 910,
        "buggy": "static int\nlldp_private_8023_print(netdissect_options *ndo,\n                        const u_char *tptr, u_int tlv_len)\n{\n    int subtype, hexdump = FALSE;\n\n    if (tlv_len < 4) {\n        return hexdump;\n    }\n    subtype = *(tptr+3);\n\n    ND_PRINT((ndo, \"\\n\\t  %s Subtype (%u)\",\n           tok2str(lldp_8023_subtype_values, \"unknown\", subtype),\n           subtype));\n\n    switch (subtype) {\n    case LLDP_PRIVATE_8023_SUBTYPE_MACPHY:\n        if (tlv_len < 9) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    autonegotiation [%s] (0x%02x)\",\n               bittok2str(lldp_8023_autonegotiation_values, \"none\", *(tptr+4)),\n               *(tptr + 4)));\n        ND_PRINT((ndo, \"\\n\\t    PMD autoneg capability [%s] (0x%04x)\",\n               bittok2str(lldp_pmd_capability_values,\"unknown\", EXTRACT_16BITS(tptr+5)),\n               EXTRACT_16BITS(tptr + 5)));\n        ND_PRINT((ndo, \"\\n\\t    MAU type %s (0x%04x)\",\n               tok2str(lldp_mau_types_values, \"unknown\", EXTRACT_16BITS(tptr+7)),\n               EXTRACT_16BITS(tptr + 7)));\n        break;\n\n    case LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER:\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    MDI power support [%s], power pair %s, power class %s\",\n               bittok2str(lldp_mdi_values, \"none\", *(tptr+4)),\n               tok2str(lldp_mdi_power_pairs_values, \"unknown\", *(tptr+5)),\n               tok2str(lldp_mdi_power_class_values, \"unknown\", *(tptr + 6))));\n        break;\n\n    case LLDP_PRIVATE_8023_SUBTYPE_LINKAGGR:\n        if (tlv_len < 9) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    aggregation status [%s], aggregation port ID %u\",\n               bittok2str(lldp_aggregation_values, \"none\", *(tptr+4)),\n               EXTRACT_32BITS(tptr + 5)));\n        break;\n\n    case LLDP_PRIVATE_8023_SUBTYPE_MTU:\n        ND_PRINT((ndo, \"\\n\\t    MTU size %u\", EXTRACT_16BITS(tptr + 4)));\n        break;\n\n    default:\n        hexdump = TRUE;\n        break;\n    }\n\n    return hexdump;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        ND_PRINT((ndo, \"\\n\\t    MTU size %u\", EXTRACT_16BITS(tptr + 4)));\n",
        "src_path": "e6511cc1a950fe1566b2236329d6b4bd0826cc7a___print-lldp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/e6511cc1a950fe1566b2236329d6b4bd0826cc7a",
        "commit_msg": "CVE-2017-13054/LLDP: add a missing length check\n\nIn lldp_private_8023_print() the case block for subtype 4 (Maximum Frame\nSize TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length\ncheck and could over-read the input buffer, put it right.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -571,6 +571,7 @@ rsvp_uni-oobr-1\trsvp_uni-oobr-1.pcap\trsvp_uni-oobr-1.out\t-v -c1\n rsvp_uni-oobr-2\trsvp_uni-oobr-2.pcap\trsvp_uni-oobr-2.out\t-v -c1\n rsvp_uni-oobr-3\trsvp_uni-oobr-3.pcap\trsvp_uni-oobr-3.out\t-v -c3\n rpki-rtr-oob\t\trpki-rtr-oob.pcap\trpki-rtr-oob.out\t-v -c1\n+lldp_8023_mtu-oobr\tlldp_8023_mtu-oobr.pcap\tlldp_8023_mtu-oobr.out\t-v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/lldp_8023_mtu-oobr.out",
                "patch": "@@ -0,0 +1,4 @@\n+LLDP, length 4293194266\n+\tOrganization specific TLV (127), length 4: OUI IEEE 802.3 Private (0x00120f)\n+\t  Max frame size Subtype (4)\n+\t[|LLDP]"
            }
        ],
        "error_msg": "    lldp_8023_mtu-oobr                 : TEST FAILED(exit 256)\n"
    },
    "061e7371a944588f231cb1b66d6fb070b646e376___print-isakmp.c": {
        "prefix": "static const u_char *\nikev1_id_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len,\n\t       const u_char *ep _U_, uint32_t phase, uint32_t doi _U_,\n\t       uint32_t proto _U_, int depth _U_)\n{\n#define USE_IPSECDOI_IN_PHASE1\t1\n\tconst struct ikev1_pl_id *p;\n\tstruct ikev1_pl_id id;\n\tstatic const char *idtypestr[] = {\n\t\t\"IPv4\", \"IPv4net\", \"IPv6\", \"IPv6net\",\n\t};\n\tstatic const char *ipsecidtypestr[] = {\n\t\tNULL, \"IPv4\", \"FQDN\", \"user FQDN\", \"IPv4net\", \"IPv6\",\n\t\t\"IPv6net\", \"IPv4range\", \"IPv6range\", \"ASN1 DN\", \"ASN1 GN\",\n\t\t\"keyid\",\n\t};\n\tint len;\n\tconst u_char *data;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_ID)));\n\n\tp = (const struct ikev1_pl_id *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&id, ext, sizeof(id));\n\tif (sizeof(*p) < item_len) {\n\t\tdata = (const u_char *)(p + 1);\n\t\tlen = item_len - sizeof(*p);\n\t} else {\n\t\tdata = NULL;\n\t\tlen = 0;\n\t}\n\n#if 0 /*debug*/\n\tND_PRINT((ndo,\" [phase=%d doi=%d proto=%d]\", phase, doi, proto));\n#endif\n\tswitch (phase) {\n#ifndef USE_IPSECDOI_IN_PHASE1\n\tcase 1:\n#endif\n\tdefault:\n\t\tND_PRINT((ndo,\" idtype=%s\", STR_OR_ID(id.d.id_type, idtypestr)));\n\t\tND_PRINT((ndo,\" doi_data=%u\",\n\t\t\t  (uint32_t)(ntohl(id.d.doi_data) & 0xffffff)));\n\t\tbreak;\n\n#ifdef USE_IPSECDOI_IN_PHASE1\n\tcase 1:\n#endif\n\tcase 2:\n\t    {\n\t\tconst struct ipsecdoi_id *doi_p;\n\t\tstruct ipsecdoi_id doi_id;\n\t\tconst char *p_name;\n\n\t\tdoi_p = (const struct ipsecdoi_id *)ext;\n\t\tND_TCHECK(*doi_p);\n\t\tUNALIGNED_MEMCPY(&doi_id, ext, sizeof(doi_id));\n\t\tND_PRINT((ndo,\" idtype=%s\", STR_OR_ID(doi_id.type, ipsecidtypestr)));\n\t\t/* A protocol ID of 0 DOES NOT mean IPPROTO_IP! */\n\t\tif (!ndo->ndo_nflag && doi_id.proto_id && (p_name = netdb_protoname(doi_id.proto_id)) != NULL)\n\t\t\tND_PRINT((ndo,\" protoid=%s\", p_name));\n\t\telse\n\t\t\tND_PRINT((ndo,\" protoid=%u\", doi_id.proto_id));\n\t\tND_PRINT((ndo,\" port=%d\", ntohs(doi_id.port)));\n\t\tif (!len)\n\t\t\tbreak;\n\t\tif (data == NULL)\n\t\t\tgoto trunc;\n\t\tND_TCHECK2(*data, len);\n\t\tswitch (doi_id.type) {\n\t\tcase IPSECDOI_ID_IPV4_ADDR:\n\t\t\tif (len < 4)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 4]\", len));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo,\" len=%d %s\", len, ipaddr_string(ndo, data)));\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_FQDN:\n\t\tcase IPSECDOI_ID_USER_FQDN:\n\t\t    {\n\t\t\tint i;\n\t\t\tND_PRINT((ndo,\" len=%d \", len));\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\tsafeputchar(ndo, data[i]);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_ID_IPV4_ADDR_SUBNET:\n\t\t    {\n\t\t\tconst u_char *mask;\n\t\t\tif (len < 8)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 8]\", len));\n\t\t\telse {\n\t\t\t\tmask = data + sizeof(struct in_addr);\n\t\t\t\tND_PRINT((ndo,\" len=%d %s/%u.%u.%u.%u\", len,\n\t\t\t\t\t  ipaddr_string(ndo, data),\n\t\t\t\t\t  mask[0], mask[1], mask[2], mask[3]));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_ID_IPV6_ADDR:\n\t\t\tif (len < 16)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 16]\", len));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo,\" len=%d %s\", len, ip6addr_string(ndo, data)));\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_IPV6_ADDR_SUBNET:\n\t\t    {\n\t\t\tconst u_char *mask;\n",
        "suffix": "\t\t\t\tmask = (const u_char *)(data + sizeof(struct in6_addr));\n\t\t\t\t/*XXX*/\n\t\t\t\tND_PRINT((ndo,\" len=%d %s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\", len,\n\t\t\t\t\t  ip6addr_string(ndo, data),\n\t\t\t\t\t  mask[0], mask[1], mask[2], mask[3],\n\t\t\t\t\t  mask[4], mask[5], mask[6], mask[7],\n\t\t\t\t\t  mask[8], mask[9], mask[10], mask[11],\n\t\t\t\t\t  mask[12], mask[13], mask[14], mask[15]));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_ID_IPV4_ADDR_RANGE:\n\t\t\tif (len < 8)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 8]\", len));\n\t\t\telse {\n\t\t\t\tND_PRINT((ndo,\" len=%d %s-%s\", len,\n\t\t\t\t\t  ipaddr_string(ndo, data),\n\t\t\t\t\t  ipaddr_string(ndo, data + sizeof(struct in_addr))));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_IPV6_ADDR_RANGE:\n\t\t\tif (len < 32)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 32]\", len));\n\t\t\telse {\n\t\t\t\tND_PRINT((ndo,\" len=%d %s-%s\", len,\n\t\t\t\t\t  ip6addr_string(ndo, data),\n\t\t\t\t\t  ip6addr_string(ndo, data + sizeof(struct in6_addr))));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_DER_ASN1_DN:\n\t\tcase IPSECDOI_ID_DER_ASN1_GN:\n\t\tcase IPSECDOI_ID_KEY_ID:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tif (data && len) {\n\t\tND_PRINT((ndo,\" len=%d\", len));\n\t\tif (2 < ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo,\" \"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)data, len))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_ID)));\n\treturn NULL;\n}\n",
        "start": 1326,
        "end": 1493,
        "buggy": "static const u_char *\nikev1_id_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len,\n\t       const u_char *ep _U_, uint32_t phase, uint32_t doi _U_,\n\t       uint32_t proto _U_, int depth _U_)\n{\n#define USE_IPSECDOI_IN_PHASE1\t1\n\tconst struct ikev1_pl_id *p;\n\tstruct ikev1_pl_id id;\n\tstatic const char *idtypestr[] = {\n\t\t\"IPv4\", \"IPv4net\", \"IPv6\", \"IPv6net\",\n\t};\n\tstatic const char *ipsecidtypestr[] = {\n\t\tNULL, \"IPv4\", \"FQDN\", \"user FQDN\", \"IPv4net\", \"IPv6\",\n\t\t\"IPv6net\", \"IPv4range\", \"IPv6range\", \"ASN1 DN\", \"ASN1 GN\",\n\t\t\"keyid\",\n\t};\n\tint len;\n\tconst u_char *data;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_ID)));\n\n\tp = (const struct ikev1_pl_id *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&id, ext, sizeof(id));\n\tif (sizeof(*p) < item_len) {\n\t\tdata = (const u_char *)(p + 1);\n\t\tlen = item_len - sizeof(*p);\n\t} else {\n\t\tdata = NULL;\n\t\tlen = 0;\n\t}\n\n#if 0 /*debug*/\n\tND_PRINT((ndo,\" [phase=%d doi=%d proto=%d]\", phase, doi, proto));\n#endif\n\tswitch (phase) {\n#ifndef USE_IPSECDOI_IN_PHASE1\n\tcase 1:\n#endif\n\tdefault:\n\t\tND_PRINT((ndo,\" idtype=%s\", STR_OR_ID(id.d.id_type, idtypestr)));\n\t\tND_PRINT((ndo,\" doi_data=%u\",\n\t\t\t  (uint32_t)(ntohl(id.d.doi_data) & 0xffffff)));\n\t\tbreak;\n\n#ifdef USE_IPSECDOI_IN_PHASE1\n\tcase 1:\n#endif\n\tcase 2:\n\t    {\n\t\tconst struct ipsecdoi_id *doi_p;\n\t\tstruct ipsecdoi_id doi_id;\n\t\tconst char *p_name;\n\n\t\tdoi_p = (const struct ipsecdoi_id *)ext;\n\t\tND_TCHECK(*doi_p);\n\t\tUNALIGNED_MEMCPY(&doi_id, ext, sizeof(doi_id));\n\t\tND_PRINT((ndo,\" idtype=%s\", STR_OR_ID(doi_id.type, ipsecidtypestr)));\n\t\t/* A protocol ID of 0 DOES NOT mean IPPROTO_IP! */\n\t\tif (!ndo->ndo_nflag && doi_id.proto_id && (p_name = netdb_protoname(doi_id.proto_id)) != NULL)\n\t\t\tND_PRINT((ndo,\" protoid=%s\", p_name));\n\t\telse\n\t\t\tND_PRINT((ndo,\" protoid=%u\", doi_id.proto_id));\n\t\tND_PRINT((ndo,\" port=%d\", ntohs(doi_id.port)));\n\t\tif (!len)\n\t\t\tbreak;\n\t\tif (data == NULL)\n\t\t\tgoto trunc;\n\t\tND_TCHECK2(*data, len);\n\t\tswitch (doi_id.type) {\n\t\tcase IPSECDOI_ID_IPV4_ADDR:\n\t\t\tif (len < 4)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 4]\", len));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo,\" len=%d %s\", len, ipaddr_string(ndo, data)));\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_FQDN:\n\t\tcase IPSECDOI_ID_USER_FQDN:\n\t\t    {\n\t\t\tint i;\n\t\t\tND_PRINT((ndo,\" len=%d \", len));\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\tsafeputchar(ndo, data[i]);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_ID_IPV4_ADDR_SUBNET:\n\t\t    {\n\t\t\tconst u_char *mask;\n\t\t\tif (len < 8)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 8]\", len));\n\t\t\telse {\n\t\t\t\tmask = data + sizeof(struct in_addr);\n\t\t\t\tND_PRINT((ndo,\" len=%d %s/%u.%u.%u.%u\", len,\n\t\t\t\t\t  ipaddr_string(ndo, data),\n\t\t\t\t\t  mask[0], mask[1], mask[2], mask[3]));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_ID_IPV6_ADDR:\n\t\t\tif (len < 16)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 16]\", len));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo,\" len=%d %s\", len, ip6addr_string(ndo, data)));\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_IPV6_ADDR_SUBNET:\n\t\t    {\n\t\t\tconst u_char *mask;\n\t\t\tif (len < 20)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 20]\", len));\n\t\t\telse {\n\t\t\t\tmask = (const u_char *)(data + sizeof(struct in6_addr));\n\t\t\t\t/*XXX*/\n\t\t\t\tND_PRINT((ndo,\" len=%d %s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\", len,\n\t\t\t\t\t  ip6addr_string(ndo, data),\n\t\t\t\t\t  mask[0], mask[1], mask[2], mask[3],\n\t\t\t\t\t  mask[4], mask[5], mask[6], mask[7],\n\t\t\t\t\t  mask[8], mask[9], mask[10], mask[11],\n\t\t\t\t\t  mask[12], mask[13], mask[14], mask[15]));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_ID_IPV4_ADDR_RANGE:\n\t\t\tif (len < 8)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 8]\", len));\n\t\t\telse {\n\t\t\t\tND_PRINT((ndo,\" len=%d %s-%s\", len,\n\t\t\t\t\t  ipaddr_string(ndo, data),\n\t\t\t\t\t  ipaddr_string(ndo, data + sizeof(struct in_addr))));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_IPV6_ADDR_RANGE:\n\t\t\tif (len < 32)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 32]\", len));\n\t\t\telse {\n\t\t\t\tND_PRINT((ndo,\" len=%d %s-%s\", len,\n\t\t\t\t\t  ip6addr_string(ndo, data),\n\t\t\t\t\t  ip6addr_string(ndo, data + sizeof(struct in6_addr))));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_DER_ASN1_DN:\n\t\tcase IPSECDOI_ID_DER_ASN1_GN:\n\t\tcase IPSECDOI_ID_KEY_ID:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tif (data && len) {\n\t\tND_PRINT((ndo,\" len=%d\", len));\n\t\tif (2 < ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo,\" \"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)data, len))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_ID)));\n\treturn NULL;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tif (len < 20)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 20]\", len));\n\t\t\telse {\n",
        "src_path": "061e7371a944588f231cb1b66d6fb070b646e376___print-isakmp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/061e7371a944588f231cb1b66d6fb070b646e376",
        "commit_msg": "CVE-2017-13689/IKEv1: Fix addr+subnet length check.\n\nAn IPv6 address plus subnet mask is 32 bytes, not 20 bytes.\n16 bytes of IPv6 address, 16 bytes of subnet mask.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -577,6 +577,7 @@ cfm_sender_id-oobr\tcfm_sender_id-oobr.pcap\tcfm_sender_id-oobr.out\t-v -c1\n isis-extd-isreach-oobr\tisis-extd-isreach-oobr.pcap\tisis-extd-isreach-oobr.out -v -c4\n olsr-oobr-1\t\tolsr-oobr-1.pcap\t\tolsr-oobr-1.out\t-v\n olsr-oobr-2\t\tolsr-oobr-2.pcap\t\tolsr-oobr-2.out\t-v\n+ikev1_id_ipv6_addr_subnet-oobr\tikev1_id_ipv6_addr_subnet-oobr.pcap\tikev1_id_ipv6_addr_subnet-oobr.out\t-v\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/ikev1_id_ipv6_addr_subnet-oobr.out",
                "patch": "@@ -0,0 +1,3 @@\n+IP (tos 0x0, ttl 100, id 40207, offset 0, flags [+, DF, rsvd], proto UDP (17), length 32808, bad cksum 8e7f (->bc78)!)\n+    16.0.128.20.500 > 12.251.0.45.0: isakmp 1.0 msgid 0d101010: phase 2/others ? #16[]:\n+    (id: idtype=IPv6net protoid=16 port=4112 len=24 [bad: < 32]) [|#145] (len mismatch: isakmp 4278190080/ip 4856)"
            }
        ],
        "error_msg": "    ikev1_id_ipv6_addr_subnet-oobr     : TEST FAILED(exit 256)\n"
    },
    "d229761821da38d984a9e4098ad96842490dc001___Client.cpp": {
        "prefix": "bool CClient::OnTextMessage(CTextMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n",
        "suffix": "                CString sMsg = Message.GetText();\n                UserCommand(sMsg);\n            } else {\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModCommand(Message.GetText()));\n            }\n            continue;\n        }\n\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n\n        if (!GetIRCSock()) {\n            // Some lagmeters do a PRIVMSG to their own nick, ignore those.\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(\n                    t_f(\"Your message to {1} got lost, you are not connected \"\n                        \"to IRC!\")(Message.GetTarget()));\n            continue;\n        }\n\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}\n",
        "start": 1223,
        "end": 1270,
        "buggy": "bool CClient::OnTextMessage(CTextMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n            if (sTarget.Equals(\"status\")) {\n                CString sMsg = Message.GetText();\n                UserCommand(sMsg);\n            } else {\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModCommand(Message.GetText()));\n            }\n            continue;\n        }\n\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n\n        if (!GetIRCSock()) {\n            // Some lagmeters do a PRIVMSG to their own nick, ignore those.\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(\n                    t_f(\"Your message to {1} got lost, you are not connected \"\n                        \"to IRC!\")(Message.GetTarget()));\n            continue;\n        }\n\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            if (sTarget.Equals(\"status\")) {\n",
        "src_path": "d229761821da38d984a9e4098ad96842490dc001___Client.cpp",
        "uri": "https://api.github.com/repos/znc/znc/commits/d229761821da38d984a9e4098ad96842490dc001",
        "commit_msg": "Fix echo-message for *status\n\nClose #1705",
        "test_func_diff": [
            {
                "fn": "test/integration/tests/core.cpp",
                "patch": "@@ -14,9 +14,10 @@\n  * limitations under the License.\n  */\n \n-#include \"znctest.h\"\n #include <gmock/gmock.h>\n \n+#include \"znctest.h\"\n+\n using testing::HasSubstr;\n \n namespace znc_inttest {\n@@ -244,7 +245,8 @@ TEST_F(ZNCTest, AwayNotify) {\n     client.Write(\"USER user/test x x :x\");\n     QByteArray cap_ls;\n     client.ReadUntilAndGet(\" LS :\", cap_ls);\n-    ASSERT_THAT(cap_ls.toStdString(), AllOf(HasSubstr(\"cap-notify\"), Not(HasSubstr(\"away-notify\"))));\n+    ASSERT_THAT(cap_ls.toStdString(),\n+                AllOf(HasSubstr(\"cap-notify\"), Not(HasSubstr(\"away-notify\"))));\n     client.Write(\"CAP REQ :cap-notify\");\n     client.ReadUntil(\"ACK :cap-notify\");\n     client.Write(\"CAP END\");\n@@ -284,5 +286,15 @@ TEST_F(ZNCTest, JoinKey) {\n     ircd.ReadUntil(\"JOIN #znc secret\");\n }\n \n+TEST_F(ZNCTest, StatusEchoMessage) {\n+    auto znc = Run();\n+    auto ircd = ConnectIRCd();\n+    auto client = LoginClient();\n+    client.Write(\"CAP REQ :echo-message\");\n+    client.Write(\"PRIVMSG *status :blah\");\n+    client.ReadUntil(\":nick!user@irc.znc.in PRIVMSG *status :blah\");\n+    client.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n+}\n+\n }  // namespace\n }  // namespace znc_inttest"
            }
        ],
        "error_msg": "      <failure message=\"test/integration/framework/base.h:116&#x0A;Value of: m_device-&gt;waitForReadyRead(timeout_ms)&#x0A;  Actual: false&#x0A;Expected: true&#x0A;Wanted: :nick!user@irc.znc.in PRIVMSG *status :blah\" type=\"\"><![CDATA[test/integration/framework/base.h:116\nValue of: m_device->waitForReadyRead(timeout_ms)\n  Actual: false\nExpected: true\nWanted: :nick!user@irc.znc.in PRIVMSG *status :blah]]></failure>\n"
    },
    "3fbd1dca6a4d2dad332a2110d646e4ffef36d590___onyx_if.c": {
        "prefix": "void vp8_change_config(VP8_COMP *cpi, VP8_CONFIG *oxcf) {\n  VP8_COMMON *cm = &cpi->common;\n  int last_w, last_h;\n  unsigned int prev_number_of_layers;\n  unsigned int raw_target_rate;\n\n  if (!cpi) return;\n\n  if (!oxcf) return;\n\n  if (cm->version != oxcf->Version) {\n    cm->version = oxcf->Version;\n    vp8_setup_version(cm);\n  }\n\n  last_w = cpi->oxcf.Width;\n  last_h = cpi->oxcf.Height;\n  prev_number_of_layers = cpi->oxcf.number_of_layers;\n\n",
        "suffix": "\n  switch (cpi->oxcf.Mode) {\n    case MODE_REALTIME:\n      cpi->pass = 0;\n      cpi->compressor_speed = 2;\n\n      if (cpi->oxcf.cpu_used < -16) {\n        cpi->oxcf.cpu_used = -16;\n      }\n\n      if (cpi->oxcf.cpu_used > 16) cpi->oxcf.cpu_used = 16;\n\n      break;\n\n    case MODE_GOODQUALITY:\n      cpi->pass = 0;\n      cpi->compressor_speed = 1;\n\n      if (cpi->oxcf.cpu_used < -5) {\n        cpi->oxcf.cpu_used = -5;\n      }\n\n      if (cpi->oxcf.cpu_used > 5) cpi->oxcf.cpu_used = 5;\n\n      break;\n\n    case MODE_BESTQUALITY:\n      cpi->pass = 0;\n      cpi->compressor_speed = 0;\n      break;\n\n    case MODE_FIRSTPASS:\n      cpi->pass = 1;\n      cpi->compressor_speed = 1;\n      break;\n    case MODE_SECONDPASS:\n      cpi->pass = 2;\n      cpi->compressor_speed = 1;\n\n      if (cpi->oxcf.cpu_used < -5) {\n        cpi->oxcf.cpu_used = -5;\n      }\n\n      if (cpi->oxcf.cpu_used > 5) cpi->oxcf.cpu_used = 5;\n\n      break;\n    case MODE_SECONDPASS_BEST:\n      cpi->pass = 2;\n      cpi->compressor_speed = 0;\n      break;\n  }\n\n  if (cpi->pass == 0) cpi->auto_worst_q = 1;\n\n  cpi->oxcf.worst_allowed_q = q_trans[oxcf->worst_allowed_q];\n  cpi->oxcf.best_allowed_q = q_trans[oxcf->best_allowed_q];\n  cpi->oxcf.cq_level = q_trans[cpi->oxcf.cq_level];\n\n  if (oxcf->fixed_q >= 0) {\n    if (oxcf->worst_allowed_q < 0) {\n      cpi->oxcf.fixed_q = q_trans[0];\n    } else {\n      cpi->oxcf.fixed_q = q_trans[oxcf->worst_allowed_q];\n    }\n\n    if (oxcf->alt_q < 0) {\n      cpi->oxcf.alt_q = q_trans[0];\n    } else {\n      cpi->oxcf.alt_q = q_trans[oxcf->alt_q];\n    }\n\n    if (oxcf->key_q < 0) {\n      cpi->oxcf.key_q = q_trans[0];\n    } else {\n      cpi->oxcf.key_q = q_trans[oxcf->key_q];\n    }\n\n    if (oxcf->gold_q < 0) {\n      cpi->oxcf.gold_q = q_trans[0];\n    } else {\n      cpi->oxcf.gold_q = q_trans[oxcf->gold_q];\n    }\n  }\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n\n  cpi->baseline_gf_interval =\n      cpi->oxcf.alt_freq ? cpi->oxcf.alt_freq : DEFAULT_GF_INTERVAL;\n\n  // GF behavior for 1 pass CBR, used when error_resilience is off.\n  if (!cpi->oxcf.error_resilient_mode &&\n      cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER &&\n      cpi->oxcf.Mode == MODE_REALTIME)\n    cpi->baseline_gf_interval = cpi->gf_interval_onepass_cbr;\n\n#if (CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING)\n  cpi->oxcf.token_partitions = 3;\n#endif\n\n  if (cpi->oxcf.token_partitions >= 0 && cpi->oxcf.token_partitions <= 3) {\n    cm->multi_token_partition = (TOKEN_PARTITION)cpi->oxcf.token_partitions;\n  }\n\n  setup_features(cpi);\n\n  if (!cpi->use_roi_static_threshold) {\n    int i;\n    for (i = 0; i < MAX_MB_SEGMENTS; ++i) {\n      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;\n    }\n  }\n\n  /* At the moment the first order values may not be > MAXQ */\n  if (cpi->oxcf.fixed_q > MAXQ) cpi->oxcf.fixed_q = MAXQ;\n\n  /* local file playback mode == really big buffer */\n  if (cpi->oxcf.end_usage == USAGE_LOCAL_FILE_PLAYBACK) {\n    cpi->oxcf.starting_buffer_level = 60000;\n    cpi->oxcf.optimal_buffer_level = 60000;\n    cpi->oxcf.maximum_buffer_size = 240000;\n    cpi->oxcf.starting_buffer_level_in_ms = 60000;\n    cpi->oxcf.optimal_buffer_level_in_ms = 60000;\n    cpi->oxcf.maximum_buffer_size_in_ms = 240000;\n  }\n\n  raw_target_rate = (unsigned int)((int64_t)cpi->oxcf.Width * cpi->oxcf.Height *\n                                   8 * 3 * cpi->framerate / 1000);\n  if (cpi->oxcf.target_bandwidth > raw_target_rate)\n    cpi->oxcf.target_bandwidth = raw_target_rate;\n  /* Convert target bandwidth from Kbit/s to Bit/s */\n  cpi->oxcf.target_bandwidth *= 1000;\n\n  cpi->oxcf.starting_buffer_level = rescale(\n      (int)cpi->oxcf.starting_buffer_level, cpi->oxcf.target_bandwidth, 1000);\n\n  /* Set or reset optimal and maximum buffer levels. */\n  if (cpi->oxcf.optimal_buffer_level == 0) {\n    cpi->oxcf.optimal_buffer_level = cpi->oxcf.target_bandwidth / 8;\n  } else {\n    cpi->oxcf.optimal_buffer_level = rescale(\n        (int)cpi->oxcf.optimal_buffer_level, cpi->oxcf.target_bandwidth, 1000);\n  }\n\n  if (cpi->oxcf.maximum_buffer_size == 0) {\n    cpi->oxcf.maximum_buffer_size = cpi->oxcf.target_bandwidth / 8;\n  } else {\n    cpi->oxcf.maximum_buffer_size = rescale((int)cpi->oxcf.maximum_buffer_size,\n                                            cpi->oxcf.target_bandwidth, 1000);\n  }\n  // Under a configuration change, where maximum_buffer_size may change,\n  // keep buffer level clipped to the maximum allowed buffer size.\n  if (cpi->bits_off_target > cpi->oxcf.maximum_buffer_size) {\n    cpi->bits_off_target = cpi->oxcf.maximum_buffer_size;\n    cpi->buffer_level = cpi->bits_off_target;\n  }\n\n  /* Set up frame rate and related parameters rate control values. */\n  vp8_new_framerate(cpi, cpi->framerate);\n\n  /* Set absolute upper and lower quality limits */\n  cpi->worst_quality = cpi->oxcf.worst_allowed_q;\n  cpi->best_quality = cpi->oxcf.best_allowed_q;\n\n  /* active values should only be modified if out of new range */\n  if (cpi->active_worst_quality > cpi->oxcf.worst_allowed_q) {\n    cpi->active_worst_quality = cpi->oxcf.worst_allowed_q;\n  }\n  /* less likely */\n  else if (cpi->active_worst_quality < cpi->oxcf.best_allowed_q) {\n    cpi->active_worst_quality = cpi->oxcf.best_allowed_q;\n  }\n  if (cpi->active_best_quality < cpi->oxcf.best_allowed_q) {\n    cpi->active_best_quality = cpi->oxcf.best_allowed_q;\n  }\n  /* less likely */\n  else if (cpi->active_best_quality > cpi->oxcf.worst_allowed_q) {\n    cpi->active_best_quality = cpi->oxcf.worst_allowed_q;\n  }\n\n  cpi->buffered_mode = cpi->oxcf.optimal_buffer_level > 0;\n\n  cpi->cq_target_quality = cpi->oxcf.cq_level;\n\n  /* Only allow dropped frames in buffered mode */\n  cpi->drop_frames_allowed = cpi->oxcf.allow_df && cpi->buffered_mode;\n\n  cpi->target_bandwidth = cpi->oxcf.target_bandwidth;\n\n  // Check if the number of temporal layers has changed, and if so reset the\n  // pattern counter and set/initialize the temporal layer context for the\n  // new layer configuration.\n  if (cpi->oxcf.number_of_layers != prev_number_of_layers) {\n    // If the number of temporal layers are changed we must start at the\n    // base of the pattern cycle, so set the layer id to 0 and reset\n    // the temporal pattern counter.\n    if (cpi->temporal_layer_id > 0) {\n      cpi->temporal_layer_id = 0;\n    }\n    cpi->temporal_pattern_counter = 0;\n    vp8_reset_temporal_layer_change(cpi, oxcf, prev_number_of_layers);\n  }\n\n  if (!cpi->initial_width) {\n    cpi->initial_width = cpi->oxcf.Width;\n    cpi->initial_height = cpi->oxcf.Height;\n  }\n\n  cm->Width = cpi->oxcf.Width;\n  cm->Height = cpi->oxcf.Height;\n  assert(cm->Width <= cpi->initial_width);\n  assert(cm->Height <= cpi->initial_height);\n\n  /* TODO(jkoleszar): if an internal spatial resampling is active,\n   * and we downsize the input image, maybe we should clear the\n   * internal scale immediately rather than waiting for it to\n   * correct.\n   */\n\n  /* VP8 sharpness level mapping 0-7 (vs 0-10 in general VPx dialogs) */\n  if (cpi->oxcf.Sharpness > 7) cpi->oxcf.Sharpness = 7;\n\n  cm->sharpness_level = cpi->oxcf.Sharpness;\n\n  if (cm->horiz_scale != VP8E_NORMAL || cm->vert_scale != VP8E_NORMAL) {\n    int hr, hs, vr, vs;\n\n    Scale2Ratio(cm->horiz_scale, &hr, &hs);\n    Scale2Ratio(cm->vert_scale, &vr, &vs);\n\n    /* always go to the next whole number */\n    cm->Width = (hs - 1 + cpi->oxcf.Width * hr) / hs;\n    cm->Height = (vs - 1 + cpi->oxcf.Height * vr) / vs;\n  }\n\n  if (last_w != cpi->oxcf.Width || last_h != cpi->oxcf.Height) {\n    cpi->force_next_frame_intra = 1;\n  }\n\n  if (((cm->Width + 15) & ~15) != cm->yv12_fb[cm->lst_fb_idx].y_width ||\n      ((cm->Height + 15) & ~15) != cm->yv12_fb[cm->lst_fb_idx].y_height ||\n      cm->yv12_fb[cm->lst_fb_idx].y_width == 0) {\n    dealloc_raw_frame_buffers(cpi);\n    alloc_raw_frame_buffers(cpi);\n    vp8_alloc_compressor_data(cpi);\n  }\n\n  if (cpi->oxcf.fixed_q >= 0) {\n    cpi->last_q[0] = cpi->oxcf.fixed_q;\n    cpi->last_q[1] = cpi->oxcf.fixed_q;\n  }\n\n  cpi->Speed = cpi->oxcf.cpu_used;\n\n  /* force to allowlag to 0 if lag_in_frames is 0; */\n  if (cpi->oxcf.lag_in_frames == 0) {\n    cpi->oxcf.allow_lag = 0;\n  }\n  /* Limit on lag buffers as these are not currently dynamically allocated */\n  else if (cpi->oxcf.lag_in_frames > MAX_LAG_BUFFERS) {\n    cpi->oxcf.lag_in_frames = MAX_LAG_BUFFERS;\n  }\n\n  /* YX Temp */\n  cpi->alt_ref_source = NULL;\n  cpi->is_src_frame_alt_ref = 0;\n\n#if CONFIG_TEMPORAL_DENOISING\n  if (cpi->oxcf.noise_sensitivity) {\n    if (!cpi->denoiser.yv12_mc_running_avg.buffer_alloc) {\n      int width = (cpi->oxcf.Width + 15) & ~15;\n      int height = (cpi->oxcf.Height + 15) & ~15;\n      if (vp8_denoiser_allocate(&cpi->denoiser, width, height, cm->mb_rows,\n                                cm->mb_cols, cpi->oxcf.noise_sensitivity)) {\n        vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                           \"Failed to allocate denoiser\");\n      }\n    }\n  }\n#endif\n\n#if 0\n    /* Experimental RD Code */\n    cpi->frame_distortion = 0;\n    cpi->last_frame_distortion = 0;\n#endif\n}\n",
        "start": 1431,
        "end": 1736,
        "buggy": "void vp8_change_config(VP8_COMP *cpi, VP8_CONFIG *oxcf) {\n  VP8_COMMON *cm = &cpi->common;\n  int last_w, last_h;\n  unsigned int prev_number_of_layers;\n  unsigned int raw_target_rate;\n\n  if (!cpi) return;\n\n  if (!oxcf) return;\n\n  if (cm->version != oxcf->Version) {\n    cm->version = oxcf->Version;\n    vp8_setup_version(cm);\n  }\n\n  last_w = cpi->oxcf.Width;\n  last_h = cpi->oxcf.Height;\n  prev_number_of_layers = cpi->oxcf.number_of_layers;\n\n  cpi->oxcf = *oxcf;\n\n  switch (cpi->oxcf.Mode) {\n    case MODE_REALTIME:\n      cpi->pass = 0;\n      cpi->compressor_speed = 2;\n\n      if (cpi->oxcf.cpu_used < -16) {\n        cpi->oxcf.cpu_used = -16;\n      }\n\n      if (cpi->oxcf.cpu_used > 16) cpi->oxcf.cpu_used = 16;\n\n      break;\n\n    case MODE_GOODQUALITY:\n      cpi->pass = 0;\n      cpi->compressor_speed = 1;\n\n      if (cpi->oxcf.cpu_used < -5) {\n        cpi->oxcf.cpu_used = -5;\n      }\n\n      if (cpi->oxcf.cpu_used > 5) cpi->oxcf.cpu_used = 5;\n\n      break;\n\n    case MODE_BESTQUALITY:\n      cpi->pass = 0;\n      cpi->compressor_speed = 0;\n      break;\n\n    case MODE_FIRSTPASS:\n      cpi->pass = 1;\n      cpi->compressor_speed = 1;\n      break;\n    case MODE_SECONDPASS:\n      cpi->pass = 2;\n      cpi->compressor_speed = 1;\n\n      if (cpi->oxcf.cpu_used < -5) {\n        cpi->oxcf.cpu_used = -5;\n      }\n\n      if (cpi->oxcf.cpu_used > 5) cpi->oxcf.cpu_used = 5;\n\n      break;\n    case MODE_SECONDPASS_BEST:\n      cpi->pass = 2;\n      cpi->compressor_speed = 0;\n      break;\n  }\n\n  if (cpi->pass == 0) cpi->auto_worst_q = 1;\n\n  cpi->oxcf.worst_allowed_q = q_trans[oxcf->worst_allowed_q];\n  cpi->oxcf.best_allowed_q = q_trans[oxcf->best_allowed_q];\n  cpi->oxcf.cq_level = q_trans[cpi->oxcf.cq_level];\n\n  if (oxcf->fixed_q >= 0) {\n    if (oxcf->worst_allowed_q < 0) {\n      cpi->oxcf.fixed_q = q_trans[0];\n    } else {\n      cpi->oxcf.fixed_q = q_trans[oxcf->worst_allowed_q];\n    }\n\n    if (oxcf->alt_q < 0) {\n      cpi->oxcf.alt_q = q_trans[0];\n    } else {\n      cpi->oxcf.alt_q = q_trans[oxcf->alt_q];\n    }\n\n    if (oxcf->key_q < 0) {\n      cpi->oxcf.key_q = q_trans[0];\n    } else {\n      cpi->oxcf.key_q = q_trans[oxcf->key_q];\n    }\n\n    if (oxcf->gold_q < 0) {\n      cpi->oxcf.gold_q = q_trans[0];\n    } else {\n      cpi->oxcf.gold_q = q_trans[oxcf->gold_q];\n    }\n  }\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n\n  cpi->baseline_gf_interval =\n      cpi->oxcf.alt_freq ? cpi->oxcf.alt_freq : DEFAULT_GF_INTERVAL;\n\n  // GF behavior for 1 pass CBR, used when error_resilience is off.\n  if (!cpi->oxcf.error_resilient_mode &&\n      cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER &&\n      cpi->oxcf.Mode == MODE_REALTIME)\n    cpi->baseline_gf_interval = cpi->gf_interval_onepass_cbr;\n\n#if (CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING)\n  cpi->oxcf.token_partitions = 3;\n#endif\n\n  if (cpi->oxcf.token_partitions >= 0 && cpi->oxcf.token_partitions <= 3) {\n    cm->multi_token_partition = (TOKEN_PARTITION)cpi->oxcf.token_partitions;\n  }\n\n  setup_features(cpi);\n\n  if (!cpi->use_roi_static_threshold) {\n    int i;\n    for (i = 0; i < MAX_MB_SEGMENTS; ++i) {\n      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;\n    }\n  }\n\n  /* At the moment the first order values may not be > MAXQ */\n  if (cpi->oxcf.fixed_q > MAXQ) cpi->oxcf.fixed_q = MAXQ;\n\n  /* local file playback mode == really big buffer */\n  if (cpi->oxcf.end_usage == USAGE_LOCAL_FILE_PLAYBACK) {\n    cpi->oxcf.starting_buffer_level = 60000;\n    cpi->oxcf.optimal_buffer_level = 60000;\n    cpi->oxcf.maximum_buffer_size = 240000;\n    cpi->oxcf.starting_buffer_level_in_ms = 60000;\n    cpi->oxcf.optimal_buffer_level_in_ms = 60000;\n    cpi->oxcf.maximum_buffer_size_in_ms = 240000;\n  }\n\n  raw_target_rate = (unsigned int)((int64_t)cpi->oxcf.Width * cpi->oxcf.Height *\n                                   8 * 3 * cpi->framerate / 1000);\n  if (cpi->oxcf.target_bandwidth > raw_target_rate)\n    cpi->oxcf.target_bandwidth = raw_target_rate;\n  /* Convert target bandwidth from Kbit/s to Bit/s */\n  cpi->oxcf.target_bandwidth *= 1000;\n\n  cpi->oxcf.starting_buffer_level = rescale(\n      (int)cpi->oxcf.starting_buffer_level, cpi->oxcf.target_bandwidth, 1000);\n\n  /* Set or reset optimal and maximum buffer levels. */\n  if (cpi->oxcf.optimal_buffer_level == 0) {\n    cpi->oxcf.optimal_buffer_level = cpi->oxcf.target_bandwidth / 8;\n  } else {\n    cpi->oxcf.optimal_buffer_level = rescale(\n        (int)cpi->oxcf.optimal_buffer_level, cpi->oxcf.target_bandwidth, 1000);\n  }\n\n  if (cpi->oxcf.maximum_buffer_size == 0) {\n    cpi->oxcf.maximum_buffer_size = cpi->oxcf.target_bandwidth / 8;\n  } else {\n    cpi->oxcf.maximum_buffer_size = rescale((int)cpi->oxcf.maximum_buffer_size,\n                                            cpi->oxcf.target_bandwidth, 1000);\n  }\n  // Under a configuration change, where maximum_buffer_size may change,\n  // keep buffer level clipped to the maximum allowed buffer size.\n  if (cpi->bits_off_target > cpi->oxcf.maximum_buffer_size) {\n    cpi->bits_off_target = cpi->oxcf.maximum_buffer_size;\n    cpi->buffer_level = cpi->bits_off_target;\n  }\n\n  /* Set up frame rate and related parameters rate control values. */\n  vp8_new_framerate(cpi, cpi->framerate);\n\n  /* Set absolute upper and lower quality limits */\n  cpi->worst_quality = cpi->oxcf.worst_allowed_q;\n  cpi->best_quality = cpi->oxcf.best_allowed_q;\n\n  /* active values should only be modified if out of new range */\n  if (cpi->active_worst_quality > cpi->oxcf.worst_allowed_q) {\n    cpi->active_worst_quality = cpi->oxcf.worst_allowed_q;\n  }\n  /* less likely */\n  else if (cpi->active_worst_quality < cpi->oxcf.best_allowed_q) {\n    cpi->active_worst_quality = cpi->oxcf.best_allowed_q;\n  }\n  if (cpi->active_best_quality < cpi->oxcf.best_allowed_q) {\n    cpi->active_best_quality = cpi->oxcf.best_allowed_q;\n  }\n  /* less likely */\n  else if (cpi->active_best_quality > cpi->oxcf.worst_allowed_q) {\n    cpi->active_best_quality = cpi->oxcf.worst_allowed_q;\n  }\n\n  cpi->buffered_mode = cpi->oxcf.optimal_buffer_level > 0;\n\n  cpi->cq_target_quality = cpi->oxcf.cq_level;\n\n  /* Only allow dropped frames in buffered mode */\n  cpi->drop_frames_allowed = cpi->oxcf.allow_df && cpi->buffered_mode;\n\n  cpi->target_bandwidth = cpi->oxcf.target_bandwidth;\n\n  // Check if the number of temporal layers has changed, and if so reset the\n  // pattern counter and set/initialize the temporal layer context for the\n  // new layer configuration.\n  if (cpi->oxcf.number_of_layers != prev_number_of_layers) {\n    // If the number of temporal layers are changed we must start at the\n    // base of the pattern cycle, so set the layer id to 0 and reset\n    // the temporal pattern counter.\n    if (cpi->temporal_layer_id > 0) {\n      cpi->temporal_layer_id = 0;\n    }\n    cpi->temporal_pattern_counter = 0;\n    vp8_reset_temporal_layer_change(cpi, oxcf, prev_number_of_layers);\n  }\n\n  if (!cpi->initial_width) {\n    cpi->initial_width = cpi->oxcf.Width;\n    cpi->initial_height = cpi->oxcf.Height;\n  }\n\n  cm->Width = cpi->oxcf.Width;\n  cm->Height = cpi->oxcf.Height;\n  assert(cm->Width <= cpi->initial_width);\n  assert(cm->Height <= cpi->initial_height);\n\n  /* TODO(jkoleszar): if an internal spatial resampling is active,\n   * and we downsize the input image, maybe we should clear the\n   * internal scale immediately rather than waiting for it to\n   * correct.\n   */\n\n  /* VP8 sharpness level mapping 0-7 (vs 0-10 in general VPx dialogs) */\n  if (cpi->oxcf.Sharpness > 7) cpi->oxcf.Sharpness = 7;\n\n  cm->sharpness_level = cpi->oxcf.Sharpness;\n\n  if (cm->horiz_scale != VP8E_NORMAL || cm->vert_scale != VP8E_NORMAL) {\n    int hr, hs, vr, vs;\n\n    Scale2Ratio(cm->horiz_scale, &hr, &hs);\n    Scale2Ratio(cm->vert_scale, &vr, &vs);\n\n    /* always go to the next whole number */\n    cm->Width = (hs - 1 + cpi->oxcf.Width * hr) / hs;\n    cm->Height = (vs - 1 + cpi->oxcf.Height * vr) / vs;\n  }\n\n  if (last_w != cpi->oxcf.Width || last_h != cpi->oxcf.Height) {\n    cpi->force_next_frame_intra = 1;\n  }\n\n  if (((cm->Width + 15) & ~15) != cm->yv12_fb[cm->lst_fb_idx].y_width ||\n      ((cm->Height + 15) & ~15) != cm->yv12_fb[cm->lst_fb_idx].y_height ||\n      cm->yv12_fb[cm->lst_fb_idx].y_width == 0) {\n    dealloc_raw_frame_buffers(cpi);\n    alloc_raw_frame_buffers(cpi);\n    vp8_alloc_compressor_data(cpi);\n  }\n\n  if (cpi->oxcf.fixed_q >= 0) {\n    cpi->last_q[0] = cpi->oxcf.fixed_q;\n    cpi->last_q[1] = cpi->oxcf.fixed_q;\n  }\n\n  cpi->Speed = cpi->oxcf.cpu_used;\n\n  /* force to allowlag to 0 if lag_in_frames is 0; */\n  if (cpi->oxcf.lag_in_frames == 0) {\n    cpi->oxcf.allow_lag = 0;\n  }\n  /* Limit on lag buffers as these are not currently dynamically allocated */\n  else if (cpi->oxcf.lag_in_frames > MAX_LAG_BUFFERS) {\n    cpi->oxcf.lag_in_frames = MAX_LAG_BUFFERS;\n  }\n\n  /* YX Temp */\n  cpi->alt_ref_source = NULL;\n  cpi->is_src_frame_alt_ref = 0;\n\n#if CONFIG_TEMPORAL_DENOISING\n  if (cpi->oxcf.noise_sensitivity) {\n    if (!cpi->denoiser.yv12_mc_running_avg.buffer_alloc) {\n      int width = (cpi->oxcf.Width + 15) & ~15;\n      int height = (cpi->oxcf.Height + 15) & ~15;\n      if (vp8_denoiser_allocate(&cpi->denoiser, width, height, cm->mb_rows,\n                                cm->mb_cols, cpi->oxcf.noise_sensitivity)) {\n        vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                           \"Failed to allocate denoiser\");\n      }\n    }\n  }\n#endif\n\n#if 0\n    /* Experimental RD Code */\n    cpi->frame_distortion = 0;\n    cpi->last_frame_distortion = 0;\n#endif\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  cpi->oxcf = *oxcf;\n",
        "src_path": "3fbd1dca6a4d2dad332a2110d646e4ffef36d590___onyx_if.c",
        "uri": "https://api.github.com/repos/webmproject/libvpx/commits/3fbd1dca6a4d2dad332a2110d646e4ffef36d590",
        "commit_msg": "VP8: disallow thread count changes\n\nCurrently allocations are done at encoder creation time. Going from\nthreaded to non-threaded would cause a crash.\n\nBug: chromium:1486441\nChange-Id: Ie301c2a70847dff2f0daae408fbef1e4d42e73d4",
        "test_func_diff": [
            {
                "fn": "test/encode_api_test.cc",
                "patch": "@@ -370,10 +370,6 @@ TEST(EncodeAPI, ConfigResizeChangeThreadCount) {\n \n   for (const auto *iface : kCodecIfaces) {\n     SCOPED_TRACE(vpx_codec_iface_name(iface));\n-    if (!IsVP9(iface)) {\n-      GTEST_SKIP() << \"TODO(https://crbug.com/1486441) remove this condition \"\n-                      \"after VP8 is fixed.\";\n-    }\n     for (int i = 0; i < (IsVP9(iface) ? 2 : 1); ++i) {\n       vpx_codec_enc_cfg_t cfg = {};\n       struct Encoder {"
            }
        ],
        "error_msg": "warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\nNote: Google Test filter = EncodeAPI.ConfigResizeChangeThreadCount-:AVX512.*:AVX512/*\n[==========] Running 1 test from 1 test suite.\n[----------] Global test environment set-up.\n[----------] 1 test from EncodeAPI\n[ RUN      ] EncodeAPI.ConfigResizeChangeThreadCount\n[New Thread 0x7f7b1de0d700 (LWP 19995)]\n[New Thread 0x7f7b1d60c700 (LWP 19996)]\n[New Thread 0x7f7b1ce0b700 (LWP 19998)]\n[New Thread 0x7f7b1c60a700 (LWP 19999)]\nmunmap_chunk(): invalid pointer\n[Thread 0x7f7b1ce0b700 (LWP 19998) exited]\n[Thread 0x7f7b1c60a700 (LWP 19999) exited]\n[Thread 0x7f7b1d60c700 (LWP 19996) exited]\n[Thread 0x7f7b1de0d700 (LWP 19995) exited]\n\nThread 1 \"test_libvpx\" received signal SIGABRT, Aborted.\n__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50\n50\t../sysdeps/unix/sysv/linux/raise.c: No such file or directory.\n"
    },
    "e59c562b3f6894f84c715772c4b116d7b5c01348___select.c": {
        "prefix": "int sqlite3Select(\n  Parse *pParse,         /* The parser context */\n  Select *p,             /* The SELECT statement being coded. */\n  SelectDest *pDest      /* What to do with the query results */\n){\n  int i, j;              /* Loop counters */\n  WhereInfo *pWInfo;     /* Return from sqlite3WhereBegin() */\n  Vdbe *v;               /* The virtual machine under construction */\n  int isAgg;             /* True for select lists like \"count(*)\" */\n  ExprList *pEList = 0;  /* List of columns to extract. */\n  SrcList *pTabList;     /* List of tables to select from */\n  Expr *pWhere;          /* The WHERE clause.  May be NULL */\n  ExprList *pGroupBy;    /* The GROUP BY clause.  May be NULL */\n  Expr *pHaving;         /* The HAVING clause.  May be NULL */\n  int rc = 1;            /* Value to return from this function */\n  DistinctCtx sDistinct; /* Info on how to code the DISTINCT keyword */\n  SortCtx sSort;         /* Info on how to code the ORDER BY clause */\n  AggInfo sAggInfo;      /* Information used by aggregate queries */\n  int iEnd;              /* Address of the end of the query */\n  sqlite3 *db;           /* The database connection */\n  ExprList *pMinMaxOrderBy = 0;  /* Added ORDER BY for min/max queries */\n  u8 minMaxFlag;                 /* Flag for min/max queries */\n\n  db = pParse->db;\n  v = sqlite3GetVdbe(pParse);\n  if( p==0 || db->mallocFailed || pParse->nErr ){\n    return 1;\n  }\n  if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) return 1;\n  memset(&sAggInfo, 0, sizeof(sAggInfo));\n#if SELECTTRACE_ENABLED\n  SELECTTRACE(1,pParse,p, (\"begin processing:\\n\", pParse->addrExplain));\n  if( sqlite3SelectTrace & 0x100 ){\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistFifo );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Fifo );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistQueue );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Queue );\n  if( IgnorableOrderby(pDest) ){\n    assert(pDest->eDest==SRT_Exists || pDest->eDest==SRT_Union || \n           pDest->eDest==SRT_Except || pDest->eDest==SRT_Discard ||\n           pDest->eDest==SRT_Queue  || pDest->eDest==SRT_DistFifo ||\n           pDest->eDest==SRT_DistQueue || pDest->eDest==SRT_Fifo);\n    /* If ORDER BY makes no difference in the output then neither does\n    ** DISTINCT so it can be removed too. */\n    sqlite3ExprListDelete(db, p->pOrderBy);\n    p->pOrderBy = 0;\n    p->selFlags &= ~SF_Distinct;\n  }\n  sqlite3SelectPrep(pParse, p, 0);\n  if( pParse->nErr || db->mallocFailed ){\n    goto select_end;\n  }\n  assert( p->pEList!=0 );\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x104 ){\n    SELECTTRACE(0x104,pParse,p, (\"after name resolution:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  if( pDest->eDest==SRT_Output ){\n    generateColumnNames(pParse, p);\n  }\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( sqlite3WindowRewrite(pParse, p) ){\n    goto select_end;\n  }\n#if SELECTTRACE_ENABLED\n  if( p->pWin && (sqlite3SelectTrace & 0x108)!=0 ){\n    SELECTTRACE(0x104,pParse,p, (\"after window rewrite:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n  pTabList = p->pSrc;\n  isAgg = (p->selFlags & SF_Aggregate)!=0;\n  memset(&sSort, 0, sizeof(sSort));\n  sSort.pOrderBy = p->pOrderBy;\n\n  /* Try to various optimizations (flattening subqueries, and strength\n  ** reduction of join operators) in the FROM clause up into the main query\n  */\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n  for(i=0; !p->pPrior && i<pTabList->nSrc; i++){\n    struct SrcList_item *pItem = &pTabList->a[i];\n    Select *pSub = pItem->pSelect;\n    Table *pTab = pItem->pTab;\n\n    /* Convert LEFT JOIN into JOIN if there are terms of the right table\n    ** of the LEFT JOIN used in the WHERE clause.\n    */\n    if( (pItem->fg.jointype & JT_LEFT)!=0\n     && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor)\n     && OptimizationEnabled(db, SQLITE_SimplifyJoin)\n    ){\n      SELECTTRACE(0x100,pParse,p,\n                (\"LEFT-JOIN simplifies to JOIN on term %d\\n\",i));\n      pItem->fg.jointype &= ~(JT_LEFT|JT_OUTER);\n      unsetJoinExpr(p->pWhere, pItem->iCursor);\n    }\n\n    /* No futher action if this term of the FROM clause is no a subquery */\n    if( pSub==0 ) continue;\n\n    /* Catch mismatch in the declared columns of a view and the number of\n    ** columns in the SELECT on the RHS */\n    if( pTab->nCol!=pSub->pEList->nExpr ){\n      sqlite3ErrorMsg(pParse, \"expected %d columns for '%s' but got %d\",\n                      pTab->nCol, pTab->zName, pSub->pEList->nExpr);\n      goto select_end;\n    }\n\n    /* Do not try to flatten an aggregate subquery.\n    **\n    ** Flattening an aggregate subquery is only possible if the outer query\n    ** is not a join.  But if the outer query is not a join, then the subquery\n    ** will be implemented as a co-routine and there is no advantage to\n    ** flattening in that case.\n    */\n    if( (pSub->selFlags & SF_Aggregate)!=0 ) continue;\n    assert( pSub->pGroupBy==0 );\n\n    /* If the outer query contains a \"complex\" result set (that is,\n    ** if the result set of the outer query uses functions or subqueries)\n    ** and if the subquery contains an ORDER BY clause and if\n    ** it will be implemented as a co-routine, then do not flatten.  This\n    ** restriction allows SQL constructs like this:\n    **\n    **  SELECT expensive_function(x)\n    **    FROM (SELECT x FROM tab ORDER BY y LIMIT 10);\n    **\n    ** The expensive_function() is only computed on the 10 rows that\n    ** are output, rather than every row of the table.\n    **\n    ** The requirement that the outer query have a complex result set\n    ** means that flattening does occur on simpler SQL constraints without\n    ** the expensive_function() like:\n    **\n    **  SELECT x FROM (SELECT x FROM tab ORDER BY y LIMIT 10);\n    */\n    if( pSub->pOrderBy!=0\n     && i==0\n     && (p->selFlags & SF_ComplexResult)!=0\n     && (pTabList->nSrc==1\n         || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)\n    ){\n      continue;\n    }\n\n    if( flattenSubquery(pParse, p, i, isAgg) ){\n      if( pParse->nErr ) goto select_end;\n      /* This subquery can be absorbed into its parent. */\n      i = -1;\n    }\n    pTabList = p->pSrc;\n    if( db->mallocFailed ) goto select_end;\n    if( !IgnorableOrderby(pDest) ){\n      sSort.pOrderBy = p->pOrderBy;\n    }\n  }\n#endif\n\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n  /* Handle compound SELECT statements using the separate multiSelect()\n  ** procedure.\n  */\n  if( p->pPrior ){\n    rc = multiSelect(pParse, p, pDest);\n#if SELECTTRACE_ENABLED\n    SELECTTRACE(0x1,pParse,p,(\"end compound-select processing\\n\"));\n    if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n    if( p->pNext==0 ) ExplainQueryPlanPop(pParse);\n    return rc;\n  }\n#endif\n\n  /* Do the WHERE-clause constant propagation optimization if this is\n  ** a join.  No need to speed time on this operation for non-join queries\n  ** as the equivalent optimization will be handled by query planner in\n  ** sqlite3WhereBegin().\n  */\n  if( pTabList->nSrc>1\n   && OptimizationEnabled(db, SQLITE_PropagateConst)\n   && propagateConstants(pParse, p)\n  ){\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x100 ){\n      SELECTTRACE(0x100,pParse,p,(\"After constant propagation:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n  }else{\n    SELECTTRACE(0x100,pParse,p,(\"Constant propagation not helpful\\n\"));\n  }\n\n#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION\n  if( OptimizationEnabled(db, SQLITE_QueryFlattener|SQLITE_CountOfView)\n   && countOfViewOptimization(pParse, p)\n  ){\n    if( db->mallocFailed ) goto select_end;\n    pEList = p->pEList;\n    pTabList = p->pSrc;\n  }\n#endif\n\n  /* For each term in the FROM clause, do two things:\n  ** (1) Authorized unreferenced tables\n  ** (2) Generate code for all sub-queries\n  */\n  for(i=0; i<pTabList->nSrc; i++){\n    struct SrcList_item *pItem = &pTabList->a[i];\n    SelectDest dest;\n    Select *pSub;\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n    const char *zSavedAuthContext;\n#endif\n\n    /* Issue SQLITE_READ authorizations with a fake column name for any\n    ** tables that are referenced but from which no values are extracted.\n    ** Examples of where these kinds of null SQLITE_READ authorizations\n    ** would occur:\n    **\n    **     SELECT count(*) FROM t1;   -- SQLITE_READ t1.\"\"\n    **     SELECT t1.* FROM t1, t2;   -- SQLITE_READ t2.\"\"\n    **\n    ** The fake column name is an empty string.  It is possible for a table to\n    ** have a column named by the empty string, in which case there is no way to\n    ** distinguish between an unreferenced table and an actual reference to the\n    ** \"\" column. The original design was for the fake column name to be a NULL,\n    ** which would be unambiguous.  But legacy authorization callbacks might\n    ** assume the column name is non-NULL and segfault.  The use of an empty\n    ** string for the fake column name seems safer.\n    */\n    if( pItem->colUsed==0 && pItem->zName!=0 ){\n      sqlite3AuthCheck(pParse, SQLITE_READ, pItem->zName, \"\", pItem->zDatabase);\n    }\n\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n    /* Generate code for all sub-queries in the FROM clause\n    */\n    pSub = pItem->pSelect;\n    if( pSub==0 ) continue;\n\n    /* The code for a subquery should only be generated once, though it is\n    ** technically harmless for it to be generated multiple times. The\n    ** following assert() will detect if something changes to cause\n    ** the same subquery to be coded multiple times, as a signal to the\n    ** developers to try to optimize the situation.\n    **\n    ** Update 2019-07-24:\n    ** See ticket https://sqlite.org/src/tktview/c52b09c7f38903b1311cec40.\n    ** The dbsqlfuzz fuzzer found a case where the same subquery gets\n    ** coded twice.  So this assert() now becomes a testcase().  It should\n    ** be very rare, though.\n    */\n    testcase( pItem->addrFillSub!=0 );\n\n    /* Increment Parse.nHeight by the height of the largest expression\n    ** tree referred to by this, the parent select. The child select\n    ** may contain expression trees of at most\n    ** (SQLITE_MAX_EXPR_DEPTH-Parse.nHeight) height. This is a bit\n    ** more conservative than necessary, but much easier than enforcing\n    ** an exact limit.\n    */\n    pParse->nHeight += sqlite3SelectExprHeight(p);\n\n    /* Make copies of constant WHERE-clause terms in the outer query down\n    ** inside the subquery.  This can help the subquery to run more efficiently.\n    */\n    if( OptimizationEnabled(db, SQLITE_PushDown)\n     && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem->iCursor,\n                           (pItem->fg.jointype & JT_OUTER)!=0)\n    ){\n#if SELECTTRACE_ENABLED\n      if( sqlite3SelectTrace & 0x100 ){\n        SELECTTRACE(0x100,pParse,p,\n            (\"After WHERE-clause push-down into subquery %d:\\n\", pSub->selId));\n        sqlite3TreeViewSelect(0, p, 0);\n      }\n#endif\n    }else{\n      SELECTTRACE(0x100,pParse,p,(\"Push-down not possible\\n\"));\n    }\n\n    zSavedAuthContext = pParse->zAuthContext;\n    pParse->zAuthContext = pItem->zName;\n\n    /* Generate code to implement the subquery\n    **\n    ** The subquery is implemented as a co-routine if the subquery is\n    ** guaranteed to be the outer loop (so that it does not need to be\n    ** computed more than once)\n    **\n    ** TODO: Are there other reasons beside (1) to use a co-routine\n    ** implementation?\n    */\n    if( i==0\n     && (pTabList->nSrc==1\n            || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)  /* (1) */\n    ){\n      /* Implement a co-routine that will return a single row of the result\n      ** set on each invocation.\n      */\n      int addrTop = sqlite3VdbeCurrentAddr(v)+1;\n     \n      pItem->regReturn = ++pParse->nMem;\n      sqlite3VdbeAddOp3(v, OP_InitCoroutine, pItem->regReturn, 0, addrTop);\n      VdbeComment((v, \"%s\", pItem->pTab->zName));\n      pItem->addrFillSub = addrTop;\n      sqlite3SelectDestInit(&dest, SRT_Coroutine, pItem->regReturn);\n      ExplainQueryPlan((pParse, 1, \"CO-ROUTINE %u\", pSub->selId));\n      sqlite3Select(pParse, pSub, &dest);\n      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n      pItem->fg.viaCoroutine = 1;\n      pItem->regResult = dest.iSdst;\n      sqlite3VdbeEndCoroutine(v, pItem->regReturn);\n      sqlite3VdbeJumpHere(v, addrTop-1);\n      sqlite3ClearTempRegCache(pParse);\n    }else{\n      /* Generate a subroutine that will fill an ephemeral table with\n      ** the content of this subquery.  pItem->addrFillSub will point\n      ** to the address of the generated subroutine.  pItem->regReturn\n      ** is a register allocated to hold the subroutine return address\n      */\n      int topAddr;\n      int onceAddr = 0;\n      int retAddr;\n      struct SrcList_item *pPrior;\n\n      testcase( pItem->addrFillSub==0 ); /* Ticket c52b09c7f38903b1311 */\n      pItem->regReturn = ++pParse->nMem;\n      topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);\n      pItem->addrFillSub = topAddr+1;\n      if( pItem->fg.isCorrelated==0 ){\n        /* If the subquery is not correlated and if we are not inside of\n        ** a trigger, then we only need to compute the value of the subquery\n        ** once. */\n        onceAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n        VdbeComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n      }else{\n        VdbeNoopComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n      }\n      pPrior = isSelfJoinView(pTabList, pItem);\n      if( pPrior ){\n        sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pPrior->iCursor);\n        assert( pPrior->pSelect!=0 );\n        pSub->nSelectRow = pPrior->pSelect->nSelectRow;\n      }else{\n        sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);\n        ExplainQueryPlan((pParse, 1, \"MATERIALIZE %u\", pSub->selId));\n        sqlite3Select(pParse, pSub, &dest);\n      }\n      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n      if( onceAddr ) sqlite3VdbeJumpHere(v, onceAddr);\n      retAddr = sqlite3VdbeAddOp1(v, OP_Return, pItem->regReturn);\n      VdbeComment((v, \"end %s\", pItem->pTab->zName));\n      sqlite3VdbeChangeP1(v, topAddr, retAddr);\n      sqlite3ClearTempRegCache(pParse);\n    }\n    if( db->mallocFailed ) goto select_end;\n    pParse->nHeight -= sqlite3SelectExprHeight(p);\n    pParse->zAuthContext = zSavedAuthContext;\n#endif\n  }\n\n  /* Various elements of the SELECT copied into local variables for\n  ** convenience */\n  pEList = p->pEList;\n  pWhere = p->pWhere;\n  pGroupBy = p->pGroupBy;\n  pHaving = p->pHaving;\n  sDistinct.isTnct = (p->selFlags & SF_Distinct)!=0;\n\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x400 ){\n    SELECTTRACE(0x400,pParse,p,(\"After all FROM-clause analysis:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  /* If the query is DISTINCT with an ORDER BY but is not an aggregate, and \n  ** if the select-list is the same as the ORDER BY list, then this query\n  ** can be rewritten as a GROUP BY. In other words, this:\n  **\n  **     SELECT DISTINCT xyz FROM ... ORDER BY xyz\n  **\n  ** is transformed to:\n  **\n  **     SELECT xyz FROM ... GROUP BY xyz ORDER BY xyz\n  **\n  ** The second form is preferred as a single index (or temp-table) may be \n  ** used for both the ORDER BY and DISTINCT processing. As originally \n  ** written the query must use a temp-table for at least one of the ORDER \n  ** BY and DISTINCT, and an index or separate temp-table for the other.\n  */\n  if( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct \n   && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1)==0\n",
        "suffix": "    p->selFlags &= ~SF_Distinct;\n    pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);\n    /* Notice that even thought SF_Distinct has been cleared from p->selFlags,\n    ** the sDistinct.isTnct is still set.  Hence, isTnct represents the\n    ** original setting of the SF_Distinct flag, not the current setting */\n    assert( sDistinct.isTnct );\n\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x400 ){\n      SELECTTRACE(0x400,pParse,p,(\"Transform DISTINCT into GROUP BY:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n  }\n\n  /* If there is an ORDER BY clause, then create an ephemeral index to\n  ** do the sorting.  But this sorting ephemeral index might end up\n  ** being unused if the data can be extracted in pre-sorted order.\n  ** If that is the case, then the OP_OpenEphemeral instruction will be\n  ** changed to an OP_Noop once we figure out that the sorting index is\n  ** not needed.  The sSort.addrSortIndex variable is used to facilitate\n  ** that change.\n  */\n  if( sSort.pOrderBy ){\n    KeyInfo *pKeyInfo;\n    pKeyInfo = sqlite3KeyInfoFromExprList(\n        pParse, sSort.pOrderBy, 0, pEList->nExpr);\n    sSort.iECursor = pParse->nTab++;\n    sSort.addrSortIndex =\n      sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n          sSort.iECursor, sSort.pOrderBy->nExpr+1+pEList->nExpr, 0,\n          (char*)pKeyInfo, P4_KEYINFO\n      );\n  }else{\n    sSort.addrSortIndex = -1;\n  }\n\n  /* If the output is destined for a temporary table, open that table.\n  */\n  if( pDest->eDest==SRT_EphemTab ){\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pDest->iSDParm, pEList->nExpr);\n  }\n\n  /* Set the limiter.\n  */\n  iEnd = sqlite3VdbeMakeLabel(pParse);\n  if( (p->selFlags & SF_FixedLimit)==0 ){\n    p->nSelectRow = 320;  /* 4 billion rows */\n  }\n  computeLimitRegisters(pParse, p, iEnd);\n  if( p->iLimit==0 && sSort.addrSortIndex>=0 ){\n    sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, OP_SorterOpen);\n    sSort.sortFlags |= SORTFLAG_UseSorter;\n  }\n\n  /* Open an ephemeral index to use for the distinct set.\n  */\n  if( p->selFlags & SF_Distinct ){\n    sDistinct.tabTnct = pParse->nTab++;\n    sDistinct.addrTnct = sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n                       sDistinct.tabTnct, 0, 0,\n                       (char*)sqlite3KeyInfoFromExprList(pParse, p->pEList,0,0),\n                       P4_KEYINFO);\n    sqlite3VdbeChangeP5(v, BTREE_UNORDERED);\n    sDistinct.eTnctType = WHERE_DISTINCT_UNORDERED;\n  }else{\n    sDistinct.eTnctType = WHERE_DISTINCT_NOOP;\n  }\n\n  if( !isAgg && pGroupBy==0 ){\n    /* No aggregate functions and no GROUP BY clause */\n    u16 wctrlFlags = (sDistinct.isTnct ? WHERE_WANT_DISTINCT : 0)\n                   | (p->selFlags & SF_FixedLimit);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    Window *pWin = p->pWin;      /* Master window object (or NULL) */\n    if( pWin ){\n      sqlite3WindowCodeInit(pParse, pWin);\n    }\n#endif\n    assert( WHERE_USE_LIMIT==SF_FixedLimit );\n\n\n    /* Begin the database scan. */\n    SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy,\n                               p->pEList, wctrlFlags, p->nSelectRow);\n    if( pWInfo==0 ) goto select_end;\n    if( sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow ){\n      p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);\n    }\n    if( sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo) ){\n      sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);\n    }\n    if( sSort.pOrderBy ){\n      sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);\n      sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);\n      if( sSort.nOBSat==sSort.pOrderBy->nExpr ){\n        sSort.pOrderBy = 0;\n      }\n    }\n\n    /* If sorting index that was created by a prior OP_OpenEphemeral \n    ** instruction ended up not being needed, then change the OP_OpenEphemeral\n    ** into an OP_Noop.\n    */\n    if( sSort.addrSortIndex>=0 && sSort.pOrderBy==0 ){\n      sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n    }\n\n    assert( p->pEList==pEList );\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    if( pWin ){\n      int addrGosub = sqlite3VdbeMakeLabel(pParse);\n      int iCont = sqlite3VdbeMakeLabel(pParse);\n      int iBreak = sqlite3VdbeMakeLabel(pParse);\n      int regGosub = ++pParse->nMem;\n\n      sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);\n\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, iBreak);\n      sqlite3VdbeResolveLabel(v, addrGosub);\n      VdbeNoopComment((v, \"inner-loop subroutine\"));\n      sSort.labelOBLopt = 0;\n      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);\n      sqlite3VdbeResolveLabel(v, iCont);\n      sqlite3VdbeAddOp1(v, OP_Return, regGosub);\n      VdbeComment((v, \"end inner-loop subroutine\"));\n      sqlite3VdbeResolveLabel(v, iBreak);\n    }else\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n    {\n      /* Use the standard inner loop. */\n      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest,\n          sqlite3WhereContinueLabel(pWInfo),\n          sqlite3WhereBreakLabel(pWInfo));\n\n      /* End the database scan loop.\n      */\n      sqlite3WhereEnd(pWInfo);\n    }\n  }else{\n    /* This case when there exist aggregate functions or a GROUP BY clause\n    ** or both */\n    NameContext sNC;    /* Name context for processing aggregate information */\n    int iAMem;          /* First Mem address for storing current GROUP BY */\n    int iBMem;          /* First Mem address for previous GROUP BY */\n    int iUseFlag;       /* Mem address holding flag indicating that at least\n                        ** one row of the input to the aggregator has been\n                        ** processed */\n    int iAbortFlag;     /* Mem address which causes query abort if positive */\n    int groupBySort;    /* Rows come from source in GROUP BY order */\n    int addrEnd;        /* End of processing for this SELECT */\n    int sortPTab = 0;   /* Pseudotable used to decode sorting results */\n    int sortOut = 0;    /* Output register from the sorter */\n    int orderByGrp = 0; /* True if the GROUP BY and ORDER BY are the same */\n\n    /* Remove any and all aliases between the result set and the\n    ** GROUP BY clause.\n    */\n    if( pGroupBy ){\n      int k;                        /* Loop counter */\n      struct ExprList_item *pItem;  /* For looping over expression in a list */\n\n      for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++){\n        pItem->u.x.iAlias = 0;\n      }\n      for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++){\n        pItem->u.x.iAlias = 0;\n      }\n      assert( 66==sqlite3LogEst(100) );\n      if( p->nSelectRow>66 ) p->nSelectRow = 66;\n\n      /* If there is both a GROUP BY and an ORDER BY clause and they are\n      ** identical, then it may be possible to disable the ORDER BY clause \n      ** on the grounds that the GROUP BY will cause elements to come out \n      ** in the correct order. It also may not - the GROUP BY might use a\n      ** database index that causes rows to be grouped together as required\n      ** but not actually sorted. Either way, record the fact that the\n      ** ORDER BY and GROUP BY clauses are the same by setting the orderByGrp\n      ** variable.  */\n      if( sSort.pOrderBy && pGroupBy->nExpr==sSort.pOrderBy->nExpr ){\n        int ii;\n        /* The GROUP BY processing doesn't care whether rows are delivered in\n        ** ASC or DESC order - only that each group is returned contiguously.\n        ** So set the ASC/DESC flags in the GROUP BY to match those in the \n        ** ORDER BY to maximize the chances of rows being delivered in an \n        ** order that makes the ORDER BY redundant.  */\n        for(ii=0; ii<pGroupBy->nExpr; ii++){\n          u8 sortFlags = sSort.pOrderBy->a[ii].sortFlags & KEYINFO_ORDER_DESC;\n          pGroupBy->a[ii].sortFlags = sortFlags;\n        }\n        if( sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1)==0 ){\n          orderByGrp = 1;\n        }\n      }\n    }else{\n      assert( 0==sqlite3LogEst(1) );\n      p->nSelectRow = 0;\n    }\n\n    /* Create a label to jump to when we want to abort the query */\n    addrEnd = sqlite3VdbeMakeLabel(pParse);\n\n    /* Convert TK_COLUMN nodes into TK_AGG_COLUMN and make entries in\n    ** sAggInfo for all TK_AGG_FUNCTION nodes in expressions of the\n    ** SELECT statement.\n    */\n    memset(&sNC, 0, sizeof(sNC));\n    sNC.pParse = pParse;\n    sNC.pSrcList = pTabList;\n    sNC.uNC.pAggInfo = &sAggInfo;\n    VVA_ONLY( sNC.ncFlags = NC_UAggInfo; )\n    sAggInfo.mnReg = pParse->nMem+1;\n    sAggInfo.nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;\n    sAggInfo.pGroupBy = pGroupBy;\n    sqlite3ExprAnalyzeAggList(&sNC, pEList);\n    sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);\n    if( pHaving ){\n      if( pGroupBy ){\n        assert( pWhere==p->pWhere );\n        assert( pHaving==p->pHaving );\n        assert( pGroupBy==p->pGroupBy );\n        havingToWhere(pParse, p);\n        pWhere = p->pWhere;\n      }\n      sqlite3ExprAnalyzeAggregates(&sNC, pHaving);\n    }\n    sAggInfo.nAccumulator = sAggInfo.nColumn;\n    if( p->pGroupBy==0 && p->pHaving==0 && sAggInfo.nFunc==1 ){\n      minMaxFlag = minMaxQuery(db, sAggInfo.aFunc[0].pExpr, &pMinMaxOrderBy);\n    }else{\n      minMaxFlag = WHERE_ORDERBY_NORMAL;\n    }\n    for(i=0; i<sAggInfo.nFunc; i++){\n      Expr *pExpr = sAggInfo.aFunc[i].pExpr;\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      sNC.ncFlags |= NC_InAggFunc;\n      sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      assert( !IsWindowFunc(pExpr) );\n      if( ExprHasProperty(pExpr, EP_WinFunc) ){\n        sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);\n      }\n#endif\n      sNC.ncFlags &= ~NC_InAggFunc;\n    }\n    sAggInfo.mxReg = pParse->nMem;\n    if( db->mallocFailed ) goto select_end;\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x400 ){\n      int ii;\n      SELECTTRACE(0x400,pParse,p,(\"After aggregate analysis:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n      for(ii=0; ii<sAggInfo.nColumn; ii++){\n        sqlite3DebugPrintf(\"agg-column[%d] iMem=%d\\n\",\n            ii, sAggInfo.aCol[ii].iMem);\n        sqlite3TreeViewExpr(0, sAggInfo.aCol[ii].pExpr, 0);\n      }\n      for(ii=0; ii<sAggInfo.nFunc; ii++){\n        sqlite3DebugPrintf(\"agg-func[%d]: iMem=%d\\n\",\n            ii, sAggInfo.aFunc[ii].iMem);\n        sqlite3TreeViewExpr(0, sAggInfo.aFunc[ii].pExpr, 0);\n      }\n    }\n#endif\n\n\n    /* Processing for aggregates with GROUP BY is very different and\n    ** much more complex than aggregates without a GROUP BY.\n    */\n    if( pGroupBy ){\n      KeyInfo *pKeyInfo;  /* Keying information for the group by clause */\n      int addr1;          /* A-vs-B comparision jump */\n      int addrOutputRow;  /* Start of subroutine that outputs a result row */\n      int regOutputRow;   /* Return address register for output subroutine */\n      int addrSetAbort;   /* Set the abort flag and return */\n      int addrTopOfLoop;  /* Top of the input loop */\n      int addrSortingIdx; /* The OP_OpenEphemeral for the sorting index */\n      int addrReset;      /* Subroutine for resetting the accumulator */\n      int regReset;       /* Return address register for reset subroutine */\n\n      /* If there is a GROUP BY clause we might need a sorting index to\n      ** implement it.  Allocate that sorting index now.  If it turns out\n      ** that we do not need it after all, the OP_SorterOpen instruction\n      ** will be converted into a Noop.  \n      */\n      sAggInfo.sortingIdx = pParse->nTab++;\n      pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pGroupBy,0,sAggInfo.nColumn);\n      addrSortingIdx = sqlite3VdbeAddOp4(v, OP_SorterOpen, \n          sAggInfo.sortingIdx, sAggInfo.nSortingColumn, \n          0, (char*)pKeyInfo, P4_KEYINFO);\n\n      /* Initialize memory locations used by GROUP BY aggregate processing\n      */\n      iUseFlag = ++pParse->nMem;\n      iAbortFlag = ++pParse->nMem;\n      regOutputRow = ++pParse->nMem;\n      addrOutputRow = sqlite3VdbeMakeLabel(pParse);\n      regReset = ++pParse->nMem;\n      addrReset = sqlite3VdbeMakeLabel(pParse);\n      iAMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      iBMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iAbortFlag);\n      VdbeComment((v, \"clear abort flag\"));\n      sqlite3VdbeAddOp3(v, OP_Null, 0, iAMem, iAMem+pGroupBy->nExpr-1);\n\n      /* Begin a loop that will extract all source rows in GROUP BY order.\n      ** This might involve two separate loops with an OP_Sort in between, or\n      ** it might be a single loop that uses an index to extract information\n      ** in the right order to begin with.\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, 0,\n          WHERE_GROUPBY | (orderByGrp ? WHERE_SORTBYGROUP : 0), 0\n      );\n      if( pWInfo==0 ) goto select_end;\n      if( sqlite3WhereIsOrdered(pWInfo)==pGroupBy->nExpr ){\n        /* The optimizer is able to deliver rows in group by order so\n        ** we do not have to sort.  The OP_OpenEphemeral table will be\n        ** cancelled later because we still need to use the pKeyInfo\n        */\n        groupBySort = 0;\n      }else{\n        /* Rows are coming out in undetermined order.  We have to push\n        ** each row into a sorting index, terminate the first loop,\n        ** then loop over the sorting index in order to get the output\n        ** in sorted order\n        */\n        int regBase;\n        int regRecord;\n        int nCol;\n        int nGroupBy;\n\n        explainTempTable(pParse, \n            (sDistinct.isTnct && (p->selFlags&SF_Distinct)==0) ?\n                    \"DISTINCT\" : \"GROUP BY\");\n\n        groupBySort = 1;\n        nGroupBy = pGroupBy->nExpr;\n        nCol = nGroupBy;\n        j = nGroupBy;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          if( sAggInfo.aCol[i].iSorterColumn>=j ){\n            nCol++;\n            j++;\n          }\n        }\n        regBase = sqlite3GetTempRange(pParse, nCol);\n        sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);\n        j = nGroupBy;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          struct AggInfo_col *pCol = &sAggInfo.aCol[i];\n          if( pCol->iSorterColumn>=j ){\n            int r1 = j + regBase;\n            sqlite3ExprCodeGetColumnOfTable(v,\n                               pCol->pTab, pCol->iTable, pCol->iColumn, r1);\n            j++;\n          }\n        }\n        regRecord = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regRecord);\n        sqlite3VdbeAddOp2(v, OP_SorterInsert, sAggInfo.sortingIdx, regRecord);\n        sqlite3ReleaseTempReg(pParse, regRecord);\n        sqlite3ReleaseTempRange(pParse, regBase, nCol);\n        sqlite3WhereEnd(pWInfo);\n        sAggInfo.sortingIdxPTab = sortPTab = pParse->nTab++;\n        sortOut = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_OpenPseudo, sortPTab, sortOut, nCol);\n        sqlite3VdbeAddOp2(v, OP_SorterSort, sAggInfo.sortingIdx, addrEnd);\n        VdbeComment((v, \"GROUP BY sort\")); VdbeCoverage(v);\n        sAggInfo.useSortingIdx = 1;\n      }\n\n      /* If the index or temporary table used by the GROUP BY sort\n      ** will naturally deliver rows in the order required by the ORDER BY\n      ** clause, cancel the ephemeral table open coded earlier.\n      **\n      ** This is an optimization - the correct answer should result regardless.\n      ** Use the SQLITE_GroupByOrder flag with SQLITE_TESTCTRL_OPTIMIZER to \n      ** disable this optimization for testing purposes.  */\n      if( orderByGrp && OptimizationEnabled(db, SQLITE_GroupByOrder) \n       && (groupBySort || sqlite3WhereIsSorted(pWInfo))\n      ){\n        sSort.pOrderBy = 0;\n        sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n      }\n\n      /* Evaluate the current GROUP BY terms and store in b0, b1, b2...\n      ** (b0 is memory location iBMem+0, b1 is iBMem+1, and so forth)\n      ** Then compare the current GROUP BY terms against the GROUP BY terms\n      ** from the previous row currently stored in a0, a1, a2...\n      */\n      addrTopOfLoop = sqlite3VdbeCurrentAddr(v);\n      if( groupBySort ){\n        sqlite3VdbeAddOp3(v, OP_SorterData, sAggInfo.sortingIdx,\n                          sortOut, sortPTab);\n      }\n      for(j=0; j<pGroupBy->nExpr; j++){\n        if( groupBySort ){\n          sqlite3VdbeAddOp3(v, OP_Column, sortPTab, j, iBMem+j);\n        }else{\n          sAggInfo.directMode = 1;\n          sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j);\n        }\n      }\n      sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy->nExpr,\n                          (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);\n      addr1 = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp3(v, OP_Jump, addr1+1, 0, addr1+1); VdbeCoverage(v);\n\n      /* Generate code that runs whenever the GROUP BY changes.\n      ** Changes in the GROUP BY are detected by the previous code\n      ** block.  If there were no changes, this block is skipped.\n      **\n      ** This code copies current group by terms in b0,b1,b2,...\n      ** over to a0,a1,a2.  It then calls the output subroutine\n      ** and resets the aggregate accumulator registers in preparation\n      ** for the next GROUP BY batch.\n      */\n      sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output one row\"));\n      sqlite3VdbeAddOp2(v, OP_IfPos, iAbortFlag, addrEnd); VdbeCoverage(v);\n      VdbeComment((v, \"check abort flag\"));\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      VdbeComment((v, \"reset accumulator\"));\n\n      /* Update the aggregate accumulators based on the content of\n      ** the current row\n      */\n      sqlite3VdbeJumpHere(v, addr1);\n      updateAccumulator(pParse, iUseFlag, &sAggInfo);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag);\n      VdbeComment((v, \"indicate data in accumulator\"));\n\n      /* End of the loop\n      */\n      if( groupBySort ){\n        sqlite3VdbeAddOp2(v, OP_SorterNext, sAggInfo.sortingIdx, addrTopOfLoop);\n        VdbeCoverage(v);\n      }else{\n        sqlite3WhereEnd(pWInfo);\n        sqlite3VdbeChangeToNoop(v, addrSortingIdx);\n      }\n\n      /* Output the final row of result\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output final row\"));\n\n      /* Jump over the subroutines\n      */\n      sqlite3VdbeGoto(v, addrEnd);\n\n      /* Generate a subroutine that outputs a single row of the result\n      ** set.  This subroutine first looks at the iUseFlag.  If iUseFlag\n      ** is less than or equal to zero, the subroutine is a no-op.  If\n      ** the processing calls for the query to abort, this subroutine\n      ** increments the iAbortFlag memory location before returning in\n      ** order to signal the caller to abort.\n      */\n      addrSetAbort = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iAbortFlag);\n      VdbeComment((v, \"set abort flag\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      sqlite3VdbeResolveLabel(v, addrOutputRow);\n      addrOutputRow = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_IfPos, iUseFlag, addrOutputRow+2);\n      VdbeCoverage(v);\n      VdbeComment((v, \"Groupby result generator entry point\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      finalizeAggFunctions(pParse, &sAggInfo);\n      sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, -1, &sSort,\n                      &sDistinct, pDest,\n                      addrOutputRow+1, addrSetAbort);\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      VdbeComment((v, \"end groupby result generator\"));\n\n      /* Generate a subroutine that will reset the group-by accumulator\n      */\n      sqlite3VdbeResolveLabel(v, addrReset);\n      resetAccumulator(pParse, &sAggInfo);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iUseFlag);\n      VdbeComment((v, \"indicate accumulator empty\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regReset);\n     \n    } /* endif pGroupBy.  Begin aggregate queries without GROUP BY: */\n    else {\n#ifndef SQLITE_OMIT_BTREECOUNT\n      Table *pTab;\n      if( (pTab = isSimpleCount(p, &sAggInfo))!=0 ){\n        /* If isSimpleCount() returns a pointer to a Table structure, then\n        ** the SQL statement is of the form:\n        **\n        **   SELECT count(*) FROM <tbl>\n        **\n        ** where the Table structure returned represents table <tbl>.\n        **\n        ** This statement is so common that it is optimized specially. The\n        ** OP_Count instruction is executed either on the intkey table that\n        ** contains the data for table <tbl> or on one of its indexes. It\n        ** is better to execute the op on an index, as indexes are almost\n        ** always spread across less pages than their corresponding tables.\n        */\n        const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n        const int iCsr = pParse->nTab++;     /* Cursor to scan b-tree */\n        Index *pIdx;                         /* Iterator variable */\n        KeyInfo *pKeyInfo = 0;               /* Keyinfo for scanned index */\n        Index *pBest = 0;                    /* Best index found so far */\n        int iRoot = pTab->tnum;              /* Root page of scanned b-tree */\n\n        sqlite3CodeVerifySchema(pParse, iDb);\n        sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n\n        /* Search for the index that has the lowest scan cost.\n        **\n        ** (2011-04-15) Do not do a full scan of an unordered index.\n        **\n        ** (2013-10-03) Do not count the entries in a partial index.\n        **\n        ** In practice the KeyInfo structure will not be used. It is only \n        ** passed to keep OP_OpenRead happy.\n        */\n        if( !HasRowid(pTab) ) pBest = sqlite3PrimaryKeyIndex(pTab);\n        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n          if( pIdx->bUnordered==0\n           && pIdx->szIdxRow<pTab->szTabRow\n           && pIdx->pPartIdxWhere==0\n           && (!pBest || pIdx->szIdxRow<pBest->szIdxRow)\n          ){\n            pBest = pIdx;\n          }\n        }\n        if( pBest ){\n          iRoot = pBest->tnum;\n          pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);\n        }\n\n        /* Open a read-only cursor, execute the OP_Count, close the cursor. */\n        sqlite3VdbeAddOp4Int(v, OP_OpenRead, iCsr, iRoot, iDb, 1);\n        if( pKeyInfo ){\n          sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, P4_KEYINFO);\n        }\n        sqlite3VdbeAddOp2(v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem);\n        sqlite3VdbeAddOp1(v, OP_Close, iCsr);\n        explainSimpleCount(pParse, pTab, pBest);\n      }else\n#endif /* SQLITE_OMIT_BTREECOUNT */\n      {\n        int regAcc = 0;           /* \"populate accumulators\" flag */\n\n        /* If there are accumulator registers but no min() or max() functions\n        ** without FILTER clauses, allocate register regAcc. Register regAcc\n        ** will contain 0 the first time the inner loop runs, and 1 thereafter.\n        ** The code generated by updateAccumulator() uses this to ensure\n        ** that the accumulator registers are (a) updated only once if\n        ** there are no min() or max functions or (b) always updated for the\n        ** first row visited by the aggregate, so that they are updated at\n        ** least once even if the FILTER clause means the min() or max() \n        ** function visits zero rows.  */\n        if( sAggInfo.nAccumulator ){\n          for(i=0; i<sAggInfo.nFunc; i++){\n            if( ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_WinFunc) ) continue;\n            if( sAggInfo.aFunc[i].pFunc->funcFlags&SQLITE_FUNC_NEEDCOLL ) break;\n          }\n          if( i==sAggInfo.nFunc ){\n            regAcc = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, OP_Integer, 0, regAcc);\n          }\n        }\n\n        /* This case runs if the aggregate has no GROUP BY clause.  The\n        ** processing is much simpler since there is only a single row\n        ** of output.\n        */\n        assert( p->pGroupBy==0 );\n        resetAccumulator(pParse, &sAggInfo);\n\n        /* If this query is a candidate for the min/max optimization, then\n        ** minMaxFlag will have been previously set to either\n        ** WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX and pMinMaxOrderBy will\n        ** be an appropriate ORDER BY expression for the optimization.\n        */\n        assert( minMaxFlag==WHERE_ORDERBY_NORMAL || pMinMaxOrderBy!=0 );\n        assert( pMinMaxOrderBy==0 || pMinMaxOrderBy->nExpr==1 );\n\n        SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy,\n                                   0, minMaxFlag, 0);\n        if( pWInfo==0 ){\n          goto select_end;\n        }\n        updateAccumulator(pParse, regAcc, &sAggInfo);\n        if( regAcc ) sqlite3VdbeAddOp2(v, OP_Integer, 1, regAcc);\n        if( sqlite3WhereIsOrdered(pWInfo)>0 ){\n          sqlite3VdbeGoto(v, sqlite3WhereBreakLabel(pWInfo));\n          VdbeComment((v, \"%s() by index\",\n                (minMaxFlag==WHERE_ORDERBY_MIN?\"min\":\"max\")));\n        }\n        sqlite3WhereEnd(pWInfo);\n        finalizeAggFunctions(pParse, &sAggInfo);\n      }\n\n      sSort.pOrderBy = 0;\n      sqlite3ExprIfFalse(pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, -1, 0, 0, \n                      pDest, addrEnd, addrEnd);\n    }\n    sqlite3VdbeResolveLabel(v, addrEnd);\n    \n  } /* endif aggregate query */\n\n  if( sDistinct.eTnctType==WHERE_DISTINCT_UNORDERED ){\n    explainTempTable(pParse, \"DISTINCT\");\n  }\n\n  /* If there is an ORDER BY clause, then we need to sort the results\n  ** and send them to the callback one by one.\n  */\n  if( sSort.pOrderBy ){\n    explainTempTable(pParse,\n                     sSort.nOBSat>0 ? \"RIGHT PART OF ORDER BY\":\"ORDER BY\");\n    assert( p->pEList==pEList );\n    generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);\n  }\n\n  /* Jump here to skip this query\n  */\n  sqlite3VdbeResolveLabel(v, iEnd);\n\n  /* The SELECT has been coded. If there is an error in the Parse structure,\n  ** set the return code to 1. Otherwise 0. */\n  rc = (pParse->nErr>0);\n\n  /* Control jumps to here if an error is encountered above, or upon\n  ** successful coding of the SELECT.\n  */\nselect_end:\n  sqlite3ExprListDelete(db, pMinMaxOrderBy);\n  sqlite3DbFree(db, sAggInfo.aCol);\n  sqlite3DbFree(db, sAggInfo.aFunc);\n#if SELECTTRACE_ENABLED\n  SELECTTRACE(0x1,pParse,p,(\"end processing\\n\"));\n  if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n  ExplainQueryPlanPop(pParse);\n  return rc;\n}\n",
        "start": 5662,
        "end": 6721,
        "buggy": "int sqlite3Select(\n  Parse *pParse,         /* The parser context */\n  Select *p,             /* The SELECT statement being coded. */\n  SelectDest *pDest      /* What to do with the query results */\n){\n  int i, j;              /* Loop counters */\n  WhereInfo *pWInfo;     /* Return from sqlite3WhereBegin() */\n  Vdbe *v;               /* The virtual machine under construction */\n  int isAgg;             /* True for select lists like \"count(*)\" */\n  ExprList *pEList = 0;  /* List of columns to extract. */\n  SrcList *pTabList;     /* List of tables to select from */\n  Expr *pWhere;          /* The WHERE clause.  May be NULL */\n  ExprList *pGroupBy;    /* The GROUP BY clause.  May be NULL */\n  Expr *pHaving;         /* The HAVING clause.  May be NULL */\n  int rc = 1;            /* Value to return from this function */\n  DistinctCtx sDistinct; /* Info on how to code the DISTINCT keyword */\n  SortCtx sSort;         /* Info on how to code the ORDER BY clause */\n  AggInfo sAggInfo;      /* Information used by aggregate queries */\n  int iEnd;              /* Address of the end of the query */\n  sqlite3 *db;           /* The database connection */\n  ExprList *pMinMaxOrderBy = 0;  /* Added ORDER BY for min/max queries */\n  u8 minMaxFlag;                 /* Flag for min/max queries */\n\n  db = pParse->db;\n  v = sqlite3GetVdbe(pParse);\n  if( p==0 || db->mallocFailed || pParse->nErr ){\n    return 1;\n  }\n  if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) return 1;\n  memset(&sAggInfo, 0, sizeof(sAggInfo));\n#if SELECTTRACE_ENABLED\n  SELECTTRACE(1,pParse,p, (\"begin processing:\\n\", pParse->addrExplain));\n  if( sqlite3SelectTrace & 0x100 ){\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistFifo );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Fifo );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistQueue );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Queue );\n  if( IgnorableOrderby(pDest) ){\n    assert(pDest->eDest==SRT_Exists || pDest->eDest==SRT_Union || \n           pDest->eDest==SRT_Except || pDest->eDest==SRT_Discard ||\n           pDest->eDest==SRT_Queue  || pDest->eDest==SRT_DistFifo ||\n           pDest->eDest==SRT_DistQueue || pDest->eDest==SRT_Fifo);\n    /* If ORDER BY makes no difference in the output then neither does\n    ** DISTINCT so it can be removed too. */\n    sqlite3ExprListDelete(db, p->pOrderBy);\n    p->pOrderBy = 0;\n    p->selFlags &= ~SF_Distinct;\n  }\n  sqlite3SelectPrep(pParse, p, 0);\n  if( pParse->nErr || db->mallocFailed ){\n    goto select_end;\n  }\n  assert( p->pEList!=0 );\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x104 ){\n    SELECTTRACE(0x104,pParse,p, (\"after name resolution:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  if( pDest->eDest==SRT_Output ){\n    generateColumnNames(pParse, p);\n  }\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( sqlite3WindowRewrite(pParse, p) ){\n    goto select_end;\n  }\n#if SELECTTRACE_ENABLED\n  if( p->pWin && (sqlite3SelectTrace & 0x108)!=0 ){\n    SELECTTRACE(0x104,pParse,p, (\"after window rewrite:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n  pTabList = p->pSrc;\n  isAgg = (p->selFlags & SF_Aggregate)!=0;\n  memset(&sSort, 0, sizeof(sSort));\n  sSort.pOrderBy = p->pOrderBy;\n\n  /* Try to various optimizations (flattening subqueries, and strength\n  ** reduction of join operators) in the FROM clause up into the main query\n  */\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n  for(i=0; !p->pPrior && i<pTabList->nSrc; i++){\n    struct SrcList_item *pItem = &pTabList->a[i];\n    Select *pSub = pItem->pSelect;\n    Table *pTab = pItem->pTab;\n\n    /* Convert LEFT JOIN into JOIN if there are terms of the right table\n    ** of the LEFT JOIN used in the WHERE clause.\n    */\n    if( (pItem->fg.jointype & JT_LEFT)!=0\n     && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor)\n     && OptimizationEnabled(db, SQLITE_SimplifyJoin)\n    ){\n      SELECTTRACE(0x100,pParse,p,\n                (\"LEFT-JOIN simplifies to JOIN on term %d\\n\",i));\n      pItem->fg.jointype &= ~(JT_LEFT|JT_OUTER);\n      unsetJoinExpr(p->pWhere, pItem->iCursor);\n    }\n\n    /* No futher action if this term of the FROM clause is no a subquery */\n    if( pSub==0 ) continue;\n\n    /* Catch mismatch in the declared columns of a view and the number of\n    ** columns in the SELECT on the RHS */\n    if( pTab->nCol!=pSub->pEList->nExpr ){\n      sqlite3ErrorMsg(pParse, \"expected %d columns for '%s' but got %d\",\n                      pTab->nCol, pTab->zName, pSub->pEList->nExpr);\n      goto select_end;\n    }\n\n    /* Do not try to flatten an aggregate subquery.\n    **\n    ** Flattening an aggregate subquery is only possible if the outer query\n    ** is not a join.  But if the outer query is not a join, then the subquery\n    ** will be implemented as a co-routine and there is no advantage to\n    ** flattening in that case.\n    */\n    if( (pSub->selFlags & SF_Aggregate)!=0 ) continue;\n    assert( pSub->pGroupBy==0 );\n\n    /* If the outer query contains a \"complex\" result set (that is,\n    ** if the result set of the outer query uses functions or subqueries)\n    ** and if the subquery contains an ORDER BY clause and if\n    ** it will be implemented as a co-routine, then do not flatten.  This\n    ** restriction allows SQL constructs like this:\n    **\n    **  SELECT expensive_function(x)\n    **    FROM (SELECT x FROM tab ORDER BY y LIMIT 10);\n    **\n    ** The expensive_function() is only computed on the 10 rows that\n    ** are output, rather than every row of the table.\n    **\n    ** The requirement that the outer query have a complex result set\n    ** means that flattening does occur on simpler SQL constraints without\n    ** the expensive_function() like:\n    **\n    **  SELECT x FROM (SELECT x FROM tab ORDER BY y LIMIT 10);\n    */\n    if( pSub->pOrderBy!=0\n     && i==0\n     && (p->selFlags & SF_ComplexResult)!=0\n     && (pTabList->nSrc==1\n         || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)\n    ){\n      continue;\n    }\n\n    if( flattenSubquery(pParse, p, i, isAgg) ){\n      if( pParse->nErr ) goto select_end;\n      /* This subquery can be absorbed into its parent. */\n      i = -1;\n    }\n    pTabList = p->pSrc;\n    if( db->mallocFailed ) goto select_end;\n    if( !IgnorableOrderby(pDest) ){\n      sSort.pOrderBy = p->pOrderBy;\n    }\n  }\n#endif\n\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n  /* Handle compound SELECT statements using the separate multiSelect()\n  ** procedure.\n  */\n  if( p->pPrior ){\n    rc = multiSelect(pParse, p, pDest);\n#if SELECTTRACE_ENABLED\n    SELECTTRACE(0x1,pParse,p,(\"end compound-select processing\\n\"));\n    if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n    if( p->pNext==0 ) ExplainQueryPlanPop(pParse);\n    return rc;\n  }\n#endif\n\n  /* Do the WHERE-clause constant propagation optimization if this is\n  ** a join.  No need to speed time on this operation for non-join queries\n  ** as the equivalent optimization will be handled by query planner in\n  ** sqlite3WhereBegin().\n  */\n  if( pTabList->nSrc>1\n   && OptimizationEnabled(db, SQLITE_PropagateConst)\n   && propagateConstants(pParse, p)\n  ){\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x100 ){\n      SELECTTRACE(0x100,pParse,p,(\"After constant propagation:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n  }else{\n    SELECTTRACE(0x100,pParse,p,(\"Constant propagation not helpful\\n\"));\n  }\n\n#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION\n  if( OptimizationEnabled(db, SQLITE_QueryFlattener|SQLITE_CountOfView)\n   && countOfViewOptimization(pParse, p)\n  ){\n    if( db->mallocFailed ) goto select_end;\n    pEList = p->pEList;\n    pTabList = p->pSrc;\n  }\n#endif\n\n  /* For each term in the FROM clause, do two things:\n  ** (1) Authorized unreferenced tables\n  ** (2) Generate code for all sub-queries\n  */\n  for(i=0; i<pTabList->nSrc; i++){\n    struct SrcList_item *pItem = &pTabList->a[i];\n    SelectDest dest;\n    Select *pSub;\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n    const char *zSavedAuthContext;\n#endif\n\n    /* Issue SQLITE_READ authorizations with a fake column name for any\n    ** tables that are referenced but from which no values are extracted.\n    ** Examples of where these kinds of null SQLITE_READ authorizations\n    ** would occur:\n    **\n    **     SELECT count(*) FROM t1;   -- SQLITE_READ t1.\"\"\n    **     SELECT t1.* FROM t1, t2;   -- SQLITE_READ t2.\"\"\n    **\n    ** The fake column name is an empty string.  It is possible for a table to\n    ** have a column named by the empty string, in which case there is no way to\n    ** distinguish between an unreferenced table and an actual reference to the\n    ** \"\" column. The original design was for the fake column name to be a NULL,\n    ** which would be unambiguous.  But legacy authorization callbacks might\n    ** assume the column name is non-NULL and segfault.  The use of an empty\n    ** string for the fake column name seems safer.\n    */\n    if( pItem->colUsed==0 && pItem->zName!=0 ){\n      sqlite3AuthCheck(pParse, SQLITE_READ, pItem->zName, \"\", pItem->zDatabase);\n    }\n\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n    /* Generate code for all sub-queries in the FROM clause\n    */\n    pSub = pItem->pSelect;\n    if( pSub==0 ) continue;\n\n    /* The code for a subquery should only be generated once, though it is\n    ** technically harmless for it to be generated multiple times. The\n    ** following assert() will detect if something changes to cause\n    ** the same subquery to be coded multiple times, as a signal to the\n    ** developers to try to optimize the situation.\n    **\n    ** Update 2019-07-24:\n    ** See ticket https://sqlite.org/src/tktview/c52b09c7f38903b1311cec40.\n    ** The dbsqlfuzz fuzzer found a case where the same subquery gets\n    ** coded twice.  So this assert() now becomes a testcase().  It should\n    ** be very rare, though.\n    */\n    testcase( pItem->addrFillSub!=0 );\n\n    /* Increment Parse.nHeight by the height of the largest expression\n    ** tree referred to by this, the parent select. The child select\n    ** may contain expression trees of at most\n    ** (SQLITE_MAX_EXPR_DEPTH-Parse.nHeight) height. This is a bit\n    ** more conservative than necessary, but much easier than enforcing\n    ** an exact limit.\n    */\n    pParse->nHeight += sqlite3SelectExprHeight(p);\n\n    /* Make copies of constant WHERE-clause terms in the outer query down\n    ** inside the subquery.  This can help the subquery to run more efficiently.\n    */\n    if( OptimizationEnabled(db, SQLITE_PushDown)\n     && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem->iCursor,\n                           (pItem->fg.jointype & JT_OUTER)!=0)\n    ){\n#if SELECTTRACE_ENABLED\n      if( sqlite3SelectTrace & 0x100 ){\n        SELECTTRACE(0x100,pParse,p,\n            (\"After WHERE-clause push-down into subquery %d:\\n\", pSub->selId));\n        sqlite3TreeViewSelect(0, p, 0);\n      }\n#endif\n    }else{\n      SELECTTRACE(0x100,pParse,p,(\"Push-down not possible\\n\"));\n    }\n\n    zSavedAuthContext = pParse->zAuthContext;\n    pParse->zAuthContext = pItem->zName;\n\n    /* Generate code to implement the subquery\n    **\n    ** The subquery is implemented as a co-routine if the subquery is\n    ** guaranteed to be the outer loop (so that it does not need to be\n    ** computed more than once)\n    **\n    ** TODO: Are there other reasons beside (1) to use a co-routine\n    ** implementation?\n    */\n    if( i==0\n     && (pTabList->nSrc==1\n            || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)  /* (1) */\n    ){\n      /* Implement a co-routine that will return a single row of the result\n      ** set on each invocation.\n      */\n      int addrTop = sqlite3VdbeCurrentAddr(v)+1;\n     \n      pItem->regReturn = ++pParse->nMem;\n      sqlite3VdbeAddOp3(v, OP_InitCoroutine, pItem->regReturn, 0, addrTop);\n      VdbeComment((v, \"%s\", pItem->pTab->zName));\n      pItem->addrFillSub = addrTop;\n      sqlite3SelectDestInit(&dest, SRT_Coroutine, pItem->regReturn);\n      ExplainQueryPlan((pParse, 1, \"CO-ROUTINE %u\", pSub->selId));\n      sqlite3Select(pParse, pSub, &dest);\n      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n      pItem->fg.viaCoroutine = 1;\n      pItem->regResult = dest.iSdst;\n      sqlite3VdbeEndCoroutine(v, pItem->regReturn);\n      sqlite3VdbeJumpHere(v, addrTop-1);\n      sqlite3ClearTempRegCache(pParse);\n    }else{\n      /* Generate a subroutine that will fill an ephemeral table with\n      ** the content of this subquery.  pItem->addrFillSub will point\n      ** to the address of the generated subroutine.  pItem->regReturn\n      ** is a register allocated to hold the subroutine return address\n      */\n      int topAddr;\n      int onceAddr = 0;\n      int retAddr;\n      struct SrcList_item *pPrior;\n\n      testcase( pItem->addrFillSub==0 ); /* Ticket c52b09c7f38903b1311 */\n      pItem->regReturn = ++pParse->nMem;\n      topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);\n      pItem->addrFillSub = topAddr+1;\n      if( pItem->fg.isCorrelated==0 ){\n        /* If the subquery is not correlated and if we are not inside of\n        ** a trigger, then we only need to compute the value of the subquery\n        ** once. */\n        onceAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n        VdbeComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n      }else{\n        VdbeNoopComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n      }\n      pPrior = isSelfJoinView(pTabList, pItem);\n      if( pPrior ){\n        sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pPrior->iCursor);\n        assert( pPrior->pSelect!=0 );\n        pSub->nSelectRow = pPrior->pSelect->nSelectRow;\n      }else{\n        sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);\n        ExplainQueryPlan((pParse, 1, \"MATERIALIZE %u\", pSub->selId));\n        sqlite3Select(pParse, pSub, &dest);\n      }\n      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n      if( onceAddr ) sqlite3VdbeJumpHere(v, onceAddr);\n      retAddr = sqlite3VdbeAddOp1(v, OP_Return, pItem->regReturn);\n      VdbeComment((v, \"end %s\", pItem->pTab->zName));\n      sqlite3VdbeChangeP1(v, topAddr, retAddr);\n      sqlite3ClearTempRegCache(pParse);\n    }\n    if( db->mallocFailed ) goto select_end;\n    pParse->nHeight -= sqlite3SelectExprHeight(p);\n    pParse->zAuthContext = zSavedAuthContext;\n#endif\n  }\n\n  /* Various elements of the SELECT copied into local variables for\n  ** convenience */\n  pEList = p->pEList;\n  pWhere = p->pWhere;\n  pGroupBy = p->pGroupBy;\n  pHaving = p->pHaving;\n  sDistinct.isTnct = (p->selFlags & SF_Distinct)!=0;\n\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x400 ){\n    SELECTTRACE(0x400,pParse,p,(\"After all FROM-clause analysis:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  /* If the query is DISTINCT with an ORDER BY but is not an aggregate, and \n  ** if the select-list is the same as the ORDER BY list, then this query\n  ** can be rewritten as a GROUP BY. In other words, this:\n  **\n  **     SELECT DISTINCT xyz FROM ... ORDER BY xyz\n  **\n  ** is transformed to:\n  **\n  **     SELECT xyz FROM ... GROUP BY xyz ORDER BY xyz\n  **\n  ** The second form is preferred as a single index (or temp-table) may be \n  ** used for both the ORDER BY and DISTINCT processing. As originally \n  ** written the query must use a temp-table for at least one of the ORDER \n  ** BY and DISTINCT, and an index or separate temp-table for the other.\n  */\n  if( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct \n   && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1)==0\n  ){\n    p->selFlags &= ~SF_Distinct;\n    pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);\n    /* Notice that even thought SF_Distinct has been cleared from p->selFlags,\n    ** the sDistinct.isTnct is still set.  Hence, isTnct represents the\n    ** original setting of the SF_Distinct flag, not the current setting */\n    assert( sDistinct.isTnct );\n\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x400 ){\n      SELECTTRACE(0x400,pParse,p,(\"Transform DISTINCT into GROUP BY:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n  }\n\n  /* If there is an ORDER BY clause, then create an ephemeral index to\n  ** do the sorting.  But this sorting ephemeral index might end up\n  ** being unused if the data can be extracted in pre-sorted order.\n  ** If that is the case, then the OP_OpenEphemeral instruction will be\n  ** changed to an OP_Noop once we figure out that the sorting index is\n  ** not needed.  The sSort.addrSortIndex variable is used to facilitate\n  ** that change.\n  */\n  if( sSort.pOrderBy ){\n    KeyInfo *pKeyInfo;\n    pKeyInfo = sqlite3KeyInfoFromExprList(\n        pParse, sSort.pOrderBy, 0, pEList->nExpr);\n    sSort.iECursor = pParse->nTab++;\n    sSort.addrSortIndex =\n      sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n          sSort.iECursor, sSort.pOrderBy->nExpr+1+pEList->nExpr, 0,\n          (char*)pKeyInfo, P4_KEYINFO\n      );\n  }else{\n    sSort.addrSortIndex = -1;\n  }\n\n  /* If the output is destined for a temporary table, open that table.\n  */\n  if( pDest->eDest==SRT_EphemTab ){\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pDest->iSDParm, pEList->nExpr);\n  }\n\n  /* Set the limiter.\n  */\n  iEnd = sqlite3VdbeMakeLabel(pParse);\n  if( (p->selFlags & SF_FixedLimit)==0 ){\n    p->nSelectRow = 320;  /* 4 billion rows */\n  }\n  computeLimitRegisters(pParse, p, iEnd);\n  if( p->iLimit==0 && sSort.addrSortIndex>=0 ){\n    sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, OP_SorterOpen);\n    sSort.sortFlags |= SORTFLAG_UseSorter;\n  }\n\n  /* Open an ephemeral index to use for the distinct set.\n  */\n  if( p->selFlags & SF_Distinct ){\n    sDistinct.tabTnct = pParse->nTab++;\n    sDistinct.addrTnct = sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n                       sDistinct.tabTnct, 0, 0,\n                       (char*)sqlite3KeyInfoFromExprList(pParse, p->pEList,0,0),\n                       P4_KEYINFO);\n    sqlite3VdbeChangeP5(v, BTREE_UNORDERED);\n    sDistinct.eTnctType = WHERE_DISTINCT_UNORDERED;\n  }else{\n    sDistinct.eTnctType = WHERE_DISTINCT_NOOP;\n  }\n\n  if( !isAgg && pGroupBy==0 ){\n    /* No aggregate functions and no GROUP BY clause */\n    u16 wctrlFlags = (sDistinct.isTnct ? WHERE_WANT_DISTINCT : 0)\n                   | (p->selFlags & SF_FixedLimit);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    Window *pWin = p->pWin;      /* Master window object (or NULL) */\n    if( pWin ){\n      sqlite3WindowCodeInit(pParse, pWin);\n    }\n#endif\n    assert( WHERE_USE_LIMIT==SF_FixedLimit );\n\n\n    /* Begin the database scan. */\n    SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy,\n                               p->pEList, wctrlFlags, p->nSelectRow);\n    if( pWInfo==0 ) goto select_end;\n    if( sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow ){\n      p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);\n    }\n    if( sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo) ){\n      sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);\n    }\n    if( sSort.pOrderBy ){\n      sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);\n      sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);\n      if( sSort.nOBSat==sSort.pOrderBy->nExpr ){\n        sSort.pOrderBy = 0;\n      }\n    }\n\n    /* If sorting index that was created by a prior OP_OpenEphemeral \n    ** instruction ended up not being needed, then change the OP_OpenEphemeral\n    ** into an OP_Noop.\n    */\n    if( sSort.addrSortIndex>=0 && sSort.pOrderBy==0 ){\n      sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n    }\n\n    assert( p->pEList==pEList );\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    if( pWin ){\n      int addrGosub = sqlite3VdbeMakeLabel(pParse);\n      int iCont = sqlite3VdbeMakeLabel(pParse);\n      int iBreak = sqlite3VdbeMakeLabel(pParse);\n      int regGosub = ++pParse->nMem;\n\n      sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);\n\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, iBreak);\n      sqlite3VdbeResolveLabel(v, addrGosub);\n      VdbeNoopComment((v, \"inner-loop subroutine\"));\n      sSort.labelOBLopt = 0;\n      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);\n      sqlite3VdbeResolveLabel(v, iCont);\n      sqlite3VdbeAddOp1(v, OP_Return, regGosub);\n      VdbeComment((v, \"end inner-loop subroutine\"));\n      sqlite3VdbeResolveLabel(v, iBreak);\n    }else\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n    {\n      /* Use the standard inner loop. */\n      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest,\n          sqlite3WhereContinueLabel(pWInfo),\n          sqlite3WhereBreakLabel(pWInfo));\n\n      /* End the database scan loop.\n      */\n      sqlite3WhereEnd(pWInfo);\n    }\n  }else{\n    /* This case when there exist aggregate functions or a GROUP BY clause\n    ** or both */\n    NameContext sNC;    /* Name context for processing aggregate information */\n    int iAMem;          /* First Mem address for storing current GROUP BY */\n    int iBMem;          /* First Mem address for previous GROUP BY */\n    int iUseFlag;       /* Mem address holding flag indicating that at least\n                        ** one row of the input to the aggregator has been\n                        ** processed */\n    int iAbortFlag;     /* Mem address which causes query abort if positive */\n    int groupBySort;    /* Rows come from source in GROUP BY order */\n    int addrEnd;        /* End of processing for this SELECT */\n    int sortPTab = 0;   /* Pseudotable used to decode sorting results */\n    int sortOut = 0;    /* Output register from the sorter */\n    int orderByGrp = 0; /* True if the GROUP BY and ORDER BY are the same */\n\n    /* Remove any and all aliases between the result set and the\n    ** GROUP BY clause.\n    */\n    if( pGroupBy ){\n      int k;                        /* Loop counter */\n      struct ExprList_item *pItem;  /* For looping over expression in a list */\n\n      for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++){\n        pItem->u.x.iAlias = 0;\n      }\n      for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++){\n        pItem->u.x.iAlias = 0;\n      }\n      assert( 66==sqlite3LogEst(100) );\n      if( p->nSelectRow>66 ) p->nSelectRow = 66;\n\n      /* If there is both a GROUP BY and an ORDER BY clause and they are\n      ** identical, then it may be possible to disable the ORDER BY clause \n      ** on the grounds that the GROUP BY will cause elements to come out \n      ** in the correct order. It also may not - the GROUP BY might use a\n      ** database index that causes rows to be grouped together as required\n      ** but not actually sorted. Either way, record the fact that the\n      ** ORDER BY and GROUP BY clauses are the same by setting the orderByGrp\n      ** variable.  */\n      if( sSort.pOrderBy && pGroupBy->nExpr==sSort.pOrderBy->nExpr ){\n        int ii;\n        /* The GROUP BY processing doesn't care whether rows are delivered in\n        ** ASC or DESC order - only that each group is returned contiguously.\n        ** So set the ASC/DESC flags in the GROUP BY to match those in the \n        ** ORDER BY to maximize the chances of rows being delivered in an \n        ** order that makes the ORDER BY redundant.  */\n        for(ii=0; ii<pGroupBy->nExpr; ii++){\n          u8 sortFlags = sSort.pOrderBy->a[ii].sortFlags & KEYINFO_ORDER_DESC;\n          pGroupBy->a[ii].sortFlags = sortFlags;\n        }\n        if( sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1)==0 ){\n          orderByGrp = 1;\n        }\n      }\n    }else{\n      assert( 0==sqlite3LogEst(1) );\n      p->nSelectRow = 0;\n    }\n\n    /* Create a label to jump to when we want to abort the query */\n    addrEnd = sqlite3VdbeMakeLabel(pParse);\n\n    /* Convert TK_COLUMN nodes into TK_AGG_COLUMN and make entries in\n    ** sAggInfo for all TK_AGG_FUNCTION nodes in expressions of the\n    ** SELECT statement.\n    */\n    memset(&sNC, 0, sizeof(sNC));\n    sNC.pParse = pParse;\n    sNC.pSrcList = pTabList;\n    sNC.uNC.pAggInfo = &sAggInfo;\n    VVA_ONLY( sNC.ncFlags = NC_UAggInfo; )\n    sAggInfo.mnReg = pParse->nMem+1;\n    sAggInfo.nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;\n    sAggInfo.pGroupBy = pGroupBy;\n    sqlite3ExprAnalyzeAggList(&sNC, pEList);\n    sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);\n    if( pHaving ){\n      if( pGroupBy ){\n        assert( pWhere==p->pWhere );\n        assert( pHaving==p->pHaving );\n        assert( pGroupBy==p->pGroupBy );\n        havingToWhere(pParse, p);\n        pWhere = p->pWhere;\n      }\n      sqlite3ExprAnalyzeAggregates(&sNC, pHaving);\n    }\n    sAggInfo.nAccumulator = sAggInfo.nColumn;\n    if( p->pGroupBy==0 && p->pHaving==0 && sAggInfo.nFunc==1 ){\n      minMaxFlag = minMaxQuery(db, sAggInfo.aFunc[0].pExpr, &pMinMaxOrderBy);\n    }else{\n      minMaxFlag = WHERE_ORDERBY_NORMAL;\n    }\n    for(i=0; i<sAggInfo.nFunc; i++){\n      Expr *pExpr = sAggInfo.aFunc[i].pExpr;\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      sNC.ncFlags |= NC_InAggFunc;\n      sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      assert( !IsWindowFunc(pExpr) );\n      if( ExprHasProperty(pExpr, EP_WinFunc) ){\n        sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);\n      }\n#endif\n      sNC.ncFlags &= ~NC_InAggFunc;\n    }\n    sAggInfo.mxReg = pParse->nMem;\n    if( db->mallocFailed ) goto select_end;\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x400 ){\n      int ii;\n      SELECTTRACE(0x400,pParse,p,(\"After aggregate analysis:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n      for(ii=0; ii<sAggInfo.nColumn; ii++){\n        sqlite3DebugPrintf(\"agg-column[%d] iMem=%d\\n\",\n            ii, sAggInfo.aCol[ii].iMem);\n        sqlite3TreeViewExpr(0, sAggInfo.aCol[ii].pExpr, 0);\n      }\n      for(ii=0; ii<sAggInfo.nFunc; ii++){\n        sqlite3DebugPrintf(\"agg-func[%d]: iMem=%d\\n\",\n            ii, sAggInfo.aFunc[ii].iMem);\n        sqlite3TreeViewExpr(0, sAggInfo.aFunc[ii].pExpr, 0);\n      }\n    }\n#endif\n\n\n    /* Processing for aggregates with GROUP BY is very different and\n    ** much more complex than aggregates without a GROUP BY.\n    */\n    if( pGroupBy ){\n      KeyInfo *pKeyInfo;  /* Keying information for the group by clause */\n      int addr1;          /* A-vs-B comparision jump */\n      int addrOutputRow;  /* Start of subroutine that outputs a result row */\n      int regOutputRow;   /* Return address register for output subroutine */\n      int addrSetAbort;   /* Set the abort flag and return */\n      int addrTopOfLoop;  /* Top of the input loop */\n      int addrSortingIdx; /* The OP_OpenEphemeral for the sorting index */\n      int addrReset;      /* Subroutine for resetting the accumulator */\n      int regReset;       /* Return address register for reset subroutine */\n\n      /* If there is a GROUP BY clause we might need a sorting index to\n      ** implement it.  Allocate that sorting index now.  If it turns out\n      ** that we do not need it after all, the OP_SorterOpen instruction\n      ** will be converted into a Noop.  \n      */\n      sAggInfo.sortingIdx = pParse->nTab++;\n      pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pGroupBy,0,sAggInfo.nColumn);\n      addrSortingIdx = sqlite3VdbeAddOp4(v, OP_SorterOpen, \n          sAggInfo.sortingIdx, sAggInfo.nSortingColumn, \n          0, (char*)pKeyInfo, P4_KEYINFO);\n\n      /* Initialize memory locations used by GROUP BY aggregate processing\n      */\n      iUseFlag = ++pParse->nMem;\n      iAbortFlag = ++pParse->nMem;\n      regOutputRow = ++pParse->nMem;\n      addrOutputRow = sqlite3VdbeMakeLabel(pParse);\n      regReset = ++pParse->nMem;\n      addrReset = sqlite3VdbeMakeLabel(pParse);\n      iAMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      iBMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iAbortFlag);\n      VdbeComment((v, \"clear abort flag\"));\n      sqlite3VdbeAddOp3(v, OP_Null, 0, iAMem, iAMem+pGroupBy->nExpr-1);\n\n      /* Begin a loop that will extract all source rows in GROUP BY order.\n      ** This might involve two separate loops with an OP_Sort in between, or\n      ** it might be a single loop that uses an index to extract information\n      ** in the right order to begin with.\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, 0,\n          WHERE_GROUPBY | (orderByGrp ? WHERE_SORTBYGROUP : 0), 0\n      );\n      if( pWInfo==0 ) goto select_end;\n      if( sqlite3WhereIsOrdered(pWInfo)==pGroupBy->nExpr ){\n        /* The optimizer is able to deliver rows in group by order so\n        ** we do not have to sort.  The OP_OpenEphemeral table will be\n        ** cancelled later because we still need to use the pKeyInfo\n        */\n        groupBySort = 0;\n      }else{\n        /* Rows are coming out in undetermined order.  We have to push\n        ** each row into a sorting index, terminate the first loop,\n        ** then loop over the sorting index in order to get the output\n        ** in sorted order\n        */\n        int regBase;\n        int regRecord;\n        int nCol;\n        int nGroupBy;\n\n        explainTempTable(pParse, \n            (sDistinct.isTnct && (p->selFlags&SF_Distinct)==0) ?\n                    \"DISTINCT\" : \"GROUP BY\");\n\n        groupBySort = 1;\n        nGroupBy = pGroupBy->nExpr;\n        nCol = nGroupBy;\n        j = nGroupBy;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          if( sAggInfo.aCol[i].iSorterColumn>=j ){\n            nCol++;\n            j++;\n          }\n        }\n        regBase = sqlite3GetTempRange(pParse, nCol);\n        sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);\n        j = nGroupBy;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          struct AggInfo_col *pCol = &sAggInfo.aCol[i];\n          if( pCol->iSorterColumn>=j ){\n            int r1 = j + regBase;\n            sqlite3ExprCodeGetColumnOfTable(v,\n                               pCol->pTab, pCol->iTable, pCol->iColumn, r1);\n            j++;\n          }\n        }\n        regRecord = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regRecord);\n        sqlite3VdbeAddOp2(v, OP_SorterInsert, sAggInfo.sortingIdx, regRecord);\n        sqlite3ReleaseTempReg(pParse, regRecord);\n        sqlite3ReleaseTempRange(pParse, regBase, nCol);\n        sqlite3WhereEnd(pWInfo);\n        sAggInfo.sortingIdxPTab = sortPTab = pParse->nTab++;\n        sortOut = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_OpenPseudo, sortPTab, sortOut, nCol);\n        sqlite3VdbeAddOp2(v, OP_SorterSort, sAggInfo.sortingIdx, addrEnd);\n        VdbeComment((v, \"GROUP BY sort\")); VdbeCoverage(v);\n        sAggInfo.useSortingIdx = 1;\n      }\n\n      /* If the index or temporary table used by the GROUP BY sort\n      ** will naturally deliver rows in the order required by the ORDER BY\n      ** clause, cancel the ephemeral table open coded earlier.\n      **\n      ** This is an optimization - the correct answer should result regardless.\n      ** Use the SQLITE_GroupByOrder flag with SQLITE_TESTCTRL_OPTIMIZER to \n      ** disable this optimization for testing purposes.  */\n      if( orderByGrp && OptimizationEnabled(db, SQLITE_GroupByOrder) \n       && (groupBySort || sqlite3WhereIsSorted(pWInfo))\n      ){\n        sSort.pOrderBy = 0;\n        sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n      }\n\n      /* Evaluate the current GROUP BY terms and store in b0, b1, b2...\n      ** (b0 is memory location iBMem+0, b1 is iBMem+1, and so forth)\n      ** Then compare the current GROUP BY terms against the GROUP BY terms\n      ** from the previous row currently stored in a0, a1, a2...\n      */\n      addrTopOfLoop = sqlite3VdbeCurrentAddr(v);\n      if( groupBySort ){\n        sqlite3VdbeAddOp3(v, OP_SorterData, sAggInfo.sortingIdx,\n                          sortOut, sortPTab);\n      }\n      for(j=0; j<pGroupBy->nExpr; j++){\n        if( groupBySort ){\n          sqlite3VdbeAddOp3(v, OP_Column, sortPTab, j, iBMem+j);\n        }else{\n          sAggInfo.directMode = 1;\n          sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j);\n        }\n      }\n      sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy->nExpr,\n                          (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);\n      addr1 = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp3(v, OP_Jump, addr1+1, 0, addr1+1); VdbeCoverage(v);\n\n      /* Generate code that runs whenever the GROUP BY changes.\n      ** Changes in the GROUP BY are detected by the previous code\n      ** block.  If there were no changes, this block is skipped.\n      **\n      ** This code copies current group by terms in b0,b1,b2,...\n      ** over to a0,a1,a2.  It then calls the output subroutine\n      ** and resets the aggregate accumulator registers in preparation\n      ** for the next GROUP BY batch.\n      */\n      sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output one row\"));\n      sqlite3VdbeAddOp2(v, OP_IfPos, iAbortFlag, addrEnd); VdbeCoverage(v);\n      VdbeComment((v, \"check abort flag\"));\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      VdbeComment((v, \"reset accumulator\"));\n\n      /* Update the aggregate accumulators based on the content of\n      ** the current row\n      */\n      sqlite3VdbeJumpHere(v, addr1);\n      updateAccumulator(pParse, iUseFlag, &sAggInfo);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag);\n      VdbeComment((v, \"indicate data in accumulator\"));\n\n      /* End of the loop\n      */\n      if( groupBySort ){\n        sqlite3VdbeAddOp2(v, OP_SorterNext, sAggInfo.sortingIdx, addrTopOfLoop);\n        VdbeCoverage(v);\n      }else{\n        sqlite3WhereEnd(pWInfo);\n        sqlite3VdbeChangeToNoop(v, addrSortingIdx);\n      }\n\n      /* Output the final row of result\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output final row\"));\n\n      /* Jump over the subroutines\n      */\n      sqlite3VdbeGoto(v, addrEnd);\n\n      /* Generate a subroutine that outputs a single row of the result\n      ** set.  This subroutine first looks at the iUseFlag.  If iUseFlag\n      ** is less than or equal to zero, the subroutine is a no-op.  If\n      ** the processing calls for the query to abort, this subroutine\n      ** increments the iAbortFlag memory location before returning in\n      ** order to signal the caller to abort.\n      */\n      addrSetAbort = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iAbortFlag);\n      VdbeComment((v, \"set abort flag\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      sqlite3VdbeResolveLabel(v, addrOutputRow);\n      addrOutputRow = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_IfPos, iUseFlag, addrOutputRow+2);\n      VdbeCoverage(v);\n      VdbeComment((v, \"Groupby result generator entry point\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      finalizeAggFunctions(pParse, &sAggInfo);\n      sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, -1, &sSort,\n                      &sDistinct, pDest,\n                      addrOutputRow+1, addrSetAbort);\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      VdbeComment((v, \"end groupby result generator\"));\n\n      /* Generate a subroutine that will reset the group-by accumulator\n      */\n      sqlite3VdbeResolveLabel(v, addrReset);\n      resetAccumulator(pParse, &sAggInfo);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iUseFlag);\n      VdbeComment((v, \"indicate accumulator empty\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regReset);\n     \n    } /* endif pGroupBy.  Begin aggregate queries without GROUP BY: */\n    else {\n#ifndef SQLITE_OMIT_BTREECOUNT\n      Table *pTab;\n      if( (pTab = isSimpleCount(p, &sAggInfo))!=0 ){\n        /* If isSimpleCount() returns a pointer to a Table structure, then\n        ** the SQL statement is of the form:\n        **\n        **   SELECT count(*) FROM <tbl>\n        **\n        ** where the Table structure returned represents table <tbl>.\n        **\n        ** This statement is so common that it is optimized specially. The\n        ** OP_Count instruction is executed either on the intkey table that\n        ** contains the data for table <tbl> or on one of its indexes. It\n        ** is better to execute the op on an index, as indexes are almost\n        ** always spread across less pages than their corresponding tables.\n        */\n        const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n        const int iCsr = pParse->nTab++;     /* Cursor to scan b-tree */\n        Index *pIdx;                         /* Iterator variable */\n        KeyInfo *pKeyInfo = 0;               /* Keyinfo for scanned index */\n        Index *pBest = 0;                    /* Best index found so far */\n        int iRoot = pTab->tnum;              /* Root page of scanned b-tree */\n\n        sqlite3CodeVerifySchema(pParse, iDb);\n        sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n\n        /* Search for the index that has the lowest scan cost.\n        **\n        ** (2011-04-15) Do not do a full scan of an unordered index.\n        **\n        ** (2013-10-03) Do not count the entries in a partial index.\n        **\n        ** In practice the KeyInfo structure will not be used. It is only \n        ** passed to keep OP_OpenRead happy.\n        */\n        if( !HasRowid(pTab) ) pBest = sqlite3PrimaryKeyIndex(pTab);\n        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n          if( pIdx->bUnordered==0\n           && pIdx->szIdxRow<pTab->szTabRow\n           && pIdx->pPartIdxWhere==0\n           && (!pBest || pIdx->szIdxRow<pBest->szIdxRow)\n          ){\n            pBest = pIdx;\n          }\n        }\n        if( pBest ){\n          iRoot = pBest->tnum;\n          pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);\n        }\n\n        /* Open a read-only cursor, execute the OP_Count, close the cursor. */\n        sqlite3VdbeAddOp4Int(v, OP_OpenRead, iCsr, iRoot, iDb, 1);\n        if( pKeyInfo ){\n          sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, P4_KEYINFO);\n        }\n        sqlite3VdbeAddOp2(v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem);\n        sqlite3VdbeAddOp1(v, OP_Close, iCsr);\n        explainSimpleCount(pParse, pTab, pBest);\n      }else\n#endif /* SQLITE_OMIT_BTREECOUNT */\n      {\n        int regAcc = 0;           /* \"populate accumulators\" flag */\n\n        /* If there are accumulator registers but no min() or max() functions\n        ** without FILTER clauses, allocate register regAcc. Register regAcc\n        ** will contain 0 the first time the inner loop runs, and 1 thereafter.\n        ** The code generated by updateAccumulator() uses this to ensure\n        ** that the accumulator registers are (a) updated only once if\n        ** there are no min() or max functions or (b) always updated for the\n        ** first row visited by the aggregate, so that they are updated at\n        ** least once even if the FILTER clause means the min() or max() \n        ** function visits zero rows.  */\n        if( sAggInfo.nAccumulator ){\n          for(i=0; i<sAggInfo.nFunc; i++){\n            if( ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_WinFunc) ) continue;\n            if( sAggInfo.aFunc[i].pFunc->funcFlags&SQLITE_FUNC_NEEDCOLL ) break;\n          }\n          if( i==sAggInfo.nFunc ){\n            regAcc = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, OP_Integer, 0, regAcc);\n          }\n        }\n\n        /* This case runs if the aggregate has no GROUP BY clause.  The\n        ** processing is much simpler since there is only a single row\n        ** of output.\n        */\n        assert( p->pGroupBy==0 );\n        resetAccumulator(pParse, &sAggInfo);\n\n        /* If this query is a candidate for the min/max optimization, then\n        ** minMaxFlag will have been previously set to either\n        ** WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX and pMinMaxOrderBy will\n        ** be an appropriate ORDER BY expression for the optimization.\n        */\n        assert( minMaxFlag==WHERE_ORDERBY_NORMAL || pMinMaxOrderBy!=0 );\n        assert( pMinMaxOrderBy==0 || pMinMaxOrderBy->nExpr==1 );\n\n        SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy,\n                                   0, minMaxFlag, 0);\n        if( pWInfo==0 ){\n          goto select_end;\n        }\n        updateAccumulator(pParse, regAcc, &sAggInfo);\n        if( regAcc ) sqlite3VdbeAddOp2(v, OP_Integer, 1, regAcc);\n        if( sqlite3WhereIsOrdered(pWInfo)>0 ){\n          sqlite3VdbeGoto(v, sqlite3WhereBreakLabel(pWInfo));\n          VdbeComment((v, \"%s() by index\",\n                (minMaxFlag==WHERE_ORDERBY_MIN?\"min\":\"max\")));\n        }\n        sqlite3WhereEnd(pWInfo);\n        finalizeAggFunctions(pParse, &sAggInfo);\n      }\n\n      sSort.pOrderBy = 0;\n      sqlite3ExprIfFalse(pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, -1, 0, 0, \n                      pDest, addrEnd, addrEnd);\n    }\n    sqlite3VdbeResolveLabel(v, addrEnd);\n    \n  } /* endif aggregate query */\n\n  if( sDistinct.eTnctType==WHERE_DISTINCT_UNORDERED ){\n    explainTempTable(pParse, \"DISTINCT\");\n  }\n\n  /* If there is an ORDER BY clause, then we need to sort the results\n  ** and send them to the callback one by one.\n  */\n  if( sSort.pOrderBy ){\n    explainTempTable(pParse,\n                     sSort.nOBSat>0 ? \"RIGHT PART OF ORDER BY\":\"ORDER BY\");\n    assert( p->pEList==pEList );\n    generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);\n  }\n\n  /* Jump here to skip this query\n  */\n  sqlite3VdbeResolveLabel(v, iEnd);\n\n  /* The SELECT has been coded. If there is an error in the Parse structure,\n  ** set the return code to 1. Otherwise 0. */\n  rc = (pParse->nErr>0);\n\n  /* Control jumps to here if an error is encountered above, or upon\n  ** successful coding of the SELECT.\n  */\nselect_end:\n  sqlite3ExprListDelete(db, pMinMaxOrderBy);\n  sqlite3DbFree(db, sAggInfo.aCol);\n  sqlite3DbFree(db, sAggInfo.aFunc);\n#if SELECTTRACE_ENABLED\n  SELECTTRACE(0x1,pParse,p,(\"end processing\\n\"));\n  if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n  ExplainQueryPlanPop(pParse);\n  return rc;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  ){\n",
        "src_path": "e59c562b3f6894f84c715772c4b116d7b5c01348___select.c",
        "uri": "https://api.github.com/repos/sqlite/sqlite/commits/e59c562b3f6894f84c715772c4b116d7b5c01348",
        "commit_msg": "Fix a crash that could occur if a sub-select that uses both DISTINCT and window functions also used an ORDER BY that is the same as its select list.\n\nFossilOrigin-Name: bcdd66c1691955c697f3d756c2b035acfe98f6aad72e90b0021bab6e9023b3ba",
        "test_func_diff": [
            {
                "fn": "test/window1.test",
                "patch": "@@ -1243,4 +1243,17 @@ do_catchsql_test 32.10 {\n   ALTER TABLE a0 RENAME TO S;\n } {1 {error in view a: 1st ORDER BY term does not match any column in the result set}}\n \n+reset_db\n+do_execsql_test 33.1 {\n+  CREATE TABLE t1(aa, bb);\n+  INSERT INTO t1 VALUES(1, 2);\n+  INSERT INTO t1 VALUES(5, 6);\n+  CREATE TABLE t2(x);\n+  INSERT INTO t2 VALUES(1);\n+}\n+do_execsql_test 33.2 {\n+  SELECT (SELECT DISTINCT sum(aa) OVER() FROM t1 ORDER BY 1), x FROM t2 \n+  ORDER BY 1;\n+} {6 1}\n+\n finish_test"
            }
        ],
        "error_msg": "warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\nwindow1-33.2...\n! window1-33.2 expected: [6 1]\n! window1-33.2 got:      [{} 1]\n[Detaching after fork from child process 17063]\nSQLite 2019-11-22 10:14:01 bcdd66c1691955c697f3d756c2b035acfe98f6aad72e90b0021bab6e9023b3ba\n1 errors out of 179 tests on deef54515472 Linux 64-bit little-endian\n!Failures on these tests: window1-33.2\nAll memory allocations freed - no leaks\nMemory used:          now          0  max     358312  max-size     120000\nAllocation count:     now          0  max        453\nPage-cache used:      now          0  max          0  max-size       1288\nPage-cache overflow:  now          0  max      18312\nMaximum memory usage: 358312 bytes\nCurrent memory usage: 0 bytes\nNumber of malloc()  : -1 calls\n[Inferior 1 (process 15013) exited with code 01]\n"
    },
    "54d501092d88c0cf89bec4279951f548fb0b8618___zipfile.c": {
        "prefix": "static int zipfileUpdate(\n  sqlite3_vtab *pVtab, \n  int nVal, \n  sqlite3_value **apVal, \n  sqlite_int64 *pRowid\n){\n  ZipfileTab *pTab = (ZipfileTab*)pVtab;\n  int rc = SQLITE_OK;             /* Return Code */\n  ZipfileEntry *pNew = 0;         /* New in-memory CDS entry */\n\n  u32 mode = 0;                   /* Mode for new entry */\n  u32 mTime = 0;                  /* Modification time for new entry */\n  i64 sz = 0;                     /* Uncompressed size */\n  const char *zPath = 0;          /* Path for new entry */\n  int nPath = 0;                  /* strlen(zPath) */\n  const u8 *pData = 0;            /* Pointer to buffer containing content */\n  int nData = 0;                  /* Size of pData buffer in bytes */\n  int iMethod = 0;                /* Compression method for new entry */\n  u8 *pFree = 0;                  /* Free this */\n  char *zFree = 0;                /* Also free this */\n  ZipfileEntry *pOld = 0;\n  ZipfileEntry *pOld2 = 0;\n  int bUpdate = 0;                /* True for an update that modifies \"name\" */\n  int bIsDir = 0;\n  u32 iCrc32 = 0;\n\n  if( pTab->pWriteFd==0 ){\n    rc = zipfileBegin(pVtab);\n    if( rc!=SQLITE_OK ) return rc;\n  }\n\n  /* If this is a DELETE or UPDATE, find the archive entry to delete. */\n  if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){\n    const char *zDelete = (const char*)sqlite3_value_text(apVal[0]);\n    int nDelete = (int)strlen(zDelete);\n    if( nVal>1 ){\n      const char *zUpdate = (const char*)sqlite3_value_text(apVal[1]);\n      if( zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete)!=0 ){\n        bUpdate = 1;\n      }\n    }\n    for(pOld=pTab->pFirstEntry; 1; pOld=pOld->pNext){\n      if( zipfileComparePath(pOld->cds.zFile, zDelete, nDelete)==0 ){\n        break;\n      }\n      assert( pOld->pNext );\n    }\n  }\n\n  if( nVal>1 ){\n    /* Check that \"sz\" and \"rawdata\" are both NULL: */\n    if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){\n      zipfileTableErr(pTab, \"sz must be NULL\");\n      rc = SQLITE_CONSTRAINT;\n    }\n    if( sqlite3_value_type(apVal[6])!=SQLITE_NULL ){\n      zipfileTableErr(pTab, \"rawdata must be NULL\"); \n      rc = SQLITE_CONSTRAINT;\n    }\n\n    if( rc==SQLITE_OK ){\n      if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){\n        /* data=NULL. A directory */\n        bIsDir = 1;\n      }else{\n        /* Value specified for \"data\", and possibly \"method\". This must be\n        ** a regular file or a symlink. */\n        const u8 *aIn = sqlite3_value_blob(apVal[7]);\n        int nIn = sqlite3_value_bytes(apVal[7]);\n        int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;\n\n        iMethod = sqlite3_value_int(apVal[8]);\n        sz = nIn;\n        pData = aIn;\n        nData = nIn;\n        if( iMethod!=0 && iMethod!=8 ){\n          zipfileTableErr(pTab, \"unknown compression method: %d\", iMethod);\n          rc = SQLITE_CONSTRAINT;\n        }else{\n          if( bAuto || iMethod ){\n            int nCmp;\n            rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);\n            if( rc==SQLITE_OK ){\n              if( iMethod || nCmp<nIn ){\n                iMethod = 8;\n                pData = pFree;\n                nData = nCmp;\n              }\n            }\n          }\n          iCrc32 = crc32(0, aIn, nIn);\n        }\n      }\n    }\n\n    if( rc==SQLITE_OK ){\n      rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);\n    }\n\n    if( rc==SQLITE_OK ){\n      zPath = (const char*)sqlite3_value_text(apVal[2]);\n",
        "suffix": "      mTime = zipfileGetTime(apVal[4]);\n    }\n\n    if( rc==SQLITE_OK && bIsDir ){\n      /* For a directory, check that the last character in the path is a\n      ** '/'. This appears to be required for compatibility with info-zip\n      ** (the unzip command on unix). It does not create directories\n      ** otherwise.  */\n      if( zPath[nPath-1]!='/' ){\n        zFree = sqlite3_mprintf(\"%s/\", zPath);\n        if( zFree==0 ){ rc = SQLITE_NOMEM; }\n        zPath = (const char*)zFree;\n        nPath++;\n      }\n    }\n\n    /* Check that we're not inserting a duplicate entry -OR- updating an\n    ** entry with a path, thereby making it into a duplicate. */\n    if( (pOld==0 || bUpdate) && rc==SQLITE_OK ){\n      ZipfileEntry *p;\n      for(p=pTab->pFirstEntry; p; p=p->pNext){\n        if( zipfileComparePath(p->cds.zFile, zPath, nPath)==0 ){\n          switch( sqlite3_vtab_on_conflict(pTab->db) ){\n            case SQLITE_IGNORE: {\n              goto zipfile_update_done;\n            }\n            case SQLITE_REPLACE: {\n              pOld2 = p;\n              break;\n            }\n            default: {\n              zipfileTableErr(pTab, \"duplicate name: \\\"%s\\\"\", zPath);\n              rc = SQLITE_CONSTRAINT;\n              break;\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    if( rc==SQLITE_OK ){\n      /* Create the new CDS record. */\n      pNew = zipfileNewEntry(zPath);\n      if( pNew==0 ){\n        rc = SQLITE_NOMEM;\n      }else{\n        pNew->cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;\n        pNew->cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;\n        pNew->cds.flags = ZIPFILE_NEWENTRY_FLAGS;\n        pNew->cds.iCompression = (u16)iMethod;\n        zipfileMtimeToDos(&pNew->cds, mTime);\n        pNew->cds.crc32 = iCrc32;\n        pNew->cds.szCompressed = nData;\n        pNew->cds.szUncompressed = (u32)sz;\n        pNew->cds.iExternalAttr = (mode<<16);\n        pNew->cds.iOffset = (u32)pTab->szCurrent;\n        pNew->cds.nFile = (u16)nPath;\n        pNew->mUnixTime = (u32)mTime;\n        rc = zipfileAppendEntry(pTab, pNew, pData, nData);\n        zipfileAddEntry(pTab, pOld, pNew);\n      }\n    }\n  }\n\n  if( rc==SQLITE_OK && (pOld || pOld2) ){\n    ZipfileCsr *pCsr;\n    for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){\n      if( pCsr->pCurrent && (pCsr->pCurrent==pOld || pCsr->pCurrent==pOld2) ){\n        pCsr->pCurrent = pCsr->pCurrent->pNext;\n        pCsr->bNoop = 1;\n      }\n    }\n\n    zipfileRemoveEntryFromList(pTab, pOld);\n    zipfileRemoveEntryFromList(pTab, pOld2);\n  }\n\nzipfile_update_done:\n  sqlite3_free(pFree);\n  sqlite3_free(zFree);\n  return rc;\n}\n",
        "start": 1521,
        "end": 1705,
        "buggy": "static int zipfileUpdate(\n  sqlite3_vtab *pVtab, \n  int nVal, \n  sqlite3_value **apVal, \n  sqlite_int64 *pRowid\n){\n  ZipfileTab *pTab = (ZipfileTab*)pVtab;\n  int rc = SQLITE_OK;             /* Return Code */\n  ZipfileEntry *pNew = 0;         /* New in-memory CDS entry */\n\n  u32 mode = 0;                   /* Mode for new entry */\n  u32 mTime = 0;                  /* Modification time for new entry */\n  i64 sz = 0;                     /* Uncompressed size */\n  const char *zPath = 0;          /* Path for new entry */\n  int nPath = 0;                  /* strlen(zPath) */\n  const u8 *pData = 0;            /* Pointer to buffer containing content */\n  int nData = 0;                  /* Size of pData buffer in bytes */\n  int iMethod = 0;                /* Compression method for new entry */\n  u8 *pFree = 0;                  /* Free this */\n  char *zFree = 0;                /* Also free this */\n  ZipfileEntry *pOld = 0;\n  ZipfileEntry *pOld2 = 0;\n  int bUpdate = 0;                /* True for an update that modifies \"name\" */\n  int bIsDir = 0;\n  u32 iCrc32 = 0;\n\n  if( pTab->pWriteFd==0 ){\n    rc = zipfileBegin(pVtab);\n    if( rc!=SQLITE_OK ) return rc;\n  }\n\n  /* If this is a DELETE or UPDATE, find the archive entry to delete. */\n  if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){\n    const char *zDelete = (const char*)sqlite3_value_text(apVal[0]);\n    int nDelete = (int)strlen(zDelete);\n    if( nVal>1 ){\n      const char *zUpdate = (const char*)sqlite3_value_text(apVal[1]);\n      if( zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete)!=0 ){\n        bUpdate = 1;\n      }\n    }\n    for(pOld=pTab->pFirstEntry; 1; pOld=pOld->pNext){\n      if( zipfileComparePath(pOld->cds.zFile, zDelete, nDelete)==0 ){\n        break;\n      }\n      assert( pOld->pNext );\n    }\n  }\n\n  if( nVal>1 ){\n    /* Check that \"sz\" and \"rawdata\" are both NULL: */\n    if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){\n      zipfileTableErr(pTab, \"sz must be NULL\");\n      rc = SQLITE_CONSTRAINT;\n    }\n    if( sqlite3_value_type(apVal[6])!=SQLITE_NULL ){\n      zipfileTableErr(pTab, \"rawdata must be NULL\"); \n      rc = SQLITE_CONSTRAINT;\n    }\n\n    if( rc==SQLITE_OK ){\n      if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){\n        /* data=NULL. A directory */\n        bIsDir = 1;\n      }else{\n        /* Value specified for \"data\", and possibly \"method\". This must be\n        ** a regular file or a symlink. */\n        const u8 *aIn = sqlite3_value_blob(apVal[7]);\n        int nIn = sqlite3_value_bytes(apVal[7]);\n        int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;\n\n        iMethod = sqlite3_value_int(apVal[8]);\n        sz = nIn;\n        pData = aIn;\n        nData = nIn;\n        if( iMethod!=0 && iMethod!=8 ){\n          zipfileTableErr(pTab, \"unknown compression method: %d\", iMethod);\n          rc = SQLITE_CONSTRAINT;\n        }else{\n          if( bAuto || iMethod ){\n            int nCmp;\n            rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);\n            if( rc==SQLITE_OK ){\n              if( iMethod || nCmp<nIn ){\n                iMethod = 8;\n                pData = pFree;\n                nData = nCmp;\n              }\n            }\n          }\n          iCrc32 = crc32(0, aIn, nIn);\n        }\n      }\n    }\n\n    if( rc==SQLITE_OK ){\n      rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);\n    }\n\n    if( rc==SQLITE_OK ){\n      zPath = (const char*)sqlite3_value_text(apVal[2]);\n      nPath = (int)strlen(zPath);\n      mTime = zipfileGetTime(apVal[4]);\n    }\n\n    if( rc==SQLITE_OK && bIsDir ){\n      /* For a directory, check that the last character in the path is a\n      ** '/'. This appears to be required for compatibility with info-zip\n      ** (the unzip command on unix). It does not create directories\n      ** otherwise.  */\n      if( zPath[nPath-1]!='/' ){\n        zFree = sqlite3_mprintf(\"%s/\", zPath);\n        if( zFree==0 ){ rc = SQLITE_NOMEM; }\n        zPath = (const char*)zFree;\n        nPath++;\n      }\n    }\n\n    /* Check that we're not inserting a duplicate entry -OR- updating an\n    ** entry with a path, thereby making it into a duplicate. */\n    if( (pOld==0 || bUpdate) && rc==SQLITE_OK ){\n      ZipfileEntry *p;\n      for(p=pTab->pFirstEntry; p; p=p->pNext){\n        if( zipfileComparePath(p->cds.zFile, zPath, nPath)==0 ){\n          switch( sqlite3_vtab_on_conflict(pTab->db) ){\n            case SQLITE_IGNORE: {\n              goto zipfile_update_done;\n            }\n            case SQLITE_REPLACE: {\n              pOld2 = p;\n              break;\n            }\n            default: {\n              zipfileTableErr(pTab, \"duplicate name: \\\"%s\\\"\", zPath);\n              rc = SQLITE_CONSTRAINT;\n              break;\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    if( rc==SQLITE_OK ){\n      /* Create the new CDS record. */\n      pNew = zipfileNewEntry(zPath);\n      if( pNew==0 ){\n        rc = SQLITE_NOMEM;\n      }else{\n        pNew->cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;\n        pNew->cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;\n        pNew->cds.flags = ZIPFILE_NEWENTRY_FLAGS;\n        pNew->cds.iCompression = (u16)iMethod;\n        zipfileMtimeToDos(&pNew->cds, mTime);\n        pNew->cds.crc32 = iCrc32;\n        pNew->cds.szCompressed = nData;\n        pNew->cds.szUncompressed = (u32)sz;\n        pNew->cds.iExternalAttr = (mode<<16);\n        pNew->cds.iOffset = (u32)pTab->szCurrent;\n        pNew->cds.nFile = (u16)nPath;\n        pNew->mUnixTime = (u32)mTime;\n        rc = zipfileAppendEntry(pTab, pNew, pData, nData);\n        zipfileAddEntry(pTab, pOld, pNew);\n      }\n    }\n  }\n\n  if( rc==SQLITE_OK && (pOld || pOld2) ){\n    ZipfileCsr *pCsr;\n    for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){\n      if( pCsr->pCurrent && (pCsr->pCurrent==pOld || pCsr->pCurrent==pOld2) ){\n        pCsr->pCurrent = pCsr->pCurrent->pNext;\n        pCsr->bNoop = 1;\n      }\n    }\n\n    zipfileRemoveEntryFromList(pTab, pOld);\n    zipfileRemoveEntryFromList(pTab, pOld2);\n  }\n\nzipfile_update_done:\n  sqlite3_free(pFree);\n  sqlite3_free(zFree);\n  return rc;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      nPath = (int)strlen(zPath);\n",
        "src_path": "54d501092d88c0cf89bec4279951f548fb0b8618___zipfile.c",
        "uri": "https://api.github.com/repos/sqlite/sqlite/commits/54d501092d88c0cf89bec4279951f548fb0b8618",
        "commit_msg": "Fix the zipfile extension so that INSERT works even if the pathname of\nthe file being inserted is a NULL.  Bug discovered by the\nYongheng and Rui fuzzer.\n\nFossilOrigin-Name: a80f84b511231204658304226de3e075a55afc2e3f39ac063716f7a57f585c06",
        "test_func_diff": [
            {
                "fn": "test/zipfile.test",
                "patch": "@@ -795,4 +795,18 @@ if {$tcl_platform(platform)!=\"windows\"} {\n   } {. ./x1.txt ./x2.txt}\n }\n \n+# 2019-12-18 Yongheng and Rui fuzzer\n+#\n+do_execsql_test 13.10 {\n+  DROP TABLE IF EXISTS t0;\n+  DROP TABLE IF EXISTS t1;\n+  CREATE TABLE t0(a,b,c,d,e,f,g);\n+  REPLACE INTO t0(c,b,f) VALUES(10,10,10);\n+  CREATE VIRTUAL TABLE t1 USING zipfile('h.zip');\n+  REPLACE INTO t1 SELECT * FROM t0;\n+  SELECT quote(name),quote(mode),quote(mtime),quote(sz),quote(rawdata),\n+         quote(data),quote(method) FROM t1;\n+} {'' 10 10 2 X'3130' X'3130' 0}\n+\n+\n finish_test"
            }
        ],
        "error_msg": "warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n[Detaching after fork from child process 73615]\n[Detaching after fork from child process 73627]\n[Detaching after fork from child process 73634]\n[Detaching after fork from child process 73643]\n[Detaching after fork from child process 73647]\n[Detaching after fork from child process 73656]\n[Detaching after fork from child process 73661]\n[Detaching after fork from child process 73673]\n[Detaching after fork from child process 73679]\n[Detaching after fork from child process 73685]\n[Detaching after fork from child process 73688]\n[Detaching after fork from child process 73696]\n[Detaching after fork from child process 73700]\nzipfile-2.5.1...[Detaching after fork from child process 73706]\nzipfile-6.0...[Detaching after fork from child process 73717]\nzipfile-6.2...[Detaching after fork from child process 73718]\nzipfile-13.10...\nProgram received signal SIGSEGV, Segmentation fault.\n__strlen_avx2 () at ../sysdeps/x86_64/multiarch/strlen-avx2.S:65\n65\t../sysdeps/x86_64/multiarch/strlen-avx2.S: No such file or directory.\n"
    },
    "bc7fe41e5857a0854d524e2a63a028e9394d2a5c___t_hash.c": {
        "prefix": "void hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n",
        "suffix": "    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Always replicate HINCRBYFLOAT as an HSET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}\n",
        "start": 660,
        "end": 706,
        "buggy": "void hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Always replicate HINCRBYFLOAT as an HSET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n",
        "src_path": "bc7fe41e5857a0854d524e2a63a028e9394d2a5c___t_hash.c",
        "uri": "https://api.github.com/repos/redis/redis/commits/bc7fe41e5857a0854d524e2a63a028e9394d2a5c",
        "commit_msg": "fix hincrbyfloat not to create a key if the new value is invalid (#11149)\n\nCheck the validity of the value before performing the create operation,\r\nprevents new data from being generated even if the request fails to execute.\r\n\r\nCo-authored-by: Oran Agra <oran@redislabs.com>\r\nCo-authored-by: chendianqiang <chendianqiang@meituan.com>\r\nCo-authored-by: Binbin <binloveplay1314@qq.com>",
        "test_func_diff": [
            {
                "fn": "tests/unit/type/hash.tcl",
                "patch": "@@ -819,4 +819,8 @@ start_server {tags {\"hash\"}} {\n         set _ $k\n     } {ZIP_INT_8B 127 ZIP_INT_16B 32767 ZIP_INT_32B 2147483647 ZIP_INT_64B 9223372036854775808 ZIP_INT_IMM_MIN 0 ZIP_INT_IMM_MAX 12}\n \n+    test {HINCRBYFLOAT does not allow NaN or Infinity} {\n+        assert_error \"*value is NaN or Infinity*\" {r hincrbyfloat hfoo field +inf}\n+        assert_equal 0 [r exists hfoo]\n+    }\n }"
            }
        ],
        "error_msg": "[\u001b[0;31;49merr\u001b[0m]: HINCRBYFLOAT does not allow NaN or Infinity in tests/unit/type/hash.tcl\nExpected 'ERR increment would produce NaN or Infinity' to match '*value is NaN or Infinity*' (context: type source line 87 file /out/redis___redis/git_repo_dir_bc7fe41e5857a0854d524e2a63a028e9394d2a5c/tests/support/test.tcl cmd {assert_match $pattern $error $detail} proc ::assert_error level 1) \n[1/1 \u001b[0;33;49mdone\u001b[0m]: unit/type/hash (4 seconds)\n\n                   The End\n\nExecution time of different units:\n  4 seconds - unit/type/hash\n\n\u001b[1;31;49m!!! WARNING\u001b[0m The following tests failed:\n\n*** [\u001b[0;31;49merr\u001b[0m]: HINCRBYFLOAT does not allow NaN or Infinity in tests/unit/type/hash.tcl\nExpected 'ERR increment would produce NaN or Infinity' to match '*value is NaN or Infinity*' (context: type source line 87 file /out/redis___redis/git_repo_dir_bc7fe41e5857a0854d524e2a63a028e9394d2a5c/tests/support/test.tcl cmd {assert_match $pattern $error $detail} proc ::assert_error level 1) \nCleanup: may take some time... OK\n"
    },
    "76a7b10005c70babee357a7d0f2becf28ec7ed1e___hiredis.c": {
        "prefix": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n\n    if (elements > 0) {\n",
        "suffix": "        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n\n    r->elements = elements;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n",
        "start": 169,
        "end": 195,
        "buggy": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n\n    if (elements > 0) {\n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n\n    r->elements = elements;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        r->element = hi_calloc(elements,sizeof(redisReply*));\n",
        "src_path": "76a7b10005c70babee357a7d0f2becf28ec7ed1e___hiredis.c",
        "uri": "https://api.github.com/repos/redis/hiredis/commits/76a7b10005c70babee357a7d0f2becf28ec7ed1e",
        "commit_msg": "Fix for integer/buffer overflow CVE-2021-32765\n\nThis fix prevents hiredis from trying to allocate more than `SIZE_MAX`\nbytes, which would result in a buffer overrun.\n\n[Full Details](https://github.com/redis/hiredis/security/advisories/GHSA-hfm9-39pp-55p2)",
        "test_func_diff": [
            {
                "fn": "test.c",
                "patch": "@@ -493,6 +493,20 @@ static void test_reply_reader(void) {\n     freeReplyObject(reply);\n     redisReaderFree(reader);\n \n+    test(\"Multi-bulk never overflows regardless of maxelements: \");\n+    size_t bad_mbulk_len = (SIZE_MAX / sizeof(void *)) + 3;\n+    char bad_mbulk_reply[100];\n+    snprintf(bad_mbulk_reply, sizeof(bad_mbulk_reply), \"*%llu\\r\\n+asdf\\r\\n\",\n+        (unsigned long long) bad_mbulk_len);\n+\n+    reader = redisReaderCreate();\n+    reader->maxelements = 0;    /* Don't rely on default limit */\n+    redisReaderFeed(reader, bad_mbulk_reply, strlen(bad_mbulk_reply));\n+    ret = redisReaderGetReply(reader,&reply);\n+    test_cond(ret == REDIS_ERR && strcasecmp(reader->errstr, \"Out of memory\") == 0);\n+    freeReplyObject(reply);\n+    redisReaderFree(reader);\n+\n #if LLONG_MAX > SIZE_MAX\n     test(\"Set error when array > SIZE_MAX: \");\n     reader = redisReaderCreate();"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/redis___hiredis/git_repo_dir_76a7b10005c70babee357a7d0f2becf28ec7ed1e/build_76a7b10005c70babee357a7d0f2becf28ec7ed1e\nUpdateCTestConfiguration  from :/out/redis___hiredis/git_repo_dir_76a7b10005c70babee357a7d0f2becf28ec7ed1e/build_76a7b10005c70babee357a7d0f2becf28ec7ed1e/DartConfiguration.tcl\nUpdateCTestConfiguration  from :/out/redis___hiredis/git_repo_dir_76a7b10005c70babee357a7d0f2becf28ec7ed1e/build_76a7b10005c70babee357a7d0f2becf28ec7ed1e/DartConfiguration.tcl\nTest project /out/redis___hiredis/git_repo_dir_76a7b10005c70babee357a7d0f2becf28ec7ed1e/build_76a7b10005c70babee357a7d0f2becf28ec7ed1e\nConstructing a list of tests\nDone constructing a list of tests\nUpdating test list for fixtures\nAdded 0 tests to meet fixture requirements\nChecking test dependency graph...\nChecking test dependency graph end\ntest 1\n    Start 1: hiredis-test\n\n1: Test command: /out/redis___hiredis/git_repo_dir_76a7b10005c70babee357a7d0f2becf28ec7ed1e/test.sh\n1: Working Directory: /out/redis___hiredis/git_repo_dir_76a7b10005c70babee357a7d0f2becf28ec7ed1e/build_76a7b10005c70babee357a7d0f2becf28ec7ed1e\n1: Test timeout computed to be: 10000000\n1: daemonize yes\n1: pidfile /tmp/tmp.huJiQk2vYX/hiredis-test-redis.pid\n1: port 56379\n1: bind 127.0.0.1\n1: unixsocket /tmp/tmp.huJiQk2vYX/hiredis-test-redis.sock\n1: 25103:C 28 Mar 2024 08:41:34.774 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\n1: 25103:C 28 Mar 2024 08:41:34.775 # Redis version=5.0.7, bits=64, commit=00000000, modified=0, pid=25103, just started\n1: 25103:C 28 Mar 2024 08:41:34.775 # Configuration loaded\n1/1 Test #1: hiredis-test .....................***Failed    1.67 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.67 sec\n\nThe following tests FAILED:\n\t  1 - hiredis-test (Failed)\nErrors while running CTest\nOutput from these tests are in: /out/redis___hiredis/git_repo_dir_76a7b10005c70babee357a7d0f2becf28ec7ed1e/build_76a7b10005c70babee357a7d0f2becf28ec7ed1e/Testing/Temporary/LastTest.log\nUse \"--rerun-failed --output-"
    },
    "2bb97f407c1145c850416a3bfbcc8cf124e68a19___gd_gd2.c": {
        "prefix": "static int\n_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (!cidx) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n",
        "suffix": "\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n",
        "start": 63,
        "end": 179,
        "buggy": "static int\n_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (!cidx) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t};\n\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t};\n",
        "src_path": "2bb97f407c1145c850416a3bfbcc8cf124e68a19___gd_gd2.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/2bb97f407c1145c850416a3bfbcc8cf124e68a19",
        "commit_msg": "gd2: handle corrupt images better (CVE-2016-3074)\n\nMake sure we do some range checking on corrupted chunks.\n\nThanks to Hans Jerry Illikainen <hji@dyntopia.com> for indepth report\nand reproducer information.  Made for easy test case writing :).",
        "test_func_diff": [
            {
                "fn": "tests/Makefile.am",
                "patch": "@@ -129,7 +129,8 @@ endif\n \n if HAVE_LIBZ\n check_PROGRAMS += \\\n-\tgd2/gd2_null\n+\tgd2/gd2_null \\\n+\tgd2/gd2_read_corrupt\n endif\n \n if HAVE_LIBPNG"
            },
            {
                "fn": "tests/gd2/gd2_read_corrupt.c",
                "patch": "@@ -0,0 +1,25 @@\n+/* Just try to read the invalid gd2 image & not crash. */\n+#include \"gd.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"gdtest.h\"\n+\n+int main()\n+{\n+\tgdImagePtr im;\n+\tFILE *fp;\n+\tchar path[1024];\n+\n+\t/* Read the corrupt image. */\n+\tsprintf(path, \"%s/gd2/invalid_neg_size.gd2\", GDTEST_TOP_DIR);\n+\tfp = fopen(path, \"rb\");\n+\tif (!fp) {\n+\t\tprintf(\"failed, cannot open file\\n\");\n+\t\treturn 1;\n+\t}\n+\tim = gdImageCreateFromGd2(fp);\n+\tfclose(fp);\n+\n+\t/* Should have failed & rejected it. */\n+\treturn im == NULL ? 0 : 1;\n+}"
            }
        ],
        "error_msg": "========================================\n   GD 2.2.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 102\n# PASS:  99\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  3\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: gd2/gd2_read_corrupt\n==========================\n\ncorrupted size vs. prev_size\nFAIL gd2/gd2_read_corrupt (exit status: 134)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\n(491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:35: Total pixels changed: 9 with a maximum channel difference of 0.\nReference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\n"
    },
    "1846f48e5fcdde996e7c27a4bbac5d0aef183e4b___gd.c": {
        "prefix": "BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n",
        "suffix": "\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char), sx)) {\n\t\treturn NULL;\n\t}\n\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n\n\t/* Row-major ever since gd 1.3 */\n\tim->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; (i < sy); i++) {\n\t\t/* Row-major ever since gd 1.3 */\n\t\tim->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\tif (!im->pixels[i]) {\n\t\t\tfor (--i ; i >= 0; i--) {\n\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t}\n\t\t\tgdFree(im->pixels);\n\t\t\tgdFree(im);\n\t\t\treturn NULL;\n\t\t}\n\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tim->open[i] = 1;\n\t};\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->res_x = GD_RESOLUTION;\n\tim->res_y = GD_RESOLUTION;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}\n",
        "start": 183,
        "end": 249,
        "buggy": "BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char), sx)) {\n\t\treturn NULL;\n\t}\n\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n\n\t/* Row-major ever since gd 1.3 */\n\tim->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; (i < sy); i++) {\n\t\t/* Row-major ever since gd 1.3 */\n\t\tim->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\tif (!im->pixels[i]) {\n\t\t\tfor (--i ; i >= 0; i--) {\n\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t}\n\t\t\tgdFree(im->pixels);\n\t\t\tgdFree(im);\n\t\t\treturn NULL;\n\t\t}\n\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tim->open[i] = 1;\n\t};\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->res_x = GD_RESOLUTION;\n\tim->res_y = GD_RESOLUTION;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\tif (overflow2(sizeof (unsigned char *), sy)) {\n",
        "src_path": "1846f48e5fcdde996e7c27a4bbac5d0aef183e4b___gd.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/1846f48e5fcdde996e7c27a4bbac5d0aef183e4b",
        "commit_msg": "Fix #340: System frozen\n\ngdImageCreate() doesn't check for oversized images and as such is prone\nto DoS vulnerabilities. We fix that by applying the same overflow check\nthat is already in place for gdImageCreateTrueColor().\n\nCVE-2016-9317",
        "test_func_diff": [
            {
                "fn": "tests/CMakeLists.txt",
                "patch": "@@ -38,6 +38,7 @@ if (BUILD_TEST)\n \t\tgdimagecopy\n \t\tgdimagecopyresampled\n \t\tgdimagecopyrotated\n+\t\tgdimagecreate\n \t\tgdimagecrop\n \t\tgdimagefile\n \t\tgdimagefill"
            },
            {
                "fn": "tests/Makefile.am",
                "patch": "@@ -33,6 +33,7 @@ include gdimageconvolution/Makemodule.am\n include gdimagecopy/Makemodule.am\n include gdimagecopyresampled/Makemodule.am\n include gdimagecopyrotated/Makemodule.am\n+include gdimagecreate/Makemodule.am\n include gdimagecrop/Makemodule.am\n include gdimagefile/Makemodule.am\n include gdimagefill/Makemodule.am"
            },
            {
                "fn": "tests/gdimagecreate/.gitignore",
                "patch": "@@ -0,0 +1 @@\n+/bug00340"
            },
            {
                "fn": "tests/gdimagecreate/CMakeLists.txt",
                "patch": "@@ -0,0 +1,5 @@\n+SET(TESTS_FILES\n+\tbug00340\n+)\n+\n+ADD_GD_TESTS()"
            },
            {
                "fn": "tests/gdimagecreate/Makemodule.am",
                "patch": "@@ -0,0 +1,5 @@\n+libgd_test_programs += \\\n+\tgdimagecreate/bug00340\n+\n+EXTRA_DIST += \\\n+\tgdimagecreate/CMakeLists.txt"
            },
            {
                "fn": "tests/gdimagecreate/bug00340.c",
                "patch": "@@ -0,0 +1,33 @@\n+/**\r\n+ * Regression test for <https://github.com/libgd/libgd/issues/340>\r\n+ *\r\n+ * We're testing that trying to create an oversized image fails early,\r\n+ * triggering an appropriate warning.\r\n+ */\r\n+\r\n+\r\n+#include <string.h>\r\n+#include \"gd.h\"\r\n+#include \"gd_errors.h\"\r\n+#include \"gdtest.h\"\r\n+\r\n+\r\n+#define MSG \"product of memory allocation multiplication would exceed INT_MAX, failing operation gracefully\\n\"\r\n+\r\n+\r\n+void error_handler(int priority, const char *format, ...)\r\n+{\r\n+    gdTestAssert(priority == GD_WARNING);\r\n+    gdTestAssert(!strcmp(format, MSG));\r\n+}\r\n+\r\n+\r\n+int main()\r\n+{\r\n+    gdImagePtr im;\r\n+\r\n+    im = gdImageCreate(64970, 65111);\r\n+    gdTestAssert(im == NULL);\r\n+\r\n+    return gdNumFailures();\r\n+}\r"
            }
        ],
        "error_msg": "========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 156\n# PASS:  154\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  2\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:31: Total pixels changed: 9 with a maximum channel difference of 255.\nfreetype/bug00132.c:33: Reference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\ngdimagestringft/gdimagestringft_bbox.c:56: (491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\n"
    },
    "69d2fd2c597ffc0c217de1238b9bf4d4bceba8e6___gd_gd2.c": {
        "prefix": "static int\n_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n",
        "suffix": "\n\t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tif (overflow2(sizeof(t_chunk_info), nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0)\n\t\t\t\tgoto fail2;\n\t\t};\n\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n",
        "start": 121,
        "end": 247,
        "buggy": "static int\n_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\n\t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tif (overflow2(sizeof(t_chunk_info), nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0)\n\t\t\t\tgoto fail2;\n\t\t};\n\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\tnc = (*ncx) * (*ncy);\n",
        "src_path": "69d2fd2c597ffc0c217de1238b9bf4d4bceba8e6___gd_gd2.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/69d2fd2c597ffc0c217de1238b9bf4d4bceba8e6",
        "commit_msg": "Fix #354: Signed Integer Overflow gd_io.c\n\nGD2 stores the number of horizontal and vertical chunks as words (i.e. 2\nbyte unsigned). These values are multiplied and assigned to an int when\nreading the image, what can cause integer overflows. We have to avoid\nthat, and also make sure that either chunk count is actually greater\nthan zero. If illegal chunk counts are detected, we bail out from\nreading the image.",
        "test_func_diff": [
            {
                "fn": "tests/gd2/.gitignore",
                "patch": "@@ -1,5 +1,6 @@\n /bug_289\n /bug00309\n+/bug00354\n /gd2_empty_file\n /gd2_im2im\n /gd2_null"
            },
            {
                "fn": "tests/gd2/CMakeLists.txt",
                "patch": "@@ -1,6 +1,7 @@\n LIST(APPEND TESTS_FILES\n \tbug_289\n \tbug00309\n+\tbug00354\n \tgd2_empty_file\n \tgd2_im2im\n \tgd2_null"
            },
            {
                "fn": "tests/gd2/Makemodule.am",
                "patch": "@@ -1,6 +1,7 @@\n libgd_test_programs += \\\n \tgd2/bug_289 \\\n \tgd2/bug00309 \\\n+\tgd2/bug00354 \\\n \tgd2/gd2_empty_file \\\n \tgd2/php_bug_72339 \\\n \tgd2/gd2_read_corrupt \\\n@@ -19,6 +20,8 @@ endif\n \n EXTRA_DIST += \\\n \tgd2/CMakeLists.txt \\\n+\tgd2/bug00354a.gd2 \\\n+\tgd2/bug00354b.gd2 \\\n \tgd2/conv_gd2_exp.gd2 \\\n \tgd2/conv_test.gd2 \\\n \tgd2/conv_test_exp.png \\"
            },
            {
                "fn": "tests/gd2/bug00354.c",
                "patch": "@@ -0,0 +1,32 @@\n+/**\r\n+ * We're testing GD2 image files which report illegal chunk counts. These should\r\n+ * not cause integer overflows or other issues, but instead simply fail to be\r\n+ * loaded.\r\n+ *\r\n+ * See also <https://github.com/libgd/libgd/issues/354>.\r\n+ */\r\n+\r\n+\r\n+#include \"gd.h\"\r\n+#include \"gdtest.h\"\r\n+\r\n+\r\n+int main()\r\n+{\r\n+    gdImagePtr im;\r\n+    FILE *fp;\r\n+\r\n+    fp = gdTestFileOpen2(\"gd2\", \"bug00354a.gd2\");\r\n+    gdTestAssert(fp != NULL);\r\n+    im = gdImageCreateFromGd2(fp);\r\n+    gdTestAssert(im == NULL);\r\n+    fclose(fp);\r\n+\r\n+    fp = gdTestFileOpen2(\"gd2\", \"bug00354b.gd2\");\r\n+    gdTestAssert(fp != NULL);\r\n+    im = gdImageCreateFromGd2(fp);\r\n+    gdTestAssert(im == NULL);\r\n+    fclose(fp);\r\n+\r\n+    return gdNumFailures();\r\n+}\r"
            }
        ],
        "error_msg": "========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 157\n# PASS:  155\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  2\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:31: Total pixels changed: 9 with a maximum channel difference of 255.\nfreetype/bug00132.c:33: Reference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\ngdimagestringft/gdimagestringft_bbox.c:56: (491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\n"
    },
    "7325e9a5e71e2fc0e350487ecac7d84acdf0ed5e___jwe.c": {
        "prefix": "static bool _cjose_jwe_decrypt_dat_aes_gcm(cjose_jwe_t *jwe, cjose_err *err)\n{\n    EVP_CIPHER_CTX *ctx = NULL;\n\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // get AES GCM cipher\n    const EVP_CIPHER *cipher = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128GCM) == 0)\n        cipher = EVP_aes_128_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A192GCM) == 0)\n        cipher = EVP_aes_192_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A256GCM) == 0)\n        cipher = EVP_aes_256_gcm();\n\n    if (NULL == cipher)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // instantiate and initialize a new openssl cipher context\n    ctx = EVP_CIPHER_CTX_new();\n    if (NULL == ctx)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    EVP_CIPHER_CTX_init(ctx);\n\n    // initialize context for decryption using AES GCM cipher and CEK and IV\n    if (EVP_DecryptInit_ex(ctx, cipher, NULL, jwe->cek, jwe->enc_iv.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n",
        "suffix": "    if (EVP_CIPHER_CTX_ctrl(ctx, CJOSE_EVP_CTRL_GCM_SET_TAG, jwe->enc_auth_tag.raw_len, jwe->enc_auth_tag.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // set GCM mode AAD data (hdr_b64u) by setting \"out\" to NULL\n    int bytes_decrypted = 0;\n    if (EVP_DecryptUpdate(ctx, NULL, &bytes_decrypted, (unsigned char *)jwe->enc_header.b64u, jwe->enc_header.b64u_len) != 1\n        || bytes_decrypted != jwe->enc_header.b64u_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // allocate buffer for the plaintext\n    cjose_get_dealloc()(jwe->dat);\n    jwe->dat_len = jwe->enc_ct.raw_len;\n    if (!_cjose_jwe_malloc(jwe->dat_len, false, &jwe->dat, err))\n    {\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // decrypt ciphertext to plaintext buffer\n    if (EVP_DecryptUpdate(ctx, jwe->dat, &bytes_decrypted, jwe->enc_ct.raw, jwe->enc_ct.raw_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    jwe->dat_len = bytes_decrypted;\n\n    // finalize the decryption\n    if (EVP_DecryptFinal_ex(ctx, NULL, &bytes_decrypted) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    EVP_CIPHER_CTX_free(ctx);\n    return true;\n\n_cjose_jwe_decrypt_dat_aes_gcm_fail:\n    if (NULL != ctx)\n    {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n    return false;\n}\n",
        "start": 1244,
        "end": 1337,
        "buggy": "static bool _cjose_jwe_decrypt_dat_aes_gcm(cjose_jwe_t *jwe, cjose_err *err)\n{\n    EVP_CIPHER_CTX *ctx = NULL;\n\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // get AES GCM cipher\n    const EVP_CIPHER *cipher = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128GCM) == 0)\n        cipher = EVP_aes_128_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A192GCM) == 0)\n        cipher = EVP_aes_192_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A256GCM) == 0)\n        cipher = EVP_aes_256_gcm();\n\n    if (NULL == cipher)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // instantiate and initialize a new openssl cipher context\n    ctx = EVP_CIPHER_CTX_new();\n    if (NULL == ctx)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    EVP_CIPHER_CTX_init(ctx);\n\n    // initialize context for decryption using AES GCM cipher and CEK and IV\n    if (EVP_DecryptInit_ex(ctx, cipher, NULL, jwe->cek, jwe->enc_iv.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // set the expected GCM-mode authentication tag\n    if (EVP_CIPHER_CTX_ctrl(ctx, CJOSE_EVP_CTRL_GCM_SET_TAG, jwe->enc_auth_tag.raw_len, jwe->enc_auth_tag.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // set GCM mode AAD data (hdr_b64u) by setting \"out\" to NULL\n    int bytes_decrypted = 0;\n    if (EVP_DecryptUpdate(ctx, NULL, &bytes_decrypted, (unsigned char *)jwe->enc_header.b64u, jwe->enc_header.b64u_len) != 1\n        || bytes_decrypted != jwe->enc_header.b64u_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // allocate buffer for the plaintext\n    cjose_get_dealloc()(jwe->dat);\n    jwe->dat_len = jwe->enc_ct.raw_len;\n    if (!_cjose_jwe_malloc(jwe->dat_len, false, &jwe->dat, err))\n    {\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // decrypt ciphertext to plaintext buffer\n    if (EVP_DecryptUpdate(ctx, jwe->dat, &bytes_decrypted, jwe->enc_ct.raw, jwe->enc_ct.raw_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    jwe->dat_len = bytes_decrypted;\n\n    // finalize the decryption\n    if (EVP_DecryptFinal_ex(ctx, NULL, &bytes_decrypted) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    EVP_CIPHER_CTX_free(ctx);\n    return true;\n\n_cjose_jwe_decrypt_dat_aes_gcm_fail:\n    if (NULL != ctx)\n    {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n    return false;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    // set the expected GCM-mode authentication tag\n",
        "src_path": "7325e9a5e71e2fc0e350487ecac7d84acdf0ed5e___jwe.c",
        "uri": "https://api.github.com/repos/OpenIDC/cjose/commits/7325e9a5e71e2fc0e350487ecac7d84acdf0ed5e",
        "commit_msg": "use fixed authentication tag length of 16 octets in AES GCM decryption\n\nsee: https://github.com/cisco/cjose/issues/125\n\nSigned-off-by: Hans Zandbelt <hans.zandbelt@openidc.com>",
        "test_func_diff": [
            {
                "fn": "test/check_jwe.c",
                "patch": "@@ -967,6 +967,63 @@ START_TEST(test_cjose_jwe_decrypt_aes)\n }\n END_TEST\n \n+START_TEST(test_cjose_jwe_decrypt_aes_gcm)\n+{\n+    cjose_err err;\n+\n+    const char *key = JWK_OCT_32;\n+    const char *plain1 = \"Live long and prosper.\";\n+    char *compact1 = \"eyJhbGciOiAiZGlyIiwgImVuYyI6ICJBMjU2R0NNIn0..Du_9fxxV-zrReaWC.aS_rpokeuxkaPc2sykcQDCQuJCYoww.GpeKGEqd8KQ0v6JNea5aSA\";\n+    char *compact2 = \"eyJhbGciOiAiZGlyIiwgImVuYyI6ICJBMjU2R0NNIn0..Du_9fxxV-zrReaWC.aS_rpokeuxkaPc2sykcQDCQuJCYoww.Gp\";\n+\n+    cjose_jwk_t *jwk = cjose_jwk_import(key, strlen(key), &err);\n+    ck_assert_msg(NULL != jwk,\n+                  \"cjose_jwk_import failed: \"\n+                  \"%s, file: %s, function: %s, line: %ld\",\n+                  err.message, err.file, err.function, err.line);\n+\n+    cjose_jwe_t *jwe1 = cjose_jwe_import(compact1, strlen(compact1), &err);\n+    ck_assert_msg(NULL != jwe1,\n+                  \"cjose_jwe_import failed: \"\n+                  \"%s, file: %s, function: %s, line: %ld\",\n+                  err.message, err.file, err.function, err.line);\n+\n+    uint8_t *plain2 = NULL;\n+    size_t plain2_len = 0;\n+    plain2 = cjose_jwe_decrypt(jwe1, jwk, &plain2_len, &err);\n+    ck_assert_msg(NULL != plain2,\n+                  \"cjose_jwe_decrypt failed: \"\n+                  \"%s, file: %s, function: %s, line: %ld\",\n+                  err.message, err.file, err.function, err.line);\n+\n+    ck_assert_msg(plain2_len == strlen(plain1),\n+                  \"length of decrypted plaintext does not match length of original, \"\n+                  \"expected: %lu, found: %lu\",\n+                  strlen(plain1), plain2_len);\n+    ck_assert_msg(strncmp(plain1, plain2, plain2_len) == 0, \"decrypted plaintext does not match encrypted plaintext\");\n+\n+    cjose_get_dealloc()(plain2);\n+    cjose_jwe_release(jwe1);\n+\n+    cjose_jwe_t *jwe2 = cjose_jwe_import(compact2, strlen(compact2), &err);\n+    ck_assert_msg(NULL != jwe2,\n+                   \"cjose_jwe_import failed: \"\n+                   \"%s, file: %s, function: %s, line: %ld\",\n+                   err.message, err.file, err.function, err.line);\n+\n+    uint8_t *plain3 = NULL;\n+    size_t plain3_len = 0;\n+    plain3 = cjose_jwe_decrypt(jwe2, jwk, &plain3_len, &err);\n+    ck_assert_msg(NULL == plain3,\n+                   \"cjose_jwe_decrypt succeeded where it should have failed: \"\n+                   \"%s, file: %s, function: %s, line: %ld\",\n+                   err.message, err.file, err.function, err.line);\n+\n+    cjose_jwe_release(jwe2);\n+    cjose_jwk_release(jwk);\n+}\n+END_TEST\n+\n START_TEST(test_cjose_jwe_decrypt_rsa)\n {\n     struct cjose_jwe_decrypt_rsa\n@@ -1373,6 +1430,7 @@ Suite *cjose_jwe_suite()\n     tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_large);\n     tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_many);\n     tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_aes);\n+    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_aes_gcm);\n     tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_rsa);\n     tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_header);\n     tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_key);"
            }
        ],
        "error_msg": "check_jwe.c:1017:F:core:test_cjose_jwe_decrypt_aes_gcm:0: cjose_jwe_decrypt succeeded where it should have failed: (, file: H\bD]A\\\u000f\u001f, function: (null), line: 0\n"
    },
    "abd159cce48f3e34f08e4751c568e09677d5ec9c___file.c": {
        "prefix": "PHP_FUNCTION(flock)\n{\n\tzval *arg1, *arg3 = NULL;\n\tint act;\n\tphp_stream *stream;\n\tlong operation = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl|z\", &arg1, &operation, &arg3) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tact = operation & 3;\n\tif (act < 1 || act > 3) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Illegal operation argument\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (arg3 && PZVAL_IS_REF(arg3)) {\n\t\tconvert_to_long_ex(&arg3);\n\t\tZ_LVAL_P(arg3) = 0;\n\t}\n\n\t/* flock_values contains all possible actions if (operation & 4) we won't block on the lock */\n\tact = flock_values[act - 1] | (operation & PHP_LOCK_NB ? LOCK_NB : 0);\n\tif (php_stream_lock(stream, act)) {\n\t\tif (operation && errno == EWOULDBLOCK && arg3 && PZVAL_IS_REF(arg3)) {\n\t\t\tZ_LVAL_P(arg3) = 1;\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n#define PHP_META_UNSAFE \".\\\\+*?[^]$() \"\n\n/* {{{ proto array get_meta_tags(string filename [, bool use_include_path])\n   Extracts all meta tag content attributes from a file and returns an array */\nPHP_FUNCTION(get_meta_tags)\n{\n\tchar *filename;\n\tint filename_len;\n\tzend_bool use_include_path = 0;\n\tint in_tag = 0, done = 0;\n\tint looking_for_val = 0, have_name = 0, have_content = 0;\n\tint saw_name = 0, saw_content = 0;\n\tchar *name = NULL, *value = NULL, *temp = NULL;\n\tphp_meta_tags_token tok, tok_last;\n\tphp_meta_tags_data md;\n\n\t/* Initiailize our structure */\n\tmemset(&md, 0, sizeof(md));\n\n\t/* Parse arguments */\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|b\", &filename, &filename_len, &use_include_path) == FAILURE) {\n\t\treturn;\n\t}\n\n\tmd.stream = php_stream_open_wrapper(filename, \"rb\",\n\t\t\t(use_include_path ? USE_PATH : 0) | REPORT_ERRORS,\n\t\t\tNULL);\n\tif (!md.stream)\t{\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\ttok_last = TOK_EOF;\n\n\twhile (!done && (tok = php_next_meta_token(&md TSRMLS_CC)) != TOK_EOF) {\n\t\tif (tok == TOK_ID) {\n\t\t\tif (tok_last == TOK_OPENTAG) {\n\t\t\t\tmd.in_meta = !strcasecmp(\"meta\", md.token_data);\n\t\t\t} else if (tok_last == TOK_SLASH && in_tag) {\n\t\t\t\tif (strcasecmp(\"head\", md.token_data) == 0) {\n\t\t\t\t\t/* We are done here! */\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t} else if (tok_last == TOK_EQUAL && looking_for_val) {\n\t\t\t\tif (saw_name) {\n\t\t\t\t\tSTR_FREE(name);\n\t\t\t\t\t/* Get the NAME attr (Single word attr, non-quoted) */\n\t\t\t\t\ttemp = name = estrndup(md.token_data, md.token_len);\n\n\t\t\t\t\twhile (temp && *temp) {\n\t\t\t\t\t\tif (strchr(PHP_META_UNSAFE, *temp)) {\n\t\t\t\t\t\t\t*temp = '_';\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp++;\n\t\t\t\t\t}\n\n\t\t\t\t\thave_name = 1;\n\t\t\t\t} else if (saw_content) {\n\t\t\t\t\tSTR_FREE(value);\n\t\t\t\t\tvalue = estrndup(md.token_data, md.token_len);\n\t\t\t\t\thave_content = 1;\n\t\t\t\t}\n\n\t\t\t\tlooking_for_val = 0;\n\t\t\t} else {\n\t\t\t\tif (md.in_meta) {\n\t\t\t\t\tif (strcasecmp(\"name\", md.token_data) == 0) {\n\t\t\t\t\t\tsaw_name = 1;\n\t\t\t\t\t\tsaw_content = 0;\n\t\t\t\t\t\tlooking_for_val = 1;\n\t\t\t\t\t} else if (strcasecmp(\"content\", md.token_data) == 0) {\n\t\t\t\t\t\tsaw_name = 0;\n\t\t\t\t\t\tsaw_content = 1;\n\t\t\t\t\t\tlooking_for_val = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tok == TOK_STRING && tok_last == TOK_EQUAL && looking_for_val) {\n\t\t\tif (saw_name) {\n\t\t\t\tSTR_FREE(name);\n\t\t\t\t/* Get the NAME attr (Quoted single/double) */\n\t\t\t\ttemp = name = estrndup(md.token_data, md.token_len);\n\n\t\t\t\twhile (temp && *temp) {\n\t\t\t\t\tif (strchr(PHP_META_UNSAFE, *temp)) {\n\t\t\t\t\t\t*temp = '_';\n\t\t\t\t\t}\n\t\t\t\t\ttemp++;\n\t\t\t\t}\n\n\t\t\t\thave_name = 1;\n\t\t\t} else if (saw_content) {\n\t\t\t\tSTR_FREE(value);\n\t\t\t\tvalue = estrndup(md.token_data, md.token_len);\n\t\t\t\thave_content = 1;\n\t\t\t}\n\n\t\t\tlooking_for_val = 0;\n\t\t} else if (tok == TOK_OPENTAG) {\n\t\t\tif (looking_for_val) {\n\t\t\t\tlooking_for_val = 0;\n\t\t\t\thave_name = saw_name = 0;\n\t\t\t\thave_content = saw_content = 0;\n\t\t\t}\n\t\t\tin_tag = 1;\n\t\t} else if (tok == TOK_CLOSETAG) {\n\t\t\tif (have_name) {\n\t\t\t\t/* For BC */\n\t\t\t\tphp_strtolower(name, strlen(name));\n\t\t\t\tif (have_content) {\n\t\t\t\t\tadd_assoc_string(return_value, name, value, 1);\n\t\t\t\t} else {\n\t\t\t\t\tadd_assoc_string(return_value, name, \"\", 1);\n\t\t\t\t}\n\n\t\t\t\tefree(name);\n\t\t\t\tSTR_FREE(value);\n\t\t\t} else if (have_content) {\n\t\t\t\tefree(value);\n\t\t\t}\n\n\t\t\tname = value = NULL;\n\n\t\t\t/* Reset all of our flags */\n\t\t\tin_tag = looking_for_val = 0;\n\t\t\thave_name = saw_name = 0;\n\t\t\thave_content = saw_content = 0;\n\t\t\tmd.in_meta = 0;\n\t\t}\n\n\t\ttok_last = tok;\n\n\t\tif (md.token_data)\n\t\t\tefree(md.token_data);\n\n\t\tmd.token_data = NULL;\n\t}\n\n\tSTR_FREE(value);\n\tSTR_FREE(name);\n\tphp_stream_close(md.stream);\n}\n/* }}} */\n\n/* {{{ proto string file_get_contents(string filename [, bool use_include_path [, resource context [, long offset [, long maxlen]]]])\n   Read the entire file into a string */\nPHP_FUNCTION(file_get_contents)\n{\n\tchar *filename;\n\tint filename_len;\n\tchar *contents;\n\tzend_bool use_include_path = 0;\n\tphp_stream *stream;\n\tlong len;\n\tlong offset = -1;\n\tlong maxlen = PHP_STREAM_COPY_ALL;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\n\t/* Parse arguments */\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|br!ll\", &filename, &filename_len, &use_include_path, &zcontext, &offset, &maxlen) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZEND_NUM_ARGS() == 5 && maxlen < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"length must be greater than or equal to zero\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\",\n\t\t\t\t(use_include_path ? USE_PATH : 0) | REPORT_ERRORS,\n\t\t\t\tNULL, context);\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (offset > 0 && php_stream_seek(stream, offset, SEEK_SET) < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to seek to position %ld in the stream\", offset);\n\t\tphp_stream_close(stream);\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((len = php_stream_copy_to_mem(stream, &contents, maxlen, 0)) > 0) {\n\t\tif (len > INT_MAX) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"content truncated from %ld to %d bytes\", len, INT_MAX);\n\t\t\tlen = INT_MAX;\n\t\t}\n\t\tRETVAL_STRINGL(contents, len, 0);\n\t} else if (len == 0) {\n\t\tRETVAL_EMPTY_STRING();\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n\n\tphp_stream_close(stream);\n}\n/* }}} */\n\n/* {{{ proto int file_put_contents(string file, mixed data [, int flags [, resource context]])\n   Write/Create a file with contents data and return the number of bytes written */\nPHP_FUNCTION(file_put_contents)\n{\n\tphp_stream *stream;\n\tchar *filename;\n\tint filename_len;\n\tzval *data;\n\tlong numbytes = 0;\n\tlong flags = 0;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\tphp_stream *srcstream = NULL;\n\tchar mode[3] = \"wb\";\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pz/|lr!\", &filename, &filename_len, &data, &flags, &zcontext) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (Z_TYPE_P(data) == IS_RESOURCE) {\n\t\tphp_stream_from_zval(srcstream, &data);\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, flags & PHP_FILE_NO_DEFAULT_CONTEXT);\n\n\tif (flags & PHP_FILE_APPEND) {\n\t\tmode[0] = 'a';\n\t} else if (flags & LOCK_EX) {\n\t\t/* check to make sure we are dealing with a regular file */\n\t\tif (php_memnstr(filename, \"://\", sizeof(\"://\") - 1, filename + filename_len)) {\n\t\t\tif (strncasecmp(filename, \"file://\", sizeof(\"file://\") - 1)) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Exclusive locks may only be set for regular files\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t\tmode[0] = 'c';\n\t}\n\tmode[2] = '\\0';\n\n\tstream = php_stream_open_wrapper_ex(filename, mode, ((flags & PHP_FILE_USE_INCLUDE_PATH) ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\tif (stream == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (flags & LOCK_EX && (!php_stream_supports_lock(stream) || php_stream_lock(stream, LOCK_EX))) {\n\t\tphp_stream_close(stream);\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Exclusive locks are not supported for this stream\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (mode[0] == 'c') {\n\t\tphp_stream_truncate_set_size(stream, 0);\n\t}\n\n\tswitch (Z_TYPE_P(data)) {\n\t\tcase IS_RESOURCE: {\n\t\t\tsize_t len;\n\t\t\tif (php_stream_copy_to_stream_ex(srcstream, stream, PHP_STREAM_COPY_ALL, &len) != SUCCESS) {\n\t\t\t\tnumbytes = -1;\n\t\t\t} else {\n\t\t\t\tif (len > LONG_MAX) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"content truncated from %lu to %ld bytes\", (unsigned long) len, LONG_MAX);\n\t\t\t\t\tlen = LONG_MAX;\n\t\t\t\t}\n\t\t\t\tnumbytes = len;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase IS_NULL:\n\t\tcase IS_LONG:\n\t\tcase IS_DOUBLE:\n\t\tcase IS_BOOL:\n\t\tcase IS_CONSTANT:\n\t\t\tconvert_to_string_ex(&data);\n\n\t\tcase IS_STRING:\n\t\t\tif (Z_STRLEN_P(data)) {\n\t\t\t\tnumbytes = php_stream_write(stream, Z_STRVAL_P(data), Z_STRLEN_P(data));\n\t\t\t\tif (numbytes != Z_STRLEN_P(data)) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Only %ld of %d bytes written, possibly out of free disk space\", numbytes, Z_STRLEN_P(data));\n\t\t\t\t\tnumbytes = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IS_ARRAY:\n\t\t\tif (zend_hash_num_elements(Z_ARRVAL_P(data))) {\n\t\t\t\tint bytes_written;\n\t\t\t\tzval **tmp;\n\t\t\t\tHashPosition pos;\n\n\t\t\t\tzend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(data), &pos);\n\t\t\t\twhile (zend_hash_get_current_data_ex(Z_ARRVAL_P(data), (void **) &tmp, &pos) == SUCCESS) {\n\t\t\t\t\tif (Z_TYPE_PP(tmp) != IS_STRING) {\n\t\t\t\t\t\tSEPARATE_ZVAL(tmp);\n\t\t\t\t\t\tconvert_to_string(*tmp);\n\t\t\t\t\t}\n\t\t\t\t\tif (Z_STRLEN_PP(tmp)) {\n\t\t\t\t\t\tnumbytes += Z_STRLEN_PP(tmp);\n\t\t\t\t\t\tbytes_written = php_stream_write(stream, Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp));\n\t\t\t\t\t\tif (bytes_written < 0 || bytes_written != Z_STRLEN_PP(tmp)) {\n\t\t\t\t\t\t\tif (bytes_written < 0) {\n\t\t\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to write %d bytes to %s\", Z_STRLEN_PP(tmp), filename);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Only %d of %d bytes written, possibly out of free disk space\", bytes_written, Z_STRLEN_PP(tmp));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnumbytes = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_move_forward_ex(Z_ARRVAL_P(data), &pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IS_OBJECT:\n\t\t\tif (Z_OBJ_HT_P(data) != NULL) {\n\t\t\t\tzval out;\n\n\t\t\t\tif (zend_std_cast_object_tostring(data, &out, IS_STRING TSRMLS_CC) == SUCCESS) {\n\t\t\t\t\tnumbytes = php_stream_write(stream, Z_STRVAL(out), Z_STRLEN(out));\n\t\t\t\t\tif (numbytes != Z_STRLEN(out)) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Only %ld of %d bytes written, possibly out of free disk space\", numbytes, Z_STRLEN(out));\n\t\t\t\t\t\tnumbytes = -1;\n\t\t\t\t\t}\n\t\t\t\t\tzval_dtor(&out);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tnumbytes = -1;\n\t\t\tbreak;\n\t}\n\tphp_stream_close(stream);\n\n\tif (numbytes < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_LONG(numbytes);\n}\n/* }}} */\n\n#define PHP_FILE_BUF_SIZE\t80\n\n/* {{{ proto array file(string filename [, int flags[, resource context]])\n   Read entire file into an array */\nPHP_FUNCTION(file)\n{\n\tchar *filename;\n\tint filename_len;\n\tchar *target_buf=NULL, *p, *s, *e;\n\tregister int i = 0;\n\tint target_len;\n\tchar eol_marker = '\\n';\n\tlong flags = 0;\n\tzend_bool use_include_path;\n\tzend_bool include_new_line;\n\tzend_bool skip_blank_lines;\n\tphp_stream *stream;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\n\t/* Parse arguments */\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|lr!\", &filename, &filename_len, &flags, &zcontext) == FAILURE) {\n\t\treturn;\n\t}\n\tif (flags < 0 || flags > (PHP_FILE_USE_INCLUDE_PATH | PHP_FILE_IGNORE_NEW_LINES | PHP_FILE_SKIP_EMPTY_LINES | PHP_FILE_NO_DEFAULT_CONTEXT)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"'%ld' flag is not supported\", flags);\n\t\tRETURN_FALSE;\n\t}\n\n\tuse_include_path = flags & PHP_FILE_USE_INCLUDE_PATH;\n\tinclude_new_line = !(flags & PHP_FILE_IGNORE_NEW_LINES);\n\tskip_blank_lines = flags & PHP_FILE_SKIP_EMPTY_LINES;\n\n\tcontext = php_stream_context_from_zval(zcontext, flags & PHP_FILE_NO_DEFAULT_CONTEXT);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\", (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Initialize return array */\n\tarray_init(return_value);\n\n\tif ((target_len = php_stream_copy_to_mem(stream, &target_buf, PHP_STREAM_COPY_ALL, 0))) {\n\t\ts = target_buf;\n\t\te = target_buf + target_len;\n\n\t\tif (!(p = php_stream_locate_eol(stream, target_buf, target_len TSRMLS_CC))) {\n\t\t\tp = e;\n\t\t\tgoto parse_eol;\n\t\t}\n\n\t\tif (stream->flags & PHP_STREAM_FLAG_EOL_MAC) {\n\t\t\teol_marker = '\\r';\n\t\t}\n\n\t\t/* for performance reasons the code is duplicated, so that the if (include_new_line)\n\t\t * will not need to be done for every single line in the file. */\n\t\tif (include_new_line) {\n\t\t\tdo {\n\t\t\t\tp++;\nparse_eol:\n\t\t\t\tadd_index_stringl(return_value, i++, estrndup(s, p-s), p-s, 0);\n\t\t\t\ts = p;\n\t\t\t} while ((p = memchr(p, eol_marker, (e-p))));\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tint windows_eol = 0;\n\t\t\t\tif (p != target_buf && eol_marker == '\\n' && *(p - 1) == '\\r') {\n\t\t\t\t\twindows_eol++;\n\t\t\t\t}\n\t\t\t\tif (skip_blank_lines && !(p-s-windows_eol)) {\n\t\t\t\t\ts = ++p;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tadd_index_stringl(return_value, i++, estrndup(s, p-s-windows_eol), p-s-windows_eol, 0);\n\t\t\t\ts = ++p;\n\t\t\t} while ((p = memchr(p, eol_marker, (e-p))));\n\t\t}\n\n\t\t/* handle any left overs of files without new lines */\n\t\tif (s != e) {\n\t\t\tp = e;\n\t\t\tgoto parse_eol;\n\t\t}\n\t}\n\n\tif (target_buf) {\n\t\tefree(target_buf);\n\t}\n\tphp_stream_close(stream);\n}\n/* }}} */\n\n/* {{{ proto string tempnam(string dir, string prefix)\n   Create a unique filename in a directory */\nPHP_FUNCTION(tempnam)\n{\n\tchar *dir, *prefix;\n\tint dir_len, prefix_len;\n\tsize_t p_len;\n\tchar *opened_path;\n\tchar *p;\n\tint fd;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp\", &dir, &dir_len, &prefix, &prefix_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (php_check_open_basedir(dir TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_basename(prefix, prefix_len, NULL, 0, &p, &p_len TSRMLS_CC);\n\tif (p_len > 64) {\n\t\tp[63] = '\\0';\n\t}\n\n\tRETVAL_FALSE;\n\n\tif ((fd = php_open_temporary_fd_ex(dir, p, &opened_path, 1 TSRMLS_CC)) >= 0) {\n\t\tclose(fd);\n\t\tRETVAL_STRING(opened_path, 0);\n\t}\n\tefree(p);\n}\n/* }}} */\n\n/* {{{ proto resource tmpfile(void)\n   Create a temporary file that will be deleted automatically after use */\nPHP_NAMED_FUNCTION(php_if_tmpfile)\n{\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tstream = php_stream_fopen_tmpfile();\n\n\tif (stream) {\n\t\tphp_stream_to_zval(stream, return_value);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource fopen(string filename, string mode [, bool use_include_path [, resource context]])\n   Open a file or a URL and return a file pointer */\nPHP_NAMED_FUNCTION(php_if_fopen)\n{\n\tchar *filename, *mode;\n\tint filename_len, mode_len;\n\tzend_bool use_include_path = 0;\n\tzval *zcontext = NULL;\n\tphp_stream *stream;\n\tphp_stream_context *context = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ps|br\", &filename, &filename_len, &mode, &mode_len, &use_include_path, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, mode, (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\n\tif (stream == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_stream_to_zval(stream, return_value);\n}\n/* }}} */\n\n/* {{{ proto bool fclose(resource fp)\n   Close an open file pointer */\nPHPAPI PHP_FUNCTION(fclose)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif ((stream->flags & PHP_STREAM_FLAG_NO_FCLOSE) != 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%d is not a valid stream resource\", stream->rsrc_id);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!stream->is_persistent) {\n\t\tphp_stream_close(stream);\n\t} else {\n\t\tphp_stream_pclose(stream);\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto resource popen(string command, string mode)\n   Execute a command and open either a read or a write pipe to it */\nPHP_FUNCTION(popen)\n{\n\tchar *command, *mode;\n\tint command_len, mode_len;\n\tFILE *fp;\n\tphp_stream *stream;\n\tchar *posix_mode;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ps\", &command, &command_len, &mode, &mode_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tposix_mode = estrndup(mode, mode_len);\n#ifndef PHP_WIN32\n\t{\n\t\tchar *z = memchr(posix_mode, 'b', mode_len);\n\t\tif (z) {\n\t\t\tmemmove(z, z + 1, mode_len - (z - posix_mode));\n\t\t}\n\t}\n#endif\n\n\tfp = VCWD_POPEN(command, posix_mode);\n\tif (!fp) {\n\t\tphp_error_docref2(NULL TSRMLS_CC, command, posix_mode, E_WARNING, \"%s\", strerror(errno));\n\t\tefree(posix_mode);\n\t\tRETURN_FALSE;\n\t}\n\n\tstream = php_stream_fopen_from_pipe(fp, mode);\n\n\tif (stream == NULL)\t{\n\t\tphp_error_docref2(NULL TSRMLS_CC, command, mode, E_WARNING, \"%s\", strerror(errno));\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tphp_stream_to_zval(stream, return_value);\n\t}\n\n\tefree(posix_mode);\n}\n/* }}} */\n\n/* {{{ proto int pclose(resource fp)\n   Close a file pointer opened by popen() */\nPHP_FUNCTION(pclose)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tFG(pclose_wait) = 1;\n\tzend_list_delete(stream->rsrc_id);\n\tFG(pclose_wait) = 0;\n\tRETURN_LONG(FG(pclose_ret));\n}\n/* }}} */\n\n/* {{{ proto bool feof(resource fp)\n   Test for end-of-file on a file pointer */\nPHPAPI PHP_FUNCTION(feof)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (php_stream_eof(stream)) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string fgets(resource fp[, int length])\n   Get a line from file pointer */\nPHPAPI PHP_FUNCTION(fgets)\n{\n\tzval *arg1;\n\tlong len = 1024;\n\tchar *buf = NULL;\n\tint argc = ZEND_NUM_ARGS();\n\tsize_t line_len = 0;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|l\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (argc == 1) {\n\t\t/* ask streams to give us a buffer of an appropriate size */\n\t\tbuf = php_stream_get_line(stream, NULL, 0, &line_len);\n\t\tif (buf == NULL) {\n\t\t\tgoto exit_failed;\n\t\t}\n\t} else if (argc > 1) {\n\t\tif (len <= 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tbuf = ecalloc(len + 1, sizeof(char));\n\t\tif (php_stream_get_line(stream, buf, len, &line_len) == NULL) {\n\t\t\tgoto exit_failed;\n\t\t}\n\t}\n\n\tZVAL_STRINGL(return_value, buf, line_len, 0);\n\t/* resize buffer if it's much larger than the result.\n\t * Only needed if the user requested a buffer size. */\n\tif (argc > 1 && Z_STRLEN_P(return_value) < len / 2) {\n\t\tZ_STRVAL_P(return_value) = erealloc(buf, line_len + 1);\n\t}\n\treturn;\n\nexit_failed:\n\tRETVAL_FALSE;\n\tif (buf) {\n\t\tefree(buf);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string fgetc(resource fp)\n   Get a character from file pointer */\nPHPAPI PHP_FUNCTION(fgetc)\n{\n\tzval *arg1;\n\tchar buf[2];\n\tint result;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tresult = php_stream_getc(stream);\n\n\tif (result == EOF) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tbuf[0] = result;\n\t\tbuf[1] = '\\0';\n\n\t\tRETURN_STRINGL(buf, 1, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string fgetss(resource fp [, int length [, string allowable_tags]])\n   Get a line from file pointer and strip HTML tags */\nPHPAPI PHP_FUNCTION(fgetss)\n{\n\tzval *fd;\n\tlong bytes = 0;\n\tsize_t len = 0;\n\tsize_t actual_len, retval_len;\n\tchar *buf = NULL, *retval;\n\tphp_stream *stream;\n\tchar *allowed_tags=NULL;\n\tint allowed_tags_len=0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|ls\", &fd, &bytes, &allowed_tags, &allowed_tags_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fd);\n\n\tif (ZEND_NUM_ARGS() >= 2) {\n\t\tif (bytes <= 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tlen = (size_t) bytes;\n\t\tbuf = safe_emalloc(sizeof(char), (len + 1), 0);\n\t\t/*needed because recv doesnt set null char at end*/\n\t\tmemset(buf, 0, len + 1);\n\t}\n\n\tif ((retval = php_stream_get_line(stream, buf, len, &actual_len)) == NULL)\t{\n\t\tif (buf != NULL) {\n\t\t\tefree(buf);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tretval_len = php_strip_tags(retval, actual_len, &stream->fgetss_state, allowed_tags, allowed_tags_len);\n\n\tRETURN_STRINGL(retval, retval_len, 0);\n}\n/* }}} */\n\n/* {{{ proto mixed fscanf(resource stream, string format [, string ...])\n   Implements a mostly ANSI compatible fscanf() */\nPHP_FUNCTION(fscanf)\n{\n\tint result, format_len, type, argc = 0;\n\tzval ***args = NULL;\n\tzval *file_handle;\n\tchar *buf, *format;\n\tsize_t len;\n\tvoid *what;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs*\", &file_handle, &format, &format_len, &args, &argc) == FAILURE) {\n\t\treturn;\n\t}\n\n\twhat = zend_fetch_resource(&file_handle TSRMLS_CC, -1, \"File-Handle\", &type, 2, php_file_le_stream(), php_file_le_pstream());\n\n\t/* we can't do a ZEND_VERIFY_RESOURCE(what), otherwise we end up\n\t * with a leak if we have an invalid filehandle. This needs changing\n\t * if the code behind ZEND_VERIFY_RESOURCE changed. - cc */\n\tif (!what) {\n\t\tif (args) {\n\t\t\tefree(args);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tbuf = php_stream_get_line((php_stream *) what, NULL, 0, &len);\n\tif (buf == NULL) {\n\t\tif (args) {\n\t\t\tefree(args);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tresult = php_sscanf_internal(buf, format, argc, args, 0, &return_value TSRMLS_CC);\n\n\tif (args) {\n\t\tefree(args);\n\t}\n\tefree(buf);\n\n\tif (SCAN_ERROR_WRONG_PARAM_COUNT == result) {\n\t\tWRONG_PARAM_COUNT;\n\t}\n}\n/* }}} */\n\n/* {{{ proto int fwrite(resource fp, string str [, int length])\n   Binary-safe file write */\nPHPAPI PHP_FUNCTION(fwrite)\n{\n\tzval *arg1;\n\tchar *arg2;\n\tint arg2len;\n\tint ret;\n\tint num_bytes;\n\tlong arg3 = 0;\n\tchar *buffer = NULL;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs|l\", &arg1, &arg2, &arg2len, &arg3) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZEND_NUM_ARGS() == 2) {\n\t\tnum_bytes = arg2len;\n\t} else {\n\t\tnum_bytes = MAX(0, MIN((int)arg3, arg2len));\n\t}\n\n\tif (!num_bytes) {\n\t\tRETURN_LONG(0);\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tret = php_stream_write(stream, buffer ? buffer : arg2, num_bytes);\n\tif (buffer) {\n\t\tefree(buffer);\n\t}\n\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ proto bool fflush(resource fp)\n   Flushes output */\nPHPAPI PHP_FUNCTION(fflush)\n{\n\tzval *arg1;\n\tint ret;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tret = php_stream_flush(stream);\n\tif (ret) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool rewind(resource fp)\n   Rewind the position of a file pointer */\nPHPAPI PHP_FUNCTION(rewind)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (-1 == php_stream_rewind(stream)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto int ftell(resource fp)\n   Get file pointer's read/write position */\nPHPAPI PHP_FUNCTION(ftell)\n{\n\tzval *arg1;\n\tlong ret;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tret = php_stream_tell(stream);\n\tif (ret == -1)\t{\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ proto int fseek(resource fp, int offset [, int whence])\n   Seek on a file pointer */\nPHPAPI PHP_FUNCTION(fseek)\n{\n\tzval *arg1;\n\tlong arg2, whence = SEEK_SET;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl|l\", &arg1, &arg2, &whence) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tRETURN_LONG(php_stream_seek(stream, arg2, whence));\n}\n/* }}} */\n\n/* {{{ php_mkdir\n*/\n\n/* DEPRECATED APIs: Use php_stream_mkdir() instead */\nPHPAPI int php_mkdir_ex(char *dir, long mode, int options TSRMLS_DC)\n{\n\tint ret;\n\n\tif (php_check_open_basedir(dir TSRMLS_CC)) {\n\t\treturn -1;\n\t}\n\n\tif ((ret = VCWD_MKDIR(dir, (mode_t)mode)) < 0 && (options & REPORT_ERRORS)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t}\n\n\treturn ret;\n}\n\nPHPAPI int php_mkdir(char *dir, long mode TSRMLS_DC)\n{\n\treturn php_mkdir_ex(dir, mode, REPORT_ERRORS TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto bool mkdir(string pathname [, int mode [, bool recursive [, resource context]]])\n   Create a directory */\nPHP_FUNCTION(mkdir)\n{\n\tchar *dir;\n\tint dir_len;\n\tzval *zcontext = NULL;\n\tlong mode = 0777;\n\tzend_bool recursive = 0;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|lbr\", &dir, &dir_len, &mode, &recursive, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(php_stream_mkdir(dir, mode, (recursive ? PHP_STREAM_MKDIR_RECURSIVE : 0) | REPORT_ERRORS, context));\n}\n/* }}} */\n\n/* {{{ proto bool rmdir(string dirname[, resource context])\n   Remove a directory */\nPHP_FUNCTION(rmdir)\n{\n\tchar *dir;\n\tint dir_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|r\", &dir, &dir_len, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(php_stream_rmdir(dir, REPORT_ERRORS, context));\n}\n/* }}} */\n\n/* {{{ proto int readfile(string filename [, bool use_include_path[, resource context]])\n   Output a file or a URL */\nPHP_FUNCTION(readfile)\n{\n\tchar *filename;\n\tint filename_len;\n\tint size = 0;\n\tzend_bool use_include_path = 0;\n\tzval *zcontext = NULL;\n\tphp_stream *stream;\n\tphp_stream_context *context = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|br!\", &filename, &filename_len, &use_include_path, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\", (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\tif (stream) {\n\t\tsize = php_stream_passthru(stream);\n\t\tphp_stream_close(stream);\n\t\tRETURN_LONG(size);\n\t}\n\n\tRETURN_FALSE;\n}\n/* }}} */\n\n/* {{{ proto int umask([int mask])\n   Return or change the umask */\nPHP_FUNCTION(umask)\n{\n\tlong arg1 = 0;\n\tint oldumask;\n\n\toldumask = umask(077);\n\n\tif (BG(umask) == -1) {\n\t\tBG(umask) = oldumask;\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZEND_NUM_ARGS() == 0) {\n\t\tumask(oldumask);\n\t} else {\n\t\tumask(arg1);\n\t}\n\n\tRETURN_LONG(oldumask);\n}\n/* }}} */\n\n/* {{{ proto int fpassthru(resource fp)\n   Output all remaining data from a file pointer */\nPHPAPI PHP_FUNCTION(fpassthru)\n{\n\tzval *arg1;\n\tint size;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tsize = php_stream_passthru(stream);\n\tRETURN_LONG(size);\n}\n/* }}} */\n\n/* {{{ proto bool rename(string old_name, string new_name[, resource context])\n   Rename a file */\nPHP_FUNCTION(rename)\n{\n\tchar *old_name, *new_name;\n\tint old_name_len, new_name_len;\n\tzval *zcontext = NULL;\n\tphp_stream_wrapper *wrapper;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp|r\", &old_name, &old_name_len, &new_name, &new_name_len, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\twrapper = php_stream_locate_url_wrapper(old_name, NULL, 0 TSRMLS_CC);\n\n\tif (!wrapper || !wrapper->wops) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to locate stream wrapper\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!wrapper->wops->rename) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s wrapper does not support renaming\", wrapper->wops->label ? wrapper->wops->label : \"Source\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (wrapper != php_stream_locate_url_wrapper(new_name, NULL, 0 TSRMLS_CC)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot rename a file across wrapper types\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(wrapper->wops->rename(wrapper, old_name, new_name, 0, context TSRMLS_CC));\n}\n/* }}} */\n\n/* {{{ proto bool unlink(string filename[, context context])\n   Delete a file */\nPHP_FUNCTION(unlink)\n{\n\tchar *filename;\n\tint filename_len;\n\tphp_stream_wrapper *wrapper;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|r\", &filename, &filename_len, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\twrapper = php_stream_locate_url_wrapper(filename, NULL, 0 TSRMLS_CC);\n\n\tif (!wrapper || !wrapper->wops) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to locate stream wrapper\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!wrapper->wops->unlink) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s does not allow unlinking\", wrapper->wops->label ? wrapper->wops->label : \"Wrapper\");\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_BOOL(wrapper->wops->unlink(wrapper, filename, REPORT_ERRORS, context TSRMLS_CC));\n}\n/* }}} */\n\n/* {{{ proto bool ftruncate(resource fp, int size)\n   Truncate file to 'size' length */\nPHP_NAMED_FUNCTION(php_if_ftruncate)\n{\n\tzval *fp;\n\tlong size;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &fp, &size) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fp);\n\n\tif (!php_stream_truncate_supported(stream)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Can't truncate this stream!\");\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL(0 == php_stream_truncate_set_size(stream, size));\n}\n/* }}} */\n\n/* {{{ proto array fstat(resource fp)\n   Stat() on a filehandle */\nPHP_NAMED_FUNCTION(php_if_fstat)\n{\n\tzval *fp;\n\tzval *stat_dev, *stat_ino, *stat_mode, *stat_nlink, *stat_uid, *stat_gid, *stat_rdev,\n\t\t *stat_size, *stat_atime, *stat_mtime, *stat_ctime, *stat_blksize, *stat_blocks;\n\tphp_stream *stream;\n\tphp_stream_statbuf stat_ssb;\n\tchar *stat_sb_names[13] = {\n\t\t\"dev\", \"ino\", \"mode\", \"nlink\", \"uid\", \"gid\", \"rdev\",\n\t\t\"size\", \"atime\", \"mtime\", \"ctime\", \"blksize\", \"blocks\"\n\t};\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &fp) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fp);\n\n\tif (php_stream_stat(stream, &stat_ssb)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\tMAKE_LONG_ZVAL_INCREF(stat_dev, stat_ssb.sb.st_dev);\n\tMAKE_LONG_ZVAL_INCREF(stat_ino, stat_ssb.sb.st_ino);\n\tMAKE_LONG_ZVAL_INCREF(stat_mode, stat_ssb.sb.st_mode);\n\tMAKE_LONG_ZVAL_INCREF(stat_nlink, stat_ssb.sb.st_nlink);\n\tMAKE_LONG_ZVAL_INCREF(stat_uid, stat_ssb.sb.st_uid);\n\tMAKE_LONG_ZVAL_INCREF(stat_gid, stat_ssb.sb.st_gid);\n#ifdef HAVE_ST_RDEV\n\tMAKE_LONG_ZVAL_INCREF(stat_rdev, stat_ssb.sb.st_rdev);\n#else\n\tMAKE_LONG_ZVAL_INCREF(stat_rdev, -1);\n#endif\n\tMAKE_LONG_ZVAL_INCREF(stat_size, stat_ssb.sb.st_size);\n\tMAKE_LONG_ZVAL_INCREF(stat_atime, stat_ssb.sb.st_atime);\n\tMAKE_LONG_ZVAL_INCREF(stat_mtime, stat_ssb.sb.st_mtime);\n\tMAKE_LONG_ZVAL_INCREF(stat_ctime, stat_ssb.sb.st_ctime);\n#ifdef HAVE_ST_BLKSIZE\n\tMAKE_LONG_ZVAL_INCREF(stat_blksize, stat_ssb.sb.st_blksize);\n#else\n\tMAKE_LONG_ZVAL_INCREF(stat_blksize,-1);\n#endif\n#ifdef HAVE_ST_BLOCKS\n\tMAKE_LONG_ZVAL_INCREF(stat_blocks, stat_ssb.sb.st_blocks);\n#else\n\tMAKE_LONG_ZVAL_INCREF(stat_blocks,-1);\n#endif\n\t/* Store numeric indexes in propper order */\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_dev, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_ino, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_mode, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_nlink, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_uid, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_gid, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_rdev, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_size, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_atime, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_mtime, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_ctime, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_blksize, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_blocks, sizeof(zval *), NULL);\n\n\t/* Store string indexes referencing the same zval*/\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[0], strlen(stat_sb_names[0])+1, (void *)&stat_dev, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[1], strlen(stat_sb_names[1])+1, (void *)&stat_ino, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[2], strlen(stat_sb_names[2])+1, (void *)&stat_mode, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[3], strlen(stat_sb_names[3])+1, (void *)&stat_nlink, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[4], strlen(stat_sb_names[4])+1, (void *)&stat_uid, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[5], strlen(stat_sb_names[5])+1, (void *)&stat_gid, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[6], strlen(stat_sb_names[6])+1, (void *)&stat_rdev, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[7], strlen(stat_sb_names[7])+1, (void *)&stat_size, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[8], strlen(stat_sb_names[8])+1, (void *)&stat_atime, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[9], strlen(stat_sb_names[9])+1, (void *)&stat_mtime, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[10], strlen(stat_sb_names[10])+1, (void *)&stat_ctime, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[11], strlen(stat_sb_names[11])+1, (void *)&stat_blksize, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[12], strlen(stat_sb_names[12])+1, (void *)&stat_blocks, sizeof(zval *), NULL);\n}\n/* }}} */\n\n/* {{{ proto bool copy(string source_file, string destination_file [, resource context])\n   Copy a file */\nPHP_FUNCTION(copy)\n{\n\tchar *source, *target;\n\tint source_len, target_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp|r\", &source, &source_len, &target, &target_len, &zcontext) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (php_check_open_basedir(source TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tif (php_copy_file_ctx(source, target, 0, context TSRMLS_CC) == SUCCESS) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ php_copy_file\n */\nPHPAPI int php_copy_file(char *src, char *dest TSRMLS_DC)\n{\n\treturn php_copy_file_ctx(src, dest, 0, NULL TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ php_copy_file_ex\n */\nPHPAPI int php_copy_file_ex(char *src, char *dest, int src_flg TSRMLS_DC)\n{\n\treturn php_copy_file_ctx(src, dest, 0, NULL TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ php_copy_file_ctx\n */\nPHPAPI int php_copy_file_ctx(char *src, char *dest, int src_flg, php_stream_context *ctx TSRMLS_DC)\n{\n\tphp_stream *srcstream = NULL, *deststream = NULL;\n\tint ret = FAILURE;\n\tphp_stream_statbuf src_s, dest_s;\n\n\tswitch (php_stream_stat_path_ex(src, 0, &src_s, ctx)) {\n\t\tcase -1:\n\t\t\t/* non-statable stream */\n\t\t\tgoto safe_to_copy;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault: /* failed to stat file, does not exist? */\n\t\t\treturn ret;\n\t}\n\tif (S_ISDIR(src_s.sb.st_mode)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The first argument to copy() function cannot be a directory\");\n\t\treturn FAILURE;\n\t}\n\n\tswitch (php_stream_stat_path_ex(dest, PHP_STREAM_URL_STAT_QUIET | PHP_STREAM_URL_STAT_NOCACHE, &dest_s, ctx)) {\n\t\tcase -1:\n\t\t\t/* non-statable stream */\n\t\t\tgoto safe_to_copy;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault: /* failed to stat file, does not exist? */\n\t\t\treturn ret;\n\t}\n\tif (S_ISDIR(dest_s.sb.st_mode)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The second argument to copy() function cannot be a directory\");\n\t\treturn FAILURE;\n\t}\n\tif (!src_s.sb.st_ino || !dest_s.sb.st_ino) {\n\t\tgoto no_stat;\n\t}\n\tif (src_s.sb.st_ino == dest_s.sb.st_ino && src_s.sb.st_dev == dest_s.sb.st_dev) {\n\t\treturn ret;\n\t} else {\n\t\tgoto safe_to_copy;\n\t}\nno_stat:\n\t{\n\t\tchar *sp, *dp;\n\t\tint res;\n\n\t\tif ((sp = expand_filepath(src, NULL TSRMLS_CC)) == NULL) {\n\t\t\treturn ret;\n\t\t}\n\t\tif ((dp = expand_filepath(dest, NULL TSRMLS_CC)) == NULL) {\n\t\t\tefree(sp);\n\t\t\tgoto safe_to_copy;\n\t\t}\n\n\t\tres =\n#ifndef PHP_WIN32\n\t\t\t!strcmp(sp, dp);\n#else\n\t\t\t!strcasecmp(sp, dp);\n#endif\n\n\t\tefree(sp);\n\t\tefree(dp);\n\t\tif (res) {\n\t\t\treturn ret;\n\t\t}\n\t}\nsafe_to_copy:\n\n\tsrcstream = php_stream_open_wrapper_ex(src, \"rb\", src_flg | REPORT_ERRORS, NULL, ctx);\n\n\tif (!srcstream) {\n\t\treturn ret;\n\t}\n\n\tdeststream = php_stream_open_wrapper_ex(dest, \"wb\", REPORT_ERRORS, NULL, ctx);\n\n\tif (srcstream && deststream) {\n\t\tret = php_stream_copy_to_stream_ex(srcstream, deststream, PHP_STREAM_COPY_ALL, NULL);\n\t}\n\tif (srcstream) {\n\t\tphp_stream_close(srcstream);\n\t}\n\tif (deststream) {\n\t\tphp_stream_close(deststream);\n\t}\n\treturn ret;\n}\n/* }}} */\n\n/* {{{ proto string fread(resource fp, int length)\n   Binary-safe file read */\nPHPAPI PHP_FUNCTION(fread)\n{\n\tzval *arg1;\n\tlong len;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (len <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\n",
        "suffix": "\tZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\n\n\t/* needed because recv/read/gzread doesnt put a null at the end*/\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}\n/* }}} */\n\nstatic const char *php_fgetcsv_lookup_trailing_spaces(const char *ptr, size_t len, const char delimiter TSRMLS_DC) /* {{{ */\n{\n\tint inc_len;\n\tunsigned char last_chars[2] = { 0, 0 };\n\n\twhile (len > 0) {\n\t\tinc_len = (*ptr == '\\0' ? 1: php_mblen(ptr, len));\n\t\tswitch (inc_len) {\n\t\t\tcase -2:\n\t\t\tcase -1:\n\t\t\t\tinc_len = 1;\n\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tgoto quit_loop;\n\t\t\tcase 1:\n\t\t\tdefault:\n\t\t\t\tlast_chars[0] = last_chars[1];\n\t\t\t\tlast_chars[1] = *ptr;\n\t\t\t\tbreak;\n\t\t}\n\t\tptr += inc_len;\n\t\tlen -= inc_len;\n\t}\nquit_loop:\n\tswitch (last_chars[1]) {\n\t\tcase '\\n':\n\t\t\tif (last_chars[0] == '\\r') {\n\t\t\t\treturn ptr - 2;\n\t\t\t}\n\t\t\t/* break is omitted intentionally */\n\t\tcase '\\r':\n\t\t\treturn ptr - 1;\n\t}\n\treturn ptr;\n}\n/* }}} */\n\n#define FPUTCSV_FLD_CHK(c) memchr(Z_STRVAL(field), c, Z_STRLEN(field))\n\n/* {{{ proto int fputcsv(resource fp, array fields [, string delimiter [, string enclosure [, string escape_char]]])\n   Format line as CSV and write to file pointer */\nPHP_FUNCTION(fputcsv)\n{\n\tchar delimiter = ',';\t /* allow this to be set as parameter */\n\tchar enclosure = '\"';\t /* allow this to be set as parameter */\n\tchar escape_char = '\\\\'; /* allow this to be set as parameter */\n\tphp_stream *stream;\n\tzval *fp = NULL, *fields = NULL;\n\tint ret;\n\tchar *delimiter_str = NULL, *enclosure_str = NULL, *escape_str = NULL;\n\tint delimiter_str_len = 0, enclosure_str_len = 0, escape_str_len = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra|sss\",\n\t\t\t&fp, &fields, &delimiter_str, &delimiter_str_len,\n\t\t\t&enclosure_str, &enclosure_str_len,\n\t\t\t&escape_str, &escape_str_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (delimiter_str != NULL) {\n\t\t/* Make sure that there is at least one character in string */\n\t\tif (delimiter_str_len < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n\t\t\tRETURN_FALSE;\n\t\t} else if (delimiter_str_len > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"delimiter must be a single character\");\n\t\t}\n\n\t\t/* use first character from string */\n\t\tdelimiter = *delimiter_str;\n\t}\n\n\tif (enclosure_str != NULL) {\n\t\tif (enclosure_str_len < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n\t\t\tRETURN_FALSE;\n\t\t} else if (enclosure_str_len > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"enclosure must be a single character\");\n\t\t}\n\t\t/* use first character from string */\n\t\tenclosure = *enclosure_str;\n\t}\n\n\tif (escape_str != NULL) {\n\t\tif (escape_str_len < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be a character\");\n\t\t\tRETURN_FALSE;\n\t\t} else if (escape_str_len > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"escape must be a single character\");\n\t\t}\n\t\t/* use first character from string */\n\t\tescape_char = *escape_str;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fp);\n\n\tret = php_fputcsv(stream, fields, delimiter, enclosure, escape_char TSRMLS_CC);\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ PHPAPI int php_fputcsv(php_stream *stream, zval *fields, char delimiter, char enclosure, char escape_char TSRMLS_DC) */\nPHPAPI int php_fputcsv(php_stream *stream, zval *fields, char delimiter, char enclosure, char escape_char TSRMLS_DC)\n{\n\tint count, i = 0, ret;\n\tzval **field_tmp = NULL, field;\n\tsmart_str csvline = {0};\n\tHashPosition pos;\n\n\tcount = zend_hash_num_elements(Z_ARRVAL_P(fields));\n\tzend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(fields), &pos);\n\twhile (zend_hash_get_current_data_ex(Z_ARRVAL_P(fields), (void **) &field_tmp, &pos) == SUCCESS) {\n\t\tfield = **field_tmp;\n\n\t\tif (Z_TYPE_PP(field_tmp) != IS_STRING) {\n\t\t\tzval_copy_ctor(&field);\n\t\t\tconvert_to_string(&field);\n\t\t}\n\n\t\t/* enclose a field that contains a delimiter, an enclosure character, or a newline */\n\t\tif (FPUTCSV_FLD_CHK(delimiter) ||\n\t\t\tFPUTCSV_FLD_CHK(enclosure) ||\n\t\t\tFPUTCSV_FLD_CHK(escape_char) ||\n\t\t\tFPUTCSV_FLD_CHK('\\n') ||\n\t\t\tFPUTCSV_FLD_CHK('\\r') ||\n\t\t\tFPUTCSV_FLD_CHK('\\t') ||\n\t\t\tFPUTCSV_FLD_CHK(' ')\n\t\t) {\n\t\t\tchar *ch = Z_STRVAL(field);\n\t\t\tchar *end = ch + Z_STRLEN(field);\n\t\t\tint escaped = 0;\n\n\t\t\tsmart_str_appendc(&csvline, enclosure);\n\t\t\twhile (ch < end) {\n\t\t\t\tif (*ch == escape_char) {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t} else if (!escaped && *ch == enclosure) {\n\t\t\t\t\tsmart_str_appendc(&csvline, enclosure);\n\t\t\t\t} else {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t}\n\t\t\t\tsmart_str_appendc(&csvline, *ch);\n\t\t\t\tch++;\n\t\t\t}\n\t\t\tsmart_str_appendc(&csvline, enclosure);\n\t\t} else {\n\t\t\tsmart_str_appendl(&csvline, Z_STRVAL(field), Z_STRLEN(field));\n\t\t}\n\n\t\tif (++i != count) {\n\t\t\tsmart_str_appendl(&csvline, &delimiter, 1);\n\t\t}\n\t\tzend_hash_move_forward_ex(Z_ARRVAL_P(fields), &pos);\n\n\t\tif (Z_TYPE_PP(field_tmp) != IS_STRING) {\n\t\t\tzval_dtor(&field);\n\t\t}\n\t}\n\n\tsmart_str_appendc(&csvline, '\\n');\n\tsmart_str_0(&csvline);\n\n\tret = php_stream_write(stream, csvline.c, csvline.len);\n\n\tsmart_str_free(&csvline);\n\n\treturn ret;\n}\n/* }}} */\n\n/* {{{ proto array fgetcsv(resource fp [,int length [, string delimiter [, string enclosure [, string escape]]]])\n   Get line from file pointer and parse for CSV fields */\nPHP_FUNCTION(fgetcsv)\n{\n\tchar delimiter = ',';\t/* allow this to be set as parameter */\n\tchar enclosure = '\"';\t/* allow this to be set as parameter */\n\tchar escape = '\\\\';\n\n\t/* first section exactly as php_fgetss */\n\n\tlong len = 0;\n\tsize_t buf_len;\n\tchar *buf;\n\tphp_stream *stream;\n\n\t{\n\t\tzval *fd, **len_zv = NULL;\n\t\tchar *delimiter_str = NULL;\n\t\tint delimiter_str_len = 0;\n\t\tchar *enclosure_str = NULL;\n\t\tint enclosure_str_len = 0;\n\t\tchar *escape_str = NULL;\n\t\tint escape_str_len = 0;\n\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|Zsss\",\n\t\t\t&fd, &len_zv, &delimiter_str, &delimiter_str_len,\n\t\t\t&enclosure_str, &enclosure_str_len,\n\t\t\t&escape_str, &escape_str_len) == FAILURE\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (delimiter_str != NULL) {\n\t\t\t/* Make sure that there is at least one character in string */\n\t\t\tif (delimiter_str_len < 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (delimiter_str_len > 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"delimiter must be a single character\");\n\t\t\t}\n\n\t\t\t/* use first character from string */\n\t\t\tdelimiter = delimiter_str[0];\n\t\t}\n\n\t\tif (enclosure_str != NULL) {\n\t\t\tif (enclosure_str_len < 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (enclosure_str_len > 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"enclosure must be a single character\");\n\t\t\t}\n\n\t\t\t/* use first character from string */\n\t\t\tenclosure = enclosure_str[0];\n\t\t}\n\n\t\tif (escape_str != NULL) {\n\t\t\tif (escape_str_len < 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (escape_str_len > 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"escape must be a single character\");\n\t\t\t}\n\n\t\t\tescape = escape_str[0];\n\t\t}\n\n\t\tif (len_zv != NULL && Z_TYPE_PP(len_zv) != IS_NULL) {\n\t\t\tconvert_to_long_ex(len_zv);\n\t\t\tlen = Z_LVAL_PP(len_zv);\n\t\t\tif (len < 0) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter may not be negative\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (len == 0) {\n\t\t\t\tlen = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tlen = -1;\n\t\t}\n\n\t\tPHP_STREAM_TO_ZVAL(stream, &fd);\n\t}\n\n\tif (len < 0) {\n\t\tif ((buf = php_stream_get_line(stream, NULL, 0, &buf_len)) == NULL) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tbuf = emalloc(len + 1);\n\t\tif (php_stream_get_line(stream, buf, len + 1, &buf_len) == NULL) {\n\t\t\tefree(buf);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tphp_fgetcsv(stream, delimiter, enclosure, escape, buf_len, buf, return_value TSRMLS_CC);\n}\n/* }}} */\n\nPHPAPI void php_fgetcsv(php_stream *stream, char delimiter, char enclosure, char escape_char, size_t buf_len, char *buf, zval *return_value TSRMLS_DC) /* {{{ */\n{\n\tchar *temp, *tptr, *bptr, *line_end, *limit;\n\tsize_t temp_len, line_end_len;\n\tint inc_len;\n\tzend_bool first_field = 1;\n\n\t/* initialize internal state */\n\tphp_ignore_value(php_mblen(NULL, 0));\n\n\t/* Now into new section that parses buf for delimiter/enclosure fields */\n\n\t/* Strip trailing space from buf, saving end of line in case required for enclosure field */\n\n\tbptr = buf;\n\ttptr = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len, delimiter TSRMLS_CC);\n\tline_end_len = buf_len - (size_t)(tptr - buf);\n\tline_end = limit = tptr;\n\n\t/* reserve workspace for building each individual field */\n\ttemp_len = buf_len;\n\ttemp = emalloc(temp_len + line_end_len + 1);\n\n\t/* Initialize return array */\n\tarray_init(return_value);\n\n\t/* Main loop to read CSV fields */\n\t/* NB this routine will return a single null entry for a blank line */\n\n\tdo {\n\t\tchar *comp_end, *hunk_begin;\n\n\t\ttptr = temp;\n\n\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\tif (inc_len == 1) {\n\t\t\tchar *tmp = bptr;\n\t\t\twhile ((*tmp != delimiter) && isspace((int)*(unsigned char *)tmp)) {\n\t\t\t\ttmp++;\n  \t\t\t}\n\t\t\tif (*tmp == enclosure) {\n\t\t\t\tbptr = tmp;\n\t\t\t}\n  \t\t}\n\n\t\tif (first_field && bptr == line_end) {\n\t\t\tadd_next_index_null(return_value);\n\t\t\tbreak;\n\t\t}\n\t\tfirst_field = 0;\n\t\t/* 2. Read field, leaving bptr pointing at start of next field */\n\t\tif (inc_len != 0 && *bptr == enclosure) {\n\t\t\tint state = 0;\n\n\t\t\tbptr++;\t/* move on to first character in field */\n\t\t\thunk_begin = bptr;\n\n\t\t\t/* 2A. handle enclosure delimited field */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (inc_len) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\t/* break is omitted intentionally */\n\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tchar *new_buf;\n\t\t\t\t\t\t\t\tsize_t new_len;\n\t\t\t\t\t\t\t\tchar *new_temp;\n\n\t\t\t\t\t\t\t\tif (hunk_begin != line_end) {\n\t\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t/* add the embedded line end to the field */\n\t\t\t\t\t\t\t\tmemcpy(tptr, line_end, line_end_len);\n\t\t\t\t\t\t\t\ttptr += line_end_len;\n\n\t\t\t\t\t\t\t\tif (stream == NULL) {\n\t\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\t\t} else if ((new_buf = php_stream_get_line(stream, NULL, 0, &new_len)) == NULL) {\n\t\t\t\t\t\t\t\t\t/* we've got an unterminated enclosure,\n\t\t\t\t\t\t\t\t\t * assign all the data from the start of\n\t\t\t\t\t\t\t\t\t * the enclosure to end of data to the\n\t\t\t\t\t\t\t\t\t * last element */\n\t\t\t\t\t\t\t\t\tif ((size_t)temp_len > (size_t)(limit - buf)) {\n\t\t\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\t\t\t\t\tRETVAL_FALSE;\n\t\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttemp_len += new_len;\n\t\t\t\t\t\t\t\tnew_temp = erealloc(temp, temp_len);\n\t\t\t\t\t\t\t\ttptr = new_temp + (size_t)(tptr - temp);\n\t\t\t\t\t\t\t\ttemp = new_temp;\n\n\t\t\t\t\t\t\t\tefree(buf);\n\t\t\t\t\t\t\t\tbuf_len = new_len;\n\t\t\t\t\t\t\t\tbptr = buf = new_buf;\n\t\t\t\t\t\t\t\thunk_begin = buf;\n\n\t\t\t\t\t\t\t\tline_end = limit = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len, delimiter TSRMLS_CC);\n\t\t\t\t\t\t\t\tline_end_len = buf_len - (size_t)(limit - buf);\n\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t} break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase -2:\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\t\t\t/* break is omitted intentionally */\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t/* we need to determine if the enclosure is\n\t\t\t\t\t\t * 'real' or is it escaped */\n\t\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\t\tcase 1: /* escaped */\n\t\t\t\t\t\t\t\tbptr++;\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2: /* embedded enclosure ? let's check it */\n\t\t\t\t\t\t\t\tif (*bptr != enclosure) {\n\t\t\t\t\t\t\t\t\t/* real enclosure */\n\t\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\tbptr++;\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (*bptr == enclosure) {\n\t\t\t\t\t\t\t\t\tstate = 2;\n\t\t\t\t\t\t\t\t} else if (*bptr == escape_char) {\n\t\t\t\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbptr++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t/* real enclosure */\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tbptr += inc_len;\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbptr += inc_len;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\t\t}\n\n\t\tquit_loop_2:\n\t\t\t/* look up for a delimiter */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (inc_len) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tgoto quit_loop_3;\n\n\t\t\t\t\tcase -2:\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tinc_len = 1;\n\t\t\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\t\t\t/* break is omitted intentionally */\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (*bptr == delimiter) {\n\t\t\t\t\t\t\tgoto quit_loop_3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbptr += inc_len;\n\t\t\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\t\t}\n\n\t\tquit_loop_3:\n\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\ttptr += (bptr - hunk_begin);\n\t\t\tbptr += inc_len;\n\t\t\tcomp_end = tptr;\n\t\t} else {\n\t\t\t/* 2B. Handle non-enclosure field */\n\n\t\t\thunk_begin = bptr;\n\n\t\t\tfor (;;) {\n\t\t\t\tswitch (inc_len) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tgoto quit_loop_4;\n\t\t\t\t\tcase -2:\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tinc_len = 1;\n\t\t\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\t\t\t/* break is omitted intentionally */\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (*bptr == delimiter) {\n\t\t\t\t\t\t\tgoto quit_loop_4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbptr += inc_len;\n\t\t\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\t\t}\n\t\tquit_loop_4:\n\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\ttptr += (bptr - hunk_begin);\n\n\t\t\tcomp_end = (char *)php_fgetcsv_lookup_trailing_spaces(temp, tptr - temp, delimiter TSRMLS_CC);\n\t\t\tif (*bptr == delimiter) {\n\t\t\t\tbptr++;\n\t\t\t}\n\t\t}\n\n\t\t/* 3. Now pass our field back to php */\n\t\t*comp_end = '\\0';\n\t\tadd_next_index_stringl(return_value, temp, comp_end - temp, 1);\n\t} while (inc_len > 0);\n\nout:\n\tefree(temp);\n\tif (stream) {\n\t\tefree(buf);\n\t}\n}\n/* }}} */\n\n#if (!defined(__BEOS__) && !defined(NETWARE) && HAVE_REALPATH) || defined(ZTS)\n/* {{{ proto string realpath(string path)\n   Return the resolved path */\nPHP_FUNCTION(realpath)\n{\n\tchar *filename;\n\tint filename_len;\n\tchar resolved_path_buff[MAXPATHLEN];\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p\", &filename, &filename_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (VCWD_REALPATH(filename, resolved_path_buff)) {\n\t\tif (php_check_open_basedir(resolved_path_buff TSRMLS_CC)) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\n#ifdef ZTS\n\t\tif (VCWD_ACCESS(resolved_path_buff, F_OK)) {\n\t\t\tRETURN_FALSE;\n\t\t}\n#endif\n\t\tRETURN_STRING(resolved_path_buff, 1);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n#endif\n\n/* See http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2 */\n#define PHP_META_HTML401_CHARS \"-_.:\"\n\n/* {{{ php_next_meta_token\n   Tokenizes an HTML file for get_meta_tags */\nphp_meta_tags_token php_next_meta_token(php_meta_tags_data *md TSRMLS_DC)\n{\n\tint ch = 0, compliment;\n\tchar buff[META_DEF_BUFSIZE + 1];\n\n\tmemset((void *)buff, 0, META_DEF_BUFSIZE + 1);\n\n\twhile (md->ulc || (!php_stream_eof(md->stream) && (ch = php_stream_getc(md->stream)))) {\n\t\tif (php_stream_eof(md->stream)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (md->ulc) {\n\t\t\tch = md->lc;\n\t\t\tmd->ulc = 0;\n\t\t}\n\n\t\tswitch (ch) {\n\t\t\tcase '<':\n\t\t\t\treturn TOK_OPENTAG;\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\treturn TOK_CLOSETAG;\n\t\t\t\tbreak;\n\n\t\t\tcase '=':\n\t\t\t\treturn TOK_EQUAL;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\treturn TOK_SLASH;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tcompliment = ch;\n\t\t\t\tmd->token_len = 0;\n\t\t\t\twhile (!php_stream_eof(md->stream) && (ch = php_stream_getc(md->stream)) && ch != compliment && ch != '<' && ch != '>') {\n\t\t\t\t\tbuff[(md->token_len)++] = ch;\n\n\t\t\t\t\tif (md->token_len == META_DEF_BUFSIZE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ch == '<' || ch == '>') {\n\t\t\t\t\t/* Was just an apostrohpe */\n\t\t\t\t\tmd->ulc = 1;\n\t\t\t\t\tmd->lc = ch;\n\t\t\t\t}\n\n\t\t\t\t/* We don't need to alloc unless we are in a meta tag */\n\t\t\t\tif (md->in_meta) {\n\t\t\t\t\tmd->token_data = (char *) emalloc(md->token_len + 1);\n\t\t\t\t\tmemcpy(md->token_data, buff, md->token_len+1);\n\t\t\t\t}\n\n\t\t\t\treturn TOK_STRING;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\n':\n\t\t\tcase '\\r':\n\t\t\tcase '\\t':\n\t\t\t\tbreak;\n\n\t\t\tcase ' ':\n\t\t\t\treturn TOK_SPACE;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (isalnum(ch)) {\n\t\t\t\t\tmd->token_len = 0;\n\t\t\t\t\tbuff[(md->token_len)++] = ch;\n\t\t\t\t\twhile (!php_stream_eof(md->stream) && (ch = php_stream_getc(md->stream)) && (isalnum(ch) || strchr(PHP_META_HTML401_CHARS, ch))) {\n\t\t\t\t\t\tbuff[(md->token_len)++] = ch;\n\n\t\t\t\t\t\tif (md->token_len == META_DEF_BUFSIZE) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* This is ugly, but we have to replace ungetc */\n\t\t\t\t\tif (!isalpha(ch) && ch != '-') {\n\t\t\t\t\t\tmd->ulc = 1;\n\t\t\t\t\t\tmd->lc = ch;\n\t\t\t\t\t}\n\n\t\t\t\t\tmd->token_data = (char *) emalloc(md->token_len + 1);\n\t\t\t\t\tmemcpy(md->token_data, buff, md->token_len+1);\n\n\t\t\t\t\treturn TOK_ID;\n\t\t\t\t} else {\n\t\t\t\t\treturn TOK_OTHER;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn TOK_EOF;\n}\n/* }}} */\n\n#ifdef HAVE_FNMATCH\n/* {{{ proto bool fnmatch(string pattern, string filename [, int flags])\n   Match filename against pattern */\nPHP_FUNCTION(fnmatch)\n{\n\tchar *pattern, *filename;\n\tint pattern_len, filename_len;\n\tlong flags = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp|l\", &pattern, &pattern_len, &filename, &filename_len, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (filename_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Filename exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\tRETURN_FALSE;\n\t}\n\tif (pattern_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Pattern exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL( ! fnmatch( pattern, filename, flags ));\n}\n/* }}} */\n#endif\n\n/* {{{ proto string sys_get_temp_dir()\n   Returns directory path used for temporary files */\nPHP_FUNCTION(sys_get_temp_dir)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_STRING((char *)php_get_temporary_directory(TSRMLS_C), 1);\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */\n",
        "start": 332,
        "end": 2482,
        "buggy": "PHP_FUNCTION(flock)\n{\n\tzval *arg1, *arg3 = NULL;\n\tint act;\n\tphp_stream *stream;\n\tlong operation = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl|z\", &arg1, &operation, &arg3) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tact = operation & 3;\n\tif (act < 1 || act > 3) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Illegal operation argument\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (arg3 && PZVAL_IS_REF(arg3)) {\n\t\tconvert_to_long_ex(&arg3);\n\t\tZ_LVAL_P(arg3) = 0;\n\t}\n\n\t/* flock_values contains all possible actions if (operation & 4) we won't block on the lock */\n\tact = flock_values[act - 1] | (operation & PHP_LOCK_NB ? LOCK_NB : 0);\n\tif (php_stream_lock(stream, act)) {\n\t\tif (operation && errno == EWOULDBLOCK && arg3 && PZVAL_IS_REF(arg3)) {\n\t\t\tZ_LVAL_P(arg3) = 1;\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n#define PHP_META_UNSAFE \".\\\\+*?[^]$() \"\n\n/* {{{ proto array get_meta_tags(string filename [, bool use_include_path])\n   Extracts all meta tag content attributes from a file and returns an array */\nPHP_FUNCTION(get_meta_tags)\n{\n\tchar *filename;\n\tint filename_len;\n\tzend_bool use_include_path = 0;\n\tint in_tag = 0, done = 0;\n\tint looking_for_val = 0, have_name = 0, have_content = 0;\n\tint saw_name = 0, saw_content = 0;\n\tchar *name = NULL, *value = NULL, *temp = NULL;\n\tphp_meta_tags_token tok, tok_last;\n\tphp_meta_tags_data md;\n\n\t/* Initiailize our structure */\n\tmemset(&md, 0, sizeof(md));\n\n\t/* Parse arguments */\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|b\", &filename, &filename_len, &use_include_path) == FAILURE) {\n\t\treturn;\n\t}\n\n\tmd.stream = php_stream_open_wrapper(filename, \"rb\",\n\t\t\t(use_include_path ? USE_PATH : 0) | REPORT_ERRORS,\n\t\t\tNULL);\n\tif (!md.stream)\t{\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\ttok_last = TOK_EOF;\n\n\twhile (!done && (tok = php_next_meta_token(&md TSRMLS_CC)) != TOK_EOF) {\n\t\tif (tok == TOK_ID) {\n\t\t\tif (tok_last == TOK_OPENTAG) {\n\t\t\t\tmd.in_meta = !strcasecmp(\"meta\", md.token_data);\n\t\t\t} else if (tok_last == TOK_SLASH && in_tag) {\n\t\t\t\tif (strcasecmp(\"head\", md.token_data) == 0) {\n\t\t\t\t\t/* We are done here! */\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t} else if (tok_last == TOK_EQUAL && looking_for_val) {\n\t\t\t\tif (saw_name) {\n\t\t\t\t\tSTR_FREE(name);\n\t\t\t\t\t/* Get the NAME attr (Single word attr, non-quoted) */\n\t\t\t\t\ttemp = name = estrndup(md.token_data, md.token_len);\n\n\t\t\t\t\twhile (temp && *temp) {\n\t\t\t\t\t\tif (strchr(PHP_META_UNSAFE, *temp)) {\n\t\t\t\t\t\t\t*temp = '_';\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp++;\n\t\t\t\t\t}\n\n\t\t\t\t\thave_name = 1;\n\t\t\t\t} else if (saw_content) {\n\t\t\t\t\tSTR_FREE(value);\n\t\t\t\t\tvalue = estrndup(md.token_data, md.token_len);\n\t\t\t\t\thave_content = 1;\n\t\t\t\t}\n\n\t\t\t\tlooking_for_val = 0;\n\t\t\t} else {\n\t\t\t\tif (md.in_meta) {\n\t\t\t\t\tif (strcasecmp(\"name\", md.token_data) == 0) {\n\t\t\t\t\t\tsaw_name = 1;\n\t\t\t\t\t\tsaw_content = 0;\n\t\t\t\t\t\tlooking_for_val = 1;\n\t\t\t\t\t} else if (strcasecmp(\"content\", md.token_data) == 0) {\n\t\t\t\t\t\tsaw_name = 0;\n\t\t\t\t\t\tsaw_content = 1;\n\t\t\t\t\t\tlooking_for_val = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tok == TOK_STRING && tok_last == TOK_EQUAL && looking_for_val) {\n\t\t\tif (saw_name) {\n\t\t\t\tSTR_FREE(name);\n\t\t\t\t/* Get the NAME attr (Quoted single/double) */\n\t\t\t\ttemp = name = estrndup(md.token_data, md.token_len);\n\n\t\t\t\twhile (temp && *temp) {\n\t\t\t\t\tif (strchr(PHP_META_UNSAFE, *temp)) {\n\t\t\t\t\t\t*temp = '_';\n\t\t\t\t\t}\n\t\t\t\t\ttemp++;\n\t\t\t\t}\n\n\t\t\t\thave_name = 1;\n\t\t\t} else if (saw_content) {\n\t\t\t\tSTR_FREE(value);\n\t\t\t\tvalue = estrndup(md.token_data, md.token_len);\n\t\t\t\thave_content = 1;\n\t\t\t}\n\n\t\t\tlooking_for_val = 0;\n\t\t} else if (tok == TOK_OPENTAG) {\n\t\t\tif (looking_for_val) {\n\t\t\t\tlooking_for_val = 0;\n\t\t\t\thave_name = saw_name = 0;\n\t\t\t\thave_content = saw_content = 0;\n\t\t\t}\n\t\t\tin_tag = 1;\n\t\t} else if (tok == TOK_CLOSETAG) {\n\t\t\tif (have_name) {\n\t\t\t\t/* For BC */\n\t\t\t\tphp_strtolower(name, strlen(name));\n\t\t\t\tif (have_content) {\n\t\t\t\t\tadd_assoc_string(return_value, name, value, 1);\n\t\t\t\t} else {\n\t\t\t\t\tadd_assoc_string(return_value, name, \"\", 1);\n\t\t\t\t}\n\n\t\t\t\tefree(name);\n\t\t\t\tSTR_FREE(value);\n\t\t\t} else if (have_content) {\n\t\t\t\tefree(value);\n\t\t\t}\n\n\t\t\tname = value = NULL;\n\n\t\t\t/* Reset all of our flags */\n\t\t\tin_tag = looking_for_val = 0;\n\t\t\thave_name = saw_name = 0;\n\t\t\thave_content = saw_content = 0;\n\t\t\tmd.in_meta = 0;\n\t\t}\n\n\t\ttok_last = tok;\n\n\t\tif (md.token_data)\n\t\t\tefree(md.token_data);\n\n\t\tmd.token_data = NULL;\n\t}\n\n\tSTR_FREE(value);\n\tSTR_FREE(name);\n\tphp_stream_close(md.stream);\n}\n/* }}} */\n\n/* {{{ proto string file_get_contents(string filename [, bool use_include_path [, resource context [, long offset [, long maxlen]]]])\n   Read the entire file into a string */\nPHP_FUNCTION(file_get_contents)\n{\n\tchar *filename;\n\tint filename_len;\n\tchar *contents;\n\tzend_bool use_include_path = 0;\n\tphp_stream *stream;\n\tlong len;\n\tlong offset = -1;\n\tlong maxlen = PHP_STREAM_COPY_ALL;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\n\t/* Parse arguments */\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|br!ll\", &filename, &filename_len, &use_include_path, &zcontext, &offset, &maxlen) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZEND_NUM_ARGS() == 5 && maxlen < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"length must be greater than or equal to zero\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\",\n\t\t\t\t(use_include_path ? USE_PATH : 0) | REPORT_ERRORS,\n\t\t\t\tNULL, context);\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (offset > 0 && php_stream_seek(stream, offset, SEEK_SET) < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to seek to position %ld in the stream\", offset);\n\t\tphp_stream_close(stream);\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((len = php_stream_copy_to_mem(stream, &contents, maxlen, 0)) > 0) {\n\t\tif (len > INT_MAX) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"content truncated from %ld to %d bytes\", len, INT_MAX);\n\t\t\tlen = INT_MAX;\n\t\t}\n\t\tRETVAL_STRINGL(contents, len, 0);\n\t} else if (len == 0) {\n\t\tRETVAL_EMPTY_STRING();\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n\n\tphp_stream_close(stream);\n}\n/* }}} */\n\n/* {{{ proto int file_put_contents(string file, mixed data [, int flags [, resource context]])\n   Write/Create a file with contents data and return the number of bytes written */\nPHP_FUNCTION(file_put_contents)\n{\n\tphp_stream *stream;\n\tchar *filename;\n\tint filename_len;\n\tzval *data;\n\tlong numbytes = 0;\n\tlong flags = 0;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\tphp_stream *srcstream = NULL;\n\tchar mode[3] = \"wb\";\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pz/|lr!\", &filename, &filename_len, &data, &flags, &zcontext) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (Z_TYPE_P(data) == IS_RESOURCE) {\n\t\tphp_stream_from_zval(srcstream, &data);\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, flags & PHP_FILE_NO_DEFAULT_CONTEXT);\n\n\tif (flags & PHP_FILE_APPEND) {\n\t\tmode[0] = 'a';\n\t} else if (flags & LOCK_EX) {\n\t\t/* check to make sure we are dealing with a regular file */\n\t\tif (php_memnstr(filename, \"://\", sizeof(\"://\") - 1, filename + filename_len)) {\n\t\t\tif (strncasecmp(filename, \"file://\", sizeof(\"file://\") - 1)) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Exclusive locks may only be set for regular files\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t\tmode[0] = 'c';\n\t}\n\tmode[2] = '\\0';\n\n\tstream = php_stream_open_wrapper_ex(filename, mode, ((flags & PHP_FILE_USE_INCLUDE_PATH) ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\tif (stream == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (flags & LOCK_EX && (!php_stream_supports_lock(stream) || php_stream_lock(stream, LOCK_EX))) {\n\t\tphp_stream_close(stream);\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Exclusive locks are not supported for this stream\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (mode[0] == 'c') {\n\t\tphp_stream_truncate_set_size(stream, 0);\n\t}\n\n\tswitch (Z_TYPE_P(data)) {\n\t\tcase IS_RESOURCE: {\n\t\t\tsize_t len;\n\t\t\tif (php_stream_copy_to_stream_ex(srcstream, stream, PHP_STREAM_COPY_ALL, &len) != SUCCESS) {\n\t\t\t\tnumbytes = -1;\n\t\t\t} else {\n\t\t\t\tif (len > LONG_MAX) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"content truncated from %lu to %ld bytes\", (unsigned long) len, LONG_MAX);\n\t\t\t\t\tlen = LONG_MAX;\n\t\t\t\t}\n\t\t\t\tnumbytes = len;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase IS_NULL:\n\t\tcase IS_LONG:\n\t\tcase IS_DOUBLE:\n\t\tcase IS_BOOL:\n\t\tcase IS_CONSTANT:\n\t\t\tconvert_to_string_ex(&data);\n\n\t\tcase IS_STRING:\n\t\t\tif (Z_STRLEN_P(data)) {\n\t\t\t\tnumbytes = php_stream_write(stream, Z_STRVAL_P(data), Z_STRLEN_P(data));\n\t\t\t\tif (numbytes != Z_STRLEN_P(data)) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Only %ld of %d bytes written, possibly out of free disk space\", numbytes, Z_STRLEN_P(data));\n\t\t\t\t\tnumbytes = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IS_ARRAY:\n\t\t\tif (zend_hash_num_elements(Z_ARRVAL_P(data))) {\n\t\t\t\tint bytes_written;\n\t\t\t\tzval **tmp;\n\t\t\t\tHashPosition pos;\n\n\t\t\t\tzend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(data), &pos);\n\t\t\t\twhile (zend_hash_get_current_data_ex(Z_ARRVAL_P(data), (void **) &tmp, &pos) == SUCCESS) {\n\t\t\t\t\tif (Z_TYPE_PP(tmp) != IS_STRING) {\n\t\t\t\t\t\tSEPARATE_ZVAL(tmp);\n\t\t\t\t\t\tconvert_to_string(*tmp);\n\t\t\t\t\t}\n\t\t\t\t\tif (Z_STRLEN_PP(tmp)) {\n\t\t\t\t\t\tnumbytes += Z_STRLEN_PP(tmp);\n\t\t\t\t\t\tbytes_written = php_stream_write(stream, Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp));\n\t\t\t\t\t\tif (bytes_written < 0 || bytes_written != Z_STRLEN_PP(tmp)) {\n\t\t\t\t\t\t\tif (bytes_written < 0) {\n\t\t\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to write %d bytes to %s\", Z_STRLEN_PP(tmp), filename);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Only %d of %d bytes written, possibly out of free disk space\", bytes_written, Z_STRLEN_PP(tmp));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnumbytes = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_move_forward_ex(Z_ARRVAL_P(data), &pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IS_OBJECT:\n\t\t\tif (Z_OBJ_HT_P(data) != NULL) {\n\t\t\t\tzval out;\n\n\t\t\t\tif (zend_std_cast_object_tostring(data, &out, IS_STRING TSRMLS_CC) == SUCCESS) {\n\t\t\t\t\tnumbytes = php_stream_write(stream, Z_STRVAL(out), Z_STRLEN(out));\n\t\t\t\t\tif (numbytes != Z_STRLEN(out)) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Only %ld of %d bytes written, possibly out of free disk space\", numbytes, Z_STRLEN(out));\n\t\t\t\t\t\tnumbytes = -1;\n\t\t\t\t\t}\n\t\t\t\t\tzval_dtor(&out);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tnumbytes = -1;\n\t\t\tbreak;\n\t}\n\tphp_stream_close(stream);\n\n\tif (numbytes < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_LONG(numbytes);\n}\n/* }}} */\n\n#define PHP_FILE_BUF_SIZE\t80\n\n/* {{{ proto array file(string filename [, int flags[, resource context]])\n   Read entire file into an array */\nPHP_FUNCTION(file)\n{\n\tchar *filename;\n\tint filename_len;\n\tchar *target_buf=NULL, *p, *s, *e;\n\tregister int i = 0;\n\tint target_len;\n\tchar eol_marker = '\\n';\n\tlong flags = 0;\n\tzend_bool use_include_path;\n\tzend_bool include_new_line;\n\tzend_bool skip_blank_lines;\n\tphp_stream *stream;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\n\t/* Parse arguments */\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|lr!\", &filename, &filename_len, &flags, &zcontext) == FAILURE) {\n\t\treturn;\n\t}\n\tif (flags < 0 || flags > (PHP_FILE_USE_INCLUDE_PATH | PHP_FILE_IGNORE_NEW_LINES | PHP_FILE_SKIP_EMPTY_LINES | PHP_FILE_NO_DEFAULT_CONTEXT)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"'%ld' flag is not supported\", flags);\n\t\tRETURN_FALSE;\n\t}\n\n\tuse_include_path = flags & PHP_FILE_USE_INCLUDE_PATH;\n\tinclude_new_line = !(flags & PHP_FILE_IGNORE_NEW_LINES);\n\tskip_blank_lines = flags & PHP_FILE_SKIP_EMPTY_LINES;\n\n\tcontext = php_stream_context_from_zval(zcontext, flags & PHP_FILE_NO_DEFAULT_CONTEXT);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\", (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Initialize return array */\n\tarray_init(return_value);\n\n\tif ((target_len = php_stream_copy_to_mem(stream, &target_buf, PHP_STREAM_COPY_ALL, 0))) {\n\t\ts = target_buf;\n\t\te = target_buf + target_len;\n\n\t\tif (!(p = php_stream_locate_eol(stream, target_buf, target_len TSRMLS_CC))) {\n\t\t\tp = e;\n\t\t\tgoto parse_eol;\n\t\t}\n\n\t\tif (stream->flags & PHP_STREAM_FLAG_EOL_MAC) {\n\t\t\teol_marker = '\\r';\n\t\t}\n\n\t\t/* for performance reasons the code is duplicated, so that the if (include_new_line)\n\t\t * will not need to be done for every single line in the file. */\n\t\tif (include_new_line) {\n\t\t\tdo {\n\t\t\t\tp++;\nparse_eol:\n\t\t\t\tadd_index_stringl(return_value, i++, estrndup(s, p-s), p-s, 0);\n\t\t\t\ts = p;\n\t\t\t} while ((p = memchr(p, eol_marker, (e-p))));\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tint windows_eol = 0;\n\t\t\t\tif (p != target_buf && eol_marker == '\\n' && *(p - 1) == '\\r') {\n\t\t\t\t\twindows_eol++;\n\t\t\t\t}\n\t\t\t\tif (skip_blank_lines && !(p-s-windows_eol)) {\n\t\t\t\t\ts = ++p;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tadd_index_stringl(return_value, i++, estrndup(s, p-s-windows_eol), p-s-windows_eol, 0);\n\t\t\t\ts = ++p;\n\t\t\t} while ((p = memchr(p, eol_marker, (e-p))));\n\t\t}\n\n\t\t/* handle any left overs of files without new lines */\n\t\tif (s != e) {\n\t\t\tp = e;\n\t\t\tgoto parse_eol;\n\t\t}\n\t}\n\n\tif (target_buf) {\n\t\tefree(target_buf);\n\t}\n\tphp_stream_close(stream);\n}\n/* }}} */\n\n/* {{{ proto string tempnam(string dir, string prefix)\n   Create a unique filename in a directory */\nPHP_FUNCTION(tempnam)\n{\n\tchar *dir, *prefix;\n\tint dir_len, prefix_len;\n\tsize_t p_len;\n\tchar *opened_path;\n\tchar *p;\n\tint fd;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp\", &dir, &dir_len, &prefix, &prefix_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (php_check_open_basedir(dir TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_basename(prefix, prefix_len, NULL, 0, &p, &p_len TSRMLS_CC);\n\tif (p_len > 64) {\n\t\tp[63] = '\\0';\n\t}\n\n\tRETVAL_FALSE;\n\n\tif ((fd = php_open_temporary_fd_ex(dir, p, &opened_path, 1 TSRMLS_CC)) >= 0) {\n\t\tclose(fd);\n\t\tRETVAL_STRING(opened_path, 0);\n\t}\n\tefree(p);\n}\n/* }}} */\n\n/* {{{ proto resource tmpfile(void)\n   Create a temporary file that will be deleted automatically after use */\nPHP_NAMED_FUNCTION(php_if_tmpfile)\n{\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tstream = php_stream_fopen_tmpfile();\n\n\tif (stream) {\n\t\tphp_stream_to_zval(stream, return_value);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource fopen(string filename, string mode [, bool use_include_path [, resource context]])\n   Open a file or a URL and return a file pointer */\nPHP_NAMED_FUNCTION(php_if_fopen)\n{\n\tchar *filename, *mode;\n\tint filename_len, mode_len;\n\tzend_bool use_include_path = 0;\n\tzval *zcontext = NULL;\n\tphp_stream *stream;\n\tphp_stream_context *context = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ps|br\", &filename, &filename_len, &mode, &mode_len, &use_include_path, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, mode, (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\n\tif (stream == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_stream_to_zval(stream, return_value);\n}\n/* }}} */\n\n/* {{{ proto bool fclose(resource fp)\n   Close an open file pointer */\nPHPAPI PHP_FUNCTION(fclose)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif ((stream->flags & PHP_STREAM_FLAG_NO_FCLOSE) != 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%d is not a valid stream resource\", stream->rsrc_id);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!stream->is_persistent) {\n\t\tphp_stream_close(stream);\n\t} else {\n\t\tphp_stream_pclose(stream);\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto resource popen(string command, string mode)\n   Execute a command and open either a read or a write pipe to it */\nPHP_FUNCTION(popen)\n{\n\tchar *command, *mode;\n\tint command_len, mode_len;\n\tFILE *fp;\n\tphp_stream *stream;\n\tchar *posix_mode;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ps\", &command, &command_len, &mode, &mode_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tposix_mode = estrndup(mode, mode_len);\n#ifndef PHP_WIN32\n\t{\n\t\tchar *z = memchr(posix_mode, 'b', mode_len);\n\t\tif (z) {\n\t\t\tmemmove(z, z + 1, mode_len - (z - posix_mode));\n\t\t}\n\t}\n#endif\n\n\tfp = VCWD_POPEN(command, posix_mode);\n\tif (!fp) {\n\t\tphp_error_docref2(NULL TSRMLS_CC, command, posix_mode, E_WARNING, \"%s\", strerror(errno));\n\t\tefree(posix_mode);\n\t\tRETURN_FALSE;\n\t}\n\n\tstream = php_stream_fopen_from_pipe(fp, mode);\n\n\tif (stream == NULL)\t{\n\t\tphp_error_docref2(NULL TSRMLS_CC, command, mode, E_WARNING, \"%s\", strerror(errno));\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tphp_stream_to_zval(stream, return_value);\n\t}\n\n\tefree(posix_mode);\n}\n/* }}} */\n\n/* {{{ proto int pclose(resource fp)\n   Close a file pointer opened by popen() */\nPHP_FUNCTION(pclose)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tFG(pclose_wait) = 1;\n\tzend_list_delete(stream->rsrc_id);\n\tFG(pclose_wait) = 0;\n\tRETURN_LONG(FG(pclose_ret));\n}\n/* }}} */\n\n/* {{{ proto bool feof(resource fp)\n   Test for end-of-file on a file pointer */\nPHPAPI PHP_FUNCTION(feof)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (php_stream_eof(stream)) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string fgets(resource fp[, int length])\n   Get a line from file pointer */\nPHPAPI PHP_FUNCTION(fgets)\n{\n\tzval *arg1;\n\tlong len = 1024;\n\tchar *buf = NULL;\n\tint argc = ZEND_NUM_ARGS();\n\tsize_t line_len = 0;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|l\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (argc == 1) {\n\t\t/* ask streams to give us a buffer of an appropriate size */\n\t\tbuf = php_stream_get_line(stream, NULL, 0, &line_len);\n\t\tif (buf == NULL) {\n\t\t\tgoto exit_failed;\n\t\t}\n\t} else if (argc > 1) {\n\t\tif (len <= 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tbuf = ecalloc(len + 1, sizeof(char));\n\t\tif (php_stream_get_line(stream, buf, len, &line_len) == NULL) {\n\t\t\tgoto exit_failed;\n\t\t}\n\t}\n\n\tZVAL_STRINGL(return_value, buf, line_len, 0);\n\t/* resize buffer if it's much larger than the result.\n\t * Only needed if the user requested a buffer size. */\n\tif (argc > 1 && Z_STRLEN_P(return_value) < len / 2) {\n\t\tZ_STRVAL_P(return_value) = erealloc(buf, line_len + 1);\n\t}\n\treturn;\n\nexit_failed:\n\tRETVAL_FALSE;\n\tif (buf) {\n\t\tefree(buf);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string fgetc(resource fp)\n   Get a character from file pointer */\nPHPAPI PHP_FUNCTION(fgetc)\n{\n\tzval *arg1;\n\tchar buf[2];\n\tint result;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tresult = php_stream_getc(stream);\n\n\tif (result == EOF) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tbuf[0] = result;\n\t\tbuf[1] = '\\0';\n\n\t\tRETURN_STRINGL(buf, 1, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string fgetss(resource fp [, int length [, string allowable_tags]])\n   Get a line from file pointer and strip HTML tags */\nPHPAPI PHP_FUNCTION(fgetss)\n{\n\tzval *fd;\n\tlong bytes = 0;\n\tsize_t len = 0;\n\tsize_t actual_len, retval_len;\n\tchar *buf = NULL, *retval;\n\tphp_stream *stream;\n\tchar *allowed_tags=NULL;\n\tint allowed_tags_len=0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|ls\", &fd, &bytes, &allowed_tags, &allowed_tags_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fd);\n\n\tif (ZEND_NUM_ARGS() >= 2) {\n\t\tif (bytes <= 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tlen = (size_t) bytes;\n\t\tbuf = safe_emalloc(sizeof(char), (len + 1), 0);\n\t\t/*needed because recv doesnt set null char at end*/\n\t\tmemset(buf, 0, len + 1);\n\t}\n\n\tif ((retval = php_stream_get_line(stream, buf, len, &actual_len)) == NULL)\t{\n\t\tif (buf != NULL) {\n\t\t\tefree(buf);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tretval_len = php_strip_tags(retval, actual_len, &stream->fgetss_state, allowed_tags, allowed_tags_len);\n\n\tRETURN_STRINGL(retval, retval_len, 0);\n}\n/* }}} */\n\n/* {{{ proto mixed fscanf(resource stream, string format [, string ...])\n   Implements a mostly ANSI compatible fscanf() */\nPHP_FUNCTION(fscanf)\n{\n\tint result, format_len, type, argc = 0;\n\tzval ***args = NULL;\n\tzval *file_handle;\n\tchar *buf, *format;\n\tsize_t len;\n\tvoid *what;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs*\", &file_handle, &format, &format_len, &args, &argc) == FAILURE) {\n\t\treturn;\n\t}\n\n\twhat = zend_fetch_resource(&file_handle TSRMLS_CC, -1, \"File-Handle\", &type, 2, php_file_le_stream(), php_file_le_pstream());\n\n\t/* we can't do a ZEND_VERIFY_RESOURCE(what), otherwise we end up\n\t * with a leak if we have an invalid filehandle. This needs changing\n\t * if the code behind ZEND_VERIFY_RESOURCE changed. - cc */\n\tif (!what) {\n\t\tif (args) {\n\t\t\tefree(args);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tbuf = php_stream_get_line((php_stream *) what, NULL, 0, &len);\n\tif (buf == NULL) {\n\t\tif (args) {\n\t\t\tefree(args);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tresult = php_sscanf_internal(buf, format, argc, args, 0, &return_value TSRMLS_CC);\n\n\tif (args) {\n\t\tefree(args);\n\t}\n\tefree(buf);\n\n\tif (SCAN_ERROR_WRONG_PARAM_COUNT == result) {\n\t\tWRONG_PARAM_COUNT;\n\t}\n}\n/* }}} */\n\n/* {{{ proto int fwrite(resource fp, string str [, int length])\n   Binary-safe file write */\nPHPAPI PHP_FUNCTION(fwrite)\n{\n\tzval *arg1;\n\tchar *arg2;\n\tint arg2len;\n\tint ret;\n\tint num_bytes;\n\tlong arg3 = 0;\n\tchar *buffer = NULL;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs|l\", &arg1, &arg2, &arg2len, &arg3) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZEND_NUM_ARGS() == 2) {\n\t\tnum_bytes = arg2len;\n\t} else {\n\t\tnum_bytes = MAX(0, MIN((int)arg3, arg2len));\n\t}\n\n\tif (!num_bytes) {\n\t\tRETURN_LONG(0);\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tret = php_stream_write(stream, buffer ? buffer : arg2, num_bytes);\n\tif (buffer) {\n\t\tefree(buffer);\n\t}\n\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ proto bool fflush(resource fp)\n   Flushes output */\nPHPAPI PHP_FUNCTION(fflush)\n{\n\tzval *arg1;\n\tint ret;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tret = php_stream_flush(stream);\n\tif (ret) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool rewind(resource fp)\n   Rewind the position of a file pointer */\nPHPAPI PHP_FUNCTION(rewind)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (-1 == php_stream_rewind(stream)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto int ftell(resource fp)\n   Get file pointer's read/write position */\nPHPAPI PHP_FUNCTION(ftell)\n{\n\tzval *arg1;\n\tlong ret;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tret = php_stream_tell(stream);\n\tif (ret == -1)\t{\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ proto int fseek(resource fp, int offset [, int whence])\n   Seek on a file pointer */\nPHPAPI PHP_FUNCTION(fseek)\n{\n\tzval *arg1;\n\tlong arg2, whence = SEEK_SET;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl|l\", &arg1, &arg2, &whence) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tRETURN_LONG(php_stream_seek(stream, arg2, whence));\n}\n/* }}} */\n\n/* {{{ php_mkdir\n*/\n\n/* DEPRECATED APIs: Use php_stream_mkdir() instead */\nPHPAPI int php_mkdir_ex(char *dir, long mode, int options TSRMLS_DC)\n{\n\tint ret;\n\n\tif (php_check_open_basedir(dir TSRMLS_CC)) {\n\t\treturn -1;\n\t}\n\n\tif ((ret = VCWD_MKDIR(dir, (mode_t)mode)) < 0 && (options & REPORT_ERRORS)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t}\n\n\treturn ret;\n}\n\nPHPAPI int php_mkdir(char *dir, long mode TSRMLS_DC)\n{\n\treturn php_mkdir_ex(dir, mode, REPORT_ERRORS TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto bool mkdir(string pathname [, int mode [, bool recursive [, resource context]]])\n   Create a directory */\nPHP_FUNCTION(mkdir)\n{\n\tchar *dir;\n\tint dir_len;\n\tzval *zcontext = NULL;\n\tlong mode = 0777;\n\tzend_bool recursive = 0;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|lbr\", &dir, &dir_len, &mode, &recursive, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(php_stream_mkdir(dir, mode, (recursive ? PHP_STREAM_MKDIR_RECURSIVE : 0) | REPORT_ERRORS, context));\n}\n/* }}} */\n\n/* {{{ proto bool rmdir(string dirname[, resource context])\n   Remove a directory */\nPHP_FUNCTION(rmdir)\n{\n\tchar *dir;\n\tint dir_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|r\", &dir, &dir_len, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(php_stream_rmdir(dir, REPORT_ERRORS, context));\n}\n/* }}} */\n\n/* {{{ proto int readfile(string filename [, bool use_include_path[, resource context]])\n   Output a file or a URL */\nPHP_FUNCTION(readfile)\n{\n\tchar *filename;\n\tint filename_len;\n\tint size = 0;\n\tzend_bool use_include_path = 0;\n\tzval *zcontext = NULL;\n\tphp_stream *stream;\n\tphp_stream_context *context = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|br!\", &filename, &filename_len, &use_include_path, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\", (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\tif (stream) {\n\t\tsize = php_stream_passthru(stream);\n\t\tphp_stream_close(stream);\n\t\tRETURN_LONG(size);\n\t}\n\n\tRETURN_FALSE;\n}\n/* }}} */\n\n/* {{{ proto int umask([int mask])\n   Return or change the umask */\nPHP_FUNCTION(umask)\n{\n\tlong arg1 = 0;\n\tint oldumask;\n\n\toldumask = umask(077);\n\n\tif (BG(umask) == -1) {\n\t\tBG(umask) = oldumask;\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZEND_NUM_ARGS() == 0) {\n\t\tumask(oldumask);\n\t} else {\n\t\tumask(arg1);\n\t}\n\n\tRETURN_LONG(oldumask);\n}\n/* }}} */\n\n/* {{{ proto int fpassthru(resource fp)\n   Output all remaining data from a file pointer */\nPHPAPI PHP_FUNCTION(fpassthru)\n{\n\tzval *arg1;\n\tint size;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tsize = php_stream_passthru(stream);\n\tRETURN_LONG(size);\n}\n/* }}} */\n\n/* {{{ proto bool rename(string old_name, string new_name[, resource context])\n   Rename a file */\nPHP_FUNCTION(rename)\n{\n\tchar *old_name, *new_name;\n\tint old_name_len, new_name_len;\n\tzval *zcontext = NULL;\n\tphp_stream_wrapper *wrapper;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp|r\", &old_name, &old_name_len, &new_name, &new_name_len, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\twrapper = php_stream_locate_url_wrapper(old_name, NULL, 0 TSRMLS_CC);\n\n\tif (!wrapper || !wrapper->wops) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to locate stream wrapper\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!wrapper->wops->rename) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s wrapper does not support renaming\", wrapper->wops->label ? wrapper->wops->label : \"Source\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (wrapper != php_stream_locate_url_wrapper(new_name, NULL, 0 TSRMLS_CC)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot rename a file across wrapper types\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(wrapper->wops->rename(wrapper, old_name, new_name, 0, context TSRMLS_CC));\n}\n/* }}} */\n\n/* {{{ proto bool unlink(string filename[, context context])\n   Delete a file */\nPHP_FUNCTION(unlink)\n{\n\tchar *filename;\n\tint filename_len;\n\tphp_stream_wrapper *wrapper;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|r\", &filename, &filename_len, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\twrapper = php_stream_locate_url_wrapper(filename, NULL, 0 TSRMLS_CC);\n\n\tif (!wrapper || !wrapper->wops) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to locate stream wrapper\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!wrapper->wops->unlink) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s does not allow unlinking\", wrapper->wops->label ? wrapper->wops->label : \"Wrapper\");\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_BOOL(wrapper->wops->unlink(wrapper, filename, REPORT_ERRORS, context TSRMLS_CC));\n}\n/* }}} */\n\n/* {{{ proto bool ftruncate(resource fp, int size)\n   Truncate file to 'size' length */\nPHP_NAMED_FUNCTION(php_if_ftruncate)\n{\n\tzval *fp;\n\tlong size;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &fp, &size) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fp);\n\n\tif (!php_stream_truncate_supported(stream)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Can't truncate this stream!\");\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL(0 == php_stream_truncate_set_size(stream, size));\n}\n/* }}} */\n\n/* {{{ proto array fstat(resource fp)\n   Stat() on a filehandle */\nPHP_NAMED_FUNCTION(php_if_fstat)\n{\n\tzval *fp;\n\tzval *stat_dev, *stat_ino, *stat_mode, *stat_nlink, *stat_uid, *stat_gid, *stat_rdev,\n\t\t *stat_size, *stat_atime, *stat_mtime, *stat_ctime, *stat_blksize, *stat_blocks;\n\tphp_stream *stream;\n\tphp_stream_statbuf stat_ssb;\n\tchar *stat_sb_names[13] = {\n\t\t\"dev\", \"ino\", \"mode\", \"nlink\", \"uid\", \"gid\", \"rdev\",\n\t\t\"size\", \"atime\", \"mtime\", \"ctime\", \"blksize\", \"blocks\"\n\t};\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &fp) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fp);\n\n\tif (php_stream_stat(stream, &stat_ssb)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\tMAKE_LONG_ZVAL_INCREF(stat_dev, stat_ssb.sb.st_dev);\n\tMAKE_LONG_ZVAL_INCREF(stat_ino, stat_ssb.sb.st_ino);\n\tMAKE_LONG_ZVAL_INCREF(stat_mode, stat_ssb.sb.st_mode);\n\tMAKE_LONG_ZVAL_INCREF(stat_nlink, stat_ssb.sb.st_nlink);\n\tMAKE_LONG_ZVAL_INCREF(stat_uid, stat_ssb.sb.st_uid);\n\tMAKE_LONG_ZVAL_INCREF(stat_gid, stat_ssb.sb.st_gid);\n#ifdef HAVE_ST_RDEV\n\tMAKE_LONG_ZVAL_INCREF(stat_rdev, stat_ssb.sb.st_rdev);\n#else\n\tMAKE_LONG_ZVAL_INCREF(stat_rdev, -1);\n#endif\n\tMAKE_LONG_ZVAL_INCREF(stat_size, stat_ssb.sb.st_size);\n\tMAKE_LONG_ZVAL_INCREF(stat_atime, stat_ssb.sb.st_atime);\n\tMAKE_LONG_ZVAL_INCREF(stat_mtime, stat_ssb.sb.st_mtime);\n\tMAKE_LONG_ZVAL_INCREF(stat_ctime, stat_ssb.sb.st_ctime);\n#ifdef HAVE_ST_BLKSIZE\n\tMAKE_LONG_ZVAL_INCREF(stat_blksize, stat_ssb.sb.st_blksize);\n#else\n\tMAKE_LONG_ZVAL_INCREF(stat_blksize,-1);\n#endif\n#ifdef HAVE_ST_BLOCKS\n\tMAKE_LONG_ZVAL_INCREF(stat_blocks, stat_ssb.sb.st_blocks);\n#else\n\tMAKE_LONG_ZVAL_INCREF(stat_blocks,-1);\n#endif\n\t/* Store numeric indexes in propper order */\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_dev, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_ino, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_mode, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_nlink, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_uid, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_gid, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_rdev, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_size, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_atime, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_mtime, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_ctime, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_blksize, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_blocks, sizeof(zval *), NULL);\n\n\t/* Store string indexes referencing the same zval*/\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[0], strlen(stat_sb_names[0])+1, (void *)&stat_dev, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[1], strlen(stat_sb_names[1])+1, (void *)&stat_ino, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[2], strlen(stat_sb_names[2])+1, (void *)&stat_mode, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[3], strlen(stat_sb_names[3])+1, (void *)&stat_nlink, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[4], strlen(stat_sb_names[4])+1, (void *)&stat_uid, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[5], strlen(stat_sb_names[5])+1, (void *)&stat_gid, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[6], strlen(stat_sb_names[6])+1, (void *)&stat_rdev, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[7], strlen(stat_sb_names[7])+1, (void *)&stat_size, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[8], strlen(stat_sb_names[8])+1, (void *)&stat_atime, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[9], strlen(stat_sb_names[9])+1, (void *)&stat_mtime, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[10], strlen(stat_sb_names[10])+1, (void *)&stat_ctime, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[11], strlen(stat_sb_names[11])+1, (void *)&stat_blksize, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[12], strlen(stat_sb_names[12])+1, (void *)&stat_blocks, sizeof(zval *), NULL);\n}\n/* }}} */\n\n/* {{{ proto bool copy(string source_file, string destination_file [, resource context])\n   Copy a file */\nPHP_FUNCTION(copy)\n{\n\tchar *source, *target;\n\tint source_len, target_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp|r\", &source, &source_len, &target, &target_len, &zcontext) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (php_check_open_basedir(source TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tif (php_copy_file_ctx(source, target, 0, context TSRMLS_CC) == SUCCESS) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ php_copy_file\n */\nPHPAPI int php_copy_file(char *src, char *dest TSRMLS_DC)\n{\n\treturn php_copy_file_ctx(src, dest, 0, NULL TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ php_copy_file_ex\n */\nPHPAPI int php_copy_file_ex(char *src, char *dest, int src_flg TSRMLS_DC)\n{\n\treturn php_copy_file_ctx(src, dest, 0, NULL TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ php_copy_file_ctx\n */\nPHPAPI int php_copy_file_ctx(char *src, char *dest, int src_flg, php_stream_context *ctx TSRMLS_DC)\n{\n\tphp_stream *srcstream = NULL, *deststream = NULL;\n\tint ret = FAILURE;\n\tphp_stream_statbuf src_s, dest_s;\n\n\tswitch (php_stream_stat_path_ex(src, 0, &src_s, ctx)) {\n\t\tcase -1:\n\t\t\t/* non-statable stream */\n\t\t\tgoto safe_to_copy;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault: /* failed to stat file, does not exist? */\n\t\t\treturn ret;\n\t}\n\tif (S_ISDIR(src_s.sb.st_mode)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The first argument to copy() function cannot be a directory\");\n\t\treturn FAILURE;\n\t}\n\n\tswitch (php_stream_stat_path_ex(dest, PHP_STREAM_URL_STAT_QUIET | PHP_STREAM_URL_STAT_NOCACHE, &dest_s, ctx)) {\n\t\tcase -1:\n\t\t\t/* non-statable stream */\n\t\t\tgoto safe_to_copy;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault: /* failed to stat file, does not exist? */\n\t\t\treturn ret;\n\t}\n\tif (S_ISDIR(dest_s.sb.st_mode)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The second argument to copy() function cannot be a directory\");\n\t\treturn FAILURE;\n\t}\n\tif (!src_s.sb.st_ino || !dest_s.sb.st_ino) {\n\t\tgoto no_stat;\n\t}\n\tif (src_s.sb.st_ino == dest_s.sb.st_ino && src_s.sb.st_dev == dest_s.sb.st_dev) {\n\t\treturn ret;\n\t} else {\n\t\tgoto safe_to_copy;\n\t}\nno_stat:\n\t{\n\t\tchar *sp, *dp;\n\t\tint res;\n\n\t\tif ((sp = expand_filepath(src, NULL TSRMLS_CC)) == NULL) {\n\t\t\treturn ret;\n\t\t}\n\t\tif ((dp = expand_filepath(dest, NULL TSRMLS_CC)) == NULL) {\n\t\t\tefree(sp);\n\t\t\tgoto safe_to_copy;\n\t\t}\n\n\t\tres =\n#ifndef PHP_WIN32\n\t\t\t!strcmp(sp, dp);\n#else\n\t\t\t!strcasecmp(sp, dp);\n#endif\n\n\t\tefree(sp);\n\t\tefree(dp);\n\t\tif (res) {\n\t\t\treturn ret;\n\t\t}\n\t}\nsafe_to_copy:\n\n\tsrcstream = php_stream_open_wrapper_ex(src, \"rb\", src_flg | REPORT_ERRORS, NULL, ctx);\n\n\tif (!srcstream) {\n\t\treturn ret;\n\t}\n\n\tdeststream = php_stream_open_wrapper_ex(dest, \"wb\", REPORT_ERRORS, NULL, ctx);\n\n\tif (srcstream && deststream) {\n\t\tret = php_stream_copy_to_stream_ex(srcstream, deststream, PHP_STREAM_COPY_ALL, NULL);\n\t}\n\tif (srcstream) {\n\t\tphp_stream_close(srcstream);\n\t}\n\tif (deststream) {\n\t\tphp_stream_close(deststream);\n\t}\n\treturn ret;\n}\n/* }}} */\n\n/* {{{ proto string fread(resource fp, int length)\n   Binary-safe file read */\nPHPAPI PHP_FUNCTION(fread)\n{\n\tzval *arg1;\n\tlong len;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (len <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\n\tZ_STRVAL_P(return_value) = emalloc(len + 1);\n\tZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\n\n\t/* needed because recv/read/gzread doesnt put a null at the end*/\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}\n/* }}} */\n\nstatic const char *php_fgetcsv_lookup_trailing_spaces(const char *ptr, size_t len, const char delimiter TSRMLS_DC) /* {{{ */\n{\n\tint inc_len;\n\tunsigned char last_chars[2] = { 0, 0 };\n\n\twhile (len > 0) {\n\t\tinc_len = (*ptr == '\\0' ? 1: php_mblen(ptr, len));\n\t\tswitch (inc_len) {\n\t\t\tcase -2:\n\t\t\tcase -1:\n\t\t\t\tinc_len = 1;\n\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tgoto quit_loop;\n\t\t\tcase 1:\n\t\t\tdefault:\n\t\t\t\tlast_chars[0] = last_chars[1];\n\t\t\t\tlast_chars[1] = *ptr;\n\t\t\t\tbreak;\n\t\t}\n\t\tptr += inc_len;\n\t\tlen -= inc_len;\n\t}\nquit_loop:\n\tswitch (last_chars[1]) {\n\t\tcase '\\n':\n\t\t\tif (last_chars[0] == '\\r') {\n\t\t\t\treturn ptr - 2;\n\t\t\t}\n\t\t\t/* break is omitted intentionally */\n\t\tcase '\\r':\n\t\t\treturn ptr - 1;\n\t}\n\treturn ptr;\n}\n/* }}} */\n\n#define FPUTCSV_FLD_CHK(c) memchr(Z_STRVAL(field), c, Z_STRLEN(field))\n\n/* {{{ proto int fputcsv(resource fp, array fields [, string delimiter [, string enclosure [, string escape_char]]])\n   Format line as CSV and write to file pointer */\nPHP_FUNCTION(fputcsv)\n{\n\tchar delimiter = ',';\t /* allow this to be set as parameter */\n\tchar enclosure = '\"';\t /* allow this to be set as parameter */\n\tchar escape_char = '\\\\'; /* allow this to be set as parameter */\n\tphp_stream *stream;\n\tzval *fp = NULL, *fields = NULL;\n\tint ret;\n\tchar *delimiter_str = NULL, *enclosure_str = NULL, *escape_str = NULL;\n\tint delimiter_str_len = 0, enclosure_str_len = 0, escape_str_len = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra|sss\",\n\t\t\t&fp, &fields, &delimiter_str, &delimiter_str_len,\n\t\t\t&enclosure_str, &enclosure_str_len,\n\t\t\t&escape_str, &escape_str_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (delimiter_str != NULL) {\n\t\t/* Make sure that there is at least one character in string */\n\t\tif (delimiter_str_len < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n\t\t\tRETURN_FALSE;\n\t\t} else if (delimiter_str_len > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"delimiter must be a single character\");\n\t\t}\n\n\t\t/* use first character from string */\n\t\tdelimiter = *delimiter_str;\n\t}\n\n\tif (enclosure_str != NULL) {\n\t\tif (enclosure_str_len < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n\t\t\tRETURN_FALSE;\n\t\t} else if (enclosure_str_len > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"enclosure must be a single character\");\n\t\t}\n\t\t/* use first character from string */\n\t\tenclosure = *enclosure_str;\n\t}\n\n\tif (escape_str != NULL) {\n\t\tif (escape_str_len < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be a character\");\n\t\t\tRETURN_FALSE;\n\t\t} else if (escape_str_len > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"escape must be a single character\");\n\t\t}\n\t\t/* use first character from string */\n\t\tescape_char = *escape_str;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fp);\n\n\tret = php_fputcsv(stream, fields, delimiter, enclosure, escape_char TSRMLS_CC);\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ PHPAPI int php_fputcsv(php_stream *stream, zval *fields, char delimiter, char enclosure, char escape_char TSRMLS_DC) */\nPHPAPI int php_fputcsv(php_stream *stream, zval *fields, char delimiter, char enclosure, char escape_char TSRMLS_DC)\n{\n\tint count, i = 0, ret;\n\tzval **field_tmp = NULL, field;\n\tsmart_str csvline = {0};\n\tHashPosition pos;\n\n\tcount = zend_hash_num_elements(Z_ARRVAL_P(fields));\n\tzend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(fields), &pos);\n\twhile (zend_hash_get_current_data_ex(Z_ARRVAL_P(fields), (void **) &field_tmp, &pos) == SUCCESS) {\n\t\tfield = **field_tmp;\n\n\t\tif (Z_TYPE_PP(field_tmp) != IS_STRING) {\n\t\t\tzval_copy_ctor(&field);\n\t\t\tconvert_to_string(&field);\n\t\t}\n\n\t\t/* enclose a field that contains a delimiter, an enclosure character, or a newline */\n\t\tif (FPUTCSV_FLD_CHK(delimiter) ||\n\t\t\tFPUTCSV_FLD_CHK(enclosure) ||\n\t\t\tFPUTCSV_FLD_CHK(escape_char) ||\n\t\t\tFPUTCSV_FLD_CHK('\\n') ||\n\t\t\tFPUTCSV_FLD_CHK('\\r') ||\n\t\t\tFPUTCSV_FLD_CHK('\\t') ||\n\t\t\tFPUTCSV_FLD_CHK(' ')\n\t\t) {\n\t\t\tchar *ch = Z_STRVAL(field);\n\t\t\tchar *end = ch + Z_STRLEN(field);\n\t\t\tint escaped = 0;\n\n\t\t\tsmart_str_appendc(&csvline, enclosure);\n\t\t\twhile (ch < end) {\n\t\t\t\tif (*ch == escape_char) {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t} else if (!escaped && *ch == enclosure) {\n\t\t\t\t\tsmart_str_appendc(&csvline, enclosure);\n\t\t\t\t} else {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t}\n\t\t\t\tsmart_str_appendc(&csvline, *ch);\n\t\t\t\tch++;\n\t\t\t}\n\t\t\tsmart_str_appendc(&csvline, enclosure);\n\t\t} else {\n\t\t\tsmart_str_appendl(&csvline, Z_STRVAL(field), Z_STRLEN(field));\n\t\t}\n\n\t\tif (++i != count) {\n\t\t\tsmart_str_appendl(&csvline, &delimiter, 1);\n\t\t}\n\t\tzend_hash_move_forward_ex(Z_ARRVAL_P(fields), &pos);\n\n\t\tif (Z_TYPE_PP(field_tmp) != IS_STRING) {\n\t\t\tzval_dtor(&field);\n\t\t}\n\t}\n\n\tsmart_str_appendc(&csvline, '\\n');\n\tsmart_str_0(&csvline);\n\n\tret = php_stream_write(stream, csvline.c, csvline.len);\n\n\tsmart_str_free(&csvline);\n\n\treturn ret;\n}\n/* }}} */\n\n/* {{{ proto array fgetcsv(resource fp [,int length [, string delimiter [, string enclosure [, string escape]]]])\n   Get line from file pointer and parse for CSV fields */\nPHP_FUNCTION(fgetcsv)\n{\n\tchar delimiter = ',';\t/* allow this to be set as parameter */\n\tchar enclosure = '\"';\t/* allow this to be set as parameter */\n\tchar escape = '\\\\';\n\n\t/* first section exactly as php_fgetss */\n\n\tlong len = 0;\n\tsize_t buf_len;\n\tchar *buf;\n\tphp_stream *stream;\n\n\t{\n\t\tzval *fd, **len_zv = NULL;\n\t\tchar *delimiter_str = NULL;\n\t\tint delimiter_str_len = 0;\n\t\tchar *enclosure_str = NULL;\n\t\tint enclosure_str_len = 0;\n\t\tchar *escape_str = NULL;\n\t\tint escape_str_len = 0;\n\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|Zsss\",\n\t\t\t&fd, &len_zv, &delimiter_str, &delimiter_str_len,\n\t\t\t&enclosure_str, &enclosure_str_len,\n\t\t\t&escape_str, &escape_str_len) == FAILURE\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (delimiter_str != NULL) {\n\t\t\t/* Make sure that there is at least one character in string */\n\t\t\tif (delimiter_str_len < 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (delimiter_str_len > 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"delimiter must be a single character\");\n\t\t\t}\n\n\t\t\t/* use first character from string */\n\t\t\tdelimiter = delimiter_str[0];\n\t\t}\n\n\t\tif (enclosure_str != NULL) {\n\t\t\tif (enclosure_str_len < 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (enclosure_str_len > 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"enclosure must be a single character\");\n\t\t\t}\n\n\t\t\t/* use first character from string */\n\t\t\tenclosure = enclosure_str[0];\n\t\t}\n\n\t\tif (escape_str != NULL) {\n\t\t\tif (escape_str_len < 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (escape_str_len > 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"escape must be a single character\");\n\t\t\t}\n\n\t\t\tescape = escape_str[0];\n\t\t}\n\n\t\tif (len_zv != NULL && Z_TYPE_PP(len_zv) != IS_NULL) {\n\t\t\tconvert_to_long_ex(len_zv);\n\t\t\tlen = Z_LVAL_PP(len_zv);\n\t\t\tif (len < 0) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter may not be negative\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (len == 0) {\n\t\t\t\tlen = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tlen = -1;\n\t\t}\n\n\t\tPHP_STREAM_TO_ZVAL(stream, &fd);\n\t}\n\n\tif (len < 0) {\n\t\tif ((buf = php_stream_get_line(stream, NULL, 0, &buf_len)) == NULL) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tbuf = emalloc(len + 1);\n\t\tif (php_stream_get_line(stream, buf, len + 1, &buf_len) == NULL) {\n\t\t\tefree(buf);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tphp_fgetcsv(stream, delimiter, enclosure, escape, buf_len, buf, return_value TSRMLS_CC);\n}\n/* }}} */\n\nPHPAPI void php_fgetcsv(php_stream *stream, char delimiter, char enclosure, char escape_char, size_t buf_len, char *buf, zval *return_value TSRMLS_DC) /* {{{ */\n{\n\tchar *temp, *tptr, *bptr, *line_end, *limit;\n\tsize_t temp_len, line_end_len;\n\tint inc_len;\n\tzend_bool first_field = 1;\n\n\t/* initialize internal state */\n\tphp_ignore_value(php_mblen(NULL, 0));\n\n\t/* Now into new section that parses buf for delimiter/enclosure fields */\n\n\t/* Strip trailing space from buf, saving end of line in case required for enclosure field */\n\n\tbptr = buf;\n\ttptr = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len, delimiter TSRMLS_CC);\n\tline_end_len = buf_len - (size_t)(tptr - buf);\n\tline_end = limit = tptr;\n\n\t/* reserve workspace for building each individual field */\n\ttemp_len = buf_len;\n\ttemp = emalloc(temp_len + line_end_len + 1);\n\n\t/* Initialize return array */\n\tarray_init(return_value);\n\n\t/* Main loop to read CSV fields */\n\t/* NB this routine will return a single null entry for a blank line */\n\n\tdo {\n\t\tchar *comp_end, *hunk_begin;\n\n\t\ttptr = temp;\n\n\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\tif (inc_len == 1) {\n\t\t\tchar *tmp = bptr;\n\t\t\twhile ((*tmp != delimiter) && isspace((int)*(unsigned char *)tmp)) {\n\t\t\t\ttmp++;\n  \t\t\t}\n\t\t\tif (*tmp == enclosure) {\n\t\t\t\tbptr = tmp;\n\t\t\t}\n  \t\t}\n\n\t\tif (first_field && bptr == line_end) {\n\t\t\tadd_next_index_null(return_value);\n\t\t\tbreak;\n\t\t}\n\t\tfirst_field = 0;\n\t\t/* 2. Read field, leaving bptr pointing at start of next field */\n\t\tif (inc_len != 0 && *bptr == enclosure) {\n\t\t\tint state = 0;\n\n\t\t\tbptr++;\t/* move on to first character in field */\n\t\t\thunk_begin = bptr;\n\n\t\t\t/* 2A. handle enclosure delimited field */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (inc_len) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\t/* break is omitted intentionally */\n\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tchar *new_buf;\n\t\t\t\t\t\t\t\tsize_t new_len;\n\t\t\t\t\t\t\t\tchar *new_temp;\n\n\t\t\t\t\t\t\t\tif (hunk_begin != line_end) {\n\t\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t/* add the embedded line end to the field */\n\t\t\t\t\t\t\t\tmemcpy(tptr, line_end, line_end_len);\n\t\t\t\t\t\t\t\ttptr += line_end_len;\n\n\t\t\t\t\t\t\t\tif (stream == NULL) {\n\t\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\t\t} else if ((new_buf = php_stream_get_line(stream, NULL, 0, &new_len)) == NULL) {\n\t\t\t\t\t\t\t\t\t/* we've got an unterminated enclosure,\n\t\t\t\t\t\t\t\t\t * assign all the data from the start of\n\t\t\t\t\t\t\t\t\t * the enclosure to end of data to the\n\t\t\t\t\t\t\t\t\t * last element */\n\t\t\t\t\t\t\t\t\tif ((size_t)temp_len > (size_t)(limit - buf)) {\n\t\t\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\t\t\t\t\tRETVAL_FALSE;\n\t\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttemp_len += new_len;\n\t\t\t\t\t\t\t\tnew_temp = erealloc(temp, temp_len);\n\t\t\t\t\t\t\t\ttptr = new_temp + (size_t)(tptr - temp);\n\t\t\t\t\t\t\t\ttemp = new_temp;\n\n\t\t\t\t\t\t\t\tefree(buf);\n\t\t\t\t\t\t\t\tbuf_len = new_len;\n\t\t\t\t\t\t\t\tbptr = buf = new_buf;\n\t\t\t\t\t\t\t\thunk_begin = buf;\n\n\t\t\t\t\t\t\t\tline_end = limit = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len, delimiter TSRMLS_CC);\n\t\t\t\t\t\t\t\tline_end_len = buf_len - (size_t)(limit - buf);\n\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t} break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase -2:\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\t\t\t/* break is omitted intentionally */\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t/* we need to determine if the enclosure is\n\t\t\t\t\t\t * 'real' or is it escaped */\n\t\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\t\tcase 1: /* escaped */\n\t\t\t\t\t\t\t\tbptr++;\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2: /* embedded enclosure ? let's check it */\n\t\t\t\t\t\t\t\tif (*bptr != enclosure) {\n\t\t\t\t\t\t\t\t\t/* real enclosure */\n\t\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\tbptr++;\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (*bptr == enclosure) {\n\t\t\t\t\t\t\t\t\tstate = 2;\n\t\t\t\t\t\t\t\t} else if (*bptr == escape_char) {\n\t\t\t\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbptr++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t/* real enclosure */\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tbptr += inc_len;\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbptr += inc_len;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\t\t}\n\n\t\tquit_loop_2:\n\t\t\t/* look up for a delimiter */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (inc_len) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tgoto quit_loop_3;\n\n\t\t\t\t\tcase -2:\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tinc_len = 1;\n\t\t\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\t\t\t/* break is omitted intentionally */\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (*bptr == delimiter) {\n\t\t\t\t\t\t\tgoto quit_loop_3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbptr += inc_len;\n\t\t\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\t\t}\n\n\t\tquit_loop_3:\n\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\ttptr += (bptr - hunk_begin);\n\t\t\tbptr += inc_len;\n\t\t\tcomp_end = tptr;\n\t\t} else {\n\t\t\t/* 2B. Handle non-enclosure field */\n\n\t\t\thunk_begin = bptr;\n\n\t\t\tfor (;;) {\n\t\t\t\tswitch (inc_len) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tgoto quit_loop_4;\n\t\t\t\t\tcase -2:\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tinc_len = 1;\n\t\t\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\t\t\t/* break is omitted intentionally */\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (*bptr == delimiter) {\n\t\t\t\t\t\t\tgoto quit_loop_4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbptr += inc_len;\n\t\t\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\t\t}\n\t\tquit_loop_4:\n\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\ttptr += (bptr - hunk_begin);\n\n\t\t\tcomp_end = (char *)php_fgetcsv_lookup_trailing_spaces(temp, tptr - temp, delimiter TSRMLS_CC);\n\t\t\tif (*bptr == delimiter) {\n\t\t\t\tbptr++;\n\t\t\t}\n\t\t}\n\n\t\t/* 3. Now pass our field back to php */\n\t\t*comp_end = '\\0';\n\t\tadd_next_index_stringl(return_value, temp, comp_end - temp, 1);\n\t} while (inc_len > 0);\n\nout:\n\tefree(temp);\n\tif (stream) {\n\t\tefree(buf);\n\t}\n}\n/* }}} */\n\n#if (!defined(__BEOS__) && !defined(NETWARE) && HAVE_REALPATH) || defined(ZTS)\n/* {{{ proto string realpath(string path)\n   Return the resolved path */\nPHP_FUNCTION(realpath)\n{\n\tchar *filename;\n\tint filename_len;\n\tchar resolved_path_buff[MAXPATHLEN];\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p\", &filename, &filename_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (VCWD_REALPATH(filename, resolved_path_buff)) {\n\t\tif (php_check_open_basedir(resolved_path_buff TSRMLS_CC)) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\n#ifdef ZTS\n\t\tif (VCWD_ACCESS(resolved_path_buff, F_OK)) {\n\t\t\tRETURN_FALSE;\n\t\t}\n#endif\n\t\tRETURN_STRING(resolved_path_buff, 1);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n#endif\n\n/* See http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2 */\n#define PHP_META_HTML401_CHARS \"-_.:\"\n\n/* {{{ php_next_meta_token\n   Tokenizes an HTML file for get_meta_tags */\nphp_meta_tags_token php_next_meta_token(php_meta_tags_data *md TSRMLS_DC)\n{\n\tint ch = 0, compliment;\n\tchar buff[META_DEF_BUFSIZE + 1];\n\n\tmemset((void *)buff, 0, META_DEF_BUFSIZE + 1);\n\n\twhile (md->ulc || (!php_stream_eof(md->stream) && (ch = php_stream_getc(md->stream)))) {\n\t\tif (php_stream_eof(md->stream)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (md->ulc) {\n\t\t\tch = md->lc;\n\t\t\tmd->ulc = 0;\n\t\t}\n\n\t\tswitch (ch) {\n\t\t\tcase '<':\n\t\t\t\treturn TOK_OPENTAG;\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\treturn TOK_CLOSETAG;\n\t\t\t\tbreak;\n\n\t\t\tcase '=':\n\t\t\t\treturn TOK_EQUAL;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\treturn TOK_SLASH;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tcompliment = ch;\n\t\t\t\tmd->token_len = 0;\n\t\t\t\twhile (!php_stream_eof(md->stream) && (ch = php_stream_getc(md->stream)) && ch != compliment && ch != '<' && ch != '>') {\n\t\t\t\t\tbuff[(md->token_len)++] = ch;\n\n\t\t\t\t\tif (md->token_len == META_DEF_BUFSIZE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ch == '<' || ch == '>') {\n\t\t\t\t\t/* Was just an apostrohpe */\n\t\t\t\t\tmd->ulc = 1;\n\t\t\t\t\tmd->lc = ch;\n\t\t\t\t}\n\n\t\t\t\t/* We don't need to alloc unless we are in a meta tag */\n\t\t\t\tif (md->in_meta) {\n\t\t\t\t\tmd->token_data = (char *) emalloc(md->token_len + 1);\n\t\t\t\t\tmemcpy(md->token_data, buff, md->token_len+1);\n\t\t\t\t}\n\n\t\t\t\treturn TOK_STRING;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\n':\n\t\t\tcase '\\r':\n\t\t\tcase '\\t':\n\t\t\t\tbreak;\n\n\t\t\tcase ' ':\n\t\t\t\treturn TOK_SPACE;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (isalnum(ch)) {\n\t\t\t\t\tmd->token_len = 0;\n\t\t\t\t\tbuff[(md->token_len)++] = ch;\n\t\t\t\t\twhile (!php_stream_eof(md->stream) && (ch = php_stream_getc(md->stream)) && (isalnum(ch) || strchr(PHP_META_HTML401_CHARS, ch))) {\n\t\t\t\t\t\tbuff[(md->token_len)++] = ch;\n\n\t\t\t\t\t\tif (md->token_len == META_DEF_BUFSIZE) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* This is ugly, but we have to replace ungetc */\n\t\t\t\t\tif (!isalpha(ch) && ch != '-') {\n\t\t\t\t\t\tmd->ulc = 1;\n\t\t\t\t\t\tmd->lc = ch;\n\t\t\t\t\t}\n\n\t\t\t\t\tmd->token_data = (char *) emalloc(md->token_len + 1);\n\t\t\t\t\tmemcpy(md->token_data, buff, md->token_len+1);\n\n\t\t\t\t\treturn TOK_ID;\n\t\t\t\t} else {\n\t\t\t\t\treturn TOK_OTHER;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn TOK_EOF;\n}\n/* }}} */\n\n#ifdef HAVE_FNMATCH\n/* {{{ proto bool fnmatch(string pattern, string filename [, int flags])\n   Match filename against pattern */\nPHP_FUNCTION(fnmatch)\n{\n\tchar *pattern, *filename;\n\tint pattern_len, filename_len;\n\tlong flags = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp|l\", &pattern, &pattern_len, &filename, &filename_len, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (filename_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Filename exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\tRETURN_FALSE;\n\t}\n\tif (pattern_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Pattern exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL( ! fnmatch( pattern, filename, flags ));\n}\n/* }}} */\n#endif\n\n/* {{{ proto string sys_get_temp_dir()\n   Returns directory path used for temporary files */\nPHP_FUNCTION(sys_get_temp_dir)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_STRING((char *)php_get_temporary_directory(TSRMLS_C), 1);\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */\n",
        "fix": null,
        "buggy_hunk_masked": "\tZ_STRVAL_P(return_value) = emalloc(len + 1);\n",
        "src_path": "abd159cce48f3e34f08e4751c568e09677d5ec9c___file.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/abd159cce48f3e34f08e4751c568e09677d5ec9c",
        "commit_msg": "Fix bug #72114 - int/size_t confusion in fread",
        "test_func_diff": [
            {
                "fn": "ext/standard/tests/file/bug72114.phpt",
                "patch": "@@ -0,0 +1,12 @@\n+--TEST--\n+Bug #72114 (Integer underflow / arbitrary null write in fread/gzread)\n+--FILE--\n+<?php\n+ini_set('memory_limit', \"2500M\");\n+$fp = fopen(\"/dev/zero\", \"r\");\n+fread($fp, 2147483648);\n+?>\n+Done\n+--EXPECTF--\n+Warning: fread(): Length parameter must be no more than 2147483647 in %s/bug72114.php on line %d\n+Done"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.5.36-dev ZEND_VERSION: 2.5.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_abd159cce48f3e34f08e4751c568e09677d5ec9c More .INIs : CWD : /out/php___php-src/git_repo_dir_abd159cce48f3e34f08e4751c568e09677d5ec9c Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/standard/tests/file/bug72114.phpt]\rFAIL Bug #72114 (Integer underflow / arbitrary null write in fread/gzread) [ext/standard/tests/file/bug72114.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 2 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72114 (Integer underflow / arbitrary null write in fread/gzread) [ext/standard/tests/file/bug72114.phpt] =====================================================================\n"
    },
    "698a691724c0a949295991e5df091ce16f899e02___wddx.c": {
        "prefix": "static void php_wddx_add_var(wddx_packet *packet, zval *name_var)\n{\n\tzval **val;\n\tHashTable *target_hash;\n\tTSRMLS_FETCH();\n\n\tif (Z_TYPE_P(name_var) == IS_STRING) {\n\t\tif (!EG(active_symbol_table)) {\n\t\t\tzend_rebuild_symbol_table(TSRMLS_C);\n\t\t}\n\t\tif (zend_hash_find(EG(active_symbol_table), Z_STRVAL_P(name_var),\n\t\t\t\t\t\t\tZ_STRLEN_P(name_var)+1, (void**)&val) != FAILURE) {\n\t\t\tphp_wddx_serialize_var(packet, *val, Z_STRVAL_P(name_var), Z_STRLEN_P(name_var) TSRMLS_CC);\n\t\t}\n\t} else if (Z_TYPE_P(name_var) == IS_ARRAY || Z_TYPE_P(name_var) == IS_OBJECT)\t{\n\t\tint is_array = Z_TYPE_P(name_var) == IS_ARRAY;\n\n\t\ttarget_hash = HASH_OF(name_var);\n\n\t\tif (is_array && target_hash->nApplyCount > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"recursion detected\");\n\t\t\treturn;\n\t\t}\n\n\t\tzend_hash_internal_pointer_reset(target_hash);\n\n\t\twhile(zend_hash_get_current_data(target_hash, (void**)&val) == SUCCESS) {\n\t\t\tif (is_array) {\n\t\t\t\ttarget_hash->nApplyCount++;\n\t\t\t}\n\n\t\t\tphp_wddx_add_var(packet, *val);\n\n\t\t\tif (is_array) {\n\t\t\t\ttarget_hash->nApplyCount--;\n\t\t\t}\n\t\t\tzend_hash_move_forward(target_hash);\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_push_element\n */\nstatic void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)\n{\n\tst_entry ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\n\tif (!strcmp(name, EL_PACKET)) {\n\t\tint i;\n\n\t\tif (atts) for (i=0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VERSION)) {\n\t\t\t\t/* nothing for now */\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_STRING)) {\n\t\tent.type = ST_STRING;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BINARY)) {\n\t\tent.type = ST_BINARY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_CHAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_CHAR_CODE) && atts[++i] && atts[i][0]) {\n\t\t\t\tchar tmp_buf[2];\n\n\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i], NULL, 16));\n\t\t\t\tphp_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NUMBER)) {\n\t\tent.type = ST_NUMBER;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\tZ_LVAL_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BOOLEAN)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[++i] && atts[i][0]) {\n\t\t\t\tent.type = ST_BOOLEAN;\n\t\t\t\tSET_STACK_VARNAME;\n\n\t\t\t\tALLOC_ZVAL(ent.data);\n\t\t\t\tINIT_PZVAL(ent.data);\n\t\t\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n\t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t\t\tphp_wddx_process_data(user_data, atts[i], strlen(atts[i]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NULL)) {\n\t\tent.type = ST_NULL;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZVAL_NULL(ent.data);\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_ARRAY)) {\n\t\tent.type = ST_ARRAY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_STRUCT)) {\n\t\tent.type = ST_STRUCT;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_VAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tif (stack->varname) efree(stack->varname);\n\t\t\t\tstack->varname = estrdup(atts[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_RECORDSET)) {\n\t\tint i;\n\n\t\tent.type = ST_RECORDSET;\n\t\tSET_STACK_VARNAME;\n\t\tMAKE_STD_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], \"fieldNames\") && atts[++i] && atts[i][0]) {\n\t\t\t\tzval *tmp;\n\t\t\t\tchar *key;\n\t\t\t\tchar *p1, *p2, *endp;\n\n\t\t\t\tendp = (char *)atts[i] + strlen(atts[i]);\n\t\t\t\tp1 = (char *)atts[i];\n\t\t\t\twhile ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {\n\t\t\t\t\tkey = estrndup(p1, p2 - p1);\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp);\n\t\t\t\t\tp1 = p2 + sizeof(\",\")-1;\n\t\t\t\t\tefree(key);\n\t\t\t\t}\n\n\t\t\t\tif (p1 <= endp) {\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tint i;\n\t\tst_entry ent;\n\n\t\tent.type = ST_FIELD;\n\t\tent.varname = NULL;\n\t\tent.data = NULL;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tst_entry *recordset;\n\t\t\t\tzval **field;\n\n\t\t\t\tif (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i], strlen(atts[i])+1, (void**)&field) == SUCCESS) {\n\t\t\t\t\tent.data = *field;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_DATETIME)) {\n\t\tent.type = ST_DATETIME;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_pop_element\n */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n",
        "suffix": "\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_process_data\n */\nstatic void php_wddx_process_data(void *user_data, const XML_Char *s, int len)\n{\n\tst_entry *ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\tTSRMLS_FETCH();\n\n\tif (!wddx_stack_is_empty(stack) && !stack->done) {\n\t\twddx_stack_top(stack, (void**)&ent);\n\t\tswitch (ent->type) {\n\t\t\tcase ST_STRING:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BINARY:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len + 1);\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t}\n\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase ST_NUMBER:\n\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\tconvert_scalar_to_number(ent->data TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BOOLEAN:\n\t\t\t\tif(!ent->data) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(s, \"true\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 1;\n\t\t\t\t} else if (!strcmp(s, \"false\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 0;\n\t\t\t\t} else {\n\t\t\t\t\tzval_ptr_dtor(&ent->data);\n\t\t\t\t\tif (ent->varname) {\n\t\t\t\t\t\tefree(ent->varname);\n\t\t\t\t\t\tent->varname = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tent->data = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_DATETIME: {\n\t\t\t\tchar *tmp;\n\n\t\t\t\tif (Z_TYPE_P(ent->data) == IS_STRING) {\n\t\t\t\t\ttmp = safe_emalloc(Z_STRLEN_P(ent->data), 1, (size_t)len + 1);\n\t\t\t\t\tmemcpy(tmp, Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data));\n\t\t\t\t\tmemcpy(tmp + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t\tlen += Z_STRLEN_P(ent->data);\n\t\t\t\t\tefree(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_TYPE_P(ent->data) = IS_LONG;\n\t\t\t\t} else {\n\t\t\t\t\ttmp = emalloc(len + 1);\n\t\t\t\t\tmemcpy(tmp, s, len);\n\t\t\t\t}\n\t\t\t\ttmp[len] = '\\0';\n\n\t\t\t\tZ_LVAL_P(ent->data) = php_parse_date(tmp, NULL);\n\t\t\t\t/* date out of range < 1969 or > 2038 */\n\t\t\t\tif (Z_LVAL_P(ent->data) == -1) {\n\t\t\t\t\tZVAL_STRINGL(ent->data, tmp, len, 0);\n\t\t\t\t} else {\n\t\t\t\t\tefree(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_deserialize_ex\n */\nint php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)\n{\n\twddx_stack stack;\n\tXML_Parser parser;\n\tst_entry *ent;\n\tint retval;\n\n\twddx_stack_init(&stack);\n\tparser = XML_ParserCreate(\"UTF-8\");\n\n\tXML_SetUserData(parser, &stack);\n\tXML_SetElementHandler(parser, php_wddx_push_element, php_wddx_pop_element);\n\tXML_SetCharacterDataHandler(parser, php_wddx_process_data);\n\n\tXML_Parse(parser, value, vallen, 1);\n\n\tXML_ParserFree(parser);\n\n\tif (stack.top == 1) {\n\t\twddx_stack_top(&stack, (void**)&ent);\n\t\t*return_value = *(ent->data);\n\t\tzval_copy_ctor(return_value);\n\t\tretval = SUCCESS;\n\t} else {\n\t\tretval = FAILURE;\n\t}\n\n\twddx_stack_destroy(&stack);\n\n\treturn retval;\n}\n/* }}} */\n\n/* {{{ proto string wddx_serialize_value(mixed var [, string comment])\n   Creates a new packet and serializes the given value */\nPHP_FUNCTION(wddx_serialize_value)\n{\n\tzval *var;\n\tchar *comment = NULL;\n\tint comment_len = 0;\n\twddx_packet *packet;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|s\", &var, &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, comment, comment_len);\n\tphp_wddx_serialize_var(packet, var, NULL, 0 TSRMLS_CC);\n\tphp_wddx_packet_end(packet);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ proto string wddx_serialize_vars(mixed var_name [, mixed ...])\n   Creates a new packet and serializes given variables into a struct */\nPHP_FUNCTION(wddx_serialize_vars)\n{\n\tint num_args, i;\n\twddx_packet *packet;\n\tzval ***args = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"+\", &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, NULL, 0);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, *args[i]);\n\t}\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\tphp_wddx_packet_end(packet);\n\n\tefree(args);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ php_wddx_constructor\n */\nwddx_packet *php_wddx_constructor(void)\n{\n\tsmart_str *packet;\n\n\tpacket = (smart_str *)emalloc(sizeof(smart_str));\n\tpacket->c = NULL;\n\n\treturn packet;\n}\n/* }}} */\n\n/* {{{ php_wddx_destructor\n */\nvoid php_wddx_destructor(wddx_packet *packet)\n{\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ proto resource wddx_packet_start([string comment])\n   Starts a WDDX packet with optional comment and returns the packet id */\nPHP_FUNCTION(wddx_packet_start)\n{\n\tchar *comment = NULL;\n\tint comment_len = 0;\n\twddx_packet *packet;\n\n\tcomment = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, comment, comment_len);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tZEND_REGISTER_RESOURCE(return_value, packet, le_wddx);\n}\n/* }}} */\n\n/* {{{ proto string wddx_packet_end(resource packet_id)\n   Ends specified WDDX packet and returns the string containing the packet */\nPHP_FUNCTION(wddx_packet_end)\n{\n\tzval *packet_id;\n\twddx_packet *packet = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &packet_id) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(packet, wddx_packet *, &packet_id, -1, \"WDDX packet ID\", le_wddx);\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\n\tphp_wddx_packet_end(packet);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\n\tzend_list_delete(Z_LVAL_P(packet_id));\n}\n/* }}} */\n\n/* {{{ proto int wddx_add_vars(resource packet_id,  mixed var_names [, mixed ...])\n   Serializes given variables and adds them to packet given by packet_id */\nPHP_FUNCTION(wddx_add_vars)\n{\n\tint num_args, i;\n\tzval ***args = NULL;\n\tzval *packet_id;\n\twddx_packet *packet = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r+\", &packet_id, &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!ZEND_FETCH_RESOURCE_NO_RETURN(packet, wddx_packet *, &packet_id, -1, \"WDDX packet ID\", le_wddx)) {\n\t\tefree(args);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!packet) {\n\t\tefree(args);\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, (*args[i]));\n\t}\n\n\tefree(args);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto mixed wddx_deserialize(mixed packet)\n   Deserializes given packet and returns a PHP value */\nPHP_FUNCTION(wddx_deserialize)\n{\n\tzval *packet;\n\tchar *payload;\n\tint payload_len;\n\tphp_stream *stream = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &packet) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (Z_TYPE_P(packet) == IS_STRING) {\n\t\tpayload \t= Z_STRVAL_P(packet);\n\t\tpayload_len = Z_STRLEN_P(packet);\n\t} else if (Z_TYPE_P(packet) == IS_RESOURCE) {\n\t\tphp_stream_from_zval(stream, &packet);\n\t\tif (stream) {\n\t\t\tpayload_len = php_stream_copy_to_mem(stream, &payload, PHP_STREAM_COPY_ALL, 0);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Expecting parameter 1 to be a string or a stream\");\n\t\treturn;\n\t}\n\n\tif (payload_len == 0) {\n\t\treturn;\n\t}\n\n\tphp_wddx_deserialize_ex(payload, payload_len, return_value);\n\n\tif (stream) {\n\t\tpefree(payload, 0);\n\t}\n}\n",
        "start": 701,
        "end": 1389,
        "buggy": "static void php_wddx_add_var(wddx_packet *packet, zval *name_var)\n{\n\tzval **val;\n\tHashTable *target_hash;\n\tTSRMLS_FETCH();\n\n\tif (Z_TYPE_P(name_var) == IS_STRING) {\n\t\tif (!EG(active_symbol_table)) {\n\t\t\tzend_rebuild_symbol_table(TSRMLS_C);\n\t\t}\n\t\tif (zend_hash_find(EG(active_symbol_table), Z_STRVAL_P(name_var),\n\t\t\t\t\t\t\tZ_STRLEN_P(name_var)+1, (void**)&val) != FAILURE) {\n\t\t\tphp_wddx_serialize_var(packet, *val, Z_STRVAL_P(name_var), Z_STRLEN_P(name_var) TSRMLS_CC);\n\t\t}\n\t} else if (Z_TYPE_P(name_var) == IS_ARRAY || Z_TYPE_P(name_var) == IS_OBJECT)\t{\n\t\tint is_array = Z_TYPE_P(name_var) == IS_ARRAY;\n\n\t\ttarget_hash = HASH_OF(name_var);\n\n\t\tif (is_array && target_hash->nApplyCount > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"recursion detected\");\n\t\t\treturn;\n\t\t}\n\n\t\tzend_hash_internal_pointer_reset(target_hash);\n\n\t\twhile(zend_hash_get_current_data(target_hash, (void**)&val) == SUCCESS) {\n\t\t\tif (is_array) {\n\t\t\t\ttarget_hash->nApplyCount++;\n\t\t\t}\n\n\t\t\tphp_wddx_add_var(packet, *val);\n\n\t\t\tif (is_array) {\n\t\t\t\ttarget_hash->nApplyCount--;\n\t\t\t}\n\t\t\tzend_hash_move_forward(target_hash);\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_push_element\n */\nstatic void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)\n{\n\tst_entry ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\n\tif (!strcmp(name, EL_PACKET)) {\n\t\tint i;\n\n\t\tif (atts) for (i=0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VERSION)) {\n\t\t\t\t/* nothing for now */\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_STRING)) {\n\t\tent.type = ST_STRING;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BINARY)) {\n\t\tent.type = ST_BINARY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_CHAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_CHAR_CODE) && atts[++i] && atts[i][0]) {\n\t\t\t\tchar tmp_buf[2];\n\n\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i], NULL, 16));\n\t\t\t\tphp_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NUMBER)) {\n\t\tent.type = ST_NUMBER;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\tZ_LVAL_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BOOLEAN)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[++i] && atts[i][0]) {\n\t\t\t\tent.type = ST_BOOLEAN;\n\t\t\t\tSET_STACK_VARNAME;\n\n\t\t\t\tALLOC_ZVAL(ent.data);\n\t\t\t\tINIT_PZVAL(ent.data);\n\t\t\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n\t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t\t\tphp_wddx_process_data(user_data, atts[i], strlen(atts[i]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NULL)) {\n\t\tent.type = ST_NULL;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZVAL_NULL(ent.data);\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_ARRAY)) {\n\t\tent.type = ST_ARRAY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_STRUCT)) {\n\t\tent.type = ST_STRUCT;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_VAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tif (stack->varname) efree(stack->varname);\n\t\t\t\tstack->varname = estrdup(atts[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_RECORDSET)) {\n\t\tint i;\n\n\t\tent.type = ST_RECORDSET;\n\t\tSET_STACK_VARNAME;\n\t\tMAKE_STD_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], \"fieldNames\") && atts[++i] && atts[i][0]) {\n\t\t\t\tzval *tmp;\n\t\t\t\tchar *key;\n\t\t\t\tchar *p1, *p2, *endp;\n\n\t\t\t\tendp = (char *)atts[i] + strlen(atts[i]);\n\t\t\t\tp1 = (char *)atts[i];\n\t\t\t\twhile ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {\n\t\t\t\t\tkey = estrndup(p1, p2 - p1);\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp);\n\t\t\t\t\tp1 = p2 + sizeof(\",\")-1;\n\t\t\t\t\tefree(key);\n\t\t\t\t}\n\n\t\t\t\tif (p1 <= endp) {\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tint i;\n\t\tst_entry ent;\n\n\t\tent.type = ST_FIELD;\n\t\tent.varname = NULL;\n\t\tent.data = NULL;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tst_entry *recordset;\n\t\t\t\tzval **field;\n\n\t\t\t\tif (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i], strlen(atts[i])+1, (void**)&field) == SUCCESS) {\n\t\t\t\t\tent.data = *field;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_DATETIME)) {\n\t\tent.type = ST_DATETIME;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_pop_element\n */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_process_data\n */\nstatic void php_wddx_process_data(void *user_data, const XML_Char *s, int len)\n{\n\tst_entry *ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\tTSRMLS_FETCH();\n\n\tif (!wddx_stack_is_empty(stack) && !stack->done) {\n\t\twddx_stack_top(stack, (void**)&ent);\n\t\tswitch (ent->type) {\n\t\t\tcase ST_STRING:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BINARY:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len + 1);\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t}\n\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase ST_NUMBER:\n\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\tconvert_scalar_to_number(ent->data TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BOOLEAN:\n\t\t\t\tif(!ent->data) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(s, \"true\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 1;\n\t\t\t\t} else if (!strcmp(s, \"false\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 0;\n\t\t\t\t} else {\n\t\t\t\t\tzval_ptr_dtor(&ent->data);\n\t\t\t\t\tif (ent->varname) {\n\t\t\t\t\t\tefree(ent->varname);\n\t\t\t\t\t\tent->varname = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tent->data = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_DATETIME: {\n\t\t\t\tchar *tmp;\n\n\t\t\t\tif (Z_TYPE_P(ent->data) == IS_STRING) {\n\t\t\t\t\ttmp = safe_emalloc(Z_STRLEN_P(ent->data), 1, (size_t)len + 1);\n\t\t\t\t\tmemcpy(tmp, Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data));\n\t\t\t\t\tmemcpy(tmp + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t\tlen += Z_STRLEN_P(ent->data);\n\t\t\t\t\tefree(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_TYPE_P(ent->data) = IS_LONG;\n\t\t\t\t} else {\n\t\t\t\t\ttmp = emalloc(len + 1);\n\t\t\t\t\tmemcpy(tmp, s, len);\n\t\t\t\t}\n\t\t\t\ttmp[len] = '\\0';\n\n\t\t\t\tZ_LVAL_P(ent->data) = php_parse_date(tmp, NULL);\n\t\t\t\t/* date out of range < 1969 or > 2038 */\n\t\t\t\tif (Z_LVAL_P(ent->data) == -1) {\n\t\t\t\t\tZVAL_STRINGL(ent->data, tmp, len, 0);\n\t\t\t\t} else {\n\t\t\t\t\tefree(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_deserialize_ex\n */\nint php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)\n{\n\twddx_stack stack;\n\tXML_Parser parser;\n\tst_entry *ent;\n\tint retval;\n\n\twddx_stack_init(&stack);\n\tparser = XML_ParserCreate(\"UTF-8\");\n\n\tXML_SetUserData(parser, &stack);\n\tXML_SetElementHandler(parser, php_wddx_push_element, php_wddx_pop_element);\n\tXML_SetCharacterDataHandler(parser, php_wddx_process_data);\n\n\tXML_Parse(parser, value, vallen, 1);\n\n\tXML_ParserFree(parser);\n\n\tif (stack.top == 1) {\n\t\twddx_stack_top(&stack, (void**)&ent);\n\t\t*return_value = *(ent->data);\n\t\tzval_copy_ctor(return_value);\n\t\tretval = SUCCESS;\n\t} else {\n\t\tretval = FAILURE;\n\t}\n\n\twddx_stack_destroy(&stack);\n\n\treturn retval;\n}\n/* }}} */\n\n/* {{{ proto string wddx_serialize_value(mixed var [, string comment])\n   Creates a new packet and serializes the given value */\nPHP_FUNCTION(wddx_serialize_value)\n{\n\tzval *var;\n\tchar *comment = NULL;\n\tint comment_len = 0;\n\twddx_packet *packet;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|s\", &var, &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, comment, comment_len);\n\tphp_wddx_serialize_var(packet, var, NULL, 0 TSRMLS_CC);\n\tphp_wddx_packet_end(packet);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ proto string wddx_serialize_vars(mixed var_name [, mixed ...])\n   Creates a new packet and serializes given variables into a struct */\nPHP_FUNCTION(wddx_serialize_vars)\n{\n\tint num_args, i;\n\twddx_packet *packet;\n\tzval ***args = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"+\", &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, NULL, 0);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, *args[i]);\n\t}\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\tphp_wddx_packet_end(packet);\n\n\tefree(args);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ php_wddx_constructor\n */\nwddx_packet *php_wddx_constructor(void)\n{\n\tsmart_str *packet;\n\n\tpacket = (smart_str *)emalloc(sizeof(smart_str));\n\tpacket->c = NULL;\n\n\treturn packet;\n}\n/* }}} */\n\n/* {{{ php_wddx_destructor\n */\nvoid php_wddx_destructor(wddx_packet *packet)\n{\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ proto resource wddx_packet_start([string comment])\n   Starts a WDDX packet with optional comment and returns the packet id */\nPHP_FUNCTION(wddx_packet_start)\n{\n\tchar *comment = NULL;\n\tint comment_len = 0;\n\twddx_packet *packet;\n\n\tcomment = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, comment, comment_len);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tZEND_REGISTER_RESOURCE(return_value, packet, le_wddx);\n}\n/* }}} */\n\n/* {{{ proto string wddx_packet_end(resource packet_id)\n   Ends specified WDDX packet and returns the string containing the packet */\nPHP_FUNCTION(wddx_packet_end)\n{\n\tzval *packet_id;\n\twddx_packet *packet = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &packet_id) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(packet, wddx_packet *, &packet_id, -1, \"WDDX packet ID\", le_wddx);\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\n\tphp_wddx_packet_end(packet);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\n\tzend_list_delete(Z_LVAL_P(packet_id));\n}\n/* }}} */\n\n/* {{{ proto int wddx_add_vars(resource packet_id,  mixed var_names [, mixed ...])\n   Serializes given variables and adds them to packet given by packet_id */\nPHP_FUNCTION(wddx_add_vars)\n{\n\tint num_args, i;\n\tzval ***args = NULL;\n\tzval *packet_id;\n\twddx_packet *packet = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r+\", &packet_id, &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!ZEND_FETCH_RESOURCE_NO_RETURN(packet, wddx_packet *, &packet_id, -1, \"WDDX packet ID\", le_wddx)) {\n\t\tefree(args);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!packet) {\n\t\tefree(args);\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, (*args[i]));\n\t}\n\n\tefree(args);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto mixed wddx_deserialize(mixed packet)\n   Deserializes given packet and returns a PHP value */\nPHP_FUNCTION(wddx_deserialize)\n{\n\tzval *packet;\n\tchar *payload;\n\tint payload_len;\n\tphp_stream *stream = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &packet) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (Z_TYPE_P(packet) == IS_STRING) {\n\t\tpayload \t= Z_STRVAL_P(packet);\n\t\tpayload_len = Z_STRLEN_P(packet);\n\t} else if (Z_TYPE_P(packet) == IS_RESOURCE) {\n\t\tphp_stream_from_zval(stream, &packet);\n\t\tif (stream) {\n\t\t\tpayload_len = php_stream_copy_to_mem(stream, &payload, PHP_STREAM_COPY_ALL, 0);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Expecting parameter 1 to be a string or a stream\");\n\t\treturn;\n\t}\n\n\tif (payload_len == 0) {\n\t\treturn;\n\t}\n\n\tphp_wddx_deserialize_ex(payload, payload_len, return_value);\n\n\tif (stream) {\n\t\tpefree(payload, 0);\n\t}\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t}\n",
        "src_path": "698a691724c0a949295991e5df091ce16f899e02___wddx.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/698a691724c0a949295991e5df091ce16f899e02",
        "commit_msg": "Fix bug #72750: wddx_deserialize null dereference",
        "test_func_diff": [
            {
                "fn": "ext/wddx/tests/bug72750.phpt",
                "patch": "@@ -0,0 +1,34 @@\n+--TEST--\n+Bug #72750: wddx_deserialize null dereference\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+\n+$xml = <<< XML\n+<?xml version='1.0'?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+<header/>\n+        <data>\n+                <struct>\n+                     <var name='aBinary'>\n+                         <binary length='11'>\\\\tYmluYXJRhdGE=</binary>\n+                     </var>\n+                 </struct>\n+        </data>\n+</wddxPacket>\n+XML;\n+\n+$array = wddx_deserialize($xml);\n+var_dump($array);\n+?>\n+--EXPECT--\n+array(1) {\n+  [\"aBinary\"]=>\n+  string(0) \"\"\n+}"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.26-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_698a691724c0a949295991e5df091ce16f899e02 More .INIs : CWD : /out/php___php-src/git_repo_dir_698a691724c0a949295991e5df091ce16f899e02 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/wddx/tests/bug72750.phpt]\r \r===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 0 ( 0.0%) ( 0.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 1 (100.0%) (100.0%) --------------------------------------------------------------------- Time taken : 0 seconds =====================================================================\n"
    },
    "1bd103df00f49cf4d4ade2cfe3f456ac058a4eae___gd.c": {
        "prefix": "PHP_FUNCTION(imagegrabwindow)\n{\n\tHWND window;\n\tlong client_area = 0;\n\tRECT rc = {0};\n\tRECT rc_win = {0};\n\tint Width, Height;\n\tHDC\t\thdc;\n\tHDC memDC;\n\tHBITMAP memBM;\n\tHBITMAP hOld;\n\tHINSTANCE handle;\n\tlong lwindow_handle;\n\ttypedef BOOL (WINAPI *tPrintWindow)(HWND, HDC,UINT);\n\ttPrintWindow pPrintWindow = 0;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|l\", &lwindow_handle, &client_area) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\twindow = (HWND) lwindow_handle;\n\n\tif (!IsWindow(window)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Invalid window handle\");\n\t\tRETURN_FALSE;\n\t}\n\n\thdc\t\t= GetDC(0);\n\n\tif (client_area) {\n\t\tGetClientRect(window, &rc);\n\t\tWidth = rc.right;\n\t\tHeight = rc.bottom;\n\t} else {\n\t\tGetWindowRect(window, &rc);\n\t\tWidth\t= rc.right - rc.left;\n\t\tHeight\t= rc.bottom - rc.top;\n\t}\n\n\tWidth\t\t= (Width/4)*4;\n\n\tmemDC\t= CreateCompatibleDC(hdc);\n\tmemBM\t= CreateCompatibleBitmap(hdc, Width, Height);\n\thOld\t= (HBITMAP) SelectObject (memDC, memBM);\n\n\n\thandle = LoadLibrary(\"User32.dll\");\n\tif ( handle == 0 ) {\n\t\tgoto clean;\n\t}\n\tpPrintWindow = (tPrintWindow) GetProcAddress(handle, \"PrintWindow\");\n\n\tif ( pPrintWindow )  {\n\t\tpPrintWindow(window, memDC, (UINT) client_area);\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Windows API too old\");\n\t\tgoto clean;\n\t}\n\n\tFreeLibrary(handle);\n\n\tim = gdImageCreateTrueColor(Width, Height);\n\tif (im) {\n\t\tint x,y;\n\t\tfor (y=0; y <= Height; y++) {\n\t\t\tfor (x=0; x <= Width; x++) {\n\t\t\t\tint c = GetPixel(memDC, x,y);\n\t\t\t\tgdImageSetPixel(im, x, y, gdTrueColor(GetRValue(c), GetGValue(c), GetBValue(c)));\n\t\t\t}\n\t\t}\n\t}\n\nclean:\n\tSelectObject(memDC,hOld);\n\tDeleteObject(memBM);\n\tDeleteDC(memDC);\n\tReleaseDC( 0, hdc );\n\n\tif (!im) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource imagegrabscreen()\n   Grab a screenshot */\nPHP_FUNCTION(imagegrabscreen)\n{\n\tHWND window = GetDesktopWindow();\n\tRECT rc = {0};\n\tint Width, Height;\n\tHDC\t\thdc;\n\tHDC memDC;\n\tHBITMAP memBM;\n\tHBITMAP hOld;\n\ttypedef BOOL (WINAPI *tPrintWindow)(HWND, HDC,UINT);\n\ttPrintWindow pPrintWindow = 0;\n\tgdImagePtr im;\n\thdc\t\t= GetDC(0);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!hdc) {\n\t\tRETURN_FALSE;\n\t}\n\n\tGetWindowRect(window, &rc);\n\tWidth\t= rc.right - rc.left;\n\tHeight\t= rc.bottom - rc.top;\n\n\tWidth\t\t= (Width/4)*4;\n\n\tmemDC\t= CreateCompatibleDC(hdc);\n\tmemBM\t= CreateCompatibleBitmap(hdc, Width, Height);\n\thOld\t= (HBITMAP) SelectObject (memDC, memBM);\n\tBitBlt( memDC, 0, 0, Width, Height , hdc, rc.left, rc.top , SRCCOPY );\n\n\tim = gdImageCreateTrueColor(Width, Height);\n\tif (im) {\n\t\tint x,y;\n\t\tfor (y=0; y <= Height; y++) {\n\t\t\tfor (x=0; x <= Width; x++) {\n\t\t\t\tint c = GetPixel(memDC, x,y);\n\t\t\t\tgdImageSetPixel(im, x, y, gdTrueColor(GetRValue(c), GetGValue(c), GetBValue(c)));\n\t\t\t}\n\t\t}\n\t}\n\n\tSelectObject(memDC,hOld);\n\tDeleteObject(memBM);\n\tDeleteDC(memDC);\n\tReleaseDC( 0, hdc );\n\n\tif (!im) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n\t}\n}\n/* }}} */\n#endif /* PHP_WIN32 */\n\n/* {{{ proto resource imagerotate(resource src_im, float angle, int bgdcolor [, int ignoretransparent])\n   Rotate an image using a custom angle */\nPHP_FUNCTION(imagerotate)\n{\n\tzval *SIM;\n\tgdImagePtr im_dst, im_src;\n\tdouble degrees;\n\tlong color;\n\tlong ignoretransparent = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rdl|l\", &SIM, &degrees, &color, &ignoretransparent) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tim_dst = gdImageRotateInterpolated(im_src, (const float)degrees, color);\n\n\tif (im_dst != NULL) {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_dst, le_gd);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool imagesettile(resource image, resource tile)\n   Set the tile image to $tile when filling $image with the \"IMG_COLOR_TILED\" color */\nPHP_FUNCTION(imagesettile)\n{\n\tzval *IM, *TILE;\n\tgdImagePtr im, tile;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rr\", &IM, &TILE) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(tile, gdImagePtr, &TILE, -1, \"Image\", le_gd);\n\n\tgdImageSetTile(im, tile);\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagesetbrush(resource image, resource brush)\n   Set the brush image to $brush when filling $image with the \"IMG_COLOR_BRUSHED\" color */\nPHP_FUNCTION(imagesetbrush)\n{\n\tzval *IM, *TILE;\n\tgdImagePtr im, tile;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rr\", &IM, &TILE) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(tile, gdImagePtr, &TILE, -1, \"Image\", le_gd);\n\n\tgdImageSetBrush(im, tile);\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto resource imagecreate(int x_size, int y_size)\n   Create a new image */\nPHP_FUNCTION(imagecreate)\n{\n\tlong x_size, y_size;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ll\", &x_size, &y_size) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (x_size <= 0 || y_size <= 0 || x_size >= INT_MAX || y_size >= INT_MAX) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid image dimensions\");\n\t\tRETURN_FALSE;\n\t}\n\n\tim = gdImageCreate(x_size, y_size);\n\n\tif (!im) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n}\n/* }}} */\n\n/* {{{ proto int imagetypes(void)\n   Return the types of images supported in a bitfield - 1=GIF, 2=JPEG, 4=PNG, 8=WBMP, 16=XPM */\nPHP_FUNCTION(imagetypes)\n{\n\tint ret=0;\n\tret = 1;\n#ifdef HAVE_GD_JPG\n\tret |= 2;\n#endif\n#ifdef HAVE_GD_PNG\n\tret |= 4;\n#endif\n\tret |= 8;\n#if defined(HAVE_GD_XPM)\n\tret |= 16;\n#endif\n#ifdef HAVE_GD_WEBP\n\tret |= 32;\n#endif\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ _php_ctx_getmbi\n */\n\nstatic int _php_ctx_getmbi(gdIOCtx *ctx)\n{\n\tint i, mbi = 0;\n\n\tdo {\n\t\ti = (ctx->getC)(ctx);\n\t\tif (i < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tmbi = (mbi << 7) | (i & 0x7f);\n\t} while (i & 0x80);\n\n\treturn mbi;\n}\n/* }}} */\n\n/* {{{ _php_image_type\n */\nstatic const char php_sig_gd2[3] = {'g', 'd', '2'};\n\nstatic int _php_image_type (char data[8])\n{\n\t/* Based on ext/standard/image.c */\n\n\tif (data == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (!memcmp(data, php_sig_gd2, 3)) {\n\t\treturn PHP_GDIMG_TYPE_GD2;\n\t} else if (!memcmp(data, php_sig_jpg, 3)) {\n\t\treturn PHP_GDIMG_TYPE_JPG;\n\t} else if (!memcmp(data, php_sig_png, 3)) {\n\t\tif (!memcmp(data, php_sig_png, 8)) {\n\t\t\treturn PHP_GDIMG_TYPE_PNG;\n\t\t}\n\t} else if (!memcmp(data, php_sig_gif, 3)) {\n\t\treturn PHP_GDIMG_TYPE_GIF;\n\t}\n\telse {\n\t\tgdIOCtx *io_ctx;\n\t\tio_ctx = gdNewDynamicCtxEx(8, data, 0);\n\t\tif (io_ctx) {\n\t\t\tif (_php_ctx_getmbi(io_ctx) == 0 && _php_ctx_getmbi(io_ctx) >= 0) {\n\t\t\t\tio_ctx->gd_free(io_ctx);\n\t\t\t\treturn PHP_GDIMG_TYPE_WBM;\n\t\t\t} else {\n\t\t\t\tio_ctx->gd_free(io_ctx);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n/* }}} */\n\n/* {{{ _php_image_create_from_string\n */\ngdImagePtr _php_image_create_from_string(zval **data, char *tn, gdImagePtr (*ioctx_func_p)() TSRMLS_DC)\n{\n\tgdImagePtr im;\n\tgdIOCtx *io_ctx;\n\n\tio_ctx = gdNewDynamicCtxEx(Z_STRLEN_PP(data), Z_STRVAL_PP(data), 0);\n\n\tif (!io_ctx) {\n\t\treturn NULL;\n\t}\n\n\tim = (*ioctx_func_p)(io_ctx);\n\tif (!im) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Passed data is not in '%s' format\", tn);\n\t\tio_ctx->gd_free(io_ctx);\n\t\treturn NULL;\n\t}\n\n\tio_ctx->gd_free(io_ctx);\n\n\treturn im;\n}\n/* }}} */\n\n/* {{{ proto resource imagecreatefromstring(string image)\n   Create a new image from the image stream in the string */\nPHP_FUNCTION(imagecreatefromstring)\n{\n\tzval **data;\n\tgdImagePtr im;\n\tint imtype;\n\tchar sig[8];\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z\", &data) == FAILURE) {\n\t\treturn;\n\t}\n\n\tconvert_to_string_ex(data);\n\tif (Z_STRLEN_PP(data) < 8) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty string or invalid image\");\n\t\tRETURN_FALSE;\n\t}\n\n\tmemcpy(sig, Z_STRVAL_PP(data), 8);\n\n\timtype = _php_image_type(sig);\n\n\tswitch (imtype) {\n\t\tcase PHP_GDIMG_TYPE_JPG:\n#ifdef HAVE_GD_JPG\n\t\t\tim = _php_image_create_from_string(data, \"JPEG\", gdImageCreateFromJpegCtx TSRMLS_CC);\n#else\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No JPEG support in this PHP build\");\n\t\t\tRETURN_FALSE;\n#endif\n\t\t\tbreak;\n\n\t\tcase PHP_GDIMG_TYPE_PNG:\n#ifdef HAVE_GD_PNG\n\t\t\tim = _php_image_create_from_string(data, \"PNG\", gdImageCreateFromPngCtx TSRMLS_CC);\n#else\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No PNG support in this PHP build\");\n\t\t\tRETURN_FALSE;\n#endif\n\t\t\tbreak;\n\n\t\tcase PHP_GDIMG_TYPE_GIF:\n\t\t\tim = _php_image_create_from_string(data, \"GIF\", gdImageCreateFromGifCtx TSRMLS_CC);\n\t\t\tbreak;\n\n\t\tcase PHP_GDIMG_TYPE_WBM:\n\t\t\tim = _php_image_create_from_string(data, \"WBMP\", gdImageCreateFromWBMPCtx TSRMLS_CC);\n\t\t\tbreak;\n\n\t\tcase PHP_GDIMG_TYPE_GD2:\n\t\t\tim = _php_image_create_from_string(data, \"GD2\", gdImageCreateFromGd2Ctx TSRMLS_CC);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Data is not in a recognized format\");\n\t\t\tRETURN_FALSE;\n\t}\n\n\tif (!im) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Couldn't create GD Image Stream out of Data\");\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n}\n/* }}} */\n\n/* {{{ _php_image_create_from\n */\nstatic void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, gdImagePtr (*func_p)(), gdImagePtr (*ioctx_func_p)())\n{\n\tchar *file;\n\tint file_len;\n\tlong srcx, srcy, width, height;\n\tgdImagePtr im = NULL;\n\tphp_stream *stream;\n\tFILE * fp = NULL;\n\tlong ignore_warning;\n\n\tif (image_type == PHP_GDIMG_TYPE_GD2PART) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pllll\", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tif (width < 1 || height < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Zero width or height not allowed\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p\", &file, &file_len) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tstream = php_stream_open_wrapper(file, \"rb\", REPORT_ERRORS|IGNORE_PATH|IGNORE_URL_WIN, NULL);\n\tif (stream == NULL)\t{\n\t\tRETURN_FALSE;\n\t}\n\n\t/* try and avoid allocating a FILE* if the stream is not naturally a FILE* */\n\tif (php_stream_is(stream, PHP_STREAM_IS_STDIO))\t{\n\t\tif (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS)) {\n\t\t\tgoto out_err;\n\t\t}\n\t} else if (ioctx_func_p) {\n\t\t/* we can create an io context */\n\t\tgdIOCtx* io_ctx;\n\t\tsize_t buff_size;\n\t\tchar *buff;\n\n\t\t/* needs to be malloc (persistent) - GD will free() it later */\n\t\tbuff_size = php_stream_copy_to_mem(stream, &buff, PHP_STREAM_COPY_ALL, 1);\n\n\t\tif (!buff_size) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Cannot read image data\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tio_ctx = gdNewDynamicCtxEx(buff_size, buff, 0);\n\t\tif (!io_ctx) {\n\t\t\tpefree(buff, 1);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Cannot allocate GD IO context\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (image_type == PHP_GDIMG_TYPE_GD2PART) {\n\t\t\tim = (*ioctx_func_p)(io_ctx, srcx, srcy, width, height);\n\t\t} else {\n\t\t\tim = (*ioctx_func_p)(io_ctx);\n\t\t}\n\t\tio_ctx->gd_free(io_ctx);\n\t\tpefree(buff, 1);\n\t}\n\telse if (php_stream_can_cast(stream, PHP_STREAM_AS_STDIO)) {\n\t\t/* try and force the stream to be FILE* */\n\t\tif (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO | PHP_STREAM_CAST_TRY_HARD, (void **) &fp, REPORT_ERRORS)) {\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (!im && fp) {\n\t\tswitch (image_type) {\n\t\t\tcase PHP_GDIMG_TYPE_GD2PART:\n\t\t\t\tim = (*func_p)(fp, srcx, srcy, width, height);\n\t\t\t\tbreak;\n#if defined(HAVE_GD_XPM)\n\t\t\tcase PHP_GDIMG_TYPE_XPM:\n\t\t\t\tim = gdImageCreateFromXpm(file);\n\t\t\t\tbreak;\n#endif\n\n#ifdef HAVE_GD_JPG\n\t\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\t\tignore_warning = INI_INT(\"gd.jpeg_ignore_warning\");\n\t\t\t\tim = gdImageCreateFromJpegEx(fp, ignore_warning);\n\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\tim = (*func_p)(fp);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfflush(fp);\n\t}\n\n/* register_im: */\n\tif (im) {\n\t\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n\t\tphp_stream_close(stream);\n\t\treturn;\n\t}\n\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"'%s' is not a valid %s file\", file, tn);\nout_err:\n\tphp_stream_close(stream);\n\tRETURN_FALSE;\n\n}\n/* }}} */\n\n/* {{{ proto resource imagecreatefromgif(string filename)\n   Create a new image from GIF file or URL */\nPHP_FUNCTION(imagecreatefromgif)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GIF, \"GIF\", gdImageCreateFromGif, gdImageCreateFromGifCtx);\n}\n/* }}} */\n\n#ifdef HAVE_GD_JPG\n/* {{{ proto resource imagecreatefromjpeg(string filename)\n   Create a new image from JPEG file or URL */\nPHP_FUNCTION(imagecreatefromjpeg)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_JPG, \"JPEG\", gdImageCreateFromJpeg, gdImageCreateFromJpegCtx);\n}\n/* }}} */\n#endif /* HAVE_GD_JPG */\n\n#ifdef HAVE_GD_PNG\n/* {{{ proto resource imagecreatefrompng(string filename)\n   Create a new image from PNG file or URL */\nPHP_FUNCTION(imagecreatefrompng)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, \"PNG\", gdImageCreateFromPng, gdImageCreateFromPngCtx);\n}\n/* }}} */\n#endif /* HAVE_GD_PNG */\n\n#ifdef HAVE_GD_WEBP\n/* {{{ proto resource imagecreatefromwebp(string filename)\n   Create a new image from WEBP file or URL */\nPHP_FUNCTION(imagecreatefromwebp)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WEBP, \"WEBP\", gdImageCreateFromWebp, gdImageCreateFromWebpCtx);\n}\n/* }}} */\n#endif /* HAVE_GD_VPX */\n\n/* {{{ proto resource imagecreatefromxbm(string filename)\n   Create a new image from XBM file or URL */\nPHP_FUNCTION(imagecreatefromxbm)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XBM, \"XBM\", gdImageCreateFromXbm, NULL);\n}\n/* }}} */\n\n#if defined(HAVE_GD_XPM)\n/* {{{ proto resource imagecreatefromxpm(string filename)\n   Create a new image from XPM file or URL */\nPHP_FUNCTION(imagecreatefromxpm)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XPM, \"XPM\", gdImageCreateFromXpm, NULL);\n}\n/* }}} */\n#endif\n\n/* {{{ proto resource imagecreatefromwbmp(string filename)\n   Create a new image from WBMP file or URL */\nPHP_FUNCTION(imagecreatefromwbmp)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WBM, \"WBMP\", gdImageCreateFromWBMP, gdImageCreateFromWBMPCtx);\n}\n/* }}} */\n\n/* {{{ proto resource imagecreatefromgd(string filename)\n   Create a new image from GD file or URL */\nPHP_FUNCTION(imagecreatefromgd)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD, \"GD\", gdImageCreateFromGd, gdImageCreateFromGdCtx);\n}\n/* }}} */\n\n/* {{{ proto resource imagecreatefromgd2(string filename)\n   Create a new image from GD2 file or URL */\nPHP_FUNCTION(imagecreatefromgd2)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2, \"GD2\", gdImageCreateFromGd2, gdImageCreateFromGd2Ctx);\n}\n/* }}} */\n\n/* {{{ proto resource imagecreatefromgd2part(string filename, int srcX, int srcY, int width, int height)\n   Create a new image from a given part of GD2 file or URL */\nPHP_FUNCTION(imagecreatefromgd2part)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2PART, \"GD2\", gdImageCreateFromGd2Part, gdImageCreateFromGd2PartCtx);\n}\n/* }}} */\n\n/* {{{ _php_image_output\n */\nstatic void _php_image_output(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, void (*func_p)())\n{\n\tzval *imgind;\n\tchar *file = NULL;\n\tlong quality = 0, type = 0;\n\tgdImagePtr im;\n\tchar *fn = NULL;\n\tFILE *fp;\n\tint file_len = 0, argc = ZEND_NUM_ARGS();\n\tint q = -1, i, t = 1;\n\n\t/* The quality parameter for Wbmp stands for the threshold when called from image2wbmp() */\n\t/* When called from imagewbmp() the quality parameter stands for the foreground color. Default: black. */\n\t/* The quality parameter for gd2 stands for chunk size */\n\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"r|pll\", &imgind, &file, &file_len, &quality, &type) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &imgind, -1, \"Image\", le_gd);\n\n\tif (argc > 1) {\n\t\tfn = file;\n\t\tif (argc == 3) {\n\t\t\tq = quality;\n\t\t}\n\t\tif (argc == 4) {\n\t\t\tt = type;\n\t\t}\n\t}\n\n\tif (argc >= 2 && file_len) {\n\t\tPHP_GD_CHECK_OPEN_BASEDIR(fn, \"Invalid filename\");\n\n\t\tfp = VCWD_FOPEN(fn, \"wb\");\n\t\tif (!fp) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' for writing\", fn);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tswitch (image_type) {\n\t\t\tcase PHP_GDIMG_CONVERT_WBM:\n\t\t\t\tif (q == -1) {\n\t\t\t\t\tq = 0;\n\t\t\t\t} else if (q < 0 || q > 255) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid threshold value '%d'. It must be between 0 and 255\", q);\n\t\t\t\t\tq = 0;\n\t\t\t\t}\n\t\t\t\tgdImageWBMP(im, q, fp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\t\t(*func_p)(im, fp, q);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_WBM:\n\t\t\t\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\t\t\t\tif (gdImageRed(im, i) == 0) break;\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, i, fp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_GD:\n\t\t\t\tif (im->trueColor){\n\t\t\t\t\tgdImageTrueColorToPalette(im,1,256);\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, fp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_GD2:\n\t\t\t\tif (q == -1) {\n\t\t\t\t\tq = 128;\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, fp, q, t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (q == -1) {\n\t\t\t\t\tq = 128;\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, fp, q, t);\n\t\t\t\tbreak;\n\t\t}\n\t\tfflush(fp);\n\t\tfclose(fp);\n\t} else {\n\t\tint   b;\n\t\tFILE *tmp;\n\t\tchar  buf[4096];\n\t\tchar *path;\n\n\t\ttmp = php_open_temporary_file(NULL, NULL, &path TSRMLS_CC);\n\t\tif (tmp == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open temporary file\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tswitch (image_type) {\n\t\t\tcase PHP_GDIMG_CONVERT_WBM:\n \t\t\t\tif (q == -1) {\n  \t\t\t\t\tq = 0;\n  \t\t\t\t} else if (q < 0 || q > 255) {\n  \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid threshold value '%d'. It must be between 0 and 255\", q);\n \t\t\t\t\tq = 0;\n  \t\t\t\t}\n\t\t\t\tgdImageWBMP(im, q, tmp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\t\t(*func_p)(im, tmp, q);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_WBM:\n\t\t\t\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\t\t\t\tif (gdImageRed(im, i) == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, q, tmp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_GD:\n\t\t\t\tif (im->trueColor) {\n\t\t\t\t\tgdImageTrueColorToPalette(im,1,256);\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, tmp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_GD2:\n\t\t\t\tif (q == -1) {\n\t\t\t\t\tq = 128;\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, tmp, q, t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t(*func_p)(im, tmp);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfseek(tmp, 0, SEEK_SET);\n\n#if APACHE && defined(CHARSET_EBCDIC)\n\t\t/* XXX this is unlikely to work any more thies@thieso.net */\n\n\t\t/* This is a binary file already: avoid EBCDIC->ASCII conversion */\n\t\tap_bsetflag(php3_rqst->connection->client, B_EBCDIC2ASCII, 0);\n#endif\n\t\twhile ((b = fread(buf, 1, sizeof(buf), tmp)) > 0) {\n\t\t\tphp_write(buf, b TSRMLS_CC);\n\t\t}\n\n\t\tfclose(tmp);\n\t\tVCWD_UNLINK((const char *)path); /* make sure that the temporary file is removed */\n\t\tefree(path);\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto int imagexbm(int im, string filename [, int foreground])\n   Output XBM image to browser or file */\nPHP_FUNCTION(imagexbm)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XBM, \"XBM\", gdImageXbmCtx);\n}\n/* }}} */\n\n/* {{{ proto bool imagegif(resource im [, string filename])\n   Output GIF image to browser or file */\nPHP_FUNCTION(imagegif)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GIF, \"GIF\", gdImageGifCtx);\n}\n/* }}} */\n\n#ifdef HAVE_GD_PNG\n/* {{{ proto bool imagepng(resource im [, string filename])\n   Output PNG image to browser or file */\nPHP_FUNCTION(imagepng)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, \"PNG\", gdImagePngCtxEx);\n}\n/* }}} */\n#endif /* HAVE_GD_PNG */\n\n\n#ifdef HAVE_GD_WEBP\n/* {{{ proto bool imagewebp(resource im [, string filename[, quality]] )\n   Output WEBP image to browser or file */\nPHP_FUNCTION(imagewebp)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WEBP, \"WEBP\", gdImageWebpCtx);\n}\n/* }}} */\n#endif /* HAVE_GD_WEBP */\n\n\n#ifdef HAVE_GD_JPG\n/* {{{ proto bool imagejpeg(resource im [, string filename [, int quality]])\n   Output JPEG image to browser or file */\nPHP_FUNCTION(imagejpeg)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_JPG, \"JPEG\", gdImageJpegCtx);\n}\n/* }}} */\n#endif /* HAVE_GD_JPG */\n\n/* {{{ proto bool imagewbmp(resource im [, string filename, [, int foreground]])\n   Output WBMP image to browser or file */\nPHP_FUNCTION(imagewbmp)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WBM, \"WBMP\", gdImageWBMPCtx);\n}\n/* }}} */\n\n/* {{{ proto bool imagegd(resource im [, string filename])\n   Output GD image to browser or file */\nPHP_FUNCTION(imagegd)\n{\n\t_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD, \"GD\", gdImageGd);\n}\n/* }}} */\n\n/* {{{ proto bool imagegd2(resource im [, string filename, [, int chunk_size, [, int type]]])\n   Output GD2 image to browser or file */\nPHP_FUNCTION(imagegd2)\n{\n\t_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2, \"GD2\", gdImageGd2);\n}\n/* }}} */\n\n/* {{{ proto bool imagedestroy(resource im)\n   Destroy an image */\nPHP_FUNCTION(imagedestroy)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &IM) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tzend_list_delete(Z_LVAL_P(IM));\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n\n/* {{{ proto int imagecolorallocate(resource im, int red, int green, int blue)\n   Allocate a color for an image */\nPHP_FUNCTION(imagecolorallocate)\n{\n\tzval *IM;\n\tlong red, green, blue;\n\tgdImagePtr im;\n\tint ct = (-1);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tct = gdImageColorAllocate(im, red, green, blue);\n\tif (ct < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_LONG(ct);\n}\n/* }}} */\n\n/* {{{ proto void imagepalettecopy(resource dst, resource src)\n   Copy the palette from the src image onto the dst image */\nPHP_FUNCTION(imagepalettecopy)\n{\n\tzval *dstim, *srcim;\n\tgdImagePtr dst, src;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rr\", &dstim, &srcim) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(dst, gdImagePtr, &dstim, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(src, gdImagePtr, &srcim, -1, \"Image\", le_gd);\n\n\tgdImagePaletteCopy(dst, src);\n}\n/* }}} */\n\n/* {{{ proto int imagecolorat(resource im, int x, int y)\n   Get the index of the color of a pixel */\nPHP_FUNCTION(imagecolorat)\n{\n\tzval *IM;\n\tlong x, y;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rll\", &IM, &x, &y) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (gdImageTrueColor(im)) {\n\t\tif (im->tpixels && gdImageBoundsSafe(im, x, y)) {\n\t\t\tRETURN_LONG(gdImageTrueColorPixel(im, x, y));\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"%ld,%ld is out of bounds\", x, y);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tif (im->pixels && gdImageBoundsSafe(im, x, y)) {\n\t\t\tRETURN_LONG(im->pixels[y][x]);\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"%ld,%ld is out of bounds\", x, y);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto int imagecolorclosest(resource im, int red, int green, int blue)\n   Get the index of the closest color to the specified color */\nPHP_FUNCTION(imagecolorclosest)\n{\n\tzval *IM;\n\tlong red, green, blue;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageColorClosest(im, red, green, blue));\n}\n/* }}} */\n\n/* {{{ proto int imagecolorclosesthwb(resource im, int red, int green, int blue)\n   Get the index of the color which has the hue, white and blackness nearest to the given color */\nPHP_FUNCTION(imagecolorclosesthwb)\n{\n\tzval *IM;\n\tlong red, green, blue;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageColorClosestHWB(im, red, green, blue));\n}\n/* }}} */\n\n/* {{{ proto bool imagecolordeallocate(resource im, int index)\n   De-allocate a color for an image */\nPHP_FUNCTION(imagecolordeallocate)\n{\n\tzval *IM;\n\tlong index;\n\tint col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &IM, &index) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\t/* We can return right away for a truecolor image as deallocating colours is meaningless here */\n\tif (gdImageTrueColor(im)) {\n\t\tRETURN_TRUE;\n\t}\n\n\tcol = index;\n\n\tif (col >= 0 && col < gdImageColorsTotal(im)) {\n\t\tgdImageColorDeallocate(im, col);\n\t\tRETURN_TRUE;\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Color index %d out of range\",\tcol);\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto int imagecolorresolve(resource im, int red, int green, int blue)\n   Get the index of the specified color or its closest possible alternative */\nPHP_FUNCTION(imagecolorresolve)\n{\n\tzval *IM;\n\tlong red, green, blue;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageColorResolve(im, red, green, blue));\n}\n/* }}} */\n\n/* {{{ proto int imagecolorexact(resource im, int red, int green, int blue)\n   Get the index of the specified color */\nPHP_FUNCTION(imagecolorexact)\n{\n\tzval *IM;\n\tlong red, green, blue;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageColorExact(im, red, green, blue));\n}\n/* }}} */\n\n/* {{{ proto void imagecolorset(resource im, int col, int red, int green, int blue)\n   Set the color for the specified palette index */\nPHP_FUNCTION(imagecolorset)\n{\n\tzval *IM;\n\tlong color, red, green, blue, alpha = 0;\n\tint col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rllll|l\", &IM, &color, &red, &green, &blue, &alpha) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tcol = color;\n\n\tif (col >= 0 && col < gdImageColorsTotal(im)) {\n\t\tim->red[col]   = red;\n\t\tim->green[col] = green;\n\t\tim->blue[col]  = blue;\n\t\tim->alpha[col]  = alpha;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto array imagecolorsforindex(resource im, int col)\n   Get the colors for an index */\nPHP_FUNCTION(imagecolorsforindex)\n{\n\tzval *IM;\n\tlong index;\n\tint col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &IM, &index) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tcol = index;\n\n\tif ((col >= 0 && gdImageTrueColor(im)) || (!gdImageTrueColor(im) && col >= 0 && col < gdImageColorsTotal(im))) {\n\t\tarray_init(return_value);\n\n\t\tadd_assoc_long(return_value,\"red\",  gdImageRed(im,col));\n\t\tadd_assoc_long(return_value,\"green\", gdImageGreen(im,col));\n\t\tadd_assoc_long(return_value,\"blue\", gdImageBlue(im,col));\n\t\tadd_assoc_long(return_value,\"alpha\", gdImageAlpha(im,col));\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Color index %d out of range\", col);\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool imagegammacorrect(resource im, float inputgamma, float outputgamma)\n   Apply a gamma correction to a GD image */\nPHP_FUNCTION(imagegammacorrect)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tint i;\n\tdouble input, output;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rdd\", &IM, &input, &output) == FAILURE) {\n\t\treturn;\n\t}\n\n",
        "suffix": "\n\tif (gdImageTrueColor(im))\t{\n\t\tint x, y, c;\n\n\t\tfor (y = 0; y < gdImageSY(im); y++)\t{\n\t\t\tfor (x = 0; x < gdImageSX(im); x++)\t{\n\t\t\t\tc = gdImageGetPixel(im, x, y);\n\t\t\t\tgdImageSetPixel(im, x, y,\n\t\t\t\t\tgdTrueColorAlpha(\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetRed(c)   / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetGreen(c) / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetBlue(c)  / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\tgdTrueColorGetAlpha(c)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tRETURN_TRUE;\n\t}\n\n\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\tim->red[i]   = (int)((pow((pow((im->red[i]   / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->green[i] = (int)((pow((pow((im->green[i] / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->blue[i]  = (int)((pow((pow((im->blue[i]  / 255.0), input)), 1.0 / output) * 255) + .5);\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagesetpixel(resource im, int x, int y, int col)\n   Set a single pixel */\nPHP_FUNCTION(imagesetpixel)\n{\n\tzval *IM;\n\tlong x, y, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &x, &y, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageSetPixel(im, x, y, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imageline(resource im, int x1, int y1, int x2, int y2, int col)\n   Draw a line */\nPHP_FUNCTION(imageline)\n{\n\tzval *IM;\n\tlong x1, y1, x2, y2, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllll\", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n#ifdef HAVE_GD_BUNDLED\n\tif (im->antialias) {\n\t\tgdImageAALine(im, x1, y1, x2, y2, col);\n\t} else\n#endif\n\t{\n\t\tgdImageLine(im, x1, y1, x2, y2, col);\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagedashedline(resource im, int x1, int y1, int x2, int y2, int col)\n   Draw a dashed line */\nPHP_FUNCTION(imagedashedline)\n{\n\tzval *IM;\n\tlong x1, y1, x2, y2, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllll\", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageDashedLine(im, x1, y1, x2, y2, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagerectangle(resource im, int x1, int y1, int x2, int y2, int col)\n   Draw a rectangle */\nPHP_FUNCTION(imagerectangle)\n{\n\tzval *IM;\n\tlong x1, y1, x2, y2, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllll\", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageRectangle(im, x1, y1, x2, y2, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagefilledrectangle(resource im, int x1, int y1, int x2, int y2, int col)\n   Draw a filled rectangle */\nPHP_FUNCTION(imagefilledrectangle)\n{\n\tzval *IM;\n\tlong x1, y1, x2, y2, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllll\", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageFilledRectangle(im, x1, y1, x2, y2, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagearc(resource im, int cx, int cy, int w, int h, int s, int e, int col)\n   Draw a partial ellipse */\nPHP_FUNCTION(imagearc)\n{\n\tzval *IM;\n\tlong cx, cy, w, h, ST, E, col;\n\tgdImagePtr im;\n\tint e, st;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllllll\", &IM, &cx, &cy, &w, &h, &ST, &E, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\te = E;\n\tif (e < 0) {\n\t\te %= 360;\n\t}\n\n\tst = ST;\n\tif (st < 0) {\n\t\tst %= 360;\n\t}\n\n\tgdImageArc(im, cx, cy, w, h, st, e, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imageellipse(resource im, int cx, int cy, int w, int h, int color)\n   Draw an ellipse */\nPHP_FUNCTION(imageellipse)\n{\n\tzval *IM;\n\tlong cx, cy, w, h, color;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllll\", &IM, &cx, &cy, &w, &h, &color) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tgdImageEllipse(im, cx, cy, w, h, color);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagefilltoborder(resource im, int x, int y, int border, int col)\n   Flood fill to specific color */\nPHP_FUNCTION(imagefilltoborder)\n{\n\tzval *IM;\n\tlong x, y, border, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rllll\", &IM, &x, &y, &border, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageFillToBorder(im, x, y, border, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagefill(resource im, int x, int y, int col)\n   Flood fill */\nPHP_FUNCTION(imagefill)\n{\n\tzval *IM;\n\tlong x, y, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &x, &y, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageFill(im, x, y, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto int imagecolorstotal(resource im)\n   Find out the number of colors in an image's palette */\nPHP_FUNCTION(imagecolorstotal)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &IM) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageColorsTotal(im));\n}\n/* }}} */\n\n/* {{{ proto int imagecolortransparent(resource im [, int col])\n   Define a color as transparent */\nPHP_FUNCTION(imagecolortransparent)\n{\n\tzval *IM;\n\tlong COL = 0;\n\tgdImagePtr im;\n\tint argc = ZEND_NUM_ARGS();\n\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"r|l\", &IM, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (argc > 1) {\n\t\tgdImageColorTransparent(im, COL);\n\t}\n\n\tRETURN_LONG(gdImageGetTransparent(im));\n}\n/* }}} */\n\n/* {{{ proto int imageinterlace(resource im [, int interlace])\n   Enable or disable interlace */\nPHP_FUNCTION(imageinterlace)\n{\n\tzval *IM;\n\tint argc = ZEND_NUM_ARGS();\n\tlong INT = 0;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"r|l\", &IM, &INT) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (argc > 1) {\n\t\tgdImageInterlace(im, INT);\n\t}\n\n\tRETURN_LONG(gdImageGetInterlaced(im));\n}\n/* }}} */\n\n/* {{{ php_imagepolygon\n   arg = 0  normal polygon\n   arg = 1  filled polygon */\n/* im, points, num_points, col */\nstatic void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n{\n\tzval *IM, *POINTS;\n\tlong NPOINTS, COL;\n\tzval **var = NULL;\n\tgdImagePtr im;\n\tgdPointPtr points;\n\tint npoints, col, nelem, i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rall\", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tnpoints = NPOINTS;\n\tcol = COL;\n\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));\n\tif (nelem < 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have at least 3 points in your array\");\n\t\tRETURN_FALSE;\n\t}\n\tif (npoints <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must give a positive number of points\");\n\t\tRETURN_FALSE;\n\t}\n\tif (nelem < npoints * 2) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Trying to use %d points in array with only %d points\", npoints, nelem/2);\n\t\tRETURN_FALSE;\n\t}\n\n\tpoints = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);\n\n\tfor (i = 0; i < npoints; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **var;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\tpoints[i].x = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\tpoints[i].x = Z_LVAL_PP(var);\n\t\t\t}\n\t\t}\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **var;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\tpoints[i].y = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\tpoints[i].y = Z_LVAL_PP(var);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (filled) {\n\t\tgdImageFilledPolygon(im, points, npoints, col);\n\t} else {\n\t\tgdImagePolygon(im, points, npoints, col);\n\t}\n\n\tefree(points);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagepolygon(resource im, array point, int num_points, int col)\n   Draw a polygon */\nPHP_FUNCTION(imagepolygon)\n{\n\tphp_imagepolygon(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto bool imagefilledpolygon(resource im, array point, int num_points, int col)\n   Draw a filled polygon */\nPHP_FUNCTION(imagefilledpolygon)\n{\n\tphp_imagepolygon(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ php_find_gd_font\n */\nstatic gdFontPtr php_find_gd_font(int size TSRMLS_DC)\n{\n\tgdFontPtr font;\n\tint ind_type;\n\n\tswitch (size) {\n\t\tcase 1:\n\t\t\t font = gdFontTiny;\n\t\t\t break;\n\t\tcase 2:\n\t\t\t font = gdFontSmall;\n\t\t\t break;\n\t\tcase 3:\n\t\t\t font = gdFontMediumBold;\n\t\t\t break;\n\t\tcase 4:\n\t\t\t font = gdFontLarge;\n\t\t\t break;\n\t\tcase 5:\n\t\t\t font = gdFontGiant;\n\t\t\t break;\n\t\tdefault:\n\t\t\tfont = zend_list_find(size - 5, &ind_type);\n\t\t\t if (!font || ind_type != le_gd_font) {\n\t\t\t\t  if (size < 1) {\n\t\t\t\t\t   font = gdFontTiny;\n\t\t\t\t  } else {\n\t\t\t\t\t   font = gdFontGiant;\n\t\t\t\t  }\n\t\t\t }\n\t\t\t break;\n\t}\n\n\treturn font;\n}\n/* }}} */\n\n/* {{{ php_imagefontsize\n * arg = 0  ImageFontWidth\n * arg = 1  ImageFontHeight\n */\nstatic void php_imagefontsize(INTERNAL_FUNCTION_PARAMETERS, int arg)\n{\n\tlong SIZE;\n\tgdFontPtr font;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &SIZE) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfont = php_find_gd_font(SIZE TSRMLS_CC);\n\tRETURN_LONG(arg ? font->h : font->w);\n}\n/* }}} */\n\n/* {{{ proto int imagefontwidth(int font)\n   Get font width */\nPHP_FUNCTION(imagefontwidth)\n{\n\tphp_imagefontsize(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto int imagefontheight(int font)\n   Get font height */\nPHP_FUNCTION(imagefontheight)\n{\n\tphp_imagefontsize(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ php_gdimagecharup\n * workaround for a bug in gd 1.2 */\nstatic void php_gdimagecharup(gdImagePtr im, gdFontPtr f, int x, int y, int c, int color)\n{\n\tint cx, cy, px, py, fline;\n\tcx = 0;\n\tcy = 0;\n\n\tif ((c < f->offset) || (c >= (f->offset + f->nchars))) {\n\t\treturn;\n\t}\n\n\tfline = (c - f->offset) * f->h * f->w;\n\tfor (py = y; (py > (y - f->w)); py--) {\n\t\tfor (px = x; (px < (x + f->h)); px++) {\n\t\t\tif (f->data[fline + cy * f->w + cx]) {\n\t\t\t\tgdImageSetPixel(im, px, py, color);\n\t\t\t}\n\t\t\tcy++;\n\t\t}\n\t\tcy = 0;\n\t\tcx++;\n\t}\n}\n/* }}} */\n\n/* {{{ php_imagechar\n * arg = 0  ImageChar\n * arg = 1  ImageCharUp\n * arg = 2  ImageString\n * arg = 3  ImageStringUp\n */\nstatic void php_imagechar(INTERNAL_FUNCTION_PARAMETERS, int mode)\n{\n\tzval *IM;\n\tlong SIZE, X, Y, COL;\n\tchar *C;\n\tint C_len;\n\tgdImagePtr im;\n\tint ch = 0, col, x, y, size, i, l = 0;\n\tunsigned char *str = NULL;\n\tgdFontPtr font;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllsl\", &IM, &SIZE, &X, &Y, &C, &C_len, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tcol = COL;\n\n\tif (mode < 2) {\n\t\tch = (int)((unsigned char)*C);\n\t} else {\n\t\tstr = (unsigned char *) estrndup(C, C_len);\n\t\tl = strlen((char *)str);\n\t}\n\n\ty = Y;\n\tx = X;\n\tsize = SIZE;\n\n\tfont = php_find_gd_font(size TSRMLS_CC);\n\n\tswitch (mode) {\n\t\tcase 0:\n\t\t\tgdImageChar(im, font, x, y, ch, col);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tphp_gdimagecharup(im, font, x, y, ch, col);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfor (i = 0; (i < l); i++) {\n\t\t\t\tgdImageChar(im, font, x, y, (int) ((unsigned char) str[i]), col);\n\t\t\t\tx += font->w;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3: {\n\t\t\tfor (i = 0; (i < l); i++) {\n\t\t\t\t/* php_gdimagecharup(im, font, x, y, (int) str[i], col); */\n\t\t\t\tgdImageCharUp(im, font, x, y, (int) str[i], col);\n\t\t\t\ty -= font->w;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (str) {\n\t\tefree(str);\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagechar(resource im, int font, int x, int y, string c, int col)\n   Draw a character */\nPHP_FUNCTION(imagechar)\n{\n\tphp_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto bool imagecharup(resource im, int font, int x, int y, string c, int col)\n   Draw a character rotated 90 degrees counter-clockwise */\nPHP_FUNCTION(imagecharup)\n{\n\tphp_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ proto bool imagestring(resource im, int font, int x, int y, string str, int col)\n   Draw a string horizontally */\nPHP_FUNCTION(imagestring)\n{\n\tphp_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 2);\n}\n/* }}} */\n\n/* {{{ proto bool imagestringup(resource im, int font, int x, int y, string str, int col)\n   Draw a string vertically - rotated 90 degrees counter-clockwise */\nPHP_FUNCTION(imagestringup)\n{\n\tphp_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 3);\n}\n/* }}} */\n\n/* {{{ proto bool imagecopy(resource dst_im, resource src_im, int dst_x, int dst_y, int src_x, int src_y, int src_w, int src_h)\n   Copy part of an image */\nPHP_FUNCTION(imagecopy)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, srcY, srcX, dstY, dstX;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &SW, &SH) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\n\tgdImageCopy(im_dst, im_src, dstX, dstY, srcX, srcY, srcW, srcH);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagecopymerge(resource src_im, resource dst_im, int dst_x, int dst_y, int src_x, int src_y, int src_w, int src_h, int pct)\n   Merge one part of an image with another */\nPHP_FUNCTION(imagecopymerge)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY, PCT;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, srcY, srcX, dstY, dstX, pct;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrlllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &SW, &SH, &PCT) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\tpct  = PCT;\n\n\tgdImageCopyMerge(im_dst, im_src, dstX, dstY, srcX, srcY, srcW, srcH, pct);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagecopymergegray(resource src_im, resource dst_im, int dst_x, int dst_y, int src_x, int src_y, int src_w, int src_h, int pct)\n   Merge one part of an image with another */\nPHP_FUNCTION(imagecopymergegray)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY, PCT;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, srcY, srcX, dstY, dstX, pct;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrlllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &SW, &SH, &PCT) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\tpct  = PCT;\n\n\tgdImageCopyMergeGray(im_dst, im_src, dstX, dstY, srcX, srcY, srcW, srcH, pct);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagecopyresized(resource dst_im, resource src_im, int dst_x, int dst_y, int src_x, int src_y, int dst_w, int dst_h, int src_w, int src_h)\n   Copy and resize part of an image */\nPHP_FUNCTION(imagecopyresized)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY, DW, DH;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrllllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\tdstH = DH;\n\tdstW = DW;\n\n\tif (dstW <= 0 || dstH <= 0 || srcW <= 0 || srcH <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid image dimensions\");\n\t\tRETURN_FALSE;\n\t}\n\n\tgdImageCopyResized(im_dst, im_src, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto int imagesx(resource im)\n   Get image width */\nPHP_FUNCTION(imagesx)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &IM) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageSX(im));\n}\n/* }}} */\n\n/* {{{ proto int imagesy(resource im)\n   Get image height */\nPHP_FUNCTION(imagesy)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &IM) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageSY(im));\n}\n/* }}} */\n\n#ifdef ENABLE_GD_TTF\n#define TTFTEXT_DRAW 0\n#define TTFTEXT_BBOX 1\n#endif\n\n#ifdef ENABLE_GD_TTF\n\n#if HAVE_GD_FREETYPE && HAVE_LIBFREETYPE\n/* {{{ proto array imageftbbox(float size, float angle, string font_file, string text [, array extrainfo])\n   Give the bounding box of a text using fonts via freetype2 */\nPHP_FUNCTION(imageftbbox)\n{\n\tphp_imagettftext_common(INTERNAL_FUNCTION_PARAM_PASSTHRU, TTFTEXT_BBOX, 1);\n}\n/* }}} */\n\n/* {{{ proto array imagefttext(resource im, float size, float angle, int x, int y, int col, string font_file, string text [, array extrainfo])\n   Write text to the image using fonts via freetype2 */\nPHP_FUNCTION(imagefttext)\n{\n\tphp_imagettftext_common(INTERNAL_FUNCTION_PARAM_PASSTHRU, TTFTEXT_DRAW, 1);\n}\n/* }}} */\n#endif /* HAVE_GD_FREETYPE && HAVE_LIBFREETYPE */\n\n/* {{{ proto array imagettfbbox(float size, float angle, string font_file, string text)\n   Give the bounding box of a text using TrueType fonts */\nPHP_FUNCTION(imagettfbbox)\n{\n\tphp_imagettftext_common(INTERNAL_FUNCTION_PARAM_PASSTHRU, TTFTEXT_BBOX, 0);\n}\n/* }}} */\n\n/* {{{ proto array imagettftext(resource im, float size, float angle, int x, int y, int col, string font_file, string text)\n   Write text to the image using a TrueType font */\nPHP_FUNCTION(imagettftext)\n{\n\tphp_imagettftext_common(INTERNAL_FUNCTION_PARAM_PASSTHRU, TTFTEXT_DRAW, 0);\n}\n/* }}} */\n\n/* {{{ php_imagettftext_common\n */\nstatic void php_imagettftext_common(INTERNAL_FUNCTION_PARAMETERS, int mode, int extended)\n{\n\tzval *IM, *EXT = NULL;\n\tgdImagePtr im=NULL;\n\tlong col = -1, x = -1, y = -1;\n\tint str_len, fontname_len, i, brect[8];\n\tdouble ptsize, angle;\n\tchar *str = NULL, *fontname = NULL;\n\tchar *error = NULL;\n\tint argc = ZEND_NUM_ARGS();\n\tgdFTStringExtra strex = {0};\n\n\tif (mode == TTFTEXT_BBOX) {\n\t\tif (argc < 4 || argc > ((extended) ? 5 : 4)) {\n\t\t\tZEND_WRONG_PARAM_COUNT();\n\t\t} else if (zend_parse_parameters(argc TSRMLS_CC, \"ddss|a\", &ptsize, &angle, &fontname, &fontname_len, &str, &str_len, &EXT) == FAILURE) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tif (argc < 8 || argc > ((extended) ? 9 : 8)) {\n\t\t\tZEND_WRONG_PARAM_COUNT();\n\t\t} else if (zend_parse_parameters(argc TSRMLS_CC, \"rddlllss|a\", &IM, &ptsize, &angle, &x, &y, &col, &fontname, &fontname_len, &str, &str_len, &EXT) == FAILURE) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\t}\n\n\t/* convert angle to radians */\n\tangle = angle * (M_PI/180);\n\n\tif (extended && EXT) {\t/* parse extended info */\n\t\tHashPosition pos;\n\n\t\t/* walk the assoc array */\n\t\tzend_hash_internal_pointer_reset_ex(HASH_OF(EXT), &pos);\n\t\tdo {\n\t\t\tzval ** item;\n\t\t\tchar * key;\n\t\t\tulong num_key;\n\n\t\t\tif (zend_hash_get_current_key_ex(HASH_OF(EXT), &key, NULL, &num_key, 0, &pos) != HASH_KEY_IS_STRING) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (zend_hash_get_current_data_ex(HASH_OF(EXT), (void **) &item, &pos) == FAILURE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (strcmp(\"linespacing\", key) == 0) {\n\t\t\t\tconvert_to_double_ex(item);\n\t\t\t\tstrex.flags |= gdFTEX_LINESPACE;\n\t\t\t\tstrex.linespacing = Z_DVAL_PP(item);\n\t\t\t}\n\n\t\t} while (zend_hash_move_forward_ex(HASH_OF(EXT), &pos) == SUCCESS);\n\t}\n\n#ifdef VIRTUAL_DIR\n\t{\n\t\tchar tmp_font_path[MAXPATHLEN];\n\n\t\tif (!VCWD_REALPATH(fontname, tmp_font_path)) {\n\t\t\tfontname = NULL;\n\t\t}\n\t}\n#endif /* VIRTUAL_DIR */\n\n\tPHP_GD_CHECK_OPEN_BASEDIR(fontname, \"Invalid font filename\");\n\n#ifdef HAVE_GD_FREETYPE\n\tif (extended) {\n\t\terror = gdImageStringFTEx(im, brect, col, fontname, ptsize, angle, x, y, str, &strex);\n\t}\n\telse\n\t\terror = gdImageStringFT(im, brect, col, fontname, ptsize, angle, x, y, str);\n\n#endif /* HAVE_GD_FREETYPE */\n\n\tif (error) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", error);\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\t/* return array with the text's bounding box */\n\tfor (i = 0; i < 8; i++) {\n\t\tadd_next_index_long(return_value, brect[i]);\n\t}\n}\n/* }}} */\n#endif\t/* ENABLE_GD_TTF */\n\n#if HAVE_LIBT1\n\n/* {{{ php_free_ps_font\n */\nstatic void php_free_ps_font(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tint *font = (int *) rsrc->ptr;\n\n\tT1_DeleteFont(*font);\n\tefree(font);\n}\n/* }}} */\n\n/* {{{ php_free_ps_enc\n */\nstatic void php_free_ps_enc(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tchar **enc = (char **) rsrc->ptr;\n\n\tT1_DeleteEncoding(enc);\n}\n/* }}} */\n\n/* {{{ proto resource imagepsloadfont(string pathname)\n   Load a new font from specified file */\nPHP_FUNCTION(imagepsloadfont)\n{\n\tchar *file;\n\tint file_len, f_ind, *font;\n#ifdef PHP_WIN32\n\tstruct stat st;\n#endif\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p\", &file, &file_len) == FAILURE) {\n\t\treturn;\n\t}\n\n#ifdef PHP_WIN32\n\tif (VCWD_STAT(file, &st) < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Font file not found (%s)\", file);\n\t\tRETURN_FALSE;\n\t}\n#endif\n\n\tf_ind = T1_AddFont(file);\n\n\tif (f_ind < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"T1Lib Error (%i): %s\", f_ind, T1_StrError(f_ind));\n\t\tRETURN_FALSE;\n\t}\n\n\tif (T1_LoadFont(f_ind)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Couldn't load the font\");\n\t\tRETURN_FALSE;\n\t}\n\n\tfont = (int *) emalloc(sizeof(int));\n\t*font = f_ind;\n\tZEND_REGISTER_RESOURCE(return_value, font, le_ps_font);\n}\n/* }}} */\n\n/* {{{ proto int imagepscopyfont(int font_index)\n   Make a copy of a font for purposes like extending or reenconding */\n/* The function in t1lib which this function uses seem to be buggy...\nPHP_FUNCTION(imagepscopyfont)\n{\n\tint l_ind, type;\n\tgd_ps_font *nf_ind, *of_ind;\n\tlong fnt;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &fnt) == FAILURE) {\n\t\treturn;\n\t}\n\n\tof_ind = zend_list_find(fnt, &type);\n\n\tif (type != le_ps_font) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%ld is not a Type 1 font index\", fnt);\n\t\tRETURN_FALSE;\n\t}\n\n\tnf_ind = emalloc(sizeof(gd_ps_font));\n\tnf_ind->font_id = T1_CopyFont(of_ind->font_id);\n\n\tif (nf_ind->font_id < 0) {\n\t\tl_ind = nf_ind->font_id;\n\t\tefree(nf_ind);\n\t\tswitch (l_ind) {\n\t\t\tcase -1:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"FontID %d is not loaded in memory\", l_ind);\n\t\t\t\tRETURN_FALSE;\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Tried to copy a logical font\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t\tbreak;\n\t\t\tcase -3:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Memory allocation fault in t1lib\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"An unknown error occurred in t1lib\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tnf_ind->extend = 1;\n\tl_ind = zend_list_insert(nf_ind, le_ps_font TSRMLS_CC);\n\tRETURN_LONG(l_ind);\n}\n*/\n/* }}} */\n\n/* {{{ proto bool imagepsfreefont(resource font_index)\n   Free memory used by a font */\nPHP_FUNCTION(imagepsfreefont)\n{\n\tzval *fnt;\n\tint *f_ind;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &fnt) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\tzend_list_delete(Z_LVAL_P(fnt));\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagepsencodefont(resource font_index, string filename)\n   To change a fonts character encoding vector */\nPHP_FUNCTION(imagepsencodefont)\n{\n\tzval *fnt;\n\tchar *enc, **enc_vector;\n\tint enc_len, *f_ind;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rp\", &fnt, &enc, &enc_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n\tif ((enc_vector = T1_LoadEncoding(enc)) == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Couldn't load encoding vector from %s\", enc);\n\t\tRETURN_FALSE;\n\t}\n\n\tT1_DeleteAllSizes(*f_ind);\n\tif (T1_ReencodeFont(*f_ind, enc_vector)) {\n\t\tT1_DeleteEncoding(enc_vector);\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Couldn't re-encode font\");\n\t\tRETURN_FALSE;\n\t}\n\n\tzend_list_insert(enc_vector, le_ps_enc TSRMLS_CC);\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagepsextendfont(resource font_index, float extend)\n   Extend or or condense (if extend < 1) a font */\nPHP_FUNCTION(imagepsextendfont)\n{\n\tzval *fnt;\n\tdouble ext;\n\tint *f_ind;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rd\", &fnt, &ext) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n\tT1_DeleteAllSizes(*f_ind);\n\n\tif (ext <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Second parameter %F out of range (must be > 0)\", ext);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (T1_ExtendFont(*f_ind, ext) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagepsslantfont(resource font_index, float slant)\n   Slant a font */\nPHP_FUNCTION(imagepsslantfont)\n{\n\tzval *fnt;\n\tdouble slt;\n\tint *f_ind;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rd\", &fnt, &slt) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n\tif (T1_SlantFont(*f_ind, slt) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto array imagepstext(resource image, string text, resource font, int size, int foreground, int background, int xcoord, int ycoord [, int space [, int tightness [, float angle [, int antialias])\n   Rasterize a string over an image */\nPHP_FUNCTION(imagepstext)\n{\n\tzval *img, *fnt;\n\tint i, j;\n\tlong _fg, _bg, x, y, size, space = 0, aa_steps = 4, width = 0;\n\tint *f_ind;\n\tint h_lines, v_lines, c_ind;\n\tint rd, gr, bl, fg_rd, fg_gr, fg_bl, bg_rd, bg_gr, bg_bl;\n\tint fg_al, bg_al, al;\n\tint aa[16];\n\tint amount_kern, add_width;\n\tdouble angle = 0.0, extend;\n\tunsigned long aa_greys[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n\tgdImagePtr bg_img;\n\tGLYPH *str_img;\n\tT1_OUTLINE *char_path, *str_path;\n\tT1_TMATRIX *transform = NULL;\n\tchar *str;\n\tint str_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rsrlllll|lldl\", &img, &str, &str_len, &fnt, &size, &_fg, &_bg, &x, &y, &space, &width, &angle, &aa_steps) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (aa_steps != 4 && aa_steps != 16) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Antialias steps must be 4 or 16\");\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(bg_img, gdImagePtr, &img, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n\t/* Ensure that the provided colors are valid */\n\tif (_fg < 0 || (!gdImageTrueColor(bg_img) && _fg > gdImageColorsTotal(bg_img))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Foreground color index %ld out of range\", _fg);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (_bg < 0 || (!gdImageTrueColor(bg_img) && _fg > gdImageColorsTotal(bg_img))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Background color index %ld out of range\", _bg);\n\t\tRETURN_FALSE;\n\t}\n\n\tfg_rd = gdImageRed  (bg_img, _fg);\n\tfg_gr = gdImageGreen(bg_img, _fg);\n\tfg_bl = gdImageBlue (bg_img, _fg);\n\tfg_al = gdImageAlpha(bg_img, _fg);\n\n\tbg_rd = gdImageRed  (bg_img, _bg);\n\tbg_gr = gdImageGreen(bg_img, _bg);\n\tbg_bl = gdImageBlue (bg_img, _bg);\n\tbg_al = gdImageAlpha(bg_img, _bg);\n\n\tfor (i = 0; i < aa_steps; i++) {\n\t\trd = bg_rd + (double) (fg_rd - bg_rd) / aa_steps * (i + 1);\n\t\tgr = bg_gr + (double) (fg_gr - bg_gr) / aa_steps * (i + 1);\n\t\tbl = bg_bl + (double) (fg_bl - bg_bl) / aa_steps * (i + 1);\n\t\tal = bg_al + (double) (fg_al - bg_al) / aa_steps * (i + 1);\n\t\taa[i] = gdImageColorResolveAlpha(bg_img, rd, gr, bl, al);\n\t}\n\n\tT1_AASetBitsPerPixel(8);\n\n\tswitch (aa_steps) {\n\t\tcase 4:\n\t\t\tT1_AASetGrayValues(0, 1, 2, 3, 4);\n\t\t\tT1_AASetLevel(T1_AA_LOW);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tT1_AAHSetGrayValues(aa_greys);\n\t\t\tT1_AASetLevel(T1_AA_HIGH);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid value %ld as number of steps for antialiasing\", aa_steps);\n\t\t\tRETURN_FALSE;\n\t}\n\n\tif (angle) {\n\t\ttransform = T1_RotateMatrix(NULL, angle);\n\t}\n\n\tif (width) {\n\t\textend = T1_GetExtend(*f_ind);\n\t\tstr_path = T1_GetCharOutline(*f_ind, str[0], size, transform);\n\n\t\tif (!str_path) {\n\t\t\tif (T1_errno) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"T1Lib Error: %s\", T1_StrError(T1_errno));\n\t\t\t}\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tfor (i = 1; i < str_len; i++) {\n\t\t\tamount_kern = (int) T1_GetKerning(*f_ind, str[i - 1], str[i]);\n\t\t\tamount_kern += str[i - 1] == ' ' ? space : 0;\n\t\t\tadd_width = (int) (amount_kern + width) / extend;\n\n\t\t\tchar_path = T1_GetMoveOutline(*f_ind, add_width, 0, 0, size, transform);\n\t\t\tstr_path = T1_ConcatOutlines(str_path, char_path);\n\n\t\t\tchar_path = T1_GetCharOutline(*f_ind, str[i], size, transform);\n\t\t\tstr_path = T1_ConcatOutlines(str_path, char_path);\n\t\t}\n\t\tstr_img = T1_AAFillOutline(str_path, 0);\n\t} else {\n\t\tstr_img = T1_AASetString(*f_ind, str,  str_len, space, T1_KERNING, size, transform);\n\t}\n\tif (T1_errno) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"T1Lib Error: %s\", T1_StrError(T1_errno));\n\t\tRETURN_FALSE;\n\t}\n\n\th_lines = str_img->metrics.ascent -  str_img->metrics.descent;\n\tv_lines = str_img->metrics.rightSideBearing - str_img->metrics.leftSideBearing;\n\n\tfor (i = 0; i < v_lines; i++) {\n\t\tfor (j = 0; j < h_lines; j++) {\n\t\t\tswitch (str_img->bits[j * v_lines + i]) {\n\t\t\t\tcase 0:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tc_ind = aa[str_img->bits[j * v_lines + i] - 1];\n\t\t\t\t\tgdImageSetPixel(bg_img, x + str_img->metrics.leftSideBearing + i, y - str_img->metrics.ascent + j, c_ind);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tarray_init(return_value);\n\n\tadd_next_index_long(return_value, str_img->metrics.leftSideBearing);\n\tadd_next_index_long(return_value, str_img->metrics.descent);\n\tadd_next_index_long(return_value, str_img->metrics.rightSideBearing);\n\tadd_next_index_long(return_value, str_img->metrics.ascent);\n}\n/* }}} */\n\n/* {{{ proto array imagepsbbox(string text, resource font, int size [, int space, int tightness, float angle])\n   Return the bounding box needed by a string if rasterized */\nPHP_FUNCTION(imagepsbbox)\n{\n\tzval *fnt;\n\tlong sz = 0, sp = 0, wd = 0;\n\tchar *str;\n\tint i, space = 0, add_width = 0, char_width, amount_kern;\n\tint cur_x, cur_y, dx, dy;\n\tint x1, y1, x2, y2, x3, y3, x4, y4;\n\tint *f_ind;\n\tint str_len, per_char = 0;\n\tint argc = ZEND_NUM_ARGS();\n\tdouble angle = 0, sin_a = 0, cos_a = 0;\n\tBBox char_bbox, str_bbox = {0, 0, 0, 0};\n\n\tif (argc != 3 && argc != 6) {\n\t\tZEND_WRONG_PARAM_COUNT();\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"srl|lld\", &str, &str_len, &fnt, &sz, &sp, &wd, &angle) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (argc == 6) {\n\t\tspace = sp;\n\t\tadd_width = wd;\n\t\tangle = angle * M_PI / 180;\n\t\tsin_a = sin(angle);\n\t\tcos_a = cos(angle);\n\t\tper_char =  add_width || angle ? 1 : 0;\n\t}\n\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n#define max(a, b) (a > b ? a : b)\n#define min(a, b) (a < b ? a : b)\n#define new_x(a, b) (int) ((a) * cos_a - (b) * sin_a)\n#define new_y(a, b) (int) ((a) * sin_a + (b) * cos_a)\n\n\tif (per_char) {\n\t\tspace += T1_GetCharWidth(*f_ind, ' ');\n\t\tcur_x = cur_y = 0;\n\n\t\tfor (i = 0; i < str_len; i++) {\n\t\t\tif (str[i] == ' ') {\n\t\t\t\tchar_bbox.llx = char_bbox.lly = char_bbox.ury = 0;\n\t\t\t\tchar_bbox.urx = char_width = space;\n\t\t\t} else {\n\t\t\t\tchar_bbox = T1_GetCharBBox(*f_ind, str[i]);\n\t\t\t\tchar_width = T1_GetCharWidth(*f_ind, str[i]);\n\t\t\t}\n\t\t\tamount_kern = i ? T1_GetKerning(*f_ind, str[i - 1], str[i]) : 0;\n\n\t\t\t/* Transfer character bounding box to right place */\n\t\t\tx1 = new_x(char_bbox.llx, char_bbox.lly) + cur_x;\n\t\t\ty1 = new_y(char_bbox.llx, char_bbox.lly) + cur_y;\n\t\t\tx2 = new_x(char_bbox.llx, char_bbox.ury) + cur_x;\n\t\t\ty2 = new_y(char_bbox.llx, char_bbox.ury) + cur_y;\n\t\t\tx3 = new_x(char_bbox.urx, char_bbox.ury) + cur_x;\n\t\t\ty3 = new_y(char_bbox.urx, char_bbox.ury) + cur_y;\n\t\t\tx4 = new_x(char_bbox.urx, char_bbox.lly) + cur_x;\n\t\t\ty4 = new_y(char_bbox.urx, char_bbox.lly) + cur_y;\n\n\t\t\t/* Find min & max values and compare them with current bounding box */\n\t\t\tstr_bbox.llx = min(str_bbox.llx, min(x1, min(x2, min(x3, x4))));\n\t\t\tstr_bbox.lly = min(str_bbox.lly, min(y1, min(y2, min(y3, y4))));\n\t\t\tstr_bbox.urx = max(str_bbox.urx, max(x1, max(x2, max(x3, x4))));\n\t\t\tstr_bbox.ury = max(str_bbox.ury, max(y1, max(y2, max(y3, y4))));\n\n\t\t\t/* Move to the next base point */\n\t\t\tdx = new_x(char_width + add_width + amount_kern, 0);\n\t\t\tdy = new_y(char_width + add_width + amount_kern, 0);\n\t\t\tcur_x += dx;\n\t\t\tcur_y += dy;\n\t\t\t/*\n\t\t\tprintf(\"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\n\", x1, y1, x2, y2, x3, y3, x4, y4, char_bbox.llx, char_bbox.lly, char_bbox.urx, char_bbox.ury, char_width, amount_kern, cur_x, cur_y, dx, dy);\n\t\t\t*/\n\t\t}\n\n\t} else {\n\t\tstr_bbox = T1_GetStringBBox(*f_ind, str, str_len, space, T1_KERNING);\n\t}\n\n\tif (T1_errno) {\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\t/*\n\tprintf(\"%d %d %d %d\\n\", str_bbox.llx, str_bbox.lly, str_bbox.urx, str_bbox.ury);\n\t*/\n\tadd_next_index_long(return_value, (int) ceil(((double) str_bbox.llx)*sz/1000));\n\tadd_next_index_long(return_value, (int) ceil(((double) str_bbox.lly)*sz/1000));\n\tadd_next_index_long(return_value, (int) ceil(((double) str_bbox.urx)*sz/1000));\n\tadd_next_index_long(return_value, (int) ceil(((double) str_bbox.ury)*sz/1000));\n}\n/* }}} */\n#endif\n\n/* {{{ proto bool image2wbmp(resource im [, string filename [, int threshold]])\n   Output WBMP image to browser or file */\nPHP_FUNCTION(image2wbmp)\n{\n\t_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_CONVERT_WBM, \"WBMP\", _php_image_bw_convert);\n}\n/* }}} */\n\n#if defined(HAVE_GD_JPG)\n/* {{{ proto bool jpeg2wbmp (string f_org, string f_dest, int d_height, int d_width, int threshold)\n   Convert JPEG image to WBMP image */\nPHP_FUNCTION(jpeg2wbmp)\n{\n\t_php_image_convert(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_JPG);\n}\n/* }}} */\n#endif\n\n#if defined(HAVE_GD_PNG)\n/* {{{ proto bool png2wbmp (string f_org, string f_dest, int d_height, int d_width, int threshold)\n   Convert PNG image to WBMP image */\nPHP_FUNCTION(png2wbmp)\n{\n\t_php_image_convert(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG);\n}\n/* }}} */\n#endif\n\n/* {{{ _php_image_bw_convert\n * It converts a gd Image to bw using a threshold value */\nstatic void _php_image_bw_convert(gdImagePtr im_org, gdIOCtx *out, int threshold)\n{\n\tgdImagePtr im_dest;\n\tint white, black;\n\tint color, color_org, median;\n\tint dest_height = gdImageSY(im_org);\n\tint dest_width = gdImageSX(im_org);\n\tint x, y;\n\tTSRMLS_FETCH();\n\n\tim_dest = gdImageCreate(dest_width, dest_height);\n\tif (im_dest == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate temporary buffer\");\n\t\treturn;\n\t}\n\n\twhite = gdImageColorAllocate(im_dest, 255, 255, 255);\n\tif (white == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate the colors for the destination buffer\");\n\t\treturn;\n\t}\n\n\tblack = gdImageColorAllocate(im_dest, 0, 0, 0);\n\tif (black == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate the colors for the destination buffer\");\n\t\treturn;\n\t}\n\n\tif (im_org->trueColor) {\n\t\tgdImageTrueColorToPalette(im_org, 1, 256);\n\t}\n\n\tfor (y = 0; y < dest_height; y++) {\n\t\tfor (x = 0; x < dest_width; x++) {\n\t\t\tcolor_org = gdImageGetPixel(im_org, x, y);\n\t\t\tmedian = (im_org->red[color_org] + im_org->green[color_org] + im_org->blue[color_org]) / 3;\n\t\t\tif (median < threshold) {\n\t\t\t\tcolor = black;\n\t\t\t} else {\n\t\t\t\tcolor = white;\n\t\t\t}\n\t\t\tgdImageSetPixel (im_dest, x, y, color);\n\t\t}\n\t}\n\tgdImageWBMPCtx (im_dest, black, out);\n\n}\n/* }}} */\n\n/* {{{ _php_image_convert\n * _php_image_convert converts jpeg/png images to wbmp and resizes them as needed  */\nstatic void _php_image_convert(INTERNAL_FUNCTION_PARAMETERS, int image_type )\n{\n\tchar *f_org, *f_dest;\n\tint f_org_len, f_dest_len;\n\tlong height, width, threshold;\n\tgdImagePtr im_org, im_dest, im_tmp;\n\tchar *fn_org = NULL;\n\tchar *fn_dest = NULL;\n\tFILE *org, *dest;\n\tint dest_height = -1;\n\tint dest_width = -1;\n\tint org_height, org_width;\n\tint white, black;\n\tint color, color_org, median;\n\tint int_threshold;\n\tint x, y;\n\tfloat x_ratio, y_ratio;\n    long ignore_warning;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pplll\", &f_org, &f_org_len, &f_dest, &f_dest_len, &height, &width, &threshold) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfn_org  = f_org;\n\tfn_dest = f_dest;\n\tdest_height = height;\n\tdest_width = width;\n\tint_threshold = threshold;\n\n\t/* Check threshold value */\n\tif (int_threshold < 0 || int_threshold > 8) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid threshold value '%d'\", int_threshold);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Check origin file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_org, \"Invalid origin filename\");\n\n\t/* Check destination file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_dest, \"Invalid destination filename\");\n\n\t/* Open origin file */\n\torg = VCWD_FOPEN(fn_org, \"rb\");\n\tif (!org) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' for reading\", fn_org);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Open destination file */\n\tdest = VCWD_FOPEN(fn_dest, \"wb\");\n\tif (!dest) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' for writing\", fn_dest);\n\t\tRETURN_FALSE;\n\t}\n\n\tswitch (image_type) {\n\t\tcase PHP_GDIMG_TYPE_GIF:\n\t\t\tim_org = gdImageCreateFromGif(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' Not a valid GIF file\", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef HAVE_GD_JPG\n\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\tignore_warning = INI_INT(\"gd.jpeg_ignore_warning\");\n\t\t\tim_org = gdImageCreateFromJpegEx(org, ignore_warning);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' Not a valid JPEG file\", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_JPG */\n\n#ifdef HAVE_GD_PNG\n\t\tcase PHP_GDIMG_TYPE_PNG:\n\t\t\tim_org = gdImageCreateFromPng(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' Not a valid PNG file\", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_PNG */\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Format not supported\");\n\t\t\tRETURN_FALSE;\n\t\t\tbreak;\n\t}\n\n\torg_width  = gdImageSX (im_org);\n\torg_height = gdImageSY (im_org);\n\n\tx_ratio = (float) org_width / (float) dest_width;\n\ty_ratio = (float) org_height / (float) dest_height;\n\n\tif (x_ratio > 1 && y_ratio > 1) {\n\t\tif (y_ratio > x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width / x_ratio);\n\t\tdest_height = (int) (org_height / y_ratio);\n\t} else {\n\t\tx_ratio = (float) dest_width / (float) org_width;\n\t\ty_ratio = (float) dest_height / (float) org_height;\n\n\t\tif (y_ratio < x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width * x_ratio);\n\t\tdest_height = (int) (org_height * y_ratio);\n\t}\n\n\tim_tmp = gdImageCreate (dest_width, dest_height);\n\tif (im_tmp == NULL ) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate temporary buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\tgdImageCopyResized (im_tmp, im_org, 0, 0, 0, 0, dest_width, dest_height, org_width, org_height);\n\n\tgdImageDestroy(im_org);\n\n\tfclose(org);\n\n\tim_dest = gdImageCreate(dest_width, dest_height);\n\tif (im_dest == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate destination buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\twhite = gdImageColorAllocate(im_dest, 255, 255, 255);\n\tif (white == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate the colors for the destination buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\tblack = gdImageColorAllocate(im_dest, 0, 0, 0);\n\tif (black == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate the colors for the destination buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\tint_threshold = int_threshold * 32;\n\n\tfor (y = 0; y < dest_height; y++) {\n\t\tfor (x = 0; x < dest_width; x++) {\n\t\t\tcolor_org = gdImageGetPixel (im_tmp, x, y);\n\t\t\tmedian = (im_tmp->red[color_org] + im_tmp->green[color_org] + im_tmp->blue[color_org]) / 3;\n\t\t\tif (median < int_threshold) {\n\t\t\t\tcolor = black;\n\t\t\t} else {\n\t\t\t\tcolor = white;\n\t\t\t}\n\t\t\tgdImageSetPixel (im_dest, x, y, color);\n\t\t}\n\t}\n\n\tgdImageDestroy (im_tmp );\n\n\tgdImageWBMP(im_dest, black , dest);\n\n\tfflush(dest);\n\tfclose(dest);\n\n\tgdImageDestroy(im_dest);\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* Section Filters */\n#define PHP_GD_SINGLE_RES\t\\\n\tzval *SIM;\t\\\n\tgdImagePtr im_src;\t\\\n\tif (zend_parse_parameters(1 TSRMLS_CC, \"r\", &SIM) == FAILURE) {\t\\\n\t\tRETURN_FALSE;\t\\\n\t}\t\\\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\t\\\n\tif (im_src == NULL) {\t\\\n\t\tRETURN_FALSE;\t\\\n\t}\n\nstatic void php_image_filter_negate(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageNegate(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_grayscale(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageGrayScale(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_brightness(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *SIM;\n\tgdImagePtr im_src;\n\tlong brightness, tmp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zll\", &SIM, &tmp, &brightness) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tif (im_src == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImageBrightness(im_src, (int)brightness) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_contrast(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *SIM;\n\tgdImagePtr im_src;\n\tlong contrast, tmp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rll\", &SIM, &tmp, &contrast) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tif (im_src == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImageContrast(im_src, (int)contrast) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_colorize(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *SIM;\n\tgdImagePtr im_src;\n\tlong r,g,b,tmp;\n\tlong a = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rllll|l\", &SIM, &tmp, &r, &g, &b, &a) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tif (im_src == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImageColor(im_src, (int) r, (int) g, (int) b, (int) a) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_edgedetect(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageEdgeDetectQuick(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_emboss(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageEmboss(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_gaussian_blur(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageGaussianBlur(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_selective_blur(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageSelectiveBlur(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_mean_removal(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageMeanRemoval(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_smooth(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *SIM;\n\tlong tmp;\n\tgdImagePtr im_src;\n\tdouble weight;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rld\", &SIM, &tmp, &weight) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tif (im_src == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImageSmooth(im_src, (float)weight)==1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_pixelate(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tlong tmp, blocksize;\n\tzend_bool mode = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rll|b\", &IM, &tmp, &blocksize, &mode) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (im == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImagePixelate(im, (int) blocksize, (const unsigned int) mode)) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\n/* {{{ proto bool imagefilter(resource src_im, int filtertype, [args] )\n   Applies Filter an image using a custom angle */\nPHP_FUNCTION(imagefilter)\n{\n\tzval *tmp;\n\n\ttypedef void (*image_filter)(INTERNAL_FUNCTION_PARAMETERS);\n\tlong filtertype;\n\timage_filter filters[] =\n\t{\n\t\tphp_image_filter_negate ,\n\t\tphp_image_filter_grayscale,\n\t\tphp_image_filter_brightness,\n\t\tphp_image_filter_contrast,\n\t\tphp_image_filter_colorize,\n\t\tphp_image_filter_edgedetect,\n\t\tphp_image_filter_emboss,\n\t\tphp_image_filter_gaussian_blur,\n\t\tphp_image_filter_selective_blur,\n\t\tphp_image_filter_mean_removal,\n\t\tphp_image_filter_smooth,\n\t\tphp_image_filter_pixelate\n\t};\n\n\tif (ZEND_NUM_ARGS() < 2 || ZEND_NUM_ARGS() > IMAGE_FILTER_MAX_ARGS) {\n\t\tWRONG_PARAM_COUNT;\n\t} else if (zend_parse_parameters(2 TSRMLS_CC, \"rl\", &tmp, &filtertype) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (filtertype >= 0 && filtertype <= IMAGE_FILTER_MAX) {\n\t\tfilters[filtertype](INTERNAL_FUNCTION_PARAM_PASSTHRU);\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource imageconvolution(resource src_im, array matrix3x3, double div, double offset)\n   Apply a 3x3 convolution matrix, using coefficient div and offset */\nPHP_FUNCTION(imageconvolution)\n{\n\tzval *SIM, *hash_matrix;\n\tzval **var = NULL, **var2 = NULL;\n\tgdImagePtr im_src = NULL;\n\tdouble div, offset;\n\tint nelem, i, j, res;\n\tfloat matrix[3][3] = {{0,0,0}, {0,0,0}, {0,0,0}};\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"radd\", &SIM, &hash_matrix, &div, &offset) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(hash_matrix));\n\tif (nelem != 3) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have 3x3 array\");\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i=0; i<3; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(hash_matrix), (i), (void **) &var) == SUCCESS && Z_TYPE_PP(var) == IS_ARRAY) {\n\t\t\tif (Z_TYPE_PP(var) != IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_PP(var)) != 3 ) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have 3x3 array\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tfor (j=0; j<3; j++) {\n\t\t\t\tif (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {\n\t\t\t\t\tif (Z_TYPE_PP(var2) != IS_DOUBLE) {\n\t\t\t\t\t\tzval dval;\n\t\t\t\t\t\tdval = **var2;\n\t\t\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\t\t\tconvert_to_double(&dval);\n\t\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL(dval);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL_PP(var2);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have a 3x3 matrix\");\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres = gdImageConvolution(im_src, matrix, (float)div, (float)offset);\n\n\tif (res) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n/* End section: Filters */\n\n/* {{{ proto void imageflip(resource im, int mode)\n   Flip an image (in place) horizontally, vertically or both directions. */\nPHP_FUNCTION(imageflip)\n{\n\tzval *IM;\n\tlong mode;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &IM, &mode) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tswitch (mode) {\n\t\tcase GD_FLIP_VERTICAL:\n\t\t\tgdImageFlipVertical(im);\n\t\t\tbreak;\n\n\t\tcase GD_FLIP_HORINZONTAL:\n\t\t\tgdImageFlipHorizontal(im);\n\t\t\tbreak;\n\n\t\tcase GD_FLIP_BOTH:\n\t\t\tgdImageFlipBoth(im);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown flip mode\");\n\t\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n#ifdef HAVE_GD_BUNDLED\n/* {{{ proto bool imageantialias(resource im, bool on)\n   Should antialiased functions used or not*/\nPHP_FUNCTION(imageantialias)\n{\n\tzval *IM;\n\tzend_bool alias;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rb\", &IM, &alias) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageAntialias(im, alias);\n\tRETURN_TRUE;\n}\n/* }}} */\n#endif\n\n/* {{{ proto void imagecrop(resource im, array rect)\n   Crop an image using the given coordinates and size, x, y, width and height. */\nPHP_FUNCTION(imagecrop)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tgdImagePtr im_crop;\n\tgdRect rect;\n\tzval *z_rect;\n\tzval **tmp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra\", &IM, &z_rect) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (zend_hash_find(HASH_OF(z_rect), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\tzval lval;\n\t\t\tlval = **tmp;\n\t\t\tzval_copy_ctor(&lval);\n\t\t\tconvert_to_long(&lval);\n\t\t\trect.x = Z_LVAL(lval);\n\t\t} else {\n\t\t\trect.x = Z_LVAL_PP(tmp);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_hash_find(HASH_OF(z_rect), \"y\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\tzval lval;\n\t\t\tlval = **tmp;\n\t\t\tzval_copy_ctor(&lval);\n\t\t\tconvert_to_long(&lval);\n\t\t\trect.y = Z_LVAL(lval);\n\t\t} else {\n\t\t\trect.y = Z_LVAL_PP(tmp);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_hash_find(HASH_OF(z_rect), \"width\", sizeof(\"width\"), (void **)&tmp) != FAILURE) {\n\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\tzval lval;\n\t\t\tlval = **tmp;\n\t\t\tzval_copy_ctor(&lval);\n\t\t\tconvert_to_long(&lval);\n\t\t\trect.width = Z_LVAL(lval);\n\t\t} else {\n\t\t\trect.width = Z_LVAL_PP(tmp);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing width\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_hash_find(HASH_OF(z_rect), \"height\", sizeof(\"height\"), (void **)&tmp) != FAILURE) {\n\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\tzval lval;\n\t\t\tlval = **tmp;\n\t\t\tzval_copy_ctor(&lval);\n\t\t\tconvert_to_long(&lval);\n\t\t\trect.height = Z_LVAL(lval);\n\t\t} else {\n\t\t\trect.height = Z_LVAL_PP(tmp);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing height\");\n\t\tRETURN_FALSE;\n\t}\n\n\tim_crop = gdImageCrop(im, &rect);\n\n\tif (im_crop == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);\n\t}\n}\n/* }}} */\n\n/* {{{ proto void imagecropauto(resource im [, int mode [, threshold [, color]]])\n   Crop an image automatically using one of the available modes. */\nPHP_FUNCTION(imagecropauto)\n{\n\tzval *IM;\n\tlong mode = -1;\n\tlong color = -1;\n\tdouble threshold = 0.5f;\n\tgdImagePtr im;\n\tgdImagePtr im_crop;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|ldl\", &IM, &mode, &threshold, &color) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tswitch (mode) {\n\t\tcase -1:\n\t\t\tmode = GD_CROP_DEFAULT;\n\t\tcase GD_CROP_DEFAULT:\n\t\tcase GD_CROP_TRANSPARENT:\n\t\tcase GD_CROP_BLACK:\n\t\tcase GD_CROP_WHITE:\n\t\tcase GD_CROP_SIDES:\n\t\t\tim_crop = gdImageCropAuto(im, mode);\n\t\t\tbreak;\n\n\t\tcase GD_CROP_THRESHOLD:\n\t\t\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Color argument missing with threshold mode\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tim_crop = gdImageCropThreshold(im, color, (float) threshold);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown crop mode\");\n\t\t\tRETURN_FALSE;\n\t}\n\tif (im_crop == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource imagescale(resource im, new_width[, new_height[, method]])\n   Scale an image using the given new width and height. */\nPHP_FUNCTION(imagescale)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tgdImagePtr im_scaled = NULL;\n\tint new_width, new_height;\n\tlong tmp_w, tmp_h=-1, tmp_m = GD_BILINEAR_FIXED;\n\tgdInterpolationMethod method;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl|ll\", &IM, &tmp_w, &tmp_h, &tmp_m) == FAILURE)  {\n\t\treturn;\n\t}\n\tmethod = tmp_m;\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (tmp_h < 0) {\n\t\t/* preserve ratio */\n\t\tlong src_x, src_y;\n\n\t\tsrc_x = gdImageSX(im);\n\t\tsrc_y = gdImageSY(im);\n\t\tif (src_x) {\n\t\t\ttmp_h = tmp_w * src_y / src_x;\n\t\t}\n\t}\n\n\tif (tmp_h <= 0 || tmp_w <= 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tnew_width = tmp_w;\n\tnew_height = tmp_h;\n\n\tif (gdImageSetInterpolationMethod(im, method)) {\n\t\tim_scaled = gdImageScale(im, new_width, new_height);\n\t}\n\n\tif (im_scaled == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_scaled, le_gd);\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource imageaffine(resource src, array affine[, array clip])\n   Return an image containing the affine tramsformed src image, using an optional clipping area */\nPHP_FUNCTION(imageaffine)\n{\n\tzval *IM;\n\tgdImagePtr src;\n\tgdImagePtr dst;\n\tgdRect rect;\n\tgdRectPtr pRect = NULL;\n\tzval *z_rect = NULL;\n\tzval *z_affine;\n\tzval **tmp;\n\tdouble affine[6];\n\tint i, nelems;\n\tzval **zval_affine_elem = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra|a\", &IM, &z_affine, &z_rect) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(src, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif ((nelems = zend_hash_num_elements(Z_ARRVAL_P(z_affine))) != 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Affine array must have six elements\");\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i = 0; i < nelems; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(z_affine), i, (void **) &zval_affine_elem) == SUCCESS) {\n\t\t\tswitch (Z_TYPE_PP(zval_affine_elem)) {\n\t\t\t\tcase IS_LONG:\n\t\t\t\t\taffine[i]  = Z_LVAL_PP(zval_affine_elem);\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_DOUBLE:\n\t\t\t\t\taffine[i] = Z_DVAL_PP(zval_affine_elem);\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_STRING:\n\t\t\t\t\t{\n\t\t\t\t\t\tzval dval;\n\t\t\t\t\t\tdval = **zval_affine_elem;\n\t\t\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\t\t\tconvert_to_double(&dval);\n\t\t\t\t\t\taffine[i] = Z_DVAL(dval);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %i\", i);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (z_rect != NULL) {\n\t\tif (zend_hash_find(HASH_OF(z_rect), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **tmp;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\trect.x = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\trect.x = Z_LVAL_PP(tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tif (zend_hash_find(HASH_OF(z_rect), \"y\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **tmp;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\trect.y = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\trect.y = Z_LVAL_PP(tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tif (zend_hash_find(HASH_OF(z_rect), \"width\", sizeof(\"width\"), (void **)&tmp) != FAILURE) {\n\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **tmp;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\trect.width = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\trect.width = Z_LVAL_PP(tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing width\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tif (zend_hash_find(HASH_OF(z_rect), \"height\", sizeof(\"height\"), (void **)&tmp) != FAILURE) {\n\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **tmp;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\trect.height = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\trect.height = Z_LVAL_PP(tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing height\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tpRect = &rect;\n\t} else {\n\t\trect.x = -1;\n\t\trect.y = -1;\n\t\trect.width = gdImageSX(src);\n\t\trect.height = gdImageSY(src);\n\t\tpRect = NULL;\n\t}\n\n\tif (gdTransformAffineGetImage(&dst, src, pRect, affine) != GD_TRUE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (dst == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, dst, le_gd);\n\t}\n}\n/* }}} */\n\n/* {{{ proto array imageaffinematrixget(type[, options])\n   Return an image containing the affine tramsformed src image, using an optional clipping area */\nPHP_FUNCTION(imageaffinematrixget)\n{\n\tdouble affine[6];\n\tlong type;\n\tzval *options = NULL;\n\tzval **tmp;\n\tint res = GD_FALSE, i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|z\", &type, &options) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tswitch((gdAffineStandardMatrix)type) {\n\t\tcase GD_AFFINE_TRANSLATE:\n\t\tcase GD_AFFINE_SCALE: {\n\t\t\tdouble x, y;\n\t\t\tif (!options || Z_TYPE_P(options) != IS_ARRAY) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Array expected as options\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tif (zend_hash_find(HASH_OF(options), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\n\t\t\t\t\tzval dval;\n\t\t\t\t\tdval = **tmp;\n\t\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\t\tconvert_to_double(&dval);\n\t\t\t\t\tx = Z_DVAL(dval);\n\t\t\t\t} else {\n\t\t\t\t\tx = Z_DVAL_PP(tmp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tif (zend_hash_find(HASH_OF(options), \"y\", sizeof(\"y\"), (void **)&tmp) != FAILURE) {\n\t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\n\t\t\t\t\tzval dval;\n\t\t\t\t\tdval = **tmp;\n\t\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\t\tconvert_to_double(&dval);\n\t\t\t\t\ty = Z_DVAL(dval);\n\t\t\t\t} else {\n\t\t\t\t\ty = Z_DVAL_PP(tmp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tif (type == GD_AFFINE_TRANSLATE) {\n\t\t\t\tres = gdAffineTranslate(affine, x, y);\n\t\t\t} else {\n\t\t\t\tres = gdAffineScale(affine, x, y);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase GD_AFFINE_ROTATE:\n\t\tcase GD_AFFINE_SHEAR_HORIZONTAL:\n\t\tcase GD_AFFINE_SHEAR_VERTICAL: {\n\t\t\tdouble angle;\n\n\t\t\tif (!options) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Number is expected as option\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tif(Z_TYPE_P(options) != IS_DOUBLE) {\n\t\t\t\tzval dval;\n\t\t\t\tdval = *options;\n\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\tconvert_to_double(&dval);\n\t\t\t\tangle = Z_DVAL(dval);\n\t\t\t} else {\n\t\t\t\tangle = Z_DVAL_P(options);\n\t\t\t}\n\n\t\t\tif (type == GD_AFFINE_SHEAR_HORIZONTAL) {\n\t\t\t\tres = gdAffineShearHorizontal(affine, angle);\n\t\t\t} else if (type == GD_AFFINE_SHEAR_VERTICAL) {\n\t\t\t\tres = gdAffineShearVertical(affine, angle);\n\t\t\t} else {\n\t\t\t\tres = gdAffineRotate(affine, angle);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %li\", type);\n\t\t\tRETURN_FALSE;\n\t}\n\n\tif (res == GD_FALSE) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tarray_init(return_value);\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tadd_index_double(return_value, i, affine[i]);\n\t\t}\n\t}\n}\n",
        "start": 1971,
        "end": 5428,
        "buggy": "PHP_FUNCTION(imagegrabwindow)\n{\n\tHWND window;\n\tlong client_area = 0;\n\tRECT rc = {0};\n\tRECT rc_win = {0};\n\tint Width, Height;\n\tHDC\t\thdc;\n\tHDC memDC;\n\tHBITMAP memBM;\n\tHBITMAP hOld;\n\tHINSTANCE handle;\n\tlong lwindow_handle;\n\ttypedef BOOL (WINAPI *tPrintWindow)(HWND, HDC,UINT);\n\ttPrintWindow pPrintWindow = 0;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|l\", &lwindow_handle, &client_area) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\twindow = (HWND) lwindow_handle;\n\n\tif (!IsWindow(window)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Invalid window handle\");\n\t\tRETURN_FALSE;\n\t}\n\n\thdc\t\t= GetDC(0);\n\n\tif (client_area) {\n\t\tGetClientRect(window, &rc);\n\t\tWidth = rc.right;\n\t\tHeight = rc.bottom;\n\t} else {\n\t\tGetWindowRect(window, &rc);\n\t\tWidth\t= rc.right - rc.left;\n\t\tHeight\t= rc.bottom - rc.top;\n\t}\n\n\tWidth\t\t= (Width/4)*4;\n\n\tmemDC\t= CreateCompatibleDC(hdc);\n\tmemBM\t= CreateCompatibleBitmap(hdc, Width, Height);\n\thOld\t= (HBITMAP) SelectObject (memDC, memBM);\n\n\n\thandle = LoadLibrary(\"User32.dll\");\n\tif ( handle == 0 ) {\n\t\tgoto clean;\n\t}\n\tpPrintWindow = (tPrintWindow) GetProcAddress(handle, \"PrintWindow\");\n\n\tif ( pPrintWindow )  {\n\t\tpPrintWindow(window, memDC, (UINT) client_area);\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Windows API too old\");\n\t\tgoto clean;\n\t}\n\n\tFreeLibrary(handle);\n\n\tim = gdImageCreateTrueColor(Width, Height);\n\tif (im) {\n\t\tint x,y;\n\t\tfor (y=0; y <= Height; y++) {\n\t\t\tfor (x=0; x <= Width; x++) {\n\t\t\t\tint c = GetPixel(memDC, x,y);\n\t\t\t\tgdImageSetPixel(im, x, y, gdTrueColor(GetRValue(c), GetGValue(c), GetBValue(c)));\n\t\t\t}\n\t\t}\n\t}\n\nclean:\n\tSelectObject(memDC,hOld);\n\tDeleteObject(memBM);\n\tDeleteDC(memDC);\n\tReleaseDC( 0, hdc );\n\n\tif (!im) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource imagegrabscreen()\n   Grab a screenshot */\nPHP_FUNCTION(imagegrabscreen)\n{\n\tHWND window = GetDesktopWindow();\n\tRECT rc = {0};\n\tint Width, Height;\n\tHDC\t\thdc;\n\tHDC memDC;\n\tHBITMAP memBM;\n\tHBITMAP hOld;\n\ttypedef BOOL (WINAPI *tPrintWindow)(HWND, HDC,UINT);\n\ttPrintWindow pPrintWindow = 0;\n\tgdImagePtr im;\n\thdc\t\t= GetDC(0);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!hdc) {\n\t\tRETURN_FALSE;\n\t}\n\n\tGetWindowRect(window, &rc);\n\tWidth\t= rc.right - rc.left;\n\tHeight\t= rc.bottom - rc.top;\n\n\tWidth\t\t= (Width/4)*4;\n\n\tmemDC\t= CreateCompatibleDC(hdc);\n\tmemBM\t= CreateCompatibleBitmap(hdc, Width, Height);\n\thOld\t= (HBITMAP) SelectObject (memDC, memBM);\n\tBitBlt( memDC, 0, 0, Width, Height , hdc, rc.left, rc.top , SRCCOPY );\n\n\tim = gdImageCreateTrueColor(Width, Height);\n\tif (im) {\n\t\tint x,y;\n\t\tfor (y=0; y <= Height; y++) {\n\t\t\tfor (x=0; x <= Width; x++) {\n\t\t\t\tint c = GetPixel(memDC, x,y);\n\t\t\t\tgdImageSetPixel(im, x, y, gdTrueColor(GetRValue(c), GetGValue(c), GetBValue(c)));\n\t\t\t}\n\t\t}\n\t}\n\n\tSelectObject(memDC,hOld);\n\tDeleteObject(memBM);\n\tDeleteDC(memDC);\n\tReleaseDC( 0, hdc );\n\n\tif (!im) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n\t}\n}\n/* }}} */\n#endif /* PHP_WIN32 */\n\n/* {{{ proto resource imagerotate(resource src_im, float angle, int bgdcolor [, int ignoretransparent])\n   Rotate an image using a custom angle */\nPHP_FUNCTION(imagerotate)\n{\n\tzval *SIM;\n\tgdImagePtr im_dst, im_src;\n\tdouble degrees;\n\tlong color;\n\tlong ignoretransparent = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rdl|l\", &SIM, &degrees, &color, &ignoretransparent) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tim_dst = gdImageRotateInterpolated(im_src, (const float)degrees, color);\n\n\tif (im_dst != NULL) {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_dst, le_gd);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool imagesettile(resource image, resource tile)\n   Set the tile image to $tile when filling $image with the \"IMG_COLOR_TILED\" color */\nPHP_FUNCTION(imagesettile)\n{\n\tzval *IM, *TILE;\n\tgdImagePtr im, tile;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rr\", &IM, &TILE) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(tile, gdImagePtr, &TILE, -1, \"Image\", le_gd);\n\n\tgdImageSetTile(im, tile);\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagesetbrush(resource image, resource brush)\n   Set the brush image to $brush when filling $image with the \"IMG_COLOR_BRUSHED\" color */\nPHP_FUNCTION(imagesetbrush)\n{\n\tzval *IM, *TILE;\n\tgdImagePtr im, tile;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rr\", &IM, &TILE) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(tile, gdImagePtr, &TILE, -1, \"Image\", le_gd);\n\n\tgdImageSetBrush(im, tile);\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto resource imagecreate(int x_size, int y_size)\n   Create a new image */\nPHP_FUNCTION(imagecreate)\n{\n\tlong x_size, y_size;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ll\", &x_size, &y_size) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (x_size <= 0 || y_size <= 0 || x_size >= INT_MAX || y_size >= INT_MAX) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid image dimensions\");\n\t\tRETURN_FALSE;\n\t}\n\n\tim = gdImageCreate(x_size, y_size);\n\n\tif (!im) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n}\n/* }}} */\n\n/* {{{ proto int imagetypes(void)\n   Return the types of images supported in a bitfield - 1=GIF, 2=JPEG, 4=PNG, 8=WBMP, 16=XPM */\nPHP_FUNCTION(imagetypes)\n{\n\tint ret=0;\n\tret = 1;\n#ifdef HAVE_GD_JPG\n\tret |= 2;\n#endif\n#ifdef HAVE_GD_PNG\n\tret |= 4;\n#endif\n\tret |= 8;\n#if defined(HAVE_GD_XPM)\n\tret |= 16;\n#endif\n#ifdef HAVE_GD_WEBP\n\tret |= 32;\n#endif\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ _php_ctx_getmbi\n */\n\nstatic int _php_ctx_getmbi(gdIOCtx *ctx)\n{\n\tint i, mbi = 0;\n\n\tdo {\n\t\ti = (ctx->getC)(ctx);\n\t\tif (i < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tmbi = (mbi << 7) | (i & 0x7f);\n\t} while (i & 0x80);\n\n\treturn mbi;\n}\n/* }}} */\n\n/* {{{ _php_image_type\n */\nstatic const char php_sig_gd2[3] = {'g', 'd', '2'};\n\nstatic int _php_image_type (char data[8])\n{\n\t/* Based on ext/standard/image.c */\n\n\tif (data == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (!memcmp(data, php_sig_gd2, 3)) {\n\t\treturn PHP_GDIMG_TYPE_GD2;\n\t} else if (!memcmp(data, php_sig_jpg, 3)) {\n\t\treturn PHP_GDIMG_TYPE_JPG;\n\t} else if (!memcmp(data, php_sig_png, 3)) {\n\t\tif (!memcmp(data, php_sig_png, 8)) {\n\t\t\treturn PHP_GDIMG_TYPE_PNG;\n\t\t}\n\t} else if (!memcmp(data, php_sig_gif, 3)) {\n\t\treturn PHP_GDIMG_TYPE_GIF;\n\t}\n\telse {\n\t\tgdIOCtx *io_ctx;\n\t\tio_ctx = gdNewDynamicCtxEx(8, data, 0);\n\t\tif (io_ctx) {\n\t\t\tif (_php_ctx_getmbi(io_ctx) == 0 && _php_ctx_getmbi(io_ctx) >= 0) {\n\t\t\t\tio_ctx->gd_free(io_ctx);\n\t\t\t\treturn PHP_GDIMG_TYPE_WBM;\n\t\t\t} else {\n\t\t\t\tio_ctx->gd_free(io_ctx);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n/* }}} */\n\n/* {{{ _php_image_create_from_string\n */\ngdImagePtr _php_image_create_from_string(zval **data, char *tn, gdImagePtr (*ioctx_func_p)() TSRMLS_DC)\n{\n\tgdImagePtr im;\n\tgdIOCtx *io_ctx;\n\n\tio_ctx = gdNewDynamicCtxEx(Z_STRLEN_PP(data), Z_STRVAL_PP(data), 0);\n\n\tif (!io_ctx) {\n\t\treturn NULL;\n\t}\n\n\tim = (*ioctx_func_p)(io_ctx);\n\tif (!im) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Passed data is not in '%s' format\", tn);\n\t\tio_ctx->gd_free(io_ctx);\n\t\treturn NULL;\n\t}\n\n\tio_ctx->gd_free(io_ctx);\n\n\treturn im;\n}\n/* }}} */\n\n/* {{{ proto resource imagecreatefromstring(string image)\n   Create a new image from the image stream in the string */\nPHP_FUNCTION(imagecreatefromstring)\n{\n\tzval **data;\n\tgdImagePtr im;\n\tint imtype;\n\tchar sig[8];\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z\", &data) == FAILURE) {\n\t\treturn;\n\t}\n\n\tconvert_to_string_ex(data);\n\tif (Z_STRLEN_PP(data) < 8) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty string or invalid image\");\n\t\tRETURN_FALSE;\n\t}\n\n\tmemcpy(sig, Z_STRVAL_PP(data), 8);\n\n\timtype = _php_image_type(sig);\n\n\tswitch (imtype) {\n\t\tcase PHP_GDIMG_TYPE_JPG:\n#ifdef HAVE_GD_JPG\n\t\t\tim = _php_image_create_from_string(data, \"JPEG\", gdImageCreateFromJpegCtx TSRMLS_CC);\n#else\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No JPEG support in this PHP build\");\n\t\t\tRETURN_FALSE;\n#endif\n\t\t\tbreak;\n\n\t\tcase PHP_GDIMG_TYPE_PNG:\n#ifdef HAVE_GD_PNG\n\t\t\tim = _php_image_create_from_string(data, \"PNG\", gdImageCreateFromPngCtx TSRMLS_CC);\n#else\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No PNG support in this PHP build\");\n\t\t\tRETURN_FALSE;\n#endif\n\t\t\tbreak;\n\n\t\tcase PHP_GDIMG_TYPE_GIF:\n\t\t\tim = _php_image_create_from_string(data, \"GIF\", gdImageCreateFromGifCtx TSRMLS_CC);\n\t\t\tbreak;\n\n\t\tcase PHP_GDIMG_TYPE_WBM:\n\t\t\tim = _php_image_create_from_string(data, \"WBMP\", gdImageCreateFromWBMPCtx TSRMLS_CC);\n\t\t\tbreak;\n\n\t\tcase PHP_GDIMG_TYPE_GD2:\n\t\t\tim = _php_image_create_from_string(data, \"GD2\", gdImageCreateFromGd2Ctx TSRMLS_CC);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Data is not in a recognized format\");\n\t\t\tRETURN_FALSE;\n\t}\n\n\tif (!im) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Couldn't create GD Image Stream out of Data\");\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n}\n/* }}} */\n\n/* {{{ _php_image_create_from\n */\nstatic void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, gdImagePtr (*func_p)(), gdImagePtr (*ioctx_func_p)())\n{\n\tchar *file;\n\tint file_len;\n\tlong srcx, srcy, width, height;\n\tgdImagePtr im = NULL;\n\tphp_stream *stream;\n\tFILE * fp = NULL;\n\tlong ignore_warning;\n\n\tif (image_type == PHP_GDIMG_TYPE_GD2PART) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pllll\", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tif (width < 1 || height < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Zero width or height not allowed\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p\", &file, &file_len) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tstream = php_stream_open_wrapper(file, \"rb\", REPORT_ERRORS|IGNORE_PATH|IGNORE_URL_WIN, NULL);\n\tif (stream == NULL)\t{\n\t\tRETURN_FALSE;\n\t}\n\n\t/* try and avoid allocating a FILE* if the stream is not naturally a FILE* */\n\tif (php_stream_is(stream, PHP_STREAM_IS_STDIO))\t{\n\t\tif (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS)) {\n\t\t\tgoto out_err;\n\t\t}\n\t} else if (ioctx_func_p) {\n\t\t/* we can create an io context */\n\t\tgdIOCtx* io_ctx;\n\t\tsize_t buff_size;\n\t\tchar *buff;\n\n\t\t/* needs to be malloc (persistent) - GD will free() it later */\n\t\tbuff_size = php_stream_copy_to_mem(stream, &buff, PHP_STREAM_COPY_ALL, 1);\n\n\t\tif (!buff_size) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Cannot read image data\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tio_ctx = gdNewDynamicCtxEx(buff_size, buff, 0);\n\t\tif (!io_ctx) {\n\t\t\tpefree(buff, 1);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Cannot allocate GD IO context\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (image_type == PHP_GDIMG_TYPE_GD2PART) {\n\t\t\tim = (*ioctx_func_p)(io_ctx, srcx, srcy, width, height);\n\t\t} else {\n\t\t\tim = (*ioctx_func_p)(io_ctx);\n\t\t}\n\t\tio_ctx->gd_free(io_ctx);\n\t\tpefree(buff, 1);\n\t}\n\telse if (php_stream_can_cast(stream, PHP_STREAM_AS_STDIO)) {\n\t\t/* try and force the stream to be FILE* */\n\t\tif (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO | PHP_STREAM_CAST_TRY_HARD, (void **) &fp, REPORT_ERRORS)) {\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (!im && fp) {\n\t\tswitch (image_type) {\n\t\t\tcase PHP_GDIMG_TYPE_GD2PART:\n\t\t\t\tim = (*func_p)(fp, srcx, srcy, width, height);\n\t\t\t\tbreak;\n#if defined(HAVE_GD_XPM)\n\t\t\tcase PHP_GDIMG_TYPE_XPM:\n\t\t\t\tim = gdImageCreateFromXpm(file);\n\t\t\t\tbreak;\n#endif\n\n#ifdef HAVE_GD_JPG\n\t\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\t\tignore_warning = INI_INT(\"gd.jpeg_ignore_warning\");\n\t\t\t\tim = gdImageCreateFromJpegEx(fp, ignore_warning);\n\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\tim = (*func_p)(fp);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfflush(fp);\n\t}\n\n/* register_im: */\n\tif (im) {\n\t\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n\t\tphp_stream_close(stream);\n\t\treturn;\n\t}\n\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"'%s' is not a valid %s file\", file, tn);\nout_err:\n\tphp_stream_close(stream);\n\tRETURN_FALSE;\n\n}\n/* }}} */\n\n/* {{{ proto resource imagecreatefromgif(string filename)\n   Create a new image from GIF file or URL */\nPHP_FUNCTION(imagecreatefromgif)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GIF, \"GIF\", gdImageCreateFromGif, gdImageCreateFromGifCtx);\n}\n/* }}} */\n\n#ifdef HAVE_GD_JPG\n/* {{{ proto resource imagecreatefromjpeg(string filename)\n   Create a new image from JPEG file or URL */\nPHP_FUNCTION(imagecreatefromjpeg)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_JPG, \"JPEG\", gdImageCreateFromJpeg, gdImageCreateFromJpegCtx);\n}\n/* }}} */\n#endif /* HAVE_GD_JPG */\n\n#ifdef HAVE_GD_PNG\n/* {{{ proto resource imagecreatefrompng(string filename)\n   Create a new image from PNG file or URL */\nPHP_FUNCTION(imagecreatefrompng)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, \"PNG\", gdImageCreateFromPng, gdImageCreateFromPngCtx);\n}\n/* }}} */\n#endif /* HAVE_GD_PNG */\n\n#ifdef HAVE_GD_WEBP\n/* {{{ proto resource imagecreatefromwebp(string filename)\n   Create a new image from WEBP file or URL */\nPHP_FUNCTION(imagecreatefromwebp)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WEBP, \"WEBP\", gdImageCreateFromWebp, gdImageCreateFromWebpCtx);\n}\n/* }}} */\n#endif /* HAVE_GD_VPX */\n\n/* {{{ proto resource imagecreatefromxbm(string filename)\n   Create a new image from XBM file or URL */\nPHP_FUNCTION(imagecreatefromxbm)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XBM, \"XBM\", gdImageCreateFromXbm, NULL);\n}\n/* }}} */\n\n#if defined(HAVE_GD_XPM)\n/* {{{ proto resource imagecreatefromxpm(string filename)\n   Create a new image from XPM file or URL */\nPHP_FUNCTION(imagecreatefromxpm)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XPM, \"XPM\", gdImageCreateFromXpm, NULL);\n}\n/* }}} */\n#endif\n\n/* {{{ proto resource imagecreatefromwbmp(string filename)\n   Create a new image from WBMP file or URL */\nPHP_FUNCTION(imagecreatefromwbmp)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WBM, \"WBMP\", gdImageCreateFromWBMP, gdImageCreateFromWBMPCtx);\n}\n/* }}} */\n\n/* {{{ proto resource imagecreatefromgd(string filename)\n   Create a new image from GD file or URL */\nPHP_FUNCTION(imagecreatefromgd)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD, \"GD\", gdImageCreateFromGd, gdImageCreateFromGdCtx);\n}\n/* }}} */\n\n/* {{{ proto resource imagecreatefromgd2(string filename)\n   Create a new image from GD2 file or URL */\nPHP_FUNCTION(imagecreatefromgd2)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2, \"GD2\", gdImageCreateFromGd2, gdImageCreateFromGd2Ctx);\n}\n/* }}} */\n\n/* {{{ proto resource imagecreatefromgd2part(string filename, int srcX, int srcY, int width, int height)\n   Create a new image from a given part of GD2 file or URL */\nPHP_FUNCTION(imagecreatefromgd2part)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2PART, \"GD2\", gdImageCreateFromGd2Part, gdImageCreateFromGd2PartCtx);\n}\n/* }}} */\n\n/* {{{ _php_image_output\n */\nstatic void _php_image_output(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, void (*func_p)())\n{\n\tzval *imgind;\n\tchar *file = NULL;\n\tlong quality = 0, type = 0;\n\tgdImagePtr im;\n\tchar *fn = NULL;\n\tFILE *fp;\n\tint file_len = 0, argc = ZEND_NUM_ARGS();\n\tint q = -1, i, t = 1;\n\n\t/* The quality parameter for Wbmp stands for the threshold when called from image2wbmp() */\n\t/* When called from imagewbmp() the quality parameter stands for the foreground color. Default: black. */\n\t/* The quality parameter for gd2 stands for chunk size */\n\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"r|pll\", &imgind, &file, &file_len, &quality, &type) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &imgind, -1, \"Image\", le_gd);\n\n\tif (argc > 1) {\n\t\tfn = file;\n\t\tif (argc == 3) {\n\t\t\tq = quality;\n\t\t}\n\t\tif (argc == 4) {\n\t\t\tt = type;\n\t\t}\n\t}\n\n\tif (argc >= 2 && file_len) {\n\t\tPHP_GD_CHECK_OPEN_BASEDIR(fn, \"Invalid filename\");\n\n\t\tfp = VCWD_FOPEN(fn, \"wb\");\n\t\tif (!fp) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' for writing\", fn);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tswitch (image_type) {\n\t\t\tcase PHP_GDIMG_CONVERT_WBM:\n\t\t\t\tif (q == -1) {\n\t\t\t\t\tq = 0;\n\t\t\t\t} else if (q < 0 || q > 255) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid threshold value '%d'. It must be between 0 and 255\", q);\n\t\t\t\t\tq = 0;\n\t\t\t\t}\n\t\t\t\tgdImageWBMP(im, q, fp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\t\t(*func_p)(im, fp, q);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_WBM:\n\t\t\t\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\t\t\t\tif (gdImageRed(im, i) == 0) break;\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, i, fp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_GD:\n\t\t\t\tif (im->trueColor){\n\t\t\t\t\tgdImageTrueColorToPalette(im,1,256);\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, fp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_GD2:\n\t\t\t\tif (q == -1) {\n\t\t\t\t\tq = 128;\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, fp, q, t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (q == -1) {\n\t\t\t\t\tq = 128;\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, fp, q, t);\n\t\t\t\tbreak;\n\t\t}\n\t\tfflush(fp);\n\t\tfclose(fp);\n\t} else {\n\t\tint   b;\n\t\tFILE *tmp;\n\t\tchar  buf[4096];\n\t\tchar *path;\n\n\t\ttmp = php_open_temporary_file(NULL, NULL, &path TSRMLS_CC);\n\t\tif (tmp == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open temporary file\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tswitch (image_type) {\n\t\t\tcase PHP_GDIMG_CONVERT_WBM:\n \t\t\t\tif (q == -1) {\n  \t\t\t\t\tq = 0;\n  \t\t\t\t} else if (q < 0 || q > 255) {\n  \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid threshold value '%d'. It must be between 0 and 255\", q);\n \t\t\t\t\tq = 0;\n  \t\t\t\t}\n\t\t\t\tgdImageWBMP(im, q, tmp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\t\t(*func_p)(im, tmp, q);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_WBM:\n\t\t\t\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\t\t\t\tif (gdImageRed(im, i) == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, q, tmp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_GD:\n\t\t\t\tif (im->trueColor) {\n\t\t\t\t\tgdImageTrueColorToPalette(im,1,256);\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, tmp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_GD2:\n\t\t\t\tif (q == -1) {\n\t\t\t\t\tq = 128;\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, tmp, q, t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t(*func_p)(im, tmp);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfseek(tmp, 0, SEEK_SET);\n\n#if APACHE && defined(CHARSET_EBCDIC)\n\t\t/* XXX this is unlikely to work any more thies@thieso.net */\n\n\t\t/* This is a binary file already: avoid EBCDIC->ASCII conversion */\n\t\tap_bsetflag(php3_rqst->connection->client, B_EBCDIC2ASCII, 0);\n#endif\n\t\twhile ((b = fread(buf, 1, sizeof(buf), tmp)) > 0) {\n\t\t\tphp_write(buf, b TSRMLS_CC);\n\t\t}\n\n\t\tfclose(tmp);\n\t\tVCWD_UNLINK((const char *)path); /* make sure that the temporary file is removed */\n\t\tefree(path);\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto int imagexbm(int im, string filename [, int foreground])\n   Output XBM image to browser or file */\nPHP_FUNCTION(imagexbm)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XBM, \"XBM\", gdImageXbmCtx);\n}\n/* }}} */\n\n/* {{{ proto bool imagegif(resource im [, string filename])\n   Output GIF image to browser or file */\nPHP_FUNCTION(imagegif)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GIF, \"GIF\", gdImageGifCtx);\n}\n/* }}} */\n\n#ifdef HAVE_GD_PNG\n/* {{{ proto bool imagepng(resource im [, string filename])\n   Output PNG image to browser or file */\nPHP_FUNCTION(imagepng)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, \"PNG\", gdImagePngCtxEx);\n}\n/* }}} */\n#endif /* HAVE_GD_PNG */\n\n\n#ifdef HAVE_GD_WEBP\n/* {{{ proto bool imagewebp(resource im [, string filename[, quality]] )\n   Output WEBP image to browser or file */\nPHP_FUNCTION(imagewebp)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WEBP, \"WEBP\", gdImageWebpCtx);\n}\n/* }}} */\n#endif /* HAVE_GD_WEBP */\n\n\n#ifdef HAVE_GD_JPG\n/* {{{ proto bool imagejpeg(resource im [, string filename [, int quality]])\n   Output JPEG image to browser or file */\nPHP_FUNCTION(imagejpeg)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_JPG, \"JPEG\", gdImageJpegCtx);\n}\n/* }}} */\n#endif /* HAVE_GD_JPG */\n\n/* {{{ proto bool imagewbmp(resource im [, string filename, [, int foreground]])\n   Output WBMP image to browser or file */\nPHP_FUNCTION(imagewbmp)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WBM, \"WBMP\", gdImageWBMPCtx);\n}\n/* }}} */\n\n/* {{{ proto bool imagegd(resource im [, string filename])\n   Output GD image to browser or file */\nPHP_FUNCTION(imagegd)\n{\n\t_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD, \"GD\", gdImageGd);\n}\n/* }}} */\n\n/* {{{ proto bool imagegd2(resource im [, string filename, [, int chunk_size, [, int type]]])\n   Output GD2 image to browser or file */\nPHP_FUNCTION(imagegd2)\n{\n\t_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2, \"GD2\", gdImageGd2);\n}\n/* }}} */\n\n/* {{{ proto bool imagedestroy(resource im)\n   Destroy an image */\nPHP_FUNCTION(imagedestroy)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &IM) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tzend_list_delete(Z_LVAL_P(IM));\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n\n/* {{{ proto int imagecolorallocate(resource im, int red, int green, int blue)\n   Allocate a color for an image */\nPHP_FUNCTION(imagecolorallocate)\n{\n\tzval *IM;\n\tlong red, green, blue;\n\tgdImagePtr im;\n\tint ct = (-1);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tct = gdImageColorAllocate(im, red, green, blue);\n\tif (ct < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_LONG(ct);\n}\n/* }}} */\n\n/* {{{ proto void imagepalettecopy(resource dst, resource src)\n   Copy the palette from the src image onto the dst image */\nPHP_FUNCTION(imagepalettecopy)\n{\n\tzval *dstim, *srcim;\n\tgdImagePtr dst, src;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rr\", &dstim, &srcim) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(dst, gdImagePtr, &dstim, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(src, gdImagePtr, &srcim, -1, \"Image\", le_gd);\n\n\tgdImagePaletteCopy(dst, src);\n}\n/* }}} */\n\n/* {{{ proto int imagecolorat(resource im, int x, int y)\n   Get the index of the color of a pixel */\nPHP_FUNCTION(imagecolorat)\n{\n\tzval *IM;\n\tlong x, y;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rll\", &IM, &x, &y) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (gdImageTrueColor(im)) {\n\t\tif (im->tpixels && gdImageBoundsSafe(im, x, y)) {\n\t\t\tRETURN_LONG(gdImageTrueColorPixel(im, x, y));\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"%ld,%ld is out of bounds\", x, y);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tif (im->pixels && gdImageBoundsSafe(im, x, y)) {\n\t\t\tRETURN_LONG(im->pixels[y][x]);\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"%ld,%ld is out of bounds\", x, y);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto int imagecolorclosest(resource im, int red, int green, int blue)\n   Get the index of the closest color to the specified color */\nPHP_FUNCTION(imagecolorclosest)\n{\n\tzval *IM;\n\tlong red, green, blue;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageColorClosest(im, red, green, blue));\n}\n/* }}} */\n\n/* {{{ proto int imagecolorclosesthwb(resource im, int red, int green, int blue)\n   Get the index of the color which has the hue, white and blackness nearest to the given color */\nPHP_FUNCTION(imagecolorclosesthwb)\n{\n\tzval *IM;\n\tlong red, green, blue;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageColorClosestHWB(im, red, green, blue));\n}\n/* }}} */\n\n/* {{{ proto bool imagecolordeallocate(resource im, int index)\n   De-allocate a color for an image */\nPHP_FUNCTION(imagecolordeallocate)\n{\n\tzval *IM;\n\tlong index;\n\tint col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &IM, &index) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\t/* We can return right away for a truecolor image as deallocating colours is meaningless here */\n\tif (gdImageTrueColor(im)) {\n\t\tRETURN_TRUE;\n\t}\n\n\tcol = index;\n\n\tif (col >= 0 && col < gdImageColorsTotal(im)) {\n\t\tgdImageColorDeallocate(im, col);\n\t\tRETURN_TRUE;\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Color index %d out of range\",\tcol);\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto int imagecolorresolve(resource im, int red, int green, int blue)\n   Get the index of the specified color or its closest possible alternative */\nPHP_FUNCTION(imagecolorresolve)\n{\n\tzval *IM;\n\tlong red, green, blue;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageColorResolve(im, red, green, blue));\n}\n/* }}} */\n\n/* {{{ proto int imagecolorexact(resource im, int red, int green, int blue)\n   Get the index of the specified color */\nPHP_FUNCTION(imagecolorexact)\n{\n\tzval *IM;\n\tlong red, green, blue;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageColorExact(im, red, green, blue));\n}\n/* }}} */\n\n/* {{{ proto void imagecolorset(resource im, int col, int red, int green, int blue)\n   Set the color for the specified palette index */\nPHP_FUNCTION(imagecolorset)\n{\n\tzval *IM;\n\tlong color, red, green, blue, alpha = 0;\n\tint col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rllll|l\", &IM, &color, &red, &green, &blue, &alpha) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tcol = color;\n\n\tif (col >= 0 && col < gdImageColorsTotal(im)) {\n\t\tim->red[col]   = red;\n\t\tim->green[col] = green;\n\t\tim->blue[col]  = blue;\n\t\tim->alpha[col]  = alpha;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto array imagecolorsforindex(resource im, int col)\n   Get the colors for an index */\nPHP_FUNCTION(imagecolorsforindex)\n{\n\tzval *IM;\n\tlong index;\n\tint col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &IM, &index) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tcol = index;\n\n\tif ((col >= 0 && gdImageTrueColor(im)) || (!gdImageTrueColor(im) && col >= 0 && col < gdImageColorsTotal(im))) {\n\t\tarray_init(return_value);\n\n\t\tadd_assoc_long(return_value,\"red\",  gdImageRed(im,col));\n\t\tadd_assoc_long(return_value,\"green\", gdImageGreen(im,col));\n\t\tadd_assoc_long(return_value,\"blue\", gdImageBlue(im,col));\n\t\tadd_assoc_long(return_value,\"alpha\", gdImageAlpha(im,col));\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Color index %d out of range\", col);\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool imagegammacorrect(resource im, float inputgamma, float outputgamma)\n   Apply a gamma correction to a GD image */\nPHP_FUNCTION(imagegammacorrect)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tint i;\n\tdouble input, output;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rdd\", &IM, &input, &output) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (gdImageTrueColor(im))\t{\n\t\tint x, y, c;\n\n\t\tfor (y = 0; y < gdImageSY(im); y++)\t{\n\t\t\tfor (x = 0; x < gdImageSX(im); x++)\t{\n\t\t\t\tc = gdImageGetPixel(im, x, y);\n\t\t\t\tgdImageSetPixel(im, x, y,\n\t\t\t\t\tgdTrueColorAlpha(\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetRed(c)   / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetGreen(c) / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetBlue(c)  / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\tgdTrueColorGetAlpha(c)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tRETURN_TRUE;\n\t}\n\n\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\tim->red[i]   = (int)((pow((pow((im->red[i]   / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->green[i] = (int)((pow((pow((im->green[i] / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->blue[i]  = (int)((pow((pow((im->blue[i]  / 255.0), input)), 1.0 / output) * 255) + .5);\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagesetpixel(resource im, int x, int y, int col)\n   Set a single pixel */\nPHP_FUNCTION(imagesetpixel)\n{\n\tzval *IM;\n\tlong x, y, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &x, &y, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageSetPixel(im, x, y, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imageline(resource im, int x1, int y1, int x2, int y2, int col)\n   Draw a line */\nPHP_FUNCTION(imageline)\n{\n\tzval *IM;\n\tlong x1, y1, x2, y2, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllll\", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n#ifdef HAVE_GD_BUNDLED\n\tif (im->antialias) {\n\t\tgdImageAALine(im, x1, y1, x2, y2, col);\n\t} else\n#endif\n\t{\n\t\tgdImageLine(im, x1, y1, x2, y2, col);\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagedashedline(resource im, int x1, int y1, int x2, int y2, int col)\n   Draw a dashed line */\nPHP_FUNCTION(imagedashedline)\n{\n\tzval *IM;\n\tlong x1, y1, x2, y2, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllll\", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageDashedLine(im, x1, y1, x2, y2, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagerectangle(resource im, int x1, int y1, int x2, int y2, int col)\n   Draw a rectangle */\nPHP_FUNCTION(imagerectangle)\n{\n\tzval *IM;\n\tlong x1, y1, x2, y2, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllll\", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageRectangle(im, x1, y1, x2, y2, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagefilledrectangle(resource im, int x1, int y1, int x2, int y2, int col)\n   Draw a filled rectangle */\nPHP_FUNCTION(imagefilledrectangle)\n{\n\tzval *IM;\n\tlong x1, y1, x2, y2, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllll\", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageFilledRectangle(im, x1, y1, x2, y2, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagearc(resource im, int cx, int cy, int w, int h, int s, int e, int col)\n   Draw a partial ellipse */\nPHP_FUNCTION(imagearc)\n{\n\tzval *IM;\n\tlong cx, cy, w, h, ST, E, col;\n\tgdImagePtr im;\n\tint e, st;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllllll\", &IM, &cx, &cy, &w, &h, &ST, &E, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\te = E;\n\tif (e < 0) {\n\t\te %= 360;\n\t}\n\n\tst = ST;\n\tif (st < 0) {\n\t\tst %= 360;\n\t}\n\n\tgdImageArc(im, cx, cy, w, h, st, e, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imageellipse(resource im, int cx, int cy, int w, int h, int color)\n   Draw an ellipse */\nPHP_FUNCTION(imageellipse)\n{\n\tzval *IM;\n\tlong cx, cy, w, h, color;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllll\", &IM, &cx, &cy, &w, &h, &color) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tgdImageEllipse(im, cx, cy, w, h, color);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagefilltoborder(resource im, int x, int y, int border, int col)\n   Flood fill to specific color */\nPHP_FUNCTION(imagefilltoborder)\n{\n\tzval *IM;\n\tlong x, y, border, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rllll\", &IM, &x, &y, &border, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageFillToBorder(im, x, y, border, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagefill(resource im, int x, int y, int col)\n   Flood fill */\nPHP_FUNCTION(imagefill)\n{\n\tzval *IM;\n\tlong x, y, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &x, &y, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageFill(im, x, y, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto int imagecolorstotal(resource im)\n   Find out the number of colors in an image's palette */\nPHP_FUNCTION(imagecolorstotal)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &IM) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageColorsTotal(im));\n}\n/* }}} */\n\n/* {{{ proto int imagecolortransparent(resource im [, int col])\n   Define a color as transparent */\nPHP_FUNCTION(imagecolortransparent)\n{\n\tzval *IM;\n\tlong COL = 0;\n\tgdImagePtr im;\n\tint argc = ZEND_NUM_ARGS();\n\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"r|l\", &IM, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (argc > 1) {\n\t\tgdImageColorTransparent(im, COL);\n\t}\n\n\tRETURN_LONG(gdImageGetTransparent(im));\n}\n/* }}} */\n\n/* {{{ proto int imageinterlace(resource im [, int interlace])\n   Enable or disable interlace */\nPHP_FUNCTION(imageinterlace)\n{\n\tzval *IM;\n\tint argc = ZEND_NUM_ARGS();\n\tlong INT = 0;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"r|l\", &IM, &INT) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (argc > 1) {\n\t\tgdImageInterlace(im, INT);\n\t}\n\n\tRETURN_LONG(gdImageGetInterlaced(im));\n}\n/* }}} */\n\n/* {{{ php_imagepolygon\n   arg = 0  normal polygon\n   arg = 1  filled polygon */\n/* im, points, num_points, col */\nstatic void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n{\n\tzval *IM, *POINTS;\n\tlong NPOINTS, COL;\n\tzval **var = NULL;\n\tgdImagePtr im;\n\tgdPointPtr points;\n\tint npoints, col, nelem, i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rall\", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tnpoints = NPOINTS;\n\tcol = COL;\n\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));\n\tif (nelem < 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have at least 3 points in your array\");\n\t\tRETURN_FALSE;\n\t}\n\tif (npoints <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must give a positive number of points\");\n\t\tRETURN_FALSE;\n\t}\n\tif (nelem < npoints * 2) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Trying to use %d points in array with only %d points\", npoints, nelem/2);\n\t\tRETURN_FALSE;\n\t}\n\n\tpoints = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);\n\n\tfor (i = 0; i < npoints; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **var;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\tpoints[i].x = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\tpoints[i].x = Z_LVAL_PP(var);\n\t\t\t}\n\t\t}\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **var;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\tpoints[i].y = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\tpoints[i].y = Z_LVAL_PP(var);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (filled) {\n\t\tgdImageFilledPolygon(im, points, npoints, col);\n\t} else {\n\t\tgdImagePolygon(im, points, npoints, col);\n\t}\n\n\tefree(points);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagepolygon(resource im, array point, int num_points, int col)\n   Draw a polygon */\nPHP_FUNCTION(imagepolygon)\n{\n\tphp_imagepolygon(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto bool imagefilledpolygon(resource im, array point, int num_points, int col)\n   Draw a filled polygon */\nPHP_FUNCTION(imagefilledpolygon)\n{\n\tphp_imagepolygon(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ php_find_gd_font\n */\nstatic gdFontPtr php_find_gd_font(int size TSRMLS_DC)\n{\n\tgdFontPtr font;\n\tint ind_type;\n\n\tswitch (size) {\n\t\tcase 1:\n\t\t\t font = gdFontTiny;\n\t\t\t break;\n\t\tcase 2:\n\t\t\t font = gdFontSmall;\n\t\t\t break;\n\t\tcase 3:\n\t\t\t font = gdFontMediumBold;\n\t\t\t break;\n\t\tcase 4:\n\t\t\t font = gdFontLarge;\n\t\t\t break;\n\t\tcase 5:\n\t\t\t font = gdFontGiant;\n\t\t\t break;\n\t\tdefault:\n\t\t\tfont = zend_list_find(size - 5, &ind_type);\n\t\t\t if (!font || ind_type != le_gd_font) {\n\t\t\t\t  if (size < 1) {\n\t\t\t\t\t   font = gdFontTiny;\n\t\t\t\t  } else {\n\t\t\t\t\t   font = gdFontGiant;\n\t\t\t\t  }\n\t\t\t }\n\t\t\t break;\n\t}\n\n\treturn font;\n}\n/* }}} */\n\n/* {{{ php_imagefontsize\n * arg = 0  ImageFontWidth\n * arg = 1  ImageFontHeight\n */\nstatic void php_imagefontsize(INTERNAL_FUNCTION_PARAMETERS, int arg)\n{\n\tlong SIZE;\n\tgdFontPtr font;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &SIZE) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfont = php_find_gd_font(SIZE TSRMLS_CC);\n\tRETURN_LONG(arg ? font->h : font->w);\n}\n/* }}} */\n\n/* {{{ proto int imagefontwidth(int font)\n   Get font width */\nPHP_FUNCTION(imagefontwidth)\n{\n\tphp_imagefontsize(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto int imagefontheight(int font)\n   Get font height */\nPHP_FUNCTION(imagefontheight)\n{\n\tphp_imagefontsize(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ php_gdimagecharup\n * workaround for a bug in gd 1.2 */\nstatic void php_gdimagecharup(gdImagePtr im, gdFontPtr f, int x, int y, int c, int color)\n{\n\tint cx, cy, px, py, fline;\n\tcx = 0;\n\tcy = 0;\n\n\tif ((c < f->offset) || (c >= (f->offset + f->nchars))) {\n\t\treturn;\n\t}\n\n\tfline = (c - f->offset) * f->h * f->w;\n\tfor (py = y; (py > (y - f->w)); py--) {\n\t\tfor (px = x; (px < (x + f->h)); px++) {\n\t\t\tif (f->data[fline + cy * f->w + cx]) {\n\t\t\t\tgdImageSetPixel(im, px, py, color);\n\t\t\t}\n\t\t\tcy++;\n\t\t}\n\t\tcy = 0;\n\t\tcx++;\n\t}\n}\n/* }}} */\n\n/* {{{ php_imagechar\n * arg = 0  ImageChar\n * arg = 1  ImageCharUp\n * arg = 2  ImageString\n * arg = 3  ImageStringUp\n */\nstatic void php_imagechar(INTERNAL_FUNCTION_PARAMETERS, int mode)\n{\n\tzval *IM;\n\tlong SIZE, X, Y, COL;\n\tchar *C;\n\tint C_len;\n\tgdImagePtr im;\n\tint ch = 0, col, x, y, size, i, l = 0;\n\tunsigned char *str = NULL;\n\tgdFontPtr font;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllsl\", &IM, &SIZE, &X, &Y, &C, &C_len, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tcol = COL;\n\n\tif (mode < 2) {\n\t\tch = (int)((unsigned char)*C);\n\t} else {\n\t\tstr = (unsigned char *) estrndup(C, C_len);\n\t\tl = strlen((char *)str);\n\t}\n\n\ty = Y;\n\tx = X;\n\tsize = SIZE;\n\n\tfont = php_find_gd_font(size TSRMLS_CC);\n\n\tswitch (mode) {\n\t\tcase 0:\n\t\t\tgdImageChar(im, font, x, y, ch, col);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tphp_gdimagecharup(im, font, x, y, ch, col);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfor (i = 0; (i < l); i++) {\n\t\t\t\tgdImageChar(im, font, x, y, (int) ((unsigned char) str[i]), col);\n\t\t\t\tx += font->w;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3: {\n\t\t\tfor (i = 0; (i < l); i++) {\n\t\t\t\t/* php_gdimagecharup(im, font, x, y, (int) str[i], col); */\n\t\t\t\tgdImageCharUp(im, font, x, y, (int) str[i], col);\n\t\t\t\ty -= font->w;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (str) {\n\t\tefree(str);\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagechar(resource im, int font, int x, int y, string c, int col)\n   Draw a character */\nPHP_FUNCTION(imagechar)\n{\n\tphp_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto bool imagecharup(resource im, int font, int x, int y, string c, int col)\n   Draw a character rotated 90 degrees counter-clockwise */\nPHP_FUNCTION(imagecharup)\n{\n\tphp_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ proto bool imagestring(resource im, int font, int x, int y, string str, int col)\n   Draw a string horizontally */\nPHP_FUNCTION(imagestring)\n{\n\tphp_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 2);\n}\n/* }}} */\n\n/* {{{ proto bool imagestringup(resource im, int font, int x, int y, string str, int col)\n   Draw a string vertically - rotated 90 degrees counter-clockwise */\nPHP_FUNCTION(imagestringup)\n{\n\tphp_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 3);\n}\n/* }}} */\n\n/* {{{ proto bool imagecopy(resource dst_im, resource src_im, int dst_x, int dst_y, int src_x, int src_y, int src_w, int src_h)\n   Copy part of an image */\nPHP_FUNCTION(imagecopy)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, srcY, srcX, dstY, dstX;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &SW, &SH) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\n\tgdImageCopy(im_dst, im_src, dstX, dstY, srcX, srcY, srcW, srcH);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagecopymerge(resource src_im, resource dst_im, int dst_x, int dst_y, int src_x, int src_y, int src_w, int src_h, int pct)\n   Merge one part of an image with another */\nPHP_FUNCTION(imagecopymerge)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY, PCT;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, srcY, srcX, dstY, dstX, pct;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrlllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &SW, &SH, &PCT) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\tpct  = PCT;\n\n\tgdImageCopyMerge(im_dst, im_src, dstX, dstY, srcX, srcY, srcW, srcH, pct);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagecopymergegray(resource src_im, resource dst_im, int dst_x, int dst_y, int src_x, int src_y, int src_w, int src_h, int pct)\n   Merge one part of an image with another */\nPHP_FUNCTION(imagecopymergegray)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY, PCT;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, srcY, srcX, dstY, dstX, pct;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrlllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &SW, &SH, &PCT) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\tpct  = PCT;\n\n\tgdImageCopyMergeGray(im_dst, im_src, dstX, dstY, srcX, srcY, srcW, srcH, pct);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagecopyresized(resource dst_im, resource src_im, int dst_x, int dst_y, int src_x, int src_y, int dst_w, int dst_h, int src_w, int src_h)\n   Copy and resize part of an image */\nPHP_FUNCTION(imagecopyresized)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY, DW, DH;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrllllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\tdstH = DH;\n\tdstW = DW;\n\n\tif (dstW <= 0 || dstH <= 0 || srcW <= 0 || srcH <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid image dimensions\");\n\t\tRETURN_FALSE;\n\t}\n\n\tgdImageCopyResized(im_dst, im_src, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto int imagesx(resource im)\n   Get image width */\nPHP_FUNCTION(imagesx)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &IM) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageSX(im));\n}\n/* }}} */\n\n/* {{{ proto int imagesy(resource im)\n   Get image height */\nPHP_FUNCTION(imagesy)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &IM) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageSY(im));\n}\n/* }}} */\n\n#ifdef ENABLE_GD_TTF\n#define TTFTEXT_DRAW 0\n#define TTFTEXT_BBOX 1\n#endif\n\n#ifdef ENABLE_GD_TTF\n\n#if HAVE_GD_FREETYPE && HAVE_LIBFREETYPE\n/* {{{ proto array imageftbbox(float size, float angle, string font_file, string text [, array extrainfo])\n   Give the bounding box of a text using fonts via freetype2 */\nPHP_FUNCTION(imageftbbox)\n{\n\tphp_imagettftext_common(INTERNAL_FUNCTION_PARAM_PASSTHRU, TTFTEXT_BBOX, 1);\n}\n/* }}} */\n\n/* {{{ proto array imagefttext(resource im, float size, float angle, int x, int y, int col, string font_file, string text [, array extrainfo])\n   Write text to the image using fonts via freetype2 */\nPHP_FUNCTION(imagefttext)\n{\n\tphp_imagettftext_common(INTERNAL_FUNCTION_PARAM_PASSTHRU, TTFTEXT_DRAW, 1);\n}\n/* }}} */\n#endif /* HAVE_GD_FREETYPE && HAVE_LIBFREETYPE */\n\n/* {{{ proto array imagettfbbox(float size, float angle, string font_file, string text)\n   Give the bounding box of a text using TrueType fonts */\nPHP_FUNCTION(imagettfbbox)\n{\n\tphp_imagettftext_common(INTERNAL_FUNCTION_PARAM_PASSTHRU, TTFTEXT_BBOX, 0);\n}\n/* }}} */\n\n/* {{{ proto array imagettftext(resource im, float size, float angle, int x, int y, int col, string font_file, string text)\n   Write text to the image using a TrueType font */\nPHP_FUNCTION(imagettftext)\n{\n\tphp_imagettftext_common(INTERNAL_FUNCTION_PARAM_PASSTHRU, TTFTEXT_DRAW, 0);\n}\n/* }}} */\n\n/* {{{ php_imagettftext_common\n */\nstatic void php_imagettftext_common(INTERNAL_FUNCTION_PARAMETERS, int mode, int extended)\n{\n\tzval *IM, *EXT = NULL;\n\tgdImagePtr im=NULL;\n\tlong col = -1, x = -1, y = -1;\n\tint str_len, fontname_len, i, brect[8];\n\tdouble ptsize, angle;\n\tchar *str = NULL, *fontname = NULL;\n\tchar *error = NULL;\n\tint argc = ZEND_NUM_ARGS();\n\tgdFTStringExtra strex = {0};\n\n\tif (mode == TTFTEXT_BBOX) {\n\t\tif (argc < 4 || argc > ((extended) ? 5 : 4)) {\n\t\t\tZEND_WRONG_PARAM_COUNT();\n\t\t} else if (zend_parse_parameters(argc TSRMLS_CC, \"ddss|a\", &ptsize, &angle, &fontname, &fontname_len, &str, &str_len, &EXT) == FAILURE) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tif (argc < 8 || argc > ((extended) ? 9 : 8)) {\n\t\t\tZEND_WRONG_PARAM_COUNT();\n\t\t} else if (zend_parse_parameters(argc TSRMLS_CC, \"rddlllss|a\", &IM, &ptsize, &angle, &x, &y, &col, &fontname, &fontname_len, &str, &str_len, &EXT) == FAILURE) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\t}\n\n\t/* convert angle to radians */\n\tangle = angle * (M_PI/180);\n\n\tif (extended && EXT) {\t/* parse extended info */\n\t\tHashPosition pos;\n\n\t\t/* walk the assoc array */\n\t\tzend_hash_internal_pointer_reset_ex(HASH_OF(EXT), &pos);\n\t\tdo {\n\t\t\tzval ** item;\n\t\t\tchar * key;\n\t\t\tulong num_key;\n\n\t\t\tif (zend_hash_get_current_key_ex(HASH_OF(EXT), &key, NULL, &num_key, 0, &pos) != HASH_KEY_IS_STRING) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (zend_hash_get_current_data_ex(HASH_OF(EXT), (void **) &item, &pos) == FAILURE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (strcmp(\"linespacing\", key) == 0) {\n\t\t\t\tconvert_to_double_ex(item);\n\t\t\t\tstrex.flags |= gdFTEX_LINESPACE;\n\t\t\t\tstrex.linespacing = Z_DVAL_PP(item);\n\t\t\t}\n\n\t\t} while (zend_hash_move_forward_ex(HASH_OF(EXT), &pos) == SUCCESS);\n\t}\n\n#ifdef VIRTUAL_DIR\n\t{\n\t\tchar tmp_font_path[MAXPATHLEN];\n\n\t\tif (!VCWD_REALPATH(fontname, tmp_font_path)) {\n\t\t\tfontname = NULL;\n\t\t}\n\t}\n#endif /* VIRTUAL_DIR */\n\n\tPHP_GD_CHECK_OPEN_BASEDIR(fontname, \"Invalid font filename\");\n\n#ifdef HAVE_GD_FREETYPE\n\tif (extended) {\n\t\terror = gdImageStringFTEx(im, brect, col, fontname, ptsize, angle, x, y, str, &strex);\n\t}\n\telse\n\t\terror = gdImageStringFT(im, brect, col, fontname, ptsize, angle, x, y, str);\n\n#endif /* HAVE_GD_FREETYPE */\n\n\tif (error) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", error);\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\t/* return array with the text's bounding box */\n\tfor (i = 0; i < 8; i++) {\n\t\tadd_next_index_long(return_value, brect[i]);\n\t}\n}\n/* }}} */\n#endif\t/* ENABLE_GD_TTF */\n\n#if HAVE_LIBT1\n\n/* {{{ php_free_ps_font\n */\nstatic void php_free_ps_font(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tint *font = (int *) rsrc->ptr;\n\n\tT1_DeleteFont(*font);\n\tefree(font);\n}\n/* }}} */\n\n/* {{{ php_free_ps_enc\n */\nstatic void php_free_ps_enc(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tchar **enc = (char **) rsrc->ptr;\n\n\tT1_DeleteEncoding(enc);\n}\n/* }}} */\n\n/* {{{ proto resource imagepsloadfont(string pathname)\n   Load a new font from specified file */\nPHP_FUNCTION(imagepsloadfont)\n{\n\tchar *file;\n\tint file_len, f_ind, *font;\n#ifdef PHP_WIN32\n\tstruct stat st;\n#endif\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p\", &file, &file_len) == FAILURE) {\n\t\treturn;\n\t}\n\n#ifdef PHP_WIN32\n\tif (VCWD_STAT(file, &st) < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Font file not found (%s)\", file);\n\t\tRETURN_FALSE;\n\t}\n#endif\n\n\tf_ind = T1_AddFont(file);\n\n\tif (f_ind < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"T1Lib Error (%i): %s\", f_ind, T1_StrError(f_ind));\n\t\tRETURN_FALSE;\n\t}\n\n\tif (T1_LoadFont(f_ind)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Couldn't load the font\");\n\t\tRETURN_FALSE;\n\t}\n\n\tfont = (int *) emalloc(sizeof(int));\n\t*font = f_ind;\n\tZEND_REGISTER_RESOURCE(return_value, font, le_ps_font);\n}\n/* }}} */\n\n/* {{{ proto int imagepscopyfont(int font_index)\n   Make a copy of a font for purposes like extending or reenconding */\n/* The function in t1lib which this function uses seem to be buggy...\nPHP_FUNCTION(imagepscopyfont)\n{\n\tint l_ind, type;\n\tgd_ps_font *nf_ind, *of_ind;\n\tlong fnt;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &fnt) == FAILURE) {\n\t\treturn;\n\t}\n\n\tof_ind = zend_list_find(fnt, &type);\n\n\tif (type != le_ps_font) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%ld is not a Type 1 font index\", fnt);\n\t\tRETURN_FALSE;\n\t}\n\n\tnf_ind = emalloc(sizeof(gd_ps_font));\n\tnf_ind->font_id = T1_CopyFont(of_ind->font_id);\n\n\tif (nf_ind->font_id < 0) {\n\t\tl_ind = nf_ind->font_id;\n\t\tefree(nf_ind);\n\t\tswitch (l_ind) {\n\t\t\tcase -1:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"FontID %d is not loaded in memory\", l_ind);\n\t\t\t\tRETURN_FALSE;\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Tried to copy a logical font\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t\tbreak;\n\t\t\tcase -3:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Memory allocation fault in t1lib\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"An unknown error occurred in t1lib\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tnf_ind->extend = 1;\n\tl_ind = zend_list_insert(nf_ind, le_ps_font TSRMLS_CC);\n\tRETURN_LONG(l_ind);\n}\n*/\n/* }}} */\n\n/* {{{ proto bool imagepsfreefont(resource font_index)\n   Free memory used by a font */\nPHP_FUNCTION(imagepsfreefont)\n{\n\tzval *fnt;\n\tint *f_ind;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &fnt) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\tzend_list_delete(Z_LVAL_P(fnt));\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagepsencodefont(resource font_index, string filename)\n   To change a fonts character encoding vector */\nPHP_FUNCTION(imagepsencodefont)\n{\n\tzval *fnt;\n\tchar *enc, **enc_vector;\n\tint enc_len, *f_ind;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rp\", &fnt, &enc, &enc_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n\tif ((enc_vector = T1_LoadEncoding(enc)) == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Couldn't load encoding vector from %s\", enc);\n\t\tRETURN_FALSE;\n\t}\n\n\tT1_DeleteAllSizes(*f_ind);\n\tif (T1_ReencodeFont(*f_ind, enc_vector)) {\n\t\tT1_DeleteEncoding(enc_vector);\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Couldn't re-encode font\");\n\t\tRETURN_FALSE;\n\t}\n\n\tzend_list_insert(enc_vector, le_ps_enc TSRMLS_CC);\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagepsextendfont(resource font_index, float extend)\n   Extend or or condense (if extend < 1) a font */\nPHP_FUNCTION(imagepsextendfont)\n{\n\tzval *fnt;\n\tdouble ext;\n\tint *f_ind;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rd\", &fnt, &ext) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n\tT1_DeleteAllSizes(*f_ind);\n\n\tif (ext <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Second parameter %F out of range (must be > 0)\", ext);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (T1_ExtendFont(*f_ind, ext) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagepsslantfont(resource font_index, float slant)\n   Slant a font */\nPHP_FUNCTION(imagepsslantfont)\n{\n\tzval *fnt;\n\tdouble slt;\n\tint *f_ind;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rd\", &fnt, &slt) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n\tif (T1_SlantFont(*f_ind, slt) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto array imagepstext(resource image, string text, resource font, int size, int foreground, int background, int xcoord, int ycoord [, int space [, int tightness [, float angle [, int antialias])\n   Rasterize a string over an image */\nPHP_FUNCTION(imagepstext)\n{\n\tzval *img, *fnt;\n\tint i, j;\n\tlong _fg, _bg, x, y, size, space = 0, aa_steps = 4, width = 0;\n\tint *f_ind;\n\tint h_lines, v_lines, c_ind;\n\tint rd, gr, bl, fg_rd, fg_gr, fg_bl, bg_rd, bg_gr, bg_bl;\n\tint fg_al, bg_al, al;\n\tint aa[16];\n\tint amount_kern, add_width;\n\tdouble angle = 0.0, extend;\n\tunsigned long aa_greys[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n\tgdImagePtr bg_img;\n\tGLYPH *str_img;\n\tT1_OUTLINE *char_path, *str_path;\n\tT1_TMATRIX *transform = NULL;\n\tchar *str;\n\tint str_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rsrlllll|lldl\", &img, &str, &str_len, &fnt, &size, &_fg, &_bg, &x, &y, &space, &width, &angle, &aa_steps) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (aa_steps != 4 && aa_steps != 16) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Antialias steps must be 4 or 16\");\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(bg_img, gdImagePtr, &img, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n\t/* Ensure that the provided colors are valid */\n\tif (_fg < 0 || (!gdImageTrueColor(bg_img) && _fg > gdImageColorsTotal(bg_img))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Foreground color index %ld out of range\", _fg);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (_bg < 0 || (!gdImageTrueColor(bg_img) && _fg > gdImageColorsTotal(bg_img))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Background color index %ld out of range\", _bg);\n\t\tRETURN_FALSE;\n\t}\n\n\tfg_rd = gdImageRed  (bg_img, _fg);\n\tfg_gr = gdImageGreen(bg_img, _fg);\n\tfg_bl = gdImageBlue (bg_img, _fg);\n\tfg_al = gdImageAlpha(bg_img, _fg);\n\n\tbg_rd = gdImageRed  (bg_img, _bg);\n\tbg_gr = gdImageGreen(bg_img, _bg);\n\tbg_bl = gdImageBlue (bg_img, _bg);\n\tbg_al = gdImageAlpha(bg_img, _bg);\n\n\tfor (i = 0; i < aa_steps; i++) {\n\t\trd = bg_rd + (double) (fg_rd - bg_rd) / aa_steps * (i + 1);\n\t\tgr = bg_gr + (double) (fg_gr - bg_gr) / aa_steps * (i + 1);\n\t\tbl = bg_bl + (double) (fg_bl - bg_bl) / aa_steps * (i + 1);\n\t\tal = bg_al + (double) (fg_al - bg_al) / aa_steps * (i + 1);\n\t\taa[i] = gdImageColorResolveAlpha(bg_img, rd, gr, bl, al);\n\t}\n\n\tT1_AASetBitsPerPixel(8);\n\n\tswitch (aa_steps) {\n\t\tcase 4:\n\t\t\tT1_AASetGrayValues(0, 1, 2, 3, 4);\n\t\t\tT1_AASetLevel(T1_AA_LOW);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tT1_AAHSetGrayValues(aa_greys);\n\t\t\tT1_AASetLevel(T1_AA_HIGH);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid value %ld as number of steps for antialiasing\", aa_steps);\n\t\t\tRETURN_FALSE;\n\t}\n\n\tif (angle) {\n\t\ttransform = T1_RotateMatrix(NULL, angle);\n\t}\n\n\tif (width) {\n\t\textend = T1_GetExtend(*f_ind);\n\t\tstr_path = T1_GetCharOutline(*f_ind, str[0], size, transform);\n\n\t\tif (!str_path) {\n\t\t\tif (T1_errno) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"T1Lib Error: %s\", T1_StrError(T1_errno));\n\t\t\t}\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tfor (i = 1; i < str_len; i++) {\n\t\t\tamount_kern = (int) T1_GetKerning(*f_ind, str[i - 1], str[i]);\n\t\t\tamount_kern += str[i - 1] == ' ' ? space : 0;\n\t\t\tadd_width = (int) (amount_kern + width) / extend;\n\n\t\t\tchar_path = T1_GetMoveOutline(*f_ind, add_width, 0, 0, size, transform);\n\t\t\tstr_path = T1_ConcatOutlines(str_path, char_path);\n\n\t\t\tchar_path = T1_GetCharOutline(*f_ind, str[i], size, transform);\n\t\t\tstr_path = T1_ConcatOutlines(str_path, char_path);\n\t\t}\n\t\tstr_img = T1_AAFillOutline(str_path, 0);\n\t} else {\n\t\tstr_img = T1_AASetString(*f_ind, str,  str_len, space, T1_KERNING, size, transform);\n\t}\n\tif (T1_errno) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"T1Lib Error: %s\", T1_StrError(T1_errno));\n\t\tRETURN_FALSE;\n\t}\n\n\th_lines = str_img->metrics.ascent -  str_img->metrics.descent;\n\tv_lines = str_img->metrics.rightSideBearing - str_img->metrics.leftSideBearing;\n\n\tfor (i = 0; i < v_lines; i++) {\n\t\tfor (j = 0; j < h_lines; j++) {\n\t\t\tswitch (str_img->bits[j * v_lines + i]) {\n\t\t\t\tcase 0:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tc_ind = aa[str_img->bits[j * v_lines + i] - 1];\n\t\t\t\t\tgdImageSetPixel(bg_img, x + str_img->metrics.leftSideBearing + i, y - str_img->metrics.ascent + j, c_ind);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tarray_init(return_value);\n\n\tadd_next_index_long(return_value, str_img->metrics.leftSideBearing);\n\tadd_next_index_long(return_value, str_img->metrics.descent);\n\tadd_next_index_long(return_value, str_img->metrics.rightSideBearing);\n\tadd_next_index_long(return_value, str_img->metrics.ascent);\n}\n/* }}} */\n\n/* {{{ proto array imagepsbbox(string text, resource font, int size [, int space, int tightness, float angle])\n   Return the bounding box needed by a string if rasterized */\nPHP_FUNCTION(imagepsbbox)\n{\n\tzval *fnt;\n\tlong sz = 0, sp = 0, wd = 0;\n\tchar *str;\n\tint i, space = 0, add_width = 0, char_width, amount_kern;\n\tint cur_x, cur_y, dx, dy;\n\tint x1, y1, x2, y2, x3, y3, x4, y4;\n\tint *f_ind;\n\tint str_len, per_char = 0;\n\tint argc = ZEND_NUM_ARGS();\n\tdouble angle = 0, sin_a = 0, cos_a = 0;\n\tBBox char_bbox, str_bbox = {0, 0, 0, 0};\n\n\tif (argc != 3 && argc != 6) {\n\t\tZEND_WRONG_PARAM_COUNT();\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"srl|lld\", &str, &str_len, &fnt, &sz, &sp, &wd, &angle) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (argc == 6) {\n\t\tspace = sp;\n\t\tadd_width = wd;\n\t\tangle = angle * M_PI / 180;\n\t\tsin_a = sin(angle);\n\t\tcos_a = cos(angle);\n\t\tper_char =  add_width || angle ? 1 : 0;\n\t}\n\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n#define max(a, b) (a > b ? a : b)\n#define min(a, b) (a < b ? a : b)\n#define new_x(a, b) (int) ((a) * cos_a - (b) * sin_a)\n#define new_y(a, b) (int) ((a) * sin_a + (b) * cos_a)\n\n\tif (per_char) {\n\t\tspace += T1_GetCharWidth(*f_ind, ' ');\n\t\tcur_x = cur_y = 0;\n\n\t\tfor (i = 0; i < str_len; i++) {\n\t\t\tif (str[i] == ' ') {\n\t\t\t\tchar_bbox.llx = char_bbox.lly = char_bbox.ury = 0;\n\t\t\t\tchar_bbox.urx = char_width = space;\n\t\t\t} else {\n\t\t\t\tchar_bbox = T1_GetCharBBox(*f_ind, str[i]);\n\t\t\t\tchar_width = T1_GetCharWidth(*f_ind, str[i]);\n\t\t\t}\n\t\t\tamount_kern = i ? T1_GetKerning(*f_ind, str[i - 1], str[i]) : 0;\n\n\t\t\t/* Transfer character bounding box to right place */\n\t\t\tx1 = new_x(char_bbox.llx, char_bbox.lly) + cur_x;\n\t\t\ty1 = new_y(char_bbox.llx, char_bbox.lly) + cur_y;\n\t\t\tx2 = new_x(char_bbox.llx, char_bbox.ury) + cur_x;\n\t\t\ty2 = new_y(char_bbox.llx, char_bbox.ury) + cur_y;\n\t\t\tx3 = new_x(char_bbox.urx, char_bbox.ury) + cur_x;\n\t\t\ty3 = new_y(char_bbox.urx, char_bbox.ury) + cur_y;\n\t\t\tx4 = new_x(char_bbox.urx, char_bbox.lly) + cur_x;\n\t\t\ty4 = new_y(char_bbox.urx, char_bbox.lly) + cur_y;\n\n\t\t\t/* Find min & max values and compare them with current bounding box */\n\t\t\tstr_bbox.llx = min(str_bbox.llx, min(x1, min(x2, min(x3, x4))));\n\t\t\tstr_bbox.lly = min(str_bbox.lly, min(y1, min(y2, min(y3, y4))));\n\t\t\tstr_bbox.urx = max(str_bbox.urx, max(x1, max(x2, max(x3, x4))));\n\t\t\tstr_bbox.ury = max(str_bbox.ury, max(y1, max(y2, max(y3, y4))));\n\n\t\t\t/* Move to the next base point */\n\t\t\tdx = new_x(char_width + add_width + amount_kern, 0);\n\t\t\tdy = new_y(char_width + add_width + amount_kern, 0);\n\t\t\tcur_x += dx;\n\t\t\tcur_y += dy;\n\t\t\t/*\n\t\t\tprintf(\"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\n\", x1, y1, x2, y2, x3, y3, x4, y4, char_bbox.llx, char_bbox.lly, char_bbox.urx, char_bbox.ury, char_width, amount_kern, cur_x, cur_y, dx, dy);\n\t\t\t*/\n\t\t}\n\n\t} else {\n\t\tstr_bbox = T1_GetStringBBox(*f_ind, str, str_len, space, T1_KERNING);\n\t}\n\n\tif (T1_errno) {\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\t/*\n\tprintf(\"%d %d %d %d\\n\", str_bbox.llx, str_bbox.lly, str_bbox.urx, str_bbox.ury);\n\t*/\n\tadd_next_index_long(return_value, (int) ceil(((double) str_bbox.llx)*sz/1000));\n\tadd_next_index_long(return_value, (int) ceil(((double) str_bbox.lly)*sz/1000));\n\tadd_next_index_long(return_value, (int) ceil(((double) str_bbox.urx)*sz/1000));\n\tadd_next_index_long(return_value, (int) ceil(((double) str_bbox.ury)*sz/1000));\n}\n/* }}} */\n#endif\n\n/* {{{ proto bool image2wbmp(resource im [, string filename [, int threshold]])\n   Output WBMP image to browser or file */\nPHP_FUNCTION(image2wbmp)\n{\n\t_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_CONVERT_WBM, \"WBMP\", _php_image_bw_convert);\n}\n/* }}} */\n\n#if defined(HAVE_GD_JPG)\n/* {{{ proto bool jpeg2wbmp (string f_org, string f_dest, int d_height, int d_width, int threshold)\n   Convert JPEG image to WBMP image */\nPHP_FUNCTION(jpeg2wbmp)\n{\n\t_php_image_convert(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_JPG);\n}\n/* }}} */\n#endif\n\n#if defined(HAVE_GD_PNG)\n/* {{{ proto bool png2wbmp (string f_org, string f_dest, int d_height, int d_width, int threshold)\n   Convert PNG image to WBMP image */\nPHP_FUNCTION(png2wbmp)\n{\n\t_php_image_convert(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG);\n}\n/* }}} */\n#endif\n\n/* {{{ _php_image_bw_convert\n * It converts a gd Image to bw using a threshold value */\nstatic void _php_image_bw_convert(gdImagePtr im_org, gdIOCtx *out, int threshold)\n{\n\tgdImagePtr im_dest;\n\tint white, black;\n\tint color, color_org, median;\n\tint dest_height = gdImageSY(im_org);\n\tint dest_width = gdImageSX(im_org);\n\tint x, y;\n\tTSRMLS_FETCH();\n\n\tim_dest = gdImageCreate(dest_width, dest_height);\n\tif (im_dest == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate temporary buffer\");\n\t\treturn;\n\t}\n\n\twhite = gdImageColorAllocate(im_dest, 255, 255, 255);\n\tif (white == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate the colors for the destination buffer\");\n\t\treturn;\n\t}\n\n\tblack = gdImageColorAllocate(im_dest, 0, 0, 0);\n\tif (black == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate the colors for the destination buffer\");\n\t\treturn;\n\t}\n\n\tif (im_org->trueColor) {\n\t\tgdImageTrueColorToPalette(im_org, 1, 256);\n\t}\n\n\tfor (y = 0; y < dest_height; y++) {\n\t\tfor (x = 0; x < dest_width; x++) {\n\t\t\tcolor_org = gdImageGetPixel(im_org, x, y);\n\t\t\tmedian = (im_org->red[color_org] + im_org->green[color_org] + im_org->blue[color_org]) / 3;\n\t\t\tif (median < threshold) {\n\t\t\t\tcolor = black;\n\t\t\t} else {\n\t\t\t\tcolor = white;\n\t\t\t}\n\t\t\tgdImageSetPixel (im_dest, x, y, color);\n\t\t}\n\t}\n\tgdImageWBMPCtx (im_dest, black, out);\n\n}\n/* }}} */\n\n/* {{{ _php_image_convert\n * _php_image_convert converts jpeg/png images to wbmp and resizes them as needed  */\nstatic void _php_image_convert(INTERNAL_FUNCTION_PARAMETERS, int image_type )\n{\n\tchar *f_org, *f_dest;\n\tint f_org_len, f_dest_len;\n\tlong height, width, threshold;\n\tgdImagePtr im_org, im_dest, im_tmp;\n\tchar *fn_org = NULL;\n\tchar *fn_dest = NULL;\n\tFILE *org, *dest;\n\tint dest_height = -1;\n\tint dest_width = -1;\n\tint org_height, org_width;\n\tint white, black;\n\tint color, color_org, median;\n\tint int_threshold;\n\tint x, y;\n\tfloat x_ratio, y_ratio;\n    long ignore_warning;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pplll\", &f_org, &f_org_len, &f_dest, &f_dest_len, &height, &width, &threshold) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfn_org  = f_org;\n\tfn_dest = f_dest;\n\tdest_height = height;\n\tdest_width = width;\n\tint_threshold = threshold;\n\n\t/* Check threshold value */\n\tif (int_threshold < 0 || int_threshold > 8) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid threshold value '%d'\", int_threshold);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Check origin file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_org, \"Invalid origin filename\");\n\n\t/* Check destination file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_dest, \"Invalid destination filename\");\n\n\t/* Open origin file */\n\torg = VCWD_FOPEN(fn_org, \"rb\");\n\tif (!org) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' for reading\", fn_org);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Open destination file */\n\tdest = VCWD_FOPEN(fn_dest, \"wb\");\n\tif (!dest) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' for writing\", fn_dest);\n\t\tRETURN_FALSE;\n\t}\n\n\tswitch (image_type) {\n\t\tcase PHP_GDIMG_TYPE_GIF:\n\t\t\tim_org = gdImageCreateFromGif(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' Not a valid GIF file\", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef HAVE_GD_JPG\n\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\tignore_warning = INI_INT(\"gd.jpeg_ignore_warning\");\n\t\t\tim_org = gdImageCreateFromJpegEx(org, ignore_warning);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' Not a valid JPEG file\", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_JPG */\n\n#ifdef HAVE_GD_PNG\n\t\tcase PHP_GDIMG_TYPE_PNG:\n\t\t\tim_org = gdImageCreateFromPng(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' Not a valid PNG file\", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_PNG */\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Format not supported\");\n\t\t\tRETURN_FALSE;\n\t\t\tbreak;\n\t}\n\n\torg_width  = gdImageSX (im_org);\n\torg_height = gdImageSY (im_org);\n\n\tx_ratio = (float) org_width / (float) dest_width;\n\ty_ratio = (float) org_height / (float) dest_height;\n\n\tif (x_ratio > 1 && y_ratio > 1) {\n\t\tif (y_ratio > x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width / x_ratio);\n\t\tdest_height = (int) (org_height / y_ratio);\n\t} else {\n\t\tx_ratio = (float) dest_width / (float) org_width;\n\t\ty_ratio = (float) dest_height / (float) org_height;\n\n\t\tif (y_ratio < x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width * x_ratio);\n\t\tdest_height = (int) (org_height * y_ratio);\n\t}\n\n\tim_tmp = gdImageCreate (dest_width, dest_height);\n\tif (im_tmp == NULL ) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate temporary buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\tgdImageCopyResized (im_tmp, im_org, 0, 0, 0, 0, dest_width, dest_height, org_width, org_height);\n\n\tgdImageDestroy(im_org);\n\n\tfclose(org);\n\n\tim_dest = gdImageCreate(dest_width, dest_height);\n\tif (im_dest == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate destination buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\twhite = gdImageColorAllocate(im_dest, 255, 255, 255);\n\tif (white == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate the colors for the destination buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\tblack = gdImageColorAllocate(im_dest, 0, 0, 0);\n\tif (black == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate the colors for the destination buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\tint_threshold = int_threshold * 32;\n\n\tfor (y = 0; y < dest_height; y++) {\n\t\tfor (x = 0; x < dest_width; x++) {\n\t\t\tcolor_org = gdImageGetPixel (im_tmp, x, y);\n\t\t\tmedian = (im_tmp->red[color_org] + im_tmp->green[color_org] + im_tmp->blue[color_org]) / 3;\n\t\t\tif (median < int_threshold) {\n\t\t\t\tcolor = black;\n\t\t\t} else {\n\t\t\t\tcolor = white;\n\t\t\t}\n\t\t\tgdImageSetPixel (im_dest, x, y, color);\n\t\t}\n\t}\n\n\tgdImageDestroy (im_tmp );\n\n\tgdImageWBMP(im_dest, black , dest);\n\n\tfflush(dest);\n\tfclose(dest);\n\n\tgdImageDestroy(im_dest);\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* Section Filters */\n#define PHP_GD_SINGLE_RES\t\\\n\tzval *SIM;\t\\\n\tgdImagePtr im_src;\t\\\n\tif (zend_parse_parameters(1 TSRMLS_CC, \"r\", &SIM) == FAILURE) {\t\\\n\t\tRETURN_FALSE;\t\\\n\t}\t\\\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\t\\\n\tif (im_src == NULL) {\t\\\n\t\tRETURN_FALSE;\t\\\n\t}\n\nstatic void php_image_filter_negate(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageNegate(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_grayscale(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageGrayScale(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_brightness(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *SIM;\n\tgdImagePtr im_src;\n\tlong brightness, tmp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zll\", &SIM, &tmp, &brightness) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tif (im_src == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImageBrightness(im_src, (int)brightness) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_contrast(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *SIM;\n\tgdImagePtr im_src;\n\tlong contrast, tmp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rll\", &SIM, &tmp, &contrast) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tif (im_src == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImageContrast(im_src, (int)contrast) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_colorize(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *SIM;\n\tgdImagePtr im_src;\n\tlong r,g,b,tmp;\n\tlong a = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rllll|l\", &SIM, &tmp, &r, &g, &b, &a) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tif (im_src == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImageColor(im_src, (int) r, (int) g, (int) b, (int) a) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_edgedetect(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageEdgeDetectQuick(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_emboss(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageEmboss(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_gaussian_blur(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageGaussianBlur(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_selective_blur(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageSelectiveBlur(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_mean_removal(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageMeanRemoval(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_smooth(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *SIM;\n\tlong tmp;\n\tgdImagePtr im_src;\n\tdouble weight;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rld\", &SIM, &tmp, &weight) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tif (im_src == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImageSmooth(im_src, (float)weight)==1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_pixelate(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tlong tmp, blocksize;\n\tzend_bool mode = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rll|b\", &IM, &tmp, &blocksize, &mode) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (im == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImagePixelate(im, (int) blocksize, (const unsigned int) mode)) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\n/* {{{ proto bool imagefilter(resource src_im, int filtertype, [args] )\n   Applies Filter an image using a custom angle */\nPHP_FUNCTION(imagefilter)\n{\n\tzval *tmp;\n\n\ttypedef void (*image_filter)(INTERNAL_FUNCTION_PARAMETERS);\n\tlong filtertype;\n\timage_filter filters[] =\n\t{\n\t\tphp_image_filter_negate ,\n\t\tphp_image_filter_grayscale,\n\t\tphp_image_filter_brightness,\n\t\tphp_image_filter_contrast,\n\t\tphp_image_filter_colorize,\n\t\tphp_image_filter_edgedetect,\n\t\tphp_image_filter_emboss,\n\t\tphp_image_filter_gaussian_blur,\n\t\tphp_image_filter_selective_blur,\n\t\tphp_image_filter_mean_removal,\n\t\tphp_image_filter_smooth,\n\t\tphp_image_filter_pixelate\n\t};\n\n\tif (ZEND_NUM_ARGS() < 2 || ZEND_NUM_ARGS() > IMAGE_FILTER_MAX_ARGS) {\n\t\tWRONG_PARAM_COUNT;\n\t} else if (zend_parse_parameters(2 TSRMLS_CC, \"rl\", &tmp, &filtertype) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (filtertype >= 0 && filtertype <= IMAGE_FILTER_MAX) {\n\t\tfilters[filtertype](INTERNAL_FUNCTION_PARAM_PASSTHRU);\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource imageconvolution(resource src_im, array matrix3x3, double div, double offset)\n   Apply a 3x3 convolution matrix, using coefficient div and offset */\nPHP_FUNCTION(imageconvolution)\n{\n\tzval *SIM, *hash_matrix;\n\tzval **var = NULL, **var2 = NULL;\n\tgdImagePtr im_src = NULL;\n\tdouble div, offset;\n\tint nelem, i, j, res;\n\tfloat matrix[3][3] = {{0,0,0}, {0,0,0}, {0,0,0}};\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"radd\", &SIM, &hash_matrix, &div, &offset) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(hash_matrix));\n\tif (nelem != 3) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have 3x3 array\");\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i=0; i<3; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(hash_matrix), (i), (void **) &var) == SUCCESS && Z_TYPE_PP(var) == IS_ARRAY) {\n\t\t\tif (Z_TYPE_PP(var) != IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_PP(var)) != 3 ) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have 3x3 array\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tfor (j=0; j<3; j++) {\n\t\t\t\tif (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {\n\t\t\t\t\tif (Z_TYPE_PP(var2) != IS_DOUBLE) {\n\t\t\t\t\t\tzval dval;\n\t\t\t\t\t\tdval = **var2;\n\t\t\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\t\t\tconvert_to_double(&dval);\n\t\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL(dval);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL_PP(var2);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have a 3x3 matrix\");\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres = gdImageConvolution(im_src, matrix, (float)div, (float)offset);\n\n\tif (res) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n/* End section: Filters */\n\n/* {{{ proto void imageflip(resource im, int mode)\n   Flip an image (in place) horizontally, vertically or both directions. */\nPHP_FUNCTION(imageflip)\n{\n\tzval *IM;\n\tlong mode;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &IM, &mode) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tswitch (mode) {\n\t\tcase GD_FLIP_VERTICAL:\n\t\t\tgdImageFlipVertical(im);\n\t\t\tbreak;\n\n\t\tcase GD_FLIP_HORINZONTAL:\n\t\t\tgdImageFlipHorizontal(im);\n\t\t\tbreak;\n\n\t\tcase GD_FLIP_BOTH:\n\t\t\tgdImageFlipBoth(im);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown flip mode\");\n\t\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n#ifdef HAVE_GD_BUNDLED\n/* {{{ proto bool imageantialias(resource im, bool on)\n   Should antialiased functions used or not*/\nPHP_FUNCTION(imageantialias)\n{\n\tzval *IM;\n\tzend_bool alias;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rb\", &IM, &alias) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageAntialias(im, alias);\n\tRETURN_TRUE;\n}\n/* }}} */\n#endif\n\n/* {{{ proto void imagecrop(resource im, array rect)\n   Crop an image using the given coordinates and size, x, y, width and height. */\nPHP_FUNCTION(imagecrop)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tgdImagePtr im_crop;\n\tgdRect rect;\n\tzval *z_rect;\n\tzval **tmp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra\", &IM, &z_rect) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (zend_hash_find(HASH_OF(z_rect), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\tzval lval;\n\t\t\tlval = **tmp;\n\t\t\tzval_copy_ctor(&lval);\n\t\t\tconvert_to_long(&lval);\n\t\t\trect.x = Z_LVAL(lval);\n\t\t} else {\n\t\t\trect.x = Z_LVAL_PP(tmp);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_hash_find(HASH_OF(z_rect), \"y\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\tzval lval;\n\t\t\tlval = **tmp;\n\t\t\tzval_copy_ctor(&lval);\n\t\t\tconvert_to_long(&lval);\n\t\t\trect.y = Z_LVAL(lval);\n\t\t} else {\n\t\t\trect.y = Z_LVAL_PP(tmp);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_hash_find(HASH_OF(z_rect), \"width\", sizeof(\"width\"), (void **)&tmp) != FAILURE) {\n\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\tzval lval;\n\t\t\tlval = **tmp;\n\t\t\tzval_copy_ctor(&lval);\n\t\t\tconvert_to_long(&lval);\n\t\t\trect.width = Z_LVAL(lval);\n\t\t} else {\n\t\t\trect.width = Z_LVAL_PP(tmp);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing width\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_hash_find(HASH_OF(z_rect), \"height\", sizeof(\"height\"), (void **)&tmp) != FAILURE) {\n\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\tzval lval;\n\t\t\tlval = **tmp;\n\t\t\tzval_copy_ctor(&lval);\n\t\t\tconvert_to_long(&lval);\n\t\t\trect.height = Z_LVAL(lval);\n\t\t} else {\n\t\t\trect.height = Z_LVAL_PP(tmp);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing height\");\n\t\tRETURN_FALSE;\n\t}\n\n\tim_crop = gdImageCrop(im, &rect);\n\n\tif (im_crop == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);\n\t}\n}\n/* }}} */\n\n/* {{{ proto void imagecropauto(resource im [, int mode [, threshold [, color]]])\n   Crop an image automatically using one of the available modes. */\nPHP_FUNCTION(imagecropauto)\n{\n\tzval *IM;\n\tlong mode = -1;\n\tlong color = -1;\n\tdouble threshold = 0.5f;\n\tgdImagePtr im;\n\tgdImagePtr im_crop;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|ldl\", &IM, &mode, &threshold, &color) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tswitch (mode) {\n\t\tcase -1:\n\t\t\tmode = GD_CROP_DEFAULT;\n\t\tcase GD_CROP_DEFAULT:\n\t\tcase GD_CROP_TRANSPARENT:\n\t\tcase GD_CROP_BLACK:\n\t\tcase GD_CROP_WHITE:\n\t\tcase GD_CROP_SIDES:\n\t\t\tim_crop = gdImageCropAuto(im, mode);\n\t\t\tbreak;\n\n\t\tcase GD_CROP_THRESHOLD:\n\t\t\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Color argument missing with threshold mode\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tim_crop = gdImageCropThreshold(im, color, (float) threshold);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown crop mode\");\n\t\t\tRETURN_FALSE;\n\t}\n\tif (im_crop == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource imagescale(resource im, new_width[, new_height[, method]])\n   Scale an image using the given new width and height. */\nPHP_FUNCTION(imagescale)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tgdImagePtr im_scaled = NULL;\n\tint new_width, new_height;\n\tlong tmp_w, tmp_h=-1, tmp_m = GD_BILINEAR_FIXED;\n\tgdInterpolationMethod method;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl|ll\", &IM, &tmp_w, &tmp_h, &tmp_m) == FAILURE)  {\n\t\treturn;\n\t}\n\tmethod = tmp_m;\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (tmp_h < 0) {\n\t\t/* preserve ratio */\n\t\tlong src_x, src_y;\n\n\t\tsrc_x = gdImageSX(im);\n\t\tsrc_y = gdImageSY(im);\n\t\tif (src_x) {\n\t\t\ttmp_h = tmp_w * src_y / src_x;\n\t\t}\n\t}\n\n\tif (tmp_h <= 0 || tmp_w <= 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tnew_width = tmp_w;\n\tnew_height = tmp_h;\n\n\tif (gdImageSetInterpolationMethod(im, method)) {\n\t\tim_scaled = gdImageScale(im, new_width, new_height);\n\t}\n\n\tif (im_scaled == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_scaled, le_gd);\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource imageaffine(resource src, array affine[, array clip])\n   Return an image containing the affine tramsformed src image, using an optional clipping area */\nPHP_FUNCTION(imageaffine)\n{\n\tzval *IM;\n\tgdImagePtr src;\n\tgdImagePtr dst;\n\tgdRect rect;\n\tgdRectPtr pRect = NULL;\n\tzval *z_rect = NULL;\n\tzval *z_affine;\n\tzval **tmp;\n\tdouble affine[6];\n\tint i, nelems;\n\tzval **zval_affine_elem = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra|a\", &IM, &z_affine, &z_rect) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(src, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif ((nelems = zend_hash_num_elements(Z_ARRVAL_P(z_affine))) != 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Affine array must have six elements\");\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i = 0; i < nelems; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(z_affine), i, (void **) &zval_affine_elem) == SUCCESS) {\n\t\t\tswitch (Z_TYPE_PP(zval_affine_elem)) {\n\t\t\t\tcase IS_LONG:\n\t\t\t\t\taffine[i]  = Z_LVAL_PP(zval_affine_elem);\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_DOUBLE:\n\t\t\t\t\taffine[i] = Z_DVAL_PP(zval_affine_elem);\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_STRING:\n\t\t\t\t\t{\n\t\t\t\t\t\tzval dval;\n\t\t\t\t\t\tdval = **zval_affine_elem;\n\t\t\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\t\t\tconvert_to_double(&dval);\n\t\t\t\t\t\taffine[i] = Z_DVAL(dval);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %i\", i);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (z_rect != NULL) {\n\t\tif (zend_hash_find(HASH_OF(z_rect), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **tmp;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\trect.x = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\trect.x = Z_LVAL_PP(tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tif (zend_hash_find(HASH_OF(z_rect), \"y\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **tmp;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\trect.y = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\trect.y = Z_LVAL_PP(tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tif (zend_hash_find(HASH_OF(z_rect), \"width\", sizeof(\"width\"), (void **)&tmp) != FAILURE) {\n\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **tmp;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\trect.width = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\trect.width = Z_LVAL_PP(tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing width\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tif (zend_hash_find(HASH_OF(z_rect), \"height\", sizeof(\"height\"), (void **)&tmp) != FAILURE) {\n\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **tmp;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\trect.height = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\trect.height = Z_LVAL_PP(tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing height\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tpRect = &rect;\n\t} else {\n\t\trect.x = -1;\n\t\trect.y = -1;\n\t\trect.width = gdImageSX(src);\n\t\trect.height = gdImageSY(src);\n\t\tpRect = NULL;\n\t}\n\n\tif (gdTransformAffineGetImage(&dst, src, pRect, affine) != GD_TRUE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (dst == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, dst, le_gd);\n\t}\n}\n/* }}} */\n\n/* {{{ proto array imageaffinematrixget(type[, options])\n   Return an image containing the affine tramsformed src image, using an optional clipping area */\nPHP_FUNCTION(imageaffinematrixget)\n{\n\tdouble affine[6];\n\tlong type;\n\tzval *options = NULL;\n\tzval **tmp;\n\tint res = GD_FALSE, i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|z\", &type, &options) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tswitch((gdAffineStandardMatrix)type) {\n\t\tcase GD_AFFINE_TRANSLATE:\n\t\tcase GD_AFFINE_SCALE: {\n\t\t\tdouble x, y;\n\t\t\tif (!options || Z_TYPE_P(options) != IS_ARRAY) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Array expected as options\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tif (zend_hash_find(HASH_OF(options), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\n\t\t\t\t\tzval dval;\n\t\t\t\t\tdval = **tmp;\n\t\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\t\tconvert_to_double(&dval);\n\t\t\t\t\tx = Z_DVAL(dval);\n\t\t\t\t} else {\n\t\t\t\t\tx = Z_DVAL_PP(tmp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tif (zend_hash_find(HASH_OF(options), \"y\", sizeof(\"y\"), (void **)&tmp) != FAILURE) {\n\t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\n\t\t\t\t\tzval dval;\n\t\t\t\t\tdval = **tmp;\n\t\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\t\tconvert_to_double(&dval);\n\t\t\t\t\ty = Z_DVAL(dval);\n\t\t\t\t} else {\n\t\t\t\t\ty = Z_DVAL_PP(tmp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tif (type == GD_AFFINE_TRANSLATE) {\n\t\t\t\tres = gdAffineTranslate(affine, x, y);\n\t\t\t} else {\n\t\t\t\tres = gdAffineScale(affine, x, y);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase GD_AFFINE_ROTATE:\n\t\tcase GD_AFFINE_SHEAR_HORIZONTAL:\n\t\tcase GD_AFFINE_SHEAR_VERTICAL: {\n\t\t\tdouble angle;\n\n\t\t\tif (!options) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Number is expected as option\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tif(Z_TYPE_P(options) != IS_DOUBLE) {\n\t\t\t\tzval dval;\n\t\t\t\tdval = *options;\n\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\tconvert_to_double(&dval);\n\t\t\t\tangle = Z_DVAL(dval);\n\t\t\t} else {\n\t\t\t\tangle = Z_DVAL_P(options);\n\t\t\t}\n\n\t\t\tif (type == GD_AFFINE_SHEAR_HORIZONTAL) {\n\t\t\t\tres = gdAffineShearHorizontal(affine, angle);\n\t\t\t} else if (type == GD_AFFINE_SHEAR_VERTICAL) {\n\t\t\t\tres = gdAffineShearVertical(affine, angle);\n\t\t\t} else {\n\t\t\t\tres = gdAffineRotate(affine, angle);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %li\", type);\n\t\t\tRETURN_FALSE;\n\t}\n\n\tif (res == GD_FALSE) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tarray_init(return_value);\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tadd_index_double(return_value, i, affine[i]);\n\t\t}\n\t}\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n",
        "src_path": "1bd103df00f49cf4d4ade2cfe3f456ac058a4eae___gd.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/1bd103df00f49cf4d4ade2cfe3f456ac058a4eae",
        "commit_msg": "Fix bug #72730 - imagegammacorrect allows arbitrary write access",
        "test_func_diff": [
            {
                "fn": "ext/gd/tests/bug72730.phpt",
                "patch": "@@ -0,0 +1,15 @@\n+--TEST--\n+Bug #72730: imagegammacorrect allows arbitrary write access\n+--SKIPIF--\n+<?php \n+if (!function_exists(\"imagecreatetruecolor\")) die(\"skip\");\n+?>\n+--FILE--\n+<?php\n+$img =  imagecreatetruecolor(1, 1);\n+imagegammacorrect($img, -1, 1337);\n+?>\n+DONE\n+--EXPECTF--\n+Warning: imagegammacorrect(): Gamma values should be positive in %sbug72730.php on line %d\n+DONE\n\\ No newline at end of file"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.26-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_1bd103df00f49cf4d4ade2cfe3f456ac058a4eae More .INIs : CWD : /out/php___php-src/git_repo_dir_1bd103df00f49cf4d4ade2cfe3f456ac058a4eae Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/gd/tests/bug72730.phpt]\rFAIL Bug #72730: imagegammacorrect allows arbitrary write access [ext/gd/tests/bug72730.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72730: imagegammacorrect allows arbitrary write access [ext/gd/tests/bug72730.phpt] =====================================================================\n"
    },
    "3530bcc30350d4a6ccf35d2f7b33e23292b9de70___idna.c": {
        "prefix": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n",
        "suffix": "\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* \u3002 */\n        if (c != 0xFF0E)  /* \uff0e */\n          if (c != 0xFF61)  /* \uff61 */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d >= de)\n    return UV_EINVAL;\n\n  *d++ = '\\0';\n  return d - ds;  /* Number of bytes written. */\n}\n",
        "start": 318,
        "end": 364,
        "buggy": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* \u3002 */\n        if (c != 0xFF0E)  /* \uff0e */\n          if (c != 0xFF61)  /* \uff61 */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d >= de)\n    return UV_EINVAL;\n\n  *d++ = '\\0';\n  return d - ds;  /* Number of bytes written. */\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  ds = d;\n",
        "src_path": "3530bcc30350d4a6ccf35d2f7b33e23292b9de70___idna.c",
        "uri": "https://api.github.com/repos/libuv/libuv/commits/3530bcc30350d4a6ccf35d2f7b33e23292b9de70",
        "commit_msg": "fix: reject zero-length idna inputs\n\nFixes: https://github.com/libuv/libuv/security/advisories/GHSA-f74f-cvh7-c6q6",
        "test_func_diff": [
            {
                "fn": "test/test-idna.c",
                "patch": "@@ -115,6 +115,7 @@ TEST_IMPL(utf8_decode1_overrun) {\n   ASSERT_PTR_EQ(p, b + 1);\n \n   b[0] = 0x7F;\n+  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 0, c, c + 1));\n   ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 1, c, c + 1));\n \n   return 0;"
            }
        ],
        "error_msg": "not ok 35 - fork_fs_events_child\n# exit code 134\n# Output from process `fork_fs_events_child`:\n# Assertion failed in test/test-fork.c on line 426: `r >= 0` (-13 >= 0)\nnot ok 36 - fork_fs_events_child_dir\n# exit code 134\n# Output from process `fork_fs_events_child_dir`:\n# Assertion failed in test/test-fork.c on line 426: `r >= 0` (-13 >= 0)\nnot ok 37 - fork_fs_events_file_parent_child\n# exit code 134\n# Output from process `fork_fs_events_file_parent_child`:\n# Assertion failed in test/test-fork.c on line 426: `r >= 0` (-13 >= 0)\nok 38 - fork_signal_to_child\nnot ok 44 - fs_access\n# exit code 134\n# Output from process `fs_access`:\n# Assertion failed in test/test-fs.c on line 1631: `r >= 0` (-13 >= 0)\nnot ok 45 - fs_async_dir\n# exit code 134\n# Output from process `fs_async_dir`:\n# Assertion failed in test/test-fs.c on line 511: `req->result == 0` (-13 == 0)\nnot ok 46 - fs_async_sendfile\n# exit code 134\n# Output from process `fs_async_sendfile`:\n# Assertion failed in test/test-fs.c on line 1218: `f != -1` (-1 != -1)\nnot ok 47 - fs_async_sendfile_nodata\n# exit code 134\n# Output from process `fs_async_sendfile_nodata`:\n# Assertion failed in test/test-fs.c on line 1218: `f != -1` (-1 != -1)\nnot ok 48 - fs_chmod\n# exit code 134\n# Output from process `fs_chmod`:\n# Assertion failed in test/test-fs.c on line 1692: `r >= 0` (-13 >= 0)\nnot ok 49 - fs_chown\n# exit code 134\n# Output from process `fs_chown`:\n# Assertion failed in test/test-fs.c on line 1904: `r >= 0` (-13 >= 0)\nnot ok 50 - fs_copyfile\n# exit code 134\n# Output from process `fs_copyfile`:\n# Assertion failed in test/test-fs-copyfile.c on line 81: `r >= 0` (-13 >= 0)\nnot ok 51 - fs_event_close_in_callback\n# exit code 134\n# Output from process `fs_event_close_in_callback`:\n# Assertion failed in test/test-fs-event.c on line 74: r == 0 || r == UV_EEXIST\nnot ok 52 - fs_event_close_with_pending_delete_event\n# exit code 134\n# Output from process `fs_event_close_with_pending_delete_event`:\n# Assertion failed in test/test-fs-event.c on line 74: r == 0 || r == UV_EEXIST\nnot o"
    },
    "d457c9545e7e71ebb5c0479eb16b9d33175855e2___njs_vmcode.c": {
        "prefix": "static njs_jump_off_t\nnjs_vmcode_typeof(njs_vm_t *vm, njs_value_t *value, njs_value_t *invld)\n{\n    /* ECMAScript 5.1: null, array and regexp are objects. */\n\n    static const njs_value_t  *types[NJS_VALUE_TYPE_MAX] = {\n        &njs_string_object,\n        &njs_string_undefined,\n        &njs_string_boolean,\n        &njs_string_number,\n        &njs_string_symbol,\n        &njs_string_string,\n        &njs_string_data,\n        &njs_string_external,\n        &njs_string_invalid,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_function,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n",
        "suffix": "\n    vm->retval = *types[value->type];\n\n    return sizeof(njs_vmcode_2addr_t);\n}\n",
        "start": 1487,
        "end": 1524,
        "buggy": "static njs_jump_off_t\nnjs_vmcode_typeof(njs_vm_t *vm, njs_value_t *value, njs_value_t *invld)\n{\n    /* ECMAScript 5.1: null, array and regexp are objects. */\n\n    static const njs_value_t  *types[NJS_VALUE_TYPE_MAX] = {\n        &njs_string_object,\n        &njs_string_undefined,\n        &njs_string_boolean,\n        &njs_string_number,\n        &njs_string_symbol,\n        &njs_string_string,\n        &njs_string_data,\n        &njs_string_external,\n        &njs_string_invalid,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_function,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n    };\n\n    vm->retval = *types[value->type];\n\n    return sizeof(njs_vmcode_2addr_t);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    };\n",
        "src_path": "d457c9545e7e71ebb5c0479eb16b9d33175855e2___njs_vmcode.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/d457c9545e7e71ebb5c0479eb16b9d33175855e2",
        "commit_msg": "Added missing element in typeof table for DataView() type.\n\nPreviously, typeof operation for DataView object resulted\nin out of bounds array accessing.\n\nThis fixes #450 issue on Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -6390,6 +6390,9 @@ static njs_unit_test_t  njs_test[] =\n     { njs_str(\"(new DataView(new ArrayBuffer(3)))\"),\n       njs_str(\"[object DataView]\") },\n \n+    { njs_str(\"var x = new ArrayBuffer(3); [typeof x, typeof new DataView(x)]\"),\n+      njs_str(\"object,object\") },\n+\n     { njs_str(\"(new DataView(new ArrayBuffer(3))).buffer\"),\n       njs_str(\"[object ArrayBuffer]\") },\n "
            }
        ],
        "error_msg": "AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==20698==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7f1d3afadaeb bp 0x7ffe851a25f0 sp 0x7ffe851a1da8 T0)\n==20698==The signal is caused by a READ memory access.\n==20698==Hint: address points to the zero page.\n    #0 0x7f1d3afadaeb in memcpy /build/glibc-wuryBv/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:142\n    #1 0x556a0332e1a3 in __asan_memcpy /src/llvm-project/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:22:3\n    #2 0x556a0338bbcd in njs_vmcode_typeof /out/nginx___njs/git_repo_dir_d457c9545e7e71ebb5c0479eb16b9d33175855e2/src/njs_vmcode.c:1521:18\n    #3 0x556a0338bbcd in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_d457c9545e7e71ebb5c0479eb16b9d33175855e2/src/njs_vmcode.c:594:23\n    #4 0x556a033856a7 in njs_vm_start /out/nginx___njs/git_repo_dir_d457c9545e7e71ebb5c0479eb16b9d33175855e2/src/njs_vm.c:493:11\n    #5 0x556a0336cfb0 in njs_process_test /out/nginx___njs/git_repo_dir_d457c9545e7e71ebb5c0479eb16b9d33175855e2/src/test/njs_unit_test.c:21859:15\n    #6 0x556a0336cfb0 in njs_unit_test /out/nginx___njs/git_repo_dir_d457c9545e7e71ebb5c0479eb16b9d33175855e2/src/test/njs_unit_test.c:22011:23\n    #7 0x556a0336c261 in main /out/nginx___njs/git_repo_dir_d457c9545e7e71ebb5c0479eb16b9d33175855e2/src/test/njs_unit_test.c:23501:15\n    #8 0x7f1d3af16082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #9 0x556a03296acd in _start (/out/nginx___njs/git_repo_dir_d457c9545e7e71ebb5c0479eb16b9d33175855e2/build/njs_unit_test+0x11dacd)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV /build/glibc-wuryBv/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:142 in memcpy\n==20698==ABORTING\nAddressSanitizer:DEADLYSIGNAL\n=================================================================\n==67766==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7feb8"
    },
    "f65981b0b8fcf02d69a40bc934803c25c9f607ab___njs_vmcode.c": {
        "prefix": "static njs_jump_off_t\nnjs_vmcode_array(njs_vm_t *vm, u_char *pc)\n{\n    uint32_t            length;\n    njs_array_t         *array;\n    njs_value_t         *value;\n    njs_vmcode_array_t  *code;\n\n    code = (njs_vmcode_array_t *) pc;\n\n    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);\n\n    if (njs_fast_path(array != NULL)) {\n\n        if (code->ctor) {\n            /* Array of the form [,,,], [1,,]. */\n",
        "suffix": "        } else {\n            /* Array of the form [], [,,1], [1,2,3]. */\n            array->length = 0;\n        }\n\n        njs_set_array(&vm->retval, array);\n\n        return sizeof(njs_vmcode_array_t);\n    }\n\n    return NJS_ERROR;\n}\n",
        "start": 1042,
        "end": 1078,
        "buggy": "static njs_jump_off_t\nnjs_vmcode_array(njs_vm_t *vm, u_char *pc)\n{\n    uint32_t            length;\n    njs_array_t         *array;\n    njs_value_t         *value;\n    njs_vmcode_array_t  *code;\n\n    code = (njs_vmcode_array_t *) pc;\n\n    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);\n\n    if (njs_fast_path(array != NULL)) {\n\n        if (code->ctor) {\n            /* Array of the form [,,,], [1,,]. */\n            value = array->start;\n            length = array->length;\n\n            do {\n                njs_set_invalid(value);\n                value++;\n                length--;\n            } while (length != 0);\n\n        } else {\n            /* Array of the form [], [,,1], [1,2,3]. */\n            array->length = 0;\n        }\n\n        njs_set_array(&vm->retval, array);\n\n        return sizeof(njs_vmcode_array_t);\n    }\n\n    return NJS_ERROR;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            value = array->start;\n            length = array->length;\n\n            do {\n                njs_set_invalid(value);\n                value++;\n                length--;\n            } while (length != 0);\n\n",
        "src_path": "f65981b0b8fcf02d69a40bc934803c25c9f607ab___njs_vmcode.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/f65981b0b8fcf02d69a40bc934803c25c9f607ab",
        "commit_msg": "Fixed allocation of large array literals.\n\nPreviously, allocation of large array literals may result in\nnull-pointer dereference. The reason is that njs_array_alloc() may\nreturn a slow array when size is large enough, but the instruction\ncode assumes that array is always flat.\n\nThe fix is to check fast_array flag before accessing array->start.\n\nThis closes #473 issue on Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -13154,6 +13154,10 @@ static njs_unit_test_t  njs_test[] =\n     { njs_str(\"(new Function('return 5' + '** 1'.repeat(2**13)))()\"),\n       njs_str(\"5\") },\n \n+    { njs_str(\"var a = (new Function('return [' + ','.repeat(2**16) + ']'))();\"\n+\t\t\t  \"njs.dump(a)\"),\n+      njs_str(\"[<65536 empty items>]\") },\n+\n     { njs_str(\"(new Function('var a = 7; return a' + '= a'.repeat(2**13)))()\"),\n       njs_str(\"7\") },\n "
            }
        ],
        "error_msg": "AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==25378==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x555a008e63c9 bp 0x7fff7783fd50 sp 0x7fff7783fac0 T0)\n==25378==The signal is caused by a WRITE memory access.\n==25378==Hint: address points to the zero page.\n    #0 0x555a008e63c9 in njs_vmcode_array /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/njs_vmcode.c:1062:17\n    #1 0x555a008e63c9 in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/njs_vmcode.c:583:23\n    #2 0x555a0093942d in njs_function_lambda_call /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/njs_function.c:703:11\n    #3 0x555a008e728f in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/njs_vmcode.c:788:23\n    #4 0x555a008dfcaa in njs_vm_start /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/njs_vm.c:553:11\n    #5 0x555a008c6fb0 in njs_process_test /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/test/njs_unit_test.c:21958:15\n    #6 0x555a008c6fb0 in njs_unit_test /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/test/njs_unit_test.c:22110:23\n    #7 0x555a008c6261 in main /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/test/njs_unit_test.c:23600:15\n    #8 0x7fe5c3507082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #9 0x555a007f0acd in _start (/out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/build_f65981b0b8fcf02d69a40bc934803c25c9f607ab/njs_unit_test+0x11dacd)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/njs_vmcode.c:1062:17 in njs_vmcode_array\n==25378==ABORTING\nAddressSanitizer:DEADLYSIGNAL\n=============================================================="
    },
    "2e00e95473861846aa8538be87db07699d9f676d___njs_array.c": {
        "prefix": "static njs_int_t\nnjs_array_prototype_splice(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t      i, n, start, length, items, delta, delete;\n    njs_int_t    ret;\n    njs_value_t  *this, value, del_object;\n    njs_array_t  *array, *deleted;\n\n    this = njs_argument(args, 0);\n\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_object_length(vm, this, &length);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    start = (start < 0) ? njs_max(length + start, 0) : njs_min(start, length);\n\n    items = 0;\n    delete = 0;\n\n    if (nargs == 2) {\n        delete = length - start;\n\n    } else if (nargs > 2) {\n        items = nargs - 3;\n\n        ret = njs_value_to_integer(vm, njs_arg(args, nargs, 2), &delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n\n        delete = njs_min(njs_max(delete, 0), length - start);\n    }\n\n    delta = items - delete;\n\n    if (njs_slow_path((length + delta) > NJS_MAX_LENGTH)) {\n        njs_type_error(vm, \"Invalid length\");\n        return NJS_ERROR;\n    }\n\n    /* TODO: ArraySpeciesCreate(). */\n\n    deleted = njs_array_alloc(vm, 0, delete, 0);\n    if (njs_slow_path(deleted == NULL)) {\n        return NJS_ERROR;\n    }\n\n    if (njs_fast_path(njs_is_fast_array(this) && deleted->object.fast_array)) {\n        array = njs_array(this);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            deleted->start[i] = array->start[n];\n        }\n\n    } else {\n        njs_set_array(&del_object, deleted);\n\n        for (i = 0, n = start; i < delete; i++, n++) {\n            ret = njs_value_property_i64(vm, this, n, &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n\n            if (ret == NJS_OK) {\n                /* TODO:  CreateDataPropertyOrThrow(). */\n                ret = njs_value_property_i64_set(vm, &del_object, i, &value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return ret;\n                }\n",
        "suffix": "        }\n\n        ret = njs_object_length_set(vm, &del_object, delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    if (njs_fast_path(njs_is_fast_array(this))) {\n        array = njs_array(this);\n\n        if (delta != 0) {\n            /*\n             * Relocate the rest of items.\n             * Index of the first item is in \"n\".\n             */\n            if (delta > 0) {\n                ret = njs_array_expand(vm, array, 0, delta);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n            }\n\n            ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                        array->length - (start + delete), 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n            array->length += delta;\n        }\n\n        /* Copy new items. */\n\n        if (items > 0) {\n            memcpy(&array->start[start], &args[3],\n                   items * sizeof(njs_value_t));\n        }\n\n    } else {\n\n       if (delta != 0) {\n           ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                       length - (start + delete), delta < 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n            for (i = length - 1; i >= length + delta; i--) {\n                ret = njs_value_property_i64_delete(vm, this, i, NULL);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return NJS_ERROR;\n                }\n            }\n       }\n\n        /* Copy new items. */\n\n        for (i = 3, n = start; items-- > 0; i++, n++) {\n            ret = njs_value_property_i64_set(vm, this, n, &args[i]);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n        }\n\n        ret = njs_object_length_set(vm, this, length + delta);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    njs_set_array(&vm->retval, deleted);\n\n    return NJS_OK;\n}\n",
        "start": 1207,
        "end": 1362,
        "buggy": "static njs_int_t\nnjs_array_prototype_splice(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t      i, n, start, length, items, delta, delete;\n    njs_int_t    ret;\n    njs_value_t  *this, value, del_object;\n    njs_array_t  *array, *deleted;\n\n    this = njs_argument(args, 0);\n\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_object_length(vm, this, &length);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    start = (start < 0) ? njs_max(length + start, 0) : njs_min(start, length);\n\n    items = 0;\n    delete = 0;\n\n    if (nargs == 2) {\n        delete = length - start;\n\n    } else if (nargs > 2) {\n        items = nargs - 3;\n\n        ret = njs_value_to_integer(vm, njs_arg(args, nargs, 2), &delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n\n        delete = njs_min(njs_max(delete, 0), length - start);\n    }\n\n    delta = items - delete;\n\n    if (njs_slow_path((length + delta) > NJS_MAX_LENGTH)) {\n        njs_type_error(vm, \"Invalid length\");\n        return NJS_ERROR;\n    }\n\n    /* TODO: ArraySpeciesCreate(). */\n\n    deleted = njs_array_alloc(vm, 0, delete, 0);\n    if (njs_slow_path(deleted == NULL)) {\n        return NJS_ERROR;\n    }\n\n    if (njs_fast_path(njs_is_fast_array(this) && deleted->object.fast_array)) {\n        array = njs_array(this);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            deleted->start[i] = array->start[n];\n        }\n\n    } else {\n        njs_set_array(&del_object, deleted);\n\n        for (i = 0, n = start; i < delete; i++, n++) {\n            ret = njs_value_property_i64(vm, this, n, &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n\n            if (ret == NJS_OK) {\n                /* TODO:  CreateDataPropertyOrThrow(). */\n                ret = njs_value_property_i64_set(vm, &del_object, i, &value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return ret;\n                }\n            }\n        }\n\n        ret = njs_object_length_set(vm, &del_object, delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    if (njs_fast_path(njs_is_fast_array(this))) {\n        array = njs_array(this);\n\n        if (delta != 0) {\n            /*\n             * Relocate the rest of items.\n             * Index of the first item is in \"n\".\n             */\n            if (delta > 0) {\n                ret = njs_array_expand(vm, array, 0, delta);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n            }\n\n            ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                        array->length - (start + delete), 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n            array->length += delta;\n        }\n\n        /* Copy new items. */\n\n        if (items > 0) {\n            memcpy(&array->start[start], &args[3],\n                   items * sizeof(njs_value_t));\n        }\n\n    } else {\n\n       if (delta != 0) {\n           ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                       length - (start + delete), delta < 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n            for (i = length - 1; i >= length + delta; i--) {\n                ret = njs_value_property_i64_delete(vm, this, i, NULL);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return NJS_ERROR;\n                }\n            }\n       }\n\n        /* Copy new items. */\n\n        for (i = 3, n = start; items-- > 0; i++, n++) {\n            ret = njs_value_property_i64_set(vm, this, n, &args[i]);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n        }\n\n        ret = njs_object_length_set(vm, this, length + delta);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    njs_set_array(&vm->retval, deleted);\n\n    return NJS_OK;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            }\n",
        "src_path": "2e00e95473861846aa8538be87db07699d9f676d___njs_array.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/2e00e95473861846aa8538be87db07699d9f676d",
        "commit_msg": "Fixed Array.prototype.slice() with slow \"this\" argument.\n\nPreviously, when \"this\" argument was not a fast array, but the \"deleted\" array\nwas a fast array, the \"deleted\" array may be left in uninitialized state if\n\"this\" argument had gaps.\n\nThis fix is to ensure that \"deleted\" is properly initialized.\n\nThis fixes #485 issue on Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -4869,6 +4869,15 @@ static njs_unit_test_t  njs_test[] =\n               \"Array.prototype.splice.call(obj, 2**53-2, 0, 'C');\"),\n       njs_str(\"TypeError: Invalid length\") },\n \n+    { njs_str(\"var a = {1: 'B', length: 2};\"\n+              \"Array.prototype.splice.call(a, 0)\"),\n+      njs_str(\",B\") },\n+\n+    { njs_str(\"var a = new Uint8Array();\"\n+              \"a.__proto__ = [1,2,3];\"\n+              \"a.splice(0)\"),\n+      njs_str(\",,\") },\n+\n     { njs_str(\"var a = []; a.reverse()\"),\n       njs_str(\"\") },\n "
            }
        ],
        "error_msg": "AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==40169==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x55811be8f248 bp 0x7fffbffba850 sp 0x7fffbffba810 T0)\n==40169==The signal is caused by a READ memory access.\n==40169==Hint: this fault was caused by a dereference of a high value address (see register values below).  Disassemble the provided pc to learn which register was used.\n    #0 0x55811be8f248 in njs_lvlhsh_find /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_lvlhsh.c:176:16\n    #1 0x55811bed9f2f in njs_object_property /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_object_prop.c:59:15\n    #2 0x55811be99e13 in njs_value_to_primitive /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_value.c:159:19\n    #3 0x55811bee56e9 in njs_value_to_chain /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_value_conversion.h:217:19\n    #4 0x55811bee56e9 in njs_array_prototype_join /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_array.c:1535:23\n    #5 0x55811befd051 in njs_function_native_call /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_function.c:739:11\n    #6 0x55811befb707 in njs_function_frame_invoke /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_function.c:777:16\n    #7 0x55811befb707 in njs_function_call2 /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_function.c:600:11\n    #8 0x55811bee1761 in njs_function_apply /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_function.h:188:12\n    #9 0x55811bee1761 in njs_array_prototype_to_string /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_array.c:1459:20\n    #10 0x55811befd051 in njs_function_native_call /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_function.c:739:11\n    #11 0x55811bef"
    },
    "81af26364c21c196dd21fb5e14c7fa9ce7debd17___njs_array.c": {
        "prefix": "njs_int_t\nnjs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)\n{\n    uint32_t           i, length;\n    njs_value_t        index, value;\n    njs_object_prop_t  *prop;\n\n",
        "suffix": "    array->object.fast_array = 0;\n\n    length = array->length;\n\n    for (i = 0; i < length; i++) {\n        if (njs_is_valid(&array->start[i])) {\n            njs_uint32_to_string(&index, i);\n            prop = njs_object_property_add(vm, &value, &index, 0);\n            if (njs_slow_path(prop == NULL)) {\n                return NJS_ERROR;\n            }\n\n            prop->value = array->start[i];\n        }\n    }\n\n    /* GC: release value. */\n\n    njs_mp_free(vm->mem_pool, array->start);\n    array->start = NULL;\n\n    return NJS_OK;\n}\n",
        "start": 138,
        "end": 168,
        "buggy": "njs_int_t\nnjs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)\n{\n    uint32_t           i, length;\n    njs_value_t        index, value;\n    njs_object_prop_t  *prop;\n\n    njs_set_array(&value, array);\n    array->object.fast_array = 0;\n\n    length = array->length;\n\n    for (i = 0; i < length; i++) {\n        if (njs_is_valid(&array->start[i])) {\n            njs_uint32_to_string(&index, i);\n            prop = njs_object_property_add(vm, &value, &index, 0);\n            if (njs_slow_path(prop == NULL)) {\n                return NJS_ERROR;\n            }\n\n            prop->value = array->start[i];\n        }\n    }\n\n    /* GC: release value. */\n\n    njs_mp_free(vm->mem_pool, array->start);\n    array->start = NULL;\n\n    return NJS_OK;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    njs_set_array(&value, array);\n",
        "src_path": "81af26364c21c196dd21fb5e14c7fa9ce7debd17___njs_array.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/81af26364c21c196dd21fb5e14c7fa9ce7debd17",
        "commit_msg": "Fixed Object.defineProperty() when a recursive descriptor is provided.\n\nThis closes #481 issue on Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -13837,6 +13837,16 @@ static njs_unit_test_t  njs_test[] =\n               \"d.enumerable && d.writable && d.configurable\"),\n       njs_str(\"true\") },\n \n+    { njs_str(\"const arr = [1,2];\"\n+              \"function f(arg) {\"\n+              \"        const desc = {get: arg};\"\n+              \"        Object.defineProperty(desc, 'set', desc);\"\n+              \"        Object.defineProperty(arr, 1, desc);\"\n+              \"}\"\n+              \"f(f);\"\n+              \"njs.dump(arr)\"),\n+      njs_str(\"[1,'[Getter]']\") },\n+\n     { njs_str(\"Object.defineProperties()\"),\n       njs_str(\"TypeError: Object.defineProperties is called on non-object\") },\n "
            }
        ],
        "error_msg": "AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==41829==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x564e05c665fe bp 0x7ffe16d6e1f0 sp 0x7ffe16d6e140 T0)\n==41829==The signal is caused by a READ memory access.\n==41829==Hint: address points to the zero page.\n    #0 0x564e05c665fe in njs_array_convert_to_slow_array /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_array.c:151:13\n    #1 0x564e05c61147 in njs_object_prop_define /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_object_prop.c:288:19\n    #2 0x564e05c5d06b in njs_object_define_property /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_object.c:1268:11\n    #3 0x564e05c828d1 in njs_function_native_call /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_function.c:739:11\n    #4 0x564e05c303bf in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_vmcode.c:810:23\n    #5 0x564e05c81d6d in njs_function_lambda_call /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_function.c:703:11\n    #6 0x564e05c303bf in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_vmcode.c:810:23\n    #7 0x564e05c28cca in njs_vm_start /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_vm.c:553:11\n    #8 0x564e05c0ffc0 in njs_process_test /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/test/njs_unit_test.c:22026:15\n    #9 0x564e05c0ffc0 in njs_unit_test /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/test/njs_unit_test.c:22178:23\n    #10 0x564e05c0f271 in main /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/test/njs_unit_test.c:23668:15\n    #11 0x7fc0a51e8082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #12 0x564e05b39add in _"
    },
    "5c6130a2a0b4c41ab415f6b8992aa323636338b9___njs_typed_array.c": {
        "prefix": "njs_int_t\nnjs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n\n    njs_typed_array_prop_set(vm, array, index, num);\n\n",
        "suffix": "}\n",
        "start": 685,
        "end": 708,
        "buggy": "njs_int_t\nnjs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n\n    njs_typed_array_prop_set(vm, array, index, num);\n\n    njs_set_number(setval, num);\n\n    return NJS_OK;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    njs_set_number(setval, num);\n\n    return NJS_OK;\n",
        "src_path": "5c6130a2a0b4c41ab415f6b8992aa323636338b9___njs_typed_array.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/5c6130a2a0b4c41ab415f6b8992aa323636338b9",
        "commit_msg": "Fixed Array.prototype.fill() for typed-arrays.\n\nThis closes #478 issue on Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -5409,6 +5409,9 @@ static njs_unit_test_t  njs_test[] =\n                  \"Array.prototype.fill.call(o, 2).a\"),\n       njs_str(\"4\") },\n \n+    { njs_str(\"Array.prototype.fill.call(new Int32Array(1))\"),\n+      njs_str(\"0\") },\n+\n     { njs_str(\"ArrayBuffer()\"),\n       njs_str(\"TypeError: Constructor ArrayBuffer requires 'new'\") },\n "
            }
        ],
        "error_msg": "AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==43483==ERROR: AddressSanitizer: SEGV on unknown address 0x55e087212088 (pc 0x55e0870e5b1a bp 0x7ffe88707990 sp 0x7ffe88707900 T0)\n==43483==The signal is caused by a WRITE memory access.\n    #0 0x55e0870e5b1a in njs_set_number /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_value.h:852:26\n    #1 0x55e0870e5b1a in njs_typed_array_set_value /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_typed_array.c:705:5\n    #2 0x55e086fe6ec7 in njs_value_property_set /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_value.c\n    #3 0x55e08702df4d in njs_value_property_i64_set /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_value.h:1097:12\n    #4 0x55e08702df4d in njs_array_prototype_fill /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_array.c:1894:15\n    #5 0x55e087045921 in njs_function_native_call /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_function.c:739:11\n    #6 0x55e087047c52 in njs_function_frame_invoke /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_function.c:777:16\n    #7 0x55e087047c52 in njs_function_prototype_call /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_function.c:1351:11\n    #8 0x55e087045921 in njs_function_native_call /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_function.c:739:11\n    #9 0x55e086ff33bf in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_vmcode.c:810:23\n    #10 0x55e086febcca in njs_vm_start /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_vm.c:553:11\n    #11 0x55e086fd2fc0 in njs_process_test /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/test/njs_unit_test.c:22029:15\n    #12 0x55e086fd2fc0 in njs_unit_tes"
    },
    "1bbaa929b77113532785c408dd1b41cd0521ffc8___log_blackbox.c": {
        "prefix": "static void\n_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\n\tfn_size = strlen(cs->function) + 1;\n\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\n\tif (chunk == NULL) {\n\t\t/* something bad has happened. abort blackbox logging */\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* line number */\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* tags */\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* log level/priority */\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\n\t/* function name */\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\n\t/* timestamp */\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\n\t/* log message length */\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\n\t/* log message */\n",
        "suffix": "\n\t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */\n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\n\tactual_size += msg_len;\n\n\t/* now that we know the length, write it\n\t */\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}\n",
        "start": 54,
        "end": 130,
        "buggy": "static void\n_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\n\tfn_size = strlen(cs->function) + 1;\n\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\n\tif (chunk == NULL) {\n\t\t/* something bad has happened. abort blackbox logging */\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* line number */\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* tags */\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* log level/priority */\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\n\t/* function name */\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\n\t/* timestamp */\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\n\t/* log message length */\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\n\t/* log message */\n\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);\n\tif (msg_len >= max_size) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n\n\t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */\n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\n\tactual_size += msg_len;\n\n\t/* now that we know the length, write it\n\t */\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);\n\tif (msg_len >= max_size) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n",
        "src_path": "1bbaa929b77113532785c408dd1b41cd0521ffc8___log_blackbox.c",
        "uri": "https://api.github.com/repos/ClusterLabs/libqb/commits/1bbaa929b77113532785c408dd1b41cd0521ffc8",
        "commit_msg": "log: fix potential overflow with long log messages (#490)\n\nqb_vsnprintf_serialize was called with 'max_size' as the\r\nlimiting number for the length of the formatted log\r\nmessage. But the buffer also needs to contain the\r\nlog header (given by 'actual_size'), so we now pass\r\n't->max_line_length' as the maximum length of the\r\nformatted log message to limit space to the actual \r\nbytes left\r\n\r\nAlso added error checks to the blackbox calls at\r\nthe end of the test, as these now provide a proper\r\ntest that the BB is functioning. Before they were\r\nmasking failures.",
        "test_func_diff": [
            {
                "fn": "tests/check_log.c",
                "patch": "@@ -832,8 +832,10 @@ START_TEST(test_log_long_msg)\n \t\tqb_log(LOG_INFO, \"Message %d %d - %s\", lpc, lpc%600, buffer);\n \t}\n \n-        qb_log_blackbox_write_to_file(\"blackbox.dump\");\n-        qb_log_blackbox_print_from_file(\"blackbox.dump\");\n+        rc = qb_log_blackbox_write_to_file(\"blackbox.dump\");\n+\tck_assert_int_gt(rc, 0);\n+        rc = qb_log_blackbox_print_from_file(\"blackbox.dump\");\n+\tck_assert_int_le(rc, 0);\n \tunlink(\"blackbox.dump\");\n \tqb_log_fini();\n }"
            }
        ],
        "error_msg": "Running suite(s): logging\nthr_send_logs_1\nthr_send_logs_1\nthr_send_logs_2\nthr_send_logs_2\n93%: Checks: 16, Failures: 1, Errors: 0\ncheck_log.c:131:P:va_serialize:test_va_serialize:0: Passed\ncheck_log.c:189:P:log_stupid_inputs:test_log_stupid_inputs:0: Passed\ncheck_log.c:597:P:log_basic:test_log_basic:0: Passed\ncheck_log.c:678:P:log_format:test_log_format:0: Passed\ncheck_log.c:716:P:log_enable:test_log_enable:0: Passed\ncheck_log.c:783:P:log_threads:test_log_threads:0: Passed\ncheck_log.c:836:F:log_long_msg:test_log_long_msg:0: Assertion 'rc > 0' failed: rc == -2, 0 == 0\ncheck_log.c:295:P:log_filter_fn:test_log_filter_fn:0: Passed\ncheck_log.c:880:P:threaded_logging:test_threaded_logging:0: Passed\ncheck_log.c:432:P:line_length:test_line_length:0: Passed\ncheck_log.c:340:P:file_logging:test_file_logging:0: Passed\ncheck_log.c:914:P:threaded_logging_bad_sched_params:test_threaded_logging_bad_sched_params:0: Passed\ncheck_log.c:374:P:timestamps:test_timestamps:0: Passed\ncheck_log.c:971:P:extended_information:test_extended_information:0: Passed\ncheck_log.c:1009:P:zero_tags:test_zero_tags:0: Passed\ncheck_log.c:1083:P:syslog:test_syslog:0: Passed\n"
    },
    "3cb0f914d6427073f262e1b2b5fd973e3043cdf7___ytnef.c": {
        "prefix": "int TNEFParse(TNEFStruct *TNEF) {\n  WORD key;\n  DWORD type;\n  DWORD size;\n  DWORD signature;\n  BYTE *data;\n  WORD checksum, header_checksum;\n  int i;\n\n  if (TNEF->IO.ReadProc == NULL) {\n    printf(\"ERROR: Setup incorrectly: No ReadProc\\n\");\n    return YTNEF_INCORRECT_SETUP;\n  }\n\n  if (TNEF->IO.InitProc != NULL) {\n    DEBUG(TNEF->Debug, 2, \"About to initialize\");\n    if (TNEF->IO.InitProc(&TNEF->IO) != 0) {\n      return YTNEF_CANNOT_INIT_DATA;\n    }\n    DEBUG(TNEF->Debug, 2, \"Initialization finished\");\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Signature\");\n  if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(DWORD), 1, &signature) < 1) {\n    printf(\"ERROR: Error reading signature\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_ERROR_READING_DATA;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Checking Signature\");\n  if (TNEFCheckForSignature(signature) < 0) {\n    printf(\"ERROR: Signature does not match. Not TNEF.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NOT_TNEF_STREAM;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Key.\");\n\n  if (TNEFGetKey(TNEF, &key) < 0) {\n    printf(\"ERROR: Unable to retrieve key.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NO_KEY;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Starting Full Processing.\");\n\n  while (TNEFGetHeader(TNEF, &type, &size) == 0) {\n    DEBUG2(TNEF->Debug, 2, \"Header says type=0x%X, size=%u\", type, size);\n    DEBUG2(TNEF->Debug, 2, \"Header says type=%u, size=%u\", type, size);\n",
        "suffix": "    ALLOCCHECK(data);\n    if (TNEFRawRead(TNEF, data, size, &header_checksum) < 0) {\n      printf(\"ERROR: Unable to read data.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    if (TNEFRawRead(TNEF, (BYTE *)&checksum, 2, NULL) < 0) {\n      printf(\"ERROR: Unable to read checksum.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    checksum = SwapWord((BYTE *)&checksum, sizeof(WORD));\n    if (checksum != header_checksum) {\n      printf(\"ERROR: Checksum mismatch. Data corruption?:\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_BAD_CHECKSUM;\n    }\n    for (i = 0; i < (sizeof(TNEFList) / sizeof(TNEFHandler)); i++) {\n      if (TNEFList[i].id == type) {\n        if (TNEFList[i].handler != NULL) {\n          if (TNEFList[i].handler(TNEF, i, (char*)data, size) < 0) {\n            free(data);\n            if (TNEF->IO.CloseProc != NULL) {\n              TNEF->IO.CloseProc(&TNEF->IO);\n            }\n            return YTNEF_ERROR_IN_HANDLER;\n          } else {\n            //  Found our handler and processed it.  now time to get out\n            break;\n          }\n        } else {\n          DEBUG2(TNEF->Debug, 1, \"No handler for %s: %u bytes\",\n                 TNEFList[i].name, size);\n        }\n      }\n    }\n\n    free(data);\n  }\n\n  if (TNEF->IO.CloseProc != NULL) {\n    TNEF->IO.CloseProc(&TNEF->IO);\n  }\n  return 0;\n\n}\n",
        "start": 1095,
        "end": 1205,
        "buggy": "int TNEFParse(TNEFStruct *TNEF) {\n  WORD key;\n  DWORD type;\n  DWORD size;\n  DWORD signature;\n  BYTE *data;\n  WORD checksum, header_checksum;\n  int i;\n\n  if (TNEF->IO.ReadProc == NULL) {\n    printf(\"ERROR: Setup incorrectly: No ReadProc\\n\");\n    return YTNEF_INCORRECT_SETUP;\n  }\n\n  if (TNEF->IO.InitProc != NULL) {\n    DEBUG(TNEF->Debug, 2, \"About to initialize\");\n    if (TNEF->IO.InitProc(&TNEF->IO) != 0) {\n      return YTNEF_CANNOT_INIT_DATA;\n    }\n    DEBUG(TNEF->Debug, 2, \"Initialization finished\");\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Signature\");\n  if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(DWORD), 1, &signature) < 1) {\n    printf(\"ERROR: Error reading signature\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_ERROR_READING_DATA;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Checking Signature\");\n  if (TNEFCheckForSignature(signature) < 0) {\n    printf(\"ERROR: Signature does not match. Not TNEF.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NOT_TNEF_STREAM;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Key.\");\n\n  if (TNEFGetKey(TNEF, &key) < 0) {\n    printf(\"ERROR: Unable to retrieve key.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NO_KEY;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Starting Full Processing.\");\n\n  while (TNEFGetHeader(TNEF, &type, &size) == 0) {\n    DEBUG2(TNEF->Debug, 2, \"Header says type=0x%X, size=%u\", type, size);\n    DEBUG2(TNEF->Debug, 2, \"Header says type=%u, size=%u\", type, size);\n    data = calloc(size, sizeof(BYTE));\n    ALLOCCHECK(data);\n    if (TNEFRawRead(TNEF, data, size, &header_checksum) < 0) {\n      printf(\"ERROR: Unable to read data.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    if (TNEFRawRead(TNEF, (BYTE *)&checksum, 2, NULL) < 0) {\n      printf(\"ERROR: Unable to read checksum.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    checksum = SwapWord((BYTE *)&checksum, sizeof(WORD));\n    if (checksum != header_checksum) {\n      printf(\"ERROR: Checksum mismatch. Data corruption?:\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_BAD_CHECKSUM;\n    }\n    for (i = 0; i < (sizeof(TNEFList) / sizeof(TNEFHandler)); i++) {\n      if (TNEFList[i].id == type) {\n        if (TNEFList[i].handler != NULL) {\n          if (TNEFList[i].handler(TNEF, i, (char*)data, size) < 0) {\n            free(data);\n            if (TNEF->IO.CloseProc != NULL) {\n              TNEF->IO.CloseProc(&TNEF->IO);\n            }\n            return YTNEF_ERROR_IN_HANDLER;\n          } else {\n            //  Found our handler and processed it.  now time to get out\n            break;\n          }\n        } else {\n          DEBUG2(TNEF->Debug, 1, \"No handler for %s: %u bytes\",\n                 TNEFList[i].name, size);\n        }\n      }\n    }\n\n    free(data);\n  }\n\n  if (TNEF->IO.CloseProc != NULL) {\n    TNEF->IO.CloseProc(&TNEF->IO);\n  }\n  return 0;\n\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    data = calloc(size, sizeof(BYTE));\n",
        "src_path": "3cb0f914d6427073f262e1b2b5fd973e3043cdf7___ytnef.c",
        "uri": "https://api.github.com/repos/Yeraze/ytnef/commits/3cb0f914d6427073f262e1b2b5fd973e3043cdf7",
        "commit_msg": "BugFix - Potential OOB with Fields of Size 0\n\nThanks to @hannob for contributing a malformed TNEF stream with\na Version field of size 0.  Now such files will return an error\nindicating invalid data.",
        "test_func_diff": [
            {
                "fn": "test-data/test.sh",
                "patch": "@@ -21,3 +21,5 @@ diff results data\n ../ytnefprint/ytnefprint ./winmail.dat  | grep -A 1 PR_RTF_SYNC_BODY_CRC     | grep 872404792\n ../ytnefprint/ytnefprint ./winmail.dat  | grep -A 1 PR_RTF_SYNC_BODY_COUNT   | grep 90\n ../ytnefprint/ytnefprint ./winmail.dat  | grep -A 18 PR_RTF_COMPRESSED       | grep '\\pard Casdasdfasdfasd\\\\par'\n+\n+../ytnefprint/ytnefprint ./ytnef-oob-TNEFVersion-SwapWord | grep 'ERROR: Field with size of 0'"
            }
        ],
        "error_msg": "==20774==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000012 at pc 0x7fb1e9e612eb bp 0x7ffff6dbd950 sp 0x7ffff6dbd948\nREAD of size 1 at 0x602000000012 thread T0\n    #0 0x7fb1e9e612ea in SwapWord /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:153:28\n    #1 0x7fb1e9e60c38 in TNEFVersion /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:338:11\n    #2 0x7fb1e9e6e02d in TNEFParse /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:1180:15\n    #3 0x7fb1e9e6cad6 in TNEFParseFile /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:1042:10\n    #4 0x55feb14dd4f0 in main /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/ytnefprint/main.c:80:9\n    #5 0x7fb1e9abc082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #6 0x55feb140a35d in _start (/out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/ytnefprint/.libs/ytnefprint+0x1f35d)\n\n0x602000000012 is located 1 bytes after 1-byte region [0x602000000010,0x602000000011)\nallocated by thread T0 here:\n    #0 0x55feb14a2b08 in __interceptor_calloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:77:3\n    #1 0x7fb1e9e6d9f1 in TNEFParse /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:1150:12\n    #2 0x7fb1e9e6cad6 in TNEFParseFile /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:1042:10\n    #3 0x55feb14dd4f0 in main /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/ytnefprint/main.c:80:9\n    #4 0x7fb1e9abc082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:153:28 in SwapWord\nShadow bytes around the buggy address:\n  0x601ffffffd80: 00 00 00 00 00 00 00 00 00 00 00 00 00"
    },
    "864f5d4c127def386dd5cc926ad96934b297f04e___UriQuery.c": {
        "prefix": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\t\t\t\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t} else {\n\t\t\tURI_CHAR * afterKey;\n\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\n\t\t\t/* Copy key */\n\t\t\tif (firstItem == URI_TRUE) {\n",
        "suffix": "\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\tafterKey = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\twrite += (afterKey - write);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tURI_CHAR * afterValue;\n\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\tafterValue = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t\twrite += (afterValue - write);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n",
        "start": 184,
        "end": 262,
        "buggy": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\t\t\t\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t} else {\n\t\t\tURI_CHAR * afterKey;\n\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\n\t\t\t/* Copy key */\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\tafterKey = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\twrite += (afterKey - write);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tURI_CHAR * afterValue;\n\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\tafterValue = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t\twrite += (afterValue - write);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\t\tfirstItem = URI_FALSE;\n",
        "src_path": "864f5d4c127def386dd5cc926ad96934b297f04e___UriQuery.c",
        "uri": "https://api.github.com/repos/uriparser/uriparser/commits/864f5d4c127def386dd5cc926ad96934b297f04e",
        "commit_msg": "UriQuery.c: Fix out-of-bounds-write in ComposeQuery and ...Ex\n\nReported by Google Autofuzz team",
        "test_func_diff": [
            {
                "fn": "test/test.cpp",
                "patch": "@@ -104,6 +104,7 @@ class UriSuite : public Suite {\n \t\tTEST_ADD(UriSuite::testQueryList)\n \t\tTEST_ADD(UriSuite::testQueryListPair)\n \t\tTEST_ADD(UriSuite::testQueryDissection_Bug3590761)\n+\t\tTEST_ADD(UriSuite::testQueryCompositionMathWrite_GoogleAutofuzz113244572)\n \t\tTEST_ADD(UriSuite::testFreeCrash_Bug20080827)\n \t\tTEST_ADD(UriSuite::testParseInvalid_Bug16)\n \t\tTEST_ADD(UriSuite::testRangeComparison)\n@@ -1749,6 +1750,37 @@ Rule                                | Example | hostSet | absPath | emptySeg\n \t\turiFreeQueryListA(queryList);\n \t}\n \n+\tvoid testQueryCompositionMathWrite_GoogleAutofuzz113244572() {\n+\t\tUriQueryListA second = { .key = \"\\x11\", .value = NULL, .next = NULL };\n+\t\tUriQueryListA first = { .key = \"\\x01\", .value = \"\\x02\", .next = &second };\n+\n+\t\tconst UriBool spaceToPlus = URI_TRUE;\n+\t\tconst UriBool normalizeBreaks = URI_FALSE;  /* for factor 3 but 6 */\n+\n+\t\tconst int charsRequired = (3 + 1 + 3) + 1 + (3);\n+\n+\t\t{\n+\t\t\t// Minimum space to hold everything fine\n+\t\t\tconst char * const expected = \"%01=%02\" \"&\" \"%11\";\n+\t\t\tchar dest[charsRequired + 1];\n+\t\t\tint charsWritten;\n+\t\t\tTEST_ASSERT(uriComposeQueryExA(dest, &first, sizeof(dest),\n+\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n+\t\t\t\t== URI_SUCCESS);\n+\t\t\tTEST_ASSERT(! strcmp(dest, expected));\n+\t\t\tTEST_ASSERT(charsWritten == strlen(expected) + 1);\n+\t\t}\n+\n+\t\t{\n+\t\t\t// Previous math failed to take ampersand into account\n+\t\t\tchar dest[charsRequired + 1 - 1];\n+\t\t\tint charsWritten;\n+\t\t\tTEST_ASSERT(uriComposeQueryExA(dest, &first, sizeof(dest),\n+\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n+\t\t\t\t== URI_ERROR_OUTPUT_TOO_LARGE);\n+\t\t}\n+\t}\n+\n \tvoid testFreeCrash_Bug20080827() {\n \t\tchar const * const sourceUri = \"abc\";\n \t\tchar const * const baseUri = \"http://www.example.org/\";"
            }
        ],
        "error_msg": "UriSuite: 0/56\rUriSuite: 1/56\rUriSuite: 2/56\rUriSuite: 3/56\rUriSuite: 4/56\rUriSuite: 5/56\rUriSuite: 6/56\rUriSuite: 7/56\rUriSuite: 8/56\rUriSuite: 9/56\rUriSuite: 10/56\rUriSuite: 11/56\rUriSuite: 12/56\rUriSuite: 13/56\rUriSuite: 14/56\rUriSuite: 15/56\rUriSuite: 16/56\rUriSuite: 17/56\rUriSuite: 18/56\rUriSuite: 19/56\rUriSuite: 20/56\rUriSuite: 21/56\rUriSuite: 22/56\rUriSuite: 23/56\rUriSuite: 24/56\rUriSuite: 25/56\rUriSuite: 26/56\rUriSuite: 27/56\rUriSuite: 28/56\rUriSuite: 29/56\rUriSuite: 30/56\rUriSuite: 31/56\rUriSuite: 32/56\rUriSuite: 33/56\rUriSuite: 34/56\rUriSuite: 35/56\rUriSuite: 36/56\rUriSuite: 37/56\rUriSuite: 38/56\rUriSuite: 39/56\rUriSuite: 40/56\rUriSuite: 41/56\rUriSuite: 42/56\rUriSuite: 43/56\rUriSuite: 44/56\rUriSuite: 45/56\rUriSuite: 46/56\rUriSuite: 47/56\rUriSuite: 48/56\rUriSuite: 49/56\rUriSuite: 50/56\rUriSuite: 51/56\rUriSuite: 52/56\rUriSuite: 53/56\rUriSuite: 54/56\rUriSuite: 55/56\rUriSuite: 56/56\rUriSuite: 56/56, 98% correct in 0.000306 seconds\n\tTest:    testQueryCompositionMathWrite_GoogleAutofuzz113244572\n\tSuite:   UriSuite\n\tFile:    test/test.cpp\n\tLine:    1780\n\tMessage: uriComposeQueryExA(dest, &first, sizeof(dest), &charsWritten, spaceToPlus, normalizeBreaks) == URI_ERROR_OUTPUT_TOO_LARGE\n\nFourSuite: 0/7\rFourSuite: 1/7\rFourSuite: 2/7\rFourSuite: 3/7\rFourSuite: 4/7\rFourSuite: 5/7\rFourSuite: 6/7\rFourSuite: 7/7\rFourSuite: 7/7, 100% correct in 0.000245 seconds\nVersionSuite: 0/1\rbytes_printed: 5\nVersionSuite: 1/1\rVersionSuite: 1/1, 100% correct in 0.000012 seconds\nTotal: 64 tests, 98% correct in 0.000563 seconds\nFAIL test/uriparser_test (exit status: 1)\n"
    },
    "cef25028de5ff872c2e1f0a6c562eb3ea9ecbce4___UriParse.c": {
        "prefix": "static const URI_CHAR * URI_FUNC(ParseIPv6address2)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tint zipperEver = 0;\n\tint quadsDone = 0;\n\tint digitCount = 0;\n\tunsigned char digitHistory[4];\n\tint ip4OctetsDone = 0;\n\n\tunsigned char quadsAfterZipper[14];\n\tint quadsAfterZipperCount = 0;\n\n\n\tfor (;;) {\n\t\tif (first >= afterLast) {\n\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Inside IPv4 part? */\n\t\tif (ip4OctetsDone > 0) {\n\t\t\t/* Eat rest of IPv4 address */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (*first) {\n\t\t\t\tcase URI_SET_DIGIT:\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount++] = (unsigned char)(9 + *first - _UT('9'));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT('.'):\n\t\t\t\t\tif ((ip4OctetsDone == 4) /* NOTE! */\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid digit or octet count */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4 + ip4OctetsDone] = uriGetOctetValue(digitHistory, digitCount);\n\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\tip4OctetsDone++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(']'):\n\t\t\t\t\tif ((ip4OctetsDone != 3) /* NOTE! */\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid digit or octet count */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate->uri->hostText.afterLast = first; /* HOST END */\n\n\t\t\t\t\t/* Copy missing quads right before IPv4 */\n\t\t\t\t\tmemcpy(state->uri->hostData.ip6->data + 16 - 4 - 2 * quadsAfterZipperCount,\n\t\t\t\t\t\t\t\tquadsAfterZipper, 2 * quadsAfterZipperCount);\n\n\t\t\t\t\t/* Copy last IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4 + 3] = uriGetOctetValue(digitHistory, digitCount);\n\n\t\t\t\t\treturn first + 1;\n\n\t\t\t\tdefault:\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tfirst++;\n",
        "suffix": "\t\t} else {\n\t\t\t/* Eat while no dot in sight */\n\t\t\tint letterAmong = 0;\n\t\t\tint walking = 1;\n\t\t\tdo {\n\t\t\t\tswitch (*first) {\n\t\t\t\tcase URI_SET_HEX_LETTER_LOWER:\n\t\t\t\t\tletterAmong = 1;\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(15 + *first - _UT('f'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase URI_SET_HEX_LETTER_UPPER:\n\t\t\t\t\tletterAmong = 1;\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(15 + *first - _UT('F'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase URI_SET_DIGIT:\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(9 + *first - _UT('9'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(':'):\n\t\t\t\t\t{\n\t\t\t\t\t\tint setZipper = 0;\n\n\t\t\t\t\t\tif (digitCount > 0) {\n\t\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, quadsAfterZipper + 2 * quadsAfterZipperCount);\n\t\t\t\t\t\t\t\tquadsAfterZipperCount++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, state->uri->hostData.ip6->data + 2 * quadsDone);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tquadsDone++;\n\t\t\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tletterAmong = 0;\n\n\t\t\t\t\t\t/* Too many quads? */\n\t\t\t\t\t\tif (quadsDone >= 8 - zipperEver) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* \"::\"? */\n\t\t\t\t\t\tif (first + 1 >= afterLast) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (first[1] == _UT(':')) {\n\t\t\t\t\t\t\tconst int resetOffset = 2 * (quadsDone + (digitCount > 0));\n\n\t\t\t\t\t\t\tfirst++;\n\t\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* \"::.+::\" */\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Zero everything after zipper */\n\t\t\t\t\t\t\tmemset(state->uri->hostData.ip6->data + resetOffset, 0, 16 - resetOffset);\n\t\t\t\t\t\t\tsetZipper = 1;\n\n\t\t\t\t\t\t\t/* \":::+\"? */\n\t\t\t\t\t\t\tif (first + 1 >= afterLast) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* No ']' yet */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (first[1] == _UT(':')) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* \":::+ \"*/\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (setZipper) {\n\t\t\t\t\t\t\tzipperEver = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT('.'):\n\t\t\t\t\tif ((quadsDone > 6) /* NOTE */\n\t\t\t\t\t\t\t|| (!zipperEver && (quadsDone < 6))\n\t\t\t\t\t\t\t|| letterAmong\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid octet before */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy first IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4] = uriGetOctetValue(digitHistory, digitCount);\n\t\t\t\t\tdigitCount = 0;\n\n\t\t\t\t\t/* Switch over to IPv4 loop */\n\t\t\t\t\tip4OctetsDone = 1;\n\t\t\t\t\twalking = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(']'):\n\t\t\t\t\t/* Too little quads? */\n\t\t\t\t\tif (!zipperEver && !((quadsDone == 7) && (digitCount > 0))) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (digitCount > 0) {\n\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, quadsAfterZipper + 2 * quadsAfterZipperCount);\n\t\t\t\t\t\t\tquadsAfterZipperCount++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, state->uri->hostData.ip6->data + 2 * quadsDone);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tquadsDone++;\n\t\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy missing quads to the end */\n\t\t\t\t\tmemcpy(state->uri->hostData.ip6->data + 16 - 2 * quadsAfterZipperCount,\n\t\t\t\t\t\t\t\tquadsAfterZipper, 2 * quadsAfterZipperCount);\n\n\t\t\t\t\tstate->uri->hostText.afterLast = first; /* HOST END */\n\t\t\t\t\treturn first + 1; /* Fine */\n\n\t\t\t\tdefault:\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tfirst++;\n\n\t\t\t\tif (first >= afterLast) {\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL; /* No ']' yet */\n\t\t\t\t}\n\t\t\t} while (walking);\n\t\t}\n\t}\n}\n",
        "start": 576,
        "end": 871,
        "buggy": "static const URI_CHAR * URI_FUNC(ParseIPv6address2)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tint zipperEver = 0;\n\tint quadsDone = 0;\n\tint digitCount = 0;\n\tunsigned char digitHistory[4];\n\tint ip4OctetsDone = 0;\n\n\tunsigned char quadsAfterZipper[14];\n\tint quadsAfterZipperCount = 0;\n\n\n\tfor (;;) {\n\t\tif (first >= afterLast) {\n\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Inside IPv4 part? */\n\t\tif (ip4OctetsDone > 0) {\n\t\t\t/* Eat rest of IPv4 address */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (*first) {\n\t\t\t\tcase URI_SET_DIGIT:\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount++] = (unsigned char)(9 + *first - _UT('9'));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT('.'):\n\t\t\t\t\tif ((ip4OctetsDone == 4) /* NOTE! */\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid digit or octet count */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4 + ip4OctetsDone] = uriGetOctetValue(digitHistory, digitCount);\n\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\tip4OctetsDone++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(']'):\n\t\t\t\t\tif ((ip4OctetsDone != 3) /* NOTE! */\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid digit or octet count */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate->uri->hostText.afterLast = first; /* HOST END */\n\n\t\t\t\t\t/* Copy missing quads right before IPv4 */\n\t\t\t\t\tmemcpy(state->uri->hostData.ip6->data + 16 - 4 - 2 * quadsAfterZipperCount,\n\t\t\t\t\t\t\t\tquadsAfterZipper, 2 * quadsAfterZipperCount);\n\n\t\t\t\t\t/* Copy last IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4 + 3] = uriGetOctetValue(digitHistory, digitCount);\n\n\t\t\t\t\treturn first + 1;\n\n\t\t\t\tdefault:\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tfirst++;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Eat while no dot in sight */\n\t\t\tint letterAmong = 0;\n\t\t\tint walking = 1;\n\t\t\tdo {\n\t\t\t\tswitch (*first) {\n\t\t\t\tcase URI_SET_HEX_LETTER_LOWER:\n\t\t\t\t\tletterAmong = 1;\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(15 + *first - _UT('f'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase URI_SET_HEX_LETTER_UPPER:\n\t\t\t\t\tletterAmong = 1;\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(15 + *first - _UT('F'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase URI_SET_DIGIT:\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(9 + *first - _UT('9'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(':'):\n\t\t\t\t\t{\n\t\t\t\t\t\tint setZipper = 0;\n\n\t\t\t\t\t\tif (digitCount > 0) {\n\t\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, quadsAfterZipper + 2 * quadsAfterZipperCount);\n\t\t\t\t\t\t\t\tquadsAfterZipperCount++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, state->uri->hostData.ip6->data + 2 * quadsDone);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tquadsDone++;\n\t\t\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tletterAmong = 0;\n\n\t\t\t\t\t\t/* Too many quads? */\n\t\t\t\t\t\tif (quadsDone >= 8 - zipperEver) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* \"::\"? */\n\t\t\t\t\t\tif (first + 1 >= afterLast) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (first[1] == _UT(':')) {\n\t\t\t\t\t\t\tconst int resetOffset = 2 * (quadsDone + (digitCount > 0));\n\n\t\t\t\t\t\t\tfirst++;\n\t\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* \"::.+::\" */\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Zero everything after zipper */\n\t\t\t\t\t\t\tmemset(state->uri->hostData.ip6->data + resetOffset, 0, 16 - resetOffset);\n\t\t\t\t\t\t\tsetZipper = 1;\n\n\t\t\t\t\t\t\t/* \":::+\"? */\n\t\t\t\t\t\t\tif (first + 1 >= afterLast) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* No ']' yet */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (first[1] == _UT(':')) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* \":::+ \"*/\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (setZipper) {\n\t\t\t\t\t\t\tzipperEver = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT('.'):\n\t\t\t\t\tif ((quadsDone > 6) /* NOTE */\n\t\t\t\t\t\t\t|| (!zipperEver && (quadsDone < 6))\n\t\t\t\t\t\t\t|| letterAmong\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid octet before */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy first IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4] = uriGetOctetValue(digitHistory, digitCount);\n\t\t\t\t\tdigitCount = 0;\n\n\t\t\t\t\t/* Switch over to IPv4 loop */\n\t\t\t\t\tip4OctetsDone = 1;\n\t\t\t\t\twalking = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(']'):\n\t\t\t\t\t/* Too little quads? */\n\t\t\t\t\tif (!zipperEver && !((quadsDone == 7) && (digitCount > 0))) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (digitCount > 0) {\n\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, quadsAfterZipper + 2 * quadsAfterZipperCount);\n\t\t\t\t\t\t\tquadsAfterZipperCount++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, state->uri->hostData.ip6->data + 2 * quadsDone);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tquadsDone++;\n\t\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy missing quads to the end */\n\t\t\t\t\tmemcpy(state->uri->hostData.ip6->data + 16 - 2 * quadsAfterZipperCount,\n\t\t\t\t\t\t\t\tquadsAfterZipper, 2 * quadsAfterZipperCount);\n\n\t\t\t\t\tstate->uri->hostText.afterLast = first; /* HOST END */\n\t\t\t\t\treturn first + 1; /* Fine */\n\n\t\t\t\tdefault:\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tfirst++;\n\n\t\t\t\tif (first >= afterLast) {\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL; /* No ']' yet */\n\t\t\t\t}\n\t\t\t} while (walking);\n\t\t}\n\t}\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\t}\n",
        "src_path": "cef25028de5ff872c2e1f0a6c562eb3ea9ecbce4___UriParse.c",
        "uri": "https://api.github.com/repos/uriparser/uriparser/commits/cef25028de5ff872c2e1f0a6c562eb3ea9ecbce4",
        "commit_msg": "Fix uriParse*Ex* out-of-bounds read",
        "test_func_diff": [
            {
                "fn": "test/test.cpp",
                "patch": "@@ -242,6 +242,19 @@ TEST(UriSuite, TestIpSixFail) {\n \t\tURI_TEST_IP_SIX_FAIL(\"g:0:0:0:0:0:0\");\n }\n \n+TEST(UriSuite, TestIpSixOverread) {\n+\t\tUriUriA uri;\n+\t\tconst char * errorPos;\n+\n+\t\t// NOTE: This string is designed to not have a terminator\n+\t\tchar uriText[2 + 3 + 2 + 1 + 1];\n+\t\tstrncpy(uriText, \"//[::44.1\", sizeof(uriText));\n+\n+\t\tEXPECT_EQ(uriParseSingleUriExA(&uri, uriText,\n+\t\t\t\turiText + sizeof(uriText), &errorPos), URI_ERROR_SYNTAX);\n+\t\tEXPECT_EQ(errorPos, uriText + sizeof(uriText));\n+}\n+\n TEST(UriSuite, TestUri) {\n \t\tUriParserStateA stateA;\n \t\tUriParserStateW stateW;"
            }
        ],
        "error_msg": "[==========] Running 88 tests from 9 test suites.\n[----------] Global test environment set-up.\n[----------] 7 tests from FourSuite\n[ RUN      ] FourSuite.AbsolutizeTestCases\n[       OK ] FourSuite.AbsolutizeTestCases (0 ms)\n[ RUN      ] FourSuite.RelativizeTestCases\n[       OK ] FourSuite.RelativizeTestCases (0 ms)\n[ RUN      ] FourSuite.GoodUriReferences\n[       OK ] FourSuite.GoodUriReferences (0 ms)\n[ RUN      ] FourSuite.BadUriReferences\n[       OK ] FourSuite.BadUriReferences (0 ms)\n[ RUN      ] FourSuite.CaseNormalizationTests\n[       OK ] FourSuite.CaseNormalizationTests (0 ms)\n[ RUN      ] FourSuite.PctEncNormalizationTests\n[       OK ] FourSuite.PctEncNormalizationTests (0 ms)\n[ RUN      ] FourSuite.PathSegmentNormalizationTests\n[       OK ] FourSuite.PathSegmentNormalizationTests (0 ms)\n[----------] 7 tests from FourSuite (0 ms total)\n\n[----------] 2 tests from MemoryManagerCompletenessSuite\n[ RUN      ] MemoryManagerCompletenessSuite.AllFunctionMembersRequired\n[       OK ] MemoryManagerCompletenessSuite.AllFunctionMembersRequired (0 ms)\n[ RUN      ] MemoryManagerCompletenessSuite.MallocAndFreeRequiredOnly\n[       OK ] MemoryManagerCompletenessSuite.MallocAndFreeRequiredOnly (0 ms)\n[----------] 2 tests from MemoryManagerCompletenessSuite (0 ms total)\n\n[----------] 5 tests from MemoryManagerTestingSuite\n[ RUN      ] MemoryManagerTestingSuite.DefaultMemoryManager\n[       OK ] MemoryManagerTestingSuite.DefaultMemoryManager (0 ms)\n[ RUN      ] MemoryManagerTestingSuite.CompleteMemoryManager\n[       OK ] MemoryManagerTestingSuite.CompleteMemoryManager (0 ms)\n[ RUN      ] MemoryManagerTestingSuite.EmulateCalloc\n[       OK ] MemoryManagerTestingSuite.EmulateCalloc (0 ms)\n[ RUN      ] MemoryManagerTestingSuite.EmulateReallocarray\n[       OK ] MemoryManagerTestingSuite.EmulateReallocarray (0 ms)\n[ RUN      ] MemoryManagerTestingSuite.EmulateCallocAndReallocarray\n[       OK ] MemoryManagerTestingSuite.EmulateCallocAndReallocarray (0 ms)\n[----------] 5 tests from MemoryManagerTestingSuite (0 ms total)\n\n[---------"
    },
    "ea0f96cf45deed39fb98b28f30d0acdc304db243___printer_xml.c": {
        "prefix": "static LY_ERR\nxml_print_opaq_open(struct xmlpr_ctx *pctx, const struct lyd_node_opaq *node)\n{\n    /* print node name */\n    ly_print_(pctx->out, \"%*s<%s\", INDENT, node->name.name);\n\n",
        "suffix": "    /* print attributes */\n    LY_CHECK_RET(xml_print_attr(pctx, node));\n\n    return LY_SUCCESS;\n}\n",
        "start": 284,
        "end": 297,
        "buggy": "static LY_ERR\nxml_print_opaq_open(struct xmlpr_ctx *pctx, const struct lyd_node_opaq *node)\n{\n    /* print node name */\n    ly_print_(pctx->out, \"%*s<%s\", INDENT, node->name.name);\n\n    /* print default namespace */\n    xml_print_ns_opaq(pctx, node->format, &node->name, LYXML_PREFIX_DEFAULT);\n\n    /* print attributes */\n    LY_CHECK_RET(xml_print_attr(pctx, node));\n\n    return LY_SUCCESS;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    /* print default namespace */\n    xml_print_ns_opaq(pctx, node->format, &node->name, LYXML_PREFIX_DEFAULT);\n\n",
        "src_path": "ea0f96cf45deed39fb98b28f30d0acdc304db243___printer_xml.c",
        "uri": "https://api.github.com/repos/CESNET/libyang/commits/ea0f96cf45deed39fb98b28f30d0acdc304db243",
        "commit_msg": "printer xml BUGFIX printing anydata tree without namespace\n\nRefs #1958",
        "test_func_diff": [
            {
                "fn": "tests/utests/data/test_new.c",
                "patch": "@@ -370,6 +370,27 @@ test_path(void **state)\n             \"<ll2 xmlns=\\\"urn:tests:a\\\">val3</ll2>\\n\");\n     free(str);\n     lyd_free_siblings(root);\n+\n+    /* anydata */\n+    ret = lyd_new_path2(NULL, UTEST_LYCTX, \"/a:any\", \"<elem>val</elem>\", 0, LYD_ANYDATA_XML, 0, &root, NULL);\n+    assert_int_equal(ret, LY_SUCCESS);\n+    assert_non_null(root);\n+\n+    lyd_print_mem(&str, root, LYD_XML, LYD_PRINT_WITHSIBLINGS);\n+    assert_string_equal(str,\n+            \"<any xmlns=\\\"urn:tests:a\\\">\\n\"\n+            \"  <elem>val</elem>\\n\"\n+            \"</any>\\n\");\n+    free(str);\n+    lyd_print_mem(&str, root, LYD_JSON, LYD_PRINT_WITHSIBLINGS);\n+    assert_string_equal(str,\n+            \"{\\n\"\n+            \"  \\\"a:any\\\": {\\n\"\n+            \"    \\\"elem\\\": \\\"val\\\"\\n\"\n+            \"  }\\n\"\n+            \"}\\n\");\n+    free(str);\n+    lyd_free_siblings(root);\n }\n \n static void"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_ea0f96cf45deed39fb98b28f30d0acdc304db243/build_ea0f96cf45deed39fb98b28f30d0acdc304db243\nTest project /out/CESNET___libyang/git_repo_dir_ea0f96cf45deed39fb98b28f30d0acdc304db243/build_ea0f96cf45deed39fb98b28f30d0acdc304db243\n    Start 42: utest_new\n1/1 Test #42: utest_new ........................***Failed    0.04 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.05 sec\n\nThe following tests FAILED:\n\t 42 - utest_new (Failed)\n"
    },
    "812a5bff4857a485db96fe7269af944d0bdb91b3___tree_schema_compile.c": {
        "prefix": "static LY_ERR\nlys_compile_node_leaf(struct lysc_ctx *ctx, struct lysp_node *node_p, struct lysc_node *node)\n{\n    struct lysp_node_leaf *leaf_p = (struct lysp_node_leaf*)node_p;\n    struct lysc_node_leaf *leaf = (struct lysc_node_leaf*)node;\n    unsigned int u;\n    LY_ERR ret = LY_SUCCESS;\n\n    COMPILE_ARRAY_GOTO(ctx, leaf_p->musts, leaf->musts, u, lys_compile_must, ret, done);\n    if (leaf_p->units) {\n        leaf->units = lydict_insert(ctx->ctx, leaf_p->units, 0);\n        leaf->flags |= LYS_SET_UNITS;\n    }\n\n    /* the dflt member is just filled to avoid getting the default value from the type */\n    leaf->dflt = (void*)leaf_p->dflt;\n    ret = lys_compile_node_type(ctx, node_p, &leaf_p->type, leaf);\n",
        "suffix": "    if (leaf_p->dflt) {\n        struct ly_err_item *err = NULL;\n        leaf->dflt_mod = ctx->mod_def;\n        leaf->dflt = calloc(1, sizeof *leaf->dflt);\n        leaf->dflt->realtype = leaf->type;\n        ret = leaf->type->plugin->store(ctx->ctx, leaf->type, leaf_p->dflt, strlen(leaf_p->dflt),\n                                        LY_TYPE_OPTS_INCOMPLETE_DATA | LY_TYPE_OPTS_SCHEMA | LY_TYPE_OPTS_STORE,\n                                        lys_resolve_prefix, (void*)leaf->dflt_mod, LYD_XML, node, NULL, leaf->dflt, NULL, &err);\n        leaf->dflt->realtype->refcount++;\n        if (err) {\n            ly_err_print(err);\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_SEMANTICS,\n                   \"Invalid leaf's default value \\\"%s\\\" which does not fit the type (%s).\", leaf_p->dflt, err->msg);\n            ly_err_free(err);\n        }\n        if (ret == LY_EINCOMPLETE) {\n            /* postpone default compilation when the tree is complete */\n            LY_CHECK_RET(lysc_incomplete_dflts_add(ctx, node, leaf->dflt, leaf->dflt_mod));\n\n            /* but in general result is so far ok */\n            ret = LY_SUCCESS;\n        }\n        LY_CHECK_RET(ret);\n        leaf->flags |= LYS_SET_DFLT;\n    }\n\n\ndone:\n    return ret;\n}\n",
        "start": 3656,
        "end": 3705,
        "buggy": "static LY_ERR\nlys_compile_node_leaf(struct lysc_ctx *ctx, struct lysp_node *node_p, struct lysc_node *node)\n{\n    struct lysp_node_leaf *leaf_p = (struct lysp_node_leaf*)node_p;\n    struct lysc_node_leaf *leaf = (struct lysc_node_leaf*)node;\n    unsigned int u;\n    LY_ERR ret = LY_SUCCESS;\n\n    COMPILE_ARRAY_GOTO(ctx, leaf_p->musts, leaf->musts, u, lys_compile_must, ret, done);\n    if (leaf_p->units) {\n        leaf->units = lydict_insert(ctx->ctx, leaf_p->units, 0);\n        leaf->flags |= LYS_SET_UNITS;\n    }\n\n    /* the dflt member is just filled to avoid getting the default value from the type */\n    leaf->dflt = (void*)leaf_p->dflt;\n    ret = lys_compile_node_type(ctx, node_p, &leaf_p->type, leaf);\n    leaf->dflt = NULL;\n    LY_CHECK_RET(ret);\n\n    if (leaf_p->dflt) {\n        struct ly_err_item *err = NULL;\n        leaf->dflt_mod = ctx->mod_def;\n        leaf->dflt = calloc(1, sizeof *leaf->dflt);\n        leaf->dflt->realtype = leaf->type;\n        ret = leaf->type->plugin->store(ctx->ctx, leaf->type, leaf_p->dflt, strlen(leaf_p->dflt),\n                                        LY_TYPE_OPTS_INCOMPLETE_DATA | LY_TYPE_OPTS_SCHEMA | LY_TYPE_OPTS_STORE,\n                                        lys_resolve_prefix, (void*)leaf->dflt_mod, LYD_XML, node, NULL, leaf->dflt, NULL, &err);\n        leaf->dflt->realtype->refcount++;\n        if (err) {\n            ly_err_print(err);\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_SEMANTICS,\n                   \"Invalid leaf's default value \\\"%s\\\" which does not fit the type (%s).\", leaf_p->dflt, err->msg);\n            ly_err_free(err);\n        }\n        if (ret == LY_EINCOMPLETE) {\n            /* postpone default compilation when the tree is complete */\n            LY_CHECK_RET(lysc_incomplete_dflts_add(ctx, node, leaf->dflt, leaf->dflt_mod));\n\n            /* but in general result is so far ok */\n            ret = LY_SUCCESS;\n        }\n        LY_CHECK_RET(ret);\n        leaf->flags |= LYS_SET_DFLT;\n    }\n\n\ndone:\n    return ret;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    leaf->dflt = NULL;\n    LY_CHECK_RET(ret);\n\n",
        "src_path": "812a5bff4857a485db96fe7269af944d0bdb91b3___tree_schema_compile.c",
        "uri": "https://api.github.com/repos/CESNET/libyang/commits/812a5bff4857a485db96fe7269af944d0bdb91b3",
        "commit_msg": "schema compile BUGFIX memory leak\n\nFixes #872",
        "test_func_diff": [
            {
                "fn": "tests/src/test_tree_schema_compile.c",
                "patch": "@@ -2298,7 +2298,7 @@ test_type_dflt(void **state)\n     assert_non_null(type);\n     assert_int_equal(3, type->refcount); /* 2x type reference, 1x default value's reference (typedf's default does not reference own type)*/\n     assert_int_equal(LY_TYPE_STRING, type->basetype);\n-    leaf = (struct lysc_node_leaf*)mod->compiled->data;\n+    assert_non_null(leaf = (struct lysc_node_leaf*)mod->compiled->data);\n     assert_string_equal(\"hello\", leaf->dflt->realtype->plugin->print(leaf->dflt, LYD_XML, NULL, NULL, &dynamic));\n     assert_int_equal(0, dynamic);\n     assert_string_equal(\"xxx\", leaf->units);"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_812a5bff4857a485db96fe7269af944d0bdb91b3/build_812a5bff4857a485db96fe7269af944d0bdb91b3\nTest project /out/CESNET___libyang/git_repo_dir_812a5bff4857a485db96fe7269af944d0bdb91b3/build_812a5bff4857a485db96fe7269af944d0bdb91b3\n    Start 9: src_tree_schema_compile\n1/1 Test #9: src_tree_schema_compile ..........***Failed    0.12 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.12 sec\n\nThe following tests FAILED:\n\t  9 - src_tree_schema_compile (Failed)\n"
    },
    "823fbe0f7a7b50b7c80cfd948eb3c189579126ab___tree_schema.c": {
        "prefix": "static void\nlys_switch_deviation(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)\n{\n    int ret, reapply = 0;\n    char *parent_path;\n    struct lys_node *target = NULL, *parent;\n    struct ly_set *set;\n\n    if (!dev->deviate) {\n        return;\n    }\n\n    if (dev->deviate[0].mod == LY_DEVIATE_NO) {\n        if (dev->orig_node) {\n            /* removing not-supported deviation ... */\n            if (strrchr(dev->target_name, '/') != dev->target_name) {\n                /* ... from a parent */\n\n                /* reconnect to its previous position */\n                parent = dev->orig_node->parent;\n                if (parent) {\n                    dev->orig_node->parent = NULL;\n                    /* the original node was actually from augment, we have to get know if the augment is\n                     * applied (its module is enabled and implemented). If yes, the node will be connected\n                     * to the augment and the linkage with the target will be fixed if needed, otherwise\n                     * it will be connected only to the augment */\n                    if (!(parent->flags & LYS_NOTAPPLIED)) {\n                        /* start with removing augment if applied before adding nodes, we have to make sure\n                         * that everything will be connect correctly */\n                        remove_aug((struct lys_node_augment *)parent);\n                        reapply = 1;\n                    }\n                    /* connect the deviated node back into the augment */\n                    lys_node_addchild(parent, NULL, dev->orig_node);\n                    if (reapply) {\n                        /* augment is supposed to be applied, so fix pointers in target and the status of the original node */\n",
        "suffix": "                } else {\n                    /* non-augment, non-toplevel */\n                    parent_path = strndup(dev->target_name, strrchr(dev->target_name, '/') - dev->target_name);\n                    ret = resolve_schema_nodeid(parent_path, NULL, module, &set, 0, 1);\n                    free(parent_path);\n                    if (ret == -1) {\n                        LOGINT;\n                        ly_set_free(set);\n                        return;\n                    }\n                    target = set->set.s[0];\n                    ly_set_free(set);\n\n                    lys_node_addchild(target, NULL, dev->orig_node);\n                }\n            } else {\n                /* ... from top-level data */\n                lys_node_addchild(NULL, (struct lys_module *)dev->orig_node->module, dev->orig_node);\n            }\n\n            dev->orig_node = NULL;\n        } else {\n            /* adding not-supported deviation */\n            ret = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n            if (ret == -1) {\n                LOGINT;\n                ly_set_free(set);\n                return;\n            }\n            target = set->set.s[0];\n            ly_set_free(set);\n\n            /* unlink and store the original node */\n            parent = target->parent;\n            lys_node_unlink(target);\n            if (parent && parent->nodetype == LYS_AUGMENT) {\n                /* hack for augment, because when the original will be sometime reconnected back, we actually need\n                 * to reconnect it to both - the augment and its target (which is deduced from the deviations target\n                 * path), so we need to remember the augment as an addition */\n                target->parent = parent;\n            }\n            dev->orig_node = target;\n        }\n    } else {\n        ret = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n        if (ret == -1) {\n            LOGINT;\n            ly_set_free(set);\n            return;\n        }\n        target = set->set.s[0];\n        ly_set_free(set);\n\n        lys_node_switch(target, dev->orig_node);\n        dev->orig_node = target;\n    }\n}\n",
        "start": 4046,
        "end": 4146,
        "buggy": "static void\nlys_switch_deviation(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)\n{\n    int ret, reapply = 0;\n    char *parent_path;\n    struct lys_node *target = NULL, *parent;\n    struct ly_set *set;\n\n    if (!dev->deviate) {\n        return;\n    }\n\n    if (dev->deviate[0].mod == LY_DEVIATE_NO) {\n        if (dev->orig_node) {\n            /* removing not-supported deviation ... */\n            if (strrchr(dev->target_name, '/') != dev->target_name) {\n                /* ... from a parent */\n\n                /* reconnect to its previous position */\n                parent = dev->orig_node->parent;\n                if (parent) {\n                    dev->orig_node->parent = NULL;\n                    /* the original node was actually from augment, we have to get know if the augment is\n                     * applied (its module is enabled and implemented). If yes, the node will be connected\n                     * to the augment and the linkage with the target will be fixed if needed, otherwise\n                     * it will be connected only to the augment */\n                    if (!(parent->flags & LYS_NOTAPPLIED)) {\n                        /* start with removing augment if applied before adding nodes, we have to make sure\n                         * that everything will be connect correctly */\n                        remove_aug((struct lys_node_augment *)parent);\n                        reapply = 1;\n                    }\n                    /* connect the deviated node back into the augment */\n                    lys_node_addchild(parent, NULL, dev->orig_node);\n                    if (reapply) {\n                        /* augment is supposed to be applied, so fix pointers in target and the status of the original node */\n                        if (parent->child == dev->orig_node) {\n                            /* the only node in augment */\n                            parent->flags |= LYS_NOTAPPLIED; /* allow apply_aug() */\n                            apply_aug((struct lys_node_augment *)parent, unres);\n                            /* else other nodes from augment applied, nothing more needed in target, everything was done\n                             * by lys_node_addchild() */\n                        }\n                    }\n                } else {\n                    /* non-augment, non-toplevel */\n                    parent_path = strndup(dev->target_name, strrchr(dev->target_name, '/') - dev->target_name);\n                    ret = resolve_schema_nodeid(parent_path, NULL, module, &set, 0, 1);\n                    free(parent_path);\n                    if (ret == -1) {\n                        LOGINT;\n                        ly_set_free(set);\n                        return;\n                    }\n                    target = set->set.s[0];\n                    ly_set_free(set);\n\n                    lys_node_addchild(target, NULL, dev->orig_node);\n                }\n            } else {\n                /* ... from top-level data */\n                lys_node_addchild(NULL, (struct lys_module *)dev->orig_node->module, dev->orig_node);\n            }\n\n            dev->orig_node = NULL;\n        } else {\n            /* adding not-supported deviation */\n            ret = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n            if (ret == -1) {\n                LOGINT;\n                ly_set_free(set);\n                return;\n            }\n            target = set->set.s[0];\n            ly_set_free(set);\n\n            /* unlink and store the original node */\n            parent = target->parent;\n            lys_node_unlink(target);\n            if (parent && parent->nodetype == LYS_AUGMENT) {\n                /* hack for augment, because when the original will be sometime reconnected back, we actually need\n                 * to reconnect it to both - the augment and its target (which is deduced from the deviations target\n                 * path), so we need to remember the augment as an addition */\n                target->parent = parent;\n            }\n            dev->orig_node = target;\n        }\n    } else {\n        ret = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n        if (ret == -1) {\n            LOGINT;\n            ly_set_free(set);\n            return;\n        }\n        target = set->set.s[0];\n        ly_set_free(set);\n\n        lys_node_switch(target, dev->orig_node);\n        dev->orig_node = target;\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                        if (parent->child == dev->orig_node) {\n                            /* the only node in augment */\n                            parent->flags |= LYS_NOTAPPLIED; /* allow apply_aug() */\n                            apply_aug((struct lys_node_augment *)parent, unres);\n                            /* else other nodes from augment applied, nothing more needed in target, everything was done\n                             * by lys_node_addchild() */\n                        }\n                    }\n",
        "src_path": "823fbe0f7a7b50b7c80cfd948eb3c189579126ab___tree_schema.c",
        "uri": "https://api.github.com/repos/CESNET/libyang/commits/823fbe0f7a7b50b7c80cfd948eb3c189579126ab",
        "commit_msg": "schema tree BUGFIX removing not-supported deviation from augment\n\nTest for this also added.\nFixes #404",
        "test_func_diff": [
            {
                "fn": "tests/schema/test_deviation.c",
                "patch": "@@ -30,20 +30,14 @@\n \n #define SCHEMA_FOLDER_YANG TESTS_DIR\"/schema/yang/files\"\n \n-#define MOD_COUNT 7\n-#define YANG_MOD_IDX(idx) (idx)\n-\n struct ly_ctx *ctx;\n-char *yang_modules[2 * MOD_COUNT] = {0};\n \n static int\n setup_ctx_yang(void **state)\n {\n-    *state = malloc(strlen(TESTS_DIR) + 40);\n-    assert_non_null(*state);\n-    memcpy(*state, SCHEMA_FOLDER_YANG, strlen(SCHEMA_FOLDER_YANG) + 1);\n+    (void)state;\n \n-    ctx = ly_ctx_new(NULL, 0);\n+    ctx = ly_ctx_new(SCHEMA_FOLDER_YANG, 0);\n     if (!ctx) {\n         return -1;\n     }\n@@ -54,7 +48,8 @@ setup_ctx_yang(void **state)\n static int\n teardown_ctx(void **state)\n {\n-    free(*state);\n+    (void)state;\n+\n     ly_ctx_destroy(ctx, NULL);\n \n     return 0;\n@@ -63,17 +58,34 @@ teardown_ctx(void **state)\n static void\n test_deviation(void **state)\n {\n-    int length;\n-    char *path = *state;\n+    (void)state;\n+    char *str;\n     const struct lys_module *module;\n \n-    ly_ctx_set_searchdir(ctx, path);\n-    length = strlen(path);\n-    strcpy(path + length, \"/deviation1-dv.yang\");\n-    if (!(module = lys_parse_path(ctx, path, LYS_IN_YANG))) {\n+    if (!(module = ly_ctx_load_module(ctx, \"deviation1-dv\", NULL))) {\n+        fail();\n+    }\n+    lys_print_mem(&str, module, LYS_OUT_YANG, NULL);\n+    free(str);\n+    assert_int_equal(ly_errno, 0);\n+}\n+\n+static void\n+test_augment_deviation(void **state)\n+{\n+    (void)state;\n+    char *str;\n+    const struct lys_module *mod;\n+\n+    if (!ly_ctx_load_module(ctx, \"z-dev\", NULL)) {\n         fail();\n     }\n-    lys_print_mem(&yang_modules[YANG_MOD_IDX(0)], module, LYS_OUT_YANG, NULL);\n+    mod = ly_ctx_get_module(ctx, \"z\", NULL, 0);\n+    assert_ptr_not_equal(mod, NULL);\n+\n+    lys_print_mem(&str, mod, LYS_YANG, NULL);\n+    free(str);\n+    assert_int_equal(ly_errno, 0);\n }\n \n int\n@@ -82,6 +94,7 @@ main(void)\n     ly_verb(LY_LLWRN);\n     const struct CMUnitTest cmut[] = {\n         cmocka_unit_test_setup_teardown(test_deviation, setup_ctx_yang, teardown_ctx),\n+        cmocka_unit_test_setup_teardown(test_augment_deviation, setup_ctx_yang, teardown_ctx),\n     };\n \n     return cmocka_run_group_tests(cmut, NULL, NULL);"
            },
            {
                "fn": "tests/schema/yang/files/z-aug.yang",
                "patch": "@@ -0,0 +1,21 @@\n+module z-aug {\n+\n+  namespace \"urn:z-aug\";\n+  prefix \"z-aug\";\n+\n+  import z {\n+    prefix z;\n+  }\n+\n+  augment \"/z:list1/z:list2\" {\n+\n+    leaf leaf1 {\n+      type boolean;\n+    }\n+\n+    leaf leaf2 {\n+      type string;\n+    }\n+  }\n+}\n+"
            },
            {
                "fn": "tests/schema/yang/files/z-dev.yang",
                "patch": "@@ -0,0 +1,17 @@\n+module z-dev {\n+\n+    namespace \"urn:z-dev\";\n+    prefix z-dev;\n+\n+    import z {\n+      prefix z;\n+    }\n+\n+    import z-aug {\n+        prefix z-aug;\n+    }\n+\n+    deviation /z:list1/z:list2/z-aug:leaf1 {\n+        deviate not-supported;\n+    }\n+}"
            },
            {
                "fn": "tests/schema/yang/files/z.yang",
                "patch": "@@ -0,0 +1,22 @@\n+module z {\n+\n+  namespace \"urn:z\";\n+  prefix \"z\";\n+\n+  list list1 {\n+    key id;\n+\n+    leaf id {\n+      type string;\n+    }\n+\n+    list list2 {\n+      key id;\n+\n+      leaf id {\n+        type string;\n+      }\n+    }\n+  }\n+}\n+"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_823fbe0f7a7b50b7c80cfd948eb3c189579126ab/build_823fbe0f7a7b50b7c80cfd948eb3c189579126ab\nTest project /out/CESNET___libyang/git_repo_dir_823fbe0f7a7b50b7c80cfd948eb3c189579126ab/build_823fbe0f7a7b50b7c80cfd948eb3c189579126ab\n    Start 31: test_deviation\n1/1 Test #31: test_deviation ...................***Failed    0.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.02 sec\n\nThe following tests FAILED:\n\t 31 - test_deviation (Failed)\n"
    },
    "68e0fa7499876fc0cf86b8be784a890226648645___concatenate.cc": {
        "prefix": "  Result<std::shared_ptr<Buffer>> ConcatenateDictionaryIndices(\n      const DataType& index_type, const BufferVector& index_transpositions) {\n    const auto index_width =\n        internal::checked_cast<const FixedWidthType&>(index_type).bit_width() / 8;\n    int64_t out_length = 0;\n    for (const auto& data : in_) {\n      out_length += data->length;\n    }\n    ARROW_ASSIGN_OR_RAISE(auto out, AllocateBuffer(out_length * index_width, pool_));\n    uint8_t* out_data = out->mutable_data();\n    for (size_t i = 0; i < in_.size(); i++) {\n      const auto& data = in_[i];\n      auto transpose_map =\n          reinterpret_cast<const int32_t*>(index_transpositions[i]->data());\n      const uint8_t* src = data->GetValues<uint8_t>(1, 0);\n      if (!data->buffers[0]) {\n        RETURN_NOT_OK(internal::TransposeInts(index_type, index_type,\n                                              /*src=*/data->GetValues<uint8_t>(1, 0),\n                                              /*dest=*/out_data,\n                                              /*src_offset=*/data->offset,\n                                              /*dest_offset=*/0, /*length=*/data->length,\n                                              transpose_map));\n      } else {\n        internal::BitRunReader reader(data->buffers[0]->data(), data->offset,\n                                      data->length);\n        int64_t position = 0;\n        while (true) {\n          internal::BitRun run = reader.NextRun();\n          if (run.length == 0) break;\n\n          if (run.set) {\n            RETURN_NOT_OK(internal::TransposeInts(index_type, index_type, src,\n                                                  /*dest=*/out_data,\n                                                  /*src_offset=*/data->offset + position,\n                                                  /*dest_offset=*/position, run.length,\n                                                  transpose_map));\n          } else {\n",
        "suffix": "\n          position += run.length;\n        }\n      }\n      out_data += data->length * index_width;\n    }\n    return std::move(out);\n  }\n",
        "start": 277,
        "end": 324,
        "buggy": "  Result<std::shared_ptr<Buffer>> ConcatenateDictionaryIndices(\n      const DataType& index_type, const BufferVector& index_transpositions) {\n    const auto index_width =\n        internal::checked_cast<const FixedWidthType&>(index_type).bit_width() / 8;\n    int64_t out_length = 0;\n    for (const auto& data : in_) {\n      out_length += data->length;\n    }\n    ARROW_ASSIGN_OR_RAISE(auto out, AllocateBuffer(out_length * index_width, pool_));\n    uint8_t* out_data = out->mutable_data();\n    for (size_t i = 0; i < in_.size(); i++) {\n      const auto& data = in_[i];\n      auto transpose_map =\n          reinterpret_cast<const int32_t*>(index_transpositions[i]->data());\n      const uint8_t* src = data->GetValues<uint8_t>(1, 0);\n      if (!data->buffers[0]) {\n        RETURN_NOT_OK(internal::TransposeInts(index_type, index_type,\n                                              /*src=*/data->GetValues<uint8_t>(1, 0),\n                                              /*dest=*/out_data,\n                                              /*src_offset=*/data->offset,\n                                              /*dest_offset=*/0, /*length=*/data->length,\n                                              transpose_map));\n      } else {\n        internal::BitRunReader reader(data->buffers[0]->data(), data->offset,\n                                      data->length);\n        int64_t position = 0;\n        while (true) {\n          internal::BitRun run = reader.NextRun();\n          if (run.length == 0) break;\n\n          if (run.set) {\n            RETURN_NOT_OK(internal::TransposeInts(index_type, index_type, src,\n                                                  /*dest=*/out_data,\n                                                  /*src_offset=*/data->offset + position,\n                                                  /*dest_offset=*/position, run.length,\n                                                  transpose_map));\n          } else {\n            std::fill(out_data + position,\n                      out_data + position + (run.length * index_width), 0x00);\n          }\n\n          position += run.length;\n        }\n      }\n      out_data += data->length * index_width;\n    }\n    return std::move(out);\n  }\n",
        "fix": null,
        "buggy_hunk_masked": "            std::fill(out_data + position,\n                      out_data + position + (run.length * index_width), 0x00);\n          }\n",
        "src_path": "68e0fa7499876fc0cf86b8be784a890226648645___concatenate.cc",
        "uri": "https://api.github.com/repos/apache/arrow/commits/68e0fa7499876fc0cf86b8be784a890226648645",
        "commit_msg": "ARROW-17733: [C++] Take index_width into account when filling nulls in index buffer (#14129)\n\nTake into account index_width when offsetting by position into out_data. Otherwise we offset position bytes into the array, but we want to offset position places into the array.\n\nAuthored-by: Rasmus Johansen <rasnjo@gmail.com>\nSigned-off-by: David Li <li.davidm96@gmail.com>",
        "test_func_diff": [
            {
                "fn": "cpp/src/arrow/array/concatenate_test.cc",
                "patch": "@@ -539,4 +539,15 @@ TEST_F(ConcatenateTest, OffsetOverflow) {\n   ASSERT_RAISES(Invalid, Concatenate({fake_long, fake_long}).status());\n }\n \n+TEST_F(ConcatenateTest, DictionaryConcatenateWithEmptyUint16) {\n+  // Regression test for ARROW-17733\n+  auto dict_type = dictionary(uint16(), utf8());\n+  auto dict_one = DictArrayFromJSON(dict_type, \"[]\", \"[]\");\n+  auto dict_two =\n+      DictArrayFromJSON(dict_type, \"[0, 1, null, null, null, null]\", \"[\\\"A0\\\", \\\"A1\\\"]\");\n+  ASSERT_OK_AND_ASSIGN(auto concat_actual, Concatenate({dict_one, dict_two}));\n+\n+  AssertArraysEqual(*dict_two, *concat_actual);\n+}\n+\n }  // namespace arrow"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_68e0fa7499876fc0cf86b8be784a890226648645/build_68e0fa7499876fc0cf86b8be784a890226648645\nTest project /out/apache___arrow/git_repo_dir_68e0fa7499876fc0cf86b8be784a890226648645/build_68e0fa7499876fc0cf86b8be784a890226648645\n    Start 14: arrow-concatenate-test\n1/1 Test #14: arrow-concatenate-test ...........***Failed    0.22 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow-tests    =   0.22 sec*proc (1 test)\nunittest       =   0.22 sec*proc (1 test)\n\nTotal Test time (real) =   0.23 sec\n\nThe following tests FAILED:\n\t 14 - arrow-concatenate-test (Failed)\n"
    },
    "9ff3016c00108f21760d438bfbb451188886274c___type-conversion.h": {
        "prefix": "    void convert_to_base() SOCI_OVERRIDE\n    {\n",
        "suffix": "            base_value_holder<T>::val_, ind_);\n    }\n",
        "start": 148,
        "end": 152,
        "buggy": "    void convert_to_base() SOCI_OVERRIDE\n    {\n        type_conversion<T>::to_base(value_,\n            base_value_holder<T>::val_, ind_);\n    }\n",
        "fix": null,
        "buggy_hunk_masked": "        type_conversion<T>::to_base(value_,\n",
        "src_path": "9ff3016c00108f21760d438bfbb451188886274c___type-conversion.h",
        "uri": "https://api.github.com/repos/SOCI/soci/commits/9ff3016c00108f21760d438bfbb451188886274c",
        "commit_msg": "Fix use()-ing custom types with an explicitly null indicator\n\nThis fixes a bug caused by calling that soci::type_conversion::to_base()\nunconditionally, even if the caller explicitly passed i_null for the\nindicator, which is unnecessary work, but worse, actually resulted in\nwrong data being inserted into the database when using boost::optional\nconversion (and other similar custom type conversions) as it would set\nthe ind argument to i_ok, overriding the caller's explicit i_null passed\nto use().\n\nAdd (previously) failing test which now passes for most backends.",
        "test_func_diff": [
            {
                "fn": "tests/common-tests.h",
                "patch": "@@ -3588,6 +3588,90 @@ TEST_CASE_METHOD(common_tests, \"NULL with optional\", \"[core][boost][null]\")\n             CHECK((*pos).is_initialized());\n             CHECK(13 == (*pos).get());\n         }\n+\n+        // inserting using an i_null indicator with a populated boost::optional (should insert null per docs)\n+\n+        {\n+            auto_table_creator tableCreator(tc_.table_creator_1(sql));\n+\n+            {\n+                indicator ind = i_null;\n+                boost::optional<int> v1(10);\n+                sql << \"insert into soci_test(id, val) values(1, :val)\", use(v1, ind);\n+            }\n+\n+            // verify the value is fetched correctly as null\n+            {\n+                indicator ind;\n+                boost::optional<int> opt;\n+\n+                ind = (indicator)-1;\n+                opt = 0;\n+                sql << \"select val from soci_test where id = 1\", into(opt, ind);\n+                CHECK(ind == i_null);\n+                CHECK(!opt.is_initialized());\n+            }\n+        }\n+\n+        // prepared statement inserting non-null and null values alternatively (without passing an explicit indicator)\n+\n+        {\n+            auto_table_creator tableCreator(tc_.table_creator_1(sql));\n+\n+            {\n+            #if 0 // non-prepared method\n+                boost::optional<int> v1(10);\n+                sql << \"insert into soci_test(id, val) values(1, :val)\", use(v1);\n+                boost::optional<int> v2; // null\n+                sql << \"insert into soci_test(id, val) values(2, :val)\", use(v2);\n+                boost::optional<int> v3(11);\n+                sql << \"insert into soci_test(id, val) values(3, :val)\", use(v3);\n+            #else\n+                int id;\n+                boost::optional<int> val;\n+                statement st = (sql.prepare\n+                    << \"insert into soci_test(id, val) values (:id, :val)\", use(id), use(val));\n+\n+                id = 1;\n+                val = 10;\n+                st.execute(true);\n+\n+                id = 2;\n+                val = boost::optional<int>();\n+                st.execute(true);\n+\n+                id = 3;\n+                val = 11;\n+                st.execute(true);\n+            #endif\n+            }\n+\n+            // verify values are fetched correctly\n+            {\n+                indicator ind;\n+                boost::optional<int> opt;\n+\n+                ind = (indicator)-1;\n+                opt = 0;\n+                sql << \"select val from soci_test where id = 1\", into(opt, ind);\n+                CHECK(ind == i_ok);\n+                CHECK(opt.is_initialized());\n+                CHECK(opt.get() == 10);\n+\n+                ind = (indicator)-1;\n+                opt = 0;\n+                sql << \"select val from soci_test where id = 2\", into(opt, ind);\n+                CHECK(ind == i_null);\n+                CHECK(!opt.is_initialized());\n+\n+                ind = (indicator)-1;\n+                opt = 0;\n+                sql << \"select val from soci_test where id = 3\", into(opt, ind);\n+                CHECK(ind == i_ok);\n+                CHECK(opt.is_initialized());\n+                CHECK(opt.get() == 11);\n+            }\n+        }\n     }\n }\n "
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/SOCI___soci/git_repo_dir_9ff3016c00108f21760d438bfbb451188886274c/build_9ff3016c00108f21760d438bfbb451188886274c\nTest project /out/SOCI___soci/git_repo_dir_9ff3016c00108f21760d438bfbb451188886274c/build_9ff3016c00108f21760d438bfbb451188886274c\n    Start 3: soci_sqlite3_test\n1/2 Test #3: soci_sqlite3_test ................***Failed    0.10 sec\n    Start 4: soci_sqlite3_test_static\n2/2 Test #4: soci_sqlite3_test_static .........***Failed    0.09 sec\n\n0% tests passed, 2 tests failed out of 2\n\nTotal Test time (real) =   0.20 sec\n\nThe following tests FAILED:\n\t  3 - soci_sqlite3_test (Failed)\n\t  4 - soci_sqlite3_test_static (Failed)\n"
    },
    "6a9be627c760cf1efa43d155d4e6ee5e801deba3___optimizer.cpp": {
        "prefix": "bool Optimizer::Run(const uint32_t* original_binary,\n                    const size_t original_binary_size,\n                    std::vector<uint32_t>* optimized_binary,\n                    const spv_optimizer_options opt_options) const {\n  spvtools::SpirvTools tools(impl_->target_env);\n  tools.SetMessageConsumer(impl_->pass_manager.consumer());\n  if (opt_options->run_validator_ &&\n      !tools.Validate(original_binary, original_binary_size,\n                      &opt_options->val_options_)) {\n    return false;\n  }\n\n  std::unique_ptr<opt::IRContext> context = BuildModule(\n      impl_->target_env, consumer(), original_binary, original_binary_size);\n  if (context == nullptr) return false;\n\n  context->set_max_id_bound(opt_options->max_id_bound_);\n  context->set_preserve_bindings(opt_options->preserve_bindings_);\n  context->set_preserve_spec_constants(opt_options->preserve_spec_constants_);\n\n  impl_->pass_manager.SetValidatorOptions(&opt_options->val_options_);\n  impl_->pass_manager.SetTargetEnv(impl_->target_env);\n  auto status = impl_->pass_manager.Run(context.get());\n\n  if (status == opt::Pass::Status::Failure) {\n    return false;\n  }\n\n  optimized_binary->clear();\n  context->module()->ToBinary(optimized_binary, /* skip_nop = */ true);\n\n#ifndef NDEBUG\n  if (status == opt::Pass::Status::SuccessWithoutChange) {\n",
        "suffix": "    assert(!changed &&\n           \"Binary unexpectedly changed despite optimizer saying there was no \"\n           \"change\");\n  }\n#endif  // !NDEBUG\n\n  return true;\n}\n",
        "start": 535,
        "end": 578,
        "buggy": "bool Optimizer::Run(const uint32_t* original_binary,\n                    const size_t original_binary_size,\n                    std::vector<uint32_t>* optimized_binary,\n                    const spv_optimizer_options opt_options) const {\n  spvtools::SpirvTools tools(impl_->target_env);\n  tools.SetMessageConsumer(impl_->pass_manager.consumer());\n  if (opt_options->run_validator_ &&\n      !tools.Validate(original_binary, original_binary_size,\n                      &opt_options->val_options_)) {\n    return false;\n  }\n\n  std::unique_ptr<opt::IRContext> context = BuildModule(\n      impl_->target_env, consumer(), original_binary, original_binary_size);\n  if (context == nullptr) return false;\n\n  context->set_max_id_bound(opt_options->max_id_bound_);\n  context->set_preserve_bindings(opt_options->preserve_bindings_);\n  context->set_preserve_spec_constants(opt_options->preserve_spec_constants_);\n\n  impl_->pass_manager.SetValidatorOptions(&opt_options->val_options_);\n  impl_->pass_manager.SetTargetEnv(impl_->target_env);\n  auto status = impl_->pass_manager.Run(context.get());\n\n  if (status == opt::Pass::Status::Failure) {\n    return false;\n  }\n\n  optimized_binary->clear();\n  context->module()->ToBinary(optimized_binary, /* skip_nop = */ true);\n\n#ifndef NDEBUG\n  if (status == opt::Pass::Status::SuccessWithoutChange) {\n    auto changed = optimized_binary->size() != original_binary_size ||\n                   memcmp(optimized_binary->data(), original_binary,\n                          original_binary_size) != 0;\n    assert(!changed &&\n           \"Binary unexpectedly changed despite optimizer saying there was no \"\n           \"change\");\n  }\n#endif  // !NDEBUG\n\n  return true;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    auto changed = optimized_binary->size() != original_binary_size ||\n                   memcmp(optimized_binary->data(), original_binary,\n                          original_binary_size) != 0;\n",
        "src_path": "6a9be627c760cf1efa43d155d4e6ee5e801deba3___optimizer.cpp",
        "uri": "https://api.github.com/repos/KhronosGroup/SPIRV-Tools/commits/6a9be627c760cf1efa43d155d4e6ee5e801deba3",
        "commit_msg": "Keep NOPs when comparing with original binary (#2931)\n\nWe have a check that ensures that the optimizer did not change the\r\nbinary when it says that it did not.  However, when the binary is\r\nconverted back to a binary, we made a decision to remove OpNop\r\ninstructions.  This means that any spv file that contains a NOP\r\noriginally will fail this check.\r\n\r\nTo get around this, we convert the module to a second binary that keeps\r\nthe OpNop instructions.  That binary is compared against the original.\r\n\r\nFixes https://crbug.com/1010191",
        "test_func_diff": [
            {
                "fn": "test/opt/optimizer_test.cpp",
                "patch": "@@ -744,6 +744,54 @@ INSTANTIATE_TEST_SUITE_P(\n          // pass\n          \"compact-ids\"}}));\n \n+TEST(Optimizer, RemoveNop) {\n+  // Test that OpNops are removed even if no optimizations are run.\n+  const std::string before = R\"(OpCapability Shader\n+OpCapability Linkage\n+OpMemoryModel Logical GLSL450\n+%void = OpTypeVoid\n+%2 = OpTypeFunction %void\n+%3 = OpFunction %void None %2\n+%4 = OpLabel\n+OpNop\n+OpReturn\n+OpFunctionEnd\n+)\";\n+\n+  const std::string after = R\"(OpCapability Shader\n+OpCapability Linkage\n+OpMemoryModel Logical GLSL450\n+%void = OpTypeVoid\n+%2 = OpTypeFunction %void\n+%3 = OpFunction %void None %2\n+%4 = OpLabel\n+OpReturn\n+OpFunctionEnd\n+)\";\n+\n+  std::vector<uint32_t> binary;\n+  {\n+    SpirvTools tools(SPV_ENV_VULKAN_1_1);\n+    tools.Assemble(before, &binary);\n+  }\n+\n+  Optimizer opt(SPV_ENV_VULKAN_1_1);\n+\n+  std::vector<uint32_t> optimized;\n+  class ValidatorOptions validator_options;\n+  ASSERT_TRUE(opt.Run(binary.data(), binary.size(), &optimized,\n+                      validator_options, true))\n+      << before << \"\\n\";\n+  std::string disassembly;\n+  {\n+    SpirvTools tools(SPV_ENV_WEBGPU_0);\n+    tools.Disassemble(optimized.data(), optimized.size(), &disassembly);\n+  }\n+\n+  EXPECT_EQ(after, disassembly)\n+      << \"Was expecting the OpNop to have been removed.\";\n+}\n+\n }  // namespace\n }  // namespace opt\n }  // namespace spvtools"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_6a9be627c760cf1efa43d155d4e6ee5e801deba3/build_6a9be627c760cf1efa43d155d4e6ee5e801deba3\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_6a9be627c760cf1efa43d155d4e6ee5e801deba3/build_6a9be627c760cf1efa43d155d4e6ee5e801deba3\n    Start 13: spirv-tools-test_opt\n1/2 Test #13: spirv-tools-test_opt .............Subprocess aborted***Exception:  10.80 sec\n    Start 15: spirv-tools-test_opt_loops\n2/2 Test #15: spirv-tools-test_opt_loops .......   Passed    5.04 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  15.85 sec\n\nThe following tests FAILED:\n\t 13 - spirv-tools-test_opt (Subprocess aborted)\n"
    },
    "54385458ca2f7a7b06699e441822753dbc2d018d___register_pressure.cpp": {
        "prefix": "  void Compute() {\n",
        "suffix": "    EvaluateRegisterRequirements();\n  }\n",
        "start": 80,
        "end": 86,
        "buggy": "  void Compute() {\n    cfg_.ForEachBlockInPostOrder(&*function_->begin(), [this](BasicBlock* bb) {\n      ComputePartialLiveness(bb);\n    });\n    DoLoopLivenessUnification();\n    EvaluateRegisterRequirements();\n  }\n",
        "fix": null,
        "buggy_hunk_masked": "    cfg_.ForEachBlockInPostOrder(&*function_->begin(), [this](BasicBlock* bb) {\n      ComputePartialLiveness(bb);\n    });\n    DoLoopLivenessUnification();\n",
        "src_path": "54385458ca2f7a7b06699e441822753dbc2d018d___register_pressure.cpp",
        "uri": "https://api.github.com/repos/KhronosGroup/SPIRV-Tools/commits/54385458ca2f7a7b06699e441822753dbc2d018d",
        "commit_msg": "Handle unreachable block when computing register pressure (#3070)\n\nFixes #3053",
        "test_func_diff": [
            {
                "fn": "test/opt/register_liveness.cpp",
                "patch": "@@ -1277,6 +1277,46 @@ TEST_F(PassClassTest, FissionSimulation) {\n   }\n }\n \n+// Test that register liveness does not fail when there is an unreachable block.\n+// We are not testing if the liveness is computed correctly because the specific\n+// results do not matter for unreachable blocks.\n+TEST_F(PassClassTest, RegisterLivenessWithUnreachableBlock) {\n+  const std::string text = R\"(\n+               OpCapability Shader\n+          %1 = OpExtInstImport \"GLSL.std.450\"\n+               OpMemoryModel Logical GLSL450\n+               OpEntryPoint Fragment %2 \"main\"\n+               OpExecutionMode %2 OriginLowerLeft\n+               OpSource GLSL 330\n+               OpSourceExtension \"GL_ARB_shading_language_420pack\"\n+       %void = OpTypeVoid\n+          %4 = OpTypeFunction %void\n+          %2 = OpFunction %void None %4\n+          %5 = OpLabel\n+               OpBranch %6\n+          %6 = OpLabel\n+               OpLoopMerge %7 %8 None\n+               OpBranch %9\n+          %9 = OpLabel\n+               OpBranch %7\n+          %8 = OpLabel\n+               OpBranch %6\n+          %7 = OpLabel\n+               OpReturn\n+               OpFunctionEnd\n+  )\";\n+\n+  std::unique_ptr<IRContext> context =\n+      BuildModule(SPV_ENV_UNIVERSAL_1_1, nullptr, text,\n+                  SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);\n+  Module* module = context->module();\n+  EXPECT_NE(nullptr, module) << \"Assembling failed for shader:\\n\"\n+                             << text << std::endl;\n+  Function* f = &*module->begin();\n+  LivenessAnalysis* liveness_analysis = context->GetLivenessAnalysis();\n+  liveness_analysis->Get(f);\n+}\n+\n }  // namespace\n }  // namespace opt\n }  // namespace spvtools"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_54385458ca2f7a7b06699e441822753dbc2d018d/build_54385458ca2f7a7b06699e441822753dbc2d018d\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_54385458ca2f7a7b06699e441822753dbc2d018d/build_54385458ca2f7a7b06699e441822753dbc2d018d\n    Start 13: spirv-tools-test_opt\n1/2 Test #13: spirv-tools-test_opt .............Subprocess aborted***Exception:  11.83 sec\n    Start 15: spirv-tools-test_opt_loops\n2/2 Test #15: spirv-tools-test_opt_loops .......   Passed    4.86 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  16.70 sec\n\nThe following tests FAILED:\n\t 13 - spirv-tools-test_opt (Subprocess aborted)\n"
    },
    "0a5d99d02cb8c0edd41c7a9d4f309c0974d076d0___optimizer.cpp": {
        "prefix": "Optimizer& Optimizer::RegisterVulkanToWebGPUPasses() {\n",
        "suffix": "      .RegisterPass(CreateLegalizeVectorShufflePass())\n      .RegisterPass(CreateSplitInvalidUnreachablePass())\n      .RegisterPass(CreateEliminateDeadConstantPass())\n      .RegisterPass(CreateFlattenDecorationPass())\n      .RegisterPass(CreateAggressiveDCEPass())\n      .RegisterPass(CreateDeadBranchElimPass())\n      .RegisterPass(CreateCompactIdsPass());\n}\n",
        "start": 232,
        "end": 243,
        "buggy": "Optimizer& Optimizer::RegisterVulkanToWebGPUPasses() {\n  return RegisterPass(CreateStripDebugInfoPass())\n      .RegisterPass(CreateStripAtomicCounterMemoryPass())\n      .RegisterPass(CreateGenerateWebGPUInitializersPass())\n      .RegisterPass(CreateLegalizeVectorShufflePass())\n      .RegisterPass(CreateSplitInvalidUnreachablePass())\n      .RegisterPass(CreateEliminateDeadConstantPass())\n      .RegisterPass(CreateFlattenDecorationPass())\n      .RegisterPass(CreateAggressiveDCEPass())\n      .RegisterPass(CreateDeadBranchElimPass())\n      .RegisterPass(CreateCompactIdsPass());\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  return RegisterPass(CreateStripDebugInfoPass())\n      .RegisterPass(CreateStripAtomicCounterMemoryPass())\n      .RegisterPass(CreateGenerateWebGPUInitializersPass())\n",
        "src_path": "0a5d99d02cb8c0edd41c7a9d4f309c0974d076d0___optimizer.cpp",
        "uri": "https://api.github.com/repos/KhronosGroup/SPIRV-Tools/commits/0a5d99d02cb8c0edd41c7a9d4f309c0974d076d0",
        "commit_msg": "Permit the debug instructions in WebGPU SPIR-V - remove from the optimizer (#3083)\n\ncontinuing #3063\r\nfixing #3052",
        "test_func_diff": [
            {
                "fn": "test/opt/optimizer_test.cpp",
                "patch": "@@ -234,7 +234,6 @@ TEST(Optimizer, VulkanToWebGPUSetsCorrectPasses) {\n                                               \"eliminate-dead-code-aggressive\",\n                                               \"eliminate-dead-const\",\n                                               \"flatten-decorations\",\n-                                              \"strip-debug\",\n                                               \"strip-atomic-counter-memory\",\n                                               \"generate-webgpu-initializers\",\n                                               \"legalize-vector-shuffle\",\n@@ -330,35 +329,6 @@ INSTANTIATE_TEST_SUITE_P(\n          \"OpFunctionEnd\\n\",\n          // pass\n          \"flatten-decorations\"},\n-        // Strip Debug\n-        {// input\n-         \"OpCapability Shader\\n\"\n-         \"OpCapability VulkanMemoryModel\\n\"\n-         \"OpExtension \\\"SPV_KHR_vulkan_memory_model\\\"\\n\"\n-         \"OpMemoryModel Logical Vulkan\\n\"\n-         \"OpEntryPoint Vertex %func \\\"shader\\\"\\n\"\n-         \"OpName %main \\\"main\\\"\\n\"\n-         \"OpName %void_fn \\\"void_fn\\\"\\n\"\n-         \"%void = OpTypeVoid\\n\"\n-         \"%void_f = OpTypeFunction %void\\n\"\n-         \"%func = OpFunction %void None %void_f\\n\"\n-         \"%label = OpLabel\\n\"\n-         \"OpReturn\\n\"\n-         \"OpFunctionEnd\\n\",\n-         // expected\n-         \"OpCapability Shader\\n\"\n-         \"OpCapability VulkanMemoryModel\\n\"\n-         \"OpExtension \\\"SPV_KHR_vulkan_memory_model\\\"\\n\"\n-         \"OpMemoryModel Logical Vulkan\\n\"\n-         \"OpEntryPoint Vertex %1 \\\"shader\\\"\\n\"\n-         \"%void = OpTypeVoid\\n\"\n-         \"%3 = OpTypeFunction %void\\n\"\n-         \"%1 = OpFunction %void None %3\\n\"\n-         \"%4 = OpLabel\\n\"\n-         \"OpReturn\\n\"\n-         \"OpFunctionEnd\\n\",\n-         // pass\n-         \"strip-debug\"},\n         // Eliminate Dead Constants\n         {// input\n          \"OpCapability Shader\\n\""
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0a5d99d02cb8c0edd41c7a9d4f309c0974d076d0/build_0a5d99d02cb8c0edd41c7a9d4f309c0974d076d0\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0a5d99d02cb8c0edd41c7a9d4f309c0974d076d0/build_0a5d99d02cb8c0edd41c7a9d4f309c0974d076d0\n    Start 13: spirv-tools-test_opt\n1/2 Test #13: spirv-tools-test_opt .............***Failed   33.68 sec\n    Start 15: spirv-tools-test_opt_loops\n2/2 Test #15: spirv-tools-test_opt_loops .......   Passed    4.86 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  38.55 sec\n\nThe following tests FAILED:\n\t 13 - spirv-tools-test_opt (Failed)\n"
    },
    "d5a3bfcf2ffd154a244e7ffae54dd1766d98efa4___instruction.cpp": {
        "prefix": "NonSemanticShaderDebugInfo100Instructions Instruction::GetShader100DebugOpcode()\n    const {\n  if (opcode() != SpvOpExtInst) {\n    return NonSemanticShaderDebugInfo100InstructionsMax;\n  }\n\n  if (!context()->get_feature_mgr()->GetExtInstImportId_Shader100DebugInfo()) {\n    return NonSemanticShaderDebugInfo100InstructionsMax;\n  }\n\n  if (GetSingleWordInOperand(kExtInstSetIdInIdx) !=\n      context()->get_feature_mgr()->GetExtInstImportId_Shader100DebugInfo()) {\n    return NonSemanticShaderDebugInfo100InstructionsMax;\n  }\n\n",
        "suffix": "",
        "start": 681,
        "end": 698,
        "buggy": "NonSemanticShaderDebugInfo100Instructions Instruction::GetShader100DebugOpcode()\n    const {\n  if (opcode() != SpvOpExtInst) {\n    return NonSemanticShaderDebugInfo100InstructionsMax;\n  }\n\n  if (!context()->get_feature_mgr()->GetExtInstImportId_Shader100DebugInfo()) {\n    return NonSemanticShaderDebugInfo100InstructionsMax;\n  }\n\n  if (GetSingleWordInOperand(kExtInstSetIdInIdx) !=\n      context()->get_feature_mgr()->GetExtInstImportId_Shader100DebugInfo()) {\n    return NonSemanticShaderDebugInfo100InstructionsMax;\n  }\n\n  return NonSemanticShaderDebugInfo100Instructions(\n      GetSingleWordInOperand(kExtInstInstructionInIdx));\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  return NonSemanticShaderDebugInfo100Instructions(\n      GetSingleWordInOperand(kExtInstInstructionInIdx));\n}\n",
        "src_path": "d5a3bfcf2ffd154a244e7ffae54dd1766d98efa4___instruction.cpp",
        "uri": "https://api.github.com/repos/KhronosGroup/SPIRV-Tools/commits/d5a3bfcf2ffd154a244e7ffae54dd1766d98efa4",
        "commit_msg": "Avoid undefined behaviour when getting debug opcode (#4842)\n\nIf the `instruction` operand in an extended instruction instruction is\r\ntoo large, it causes undefined behaviour when that value is cast to the\r\nenum for the corresponding set.  This is done with the\r\nNonSemanticDebug100 instruction set.  We need to avoid the undefined\r\nbehaviour.\r\n\r\nFixes #4727",
        "test_func_diff": [
            {
                "fn": "test/opt/instruction_test.cpp",
                "patch": "@@ -1525,6 +1525,45 @@ OpFunctionEnd\n   EXPECT_EQ(false, inst->IsVulkanStorageTexelBuffer());\n }\n \n+TEST_F(DescriptorTypeTest, GetShader100DebugOpcode) {\n+  const std::string text = R\"(\n+              OpCapability Shader\n+         %1 = OpExtInstImport \"NonSemantic.Shader.DebugInfo.100\"\n+         %2 = OpString \"ps.hlsl\"\n+         %3 = OpString \"#line 1 \\\"ps.hlsl\\\"\"\n+      %void = OpTypeVoid\n+         %5 = OpExtInst %void %1 DebugExpression\n+         %6 = OpExtInst %void %1 DebugSource %2 %3\n+)\";\n+\n+  SetAssembleOptions(SPV_TEXT_TO_BINARY_OPTION_PRESERVE_NUMERIC_IDS);\n+  std::unique_ptr<IRContext> context =\n+      BuildModule(SPV_ENV_UNIVERSAL_1_2, nullptr, text);\n+  Instruction* debug_expression = context->get_def_use_mgr()->GetDef(5);\n+  EXPECT_EQ(debug_expression->GetShader100DebugOpcode(),\n+            NonSemanticShaderDebugInfo100DebugExpression);\n+  Instruction* debug_source = context->get_def_use_mgr()->GetDef(6);\n+  EXPECT_EQ(debug_source->GetShader100DebugOpcode(),\n+            NonSemanticShaderDebugInfo100DebugSource);\n+\n+  // Test that an opcode larger than the max will return Max.  This instruction\n+  // cannot be in the assembly above because the assembler expects the string\n+  // for the opcode, so we cannot use an arbitrary number.  However, a binary\n+  // file could have an arbitrary number.\n+  std::unique_ptr<Instruction> past_max(debug_expression->Clone(context.get()));\n+  const uint32_t kExtInstOpcodeInIndex = 1;\n+  uint32_t large_opcode = NonSemanticShaderDebugInfo100InstructionsMax + 2;\n+  past_max->SetInOperand(kExtInstOpcodeInIndex, {large_opcode});\n+  EXPECT_EQ(past_max->GetShader100DebugOpcode(),\n+            NonSemanticShaderDebugInfo100InstructionsMax);\n+\n+  // Test that an opcode without a value in the enum, but less than Max returns\n+  // the same value.\n+  uint32_t opcode = NonSemanticShaderDebugInfo100InstructionsMax - 2;\n+  past_max->SetInOperand(kExtInstOpcodeInIndex, {opcode});\n+  EXPECT_EQ(past_max->GetShader100DebugOpcode(), opcode);\n+}\n+\n }  // namespace\n }  // namespace opt\n }  // namespace spvtools"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_d5a3bfcf2ffd154a244e7ffae54dd1766d98efa4/build_d5a3bfcf2ffd154a244e7ffae54dd1766d98efa4\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_d5a3bfcf2ffd154a244e7ffae54dd1766d98efa4/build_d5a3bfcf2ffd154a244e7ffae54dd1766d98efa4\n    Start 18: spirv-tools-test_opt\n1/2 Test #18: spirv-tools-test_opt .............***Failed   49.79 sec\n    Start 20: spirv-tools-test_opt_loops\n2/2 Test #20: spirv-tools-test_opt_loops .......   Passed    5.27 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  55.08 sec\n\nThe following tests FAILED:\n\t 18 - spirv-tools-test_opt (Failed)\n"
    },
    "93035c8f47589590b65041603524f48a7c007e1f___Verifier.cpp": {
        "prefix": "void Verifier::verifyCallSite(CallSite CS) {\n  Instruction *I = CS.getInstruction();\n\n  Assert(CS.getCalledValue()->getType()->isPointerTy(),\n         \"Called function must be a pointer!\", I);\n  PointerType *FPTy = cast<PointerType>(CS.getCalledValue()->getType());\n\n  Assert(FPTy->getElementType()->isFunctionTy(),\n         \"Called function is not pointer to function type!\", I);\n\n  Assert(FPTy->getElementType() == CS.getFunctionType(),\n         \"Called function is not the same type as the call!\", I);\n\n  FunctionType *FTy = CS.getFunctionType();\n\n  // Verify that the correct number of arguments are being passed\n  if (FTy->isVarArg())\n    Assert(CS.arg_size() >= FTy->getNumParams(),\n           \"Called function requires more parameters than were provided!\", I);\n  else\n    Assert(CS.arg_size() == FTy->getNumParams(),\n           \"Incorrect number of arguments passed to called function!\", I);\n\n  // Verify that all arguments to the call match the function type.\n  for (unsigned i = 0, e = FTy->getNumParams(); i != e; ++i)\n    Assert(CS.getArgument(i)->getType() == FTy->getParamType(i),\n           \"Call parameter type does not match function signature!\",\n           CS.getArgument(i), FTy->getParamType(i), I);\n\n  AttributeSet Attrs = CS.getAttributes();\n\n  Assert(verifyAttributeCount(Attrs, CS.arg_size()),\n         \"Attribute after last parameter!\", I);\n\n  // Verify call attributes.\n  verifyFunctionAttrs(FTy, Attrs, I);\n\n  // Conservatively check the inalloca argument.\n  // We have a bug if we can find that there is an underlying alloca without\n  // inalloca.\n  if (CS.hasInAllocaArgument()) {\n    Value *InAllocaArg = CS.getArgument(FTy->getNumParams() - 1);\n    if (auto AI = dyn_cast<AllocaInst>(InAllocaArg->stripInBoundsOffsets()))\n      Assert(AI->isUsedWithInAlloca(),\n             \"inalloca argument for call has mismatched alloca\", AI, I);\n  }\n\n  // For each argument of the callsite, if it has the swifterror argument,\n  // make sure the underlying alloca has swifterror as well.\n  for (unsigned i = 0, e = FTy->getNumParams(); i != e; ++i)\n    if (CS.paramHasAttr(i+1, Attribute::SwiftError)) {\n      Value *SwiftErrorArg = CS.getArgument(i);\n      auto AI = dyn_cast<AllocaInst>(SwiftErrorArg->stripInBoundsOffsets());\n      Assert(AI, \"swifterror argument should come from alloca\", AI, I);\n      if (AI)\n        Assert(AI->isSwiftError(),\n               \"swifterror argument for call has mismatched alloca\", AI, I);\n    }\n\n  if (FTy->isVarArg()) {\n    // FIXME? is 'nest' even legal here?\n    bool SawNest = false;\n    bool SawReturned = false;\n\n    for (unsigned Idx = 1; Idx < 1 + FTy->getNumParams(); ++Idx) {\n      if (Attrs.hasAttribute(Idx, Attribute::Nest))\n        SawNest = true;\n      if (Attrs.hasAttribute(Idx, Attribute::Returned))\n        SawReturned = true;\n    }\n\n    // Check attributes on the varargs part.\n    for (unsigned Idx = 1 + FTy->getNumParams(); Idx <= CS.arg_size(); ++Idx) {\n      Type *Ty = CS.getArgument(Idx-1)->getType();\n      verifyParameterAttrs(Attrs, Idx, Ty, false, I);\n\n      if (Attrs.hasAttribute(Idx, Attribute::Nest)) {\n        Assert(!SawNest, \"More than one parameter has attribute nest!\", I);\n        SawNest = true;\n      }\n\n      if (Attrs.hasAttribute(Idx, Attribute::Returned)) {\n        Assert(!SawReturned, \"More than one parameter has attribute returned!\",\n               I);\n        Assert(Ty->canLosslesslyBitCastTo(FTy->getReturnType()),\n               \"Incompatible argument and return types for 'returned' \"\n               \"attribute\",\n               I);\n        SawReturned = true;\n      }\n\n      Assert(!Attrs.hasAttribute(Idx, Attribute::StructRet),\n             \"Attribute 'sret' cannot be used for vararg call arguments!\", I);\n\n      if (Attrs.hasAttribute(Idx, Attribute::InAlloca))\n        Assert(Idx == CS.arg_size(), \"inalloca isn't on the last argument!\", I);\n    }\n  }\n\n  // Verify that there's no metadata unless it's a direct call to an intrinsic.\n  if (CS.getCalledFunction() == nullptr ||\n      !CS.getCalledFunction()->getName().startswith(\"llvm.\")) {\n    for (Type *ParamTy : FTy->params()) {\n      Assert(!ParamTy->isMetadataTy(),\n             \"Function has metadata parameter but isn't an intrinsic\", I);\n      Assert(!ParamTy->isTokenTy(),\n             \"Function has token parameter but isn't an intrinsic\", I);\n    }\n  }\n\n  // Verify that indirect calls don't return tokens.\n  if (CS.getCalledFunction() == nullptr)\n    Assert(!FTy->getReturnType()->isTokenTy(),\n           \"Return type cannot be token for indirect call!\");\n\n  if (Function *F = CS.getCalledFunction())\n    if (Intrinsic::ID ID = (Intrinsic::ID)F->getIntrinsicID())\n      visitIntrinsicCallSite(ID, CS);\n\n  // Verify that a callsite has at most one \"deopt\", at most one \"funclet\" and\n  // at most one \"gc-transition\" operand bundle.\n  bool FoundDeoptBundle = false, FoundFuncletBundle = false,\n       FoundGCTransitionBundle = false;\n  for (unsigned i = 0, e = CS.getNumOperandBundles(); i < e; ++i) {\n    OperandBundleUse BU = CS.getOperandBundleAt(i);\n    uint32_t Tag = BU.getTagID();\n    if (Tag == LLVMContext::OB_deopt) {\n      Assert(!FoundDeoptBundle, \"Multiple deopt operand bundles\", I);\n      FoundDeoptBundle = true;\n    } else if (Tag == LLVMContext::OB_gc_transition) {\n      Assert(!FoundGCTransitionBundle, \"Multiple gc-transition operand bundles\",\n             I);\n      FoundGCTransitionBundle = true;\n    } else if (Tag == LLVMContext::OB_funclet) {\n      Assert(!FoundFuncletBundle, \"Multiple funclet operand bundles\", I);\n      FoundFuncletBundle = true;\n      Assert(BU.Inputs.size() == 1,\n             \"Expected exactly one funclet bundle operand\", I);\n      Assert(isa<FuncletPadInst>(BU.Inputs.front()),\n             \"Funclet bundle operands should correspond to a FuncletPadInst\",\n             I);\n    }\n  }\n\n",
        "suffix": "}\n",
        "start": 2438,
        "end": 2583,
        "buggy": "void Verifier::verifyCallSite(CallSite CS) {\n  Instruction *I = CS.getInstruction();\n\n  Assert(CS.getCalledValue()->getType()->isPointerTy(),\n         \"Called function must be a pointer!\", I);\n  PointerType *FPTy = cast<PointerType>(CS.getCalledValue()->getType());\n\n  Assert(FPTy->getElementType()->isFunctionTy(),\n         \"Called function is not pointer to function type!\", I);\n\n  Assert(FPTy->getElementType() == CS.getFunctionType(),\n         \"Called function is not the same type as the call!\", I);\n\n  FunctionType *FTy = CS.getFunctionType();\n\n  // Verify that the correct number of arguments are being passed\n  if (FTy->isVarArg())\n    Assert(CS.arg_size() >= FTy->getNumParams(),\n           \"Called function requires more parameters than were provided!\", I);\n  else\n    Assert(CS.arg_size() == FTy->getNumParams(),\n           \"Incorrect number of arguments passed to called function!\", I);\n\n  // Verify that all arguments to the call match the function type.\n  for (unsigned i = 0, e = FTy->getNumParams(); i != e; ++i)\n    Assert(CS.getArgument(i)->getType() == FTy->getParamType(i),\n           \"Call parameter type does not match function signature!\",\n           CS.getArgument(i), FTy->getParamType(i), I);\n\n  AttributeSet Attrs = CS.getAttributes();\n\n  Assert(verifyAttributeCount(Attrs, CS.arg_size()),\n         \"Attribute after last parameter!\", I);\n\n  // Verify call attributes.\n  verifyFunctionAttrs(FTy, Attrs, I);\n\n  // Conservatively check the inalloca argument.\n  // We have a bug if we can find that there is an underlying alloca without\n  // inalloca.\n  if (CS.hasInAllocaArgument()) {\n    Value *InAllocaArg = CS.getArgument(FTy->getNumParams() - 1);\n    if (auto AI = dyn_cast<AllocaInst>(InAllocaArg->stripInBoundsOffsets()))\n      Assert(AI->isUsedWithInAlloca(),\n             \"inalloca argument for call has mismatched alloca\", AI, I);\n  }\n\n  // For each argument of the callsite, if it has the swifterror argument,\n  // make sure the underlying alloca has swifterror as well.\n  for (unsigned i = 0, e = FTy->getNumParams(); i != e; ++i)\n    if (CS.paramHasAttr(i+1, Attribute::SwiftError)) {\n      Value *SwiftErrorArg = CS.getArgument(i);\n      auto AI = dyn_cast<AllocaInst>(SwiftErrorArg->stripInBoundsOffsets());\n      Assert(AI, \"swifterror argument should come from alloca\", AI, I);\n      if (AI)\n        Assert(AI->isSwiftError(),\n               \"swifterror argument for call has mismatched alloca\", AI, I);\n    }\n\n  if (FTy->isVarArg()) {\n    // FIXME? is 'nest' even legal here?\n    bool SawNest = false;\n    bool SawReturned = false;\n\n    for (unsigned Idx = 1; Idx < 1 + FTy->getNumParams(); ++Idx) {\n      if (Attrs.hasAttribute(Idx, Attribute::Nest))\n        SawNest = true;\n      if (Attrs.hasAttribute(Idx, Attribute::Returned))\n        SawReturned = true;\n    }\n\n    // Check attributes on the varargs part.\n    for (unsigned Idx = 1 + FTy->getNumParams(); Idx <= CS.arg_size(); ++Idx) {\n      Type *Ty = CS.getArgument(Idx-1)->getType();\n      verifyParameterAttrs(Attrs, Idx, Ty, false, I);\n\n      if (Attrs.hasAttribute(Idx, Attribute::Nest)) {\n        Assert(!SawNest, \"More than one parameter has attribute nest!\", I);\n        SawNest = true;\n      }\n\n      if (Attrs.hasAttribute(Idx, Attribute::Returned)) {\n        Assert(!SawReturned, \"More than one parameter has attribute returned!\",\n               I);\n        Assert(Ty->canLosslesslyBitCastTo(FTy->getReturnType()),\n               \"Incompatible argument and return types for 'returned' \"\n               \"attribute\",\n               I);\n        SawReturned = true;\n      }\n\n      Assert(!Attrs.hasAttribute(Idx, Attribute::StructRet),\n             \"Attribute 'sret' cannot be used for vararg call arguments!\", I);\n\n      if (Attrs.hasAttribute(Idx, Attribute::InAlloca))\n        Assert(Idx == CS.arg_size(), \"inalloca isn't on the last argument!\", I);\n    }\n  }\n\n  // Verify that there's no metadata unless it's a direct call to an intrinsic.\n  if (CS.getCalledFunction() == nullptr ||\n      !CS.getCalledFunction()->getName().startswith(\"llvm.\")) {\n    for (Type *ParamTy : FTy->params()) {\n      Assert(!ParamTy->isMetadataTy(),\n             \"Function has metadata parameter but isn't an intrinsic\", I);\n      Assert(!ParamTy->isTokenTy(),\n             \"Function has token parameter but isn't an intrinsic\", I);\n    }\n  }\n\n  // Verify that indirect calls don't return tokens.\n  if (CS.getCalledFunction() == nullptr)\n    Assert(!FTy->getReturnType()->isTokenTy(),\n           \"Return type cannot be token for indirect call!\");\n\n  if (Function *F = CS.getCalledFunction())\n    if (Intrinsic::ID ID = (Intrinsic::ID)F->getIntrinsicID())\n      visitIntrinsicCallSite(ID, CS);\n\n  // Verify that a callsite has at most one \"deopt\", at most one \"funclet\" and\n  // at most one \"gc-transition\" operand bundle.\n  bool FoundDeoptBundle = false, FoundFuncletBundle = false,\n       FoundGCTransitionBundle = false;\n  for (unsigned i = 0, e = CS.getNumOperandBundles(); i < e; ++i) {\n    OperandBundleUse BU = CS.getOperandBundleAt(i);\n    uint32_t Tag = BU.getTagID();\n    if (Tag == LLVMContext::OB_deopt) {\n      Assert(!FoundDeoptBundle, \"Multiple deopt operand bundles\", I);\n      FoundDeoptBundle = true;\n    } else if (Tag == LLVMContext::OB_gc_transition) {\n      Assert(!FoundGCTransitionBundle, \"Multiple gc-transition operand bundles\",\n             I);\n      FoundGCTransitionBundle = true;\n    } else if (Tag == LLVMContext::OB_funclet) {\n      Assert(!FoundFuncletBundle, \"Multiple funclet operand bundles\", I);\n      FoundFuncletBundle = true;\n      Assert(BU.Inputs.size() == 1,\n             \"Expected exactly one funclet bundle operand\", I);\n      Assert(isa<FuncletPadInst>(BU.Inputs.front()),\n             \"Funclet bundle operands should correspond to a FuncletPadInst\",\n             I);\n    }\n  }\n\n  visitInstruction(*I);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  visitInstruction(*I);\n",
        "src_path": "93035c8f47589590b65041603524f48a7c007e1f___Verifier.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/93035c8f47589590b65041603524f48a7c007e1f",
        "commit_msg": "Verifier: Verify that each inlinable callsite of a debug-info-bearing function\nin a debug-info-bearing function has a debug location attached to it. Failure to\ndo so causes an \"!dbg attachment points at wrong subprogram for function\"\nassertion failure when the inliner sets up inline scope info.\n\nrdar://problem/25878916\n\nThis reaplies r267320 without changes after fixing an issue in the OpenMP IR\ngenerator in clang.\n\nllvm-svn: 267370",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/X86/arange-and-stub.ll",
                "patch": "@@ -18,7 +18,7 @@ define void @foo() !dbg !4 {\n \n define void @bar() personality i8* bitcast (void ()* @foo to i8*) !dbg !9 {\n   invoke void @foo()\n-          to label %invoke.cont unwind label %lpad\n+          to label %invoke.cont unwind label %lpad, !dbg !19\n \n invoke.cont:                                      ; preds = %0\n   ret void\n@@ -50,3 +50,4 @@ lpad:                                             ; preds = %0\n !16 = !DISubrange(count: 1)\n !17 = !{i32 2, !\"Dwarf Version\", i32 4}\n !18 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!19 = !DILocation(line: 0, scope: !9)"
            },
            {
                "fn": "llvm/test/DebugInfo/X86/dbg-declare-arg.ll",
                "patch": "@@ -54,7 +54,7 @@ entry:\n   store %class.A* %this, %class.A** %this.addr, align 8\n   call void @llvm.dbg.declare(metadata %class.A** %this.addr, metadata !43, metadata !DIExpression()), !dbg !44\n   %this1 = load %class.A*, %class.A** %this.addr\n-  call void @_ZN1AD2Ev(%class.A* %this1)\n+  call void @_ZN1AD2Ev(%class.A* %this1), !dbg !53\n   ret void, !dbg !45\n }\n \n@@ -124,3 +124,4 @@ entry:\n !49 = distinct !DILexicalBlock(line: 2, column: 52, file: !51, scope: !25)\n !51 = !DIFile(filename: \"a.cc\", directory: \"/private/tmp\")\n !52 = !{i32 1, !\"Debug Info Version\", i32 3}\n+!53 = !DILocation(line: 0, scope: !22)"
            },
            {
                "fn": "llvm/test/Verifier/callsite-dbgloc.ll",
                "patch": "@@ -0,0 +1,62 @@\n+; RUN: not llvm-as %s -o %t 2>&1 | FileCheck %s\n+; Created and then edited from\n+;   extern void i();\n+;   void h() { i(); }\n+;   void g() { h(); }\n+;   void f() { g(); }\n+;\n+; Compiling this with inlining runs into the\n+; \"!dbg attachment points at wrong subprogram for function\"\n+; assertion.\n+\n+target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n+target triple = \"x86_64-apple-macosx\"\n+\n+; Function Attrs: nounwind ssp uwtable\n+define void @h() #0 !dbg !7 {\n+entry:\n+  call void (...) @i(), !dbg !9\n+  ret void, !dbg !10\n+}\n+\n+declare void @i(...) #1\n+\n+; Function Attrs: nounwind ssp uwtable\n+define void @g() #0 !dbg !11 {\n+entry:\n+; Manually removed !dbg.\n+; CHECK: inlinable function call in a function with debug info must have a !dbg location\n+  call void @h()\n+  ret void, !dbg !13\n+}\n+\n+; Function Attrs: nounwind ssp uwtable\n+define void @f() #0 !dbg !14 {\n+entry:\n+  call void @g(), !dbg !15\n+  ret void, !dbg !16\n+}\n+\n+attributes #0 = { nounwind ssp uwtable }\n+\n+!llvm.dbg.cu = !{!0}\n+!llvm.module.flags = !{!3, !4, !5}\n+!llvm.ident = !{!6}\n+\n+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: \"clang version 3.9.0 (trunk 267186)\", isOptimized: false, runtimeVersion: 0, emissionKind: LineTablesOnly, enums: !2)\n+!1 = !DIFile(filename: \"test.c\", directory: \"/Volumes/Data/llvm\")\n+!2 = !{}\n+!3 = !{i32 2, !\"Dwarf Version\", i32 2}\n+!4 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!5 = !{i32 1, !\"PIC Level\", i32 2}\n+!6 = !{!\"clang version 3.9.0 (trunk 267186)\"}\n+!7 = distinct !DISubprogram(name: \"h\", scope: !1, file: !1, line: 2, type: !8, isLocal: false, isDefinition: true, scopeLine: 2, isOptimized: false, unit: !0, variables: !2)\n+!8 = !DISubroutineType(types: !2)\n+!9 = !DILocation(line: 2, column: 12, scope: !7)\n+!10 = !DILocation(line: 2, column: 17, scope: !7)\n+!11 = distinct !DISubprogram(name: \"g\", scope: !1, file: !1, line: 3, type: !8, isLocal: false, isDefinition: true, scopeLine: 3, isOptimized: false, unit: !0, variables: !2)\n+!12 = !DILocation(line: 3, column: 12, scope: !11)\n+!13 = !DILocation(line: 3, column: 17, scope: !11)\n+!14 = distinct !DISubprogram(name: \"f\", scope: !1, file: !1, line: 4, type: !8, isLocal: false, isDefinition: true, scopeLine: 4, isOptimized: false, unit: !0, variables: !2)\n+!15 = !DILocation(line: 4, column: 12, scope: !14)\n+!16 = !DILocation(line: 4, column: 17, scope: !14)"
            }
        ],
        "error_msg": "FAIL: LLVM :: Verifier/callsite-dbgloc.ll (1 of 1)\nTesting Time: 0.03s\n********************\nFailing Tests (1):\n    LLVM :: Verifier/callsite-dbgloc.ll\n\n  Unexpected Failures: 1\n"
    },
    "0c8f3f9332929b12c0f81dcf07169c1869098c3b___InstCombineCompares.cpp": {
        "prefix": "static ICmpInst *canonicalizeCmpWithConstant(ICmpInst &I,\n                                             InstCombiner::BuilderTy &Builder) {\n  Value *Op0 = I.getOperand(0);\n  Value *Op1 = I.getOperand(1);\n\n  if (auto *Op1C = dyn_cast<ConstantInt>(Op1)) {\n    // For scalars, SimplifyICmpInst has already handled the edge cases for us,\n    // so we just assert on them.\n    APInt Op1Val = Op1C->getValue();\n    switch (I.getPredicate()) {\n    case ICmpInst::ICMP_ULE:\n      assert(!Op1C->isMaxValue(false)); // A <=u MAX -> TRUE\n      return new ICmpInst(ICmpInst::ICMP_ULT, Op0, Builder.getInt(Op1Val + 1));\n    case ICmpInst::ICMP_SLE:\n      assert(!Op1C->isMaxValue(true));  // A <=s MAX -> TRUE\n      return new ICmpInst(ICmpInst::ICMP_SLT, Op0, Builder.getInt(Op1Val + 1));\n    case ICmpInst::ICMP_UGE:\n      assert(!Op1C->isMinValue(false)); // A >=u MIN -> TRUE\n      return new ICmpInst(ICmpInst::ICMP_UGT, Op0, Builder.getInt(Op1Val - 1));\n    case ICmpInst::ICMP_SGE:\n      assert(!Op1C->isMinValue(true));  // A >=s MIN -> TRUE\n      return new ICmpInst(ICmpInst::ICMP_SGT, Op0, Builder.getInt(Op1Val - 1));\n    default:\n      return nullptr;\n    }\n  }\n\n  // The usual vector types are ConstantDataVector. Exotic vector types are\n",
        "suffix": "    Type *Op1Type = Op1->getType();\n    unsigned NumElts = Op1Type->getVectorNumElements();\n\n    // Set the new comparison predicate and splat a vector of 1 or -1 to\n    // increment or decrement the vector constants. But first, check that no\n    // elements of the constant vector would overflow/underflow when we\n    // increment/decrement the constants.\n    //\n    // TODO? If the edge cases for vectors were guaranteed to be handled as they\n    // are for scalar, we could remove the min/max checks here. However, to do\n    // that, we would have to use insertelement/shufflevector to replace edge\n    // values.\n    \n    CmpInst::Predicate NewPred;\n    Constant *OneOrNegOne = nullptr;\n    switch (I.getPredicate()) {\n    case ICmpInst::ICMP_ULE:\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (cast<ConstantInt>(Op1C->getAggregateElement(i))->isMaxValue(false))\n          return nullptr;\n      NewPred = ICmpInst::ICMP_ULT;\n      OneOrNegOne = ConstantInt::get(Op1Type, 1);\n      break;\n    case ICmpInst::ICMP_SLE:\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (cast<ConstantInt>(Op1C->getAggregateElement(i))->isMaxValue(true))\n          return nullptr;\n      NewPred = ICmpInst::ICMP_SLT;\n      OneOrNegOne = ConstantInt::get(Op1Type, 1);\n      break;\n    case ICmpInst::ICMP_UGE:\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (cast<ConstantInt>(Op1C->getAggregateElement(i))->isMinValue(false))\n          return nullptr;\n      NewPred = ICmpInst::ICMP_UGT;\n      OneOrNegOne = ConstantInt::get(Op1Type, -1);\n      break;\n    case ICmpInst::ICMP_SGE:\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (cast<ConstantInt>(Op1C->getAggregateElement(i))->isMinValue(true))\n          return nullptr;\n      NewPred = ICmpInst::ICMP_SGT;\n      OneOrNegOne = ConstantInt::get(Op1Type, -1);\n      break;\n    default:\n      return nullptr;\n    }\n\n    return new ICmpInst(NewPred, Op0, ConstantExpr::getAdd(Op1C, OneOrNegOne));\n  }\n\n  return nullptr;\n}\n",
        "start": 3105,
        "end": 3188,
        "buggy": "static ICmpInst *canonicalizeCmpWithConstant(ICmpInst &I,\n                                             InstCombiner::BuilderTy &Builder) {\n  Value *Op0 = I.getOperand(0);\n  Value *Op1 = I.getOperand(1);\n\n  if (auto *Op1C = dyn_cast<ConstantInt>(Op1)) {\n    // For scalars, SimplifyICmpInst has already handled the edge cases for us,\n    // so we just assert on them.\n    APInt Op1Val = Op1C->getValue();\n    switch (I.getPredicate()) {\n    case ICmpInst::ICMP_ULE:\n      assert(!Op1C->isMaxValue(false)); // A <=u MAX -> TRUE\n      return new ICmpInst(ICmpInst::ICMP_ULT, Op0, Builder.getInt(Op1Val + 1));\n    case ICmpInst::ICMP_SLE:\n      assert(!Op1C->isMaxValue(true));  // A <=s MAX -> TRUE\n      return new ICmpInst(ICmpInst::ICMP_SLT, Op0, Builder.getInt(Op1Val + 1));\n    case ICmpInst::ICMP_UGE:\n      assert(!Op1C->isMinValue(false)); // A >=u MIN -> TRUE\n      return new ICmpInst(ICmpInst::ICMP_UGT, Op0, Builder.getInt(Op1Val - 1));\n    case ICmpInst::ICMP_SGE:\n      assert(!Op1C->isMinValue(true));  // A >=s MIN -> TRUE\n      return new ICmpInst(ICmpInst::ICMP_SGT, Op0, Builder.getInt(Op1Val - 1));\n    default:\n      return nullptr;\n    }\n  }\n\n  // The usual vector types are ConstantDataVector. Exotic vector types are\n  // ConstantVector. They both derive from Constant.\n  if (isa<ConstantDataVector>(Op1) || isa<ConstantVector>(Op1)) {\n    Constant *Op1C = cast<Constant>(Op1);\n    Type *Op1Type = Op1->getType();\n    unsigned NumElts = Op1Type->getVectorNumElements();\n\n    // Set the new comparison predicate and splat a vector of 1 or -1 to\n    // increment or decrement the vector constants. But first, check that no\n    // elements of the constant vector would overflow/underflow when we\n    // increment/decrement the constants.\n    //\n    // TODO? If the edge cases for vectors were guaranteed to be handled as they\n    // are for scalar, we could remove the min/max checks here. However, to do\n    // that, we would have to use insertelement/shufflevector to replace edge\n    // values.\n    \n    CmpInst::Predicate NewPred;\n    Constant *OneOrNegOne = nullptr;\n    switch (I.getPredicate()) {\n    case ICmpInst::ICMP_ULE:\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (cast<ConstantInt>(Op1C->getAggregateElement(i))->isMaxValue(false))\n          return nullptr;\n      NewPred = ICmpInst::ICMP_ULT;\n      OneOrNegOne = ConstantInt::get(Op1Type, 1);\n      break;\n    case ICmpInst::ICMP_SLE:\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (cast<ConstantInt>(Op1C->getAggregateElement(i))->isMaxValue(true))\n          return nullptr;\n      NewPred = ICmpInst::ICMP_SLT;\n      OneOrNegOne = ConstantInt::get(Op1Type, 1);\n      break;\n    case ICmpInst::ICMP_UGE:\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (cast<ConstantInt>(Op1C->getAggregateElement(i))->isMinValue(false))\n          return nullptr;\n      NewPred = ICmpInst::ICMP_UGT;\n      OneOrNegOne = ConstantInt::get(Op1Type, -1);\n      break;\n    case ICmpInst::ICMP_SGE:\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (cast<ConstantInt>(Op1C->getAggregateElement(i))->isMinValue(true))\n          return nullptr;\n      NewPred = ICmpInst::ICMP_SGT;\n      OneOrNegOne = ConstantInt::get(Op1Type, -1);\n      break;\n    default:\n      return nullptr;\n    }\n\n    return new ICmpInst(NewPred, Op0, ConstantExpr::getAdd(Op1C, OneOrNegOne));\n  }\n\n  return nullptr;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  // ConstantVector. They both derive from Constant.\n  if (isa<ConstantDataVector>(Op1) || isa<ConstantVector>(Op1)) {\n    Constant *Op1C = cast<Constant>(Op1);\n",
        "src_path": "0c8f3f9332929b12c0f81dcf07169c1869098c3b___InstCombineCompares.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/0c8f3f9332929b12c0f81dcf07169c1869098c3b",
        "commit_msg": "[InstCombine] handle zero constant vectors for LE/GE comparisons too\n\nEnhancement to: http://reviews.llvm.org/rL269426\nWith discussion in: http://reviews.llvm.org/D17859\n\nThis should complete the fixes for: PR26701, PR26819:\nhttps://llvm.org/bugs/show_bug.cgi?id=26701\nhttps://llvm.org/bugs/show_bug.cgi?id=26819\n \n\nllvm-svn: 269439",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/icmp-vec.ll",
                "patch": "@@ -42,6 +42,43 @@ define <2 x i1> @ule(<2 x i8> %x) {\n   ret <2 x i1> %cmp\n }\n \n+; Zeros are special: they're ConstantAggregateZero.\n+\n+define <2 x i1> @sge_zero(<2 x i8> %x) {\n+; CHECK-LABEL: @sge_zero(\n+; CHECK-NEXT:    [[CMP:%.*]] = icmp sgt <2 x i8> %x, <i8 -1, i8 -1>\n+; CHECK-NEXT:    ret <2 x i1> [[CMP]]\n+;\n+  %cmp = icmp sge <2 x i8> %x, <i8 0, i8 0>\n+  ret <2 x i1> %cmp\n+}\n+\n+define <2 x i1> @uge_zero(<2 x i8> %x) {\n+; CHECK-LABEL: @uge_zero(\n+; CHECK-NEXT:    ret <2 x i1> <i1 true, i1 true>\n+;\n+  %cmp = icmp uge <2 x i8> %x, <i8 0, i8 0>\n+  ret <2 x i1> %cmp\n+}\n+\n+define <2 x i1> @sle_zero(<2 x i8> %x) {\n+; CHECK-LABEL: @sle_zero(\n+; CHECK-NEXT:    [[CMP:%.*]] = icmp slt <2 x i8> %x, <i8 1, i8 1>\n+; CHECK-NEXT:    ret <2 x i1> [[CMP]]\n+;\n+  %cmp = icmp sle <2 x i8> %x, <i8 0, i8 0>\n+  ret <2 x i1> %cmp\n+}\n+\n+define <2 x i1> @ule_zero(<2 x i8> %x) {\n+; CHECK-LABEL: @ule_zero(\n+; CHECK-NEXT:    [[CMP:%.*]] = icmp ult <2 x i8> %x, <i8 1, i8 1>\n+; CHECK-NEXT:    ret <2 x i1> [[CMP]]\n+;\n+  %cmp = icmp ule <2 x i8> %x, <i8 0, i8 0>\n+  ret <2 x i1> %cmp\n+}\n+\n ; Weird types are ConstantVectors, not ConstantDataVectors. For an i3 type:\n ; Signed min = -4\n ; Unsigned min = 0"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/icmp-vec.ll (1 of 1)\nTesting Time: 0.12s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/icmp-vec.ll\n\n  Unexpected Failures: 1\n"
    },
    "4a697c312f901a3a1ec92e24c91cefd64f6b4346___LoopUnrollPass.cpp": {
        "prefix": "static bool tryToUnrollLoop(Loop *L, DominatorTree &DT, LoopInfo *LI,\n                            ScalarEvolution *SE, const TargetTransformInfo &TTI,\n                            AssumptionCache &AC, bool PreserveLCSSA,\n                            Optional<unsigned> ProvidedCount,\n                            Optional<unsigned> ProvidedThreshold,\n                            Optional<bool> ProvidedAllowPartial,\n                            Optional<bool> ProvidedRuntime) {\n  DEBUG(dbgs() << \"Loop Unroll: F[\" << L->getHeader()->getParent()->getName()\n               << \"] Loop %\" << L->getHeader()->getName() << \"\\n\");\n  if (HasUnrollDisablePragma(L)) {\n    return false;\n  }\n\n  unsigned NumInlineCandidates;\n  bool NotDuplicatable;\n  bool Convergent;\n  unsigned LoopSize = ApproximateLoopSize(\n      L, NumInlineCandidates, NotDuplicatable, Convergent, TTI, &AC);\n  DEBUG(dbgs() << \"  Loop Size = \" << LoopSize << \"\\n\");\n  if (NotDuplicatable) {\n    DEBUG(dbgs() << \"  Not unrolling loop which contains non-duplicatable\"\n                 << \" instructions.\\n\");\n    return false;\n  }\n  if (NumInlineCandidates != 0) {\n    DEBUG(dbgs() << \"  Not unrolling loop with inlinable calls.\\n\");\n    return false;\n  }\n",
        "suffix": "  // Find trip count and trip multiple if count is not available\n  unsigned TripCount = 0;\n  unsigned TripMultiple = 1;\n  // If there are multiple exiting blocks but one of them is the latch, use the\n  // latch for the trip count estimation. Otherwise insist on a single exiting\n  // block for the trip count estimation.\n  BasicBlock *ExitingBlock = L->getLoopLatch();\n  if (!ExitingBlock || !L->isLoopExiting(ExitingBlock))\n    ExitingBlock = L->getExitingBlock();\n  if (ExitingBlock) {\n    TripCount = SE->getSmallConstantTripCount(L, ExitingBlock);\n    TripMultiple = SE->getSmallConstantTripMultiple(L, ExitingBlock);\n  }\n\n  TargetTransformInfo::UnrollingPreferences UP = gatherUnrollingPreferences(\n      L, TTI, ProvidedThreshold, ProvidedCount, ProvidedAllowPartial,\n      ProvidedRuntime);\n\n  // If the loop contains a convergent operation, the prelude we'd add\n  // to do the first few instructions before we hit the unrolled loop\n  // is unsafe -- it adds a control-flow dependency to the convergent\n  // operation.  Therefore restrict remainder loop (try unrollig without).\n  //\n  // TODO: This is quite conservative.  In practice, convergent_op()\n  // is likely to be called unconditionally in the loop.  In this\n  // case, the program would be ill-formed (on most architectures)\n  // unless n were the same on all threads in a thread group.\n  // Assuming n is the same on all threads, any kind of unrolling is\n  // safe.  But currently llvm's notion of convergence isn't powerful\n  // enough to express this.\n  if (Convergent)\n    UP.AllowRemainder = false;\n\n  bool IsCountSetExplicitly = computeUnrollCount(L, TTI, DT, LI, SE, TripCount,\n                                                 TripMultiple, LoopSize, UP);\n  if (!UP.Count)\n    return false;\n  // Unroll factor (Count) must be less or equal to TripCount.\n  if (TripCount && UP.Count > TripCount)\n    UP.Count = TripCount;\n\n  // Unroll the loop.\n  if (!UnrollLoop(L, UP.Count, TripCount, UP.Force, UP.Runtime,\n                  UP.AllowExpensiveTripCount, TripMultiple, LI, SE, &DT, &AC,\n                  PreserveLCSSA))\n    return false;\n\n  // If loop has an unroll count pragma or unrolled by explicitly set count\n  // mark loop as unrolled to prevent unrolling beyond that requested.\n  if (IsCountSetExplicitly)\n    SetLoopAlreadyUnrolled(L);\n  return true;\n}\n",
        "start": 897,
        "end": 978,
        "buggy": "static bool tryToUnrollLoop(Loop *L, DominatorTree &DT, LoopInfo *LI,\n                            ScalarEvolution *SE, const TargetTransformInfo &TTI,\n                            AssumptionCache &AC, bool PreserveLCSSA,\n                            Optional<unsigned> ProvidedCount,\n                            Optional<unsigned> ProvidedThreshold,\n                            Optional<bool> ProvidedAllowPartial,\n                            Optional<bool> ProvidedRuntime) {\n  DEBUG(dbgs() << \"Loop Unroll: F[\" << L->getHeader()->getParent()->getName()\n               << \"] Loop %\" << L->getHeader()->getName() << \"\\n\");\n  if (HasUnrollDisablePragma(L)) {\n    return false;\n  }\n\n  unsigned NumInlineCandidates;\n  bool NotDuplicatable;\n  bool Convergent;\n  unsigned LoopSize = ApproximateLoopSize(\n      L, NumInlineCandidates, NotDuplicatable, Convergent, TTI, &AC);\n  DEBUG(dbgs() << \"  Loop Size = \" << LoopSize << \"\\n\");\n  if (NotDuplicatable) {\n    DEBUG(dbgs() << \"  Not unrolling loop which contains non-duplicatable\"\n                 << \" instructions.\\n\");\n    return false;\n  }\n  if (NumInlineCandidates != 0) {\n    DEBUG(dbgs() << \"  Not unrolling loop with inlinable calls.\\n\");\n    return false;\n  }\n\n  // Find trip count and trip multiple if count is not available\n  unsigned TripCount = 0;\n  unsigned TripMultiple = 1;\n  // If there are multiple exiting blocks but one of them is the latch, use the\n  // latch for the trip count estimation. Otherwise insist on a single exiting\n  // block for the trip count estimation.\n  BasicBlock *ExitingBlock = L->getLoopLatch();\n  if (!ExitingBlock || !L->isLoopExiting(ExitingBlock))\n    ExitingBlock = L->getExitingBlock();\n  if (ExitingBlock) {\n    TripCount = SE->getSmallConstantTripCount(L, ExitingBlock);\n    TripMultiple = SE->getSmallConstantTripMultiple(L, ExitingBlock);\n  }\n\n  TargetTransformInfo::UnrollingPreferences UP = gatherUnrollingPreferences(\n      L, TTI, ProvidedThreshold, ProvidedCount, ProvidedAllowPartial,\n      ProvidedRuntime);\n\n  // If the loop contains a convergent operation, the prelude we'd add\n  // to do the first few instructions before we hit the unrolled loop\n  // is unsafe -- it adds a control-flow dependency to the convergent\n  // operation.  Therefore restrict remainder loop (try unrollig without).\n  //\n  // TODO: This is quite conservative.  In practice, convergent_op()\n  // is likely to be called unconditionally in the loop.  In this\n  // case, the program would be ill-formed (on most architectures)\n  // unless n were the same on all threads in a thread group.\n  // Assuming n is the same on all threads, any kind of unrolling is\n  // safe.  But currently llvm's notion of convergence isn't powerful\n  // enough to express this.\n  if (Convergent)\n    UP.AllowRemainder = false;\n\n  bool IsCountSetExplicitly = computeUnrollCount(L, TTI, DT, LI, SE, TripCount,\n                                                 TripMultiple, LoopSize, UP);\n  if (!UP.Count)\n    return false;\n  // Unroll factor (Count) must be less or equal to TripCount.\n  if (TripCount && UP.Count > TripCount)\n    UP.Count = TripCount;\n\n  // Unroll the loop.\n  if (!UnrollLoop(L, UP.Count, TripCount, UP.Force, UP.Runtime,\n                  UP.AllowExpensiveTripCount, TripMultiple, LI, SE, &DT, &AC,\n                  PreserveLCSSA))\n    return false;\n\n  // If loop has an unroll count pragma or unrolled by explicitly set count\n  // mark loop as unrolled to prevent unrolling beyond that requested.\n  if (IsCountSetExplicitly)\n    SetLoopAlreadyUnrolled(L);\n  return true;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\n",
        "src_path": "4a697c312f901a3a1ec92e24c91cefd64f6b4346___LoopUnrollPass.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/4a697c312f901a3a1ec92e24c91cefd64f6b4346",
        "commit_msg": "[LoopUnroll] Don't crash trying to unroll loop with EH pad exit\n\nWe do not support splitting cleanuppad or catchswitches.  This is\nproblematic for passes which assume that a loop is in loop simplify\nform (the loop would have a dedicated exit block instead of sharing it).\n\nWhile it isn't great that we don't support this for cleanups, we still\ncannot make loop-simplify form an assertable precondition because\nindirectbr will also disable these sorts of CFG cleanups.\n\nThis fixes PR28132.\n\nllvm-svn: 272739",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/LoopUnroll/pr28132.ll",
                "patch": "@@ -0,0 +1,77 @@\n+; RUN: opt -loop-unroll -S < %s | FileCheck %s\n+target datalayout = \"e-m:x-p:32:32-i64:64-f80:32-n8:16:32-a:0:32-S32\"\n+target triple = \"i686-pc-windows-msvc\"\n+\n+declare void @fn1(i8*)\n+\n+declare i1 @fn2(i8*, i8*)\n+\n+define void @fn4() personality i32 (...)* @__CxxFrameHandler3 {\n+entry:\n+  br label %for.body\n+\n+for.body:                                         ; preds = %for.inc, %entry\n+  %i.05 = phi i8 [ 0, %entry ], [ %inc, %for.inc ]\n+  store i8 undef, i8* undef, align 4\n+  invoke void @fn1(i8* undef)\n+          to label %call.i.noexc unwind label %ehcleanup\n+\n+call.i.noexc:                                     ; preds = %for.body\n+  %call1.i2 = invoke i1 @fn2(i8* undef, i8* undef)\n+          to label %call1.i.noexc unwind label %ehcleanup\n+\n+call1.i.noexc:                                    ; preds = %call.i.noexc\n+  br i1 undef, label %if.then.i, label %if.end4.i\n+\n+if.then.i:                                        ; preds = %call1.i.noexc\n+  %tmp1 = load i8, i8* undef, align 4\n+  %tobool.i = icmp eq i8 undef, undef\n+  br i1 undef, label %if.end4.i, label %if.then2.i\n+\n+if.then2.i:                                       ; preds = %if.then.i\n+  %call3.i3 = invoke i1 @fn2(i8* undef, i8* null)\n+          to label %call3.i.noexc unwind label %ehcleanup\n+\n+call3.i.noexc:                                    ; preds = %if.then2.i\n+  br label %if.end4.i\n+\n+if.end4.i:                                        ; preds = %call3.i.noexc, %if.then.i, %call1.i.noexc\n+  %tmp2 = load i8, i8* undef, align 4\n+  br label %if.then6.i\n+\n+if.then6.i:                                       ; preds = %if.end4.i\n+  %call7.i4 = invoke i1 @fn2(i8* undef, i8* null)\n+          to label %call7.i.noexc unwind label %ehcleanup\n+\n+call7.i.noexc:                                    ; preds = %if.then6.i\n+  br label %fn3\n+\n+fn3:                                              ; preds = %call7.i.noexc\n+  %tmp3 = load i8, i8* undef, align 4\n+  %inc.i = add nsw i8 undef, undef\n+  store i8 undef, i8* undef, align 4\n+  br label %for.inc\n+\n+for.inc:                                          ; preds = %fn3\n+  %inc = add nsw i8 %i.05, 1\n+  %cmp = icmp slt i8 %inc, 6\n+  br i1 %cmp, label %for.body, label %for.end\n+\n+for.end:                                          ; preds = %for.inc\n+  invoke void @throw()\n+          to label %unreachable unwind label %ehcleanup\n+\n+ehcleanup:                                        ; preds = %for.end, %if.then6.i, %if.then2.i, %call.i.noexc, %for.body\n+  %cp = cleanuppad within none []\n+  cleanupret from %cp unwind to caller\n+\n+; CHECK: cleanuppad\n+; CHECK-NOT: cleanuppad\n+\n+unreachable:                                      ; preds = %for.end\n+  unreachable\n+}\n+\n+declare i32 @__CxxFrameHandler3(...)\n+\n+declare void @throw()"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/LoopUnroll/pr28132.ll (1 of 1)\nTesting Time: 0.49s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LoopUnroll/pr28132.ll\n\n  Unexpected Failures: 1\n"
    },
    "c1fa163392f52d2119dec645f4f127ef79b83310___ExecutionDepsFix.cpp": {
        "prefix": "void ExeDepsFix::processDefs(MachineInstr *MI, bool Kill) {\n  assert(!MI->isDebugValue() && \"Won't process debug values\");\n\n  // Break dependence on undef uses. Do this before updating LiveRegs below.\n  unsigned OpNum;\n  unsigned Pref = TII->getUndefRegClearance(*MI, OpNum, TRI);\n  if (Pref) {\n    if (shouldBreakDependence(MI, OpNum, Pref))\n      UndefReads.push_back(std::make_pair(MI, OpNum));\n  }\n  const MCInstrDesc &MCID = MI->getDesc();\n  for (unsigned i = 0,\n         e = MI->isVariadic() ? MI->getNumOperands() : MCID.getNumDefs();\n         i != e; ++i) {\n    MachineOperand &MO = MI->getOperand(i);\n    if (!MO.isReg())\n      continue;\n",
        "suffix": "      continue;\n    for (int rx : regIndices(MO.getReg())) {\n      // This instruction explicitly defines rx.\n      DEBUG(dbgs() << TRI->getName(RC->getRegister(rx)) << \":\\t\" << CurInstr\n                   << '\\t' << *MI);\n\n      // Check clearance before partial register updates.\n      // Call breakDependence before setting LiveRegs[rx].Def.\n      unsigned Pref = TII->getPartialRegUpdateClearance(*MI, i, TRI);\n      if (Pref && shouldBreakDependence(MI, i, Pref))\n        TII->breakPartialRegDependency(*MI, i, TRI);\n\n      // How many instructions since rx was last written?\n      LiveRegs[rx].Def = CurInstr;\n\n      // Kill off domains redefined by generic instructions.\n      if (Kill)\n        kill(rx);\n    }\n  }\n  ++CurInstr;\n}\n",
        "start": 506,
        "end": 547,
        "buggy": "void ExeDepsFix::processDefs(MachineInstr *MI, bool Kill) {\n  assert(!MI->isDebugValue() && \"Won't process debug values\");\n\n  // Break dependence on undef uses. Do this before updating LiveRegs below.\n  unsigned OpNum;\n  unsigned Pref = TII->getUndefRegClearance(*MI, OpNum, TRI);\n  if (Pref) {\n    if (shouldBreakDependence(MI, OpNum, Pref))\n      UndefReads.push_back(std::make_pair(MI, OpNum));\n  }\n  const MCInstrDesc &MCID = MI->getDesc();\n  for (unsigned i = 0,\n         e = MI->isVariadic() ? MI->getNumOperands() : MCID.getNumDefs();\n         i != e; ++i) {\n    MachineOperand &MO = MI->getOperand(i);\n    if (!MO.isReg())\n      continue;\n    if (MO.isImplicit())\n      break;\n    if (MO.isUse())\n      continue;\n    for (int rx : regIndices(MO.getReg())) {\n      // This instruction explicitly defines rx.\n      DEBUG(dbgs() << TRI->getName(RC->getRegister(rx)) << \":\\t\" << CurInstr\n                   << '\\t' << *MI);\n\n      // Check clearance before partial register updates.\n      // Call breakDependence before setting LiveRegs[rx].Def.\n      unsigned Pref = TII->getPartialRegUpdateClearance(*MI, i, TRI);\n      if (Pref && shouldBreakDependence(MI, i, Pref))\n        TII->breakPartialRegDependency(*MI, i, TRI);\n\n      // How many instructions since rx was last written?\n      LiveRegs[rx].Def = CurInstr;\n\n      // Kill off domains redefined by generic instructions.\n      if (Kill)\n        kill(rx);\n    }\n  }\n  ++CurInstr;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (MO.isImplicit())\n      break;\n    if (MO.isUse())\n",
        "src_path": "c1fa163392f52d2119dec645f4f127ef79b83310___ExecutionDepsFix.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/c1fa163392f52d2119dec645f4f127ef79b83310",
        "commit_msg": "ExecutionDepsFix - Fix bug in clearance calculation\n\nThe clearance calculation did not take into account registers defined as outputs or clobbers in inline assembly machine instructions because these register defs are implicit.\n\nDifferential Revision: http://reviews.llvm.org/D22580\n\nllvm-svn: 276266",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/break-false-dep.ll",
                "patch": "@@ -199,3 +199,13 @@ for.end16:                                        ; preds = %for.inc14\n ;AVX-NEXT: vmulsd {{.*}}, [[XMM0]], [[XMM0]]\n ;AVX-NEXT: vmovsd [[XMM0]],\n }\n+\n+define double @inlineasmdep(i64 %arg) {\n+top:\n+  tail call void asm sideeffect \"\", \"~{xmm0},~{dirflag},~{fpsr},~{flags}\"()\n+  %tmp1 = sitofp i64 %arg to double\n+  ret double %tmp1\n+;AVX-LABEL:@inlineasmdep\n+;AVX: vxorps  [[XMM0:%xmm[0-9]+]], [[XMM0]], [[XMM0]]\n+;AVX-NEXT: vcvtsi2sdq {{.*}}, [[XMM0]], {{%xmm[0-9]+}}\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/break-false-dep.ll (1 of 1)\nTesting Time: 0.37s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/break-false-dep.ll\n\n  Unexpected Failures: 1\n"
    },
    "7fdaa5e64114bd5b614cff87bc350e4358b95200___MIRPrinter.cpp": {
        "prefix": "void MIPrinter::print(const MachineBasicBlock &MBB) {\n  assert(MBB.getNumber() >= 0 && \"Invalid MBB number\");\n  OS << \"bb.\" << MBB.getNumber();\n  bool HasAttributes = false;\n  if (const auto *BB = MBB.getBasicBlock()) {\n    if (BB->hasName()) {\n      OS << \".\" << BB->getName();\n    } else {\n      HasAttributes = true;\n      OS << \" (\";\n      int Slot = MST.getLocalSlot(BB);\n      if (Slot == -1)\n        OS << \"<ir-block badref>\";\n      else\n        OS << (Twine(\"%ir-block.\") + Twine(Slot)).str();\n    }\n  }\n  if (MBB.hasAddressTaken()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"address-taken\";\n    HasAttributes = true;\n  }\n  if (MBB.isEHPad()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"landing-pad\";\n    HasAttributes = true;\n  }\n  if (MBB.getAlignment()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"align \" << MBB.getAlignment();\n    HasAttributes = true;\n  }\n  if (HasAttributes)\n    OS << \")\";\n  OS << \":\\n\";\n\n  bool HasLineAttributes = false;\n  // Print the successors\n  bool canPredictProbs = canPredictBranchProbabilities(MBB);\n",
        "suffix": "    for (auto I = MBB.succ_begin(), E = MBB.succ_end(); I != E; ++I) {\n      if (I != MBB.succ_begin())\n        OS << \", \";\n      printMBBReference(**I);\n      if (!SimplifyMIR || !canPredictProbs)\n        OS << '('\n           << format(\"0x%08\" PRIx32, MBB.getSuccProbability(I).getNumerator())\n           << ')';\n    }\n    OS << \"\\n\";\n    HasLineAttributes = true;\n  }\n\n  // Print the live in registers.\n  const MachineRegisterInfo &MRI = MBB.getParent()->getRegInfo();\n  if (MRI.tracksLiveness() && !MBB.livein_empty()) {\n    const TargetRegisterInfo &TRI = *MRI.getTargetRegisterInfo();\n    OS.indent(2) << \"liveins: \";\n    bool First = true;\n    for (const auto &LI : MBB.liveins()) {\n      if (!First)\n        OS << \", \";\n      First = false;\n      printReg(LI.PhysReg, OS, &TRI);\n      if (!LI.LaneMask.all())\n        OS << \":0x\" << PrintLaneMask(LI.LaneMask);\n    }\n    OS << \"\\n\";\n    HasLineAttributes = true;\n  }\n\n  if (HasLineAttributes)\n    OS << \"\\n\";\n  bool IsInBundle = false;\n  for (auto I = MBB.instr_begin(), E = MBB.instr_end(); I != E; ++I) {\n    const MachineInstr &MI = *I;\n    if (IsInBundle && !MI.isInsideBundle()) {\n      OS.indent(2) << \"}\\n\";\n      IsInBundle = false;\n    }\n    OS.indent(IsInBundle ? 4 : 2);\n    print(MI);\n    if (!IsInBundle && MI.getFlag(MachineInstr::BundledSucc)) {\n      OS << \" {\";\n      IsInBundle = true;\n    }\n    OS << \"\\n\";\n  }\n  if (IsInBundle)\n    OS.indent(2) << \"}\\n\";\n}\n",
        "start": 562,
        "end": 654,
        "buggy": "void MIPrinter::print(const MachineBasicBlock &MBB) {\n  assert(MBB.getNumber() >= 0 && \"Invalid MBB number\");\n  OS << \"bb.\" << MBB.getNumber();\n  bool HasAttributes = false;\n  if (const auto *BB = MBB.getBasicBlock()) {\n    if (BB->hasName()) {\n      OS << \".\" << BB->getName();\n    } else {\n      HasAttributes = true;\n      OS << \" (\";\n      int Slot = MST.getLocalSlot(BB);\n      if (Slot == -1)\n        OS << \"<ir-block badref>\";\n      else\n        OS << (Twine(\"%ir-block.\") + Twine(Slot)).str();\n    }\n  }\n  if (MBB.hasAddressTaken()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"address-taken\";\n    HasAttributes = true;\n  }\n  if (MBB.isEHPad()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"landing-pad\";\n    HasAttributes = true;\n  }\n  if (MBB.getAlignment()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"align \" << MBB.getAlignment();\n    HasAttributes = true;\n  }\n  if (HasAttributes)\n    OS << \")\";\n  OS << \":\\n\";\n\n  bool HasLineAttributes = false;\n  // Print the successors\n  bool canPredictProbs = canPredictBranchProbabilities(MBB);\n  if (!MBB.succ_empty() && (!SimplifyMIR || !canPredictProbs ||\n                            !canPredictSuccessors(MBB))) {\n    OS.indent(2) << \"successors: \";\n    for (auto I = MBB.succ_begin(), E = MBB.succ_end(); I != E; ++I) {\n      if (I != MBB.succ_begin())\n        OS << \", \";\n      printMBBReference(**I);\n      if (!SimplifyMIR || !canPredictProbs)\n        OS << '('\n           << format(\"0x%08\" PRIx32, MBB.getSuccProbability(I).getNumerator())\n           << ')';\n    }\n    OS << \"\\n\";\n    HasLineAttributes = true;\n  }\n\n  // Print the live in registers.\n  const MachineRegisterInfo &MRI = MBB.getParent()->getRegInfo();\n  if (MRI.tracksLiveness() && !MBB.livein_empty()) {\n    const TargetRegisterInfo &TRI = *MRI.getTargetRegisterInfo();\n    OS.indent(2) << \"liveins: \";\n    bool First = true;\n    for (const auto &LI : MBB.liveins()) {\n      if (!First)\n        OS << \", \";\n      First = false;\n      printReg(LI.PhysReg, OS, &TRI);\n      if (!LI.LaneMask.all())\n        OS << \":0x\" << PrintLaneMask(LI.LaneMask);\n    }\n    OS << \"\\n\";\n    HasLineAttributes = true;\n  }\n\n  if (HasLineAttributes)\n    OS << \"\\n\";\n  bool IsInBundle = false;\n  for (auto I = MBB.instr_begin(), E = MBB.instr_end(); I != E; ++I) {\n    const MachineInstr &MI = *I;\n    if (IsInBundle && !MI.isInsideBundle()) {\n      OS.indent(2) << \"}\\n\";\n      IsInBundle = false;\n    }\n    OS.indent(IsInBundle ? 4 : 2);\n    print(MI);\n    if (!IsInBundle && MI.getFlag(MachineInstr::BundledSucc)) {\n      OS << \" {\";\n      IsInBundle = true;\n    }\n    OS << \"\\n\";\n  }\n  if (IsInBundle)\n    OS.indent(2) << \"}\\n\";\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  if (!MBB.succ_empty() && (!SimplifyMIR || !canPredictProbs ||\n                            !canPredictSuccessors(MBB))) {\n    OS.indent(2) << \"successors: \";\n",
        "src_path": "7fdaa5e64114bd5b614cff87bc350e4358b95200___MIRPrinter.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/7fdaa5e64114bd5b614cff87bc350e4358b95200",
        "commit_msg": "[MIRPrinter] Print empty successor lists when they cannot be guessed\n\nUnreachable blocks in the machine instr representation are these\nweird empty blocks with no successors.\nThe MIR printer used to not print empty lists of successors. However,\nthe MIR parser now treats non-printed list of successors as \"please\nguess it for me\". As a result, the parser tries to guess the list of\nsuccessors and given the block is empty, just assumes it falls through\nthe next block (if any).\n\nFor instance, the following test case used to fail the verifier.\nThe MIR printer would print\n          entry\n         /      \\\n    true (def)   false (no list of successors)\n        |\n  split.true (use)\n\nThe MIR parser would understand this:\n          entry\n         /      \\\n    true (def)   false\n        |        /  <-- invalid edge\n  split.true (use)\n\nBecause of the invalid edge, we get the \"def does not\ndominate all uses\" error.\n\nThe fix consists in printing empty successor lists, so that the parser\nknows what to do for unreachable blocks.\n\nrdar://problem/34022159\n\nllvm-svn: 313685",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/MIR/X86/unreachable_block.ll",
                "patch": "@@ -0,0 +1,48 @@\n+; RUN: llc -mtriple x86_64-- -stop-before peephole-opt -o %t.mir %s\n+; RUN: llc -mtriple x86_64-- -run-pass none %t.mir -verify-machineinstrs -o - | FileCheck %s\n+\n+; Unreachable blocks in the machine instr representation are these\n+; weird empty blocks with no successors.\n+; The MIR printer used to not print empty lists of successors. However,\n+; the MIR parser now treats non-printed list of successors as \"please\n+; guess it for me\". As a result, the parser tries to guess the list of\n+; successors and given the block is empty, just assumes it falls through\n+; the next block.\n+;\n+; The following test case used to fail the verifier because the false\n+; path ended up falling through split.true and now, the definition of\n+; %v does not dominate all its uses.\n+; Indeed, we go from the following CFG:\n+;          entry\n+;         /      \\\n+;    true (def)   false\n+;        |\n+;  split.true (use)\n+;\n+; To this one:\n+;          entry\n+;         /      \\\n+;    true (def)   false\n+;        |        /  <-- invalid edge\n+;  split.true (use)\n+;\n+; Because of the invalid edge, we get the \"def does not\n+; dominate all uses\" error.\n+;\n+; CHECK-LABEL: name: foo\n+; CHECK-LABEL: bb.{{[0-9]+}}.false:\n+; CHECK-NEXT: successors:\n+; CHECK-NOT: %bb.{{[0-9]+}}.split.true\n+; CHECK-LABEL: bb.{{[0-9]+}}.split.true:\n+define void @foo(i32* %bar) {\n+  br i1 undef, label %true, label %false\n+true:\n+  %v = load i32, i32* %bar\n+  br label %split.true\n+false:\n+  unreachable\n+split.true:\n+  %vInc = add i32 %v, 1\n+  store i32 %vInc, i32* %bar\n+  ret void\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/MIR/X86/unreachable_block.ll (1 of 1)\nTesting Time: 0.22s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/MIR/X86/unreachable_block.ll\n\n  Unexpected Failures: 1\n"
    },
    "17b0c78447e094e8465abc5dfb3a491f02521647___InstCombineCasts.cpp": {
        "prefix": "Instruction *InstCombiner::transformZExtICmp(ICmpInst *ICI, ZExtInst &CI,\n                                             bool DoTransform) {\n  // If we are just checking for a icmp eq of a single bit and zext'ing it\n  // to an integer, then shift the bit to the appropriate place and then\n  // cast to integer to avoid the comparison.\n  const APInt *Op1CV;\n  if (match(ICI->getOperand(1), m_APInt(Op1CV))) {\n\n    // zext (x <s  0) to i32 --> x>>u31      true if signbit set.\n    // zext (x >s -1) to i32 --> (x>>u31)^1  true if signbit clear.\n    if ((ICI->getPredicate() == ICmpInst::ICMP_SLT && Op1CV->isNullValue()) ||\n        (ICI->getPredicate() == ICmpInst::ICMP_SGT && Op1CV->isAllOnesValue())) {\n      if (!DoTransform) return ICI;\n\n      Value *In = ICI->getOperand(0);\n      Value *Sh = ConstantInt::get(In->getType(),\n                                   In->getType()->getScalarSizeInBits() - 1);\n      In = Builder.CreateLShr(In, Sh, In->getName() + \".lobit\");\n      if (In->getType() != CI.getType())\n        In = Builder.CreateIntCast(In, CI.getType(), false /*ZExt*/);\n\n      if (ICI->getPredicate() == ICmpInst::ICMP_SGT) {\n        Constant *One = ConstantInt::get(In->getType(), 1);\n        In = Builder.CreateXor(In, One, In->getName() + \".not\");\n      }\n\n      return replaceInstUsesWith(CI, In);\n    }\n\n    // zext (X == 0) to i32 --> X^1      iff X has only the low bit set.\n    // zext (X == 0) to i32 --> (X>>1)^1 iff X has only the 2nd bit set.\n    // zext (X == 1) to i32 --> X        iff X has only the low bit set.\n    // zext (X == 2) to i32 --> X>>1     iff X has only the 2nd bit set.\n    // zext (X != 0) to i32 --> X        iff X has only the low bit set.\n    // zext (X != 0) to i32 --> X>>1     iff X has only the 2nd bit set.\n    // zext (X != 1) to i32 --> X^1      iff X has only the low bit set.\n    // zext (X != 2) to i32 --> (X>>1)^1 iff X has only the 2nd bit set.\n    if ((Op1CV->isNullValue() || Op1CV->isPowerOf2()) &&\n        // This only works for EQ and NE\n        ICI->isEquality()) {\n      // If Op1C some other power of two, convert:\n      KnownBits Known = computeKnownBits(ICI->getOperand(0), 0, &CI);\n\n      APInt KnownZeroMask(~Known.Zero);\n      if (KnownZeroMask.isPowerOf2()) { // Exactly 1 possible 1?\n        if (!DoTransform) return ICI;\n\n        bool isNE = ICI->getPredicate() == ICmpInst::ICMP_NE;\n        if (!Op1CV->isNullValue() && (*Op1CV != KnownZeroMask)) {\n          // (X&4) == 2 --> false\n          // (X&4) != 2 --> true\n",
        "suffix": "        }\n\n        uint32_t ShAmt = KnownZeroMask.logBase2();\n        Value *In = ICI->getOperand(0);\n        if (ShAmt) {\n          // Perform a logical shr by shiftamt.\n          // Insert the shift to put the result in the low bit.\n          In = Builder.CreateLShr(In, ConstantInt::get(In->getType(), ShAmt),\n                                  In->getName() + \".lobit\");\n        }\n\n        if (!Op1CV->isNullValue() == isNE) { // Toggle the low bit.\n          Constant *One = ConstantInt::get(In->getType(), 1);\n          In = Builder.CreateXor(In, One);\n        }\n\n        if (CI.getType() == In->getType())\n          return replaceInstUsesWith(CI, In);\n\n        Value *IntCast = Builder.CreateIntCast(In, CI.getType(), false);\n        return replaceInstUsesWith(CI, IntCast);\n      }\n    }\n  }\n\n  // icmp ne A, B is equal to xor A, B when A and B only really have one bit.\n  // It is also profitable to transform icmp eq into not(xor(A, B)) because that\n  // may lead to additional simplifications.\n  if (ICI->isEquality() && CI.getType() == ICI->getOperand(0)->getType()) {\n    if (IntegerType *ITy = dyn_cast<IntegerType>(CI.getType())) {\n      Value *LHS = ICI->getOperand(0);\n      Value *RHS = ICI->getOperand(1);\n\n      KnownBits KnownLHS = computeKnownBits(LHS, 0, &CI);\n      KnownBits KnownRHS = computeKnownBits(RHS, 0, &CI);\n\n      if (KnownLHS.Zero == KnownRHS.Zero && KnownLHS.One == KnownRHS.One) {\n        APInt KnownBits = KnownLHS.Zero | KnownLHS.One;\n        APInt UnknownBit = ~KnownBits;\n        if (UnknownBit.countPopulation() == 1) {\n          if (!DoTransform) return ICI;\n\n          Value *Result = Builder.CreateXor(LHS, RHS);\n\n          // Mask off any bits that are set and won't be shifted away.\n          if (KnownLHS.One.uge(UnknownBit))\n            Result = Builder.CreateAnd(Result,\n                                        ConstantInt::get(ITy, UnknownBit));\n\n          // Shift the bit we're testing down to the lsb.\n          Result = Builder.CreateLShr(\n               Result, ConstantInt::get(ITy, UnknownBit.countTrailingZeros()));\n\n          if (ICI->getPredicate() == ICmpInst::ICMP_EQ)\n            Result = Builder.CreateXor(Result, ConstantInt::get(ITy, 1));\n          Result->takeName(ICI);\n          return replaceInstUsesWith(CI, Result);\n        }\n      }\n    }\n  }\n\n  return nullptr;\n}\n",
        "start": 770,
        "end": 888,
        "buggy": "Instruction *InstCombiner::transformZExtICmp(ICmpInst *ICI, ZExtInst &CI,\n                                             bool DoTransform) {\n  // If we are just checking for a icmp eq of a single bit and zext'ing it\n  // to an integer, then shift the bit to the appropriate place and then\n  // cast to integer to avoid the comparison.\n  const APInt *Op1CV;\n  if (match(ICI->getOperand(1), m_APInt(Op1CV))) {\n\n    // zext (x <s  0) to i32 --> x>>u31      true if signbit set.\n    // zext (x >s -1) to i32 --> (x>>u31)^1  true if signbit clear.\n    if ((ICI->getPredicate() == ICmpInst::ICMP_SLT && Op1CV->isNullValue()) ||\n        (ICI->getPredicate() == ICmpInst::ICMP_SGT && Op1CV->isAllOnesValue())) {\n      if (!DoTransform) return ICI;\n\n      Value *In = ICI->getOperand(0);\n      Value *Sh = ConstantInt::get(In->getType(),\n                                   In->getType()->getScalarSizeInBits() - 1);\n      In = Builder.CreateLShr(In, Sh, In->getName() + \".lobit\");\n      if (In->getType() != CI.getType())\n        In = Builder.CreateIntCast(In, CI.getType(), false /*ZExt*/);\n\n      if (ICI->getPredicate() == ICmpInst::ICMP_SGT) {\n        Constant *One = ConstantInt::get(In->getType(), 1);\n        In = Builder.CreateXor(In, One, In->getName() + \".not\");\n      }\n\n      return replaceInstUsesWith(CI, In);\n    }\n\n    // zext (X == 0) to i32 --> X^1      iff X has only the low bit set.\n    // zext (X == 0) to i32 --> (X>>1)^1 iff X has only the 2nd bit set.\n    // zext (X == 1) to i32 --> X        iff X has only the low bit set.\n    // zext (X == 2) to i32 --> X>>1     iff X has only the 2nd bit set.\n    // zext (X != 0) to i32 --> X        iff X has only the low bit set.\n    // zext (X != 0) to i32 --> X>>1     iff X has only the 2nd bit set.\n    // zext (X != 1) to i32 --> X^1      iff X has only the low bit set.\n    // zext (X != 2) to i32 --> (X>>1)^1 iff X has only the 2nd bit set.\n    if ((Op1CV->isNullValue() || Op1CV->isPowerOf2()) &&\n        // This only works for EQ and NE\n        ICI->isEquality()) {\n      // If Op1C some other power of two, convert:\n      KnownBits Known = computeKnownBits(ICI->getOperand(0), 0, &CI);\n\n      APInt KnownZeroMask(~Known.Zero);\n      if (KnownZeroMask.isPowerOf2()) { // Exactly 1 possible 1?\n        if (!DoTransform) return ICI;\n\n        bool isNE = ICI->getPredicate() == ICmpInst::ICMP_NE;\n        if (!Op1CV->isNullValue() && (*Op1CV != KnownZeroMask)) {\n          // (X&4) == 2 --> false\n          // (X&4) != 2 --> true\n          Constant *Res = ConstantInt::get(Type::getInt1Ty(CI.getContext()),\n                                           isNE);\n          Res = ConstantExpr::getZExt(Res, CI.getType());\n          return replaceInstUsesWith(CI, Res);\n        }\n\n        uint32_t ShAmt = KnownZeroMask.logBase2();\n        Value *In = ICI->getOperand(0);\n        if (ShAmt) {\n          // Perform a logical shr by shiftamt.\n          // Insert the shift to put the result in the low bit.\n          In = Builder.CreateLShr(In, ConstantInt::get(In->getType(), ShAmt),\n                                  In->getName() + \".lobit\");\n        }\n\n        if (!Op1CV->isNullValue() == isNE) { // Toggle the low bit.\n          Constant *One = ConstantInt::get(In->getType(), 1);\n          In = Builder.CreateXor(In, One);\n        }\n\n        if (CI.getType() == In->getType())\n          return replaceInstUsesWith(CI, In);\n\n        Value *IntCast = Builder.CreateIntCast(In, CI.getType(), false);\n        return replaceInstUsesWith(CI, IntCast);\n      }\n    }\n  }\n\n  // icmp ne A, B is equal to xor A, B when A and B only really have one bit.\n  // It is also profitable to transform icmp eq into not(xor(A, B)) because that\n  // may lead to additional simplifications.\n  if (ICI->isEquality() && CI.getType() == ICI->getOperand(0)->getType()) {\n    if (IntegerType *ITy = dyn_cast<IntegerType>(CI.getType())) {\n      Value *LHS = ICI->getOperand(0);\n      Value *RHS = ICI->getOperand(1);\n\n      KnownBits KnownLHS = computeKnownBits(LHS, 0, &CI);\n      KnownBits KnownRHS = computeKnownBits(RHS, 0, &CI);\n\n      if (KnownLHS.Zero == KnownRHS.Zero && KnownLHS.One == KnownRHS.One) {\n        APInt KnownBits = KnownLHS.Zero | KnownLHS.One;\n        APInt UnknownBit = ~KnownBits;\n        if (UnknownBit.countPopulation() == 1) {\n          if (!DoTransform) return ICI;\n\n          Value *Result = Builder.CreateXor(LHS, RHS);\n\n          // Mask off any bits that are set and won't be shifted away.\n          if (KnownLHS.One.uge(UnknownBit))\n            Result = Builder.CreateAnd(Result,\n                                        ConstantInt::get(ITy, UnknownBit));\n\n          // Shift the bit we're testing down to the lsb.\n          Result = Builder.CreateLShr(\n               Result, ConstantInt::get(ITy, UnknownBit.countTrailingZeros()));\n\n          if (ICI->getPredicate() == ICmpInst::ICMP_EQ)\n            Result = Builder.CreateXor(Result, ConstantInt::get(ITy, 1));\n          Result->takeName(ICI);\n          return replaceInstUsesWith(CI, Result);\n        }\n      }\n    }\n  }\n\n  return nullptr;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "          Constant *Res = ConstantInt::get(Type::getInt1Ty(CI.getContext()),\n                                           isNE);\n          Res = ConstantExpr::getZExt(Res, CI.getType());\n          return replaceInstUsesWith(CI, Res);\n",
        "src_path": "17b0c78447e094e8465abc5dfb3a491f02521647___InstCombineCasts.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/17b0c78447e094e8465abc5dfb3a491f02521647",
        "commit_msg": "[InstCombine] Fix a vector splat handling bug in transformZExtICmp.\n\nWe were using an i1 type and then zero extending to a vector. Instead just create the 0/1 directly as a ConstantInt with the correct type. No need to ask ConstantExpr to zero extend for us.\n\nThis bug is a bit tricky to hit because it requires us to visit a zext of an icmp that would normally be simplified to true/false, but that icmp hasnt' been visited yet. In the test case this zext and icmp were created by visiting a udiv and due to worklist ordering we got to the zext first.\n\nFixes PR34841.\n\nllvm-svn: 314971",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/div.ll",
                "patch": "@@ -553,3 +553,12 @@ define i32 @shrink_no3(i16 %x) {\n   ret i32 %div\n }\n \n+; This previously crashed when trying to simplify the zext/icmp this becomes.\n+define <2 x i8> @PR34841(<2 x i8> %x) {\n+; CHECK-LABEL: @PR34841(\n+; CHECK-NEXT:    ret <2 x i8> zeroinitializer\n+;\n+  %neg = and <2 x i8> %x, <i8 2, i8 2>\n+  %div = udiv <2 x i8> <i8 1, i8 1>, %neg\n+  ret <2 x i8> %div\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/div.ll (1 of 1)\nTesting Time: 0.61s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/div.ll\n\n  Unexpected Failures: 1\n"
    },
    "77d90b0c39f079b8871c39772a5bad8b8bfac322___SROA.cpp": {
        "prefix": "bool SROA::splitAlloca(AllocaInst &AI, AllocaSlices &AS) {\n  if (AS.begin() == AS.end())\n    return false;\n\n  unsigned NumPartitions = 0;\n  bool Changed = false;\n  const DataLayout &DL = AI.getModule()->getDataLayout();\n\n  // First try to pre-split loads and stores.\n  Changed |= presplitLoadsAndStores(AI, AS);\n\n  // Now that we have identified any pre-splitting opportunities, mark any\n  // splittable (non-whole-alloca) loads and stores as unsplittable. If we fail\n  // to split these during pre-splitting, we want to force them to be\n  // rewritten into a partition.\n  bool IsSorted = true;\n  for (Slice &S : AS) {\n    if (!S.isSplittable())\n      continue;\n    // FIXME: We currently leave whole-alloca splittable loads and stores. This\n    // used to be the only splittable loads and stores and we need to be\n    // confident that the above handling of splittable loads and stores is\n    // completely sufficient before we forcibly disable the remaining handling.\n    if (S.beginOffset() == 0 &&\n        S.endOffset() >= DL.getTypeAllocSize(AI.getAllocatedType()))\n      continue;\n    if (isa<LoadInst>(S.getUse()->getUser()) ||\n        isa<StoreInst>(S.getUse()->getUser())) {\n      S.makeUnsplittable();\n      IsSorted = false;\n    }\n  }\n  if (!IsSorted)\n    std::sort(AS.begin(), AS.end());\n\n  /// Describes the allocas introduced by rewritePartition in order to migrate\n  /// the debug info.\n  struct Fragment {\n    AllocaInst *Alloca;\n    uint64_t Offset;\n    uint64_t Size;\n    Fragment(AllocaInst *AI, uint64_t O, uint64_t S)\n      : Alloca(AI), Offset(O), Size(S) {}\n  };\n  SmallVector<Fragment, 4> Fragments;\n\n  // Rewrite each partition.\n  for (auto &P : AS.partitions()) {\n    if (AllocaInst *NewAI = rewritePartition(AI, AS, P)) {\n      Changed = true;\n      if (NewAI != &AI) {\n        uint64_t SizeOfByte = 8;\n        uint64_t AllocaSize = DL.getTypeSizeInBits(NewAI->getAllocatedType());\n        // Don't include any padding.\n        uint64_t Size = std::min(AllocaSize, P.size() * SizeOfByte);\n        Fragments.push_back(Fragment(NewAI, P.beginOffset() * SizeOfByte, Size));\n      }\n    }\n    ++NumPartitions;\n  }\n\n  NumAllocaPartitions += NumPartitions;\n  MaxPartitionsPerAlloca.updateMax(NumPartitions);\n\n  // Migrate debug information from the old alloca to the new alloca(s)\n  // and the individual partitions.\n  TinyPtrVector<DbgInfoIntrinsic *> DbgDeclares = FindDbgAddrUses(&AI);\n  if (!DbgDeclares.empty()) {\n    auto *Var = DbgDeclares.front()->getVariable();\n    auto *Expr = DbgDeclares.front()->getExpression();\n    auto VarSize = Var->getSizeInBits();\n    DIBuilder DIB(*AI.getModule(), /*AllowUnresolved*/ false);\n    uint64_t AllocaSize = DL.getTypeSizeInBits(AI.getAllocatedType());\n    for (auto Fragment : Fragments) {\n      // Create a fragment expression describing the new partition or reuse AI's\n      // expression if there is only one partition.\n      auto *FragmentExpr = Expr;\n      if (Fragment.Size < AllocaSize || Expr->isFragment()) {\n        // If this alloca is already a scalar replacement of a larger aggregate,\n        // Fragment.Offset describes the offset inside the scalar.\n        auto ExprFragment = Expr->getFragmentInfo();\n        uint64_t Offset = ExprFragment ? ExprFragment->OffsetInBits : 0;\n        uint64_t Start = Offset + Fragment.Offset;\n        uint64_t Size = Fragment.Size;\n        if (ExprFragment) {\n          uint64_t AbsEnd =\n              ExprFragment->OffsetInBits + ExprFragment->SizeInBits;\n          if (Start >= AbsEnd)\n            // No need to describe a SROAed padding.\n            continue;\n          Size = std::min(Size, AbsEnd - Start);\n        }\n        // The new, smaller fragment is stenciled out from the old fragment.\n        if (auto OrigFragment = FragmentExpr->getFragmentInfo()) {\n          assert(Start >= OrigFragment->OffsetInBits &&\n                 \"new fragment is outside of original fragment\");\n          Start -= OrigFragment->OffsetInBits;\n        }\n",
        "suffix": "        if (!VarSize || *VarSize != Size) {\n          if (auto E =\n                  DIExpression::createFragmentExpression(Expr, Start, Size))\n            FragmentExpr = *E;\n          else\n            continue;\n        }\n      }\n\n      // Remove any existing intrinsics describing the same alloca.\n      for (DbgInfoIntrinsic *OldDII : FindDbgAddrUses(Fragment.Alloca))\n        OldDII->eraseFromParent();\n\n      DIB.insertDeclare(Fragment.Alloca, Var, FragmentExpr,\n                        DbgDeclares.front()->getDebugLoc(), &AI);\n    }\n  }\n  return Changed;\n}\n",
        "start": 4039,
        "end": 4156,
        "buggy": "bool SROA::splitAlloca(AllocaInst &AI, AllocaSlices &AS) {\n  if (AS.begin() == AS.end())\n    return false;\n\n  unsigned NumPartitions = 0;\n  bool Changed = false;\n  const DataLayout &DL = AI.getModule()->getDataLayout();\n\n  // First try to pre-split loads and stores.\n  Changed |= presplitLoadsAndStores(AI, AS);\n\n  // Now that we have identified any pre-splitting opportunities, mark any\n  // splittable (non-whole-alloca) loads and stores as unsplittable. If we fail\n  // to split these during pre-splitting, we want to force them to be\n  // rewritten into a partition.\n  bool IsSorted = true;\n  for (Slice &S : AS) {\n    if (!S.isSplittable())\n      continue;\n    // FIXME: We currently leave whole-alloca splittable loads and stores. This\n    // used to be the only splittable loads and stores and we need to be\n    // confident that the above handling of splittable loads and stores is\n    // completely sufficient before we forcibly disable the remaining handling.\n    if (S.beginOffset() == 0 &&\n        S.endOffset() >= DL.getTypeAllocSize(AI.getAllocatedType()))\n      continue;\n    if (isa<LoadInst>(S.getUse()->getUser()) ||\n        isa<StoreInst>(S.getUse()->getUser())) {\n      S.makeUnsplittable();\n      IsSorted = false;\n    }\n  }\n  if (!IsSorted)\n    std::sort(AS.begin(), AS.end());\n\n  /// Describes the allocas introduced by rewritePartition in order to migrate\n  /// the debug info.\n  struct Fragment {\n    AllocaInst *Alloca;\n    uint64_t Offset;\n    uint64_t Size;\n    Fragment(AllocaInst *AI, uint64_t O, uint64_t S)\n      : Alloca(AI), Offset(O), Size(S) {}\n  };\n  SmallVector<Fragment, 4> Fragments;\n\n  // Rewrite each partition.\n  for (auto &P : AS.partitions()) {\n    if (AllocaInst *NewAI = rewritePartition(AI, AS, P)) {\n      Changed = true;\n      if (NewAI != &AI) {\n        uint64_t SizeOfByte = 8;\n        uint64_t AllocaSize = DL.getTypeSizeInBits(NewAI->getAllocatedType());\n        // Don't include any padding.\n        uint64_t Size = std::min(AllocaSize, P.size() * SizeOfByte);\n        Fragments.push_back(Fragment(NewAI, P.beginOffset() * SizeOfByte, Size));\n      }\n    }\n    ++NumPartitions;\n  }\n\n  NumAllocaPartitions += NumPartitions;\n  MaxPartitionsPerAlloca.updateMax(NumPartitions);\n\n  // Migrate debug information from the old alloca to the new alloca(s)\n  // and the individual partitions.\n  TinyPtrVector<DbgInfoIntrinsic *> DbgDeclares = FindDbgAddrUses(&AI);\n  if (!DbgDeclares.empty()) {\n    auto *Var = DbgDeclares.front()->getVariable();\n    auto *Expr = DbgDeclares.front()->getExpression();\n    auto VarSize = Var->getSizeInBits();\n    DIBuilder DIB(*AI.getModule(), /*AllowUnresolved*/ false);\n    uint64_t AllocaSize = DL.getTypeSizeInBits(AI.getAllocatedType());\n    for (auto Fragment : Fragments) {\n      // Create a fragment expression describing the new partition or reuse AI's\n      // expression if there is only one partition.\n      auto *FragmentExpr = Expr;\n      if (Fragment.Size < AllocaSize || Expr->isFragment()) {\n        // If this alloca is already a scalar replacement of a larger aggregate,\n        // Fragment.Offset describes the offset inside the scalar.\n        auto ExprFragment = Expr->getFragmentInfo();\n        uint64_t Offset = ExprFragment ? ExprFragment->OffsetInBits : 0;\n        uint64_t Start = Offset + Fragment.Offset;\n        uint64_t Size = Fragment.Size;\n        if (ExprFragment) {\n          uint64_t AbsEnd =\n              ExprFragment->OffsetInBits + ExprFragment->SizeInBits;\n          if (Start >= AbsEnd)\n            // No need to describe a SROAed padding.\n            continue;\n          Size = std::min(Size, AbsEnd - Start);\n        }\n        // The new, smaller fragment is stenciled out from the old fragment.\n        if (auto OrigFragment = FragmentExpr->getFragmentInfo()) {\n          assert(Start >= OrigFragment->OffsetInBits &&\n                 \"new fragment is outside of original fragment\");\n          Start -= OrigFragment->OffsetInBits;\n        }\n        // Avoid creating a fragment expression that covers the entire variable.\n        if (!VarSize || *VarSize != Size) {\n          if (auto E =\n                  DIExpression::createFragmentExpression(Expr, Start, Size))\n            FragmentExpr = *E;\n          else\n            continue;\n        }\n      }\n\n      // Remove any existing intrinsics describing the same alloca.\n      for (DbgInfoIntrinsic *OldDII : FindDbgAddrUses(Fragment.Alloca))\n        OldDII->eraseFromParent();\n\n      DIB.insertDeclare(Fragment.Alloca, Var, FragmentExpr,\n                        DbgDeclares.front()->getDebugLoc(), &AI);\n    }\n  }\n  return Changed;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        // Avoid creating a fragment expression that covers the entire variable.\n",
        "src_path": "77d90b0c39f079b8871c39772a5bad8b8bfac322___SROA.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/77d90b0c39f079b8871c39772a5bad8b8bfac322",
        "commit_msg": "SROA: Don't create variable fragments that are outside of the variable.\n\nAn alloca may be larger than a variable that is described to be stored\nthere. Don't create a dbg.value for fragments that are outside of the\nvariable.\n\nThis fixes PR35447.\nhttps://bugs.llvm.org/show_bug.cgi?id=35447\n\nllvm-svn: 319230",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/Generic/sroa-larger.ll",
                "patch": "@@ -0,0 +1,85 @@\n+; RUN: opt -sroa -S -o - %s | FileCheck %s\n+; Generated from clang -c  -O2 -g -target x86_64-pc-windows-msvc\n+; struct A {\n+;   int _Myval2;\n+;   A() : _Myval2() {}\n+; };\n+; struct B {\n+;   double buffer[];\n+; };\n+; struct C {\n+;   C(int) {}\n+;   A _Mypair;\n+; };\n+; int getPtr();\n+; struct D {\n+;   C takePayload() {\n+;     C Tmp(getPtr());\n+;     return Tmp;\n+;   }\n+; } Dd;\n+; void *operator new(size_t, void *);\n+; struct F {\n+;   F(D Err) : HasError() {\n+;     C *e = (C *)(ErrorStorage.buffer);\n+;     new (e) C(Err.takePayload());\n+;   }\n+;   B ErrorStorage;\n+;   bool HasError;\n+; };\n+; F fn2() { return Dd; }\n+; void fn3() { fn2(); }\n+source_filename = \"test.ll\"\n+\n+%struct.F = type { %struct.B, i8 }\n+%struct.B = type { [0 x double], [8 x i8] }\n+\n+define void @\"\\01?fn3@@YAXXZ\"() local_unnamed_addr !dbg !6 {\n+entry:\n+  %tmp = alloca %struct.F, align 8\n+  %0 = bitcast %struct.F* %tmp to i8*\n+  call void @llvm.lifetime.start.p0i8(i64 16, i8* %0)\n+  call void @llvm.dbg.declare(metadata %struct.F* %tmp, metadata !10, metadata !DIExpression()), !dbg !14\n+  ; CHECK-NOT: !DIExpression(DW_OP_LLVM_fragment, 32, 96)\n+  ; CHECK: call void @llvm.dbg.value(metadata i32 0, metadata !10, metadata !DIExpression())\n+  %_Myval2.i.i.i.i.i = bitcast %struct.F* %tmp to i32*\n+  store i32 0, i32* %_Myval2.i.i.i.i.i, align 8\n+  ret void\n+}\n+\n+; Function Attrs: argmemonly nounwind\n+declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture) #0\n+\n+; Function Attrs: nounwind readnone speculatable\n+declare void @llvm.dbg.declare(metadata, metadata, metadata) #1\n+\n+attributes #0 = { argmemonly nounwind }\n+attributes #1 = { nounwind readnone speculatable }\n+\n+!llvm.dbg.cu = !{!0}\n+!llvm.module.flags = !{!2, !3, !4, !5}\n+\n+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: \"clang version 6.0.0 (trunk 319178) (llvm/trunk 319187)\", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug)\n+!1 = !DIFile(filename: \"test.cpp\", directory: \"/\")\n+!2 = !{i32 2, !\"Dwarf Version\", i32 4}\n+!3 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!4 = !{i32 1, !\"wchar_size\", i32 2}\n+!5 = !{i32 7, !\"PIC Level\", i32 2}\n+!6 = distinct !DISubprogram(name: \"fn3\", linkageName: \"\\01?fn3@@YAXXZ\", scope: !1, file: !1, line: 30, type: !7, isLocal: false, isDefinition: true, scopeLine: 30, flags: DIFlagPrototyped, isOptimized: true, unit: !0, variables: !9)\n+!7 = !DISubroutineType(types: !8)\n+!8 = !{null}\n+!9 = !{}\n+!10 = !DILocalVariable(name: \"Tmp\", scope: !11, file: !1, line: 16, type: !23)\n+!11 = distinct !DISubprogram(name: \"takePayload\", linkageName: \"\\01?takePayload@D@@QEAA?AUC@@XZ\", scope: !12, file: !1, line: 15, type: !7, isLocal: false, isDefinition: true, scopeLine: 15, flags: DIFlagPrototyped, isOptimized: true, unit: !0, declaration: !13, variables: !9)\n+!12 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: \"D\", file: !1, line: 14, size: 8, elements: !9, identifier: \".?AUD@@\")\n+!13 = !DISubprogram(name: \"takePayload\", linkageName: \"\\01?takePayload@D@@QEAA?AUC@@XZ\", scope: !12, file: !1, line: 15, type: !7, isLocal: false, isDefinition: false, scopeLine: 15, flags: DIFlagPrototyped, isOptimized: true)\n+!14 = !DILocation(line: 16, column: 7, scope: !11, inlinedAt: !15)\n+!15 = distinct !DILocation(line: 24, column: 19, scope: !16, inlinedAt: !20)\n+!16 = distinct !DILexicalBlock(scope: !17, file: !1, line: 22, column: 25)\n+!17 = distinct !DISubprogram(name: \"F\", linkageName: \"\\01??0F@@QEAA@UD@@@Z\", scope: !18, file: !1, line: 22, type: !7, isLocal: false, isDefinition: true, scopeLine: 22, flags: DIFlagPrototyped, isOptimized: true, unit: !0, declaration: !19, variables: !9)\n+!18 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: \"F\", file: !1, line: 21, size: 128, elements: !9, identifier: \".?AUF@@\")\n+!19 = !DISubprogram(name: \"F\", scope: !18, file: !1, line: 22, type: !7, isLocal: false, isDefinition: false, scopeLine: 22, flags: DIFlagPrototyped, isOptimized: true)\n+!20 = distinct !DILocation(line: 29, column: 18, scope: !21, inlinedAt: !22)\n+!21 = distinct !DISubprogram(name: \"fn2\", linkageName: \"\\01?fn2@@YA?AUF@@XZ\", scope: !1, file: !1, line: 29, type: !7, isLocal: false, isDefinition: true, scopeLine: 29, flags: DIFlagPrototyped, isOptimized: true, unit: !0, variables: !9)\n+!22 = distinct !DILocation(line: 30, column: 14, scope: !6)\n+!23 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: \"C\", file: !1, line: 9, size: 32, elements: !9, identifier: \".?AUC@@\")"
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/Generic/sroa-larger.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/Generic/sroa-larger.ll\n\n  Unexpected Failures: 1\n"
    },
    "57feeed3076137da48c43010130eddbb8e81cb54___X86FrameLowering.cpp": {
        "prefix": "void X86FrameLowering::determineCalleeSaves(MachineFunction &MF,\n                                            BitVector &SavedRegs,\n                                            RegScavenger *RS) const {\n  TargetFrameLowering::determineCalleeSaves(MF, SavedRegs, RS);\n\n  // Spill the BasePtr if it's used.\n",
        "suffix": "",
        "start": 2105,
        "end": 2113,
        "buggy": "void X86FrameLowering::determineCalleeSaves(MachineFunction &MF,\n                                            BitVector &SavedRegs,\n                                            RegScavenger *RS) const {\n  TargetFrameLowering::determineCalleeSaves(MF, SavedRegs, RS);\n\n  // Spill the BasePtr if it's used.\n  if (TRI->hasBasePointer(MF))\n    SavedRegs.set(TRI->getBaseRegister());\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  if (TRI->hasBasePointer(MF))\n    SavedRegs.set(TRI->getBaseRegister());\n}\n",
        "src_path": "57feeed3076137da48c43010130eddbb8e81cb54___X86FrameLowering.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/57feeed3076137da48c43010130eddbb8e81cb54",
        "commit_msg": "[X86][x32] Save callee-save register used as base pointer for x32 ABI\n\nFor the x32 ABI, since the base pointer register (EBX) is a callee save register\nit should be saved before use.\n\nThis fixes https://bugs.llvm.org/show_bug.cgi?id=36011\n\nDifferential Revision: https://reviews.llvm.org/D42358\n\nPatch by Pratik Bhatu\n\nllvm-svn: 326593",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/x86-64-baseptr.ll",
                "patch": "@@ -39,6 +39,7 @@ define void @base() #0 {\n ; X32ABI:       # %bb.0: # %entry\n ; X32ABI-NEXT:    pushq %rbp\n ; X32ABI-NEXT:    movl %esp, %ebp\n+; X32ABI-NEXT:    pushq  %rbx\n ; X32ABI-NEXT:    andl $-32, %esp\n ; X32ABI-NEXT:    subl $32, %esp\n ; X32ABI-NEXT:    movl %esp, %ebx\n@@ -52,7 +53,8 @@ define void @base() #0 {\n ; X32ABI-NEXT:    movl %edx, %esp\n ; X32ABI-NEXT:    negl %eax\n ; X32ABI-NEXT:    movl $0, (%ecx,%eax)\n-; X32ABI-NEXT:    movl %ebp, %esp\n+; X32ABI-NEXT:    leal -8(%ebp), %esp\n+; X32ABI-NEXT:    popq %rbx\n ; X32ABI-NEXT:    popq %rbp\n ; X32ABI-NEXT:    retq\n entry:"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/x86-64-baseptr.ll (1 of 1)\nTesting Time: 0.22s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/x86-64-baseptr.ll\n\n  Unexpected Failures: 1\n"
    },
    "e4ec473b3ff94ecec6fe2c828770a124b139e1a5___MustExecute.cpp": {
        "prefix": "bool llvm::isGuaranteedToExecute(const Instruction &Inst,\n                                 const DominatorTree *DT, const Loop *CurLoop,\n                                 const LoopSafetyInfo *SafetyInfo) {\n  // We have to check to make sure that the instruction dominates all\n  // of the exit blocks.  If it doesn't, then there is a path out of the loop\n  // which does not execute this instruction, so we can't hoist it.\n\n  // If the instruction is in the header block for the loop (which is very\n  // common), it is always guaranteed to dominate the exit blocks.  Since this\n  // is a common case, and can save some work, check it now.\n  if (Inst.getParent() == CurLoop->getHeader())\n    // If there's a throw in the header block, we can't guarantee we'll reach\n",
        "suffix": "  // Somewhere in this loop there is an instruction which may throw and make us\n  // exit the loop.\n  if (SafetyInfo->MayThrow)\n    return false;\n\n  // Note: There are two styles of reasoning intermixed below for\n  // implementation efficiency reasons.  They are:\n  // 1) If we can prove that the instruction dominates all exit blocks, then we\n  // know the instruction must have executed on *some* iteration before we\n  // exit.  We do not prove *which* iteration the instruction must execute on.\n  // 2) If we can prove that the instruction dominates the latch and all exits\n  // which might be taken on the first iteration, we know the instruction must\n  // execute on the first iteration.  This second style allows a conditional\n  // exit before the instruction of interest which is provably not taken on the\n  // first iteration.  This is a quite common case for range check like\n  // patterns.  TODO: support loops with multiple latches.\n\n  const bool InstDominatesLatch =\n    CurLoop->getLoopLatch() != nullptr &&\n    DT->dominates(Inst.getParent(), CurLoop->getLoopLatch());\n\n  // Get the exit blocks for the current loop.\n  SmallVector<BasicBlock *, 8> ExitBlocks;\n  CurLoop->getExitBlocks(ExitBlocks);\n\n  // Verify that the block dominates each of the exit blocks of the loop.\n  for (BasicBlock *ExitBlock : ExitBlocks)\n    if (!DT->dominates(Inst.getParent(), ExitBlock))\n      if (!InstDominatesLatch ||\n          !CanProveNotTakenFirstIteration(ExitBlock, DT, CurLoop))\n        return false;\n\n  // As a degenerate case, if the loop is statically infinite then we haven't\n  // proven anything since there are no exit blocks.\n  if (ExitBlocks.empty())\n    return false;\n\n  // FIXME: In general, we have to prove that the loop isn't an infinite loop.\n  // See http::llvm.org/PR24078 .  (The \"ExitBlocks.empty()\" check above is\n  // just a special case of this.)\n  return true;\n}\n",
        "start": 100,
        "end": 156,
        "buggy": "bool llvm::isGuaranteedToExecute(const Instruction &Inst,\n                                 const DominatorTree *DT, const Loop *CurLoop,\n                                 const LoopSafetyInfo *SafetyInfo) {\n  // We have to check to make sure that the instruction dominates all\n  // of the exit blocks.  If it doesn't, then there is a path out of the loop\n  // which does not execute this instruction, so we can't hoist it.\n\n  // If the instruction is in the header block for the loop (which is very\n  // common), it is always guaranteed to dominate the exit blocks.  Since this\n  // is a common case, and can save some work, check it now.\n  if (Inst.getParent() == CurLoop->getHeader())\n    // If there's a throw in the header block, we can't guarantee we'll reach\n    // Inst.\n    return !SafetyInfo->HeaderMayThrow;\n\n  // Somewhere in this loop there is an instruction which may throw and make us\n  // exit the loop.\n  if (SafetyInfo->MayThrow)\n    return false;\n\n  // Note: There are two styles of reasoning intermixed below for\n  // implementation efficiency reasons.  They are:\n  // 1) If we can prove that the instruction dominates all exit blocks, then we\n  // know the instruction must have executed on *some* iteration before we\n  // exit.  We do not prove *which* iteration the instruction must execute on.\n  // 2) If we can prove that the instruction dominates the latch and all exits\n  // which might be taken on the first iteration, we know the instruction must\n  // execute on the first iteration.  This second style allows a conditional\n  // exit before the instruction of interest which is provably not taken on the\n  // first iteration.  This is a quite common case for range check like\n  // patterns.  TODO: support loops with multiple latches.\n\n  const bool InstDominatesLatch =\n    CurLoop->getLoopLatch() != nullptr &&\n    DT->dominates(Inst.getParent(), CurLoop->getLoopLatch());\n\n  // Get the exit blocks for the current loop.\n  SmallVector<BasicBlock *, 8> ExitBlocks;\n  CurLoop->getExitBlocks(ExitBlocks);\n\n  // Verify that the block dominates each of the exit blocks of the loop.\n  for (BasicBlock *ExitBlock : ExitBlocks)\n    if (!DT->dominates(Inst.getParent(), ExitBlock))\n      if (!InstDominatesLatch ||\n          !CanProveNotTakenFirstIteration(ExitBlock, DT, CurLoop))\n        return false;\n\n  // As a degenerate case, if the loop is statically infinite then we haven't\n  // proven anything since there are no exit blocks.\n  if (ExitBlocks.empty())\n    return false;\n\n  // FIXME: In general, we have to prove that the loop isn't an infinite loop.\n  // See http::llvm.org/PR24078 .  (The \"ExitBlocks.empty()\" check above is\n  // just a special case of this.)\n  return true;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    // Inst.\n    return !SafetyInfo->HeaderMayThrow;\n\n",
        "src_path": "e4ec473b3ff94ecec6fe2c828770a124b139e1a5___MustExecute.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/e4ec473b3ff94ecec6fe2c828770a124b139e1a5",
        "commit_msg": "[MustExecute/LICM] Special case first instruction in throwing header\n\nWe currently have a hard to solve analysis problem around the order of instructions within a potentially throwing block.  We can't cheaply determine whether a given instruction is before the first potential throw in the block.  While we're working on that in the background, special case the first instruction within the header.\n\nwhy this particular special case?  Well, headers are guaranteed to execute if the loop does, and it turns out we tend to produce this form in practice.\n\nIn a follow on patch, I tend to extend LICM with an alternate approach which works for any instruction in the header before the first throw, but this is the best I can come up with other users of the analysis (such as store promotion.)\n\nNote: I can't show the difference in the analysis result since we're ORing in the expensive instruction walk used by SCEV.  Using the full walk is not suitable for a general solution.\nllvm-svn: 331079",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/LICM/preheader-safe.ll",
                "patch": "@@ -3,6 +3,7 @@\n \n declare void @use_nothrow(i64 %a) nounwind\n declare void @use(i64 %a)\n+declare void @maythrow()\n \n define void @nothrow(i64 %x, i64 %y, i1* %cond) {\n ; CHECK-LABEL: nothrow\n@@ -21,16 +22,52 @@ loop2:\n   call void @use_nothrow(i64 %div)\n   br label %loop\n }\n+\n+; The udiv is guarantee to execute if the loop is\n+define void @throw_header_after(i64 %x, i64 %y, i1* %cond) {\n+; CHECK-LABEL: throw_header_after\n+; CHECK: %div = udiv i64 %x, %y\n+; CHECK-LABEL: loop\n+; CHECK: call void @use(i64 %div)\n+entry:\n+  br label %loop\n+\n+loop:                                         ; preds = %entry, %for.inc\n+  %div = udiv i64 %x, %y\n+  call void @use(i64 %div)\n+  br label %loop\n+}\n+define void @throw_header_after_rec(i64* %xp, i64* %yp, i1* %cond) {\n+; CHECK-LABEL: throw_header_after_rec\n+; CHECK: %x = load i64, i64* %xp\n+; CHECK: %y = load i64, i64* %yp\n+; CHECK: %div = udiv i64 %x, %y\n+; CHECK-LABEL: loop\n+; CHECK: call void @use(i64 %div)\n+entry:\n+  br label %loop\n+\n+loop:                                         ; preds = %entry, %for.inc\n+  %x = load i64, i64* %xp\n+  %y = load i64, i64* %yp\n+  %div = udiv i64 %x, %y\n+  call void @use(i64 %div) readonly\n+  br label %loop\n+}\n+\n+\n+\n ; Negative test\n-define void @throw_header(i64 %x, i64 %y, i1* %cond) {\n-; CHECK-LABEL: throw_header\n+define void @throw_header_before(i64 %x, i64 %y, i1* %cond) {\n+; CHECK-LABEL: throw_header_before\n ; CHECK-LABEL: loop\n ; CHECK: %div = udiv i64 %x, %y\n ; CHECK: call void @use(i64 %div)\n entry:\n   br label %loop\n \n loop:                                         ; preds = %entry, %for.inc\n+  call void @maythrow()\n   %div = udiv i64 %x, %y\n   call void @use(i64 %div)\n   br label %loop\n@@ -43,7 +80,7 @@ define void @nothrow_header(i64 %x, i64 %y, i1 %cond) {\n ; CHECK-LABEL: entry\n ; CHECK: %div = udiv i64 %x, %y\n ; CHECK-LABEL: loop\n-; CHECK: call void @use(i64 %div)\n+  ; CHECK: call void @use(i64 %div)\n entry:\n   br label %loop\n loop:                                         ; preds = %entry, %for.inc"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/LICM/preheader-safe.ll (1 of 1)\nTesting Time: 0.31s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LICM/preheader-safe.ll\n\n  Unexpected Failures: 1\n"
    },
    "55321d82bd329bb88799e5a853a256b4a70e4106___DwarfCompileUnit.cpp": {
        "prefix": "void DwarfCompileUnit::finishEntityDefinition(const DbgEntity *Entity) {\n  DbgEntity *AbsEntity = getExistingAbstractEntity(Entity->getEntity());\n\n  auto *Die = Entity->getDIE();\n  /// Label may be used to generate DW_AT_low_pc, so put it outside\n  /// if/else block.\n  const DbgLabel *Label = nullptr;\n  if (AbsEntity && AbsEntity->getDIE()) {\n    addDIEEntry(*Die, dwarf::DW_AT_abstract_origin, *AbsEntity->getDIE());\n    Label = dyn_cast<const DbgLabel>(Entity);\n  } else {\n    if (const DbgVariable *Var = dyn_cast<const DbgVariable>(Entity))\n      applyVariableAttributes(*Var, *Die);\n    else if ((Label = dyn_cast<const DbgLabel>(Entity)))\n      applyLabelAttributes(*Label, *Die);\n    else\n      llvm_unreachable(\"DbgEntity must be DbgVariable or DbgLabel.\");\n  }\n\n",
        "suffix": "",
        "start": 849,
        "end": 872,
        "buggy": "void DwarfCompileUnit::finishEntityDefinition(const DbgEntity *Entity) {\n  DbgEntity *AbsEntity = getExistingAbstractEntity(Entity->getEntity());\n\n  auto *Die = Entity->getDIE();\n  /// Label may be used to generate DW_AT_low_pc, so put it outside\n  /// if/else block.\n  const DbgLabel *Label = nullptr;\n  if (AbsEntity && AbsEntity->getDIE()) {\n    addDIEEntry(*Die, dwarf::DW_AT_abstract_origin, *AbsEntity->getDIE());\n    Label = dyn_cast<const DbgLabel>(Entity);\n  } else {\n    if (const DbgVariable *Var = dyn_cast<const DbgVariable>(Entity))\n      applyVariableAttributes(*Var, *Die);\n    else if ((Label = dyn_cast<const DbgLabel>(Entity)))\n      applyLabelAttributes(*Label, *Die);\n    else\n      llvm_unreachable(\"DbgEntity must be DbgVariable or DbgLabel.\");\n  }\n\n  if (Label) {\n    const MCSymbol *Sym = Label->getSymbol();\n    addLabelAddress(*Die, dwarf::DW_AT_low_pc, Sym);\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  if (Label) {\n    const MCSymbol *Sym = Label->getSymbol();\n    addLabelAddress(*Die, dwarf::DW_AT_low_pc, Sym);\n  }\n}\n",
        "src_path": "55321d82bd329bb88799e5a853a256b4a70e4106___DwarfCompileUnit.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/55321d82bd329bb88799e5a853a256b4a70e4106",
        "commit_msg": "[DebugInfo] Do not generate address info for removed debug labels.\n\nIn some senario, LLVM will remove llvm.dbg.labels in IR. For example,\nwhen the labels are in unreachable blocks, these labels will not\nbe generated in LLVM IR. In the case, these debug labels will have\naddress zero as their address. It is not legal address for debugger to\nset breakpoints or query sources. So, the patch inhibits the address info\n(DW_AT_low_pc) of removed labels.\n\nFix build failed in BuildBot, clang-stage1-cmake-RA-incremental, on macOS.\n\nDifferential Revision: https://reviews.llvm.org/D51908\n\nllvm-svn: 343062",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/X86/debug-label-unreached.ll",
                "patch": "@@ -0,0 +1,39 @@\n+; Test unreachable llvm.dbg.label\n+;\n+; RUN: llc -filetype=obj -split-dwarf-file debug.dwo -mtriple=x86_64-unknown-linux-gnu -o - %s | llvm-dwarfdump -v - | FileCheck %s\n+;\n+; CHECK: .debug_info.dwo contents:\n+; CHECK: DW_TAG_label\n+; CHECK-NEXT: DW_AT_name {{.*}}\"done\"\n+; CHECK-NOT: {{DW_TAG|NULL}}\n+; CHECK: DW_AT_low_pc\n+; CHECK: DW_TAG_label\n+; CHECK-NEXT: DW_AT_name {{.*}}\"removed\"\n+; CHECK-NOT: DW_AT_low_pc\n+source_filename = \"debug-label-unreached.c\"\n+\n+define dso_local i32 @foo(i32 %a, i32 %b) !dbg !8 {\n+entry:\n+  %sum = add nsw i32 %a, %b, !dbg !12\n+  call void @llvm.dbg.label(metadata !11), !dbg !12\n+  ret i32 %sum, !dbg !13\n+}\n+\n+declare void @llvm.dbg.label(metadata)\n+\n+!llvm.dbg.cu = !{!0}\n+!llvm.module.flags = !{!4}\n+\n+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, isOptimized: true, emissionKind: FullDebug, enums: !2)\n+!1 = !DIFile(filename: \"debug-label-unreached.c\", directory: \"./\")\n+!2 = !{}\n+!4 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!5 = !DISubroutineType(types: !6)\n+!6 = !{!7}\n+!7 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n+!8 = distinct !DISubprogram(name: \"foo\", scope: !1, file: !1, line: 8, type: !5, isLocal: false, isDefinition: true, scopeLine: 9, flags: DIFlagPrototyped, isOptimized: true, unit: !0, retainedNodes: !9)\n+!9 = !{!10, !11}\n+!10 = !DILabel(scope: !8, name: \"removed\", file: !1, line: 11)\n+!11 = !DILabel(scope: !8, name: \"done\", file: !1, line: 13)\n+!12 = !DILocation(line: 13, column: 1, scope: !8)\n+!13 = !DILocation(line: 14, column: 5, scope: !8)"
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/X86/debug-label-unreached.ll (1 of 1)\nTesting Time: 0.52s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/debug-label-unreached.ll\n\n  Unexpected Failures: 1\n"
    },
    "36e03ac6ee91366225f446db6437f184de258be6___InstCombineCompares.cpp": {
        "prefix": "static Value *evaluateGEPOffsetExpression(User *GEP, InstCombiner &IC,\n                                          const DataLayout &DL) {\n  gep_type_iterator GTI = gep_type_begin(GEP);\n\n  // Check to see if this gep only has a single variable index.  If so, and if\n  // any constant indices are a multiple of its scale, then we can compute this\n  // in terms of the scale of the variable index.  For example, if the GEP\n  // implies an offset of \"12 + i*4\", then we can codegen this as \"3 + i\",\n  // because the expression will cross zero at the same point.\n  unsigned i, e = GEP->getNumOperands();\n  int64_t Offset = 0;\n  for (i = 1; i != e; ++i, ++GTI) {\n    if (ConstantInt *CI = dyn_cast<ConstantInt>(GEP->getOperand(i))) {\n      // Compute the aggregate offset of constant indices.\n      if (CI->isZero()) continue;\n\n      // Handle a struct index, which adds its field offset to the pointer.\n      if (StructType *STy = GTI.getStructTypeOrNull()) {\n        Offset += DL.getStructLayout(STy)->getElementOffset(CI->getZExtValue());\n      } else {\n        uint64_t Size = DL.getTypeAllocSize(GTI.getIndexedType());\n        Offset += Size*CI->getSExtValue();\n      }\n    } else {\n      // Found our variable index.\n      break;\n    }\n  }\n\n  // If there are no variable indices, we must have a constant offset, just\n  // evaluate it the general way.\n  if (i == e) return nullptr;\n\n  Value *VariableIdx = GEP->getOperand(i);\n  // Determine the scale factor of the variable element.  For example, this is\n  // 4 if the variable index is into an array of i32.\n  uint64_t VariableScale = DL.getTypeAllocSize(GTI.getIndexedType());\n\n  // Verify that there are no other variable indices.  If so, emit the hard way.\n  for (++i, ++GTI; i != e; ++i, ++GTI) {\n    ConstantInt *CI = dyn_cast<ConstantInt>(GEP->getOperand(i));\n    if (!CI) return nullptr;\n\n    // Compute the aggregate offset of constant indices.\n    if (CI->isZero()) continue;\n\n    // Handle a struct index, which adds its field offset to the pointer.\n    if (StructType *STy = GTI.getStructTypeOrNull()) {\n      Offset += DL.getStructLayout(STy)->getElementOffset(CI->getZExtValue());\n    } else {\n      uint64_t Size = DL.getTypeAllocSize(GTI.getIndexedType());\n      Offset += Size*CI->getSExtValue();\n    }\n  }\n\n  // Okay, we know we have a single variable index, which must be a\n  // pointer/array/vector index.  If there is no offset, life is simple, return\n  // the index.\n  Type *IntPtrTy = DL.getIntPtrType(GEP->getOperand(0)->getType());\n  unsigned IntPtrWidth = IntPtrTy->getIntegerBitWidth();\n  if (Offset == 0) {\n    // Cast to intptrty in case a truncation occurs.  If an extension is needed,\n    // we don't need to bother extending: the extension won't affect where the\n    // computation crosses zero.\n    if (VariableIdx->getType()->getPrimitiveSizeInBits() > IntPtrWidth) {\n      VariableIdx = IC.Builder.CreateTrunc(VariableIdx, IntPtrTy);\n    }\n    return VariableIdx;\n  }\n\n  // Otherwise, there is an index.  The computation we will do will be modulo\n",
        "suffix": "  // To do this transformation, any constant index must be a multiple of the\n  // variable scale factor.  For example, we can evaluate \"12 + 4*i\" as \"3 + i\",\n  // but we can't evaluate \"10 + 3*i\" in terms of i.  Check that the offset is a\n  // multiple of the variable scale.\n  int64_t NewOffs = Offset / (int64_t)VariableScale;\n  if (Offset != NewOffs*(int64_t)VariableScale)\n    return nullptr;\n\n  // Okay, we can do this evaluation.  Start by converting the index to intptr.\n  if (VariableIdx->getType() != IntPtrTy)\n    VariableIdx = IC.Builder.CreateIntCast(VariableIdx, IntPtrTy,\n                                            true /*Signed*/);\n  Constant *OffsetVal = ConstantInt::get(IntPtrTy, NewOffs);\n  return IC.Builder.CreateAdd(VariableIdx, OffsetVal, \"offset\");\n}\n",
        "start": 454,
        "end": 545,
        "buggy": "static Value *evaluateGEPOffsetExpression(User *GEP, InstCombiner &IC,\n                                          const DataLayout &DL) {\n  gep_type_iterator GTI = gep_type_begin(GEP);\n\n  // Check to see if this gep only has a single variable index.  If so, and if\n  // any constant indices are a multiple of its scale, then we can compute this\n  // in terms of the scale of the variable index.  For example, if the GEP\n  // implies an offset of \"12 + i*4\", then we can codegen this as \"3 + i\",\n  // because the expression will cross zero at the same point.\n  unsigned i, e = GEP->getNumOperands();\n  int64_t Offset = 0;\n  for (i = 1; i != e; ++i, ++GTI) {\n    if (ConstantInt *CI = dyn_cast<ConstantInt>(GEP->getOperand(i))) {\n      // Compute the aggregate offset of constant indices.\n      if (CI->isZero()) continue;\n\n      // Handle a struct index, which adds its field offset to the pointer.\n      if (StructType *STy = GTI.getStructTypeOrNull()) {\n        Offset += DL.getStructLayout(STy)->getElementOffset(CI->getZExtValue());\n      } else {\n        uint64_t Size = DL.getTypeAllocSize(GTI.getIndexedType());\n        Offset += Size*CI->getSExtValue();\n      }\n    } else {\n      // Found our variable index.\n      break;\n    }\n  }\n\n  // If there are no variable indices, we must have a constant offset, just\n  // evaluate it the general way.\n  if (i == e) return nullptr;\n\n  Value *VariableIdx = GEP->getOperand(i);\n  // Determine the scale factor of the variable element.  For example, this is\n  // 4 if the variable index is into an array of i32.\n  uint64_t VariableScale = DL.getTypeAllocSize(GTI.getIndexedType());\n\n  // Verify that there are no other variable indices.  If so, emit the hard way.\n  for (++i, ++GTI; i != e; ++i, ++GTI) {\n    ConstantInt *CI = dyn_cast<ConstantInt>(GEP->getOperand(i));\n    if (!CI) return nullptr;\n\n    // Compute the aggregate offset of constant indices.\n    if (CI->isZero()) continue;\n\n    // Handle a struct index, which adds its field offset to the pointer.\n    if (StructType *STy = GTI.getStructTypeOrNull()) {\n      Offset += DL.getStructLayout(STy)->getElementOffset(CI->getZExtValue());\n    } else {\n      uint64_t Size = DL.getTypeAllocSize(GTI.getIndexedType());\n      Offset += Size*CI->getSExtValue();\n    }\n  }\n\n  // Okay, we know we have a single variable index, which must be a\n  // pointer/array/vector index.  If there is no offset, life is simple, return\n  // the index.\n  Type *IntPtrTy = DL.getIntPtrType(GEP->getOperand(0)->getType());\n  unsigned IntPtrWidth = IntPtrTy->getIntegerBitWidth();\n  if (Offset == 0) {\n    // Cast to intptrty in case a truncation occurs.  If an extension is needed,\n    // we don't need to bother extending: the extension won't affect where the\n    // computation crosses zero.\n    if (VariableIdx->getType()->getPrimitiveSizeInBits() > IntPtrWidth) {\n      VariableIdx = IC.Builder.CreateTrunc(VariableIdx, IntPtrTy);\n    }\n    return VariableIdx;\n  }\n\n  // Otherwise, there is an index.  The computation we will do will be modulo\n  // the pointer size, so get it.\n  uint64_t PtrSizeMask = ~0ULL >> (64-IntPtrWidth);\n\n  Offset &= PtrSizeMask;\n  VariableScale &= PtrSizeMask;\n\n  // To do this transformation, any constant index must be a multiple of the\n  // variable scale factor.  For example, we can evaluate \"12 + 4*i\" as \"3 + i\",\n  // but we can't evaluate \"10 + 3*i\" in terms of i.  Check that the offset is a\n  // multiple of the variable scale.\n  int64_t NewOffs = Offset / (int64_t)VariableScale;\n  if (Offset != NewOffs*(int64_t)VariableScale)\n    return nullptr;\n\n  // Okay, we can do this evaluation.  Start by converting the index to intptr.\n  if (VariableIdx->getType() != IntPtrTy)\n    VariableIdx = IC.Builder.CreateIntCast(VariableIdx, IntPtrTy,\n                                            true /*Signed*/);\n  Constant *OffsetVal = ConstantInt::get(IntPtrTy, NewOffs);\n  return IC.Builder.CreateAdd(VariableIdx, OffsetVal, \"offset\");\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  // the pointer size, so get it.\n  uint64_t PtrSizeMask = ~0ULL >> (64-IntPtrWidth);\n\n  Offset &= PtrSizeMask;\n  VariableScale &= PtrSizeMask;\n\n",
        "src_path": "36e03ac6ee91366225f446db6437f184de258be6___InstCombineCompares.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/36e03ac6ee91366225f446db6437f184de258be6",
        "commit_msg": "[InstCombine] Fix negative GEP offset evaluation for 32-bit pointers\n\nThis fixes https://bugs.llvm.org/show_bug.cgi?id=39908.\n\nThe evaluateGEPOffsetExpression() function simplifies GEP offsets for\nuse in comparisons against zero, basically by converting X*Scale+Offset==0\nto X+Offset/Scale==0 if Scale divides Offset. However, before this is done,\nOffset is masked down to the pointer size. This results in incorrect\nresults for negative Offsets, because we basically end up dividing the\n32-bit offset *zero* extended to 64-bit bits (rather than sign extended).\n\nFix this by explicitly sign extending the truncated value.\n\nDifferential Revision: https://reviews.llvm.org/D55449\n\nllvm-svn: 348987",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/pr39908.ll",
                "patch": "@@ -0,0 +1,49 @@\n+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py\n+; RUN: opt < %s -instcombine -S | FileCheck %s\n+\n+target datalayout = \"p:32:32\"\n+\n+%S = type { [2 x i32] }\n+\n+define i1 @test([0 x %S]* %p, i32 %n) {\n+; CHECK-LABEL: @test(\n+; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[N:%.*]], 1\n+; CHECK-NEXT:    ret i1 [[CMP]]\n+;\n+  %start.cast = bitcast [0 x %S]* %p to %S*\n+  %end = getelementptr inbounds [0 x %S], [0 x %S]* %p, i32 0, i32 %n, i32 0, i32 0\n+  %end.cast = bitcast i32* %end to %S*\n+  %last = getelementptr inbounds %S, %S* %end.cast, i32 -1\n+  %cmp = icmp eq %S* %last, %start.cast\n+  ret i1 %cmp\n+}\n+\n+; Same test using 64-bit indices.\n+define i1 @test64([0 x %S]* %p, i64 %n) {\n+; CHECK-LABEL: @test64(\n+; CHECK-NEXT:    [[TMP1:%.*]] = trunc i64 [[N:%.*]] to i32\n+; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP1]], 1\n+; CHECK-NEXT:    ret i1 [[CMP]]\n+;\n+  %start.cast = bitcast [0 x %S]* %p to %S*\n+  %end = getelementptr inbounds [0 x %S], [0 x %S]* %p, i64 0, i64 %n, i32 0, i64 0\n+  %end.cast = bitcast i32* %end to %S*\n+  %last = getelementptr inbounds %S, %S* %end.cast, i64 -1\n+  %cmp = icmp eq %S* %last, %start.cast\n+  ret i1 %cmp\n+}\n+\n+; Here the offset overflows and is treated modulo 2^32. This is UB.\n+define i1 @test64_overflow([0 x %S]* %p, i64 %n) {\n+; CHECK-LABEL: @test64_overflow(\n+; CHECK-NEXT:    [[TMP1:%.*]] = trunc i64 [[N:%.*]] to i32\n+; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP1]], 1\n+; CHECK-NEXT:    ret i1 [[CMP]]\n+;\n+  %start.cast = bitcast [0 x %S]* %p to %S*\n+  %end = getelementptr inbounds [0 x %S], [0 x %S]* %p, i64 0, i64 %n, i32 0, i64 8589934592\n+  %end.cast = bitcast i32* %end to %S*\n+  %last = getelementptr inbounds %S, %S* %end.cast, i64 -1\n+  %cmp = icmp eq %S* %last, %start.cast\n+  ret i1 %cmp\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/pr39908.ll (1 of 1)\nTesting Time: 0.22s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/pr39908.ll\n\n  Unexpected Failures: 1\n"
    },
    "ef7b5949e5c35fdeefb69b8f9a8eef9cfa012ed0___X86ISelLowering.cpp": {
        "prefix": "static SDValue LowerFunnelShift(SDValue Op, const X86Subtarget &Subtarget,\n                                SelectionDAG &DAG) {\n  MVT VT = Op.getSimpleValueType();\n  assert((Op.getOpcode() == ISD::FSHL || Op.getOpcode() == ISD::FSHR) &&\n         \"Unexpected funnel shift opcode!\");\n  assert((VT == MVT::i16 || VT == MVT::i32 || VT == MVT::i64) &&\n         \"Unexpected funnel shift type!\");\n\n  SDLoc DL(Op);\n  SDValue Op0 = Op.getOperand(0);\n  SDValue Op1 = Op.getOperand(1);\n  SDValue Amt = Op.getOperand(2);\n\n",
        "suffix": "\n  bool IsFSHR = Op.getOpcode() == ISD::FSHR;\n  if (IsFSHR)\n    std::swap(Op0, Op1);\n\n  // i16 needs to modulo the shift amount, but i32/i64 have implicit modulo.\n  if (VT == MVT::i16)\n    Amt = DAG.getNode(ISD::AND, DL, Amt.getValueType(), Amt,\n                      DAG.getConstant(15, DL, Amt.getValueType()));\n\n  unsigned SHDOp = (IsFSHR ? X86ISD::SHRD : X86ISD::SHLD);\n  return DAG.getNode(SHDOp, DL, VT, Op0, Op1, Amt);\n}\n",
        "start": 17037,
        "end": 17066,
        "buggy": "static SDValue LowerFunnelShift(SDValue Op, const X86Subtarget &Subtarget,\n                                SelectionDAG &DAG) {\n  MVT VT = Op.getSimpleValueType();\n  assert((Op.getOpcode() == ISD::FSHL || Op.getOpcode() == ISD::FSHR) &&\n         \"Unexpected funnel shift opcode!\");\n  assert((VT == MVT::i16 || VT == MVT::i32 || VT == MVT::i64) &&\n         \"Unexpected funnel shift type!\");\n\n  SDLoc DL(Op);\n  SDValue Op0 = Op.getOperand(0);\n  SDValue Op1 = Op.getOperand(1);\n  SDValue Amt = Op.getOperand(2);\n\n  // Expand slow SHLD/SHRD cases.\n  // TODO - can we be more selective here: OptSize/RMW etc.?\n  if (Subtarget.isSHLDSlow())\n    return SDValue();\n\n  bool IsFSHR = Op.getOpcode() == ISD::FSHR;\n  if (IsFSHR)\n    std::swap(Op0, Op1);\n\n  // i16 needs to modulo the shift amount, but i32/i64 have implicit modulo.\n  if (VT == MVT::i16)\n    Amt = DAG.getNode(ISD::AND, DL, Amt.getValueType(), Amt,\n                      DAG.getConstant(15, DL, Amt.getValueType()));\n\n  unsigned SHDOp = (IsFSHR ? X86ISD::SHRD : X86ISD::SHLD);\n  return DAG.getNode(SHDOp, DL, VT, Op0, Op1, Amt);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  // Expand slow SHLD/SHRD cases.\n  // TODO - can we be more selective here: OptSize/RMW etc.?\n  if (Subtarget.isSHLDSlow())\n    return SDValue();\n",
        "src_path": "ef7b5949e5c35fdeefb69b8f9a8eef9cfa012ed0___X86ISelLowering.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/ef7b5949e5c35fdeefb69b8f9a8eef9cfa012ed0",
        "commit_msg": "[X86] Lower to SHLD/SHRD on slow machines for optsize\n\nUse consistent rules for when to lower to SHLD/SHRD for slow machines - fixes a weird issue where funnel shift gets expanded but then X86ISelLowering's combineOr sees the optsize and combines to SHLD/SHRD, but now with the modulo amount guard......\n\nllvm-svn: 349285",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/fshl.ll",
                "patch": "@@ -179,46 +179,21 @@ define i32 @var_shift_i32(i32 %x, i32 %y, i32 %z) nounwind {\n }\n \n define i32 @var_shift_i32_optsize(i32 %x, i32 %y, i32 %z) nounwind optsize {\n-; X86-FAST-LABEL: var_shift_i32_optsize:\n-; X86-FAST:       # %bb.0:\n-; X86-FAST-NEXT:    movb {{[0-9]+}}(%esp), %cl\n-; X86-FAST-NEXT:    movl {{[0-9]+}}(%esp), %edx\n-; X86-FAST-NEXT:    movl {{[0-9]+}}(%esp), %eax\n-; X86-FAST-NEXT:    shldl %cl, %edx, %eax\n-; X86-FAST-NEXT:    retl\n-;\n-; X86-SLOW-LABEL: var_shift_i32_optsize:\n-; X86-SLOW:       # %bb.0:\n-; X86-SLOW-NEXT:    pushl %esi\n-; X86-SLOW-NEXT:    movb {{[0-9]+}}(%esp), %cl\n-; X86-SLOW-NEXT:    movl {{[0-9]+}}(%esp), %esi\n-; X86-SLOW-NEXT:    movl {{[0-9]+}}(%esp), %eax\n-; X86-SLOW-NEXT:    movl %eax, %edx\n-; X86-SLOW-NEXT:    shldl %cl, %esi, %edx\n-; X86-SLOW-NEXT:    andb $31, %cl\n-; X86-SLOW-NEXT:    je .LBB3_2\n-; X86-SLOW-NEXT:  # %bb.1:\n-; X86-SLOW-NEXT:    movl %edx, %eax\n-; X86-SLOW-NEXT:  .LBB3_2:\n-; X86-SLOW-NEXT:    popl %esi\n-; X86-SLOW-NEXT:    retl\n-;\n-; X64-FAST-LABEL: var_shift_i32_optsize:\n-; X64-FAST:       # %bb.0:\n-; X64-FAST-NEXT:    movl %edx, %ecx\n-; X64-FAST-NEXT:    movl %edi, %eax\n-; X64-FAST-NEXT:    # kill: def $cl killed $cl killed $ecx\n-; X64-FAST-NEXT:    shldl %cl, %esi, %eax\n-; X64-FAST-NEXT:    retq\n+; X86-LABEL: var_shift_i32_optsize:\n+; X86:       # %bb.0:\n+; X86-NEXT:    movb {{[0-9]+}}(%esp), %cl\n+; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx\n+; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax\n+; X86-NEXT:    shldl %cl, %edx, %eax\n+; X86-NEXT:    retl\n ;\n-; X64-SLOW-LABEL: var_shift_i32_optsize:\n-; X64-SLOW:       # %bb.0:\n-; X64-SLOW-NEXT:    movl %edx, %ecx\n-; X64-SLOW-NEXT:    movl %edi, %eax\n-; X64-SLOW-NEXT:    shldl %cl, %esi, %eax\n-; X64-SLOW-NEXT:    andb $31, %cl\n-; X64-SLOW-NEXT:    cmovel %edi, %eax\n-; X64-SLOW-NEXT:    retq\n+; X64-LABEL: var_shift_i32_optsize:\n+; X64:       # %bb.0:\n+; X64-NEXT:    movl %edx, %ecx\n+; X64-NEXT:    movl %edi, %eax\n+; X64-NEXT:    # kill: def $cl killed $cl killed $ecx\n+; X64-NEXT:    shldl %cl, %esi, %eax\n+; X64-NEXT:    retq\n   %tmp = tail call i32 @llvm.fshl.i32(i32 %x, i32 %y, i32 %z)\n   ret i32 %tmp\n }"
            },
            {
                "fn": "llvm/test/CodeGen/X86/fshr.ll",
                "patch": "@@ -178,46 +178,21 @@ define i32 @var_shift_i32(i32 %x, i32 %y, i32 %z) nounwind {\n }\n \n define i32 @var_shift_i32_optsize(i32 %x, i32 %y, i32 %z) nounwind optsize {\n-; X86-FAST-LABEL: var_shift_i32_optsize:\n-; X86-FAST:       # %bb.0:\n-; X86-FAST-NEXT:    movb {{[0-9]+}}(%esp), %cl\n-; X86-FAST-NEXT:    movl {{[0-9]+}}(%esp), %edx\n-; X86-FAST-NEXT:    movl {{[0-9]+}}(%esp), %eax\n-; X86-FAST-NEXT:    shrdl %cl, %edx, %eax\n-; X86-FAST-NEXT:    retl\n-;\n-; X86-SLOW-LABEL: var_shift_i32_optsize:\n-; X86-SLOW:       # %bb.0:\n-; X86-SLOW-NEXT:    pushl %esi\n-; X86-SLOW-NEXT:    movb {{[0-9]+}}(%esp), %cl\n-; X86-SLOW-NEXT:    movl {{[0-9]+}}(%esp), %esi\n-; X86-SLOW-NEXT:    movl {{[0-9]+}}(%esp), %eax\n-; X86-SLOW-NEXT:    movl %eax, %edx\n-; X86-SLOW-NEXT:    shrdl %cl, %esi, %edx\n-; X86-SLOW-NEXT:    andb $31, %cl\n-; X86-SLOW-NEXT:    je .LBB3_2\n-; X86-SLOW-NEXT:  # %bb.1:\n-; X86-SLOW-NEXT:    movl %edx, %eax\n-; X86-SLOW-NEXT:  .LBB3_2:\n-; X86-SLOW-NEXT:    popl %esi\n-; X86-SLOW-NEXT:    retl\n-;\n-; X64-FAST-LABEL: var_shift_i32_optsize:\n-; X64-FAST:       # %bb.0:\n-; X64-FAST-NEXT:    movl %edx, %ecx\n-; X64-FAST-NEXT:    movl %esi, %eax\n-; X64-FAST-NEXT:    # kill: def $cl killed $cl killed $ecx\n-; X64-FAST-NEXT:    shrdl %cl, %edi, %eax\n-; X64-FAST-NEXT:    retq\n+; X86-LABEL: var_shift_i32_optsize:\n+; X86:       # %bb.0:\n+; X86-NEXT:    movb {{[0-9]+}}(%esp), %cl\n+; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx\n+; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax\n+; X86-NEXT:    shrdl %cl, %edx, %eax\n+; X86-NEXT:    retl\n ;\n-; X64-SLOW-LABEL: var_shift_i32_optsize:\n-; X64-SLOW:       # %bb.0:\n-; X64-SLOW-NEXT:    movl %edx, %ecx\n-; X64-SLOW-NEXT:    movl %esi, %eax\n-; X64-SLOW-NEXT:    shrdl %cl, %edi, %eax\n-; X64-SLOW-NEXT:    andb $31, %cl\n-; X64-SLOW-NEXT:    cmovel %esi, %eax\n-; X64-SLOW-NEXT:    retq\n+; X64-LABEL: var_shift_i32_optsize:\n+; X64:       # %bb.0:\n+; X64-NEXT:    movl %edx, %ecx\n+; X64-NEXT:    movl %esi, %eax\n+; X64-NEXT:    # kill: def $cl killed $cl killed $ecx\n+; X64-NEXT:    shrdl %cl, %edi, %eax\n+; X64-NEXT:    retq\n   %tmp = tail call i32 @llvm.fshr.i32(i32 %x, i32 %y, i32 %z)\n   ret i32 %tmp\n }"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/fshl.ll (1 of 1)\nTesting Time: 0.32s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/fshl.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/fshr.ll (1 of 1)\nTesting Time: 0.32s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/fshr.ll\n\n  Unexpected Failures: 1\n"
    },
    "2153c4b8281c1e5f25887ef9183947198c50a9d2___AtomicExpandPass.cpp": {
        "prefix": "bool AtomicExpand::expandAtomicLoadToCmpXchg(LoadInst *LI) {\n  IRBuilder<> Builder(LI);\n  AtomicOrdering Order = LI->getOrdering();\n",
        "suffix": "  Type *Ty = cast<PointerType>(Addr->getType())->getElementType();\n  Constant *DummyVal = Constant::getNullValue(Ty);\n\n  Value *Pair = Builder.CreateAtomicCmpXchg(\n      Addr, DummyVal, DummyVal, Order,\n      AtomicCmpXchgInst::getStrongestFailureOrdering(Order));\n  Value *Loaded = Builder.CreateExtractValue(Pair, 0, \"loaded\");\n\n  LI->replaceAllUsesWith(Loaded);\n  LI->eraseFromParent();\n\n  return true;\n}\n",
        "start": 430,
        "end": 446,
        "buggy": "bool AtomicExpand::expandAtomicLoadToCmpXchg(LoadInst *LI) {\n  IRBuilder<> Builder(LI);\n  AtomicOrdering Order = LI->getOrdering();\n  Value *Addr = LI->getPointerOperand();\n  Type *Ty = cast<PointerType>(Addr->getType())->getElementType();\n  Constant *DummyVal = Constant::getNullValue(Ty);\n\n  Value *Pair = Builder.CreateAtomicCmpXchg(\n      Addr, DummyVal, DummyVal, Order,\n      AtomicCmpXchgInst::getStrongestFailureOrdering(Order));\n  Value *Loaded = Builder.CreateExtractValue(Pair, 0, \"loaded\");\n\n  LI->replaceAllUsesWith(Loaded);\n  LI->eraseFromParent();\n\n  return true;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  Value *Addr = LI->getPointerOperand();\n",
        "src_path": "2153c4b8281c1e5f25887ef9183947198c50a9d2___AtomicExpandPass.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/2153c4b8281c1e5f25887ef9183947198c50a9d2",
        "commit_msg": "[AtomicExpand] Fix a crash bug when lowering unordered loads to cmpxchg\n\nAdd tests for wider atomic loads and stores.  In the process, fix a crasher where we appearently handled unorder stores, but not loads, when lowering to cmpxchg idioms.\n\nllvm-svn: 356482",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/atomic-unordered.ll",
                "patch": "@@ -272,6 +272,192 @@ define void @widen_broadcast_unaligned(i32* %p0, i32 %v) {\n   ret void\n }\n \n+define i128 @load_i128(i128* %ptr) {\n+; CHECK-O0-LABEL: load_i128:\n+; CHECK-O0:       # %bb.0:\n+; CHECK-O0-NEXT:    pushq %rbx\n+; CHECK-O0-NEXT:    .cfi_def_cfa_offset 16\n+; CHECK-O0-NEXT:    .cfi_offset %rbx, -16\n+; CHECK-O0-NEXT:    xorl %eax, %eax\n+; CHECK-O0-NEXT:    movl %eax, %ecx\n+; CHECK-O0-NEXT:    movq %rcx, %rax\n+; CHECK-O0-NEXT:    movq %rcx, %rdx\n+; CHECK-O0-NEXT:    movq %rcx, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill\n+; CHECK-O0-NEXT:    movq {{[-0-9]+}}(%r{{[sb]}}p), %rbx # 8-byte Reload\n+; CHECK-O0-NEXT:    lock cmpxchg16b (%rdi)\n+; CHECK-O0-NEXT:    popq %rbx\n+; CHECK-O0-NEXT:    .cfi_def_cfa_offset 8\n+; CHECK-O0-NEXT:    retq\n+;\n+; CHECK-O3-LABEL: load_i128:\n+; CHECK-O3:       # %bb.0:\n+; CHECK-O3-NEXT:    pushq %rbx\n+; CHECK-O3-NEXT:    .cfi_def_cfa_offset 16\n+; CHECK-O3-NEXT:    .cfi_offset %rbx, -16\n+; CHECK-O3-NEXT:    xorl %eax, %eax\n+; CHECK-O3-NEXT:    xorl %edx, %edx\n+; CHECK-O3-NEXT:    xorl %ecx, %ecx\n+; CHECK-O3-NEXT:    xorl %ebx, %ebx\n+; CHECK-O3-NEXT:    lock cmpxchg16b (%rdi)\n+; CHECK-O3-NEXT:    popq %rbx\n+; CHECK-O3-NEXT:    .cfi_def_cfa_offset 8\n+; CHECK-O3-NEXT:    retq\n+  %v = load atomic i128, i128* %ptr unordered, align 16\n+  ret i128 %v\n+}\n+\n+define void @store_i128(i128* %ptr, i128 %v) {\n+; CHECK-O0-LABEL: store_i128:\n+; CHECK-O0:       # %bb.0:\n+; CHECK-O0-NEXT:    pushq %rbx\n+; CHECK-O0-NEXT:    .cfi_def_cfa_offset 16\n+; CHECK-O0-NEXT:    .cfi_offset %rbx, -16\n+; CHECK-O0-NEXT:    movq (%rdi), %rax\n+; CHECK-O0-NEXT:    movq 8(%rdi), %rcx\n+; CHECK-O0-NEXT:    movq %rdx, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill\n+; CHECK-O0-NEXT:    movq %rsi, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill\n+; CHECK-O0-NEXT:    movq %rdi, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill\n+; CHECK-O0-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill\n+; CHECK-O0-NEXT:    movq %rcx, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill\n+; CHECK-O0-NEXT:    jmp .LBB16_1\n+; CHECK-O0-NEXT:  .LBB16_1: # %atomicrmw.start\n+; CHECK-O0-NEXT:    # =>This Inner Loop Header: Depth=1\n+; CHECK-O0-NEXT:    movq {{[-0-9]+}}(%r{{[sb]}}p), %rax # 8-byte Reload\n+; CHECK-O0-NEXT:    movq {{[-0-9]+}}(%r{{[sb]}}p), %rcx # 8-byte Reload\n+; CHECK-O0-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill\n+; CHECK-O0-NEXT:    movq %rcx, %rax\n+; CHECK-O0-NEXT:    movq {{[-0-9]+}}(%r{{[sb]}}p), %rdx # 8-byte Reload\n+; CHECK-O0-NEXT:    movq {{[-0-9]+}}(%r{{[sb]}}p), %rcx # 8-byte Reload\n+; CHECK-O0-NEXT:    movq {{[-0-9]+}}(%r{{[sb]}}p), %rbx # 8-byte Reload\n+; CHECK-O0-NEXT:    movq {{[-0-9]+}}(%r{{[sb]}}p), %rsi # 8-byte Reload\n+; CHECK-O0-NEXT:    lock cmpxchg16b (%rsi)\n+; CHECK-O0-NEXT:    movq %rdx, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill\n+; CHECK-O0-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill\n+; CHECK-O0-NEXT:    jne .LBB16_1\n+; CHECK-O0-NEXT:    jmp .LBB16_2\n+; CHECK-O0-NEXT:  .LBB16_2: # %atomicrmw.end\n+; CHECK-O0-NEXT:    popq %rbx\n+; CHECK-O0-NEXT:    .cfi_def_cfa_offset 8\n+; CHECK-O0-NEXT:    retq\n+;\n+; CHECK-O3-LABEL: store_i128:\n+; CHECK-O3:       # %bb.0:\n+; CHECK-O3-NEXT:    pushq %rbx\n+; CHECK-O3-NEXT:    .cfi_def_cfa_offset 16\n+; CHECK-O3-NEXT:    .cfi_offset %rbx, -16\n+; CHECK-O3-NEXT:    movq %rdx, %rcx\n+; CHECK-O3-NEXT:    movq %rsi, %rbx\n+; CHECK-O3-NEXT:    movq (%rdi), %rax\n+; CHECK-O3-NEXT:    movq 8(%rdi), %rdx\n+; CHECK-O3-NEXT:    .p2align 4, 0x90\n+; CHECK-O3-NEXT:  .LBB16_1: # %atomicrmw.start\n+; CHECK-O3-NEXT:    # =>This Inner Loop Header: Depth=1\n+; CHECK-O3-NEXT:    lock cmpxchg16b (%rdi)\n+; CHECK-O3-NEXT:    jne .LBB16_1\n+; CHECK-O3-NEXT:  # %bb.2: # %atomicrmw.end\n+; CHECK-O3-NEXT:    popq %rbx\n+; CHECK-O3-NEXT:    .cfi_def_cfa_offset 8\n+; CHECK-O3-NEXT:    retq\n+  store atomic i128 %v, i128* %ptr unordered, align 16\n+  ret void\n+}\n+\n+define i256 @load_i256(i256* %ptr) {\n+; CHECK-O0-LABEL: load_i256:\n+; CHECK-O0:       # %bb.0:\n+; CHECK-O0-NEXT:    subq $56, %rsp\n+; CHECK-O0-NEXT:    .cfi_def_cfa_offset 64\n+; CHECK-O0-NEXT:    movq %rdi, %rax\n+; CHECK-O0-NEXT:    movl $32, %ecx\n+; CHECK-O0-NEXT:    leaq {{[0-9]+}}(%rsp), %rdx\n+; CHECK-O0-NEXT:    xorl %r8d, %r8d\n+; CHECK-O0-NEXT:    movq %rdi, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill\n+; CHECK-O0-NEXT:    movq %rcx, %rdi\n+; CHECK-O0-NEXT:    movl %r8d, %ecx\n+; CHECK-O0-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill\n+; CHECK-O0-NEXT:    callq __atomic_load\n+; CHECK-O0-NEXT:    movq {{[0-9]+}}(%rsp), %rax\n+; CHECK-O0-NEXT:    movq {{[0-9]+}}(%rsp), %rdx\n+; CHECK-O0-NEXT:    movq {{[0-9]+}}(%rsp), %rsi\n+; CHECK-O0-NEXT:    movq {{[0-9]+}}(%rsp), %rdi\n+; CHECK-O0-NEXT:    movq {{[-0-9]+}}(%r{{[sb]}}p), %r9 # 8-byte Reload\n+; CHECK-O0-NEXT:    movq %rdi, 24(%r9)\n+; CHECK-O0-NEXT:    movq %rsi, 16(%r9)\n+; CHECK-O0-NEXT:    movq %rdx, 8(%r9)\n+; CHECK-O0-NEXT:    movq %rax, (%r9)\n+; CHECK-O0-NEXT:    movq {{[-0-9]+}}(%r{{[sb]}}p), %rax # 8-byte Reload\n+; CHECK-O0-NEXT:    addq $56, %rsp\n+; CHECK-O0-NEXT:    .cfi_def_cfa_offset 8\n+; CHECK-O0-NEXT:    retq\n+;\n+; CHECK-O3-LABEL: load_i256:\n+; CHECK-O3:       # %bb.0:\n+; CHECK-O3-NEXT:    pushq %rbx\n+; CHECK-O3-NEXT:    .cfi_def_cfa_offset 16\n+; CHECK-O3-NEXT:    subq $32, %rsp\n+; CHECK-O3-NEXT:    .cfi_def_cfa_offset 48\n+; CHECK-O3-NEXT:    .cfi_offset %rbx, -16\n+; CHECK-O3-NEXT:    movq %rdi, %rbx\n+; CHECK-O3-NEXT:    movq %rsp, %rdx\n+; CHECK-O3-NEXT:    movl $32, %edi\n+; CHECK-O3-NEXT:    xorl %ecx, %ecx\n+; CHECK-O3-NEXT:    callq __atomic_load\n+; CHECK-O3-NEXT:    vmovups (%rsp), %ymm0\n+; CHECK-O3-NEXT:    vmovups %ymm0, (%rbx)\n+; CHECK-O3-NEXT:    movq %rbx, %rax\n+; CHECK-O3-NEXT:    addq $32, %rsp\n+; CHECK-O3-NEXT:    .cfi_def_cfa_offset 16\n+; CHECK-O3-NEXT:    popq %rbx\n+; CHECK-O3-NEXT:    .cfi_def_cfa_offset 8\n+; CHECK-O3-NEXT:    vzeroupper\n+; CHECK-O3-NEXT:    retq\n+  %v = load atomic i256, i256* %ptr unordered, align 16\n+  ret i256 %v\n+}\n+\n+define void @store_i256(i256* %ptr, i256 %v) {\n+; CHECK-O0-LABEL: store_i256:\n+; CHECK-O0:       # %bb.0:\n+; CHECK-O0-NEXT:    subq $40, %rsp\n+; CHECK-O0-NEXT:    .cfi_def_cfa_offset 48\n+; CHECK-O0-NEXT:    xorl %eax, %eax\n+; CHECK-O0-NEXT:    leaq {{[0-9]+}}(%rsp), %r9\n+; CHECK-O0-NEXT:    movq %rsi, {{[0-9]+}}(%rsp)\n+; CHECK-O0-NEXT:    movq %rdx, {{[0-9]+}}(%rsp)\n+; CHECK-O0-NEXT:    movq %rcx, {{[0-9]+}}(%rsp)\n+; CHECK-O0-NEXT:    movq %r8, {{[0-9]+}}(%rsp)\n+; CHECK-O0-NEXT:    movl $32, %ecx\n+; CHECK-O0-NEXT:    movq %rdi, (%rsp) # 8-byte Spill\n+; CHECK-O0-NEXT:    movq %rcx, %rdi\n+; CHECK-O0-NEXT:    movq (%rsp), %rsi # 8-byte Reload\n+; CHECK-O0-NEXT:    movq %r9, %rdx\n+; CHECK-O0-NEXT:    movl %eax, %ecx\n+; CHECK-O0-NEXT:    callq __atomic_store\n+; CHECK-O0-NEXT:    addq $40, %rsp\n+; CHECK-O0-NEXT:    .cfi_def_cfa_offset 8\n+; CHECK-O0-NEXT:    retq\n+;\n+; CHECK-O3-LABEL: store_i256:\n+; CHECK-O3:       # %bb.0:\n+; CHECK-O3-NEXT:    subq $40, %rsp\n+; CHECK-O3-NEXT:    .cfi_def_cfa_offset 48\n+; CHECK-O3-NEXT:    movq %rdi, %rax\n+; CHECK-O3-NEXT:    movq %r8, {{[0-9]+}}(%rsp)\n+; CHECK-O3-NEXT:    movq %rcx, {{[0-9]+}}(%rsp)\n+; CHECK-O3-NEXT:    movq %rdx, {{[0-9]+}}(%rsp)\n+; CHECK-O3-NEXT:    movq %rsi, {{[0-9]+}}(%rsp)\n+; CHECK-O3-NEXT:    leaq {{[0-9]+}}(%rsp), %rdx\n+; CHECK-O3-NEXT:    movl $32, %edi\n+; CHECK-O3-NEXT:    movq %rax, %rsi\n+; CHECK-O3-NEXT:    xorl %ecx, %ecx\n+; CHECK-O3-NEXT:    callq __atomic_store\n+; CHECK-O3-NEXT:    addq $40, %rsp\n+; CHECK-O3-NEXT:    .cfi_def_cfa_offset 8\n+; CHECK-O3-NEXT:    retq\n+  store atomic i256 %v, i256* %ptr unordered, align 16\n+  ret void\n+}\n+\n ; Legal if wider type is also atomic (TODO)\n define void @vec_store(i32* %p0, <2 x i32> %vec) {\n ; CHECK-O0-LABEL: vec_store:\n@@ -621,12 +807,12 @@ define i64 @load_fold_sdiv2(i64* %p, i64 %v2) {\n ; CHECK-O3-NEXT:    movq %rax, %rcx\n ; CHECK-O3-NEXT:    orq %rsi, %rcx\n ; CHECK-O3-NEXT:    shrq $32, %rcx\n-; CHECK-O3-NEXT:    je .LBB31_1\n+; CHECK-O3-NEXT:    je .LBB35_1\n ; CHECK-O3-NEXT:  # %bb.2:\n ; CHECK-O3-NEXT:    cqto\n ; CHECK-O3-NEXT:    idivq %rsi\n ; CHECK-O3-NEXT:    retq\n-; CHECK-O3-NEXT:  .LBB31_1:\n+; CHECK-O3-NEXT:  .LBB35_1:\n ; CHECK-O3-NEXT:    # kill: def $eax killed $eax killed $rax\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divl %esi\n@@ -652,12 +838,12 @@ define i64 @load_fold_sdiv3(i64* %p1, i64* %p2) {\n ; CHECK-O3-NEXT:    movq %rax, %rdx\n ; CHECK-O3-NEXT:    orq %rcx, %rdx\n ; CHECK-O3-NEXT:    shrq $32, %rdx\n-; CHECK-O3-NEXT:    je .LBB32_1\n+; CHECK-O3-NEXT:    je .LBB36_1\n ; CHECK-O3-NEXT:  # %bb.2:\n ; CHECK-O3-NEXT:    cqto\n ; CHECK-O3-NEXT:    idivq %rcx\n ; CHECK-O3-NEXT:    retq\n-; CHECK-O3-NEXT:  .LBB32_1:\n+; CHECK-O3-NEXT:  .LBB36_1:\n ; CHECK-O3-NEXT:    # kill: def $eax killed $eax killed $rax\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divl %ecx\n@@ -708,12 +894,12 @@ define i64 @load_fold_udiv2(i64* %p, i64 %v2) {\n ; CHECK-O3-NEXT:    movq %rax, %rcx\n ; CHECK-O3-NEXT:    orq %rsi, %rcx\n ; CHECK-O3-NEXT:    shrq $32, %rcx\n-; CHECK-O3-NEXT:    je .LBB34_1\n+; CHECK-O3-NEXT:    je .LBB38_1\n ; CHECK-O3-NEXT:  # %bb.2:\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divq %rsi\n ; CHECK-O3-NEXT:    retq\n-; CHECK-O3-NEXT:  .LBB34_1:\n+; CHECK-O3-NEXT:  .LBB38_1:\n ; CHECK-O3-NEXT:    # kill: def $eax killed $eax killed $rax\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divl %esi\n@@ -740,12 +926,12 @@ define i64 @load_fold_udiv3(i64* %p1, i64* %p2) {\n ; CHECK-O3-NEXT:    movq %rax, %rdx\n ; CHECK-O3-NEXT:    orq %rcx, %rdx\n ; CHECK-O3-NEXT:    shrq $32, %rdx\n-; CHECK-O3-NEXT:    je .LBB35_1\n+; CHECK-O3-NEXT:    je .LBB39_1\n ; CHECK-O3-NEXT:  # %bb.2:\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divq %rcx\n ; CHECK-O3-NEXT:    retq\n-; CHECK-O3-NEXT:  .LBB35_1:\n+; CHECK-O3-NEXT:  .LBB39_1:\n ; CHECK-O3-NEXT:    # kill: def $eax killed $eax killed $rax\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divl %ecx\n@@ -805,13 +991,13 @@ define i64 @load_fold_srem2(i64* %p, i64 %v2) {\n ; CHECK-O3-NEXT:    movq %rax, %rcx\n ; CHECK-O3-NEXT:    orq %rsi, %rcx\n ; CHECK-O3-NEXT:    shrq $32, %rcx\n-; CHECK-O3-NEXT:    je .LBB37_1\n+; CHECK-O3-NEXT:    je .LBB41_1\n ; CHECK-O3-NEXT:  # %bb.2:\n ; CHECK-O3-NEXT:    cqto\n ; CHECK-O3-NEXT:    idivq %rsi\n ; CHECK-O3-NEXT:    movq %rdx, %rax\n ; CHECK-O3-NEXT:    retq\n-; CHECK-O3-NEXT:  .LBB37_1:\n+; CHECK-O3-NEXT:  .LBB41_1:\n ; CHECK-O3-NEXT:    # kill: def $eax killed $eax killed $rax\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divl %esi\n@@ -838,13 +1024,13 @@ define i64 @load_fold_srem3(i64* %p1, i64* %p2) {\n ; CHECK-O3-NEXT:    movq %rax, %rdx\n ; CHECK-O3-NEXT:    orq %rcx, %rdx\n ; CHECK-O3-NEXT:    shrq $32, %rdx\n-; CHECK-O3-NEXT:    je .LBB38_1\n+; CHECK-O3-NEXT:    je .LBB42_1\n ; CHECK-O3-NEXT:  # %bb.2:\n ; CHECK-O3-NEXT:    cqto\n ; CHECK-O3-NEXT:    idivq %rcx\n ; CHECK-O3-NEXT:    movq %rdx, %rax\n ; CHECK-O3-NEXT:    retq\n-; CHECK-O3-NEXT:  .LBB38_1:\n+; CHECK-O3-NEXT:  .LBB42_1:\n ; CHECK-O3-NEXT:    # kill: def $eax killed $eax killed $rax\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divl %ecx\n@@ -902,13 +1088,13 @@ define i64 @load_fold_urem2(i64* %p, i64 %v2) {\n ; CHECK-O3-NEXT:    movq %rax, %rcx\n ; CHECK-O3-NEXT:    orq %rsi, %rcx\n ; CHECK-O3-NEXT:    shrq $32, %rcx\n-; CHECK-O3-NEXT:    je .LBB40_1\n+; CHECK-O3-NEXT:    je .LBB44_1\n ; CHECK-O3-NEXT:  # %bb.2:\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divq %rsi\n ; CHECK-O3-NEXT:    movq %rdx, %rax\n ; CHECK-O3-NEXT:    retq\n-; CHECK-O3-NEXT:  .LBB40_1:\n+; CHECK-O3-NEXT:  .LBB44_1:\n ; CHECK-O3-NEXT:    # kill: def $eax killed $eax killed $rax\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divl %esi\n@@ -936,13 +1122,13 @@ define i64 @load_fold_urem3(i64* %p1, i64* %p2) {\n ; CHECK-O3-NEXT:    movq %rax, %rdx\n ; CHECK-O3-NEXT:    orq %rcx, %rdx\n ; CHECK-O3-NEXT:    shrq $32, %rdx\n-; CHECK-O3-NEXT:    je .LBB41_1\n+; CHECK-O3-NEXT:    je .LBB45_1\n ; CHECK-O3-NEXT:  # %bb.2:\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divq %rcx\n ; CHECK-O3-NEXT:    movq %rdx, %rax\n ; CHECK-O3-NEXT:    retq\n-; CHECK-O3-NEXT:  .LBB41_1:\n+; CHECK-O3-NEXT:  .LBB45_1:\n ; CHECK-O3-NEXT:    # kill: def $eax killed $eax killed $rax\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divl %ecx\n@@ -1537,13 +1723,13 @@ define void @rmw_fold_sdiv2(i64* %p, i64 %v) {\n ; CHECK-O3-NEXT:    movq %rax, %rcx\n ; CHECK-O3-NEXT:    orq %rsi, %rcx\n ; CHECK-O3-NEXT:    shrq $32, %rcx\n-; CHECK-O3-NEXT:    je .LBB70_1\n+; CHECK-O3-NEXT:    je .LBB74_1\n ; CHECK-O3-NEXT:  # %bb.2:\n ; CHECK-O3-NEXT:    cqto\n ; CHECK-O3-NEXT:    idivq %rsi\n ; CHECK-O3-NEXT:    movq %rax, (%rdi)\n ; CHECK-O3-NEXT:    retq\n-; CHECK-O3-NEXT:  .LBB70_1:\n+; CHECK-O3-NEXT:  .LBB74_1:\n ; CHECK-O3-NEXT:    # kill: def $eax killed $eax killed $rax\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divl %esi\n@@ -1599,13 +1785,13 @@ define void @rmw_fold_udiv2(i64* %p, i64 %v) {\n ; CHECK-O3-NEXT:    movq %rax, %rcx\n ; CHECK-O3-NEXT:    orq %rsi, %rcx\n ; CHECK-O3-NEXT:    shrq $32, %rcx\n-; CHECK-O3-NEXT:    je .LBB72_1\n+; CHECK-O3-NEXT:    je .LBB76_1\n ; CHECK-O3-NEXT:  # %bb.2:\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divq %rsi\n ; CHECK-O3-NEXT:    movq %rax, (%rdi)\n ; CHECK-O3-NEXT:    retq\n-; CHECK-O3-NEXT:  .LBB72_1:\n+; CHECK-O3-NEXT:  .LBB76_1:\n ; CHECK-O3-NEXT:    # kill: def $eax killed $eax killed $rax\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divl %esi\n@@ -1677,13 +1863,13 @@ define void @rmw_fold_srem2(i64* %p, i64 %v) {\n ; CHECK-O3-NEXT:    movq %rax, %rcx\n ; CHECK-O3-NEXT:    orq %rsi, %rcx\n ; CHECK-O3-NEXT:    shrq $32, %rcx\n-; CHECK-O3-NEXT:    je .LBB74_1\n+; CHECK-O3-NEXT:    je .LBB78_1\n ; CHECK-O3-NEXT:  # %bb.2:\n ; CHECK-O3-NEXT:    cqto\n ; CHECK-O3-NEXT:    idivq %rsi\n ; CHECK-O3-NEXT:    movq %rdx, (%rdi)\n ; CHECK-O3-NEXT:    retq\n-; CHECK-O3-NEXT:  .LBB74_1:\n+; CHECK-O3-NEXT:  .LBB78_1:\n ; CHECK-O3-NEXT:    # kill: def $eax killed $eax killed $rax\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divl %esi\n@@ -1748,13 +1934,13 @@ define void @rmw_fold_urem2(i64* %p, i64 %v) {\n ; CHECK-O3-NEXT:    movq %rax, %rcx\n ; CHECK-O3-NEXT:    orq %rsi, %rcx\n ; CHECK-O3-NEXT:    shrq $32, %rcx\n-; CHECK-O3-NEXT:    je .LBB76_1\n+; CHECK-O3-NEXT:    je .LBB80_1\n ; CHECK-O3-NEXT:  # %bb.2:\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divq %rsi\n ; CHECK-O3-NEXT:    movq %rdx, (%rdi)\n ; CHECK-O3-NEXT:    retq\n-; CHECK-O3-NEXT:  .LBB76_1:\n+; CHECK-O3-NEXT:  .LBB80_1:\n ; CHECK-O3-NEXT:    # kill: def $eax killed $eax killed $rax\n ; CHECK-O3-NEXT:    xorl %edx, %edx\n ; CHECK-O3-NEXT:    divl %esi"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/atomic-unordered.ll (1 of 1)\nTesting Time: 1.73s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/atomic-unordered.ll\n\n  Unexpected Failures: 1\n"
    },
    "0be2d25ecc7d9b71e03b07529eb1581efa92674a___ShrinkWrap.cpp": {
        "prefix": "bool ShrinkWrap::useOrDefCSROrFI(const MachineInstr &MI,\n                                 RegScavenger *RS) const {\n",
        "suffix": "      MI.getOpcode() == FrameDestroyOpcode) {\n    LLVM_DEBUG(dbgs() << \"Frame instruction: \" << MI << '\\n');\n    return true;\n  }\n  for (const MachineOperand &MO : MI.operands()) {\n    bool UseOrDefCSR = false;\n    if (MO.isReg()) {\n      // Ignore instructions like DBG_VALUE which don't read/def the register.\n      if (!MO.isDef() && !MO.readsReg())\n        continue;\n      unsigned PhysReg = MO.getReg();\n      if (!PhysReg)\n        continue;\n      assert(TargetRegisterInfo::isPhysicalRegister(PhysReg) &&\n             \"Unallocated register?!\");\n      // The stack pointer is not normally described as a callee-saved register\n      // in calling convention definitions, so we need to watch for it\n      // separately. An SP mentioned by a call instruction, we can ignore,\n      // though, as it's harmless and we do not want to effectively disable tail\n      // calls by forcing the restore point to post-dominate them.\n      UseOrDefCSR = (!MI.isCall() && PhysReg == SP) ||\n                    RCI.getLastCalleeSavedAlias(PhysReg);\n    } else if (MO.isRegMask()) {\n      // Check if this regmask clobbers any of the CSRs.\n      for (unsigned Reg : getCurrentCSRs(RS)) {\n        if (MO.clobbersPhysReg(Reg)) {\n          UseOrDefCSR = true;\n          break;\n        }\n      }\n    }\n    // Skip FrameIndex operands in DBG_VALUE instructions.\n    if (UseOrDefCSR || (MO.isFI() && !MI.isDebugValue())) {\n      LLVM_DEBUG(dbgs() << \"Use or define CSR(\" << UseOrDefCSR << \") or FI(\"\n                        << MO.isFI() << \"): \" << MI << '\\n');\n      return true;\n    }\n  }\n  return false;\n}\n",
        "start": 259,
        "end": 301,
        "buggy": "bool ShrinkWrap::useOrDefCSROrFI(const MachineInstr &MI,\n                                 RegScavenger *RS) const {\n  if (MI.getOpcode() == FrameSetupOpcode ||\n      MI.getOpcode() == FrameDestroyOpcode) {\n    LLVM_DEBUG(dbgs() << \"Frame instruction: \" << MI << '\\n');\n    return true;\n  }\n  for (const MachineOperand &MO : MI.operands()) {\n    bool UseOrDefCSR = false;\n    if (MO.isReg()) {\n      // Ignore instructions like DBG_VALUE which don't read/def the register.\n      if (!MO.isDef() && !MO.readsReg())\n        continue;\n      unsigned PhysReg = MO.getReg();\n      if (!PhysReg)\n        continue;\n      assert(TargetRegisterInfo::isPhysicalRegister(PhysReg) &&\n             \"Unallocated register?!\");\n      // The stack pointer is not normally described as a callee-saved register\n      // in calling convention definitions, so we need to watch for it\n      // separately. An SP mentioned by a call instruction, we can ignore,\n      // though, as it's harmless and we do not want to effectively disable tail\n      // calls by forcing the restore point to post-dominate them.\n      UseOrDefCSR = (!MI.isCall() && PhysReg == SP) ||\n                    RCI.getLastCalleeSavedAlias(PhysReg);\n    } else if (MO.isRegMask()) {\n      // Check if this regmask clobbers any of the CSRs.\n      for (unsigned Reg : getCurrentCSRs(RS)) {\n        if (MO.clobbersPhysReg(Reg)) {\n          UseOrDefCSR = true;\n          break;\n        }\n      }\n    }\n    // Skip FrameIndex operands in DBG_VALUE instructions.\n    if (UseOrDefCSR || (MO.isFI() && !MI.isDebugValue())) {\n      LLVM_DEBUG(dbgs() << \"Use or define CSR(\" << UseOrDefCSR << \") or FI(\"\n                        << MO.isFI() << \"): \" << MI << '\\n');\n      return true;\n    }\n  }\n  return false;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  if (MI.getOpcode() == FrameSetupOpcode ||\n",
        "src_path": "0be2d25ecc7d9b71e03b07529eb1581efa92674a___ShrinkWrap.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/0be2d25ecc7d9b71e03b07529eb1581efa92674a",
        "commit_msg": "[FIX] Forces shrink wrapping to consider any memory access as aliasing with the stack\n\nSummary:\nRelate bug: https://bugs.llvm.org/show_bug.cgi?id=37472\n\nThe shrink wrapping pass prematurally restores the stack, at a point where the stack might still be accessed.\nTaking an exception can cause the stack to be corrupted.\n\nAs a first approach, this patch is overly conservative, assuming that any instruction that may load or store could access\nthe stack.\n\nReviewers: dmgreen, qcolombet\n\nReviewed By: qcolombet\n\nSubscribers: simpal01, efriedma, eli.friedman, javed.absar, llvm-commits, eugenis, chill, carwil, thegameg\n\nTags: #llvm\n\nDifferential Revision: https://reviews.llvm.org/D63152\n\nllvm-svn: 363265",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/AArch64/arm64-shrink-wrapping.ll",
                "patch": "@@ -1,45 +1,51 @@\n-; RUN: llc %s -o - -enable-shrink-wrap=true -disable-post-ra -frame-pointer=all | FileCheck %s --check-prefix=CHECK --check-prefix=ENABLE\n-; RUN: llc %s -o - -enable-shrink-wrap=false -disable-post-ra -frame-pointer=all | FileCheck %s --check-prefix=CHECK --check-prefix=DISABLE\n+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py\n+; RUN: llc %s -o - -mtriple=arm64-apple-ios -enable-shrink-wrap=true -disable-post-ra -frame-pointer=all | FileCheck %s --check-prefix=ENABLE\n+; RUN: llc %s -o - -enable-shrink-wrap=false -disable-post-ra -frame-pointer=all | FileCheck %s --check-prefix=DISABLE\n target datalayout = \"e-m:o-i64:64-i128:128-n32:64-S128\"\n target triple = \"arm64-apple-ios\"\n \n \n ; Initial motivating example: Simple diamond with a call just on one side.\n-; CHECK-LABEL: foo:\n-;\n-; Compare the arguments and jump to exit.\n-; No prologue needed.\n-; ENABLE: cmp w0, w1\n-; ENABLE-NEXT: b.ge [[EXIT_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; CHECK: sub sp, sp, #32\n-; CHECK-NEXT: stp [[SAVE_SP:x[0-9]+]], [[CSR:x[0-9]+]], [sp, #16]\n-; CHECK-NEXT: add [[SAVE_SP]], sp, #16\n-;\n-; Compare the arguments and jump to exit.\n-; After the prologue is set.\n-; DISABLE: cmp w0, w1\n-; DISABLE-NEXT: b.ge [[EXIT_LABEL:LBB[0-9_]+]]\n-;\n-; Store %a in the alloca.\n-; CHECK: stur w0, {{\\[}}[[SAVE_SP]], #-4]\n-; Set the alloca address in the second argument.\n-; CHECK-NEXT: sub x1, [[SAVE_SP]], #4\n-; Set the first argument to zero.\n-; CHECK-NEXT: mov w0, wzr\n-; CHECK-NEXT: bl _doSomething\n-;\n-; Without shrink-wrapping, epilogue is in the exit block.\n-; DISABLE: [[EXIT_LABEL]]:\n-; Epilogue code.\n-; CHECK-NEXT: ldp x{{[0-9]+}}, [[CSR]], [sp, #16]\n-; CHECK-NEXT: add sp, sp, #32\n-;\n-; With shrink-wrapping, exit block is a simple return.\n-; ENABLE: [[EXIT_LABEL]]:\n-; CHECK-NEXT: ret\n define i32 @foo(i32 %a, i32 %b) {\n+; ENABLE-LABEL: foo:\n+; ENABLE:       ; %bb.0:\n+; ENABLE-NEXT:    cmp w0, w1\n+; ENABLE-NEXT:    b.ge LBB0_2\n+; ENABLE-NEXT:  ; %bb.1: ; %true\n+; ENABLE-NEXT:    sub sp, sp, #32 ; =32\n+; ENABLE-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill\n+; ENABLE-NEXT:    add x29, sp, #16 ; =16\n+; ENABLE-NEXT:    .cfi_def_cfa w29, 16\n+; ENABLE-NEXT:    .cfi_offset w30, -8\n+; ENABLE-NEXT:    .cfi_offset w29, -16\n+; ENABLE-NEXT:    stur w0, [x29, #-4]\n+; ENABLE-NEXT:    sub x1, x29, #4 ; =4\n+; ENABLE-NEXT:    mov w0, wzr\n+; ENABLE-NEXT:    bl _doSomething\n+; ENABLE-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload\n+; ENABLE-NEXT:    add sp, sp, #32 ; =32\n+; ENABLE-NEXT:  LBB0_2: ; %false\n+; ENABLE-NEXT:    ret\n+;\n+; DISABLE-LABEL: foo:\n+; DISABLE:       ; %bb.0:\n+; DISABLE-NEXT:    sub sp, sp, #32 ; =32\n+; DISABLE-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill\n+; DISABLE-NEXT:    add x29, sp, #16 ; =16\n+; DISABLE-NEXT:    .cfi_def_cfa w29, 16\n+; DISABLE-NEXT:    .cfi_offset w30, -8\n+; DISABLE-NEXT:    .cfi_offset w29, -16\n+; DISABLE-NEXT:    cmp w0, w1\n+; DISABLE-NEXT:    b.ge LBB0_2\n+; DISABLE-NEXT:  ; %bb.1: ; %true\n+; DISABLE-NEXT:    stur w0, [x29, #-4]\n+; DISABLE-NEXT:    sub x1, x29, #4 ; =4\n+; DISABLE-NEXT:    mov w0, wzr\n+; DISABLE-NEXT:    bl _doSomething\n+; DISABLE-NEXT:  LBB0_2: ; %false\n+; DISABLE-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload\n+; DISABLE-NEXT:    add sp, sp, #32 ; =32\n+; DISABLE-NEXT:    ret\n   %tmp = alloca i32, align 4\n   %tmp2 = icmp slt i32 %a, %b\n   br i1 %tmp2, label %true, label %false\n@@ -60,50 +66,65 @@ declare i32 @doSomething(i32, i32*)\n \n ; Check that we do not perform the restore inside the loop whereas the save\n ; is outside.\n-; CHECK-LABEL: freqSaveAndRestoreOutsideLoop:\n-;\n-; Shrink-wrapping allows to skip the prologue in the else case.\n-; ENABLE: cbz w0, [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; CHECK: stp [[CSR1:x[0-9]+]], [[CSR2:x[0-9]+]], [sp, #-32]!\n-; CHECK-NEXT: stp [[CSR3:x[0-9]+]], [[CSR4:x[0-9]+]], [sp, #16]\n-; CHECK-NEXT: add [[NEW_SP:x[0-9]+]], sp, #16\n-;\n-; DISABLE: cbz w0, [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: mov [[SUM:w[0-9]+]], wzr\n-; CHECK-NEXT: mov [[IV:w[0-9]+]], #10\n-;\n-; Next BB.\n-; CHECK: [[LOOP:LBB[0-9_]+]]: ; %for.body\n-; CHECK: bl _something\n-; CHECK-NEXT: subs [[IV]], [[IV]], #1\n-; CHECK-NEXT: add [[SUM]], w0, [[SUM]]\n-; CHECK-NEXT: b.ne [[LOOP]]\n-;\n-; Next BB.\n-; Copy SUM into the returned register + << 3.\n-; CHECK: lsl w0, [[SUM]], #3\n-;\n-; Jump to epilogue.\n-; DISABLE: b [[EPILOG_BB:LBB[0-9_]+]]\n-;\n-; DISABLE: [[ELSE_LABEL]]: ; %if.else\n-; Shift second argument by one and store into returned register.\n-; DISABLE: lsl w0, w1, #1\n-; DISABLE: [[EPILOG_BB]]: ; %if.end\n-;\n-; Epilogue code.\n-; CHECK: ldp [[CSR3]], [[CSR4]], [sp, #16]\n-; CHECK-NEXT: ldp [[CSR1]], [[CSR2]], [sp], #32\n-; CHECK-NEXT: ret\n-;\n-; ENABLE: [[ELSE_LABEL]]: ; %if.else\n-; Shift second argument by one and store into returned register.\n-; ENABLE: lsl w0, w1, #1\n-; ENABLE: ret\n define i32 @freqSaveAndRestoreOutsideLoop(i32 %cond, i32 %N) {\n+; ENABLE-LABEL: freqSaveAndRestoreOutsideLoop:\n+; ENABLE:       ; %bb.0: ; %entry\n+; ENABLE-NEXT:    cbz w0, LBB1_4\n+; ENABLE-NEXT:  ; %bb.1: ; %for.body.preheader\n+; ENABLE-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill\n+; ENABLE-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill\n+; ENABLE-NEXT:    add x29, sp, #16 ; =16\n+; ENABLE-NEXT:    .cfi_def_cfa w29, 16\n+; ENABLE-NEXT:    .cfi_offset w30, -8\n+; ENABLE-NEXT:    .cfi_offset w29, -16\n+; ENABLE-NEXT:    .cfi_offset w19, -24\n+; ENABLE-NEXT:    .cfi_offset w20, -32\n+; ENABLE-NEXT:    mov w19, wzr\n+; ENABLE-NEXT:    mov w20, #10\n+; ENABLE-NEXT:  LBB1_2: ; %for.body\n+; ENABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    bl _something\n+; ENABLE-NEXT:    subs w20, w20, #1 ; =1\n+; ENABLE-NEXT:    add w19, w0, w19\n+; ENABLE-NEXT:    b.ne LBB1_2\n+; ENABLE-NEXT:  ; %bb.3: ; %for.end\n+; ENABLE-NEXT:    lsl w0, w19, #3\n+; ENABLE-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ret\n+; ENABLE-NEXT:  LBB1_4: ; %if.else\n+; ENABLE-NEXT:    lsl w0, w1, #1\n+; ENABLE-NEXT:    ret\n+;\n+; DISABLE-LABEL: freqSaveAndRestoreOutsideLoop:\n+; DISABLE:       ; %bb.0: ; %entry\n+; DISABLE-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill\n+; DISABLE-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill\n+; DISABLE-NEXT:    add x29, sp, #16 ; =16\n+; DISABLE-NEXT:    .cfi_def_cfa w29, 16\n+; DISABLE-NEXT:    .cfi_offset w30, -8\n+; DISABLE-NEXT:    .cfi_offset w29, -16\n+; DISABLE-NEXT:    .cfi_offset w19, -24\n+; DISABLE-NEXT:    .cfi_offset w20, -32\n+; DISABLE-NEXT:    cbz w0, LBB1_4\n+; DISABLE-NEXT:  ; %bb.1: ; %for.body.preheader\n+; DISABLE-NEXT:    mov w19, wzr\n+; DISABLE-NEXT:    mov w20, #10\n+; DISABLE-NEXT:  LBB1_2: ; %for.body\n+; DISABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    bl _something\n+; DISABLE-NEXT:    subs w20, w20, #1 ; =1\n+; DISABLE-NEXT:    add w19, w0, w19\n+; DISABLE-NEXT:    b.ne LBB1_2\n+; DISABLE-NEXT:  ; %bb.3: ; %for.end\n+; DISABLE-NEXT:    lsl w0, w19, #3\n+; DISABLE-NEXT:    b LBB1_5\n+; DISABLE-NEXT:  LBB1_4: ; %if.else\n+; DISABLE-NEXT:    lsl w0, w1, #1\n+; DISABLE-NEXT:  LBB1_5: ; %if.end\n+; DISABLE-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ret\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %for.body\n@@ -134,26 +155,54 @@ declare i32 @something(...)\n \n ; Check that we do not perform the shrink-wrapping inside the loop even\n ; though that would be legal. The cost model must prevent that.\n-; CHECK-LABEL: freqSaveAndRestoreOutsideLoop2:\n-; Prologue code.\n-; CHECK: stp [[CSR1:x[0-9]+]], [[CSR2:x[0-9]+]], [sp, #-32]!\n-; CHECK-NEXT: stp [[CSR3:x[0-9]+]], [[CSR4:x[0-9]+]], [sp, #16]\n-; CHECK-NEXT: add [[NEW_SP:x[0-9]+]], sp, #16\n-; CHECK: mov [[SUM:w[0-9]+]], wzr\n-; CHECK-NEXT: mov [[IV:w[0-9]+]], #10\n-; Next BB.\n-; CHECK: [[LOOP_LABEL:LBB[0-9_]+]]: ; %for.body\n-; CHECK: bl _something\n-; CHECK-NEXT: subs [[IV]], [[IV]], #1\n-; CHECK-NEXT: add [[SUM]], w0, [[SUM]]\n-; CHECK-NEXT: b.ne [[LOOP_LABEL]]\n-; Next BB.\n-; CHECK: ; %for.end\n-; CHECK: mov w0, [[SUM]]\n-; CHECK-NEXT: ldp [[CSR3]], [[CSR4]], [sp, #16]\n-; CHECK-NEXT: ldp [[CSR1]], [[CSR2]], [sp], #32\n-; CHECK-NEXT: ret\n define i32 @freqSaveAndRestoreOutsideLoop2(i32 %cond) {\n+; ENABLE-LABEL: freqSaveAndRestoreOutsideLoop2:\n+; ENABLE:       ; %bb.0: ; %entry\n+; ENABLE-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill\n+; ENABLE-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill\n+; ENABLE-NEXT:    add x29, sp, #16 ; =16\n+; ENABLE-NEXT:    .cfi_def_cfa w29, 16\n+; ENABLE-NEXT:    .cfi_offset w30, -8\n+; ENABLE-NEXT:    .cfi_offset w29, -16\n+; ENABLE-NEXT:    .cfi_offset w19, -24\n+; ENABLE-NEXT:    .cfi_offset w20, -32\n+; ENABLE-NEXT:    mov w19, wzr\n+; ENABLE-NEXT:    mov w20, #10\n+; ENABLE-NEXT:  LBB2_1: ; %for.body\n+; ENABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    bl _something\n+; ENABLE-NEXT:    subs w20, w20, #1 ; =1\n+; ENABLE-NEXT:    add w19, w0, w19\n+; ENABLE-NEXT:    b.ne LBB2_1\n+; ENABLE-NEXT:  ; %bb.2: ; %for.end\n+; ENABLE-NEXT:    mov w0, w19\n+; ENABLE-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ret\n+;\n+; DISABLE-LABEL: freqSaveAndRestoreOutsideLoop2:\n+; DISABLE:       ; %bb.0: ; %entry\n+; DISABLE-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill\n+; DISABLE-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill\n+; DISABLE-NEXT:    add x29, sp, #16 ; =16\n+; DISABLE-NEXT:    .cfi_def_cfa w29, 16\n+; DISABLE-NEXT:    .cfi_offset w30, -8\n+; DISABLE-NEXT:    .cfi_offset w29, -16\n+; DISABLE-NEXT:    .cfi_offset w19, -24\n+; DISABLE-NEXT:    .cfi_offset w20, -32\n+; DISABLE-NEXT:    mov w19, wzr\n+; DISABLE-NEXT:    mov w20, #10\n+; DISABLE-NEXT:  LBB2_1: ; %for.body\n+; DISABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    bl _something\n+; DISABLE-NEXT:    subs w20, w20, #1 ; =1\n+; DISABLE-NEXT:    add w19, w0, w19\n+; DISABLE-NEXT:    b.ne LBB2_1\n+; DISABLE-NEXT:  ; %bb.2: ; %for.end\n+; DISABLE-NEXT:    mov w0, w19\n+; DISABLE-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ret\n entry:\n   br label %for.body\n \n@@ -172,46 +221,67 @@ for.end:                                          ; preds = %for.body\n \n ; Check with a more complex case that we do not have save within the loop and\n ; restore outside.\n-; CHECK-LABEL: loopInfoSaveOutsideLoop:\n-;\n-; ENABLE: cbz w0, [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; CHECK: stp [[CSR1:x[0-9]+]], [[CSR2:x[0-9]+]], [sp, #-32]!\n-; CHECK-NEXT: stp [[CSR3:x[0-9]+]], [[CSR4:x[0-9]+]], [sp, #16]\n-; CHECK-NEXT: add [[NEW_SP:x[0-9]+]], sp, #16\n-;\n-; DISABLE: cbz w0, [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: mov [[SUM:w[0-9]+]], wzr\n-; CHECK-NEXT: mov [[IV:w[0-9]+]], #10\n-;\n-; CHECK: [[LOOP_LABEL:LBB[0-9_]+]]: ; %for.body\n-; CHECK: bl _something\n-; CHECK-NEXT: subs [[IV]], [[IV]], #1\n-; CHECK-NEXT: add [[SUM]], w0, [[SUM]]\n-; CHECK-NEXT: b.ne [[LOOP_LABEL]]\n-; Next BB.\n-; CHECK: bl _somethingElse\n-; CHECK-NEXT: lsl w0, [[SUM]], #3\n-;\n-; Jump to epilogue.\n-; DISABLE: b [[EPILOG_BB:LBB[0-9_]+]]\n-;\n-; DISABLE: [[ELSE_LABEL]]: ; %if.else\n-; Shift second argument by one and store into returned register.\n-; DISABLE: lsl w0, w1, #1\n-; DISABLE: [[EPILOG_BB]]: ; %if.end\n-; Epilogue code.\n-; CHECK-NEXT: ldp [[CSR3]], [[CSR4]], [sp, #16]\n-; CHECK-NEXT: ldp [[CSR1]], [[CSR2]], [sp], #32\n-; CHECK-NEXT: ret\n-;\n-; ENABLE: [[ELSE_LABEL]]: ; %if.else\n-; Shift second argument by one and store into returned register.\n-; ENABLE: lsl w0, w1, #1\n-; ENABLE: ret\n define i32 @loopInfoSaveOutsideLoop(i32 %cond, i32 %N) {\n+; ENABLE-LABEL: loopInfoSaveOutsideLoop:\n+; ENABLE:       ; %bb.0: ; %entry\n+; ENABLE-NEXT:    cbz w0, LBB3_4\n+; ENABLE-NEXT:  ; %bb.1: ; %for.body.preheader\n+; ENABLE-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill\n+; ENABLE-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill\n+; ENABLE-NEXT:    add x29, sp, #16 ; =16\n+; ENABLE-NEXT:    .cfi_def_cfa w29, 16\n+; ENABLE-NEXT:    .cfi_offset w30, -8\n+; ENABLE-NEXT:    .cfi_offset w29, -16\n+; ENABLE-NEXT:    .cfi_offset w19, -24\n+; ENABLE-NEXT:    .cfi_offset w20, -32\n+; ENABLE-NEXT:    mov w19, wzr\n+; ENABLE-NEXT:    mov w20, #10\n+; ENABLE-NEXT:  LBB3_2: ; %for.body\n+; ENABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    bl _something\n+; ENABLE-NEXT:    subs w20, w20, #1 ; =1\n+; ENABLE-NEXT:    add w19, w0, w19\n+; ENABLE-NEXT:    b.ne LBB3_2\n+; ENABLE-NEXT:  ; %bb.3: ; %for.end\n+; ENABLE-NEXT:    bl _somethingElse\n+; ENABLE-NEXT:    lsl w0, w19, #3\n+; ENABLE-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ret\n+; ENABLE-NEXT:  LBB3_4: ; %if.else\n+; ENABLE-NEXT:    lsl w0, w1, #1\n+; ENABLE-NEXT:    ret\n+;\n+; DISABLE-LABEL: loopInfoSaveOutsideLoop:\n+; DISABLE:       ; %bb.0: ; %entry\n+; DISABLE-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill\n+; DISABLE-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill\n+; DISABLE-NEXT:    add x29, sp, #16 ; =16\n+; DISABLE-NEXT:    .cfi_def_cfa w29, 16\n+; DISABLE-NEXT:    .cfi_offset w30, -8\n+; DISABLE-NEXT:    .cfi_offset w29, -16\n+; DISABLE-NEXT:    .cfi_offset w19, -24\n+; DISABLE-NEXT:    .cfi_offset w20, -32\n+; DISABLE-NEXT:    cbz w0, LBB3_4\n+; DISABLE-NEXT:  ; %bb.1: ; %for.body.preheader\n+; DISABLE-NEXT:    mov w19, wzr\n+; DISABLE-NEXT:    mov w20, #10\n+; DISABLE-NEXT:  LBB3_2: ; %for.body\n+; DISABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    bl _something\n+; DISABLE-NEXT:    subs w20, w20, #1 ; =1\n+; DISABLE-NEXT:    add w19, w0, w19\n+; DISABLE-NEXT:    b.ne LBB3_2\n+; DISABLE-NEXT:  ; %bb.3: ; %for.end\n+; DISABLE-NEXT:    bl _somethingElse\n+; DISABLE-NEXT:    lsl w0, w19, #3\n+; DISABLE-NEXT:    b LBB3_5\n+; DISABLE-NEXT:  LBB3_4: ; %if.else\n+; DISABLE-NEXT:    lsl w0, w1, #1\n+; DISABLE-NEXT:  LBB3_5: ; %if.end\n+; DISABLE-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ret\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %for.body\n@@ -243,45 +313,57 @@ declare void @somethingElse(...)\n \n ; Check with a more complex case that we do not have restore within the loop and\n ; save outside.\n-; CHECK-LABEL: loopInfoRestoreOutsideLoop:\n-;\n-; ENABLE: cbz w0, [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: stp [[CSR1:x[0-9]+]], [[CSR2:x[0-9]+]], [sp, #-32]!\n-; CHECK-NEXT: stp [[CSR3:x[0-9]+]], [[CSR4:x[0-9]+]], [sp, #16]\n-; CHECK-NEXT: add [[NEW_SP:x[0-9]+]], sp, #16\n-;\n-; DISABLE: cbz w0, [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: bl _somethingElse\n-; CHECK-NEXT: mov [[SUM:w[0-9]+]], wzr\n-; CHECK-NEXT: mov [[IV:w[0-9]+]], #10\n-;\n-; CHECK: [[LOOP_LABEL:LBB[0-9_]+]]: ; %for.body\n-; CHECK: bl _something\n-; CHECK-NEXT: subs [[IV]], [[IV]], #1\n-; CHECK-NEXT: add [[SUM]], w0, [[SUM]]\n-; CHECK-NEXT: b.ne [[LOOP_LABEL]]\n-; Next BB.\n-; CHECK: lsl w0, [[SUM]], #3\n-;\n-; Jump to epilogue.\n-; DISABLE: b [[EPILOG_BB:LBB[0-9_]+]]\n-;\n-; DISABLE: [[ELSE_LABEL]]: ; %if.else\n-; Shift second argument by one and store into returned register.\n-; DISABLE: lsl w0, w1, #1\n-; DISABLE: [[EPILOG_BB]]: ; %if.end\n-; Epilogue code.\n-; CHECK: ldp [[CSR3]], [[CSR4]], [sp, #16]\n-; CHECK-NEXT: ldp [[CSR1]], [[CSR2]], [sp], #32\n-; CHECK-NEXT: ret\n-;\n-; ENABLE: [[ELSE_LABEL]]: ; %if.else\n-; Shift second argument by one and store into returned register.\n-; ENABLE: lsl w0, w1, #1\n-; ENABLE: ret\n define i32 @loopInfoRestoreOutsideLoop(i32 %cond, i32 %N) nounwind {\n+; ENABLE-LABEL: loopInfoRestoreOutsideLoop:\n+; ENABLE:       ; %bb.0: ; %entry\n+; ENABLE-NEXT:    cbz w0, LBB4_4\n+; ENABLE-NEXT:  ; %bb.1: ; %if.then\n+; ENABLE-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill\n+; ENABLE-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill\n+; ENABLE-NEXT:    add x29, sp, #16 ; =16\n+; ENABLE-NEXT:    bl _somethingElse\n+; ENABLE-NEXT:    mov w19, wzr\n+; ENABLE-NEXT:    mov w20, #10\n+; ENABLE-NEXT:  LBB4_2: ; %for.body\n+; ENABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    bl _something\n+; ENABLE-NEXT:    subs w20, w20, #1 ; =1\n+; ENABLE-NEXT:    add w19, w0, w19\n+; ENABLE-NEXT:    b.ne LBB4_2\n+; ENABLE-NEXT:  ; %bb.3: ; %for.end\n+; ENABLE-NEXT:    lsl w0, w19, #3\n+; ENABLE-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ret\n+; ENABLE-NEXT:  LBB4_4: ; %if.else\n+; ENABLE-NEXT:    lsl w0, w1, #1\n+; ENABLE-NEXT:    ret\n+;\n+; DISABLE-LABEL: loopInfoRestoreOutsideLoop:\n+; DISABLE:       ; %bb.0: ; %entry\n+; DISABLE-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill\n+; DISABLE-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill\n+; DISABLE-NEXT:    add x29, sp, #16 ; =16\n+; DISABLE-NEXT:    cbz w0, LBB4_4\n+; DISABLE-NEXT:  ; %bb.1: ; %if.then\n+; DISABLE-NEXT:    bl _somethingElse\n+; DISABLE-NEXT:    mov w19, wzr\n+; DISABLE-NEXT:    mov w20, #10\n+; DISABLE-NEXT:  LBB4_2: ; %for.body\n+; DISABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    bl _something\n+; DISABLE-NEXT:    subs w20, w20, #1 ; =1\n+; DISABLE-NEXT:    add w19, w0, w19\n+; DISABLE-NEXT:    b.ne LBB4_2\n+; DISABLE-NEXT:  ; %bb.3: ; %for.end\n+; DISABLE-NEXT:    lsl w0, w19, #3\n+; DISABLE-NEXT:    b LBB4_5\n+; DISABLE-NEXT:  LBB4_4: ; %if.else\n+; DISABLE-NEXT:    lsl w0, w1, #1\n+; DISABLE-NEXT:  LBB4_5: ; %if.end\n+; DISABLE-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ret\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %if.then\n@@ -313,49 +395,74 @@ if.end:                                           ; preds = %if.else, %for.end\n }\n \n ; Check that we handle function with no frame information correctly.\n-; CHECK-LABEL: emptyFrame:\n-; CHECK: ; %entry\n-; CHECK-NEXT: mov w0, wzr\n-; CHECK-NEXT: ret\n define i32 @emptyFrame() {\n+; ENABLE-LABEL: emptyFrame:\n+; ENABLE:       ; %bb.0: ; %entry\n+; ENABLE-NEXT:    mov w0, wzr\n+; ENABLE-NEXT:    ret\n+;\n+; DISABLE-LABEL: emptyFrame:\n+; DISABLE:       ; %bb.0: ; %entry\n+; DISABLE-NEXT:    mov w0, wzr\n+; DISABLE-NEXT:    ret\n entry:\n   ret i32 0\n }\n \n ; Check that we handle variadic function correctly.\n-; CHECK-LABEL: variadicFunc:\n-;\n-; ENABLE: cbz w0, [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; CHECK: sub sp, sp, #16\n-; DISABLE: cbz w0, [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Sum is merged with the returned register.\n-; CHECK: add [[VA_BASE:x[0-9]+]], sp, #16\n-; CHECK-NEXT: cmp w1, #1\n-; CHECK-NEXT: str [[VA_BASE]], [sp, #8]\n-; CHECK-NEXT: mov [[SUM:w0]], wzr\n-; CHECK-NEXT: b.lt [[IFEND_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: [[LOOP_LABEL:LBB[0-9_]+]]: ; %for.body\n-; CHECK: ldr [[VA_ADDR:x[0-9]+]], [sp, #8]\n-; CHECK-NEXT: add [[NEXT_VA_ADDR:x[0-9]+]], [[VA_ADDR]], #8\n-; CHECK-NEXT: str [[NEXT_VA_ADDR]], [sp, #8]\n-; CHECK-NEXT: ldr [[VA_VAL:w[0-9]+]], {{\\[}}[[VA_ADDR]]]\n-; CHECK-NEXT: subs w1, w1, #1\n-; CHECK-NEXT: add [[SUM]], [[SUM]], [[VA_VAL]]\n-; CHECK-NEXT: b.ne [[LOOP_LABEL]]\n-; CHECK-NEXT: [[IFEND_LABEL]]:\n-; Epilogue code.\n-; CHECK: add sp, sp, #16\n-; CHECK-NEXT: ret\n-;\n-; CHECK: [[ELSE_LABEL]]: ; %if.else\n-; CHECK-NEXT: lsl w0, w1, #1\n-; DISABLE-NEXT: add sp, sp, #16\n-; CHECK-NEXT: ret\n define i32 @variadicFunc(i32 %cond, i32 %count, ...) nounwind {\n+; ENABLE-LABEL: variadicFunc:\n+; ENABLE:       ; %bb.0: ; %entry\n+; ENABLE-NEXT:    cbz w0, LBB6_4\n+; ENABLE-NEXT:  ; %bb.1: ; %if.then\n+; ENABLE-NEXT:    sub sp, sp, #16 ; =16\n+; ENABLE-NEXT:    add x8, sp, #16 ; =16\n+; ENABLE-NEXT:    cmp w1, #1 ; =1\n+; ENABLE-NEXT:    str x8, [sp, #8]\n+; ENABLE-NEXT:    mov w0, wzr\n+; ENABLE-NEXT:    b.lt LBB6_3\n+; ENABLE-NEXT:  LBB6_2: ; %for.body\n+; ENABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    ldr x8, [sp, #8]\n+; ENABLE-NEXT:    add x9, x8, #8 ; =8\n+; ENABLE-NEXT:    str x9, [sp, #8]\n+; ENABLE-NEXT:    ldr w8, [x8]\n+; ENABLE-NEXT:    subs w1, w1, #1 ; =1\n+; ENABLE-NEXT:    add w0, w0, w8\n+; ENABLE-NEXT:    b.ne LBB6_2\n+; ENABLE-NEXT:  LBB6_3: ; %for.end\n+; ENABLE-NEXT:    add sp, sp, #16 ; =16\n+; ENABLE-NEXT:    ret\n+; ENABLE-NEXT:  LBB6_4: ; %if.else\n+; ENABLE-NEXT:    lsl w0, w1, #1\n+; ENABLE-NEXT:    ret\n+;\n+; DISABLE-LABEL: variadicFunc:\n+; DISABLE:       ; %bb.0: ; %entry\n+; DISABLE-NEXT:    sub sp, sp, #16 ; =16\n+; DISABLE-NEXT:    cbz w0, LBB6_4\n+; DISABLE-NEXT:  ; %bb.1: ; %if.then\n+; DISABLE-NEXT:    add x8, sp, #16 ; =16\n+; DISABLE-NEXT:    cmp w1, #1 ; =1\n+; DISABLE-NEXT:    str x8, [sp, #8]\n+; DISABLE-NEXT:    mov w0, wzr\n+; DISABLE-NEXT:    b.lt LBB6_3\n+; DISABLE-NEXT:  LBB6_2: ; %for.body\n+; DISABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    ldr x8, [sp, #8]\n+; DISABLE-NEXT:    add x9, x8, #8 ; =8\n+; DISABLE-NEXT:    str x9, [sp, #8]\n+; DISABLE-NEXT:    ldr w8, [x8]\n+; DISABLE-NEXT:    subs w1, w1, #1 ; =1\n+; DISABLE-NEXT:    add w0, w0, w8\n+; DISABLE-NEXT:    b.ne LBB6_2\n+; DISABLE-NEXT:  LBB6_3: ; %if.end\n+; DISABLE-NEXT:    add sp, sp, #16 ; =16\n+; DISABLE-NEXT:    ret\n+; DISABLE-NEXT:  LBB6_4: ; %if.else\n+; DISABLE-NEXT:    lsl w0, w1, #1\n+; DISABLE-NEXT:    add sp, sp, #16 ; =16\n+; DISABLE-NEXT:    ret\n entry:\n   %ap = alloca i8*, align 8\n   %tobool = icmp eq i32 %cond, 0\n@@ -395,35 +502,55 @@ declare void @llvm.va_start(i8*)\n declare void @llvm.va_end(i8*)\n \n ; Check that we handle inline asm correctly.\n-; CHECK-LABEL: inlineAsm:\n-;\n-; ENABLE: cbz w0, [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; Make sure we save the CSR used in the inline asm: x19.\n-; CHECK: stp [[CSR1:x[0-9]+]], [[CSR2:x19]], [sp, #-16]!\n-;\n-; DISABLE: cbz w0, [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: mov [[IV:w[0-9]+]], #10\n-;\n-; CHECK: [[LOOP_LABEL:LBB[0-9_]+]]: ; %for.body\n-; Inline asm statement.\n-; CHECK: subs [[IV]], [[IV]], #1\n-; CHECK: add x19, x19, #1\n-; CHECK: b.ne [[LOOP_LABEL]]\n-; Next BB.\n-; CHECK: mov w0, wzr\n-; Epilogue code.\n-; CHECK-NEXT: ldp [[CSR1]], [[CSR2]], [sp], #16\n-; CHECK-NEXT: ret\n-; Next BB.\n-; CHECK: [[ELSE_LABEL]]: ; %if.else\n-; CHECK-NEXT: lsl w0, w1, #1\n-; Epilogue code.\n-; DISABLE-NEXT: ldp [[CSR1]], [[CSR2]], [sp], #16\n-; CHECK-NEXT: ret\n define i32 @inlineAsm(i32 %cond, i32 %N) {\n+; ENABLE-LABEL: inlineAsm:\n+; ENABLE:       ; %bb.0: ; %entry\n+; ENABLE-NEXT:    cbz w0, LBB7_4\n+; ENABLE-NEXT:  ; %bb.1: ; %for.body.preheader\n+; ENABLE-NEXT:    stp x20, x19, [sp, #-16]! ; 16-byte Folded Spill\n+; ENABLE-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-NEXT:    .cfi_offset w19, -8\n+; ENABLE-NEXT:    .cfi_offset w20, -16\n+; ENABLE-NEXT:    mov w8, #10\n+; ENABLE-NEXT:  LBB7_2: ; %for.body\n+; ENABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    subs w8, w8, #1 ; =1\n+; ENABLE-NEXT:    ; InlineAsm Start\n+; ENABLE-NEXT:    add x19, x19, #1 ; =1\n+; ENABLE-NEXT:    ; InlineAsm End\n+; ENABLE-NEXT:    b.ne LBB7_2\n+; ENABLE-NEXT:  ; %bb.3:\n+; ENABLE-NEXT:    mov w0, wzr\n+; ENABLE-NEXT:    ldp x20, x19, [sp], #16 ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ret\n+; ENABLE-NEXT:  LBB7_4: ; %if.else\n+; ENABLE-NEXT:    lsl w0, w1, #1\n+; ENABLE-NEXT:    ret\n+;\n+; DISABLE-LABEL: inlineAsm:\n+; DISABLE:       ; %bb.0: ; %entry\n+; DISABLE-NEXT:    stp x20, x19, [sp, #-16]! ; 16-byte Folded Spill\n+; DISABLE-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-NEXT:    .cfi_offset w19, -8\n+; DISABLE-NEXT:    .cfi_offset w20, -16\n+; DISABLE-NEXT:    cbz w0, LBB7_4\n+; DISABLE-NEXT:  ; %bb.1: ; %for.body.preheader\n+; DISABLE-NEXT:    mov w8, #10\n+; DISABLE-NEXT:  LBB7_2: ; %for.body\n+; DISABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    subs w8, w8, #1 ; =1\n+; DISABLE-NEXT:    ; InlineAsm Start\n+; DISABLE-NEXT:    add x19, x19, #1 ; =1\n+; DISABLE-NEXT:    ; InlineAsm End\n+; DISABLE-NEXT:    b.ne LBB7_2\n+; DISABLE-NEXT:  ; %bb.3:\n+; DISABLE-NEXT:    mov w0, wzr\n+; DISABLE-NEXT:    ldp x20, x19, [sp], #16 ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ret\n+; DISABLE-NEXT:  LBB7_4: ; %if.else\n+; DISABLE-NEXT:    lsl w0, w1, #1\n+; DISABLE-NEXT:    ldp x20, x19, [sp], #16 ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ret\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %for.body\n@@ -445,38 +572,55 @@ if.end:                                           ; preds = %for.body, %if.else\n }\n \n ; Check that we handle calls to variadic functions correctly.\n-; CHECK-LABEL: callVariadicFunc:\n-;\n-; ENABLE: cbz w0, [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; CHECK: sub sp, sp, #64\n-; CHECK-NEXT: stp [[CSR1:x[0-9]+]], [[CSR2:x[0-9]+]], [sp, #48]\n-; CHECK-NEXT: add [[NEW_SP:x[0-9]+]], sp, #48\n-;\n-; DISABLE: cbz w0, [[ELSE_LABEL:LBB[0-9_]+]]\n-; Setup of the varags.\n-; CHECK: stp x1, x1, [sp, #32]\n-; CHECK-NEXT: stp x1, x1, [sp, #16]\n-; CHECK-NEXT: stp x1, x1, [sp]\n-; CHECK-NEXT: mov w0, w1\n-; CHECK-NEXT: bl _someVariadicFunc\n-; CHECK-NEXT: lsl w0, w0, #3\n-;\n-; DISABLE: b [[IFEND_LABEL:LBB[0-9_]+]]\n-; DISABLE: [[ELSE_LABEL]]: ; %if.else\n-; DISABLE-NEXT: lsl w0, w1, #1\n-; DISABLE: [[IFEND_LABEL]]: ; %if.end\n-;\n-; Epilogue code.\n-; CHECK: ldp [[CSR1]], [[CSR2]], [sp, #48]\n-; CHECK-NEXT: add sp, sp, #64\n-; CHECK-NEXT: ret\n-;\n-; ENABLE: [[ELSE_LABEL]]: ; %if.else\n-; ENABLE-NEXT: lsl w0, w1, #1\n-; ENABLE-NEXT: ret\n define i32 @callVariadicFunc(i32 %cond, i32 %N) {\n+; ENABLE-LABEL: callVariadicFunc:\n+; ENABLE:       ; %bb.0: ; %entry\n+; ENABLE-NEXT:    ; kill: def $w1 killed $w1 def $x1\n+; ENABLE-NEXT:    cbz w0, LBB8_2\n+; ENABLE-NEXT:  ; %bb.1: ; %if.then\n+; ENABLE-NEXT:    sub sp, sp, #64 ; =64\n+; ENABLE-NEXT:    stp x29, x30, [sp, #48] ; 16-byte Folded Spill\n+; ENABLE-NEXT:    add x29, sp, #48 ; =48\n+; ENABLE-NEXT:    .cfi_def_cfa w29, 16\n+; ENABLE-NEXT:    .cfi_offset w30, -8\n+; ENABLE-NEXT:    .cfi_offset w29, -16\n+; ENABLE-NEXT:    stp x1, x1, [sp, #32]\n+; ENABLE-NEXT:    stp x1, x1, [sp, #16]\n+; ENABLE-NEXT:    stp x1, x1, [sp]\n+; ENABLE-NEXT:    mov w0, w1\n+; ENABLE-NEXT:    bl _someVariadicFunc\n+; ENABLE-NEXT:    lsl w0, w0, #3\n+; ENABLE-NEXT:    ldp x29, x30, [sp, #48] ; 16-byte Folded Reload\n+; ENABLE-NEXT:    add sp, sp, #64 ; =64\n+; ENABLE-NEXT:    ret\n+; ENABLE-NEXT:  LBB8_2: ; %if.else\n+; ENABLE-NEXT:    lsl w0, w1, #1\n+; ENABLE-NEXT:    ret\n+;\n+; DISABLE-LABEL: callVariadicFunc:\n+; DISABLE:       ; %bb.0: ; %entry\n+; DISABLE-NEXT:    sub sp, sp, #64 ; =64\n+; DISABLE-NEXT:    stp x29, x30, [sp, #48] ; 16-byte Folded Spill\n+; DISABLE-NEXT:    add x29, sp, #48 ; =48\n+; DISABLE-NEXT:    .cfi_def_cfa w29, 16\n+; DISABLE-NEXT:    .cfi_offset w30, -8\n+; DISABLE-NEXT:    .cfi_offset w29, -16\n+; DISABLE-NEXT:    ; kill: def $w1 killed $w1 def $x1\n+; DISABLE-NEXT:    cbz w0, LBB8_2\n+; DISABLE-NEXT:  ; %bb.1: ; %if.then\n+; DISABLE-NEXT:    stp x1, x1, [sp, #32]\n+; DISABLE-NEXT:    stp x1, x1, [sp, #16]\n+; DISABLE-NEXT:    stp x1, x1, [sp]\n+; DISABLE-NEXT:    mov w0, w1\n+; DISABLE-NEXT:    bl _someVariadicFunc\n+; DISABLE-NEXT:    lsl w0, w0, #3\n+; DISABLE-NEXT:    b LBB8_3\n+; DISABLE-NEXT:  LBB8_2: ; %if.else\n+; DISABLE-NEXT:    lsl w0, w1, #1\n+; DISABLE-NEXT:  LBB8_3: ; %if.end\n+; DISABLE-NEXT:    ldp x29, x30, [sp, #48] ; 16-byte Folded Reload\n+; DISABLE-NEXT:    add sp, sp, #64 ; =64\n+; DISABLE-NEXT:    ret\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %if.then\n@@ -501,24 +645,35 @@ declare i32 @someVariadicFunc(i32, ...)\n ; Although this is not incorrect to insert such code, it is useless\n ; and it hurts the binary size.\n ;\n-; CHECK-LABEL: noreturn:\n-; DISABLE: stp\n-;\n-; CHECK: cbnz w0, [[ABORT:LBB[0-9_]+]]\n-;\n-; CHECK: mov w0, #42\n-;\n-; DISABLE-NEXT: ldp\n-;\n-; CHECK-NEXT: ret\n-;\n-; CHECK: [[ABORT]]: ; %if.abort\n-;\n-; ENABLE: stp\n-;\n-; CHECK: bl _abort\n-; ENABLE-NOT: ldp\n define i32 @noreturn(i8 signext %bad_thing) {\n+; ENABLE-LABEL: noreturn:\n+; ENABLE:       ; %bb.0: ; %entry\n+; ENABLE-NEXT:    cbnz w0, LBB9_2\n+; ENABLE-NEXT:  ; %bb.1: ; %if.end\n+; ENABLE-NEXT:    mov w0, #42\n+; ENABLE-NEXT:    ret\n+; ENABLE-NEXT:  LBB9_2: ; %if.abort\n+; ENABLE-NEXT:    stp x29, x30, [sp, #-16]! ; 16-byte Folded Spill\n+; ENABLE-NEXT:    mov x29, sp\n+; ENABLE-NEXT:    .cfi_def_cfa w29, 16\n+; ENABLE-NEXT:    .cfi_offset w30, -8\n+; ENABLE-NEXT:    .cfi_offset w29, -16\n+; ENABLE-NEXT:    bl _abort\n+;\n+; DISABLE-LABEL: noreturn:\n+; DISABLE:       ; %bb.0: ; %entry\n+; DISABLE-NEXT:    stp x29, x30, [sp, #-16]! ; 16-byte Folded Spill\n+; DISABLE-NEXT:    mov x29, sp\n+; DISABLE-NEXT:    .cfi_def_cfa w29, 16\n+; DISABLE-NEXT:    .cfi_offset w30, -8\n+; DISABLE-NEXT:    .cfi_offset w29, -16\n+; DISABLE-NEXT:    cbnz w0, LBB9_2\n+; DISABLE-NEXT:  ; %bb.1: ; %if.end\n+; DISABLE-NEXT:    mov w0, #42\n+; DISABLE-NEXT:    ldp x29, x30, [sp], #16 ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ret\n+; DISABLE-NEXT:  LBB9_2: ; %if.abort\n+; DISABLE-NEXT:    bl _abort\n entry:\n   %tobool = icmp eq i8 %bad_thing, 0\n   br i1 %tobool, label %if.end, label %if.abort\n@@ -543,9 +698,60 @@ attributes #0 = { noreturn nounwind }\n ; should return gracefully and continue compilation.\n ; The only condition for this test is the compilation finishes correctly.\n ;\n-; CHECK-LABEL: infiniteloop\n-; CHECK: ret\n define void @infiniteloop() {\n+; ENABLE-LABEL: infiniteloop:\n+; ENABLE:       ; %bb.0: ; %entry\n+; ENABLE-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill\n+; ENABLE-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill\n+; ENABLE-NEXT:    add x29, sp, #16 ; =16\n+; ENABLE-NEXT:    .cfi_def_cfa w29, 16\n+; ENABLE-NEXT:    .cfi_offset w30, -8\n+; ENABLE-NEXT:    .cfi_offset w29, -16\n+; ENABLE-NEXT:    .cfi_offset w19, -24\n+; ENABLE-NEXT:    .cfi_offset w20, -32\n+; ENABLE-NEXT:    cbnz wzr, LBB10_3\n+; ENABLE-NEXT:  ; %bb.1: ; %if.then\n+; ENABLE-NEXT:    sub x19, sp, #16 ; =16\n+; ENABLE-NEXT:    mov sp, x19\n+; ENABLE-NEXT:    mov w20, wzr\n+; ENABLE-NEXT:  LBB10_2: ; %for.body\n+; ENABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    bl _something\n+; ENABLE-NEXT:    add w20, w0, w20\n+; ENABLE-NEXT:    str w20, [x19]\n+; ENABLE-NEXT:    b LBB10_2\n+; ENABLE-NEXT:  LBB10_3: ; %if.end\n+; ENABLE-NEXT:    sub sp, x29, #16 ; =16\n+; ENABLE-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ret\n+;\n+; DISABLE-LABEL: infiniteloop:\n+; DISABLE:       ; %bb.0: ; %entry\n+; DISABLE-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill\n+; DISABLE-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill\n+; DISABLE-NEXT:    add x29, sp, #16 ; =16\n+; DISABLE-NEXT:    .cfi_def_cfa w29, 16\n+; DISABLE-NEXT:    .cfi_offset w30, -8\n+; DISABLE-NEXT:    .cfi_offset w29, -16\n+; DISABLE-NEXT:    .cfi_offset w19, -24\n+; DISABLE-NEXT:    .cfi_offset w20, -32\n+; DISABLE-NEXT:    cbnz wzr, LBB10_3\n+; DISABLE-NEXT:  ; %bb.1: ; %if.then\n+; DISABLE-NEXT:    sub x19, sp, #16 ; =16\n+; DISABLE-NEXT:    mov sp, x19\n+; DISABLE-NEXT:    mov w20, wzr\n+; DISABLE-NEXT:  LBB10_2: ; %for.body\n+; DISABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    bl _something\n+; DISABLE-NEXT:    add w20, w0, w20\n+; DISABLE-NEXT:    str w20, [x19]\n+; DISABLE-NEXT:    b LBB10_2\n+; DISABLE-NEXT:  LBB10_3: ; %if.end\n+; DISABLE-NEXT:    sub sp, x29, #16 ; =16\n+; DISABLE-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ret\n entry:\n   br i1 undef, label %if.then, label %if.end\n \n@@ -565,9 +771,72 @@ if.end:\n }\n \n ; Another infinite loop test this time with a body bigger than just one block.\n-; CHECK-LABEL: infiniteloop2\n-; CHECK: ret\n define void @infiniteloop2() {\n+; ENABLE-LABEL: infiniteloop2:\n+; ENABLE:       ; %bb.0: ; %entry\n+; ENABLE-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill\n+; ENABLE-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill\n+; ENABLE-NEXT:    add x29, sp, #16 ; =16\n+; ENABLE-NEXT:    .cfi_def_cfa w29, 16\n+; ENABLE-NEXT:    .cfi_offset w30, -8\n+; ENABLE-NEXT:    .cfi_offset w29, -16\n+; ENABLE-NEXT:    .cfi_offset w19, -24\n+; ENABLE-NEXT:    .cfi_offset w20, -32\n+; ENABLE-NEXT:    cbnz wzr, LBB11_3\n+; ENABLE-NEXT:  ; %bb.1: ; %if.then\n+; ENABLE-NEXT:    sub x8, sp, #16 ; =16\n+; ENABLE-NEXT:    mov sp, x8\n+; ENABLE-NEXT:    mov w9, wzr\n+; ENABLE-NEXT:    ; InlineAsm Start\n+; ENABLE-NEXT:    mov x10, #0\n+; ENABLE-NEXT:    ; InlineAsm End\n+; ENABLE-NEXT:  LBB11_2: ; %for.body\n+; ENABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    add w9, w10, w9\n+; ENABLE-NEXT:    str w9, [x8]\n+; ENABLE-NEXT:    ; InlineAsm Start\n+; ENABLE-NEXT:    nop\n+; ENABLE-NEXT:    ; InlineAsm End\n+; ENABLE-NEXT:    mov w9, #1\n+; ENABLE-NEXT:    b LBB11_2\n+; ENABLE-NEXT:  LBB11_3: ; %if.end\n+; ENABLE-NEXT:    sub sp, x29, #16 ; =16\n+; ENABLE-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ret\n+;\n+; DISABLE-LABEL: infiniteloop2:\n+; DISABLE:       ; %bb.0: ; %entry\n+; DISABLE-NEXT:    stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill\n+; DISABLE-NEXT:    stp x29, x30, [sp, #16] ; 16-byte Folded Spill\n+; DISABLE-NEXT:    add x29, sp, #16 ; =16\n+; DISABLE-NEXT:    .cfi_def_cfa w29, 16\n+; DISABLE-NEXT:    .cfi_offset w30, -8\n+; DISABLE-NEXT:    .cfi_offset w29, -16\n+; DISABLE-NEXT:    .cfi_offset w19, -24\n+; DISABLE-NEXT:    .cfi_offset w20, -32\n+; DISABLE-NEXT:    cbnz wzr, LBB11_3\n+; DISABLE-NEXT:  ; %bb.1: ; %if.then\n+; DISABLE-NEXT:    sub x8, sp, #16 ; =16\n+; DISABLE-NEXT:    mov sp, x8\n+; DISABLE-NEXT:    mov w9, wzr\n+; DISABLE-NEXT:    ; InlineAsm Start\n+; DISABLE-NEXT:    mov x10, #0\n+; DISABLE-NEXT:    ; InlineAsm End\n+; DISABLE-NEXT:  LBB11_2: ; %for.body\n+; DISABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    add w9, w10, w9\n+; DISABLE-NEXT:    str w9, [x8]\n+; DISABLE-NEXT:    ; InlineAsm Start\n+; DISABLE-NEXT:    nop\n+; DISABLE-NEXT:    ; InlineAsm End\n+; DISABLE-NEXT:    mov w9, #1\n+; DISABLE-NEXT:    b LBB11_2\n+; DISABLE-NEXT:  LBB11_3: ; %if.end\n+; DISABLE-NEXT:    sub sp, x29, #16 ; =16\n+; DISABLE-NEXT:    ldp x29, x30, [sp, #16] ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ldp x20, x19, [sp], #32 ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ret\n entry:\n   br i1 undef, label %if.then, label %if.end\n \n@@ -595,9 +864,54 @@ if.end:\n }\n \n ; Another infinite loop test this time with two nested infinite loop.\n-; CHECK-LABEL: infiniteloop3\n-; CHECK: ret\n define void @infiniteloop3() {\n+; ENABLE-LABEL: infiniteloop3:\n+; ENABLE:       ; %bb.0: ; %entry\n+; ENABLE-NEXT:    cbnz wzr, LBB12_5\n+; ENABLE-NEXT:  ; %bb.1: ; %loop2a.preheader\n+; ENABLE-NEXT:    mov x8, xzr\n+; ENABLE-NEXT:    mov x9, xzr\n+; ENABLE-NEXT:    mov x11, xzr\n+; ENABLE-NEXT:    b LBB12_3\n+; ENABLE-NEXT:  LBB12_2: ; %loop2b\n+; ENABLE-NEXT:    ; in Loop: Header=BB12_3 Depth=1\n+; ENABLE-NEXT:    str x10, [x11]\n+; ENABLE-NEXT:    mov x11, x10\n+; ENABLE-NEXT:  LBB12_3: ; %loop1\n+; ENABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    mov x10, x9\n+; ENABLE-NEXT:    ldr x9, [x8]\n+; ENABLE-NEXT:    cbnz x8, LBB12_2\n+; ENABLE-NEXT:  ; %bb.4: ; in Loop: Header=BB12_3 Depth=1\n+; ENABLE-NEXT:    mov x8, x10\n+; ENABLE-NEXT:    mov x11, x10\n+; ENABLE-NEXT:    b LBB12_3\n+; ENABLE-NEXT:  LBB12_5: ; %end\n+; ENABLE-NEXT:    ret\n+;\n+; DISABLE-LABEL: infiniteloop3:\n+; DISABLE:       ; %bb.0: ; %entry\n+; DISABLE-NEXT:    cbnz wzr, LBB12_5\n+; DISABLE-NEXT:  ; %bb.1: ; %loop2a.preheader\n+; DISABLE-NEXT:    mov x8, xzr\n+; DISABLE-NEXT:    mov x9, xzr\n+; DISABLE-NEXT:    mov x11, xzr\n+; DISABLE-NEXT:    b LBB12_3\n+; DISABLE-NEXT:  LBB12_2: ; %loop2b\n+; DISABLE-NEXT:    ; in Loop: Header=BB12_3 Depth=1\n+; DISABLE-NEXT:    str x10, [x11]\n+; DISABLE-NEXT:    mov x11, x10\n+; DISABLE-NEXT:  LBB12_3: ; %loop1\n+; DISABLE-NEXT:    ; =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    mov x10, x9\n+; DISABLE-NEXT:    ldr x9, [x8]\n+; DISABLE-NEXT:    cbnz x8, LBB12_2\n+; DISABLE-NEXT:  ; %bb.4: ; in Loop: Header=BB12_3 Depth=1\n+; DISABLE-NEXT:    mov x8, x10\n+; DISABLE-NEXT:    mov x11, x10\n+; DISABLE-NEXT:    b LBB12_3\n+; DISABLE-NEXT:  LBB12_5: ; %end\n+; DISABLE-NEXT:    ret\n entry:\n   br i1 undef, label %loop2a, label %body\n \n@@ -628,22 +942,50 @@ end:\n \n ; Re-aligned stack pointer.  See bug 26642.  Avoid clobbering live\n ; values in the prologue when re-aligning the stack pointer.\n-; CHECK-LABEL: stack_realign:\n-; ENABLE-DAG: lsl w[[LSL1:[0-9]+]], w0, w1\n-; ENABLE-DAG: lsl w[[LSL2:[0-9]+]], w1, w0\n-; DISABLE-NOT: lsl w[[LSL1:[0-9]+]], w0, w1\n-; DISABLE-NOT: lsl w[[LSL2:[0-9]+]], w1, w0\n-; CHECK: stp x29, x30, [sp, #-16]!\n-; CHECK: mov x29, sp\n-; ENABLE-NOT: sub x[[LSL1]], sp, #16\n-; ENABLE-NOT: sub x[[LSL2]], sp, #16\n-; DISABLE: sub x{{[0-9]+}}, sp, #16\n-; DISABLE-DAG: lsl w[[LSL1:[0-9]+]], w0, w1\n-; DISABLE-DAG: lsl w[[LSL2:[0-9]+]], w1, w0\n-; CHECK-DAG: str w[[LSL1]],\n-; CHECK-DAG: str w[[LSL2]],\n-\n define i32 @stack_realign(i32 %a, i32 %b, i32* %ptr1, i32* %ptr2) {\n+; ENABLE-LABEL: stack_realign:\n+; ENABLE:       ; %bb.0:\n+; ENABLE-NEXT:    stp x29, x30, [sp, #-16]! ; 16-byte Folded Spill\n+; ENABLE-NEXT:    mov x29, sp\n+; ENABLE-NEXT:    sub x9, sp, #16 ; =16\n+; ENABLE-NEXT:    and sp, x9, #0xffffffffffffffe0\n+; ENABLE-NEXT:    .cfi_def_cfa w29, 16\n+; ENABLE-NEXT:    .cfi_offset w30, -8\n+; ENABLE-NEXT:    .cfi_offset w29, -16\n+; ENABLE-NEXT:    lsl w8, w0, w1\n+; ENABLE-NEXT:    cmp w0, w1\n+; ENABLE-NEXT:    lsl w9, w1, w0\n+; ENABLE-NEXT:    b.ge LBB13_2\n+; ENABLE-NEXT:  ; %bb.1: ; %true\n+; ENABLE-NEXT:    str w0, [sp]\n+; ENABLE-NEXT:  LBB13_2: ; %false\n+; ENABLE-NEXT:    str w8, [x2]\n+; ENABLE-NEXT:    str w9, [x3]\n+; ENABLE-NEXT:    mov sp, x29\n+; ENABLE-NEXT:    ldp x29, x30, [sp], #16 ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ret\n+;\n+; DISABLE-LABEL: stack_realign:\n+; DISABLE:       ; %bb.0:\n+; DISABLE-NEXT:    stp x29, x30, [sp, #-16]! ; 16-byte Folded Spill\n+; DISABLE-NEXT:    mov x29, sp\n+; DISABLE-NEXT:    sub x9, sp, #16 ; =16\n+; DISABLE-NEXT:    and sp, x9, #0xffffffffffffffe0\n+; DISABLE-NEXT:    .cfi_def_cfa w29, 16\n+; DISABLE-NEXT:    .cfi_offset w30, -8\n+; DISABLE-NEXT:    .cfi_offset w29, -16\n+; DISABLE-NEXT:    lsl w8, w0, w1\n+; DISABLE-NEXT:    cmp w0, w1\n+; DISABLE-NEXT:    lsl w9, w1, w0\n+; DISABLE-NEXT:    b.ge LBB13_2\n+; DISABLE-NEXT:  ; %bb.1: ; %true\n+; DISABLE-NEXT:    str w0, [sp]\n+; DISABLE-NEXT:  LBB13_2: ; %false\n+; DISABLE-NEXT:    str w8, [x2]\n+; DISABLE-NEXT:    str w9, [x3]\n+; DISABLE-NEXT:    mov sp, x29\n+; DISABLE-NEXT:    ldp x29, x30, [sp], #16 ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ret\n   %tmp = alloca i32, align 32\n   %shl1 = shl i32 %a, %b\n   %shl2 = shl i32 %b, %a\n@@ -667,12 +1009,126 @@ false:\n ; ensuring we have a scratch register to re-align the stack pointer is\n ; too complicated.  Output should be the same for both enabled and\n ; disabled shrink wrapping.\n-; CHECK-LABEL: stack_realign2:\n-; CHECK: stp {{x[0-9]+}}, {{x[0-9]+}}, [sp, #-{{[0-9]+}}]!\n-; CHECK: add x29, sp, #{{[0-9]+}}\n-; CHECK: lsl {{w[0-9]+}}, w0, w1\n-\n define void @stack_realign2(i32 %a, i32 %b, i32* %ptr1, i32* %ptr2, i32* %ptr3, i32* %ptr4, i32* %ptr5, i32* %ptr6) {\n+; ENABLE-LABEL: stack_realign2:\n+; ENABLE:       ; %bb.0:\n+; ENABLE-NEXT:    stp x28, x27, [sp, #-96]! ; 16-byte Folded Spill\n+; ENABLE-NEXT:    stp x26, x25, [sp, #16] ; 16-byte Folded Spill\n+; ENABLE-NEXT:    stp x24, x23, [sp, #32] ; 16-byte Folded Spill\n+; ENABLE-NEXT:    stp x22, x21, [sp, #48] ; 16-byte Folded Spill\n+; ENABLE-NEXT:    stp x20, x19, [sp, #64] ; 16-byte Folded Spill\n+; ENABLE-NEXT:    stp x29, x30, [sp, #80] ; 16-byte Folded Spill\n+; ENABLE-NEXT:    add x29, sp, #80 ; =80\n+; ENABLE-NEXT:    sub x9, sp, #32 ; =32\n+; ENABLE-NEXT:    and sp, x9, #0xffffffffffffffe0\n+; ENABLE-NEXT:    .cfi_def_cfa w29, 16\n+; ENABLE-NEXT:    .cfi_offset w30, -8\n+; ENABLE-NEXT:    .cfi_offset w29, -16\n+; ENABLE-NEXT:    .cfi_offset w19, -24\n+; ENABLE-NEXT:    .cfi_offset w20, -32\n+; ENABLE-NEXT:    .cfi_offset w21, -40\n+; ENABLE-NEXT:    .cfi_offset w22, -48\n+; ENABLE-NEXT:    .cfi_offset w23, -56\n+; ENABLE-NEXT:    .cfi_offset w24, -64\n+; ENABLE-NEXT:    .cfi_offset w25, -72\n+; ENABLE-NEXT:    .cfi_offset w26, -80\n+; ENABLE-NEXT:    .cfi_offset w27, -88\n+; ENABLE-NEXT:    .cfi_offset w28, -96\n+; ENABLE-NEXT:    lsl w8, w0, w1\n+; ENABLE-NEXT:    lsl w9, w1, w0\n+; ENABLE-NEXT:    lsr w10, w0, w1\n+; ENABLE-NEXT:    lsr w11, w1, w0\n+; ENABLE-NEXT:    add w12, w1, w0\n+; ENABLE-NEXT:    sub w13, w1, w0\n+; ENABLE-NEXT:    cmp w0, w1\n+; ENABLE-NEXT:    add w17, w8, w9\n+; ENABLE-NEXT:    sub w16, w9, w10\n+; ENABLE-NEXT:    add w15, w10, w11\n+; ENABLE-NEXT:    add w14, w11, w12\n+; ENABLE-NEXT:    b.ge LBB14_2\n+; ENABLE-NEXT:  ; %bb.1: ; %true\n+; ENABLE-NEXT:    str w0, [sp]\n+; ENABLE-NEXT:    ; InlineAsm Start\n+; ENABLE-NEXT:    nop\n+; ENABLE-NEXT:    ; InlineAsm End\n+; ENABLE-NEXT:  LBB14_2: ; %false\n+; ENABLE-NEXT:    str w8, [x2]\n+; ENABLE-NEXT:    str w9, [x3]\n+; ENABLE-NEXT:    str w10, [x4]\n+; ENABLE-NEXT:    str w11, [x5]\n+; ENABLE-NEXT:    str w12, [x6]\n+; ENABLE-NEXT:    str w13, [x7]\n+; ENABLE-NEXT:    stp w0, w1, [x2, #4]\n+; ENABLE-NEXT:    stp w17, w16, [x2, #12]\n+; ENABLE-NEXT:    stp w15, w14, [x2, #20]\n+; ENABLE-NEXT:    sub sp, x29, #80 ; =80\n+; ENABLE-NEXT:    ldp x29, x30, [sp, #80] ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ldp x20, x19, [sp, #64] ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ldp x22, x21, [sp, #48] ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ldp x24, x23, [sp, #32] ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ldp x26, x25, [sp, #16] ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ldp x28, x27, [sp], #96 ; 16-byte Folded Reload\n+; ENABLE-NEXT:    ret\n+;\n+; DISABLE-LABEL: stack_realign2:\n+; DISABLE:       ; %bb.0:\n+; DISABLE-NEXT:    stp x28, x27, [sp, #-96]! ; 16-byte Folded Spill\n+; DISABLE-NEXT:    stp x26, x25, [sp, #16] ; 16-byte Folded Spill\n+; DISABLE-NEXT:    stp x24, x23, [sp, #32] ; 16-byte Folded Spill\n+; DISABLE-NEXT:    stp x22, x21, [sp, #48] ; 16-byte Folded Spill\n+; DISABLE-NEXT:    stp x20, x19, [sp, #64] ; 16-byte Folded Spill\n+; DISABLE-NEXT:    stp x29, x30, [sp, #80] ; 16-byte Folded Spill\n+; DISABLE-NEXT:    add x29, sp, #80 ; =80\n+; DISABLE-NEXT:    sub x9, sp, #32 ; =32\n+; DISABLE-NEXT:    and sp, x9, #0xffffffffffffffe0\n+; DISABLE-NEXT:    .cfi_def_cfa w29, 16\n+; DISABLE-NEXT:    .cfi_offset w30, -8\n+; DISABLE-NEXT:    .cfi_offset w29, -16\n+; DISABLE-NEXT:    .cfi_offset w19, -24\n+; DISABLE-NEXT:    .cfi_offset w20, -32\n+; DISABLE-NEXT:    .cfi_offset w21, -40\n+; DISABLE-NEXT:    .cfi_offset w22, -48\n+; DISABLE-NEXT:    .cfi_offset w23, -56\n+; DISABLE-NEXT:    .cfi_offset w24, -64\n+; DISABLE-NEXT:    .cfi_offset w25, -72\n+; DISABLE-NEXT:    .cfi_offset w26, -80\n+; DISABLE-NEXT:    .cfi_offset w27, -88\n+; DISABLE-NEXT:    .cfi_offset w28, -96\n+; DISABLE-NEXT:    lsl w8, w0, w1\n+; DISABLE-NEXT:    lsl w9, w1, w0\n+; DISABLE-NEXT:    lsr w10, w0, w1\n+; DISABLE-NEXT:    lsr w11, w1, w0\n+; DISABLE-NEXT:    add w12, w1, w0\n+; DISABLE-NEXT:    sub w13, w1, w0\n+; DISABLE-NEXT:    cmp w0, w1\n+; DISABLE-NEXT:    add w17, w8, w9\n+; DISABLE-NEXT:    sub w16, w9, w10\n+; DISABLE-NEXT:    add w15, w10, w11\n+; DISABLE-NEXT:    add w14, w11, w12\n+; DISABLE-NEXT:    b.ge LBB14_2\n+; DISABLE-NEXT:  ; %bb.1: ; %true\n+; DISABLE-NEXT:    str w0, [sp]\n+; DISABLE-NEXT:    ; InlineAsm Start\n+; DISABLE-NEXT:    nop\n+; DISABLE-NEXT:    ; InlineAsm End\n+; DISABLE-NEXT:  LBB14_2: ; %false\n+; DISABLE-NEXT:    str w8, [x2]\n+; DISABLE-NEXT:    str w9, [x3]\n+; DISABLE-NEXT:    str w10, [x4]\n+; DISABLE-NEXT:    str w11, [x5]\n+; DISABLE-NEXT:    str w12, [x6]\n+; DISABLE-NEXT:    str w13, [x7]\n+; DISABLE-NEXT:    stp w0, w1, [x2, #4]\n+; DISABLE-NEXT:    stp w17, w16, [x2, #12]\n+; DISABLE-NEXT:    stp w15, w14, [x2, #20]\n+; DISABLE-NEXT:    sub sp, x29, #80 ; =80\n+; DISABLE-NEXT:    ldp x29, x30, [sp, #80] ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ldp x20, x19, [sp, #64] ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ldp x22, x21, [sp, #48] ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ldp x24, x23, [sp, #32] ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ldp x26, x25, [sp, #16] ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ldp x28, x27, [sp], #96 ; 16-byte Folded Reload\n+; DISABLE-NEXT:    ret\n   %tmp = alloca i32, align 32\n   %tmp1 = shl i32 %a, %b\n   %tmp2 = shl i32 %b, %a"
            },
            {
                "fn": "llvm/test/CodeGen/AArch64/branch-relax-cbz.ll",
                "patch": "@@ -1,28 +1,28 @@\n+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py\n ; RUN: llc -mtriple=aarch64-apple-darwin -aarch64-cbz-offset-bits=3 < %s | FileCheck %s\n \n-; CHECK-LABEL: _split_block_no_fallthrough:\n-; CHECK: cmn x{{[0-9]+}}, #5\n-; CHECK-NEXT: b.le [[B2:LBB[0-9]+_[0-9]+]]\n-\n-; CHECK-NEXT: ; %bb.1: ; %b3\n-; CHECK: ldr [[LOAD:w[0-9]+]]\n-; CHECK: cbnz [[LOAD]], [[B8:LBB[0-9]+_[0-9]+]]\n-; CHECK-NEXT: b [[B7:LBB[0-9]+_[0-9]+]]\n-\n-; CHECK-NEXT: [[B8]]: ; %b8\n-; CHECK-NEXT: ret\n-\n-; CHECK-NEXT: [[B2]]: ; %b2\n-; CHECK: mov w{{[0-9]+}}, #93\n-; CHECK: bl _extfunc\n-; CHECK: cbz w{{[0-9]+}}, [[B7]]\n-; CHECK-NEXT: b [[B8]]\n-\n-; CHECK-NEXT: [[B7]]: ; %b7\n-; CHECK: mov w{{[0-9]+}}, #13\n-; CHECK: b _extfunc\n \n define void @split_block_no_fallthrough(i64 %val) #0 {\n+; CHECK-LABEL: split_block_no_fallthrough:\n+; CHECK:       ; %bb.0: ; %bb\n+; CHECK-NEXT:    stp x29, x30, [sp, #-16]! ; 16-byte Folded Spill\n+; CHECK-NEXT:    cmn x0, #5 ; =5\n+; CHECK-NEXT:    b.le LBB0_3\n+; CHECK-NEXT:  ; %bb.1: ; %b3\n+; CHECK-NEXT:    ldr w8, [x8]\n+; CHECK-NEXT:    cbnz w8, LBB0_2\n+; CHECK-NEXT:    b LBB0_4\n+; CHECK-NEXT:  LBB0_2: ; %b8\n+; CHECK-NEXT:    ldp x29, x30, [sp], #16 ; 16-byte Folded Reload\n+; CHECK-NEXT:    ret\n+; CHECK-NEXT:  LBB0_3: ; %b2\n+; CHECK-NEXT:    mov w0, #93\n+; CHECK-NEXT:    bl _extfunc\n+; CHECK-NEXT:    cbnz w0, LBB0_2\n+; CHECK-NEXT:  LBB0_4: ; %b7\n+; CHECK-NEXT:    mov w0, #13\n+; CHECK-NEXT:    ldp x29, x30, [sp], #16 ; 16-byte Folded Reload\n+; CHECK-NEXT:    b _extfunc\n bb:\n   %c0 = icmp sgt i64 %val, -5\n   br i1 %c0, label %b3, label %b2"
            },
            {
                "fn": "llvm/test/CodeGen/AArch64/dont-shrink-wrap-stack-mayloadorstore.mir",
                "patch": "@@ -0,0 +1,229 @@\n+--- |\n+ ; pr37472\n+ ; These test verify that shrink-wrap does not set the restore point\n+ ; to a position where the stack might still be accessed by a load or store\n+ \n+ ; RUN: llc -x=mir -simplify-mir -run-pass=shrink-wrap -o - %s | FileCheck %s\n+ ; CHECK:      name:            compiler_pop_stack\n+ ; CHECK:      frameInfo:       \n+ ; CHECK-NOT:  savePoint:\n+ ; CHECK-NOT:  restorePoint:\n+ ; CHECK:      stack:\n+ ; CHECK:      name:            f\n+ ; CHECK:      frameInfo:       \n+ ; CHECK:      savePoint:       '%bb.2'\n+ ; CHECK-NEXT: restorePoint:    '%bb.4'\n+ ; CHECK-NEXT: stack:\n+\n+  target datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\"\n+  target triple = \"aarch64-arm-none-eabi\"\n+\n+  %struct.S = type { i32, i32 }\n+\n+  @__const.f.arr = private unnamed_addr constant [4 x i8] c\"\\01\\02\\03\\04\", align 1\n+\n+\n+  declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture)\n+\n+\n+  declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture)\n+\n+\n+  declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1 immarg)\n+ ; Test from: https://bugs.llvm.org/show_bug.cgi?id=42136\n+  define void @compiler_pop_stack(i32 %num) {\n+  entry:\n+    %rstack = alloca [16 x i32], align 4\n+    %tmp = bitcast [16 x i32]* %rstack to i8*\n+    call void @llvm.lifetime.start.p0i8(i64 64, i8* nonnull %tmp)\n+    %cmp = icmp ult i32 %num, 2\n+    br i1 %cmp, label %cleanup, label %if.end\n+\n+  if.end:\n+    %arrayidx1 = bitcast [16 x i32]* %rstack to i32*\n+    store volatile i32 %num, i32* %arrayidx1, align 4\n+    br label %while.body\n+\n+  while.body:\n+    %ptr.017 = phi i32 [ 1, %if.end ], [ %ptr.1, %if.end7 ]\n+    %dec = add i32 %ptr.017, -1\n+    %idxprom = zext i32 %dec to i64\n+    %arrayidx2 = getelementptr inbounds [16 x i32], [16 x i32]* %rstack, i64 0, i64 %idxprom\n+    %tmp1 = load volatile i32, i32* %arrayidx2, align 4\n+    %cmp3 = icmp eq i32 %tmp1, 0\n+    br i1 %cmp3, label %if.end7, label %if.then4\n+\n+  if.then4:\n+    %sunkaddr = mul i64 %idxprom, 4\n+    %0 = bitcast [16 x i32]* %rstack to i8*\n+    %sunkaddr2 = getelementptr inbounds i8, i8* %0, i64 %sunkaddr\n+    %1 = bitcast i8* %sunkaddr2 to i32*\n+    store volatile i32 %tmp1, i32* %1, align 4\n+    br label %if.end7\n+\n+  if.end7:\n+    %ptr.1 = phi i32 [ %ptr.017, %if.then4 ], [ %dec, %while.body ]\n+    %cmp1 = icmp eq i32 %ptr.1, 0\n+    br i1 %cmp1, label %cleanup, label %while.body\n+\n+  cleanup:\n+    %2 = bitcast [16 x i32]* %rstack to i8*\n+    call void @llvm.lifetime.end.p0i8(i64 64, i8* nonnull %2)\n+    ret void\n+  }\n+ ; Test from: https://bugs.llvm.org/show_bug.cgi?id=37472\n+  define i32 @f(%struct.S* nocapture %arg, i32 %arg1) {\n+  bb:\n+    %tmp = alloca [4 x i8], align 1\n+    %tmp2 = icmp ugt i32 %arg1, 4\n+    br i1 %tmp2, label %bb16, label %bb3\n+\n+  bb3:\n+    %tmp41 = bitcast [4 x i8]* %tmp to i8*\n+    call void @llvm.lifetime.start.p0i8(i64 4, i8* nonnull %tmp41)\n+    call void @llvm.memcpy.p0i8.p0i8.i64(i8* nonnull align 1 %tmp41, i8* align 1 getelementptr inbounds ([4 x i8], [4 x i8]* @__const.f.arr, i64 0, i64 0), i64 4, i1 true)\n+    %tmp5 = zext i32 %arg1 to i64\n+    %tmp6 = getelementptr inbounds [4 x i8], [4 x i8]* %tmp, i64 0, i64 %tmp5\n+    %tmp7 = load volatile i8, i8* %tmp6, align 1\n+    %tmp8 = zext i8 %tmp7 to i32\n+    %tmp92 = bitcast %struct.S* %arg to i32*\n+    store i32 %tmp8, i32* %tmp92, align 4\n+    %tmp10 = icmp ult i32 %arg1, 3\n+    br i1 %tmp10, label %bb11, label %bb15\n+\n+  bb11:\n+    %0 = bitcast [4 x i8]* %tmp to i8*\n+    %sunkaddr = getelementptr inbounds i8, i8* %0, i64 %tmp5\n+    %tmp12 = load volatile i8, i8* %sunkaddr, align 1\n+    %tmp13 = zext i8 %tmp12 to i32\n+    %tmp14 = getelementptr inbounds %struct.S, %struct.S* %arg, i64 0, i32 1\n+    store i32 %tmp13, i32* %tmp14, align 4\n+    br label %bb15\n+\n+  bb15:\n+    %1 = bitcast [4 x i8]* %tmp to i8*\n+    call void @llvm.lifetime.end.p0i8(i64 4, i8* nonnull %1)\n+    br label %bb16\n+\n+  bb16:\n+    %tmp17 = phi i32 [ 0, %bb15 ], [ 1, %bb ]\n+    ret i32 %tmp17\n+  }\n+\n+\n+  declare void @llvm.stackprotector(i8*, i8**)\n+\n+...\n+---\n+name:            compiler_pop_stack\n+alignment:       2\n+tracksRegLiveness: true\n+liveins:\n+  - { reg: '$w0' }\n+frameInfo:\n+  maxAlignment:    4\n+  maxCallFrameSize: 0\n+  localFrameSize:  64\n+stack:\n+  - { id: 0, name: rstack, size: 64, alignment: 4, stack-id: 0, local-offset: -64 }\n+machineFunctionInfo: {}\n+body:             |\n+  bb.0.entry:\n+    liveins: $w0\n+\n+    dead $wzr = SUBSWri renamable $w0, 2, 0, implicit-def $nzcv\n+    Bcc 3, %bb.6, implicit killed $nzcv\n+    B %bb.1\n+\n+  bb.1.if.end:\n+    liveins: $w0\n+\n+    STRWui killed renamable $w0, %stack.0.rstack, 0 :: (volatile store 4 into %ir.arrayidx1)\n+    renamable $w9 = MOVi32imm 1\n+    renamable $x8 = ADDXri %stack.0.rstack, 0, 0\n+\n+  bb.2.while.body:\n+    successors: %bb.3(0x30000000), %bb.4(0x50000000)\n+    liveins: $w9, $x8\n+\n+    renamable $w10 = SUBWri renamable $w9, 1, 0, implicit-def $x10\n+    renamable $w11 = LDRWroW renamable $x8, renamable $w10, 0, 1 :: (volatile load 4 from %ir.arrayidx2)\n+    CBNZW renamable $w11, %bb.4\n+\n+  bb.3:\n+    liveins: $x8, $x10\n+\n+    renamable $w9 = COPY renamable $w10, implicit killed $x10\n+    B %bb.5\n+\n+  bb.4.if.then4:\n+    liveins: $w9, $w11, $x8, $x10\n+\n+    STRWroX killed renamable $w11, renamable $x8, killed renamable $x10, 0, 1 :: (volatile store 4 into %ir.1)\n+\n+  bb.5.if.end7:\n+    successors: %bb.6(0x04000000), %bb.2(0x7c000000)\n+    liveins: $w9, $x8\n+\n+    CBNZW renamable $w9, %bb.2\n+    B %bb.6\n+\n+  bb.6.cleanup:\n+    RET_ReallyLR\n+\n+...\n+---\n+name:            f\n+alignment:       2\n+tracksRegLiveness: true\n+liveins:\n+  - { reg: '$x0' }\n+  - { reg: '$w1' }\n+frameInfo:\n+  maxAlignment:    4\n+  maxCallFrameSize: 0\n+  localFrameSize:  4\n+stack:\n+  - { id: 0, name: tmp, size: 4, alignment: 4, stack-id: 0, local-offset: -4 }\n+machineFunctionInfo: {}\n+body:             |\n+  bb.0.bb:\n+    successors: %bb.1, %bb.2\n+    liveins: $w1, $x0\n+\n+    dead $wzr = SUBSWri renamable $w1, 4, 0, implicit-def $nzcv\n+    Bcc 9, %bb.2, implicit killed $nzcv\n+\n+  bb.1:\n+    renamable $w0 = MOVi32imm 1\n+    B %bb.5\n+\n+  bb.2.bb3:\n+    successors: %bb.3, %bb.4\n+    liveins: $w1, $x0\n+\n+    renamable $w9 = MOVi32imm 67305985\n+    renamable $w8 = ORRWrs $wzr, renamable $w1, 0, implicit-def $x8\n+    STRWui killed renamable $w9, %stack.0.tmp, 0 :: (volatile store 4 into %ir.tmp41)\n+    renamable $x9 = ADDXri %stack.0.tmp, 0, 0\n+    renamable $w10 = LDRBBroX renamable $x9, renamable $x8, 0, 0 :: (volatile load 1 from %ir.tmp6)\n+    dead $wzr = SUBSWri killed renamable $w1, 2, 0, implicit-def $nzcv\n+    STRWui killed renamable $w10, renamable $x0, 0 :: (store 4 into %ir.tmp92)\n+    Bcc 8, %bb.4, implicit killed $nzcv\n+    B %bb.3\n+\n+  bb.3.bb11:\n+    liveins: $x0, $x8, $x9\n+\n+    renamable $w8 = LDRBBroX killed renamable $x9, killed renamable $x8, 0, 0 :: (volatile load 1 from %ir.sunkaddr)\n+    STRWui killed renamable $w8, killed renamable $x0, 1 :: (store 4 into %ir.tmp14)\n+\n+  bb.4.bb15:\n+    renamable $w0 = COPY $wzr\n+\n+  bb.5.bb16:\n+    liveins: $w0\n+\n+    RET_ReallyLR implicit $w0\n+\n+..."
            },
            {
                "fn": "llvm/test/CodeGen/AArch64/taildup-cfi.ll",
                "patch": "@@ -32,7 +32,7 @@ if.then:                                          ; preds = %entry\n   store i32 0, i32* @f, align 4, !tbaa !2\n   br label %if.end\n \n-; DARWIN-NOT:       Merging into block\n+; DARWIN:           Merging into block\n ; LINUX:    \t      Merging into block\n \n if.end:                                           ; preds = %entry.if.end_crit_edge, %if.then"
            },
            {
                "fn": "llvm/test/CodeGen/ARM/arm-shrink-wrapping-linux.ll",
                "patch": "@@ -1,5 +1,6 @@\n-; RUN: llc %s -o - -enable-shrink-wrap=true | FileCheck %s --check-prefix=CHECK --check-prefix=ENABLE\n-; RUN: llc %s -o - -enable-shrink-wrap=false | FileCheck %s --check-prefix=CHECK --check-prefix=DISABLE\n+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py\n+; RUN: llc %s -o - -enable-shrink-wrap=true | FileCheck %s --check-prefix=ENABLE\n+; RUN: llc %s -o - -enable-shrink-wrap=false | FileCheck %s --check-prefix=DISABLE\n ; We cannot merge this test with the main test for shrink-wrapping, because\n ; the code path we want to exerce is not taken with ios lowering.\n target datalayout = \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n8:16:32-S64\"\n@@ -12,53 +13,185 @@ target triple = \"armv7--linux-gnueabi\"\n ; The exit block of the loop happens to also lead to defs/uses of CSRs.\n ; It also post-dominates the loop body and we use to generate invalid\n ; restore sequence. I.e., we restored too early.\n-;\n-; CHECK-LABEL: wrongUseOfPostDominate:\n-;\n-; The prologue is the first thing happening in the function\n-; without shrink-wrapping.\n-; DISABLE: push\n-;\n-; CHECK: cmn r1, #1\n-;\n-; With shrink-wrapping, we branch to a pre-header, where the prologue\n-; is located.\n-; ENABLE-NEXT: ble [[LOOP_PREHEADER:[.a-zA-Z0-9_]+]]\n-; Without shrink-wrapping, we go straight into the loop.\n-; DISABLE-NEXT: ble [[LOOP_HEADER:[.a-zA-Z0-9_]+]]\n-;\n-; CHECK: @ %if.end29\n-; DISABLE-NEXT: pop\n-; ENABLE-NEXT: bx lr\n-;\n-; ENABLE: [[LOOP_PREHEADER]]\n-; ENABLE: push\n-; We must not find a pop here, otherwise that means we are in the loop\n-; and are restoring before using the saved CSRs.\n-; ENABLE-NOT: pop\n-; ENALBE-NEXT: [[LOOP_HEADER:[.a-zA-Z0-9_]+]]: @ %while.cond2.outer\n-;\n-; DISABLE: [[LOOP_HEADER]]: @ %while.cond2.outer\n-;\n-; ENABLE-NOT: pop\n-;\n-; CHECK: @ %while.cond2\n-; CHECK: add\n-; CHECK-NEXT: cmp r{{[0-1]+}}, #1\n-; Jump to the return block\n-; CHECK-NEXT: beq [[RETURN_BLOCK:[.a-zA-Z0-9_]+]]\n-;\n-; Use the back edge to check we get the label of the loop right.\n-; This is to make sure we check the right loop pattern.\n-; CHECK:  @ %while.body24.land.rhs14_crit_edge\n-; CHECK: cmp r{{[0-9]+}}, #192\n-; CHECK-NEXT bhs [[LOOP_HEADER]]\n-;\n-; CHECK: [[RETURN_BLOCK]]:\n-; Set the return value.\n-; CHECK-NEXT: mov r0,\n-; CHECK-NEXT: pop\n+\n define fastcc i8* @wrongUseOfPostDominate(i8* readonly %s, i32 %off, i8* readnone %lim) {\n+; ENABLE-LABEL: wrongUseOfPostDominate:\n+; ENABLE:       @ %bb.0: @ %entry\n+; ENABLE-NEXT:    .save {r11, lr}\n+; ENABLE-NEXT:    push {r11, lr}\n+; ENABLE-NEXT:    cmn r1, #1\n+; ENABLE-NEXT:    ble .LBB0_6\n+; ENABLE-NEXT:  @ %bb.1: @ %while.cond.preheader\n+; ENABLE-NEXT:    cmp r1, #0\n+; ENABLE-NEXT:    beq .LBB0_5\n+; ENABLE-NEXT:  @ %bb.2: @ %while.cond.preheader\n+; ENABLE-NEXT:    cmp r0, r2\n+; ENABLE-NEXT:    pophs {r11, pc}\n+; ENABLE-NEXT:    movw r12, :lower16:skip\n+; ENABLE-NEXT:    sub r1, r1, #1\n+; ENABLE-NEXT:    movt r12, :upper16:skip\n+; ENABLE-NEXT:  .LBB0_3: @ %while.body\n+; ENABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    ldrb r3, [r0]\n+; ENABLE-NEXT:    ldrb r3, [r12, r3]\n+; ENABLE-NEXT:    add r0, r0, r3\n+; ENABLE-NEXT:    sub r3, r1, #1\n+; ENABLE-NEXT:    cmp r3, r1\n+; ENABLE-NEXT:    bhs .LBB0_5\n+; ENABLE-NEXT:  @ %bb.4: @ %while.body\n+; ENABLE-NEXT:    @ in Loop: Header=BB0_3 Depth=1\n+; ENABLE-NEXT:    cmp r0, r2\n+; ENABLE-NEXT:    mov r1, r3\n+; ENABLE-NEXT:    blo .LBB0_3\n+; ENABLE-NEXT:  .LBB0_5: @ %if.end29\n+; ENABLE-NEXT:    pop {r11, pc}\n+; ENABLE-NEXT:  .LBB0_6: @ %while.cond2.outer\n+; ENABLE-NEXT:    @ =>This Loop Header: Depth=1\n+; ENABLE-NEXT:    @ Child Loop BB0_7 Depth 2\n+; ENABLE-NEXT:    @ Child Loop BB0_14 Depth 2\n+; ENABLE-NEXT:    mov r3, r0\n+; ENABLE-NEXT:  .LBB0_7: @ %while.cond2\n+; ENABLE-NEXT:    @ Parent Loop BB0_6 Depth=1\n+; ENABLE-NEXT:    @ => This Inner Loop Header: Depth=2\n+; ENABLE-NEXT:    add r1, r1, #1\n+; ENABLE-NEXT:    cmp r1, #1\n+; ENABLE-NEXT:    beq .LBB0_17\n+; ENABLE-NEXT:  @ %bb.8: @ %while.body4\n+; ENABLE-NEXT:    @ in Loop: Header=BB0_7 Depth=2\n+; ENABLE-NEXT:    cmp r3, r2\n+; ENABLE-NEXT:    bls .LBB0_7\n+; ENABLE-NEXT:  @ %bb.9: @ %if.then7\n+; ENABLE-NEXT:    @ in Loop: Header=BB0_6 Depth=1\n+; ENABLE-NEXT:    mov r0, r3\n+; ENABLE-NEXT:    ldrb r12, [r0, #-1]!\n+; ENABLE-NEXT:    sxtb lr, r12\n+; ENABLE-NEXT:    cmn lr, #1\n+; ENABLE-NEXT:    bgt .LBB0_6\n+; ENABLE-NEXT:  @ %bb.10: @ %if.then7\n+; ENABLE-NEXT:    @ in Loop: Header=BB0_6 Depth=1\n+; ENABLE-NEXT:    cmp r0, r2\n+; ENABLE-NEXT:    bls .LBB0_6\n+; ENABLE-NEXT:  @ %bb.11: @ %land.rhs14.preheader\n+; ENABLE-NEXT:    @ in Loop: Header=BB0_6 Depth=1\n+; ENABLE-NEXT:    cmn lr, #1\n+; ENABLE-NEXT:    bgt .LBB0_6\n+; ENABLE-NEXT:  @ %bb.12: @ %land.rhs14.preheader\n+; ENABLE-NEXT:    @ in Loop: Header=BB0_6 Depth=1\n+; ENABLE-NEXT:    cmp r12, #191\n+; ENABLE-NEXT:    bhi .LBB0_6\n+; ENABLE-NEXT:  @ %bb.13: @ %while.body24.preheader\n+; ENABLE-NEXT:    @ in Loop: Header=BB0_6 Depth=1\n+; ENABLE-NEXT:    sub r3, r3, #2\n+; ENABLE-NEXT:  .LBB0_14: @ %while.body24\n+; ENABLE-NEXT:    @ Parent Loop BB0_6 Depth=1\n+; ENABLE-NEXT:    @ => This Inner Loop Header: Depth=2\n+; ENABLE-NEXT:    mov r0, r3\n+; ENABLE-NEXT:    cmp r3, r2\n+; ENABLE-NEXT:    bls .LBB0_6\n+; ENABLE-NEXT:  @ %bb.15: @ %while.body24.land.rhs14_crit_edge\n+; ENABLE-NEXT:    @ in Loop: Header=BB0_14 Depth=2\n+; ENABLE-NEXT:    mov r3, r0\n+; ENABLE-NEXT:    ldrsb lr, [r3], #-1\n+; ENABLE-NEXT:    cmn lr, #1\n+; ENABLE-NEXT:    uxtb r12, lr\n+; ENABLE-NEXT:    bgt .LBB0_6\n+; ENABLE-NEXT:  @ %bb.16: @ %while.body24.land.rhs14_crit_edge\n+; ENABLE-NEXT:    @ in Loop: Header=BB0_14 Depth=2\n+; ENABLE-NEXT:    cmp r12, #192\n+; ENABLE-NEXT:    blo .LBB0_14\n+; ENABLE-NEXT:    b .LBB0_6\n+; ENABLE-NEXT:  .LBB0_17:\n+; ENABLE-NEXT:    mov r0, r3\n+; ENABLE-NEXT:    pop {r11, pc}\n+;\n+; DISABLE-LABEL: wrongUseOfPostDominate:\n+; DISABLE:       @ %bb.0: @ %entry\n+; DISABLE-NEXT:    .save {r11, lr}\n+; DISABLE-NEXT:    push {r11, lr}\n+; DISABLE-NEXT:    cmn r1, #1\n+; DISABLE-NEXT:    ble .LBB0_6\n+; DISABLE-NEXT:  @ %bb.1: @ %while.cond.preheader\n+; DISABLE-NEXT:    cmp r1, #0\n+; DISABLE-NEXT:    beq .LBB0_5\n+; DISABLE-NEXT:  @ %bb.2: @ %while.cond.preheader\n+; DISABLE-NEXT:    cmp r0, r2\n+; DISABLE-NEXT:    pophs {r11, pc}\n+; DISABLE-NEXT:    movw r12, :lower16:skip\n+; DISABLE-NEXT:    sub r1, r1, #1\n+; DISABLE-NEXT:    movt r12, :upper16:skip\n+; DISABLE-NEXT:  .LBB0_3: @ %while.body\n+; DISABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    ldrb r3, [r0]\n+; DISABLE-NEXT:    ldrb r3, [r12, r3]\n+; DISABLE-NEXT:    add r0, r0, r3\n+; DISABLE-NEXT:    sub r3, r1, #1\n+; DISABLE-NEXT:    cmp r3, r1\n+; DISABLE-NEXT:    bhs .LBB0_5\n+; DISABLE-NEXT:  @ %bb.4: @ %while.body\n+; DISABLE-NEXT:    @ in Loop: Header=BB0_3 Depth=1\n+; DISABLE-NEXT:    cmp r0, r2\n+; DISABLE-NEXT:    mov r1, r3\n+; DISABLE-NEXT:    blo .LBB0_3\n+; DISABLE-NEXT:  .LBB0_5: @ %if.end29\n+; DISABLE-NEXT:    pop {r11, pc}\n+; DISABLE-NEXT:  .LBB0_6: @ %while.cond2.outer\n+; DISABLE-NEXT:    @ =>This Loop Header: Depth=1\n+; DISABLE-NEXT:    @ Child Loop BB0_7 Depth 2\n+; DISABLE-NEXT:    @ Child Loop BB0_14 Depth 2\n+; DISABLE-NEXT:    mov r3, r0\n+; DISABLE-NEXT:  .LBB0_7: @ %while.cond2\n+; DISABLE-NEXT:    @ Parent Loop BB0_6 Depth=1\n+; DISABLE-NEXT:    @ => This Inner Loop Header: Depth=2\n+; DISABLE-NEXT:    add r1, r1, #1\n+; DISABLE-NEXT:    cmp r1, #1\n+; DISABLE-NEXT:    beq .LBB0_17\n+; DISABLE-NEXT:  @ %bb.8: @ %while.body4\n+; DISABLE-NEXT:    @ in Loop: Header=BB0_7 Depth=2\n+; DISABLE-NEXT:    cmp r3, r2\n+; DISABLE-NEXT:    bls .LBB0_7\n+; DISABLE-NEXT:  @ %bb.9: @ %if.then7\n+; DISABLE-NEXT:    @ in Loop: Header=BB0_6 Depth=1\n+; DISABLE-NEXT:    mov r0, r3\n+; DISABLE-NEXT:    ldrb r12, [r0, #-1]!\n+; DISABLE-NEXT:    sxtb lr, r12\n+; DISABLE-NEXT:    cmn lr, #1\n+; DISABLE-NEXT:    bgt .LBB0_6\n+; DISABLE-NEXT:  @ %bb.10: @ %if.then7\n+; DISABLE-NEXT:    @ in Loop: Header=BB0_6 Depth=1\n+; DISABLE-NEXT:    cmp r0, r2\n+; DISABLE-NEXT:    bls .LBB0_6\n+; DISABLE-NEXT:  @ %bb.11: @ %land.rhs14.preheader\n+; DISABLE-NEXT:    @ in Loop: Header=BB0_6 Depth=1\n+; DISABLE-NEXT:    cmn lr, #1\n+; DISABLE-NEXT:    bgt .LBB0_6\n+; DISABLE-NEXT:  @ %bb.12: @ %land.rhs14.preheader\n+; DISABLE-NEXT:    @ in Loop: Header=BB0_6 Depth=1\n+; DISABLE-NEXT:    cmp r12, #191\n+; DISABLE-NEXT:    bhi .LBB0_6\n+; DISABLE-NEXT:  @ %bb.13: @ %while.body24.preheader\n+; DISABLE-NEXT:    @ in Loop: Header=BB0_6 Depth=1\n+; DISABLE-NEXT:    sub r3, r3, #2\n+; DISABLE-NEXT:  .LBB0_14: @ %while.body24\n+; DISABLE-NEXT:    @ Parent Loop BB0_6 Depth=1\n+; DISABLE-NEXT:    @ => This Inner Loop Header: Depth=2\n+; DISABLE-NEXT:    mov r0, r3\n+; DISABLE-NEXT:    cmp r3, r2\n+; DISABLE-NEXT:    bls .LBB0_6\n+; DISABLE-NEXT:  @ %bb.15: @ %while.body24.land.rhs14_crit_edge\n+; DISABLE-NEXT:    @ in Loop: Header=BB0_14 Depth=2\n+; DISABLE-NEXT:    mov r3, r0\n+; DISABLE-NEXT:    ldrsb lr, [r3], #-1\n+; DISABLE-NEXT:    cmn lr, #1\n+; DISABLE-NEXT:    uxtb r12, lr\n+; DISABLE-NEXT:    bgt .LBB0_6\n+; DISABLE-NEXT:  @ %bb.16: @ %while.body24.land.rhs14_crit_edge\n+; DISABLE-NEXT:    @ in Loop: Header=BB0_14 Depth=2\n+; DISABLE-NEXT:    cmp r12, #192\n+; DISABLE-NEXT:    blo .LBB0_14\n+; DISABLE-NEXT:    b .LBB0_6\n+; DISABLE-NEXT:  .LBB0_17:\n+; DISABLE-NEXT:    mov r0, r3\n+; DISABLE-NEXT:    pop {r11, pc}\n entry:\n   %cmp = icmp sgt i32 %off, -1\n   br i1 %cmp, label %while.cond.preheader, label %while.cond2.outer"
            },
            {
                "fn": "llvm/test/CodeGen/ARM/arm-shrink-wrapping.ll",
                "patch": "@@ -1,11 +1,12 @@\n+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py\n ; RUN: llc %s -o - -enable-shrink-wrap=true -ifcvt-fn-start=1 -ifcvt-fn-stop=0 -mtriple=armv7-apple-ios \\\n-; RUN:      | FileCheck %s --check-prefix=CHECK --check-prefix=ARM --check-prefix=ENABLE --check-prefix=ARM-ENABLE\n+; RUN:      | FileCheck %s --check-prefix=ARM-ENABLE\n ; RUN: llc %s -o - -enable-shrink-wrap=false -ifcvt-fn-start=1 -ifcvt-fn-stop=0 -mtriple=armv7-apple-ios \\\n-; RUN:      | FileCheck %s --check-prefix=CHECK --check-prefix=ARM --check-prefix=DISABLE --check-prefix=ARM-DISABLE\n+; RUN:      | FileCheck %s --check-prefix=ARM-DISABLE\n ; RUN: llc %s -o - -enable-shrink-wrap=true -ifcvt-fn-start=1 -ifcvt-fn-stop=0 -mtriple=thumbv7-apple-ios \\\n-; RUN:      | FileCheck %s --check-prefix=CHECK --check-prefix=THUMB --check-prefix=ENABLE --check-prefix=THUMB-ENABLE\n+; RUN:      | FileCheck %s --check-prefix=THUMB-ENABLE\n ; RUN: llc %s -o - -enable-shrink-wrap=false -ifcvt-fn-start=1 -ifcvt-fn-stop=0 -mtriple=thumbv7-apple-ios \\\n-; RUN:      | FileCheck %s --check-prefix=CHECK --check-prefix=THUMB --check-prefix=DISABLE --check-prefix=THUMB-DISABLE\n+; RUN:      | FileCheck %s --check-prefix=THUMB-DISABLE\n \n ;\n ; Note: Lots of tests use inline asm instead of regular calls.\n@@ -18,48 +19,111 @@\n ; the diffs.\n \n ; Initial motivating example: Simple diamond with a call just on one side.\n-; CHECK-LABEL: foo:\n+; foo:\n ;\n ; Compare the arguments and jump to exit.\n ; No prologue needed.\n-; ENABLE: cmp r0, r1\n-; ENABLE-NEXT: bge [[EXIT_LABEL:LBB[0-9_]+]]\n+; cmp r0, r1\n+; bge [[EXIT_LABEL:LBB[0-9_]+]]\n ;\n ; Prologue code.\n-; CHECK: push {r7, lr}\n-; CHECK-NEXT: mov r7, sp\n+; push {r7, lr}\n+; mov r7, sp\n ;;\n ; Compare the arguments and jump to exit.\n ; After the prologue is set.\n-; DISABLE: sub sp\n-; DISABLE: cmp r0, r1\n-; DISABLE-NEXT: bge [[EXIT_LABEL:LBB[0-9_]+]]\n+; sub sp\n+; cmp r0, r1\n+; bge [[EXIT_LABEL:LBB[0-9_]+]]\n ;\n ; Store %a in the alloca.\n-; ARM-ENABLE: push {r0}\n-; THUMB-ENABLE: str r0, [sp, #-4]\n-; DISABLE: str r0, [sp]\n+; push {r0}\n+; str r0, [sp, #-4]\n+; str r0, [sp]\n ; Set the alloca address in the second argument.\n-; CHECK-NEXT: mov r1, sp\n+; mov r1, sp\n ; Set the first argument to zero.\n-; CHECK-NEXT: mov{{s?}} r0, #0\n-; CHECK-NEXT: bl{{x?}} _doSomething\n+; mov{{s?}} r0, #0\n+; bl{{x?}} _doSomething\n ;\n ; With shrink-wrapping, epilogue is just after the call.\n-; ARM-ENABLE-NEXT: mov sp, r7\n-; THUMB-ENABLE-NEXT: add sp, #4\n-; ENABLE-NEXT: pop{{(\\.w)?}} {r7, lr}\n+; mov sp, r7\n+; add sp, #4\n+; pop{{(\\.w)?}} {r7, lr}\n ;\n-; CHECK: [[EXIT_LABEL]]:\n+; [[EXIT_LABEL]]:\n ;\n ; Without shrink-wrapping, epilogue is in the exit block.\n ; Epilogue code. (What we pop does not matter.)\n-; ARM-DISABLE: mov sp, r7\n-; THUMB-DISABLE: add sp, \n-; DISABLE-NEXT: pop {r7, pc}\n+; mov sp, r7\n+; add sp,\n+; pop {r7, pc}\n ;\n-; ENABLE-NEXT: bx lr\n+; bx lr\n define i32 @foo(i32 %a, i32 %b) \"no-frame-pointer-elim\"=\"true\" {\n+; ARM-ENABLE-LABEL: foo:\n+; ARM-ENABLE:       @ %bb.0:\n+; ARM-ENABLE-NEXT:    cmp r0, r1\n+; ARM-ENABLE-NEXT:    bge LBB0_2\n+; ARM-ENABLE-NEXT:  @ %bb.1: @ %true\n+; ARM-ENABLE-NEXT:    push {r7, lr}\n+; ARM-ENABLE-NEXT:    mov r7, sp\n+; ARM-ENABLE-NEXT:    push {r0}\n+; ARM-ENABLE-NEXT:    mov r1, sp\n+; ARM-ENABLE-NEXT:    mov r0, #0\n+; ARM-ENABLE-NEXT:    bl _doSomething\n+; ARM-ENABLE-NEXT:    mov sp, r7\n+; ARM-ENABLE-NEXT:    pop {r7, lr}\n+; ARM-ENABLE-NEXT:  LBB0_2: @ %false\n+; ARM-ENABLE-NEXT:    bx lr\n+;\n+; ARM-DISABLE-LABEL: foo:\n+; ARM-DISABLE:       @ %bb.0:\n+; ARM-DISABLE-NEXT:    push {r7, lr}\n+; ARM-DISABLE-NEXT:    mov r7, sp\n+; ARM-DISABLE-NEXT:    sub sp, sp, #4\n+; ARM-DISABLE-NEXT:    cmp r0, r1\n+; ARM-DISABLE-NEXT:    bge LBB0_2\n+; ARM-DISABLE-NEXT:  @ %bb.1: @ %true\n+; ARM-DISABLE-NEXT:    str r0, [sp]\n+; ARM-DISABLE-NEXT:    mov r1, sp\n+; ARM-DISABLE-NEXT:    mov r0, #0\n+; ARM-DISABLE-NEXT:    bl _doSomething\n+; ARM-DISABLE-NEXT:  LBB0_2: @ %false\n+; ARM-DISABLE-NEXT:    mov sp, r7\n+; ARM-DISABLE-NEXT:    pop {r7, pc}\n+;\n+; THUMB-ENABLE-LABEL: foo:\n+; THUMB-ENABLE:       @ %bb.0:\n+; THUMB-ENABLE-NEXT:    cmp r0, r1\n+; THUMB-ENABLE-NEXT:    bge LBB0_2\n+; THUMB-ENABLE-NEXT:  @ %bb.1: @ %true\n+; THUMB-ENABLE-NEXT:    push {r7, lr}\n+; THUMB-ENABLE-NEXT:    mov r7, sp\n+; THUMB-ENABLE-NEXT:    str r0, [sp, #-4]!\n+; THUMB-ENABLE-NEXT:    mov r1, sp\n+; THUMB-ENABLE-NEXT:    movs r0, #0\n+; THUMB-ENABLE-NEXT:    bl _doSomething\n+; THUMB-ENABLE-NEXT:    add sp, #4\n+; THUMB-ENABLE-NEXT:    pop.w {r7, lr}\n+; THUMB-ENABLE-NEXT:  LBB0_2: @ %false\n+; THUMB-ENABLE-NEXT:    bx lr\n+;\n+; THUMB-DISABLE-LABEL: foo:\n+; THUMB-DISABLE:       @ %bb.0:\n+; THUMB-DISABLE-NEXT:    push {r7, lr}\n+; THUMB-DISABLE-NEXT:    mov r7, sp\n+; THUMB-DISABLE-NEXT:    sub sp, #4\n+; THUMB-DISABLE-NEXT:    cmp r0, r1\n+; THUMB-DISABLE-NEXT:    bge LBB0_2\n+; THUMB-DISABLE-NEXT:  @ %bb.1: @ %true\n+; THUMB-DISABLE-NEXT:    str r0, [sp]\n+; THUMB-DISABLE-NEXT:    mov r1, sp\n+; THUMB-DISABLE-NEXT:    movs r0, #0\n+; THUMB-DISABLE-NEXT:    bl _doSomething\n+; THUMB-DISABLE-NEXT:  LBB0_2: @ %false\n+; THUMB-DISABLE-NEXT:    add sp, #4\n+; THUMB-DISABLE-NEXT:    pop {r7, pc}\n   %tmp = alloca i32, align 4\n   %tmp2 = icmp slt i32 %a, %b\n   br i1 %tmp2, label %true, label %false\n@@ -80,51 +144,156 @@ declare i32 @doSomething(i32, i32*)\n \n ; Check that we do not perform the restore inside the loop whereas the save\n ; is outside.\n-; CHECK-LABEL: freqSaveAndRestoreOutsideLoop:\n+; freqSaveAndRestoreOutsideLoop:\n ;\n ; Shrink-wrapping allows to skip the prologue in the else case.\n-; ARM-ENABLE: cmp r0, #0\n-; ARM-ENABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-; THUMB-ENABLE: cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n+; cmp r0, #0\n+; beq [[ELSE_LABEL:LBB[0-9_]+]]\n+; cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n ;\n ; Prologue code.\n ; Make sure we save the CSR used in the inline asm: r4.\n-; CHECK: push {r4, r7, lr}\n-; CHECK-NEXT: add r7, sp, #4\n+; push {r4, r7, lr}\n+; add r7, sp, #4\n ;\n-; ARM-DISABLE: cmp r0, #0\n-; ARM-DISABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-; THUMB-DISABLE: cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n+; cmp r0, #0\n+; beq [[ELSE_LABEL:LBB[0-9_]+]]\n+; cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n ;\n ; SUM is in r0 because it is coalesced with the second\n ; argument on the else path.\n-; CHECK: mov{{s?}} [[SUM:r0]], #0\n-; CHECK-NEXT: mov{{s?}} [[IV:r[0-9]+]], #10\n+; mov{{s?}} [[SUM:r0]], #0\n+; mov{{s?}} [[IV:r[0-9]+]], #10\n ;\n ; Next BB.\n-; CHECK: [[LOOP:LBB[0-9_]+]]: @ %for.body\n-; CHECK: mov{{(\\.w)?}} [[TMP:r[0-9]+]], #1\n-; ARM: add [[SUM]], [[TMP]], [[SUM]]\n-; THUMB: add [[SUM]], [[TMP]]\n-; ARM-NEXT: subs [[IV]], [[IV]], #1\n-; THUMB-NEXT: subs [[IV]], #1\n-; CHECK-NEXT: bne [[LOOP]]\n+; [[LOOP:LBB[0-9_]+]]: @ %for.body\n+; mov{{(\\.w)?}} [[TMP:r[0-9]+]], #1\n+; add [[SUM]], [[TMP]], [[SUM]]\n+; add [[SUM]], [[TMP]]\n+; subs [[IV]], [[IV]], #1\n+; subs [[IV]], #1\n+; bne [[LOOP]]\n ;\n ; Next BB.\n ; SUM << 3.\n-; CHECK: lsl{{s?}} [[SUM]], [[SUM]], #3\n-; ENABLE-NEXT: pop {r4, r7, pc}\n+; lsl{{s?}} [[SUM]], [[SUM]], #3\n+; pop {r4, r7, pc}\n ;\n ; Duplicated epilogue.\n-; DISABLE: pop {r4, r7, pc}\n+; pop {r4, r7, pc}\n ;\n-; CHECK: [[ELSE_LABEL]]: @ %if.else\n+; [[ELSE_LABEL]]: @ %if.else\n ; Shift second argument by one and store into returned register.\n-; CHECK: lsl{{s?}} r0, r1, #1\n-; DISABLE-NEXT: pop {r4, r7, pc}\n+; lsl{{s?}} r0, r1, #1\n+; pop {r4, r7, pc}\n ;\n-; ENABLE-NEXT: bx lr\n+; bx lr\n define i32 @freqSaveAndRestoreOutsideLoop(i32 %cond, i32 %N) \"no-frame-pointer-elim\"=\"true\" {\n+; ARM-ENABLE-LABEL: freqSaveAndRestoreOutsideLoop:\n+; ARM-ENABLE:       @ %bb.0: @ %entry\n+; ARM-ENABLE-NEXT:    cmp r0, #0\n+; ARM-ENABLE-NEXT:    beq LBB1_4\n+; ARM-ENABLE-NEXT:  @ %bb.1: @ %for.preheader\n+; ARM-ENABLE-NEXT:    push {r4, r7, lr}\n+; ARM-ENABLE-NEXT:    add r7, sp, #4\n+; ARM-ENABLE-NEXT:    mov r0, #0\n+; ARM-ENABLE-NEXT:    mov r1, #10\n+; ARM-ENABLE-NEXT:    @ InlineAsm Start\n+; ARM-ENABLE-NEXT:    nop\n+; ARM-ENABLE-NEXT:    @ InlineAsm End\n+; ARM-ENABLE-NEXT:  LBB1_2: @ %for.body\n+; ARM-ENABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-ENABLE-NEXT:    @ InlineAsm Start\n+; ARM-ENABLE-NEXT:    mov r2, #1\n+; ARM-ENABLE-NEXT:    @ InlineAsm End\n+; ARM-ENABLE-NEXT:    add r0, r2, r0\n+; ARM-ENABLE-NEXT:    subs r1, r1, #1\n+; ARM-ENABLE-NEXT:    bne LBB1_2\n+; ARM-ENABLE-NEXT:  @ %bb.3: @ %for.end\n+; ARM-ENABLE-NEXT:    lsl r0, r0, #3\n+; ARM-ENABLE-NEXT:    pop {r4, r7, pc}\n+; ARM-ENABLE-NEXT:  LBB1_4: @ %if.else\n+; ARM-ENABLE-NEXT:    lsl r0, r1, #1\n+; ARM-ENABLE-NEXT:    bx lr\n+;\n+; ARM-DISABLE-LABEL: freqSaveAndRestoreOutsideLoop:\n+; ARM-DISABLE:       @ %bb.0: @ %entry\n+; ARM-DISABLE-NEXT:    push {r4, r7, lr}\n+; ARM-DISABLE-NEXT:    add r7, sp, #4\n+; ARM-DISABLE-NEXT:    cmp r0, #0\n+; ARM-DISABLE-NEXT:    beq LBB1_4\n+; ARM-DISABLE-NEXT:  @ %bb.1: @ %for.preheader\n+; ARM-DISABLE-NEXT:    mov r0, #0\n+; ARM-DISABLE-NEXT:    mov r1, #10\n+; ARM-DISABLE-NEXT:    @ InlineAsm Start\n+; ARM-DISABLE-NEXT:    nop\n+; ARM-DISABLE-NEXT:    @ InlineAsm End\n+; ARM-DISABLE-NEXT:  LBB1_2: @ %for.body\n+; ARM-DISABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-DISABLE-NEXT:    @ InlineAsm Start\n+; ARM-DISABLE-NEXT:    mov r2, #1\n+; ARM-DISABLE-NEXT:    @ InlineAsm End\n+; ARM-DISABLE-NEXT:    add r0, r2, r0\n+; ARM-DISABLE-NEXT:    subs r1, r1, #1\n+; ARM-DISABLE-NEXT:    bne LBB1_2\n+; ARM-DISABLE-NEXT:  @ %bb.3: @ %for.end\n+; ARM-DISABLE-NEXT:    lsl r0, r0, #3\n+; ARM-DISABLE-NEXT:    pop {r4, r7, pc}\n+; ARM-DISABLE-NEXT:  LBB1_4: @ %if.else\n+; ARM-DISABLE-NEXT:    lsl r0, r1, #1\n+; ARM-DISABLE-NEXT:    pop {r4, r7, pc}\n+;\n+; THUMB-ENABLE-LABEL: freqSaveAndRestoreOutsideLoop:\n+; THUMB-ENABLE:       @ %bb.0: @ %entry\n+; THUMB-ENABLE-NEXT:    cbz r0, LBB1_4\n+; THUMB-ENABLE-NEXT:  @ %bb.1: @ %for.preheader\n+; THUMB-ENABLE-NEXT:    push {r4, r7, lr}\n+; THUMB-ENABLE-NEXT:    add r7, sp, #4\n+; THUMB-ENABLE-NEXT:    movs r0, #0\n+; THUMB-ENABLE-NEXT:    movs r1, #10\n+; THUMB-ENABLE-NEXT:    @ InlineAsm Start\n+; THUMB-ENABLE-NEXT:    nop\n+; THUMB-ENABLE-NEXT:    @ InlineAsm End\n+; THUMB-ENABLE-NEXT:  LBB1_2: @ %for.body\n+; THUMB-ENABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-ENABLE-NEXT:    @ InlineAsm Start\n+; THUMB-ENABLE-NEXT:    mov.w r2, #1\n+; THUMB-ENABLE-NEXT:    @ InlineAsm End\n+; THUMB-ENABLE-NEXT:    add r0, r2\n+; THUMB-ENABLE-NEXT:    subs r1, #1\n+; THUMB-ENABLE-NEXT:    bne LBB1_2\n+; THUMB-ENABLE-NEXT:  @ %bb.3: @ %for.end\n+; THUMB-ENABLE-NEXT:    lsls r0, r0, #3\n+; THUMB-ENABLE-NEXT:    pop {r4, r7, pc}\n+; THUMB-ENABLE-NEXT:  LBB1_4: @ %if.else\n+; THUMB-ENABLE-NEXT:    lsls r0, r1, #1\n+; THUMB-ENABLE-NEXT:    bx lr\n+;\n+; THUMB-DISABLE-LABEL: freqSaveAndRestoreOutsideLoop:\n+; THUMB-DISABLE:       @ %bb.0: @ %entry\n+; THUMB-DISABLE-NEXT:    push {r4, r7, lr}\n+; THUMB-DISABLE-NEXT:    add r7, sp, #4\n+; THUMB-DISABLE-NEXT:    cbz r0, LBB1_4\n+; THUMB-DISABLE-NEXT:  @ %bb.1: @ %for.preheader\n+; THUMB-DISABLE-NEXT:    movs r0, #0\n+; THUMB-DISABLE-NEXT:    movs r1, #10\n+; THUMB-DISABLE-NEXT:    @ InlineAsm Start\n+; THUMB-DISABLE-NEXT:    nop\n+; THUMB-DISABLE-NEXT:    @ InlineAsm End\n+; THUMB-DISABLE-NEXT:  LBB1_2: @ %for.body\n+; THUMB-DISABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-DISABLE-NEXT:    @ InlineAsm Start\n+; THUMB-DISABLE-NEXT:    mov.w r2, #1\n+; THUMB-DISABLE-NEXT:    @ InlineAsm End\n+; THUMB-DISABLE-NEXT:    add r0, r2\n+; THUMB-DISABLE-NEXT:    subs r1, #1\n+; THUMB-DISABLE-NEXT:    bne LBB1_2\n+; THUMB-DISABLE-NEXT:  @ %bb.3: @ %for.end\n+; THUMB-DISABLE-NEXT:    lsls r0, r0, #3\n+; THUMB-DISABLE-NEXT:    pop {r4, r7, pc}\n+; THUMB-DISABLE-NEXT:  LBB1_4: @ %if.else\n+; THUMB-DISABLE-NEXT:    lsls r0, r1, #1\n+; THUMB-DISABLE-NEXT:    pop {r4, r7, pc}\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %for.preheader\n@@ -159,26 +328,162 @@ declare i32 @something(...)\n \n ; Check that we do not perform the shrink-wrapping inside the loop even\n ; though that would be legal. The cost model must prevent that.\n-; CHECK-LABEL: freqSaveAndRestoreOutsideLoop2:\n+; freqSaveAndRestoreOutsideLoop2:\n ; Prologue code.\n ; Make sure we save the CSR used in the inline asm: r4.\n-; CHECK: push {r4\n-; CHECK: mov{{s?}} [[SUM:r0]], #0\n-; CHECK-NEXT: mov{{s?}} [[IV:r[0-9]+]], #10\n-; CHECK: nop\n+; push {r4\n+; mov{{s?}} [[SUM:r0]], #0\n+; mov{{s?}} [[IV:r[0-9]+]], #10\n+; nop\n ; Next BB.\n-; CHECK: [[LOOP_LABEL:LBB[0-9_]+]]: @ %for.body\n-; CHECK: mov{{(\\.w)?}} [[TMP:r[0-9]+]], #1\n-; ARM: add [[SUM]], [[TMP]], [[SUM]]\n-; THUMB: add [[SUM]], [[TMP]]\n-; ARM: subs [[IV]], [[IV]], #1\n-; THUMB: subs [[IV]], #1\n-; CHECK-NEXT: bne [[LOOP_LABEL]]\n+; [[LOOP_LABEL:LBB[0-9_]+]]: @ %for.body\n+; mov{{(\\.w)?}} [[TMP:r[0-9]+]], #1\n+; add [[SUM]], [[TMP]], [[SUM]]\n+; add [[SUM]], [[TMP]]\n+; subs [[IV]], [[IV]], #1\n+; subs [[IV]], #1\n+; bne [[LOOP_LABEL]]\n ; Next BB.\n-; CHECK: @ %for.exit\n-; CHECK: nop\n-; CHECK: pop {r4\n+; @ %for.exit\n+; nop\n+; pop {r4\n define i32 @freqSaveAndRestoreOutsideLoop2(i32 %cond) \"no-frame-pointer-elim\"=\"true\" {\n+; ARM-LABEL: freqSaveAndRestoreOutsideLoop2:\n+; ARM:       @ %bb.0: @ %entry\n+; ARM-NEXT:    push {r4, r7, lr}\n+; ARM-NEXT:    add r7, sp, #4\n+; ARM-NEXT:    mov r0, #0\n+; ARM-NEXT:    mov r1, #10\n+; ARM-NEXT:    @ InlineAsm Start\n+; ARM-NEXT:    nop\n+; ARM-NEXT:    @ InlineAsm End\n+; ARM-NEXT:  LBB2_1: @ %for.body\n+; ARM-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-NEXT:    @ InlineAsm Start\n+; ARM-NEXT:    mov r2, #1\n+; ARM-NEXT:    @ InlineAsm End\n+; ARM-NEXT:    add r0, r2, r0\n+; ARM-NEXT:    subs r1, r1, #1\n+; ARM-NEXT:    bne LBB2_1\n+; ARM-NEXT:  @ %bb.2: @ %for.exit\n+; ARM-NEXT:    @ InlineAsm Start\n+; ARM-NEXT:    nop\n+; ARM-NEXT:    @ InlineAsm End\n+; ARM-NEXT:    pop {r4, r7, pc}\n+;\n+; THUMB-LABEL: freqSaveAndRestoreOutsideLoop2:\n+; THUMB:       @ %bb.0: @ %entry\n+; THUMB-NEXT:    push {r4, r7, lr}\n+; THUMB-NEXT:    add r7, sp, #4\n+; THUMB-NEXT:    movs r0, #0\n+; THUMB-NEXT:    movs r1, #10\n+; THUMB-NEXT:    @ InlineAsm Start\n+; THUMB-NEXT:    nop\n+; THUMB-NEXT:    @ InlineAsm End\n+; THUMB-NEXT:  LBB2_1: @ %for.body\n+; THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-NEXT:    @ InlineAsm Start\n+; THUMB-NEXT:    mov.w r2, #1\n+; THUMB-NEXT:    @ InlineAsm End\n+; THUMB-NEXT:    add r0, r2\n+; THUMB-NEXT:    subs r1, #1\n+; THUMB-NEXT:    bne LBB2_1\n+; THUMB-NEXT:  @ %bb.2: @ %for.exit\n+; THUMB-NEXT:    @ InlineAsm Start\n+; THUMB-NEXT:    nop\n+; THUMB-NEXT:    @ InlineAsm End\n+; THUMB-NEXT:    pop {r4, r7, pc}\n+; ARM-ENABLE-LABEL: freqSaveAndRestoreOutsideLoop2:\n+; ARM-ENABLE:       @ %bb.0: @ %entry\n+; ARM-ENABLE-NEXT:    push {r4, r7, lr}\n+; ARM-ENABLE-NEXT:    add r7, sp, #4\n+; ARM-ENABLE-NEXT:    mov r0, #0\n+; ARM-ENABLE-NEXT:    mov r1, #10\n+; ARM-ENABLE-NEXT:    @ InlineAsm Start\n+; ARM-ENABLE-NEXT:    nop\n+; ARM-ENABLE-NEXT:    @ InlineAsm End\n+; ARM-ENABLE-NEXT:  LBB2_1: @ %for.body\n+; ARM-ENABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-ENABLE-NEXT:    @ InlineAsm Start\n+; ARM-ENABLE-NEXT:    mov r2, #1\n+; ARM-ENABLE-NEXT:    @ InlineAsm End\n+; ARM-ENABLE-NEXT:    add r0, r2, r0\n+; ARM-ENABLE-NEXT:    subs r1, r1, #1\n+; ARM-ENABLE-NEXT:    bne LBB2_1\n+; ARM-ENABLE-NEXT:  @ %bb.2: @ %for.exit\n+; ARM-ENABLE-NEXT:    @ InlineAsm Start\n+; ARM-ENABLE-NEXT:    nop\n+; ARM-ENABLE-NEXT:    @ InlineAsm End\n+; ARM-ENABLE-NEXT:    pop {r4, r7, pc}\n+;\n+; ARM-DISABLE-LABEL: freqSaveAndRestoreOutsideLoop2:\n+; ARM-DISABLE:       @ %bb.0: @ %entry\n+; ARM-DISABLE-NEXT:    push {r4, r7, lr}\n+; ARM-DISABLE-NEXT:    add r7, sp, #4\n+; ARM-DISABLE-NEXT:    mov r0, #0\n+; ARM-DISABLE-NEXT:    mov r1, #10\n+; ARM-DISABLE-NEXT:    @ InlineAsm Start\n+; ARM-DISABLE-NEXT:    nop\n+; ARM-DISABLE-NEXT:    @ InlineAsm End\n+; ARM-DISABLE-NEXT:  LBB2_1: @ %for.body\n+; ARM-DISABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-DISABLE-NEXT:    @ InlineAsm Start\n+; ARM-DISABLE-NEXT:    mov r2, #1\n+; ARM-DISABLE-NEXT:    @ InlineAsm End\n+; ARM-DISABLE-NEXT:    add r0, r2, r0\n+; ARM-DISABLE-NEXT:    subs r1, r1, #1\n+; ARM-DISABLE-NEXT:    bne LBB2_1\n+; ARM-DISABLE-NEXT:  @ %bb.2: @ %for.exit\n+; ARM-DISABLE-NEXT:    @ InlineAsm Start\n+; ARM-DISABLE-NEXT:    nop\n+; ARM-DISABLE-NEXT:    @ InlineAsm End\n+; ARM-DISABLE-NEXT:    pop {r4, r7, pc}\n+;\n+; THUMB-ENABLE-LABEL: freqSaveAndRestoreOutsideLoop2:\n+; THUMB-ENABLE:       @ %bb.0: @ %entry\n+; THUMB-ENABLE-NEXT:    push {r4, r7, lr}\n+; THUMB-ENABLE-NEXT:    add r7, sp, #4\n+; THUMB-ENABLE-NEXT:    movs r0, #0\n+; THUMB-ENABLE-NEXT:    movs r1, #10\n+; THUMB-ENABLE-NEXT:    @ InlineAsm Start\n+; THUMB-ENABLE-NEXT:    nop\n+; THUMB-ENABLE-NEXT:    @ InlineAsm End\n+; THUMB-ENABLE-NEXT:  LBB2_1: @ %for.body\n+; THUMB-ENABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-ENABLE-NEXT:    @ InlineAsm Start\n+; THUMB-ENABLE-NEXT:    mov.w r2, #1\n+; THUMB-ENABLE-NEXT:    @ InlineAsm End\n+; THUMB-ENABLE-NEXT:    add r0, r2\n+; THUMB-ENABLE-NEXT:    subs r1, #1\n+; THUMB-ENABLE-NEXT:    bne LBB2_1\n+; THUMB-ENABLE-NEXT:  @ %bb.2: @ %for.exit\n+; THUMB-ENABLE-NEXT:    @ InlineAsm Start\n+; THUMB-ENABLE-NEXT:    nop\n+; THUMB-ENABLE-NEXT:    @ InlineAsm End\n+; THUMB-ENABLE-NEXT:    pop {r4, r7, pc}\n+;\n+; THUMB-DISABLE-LABEL: freqSaveAndRestoreOutsideLoop2:\n+; THUMB-DISABLE:       @ %bb.0: @ %entry\n+; THUMB-DISABLE-NEXT:    push {r4, r7, lr}\n+; THUMB-DISABLE-NEXT:    add r7, sp, #4\n+; THUMB-DISABLE-NEXT:    movs r0, #0\n+; THUMB-DISABLE-NEXT:    movs r1, #10\n+; THUMB-DISABLE-NEXT:    @ InlineAsm Start\n+; THUMB-DISABLE-NEXT:    nop\n+; THUMB-DISABLE-NEXT:    @ InlineAsm End\n+; THUMB-DISABLE-NEXT:  LBB2_1: @ %for.body\n+; THUMB-DISABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-DISABLE-NEXT:    @ InlineAsm Start\n+; THUMB-DISABLE-NEXT:    mov.w r2, #1\n+; THUMB-DISABLE-NEXT:    @ InlineAsm End\n+; THUMB-DISABLE-NEXT:    add r0, r2\n+; THUMB-DISABLE-NEXT:    subs r1, #1\n+; THUMB-DISABLE-NEXT:    bne LBB2_1\n+; THUMB-DISABLE-NEXT:  @ %bb.2: @ %for.exit\n+; THUMB-DISABLE-NEXT:    @ InlineAsm Start\n+; THUMB-DISABLE-NEXT:    nop\n+; THUMB-DISABLE-NEXT:    @ InlineAsm End\n+; THUMB-DISABLE-NEXT:    pop {r4, r7, pc}\n entry:\n   br label %for.preheader\n \n@@ -205,50 +510,167 @@ for.end:                                          ; preds = %for.body\n \n ; Check with a more complex case that we do not have save within the loop and\n ; restore outside.\n-; CHECK-LABEL: loopInfoSaveOutsideLoop:\n+; loopInfoSaveOutsideLoop:\n ;\n-; ARM-ENABLE: cmp r0, #0\n-; ARM-ENABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-; THUMB-ENABLE: cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n+; cmp r0, #0\n+; beq [[ELSE_LABEL:LBB[0-9_]+]]\n+; cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n ;\n ; Prologue code.\n ; Make sure we save the CSR used in the inline asm: r4.\n-; CHECK: push {r4, r7, lr}\n-; CHECK-NEXT: add r7, sp, #4\n+; push {r4, r7, lr}\n+; add r7, sp, #4\n ;\n-; ARM-DISABLE: cmp r0, #0\n-; ARM-DISABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-; THUMB-DISABLE: cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n+; cmp r0, #0\n+; beq [[ELSE_LABEL:LBB[0-9_]+]]\n+; cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n ;\n ; SUM is in r0 because it is coalesced with the second\n ; argument on the else path.\n-; CHECK: mov{{s?}} [[SUM:r0]], #0\n-; CHECK-NEXT: mov{{s?}} [[IV:r[0-9]+]], #10\n+; mov{{s?}} [[SUM:r0]], #0\n+; mov{{s?}} [[IV:r[0-9]+]], #10\n ;\n ; Next BB.\n-; CHECK: [[LOOP:LBB[0-9_]+]]: @ %for.body\n-; CHECK: mov{{(\\.w)?}} [[TMP:r[0-9]+]], #1\n-; ARM: add [[SUM]], [[TMP]], [[SUM]]\n-; THUMB: add [[SUM]], [[TMP]]\n-; ARM-NEXT: subs [[IV]], [[IV]], #1\n-; THUMB-NEXT: subs [[IV]], #1\n-; CHECK-NEXT: bne [[LOOP]]\n+; [[LOOP:LBB[0-9_]+]]: @ %for.body\n+; mov{{(\\.w)?}} [[TMP:r[0-9]+]], #1\n+; add [[SUM]], [[TMP]], [[SUM]]\n+; add [[SUM]], [[TMP]]\n+; subs [[IV]], [[IV]], #1\n+; subs [[IV]], #1\n+; bne [[LOOP]]\n ;\n ; Next BB.\n ; SUM << 3.\n-; CHECK: lsl{{s?}} [[SUM]], [[SUM]], #3\n-; ENABLE: pop {r4, r7, pc}\n+; lsl{{s?}} [[SUM]], [[SUM]], #3\n+; pop {r4, r7, pc}\n ;\n ; Duplicated epilogue.\n-; DISABLE: pop {r4, r7, pc}\n+; pop {r4, r7, pc}\n ;\n-; CHECK: [[ELSE_LABEL]]: @ %if.else\n+; [[ELSE_LABEL]]: @ %if.else\n ; Shift second argument by one and store into returned register.\n-; CHECK: lsl{{s?}} r0, r1, #1\n-; DISABLE-NEXT: pop {r4, r7, pc}\n+; lsl{{s?}} r0, r1, #1\n+; pop {r4, r7, pc}\n ;\n-; ENABLE-NEXT: bx lr\n+; bx lr\n define i32 @loopInfoSaveOutsideLoop(i32 %cond, i32 %N) \"no-frame-pointer-elim\"=\"true\" {\n+; ARM-ENABLE-LABEL: loopInfoSaveOutsideLoop:\n+; ARM-ENABLE:       @ %bb.0: @ %entry\n+; ARM-ENABLE-NEXT:    cmp r0, #0\n+; ARM-ENABLE-NEXT:    beq LBB3_4\n+; ARM-ENABLE-NEXT:  @ %bb.1: @ %for.preheader\n+; ARM-ENABLE-NEXT:    push {r4, r7, lr}\n+; ARM-ENABLE-NEXT:    add r7, sp, #4\n+; ARM-ENABLE-NEXT:    mov r0, #0\n+; ARM-ENABLE-NEXT:    mov r1, #10\n+; ARM-ENABLE-NEXT:    @ InlineAsm Start\n+; ARM-ENABLE-NEXT:    nop\n+; ARM-ENABLE-NEXT:    @ InlineAsm End\n+; ARM-ENABLE-NEXT:  LBB3_2: @ %for.body\n+; ARM-ENABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-ENABLE-NEXT:    @ InlineAsm Start\n+; ARM-ENABLE-NEXT:    mov r2, #1\n+; ARM-ENABLE-NEXT:    @ InlineAsm End\n+; ARM-ENABLE-NEXT:    add r0, r2, r0\n+; ARM-ENABLE-NEXT:    subs r1, r1, #1\n+; ARM-ENABLE-NEXT:    bne LBB3_2\n+; ARM-ENABLE-NEXT:  @ %bb.3: @ %for.end\n+; ARM-ENABLE-NEXT:    lsl r0, r0, #3\n+; ARM-ENABLE-NEXT:    @ InlineAsm Start\n+; ARM-ENABLE-NEXT:    nop\n+; ARM-ENABLE-NEXT:    @ InlineAsm End\n+; ARM-ENABLE-NEXT:    pop {r4, r7, pc}\n+; ARM-ENABLE-NEXT:  LBB3_4: @ %if.else\n+; ARM-ENABLE-NEXT:    lsl r0, r1, #1\n+; ARM-ENABLE-NEXT:    bx lr\n+;\n+; ARM-DISABLE-LABEL: loopInfoSaveOutsideLoop:\n+; ARM-DISABLE:       @ %bb.0: @ %entry\n+; ARM-DISABLE-NEXT:    push {r4, r7, lr}\n+; ARM-DISABLE-NEXT:    add r7, sp, #4\n+; ARM-DISABLE-NEXT:    cmp r0, #0\n+; ARM-DISABLE-NEXT:    beq LBB3_4\n+; ARM-DISABLE-NEXT:  @ %bb.1: @ %for.preheader\n+; ARM-DISABLE-NEXT:    mov r0, #0\n+; ARM-DISABLE-NEXT:    mov r1, #10\n+; ARM-DISABLE-NEXT:    @ InlineAsm Start\n+; ARM-DISABLE-NEXT:    nop\n+; ARM-DISABLE-NEXT:    @ InlineAsm End\n+; ARM-DISABLE-NEXT:  LBB3_2: @ %for.body\n+; ARM-DISABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-DISABLE-NEXT:    @ InlineAsm Start\n+; ARM-DISABLE-NEXT:    mov r2, #1\n+; ARM-DISABLE-NEXT:    @ InlineAsm End\n+; ARM-DISABLE-NEXT:    add r0, r2, r0\n+; ARM-DISABLE-NEXT:    subs r1, r1, #1\n+; ARM-DISABLE-NEXT:    bne LBB3_2\n+; ARM-DISABLE-NEXT:  @ %bb.3: @ %for.end\n+; ARM-DISABLE-NEXT:    lsl r0, r0, #3\n+; ARM-DISABLE-NEXT:    @ InlineAsm Start\n+; ARM-DISABLE-NEXT:    nop\n+; ARM-DISABLE-NEXT:    @ InlineAsm End\n+; ARM-DISABLE-NEXT:    pop {r4, r7, pc}\n+; ARM-DISABLE-NEXT:  LBB3_4: @ %if.else\n+; ARM-DISABLE-NEXT:    lsl r0, r1, #1\n+; ARM-DISABLE-NEXT:    pop {r4, r7, pc}\n+;\n+; THUMB-ENABLE-LABEL: loopInfoSaveOutsideLoop:\n+; THUMB-ENABLE:       @ %bb.0: @ %entry\n+; THUMB-ENABLE-NEXT:    cbz r0, LBB3_4\n+; THUMB-ENABLE-NEXT:  @ %bb.1: @ %for.preheader\n+; THUMB-ENABLE-NEXT:    push {r4, r7, lr}\n+; THUMB-ENABLE-NEXT:    add r7, sp, #4\n+; THUMB-ENABLE-NEXT:    movs r0, #0\n+; THUMB-ENABLE-NEXT:    movs r1, #10\n+; THUMB-ENABLE-NEXT:    @ InlineAsm Start\n+; THUMB-ENABLE-NEXT:    nop\n+; THUMB-ENABLE-NEXT:    @ InlineAsm End\n+; THUMB-ENABLE-NEXT:  LBB3_2: @ %for.body\n+; THUMB-ENABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-ENABLE-NEXT:    @ InlineAsm Start\n+; THUMB-ENABLE-NEXT:    mov.w r2, #1\n+; THUMB-ENABLE-NEXT:    @ InlineAsm End\n+; THUMB-ENABLE-NEXT:    add r0, r2\n+; THUMB-ENABLE-NEXT:    subs r1, #1\n+; THUMB-ENABLE-NEXT:    bne LBB3_2\n+; THUMB-ENABLE-NEXT:  @ %bb.3: @ %for.end\n+; THUMB-ENABLE-NEXT:    lsls r0, r0, #3\n+; THUMB-ENABLE-NEXT:    @ InlineAsm Start\n+; THUMB-ENABLE-NEXT:    nop\n+; THUMB-ENABLE-NEXT:    @ InlineAsm End\n+; THUMB-ENABLE-NEXT:    pop {r4, r7, pc}\n+; THUMB-ENABLE-NEXT:  LBB3_4: @ %if.else\n+; THUMB-ENABLE-NEXT:    lsls r0, r1, #1\n+; THUMB-ENABLE-NEXT:    bx lr\n+;\n+; THUMB-DISABLE-LABEL: loopInfoSaveOutsideLoop:\n+; THUMB-DISABLE:       @ %bb.0: @ %entry\n+; THUMB-DISABLE-NEXT:    push {r4, r7, lr}\n+; THUMB-DISABLE-NEXT:    add r7, sp, #4\n+; THUMB-DISABLE-NEXT:    cbz r0, LBB3_4\n+; THUMB-DISABLE-NEXT:  @ %bb.1: @ %for.preheader\n+; THUMB-DISABLE-NEXT:    movs r0, #0\n+; THUMB-DISABLE-NEXT:    movs r1, #10\n+; THUMB-DISABLE-NEXT:    @ InlineAsm Start\n+; THUMB-DISABLE-NEXT:    nop\n+; THUMB-DISABLE-NEXT:    @ InlineAsm End\n+; THUMB-DISABLE-NEXT:  LBB3_2: @ %for.body\n+; THUMB-DISABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-DISABLE-NEXT:    @ InlineAsm Start\n+; THUMB-DISABLE-NEXT:    mov.w r2, #1\n+; THUMB-DISABLE-NEXT:    @ InlineAsm End\n+; THUMB-DISABLE-NEXT:    add r0, r2\n+; THUMB-DISABLE-NEXT:    subs r1, #1\n+; THUMB-DISABLE-NEXT:    bne LBB3_2\n+; THUMB-DISABLE-NEXT:  @ %bb.3: @ %for.end\n+; THUMB-DISABLE-NEXT:    lsls r0, r0, #3\n+; THUMB-DISABLE-NEXT:    @ InlineAsm Start\n+; THUMB-DISABLE-NEXT:    nop\n+; THUMB-DISABLE-NEXT:    @ InlineAsm End\n+; THUMB-DISABLE-NEXT:    pop {r4, r7, pc}\n+; THUMB-DISABLE-NEXT:  LBB3_4: @ %if.else\n+; THUMB-DISABLE-NEXT:    lsls r0, r1, #1\n+; THUMB-DISABLE-NEXT:    pop {r4, r7, pc}\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %for.preheader\n@@ -284,50 +706,155 @@ declare void @somethingElse(...)\n \n ; Check with a more complex case that we do not have restore within the loop and\n ; save outside.\n-; CHECK-LABEL: loopInfoRestoreOutsideLoop:\n+; loopInfoRestoreOutsideLoop:\n ;\n-; ARM-ENABLE: cmp r0, #0\n-; ARM-ENABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-; THUMB-ENABLE: cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n+; cmp r0, #0\n+; beq [[ELSE_LABEL:LBB[0-9_]+]]\n+; cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n ;\n ; Prologue code.\n ; Make sure we save the CSR used in the inline asm: r4.\n-; CHECK: push {r4, r7, lr}\n-; CHECK-NEXT: add r7, sp, #4\n+; push {r4, r7, lr}\n+; add r7, sp, #4\n ;\n-; ARM-DISABLE: cmp r0, #0\n-; ARM-DISABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-; THUMB-DISABLE: cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n+; cmp r0, #0\n+; beq [[ELSE_LABEL:LBB[0-9_]+]]\n+; cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n ;\n ; SUM is in r0 because it is coalesced with the second\n ; argument on the else path.\n-; CHECK: mov{{s?}} [[SUM:r0]], #0\n-; CHECK-NEXT: mov{{s?}} [[IV:r[0-9]+]], #10\n+; mov{{s?}} [[SUM:r0]], #0\n+; mov{{s?}} [[IV:r[0-9]+]], #10\n ;\n ; Next BB.\n-; CHECK: [[LOOP:LBB[0-9_]+]]: @ %for.body\n-; CHECK: mov{{(\\.w)?}} [[TMP:r[0-9]+]], #1\n-; ARM: add [[SUM]], [[TMP]], [[SUM]]\n-; THUMB: add [[SUM]], [[TMP]]\n-; ARM-NEXT: subs [[IV]], [[IV]], #1\n-; THUMB-NEXT: subs [[IV]], #1\n-; CHECK-NEXT: bne [[LOOP]]\n+; [[LOOP:LBB[0-9_]+]]: @ %for.body\n+; mov{{(\\.w)?}} [[TMP:r[0-9]+]], #1\n+; add [[SUM]], [[TMP]], [[SUM]]\n+; add [[SUM]], [[TMP]]\n+; subs [[IV]], [[IV]], #1\n+; subs [[IV]], #1\n+; bne [[LOOP]]\n ;\n ; Next BB.\n ; SUM << 3.\n-; CHECK: lsl{{s?}} [[SUM]], [[SUM]], #3\n-; ENABLE-NEXT: pop {r4, r7, pc}\n+; lsl{{s?}} [[SUM]], [[SUM]], #3\n+; pop {r4, r7, pc}\n ;\n ; Duplicated epilogue.\n-; DISABLE: pop {r4, r7, pc}\n+; pop {r4, r7, pc}\n ;\n-; CHECK: [[ELSE_LABEL]]: @ %if.else\n+; [[ELSE_LABEL]]: @ %if.else\n ; Shift second argument by one and store into returned register.\n-; CHECK: lsl{{s?}} r0, r1, #1\n-; DISABLE-NEXT: pop {r4, r7, pc}\n+; lsl{{s?}} r0, r1, #1\n+; pop {r4, r7, pc}\n ;\n-; ENABLE-NEXT: bx lr\n+; bx lr\n define i32 @loopInfoRestoreOutsideLoop(i32 %cond, i32 %N) \"no-frame-pointer-elim\"=\"true\" nounwind {\n+; ARM-ENABLE-LABEL: loopInfoRestoreOutsideLoop:\n+; ARM-ENABLE:       @ %bb.0: @ %entry\n+; ARM-ENABLE-NEXT:    cmp r0, #0\n+; ARM-ENABLE-NEXT:    beq LBB4_4\n+; ARM-ENABLE-NEXT:  @ %bb.1: @ %if.then\n+; ARM-ENABLE-NEXT:    push {r4, r7, lr}\n+; ARM-ENABLE-NEXT:    add r7, sp, #4\n+; ARM-ENABLE-NEXT:    mov r0, #0\n+; ARM-ENABLE-NEXT:    mov r1, #10\n+; ARM-ENABLE-NEXT:    @ InlineAsm Start\n+; ARM-ENABLE-NEXT:    nop\n+; ARM-ENABLE-NEXT:    @ InlineAsm End\n+; ARM-ENABLE-NEXT:  LBB4_2: @ %for.body\n+; ARM-ENABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-ENABLE-NEXT:    @ InlineAsm Start\n+; ARM-ENABLE-NEXT:    mov r2, #1\n+; ARM-ENABLE-NEXT:    @ InlineAsm End\n+; ARM-ENABLE-NEXT:    add r0, r2, r0\n+; ARM-ENABLE-NEXT:    subs r1, r1, #1\n+; ARM-ENABLE-NEXT:    bne LBB4_2\n+; ARM-ENABLE-NEXT:  @ %bb.3: @ %for.end\n+; ARM-ENABLE-NEXT:    lsl r0, r0, #3\n+; ARM-ENABLE-NEXT:    pop {r4, r7, pc}\n+; ARM-ENABLE-NEXT:  LBB4_4: @ %if.else\n+; ARM-ENABLE-NEXT:    lsl r0, r1, #1\n+; ARM-ENABLE-NEXT:    bx lr\n+;\n+; ARM-DISABLE-LABEL: loopInfoRestoreOutsideLoop:\n+; ARM-DISABLE:       @ %bb.0: @ %entry\n+; ARM-DISABLE-NEXT:    push {r4, r7, lr}\n+; ARM-DISABLE-NEXT:    add r7, sp, #4\n+; ARM-DISABLE-NEXT:    cmp r0, #0\n+; ARM-DISABLE-NEXT:    beq LBB4_4\n+; ARM-DISABLE-NEXT:  @ %bb.1: @ %if.then\n+; ARM-DISABLE-NEXT:    mov r0, #0\n+; ARM-DISABLE-NEXT:    mov r1, #10\n+; ARM-DISABLE-NEXT:    @ InlineAsm Start\n+; ARM-DISABLE-NEXT:    nop\n+; ARM-DISABLE-NEXT:    @ InlineAsm End\n+; ARM-DISABLE-NEXT:  LBB4_2: @ %for.body\n+; ARM-DISABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-DISABLE-NEXT:    @ InlineAsm Start\n+; ARM-DISABLE-NEXT:    mov r2, #1\n+; ARM-DISABLE-NEXT:    @ InlineAsm End\n+; ARM-DISABLE-NEXT:    add r0, r2, r0\n+; ARM-DISABLE-NEXT:    subs r1, r1, #1\n+; ARM-DISABLE-NEXT:    bne LBB4_2\n+; ARM-DISABLE-NEXT:  @ %bb.3: @ %for.end\n+; ARM-DISABLE-NEXT:    lsl r0, r0, #3\n+; ARM-DISABLE-NEXT:    pop {r4, r7, pc}\n+; ARM-DISABLE-NEXT:  LBB4_4: @ %if.else\n+; ARM-DISABLE-NEXT:    lsl r0, r1, #1\n+; ARM-DISABLE-NEXT:    pop {r4, r7, pc}\n+;\n+; THUMB-ENABLE-LABEL: loopInfoRestoreOutsideLoop:\n+; THUMB-ENABLE:       @ %bb.0: @ %entry\n+; THUMB-ENABLE-NEXT:    cbz r0, LBB4_4\n+; THUMB-ENABLE-NEXT:  @ %bb.1: @ %if.then\n+; THUMB-ENABLE-NEXT:    push {r4, r7, lr}\n+; THUMB-ENABLE-NEXT:    add r7, sp, #4\n+; THUMB-ENABLE-NEXT:    movs r0, #0\n+; THUMB-ENABLE-NEXT:    movs r1, #10\n+; THUMB-ENABLE-NEXT:    @ InlineAsm Start\n+; THUMB-ENABLE-NEXT:    nop\n+; THUMB-ENABLE-NEXT:    @ InlineAsm End\n+; THUMB-ENABLE-NEXT:  LBB4_2: @ %for.body\n+; THUMB-ENABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-ENABLE-NEXT:    @ InlineAsm Start\n+; THUMB-ENABLE-NEXT:    mov.w r2, #1\n+; THUMB-ENABLE-NEXT:    @ InlineAsm End\n+; THUMB-ENABLE-NEXT:    add r0, r2\n+; THUMB-ENABLE-NEXT:    subs r1, #1\n+; THUMB-ENABLE-NEXT:    bne LBB4_2\n+; THUMB-ENABLE-NEXT:  @ %bb.3: @ %for.end\n+; THUMB-ENABLE-NEXT:    lsls r0, r0, #3\n+; THUMB-ENABLE-NEXT:    pop {r4, r7, pc}\n+; THUMB-ENABLE-NEXT:  LBB4_4: @ %if.else\n+; THUMB-ENABLE-NEXT:    lsls r0, r1, #1\n+; THUMB-ENABLE-NEXT:    bx lr\n+;\n+; THUMB-DISABLE-LABEL: loopInfoRestoreOutsideLoop:\n+; THUMB-DISABLE:       @ %bb.0: @ %entry\n+; THUMB-DISABLE-NEXT:    push {r4, r7, lr}\n+; THUMB-DISABLE-NEXT:    add r7, sp, #4\n+; THUMB-DISABLE-NEXT:    cbz r0, LBB4_4\n+; THUMB-DISABLE-NEXT:  @ %bb.1: @ %if.then\n+; THUMB-DISABLE-NEXT:    movs r0, #0\n+; THUMB-DISABLE-NEXT:    movs r1, #10\n+; THUMB-DISABLE-NEXT:    @ InlineAsm Start\n+; THUMB-DISABLE-NEXT:    nop\n+; THUMB-DISABLE-NEXT:    @ InlineAsm End\n+; THUMB-DISABLE-NEXT:  LBB4_2: @ %for.body\n+; THUMB-DISABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-DISABLE-NEXT:    @ InlineAsm Start\n+; THUMB-DISABLE-NEXT:    mov.w r2, #1\n+; THUMB-DISABLE-NEXT:    @ InlineAsm End\n+; THUMB-DISABLE-NEXT:    add r0, r2\n+; THUMB-DISABLE-NEXT:    subs r1, #1\n+; THUMB-DISABLE-NEXT:    bne LBB4_2\n+; THUMB-DISABLE-NEXT:  @ %bb.3: @ %for.end\n+; THUMB-DISABLE-NEXT:    lsls r0, r0, #3\n+; THUMB-DISABLE-NEXT:    pop {r4, r7, pc}\n+; THUMB-DISABLE-NEXT:  LBB4_4: @ %if.else\n+; THUMB-DISABLE-NEXT:    lsls r0, r1, #1\n+; THUMB-DISABLE-NEXT:    pop {r4, r7, pc}\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %if.then\n@@ -359,53 +886,190 @@ if.end:                                           ; preds = %if.else, %for.end\n }\n \n ; Check that we handle function with no frame information correctly.\n-; CHECK-LABEL: emptyFrame:\n-; CHECK: @ %entry\n-; CHECK-NEXT: mov{{s?}} r0, #0\n-; CHECK-NEXT: bx lr\n+; emptyFrame:\n+; @ %entry\n+; mov{{s?}} r0, #0\n+; bx lr\n define i32 @emptyFrame() {\n+; ARM-LABEL: emptyFrame:\n+; ARM:       @ %bb.0: @ %entry\n+; ARM-NEXT:    mov r0, #0\n+; ARM-NEXT:    bx lr\n+;\n+; THUMB-LABEL: emptyFrame:\n+; THUMB:       @ %bb.0: @ %entry\n+; THUMB-NEXT:    movs r0, #0\n+; THUMB-NEXT:    bx lr\n+; ARM-ENABLE-LABEL: emptyFrame:\n+; ARM-ENABLE:       @ %bb.0: @ %entry\n+; ARM-ENABLE-NEXT:    mov r0, #0\n+; ARM-ENABLE-NEXT:    bx lr\n+;\n+; ARM-DISABLE-LABEL: emptyFrame:\n+; ARM-DISABLE:       @ %bb.0: @ %entry\n+; ARM-DISABLE-NEXT:    mov r0, #0\n+; ARM-DISABLE-NEXT:    bx lr\n+;\n+; THUMB-ENABLE-LABEL: emptyFrame:\n+; THUMB-ENABLE:       @ %bb.0: @ %entry\n+; THUMB-ENABLE-NEXT:    movs r0, #0\n+; THUMB-ENABLE-NEXT:    bx lr\n+;\n+; THUMB-DISABLE-LABEL: emptyFrame:\n+; THUMB-DISABLE:       @ %bb.0: @ %entry\n+; THUMB-DISABLE-NEXT:    movs r0, #0\n+; THUMB-DISABLE-NEXT:    bx lr\n entry:\n   ret i32 0\n }\n \n ; Check that we handle inline asm correctly.\n-; CHECK-LABEL: inlineAsm:\n+; inlineAsm:\n ;\n-; ARM-ENABLE: cmp r0, #0\n-; ARM-ENABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-; THUMB-ENABLE: cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n+; cmp r0, #0\n+; beq [[ELSE_LABEL:LBB[0-9_]+]]\n+; cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n ;\n ; Prologue code.\n ; Make sure we save the CSR used in the inline asm: r4.\n-; CHECK: push {r4, r7, lr}\n-; CHECK-NEXT: add r7, sp, #4\n+; push {r4, r7, lr}\n+; add r7, sp, #4\n ;\n-; ARM-DISABLE: cmp r0, #0\n-; ARM-DISABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-; THUMB-DISABLE: cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n+; cmp r0, #0\n+; beq [[ELSE_LABEL:LBB[0-9_]+]]\n+; cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n ;\n-; CHECK: mov{{s?}} [[IV:r[0-9]+]], #10\n+; mov{{s?}} [[IV:r[0-9]+]], #10\n ;\n ; Next BB.\n-; CHECK: [[LOOP:LBB[0-9_]+]]: @ %for.body\n-; ARM: subs [[IV]], [[IV]], #1\n-; THUMB: subs [[IV]], #1\n-; CHECK: add{{(\\.w)?}} r4, r4, #1\n-; CHECK: bne [[LOOP]]\n+; [[LOOP:LBB[0-9_]+]]: @ %for.body\n+; subs [[IV]], [[IV]], #1\n+; subs [[IV]], #1\n+; add{{(\\.w)?}} r4, r4, #1\n+; bne [[LOOP]]\n ;\n ; Next BB.\n-; CHECK: mov{{s?}} r0, #0\n+; mov{{s?}} r0, #0\n ;\n ; Duplicated epilogue.\n-; DISABLE: pop {r4, r7, pc}\n+; pop {r4, r7, pc}\n ;\n-; CHECK: [[ELSE_LABEL]]: @ %if.else\n+; [[ELSE_LABEL]]: @ %if.else\n ; Shift second argument by one and store into returned register.\n-; CHECK: lsl{{s?}} r0, r1, #1\n-; DISABLE-NEXT: pop {r4, r7, pc}\n+; lsl{{s?}} r0, r1, #1\n+; pop {r4, r7, pc}\n ;\n-; ENABLE-NEXT: bx lr\n+; bx lr\n define i32 @inlineAsm(i32 %cond, i32 %N) \"no-frame-pointer-elim\"=\"true\" {\n+; ARM-ENABLE-LABEL: inlineAsm:\n+; ARM-ENABLE:       @ %bb.0: @ %entry\n+; ARM-ENABLE-NEXT:    cmp r0, #0\n+; ARM-ENABLE-NEXT:    beq LBB6_4\n+; ARM-ENABLE-NEXT:  @ %bb.1: @ %for.preheader\n+; ARM-ENABLE-NEXT:    push {r4, r7, lr}\n+; ARM-ENABLE-NEXT:    add r7, sp, #4\n+; ARM-ENABLE-NEXT:    mov r0, #10\n+; ARM-ENABLE-NEXT:    @ InlineAsm Start\n+; ARM-ENABLE-NEXT:    nop\n+; ARM-ENABLE-NEXT:    @ InlineAsm End\n+; ARM-ENABLE-NEXT:  LBB6_2: @ %for.body\n+; ARM-ENABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-ENABLE-NEXT:    subs r0, r0, #1\n+; ARM-ENABLE-NEXT:    @ InlineAsm Start\n+; ARM-ENABLE-NEXT:    add r4, r4, #1\n+; ARM-ENABLE-NEXT:    @ InlineAsm End\n+; ARM-ENABLE-NEXT:    bne LBB6_2\n+; ARM-ENABLE-NEXT:  @ %bb.3: @ %for.exit\n+; ARM-ENABLE-NEXT:    mov r0, #0\n+; ARM-ENABLE-NEXT:    @ InlineAsm Start\n+; ARM-ENABLE-NEXT:    nop\n+; ARM-ENABLE-NEXT:    @ InlineAsm End\n+; ARM-ENABLE-NEXT:    pop {r4, r7, pc}\n+; ARM-ENABLE-NEXT:  LBB6_4: @ %if.else\n+; ARM-ENABLE-NEXT:    lsl r0, r1, #1\n+; ARM-ENABLE-NEXT:    bx lr\n+;\n+; ARM-DISABLE-LABEL: inlineAsm:\n+; ARM-DISABLE:       @ %bb.0: @ %entry\n+; ARM-DISABLE-NEXT:    push {r4, r7, lr}\n+; ARM-DISABLE-NEXT:    add r7, sp, #4\n+; ARM-DISABLE-NEXT:    cmp r0, #0\n+; ARM-DISABLE-NEXT:    beq LBB6_4\n+; ARM-DISABLE-NEXT:  @ %bb.1: @ %for.preheader\n+; ARM-DISABLE-NEXT:    mov r0, #10\n+; ARM-DISABLE-NEXT:    @ InlineAsm Start\n+; ARM-DISABLE-NEXT:    nop\n+; ARM-DISABLE-NEXT:    @ InlineAsm End\n+; ARM-DISABLE-NEXT:  LBB6_2: @ %for.body\n+; ARM-DISABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-DISABLE-NEXT:    subs r0, r0, #1\n+; ARM-DISABLE-NEXT:    @ InlineAsm Start\n+; ARM-DISABLE-NEXT:    add r4, r4, #1\n+; ARM-DISABLE-NEXT:    @ InlineAsm End\n+; ARM-DISABLE-NEXT:    bne LBB6_2\n+; ARM-DISABLE-NEXT:  @ %bb.3: @ %for.exit\n+; ARM-DISABLE-NEXT:    mov r0, #0\n+; ARM-DISABLE-NEXT:    @ InlineAsm Start\n+; ARM-DISABLE-NEXT:    nop\n+; ARM-DISABLE-NEXT:    @ InlineAsm End\n+; ARM-DISABLE-NEXT:    pop {r4, r7, pc}\n+; ARM-DISABLE-NEXT:  LBB6_4: @ %if.else\n+; ARM-DISABLE-NEXT:    lsl r0, r1, #1\n+; ARM-DISABLE-NEXT:    pop {r4, r7, pc}\n+;\n+; THUMB-ENABLE-LABEL: inlineAsm:\n+; THUMB-ENABLE:       @ %bb.0: @ %entry\n+; THUMB-ENABLE-NEXT:    cbz r0, LBB6_4\n+; THUMB-ENABLE-NEXT:  @ %bb.1: @ %for.preheader\n+; THUMB-ENABLE-NEXT:    push {r4, r7, lr}\n+; THUMB-ENABLE-NEXT:    add r7, sp, #4\n+; THUMB-ENABLE-NEXT:    movs r0, #10\n+; THUMB-ENABLE-NEXT:    @ InlineAsm Start\n+; THUMB-ENABLE-NEXT:    nop\n+; THUMB-ENABLE-NEXT:    @ InlineAsm End\n+; THUMB-ENABLE-NEXT:  LBB6_2: @ %for.body\n+; THUMB-ENABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-ENABLE-NEXT:    subs r0, #1\n+; THUMB-ENABLE-NEXT:    @ InlineAsm Start\n+; THUMB-ENABLE-NEXT:    add.w r4, r4, #1\n+; THUMB-ENABLE-NEXT:    @ InlineAsm End\n+; THUMB-ENABLE-NEXT:    bne LBB6_2\n+; THUMB-ENABLE-NEXT:  @ %bb.3: @ %for.exit\n+; THUMB-ENABLE-NEXT:    movs r0, #0\n+; THUMB-ENABLE-NEXT:    @ InlineAsm Start\n+; THUMB-ENABLE-NEXT:    nop\n+; THUMB-ENABLE-NEXT:    @ InlineAsm End\n+; THUMB-ENABLE-NEXT:    pop {r4, r7, pc}\n+; THUMB-ENABLE-NEXT:  LBB6_4: @ %if.else\n+; THUMB-ENABLE-NEXT:    lsls r0, r1, #1\n+; THUMB-ENABLE-NEXT:    bx lr\n+;\n+; THUMB-DISABLE-LABEL: inlineAsm:\n+; THUMB-DISABLE:       @ %bb.0: @ %entry\n+; THUMB-DISABLE-NEXT:    push {r4, r7, lr}\n+; THUMB-DISABLE-NEXT:    add r7, sp, #4\n+; THUMB-DISABLE-NEXT:    cbz r0, LBB6_4\n+; THUMB-DISABLE-NEXT:  @ %bb.1: @ %for.preheader\n+; THUMB-DISABLE-NEXT:    movs r0, #10\n+; THUMB-DISABLE-NEXT:    @ InlineAsm Start\n+; THUMB-DISABLE-NEXT:    nop\n+; THUMB-DISABLE-NEXT:    @ InlineAsm End\n+; THUMB-DISABLE-NEXT:  LBB6_2: @ %for.body\n+; THUMB-DISABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-DISABLE-NEXT:    subs r0, #1\n+; THUMB-DISABLE-NEXT:    @ InlineAsm Start\n+; THUMB-DISABLE-NEXT:    add.w r4, r4, #1\n+; THUMB-DISABLE-NEXT:    @ InlineAsm End\n+; THUMB-DISABLE-NEXT:    bne LBB6_2\n+; THUMB-DISABLE-NEXT:  @ %bb.3: @ %for.exit\n+; THUMB-DISABLE-NEXT:    movs r0, #0\n+; THUMB-DISABLE-NEXT:    @ InlineAsm Start\n+; THUMB-DISABLE-NEXT:    nop\n+; THUMB-DISABLE-NEXT:    @ InlineAsm End\n+; THUMB-DISABLE-NEXT:    pop {r4, r7, pc}\n+; THUMB-DISABLE-NEXT:  LBB6_4: @ %if.else\n+; THUMB-DISABLE-NEXT:    lsls r0, r1, #1\n+; THUMB-DISABLE-NEXT:    pop {r4, r7, pc}\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %for.preheader\n@@ -435,46 +1099,131 @@ if.end:                                           ; preds = %for.body, %if.else\n }\n \n ; Check that we handle calls to variadic functions correctly.\n-; CHECK-LABEL: callVariadicFunc:\n+; callVariadicFunc:\n ;\n-; ARM-ENABLE: cmp r0, #0\n-; ARM-ENABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-; THUMB-ENABLE: cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n+; cmp r0, #0\n+; beq [[ELSE_LABEL:LBB[0-9_]+]]\n+; cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n ;\n ; Prologue code.\n-; CHECK: push {r7, lr}\n-; CHECK-NEXT: mov r7, sp\n-; CHECK-NEXT: sub sp, {{(sp, )?}}#12\n+; push {r7, lr}\n+; mov r7, sp\n+; sub sp, {{(sp, )?}}#12\n ;\n-; ARM-DISABLE: cmp r0, #0\n-; ARM-DISABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-; THUMB-DISABLE-NEXT: cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n+; cmp r0, #0\n+; beq [[ELSE_LABEL:LBB[0-9_]+]]\n+; cbz r0, [[ELSE_LABEL:LBB[0-9_]+]]\n ;\n ; Setup of the varags.\n-; CHECK: mov r0, r1\n-; CHECK-NEXT: mov r2, r1\n-; CHECK-NEXT: mov r3, r1\n-; ARM-NEXT: str r1, [sp]\n-; ARM-NEXT: str r1, [sp, #4]\n-; THUMB-NEXT: strd r1, r1, [sp]\n-; CHECK-NEXT: str r1, [sp, #8]\n-; CHECK-NEXT: bl{{x?}} _someVariadicFunc\n-; CHECK-NEXT: lsl{{s?}} r0, r0, #3\n-; ARM-NEXT: mov sp, r7\n-; THUMB-NEXT: add sp, #12\n-; CHECK-NEXT: pop {r7, pc}\n-;\n-; CHECK: [[ELSE_LABEL]]: @ %if.else\n+; mov r0, r1\n+; mov r2, r1\n+; mov r3, r1\n+; str r1, [sp]\n+; str r1, [sp, #4]\n+; strd r1, r1, [sp]\n+; str r1, [sp, #8]\n+; bl{{x?}} _someVariadicFunc\n+; lsl{{s?}} r0, r0, #3\n+; mov sp, r7\n+; add sp, #12\n+; pop {r7, pc}\n+;\n+; [[ELSE_LABEL]]: @ %if.else\n ; Shift second argument by one and store into returned register.\n-; CHECK: lsl{{s?}} r0, r1, #1\n+; lsl{{s?}} r0, r1, #1\n ;\n ; Epilogue code.\n-; ENABLE-NEXT: bx lr\n+; bx lr\n ;\n-; ARM-DISABLE-NEXT: mov sp, r7\n-; THUMB-DISABLE-NEXT: add sp, #12\n-; DISABLE-NEXT: pop {r7, pc}\n+; mov sp, r7\n+; add sp, #12\n+; pop {r7, pc}\n define i32 @callVariadicFunc(i32 %cond, i32 %N) \"no-frame-pointer-elim\"=\"true\" {\n+; ARM-ENABLE-LABEL: callVariadicFunc:\n+; ARM-ENABLE:       @ %bb.0: @ %entry\n+; ARM-ENABLE-NEXT:    cmp r0, #0\n+; ARM-ENABLE-NEXT:    beq LBB7_2\n+; ARM-ENABLE-NEXT:  @ %bb.1: @ %if.then\n+; ARM-ENABLE-NEXT:    push {r7, lr}\n+; ARM-ENABLE-NEXT:    mov r7, sp\n+; ARM-ENABLE-NEXT:    sub sp, sp, #12\n+; ARM-ENABLE-NEXT:    mov r0, r1\n+; ARM-ENABLE-NEXT:    mov r2, r1\n+; ARM-ENABLE-NEXT:    mov r3, r1\n+; ARM-ENABLE-NEXT:    str r1, [sp]\n+; ARM-ENABLE-NEXT:    str r1, [sp, #4]\n+; ARM-ENABLE-NEXT:    str r1, [sp, #8]\n+; ARM-ENABLE-NEXT:    bl _someVariadicFunc\n+; ARM-ENABLE-NEXT:    lsl r0, r0, #3\n+; ARM-ENABLE-NEXT:    mov sp, r7\n+; ARM-ENABLE-NEXT:    pop {r7, pc}\n+; ARM-ENABLE-NEXT:  LBB7_2: @ %if.else\n+; ARM-ENABLE-NEXT:    lsl r0, r1, #1\n+; ARM-ENABLE-NEXT:    bx lr\n+;\n+; ARM-DISABLE-LABEL: callVariadicFunc:\n+; ARM-DISABLE:       @ %bb.0: @ %entry\n+; ARM-DISABLE-NEXT:    push {r7, lr}\n+; ARM-DISABLE-NEXT:    mov r7, sp\n+; ARM-DISABLE-NEXT:    sub sp, sp, #12\n+; ARM-DISABLE-NEXT:    cmp r0, #0\n+; ARM-DISABLE-NEXT:    beq LBB7_2\n+; ARM-DISABLE-NEXT:  @ %bb.1: @ %if.then\n+; ARM-DISABLE-NEXT:    mov r0, r1\n+; ARM-DISABLE-NEXT:    mov r2, r1\n+; ARM-DISABLE-NEXT:    mov r3, r1\n+; ARM-DISABLE-NEXT:    str r1, [sp]\n+; ARM-DISABLE-NEXT:    str r1, [sp, #4]\n+; ARM-DISABLE-NEXT:    str r1, [sp, #8]\n+; ARM-DISABLE-NEXT:    bl _someVariadicFunc\n+; ARM-DISABLE-NEXT:    lsl r0, r0, #3\n+; ARM-DISABLE-NEXT:    mov sp, r7\n+; ARM-DISABLE-NEXT:    pop {r7, pc}\n+; ARM-DISABLE-NEXT:  LBB7_2: @ %if.else\n+; ARM-DISABLE-NEXT:    lsl r0, r1, #1\n+; ARM-DISABLE-NEXT:    mov sp, r7\n+; ARM-DISABLE-NEXT:    pop {r7, pc}\n+;\n+; THUMB-ENABLE-LABEL: callVariadicFunc:\n+; THUMB-ENABLE:       @ %bb.0: @ %entry\n+; THUMB-ENABLE-NEXT:    cbz r0, LBB7_2\n+; THUMB-ENABLE-NEXT:  @ %bb.1: @ %if.then\n+; THUMB-ENABLE-NEXT:    push {r7, lr}\n+; THUMB-ENABLE-NEXT:    mov r7, sp\n+; THUMB-ENABLE-NEXT:    sub sp, #12\n+; THUMB-ENABLE-NEXT:    mov r0, r1\n+; THUMB-ENABLE-NEXT:    mov r2, r1\n+; THUMB-ENABLE-NEXT:    mov r3, r1\n+; THUMB-ENABLE-NEXT:    strd r1, r1, [sp]\n+; THUMB-ENABLE-NEXT:    str r1, [sp, #8]\n+; THUMB-ENABLE-NEXT:    bl _someVariadicFunc\n+; THUMB-ENABLE-NEXT:    lsls r0, r0, #3\n+; THUMB-ENABLE-NEXT:    add sp, #12\n+; THUMB-ENABLE-NEXT:    pop {r7, pc}\n+; THUMB-ENABLE-NEXT:  LBB7_2: @ %if.else\n+; THUMB-ENABLE-NEXT:    lsls r0, r1, #1\n+; THUMB-ENABLE-NEXT:    bx lr\n+;\n+; THUMB-DISABLE-LABEL: callVariadicFunc:\n+; THUMB-DISABLE:       @ %bb.0: @ %entry\n+; THUMB-DISABLE-NEXT:    push {r7, lr}\n+; THUMB-DISABLE-NEXT:    mov r7, sp\n+; THUMB-DISABLE-NEXT:    sub sp, #12\n+; THUMB-DISABLE-NEXT:    cbz r0, LBB7_2\n+; THUMB-DISABLE-NEXT:  @ %bb.1: @ %if.then\n+; THUMB-DISABLE-NEXT:    mov r0, r1\n+; THUMB-DISABLE-NEXT:    mov r2, r1\n+; THUMB-DISABLE-NEXT:    mov r3, r1\n+; THUMB-DISABLE-NEXT:    strd r1, r1, [sp]\n+; THUMB-DISABLE-NEXT:    str r1, [sp, #8]\n+; THUMB-DISABLE-NEXT:    bl _someVariadicFunc\n+; THUMB-DISABLE-NEXT:    lsls r0, r0, #3\n+; THUMB-DISABLE-NEXT:    add sp, #12\n+; THUMB-DISABLE-NEXT:    pop {r7, pc}\n+; THUMB-DISABLE-NEXT:  LBB7_2: @ %if.else\n+; THUMB-DISABLE-NEXT:    lsls r0, r1, #1\n+; THUMB-DISABLE-NEXT:    add sp, #12\n+; THUMB-DISABLE-NEXT:    pop {r7, pc}\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %if.then\n@@ -499,29 +1248,86 @@ declare i32 @someVariadicFunc(i32, ...)\n ; Although this is not incorrect to insert such code, it is useless\n ; and it hurts the binary size.\n ;\n-; CHECK-LABEL: noreturn:\n-; DISABLE: push\n-; ARM-ENABLE: cmp r0, #0\n-; ARM-DISABLE: cmp r0, #0\n-; ARM-ENABLE: bne [[ABORT:LBB[0-9_]+]]\n-; ARM-DISABLE: bne [[ABORT:LBB[0-9_]+]]\n-; THUMB-ENABLE: cbnz r0,  [[ABORT:LBB[0-9_]+]]\n-; THUMB-DISABLE: cbnz r0,  [[ABORT:LBB[0-9_]+]]\n+; noreturn:\n+; push\n+; cmp r0, #0\n+; cmp r0, #0\n+; bne [[ABORT:LBB[0-9_]+]]\n+; bne [[ABORT:LBB[0-9_]+]]\n+; cbnz r0,  [[ABORT:LBB[0-9_]+]]\n+; cbnz r0,  [[ABORT:LBB[0-9_]+]]\n \n ;\n-; CHECK: mov{{s?}} r0, #42\n+; mov{{s?}} r0, #42\n ;\n-; ENABLE-NEXT: bx lr\n+; bx lr\n ;\n-; DISABLE-NEXT: pop\n+; pop\n ;;\n-; CHECK: [[ABORT]]: @ %if.abort\n+; [[ABORT]]: @ %if.abort\n ;\n-; ENABLE: push\n+; push\n ;\n-; CHECK: bl{{x?}} _abort\n-; ENABLE-NOT: pop\n+; bl{{x?}} _abort\n+; pop\n define i32 @noreturn(i8 signext %bad_thing) \"no-frame-pointer-elim\"=\"true\" {\n+; ARM-ENABLE-LABEL: noreturn:\n+; ARM-ENABLE:       @ %bb.0: @ %entry\n+; ARM-ENABLE-NEXT:    cmp r0, #0\n+; ARM-ENABLE-NEXT:    bne LBB8_2\n+; ARM-ENABLE-NEXT:  @ %bb.1: @ %if.end\n+; ARM-ENABLE-NEXT:    mov r0, #42\n+; ARM-ENABLE-NEXT:    bx lr\n+; ARM-ENABLE-NEXT:  LBB8_2: @ %if.abort\n+; ARM-ENABLE-NEXT:    push {r4, r7, lr}\n+; ARM-ENABLE-NEXT:    add r7, sp, #4\n+; ARM-ENABLE-NEXT:    @ InlineAsm Start\n+; ARM-ENABLE-NEXT:    mov r0, #1\n+; ARM-ENABLE-NEXT:    @ InlineAsm End\n+; ARM-ENABLE-NEXT:    bl _abort\n+;\n+; ARM-DISABLE-LABEL: noreturn:\n+; ARM-DISABLE:       @ %bb.0: @ %entry\n+; ARM-DISABLE-NEXT:    push {r4, r7, lr}\n+; ARM-DISABLE-NEXT:    add r7, sp, #4\n+; ARM-DISABLE-NEXT:    cmp r0, #0\n+; ARM-DISABLE-NEXT:    bne LBB8_2\n+; ARM-DISABLE-NEXT:  @ %bb.1: @ %if.end\n+; ARM-DISABLE-NEXT:    mov r0, #42\n+; ARM-DISABLE-NEXT:    pop {r4, r7, pc}\n+; ARM-DISABLE-NEXT:  LBB8_2: @ %if.abort\n+; ARM-DISABLE-NEXT:    @ InlineAsm Start\n+; ARM-DISABLE-NEXT:    mov r0, #1\n+; ARM-DISABLE-NEXT:    @ InlineAsm End\n+; ARM-DISABLE-NEXT:    bl _abort\n+;\n+; THUMB-ENABLE-LABEL: noreturn:\n+; THUMB-ENABLE:       @ %bb.0: @ %entry\n+; THUMB-ENABLE-NEXT:    cbnz r0, LBB8_2\n+; THUMB-ENABLE-NEXT:  @ %bb.1: @ %if.end\n+; THUMB-ENABLE-NEXT:    movs r0, #42\n+; THUMB-ENABLE-NEXT:    bx lr\n+; THUMB-ENABLE-NEXT:  LBB8_2: @ %if.abort\n+; THUMB-ENABLE-NEXT:    push {r4, r7, lr}\n+; THUMB-ENABLE-NEXT:    add r7, sp, #4\n+; THUMB-ENABLE-NEXT:    @ InlineAsm Start\n+; THUMB-ENABLE-NEXT:    mov.w r0, #1\n+; THUMB-ENABLE-NEXT:    @ InlineAsm End\n+; THUMB-ENABLE-NEXT:    bl _abort\n+;\n+; THUMB-DISABLE-LABEL: noreturn:\n+; THUMB-DISABLE:       @ %bb.0: @ %entry\n+; THUMB-DISABLE-NEXT:    push {r4, r7, lr}\n+; THUMB-DISABLE-NEXT:    add r7, sp, #4\n+; THUMB-DISABLE-NEXT:    cbnz r0, LBB8_2\n+; THUMB-DISABLE-NEXT:  @ %bb.1: @ %if.end\n+; THUMB-DISABLE-NEXT:    movs r0, #42\n+; THUMB-DISABLE-NEXT:    pop {r4, r7, pc}\n+; THUMB-DISABLE-NEXT:  LBB8_2: @ %if.abort\n+; THUMB-DISABLE-NEXT:    @ InlineAsm Start\n+; THUMB-DISABLE-NEXT:    mov.w r0, #1\n+; THUMB-DISABLE-NEXT:    @ InlineAsm End\n+; THUMB-DISABLE-NEXT:    bl _abort\n entry:\n   %tobool = icmp eq i8 %bad_thing, 0\n   br i1 %tobool, label %if.end, label %if.abort\n@@ -546,9 +1352,142 @@ attributes #0 = { noreturn nounwind }\n ; dominator is itself. In this case, we cannot perform shrink wrapping, but we\n ; should return gracefully and continue compilation.\n ; The only condition for this test is the compilation finishes correctly.\n-; CHECK-LABEL: infiniteloop\n-; CHECK: pop\n+; infiniteloop\n+; pop\n define void @infiniteloop() \"no-frame-pointer-elim\"=\"true\" {\n+; ARM-LABEL: infiniteloop:\n+; ARM:       @ %bb.0: @ %entry\n+; ARM-NEXT:    push {r4, r5, r7, lr}\n+; ARM-NEXT:    add r7, sp, #8\n+; ARM-NEXT:    mov r0, #0\n+; ARM-NEXT:    cmp r0, #0\n+; ARM-NEXT:    bne LBB9_3\n+; ARM-NEXT:  @ %bb.1: @ %if.then\n+; ARM-NEXT:    sub r1, sp, #16\n+; ARM-NEXT:    mov sp, r1\n+; ARM-NEXT:  LBB9_2: @ %for.body\n+; ARM-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-NEXT:    @ InlineAsm Start\n+; ARM-NEXT:    mov r2, #1\n+; ARM-NEXT:    @ InlineAsm End\n+; ARM-NEXT:    add r0, r2, r0\n+; ARM-NEXT:    str r0, [r1]\n+; ARM-NEXT:    b LBB9_2\n+; ARM-NEXT:  LBB9_3: @ %if.end\n+; ARM-NEXT:    sub sp, r7, #8\n+; ARM-NEXT:    pop {r4, r5, r7, pc}\n+;\n+; THUMB-LABEL: infiniteloop:\n+; THUMB:       @ %bb.0: @ %entry\n+; THUMB-NEXT:    push {r4, r5, r7, lr}\n+; THUMB-NEXT:    add r7, sp, #8\n+; THUMB-NEXT:    movs r0, #0\n+; THUMB-NEXT:    cbnz r0, LBB9_3\n+; THUMB-NEXT:  @ %bb.1: @ %if.then\n+; THUMB-NEXT:    sub.w r0, sp, #16\n+; THUMB-NEXT:    mov sp, r0\n+; THUMB-NEXT:    movs r1, #0\n+; THUMB-NEXT:  LBB9_2: @ %for.body\n+; THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-NEXT:    @ InlineAsm Start\n+; THUMB-NEXT:    mov.w r2, #1\n+; THUMB-NEXT:    @ InlineAsm End\n+; THUMB-NEXT:    add r1, r2\n+; THUMB-NEXT:    str r1, [r0]\n+; THUMB-NEXT:    b LBB9_2\n+; THUMB-NEXT:  LBB9_3: @ %if.end\n+; THUMB-NEXT:    sub.w r4, r7, #8\n+; THUMB-NEXT:    mov sp, r4\n+; THUMB-NEXT:    pop {r4, r5, r7, pc}\n+; ARM-ENABLE-LABEL: infiniteloop:\n+; ARM-ENABLE:       @ %bb.0: @ %entry\n+; ARM-ENABLE-NEXT:    push {r4, r5, r7, lr}\n+; ARM-ENABLE-NEXT:    add r7, sp, #8\n+; ARM-ENABLE-NEXT:    mov r0, #0\n+; ARM-ENABLE-NEXT:    cmp r0, #0\n+; ARM-ENABLE-NEXT:    bne LBB9_3\n+; ARM-ENABLE-NEXT:  @ %bb.1: @ %if.then\n+; ARM-ENABLE-NEXT:    sub r1, sp, #16\n+; ARM-ENABLE-NEXT:    mov sp, r1\n+; ARM-ENABLE-NEXT:  LBB9_2: @ %for.body\n+; ARM-ENABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-ENABLE-NEXT:    @ InlineAsm Start\n+; ARM-ENABLE-NEXT:    mov r2, #1\n+; ARM-ENABLE-NEXT:    @ InlineAsm End\n+; ARM-ENABLE-NEXT:    add r0, r2, r0\n+; ARM-ENABLE-NEXT:    str r0, [r1]\n+; ARM-ENABLE-NEXT:    b LBB9_2\n+; ARM-ENABLE-NEXT:  LBB9_3: @ %if.end\n+; ARM-ENABLE-NEXT:    sub sp, r7, #8\n+; ARM-ENABLE-NEXT:    pop {r4, r5, r7, pc}\n+;\n+; ARM-DISABLE-LABEL: infiniteloop:\n+; ARM-DISABLE:       @ %bb.0: @ %entry\n+; ARM-DISABLE-NEXT:    push {r4, r5, r7, lr}\n+; ARM-DISABLE-NEXT:    add r7, sp, #8\n+; ARM-DISABLE-NEXT:    mov r0, #0\n+; ARM-DISABLE-NEXT:    cmp r0, #0\n+; ARM-DISABLE-NEXT:    bne LBB9_3\n+; ARM-DISABLE-NEXT:  @ %bb.1: @ %if.then\n+; ARM-DISABLE-NEXT:    sub r1, sp, #16\n+; ARM-DISABLE-NEXT:    mov sp, r1\n+; ARM-DISABLE-NEXT:  LBB9_2: @ %for.body\n+; ARM-DISABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-DISABLE-NEXT:    @ InlineAsm Start\n+; ARM-DISABLE-NEXT:    mov r2, #1\n+; ARM-DISABLE-NEXT:    @ InlineAsm End\n+; ARM-DISABLE-NEXT:    add r0, r2, r0\n+; ARM-DISABLE-NEXT:    str r0, [r1]\n+; ARM-DISABLE-NEXT:    b LBB9_2\n+; ARM-DISABLE-NEXT:  LBB9_3: @ %if.end\n+; ARM-DISABLE-NEXT:    sub sp, r7, #8\n+; ARM-DISABLE-NEXT:    pop {r4, r5, r7, pc}\n+;\n+; THUMB-ENABLE-LABEL: infiniteloop:\n+; THUMB-ENABLE:       @ %bb.0: @ %entry\n+; THUMB-ENABLE-NEXT:    push {r4, r5, r7, lr}\n+; THUMB-ENABLE-NEXT:    add r7, sp, #8\n+; THUMB-ENABLE-NEXT:    movs r0, #0\n+; THUMB-ENABLE-NEXT:    cbnz r0, LBB9_3\n+; THUMB-ENABLE-NEXT:  @ %bb.1: @ %if.then\n+; THUMB-ENABLE-NEXT:    sub.w r0, sp, #16\n+; THUMB-ENABLE-NEXT:    mov sp, r0\n+; THUMB-ENABLE-NEXT:    movs r1, #0\n+; THUMB-ENABLE-NEXT:  LBB9_2: @ %for.body\n+; THUMB-ENABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-ENABLE-NEXT:    @ InlineAsm Start\n+; THUMB-ENABLE-NEXT:    mov.w r2, #1\n+; THUMB-ENABLE-NEXT:    @ InlineAsm End\n+; THUMB-ENABLE-NEXT:    add r1, r2\n+; THUMB-ENABLE-NEXT:    str r1, [r0]\n+; THUMB-ENABLE-NEXT:    b LBB9_2\n+; THUMB-ENABLE-NEXT:  LBB9_3: @ %if.end\n+; THUMB-ENABLE-NEXT:    sub.w r4, r7, #8\n+; THUMB-ENABLE-NEXT:    mov sp, r4\n+; THUMB-ENABLE-NEXT:    pop {r4, r5, r7, pc}\n+;\n+; THUMB-DISABLE-LABEL: infiniteloop:\n+; THUMB-DISABLE:       @ %bb.0: @ %entry\n+; THUMB-DISABLE-NEXT:    push {r4, r5, r7, lr}\n+; THUMB-DISABLE-NEXT:    add r7, sp, #8\n+; THUMB-DISABLE-NEXT:    movs r0, #0\n+; THUMB-DISABLE-NEXT:    cbnz r0, LBB9_3\n+; THUMB-DISABLE-NEXT:  @ %bb.1: @ %if.then\n+; THUMB-DISABLE-NEXT:    sub.w r0, sp, #16\n+; THUMB-DISABLE-NEXT:    mov sp, r0\n+; THUMB-DISABLE-NEXT:    movs r1, #0\n+; THUMB-DISABLE-NEXT:  LBB9_2: @ %for.body\n+; THUMB-DISABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-DISABLE-NEXT:    @ InlineAsm Start\n+; THUMB-DISABLE-NEXT:    mov.w r2, #1\n+; THUMB-DISABLE-NEXT:    @ InlineAsm End\n+; THUMB-DISABLE-NEXT:    add r1, r2\n+; THUMB-DISABLE-NEXT:    str r1, [r0]\n+; THUMB-DISABLE-NEXT:    b LBB9_2\n+; THUMB-DISABLE-NEXT:  LBB9_3: @ %if.end\n+; THUMB-DISABLE-NEXT:    sub.w r4, r7, #8\n+; THUMB-DISABLE-NEXT:    mov sp, r4\n+; THUMB-DISABLE-NEXT:    pop {r4, r5, r7, pc}\n entry:\n   br i1 undef, label %if.then, label %if.end\n \n@@ -568,8 +1507,8 @@ if.end:\n }\n \n ; Another infinite loop test this time with a body bigger than just one block.\n-; CHECK-LABEL: infiniteloop2\n-; CHECK: pop\n+; infiniteloop2\n+; pop\n define void @infiniteloop2() \"no-frame-pointer-elim\"=\"true\" {\n entry:\n   br i1 undef, label %if.then, label %if.end\n@@ -598,9 +1537,169 @@ if.end:\n }\n \n ; Another infinite loop test this time with two nested infinite loop.\n-; CHECK-LABEL: infiniteloop3\n-; CHECK: bx lr\n+; infiniteloop3\n+; bx lr\n define void @infiniteloop3() \"no-frame-pointer-elim\"=\"true\" {\n+; ARM-LABEL: infiniteloop3:\n+; ARM:       @ %bb.0: @ %entry\n+; ARM-NEXT:    mov r0, #0\n+; ARM-NEXT:    cmp r0, #0\n+; ARM-NEXT:    bne LBB11_5\n+; ARM-NEXT:  @ %bb.1: @ %loop2a.preheader\n+; ARM-NEXT:    mov r1, #0\n+; ARM-NEXT:    mov r2, r0\n+; ARM-NEXT:    b LBB11_3\n+; ARM-NEXT:  LBB11_2: @ %loop2b\n+; ARM-NEXT:    @ in Loop: Header=BB11_3 Depth=1\n+; ARM-NEXT:    str r1, [r2]\n+; ARM-NEXT:    mov r2, r1\n+; ARM-NEXT:    mov r1, r3\n+; ARM-NEXT:  LBB11_3: @ %loop1\n+; ARM-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-NEXT:    ldr r3, [r0]\n+; ARM-NEXT:    cmp r0, #0\n+; ARM-NEXT:    bne LBB11_2\n+; ARM-NEXT:  @ %bb.4: @ in Loop: Header=BB11_3 Depth=1\n+; ARM-NEXT:    mov r0, r1\n+; ARM-NEXT:    mov r1, r3\n+; ARM-NEXT:    mov r2, r0\n+; ARM-NEXT:    b LBB11_3\n+; ARM-NEXT:  LBB11_5: @ %end\n+; ARM-NEXT:    bx lr\n+;\n+; THUMB-LABEL: infiniteloop3:\n+; THUMB:       @ %bb.0: @ %entry\n+; THUMB-NEXT:    movs r0, #0\n+; THUMB-NEXT:    cbnz r0, LBB11_5\n+; THUMB-NEXT:  @ %bb.1: @ %loop2a.preheader\n+; THUMB-NEXT:    movs r0, #0\n+; THUMB-NEXT:    movs r1, #0\n+; THUMB-NEXT:    mov r2, r0\n+; THUMB-NEXT:    b LBB11_3\n+; THUMB-NEXT:  LBB11_2: @ %loop2b\n+; THUMB-NEXT:    @ in Loop: Header=BB11_3 Depth=1\n+; THUMB-NEXT:    str r1, [r2]\n+; THUMB-NEXT:    mov r2, r1\n+; THUMB-NEXT:    mov r1, r3\n+; THUMB-NEXT:  LBB11_3: @ %loop1\n+; THUMB-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-NEXT:    ldr r3, [r0]\n+; THUMB-NEXT:    cmp r0, #0\n+; THUMB-NEXT:    bne LBB11_2\n+; THUMB-NEXT:  @ %bb.4: @ in Loop: Header=BB11_3 Depth=1\n+; THUMB-NEXT:    mov r0, r1\n+; THUMB-NEXT:    mov r1, r3\n+; THUMB-NEXT:    mov r2, r0\n+; THUMB-NEXT:    b LBB11_3\n+; THUMB-NEXT:  LBB11_5: @ %end\n+; THUMB-NEXT:    bx lr\n+; ARM-ENABLE-LABEL: infiniteloop3:\n+; ARM-ENABLE:       @ %bb.0: @ %entry\n+; ARM-ENABLE-NEXT:    mov r0, #0\n+; ARM-ENABLE-NEXT:    cmp r0, #0\n+; ARM-ENABLE-NEXT:    bne LBB11_5\n+; ARM-ENABLE-NEXT:  @ %bb.1: @ %loop2a.preheader\n+; ARM-ENABLE-NEXT:    mov r1, #0\n+; ARM-ENABLE-NEXT:    mov r2, r0\n+; ARM-ENABLE-NEXT:    b LBB11_3\n+; ARM-ENABLE-NEXT:  LBB11_2: @ %loop2b\n+; ARM-ENABLE-NEXT:    @ in Loop: Header=BB11_3 Depth=1\n+; ARM-ENABLE-NEXT:    str r1, [r2]\n+; ARM-ENABLE-NEXT:    mov r2, r1\n+; ARM-ENABLE-NEXT:    mov r1, r3\n+; ARM-ENABLE-NEXT:  LBB11_3: @ %loop1\n+; ARM-ENABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-ENABLE-NEXT:    ldr r3, [r0]\n+; ARM-ENABLE-NEXT:    cmp r0, #0\n+; ARM-ENABLE-NEXT:    bne LBB11_2\n+; ARM-ENABLE-NEXT:  @ %bb.4: @ in Loop: Header=BB11_3 Depth=1\n+; ARM-ENABLE-NEXT:    mov r0, r1\n+; ARM-ENABLE-NEXT:    mov r1, r3\n+; ARM-ENABLE-NEXT:    mov r2, r0\n+; ARM-ENABLE-NEXT:    b LBB11_3\n+; ARM-ENABLE-NEXT:  LBB11_5: @ %end\n+; ARM-ENABLE-NEXT:    bx lr\n+;\n+; ARM-DISABLE-LABEL: infiniteloop3:\n+; ARM-DISABLE:       @ %bb.0: @ %entry\n+; ARM-DISABLE-NEXT:    mov r0, #0\n+; ARM-DISABLE-NEXT:    cmp r0, #0\n+; ARM-DISABLE-NEXT:    bne LBB11_5\n+; ARM-DISABLE-NEXT:  @ %bb.1: @ %loop2a.preheader\n+; ARM-DISABLE-NEXT:    mov r1, #0\n+; ARM-DISABLE-NEXT:    mov r2, r0\n+; ARM-DISABLE-NEXT:    b LBB11_3\n+; ARM-DISABLE-NEXT:  LBB11_2: @ %loop2b\n+; ARM-DISABLE-NEXT:    @ in Loop: Header=BB11_3 Depth=1\n+; ARM-DISABLE-NEXT:    str r1, [r2]\n+; ARM-DISABLE-NEXT:    mov r2, r1\n+; ARM-DISABLE-NEXT:    mov r1, r3\n+; ARM-DISABLE-NEXT:  LBB11_3: @ %loop1\n+; ARM-DISABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ARM-DISABLE-NEXT:    ldr r3, [r0]\n+; ARM-DISABLE-NEXT:    cmp r0, #0\n+; ARM-DISABLE-NEXT:    bne LBB11_2\n+; ARM-DISABLE-NEXT:  @ %bb.4: @ in Loop: Header=BB11_3 Depth=1\n+; ARM-DISABLE-NEXT:    mov r0, r1\n+; ARM-DISABLE-NEXT:    mov r1, r3\n+; ARM-DISABLE-NEXT:    mov r2, r0\n+; ARM-DISABLE-NEXT:    b LBB11_3\n+; ARM-DISABLE-NEXT:  LBB11_5: @ %end\n+; ARM-DISABLE-NEXT:    bx lr\n+;\n+; THUMB-ENABLE-LABEL: infiniteloop3:\n+; THUMB-ENABLE:       @ %bb.0: @ %entry\n+; THUMB-ENABLE-NEXT:    movs r0, #0\n+; THUMB-ENABLE-NEXT:    cbnz r0, LBB11_5\n+; THUMB-ENABLE-NEXT:  @ %bb.1: @ %loop2a.preheader\n+; THUMB-ENABLE-NEXT:    movs r0, #0\n+; THUMB-ENABLE-NEXT:    movs r1, #0\n+; THUMB-ENABLE-NEXT:    mov r2, r0\n+; THUMB-ENABLE-NEXT:    b LBB11_3\n+; THUMB-ENABLE-NEXT:  LBB11_2: @ %loop2b\n+; THUMB-ENABLE-NEXT:    @ in Loop: Header=BB11_3 Depth=1\n+; THUMB-ENABLE-NEXT:    str r1, [r2]\n+; THUMB-ENABLE-NEXT:    mov r2, r1\n+; THUMB-ENABLE-NEXT:    mov r1, r3\n+; THUMB-ENABLE-NEXT:  LBB11_3: @ %loop1\n+; THUMB-ENABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-ENABLE-NEXT:    ldr r3, [r0]\n+; THUMB-ENABLE-NEXT:    cmp r0, #0\n+; THUMB-ENABLE-NEXT:    bne LBB11_2\n+; THUMB-ENABLE-NEXT:  @ %bb.4: @ in Loop: Header=BB11_3 Depth=1\n+; THUMB-ENABLE-NEXT:    mov r0, r1\n+; THUMB-ENABLE-NEXT:    mov r1, r3\n+; THUMB-ENABLE-NEXT:    mov r2, r0\n+; THUMB-ENABLE-NEXT:    b LBB11_3\n+; THUMB-ENABLE-NEXT:  LBB11_5: @ %end\n+; THUMB-ENABLE-NEXT:    bx lr\n+;\n+; THUMB-DISABLE-LABEL: infiniteloop3:\n+; THUMB-DISABLE:       @ %bb.0: @ %entry\n+; THUMB-DISABLE-NEXT:    movs r0, #0\n+; THUMB-DISABLE-NEXT:    cbnz r0, LBB11_5\n+; THUMB-DISABLE-NEXT:  @ %bb.1: @ %loop2a.preheader\n+; THUMB-DISABLE-NEXT:    movs r0, #0\n+; THUMB-DISABLE-NEXT:    movs r1, #0\n+; THUMB-DISABLE-NEXT:    mov r2, r0\n+; THUMB-DISABLE-NEXT:    b LBB11_3\n+; THUMB-DISABLE-NEXT:  LBB11_2: @ %loop2b\n+; THUMB-DISABLE-NEXT:    @ in Loop: Header=BB11_3 Depth=1\n+; THUMB-DISABLE-NEXT:    str r1, [r2]\n+; THUMB-DISABLE-NEXT:    mov r2, r1\n+; THUMB-DISABLE-NEXT:    mov r1, r3\n+; THUMB-DISABLE-NEXT:  LBB11_3: @ %loop1\n+; THUMB-DISABLE-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; THUMB-DISABLE-NEXT:    ldr r3, [r0]\n+; THUMB-DISABLE-NEXT:    cmp r0, #0\n+; THUMB-DISABLE-NEXT:    bne LBB11_2\n+; THUMB-DISABLE-NEXT:  @ %bb.4: @ in Loop: Header=BB11_3 Depth=1\n+; THUMB-DISABLE-NEXT:    mov r0, r1\n+; THUMB-DISABLE-NEXT:    mov r1, r3\n+; THUMB-DISABLE-NEXT:    mov r2, r0\n+; THUMB-DISABLE-NEXT:    b LBB11_3\n+; THUMB-DISABLE-NEXT:  LBB11_5: @ %end\n+; THUMB-DISABLE-NEXT:    bx lr\n entry:\n   br i1 undef, label %loop2a, label %body\n \n@@ -636,31 +1735,127 @@ declare double @llvm.pow.f64(double, double)\n ; exercise the path where we were dereferencing the end iterator\n ; to access debug info location while inserting the spill code\n ; during PEI with shrink-wrapping enable.\n-; CHECK-LABEL: debug_info:\n+; debug_info:\n ;\n-; ENABLE: {{tst  r2, #1|lsls r1, r2, #31}}\n-; ENABLE-NEXT: beq      [[BB13:LBB[0-9_]+]]\n+; {{tst  r2, #1|lsls r1, r2, #31}}\n+; beq      [[BB13:LBB[0-9_]+]]\n ;\n-; CHECK: push\n+; push\n ;\n-; DISABLE: {{tst  r2, #1|lsls r1, r2, #31}}\n-; DISABLE: beq      [[BB13:LBB[0-9_]+]]\n+; {{tst  r2, #1|lsls r1, r2, #31}}\n+; beq      [[BB13:LBB[0-9_]+]]\n ;\n-; CHECK: bl{{x?}} _pow\n+; bl{{x?}} _pow\n ;\n ;\n-; ENABLE: pop\n+; pop\n ;\n-; CHECK: [[BB13]]:\n-; CHECK: vldr\n+; [[BB13]]:\n+; vldr\n ;\n-; DISABLE: pop\n+; pop\n ;\n ; FIXME: This is flakey passing by finding 'bl' somewhere amongst the debug\n ; info (like labels named 'line_table) not because it's found a bl instruction.\n ;\n-; CHECK: bl\n+; bl\n define float @debug_info(float %gamma, float %slopeLimit, i1 %or.cond, double %tmp) \"no-frame-pointer-elim\"=\"true\" {\n+; ARM-LABEL: debug_info:\n+; ARM:       @ %bb.0: @ %bb\n+; ARM-NEXT:    push {r4, r7, lr}\n+; ARM-NEXT:    add r7, sp, #4\n+; ARM-NEXT:    sub r4, sp, #16\n+; ARM-NEXT:    bfc r4, #0, #4\n+; ARM-NEXT:    mov sp, r4\n+; ARM-NEXT:    tst r2, #1\n+; ARM-NEXT:    vst1.64 {d8, d9}, [r4:128]\n+; ARM-NEXT:    beq LBB12_2\n+; ARM-NEXT:  @ %bb.1: @ %bb3\n+; ARM-NEXT:    ldr r1, [r7, #8]\n+; ARM-NEXT:    vmov s16, r0\n+; ARM-NEXT:    mov r0, r3\n+; ARM-NEXT:    mov r2, r3\n+; ARM-NEXT:    vmov d9, r3, r1\n+; ARM-NEXT:    mov r3, r1\n+; ARM-NEXT:    bl _pow\n+; ARM-NEXT:    vmov.f32 s0, #1.000000e+00\n+; ARM-NEXT:    vmov.f64 d16, #1.000000e+00\n+; ARM-NEXT:    vadd.f64 d16, d9, d16\n+; ARM-NEXT:    vcmpe.f32 s16, s0\n+; ARM-NEXT:    vmrs APSR_nzcv, fpscr\n+; ARM-NEXT:    vmov d17, r0, r1\n+; ARM-NEXT:    vmov.f64 d18, d9\n+; ARM-NEXT:    vadd.f64 d17, d17, d17\n+; ARM-NEXT:    vmovgt.f64 d18, d16\n+; ARM-NEXT:    vcmp.f64 d18, d9\n+; ARM-NEXT:    vmrs APSR_nzcv, fpscr\n+; ARM-NEXT:    vmovne.f64 d9, d17\n+; ARM-NEXT:    vcvt.f32.f64 s0, d9\n+; ARM-NEXT:    b LBB12_3\n+; ARM-NEXT:  LBB12_2:\n+; ARM-NEXT:    vldr s0, LCPI12_0\n+; ARM-NEXT:  LBB12_3: @ %bb13\n+; ARM-NEXT:    mov r4, sp\n+; ARM-NEXT:    vld1.64 {d8, d9}, [r4:128]\n+; ARM-NEXT:    vmov r0, s0\n+; ARM-NEXT:    sub sp, r7, #4\n+; ARM-NEXT:    pop {r4, r7, pc}\n+; ARM-NEXT:    .p2align 2\n+; ARM-NEXT:  @ %bb.4:\n+; ARM-NEXT:    .data_region\n+; ARM-NEXT:  LCPI12_0:\n+; ARM-NEXT:    .long 0 @ float 0\n+; ARM-NEXT:    .end_data_region\n+;\n+; THUMB-LABEL: debug_info:\n+; THUMB:       @ %bb.0: @ %bb\n+; THUMB-NEXT:    push {r4, r7, lr}\n+; THUMB-NEXT:    add r7, sp, #4\n+; THUMB-NEXT:    sub.w r4, sp, #16\n+; THUMB-NEXT:    bfc r4, #0, #4\n+; THUMB-NEXT:    mov sp, r4\n+; THUMB-NEXT:    lsls r1, r2, #31\n+; THUMB-NEXT:    vst1.64 {d8, d9}, [r4:128]\n+; THUMB-NEXT:    beq LBB12_2\n+; THUMB-NEXT:  @ %bb.1: @ %bb3\n+; THUMB-NEXT:    ldr r1, [r7, #8]\n+; THUMB-NEXT:    vmov s16, r0\n+; THUMB-NEXT:    mov r0, r3\n+; THUMB-NEXT:    mov r2, r3\n+; THUMB-NEXT:    vmov d9, r3, r1\n+; THUMB-NEXT:    mov r3, r1\n+; THUMB-NEXT:    bl _pow\n+; THUMB-NEXT:    vmov.f32 s0, #1.000000e+00\n+; THUMB-NEXT:    vmov.f64 d16, #1.000000e+00\n+; THUMB-NEXT:    vmov.f64 d18, d9\n+; THUMB-NEXT:    vcmpe.f32 s16, s0\n+; THUMB-NEXT:    vadd.f64 d16, d9, d16\n+; THUMB-NEXT:    vmrs APSR_nzcv, fpscr\n+; THUMB-NEXT:    it gt\n+; THUMB-NEXT:    vmovgt.f64 d18, d16\n+; THUMB-NEXT:    vcmp.f64 d18, d9\n+; THUMB-NEXT:    vmov d17, r0, r1\n+; THUMB-NEXT:    vmrs APSR_nzcv, fpscr\n+; THUMB-NEXT:    vadd.f64 d17, d17, d17\n+; THUMB-NEXT:    it ne\n+; THUMB-NEXT:    vmovne.f64 d9, d17\n+; THUMB-NEXT:    vcvt.f32.f64 s0, d9\n+; THUMB-NEXT:    b LBB12_3\n+; THUMB-NEXT:  LBB12_2:\n+; THUMB-NEXT:    vldr s0, LCPI12_0\n+; THUMB-NEXT:  LBB12_3: @ %bb13\n+; THUMB-NEXT:    mov r4, sp\n+; THUMB-NEXT:    vld1.64 {d8, d9}, [r4:128]\n+; THUMB-NEXT:    subs r4, r7, #4\n+; THUMB-NEXT:    vmov r0, s0\n+; THUMB-NEXT:    mov sp, r4\n+; THUMB-NEXT:    pop {r4, r7, pc}\n+; THUMB-NEXT:    .p2align 2\n+; THUMB-NEXT:  @ %bb.4:\n+; THUMB-NEXT:    .data_region\n+; THUMB-NEXT:  LCPI12_0:\n+; THUMB-NEXT:    .long 0 @ float 0\n+; THUMB-NEXT:    .end_data_region\n bb:\n   br i1 %or.cond, label %bb3, label %bb13\n "
            },
            {
                "fn": "llvm/test/CodeGen/PowerPC/BreakableToken-reduced.ll",
                "patch": "@@ -203,8 +203,8 @@ target triple = \"powerpc64le-unknown-linux-gnu\"\n ; Load a value into R0 before saving the LR\n ; CHECK: lwz 0, {{[0-9]+([0-9]+)}}\n \n-; Ensure the LR is saved using a different register\n-; CHECK: mflr {{[1-9]+}}\n+; Ensure the LR is saved using a different register - edit:D63152 prevents stack pop befor loads and stores\n+; CHECK-NOT: mflr {{[1-9]+}}\n \n ; Ensure the LR is restored using a different register\n ; CHECK: mtlr {{[0-9]+}}"
            },
            {
                "fn": "llvm/test/CodeGen/PowerPC/ifcvt-forked-bug-2016-08-08.ll",
                "patch": "@@ -10,7 +10,8 @@ entry:\n   br i1 undef, label %land.lhs.true, label %if.end\n \n ; CHECK: # %land.lhs.true\n-; CHECK-NEXT: bclr\n+; Test updated due D63152 where any load/store prevents shrink-wrapping\n+; CHECK-NEXT: bc\n ; CHECK-NEXT: # %if.end4\n land.lhs.true:                                    ; preds = %entry\n   br i1 undef, label %return, label %if.end4"
            },
            {
                "fn": "llvm/test/CodeGen/PowerPC/licm-tocReg.ll",
                "patch": "@@ -61,11 +61,11 @@\n \n @ga = external global i32, align 4\n @gb = external global i32, align 4\n-\n define signext i32 @test(i32 (i32)* nocapture %FP) local_unnamed_addr #0 {\n ; CHECK-LABEL: test:\n ; CHECK:       # %bb.0: # %entry\n-; CHECK-NEXT:    addis 4, 2, .LC0@toc@ha\n+; CHECK-NEXT:    mflr 0\n+; CHECK:         addis 4, 2, .LC0@toc@ha\n ; CHECK-NEXT:    addis 5, 2, .LC1@toc@ha\n ; CHECK-NEXT:    mr 12, 3\n ; CHECK-NEXT:    ld 4, .LC0@toc@l(4)"
            },
            {
                "fn": "llvm/test/CodeGen/PowerPC/ppc64-sibcall-shrinkwrap.ll",
                "patch": "@@ -1,8 +1,8 @@\n ; RUN: llc -relocation-model=static -verify-machineinstrs < %s -mtriple=powerpc64-unknown-linux-gnu -disable-ppc-sco=false --enable-shrink-wrap=false | FileCheck %s -check-prefix=CHECK-SCO-ONLY\n-; RUN: llc -relocation-model=static -verify-machineinstrs < %s -mtriple=powerpc64-unknown-linux-gnu -disable-ppc-sco=false --enable-shrink-wrap=true | FileCheck %s -check-prefix=CHECK-SCO-SHRK\n+; RUN: llc -relocation-model=static -verify-machineinstrs < %s -mtriple=powerpc64-unknown-linux-gnu -disable-ppc-sco=false --enable-shrink-wrap=true | FileCheck %s -check-prefix=CHECK-SCO-ONLY\n ; RUN: llc -relocation-model=static -verify-machineinstrs < %s -mtriple=powerpc64le-unknown-linux-gnu -disable-ppc-sco=false --enable-shrink-wrap=false | FileCheck %s -check-prefix=CHECK-SCO-ONLY\n-; RUN: llc -relocation-model=static -verify-machineinstrs < %s -mtriple=powerpc64le-unknown-linux-gnu -disable-ppc-sco=false --enable-shrink-wrap=true | FileCheck %s -check-prefix=CHECK-SCO-SHRK\n-\n+; RUN: llc -relocation-model=static -verify-machineinstrs < %s -mtriple=powerpc64le-unknown-linux-gnu -disable-ppc-sco=false --enable-shrink-wrap=true | FileCheck %s -check-prefix=CHECK-SCO-ONLY\n+; Edit: D63152 prevents stack popping before loads and stores, so shrink-wrap does nothing here\n %\"class.clang::NamedDecl\" = type { i32 }\n declare void @__assert_fail();\n "
            },
            {
                "fn": "llvm/test/CodeGen/PowerPC/xray-ret-is-terminator.ll",
                "patch": "@@ -2,9 +2,9 @@\n \n define void @ILLBeBack() #0 {\n ; CHECK-LABEL @ILLBeBack\n-; CHECK: beq {{[0-9]+}}, [[LABEL:\\.[a-zA-Z0-9_]+]]\n-; CHECK: bl __xray_FunctionExit\n+; CHECK: bne {{[0-9]+}}, [[LABEL:\\.[a-zA-Z0-9_]+]]\n ; CHECK: [[LABEL]]:\n+; CHECK: bl __xray_FunctionExit\n bb:\n   br i1 undef, label %bb1, label %bb8\n "
            },
            {
                "fn": "llvm/test/CodeGen/Thumb/thumb-shrink-wrapping.ll",
                "patch": "@@ -1,11 +1,8 @@\n-; RUN: llc %s -o - -enable-shrink-wrap=true -ifcvt-fn-start=1 -ifcvt-fn-stop=0 -tail-dup-placement=0 -mtriple=thumb-macho \\\n-; RUN:      | FileCheck %s --check-prefix=CHECK --check-prefix=ENABLE --check-prefix=ENABLE-V4T\n-; RUN: llc %s -o - -enable-shrink-wrap=true -ifcvt-fn-start=1 -ifcvt-fn-stop=0 -tail-dup-placement=0 -mtriple=thumbv5-macho \\\n-; RUN:      | FileCheck %s --check-prefix=CHECK --check-prefix=ENABLE --check-prefix=ENABLE-V5T\n-; RUN: llc %s -o - -enable-shrink-wrap=false -ifcvt-fn-start=1 -ifcvt-fn-stop=0 -tail-dup-placement=0 -mtriple=thumb-macho \\\n-; RUN:      | FileCheck %s --check-prefix=CHECK --check-prefix=DISABLE --check-prefix=DISABLE-V4T\n-; RUN: llc %s -o - -enable-shrink-wrap=false -ifcvt-fn-start=1 -ifcvt-fn-stop=0 -tail-dup-placement=0 -mtriple=thumbv5-macho \\\n-; RUN:      | FileCheck %s --check-prefix=CHECK --check-prefix=DISABLE --check-prefix=DISABLE-V5T\n+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py\n+; RUN: llc %s -o - -enable-shrink-wrap=true -ifcvt-fn-start=1 -ifcvt-fn-stop=0 -tail-dup-placement=0 -mtriple=thumb-macho | FileCheck %s --check-prefix=ENABLE-V4T\n+; RUN: llc %s -o - -enable-shrink-wrap=true -ifcvt-fn-start=1 -ifcvt-fn-stop=0 -tail-dup-placement=0 -mtriple=thumbv5-macho | FileCheck %s --check-prefix=ENABLE-V5T\n+; RUN: llc %s -o - -enable-shrink-wrap=false -ifcvt-fn-start=1 -ifcvt-fn-stop=0 -tail-dup-placement=0 -mtriple=thumb-macho | FileCheck %s --check-prefix=DISABLE-V4T\n+; RUN: llc %s -o - -enable-shrink-wrap=false -ifcvt-fn-start=1 -ifcvt-fn-stop=0 -tail-dup-placement=0 -mtriple=thumbv5-macho | FileCheck %s --check-prefix=DISABLE-V5T\n \n ;\n ; Note: Lots of tests use inline asm instead of regular calls.\n@@ -20,49 +17,108 @@\n ; results due to branches not being analyzable under v5\n \n ; Initial motivating example: Simple diamond with a call just on one side.\n-; CHECK-LABEL: foo:\n-;\n-; Compare the arguments and jump to exit.\n-; No prologue needed.\n-; ENABLE: cmp r0, r1\n-; ENABLE-NEXT: bge [[EXIT_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; CHECK: push {r7, lr}\n-; CHECK: sub sp, #8\n-;\n-; Compare the arguments and jump to exit.\n-; After the prologue is set.\n-; DISABLE: cmp r0, r1\n-; DISABLE-NEXT: bge [[EXIT_LABEL:LBB[0-9_]+]]\n-;\n-; Store %a in the alloca.\n-; CHECK: str r0, [sp, #4]\n-; Set the alloca address in the second argument.\n-; Set the first argument to zero.\n-; CHECK: movs r0, #0\n-; CHECK-NEXT: add r1, sp, #4\n-; CHECK-NEXT: bl\n-;\n-; With shrink-wrapping, epilogue is just after the call.\n-; ENABLE-NEXT: add sp, #8\n-; ENABLE-V5T-NEXT: pop {r7, pc}\n-; ENABLE-V4T-NEXT: pop {r7}\n-; ENABLE-V4T-NEXT: pop {r1}\n-; ENABLE-V4T-NEXT: mov lr, r1\n-;\n-; CHECK: [[EXIT_LABEL]]:\n-;\n-; Without shrink-wrapping, epilogue is in the exit block.\n-; Epilogue code. (What we pop does not matter.)\n-; DISABLE: add sp, #8\n-; DISABLE-V5T-NEXT: pop {r7, pc}\n-; DISABLE-V4T-NEXT: pop {r7}\n-; DISABLE-V4T-NEXT: pop {r1}\n-; DISABLE-V4T-NEXT: bx r1\n-;\n-; ENABLE-NEXT: bx lr\n define i32 @foo(i32 %a, i32 %b) {\n+; ENABLE-V4T-LABEL: foo:\n+; ENABLE-V4T:       @ %bb.0:\n+; ENABLE-V4T-NEXT:    cmp r0, r1\n+; ENABLE-V4T-NEXT:    bge LBB0_2\n+; ENABLE-V4T-NEXT:  @ %bb.1: @ %true\n+; ENABLE-V4T-NEXT:    push {r7, lr}\n+; ENABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V4T-NEXT:    .cfi_offset r7, -8\n+; ENABLE-V4T-NEXT:    sub sp, #8\n+; ENABLE-V4T-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-V4T-NEXT:    str r0, [sp, #4]\n+; ENABLE-V4T-NEXT:    ldr r0, LCPI0_0\n+; ENABLE-V4T-NEXT:  LPC0_0:\n+; ENABLE-V4T-NEXT:    add r0, pc\n+; ENABLE-V4T-NEXT:    ldr r2, [r0]\n+; ENABLE-V4T-NEXT:    movs r0, #0\n+; ENABLE-V4T-NEXT:    add r1, sp, #4\n+; ENABLE-V4T-NEXT:    bl Ltmp0\n+; ENABLE-V4T-NEXT:    add sp, #8\n+; ENABLE-V4T-NEXT:    pop {r7}\n+; ENABLE-V4T-NEXT:    pop {r1}\n+; ENABLE-V4T-NEXT:    mov lr, r1\n+; ENABLE-V4T-NEXT:  LBB0_2: @ %false\n+; ENABLE-V4T-NEXT:    bx lr\n+; ENABLE-V4T-NEXT:    .p2align 2\n+; ENABLE-V4T-NEXT:  @ %bb.3:\n+; ENABLE-V4T-NEXT:    .data_region\n+; ENABLE-V4T-NEXT:  LCPI0_0:\n+; ENABLE-V4T-NEXT:    .long L_doSomething$non_lazy_ptr-(LPC0_0+4)\n+; ENABLE-V4T-NEXT:    .end_data_region\n+;\n+; ENABLE-V5T-LABEL: foo:\n+; ENABLE-V5T:       @ %bb.0:\n+; ENABLE-V5T-NEXT:    cmp r0, r1\n+; ENABLE-V5T-NEXT:    bge LBB0_2\n+; ENABLE-V5T-NEXT:  @ %bb.1: @ %true\n+; ENABLE-V5T-NEXT:    push {r7, lr}\n+; ENABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V5T-NEXT:    .cfi_offset r7, -8\n+; ENABLE-V5T-NEXT:    sub sp, #8\n+; ENABLE-V5T-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-V5T-NEXT:    str r0, [sp, #4]\n+; ENABLE-V5T-NEXT:    movs r0, #0\n+; ENABLE-V5T-NEXT:    add r1, sp, #4\n+; ENABLE-V5T-NEXT:    bl _doSomething\n+; ENABLE-V5T-NEXT:    add sp, #8\n+; ENABLE-V5T-NEXT:    pop {r7, pc}\n+; ENABLE-V5T-NEXT:  LBB0_2: @ %false\n+; ENABLE-V5T-NEXT:    bx lr\n+;\n+; DISABLE-V4T-LABEL: foo:\n+; DISABLE-V4T:       @ %bb.0:\n+; DISABLE-V4T-NEXT:    push {r7, lr}\n+; DISABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V4T-NEXT:    .cfi_offset r7, -8\n+; DISABLE-V4T-NEXT:    sub sp, #8\n+; DISABLE-V4T-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-V4T-NEXT:    cmp r0, r1\n+; DISABLE-V4T-NEXT:    bge LBB0_2\n+; DISABLE-V4T-NEXT:  @ %bb.1: @ %true\n+; DISABLE-V4T-NEXT:    str r0, [sp, #4]\n+; DISABLE-V4T-NEXT:    ldr r0, LCPI0_0\n+; DISABLE-V4T-NEXT:  LPC0_0:\n+; DISABLE-V4T-NEXT:    add r0, pc\n+; DISABLE-V4T-NEXT:    ldr r2, [r0]\n+; DISABLE-V4T-NEXT:    movs r0, #0\n+; DISABLE-V4T-NEXT:    add r1, sp, #4\n+; DISABLE-V4T-NEXT:    bl Ltmp0\n+; DISABLE-V4T-NEXT:  LBB0_2: @ %false\n+; DISABLE-V4T-NEXT:    add sp, #8\n+; DISABLE-V4T-NEXT:    pop {r7}\n+; DISABLE-V4T-NEXT:    pop {r1}\n+; DISABLE-V4T-NEXT:    bx r1\n+; DISABLE-V4T-NEXT:    .p2align 2\n+; DISABLE-V4T-NEXT:  @ %bb.3:\n+; DISABLE-V4T-NEXT:    .data_region\n+; DISABLE-V4T-NEXT:  LCPI0_0:\n+; DISABLE-V4T-NEXT:    .long L_doSomething$non_lazy_ptr-(LPC0_0+4)\n+; DISABLE-V4T-NEXT:    .end_data_region\n+;\n+; DISABLE-V5T-LABEL: foo:\n+; DISABLE-V5T:       @ %bb.0:\n+; DISABLE-V5T-NEXT:    push {r7, lr}\n+; DISABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V5T-NEXT:    .cfi_offset r7, -8\n+; DISABLE-V5T-NEXT:    sub sp, #8\n+; DISABLE-V5T-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-V5T-NEXT:    cmp r0, r1\n+; DISABLE-V5T-NEXT:    bge LBB0_2\n+; DISABLE-V5T-NEXT:  @ %bb.1: @ %true\n+; DISABLE-V5T-NEXT:    str r0, [sp, #4]\n+; DISABLE-V5T-NEXT:    movs r0, #0\n+; DISABLE-V5T-NEXT:    add r1, sp, #4\n+; DISABLE-V5T-NEXT:    bl _doSomething\n+; DISABLE-V5T-NEXT:  LBB0_2: @ %false\n+; DISABLE-V5T-NEXT:    add sp, #8\n+; DISABLE-V5T-NEXT:    pop {r7, pc}\n   %tmp = alloca i32, align 4\n   %tmp2 = icmp slt i32 %a, %b\n   br i1 %tmp2, label %true, label %false\n@@ -79,27 +135,114 @@ false:\n \n \n ; Same, but the final BB is non-trivial, so we don't duplicate the return inst.\n-; CHECK-LABEL: bar:\n-;\n-; With shrink-wrapping, epilogue is just after the call.\n-; CHECK: bl\n-; ENABLE-NEXT: add sp, #8\n-; ENABLE-NEXT: pop {r7}\n-; ENABLE-NEXT: pop {r0}\n-; ENABLE-NEXT: mov lr, r0\n-;\n-; CHECK: movs r0, #42\n-;\n-; Without shrink-wrapping, epilogue is in the exit block.\n-; Epilogue code. (What we pop does not matter.)\n-; DISABLE: add sp, #8\n-; DISABLE-V5T-NEXT: pop {r7, pc}\n-; DISABLE-V4T-NEXT: pop {r7}\n-; DISABLE-V4T-NEXT: pop {r1}\n-; DISABLE-V4T-NEXT: bx r1\n-;\n-; ENABLE-NEXT: bx lr\n define i32 @bar(i32 %a, i32 %b) {\n+; ENABLE-V4T-LABEL: bar:\n+; ENABLE-V4T:       @ %bb.0:\n+; ENABLE-V4T-NEXT:    cmp r0, r1\n+; ENABLE-V4T-NEXT:    bge LBB1_2\n+; ENABLE-V4T-NEXT:  @ %bb.1: @ %true\n+; ENABLE-V4T-NEXT:    push {r7, lr}\n+; ENABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V4T-NEXT:    .cfi_offset r7, -8\n+; ENABLE-V4T-NEXT:    sub sp, #8\n+; ENABLE-V4T-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-V4T-NEXT:    str r0, [sp, #4]\n+; ENABLE-V4T-NEXT:    ldr r0, LCPI1_0\n+; ENABLE-V4T-NEXT:  LPC1_0:\n+; ENABLE-V4T-NEXT:    add r0, pc\n+; ENABLE-V4T-NEXT:    ldr r2, [r0]\n+; ENABLE-V4T-NEXT:    movs r0, #0\n+; ENABLE-V4T-NEXT:    add r1, sp, #4\n+; ENABLE-V4T-NEXT:    bl Ltmp1\n+; ENABLE-V4T-NEXT:    add sp, #8\n+; ENABLE-V4T-NEXT:    pop {r7}\n+; ENABLE-V4T-NEXT:    pop {r0}\n+; ENABLE-V4T-NEXT:    mov lr, r0\n+; ENABLE-V4T-NEXT:  LBB1_2: @ %false\n+; ENABLE-V4T-NEXT:    movs r0, #42\n+; ENABLE-V4T-NEXT:    bx lr\n+; ENABLE-V4T-NEXT:    .p2align 2\n+; ENABLE-V4T-NEXT:  @ %bb.3:\n+; ENABLE-V4T-NEXT:    .data_region\n+; ENABLE-V4T-NEXT:  LCPI1_0:\n+; ENABLE-V4T-NEXT:    .long L_doSomething$non_lazy_ptr-(LPC1_0+4)\n+; ENABLE-V4T-NEXT:    .end_data_region\n+;\n+; ENABLE-V5T-LABEL: bar:\n+; ENABLE-V5T:       @ %bb.0:\n+; ENABLE-V5T-NEXT:    cmp r0, r1\n+; ENABLE-V5T-NEXT:    bge LBB1_2\n+; ENABLE-V5T-NEXT:  @ %bb.1: @ %true\n+; ENABLE-V5T-NEXT:    push {r7, lr}\n+; ENABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V5T-NEXT:    .cfi_offset r7, -8\n+; ENABLE-V5T-NEXT:    sub sp, #8\n+; ENABLE-V5T-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-V5T-NEXT:    str r0, [sp, #4]\n+; ENABLE-V5T-NEXT:    movs r0, #0\n+; ENABLE-V5T-NEXT:    add r1, sp, #4\n+; ENABLE-V5T-NEXT:    bl _doSomething\n+; ENABLE-V5T-NEXT:    add sp, #8\n+; ENABLE-V5T-NEXT:    pop {r7}\n+; ENABLE-V5T-NEXT:    pop {r0}\n+; ENABLE-V5T-NEXT:    mov lr, r0\n+; ENABLE-V5T-NEXT:  LBB1_2: @ %false\n+; ENABLE-V5T-NEXT:    movs r0, #42\n+; ENABLE-V5T-NEXT:    bx lr\n+;\n+; DISABLE-V4T-LABEL: bar:\n+; DISABLE-V4T:       @ %bb.0:\n+; DISABLE-V4T-NEXT:    push {r7, lr}\n+; DISABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V4T-NEXT:    .cfi_offset r7, -8\n+; DISABLE-V4T-NEXT:    sub sp, #8\n+; DISABLE-V4T-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-V4T-NEXT:    cmp r0, r1\n+; DISABLE-V4T-NEXT:    bge LBB1_2\n+; DISABLE-V4T-NEXT:  @ %bb.1: @ %true\n+; DISABLE-V4T-NEXT:    str r0, [sp, #4]\n+; DISABLE-V4T-NEXT:    ldr r0, LCPI1_0\n+; DISABLE-V4T-NEXT:  LPC1_0:\n+; DISABLE-V4T-NEXT:    add r0, pc\n+; DISABLE-V4T-NEXT:    ldr r2, [r0]\n+; DISABLE-V4T-NEXT:    movs r0, #0\n+; DISABLE-V4T-NEXT:    add r1, sp, #4\n+; DISABLE-V4T-NEXT:    bl Ltmp1\n+; DISABLE-V4T-NEXT:  LBB1_2: @ %false\n+; DISABLE-V4T-NEXT:    movs r0, #42\n+; DISABLE-V4T-NEXT:    add sp, #8\n+; DISABLE-V4T-NEXT:    pop {r7}\n+; DISABLE-V4T-NEXT:    pop {r1}\n+; DISABLE-V4T-NEXT:    bx r1\n+; DISABLE-V4T-NEXT:    .p2align 2\n+; DISABLE-V4T-NEXT:  @ %bb.3:\n+; DISABLE-V4T-NEXT:    .data_region\n+; DISABLE-V4T-NEXT:  LCPI1_0:\n+; DISABLE-V4T-NEXT:    .long L_doSomething$non_lazy_ptr-(LPC1_0+4)\n+; DISABLE-V4T-NEXT:    .end_data_region\n+;\n+; DISABLE-V5T-LABEL: bar:\n+; DISABLE-V5T:       @ %bb.0:\n+; DISABLE-V5T-NEXT:    push {r7, lr}\n+; DISABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V5T-NEXT:    .cfi_offset r7, -8\n+; DISABLE-V5T-NEXT:    sub sp, #8\n+; DISABLE-V5T-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-V5T-NEXT:    cmp r0, r1\n+; DISABLE-V5T-NEXT:    bge LBB1_2\n+; DISABLE-V5T-NEXT:  @ %bb.1: @ %true\n+; DISABLE-V5T-NEXT:    str r0, [sp, #4]\n+; DISABLE-V5T-NEXT:    movs r0, #0\n+; DISABLE-V5T-NEXT:    add r1, sp, #4\n+; DISABLE-V5T-NEXT:    bl _doSomething\n+; DISABLE-V5T-NEXT:  LBB1_2: @ %false\n+; DISABLE-V5T-NEXT:    movs r0, #42\n+; DISABLE-V5T-NEXT:    add sp, #8\n+; DISABLE-V5T-NEXT:    pop {r7, pc}\n   %tmp = alloca i32, align 4\n   %tmp2 = icmp slt i32 %a, %b\n   br i1 %tmp2, label %true, label %false\n@@ -119,51 +262,128 @@ declare i32 @doSomething(i32, i32*)\n \n ; Check that we do not perform the restore inside the loop whereas the save\n ; is outside.\n-; CHECK-LABEL: freqSaveAndRestoreOutsideLoop:\n-;\n-; Shrink-wrapping allows to skip the prologue in the else case.\n-; ENABLE: cmp r0, #0\n-; ENABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; Make sure we save the CSR used in the inline asm: r4.\n-; CHECK: push {r4, lr}\n-;\n-; DISABLE: cmp r0, #0\n-; DISABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; SUM is in r0 because it is coalesced with the second\n-; argument on the else path.\n-; CHECK: movs [[SUM:r0]], #0\n-; CHECK-NEXT: movs [[IV:r[0-9]+]], #10\n-;\n-; Next BB.\n-; CHECK: [[LOOP:LBB[0-9_]+]]: @ %for.body\n-; CHECK: movs [[TMP:r[0-9]+]], #1\n-; CHECK: adds [[SUM]], [[TMP]], [[SUM]]\n-; CHECK-NEXT: subs [[IV]], [[IV]], #1\n-; CHECK-NEXT: bne [[LOOP]]\n-;\n-; Next BB.\n-; SUM << 3.\n-; CHECK: lsls [[SUM]], [[SUM]], #3\n-;\n-; Duplicated epilogue.\n-; DISABLE-V5T: pop {r4, pc}\n-; DISABLE-V4T: b [[END_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: [[ELSE_LABEL]]: @ %if.else\n-; Shift second argument by one and store into returned register.\n-; CHECK: lsls r0, r1, #1\n-; DISABLE-V5T-NEXT: pop {r4, pc}\n-; DISABLE-V4T-NEXT: [[END_LABEL]]: @ %if.end\n-; DISABLE-V4T-NEXT: pop {r4}\n-; DISABLE-V4T-NEXT: pop {r1}\n-; DISABLE-V4T-NEXT: bx r1\n-;\n-; ENABLE-V5T-NEXT: {{LBB[0-9_]+}}: @ %if.end\n-; ENABLE-NEXT: bx lr\n define i32 @freqSaveAndRestoreOutsideLoop(i32 %cond, i32 %N) {\n+; ENABLE-V4T-LABEL: freqSaveAndRestoreOutsideLoop:\n+; ENABLE-V4T:       @ %bb.0: @ %entry\n+; ENABLE-V4T-NEXT:    cmp r0, #0\n+; ENABLE-V4T-NEXT:    beq LBB2_4\n+; ENABLE-V4T-NEXT:  @ %bb.1: @ %for.preheader\n+; ENABLE-V4T-NEXT:    push {r4, lr}\n+; ENABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V4T-NEXT:    .cfi_offset r4, -8\n+; ENABLE-V4T-NEXT:    @ InlineAsm Start\n+; ENABLE-V4T-NEXT:    mov r8, r8\n+; ENABLE-V4T-NEXT:    @ InlineAsm End\n+; ENABLE-V4T-NEXT:    movs r0, #0\n+; ENABLE-V4T-NEXT:    movs r1, #10\n+; ENABLE-V4T-NEXT:  LBB2_2: @ %for.body\n+; ENABLE-V4T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ENABLE-V4T-NEXT:    @ InlineAsm Start\n+; ENABLE-V4T-NEXT:    movs r2, #1\n+; ENABLE-V4T-NEXT:    @ InlineAsm End\n+; ENABLE-V4T-NEXT:    adds r0, r2, r0\n+; ENABLE-V4T-NEXT:    subs r1, r1, #1\n+; ENABLE-V4T-NEXT:    bne LBB2_2\n+; ENABLE-V4T-NEXT:  @ %bb.3: @ %for.end\n+; ENABLE-V4T-NEXT:    lsls r0, r0, #3\n+; ENABLE-V4T-NEXT:    pop {r4}\n+; ENABLE-V4T-NEXT:    pop {r1}\n+; ENABLE-V4T-NEXT:    bx r1\n+; ENABLE-V4T-NEXT:  LBB2_4: @ %if.else\n+; ENABLE-V4T-NEXT:    lsls r0, r1, #1\n+; ENABLE-V4T-NEXT:    bx lr\n+;\n+; ENABLE-V5T-LABEL: freqSaveAndRestoreOutsideLoop:\n+; ENABLE-V5T:       @ %bb.0: @ %entry\n+; ENABLE-V5T-NEXT:    cmp r0, #0\n+; ENABLE-V5T-NEXT:    beq LBB2_4\n+; ENABLE-V5T-NEXT:  @ %bb.1: @ %for.preheader\n+; ENABLE-V5T-NEXT:    push {r4, lr}\n+; ENABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V5T-NEXT:    .cfi_offset r4, -8\n+; ENABLE-V5T-NEXT:    @ InlineAsm Start\n+; ENABLE-V5T-NEXT:    mov r8, r8\n+; ENABLE-V5T-NEXT:    @ InlineAsm End\n+; ENABLE-V5T-NEXT:    movs r0, #0\n+; ENABLE-V5T-NEXT:    movs r1, #10\n+; ENABLE-V5T-NEXT:  LBB2_2: @ %for.body\n+; ENABLE-V5T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ENABLE-V5T-NEXT:    @ InlineAsm Start\n+; ENABLE-V5T-NEXT:    movs r2, #1\n+; ENABLE-V5T-NEXT:    @ InlineAsm End\n+; ENABLE-V5T-NEXT:    adds r0, r2, r0\n+; ENABLE-V5T-NEXT:    subs r1, r1, #1\n+; ENABLE-V5T-NEXT:    bne LBB2_2\n+; ENABLE-V5T-NEXT:  @ %bb.3: @ %for.end\n+; ENABLE-V5T-NEXT:    lsls r0, r0, #3\n+; ENABLE-V5T-NEXT:    pop {r4, pc}\n+; ENABLE-V5T-NEXT:  LBB2_4: @ %if.else\n+; ENABLE-V5T-NEXT:    lsls r0, r1, #1\n+; ENABLE-V5T-NEXT:  LBB2_5: @ %if.end\n+; ENABLE-V5T-NEXT:    bx lr\n+;\n+; DISABLE-V4T-LABEL: freqSaveAndRestoreOutsideLoop:\n+; DISABLE-V4T:       @ %bb.0: @ %entry\n+; DISABLE-V4T-NEXT:    push {r4, lr}\n+; DISABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V4T-NEXT:    .cfi_offset r4, -8\n+; DISABLE-V4T-NEXT:    cmp r0, #0\n+; DISABLE-V4T-NEXT:    beq LBB2_4\n+; DISABLE-V4T-NEXT:  @ %bb.1: @ %for.preheader\n+; DISABLE-V4T-NEXT:    @ InlineAsm Start\n+; DISABLE-V4T-NEXT:    mov r8, r8\n+; DISABLE-V4T-NEXT:    @ InlineAsm End\n+; DISABLE-V4T-NEXT:    movs r0, #0\n+; DISABLE-V4T-NEXT:    movs r1, #10\n+; DISABLE-V4T-NEXT:  LBB2_2: @ %for.body\n+; DISABLE-V4T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; DISABLE-V4T-NEXT:    @ InlineAsm Start\n+; DISABLE-V4T-NEXT:    movs r2, #1\n+; DISABLE-V4T-NEXT:    @ InlineAsm End\n+; DISABLE-V4T-NEXT:    adds r0, r2, r0\n+; DISABLE-V4T-NEXT:    subs r1, r1, #1\n+; DISABLE-V4T-NEXT:    bne LBB2_2\n+; DISABLE-V4T-NEXT:  @ %bb.3: @ %for.end\n+; DISABLE-V4T-NEXT:    lsls r0, r0, #3\n+; DISABLE-V4T-NEXT:    b LBB2_5\n+; DISABLE-V4T-NEXT:  LBB2_4: @ %if.else\n+; DISABLE-V4T-NEXT:    lsls r0, r1, #1\n+; DISABLE-V4T-NEXT:  LBB2_5: @ %if.end\n+; DISABLE-V4T-NEXT:    pop {r4}\n+; DISABLE-V4T-NEXT:    pop {r1}\n+; DISABLE-V4T-NEXT:    bx r1\n+;\n+; DISABLE-V5T-LABEL: freqSaveAndRestoreOutsideLoop:\n+; DISABLE-V5T:       @ %bb.0: @ %entry\n+; DISABLE-V5T-NEXT:    push {r4, lr}\n+; DISABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V5T-NEXT:    .cfi_offset r4, -8\n+; DISABLE-V5T-NEXT:    cmp r0, #0\n+; DISABLE-V5T-NEXT:    beq LBB2_4\n+; DISABLE-V5T-NEXT:  @ %bb.1: @ %for.preheader\n+; DISABLE-V5T-NEXT:    @ InlineAsm Start\n+; DISABLE-V5T-NEXT:    mov r8, r8\n+; DISABLE-V5T-NEXT:    @ InlineAsm End\n+; DISABLE-V5T-NEXT:    movs r0, #0\n+; DISABLE-V5T-NEXT:    movs r1, #10\n+; DISABLE-V5T-NEXT:  LBB2_2: @ %for.body\n+; DISABLE-V5T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; DISABLE-V5T-NEXT:    @ InlineAsm Start\n+; DISABLE-V5T-NEXT:    movs r2, #1\n+; DISABLE-V5T-NEXT:    @ InlineAsm End\n+; DISABLE-V5T-NEXT:    adds r0, r2, r0\n+; DISABLE-V5T-NEXT:    subs r1, r1, #1\n+; DISABLE-V5T-NEXT:    bne LBB2_2\n+; DISABLE-V5T-NEXT:  @ %bb.3: @ %for.end\n+; DISABLE-V5T-NEXT:    lsls r0, r0, #3\n+; DISABLE-V5T-NEXT:    pop {r4, pc}\n+; DISABLE-V5T-NEXT:  LBB2_4: @ %if.else\n+; DISABLE-V5T-NEXT:    lsls r0, r1, #1\n+; DISABLE-V5T-NEXT:    pop {r4, pc}\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %for.preheader\n@@ -198,26 +418,112 @@ declare i32 @something(...)\n \n ; Check that we do not perform the shrink-wrapping inside the loop even\n ; though that would be legal. The cost model must prevent that.\n-; CHECK-LABEL: freqSaveAndRestoreOutsideLoop2:\n-; Prologue code.\n-; Make sure we save the CSR used in the inline asm: r4.\n-; CHECK: push {r4\n-; This is the nop.\n-; CHECK: mov r8, r8\n-; CHECK: movs [[SUM:r0]], #0\n-; CHECK-NEXT: movs [[IV:r[0-9]+]], #10\n-; Next BB.\n-; CHECK: [[LOOP_LABEL:LBB[0-9_]+]]: @ %for.body\n-; CHECK: movs [[TMP:r[0-9]+]], #1\n-; CHECK: adds [[SUM]], [[TMP]], [[SUM]]\n-; CHECK-NEXT: subs [[IV]], [[IV]], #1\n-; CHECK-NEXT: bne [[LOOP_LABEL]]\n-; Next BB.\n-; CHECK: @ %for.exit\n-; This is the nop.\n-; CHECK: mov r8, r8\n-; CHECK: pop {r4\n define i32 @freqSaveAndRestoreOutsideLoop2(i32 %cond) {\n+; ENABLE-V4T-LABEL: freqSaveAndRestoreOutsideLoop2:\n+; ENABLE-V4T:       @ %bb.0: @ %entry\n+; ENABLE-V4T-NEXT:    push {r4, lr}\n+; ENABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V4T-NEXT:    .cfi_offset r4, -8\n+; ENABLE-V4T-NEXT:    @ InlineAsm Start\n+; ENABLE-V4T-NEXT:    mov r8, r8\n+; ENABLE-V4T-NEXT:    @ InlineAsm End\n+; ENABLE-V4T-NEXT:    movs r0, #0\n+; ENABLE-V4T-NEXT:    movs r1, #10\n+; ENABLE-V4T-NEXT:  LBB3_1: @ %for.body\n+; ENABLE-V4T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ENABLE-V4T-NEXT:    @ InlineAsm Start\n+; ENABLE-V4T-NEXT:    movs r2, #1\n+; ENABLE-V4T-NEXT:    @ InlineAsm End\n+; ENABLE-V4T-NEXT:    adds r0, r2, r0\n+; ENABLE-V4T-NEXT:    subs r1, r1, #1\n+; ENABLE-V4T-NEXT:    bne LBB3_1\n+; ENABLE-V4T-NEXT:  @ %bb.2: @ %for.exit\n+; ENABLE-V4T-NEXT:    @ InlineAsm Start\n+; ENABLE-V4T-NEXT:    mov r8, r8\n+; ENABLE-V4T-NEXT:    @ InlineAsm End\n+; ENABLE-V4T-NEXT:    pop {r4}\n+; ENABLE-V4T-NEXT:    pop {r1}\n+; ENABLE-V4T-NEXT:    bx r1\n+;\n+; ENABLE-V5T-LABEL: freqSaveAndRestoreOutsideLoop2:\n+; ENABLE-V5T:       @ %bb.0: @ %entry\n+; ENABLE-V5T-NEXT:    push {r4, lr}\n+; ENABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V5T-NEXT:    .cfi_offset r4, -8\n+; ENABLE-V5T-NEXT:    @ InlineAsm Start\n+; ENABLE-V5T-NEXT:    mov r8, r8\n+; ENABLE-V5T-NEXT:    @ InlineAsm End\n+; ENABLE-V5T-NEXT:    movs r0, #0\n+; ENABLE-V5T-NEXT:    movs r1, #10\n+; ENABLE-V5T-NEXT:  LBB3_1: @ %for.body\n+; ENABLE-V5T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ENABLE-V5T-NEXT:    @ InlineAsm Start\n+; ENABLE-V5T-NEXT:    movs r2, #1\n+; ENABLE-V5T-NEXT:    @ InlineAsm End\n+; ENABLE-V5T-NEXT:    adds r0, r2, r0\n+; ENABLE-V5T-NEXT:    subs r1, r1, #1\n+; ENABLE-V5T-NEXT:    bne LBB3_1\n+; ENABLE-V5T-NEXT:  @ %bb.2: @ %for.exit\n+; ENABLE-V5T-NEXT:    @ InlineAsm Start\n+; ENABLE-V5T-NEXT:    mov r8, r8\n+; ENABLE-V5T-NEXT:    @ InlineAsm End\n+; ENABLE-V5T-NEXT:    pop {r4, pc}\n+; ENABLE-V5T-NEXT:  LBB3_3: @ %for.end\n+; ENABLE-V5T-NEXT:    bx lr\n+;\n+; DISABLE-V4T-LABEL: freqSaveAndRestoreOutsideLoop2:\n+; DISABLE-V4T:       @ %bb.0: @ %entry\n+; DISABLE-V4T-NEXT:    push {r4, lr}\n+; DISABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V4T-NEXT:    .cfi_offset r4, -8\n+; DISABLE-V4T-NEXT:    @ InlineAsm Start\n+; DISABLE-V4T-NEXT:    mov r8, r8\n+; DISABLE-V4T-NEXT:    @ InlineAsm End\n+; DISABLE-V4T-NEXT:    movs r0, #0\n+; DISABLE-V4T-NEXT:    movs r1, #10\n+; DISABLE-V4T-NEXT:  LBB3_1: @ %for.body\n+; DISABLE-V4T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; DISABLE-V4T-NEXT:    @ InlineAsm Start\n+; DISABLE-V4T-NEXT:    movs r2, #1\n+; DISABLE-V4T-NEXT:    @ InlineAsm End\n+; DISABLE-V4T-NEXT:    adds r0, r2, r0\n+; DISABLE-V4T-NEXT:    subs r1, r1, #1\n+; DISABLE-V4T-NEXT:    bne LBB3_1\n+; DISABLE-V4T-NEXT:  @ %bb.2: @ %for.exit\n+; DISABLE-V4T-NEXT:    @ InlineAsm Start\n+; DISABLE-V4T-NEXT:    mov r8, r8\n+; DISABLE-V4T-NEXT:    @ InlineAsm End\n+; DISABLE-V4T-NEXT:    pop {r4}\n+; DISABLE-V4T-NEXT:    pop {r1}\n+; DISABLE-V4T-NEXT:    bx r1\n+;\n+; DISABLE-V5T-LABEL: freqSaveAndRestoreOutsideLoop2:\n+; DISABLE-V5T:       @ %bb.0: @ %entry\n+; DISABLE-V5T-NEXT:    push {r4, lr}\n+; DISABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V5T-NEXT:    .cfi_offset r4, -8\n+; DISABLE-V5T-NEXT:    @ InlineAsm Start\n+; DISABLE-V5T-NEXT:    mov r8, r8\n+; DISABLE-V5T-NEXT:    @ InlineAsm End\n+; DISABLE-V5T-NEXT:    movs r0, #0\n+; DISABLE-V5T-NEXT:    movs r1, #10\n+; DISABLE-V5T-NEXT:  LBB3_1: @ %for.body\n+; DISABLE-V5T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; DISABLE-V5T-NEXT:    @ InlineAsm Start\n+; DISABLE-V5T-NEXT:    movs r2, #1\n+; DISABLE-V5T-NEXT:    @ InlineAsm End\n+; DISABLE-V5T-NEXT:    adds r0, r2, r0\n+; DISABLE-V5T-NEXT:    subs r1, r1, #1\n+; DISABLE-V5T-NEXT:    bne LBB3_1\n+; DISABLE-V5T-NEXT:  @ %bb.2: @ %for.exit\n+; DISABLE-V5T-NEXT:    @ InlineAsm Start\n+; DISABLE-V5T-NEXT:    mov r8, r8\n+; DISABLE-V5T-NEXT:    @ InlineAsm End\n+; DISABLE-V5T-NEXT:    pop {r4, pc}\n entry:\n   br label %for.preheader\n \n@@ -244,54 +550,140 @@ for.end:                                          ; preds = %for.body\n \n ; Check with a more complex case that we do not have save within the loop and\n ; restore outside.\n-; CHECK-LABEL: loopInfoSaveOutsideLoop:\n-;\n-; ENABLE: cmp r0, #0\n-; ENABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; Make sure we save the CSR used in the inline asm: r4.\n-; CHECK: push {r4, lr}\n-;\n-; DISABLE: cmp r0, #0\n-; DISABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; SUM is in r0 because it is coalesced with the second\n-; argument on the else path.\n-; CHECK: movs [[SUM:r0]], #0\n-; CHECK-NEXT: movs [[IV:r[0-9]+]], #10\n-;\n-; Next BB.\n-; CHECK: [[LOOP:LBB[0-9_]+]]: @ %for.body\n-; CHECK: movs [[TMP:r[0-9]+]], #1\n-; CHECK: adds [[SUM]], [[TMP]], [[SUM]]\n-; CHECK-NEXT: subs [[IV]], [[IV]], #1\n-; CHECK-NEXT: bne [[LOOP]]\n-;\n-; Next BB.\n-; SUM << 3.\n-; CHECK: lsls [[SUM]], [[SUM]], #3\n-; ENABLE-V5T-NEXT: pop {r4, pc}\n-; ENABLE-V4T-NEXT: pop {r4}\n-; ENABLE-V4T-NEXT: pop {r1}\n-; ENABLE-V4T-NEXT: bx r1\n-;\n-; Duplicated epilogue.\n-; DISABLE-V5T: pop {r4, pc}\n-; DISABLE-V4T: b [[END_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: [[ELSE_LABEL]]: @ %if.else\n-; Shift second argument by one and store into returned register.\n-; CHECK: lsls r0, r1, #1\n-; DISABLE-V5T-NEXT: pop {r4, pc}\n-; DISABLE-V4T-NEXT: [[END_LABEL]]: @ %if.end\n-; DISABLE-V4T-NEXT: pop {r4}\n-; DISABLE-V4T-NEXT: pop {r1}\n-; DISABLE-V4T-NEXT: bx r1\n-;\n-; ENABLE-V5T-NEXT: {{LBB[0-9_]+}}: @ %if.end\n-; ENABLE-NEXT: bx lr\n define i32 @loopInfoSaveOutsideLoop(i32 %cond, i32 %N) {\n+; ENABLE-V4T-LABEL: loopInfoSaveOutsideLoop:\n+; ENABLE-V4T:       @ %bb.0: @ %entry\n+; ENABLE-V4T-NEXT:    cmp r0, #0\n+; ENABLE-V4T-NEXT:    beq LBB4_4\n+; ENABLE-V4T-NEXT:  @ %bb.1: @ %for.preheader\n+; ENABLE-V4T-NEXT:    push {r4, lr}\n+; ENABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V4T-NEXT:    .cfi_offset r4, -8\n+; ENABLE-V4T-NEXT:    @ InlineAsm Start\n+; ENABLE-V4T-NEXT:    mov r8, r8\n+; ENABLE-V4T-NEXT:    @ InlineAsm End\n+; ENABLE-V4T-NEXT:    movs r0, #0\n+; ENABLE-V4T-NEXT:    movs r1, #10\n+; ENABLE-V4T-NEXT:  LBB4_2: @ %for.body\n+; ENABLE-V4T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ENABLE-V4T-NEXT:    @ InlineAsm Start\n+; ENABLE-V4T-NEXT:    movs r2, #1\n+; ENABLE-V4T-NEXT:    @ InlineAsm End\n+; ENABLE-V4T-NEXT:    adds r0, r2, r0\n+; ENABLE-V4T-NEXT:    subs r1, r1, #1\n+; ENABLE-V4T-NEXT:    bne LBB4_2\n+; ENABLE-V4T-NEXT:  @ %bb.3: @ %for.end\n+; ENABLE-V4T-NEXT:    @ InlineAsm Start\n+; ENABLE-V4T-NEXT:    mov r8, r8\n+; ENABLE-V4T-NEXT:    @ InlineAsm End\n+; ENABLE-V4T-NEXT:    lsls r0, r0, #3\n+; ENABLE-V4T-NEXT:    pop {r4}\n+; ENABLE-V4T-NEXT:    pop {r1}\n+; ENABLE-V4T-NEXT:    bx r1\n+; ENABLE-V4T-NEXT:  LBB4_4: @ %if.else\n+; ENABLE-V4T-NEXT:    lsls r0, r1, #1\n+; ENABLE-V4T-NEXT:    bx lr\n+;\n+; ENABLE-V5T-LABEL: loopInfoSaveOutsideLoop:\n+; ENABLE-V5T:       @ %bb.0: @ %entry\n+; ENABLE-V5T-NEXT:    cmp r0, #0\n+; ENABLE-V5T-NEXT:    beq LBB4_4\n+; ENABLE-V5T-NEXT:  @ %bb.1: @ %for.preheader\n+; ENABLE-V5T-NEXT:    push {r4, lr}\n+; ENABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V5T-NEXT:    .cfi_offset r4, -8\n+; ENABLE-V5T-NEXT:    @ InlineAsm Start\n+; ENABLE-V5T-NEXT:    mov r8, r8\n+; ENABLE-V5T-NEXT:    @ InlineAsm End\n+; ENABLE-V5T-NEXT:    movs r0, #0\n+; ENABLE-V5T-NEXT:    movs r1, #10\n+; ENABLE-V5T-NEXT:  LBB4_2: @ %for.body\n+; ENABLE-V5T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ENABLE-V5T-NEXT:    @ InlineAsm Start\n+; ENABLE-V5T-NEXT:    movs r2, #1\n+; ENABLE-V5T-NEXT:    @ InlineAsm End\n+; ENABLE-V5T-NEXT:    adds r0, r2, r0\n+; ENABLE-V5T-NEXT:    subs r1, r1, #1\n+; ENABLE-V5T-NEXT:    bne LBB4_2\n+; ENABLE-V5T-NEXT:  @ %bb.3: @ %for.end\n+; ENABLE-V5T-NEXT:    @ InlineAsm Start\n+; ENABLE-V5T-NEXT:    mov r8, r8\n+; ENABLE-V5T-NEXT:    @ InlineAsm End\n+; ENABLE-V5T-NEXT:    lsls r0, r0, #3\n+; ENABLE-V5T-NEXT:    pop {r4, pc}\n+; ENABLE-V5T-NEXT:  LBB4_4: @ %if.else\n+; ENABLE-V5T-NEXT:    lsls r0, r1, #1\n+; ENABLE-V5T-NEXT:  LBB4_5: @ %if.end\n+; ENABLE-V5T-NEXT:    bx lr\n+;\n+; DISABLE-V4T-LABEL: loopInfoSaveOutsideLoop:\n+; DISABLE-V4T:       @ %bb.0: @ %entry\n+; DISABLE-V4T-NEXT:    push {r4, lr}\n+; DISABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V4T-NEXT:    .cfi_offset r4, -8\n+; DISABLE-V4T-NEXT:    cmp r0, #0\n+; DISABLE-V4T-NEXT:    beq LBB4_4\n+; DISABLE-V4T-NEXT:  @ %bb.1: @ %for.preheader\n+; DISABLE-V4T-NEXT:    @ InlineAsm Start\n+; DISABLE-V4T-NEXT:    mov r8, r8\n+; DISABLE-V4T-NEXT:    @ InlineAsm End\n+; DISABLE-V4T-NEXT:    movs r0, #0\n+; DISABLE-V4T-NEXT:    movs r1, #10\n+; DISABLE-V4T-NEXT:  LBB4_2: @ %for.body\n+; DISABLE-V4T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; DISABLE-V4T-NEXT:    @ InlineAsm Start\n+; DISABLE-V4T-NEXT:    movs r2, #1\n+; DISABLE-V4T-NEXT:    @ InlineAsm End\n+; DISABLE-V4T-NEXT:    adds r0, r2, r0\n+; DISABLE-V4T-NEXT:    subs r1, r1, #1\n+; DISABLE-V4T-NEXT:    bne LBB4_2\n+; DISABLE-V4T-NEXT:  @ %bb.3: @ %for.end\n+; DISABLE-V4T-NEXT:    @ InlineAsm Start\n+; DISABLE-V4T-NEXT:    mov r8, r8\n+; DISABLE-V4T-NEXT:    @ InlineAsm End\n+; DISABLE-V4T-NEXT:    lsls r0, r0, #3\n+; DISABLE-V4T-NEXT:    b LBB4_5\n+; DISABLE-V4T-NEXT:  LBB4_4: @ %if.else\n+; DISABLE-V4T-NEXT:    lsls r0, r1, #1\n+; DISABLE-V4T-NEXT:  LBB4_5: @ %if.end\n+; DISABLE-V4T-NEXT:    pop {r4}\n+; DISABLE-V4T-NEXT:    pop {r1}\n+; DISABLE-V4T-NEXT:    bx r1\n+;\n+; DISABLE-V5T-LABEL: loopInfoSaveOutsideLoop:\n+; DISABLE-V5T:       @ %bb.0: @ %entry\n+; DISABLE-V5T-NEXT:    push {r4, lr}\n+; DISABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V5T-NEXT:    .cfi_offset r4, -8\n+; DISABLE-V5T-NEXT:    cmp r0, #0\n+; DISABLE-V5T-NEXT:    beq LBB4_4\n+; DISABLE-V5T-NEXT:  @ %bb.1: @ %for.preheader\n+; DISABLE-V5T-NEXT:    @ InlineAsm Start\n+; DISABLE-V5T-NEXT:    mov r8, r8\n+; DISABLE-V5T-NEXT:    @ InlineAsm End\n+; DISABLE-V5T-NEXT:    movs r0, #0\n+; DISABLE-V5T-NEXT:    movs r1, #10\n+; DISABLE-V5T-NEXT:  LBB4_2: @ %for.body\n+; DISABLE-V5T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; DISABLE-V5T-NEXT:    @ InlineAsm Start\n+; DISABLE-V5T-NEXT:    movs r2, #1\n+; DISABLE-V5T-NEXT:    @ InlineAsm End\n+; DISABLE-V5T-NEXT:    adds r0, r2, r0\n+; DISABLE-V5T-NEXT:    subs r1, r1, #1\n+; DISABLE-V5T-NEXT:    bne LBB4_2\n+; DISABLE-V5T-NEXT:  @ %bb.3: @ %for.end\n+; DISABLE-V5T-NEXT:    @ InlineAsm Start\n+; DISABLE-V5T-NEXT:    mov r8, r8\n+; DISABLE-V5T-NEXT:    @ InlineAsm End\n+; DISABLE-V5T-NEXT:    lsls r0, r0, #3\n+; DISABLE-V5T-NEXT:    pop {r4, pc}\n+; DISABLE-V5T-NEXT:  LBB4_4: @ %if.else\n+; DISABLE-V5T-NEXT:    lsls r0, r1, #1\n+; DISABLE-V5T-NEXT:    pop {r4, pc}\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %for.preheader\n@@ -327,54 +719,156 @@ declare void @somethingElse(...)\n \n ; Check with a more complex case that we do not have restore within the loop and\n ; save outside.\n-; CHECK-LABEL: loopInfoRestoreOutsideLoop:\n-;\n-; ENABLE: cmp r0, #0\n-; ENABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; Make sure we save the CSR used in the inline asm: r4.\n-; CHECK: push {r4, lr}\n-;\n-; DISABLE-NEXT: cmp r0, #0\n-; DISABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; SUM is in r0 because it is coalesced with the second\n-; argument on the else path.\n-; CHECK: movs [[SUM:r0]], #0\n-; CHECK-NEXT: movs [[IV:r[0-9]+]], #10\n-;\n-; Next BB.\n-; CHECK: [[LOOP:LBB[0-9_]+]]: @ %for.body\n-; CHECK: movs [[TMP:r[0-9]+]], #1\n-; CHECK: adds [[SUM]], [[TMP]], [[SUM]]\n-; CHECK-NEXT: subs [[IV]], [[IV]], #1\n-; CHECK-NEXT: bne [[LOOP]]\n-;\n-; Next BB.\n-; SUM << 3.\n-; CHECK: lsls [[SUM]], [[SUM]], #3\n-; ENABLE-V5T-NEXT: pop {r4, pc}\n-; ENABLE-V4T-NEXT: pop {r4}\n-; ENABLE-V4T-NEXT: pop {r1}\n-; ENABLE-V4T-NEXT: bx r1\n-;\n-; Duplicated epilogue.\n-; DISABLE-V5T: pop {r4, pc}\n-; DISABLE-V4T: b [[END_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: [[ELSE_LABEL]]: @ %if.else\n-; Shift second argument by one and store into returned register.\n-; CHECK: lsls r0, r1, #1\n-; DISABLE-V5T-NEXT: pop {r4, pc}\n-; DISABLE-V4T-NEXT: [[END_LABEL]]: @ %if.end\n-; DISABLE-V4T-NEXT: pop {r4}\n-; DISABLE-V4T-NEXT: pop {r1}\n-; DISABLE-V4T-NEXT: bx r1\n-;\n-; ENABLE-V5T-NEXT: {{LBB[0-9_]+}}: @ %if.end\n-; ENABLE-NEXT: bx lr\n define i32 @loopInfoRestoreOutsideLoop(i32 %cond, i32 %N) nounwind {\n+; ENABLE-V4T-LABEL: loopInfoRestoreOutsideLoop:\n+; ENABLE-V4T:       @ %bb.0: @ %entry\n+; ENABLE-V4T-NEXT:    cmp r0, #0\n+; ENABLE-V4T-NEXT:    beq LBB5_4\n+; ENABLE-V4T-NEXT:  @ %bb.1: @ %if.then\n+; ENABLE-V4T-NEXT:    push {r4, lr}\n+; ENABLE-V4T-NEXT:    @ InlineAsm Start\n+; ENABLE-V4T-NEXT:    mov r8, r8\n+; ENABLE-V4T-NEXT:    @ InlineAsm End\n+; ENABLE-V4T-NEXT:    movs r0, #0\n+; ENABLE-V4T-NEXT:    movs r1, #10\n+; ENABLE-V4T-NEXT:  LBB5_2: @ %for.body\n+; ENABLE-V4T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ENABLE-V4T-NEXT:    @ InlineAsm Start\n+; ENABLE-V4T-NEXT:    movs r2, #1\n+; ENABLE-V4T-NEXT:    @ InlineAsm End\n+; ENABLE-V4T-NEXT:    adds r0, r2, r0\n+; ENABLE-V4T-NEXT:    subs r1, r1, #1\n+; ENABLE-V4T-NEXT:    bne LBB5_2\n+; ENABLE-V4T-NEXT:  @ %bb.3: @ %for.end\n+; ENABLE-V4T-NEXT:    lsls r0, r0, #3\n+; ENABLE-V4T-NEXT:    pop {r4}\n+; ENABLE-V4T-NEXT:    pop {r1}\n+; ENABLE-V4T-NEXT:    bx r1\n+; ENABLE-V4T-NEXT:  LBB5_4: @ %if.else\n+; ENABLE-V4T-NEXT:    lsls r0, r1, #1\n+; ENABLE-V4T-NEXT:    bx lr\n+; ENABLE-V4T-NEXT:    @ -- End function\n+; ENABLE-V4T-NEXT:    .globl _emptyFrame @ -- Begin function emptyFrame\n+; ENABLE-V4T-NEXT:    .p2align 1\n+; ENABLE-V4T-NEXT:    .code 16 @ @emptyFrame\n+; ENABLE-V4T-NEXT:    .thumb_func _emptyFrame\n+; ENABLE-V4T-NEXT:  _emptyFrame:\n+; ENABLE-V4T-NEXT:    .cfi_startproc\n+; ENABLE-V4T-NEXT:  @ %bb.0: @ %entry\n+; ENABLE-V4T-NEXT:    movs r0, #0\n+; ENABLE-V4T-NEXT:    bx lr\n+;\n+; ENABLE-V5T-LABEL: loopInfoRestoreOutsideLoop:\n+; ENABLE-V5T:       @ %bb.0: @ %entry\n+; ENABLE-V5T-NEXT:    cmp r0, #0\n+; ENABLE-V5T-NEXT:    beq LBB5_4\n+; ENABLE-V5T-NEXT:  @ %bb.1: @ %if.then\n+; ENABLE-V5T-NEXT:    push {r4, lr}\n+; ENABLE-V5T-NEXT:    @ InlineAsm Start\n+; ENABLE-V5T-NEXT:    mov r8, r8\n+; ENABLE-V5T-NEXT:    @ InlineAsm End\n+; ENABLE-V5T-NEXT:    movs r0, #0\n+; ENABLE-V5T-NEXT:    movs r1, #10\n+; ENABLE-V5T-NEXT:  LBB5_2: @ %for.body\n+; ENABLE-V5T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ENABLE-V5T-NEXT:    @ InlineAsm Start\n+; ENABLE-V5T-NEXT:    movs r2, #1\n+; ENABLE-V5T-NEXT:    @ InlineAsm End\n+; ENABLE-V5T-NEXT:    adds r0, r2, r0\n+; ENABLE-V5T-NEXT:    subs r1, r1, #1\n+; ENABLE-V5T-NEXT:    bne LBB5_2\n+; ENABLE-V5T-NEXT:  @ %bb.3: @ %for.end\n+; ENABLE-V5T-NEXT:    lsls r0, r0, #3\n+; ENABLE-V5T-NEXT:    pop {r4, pc}\n+; ENABLE-V5T-NEXT:  LBB5_4: @ %if.else\n+; ENABLE-V5T-NEXT:    lsls r0, r1, #1\n+; ENABLE-V5T-NEXT:  LBB5_5: @ %if.end\n+; ENABLE-V5T-NEXT:    bx lr\n+; ENABLE-V5T-NEXT:    @ -- End function\n+; ENABLE-V5T-NEXT:    .globl _emptyFrame @ -- Begin function emptyFrame\n+; ENABLE-V5T-NEXT:    .p2align 1\n+; ENABLE-V5T-NEXT:    .code 16 @ @emptyFrame\n+; ENABLE-V5T-NEXT:    .thumb_func _emptyFrame\n+; ENABLE-V5T-NEXT:  _emptyFrame:\n+; ENABLE-V5T-NEXT:    .cfi_startproc\n+; ENABLE-V5T-NEXT:  @ %bb.0: @ %entry\n+; ENABLE-V5T-NEXT:    movs r0, #0\n+; ENABLE-V5T-NEXT:    bx lr\n+;\n+; DISABLE-V4T-LABEL: loopInfoRestoreOutsideLoop:\n+; DISABLE-V4T:       @ %bb.0: @ %entry\n+; DISABLE-V4T-NEXT:    push {r4, lr}\n+; DISABLE-V4T-NEXT:    cmp r0, #0\n+; DISABLE-V4T-NEXT:    beq LBB5_4\n+; DISABLE-V4T-NEXT:  @ %bb.1: @ %if.then\n+; DISABLE-V4T-NEXT:    @ InlineAsm Start\n+; DISABLE-V4T-NEXT:    mov r8, r8\n+; DISABLE-V4T-NEXT:    @ InlineAsm End\n+; DISABLE-V4T-NEXT:    movs r0, #0\n+; DISABLE-V4T-NEXT:    movs r1, #10\n+; DISABLE-V4T-NEXT:  LBB5_2: @ %for.body\n+; DISABLE-V4T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; DISABLE-V4T-NEXT:    @ InlineAsm Start\n+; DISABLE-V4T-NEXT:    movs r2, #1\n+; DISABLE-V4T-NEXT:    @ InlineAsm End\n+; DISABLE-V4T-NEXT:    adds r0, r2, r0\n+; DISABLE-V4T-NEXT:    subs r1, r1, #1\n+; DISABLE-V4T-NEXT:    bne LBB5_2\n+; DISABLE-V4T-NEXT:  @ %bb.3: @ %for.end\n+; DISABLE-V4T-NEXT:    lsls r0, r0, #3\n+; DISABLE-V4T-NEXT:    b LBB5_5\n+; DISABLE-V4T-NEXT:  LBB5_4: @ %if.else\n+; DISABLE-V4T-NEXT:    lsls r0, r1, #1\n+; DISABLE-V4T-NEXT:  LBB5_5: @ %if.end\n+; DISABLE-V4T-NEXT:    pop {r4}\n+; DISABLE-V4T-NEXT:    pop {r1}\n+; DISABLE-V4T-NEXT:    bx r1\n+; DISABLE-V4T-NEXT:    @ -- End function\n+; DISABLE-V4T-NEXT:    .globl _emptyFrame @ -- Begin function emptyFrame\n+; DISABLE-V4T-NEXT:    .p2align 1\n+; DISABLE-V4T-NEXT:    .code 16 @ @emptyFrame\n+; DISABLE-V4T-NEXT:    .thumb_func _emptyFrame\n+; DISABLE-V4T-NEXT:  _emptyFrame:\n+; DISABLE-V4T-NEXT:    .cfi_startproc\n+; DISABLE-V4T-NEXT:  @ %bb.0: @ %entry\n+; DISABLE-V4T-NEXT:    movs r0, #0\n+; DISABLE-V4T-NEXT:    bx lr\n+;\n+; DISABLE-V5T-LABEL: loopInfoRestoreOutsideLoop:\n+; DISABLE-V5T:       @ %bb.0: @ %entry\n+; DISABLE-V5T-NEXT:    push {r4, lr}\n+; DISABLE-V5T-NEXT:    cmp r0, #0\n+; DISABLE-V5T-NEXT:    beq LBB5_4\n+; DISABLE-V5T-NEXT:  @ %bb.1: @ %if.then\n+; DISABLE-V5T-NEXT:    @ InlineAsm Start\n+; DISABLE-V5T-NEXT:    mov r8, r8\n+; DISABLE-V5T-NEXT:    @ InlineAsm End\n+; DISABLE-V5T-NEXT:    movs r0, #0\n+; DISABLE-V5T-NEXT:    movs r1, #10\n+; DISABLE-V5T-NEXT:  LBB5_2: @ %for.body\n+; DISABLE-V5T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; DISABLE-V5T-NEXT:    @ InlineAsm Start\n+; DISABLE-V5T-NEXT:    movs r2, #1\n+; DISABLE-V5T-NEXT:    @ InlineAsm End\n+; DISABLE-V5T-NEXT:    adds r0, r2, r0\n+; DISABLE-V5T-NEXT:    subs r1, r1, #1\n+; DISABLE-V5T-NEXT:    bne LBB5_2\n+; DISABLE-V5T-NEXT:  @ %bb.3: @ %for.end\n+; DISABLE-V5T-NEXT:    lsls r0, r0, #3\n+; DISABLE-V5T-NEXT:    pop {r4, pc}\n+; DISABLE-V5T-NEXT:  LBB5_4: @ %if.else\n+; DISABLE-V5T-NEXT:    lsls r0, r1, #1\n+; DISABLE-V5T-NEXT:    pop {r4, pc}\n+; DISABLE-V5T-NEXT:    @ -- End function\n+; DISABLE-V5T-NEXT:    .globl _emptyFrame @ -- Begin function emptyFrame\n+; DISABLE-V5T-NEXT:    .p2align 1\n+; DISABLE-V5T-NEXT:    .code 16 @ @emptyFrame\n+; DISABLE-V5T-NEXT:    .thumb_func _emptyFrame\n+; DISABLE-V5T-NEXT:  _emptyFrame:\n+; DISABLE-V5T-NEXT:    .cfi_startproc\n+; DISABLE-V5T-NEXT:  @ %bb.0: @ %entry\n+; DISABLE-V5T-NEXT:    movs r0, #0\n+; DISABLE-V5T-NEXT:    bx lr\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %if.then\n@@ -406,59 +900,138 @@ if.end:                                           ; preds = %if.else, %for.end\n }\n \n ; Check that we handle function with no frame information correctly.\n-; CHECK-LABEL: emptyFrame:\n-; CHECK: @ %entry\n-; CHECK-NEXT: movs r0, #0\n-; CHECK-NEXT: bx lr\n define i32 @emptyFrame() {\n entry:\n   ret i32 0\n }\n \n ; Check that we handle inline asm correctly.\n-; CHECK-LABEL: inlineAsm:\n-;\n-; ENABLE: cmp r0, #0\n-; ENABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; Make sure we save the CSR used in the inline asm: r4.\n-; CHECK: push {r4, lr}\n-;\n-; DISABLE: cmp r0, #0\n-; DISABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: movs [[IV:r[0-9]+]], #10\n-;\n-; Next BB.\n-; CHECK: [[LOOP:LBB[0-9_]+]]: @ %for.body\n-; CHECK: movs r4, #1\n-; CHECK: subs [[IV]], [[IV]], #1\n-; CHECK-NEXT: bne [[LOOP]]\n-;\n-; Next BB.\n-; CHECK: movs r0, #0\n-; ENABLE-V5T-NEXT: pop {r4, pc}\n-; ENABLE-V4T-NEXT: pop {r4}\n-; ENABLE-V4T-NEXT: pop {r1}\n-; ENABLE-V4T-NEXT: bx r1\n-;\n-; Duplicated epilogue.\n-; DISABLE-V5T-NEXT: pop {r4, pc}\n-; DISABLE-V4T-NEXT: b [[END_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: [[ELSE_LABEL]]: @ %if.else\n-; Shift second argument by one and store into returned register.\n-; CHECK: lsls r0, r1, #1\n-; DISABLE-V5T-NEXT: pop {r4, pc}\n-; DISABLE-V4T-NEXT: [[END_LABEL]]: @ %if.end\n-; DISABLE-V4T-NEXT: pop {r4}\n-; DISABLE-V4T-NEXT: pop {r1}\n-; DISABLE-V4T-NEXT: bx r1\n-;\n-; ENABLE-V5T-NEXT: {{LBB[0-9_]+}}: @ %if.end\n-; ENABLE-NEXT: bx lr\n define i32 @inlineAsm(i32 %cond, i32 %N) {\n+; ENABLE-V4T-LABEL: inlineAsm:\n+; ENABLE-V4T:       @ %bb.0: @ %entry\n+; ENABLE-V4T-NEXT:    cmp r0, #0\n+; ENABLE-V4T-NEXT:    beq LBB7_4\n+; ENABLE-V4T-NEXT:  @ %bb.1: @ %for.preheader\n+; ENABLE-V4T-NEXT:    push {r4, lr}\n+; ENABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V4T-NEXT:    .cfi_offset r4, -8\n+; ENABLE-V4T-NEXT:    @ InlineAsm Start\n+; ENABLE-V4T-NEXT:    mov r8, r8\n+; ENABLE-V4T-NEXT:    @ InlineAsm End\n+; ENABLE-V4T-NEXT:    movs r0, #10\n+; ENABLE-V4T-NEXT:  LBB7_2: @ %for.body\n+; ENABLE-V4T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ENABLE-V4T-NEXT:    @ InlineAsm Start\n+; ENABLE-V4T-NEXT:    movs r4, #1\n+; ENABLE-V4T-NEXT:    @ InlineAsm End\n+; ENABLE-V4T-NEXT:    subs r0, r0, #1\n+; ENABLE-V4T-NEXT:    bne LBB7_2\n+; ENABLE-V4T-NEXT:  @ %bb.3: @ %for.exit\n+; ENABLE-V4T-NEXT:    @ InlineAsm Start\n+; ENABLE-V4T-NEXT:    mov r8, r8\n+; ENABLE-V4T-NEXT:    @ InlineAsm End\n+; ENABLE-V4T-NEXT:    movs r0, #0\n+; ENABLE-V4T-NEXT:    pop {r4}\n+; ENABLE-V4T-NEXT:    pop {r1}\n+; ENABLE-V4T-NEXT:    bx r1\n+; ENABLE-V4T-NEXT:  LBB7_4: @ %if.else\n+; ENABLE-V4T-NEXT:    lsls r0, r1, #1\n+; ENABLE-V4T-NEXT:    bx lr\n+;\n+; ENABLE-V5T-LABEL: inlineAsm:\n+; ENABLE-V5T:       @ %bb.0: @ %entry\n+; ENABLE-V5T-NEXT:    cmp r0, #0\n+; ENABLE-V5T-NEXT:    beq LBB7_4\n+; ENABLE-V5T-NEXT:  @ %bb.1: @ %for.preheader\n+; ENABLE-V5T-NEXT:    push {r4, lr}\n+; ENABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V5T-NEXT:    .cfi_offset r4, -8\n+; ENABLE-V5T-NEXT:    @ InlineAsm Start\n+; ENABLE-V5T-NEXT:    mov r8, r8\n+; ENABLE-V5T-NEXT:    @ InlineAsm End\n+; ENABLE-V5T-NEXT:    movs r0, #10\n+; ENABLE-V5T-NEXT:  LBB7_2: @ %for.body\n+; ENABLE-V5T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; ENABLE-V5T-NEXT:    @ InlineAsm Start\n+; ENABLE-V5T-NEXT:    movs r4, #1\n+; ENABLE-V5T-NEXT:    @ InlineAsm End\n+; ENABLE-V5T-NEXT:    subs r0, r0, #1\n+; ENABLE-V5T-NEXT:    bne LBB7_2\n+; ENABLE-V5T-NEXT:  @ %bb.3: @ %for.exit\n+; ENABLE-V5T-NEXT:    @ InlineAsm Start\n+; ENABLE-V5T-NEXT:    mov r8, r8\n+; ENABLE-V5T-NEXT:    @ InlineAsm End\n+; ENABLE-V5T-NEXT:    movs r0, #0\n+; ENABLE-V5T-NEXT:    pop {r4, pc}\n+; ENABLE-V5T-NEXT:  LBB7_4: @ %if.else\n+; ENABLE-V5T-NEXT:    lsls r0, r1, #1\n+; ENABLE-V5T-NEXT:  LBB7_5: @ %if.end\n+; ENABLE-V5T-NEXT:    bx lr\n+;\n+; DISABLE-V4T-LABEL: inlineAsm:\n+; DISABLE-V4T:       @ %bb.0: @ %entry\n+; DISABLE-V4T-NEXT:    push {r4, lr}\n+; DISABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V4T-NEXT:    .cfi_offset r4, -8\n+; DISABLE-V4T-NEXT:    cmp r0, #0\n+; DISABLE-V4T-NEXT:    beq LBB7_4\n+; DISABLE-V4T-NEXT:  @ %bb.1: @ %for.preheader\n+; DISABLE-V4T-NEXT:    @ InlineAsm Start\n+; DISABLE-V4T-NEXT:    mov r8, r8\n+; DISABLE-V4T-NEXT:    @ InlineAsm End\n+; DISABLE-V4T-NEXT:    movs r0, #10\n+; DISABLE-V4T-NEXT:  LBB7_2: @ %for.body\n+; DISABLE-V4T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; DISABLE-V4T-NEXT:    @ InlineAsm Start\n+; DISABLE-V4T-NEXT:    movs r4, #1\n+; DISABLE-V4T-NEXT:    @ InlineAsm End\n+; DISABLE-V4T-NEXT:    subs r0, r0, #1\n+; DISABLE-V4T-NEXT:    bne LBB7_2\n+; DISABLE-V4T-NEXT:  @ %bb.3: @ %for.exit\n+; DISABLE-V4T-NEXT:    @ InlineAsm Start\n+; DISABLE-V4T-NEXT:    mov r8, r8\n+; DISABLE-V4T-NEXT:    @ InlineAsm End\n+; DISABLE-V4T-NEXT:    movs r0, #0\n+; DISABLE-V4T-NEXT:    b LBB7_5\n+; DISABLE-V4T-NEXT:  LBB7_4: @ %if.else\n+; DISABLE-V4T-NEXT:    lsls r0, r1, #1\n+; DISABLE-V4T-NEXT:  LBB7_5: @ %if.end\n+; DISABLE-V4T-NEXT:    pop {r4}\n+; DISABLE-V4T-NEXT:    pop {r1}\n+; DISABLE-V4T-NEXT:    bx r1\n+;\n+; DISABLE-V5T-LABEL: inlineAsm:\n+; DISABLE-V5T:       @ %bb.0: @ %entry\n+; DISABLE-V5T-NEXT:    push {r4, lr}\n+; DISABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V5T-NEXT:    .cfi_offset r4, -8\n+; DISABLE-V5T-NEXT:    cmp r0, #0\n+; DISABLE-V5T-NEXT:    beq LBB7_4\n+; DISABLE-V5T-NEXT:  @ %bb.1: @ %for.preheader\n+; DISABLE-V5T-NEXT:    @ InlineAsm Start\n+; DISABLE-V5T-NEXT:    mov r8, r8\n+; DISABLE-V5T-NEXT:    @ InlineAsm End\n+; DISABLE-V5T-NEXT:    movs r0, #10\n+; DISABLE-V5T-NEXT:  LBB7_2: @ %for.body\n+; DISABLE-V5T-NEXT:    @ =>This Inner Loop Header: Depth=1\n+; DISABLE-V5T-NEXT:    @ InlineAsm Start\n+; DISABLE-V5T-NEXT:    movs r4, #1\n+; DISABLE-V5T-NEXT:    @ InlineAsm End\n+; DISABLE-V5T-NEXT:    subs r0, r0, #1\n+; DISABLE-V5T-NEXT:    bne LBB7_2\n+; DISABLE-V5T-NEXT:  @ %bb.3: @ %for.exit\n+; DISABLE-V5T-NEXT:    @ InlineAsm Start\n+; DISABLE-V5T-NEXT:    mov r8, r8\n+; DISABLE-V5T-NEXT:    @ InlineAsm End\n+; DISABLE-V5T-NEXT:    movs r0, #0\n+; DISABLE-V5T-NEXT:    pop {r4, pc}\n+; DISABLE-V5T-NEXT:  LBB7_4: @ %if.else\n+; DISABLE-V5T-NEXT:    lsls r0, r1, #1\n+; DISABLE-V5T-NEXT:    pop {r4, pc}\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %for.preheader\n@@ -488,54 +1061,133 @@ if.end:                                           ; preds = %for.body, %if.else\n }\n \n ; Check that we handle calls to variadic functions correctly.\n-; CHECK-LABEL: callVariadicFunc:\n-;\n-; ENABLE: cmp r0, #0\n-; ENABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; CHECK: push {[[TMP:r[0-9]+]], lr}\n-; CHECK: sub sp, #16\n-;\n-; DISABLE: cmp r0, #0\n-; DISABLE-NEXT: beq [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Setup of the varags.\n-; CHECK: str r1, [sp]\n-; CHECK-NEXT: str r1, [sp, #4]\n-; CHECK-NEXT: str r1, [sp, #8]\n-; CHECK:      movs r0, r1\n-; CHECK-NEXT: movs r2, r1\n-; CHECK-NEXT: movs r3, r1\n-; CHECK-NEXT: bl\n-; CHECK-NEXT: lsls r0, r0, #3\n-;\n-; ENABLE-NEXT: add sp, #16\n-; ENABLE-V5T-NEXT: pop {[[TMP]], pc}\n-; ENABLE-V4T-NEXT: pop {[[TMP]]}\n-; ENABLE-V4T-NEXT: pop {r1}\n-; ENABLE-V4T-NEXT: bx r1\n-;\n-; Duplicated epilogue.\n-; DISABLE-V5T-NEXT: add sp, #16\n-; DISABLE-V5T-NEXT: pop {[[TMP]], pc}\n-; DISABLE-V4T-NEXT: b [[END_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: [[ELSE_LABEL]]: @ %if.else\n-; Shift second argument by one and store into returned register.\n-; CHECK: lsls r0, r1, #1\n-;\n-; Epilogue code.\n-; ENABLE-V5T-NEXT: {{LBB[0-9_]+}}: @ %if.end\n-; ENABLE-NEXT: bx lr\n-;\n-; DISABLE-V4T-NEXT: [[END_LABEL]]: @ %if.end\n-; DISABLE-NEXT: add sp, #16\n-; DISABLE-V5T-NEXT: pop {[[TMP]], pc}\n-; DISABLE-V4T-NEXT: pop {[[TMP]]}\n-; DISABLE-V4T-NEXT: pop {r1}\n-; DISABLE-V4T-NEXT: bx r1\n define i32 @callVariadicFunc(i32 %cond, i32 %N) {\n+; ENABLE-V4T-LABEL: callVariadicFunc:\n+; ENABLE-V4T:       @ %bb.0: @ %entry\n+; ENABLE-V4T-NEXT:    cmp r0, #0\n+; ENABLE-V4T-NEXT:    beq LBB8_2\n+; ENABLE-V4T-NEXT:  @ %bb.1: @ %if.then\n+; ENABLE-V4T-NEXT:    push {r4, lr}\n+; ENABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V4T-NEXT:    .cfi_offset r4, -8\n+; ENABLE-V4T-NEXT:    sub sp, #16\n+; ENABLE-V4T-NEXT:    .cfi_def_cfa_offset 24\n+; ENABLE-V4T-NEXT:    str r1, [sp]\n+; ENABLE-V4T-NEXT:    str r1, [sp, #4]\n+; ENABLE-V4T-NEXT:    str r1, [sp, #8]\n+; ENABLE-V4T-NEXT:    ldr r0, LCPI8_0\n+; ENABLE-V4T-NEXT:  LPC8_0:\n+; ENABLE-V4T-NEXT:    add r0, pc\n+; ENABLE-V4T-NEXT:    ldr r4, [r0]\n+; ENABLE-V4T-NEXT:    movs r0, r1\n+; ENABLE-V4T-NEXT:    movs r2, r1\n+; ENABLE-V4T-NEXT:    movs r3, r1\n+; ENABLE-V4T-NEXT:    bl Ltmp2\n+; ENABLE-V4T-NEXT:    lsls r0, r0, #3\n+; ENABLE-V4T-NEXT:    add sp, #16\n+; ENABLE-V4T-NEXT:    pop {r4}\n+; ENABLE-V4T-NEXT:    pop {r1}\n+; ENABLE-V4T-NEXT:    bx r1\n+; ENABLE-V4T-NEXT:  LBB8_2: @ %if.else\n+; ENABLE-V4T-NEXT:    lsls r0, r1, #1\n+; ENABLE-V4T-NEXT:    bx lr\n+; ENABLE-V4T-NEXT:    .p2align 2\n+; ENABLE-V4T-NEXT:  @ %bb.3:\n+; ENABLE-V4T-NEXT:    .data_region\n+; ENABLE-V4T-NEXT:  LCPI8_0:\n+; ENABLE-V4T-NEXT:    .long L_someVariadicFunc$non_lazy_ptr-(LPC8_0+4)\n+; ENABLE-V4T-NEXT:    .end_data_region\n+;\n+; ENABLE-V5T-LABEL: callVariadicFunc:\n+; ENABLE-V5T:       @ %bb.0: @ %entry\n+; ENABLE-V5T-NEXT:    cmp r0, #0\n+; ENABLE-V5T-NEXT:    beq LBB8_2\n+; ENABLE-V5T-NEXT:  @ %bb.1: @ %if.then\n+; ENABLE-V5T-NEXT:    push {r7, lr}\n+; ENABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V5T-NEXT:    .cfi_offset r7, -8\n+; ENABLE-V5T-NEXT:    sub sp, #16\n+; ENABLE-V5T-NEXT:    .cfi_def_cfa_offset 24\n+; ENABLE-V5T-NEXT:    str r1, [sp]\n+; ENABLE-V5T-NEXT:    str r1, [sp, #4]\n+; ENABLE-V5T-NEXT:    str r1, [sp, #8]\n+; ENABLE-V5T-NEXT:    movs r0, r1\n+; ENABLE-V5T-NEXT:    movs r2, r1\n+; ENABLE-V5T-NEXT:    movs r3, r1\n+; ENABLE-V5T-NEXT:    bl _someVariadicFunc\n+; ENABLE-V5T-NEXT:    lsls r0, r0, #3\n+; ENABLE-V5T-NEXT:    add sp, #16\n+; ENABLE-V5T-NEXT:    pop {r7, pc}\n+; ENABLE-V5T-NEXT:  LBB8_2: @ %if.else\n+; ENABLE-V5T-NEXT:    lsls r0, r1, #1\n+; ENABLE-V5T-NEXT:  LBB8_3: @ %if.end\n+; ENABLE-V5T-NEXT:    bx lr\n+;\n+; DISABLE-V4T-LABEL: callVariadicFunc:\n+; DISABLE-V4T:       @ %bb.0: @ %entry\n+; DISABLE-V4T-NEXT:    push {r4, lr}\n+; DISABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V4T-NEXT:    .cfi_offset r4, -8\n+; DISABLE-V4T-NEXT:    sub sp, #16\n+; DISABLE-V4T-NEXT:    .cfi_def_cfa_offset 24\n+; DISABLE-V4T-NEXT:    cmp r0, #0\n+; DISABLE-V4T-NEXT:    beq LBB8_2\n+; DISABLE-V4T-NEXT:  @ %bb.1: @ %if.then\n+; DISABLE-V4T-NEXT:    str r1, [sp]\n+; DISABLE-V4T-NEXT:    str r1, [sp, #4]\n+; DISABLE-V4T-NEXT:    str r1, [sp, #8]\n+; DISABLE-V4T-NEXT:    ldr r0, LCPI8_0\n+; DISABLE-V4T-NEXT:  LPC8_0:\n+; DISABLE-V4T-NEXT:    add r0, pc\n+; DISABLE-V4T-NEXT:    ldr r4, [r0]\n+; DISABLE-V4T-NEXT:    movs r0, r1\n+; DISABLE-V4T-NEXT:    movs r2, r1\n+; DISABLE-V4T-NEXT:    movs r3, r1\n+; DISABLE-V4T-NEXT:    bl Ltmp2\n+; DISABLE-V4T-NEXT:    lsls r0, r0, #3\n+; DISABLE-V4T-NEXT:    b LBB8_3\n+; DISABLE-V4T-NEXT:  LBB8_2: @ %if.else\n+; DISABLE-V4T-NEXT:    lsls r0, r1, #1\n+; DISABLE-V4T-NEXT:  LBB8_3: @ %if.end\n+; DISABLE-V4T-NEXT:    add sp, #16\n+; DISABLE-V4T-NEXT:    pop {r4}\n+; DISABLE-V4T-NEXT:    pop {r1}\n+; DISABLE-V4T-NEXT:    bx r1\n+; DISABLE-V4T-NEXT:    .p2align 2\n+; DISABLE-V4T-NEXT:  @ %bb.4:\n+; DISABLE-V4T-NEXT:    .data_region\n+; DISABLE-V4T-NEXT:  LCPI8_0:\n+; DISABLE-V4T-NEXT:    .long L_someVariadicFunc$non_lazy_ptr-(LPC8_0+4)\n+; DISABLE-V4T-NEXT:    .end_data_region\n+;\n+; DISABLE-V5T-LABEL: callVariadicFunc:\n+; DISABLE-V5T:       @ %bb.0: @ %entry\n+; DISABLE-V5T-NEXT:    push {r7, lr}\n+; DISABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V5T-NEXT:    .cfi_offset r7, -8\n+; DISABLE-V5T-NEXT:    sub sp, #16\n+; DISABLE-V5T-NEXT:    .cfi_def_cfa_offset 24\n+; DISABLE-V5T-NEXT:    cmp r0, #0\n+; DISABLE-V5T-NEXT:    beq LBB8_2\n+; DISABLE-V5T-NEXT:  @ %bb.1: @ %if.then\n+; DISABLE-V5T-NEXT:    str r1, [sp]\n+; DISABLE-V5T-NEXT:    str r1, [sp, #4]\n+; DISABLE-V5T-NEXT:    str r1, [sp, #8]\n+; DISABLE-V5T-NEXT:    movs r0, r1\n+; DISABLE-V5T-NEXT:    movs r2, r1\n+; DISABLE-V5T-NEXT:    movs r3, r1\n+; DISABLE-V5T-NEXT:    bl _someVariadicFunc\n+; DISABLE-V5T-NEXT:    lsls r0, r0, #3\n+; DISABLE-V5T-NEXT:    add sp, #16\n+; DISABLE-V5T-NEXT:    pop {r7, pc}\n+; DISABLE-V5T-NEXT:  LBB8_2: @ %if.else\n+; DISABLE-V5T-NEXT:    lsls r0, r1, #1\n+; DISABLE-V5T-NEXT:    add sp, #16\n+; DISABLE-V5T-NEXT:    pop {r7, pc}\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %if.then\n@@ -560,25 +1212,96 @@ declare i32 @someVariadicFunc(i32, ...)\n ; Although this is not incorrect to insert such code, it is useless\n ; and it hurts the binary size.\n ;\n-; CHECK-LABEL: noreturn:\n-; DISABLE: push\n-;\n-; CHECK: cmp r0, #0\n-; CHECK-NEXT: bne      [[ABORT:LBB[0-9_]+]]\n-;\n-; CHECK: movs r0, #42\n-;\n-; ENABLE-NEXT: bx lr\n-;\n-; DISABLE-NEXT: pop\n-;;\n-; CHECK: [[ABORT]]: @ %if.abort\n-;\n-; ENABLE: push\n-;\n-; CHECK: bl\n-; ENABLE-NOT: pop\n define i32 @noreturn(i8 signext %bad_thing) {\n+; ENABLE-V4T-LABEL: noreturn:\n+; ENABLE-V4T:       @ %bb.0: @ %entry\n+; ENABLE-V4T-NEXT:    cmp r0, #0\n+; ENABLE-V4T-NEXT:    bne LBB9_2\n+; ENABLE-V4T-NEXT:  @ %bb.1: @ %if.end\n+; ENABLE-V4T-NEXT:    movs r0, #42\n+; ENABLE-V4T-NEXT:    bx lr\n+; ENABLE-V4T-NEXT:  LBB9_2: @ %if.abort\n+; ENABLE-V4T-NEXT:    push {r4, lr}\n+; ENABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V4T-NEXT:    .cfi_offset r4, -8\n+; ENABLE-V4T-NEXT:    ldr r0, LCPI9_0\n+; ENABLE-V4T-NEXT:  LPC9_0:\n+; ENABLE-V4T-NEXT:    add r0, pc\n+; ENABLE-V4T-NEXT:    ldr r0, [r0]\n+; ENABLE-V4T-NEXT:    @ InlineAsm Start\n+; ENABLE-V4T-NEXT:    movs r1, #1\n+; ENABLE-V4T-NEXT:    @ InlineAsm End\n+; ENABLE-V4T-NEXT:    bl Ltmp3\n+; ENABLE-V4T-NEXT:    .p2align 2\n+; ENABLE-V4T-NEXT:  @ %bb.3:\n+; ENABLE-V4T-NEXT:    .data_region\n+; ENABLE-V4T-NEXT:  LCPI9_0:\n+; ENABLE-V4T-NEXT:    .long L_abort$non_lazy_ptr-(LPC9_0+4)\n+; ENABLE-V4T-NEXT:    .end_data_region\n+;\n+; ENABLE-V5T-LABEL: noreturn:\n+; ENABLE-V5T:       @ %bb.0: @ %entry\n+; ENABLE-V5T-NEXT:    cmp r0, #0\n+; ENABLE-V5T-NEXT:    bne LBB9_2\n+; ENABLE-V5T-NEXT:  @ %bb.1: @ %if.end\n+; ENABLE-V5T-NEXT:    movs r0, #42\n+; ENABLE-V5T-NEXT:    bx lr\n+; ENABLE-V5T-NEXT:  LBB9_2: @ %if.abort\n+; ENABLE-V5T-NEXT:    push {r4, lr}\n+; ENABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V5T-NEXT:    .cfi_offset r4, -8\n+; ENABLE-V5T-NEXT:    @ InlineAsm Start\n+; ENABLE-V5T-NEXT:    movs r0, #1\n+; ENABLE-V5T-NEXT:    @ InlineAsm End\n+; ENABLE-V5T-NEXT:    bl _abort\n+;\n+; DISABLE-V4T-LABEL: noreturn:\n+; DISABLE-V4T:       @ %bb.0: @ %entry\n+; DISABLE-V4T-NEXT:    push {r4, lr}\n+; DISABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V4T-NEXT:    .cfi_offset r4, -8\n+; DISABLE-V4T-NEXT:    cmp r0, #0\n+; DISABLE-V4T-NEXT:    bne LBB9_2\n+; DISABLE-V4T-NEXT:  @ %bb.1: @ %if.end\n+; DISABLE-V4T-NEXT:    movs r0, #42\n+; DISABLE-V4T-NEXT:    pop {r4}\n+; DISABLE-V4T-NEXT:    pop {r1}\n+; DISABLE-V4T-NEXT:    bx r1\n+; DISABLE-V4T-NEXT:  LBB9_2: @ %if.abort\n+; DISABLE-V4T-NEXT:    ldr r0, LCPI9_0\n+; DISABLE-V4T-NEXT:  LPC9_0:\n+; DISABLE-V4T-NEXT:    add r0, pc\n+; DISABLE-V4T-NEXT:    ldr r0, [r0]\n+; DISABLE-V4T-NEXT:    @ InlineAsm Start\n+; DISABLE-V4T-NEXT:    movs r1, #1\n+; DISABLE-V4T-NEXT:    @ InlineAsm End\n+; DISABLE-V4T-NEXT:    bl Ltmp3\n+; DISABLE-V4T-NEXT:    .p2align 2\n+; DISABLE-V4T-NEXT:  @ %bb.3:\n+; DISABLE-V4T-NEXT:    .data_region\n+; DISABLE-V4T-NEXT:  LCPI9_0:\n+; DISABLE-V4T-NEXT:    .long L_abort$non_lazy_ptr-(LPC9_0+4)\n+; DISABLE-V4T-NEXT:    .end_data_region\n+;\n+; DISABLE-V5T-LABEL: noreturn:\n+; DISABLE-V5T:       @ %bb.0: @ %entry\n+; DISABLE-V5T-NEXT:    push {r4, lr}\n+; DISABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V5T-NEXT:    .cfi_offset r4, -8\n+; DISABLE-V5T-NEXT:    cmp r0, #0\n+; DISABLE-V5T-NEXT:    bne LBB9_2\n+; DISABLE-V5T-NEXT:  @ %bb.1: @ %if.end\n+; DISABLE-V5T-NEXT:    movs r0, #42\n+; DISABLE-V5T-NEXT:    pop {r4, pc}\n+; DISABLE-V5T-NEXT:  LBB9_2: @ %if.abort\n+; DISABLE-V5T-NEXT:    @ InlineAsm Start\n+; DISABLE-V5T-NEXT:    movs r0, #1\n+; DISABLE-V5T-NEXT:    @ InlineAsm End\n+; DISABLE-V5T-NEXT:    bl _abort\n entry:\n   %tobool = icmp eq i8 %bad_thing, 0\n   br i1 %tobool, label %if.end, label %if.abort\n@@ -595,32 +1318,113 @@ if.end:\n declare void @abort() #0\n \n define i32 @b_to_bx(i32 %value) {\n-; CHECK-LABEL: b_to_bx:\n-; DISABLE: push {r7, lr}\n-; CHECK: cmp r0, #49\n-; CHECK-NEXT: bgt [[ELSE_LABEL:LBB[0-9_]+]]\n-; ENABLE: push {r7, lr}\n-\n-; CHECK: bl\n-; DISABLE-V5-NEXT: pop {r7, pc}\n-; DISABLE-V4T-NEXT: b [[END_LABEL:LBB[0-9_]+]]\n-\n-; ENABLE-V5-NEXT: pop {r7, pc}\n-; ENABLE-V4-NEXT: pop {r7}\n-; ENABLE-V4-NEXT: pop {r1}\n-; ENABLE-V4-NEXT: bx r1\n-\n-; CHECK: [[ELSE_LABEL]]: @ %if.else\n-; CHECK-NEXT: lsls r0, r1, #1\n-; DISABLE-V5-NEXT: pop {r7, pc}\n-; DISABLE-V4T-NEXT: [[END_LABEL]]: @ %if.end\n-; DISABLE-V4T-NEXT: pop {r7}\n-; DISABLE-V4T-NEXT: pop {r1}\n-; DISABLE-V4T-NEXT: bx r1\n-\n-; ENABLE-V5T-NEXT: {{LBB[0-9_]+}}: @ %if.end\n-; ENABLE-NEXT: bx lr\n-\n+; ENABLE-V4T-LABEL: b_to_bx:\n+; ENABLE-V4T:       @ %bb.0: @ %entry\n+; ENABLE-V4T-NEXT:    movs r1, r0\n+; ENABLE-V4T-NEXT:    cmp r0, #49\n+; ENABLE-V4T-NEXT:    bgt LBB10_2\n+; ENABLE-V4T-NEXT:  @ %bb.1: @ %if.then\n+; ENABLE-V4T-NEXT:    push {r7, lr}\n+; ENABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V4T-NEXT:    .cfi_offset r7, -8\n+; ENABLE-V4T-NEXT:    ldr r0, LCPI10_0\n+; ENABLE-V4T-NEXT:    ldr r2, LCPI10_1\n+; ENABLE-V4T-NEXT:  LPC10_0:\n+; ENABLE-V4T-NEXT:    add r2, pc\n+; ENABLE-V4T-NEXT:    bl Ltmp4\n+; ENABLE-V4T-NEXT:    pop {r7}\n+; ENABLE-V4T-NEXT:    pop {r1}\n+; ENABLE-V4T-NEXT:    bx r1\n+; ENABLE-V4T-NEXT:  LBB10_2: @ %if.else\n+; ENABLE-V4T-NEXT:    lsls r0, r1, #1\n+; ENABLE-V4T-NEXT:    bx lr\n+; ENABLE-V4T-NEXT:    .p2align 2\n+; ENABLE-V4T-NEXT:  @ %bb.3:\n+; ENABLE-V4T-NEXT:    .data_region\n+; ENABLE-V4T-NEXT:  LCPI10_0:\n+; ENABLE-V4T-NEXT:    .long 5000 @ 0x1388\n+; ENABLE-V4T-NEXT:  LCPI10_1:\n+; ENABLE-V4T-NEXT:    .long ___divsi3-(LPC10_0+4)\n+; ENABLE-V4T-NEXT:    .end_data_region\n+;\n+; ENABLE-V5T-LABEL: b_to_bx:\n+; ENABLE-V5T:       @ %bb.0: @ %entry\n+; ENABLE-V5T-NEXT:    movs r1, r0\n+; ENABLE-V5T-NEXT:    cmp r0, #49\n+; ENABLE-V5T-NEXT:    bgt LBB10_2\n+; ENABLE-V5T-NEXT:  @ %bb.1: @ %if.then\n+; ENABLE-V5T-NEXT:    push {r7, lr}\n+; ENABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V5T-NEXT:    .cfi_offset r7, -8\n+; ENABLE-V5T-NEXT:    ldr r0, LCPI10_0\n+; ENABLE-V5T-NEXT:    bl ___divsi3\n+; ENABLE-V5T-NEXT:    pop {r7, pc}\n+; ENABLE-V5T-NEXT:  LBB10_2: @ %if.else\n+; ENABLE-V5T-NEXT:    lsls r0, r1, #1\n+; ENABLE-V5T-NEXT:  LBB10_3: @ %if.end\n+; ENABLE-V5T-NEXT:    bx lr\n+; ENABLE-V5T-NEXT:    .p2align 2\n+; ENABLE-V5T-NEXT:  @ %bb.4:\n+; ENABLE-V5T-NEXT:    .data_region\n+; ENABLE-V5T-NEXT:  LCPI10_0:\n+; ENABLE-V5T-NEXT:    .long 5000 @ 0x1388\n+; ENABLE-V5T-NEXT:    .end_data_region\n+;\n+; DISABLE-V4T-LABEL: b_to_bx:\n+; DISABLE-V4T:       @ %bb.0: @ %entry\n+; DISABLE-V4T-NEXT:    push {r7, lr}\n+; DISABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V4T-NEXT:    .cfi_offset r7, -8\n+; DISABLE-V4T-NEXT:    movs r1, r0\n+; DISABLE-V4T-NEXT:    cmp r0, #49\n+; DISABLE-V4T-NEXT:    bgt LBB10_2\n+; DISABLE-V4T-NEXT:  @ %bb.1: @ %if.then\n+; DISABLE-V4T-NEXT:    ldr r0, LCPI10_0\n+; DISABLE-V4T-NEXT:    ldr r2, LCPI10_1\n+; DISABLE-V4T-NEXT:  LPC10_0:\n+; DISABLE-V4T-NEXT:    add r2, pc\n+; DISABLE-V4T-NEXT:    bl Ltmp4\n+; DISABLE-V4T-NEXT:    b LBB10_3\n+; DISABLE-V4T-NEXT:  LBB10_2: @ %if.else\n+; DISABLE-V4T-NEXT:    lsls r0, r1, #1\n+; DISABLE-V4T-NEXT:  LBB10_3: @ %if.end\n+; DISABLE-V4T-NEXT:    pop {r7}\n+; DISABLE-V4T-NEXT:    pop {r1}\n+; DISABLE-V4T-NEXT:    bx r1\n+; DISABLE-V4T-NEXT:    .p2align 2\n+; DISABLE-V4T-NEXT:  @ %bb.4:\n+; DISABLE-V4T-NEXT:    .data_region\n+; DISABLE-V4T-NEXT:  LCPI10_0:\n+; DISABLE-V4T-NEXT:    .long 5000 @ 0x1388\n+; DISABLE-V4T-NEXT:  LCPI10_1:\n+; DISABLE-V4T-NEXT:    .long ___divsi3-(LPC10_0+4)\n+; DISABLE-V4T-NEXT:    .end_data_region\n+;\n+; DISABLE-V5T-LABEL: b_to_bx:\n+; DISABLE-V5T:       @ %bb.0: @ %entry\n+; DISABLE-V5T-NEXT:    push {r7, lr}\n+; DISABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V5T-NEXT:    .cfi_offset r7, -8\n+; DISABLE-V5T-NEXT:    movs r1, r0\n+; DISABLE-V5T-NEXT:    cmp r0, #49\n+; DISABLE-V5T-NEXT:    bgt LBB10_2\n+; DISABLE-V5T-NEXT:  @ %bb.1: @ %if.then\n+; DISABLE-V5T-NEXT:    ldr r0, LCPI10_0\n+; DISABLE-V5T-NEXT:    bl ___divsi3\n+; DISABLE-V5T-NEXT:    pop {r7, pc}\n+; DISABLE-V5T-NEXT:  LBB10_2: @ %if.else\n+; DISABLE-V5T-NEXT:    lsls r0, r1, #1\n+; DISABLE-V5T-NEXT:    pop {r7, pc}\n+; DISABLE-V5T-NEXT:    .p2align 2\n+; DISABLE-V5T-NEXT:  @ %bb.3:\n+; DISABLE-V5T-NEXT:    .data_region\n+; DISABLE-V5T-NEXT:  LCPI10_0:\n+; DISABLE-V5T-NEXT:    .long 5000 @ 0x1388\n+; DISABLE-V5T-NEXT:    .end_data_region\n entry:\n   %cmp = icmp slt i32 %value, 50\n   br i1 %cmp, label %if.then, label %if.else\n@@ -639,29 +1443,93 @@ if.end:\n }\n \n define i1 @beq_to_bx(i32* %y, i32 %head) {\n-; CHECK-LABEL: beq_to_bx:\n-; DISABLE: push {r4, lr}\n-; CHECK: cmp r2, #0\n-; CHECK-NEXT: beq [[EXIT_LABEL:LBB[0-9_]+]]\n-; ENABLE: push {r4, lr}\n-\n-; CHECK: lsls    r4, r3, #30\n-; ENABLE-NEXT: ldr [[POP:r[4567]]], [sp, #4]\n-; ENABLE-NEXT: mov lr, [[POP]]\n-; ENABLE-NEXT: pop {[[POP]]}\n-; ENABLE-NEXT: add sp, #4\n-; CHECK-NEXT: bpl [[EXIT_LABEL]]\n-\n-; CHECK: str r1, [r2]\n-; CHECK: str r3, [r2]\n-; CHECK-NEXT: movs r0, #0\n-; CHECK-NEXT: [[EXIT_LABEL]]: @ %cleanup\n-; ENABLE-NEXT: bx lr\n-; DISABLE-V5-NEXT: pop {r4, pc}\n-; DISABLE-V4T-NEXT: pop {r4}\n-; DISABLE-V4T-NEXT: pop {r1}\n-; DISABLE-V4T-NEXT: bx r1\n-\n+; ENABLE-V4T-LABEL: beq_to_bx:\n+; ENABLE-V4T:       @ %bb.0: @ %entry\n+; ENABLE-V4T-NEXT:    push {r4, lr}\n+; ENABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V4T-NEXT:    .cfi_offset r4, -8\n+; ENABLE-V4T-NEXT:    movs r2, r0\n+; ENABLE-V4T-NEXT:    movs r0, #1\n+; ENABLE-V4T-NEXT:    cmp r2, #0\n+; ENABLE-V4T-NEXT:    beq LBB11_3\n+; ENABLE-V4T-NEXT:  @ %bb.1: @ %if.end\n+; ENABLE-V4T-NEXT:    ldr r3, [r2]\n+; ENABLE-V4T-NEXT:    lsls r4, r3, #30\n+; ENABLE-V4T-NEXT:    bpl LBB11_3\n+; ENABLE-V4T-NEXT:  @ %bb.2: @ %if.end4\n+; ENABLE-V4T-NEXT:    str r1, [r2]\n+; ENABLE-V4T-NEXT:    str r3, [r2]\n+; ENABLE-V4T-NEXT:    movs r0, #0\n+; ENABLE-V4T-NEXT:  LBB11_3: @ %cleanup\n+; ENABLE-V4T-NEXT:    pop {r4}\n+; ENABLE-V4T-NEXT:    pop {r1}\n+; ENABLE-V4T-NEXT:    bx r1\n+;\n+; ENABLE-V5T-LABEL: beq_to_bx:\n+; ENABLE-V5T:       @ %bb.0: @ %entry\n+; ENABLE-V5T-NEXT:    push {r4, lr}\n+; ENABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; ENABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; ENABLE-V5T-NEXT:    .cfi_offset r4, -8\n+; ENABLE-V5T-NEXT:    movs r2, r0\n+; ENABLE-V5T-NEXT:    movs r0, #1\n+; ENABLE-V5T-NEXT:    cmp r2, #0\n+; ENABLE-V5T-NEXT:    beq LBB11_3\n+; ENABLE-V5T-NEXT:  @ %bb.1: @ %if.end\n+; ENABLE-V5T-NEXT:    ldr r3, [r2]\n+; ENABLE-V5T-NEXT:    lsls r4, r3, #30\n+; ENABLE-V5T-NEXT:    bpl LBB11_3\n+; ENABLE-V5T-NEXT:  @ %bb.2: @ %if.end4\n+; ENABLE-V5T-NEXT:    str r1, [r2]\n+; ENABLE-V5T-NEXT:    str r3, [r2]\n+; ENABLE-V5T-NEXT:    movs r0, #0\n+; ENABLE-V5T-NEXT:  LBB11_3: @ %cleanup\n+; ENABLE-V5T-NEXT:    pop {r4, pc}\n+;\n+; DISABLE-V4T-LABEL: beq_to_bx:\n+; DISABLE-V4T:       @ %bb.0: @ %entry\n+; DISABLE-V4T-NEXT:    push {r4, lr}\n+; DISABLE-V4T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V4T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V4T-NEXT:    .cfi_offset r4, -8\n+; DISABLE-V4T-NEXT:    movs r2, r0\n+; DISABLE-V4T-NEXT:    movs r0, #1\n+; DISABLE-V4T-NEXT:    cmp r2, #0\n+; DISABLE-V4T-NEXT:    beq LBB11_3\n+; DISABLE-V4T-NEXT:  @ %bb.1: @ %if.end\n+; DISABLE-V4T-NEXT:    ldr r3, [r2]\n+; DISABLE-V4T-NEXT:    lsls r4, r3, #30\n+; DISABLE-V4T-NEXT:    bpl LBB11_3\n+; DISABLE-V4T-NEXT:  @ %bb.2: @ %if.end4\n+; DISABLE-V4T-NEXT:    str r1, [r2]\n+; DISABLE-V4T-NEXT:    str r3, [r2]\n+; DISABLE-V4T-NEXT:    movs r0, #0\n+; DISABLE-V4T-NEXT:  LBB11_3: @ %cleanup\n+; DISABLE-V4T-NEXT:    pop {r4}\n+; DISABLE-V4T-NEXT:    pop {r1}\n+; DISABLE-V4T-NEXT:    bx r1\n+;\n+; DISABLE-V5T-LABEL: beq_to_bx:\n+; DISABLE-V5T:       @ %bb.0: @ %entry\n+; DISABLE-V5T-NEXT:    push {r4, lr}\n+; DISABLE-V5T-NEXT:    .cfi_def_cfa_offset 8\n+; DISABLE-V5T-NEXT:    .cfi_offset lr, -4\n+; DISABLE-V5T-NEXT:    .cfi_offset r4, -8\n+; DISABLE-V5T-NEXT:    movs r2, r0\n+; DISABLE-V5T-NEXT:    movs r0, #1\n+; DISABLE-V5T-NEXT:    cmp r2, #0\n+; DISABLE-V5T-NEXT:    beq LBB11_3\n+; DISABLE-V5T-NEXT:  @ %bb.1: @ %if.end\n+; DISABLE-V5T-NEXT:    ldr r3, [r2]\n+; DISABLE-V5T-NEXT:    lsls r4, r3, #30\n+; DISABLE-V5T-NEXT:    bpl LBB11_3\n+; DISABLE-V5T-NEXT:  @ %bb.2: @ %if.end4\n+; DISABLE-V5T-NEXT:    str r1, [r2]\n+; DISABLE-V5T-NEXT:    str r3, [r2]\n+; DISABLE-V5T-NEXT:    movs r0, #0\n+; DISABLE-V5T-NEXT:  LBB11_3: @ %cleanup\n+; DISABLE-V5T-NEXT:    pop {r4, pc}\n entry:\n   %cmp = icmp eq i32* %y, null\n   br i1 %cmp, label %cleanup, label %if.end"
            },
            {
                "fn": "llvm/test/CodeGen/X86/2010-08-04-MaskedSignedCompare.ll",
                "patch": "@@ -9,6 +9,7 @@\n define i32 @main() nounwind {\n ; CHECK-LABEL: main:\n ; CHECK:       # %bb.0: # %entry\n+; CHECK-NEXT:    pushq %rax\n ; CHECK-NEXT:    xorl %eax, %eax\n ; CHECK-NEXT:    cmpq {{.*}}(%rip), %rax\n ; CHECK-NEXT:    sbbb %al, %al\n@@ -21,7 +22,6 @@ define i32 @main() nounwind {\n ; CHECK-NEXT:  .LBB0_1: # %entry.if.end_crit_edge\n ; CHECK-NEXT:    movl {{.*}}(%rip), %esi\n ; CHECK-NEXT:  .LBB0_3: # %if.end\n-; CHECK-NEXT:    pushq %rax\n ; CHECK-NEXT:    movl $.L.str, %edi\n ; CHECK-NEXT:    xorl %eax, %eax\n ; CHECK-NEXT:    callq printf"
            },
            {
                "fn": "llvm/test/CodeGen/X86/MachineSink-eflags.ll",
                "patch": "@@ -14,6 +14,7 @@ target triple = \"x86_64-pc-linux\"\n define void @foo(i8* nocapture %_stubArgs) nounwind {\n ; CHECK-LABEL: foo:\n ; CHECK:       # %bb.0: # %entry\n+; CHECK-NEXT:    subq $152, %rsp\n ; CHECK-NEXT:    movq 48(%rdi), %rax\n ; CHECK-NEXT:    movl 64(%rdi), %edx\n ; CHECK-NEXT:    movl $200, %esi\n@@ -29,14 +30,14 @@ define void @foo(i8* nocapture %_stubArgs) nounwind {\n ; CHECK-NEXT:    jne .LBB0_1\n ; CHECK-NEXT:  # %bb.2: # %entry\n ; CHECK-NEXT:    xorps %xmm1, %xmm1\n-; CHECK-NEXT:    jmp .LBB0_3\n+; CHECK-NEXT:    movaps %xmm1, -{{[0-9]+}}(%rsp)\n+; CHECK-NEXT:    je .LBB0_4\n+; CHECK-NEXT:    jmp .LBB0_5\n ; CHECK-NEXT:  .LBB0_1:\n ; CHECK-NEXT:    movaps (%rax,%rcx), %xmm1\n-; CHECK-NEXT:  .LBB0_3: # %entry\n-; CHECK-NEXT:    leaq -{{[0-9]+}}(%rsp), %rsp\n ; CHECK-NEXT:    movaps %xmm1, -{{[0-9]+}}(%rsp)\n ; CHECK-NEXT:    jne .LBB0_5\n-; CHECK-NEXT:  # %bb.4: # %entry\n+; CHECK-NEXT:  .LBB0_4: # %entry\n ; CHECK-NEXT:    xorps %xmm0, %xmm0\n ; CHECK-NEXT:  .LBB0_5: # %entry\n ; CHECK-NEXT:    movaps %xmm0, -{{[0-9]+}}(%rsp)"
            },
            {
                "fn": "llvm/test/CodeGen/X86/cmov.ll",
                "patch": "@@ -78,6 +78,7 @@ define void @test3(i64 %a, i64 %b, i1 %p) nounwind {\n define i1 @test4() nounwind {\n ; CHECK-LABEL: test4:\n ; CHECK:       # %bb.0: # %entry\n+; CHECK-NEXT:    pushq %rbx\n ; CHECK-NEXT:    movsbl {{.*}}(%rip), %edx\n ; CHECK-NEXT:    movzbl %dl, %ecx\n ; CHECK-NEXT:    shrl $7, %ecx\n@@ -90,7 +91,6 @@ define i1 @test4() nounwind {\n ; CHECK-NEXT:  # %bb.1: # %bb.i.i.i\n ; CHECK-NEXT:    movb {{.*}}(%rip), %cl\n ; CHECK-NEXT:  .LBB3_2: # %func_4.exit.i\n-; CHECK-NEXT:    pushq %rbx\n ; CHECK-NEXT:    xorl %esi, %esi\n ; CHECK-NEXT:    testb %dl, %dl\n ; CHECK-NEXT:    setne %bl"
            },
            {
                "fn": "llvm/test/CodeGen/X86/copy-eflags.ll",
                "patch": "@@ -43,6 +43,7 @@ define i32 @test1() nounwind {\n ;\n ; X64-LABEL: test1:\n ; X64:       # %bb.0: # %entry\n+; X64-NEXT:    pushq %rax\n ; X64-NEXT:    movb {{.*}}(%rip), %cl\n ; X64-NEXT:    leal 1(%rcx), %eax\n ; X64-NEXT:    movb %al, {{.*}}(%rip)\n@@ -56,12 +57,11 @@ define i32 @test1() nounwind {\n ; X64-NEXT:    testb %dl, %dl\n ; X64-NEXT:    jne .LBB0_2\n ; X64-NEXT:  # %bb.1: # %if.then\n-; X64-NEXT:    pushq %rax\n ; X64-NEXT:    movsbl %al, %edi\n ; X64-NEXT:    callq external\n-; X64-NEXT:    addq $8, %rsp\n ; X64-NEXT:  .LBB0_2: # %if.end\n ; X64-NEXT:    xorl %eax, %eax\n+; X64-NEXT:    popq %rcx\n ; X64-NEXT:    retq\n entry:\n   %bval = load i8, i8* @b"
            },
            {
                "fn": "llvm/test/CodeGen/X86/fold-pcmpeqd-2.ll",
                "patch": "@@ -17,16 +17,18 @@\n define void @program_1(%struct._image2d_t* %dest, %struct._image2d_t* %t0, <4 x float> %p0, <4 x float> %p1, <4 x float> %p4, <4 x float> %p5, <4 x float> %p6) nounwind {\n ; X32-LABEL: program_1:\n ; X32:       ## %bb.0: ## %entry\n+; X32-NEXT:    pushl %esi\n+; X32-NEXT:    subl $88, %esp\n ; X32-NEXT:    cmpl $0, 0\n ; X32-NEXT:    jle LBB0_2\n ; X32-NEXT:  ## %bb.1: ## %forcond\n ; X32-NEXT:    cmpl $0, 0\n ; X32-NEXT:    jg LBB0_3\n ; X32-NEXT:  LBB0_2: ## %ifthen\n+; X32-NEXT:    addl $88, %esp\n+; X32-NEXT:    popl %esi\n ; X32-NEXT:    retl\n ; X32-NEXT:  LBB0_3: ## %forbody\n-; X32-NEXT:    pushl %esi\n-; X32-NEXT:    subl $88, %esp\n ; X32-NEXT:    movaps {{.*#+}} xmm1 = [1.28E+2,1.28E+2,1.28E+2,1.28E+2]\n ; X32-NEXT:    minps LCPI0_3, %xmm1\n ; X32-NEXT:    cvttps2dq %xmm1, %xmm0\n@@ -99,16 +101,18 @@ define void @program_1(%struct._image2d_t* %dest, %struct._image2d_t* %t0, <4 x\n ;\n ; X64-LABEL: program_1:\n ; X64:       ## %bb.0: ## %entry\n+; X64-NEXT:    pushq %rbx\n+; X64-NEXT:    subq $64, %rsp\n ; X64-NEXT:    cmpl $0, 0\n ; X64-NEXT:    jle LBB0_2\n ; X64-NEXT:  ## %bb.1: ## %forcond\n ; X64-NEXT:    cmpl $0, 0\n ; X64-NEXT:    jg LBB0_3\n ; X64-NEXT:  LBB0_2: ## %ifthen\n+; X64-NEXT:    addq $64, %rsp\n+; X64-NEXT:    popq %rbx\n ; X64-NEXT:    retq\n ; X64-NEXT:  LBB0_3: ## %forbody\n-; X64-NEXT:    pushq %rbx\n-; X64-NEXT:    subq $64, %rsp\n ; X64-NEXT:    xorps %xmm0, %xmm0\n ; X64-NEXT:    movaps %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) ## 16-byte Spill\n ; X64-NEXT:    movaps {{.*#+}} xmm1 = [1.28E+2,1.28E+2,1.28E+2,1.28E+2]"
            },
            {
                "fn": "llvm/test/CodeGen/X86/i386-shrink-wrapping.ll",
                "patch": "@@ -1,5 +1,6 @@\n-; RUN: llc %s -o - -enable-shrink-wrap=true -no-x86-call-frame-opt | FileCheck %s --check-prefix=CHECK --check-prefix=ENABLE\n-; RUN: llc %s -o - -enable-shrink-wrap=false -no-x86-call-frame-opt | FileCheck %s --check-prefix=CHECK --check-prefix=DISABLE\n+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py\n+; RUN: llc %s -o - -enable-shrink-wrap=true -no-x86-call-frame-opt | FileCheck %s --check-prefix=ENABLE\n+; RUN: llc %s -o - -enable-shrink-wrap=false -no-x86-call-frame-opt | FileCheck %s --check-prefix=DISABLE\n target datalayout = \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\"\n target triple = \"i386-apple-macosx10.5\"\n \n@@ -15,53 +16,83 @@ target triple = \"i386-apple-macosx10.5\"\n ; Check that we are clobbering the flags when they are live-in of the\n ; prologue block and the prologue needs to adjust the stack.\n ; PR25607.\n-;\n-; CHECK-LABEL: eflagsLiveInPrologue:\n-;\n-; DISABLE: pushl\n-; DISABLE-NEXT: subl $8, %esp\n-;\n-; CHECK: movl L_a$non_lazy_ptr, [[A:%[a-z]+]]\n-; CHECK-NEXT: cmpl $0, ([[A]])\n-; CHECK-NEXT: je [[PREHEADER_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: movb $1, _d\n-;\n-; CHECK: [[PREHEADER_LABEL]]:\n-; CHECK-NEXT: movl L_b$non_lazy_ptr, [[B:%[a-z]+]]\n-; CHECK-NEXT: movl ([[B]]), [[TMP1:%[a-z]+]]\n-; CHECK-NEXT: testl [[TMP1]], [[TMP1]]\n-; CHECK-NEXT: je  [[FOREND_LABEL:LBB[0-9_]+]]\n-;\n-; Skip the loop.\n-; [...]\n-;\n-; The for.end block is split to accomadate the different selects.\n-; We are interested in the one with the call, so skip until the branch.\n-; CHECK: [[FOREND_LABEL]]:\n-\n-; ENABLE: pushl\n-; ENABLE-NEXT: subl $8, %esp\n-\n-; CHECK: xorl [[CMOVE_VAL:%edx]], [[CMOVE_VAL]]\n-; CHECK-NEXT: cmpb $0, _d\n-; CHECK-NEXT: movl $6, [[IMM_VAL:%ecx]]\n-; The eflags is used in the next instruction.\n-; If that instruction disappear, we are not exercising the bug\n-; anymore.\n-; CHECK-NEXT: cmovnel [[CMOVE_VAL]], [[IMM_VAL]]\n \n-; CHECK-NEXT: L_e$non_lazy_ptr, [[E:%[a-z]+]]\n-; CHECK-NEXT: movb %cl, ([[E]])\n-; CHECK-NEXT: leal 1(%ecx), %esi\n-\n-; CHECK: calll _varfunc\n-; Set the return value to 0.\n-; CHECK-NEXT: xorl %eax, %eax\n-; CHECK-NEXT: addl $8, %esp\n-; CHECK-NEXT: popl\n-; CHECK-NEXT: retl\n define i32 @eflagsLiveInPrologue() #0 {\n+; ENABLE-LABEL: eflagsLiveInPrologue:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    pushl %esi\n+; ENABLE-NEXT:    subl $8, %esp\n+; ENABLE-NEXT:    movl L_a$non_lazy_ptr, %eax\n+; ENABLE-NEXT:    cmpl $0, (%eax)\n+; ENABLE-NEXT:    je LBB0_2\n+; ENABLE-NEXT:  ## %bb.1: ## %if.then\n+; ENABLE-NEXT:    movb $1, _d\n+; ENABLE-NEXT:  LBB0_2: ## %for.cond.preheader\n+; ENABLE-NEXT:    movl L_b$non_lazy_ptr, %eax\n+; ENABLE-NEXT:    movl (%eax), %eax\n+; ENABLE-NEXT:    testl %eax, %eax\n+; ENABLE-NEXT:    je LBB0_4\n+; ENABLE-NEXT:    .p2align 4, 0x90\n+; ENABLE-NEXT:  LBB0_3: ## %for.body\n+; ENABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    jmp LBB0_3\n+; ENABLE-NEXT:  LBB0_4: ## %for.end\n+; ENABLE-NEXT:    xorl %edx, %edx\n+; ENABLE-NEXT:    cmpb $0, _d\n+; ENABLE-NEXT:    movl $6, %ecx\n+; ENABLE-NEXT:    cmovnel %edx, %ecx\n+; ENABLE-NEXT:    movl L_e$non_lazy_ptr, %edx\n+; ENABLE-NEXT:    movb %cl, (%edx)\n+; ENABLE-NEXT:    leal 1(%ecx), %esi\n+; ENABLE-NEXT:    cltd\n+; ENABLE-NEXT:    idivl %esi\n+; ENABLE-NEXT:    movl L_c$non_lazy_ptr, %eax\n+; ENABLE-NEXT:    movl %edx, (%eax)\n+; ENABLE-NEXT:    movl %ecx, {{[0-9]+}}(%esp)\n+; ENABLE-NEXT:    movl $L_.str, (%esp)\n+; ENABLE-NEXT:    calll _varfunc\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    addl $8, %esp\n+; ENABLE-NEXT:    popl %esi\n+; ENABLE-NEXT:    retl\n+;\n+; DISABLE-LABEL: eflagsLiveInPrologue:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    pushl %esi\n+; DISABLE-NEXT:    subl $8, %esp\n+; DISABLE-NEXT:    movl L_a$non_lazy_ptr, %eax\n+; DISABLE-NEXT:    cmpl $0, (%eax)\n+; DISABLE-NEXT:    je LBB0_2\n+; DISABLE-NEXT:  ## %bb.1: ## %if.then\n+; DISABLE-NEXT:    movb $1, _d\n+; DISABLE-NEXT:  LBB0_2: ## %for.cond.preheader\n+; DISABLE-NEXT:    movl L_b$non_lazy_ptr, %eax\n+; DISABLE-NEXT:    movl (%eax), %eax\n+; DISABLE-NEXT:    testl %eax, %eax\n+; DISABLE-NEXT:    je LBB0_4\n+; DISABLE-NEXT:    .p2align 4, 0x90\n+; DISABLE-NEXT:  LBB0_3: ## %for.body\n+; DISABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    jmp LBB0_3\n+; DISABLE-NEXT:  LBB0_4: ## %for.end\n+; DISABLE-NEXT:    xorl %edx, %edx\n+; DISABLE-NEXT:    cmpb $0, _d\n+; DISABLE-NEXT:    movl $6, %ecx\n+; DISABLE-NEXT:    cmovnel %edx, %ecx\n+; DISABLE-NEXT:    movl L_e$non_lazy_ptr, %edx\n+; DISABLE-NEXT:    movb %cl, (%edx)\n+; DISABLE-NEXT:    leal 1(%ecx), %esi\n+; DISABLE-NEXT:    cltd\n+; DISABLE-NEXT:    idivl %esi\n+; DISABLE-NEXT:    movl L_c$non_lazy_ptr, %eax\n+; DISABLE-NEXT:    movl %edx, (%eax)\n+; DISABLE-NEXT:    movl %ecx, {{[0-9]+}}(%esp)\n+; DISABLE-NEXT:    movl $L_.str, (%esp)\n+; DISABLE-NEXT:    calll _varfunc\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    addl $8, %esp\n+; DISABLE-NEXT:    popl %esi\n+; DISABLE-NEXT:    retl\n entry:\n   %tmp = load i32, i32* @a, align 4\n   %tobool = icmp eq i32 %tmp, 0"
            },
            {
                "fn": "llvm/test/CodeGen/X86/shrink-wrap-chkstk-x86_64.ll",
                "patch": "@@ -1,3 +1,4 @@\n+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py\n ; RUN: llc -mtriple=x86_64-windows-gnu -exception-model=dwarf < %s | FileCheck %s\n \n %struct.A = type { [4096 x i8] }\n@@ -6,6 +7,29 @@\n @b = common global i32 0, align 4\n \n define void @fn1() nounwind uwtable {\n+; CHECK-LABEL: fn1:\n+; CHECK:       # %bb.0: # %entry\n+; CHECK-NEXT:    movl $4136, %eax # imm = 0x1028\n+; CHECK-NEXT:    callq ___chkstk_ms\n+; CHECK-NEXT:    subq %rax, %rsp\n+; CHECK-NEXT:    .cfi_def_cfa_offset 4144\n+; CHECK-NEXT:    movl {{.*}}(%rip), %eax\n+; CHECK-NEXT:    testl %eax, %eax\n+; CHECK-NEXT:    jne .LBB0_2\n+; CHECK-NEXT:  # %bb.1: # %select.true.sink\n+; CHECK-NEXT:    cltq\n+; CHECK-NEXT:    imulq $715827883, %rax, %rax # imm = 0x2AAAAAAB\n+; CHECK-NEXT:    movq %rax, %rcx\n+; CHECK-NEXT:    shrq $63, %rcx\n+; CHECK-NEXT:    shrq $32, %rax\n+; CHECK-NEXT:    addl %ecx, %eax\n+; CHECK-NEXT:  .LBB0_2: # %select.end\n+; CHECK-NEXT:    movl %eax, {{.*}}(%rip)\n+; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rcx\n+; CHECK-NEXT:    # kill: def $ecx killed $ecx killed $rcx\n+; CHECK-NEXT:    callq fn2\n+; CHECK-NEXT:    addq $4136, %rsp # imm = 0x1028\n+; CHECK-NEXT:    retq\n entry:\n   %ctx = alloca %struct.A, align 1\n   %0 = load i32, i32* @a, align 4\n@@ -26,11 +50,3 @@ declare void @fn2(i32)\n declare void @llvm.lifetime.start.p0i8(i64, i8* nocapture)\n declare void @llvm.lifetime.end.p0i8(i64, i8* nocapture)\n \n-; CHECK-LABEL: fn1:\n-; CHECK: pushq %rax\n-; CHECK: movl $4128, %eax\n-; CHECK: callq ___chkstk_ms\n-; CHECK: subq %rax, %rsp\n-; CHECK: movq 4128(%rsp), %rax\n-\n-; CHECK: addq $4136, %rsp"
            },
            {
                "fn": "llvm/test/CodeGen/X86/x86-shrink-wrapping.ll",
                "patch": "@@ -1,6 +1,7 @@\n-; RUN: llc %s -o - -enable-shrink-wrap=true -pass-remarks-output=%t | FileCheck %s --check-prefix=CHECK --check-prefix=ENABLE\n+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py\n+; RUN: llc %s -o - -enable-shrink-wrap=true -pass-remarks-output=%t | FileCheck %s --check-prefix=ENABLE\n ; RUN: cat %t | FileCheck %s --check-prefix=REMARKS\n-; RUN: llc %s -o - -enable-shrink-wrap=false | FileCheck %s --check-prefix=CHECK --check-prefix=DISABLE\n+; RUN: llc %s -o - -enable-shrink-wrap=false | FileCheck %s --check-prefix=DISABLE\n ;\n ; Note: Lots of tests use inline asm instead of regular calls.\n ; This allows to have a better control on what the allocation will do.\n@@ -13,43 +14,38 @@ target triple = \"x86_64-apple-macosx\"\n \n \n ; Initial motivating example: Simple diamond with a call just on one side.\n-; CHECK-LABEL: foo:\n-;\n-; Compare the arguments and jump to exit.\n-; No prologue needed.\n-; ENABLE: movl %edi, [[ARG0CPY:%e[a-z]+]]\n-; ENABLE-NEXT: cmpl %esi, %edi\n-; ENABLE-NEXT: jge [[EXIT_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; (What we push does not matter. It should be some random sratch register.)\n-; CHECK: pushq\n-;\n-; Compare the arguments and jump to exit.\n-; After the prologue is set.\n-; DISABLE: movl %edi, [[ARG0CPY:%e[a-z]+]]\n-; DISABLE-NEXT: cmpl %esi, %edi\n-; DISABLE-NEXT: jge [[EXIT_LABEL:LBB[0-9_]+]]\n-;\n-; Store %a in the alloca.\n-; CHECK: movl [[ARG0CPY]], 4(%rsp)\n-; Set the alloca address in the second argument.\n-; CHECK-NEXT: leaq 4(%rsp), %rsi\n-; Set the first argument to zero.\n-; CHECK-NEXT: xorl %edi, %edi\n-; CHECK-NEXT: callq _doSomething\n-;\n-; With shrink-wrapping, epilogue is just after the call.\n-; ENABLE-NEXT: addq $8, %rsp\n-;\n-; CHECK: [[EXIT_LABEL]]:\n-;\n-; Without shrink-wrapping, epilogue is in the exit block.\n-; Epilogue code. (What we pop does not matter.)\n-; DISABLE-NEXT: popq\n-;\n-; CHECK-NEXT: retq\n define i32 @foo(i32 %a, i32 %b) {\n+; ENABLE-LABEL: foo:\n+; ENABLE:       ## %bb.0:\n+; ENABLE-NEXT:    movl %edi, %eax\n+; ENABLE-NEXT:    cmpl %esi, %edi\n+; ENABLE-NEXT:    jge LBB0_2\n+; ENABLE-NEXT:  ## %bb.1: ## %true\n+; ENABLE-NEXT:    pushq %rax\n+; ENABLE-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-NEXT:    movl %eax, {{[0-9]+}}(%rsp)\n+; ENABLE-NEXT:    leaq {{[0-9]+}}(%rsp), %rsi\n+; ENABLE-NEXT:    xorl %edi, %edi\n+; ENABLE-NEXT:    callq _doSomething\n+; ENABLE-NEXT:    addq $8, %rsp\n+; ENABLE-NEXT:  LBB0_2: ## %false\n+; ENABLE-NEXT:    retq\n+;\n+; DISABLE-LABEL: foo:\n+; DISABLE:       ## %bb.0:\n+; DISABLE-NEXT:    pushq %rax\n+; DISABLE-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-NEXT:    movl %edi, %eax\n+; DISABLE-NEXT:    cmpl %esi, %edi\n+; DISABLE-NEXT:    jge LBB0_2\n+; DISABLE-NEXT:  ## %bb.1: ## %true\n+; DISABLE-NEXT:    movl %eax, {{[0-9]+}}(%rsp)\n+; DISABLE-NEXT:    leaq {{[0-9]+}}(%rsp), %rsi\n+; DISABLE-NEXT:    xorl %edi, %edi\n+; DISABLE-NEXT:    callq _doSomething\n+; DISABLE-NEXT:  LBB0_2: ## %false\n+; DISABLE-NEXT:    popq %rcx\n+; DISABLE-NEXT:    retq\n   %tmp = alloca i32, align 4\n   %tmp2 = icmp slt i32 %a, %b\n   br i1 %tmp2, label %true, label %false\n@@ -70,51 +66,69 @@ declare i32 @doSomething(i32, i32*)\n \n ; Check that we do not perform the restore inside the loop whereas the save\n ; is outside.\n-; CHECK-LABEL: freqSaveAndRestoreOutsideLoop:\n-;\n-; Shrink-wrapping allows to skip the prologue in the else case.\n-; ENABLE: testl %edi, %edi\n-; ENABLE: je [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; Make sure we save the CSR used in the inline asm: rbx.\n-; CHECK: pushq %rbx\n-;\n-; DISABLE: testl %edi, %edi\n-; DISABLE: je [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: xorl [[SUM:%eax]], [[SUM]]\n-; CHECK-NEXT: movl $10, [[IV:%e[a-z]+]]\n-;\n-; Next BB.\n-; CHECK: [[LOOP:LBB[0-9_]+]]: ## %for.body\n-; CHECK: movl $1, [[TMP:%e[a-z]+]]\n-; CHECK: addl [[TMP]], [[SUM]]\n-; CHECK-NEXT: decl [[IV]]\n-; CHECK-NEXT: jne [[LOOP]]\n-;\n-; Next BB.\n-; SUM << 3.\n-; CHECK: shll $3, [[SUM]]\n-;\n-; DISABLE: popq\n-; DISABLE: retq\n-;\n-; DISABLE: [[ELSE_LABEL]]: ## %if.else\n-; Shift second argument by one in returned register.\n-; DISABLE: movl %esi, %eax\n-; DISABLE: addl %esi, %eax\n-;\n-; Epilogue code.\n-; CHECK-DAG: popq %rbx\n-; CHECK: retq\n-;\n-; ENABLE: [[ELSE_LABEL]]: ## %if.else\n-; Shift second argument by one and store into returned register.\n-; ENABLE: movl %esi, %eax\n-; ENABLE: addl %esi, %eax\n-; ENABLE-NEXT: retq\n define i32 @freqSaveAndRestoreOutsideLoop(i32 %cond, i32 %N) {\n+; ENABLE-LABEL: freqSaveAndRestoreOutsideLoop:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    testl %edi, %edi\n+; ENABLE-NEXT:    je LBB1_4\n+; ENABLE-NEXT:  ## %bb.1: ## %for.preheader\n+; ENABLE-NEXT:    pushq %rbx\n+; ENABLE-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-NEXT:    .cfi_offset %rbx, -16\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    nop\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    movl $10, %ecx\n+; ENABLE-NEXT:    .p2align 4, 0x90\n+; ENABLE-NEXT:  LBB1_2: ## %for.body\n+; ENABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    movl $1, %edx\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    addl %edx, %eax\n+; ENABLE-NEXT:    decl %ecx\n+; ENABLE-NEXT:    jne LBB1_2\n+; ENABLE-NEXT:  ## %bb.3: ## %for.end\n+; ENABLE-NEXT:    shll $3, %eax\n+; ENABLE-NEXT:    popq %rbx\n+; ENABLE-NEXT:    retq\n+; ENABLE-NEXT:  LBB1_4: ## %if.else\n+; ENABLE-NEXT:    movl %esi, %eax\n+; ENABLE-NEXT:    addl %esi, %eax\n+; ENABLE-NEXT:    retq\n+;\n+; DISABLE-LABEL: freqSaveAndRestoreOutsideLoop:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    pushq %rbx\n+; DISABLE-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-NEXT:    .cfi_offset %rbx, -16\n+; DISABLE-NEXT:    testl %edi, %edi\n+; DISABLE-NEXT:    je LBB1_4\n+; DISABLE-NEXT:  ## %bb.1: ## %for.preheader\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    nop\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    movl $10, %ecx\n+; DISABLE-NEXT:    .p2align 4, 0x90\n+; DISABLE-NEXT:  LBB1_2: ## %for.body\n+; DISABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    movl $1, %edx\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    addl %edx, %eax\n+; DISABLE-NEXT:    decl %ecx\n+; DISABLE-NEXT:    jne LBB1_2\n+; DISABLE-NEXT:  ## %bb.3: ## %for.end\n+; DISABLE-NEXT:    shll $3, %eax\n+; DISABLE-NEXT:    popq %rbx\n+; DISABLE-NEXT:    retq\n+; DISABLE-NEXT:  LBB1_4: ## %if.else\n+; DISABLE-NEXT:    movl %esi, %eax\n+; DISABLE-NEXT:    addl %esi, %eax\n+; DISABLE-NEXT:    popq %rbx\n+; DISABLE-NEXT:    retq\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %for.preheader\n@@ -149,25 +163,58 @@ declare i32 @something(...)\n \n ; Check that we do not perform the shrink-wrapping inside the loop even\n ; though that would be legal. The cost model must prevent that.\n-; CHECK-LABEL: freqSaveAndRestoreOutsideLoop2:\n-; Prologue code.\n-; Make sure we save the CSR used in the inline asm: rbx.\n-; CHECK: pushq %rbx\n-; CHECK: nop\n-; CHECK: xorl [[SUM:%e[a-z]+]], [[SUM]]\n-; CHECK-NEXT: movl $10, [[IV:%e[a-z]+]]\n-; Next BB.\n-; CHECK: [[LOOP_LABEL:LBB[0-9_]+]]: ## %for.body\n-; CHECK: movl $1, [[TMP:%e[a-z]+]]\n-; CHECK: addl [[TMP]], [[SUM]]\n-; CHECK-NEXT: decl [[IV]]\n-; CHECK-NEXT: jne [[LOOP_LABEL]]\n-; Next BB.\n-; CHECK: ## %for.exit\n-; CHECK: nop\n-; CHECK: popq %rbx\n-; CHECK-NEXT: retq\n define i32 @freqSaveAndRestoreOutsideLoop2(i32 %cond) {\n+; ENABLE-LABEL: freqSaveAndRestoreOutsideLoop2:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    pushq %rbx\n+; ENABLE-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-NEXT:    .cfi_offset %rbx, -16\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    nop\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    movl $10, %ecx\n+; ENABLE-NEXT:    .p2align 4, 0x90\n+; ENABLE-NEXT:  LBB2_1: ## %for.body\n+; ENABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    movl $1, %edx\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    addl %edx, %eax\n+; ENABLE-NEXT:    decl %ecx\n+; ENABLE-NEXT:    jne LBB2_1\n+; ENABLE-NEXT:  ## %bb.2: ## %for.exit\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    nop\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    popq %rbx\n+; ENABLE-NEXT:    retq\n+;\n+; DISABLE-LABEL: freqSaveAndRestoreOutsideLoop2:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    pushq %rbx\n+; DISABLE-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-NEXT:    .cfi_offset %rbx, -16\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    nop\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    movl $10, %ecx\n+; DISABLE-NEXT:    .p2align 4, 0x90\n+; DISABLE-NEXT:  LBB2_1: ## %for.body\n+; DISABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    movl $1, %edx\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    addl %edx, %eax\n+; DISABLE-NEXT:    decl %ecx\n+; DISABLE-NEXT:    jne LBB2_1\n+; DISABLE-NEXT:  ## %bb.2: ## %for.exit\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    nop\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    popq %rbx\n+; DISABLE-NEXT:    retq\n entry:\n   br label %for.preheader\n \n@@ -194,49 +241,75 @@ for.end:                                          ; preds = %for.body\n \n ; Check with a more complex case that we do not have save within the loop and\n ; restore outside.\n-; CHECK-LABEL: loopInfoSaveOutsideLoop:\n-;\n-; ENABLE: testl %edi, %edi\n-; ENABLE-NEXT: je [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; Make sure we save the CSR used in the inline asm: rbx.\n-; CHECK: pushq %rbx\n-;\n-; DISABLE: testl %edi, %edi\n-; DISABLE-NEXT: je [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: nop\n-; CHECK: xorl [[SUM:%eax]], [[SUM]]\n-; CHECK-NEXT: movl $10, [[IV:%e[a-z]+]]\n-;\n-; CHECK: [[LOOP_LABEL:LBB[0-9_]+]]: ## %for.body\n-; CHECK: movl $1, [[TMP:%e[a-z]+]]\n-; CHECK: addl [[TMP]], [[SUM]]\n-; CHECK-NEXT: decl [[IV]]\n-; CHECK-NEXT: jne [[LOOP_LABEL]]\n-; Next BB.\n-; CHECK: nop\n-; CHECK: shll $3, [[SUM]]\n-;\n-; DISABLE: popq\n-; DISABLE: retq\n-;\n-; DISABLE: [[ELSE_LABEL]]: ## %if.else\n-; Shift second argument by one in returned register.\n-; DISABLE: movl %esi, %eax\n-; DISABLE: addl %esi, %eax\n-;\n-; Epilogue code.\n-; CHECK-DAG: popq %rbx\n-; CHECK: retq\n-;\n-; ENABLE: [[ELSE_LABEL]]: ## %if.else\n-; Shift second argument by one and store into returned register.\n-; ENABLE: movl %esi, %eax\n-; ENABLE: addl %esi, %eax\n-; ENABLE-NEXT: retq\n define i32 @loopInfoSaveOutsideLoop(i32 %cond, i32 %N) {\n+; ENABLE-LABEL: loopInfoSaveOutsideLoop:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    testl %edi, %edi\n+; ENABLE-NEXT:    je LBB3_4\n+; ENABLE-NEXT:  ## %bb.1: ## %for.preheader\n+; ENABLE-NEXT:    pushq %rbx\n+; ENABLE-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-NEXT:    .cfi_offset %rbx, -16\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    nop\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    movl $10, %ecx\n+; ENABLE-NEXT:    .p2align 4, 0x90\n+; ENABLE-NEXT:  LBB3_2: ## %for.body\n+; ENABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    movl $1, %edx\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    addl %edx, %eax\n+; ENABLE-NEXT:    decl %ecx\n+; ENABLE-NEXT:    jne LBB3_2\n+; ENABLE-NEXT:  ## %bb.3: ## %for.end\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    nop\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    shll $3, %eax\n+; ENABLE-NEXT:    popq %rbx\n+; ENABLE-NEXT:    retq\n+; ENABLE-NEXT:  LBB3_4: ## %if.else\n+; ENABLE-NEXT:    movl %esi, %eax\n+; ENABLE-NEXT:    addl %esi, %eax\n+; ENABLE-NEXT:    retq\n+;\n+; DISABLE-LABEL: loopInfoSaveOutsideLoop:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    pushq %rbx\n+; DISABLE-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-NEXT:    .cfi_offset %rbx, -16\n+; DISABLE-NEXT:    testl %edi, %edi\n+; DISABLE-NEXT:    je LBB3_4\n+; DISABLE-NEXT:  ## %bb.1: ## %for.preheader\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    nop\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    movl $10, %ecx\n+; DISABLE-NEXT:    .p2align 4, 0x90\n+; DISABLE-NEXT:  LBB3_2: ## %for.body\n+; DISABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    movl $1, %edx\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    addl %edx, %eax\n+; DISABLE-NEXT:    decl %ecx\n+; DISABLE-NEXT:    jne LBB3_2\n+; DISABLE-NEXT:  ## %bb.3: ## %for.end\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    nop\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    shll $3, %eax\n+; DISABLE-NEXT:    popq %rbx\n+; DISABLE-NEXT:    retq\n+; DISABLE-NEXT:  LBB3_4: ## %if.else\n+; DISABLE-NEXT:    movl %esi, %eax\n+; DISABLE-NEXT:    addl %esi, %eax\n+; DISABLE-NEXT:    popq %rbx\n+; DISABLE-NEXT:    retq\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %for.preheader\n@@ -270,49 +343,65 @@ if.end:                                           ; preds = %if.else, %for.end\n \n ; Check with a more complex case that we do not have restore within the loop and\n ; save outside.\n-; CHECK-LABEL: loopInfoRestoreOutsideLoop:\n-;\n-; ENABLE: testl %edi, %edi\n-; ENABLE-NEXT: je [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; Make sure we save the CSR used in the inline asm: rbx.\n-; CHECK: pushq %rbx\n-;\n-; DISABLE: testl %edi, %edi\n-; DISABLE-NEXT: je [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: nop\n-; CHECK: xorl [[SUM:%eax]], [[SUM]]\n-; CHECK-NEXT: movl $10, [[IV:%e[a-z]+]]\n-;\n-; CHECK: [[LOOP_LABEL:LBB[0-9_]+]]: ## %for.body\n-; CHECK: movl $1, [[TMP:%e[a-z]+]]\n-; CHECK: addl [[TMP]], [[SUM]]\n-; CHECK-NEXT: decl [[IV]]\n-; CHECK-NEXT: jne [[LOOP_LABEL]]\n-; Next BB.\n-; CHECK: shll $3, [[SUM]]\n-;\n-; DISABLE: popq\n-; DISABLE: retq\n-;\n-; DISABLE: [[ELSE_LABEL]]: ## %if.else\n-\n-; Shift second argument by one in returned register.\n-; DISABLE: movl %esi, %eax\n-; DISABLE: addl %esi, %eax\n-;\n-; Epilogue code.\n-; CHECK-DAG: popq %rbx\n-; CHECK: retq\n-;\n-; ENABLE: [[ELSE_LABEL]]: ## %if.else\n-; Shift second argument by one and store into returned register.\n-; ENABLE: movl %esi, %eax\n-; ENABLE: addl %esi, %eax\n-; ENABLE-NEXT: retq\n define i32 @loopInfoRestoreOutsideLoop(i32 %cond, i32 %N) nounwind {\n+; ENABLE-LABEL: loopInfoRestoreOutsideLoop:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    testl %edi, %edi\n+; ENABLE-NEXT:    je LBB4_4\n+; ENABLE-NEXT:  ## %bb.1: ## %if.then\n+; ENABLE-NEXT:    pushq %rbx\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    nop\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    movl $10, %ecx\n+; ENABLE-NEXT:    .p2align 4, 0x90\n+; ENABLE-NEXT:  LBB4_2: ## %for.body\n+; ENABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    movl $1, %edx\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    addl %edx, %eax\n+; ENABLE-NEXT:    decl %ecx\n+; ENABLE-NEXT:    jne LBB4_2\n+; ENABLE-NEXT:  ## %bb.3: ## %for.end\n+; ENABLE-NEXT:    shll $3, %eax\n+; ENABLE-NEXT:    popq %rbx\n+; ENABLE-NEXT:    retq\n+; ENABLE-NEXT:  LBB4_4: ## %if.else\n+; ENABLE-NEXT:    movl %esi, %eax\n+; ENABLE-NEXT:    addl %esi, %eax\n+; ENABLE-NEXT:    retq\n+;\n+; DISABLE-LABEL: loopInfoRestoreOutsideLoop:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    pushq %rbx\n+; DISABLE-NEXT:    testl %edi, %edi\n+; DISABLE-NEXT:    je LBB4_4\n+; DISABLE-NEXT:  ## %bb.1: ## %if.then\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    nop\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    movl $10, %ecx\n+; DISABLE-NEXT:    .p2align 4, 0x90\n+; DISABLE-NEXT:  LBB4_2: ## %for.body\n+; DISABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    movl $1, %edx\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    addl %edx, %eax\n+; DISABLE-NEXT:    decl %ecx\n+; DISABLE-NEXT:    jne LBB4_2\n+; DISABLE-NEXT:  ## %bb.3: ## %for.end\n+; DISABLE-NEXT:    shll $3, %eax\n+; DISABLE-NEXT:    popq %rbx\n+; DISABLE-NEXT:    retq\n+; DISABLE-NEXT:  LBB4_4: ## %if.else\n+; DISABLE-NEXT:    movl %esi, %eax\n+; DISABLE-NEXT:    addl %esi, %eax\n+; DISABLE-NEXT:    popq %rbx\n+; DISABLE-NEXT:    retq\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %if.then\n@@ -344,58 +433,86 @@ if.end:                                           ; preds = %if.else, %for.end\n }\n \n ; Check that we handle function with no frame information correctly.\n-; CHECK-LABEL: emptyFrame:\n-; CHECK: ## %entry\n-; CHECK-NEXT: xorl %eax, %eax\n-; CHECK-NEXT: retq\n define i32 @emptyFrame() {\n+; ENABLE-LABEL: emptyFrame:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    retq\n+;\n+; DISABLE-LABEL: emptyFrame:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    retq\n entry:\n   ret i32 0\n }\n \n ; Check that we handle inline asm correctly.\n-; CHECK-LABEL: inlineAsm:\n-;\n-; ENABLE: testl %edi, %edi\n-; ENABLE-NEXT: je [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; Make sure we save the CSR used in the inline asm: rbx.\n-; CHECK: pushq %rbx\n-;\n-; DISABLE: testl %edi, %edi\n-; DISABLE-NEXT: je [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: nop\n-; CHECK: movl $10, [[IV:%e[a-z]+]]\n-;\n-; CHECK: [[LOOP_LABEL:LBB[0-9_]+]]: ## %for.body\n-; Inline asm statement.\n-; CHECK: addl $1, %ebx\n-; CHECK: decl [[IV]]\n-; CHECK-NEXT: jne [[LOOP_LABEL]]\n-; Next BB.\n-; CHECK: nop\n-; CHECK: xorl %eax, %eax\n-;\n-; DISABLE: popq\n-; DISABLE: retq\n-;\n-; DISABLE: [[ELSE_LABEL]]: ## %if.else\n-; Shift second argument by one in returned register.\n-; DISABLE: movl %esi, %eax\n-; DISABLE: addl %esi, %eax\n-;\n-; Epilogue code.\n-; CHECK-DAG: popq %rbx\n-; CHECK: retq\n-;\n-; ENABLE: [[ELSE_LABEL]]: ## %if.else\n-; Shift second argument by one and store into returned register.\n-; ENABLE: movl %esi, %eax\n-; ENABLE: addl %esi, %eax\n-; ENABLE-NEXT: retq\n define i32 @inlineAsm(i32 %cond, i32 %N) {\n+; ENABLE-LABEL: inlineAsm:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    testl %edi, %edi\n+; ENABLE-NEXT:    je LBB6_4\n+; ENABLE-NEXT:  ## %bb.1: ## %for.preheader\n+; ENABLE-NEXT:    pushq %rbx\n+; ENABLE-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-NEXT:    .cfi_offset %rbx, -16\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    nop\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    movl $10, %eax\n+; ENABLE-NEXT:    .p2align 4, 0x90\n+; ENABLE-NEXT:  LBB6_2: ## %for.body\n+; ENABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    addl $1, %ebx\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    decl %eax\n+; ENABLE-NEXT:    jne LBB6_2\n+; ENABLE-NEXT:  ## %bb.3: ## %for.exit\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    nop\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    popq %rbx\n+; ENABLE-NEXT:    retq\n+; ENABLE-NEXT:  LBB6_4: ## %if.else\n+; ENABLE-NEXT:    movl %esi, %eax\n+; ENABLE-NEXT:    addl %esi, %eax\n+; ENABLE-NEXT:    retq\n+;\n+; DISABLE-LABEL: inlineAsm:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    pushq %rbx\n+; DISABLE-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-NEXT:    .cfi_offset %rbx, -16\n+; DISABLE-NEXT:    testl %edi, %edi\n+; DISABLE-NEXT:    je LBB6_4\n+; DISABLE-NEXT:  ## %bb.1: ## %for.preheader\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    nop\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    movl $10, %eax\n+; DISABLE-NEXT:    .p2align 4, 0x90\n+; DISABLE-NEXT:  LBB6_2: ## %for.body\n+; DISABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    addl $1, %ebx\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    decl %eax\n+; DISABLE-NEXT:    jne LBB6_2\n+; DISABLE-NEXT:  ## %bb.3: ## %for.exit\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    nop\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    popq %rbx\n+; DISABLE-NEXT:    retq\n+; DISABLE-NEXT:  LBB6_4: ## %if.else\n+; DISABLE-NEXT:    movl %esi, %eax\n+; DISABLE-NEXT:    addl %esi, %eax\n+; DISABLE-NEXT:    popq %rbx\n+; DISABLE-NEXT:    retq\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %for.preheader\n@@ -425,43 +542,55 @@ if.end:                                           ; preds = %for.body, %if.else\n }\n \n ; Check that we handle calls to variadic functions correctly.\n-; CHECK-LABEL: callVariadicFunc:\n-;\n-; ENABLE: movl %esi, %eax\n-; ENABLE: testl %edi, %edi\n-; ENABLE-NEXT: je [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; CHECK: pushq\n-;\n-; DISABLE: movl %esi, %eax\n-; DISABLE: testl %edi, %edi\n-; DISABLE-NEXT: je [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; Setup of the varags.\n-; CHECK:       movl\t%eax, (%rsp)\n-; CHECK-NEXT:  movl\t%eax, %edi\n-; CHECK-NEXT:  movl\t%eax, %esi\n-; CHECK-NEXT:  movl\t%eax, %edx\n-; CHECK-NEXT:  movl\t%eax, %ecx\n-; CHECK-NEXT:  movl\t%eax, %r8d\n-; CHECK-NEXT:  movl\t%eax, %r9d\n-; CHECK-NEXT:  xorl\t%eax, %eax\n-; CHECK-NEXT: callq _someVariadicFunc\n-; CHECK-NEXT: shll $3, %eax\n-;\n-; ENABLE-NEXT: addq $8, %rsp\n-; ENABLE-NEXT: retq\n-;\n-\n-; CHECK: [[ELSE_LABEL]]: ## %if.else\n-; Shift second argument by one and store into returned register.\n-; CHECK: addl %eax, %eax\n-;\n-; Epilogue code.\n-; DISABLE-NEXT: popq\n-; CHECK-NEXT: retq\n define i32 @callVariadicFunc(i32 %cond, i32 %N) {\n+; ENABLE-LABEL: callVariadicFunc:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    movl %esi, %eax\n+; ENABLE-NEXT:    testl %edi, %edi\n+; ENABLE-NEXT:    je LBB7_2\n+; ENABLE-NEXT:  ## %bb.1: ## %if.then\n+; ENABLE-NEXT:    pushq %rax\n+; ENABLE-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-NEXT:    movl %eax, (%rsp)\n+; ENABLE-NEXT:    movl %eax, %edi\n+; ENABLE-NEXT:    movl %eax, %esi\n+; ENABLE-NEXT:    movl %eax, %edx\n+; ENABLE-NEXT:    movl %eax, %ecx\n+; ENABLE-NEXT:    movl %eax, %r8d\n+; ENABLE-NEXT:    movl %eax, %r9d\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    callq _someVariadicFunc\n+; ENABLE-NEXT:    shll $3, %eax\n+; ENABLE-NEXT:    addq $8, %rsp\n+; ENABLE-NEXT:    retq\n+; ENABLE-NEXT:  LBB7_2: ## %if.else\n+; ENABLE-NEXT:    addl %eax, %eax\n+; ENABLE-NEXT:    retq\n+;\n+; DISABLE-LABEL: callVariadicFunc:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    pushq %rax\n+; DISABLE-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-NEXT:    movl %esi, %eax\n+; DISABLE-NEXT:    testl %edi, %edi\n+; DISABLE-NEXT:    je LBB7_2\n+; DISABLE-NEXT:  ## %bb.1: ## %if.then\n+; DISABLE-NEXT:    movl %eax, (%rsp)\n+; DISABLE-NEXT:    movl %eax, %edi\n+; DISABLE-NEXT:    movl %eax, %esi\n+; DISABLE-NEXT:    movl %eax, %edx\n+; DISABLE-NEXT:    movl %eax, %ecx\n+; DISABLE-NEXT:    movl %eax, %r8d\n+; DISABLE-NEXT:    movl %eax, %r9d\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    callq _someVariadicFunc\n+; DISABLE-NEXT:    shll $3, %eax\n+; DISABLE-NEXT:    popq %rcx\n+; DISABLE-NEXT:    retq\n+; DISABLE-NEXT:  LBB7_2: ## %if.else\n+; DISABLE-NEXT:    addl %eax, %eax\n+; DISABLE-NEXT:    popq %rcx\n+; DISABLE-NEXT:    retq\n entry:\n   %tobool = icmp eq i32 %cond, 0\n   br i1 %tobool, label %if.else, label %if.then\n@@ -507,47 +636,80 @@ declare i32 @someVariadicFunc(i32, ...)\n \n declare hidden fastcc %struct.temp_slot* @find_temp_slot_from_address(%struct.rtx_def* readonly)\n \n-; CHECK-LABEL: useLEA:\n-; DISABLE: pushq\n-;\n-; CHECK: testq   %rdi, %rdi\n-; CHECK-NEXT: je      [[CLEANUP:LBB[0-9_]+]]\n-;\n-; CHECK: cmpw $66, (%rdi)\n-; CHECK-NEXT: jne [[CLEANUP]]\n-;\n-; CHECK: movq 8(%rdi), %rdi\n-; CHECK-NEXT: movzwl (%rdi), %e[[BF_LOAD2:[a-z]+]]\n-; CHECK-NEXT: leal -54(%r[[BF_LOAD2]]), [[TMP:%e[a-z]+]]\n-; CHECK-NEXT: cmpl $14, [[TMP]]\n-; CHECK-NEXT: ja [[LOR_LHS_FALSE:LBB[0-9_]+]]\n-;\n-; CHECK: movl $24599, [[TMP2:%e[a-z]+]]\n-; CHECK-NEXT: btl [[TMP]], [[TMP2]]\n-; CHECK-NEXT: jae [[LOR_LHS_FALSE:LBB[0-9_]+]]\n-;\n-; CHECK: [[CLEANUP]]: ## %cleanup\n-; DISABLE: popq\n-; CHECK-NEXT: retq\n-;\n-; CHECK: [[LOR_LHS_FALSE]]: ## %lor.lhs.false\n-; CHECK: cmpl $134, %e[[BF_LOAD2]]\n-; CHECK-NEXT: je [[CLEANUP]]\n-;\n-; CHECK: cmpl $140, %e[[BF_LOAD2]]\n-; CHECK-NEXT: je [[CLEANUP]]\n-;\n-; ENABLE: pushq\n-; CHECK: callq _find_temp_slot_from_address\n-; CHECK-NEXT: testq   %rax, %rax\n-;\n-; The adjustment must use LEA here (or be moved above the test).\n-; ENABLE-NEXT: leaq 8(%rsp), %rsp\n-;\n-; CHECK-NEXT: je [[CLEANUP]]\n-;\n-; CHECK: movb $1, 57(%rax)\n define void @useLEA(%struct.rtx_def* readonly %x) {\n+; ENABLE-LABEL: useLEA:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    pushq %rax\n+; ENABLE-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-NEXT:    testq %rdi, %rdi\n+; ENABLE-NEXT:    je LBB8_7\n+; ENABLE-NEXT:  ## %bb.1: ## %if.end\n+; ENABLE-NEXT:    cmpw $66, (%rdi)\n+; ENABLE-NEXT:    jne LBB8_7\n+; ENABLE-NEXT:  ## %bb.2: ## %lor.lhs.false\n+; ENABLE-NEXT:    movq 8(%rdi), %rdi\n+; ENABLE-NEXT:    movzwl (%rdi), %eax\n+; ENABLE-NEXT:    leal -54(%rax), %ecx\n+; ENABLE-NEXT:    cmpl $14, %ecx\n+; ENABLE-NEXT:    ja LBB8_3\n+; ENABLE-NEXT:  ## %bb.8: ## %lor.lhs.false\n+; ENABLE-NEXT:    movl $24599, %edx ## imm = 0x6017\n+; ENABLE-NEXT:    btl %ecx, %edx\n+; ENABLE-NEXT:    jae LBB8_3\n+; ENABLE-NEXT:  LBB8_7: ## %cleanup\n+; ENABLE-NEXT:    popq %rax\n+; ENABLE-NEXT:    retq\n+; ENABLE-NEXT:  LBB8_3: ## %lor.lhs.false\n+; ENABLE-NEXT:    cmpl $134, %eax\n+; ENABLE-NEXT:    je LBB8_7\n+; ENABLE-NEXT:  ## %bb.4: ## %lor.lhs.false\n+; ENABLE-NEXT:    cmpl $140, %eax\n+; ENABLE-NEXT:    je LBB8_7\n+; ENABLE-NEXT:  ## %bb.5: ## %if.end.55\n+; ENABLE-NEXT:    callq _find_temp_slot_from_address\n+; ENABLE-NEXT:    testq %rax, %rax\n+; ENABLE-NEXT:    je LBB8_7\n+; ENABLE-NEXT:  ## %bb.6: ## %if.then.60\n+; ENABLE-NEXT:    movb $1, 57(%rax)\n+; ENABLE-NEXT:    popq %rax\n+; ENABLE-NEXT:    retq\n+;\n+; DISABLE-LABEL: useLEA:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    pushq %rax\n+; DISABLE-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-NEXT:    testq %rdi, %rdi\n+; DISABLE-NEXT:    je LBB8_7\n+; DISABLE-NEXT:  ## %bb.1: ## %if.end\n+; DISABLE-NEXT:    cmpw $66, (%rdi)\n+; DISABLE-NEXT:    jne LBB8_7\n+; DISABLE-NEXT:  ## %bb.2: ## %lor.lhs.false\n+; DISABLE-NEXT:    movq 8(%rdi), %rdi\n+; DISABLE-NEXT:    movzwl (%rdi), %eax\n+; DISABLE-NEXT:    leal -54(%rax), %ecx\n+; DISABLE-NEXT:    cmpl $14, %ecx\n+; DISABLE-NEXT:    ja LBB8_3\n+; DISABLE-NEXT:  ## %bb.8: ## %lor.lhs.false\n+; DISABLE-NEXT:    movl $24599, %edx ## imm = 0x6017\n+; DISABLE-NEXT:    btl %ecx, %edx\n+; DISABLE-NEXT:    jae LBB8_3\n+; DISABLE-NEXT:  LBB8_7: ## %cleanup\n+; DISABLE-NEXT:    popq %rax\n+; DISABLE-NEXT:    retq\n+; DISABLE-NEXT:  LBB8_3: ## %lor.lhs.false\n+; DISABLE-NEXT:    cmpl $134, %eax\n+; DISABLE-NEXT:    je LBB8_7\n+; DISABLE-NEXT:  ## %bb.4: ## %lor.lhs.false\n+; DISABLE-NEXT:    cmpl $140, %eax\n+; DISABLE-NEXT:    je LBB8_7\n+; DISABLE-NEXT:  ## %bb.5: ## %if.end.55\n+; DISABLE-NEXT:    callq _find_temp_slot_from_address\n+; DISABLE-NEXT:    testq %rax, %rax\n+; DISABLE-NEXT:    je LBB8_7\n+; DISABLE-NEXT:  ## %bb.6: ## %if.then.60\n+; DISABLE-NEXT:    movb $1, 57(%rax)\n+; DISABLE-NEXT:    popq %rax\n+; DISABLE-NEXT:    retq\n entry:\n   %cmp = icmp eq %struct.rtx_def* %x, null\n   br i1 %cmp, label %cleanup, label %if.end\n@@ -594,26 +756,31 @@ cleanup:                                          ; preds = %if.then.60, %if.end\n ; Make sure we do not insert unreachable code after noreturn function.\n ; Although this is not incorrect to insert such code, it is useless\n ; and it hurts the binary size.\n-;\n-; CHECK-LABEL: noreturn:\n-; DISABLE: pushq\n-;\n-; CHECK: testb   %dil, %dil\n-; CHECK-NEXT: jne      [[ABORT:LBB[0-9_]+]]\n-;\n-; CHECK: movl $42, %eax\n-;\n-; DISABLE-NEXT: popq\n-;\n-; CHECK-NEXT: retq\n-;\n-; CHECK: [[ABORT]]: ## %if.abort\n-;\n-; ENABLE: pushq\n-;\n-; CHECK: callq _abort\n-; ENABLE-NOT: popq\n define i32 @noreturn(i8 signext %bad_thing) {\n+; ENABLE-LABEL: noreturn:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    testb %dil, %dil\n+; ENABLE-NEXT:    jne LBB9_2\n+; ENABLE-NEXT:  ## %bb.1: ## %if.end\n+; ENABLE-NEXT:    movl $42, %eax\n+; ENABLE-NEXT:    retq\n+; ENABLE-NEXT:  LBB9_2: ## %if.abort\n+; ENABLE-NEXT:    pushq %rax\n+; ENABLE-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-NEXT:    callq _abort\n+;\n+; DISABLE-LABEL: noreturn:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    pushq %rax\n+; DISABLE-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-NEXT:    testb %dil, %dil\n+; DISABLE-NEXT:    jne LBB9_2\n+; DISABLE-NEXT:  ## %bb.1: ## %if.end\n+; DISABLE-NEXT:    movl $42, %eax\n+; DISABLE-NEXT:    popq %rcx\n+; DISABLE-NEXT:    retq\n+; DISABLE-NEXT:  LBB9_2: ## %if.abort\n+; DISABLE-NEXT:    callq _abort\n entry:\n   %tobool = icmp eq i8 %bad_thing, 0\n   br i1 %tobool, label %if.end, label %if.abort\n@@ -639,9 +806,70 @@ attributes #0 = { noreturn nounwind }\n ; should return gracefully and continue compilation.\n ; The only condition for this test is the compilation finishes correctly.\n ;\n-; CHECK-LABEL: infiniteloop\n-; CHECK: retq\n define void @infiniteloop() {\n+; ENABLE-LABEL: infiniteloop:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    pushq %rbp\n+; ENABLE-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-NEXT:    .cfi_offset %rbp, -16\n+; ENABLE-NEXT:    movq %rsp, %rbp\n+; ENABLE-NEXT:    .cfi_def_cfa_register %rbp\n+; ENABLE-NEXT:    pushq %rbx\n+; ENABLE-NEXT:    pushq %rax\n+; ENABLE-NEXT:    .cfi_offset %rbx, -24\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    testb %al, %al\n+; ENABLE-NEXT:    jne LBB10_3\n+; ENABLE-NEXT:  ## %bb.1: ## %if.then\n+; ENABLE-NEXT:    movq %rsp, %rcx\n+; ENABLE-NEXT:    addq $-16, %rcx\n+; ENABLE-NEXT:    movq %rcx, %rsp\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    movl $1, %edx\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    .p2align 4, 0x90\n+; ENABLE-NEXT:  LBB10_2: ## %for.body\n+; ENABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    addl %edx, %eax\n+; ENABLE-NEXT:    movl %eax, (%rcx)\n+; ENABLE-NEXT:    jmp LBB10_2\n+; ENABLE-NEXT:  LBB10_3: ## %if.end\n+; ENABLE-NEXT:    leaq -8(%rbp), %rsp\n+; ENABLE-NEXT:    popq %rbx\n+; ENABLE-NEXT:    popq %rbp\n+; ENABLE-NEXT:    retq\n+;\n+; DISABLE-LABEL: infiniteloop:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    pushq %rbp\n+; DISABLE-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-NEXT:    .cfi_offset %rbp, -16\n+; DISABLE-NEXT:    movq %rsp, %rbp\n+; DISABLE-NEXT:    .cfi_def_cfa_register %rbp\n+; DISABLE-NEXT:    pushq %rbx\n+; DISABLE-NEXT:    pushq %rax\n+; DISABLE-NEXT:    .cfi_offset %rbx, -24\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    testb %al, %al\n+; DISABLE-NEXT:    jne LBB10_3\n+; DISABLE-NEXT:  ## %bb.1: ## %if.then\n+; DISABLE-NEXT:    movq %rsp, %rcx\n+; DISABLE-NEXT:    addq $-16, %rcx\n+; DISABLE-NEXT:    movq %rcx, %rsp\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    movl $1, %edx\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    .p2align 4, 0x90\n+; DISABLE-NEXT:  LBB10_2: ## %for.body\n+; DISABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    addl %edx, %eax\n+; DISABLE-NEXT:    movl %eax, (%rcx)\n+; DISABLE-NEXT:    jmp LBB10_2\n+; DISABLE-NEXT:  LBB10_3: ## %if.end\n+; DISABLE-NEXT:    leaq -8(%rbp), %rsp\n+; DISABLE-NEXT:    popq %rbx\n+; DISABLE-NEXT:    popq %rbp\n+; DISABLE-NEXT:    retq\n entry:\n   br i1 undef, label %if.then, label %if.end\n \n@@ -661,9 +889,102 @@ if.end:\n }\n \n ; Another infinite loop test this time with a body bigger than just one block.\n-; CHECK-LABEL: infiniteloop2\n-; CHECK: retq\n define void @infiniteloop2() {\n+; ENABLE-LABEL: infiniteloop2:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    pushq %rbp\n+; ENABLE-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-NEXT:    .cfi_offset %rbp, -16\n+; ENABLE-NEXT:    movq %rsp, %rbp\n+; ENABLE-NEXT:    .cfi_def_cfa_register %rbp\n+; ENABLE-NEXT:    pushq %rbx\n+; ENABLE-NEXT:    pushq %rax\n+; ENABLE-NEXT:    .cfi_offset %rbx, -24\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    testb %al, %al\n+; ENABLE-NEXT:    jne LBB11_5\n+; ENABLE-NEXT:  ## %bb.1: ## %if.then\n+; ENABLE-NEXT:    movq %rsp, %rcx\n+; ENABLE-NEXT:    addq $-16, %rcx\n+; ENABLE-NEXT:    movq %rcx, %rsp\n+; ENABLE-NEXT:    xorl %edx, %edx\n+; ENABLE-NEXT:    jmp LBB11_2\n+; ENABLE-NEXT:    .p2align 4, 0x90\n+; ENABLE-NEXT:  LBB11_4: ## %body2\n+; ENABLE-NEXT:    ## in Loop: Header=BB11_2 Depth=1\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    nop\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    movl $1, %edx\n+; ENABLE-NEXT:  LBB11_2: ## %for.body\n+; ENABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    movl %edx, %esi\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    movl $1, %edx\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    addl %esi, %edx\n+; ENABLE-NEXT:    movl %edx, (%rcx)\n+; ENABLE-NEXT:    testb %al, %al\n+; ENABLE-NEXT:    jne LBB11_4\n+; ENABLE-NEXT:  ## %bb.3: ## %body1\n+; ENABLE-NEXT:    ## in Loop: Header=BB11_2 Depth=1\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    nop\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    jmp LBB11_2\n+; ENABLE-NEXT:  LBB11_5: ## %if.end\n+; ENABLE-NEXT:    leaq -8(%rbp), %rsp\n+; ENABLE-NEXT:    popq %rbx\n+; ENABLE-NEXT:    popq %rbp\n+; ENABLE-NEXT:    retq\n+;\n+; DISABLE-LABEL: infiniteloop2:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    pushq %rbp\n+; DISABLE-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-NEXT:    .cfi_offset %rbp, -16\n+; DISABLE-NEXT:    movq %rsp, %rbp\n+; DISABLE-NEXT:    .cfi_def_cfa_register %rbp\n+; DISABLE-NEXT:    pushq %rbx\n+; DISABLE-NEXT:    pushq %rax\n+; DISABLE-NEXT:    .cfi_offset %rbx, -24\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    testb %al, %al\n+; DISABLE-NEXT:    jne LBB11_5\n+; DISABLE-NEXT:  ## %bb.1: ## %if.then\n+; DISABLE-NEXT:    movq %rsp, %rcx\n+; DISABLE-NEXT:    addq $-16, %rcx\n+; DISABLE-NEXT:    movq %rcx, %rsp\n+; DISABLE-NEXT:    xorl %edx, %edx\n+; DISABLE-NEXT:    jmp LBB11_2\n+; DISABLE-NEXT:    .p2align 4, 0x90\n+; DISABLE-NEXT:  LBB11_4: ## %body2\n+; DISABLE-NEXT:    ## in Loop: Header=BB11_2 Depth=1\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    nop\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    movl $1, %edx\n+; DISABLE-NEXT:  LBB11_2: ## %for.body\n+; DISABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    movl %edx, %esi\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    movl $1, %edx\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    addl %esi, %edx\n+; DISABLE-NEXT:    movl %edx, (%rcx)\n+; DISABLE-NEXT:    testb %al, %al\n+; DISABLE-NEXT:    jne LBB11_4\n+; DISABLE-NEXT:  ## %bb.3: ## %body1\n+; DISABLE-NEXT:    ## in Loop: Header=BB11_2 Depth=1\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    nop\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    jmp LBB11_2\n+; DISABLE-NEXT:  LBB11_5: ## %if.end\n+; DISABLE-NEXT:    leaq -8(%rbp), %rsp\n+; DISABLE-NEXT:    popq %rbx\n+; DISABLE-NEXT:    popq %rbp\n+; DISABLE-NEXT:    retq\n entry:\n   br i1 undef, label %if.then, label %if.end\n \n@@ -691,9 +1012,70 @@ if.end:\n }\n \n ; Another infinite loop test this time with two nested infinite loop.\n-; CHECK-LABEL: infiniteloop3\n-; CHECK: retq\n define void @infiniteloop3() {\n+; ENABLE-LABEL: infiniteloop3:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    testb %al, %al\n+; ENABLE-NEXT:    jne LBB12_2\n+; ENABLE-NEXT:  ## %bb.1: ## %body\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    testb %al, %al\n+; ENABLE-NEXT:    jne LBB12_7\n+; ENABLE-NEXT:  LBB12_2: ## %loop2a.preheader\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    xorl %ecx, %ecx\n+; ENABLE-NEXT:    movq %rax, %rsi\n+; ENABLE-NEXT:    jmp LBB12_4\n+; ENABLE-NEXT:    .p2align 4, 0x90\n+; ENABLE-NEXT:  LBB12_3: ## %loop2b\n+; ENABLE-NEXT:    ## in Loop: Header=BB12_4 Depth=1\n+; ENABLE-NEXT:    movq %rdx, (%rsi)\n+; ENABLE-NEXT:    movq %rdx, %rsi\n+; ENABLE-NEXT:  LBB12_4: ## %loop1\n+; ENABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    movq %rcx, %rdx\n+; ENABLE-NEXT:    testq %rax, %rax\n+; ENABLE-NEXT:    movq (%rax), %rcx\n+; ENABLE-NEXT:    jne LBB12_3\n+; ENABLE-NEXT:  ## %bb.5: ## in Loop: Header=BB12_4 Depth=1\n+; ENABLE-NEXT:    movq %rdx, %rax\n+; ENABLE-NEXT:    movq %rdx, %rsi\n+; ENABLE-NEXT:    jmp LBB12_4\n+; ENABLE-NEXT:  LBB12_7: ## %end\n+; ENABLE-NEXT:    retq\n+;\n+; DISABLE-LABEL: infiniteloop3:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    testb %al, %al\n+; DISABLE-NEXT:    jne LBB12_2\n+; DISABLE-NEXT:  ## %bb.1: ## %body\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    testb %al, %al\n+; DISABLE-NEXT:    jne LBB12_7\n+; DISABLE-NEXT:  LBB12_2: ## %loop2a.preheader\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    xorl %ecx, %ecx\n+; DISABLE-NEXT:    movq %rax, %rsi\n+; DISABLE-NEXT:    jmp LBB12_4\n+; DISABLE-NEXT:    .p2align 4, 0x90\n+; DISABLE-NEXT:  LBB12_3: ## %loop2b\n+; DISABLE-NEXT:    ## in Loop: Header=BB12_4 Depth=1\n+; DISABLE-NEXT:    movq %rdx, (%rsi)\n+; DISABLE-NEXT:    movq %rdx, %rsi\n+; DISABLE-NEXT:  LBB12_4: ## %loop1\n+; DISABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    movq %rcx, %rdx\n+; DISABLE-NEXT:    testq %rax, %rax\n+; DISABLE-NEXT:    movq (%rax), %rcx\n+; DISABLE-NEXT:    jne LBB12_3\n+; DISABLE-NEXT:  ## %bb.5: ## in Loop: Header=BB12_4 Depth=1\n+; DISABLE-NEXT:    movq %rdx, %rax\n+; DISABLE-NEXT:    movq %rdx, %rsi\n+; DISABLE-NEXT:    jmp LBB12_4\n+; DISABLE-NEXT:  LBB12_7: ## %end\n+; DISABLE-NEXT:    retq\n entry:\n   br i1 undef, label %loop2a, label %body\n \n@@ -724,44 +1106,49 @@ end:\n \n ; Check that we just don't bail out on RegMask.\n ; In this case, the RegMask does not touch a CSR so we are good to go!\n-; CHECK-LABEL: regmask:\n-;\n-; Compare the arguments and jump to exit.\n-; No prologue needed.\n-; ENABLE: cmpl %esi, %edi\n-; ENABLE-NEXT: jge [[EXIT_LABEL:LBB[0-9_]+]]\n-;\n-; Prologue code.\n-; (What we push does not matter. It should be some random sratch register.)\n-; CHECK: pushq\n-;\n-; Compare the arguments and jump to exit.\n-; After the prologue is set.\n-; DISABLE: cmpl %esi, %edi\n-; DISABLE-NEXT: jge [[EXIT_LABEL:LBB[0-9_]+]]\n-;\n-; CHECK: nop\n-; Set the first argument to zero.\n-; CHECK: xorl %edi, %edi\n-; Set the second argument to addr.\n-; CHECK-NEXT: movq %rdx, %rsi\n-; CHECK-NEXT: callq _doSomething\n-; CHECK-NEXT: popq\n-; CHECK-NEXT: retq\n-;\n-; CHECK: [[EXIT_LABEL]]:\n-; Set the first argument to 6.\n-; CHECK-NEXT: movl $6, %edi\n-; Set the second argument to addr.\n-; CHECK-NEXT: movq %rdx, %rsi\n-;\n-; Without shrink-wrapping, we need to restore the stack before\n-; making the tail call.\n-; Epilogue code.\n-; DISABLE-NEXT: popq\n-;\n-; CHECK-NEXT: jmp _doSomething\n define i32 @regmask(i32 %a, i32 %b, i32* %addr) {\n+; ENABLE-LABEL: regmask:\n+; ENABLE:       ## %bb.0:\n+; ENABLE-NEXT:    cmpl %esi, %edi\n+; ENABLE-NEXT:    jge LBB13_2\n+; ENABLE-NEXT:  ## %bb.1: ## %true\n+; ENABLE-NEXT:    pushq %rbx\n+; ENABLE-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-NEXT:    .cfi_offset %rbx, -16\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    nop\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    xorl %edi, %edi\n+; ENABLE-NEXT:    movq %rdx, %rsi\n+; ENABLE-NEXT:    callq _doSomething\n+; ENABLE-NEXT:    popq %rbx\n+; ENABLE-NEXT:    retq\n+; ENABLE-NEXT:  LBB13_2: ## %false\n+; ENABLE-NEXT:    movl $6, %edi\n+; ENABLE-NEXT:    movq %rdx, %rsi\n+; ENABLE-NEXT:    jmp _doSomething ## TAILCALL\n+;\n+; DISABLE-LABEL: regmask:\n+; DISABLE:       ## %bb.0:\n+; DISABLE-NEXT:    pushq %rbx\n+; DISABLE-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-NEXT:    .cfi_offset %rbx, -16\n+; DISABLE-NEXT:    cmpl %esi, %edi\n+; DISABLE-NEXT:    jge LBB13_2\n+; DISABLE-NEXT:  ## %bb.1: ## %true\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    nop\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    xorl %edi, %edi\n+; DISABLE-NEXT:    movq %rdx, %rsi\n+; DISABLE-NEXT:    callq _doSomething\n+; DISABLE-NEXT:    popq %rbx\n+; DISABLE-NEXT:    retq\n+; DISABLE-NEXT:  LBB13_2: ## %false\n+; DISABLE-NEXT:    movl $6, %edi\n+; DISABLE-NEXT:    movq %rdx, %rsi\n+; DISABLE-NEXT:    popq %rbx\n+; DISABLE-NEXT:    jmp _doSomething ## TAILCALL\n   %tmp2 = icmp slt i32 %a, %b\n   br i1 %tmp2, label %true, label %false\n \n@@ -791,41 +1178,76 @@ end:\n ; Note: The registers may change in the following patterns, but\n ; because they imply register hierarchy (e.g., eax, al) this is\n ; tricky to write robust patterns.\n-;\n-; CHECK-LABEL: useLEAForPrologue:\n-;\n-; Prologue is at the beginning of the function when shrink-wrapping\n-; is disabled.\n-; DISABLE: pushq\n-; The stack adjustment can use SUB instr because we do not need to\n-; preserve the EFLAGS at this point.\n-; DISABLE-NEXT: subq $16, %rsp\n-;\n-; Load the value of b.\n-; Create the zero value for the select assignment.\n-; CHECK: xorl [[CMOVE_VAL:%eax]], [[CMOVE_VAL]]\n-; CHECK-NEXT: cmpb $0, _b(%rip)\n-; CHECK-NEXT: movl $48, [[IMM_VAL:%ecx]]\n-; CHECK-NEXT: cmovnel [[CMOVE_VAL]], [[IMM_VAL]]\n-; CHECK-NEXT: movb %cl, _c(%rip)\n-; CHECK-NEXT: je [[VARFUNC_CALL:LBB[0-9_]+]]\n-;\n-; The code of the loop is not interesting.\n-; [...]\n-;\n-; CHECK: [[VARFUNC_CALL]]:\n-; Set the null parameter.\n-; CHECK-NEXT: xorl %edi, %edi\n-; CHECK-NEXT: callq _varfunc\n-;\n-; Set the return value.\n-; CHECK-NEXT: xorl %eax, %eax\n-;\n-; Epilogue code.\n-; CHECK-NEXT: addq $16, %rsp\n-; CHECK-NEXT: popq\n-; CHECK-NEXT: retq\n define i32 @useLEAForPrologue(i32 %d, i32 %a, i8 %c) #3 {\n+; ENABLE-LABEL: useLEAForPrologue:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    pushq %rbx\n+; ENABLE-NEXT:    subq $16, %rsp\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    cmpb $0, {{.*}}(%rip)\n+; ENABLE-NEXT:    movl $48, %ecx\n+; ENABLE-NEXT:    cmovnel %eax, %ecx\n+; ENABLE-NEXT:    movb %cl, {{.*}}(%rip)\n+; ENABLE-NEXT:    je LBB14_4\n+; ENABLE-NEXT:  ## %bb.1: ## %for.body.lr.ph\n+; ENABLE-NEXT:    ## InlineAsm Start\n+; ENABLE-NEXT:    nop\n+; ENABLE-NEXT:    ## InlineAsm End\n+; ENABLE-NEXT:    .p2align 4, 0x90\n+; ENABLE-NEXT:  LBB14_2: ## %for.body\n+; ENABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    cmpl %esi, %edi\n+; ENABLE-NEXT:    setl %al\n+; ENABLE-NEXT:    xorl %esi, %esi\n+; ENABLE-NEXT:    movb %al, %sil\n+; ENABLE-NEXT:    incb %dl\n+; ENABLE-NEXT:    cmpb $45, %dl\n+; ENABLE-NEXT:    jl LBB14_2\n+; ENABLE-NEXT:  ## %bb.3: ## %for.cond.for.end_crit_edge\n+; ENABLE-NEXT:    movq _a@{{.*}}(%rip), %rax\n+; ENABLE-NEXT:    movl %esi, (%rax)\n+; ENABLE-NEXT:  LBB14_4: ## %for.end\n+; ENABLE-NEXT:    xorl %edi, %edi\n+; ENABLE-NEXT:    callq _varfunc\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    addq $16, %rsp\n+; ENABLE-NEXT:    popq %rbx\n+; ENABLE-NEXT:    retq\n+;\n+; DISABLE-LABEL: useLEAForPrologue:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    pushq %rbx\n+; DISABLE-NEXT:    subq $16, %rsp\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    cmpb $0, {{.*}}(%rip)\n+; DISABLE-NEXT:    movl $48, %ecx\n+; DISABLE-NEXT:    cmovnel %eax, %ecx\n+; DISABLE-NEXT:    movb %cl, {{.*}}(%rip)\n+; DISABLE-NEXT:    je LBB14_4\n+; DISABLE-NEXT:  ## %bb.1: ## %for.body.lr.ph\n+; DISABLE-NEXT:    ## InlineAsm Start\n+; DISABLE-NEXT:    nop\n+; DISABLE-NEXT:    ## InlineAsm End\n+; DISABLE-NEXT:    .p2align 4, 0x90\n+; DISABLE-NEXT:  LBB14_2: ## %for.body\n+; DISABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    cmpl %esi, %edi\n+; DISABLE-NEXT:    setl %al\n+; DISABLE-NEXT:    xorl %esi, %esi\n+; DISABLE-NEXT:    movb %al, %sil\n+; DISABLE-NEXT:    incb %dl\n+; DISABLE-NEXT:    cmpb $45, %dl\n+; DISABLE-NEXT:    jl LBB14_2\n+; DISABLE-NEXT:  ## %bb.3: ## %for.cond.for.end_crit_edge\n+; DISABLE-NEXT:    movq _a@{{.*}}(%rip), %rax\n+; DISABLE-NEXT:    movl %esi, (%rax)\n+; DISABLE-NEXT:  LBB14_4: ## %for.end\n+; DISABLE-NEXT:    xorl %edi, %edi\n+; DISABLE-NEXT:    callq _varfunc\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    addq $16, %rsp\n+; DISABLE-NEXT:    popq %rbx\n+; DISABLE-NEXT:    retq\n entry:\n   %tmp = alloca i3\n   %.b = load i1, i1* @b, align 1\n@@ -866,24 +1288,48 @@ declare i32 @varfunc(i8* nocapture readonly)\n ; TLS calls used to be wrongly model and shrink-wrapping would have inserted\n ; the prologue and epilogue just around the call to doSomething.\n ; PR25820.\n-;\n-; CHECK-LABEL: tlsCall:\n-; CHECK: pushq\n-; CHECK: testb $1, %dil\n-; CHECK: je [[ELSE_LABEL:LBB[0-9_]+]]\n-;\n-; master bb\n-; CHECK: movq _sum1@TLVP(%rip), %rdi\n-; CHECK-NEXT: callq *(%rdi)\n-; CHECK: jmp [[EXIT_LABEL:LBB[0-9_]+]]\n-;\n-; [[ELSE_LABEL]]:\n-; CHECK: callq _doSomething\n-;\n-; [[EXIT_LABEL]]:\n-; CHECK: popq\n-; CHECK-NEXT: retq\n define i32 @tlsCall(i1 %bool1, i32 %arg, i32* readonly dereferenceable(4) %sum1) #3 {\n+; ENABLE-LABEL: tlsCall:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    pushq %rax\n+; ENABLE-NEXT:    testb $1, %dil\n+; ENABLE-NEXT:    je LBB15_2\n+; ENABLE-NEXT:  ## %bb.1: ## %master\n+; ENABLE-NEXT:    movl (%rdx), %ecx\n+; ENABLE-NEXT:    movq _sum1@{{.*}}(%rip), %rdi\n+; ENABLE-NEXT:    callq *(%rdi)\n+; ENABLE-NEXT:    movl %ecx, (%rax)\n+; ENABLE-NEXT:    jmp LBB15_3\n+; ENABLE-NEXT:  LBB15_2: ## %else\n+; ENABLE-NEXT:    xorl %edi, %edi\n+; ENABLE-NEXT:    xorl %esi, %esi\n+; ENABLE-NEXT:    callq _doSomething\n+; ENABLE-NEXT:    movl %eax, %esi\n+; ENABLE-NEXT:  LBB15_3: ## %exit\n+; ENABLE-NEXT:    movl %esi, %eax\n+; ENABLE-NEXT:    popq %rcx\n+; ENABLE-NEXT:    retq\n+;\n+; DISABLE-LABEL: tlsCall:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    pushq %rax\n+; DISABLE-NEXT:    testb $1, %dil\n+; DISABLE-NEXT:    je LBB15_2\n+; DISABLE-NEXT:  ## %bb.1: ## %master\n+; DISABLE-NEXT:    movl (%rdx), %ecx\n+; DISABLE-NEXT:    movq _sum1@{{.*}}(%rip), %rdi\n+; DISABLE-NEXT:    callq *(%rdi)\n+; DISABLE-NEXT:    movl %ecx, (%rax)\n+; DISABLE-NEXT:    jmp LBB15_3\n+; DISABLE-NEXT:  LBB15_2: ## %else\n+; DISABLE-NEXT:    xorl %edi, %edi\n+; DISABLE-NEXT:    xorl %esi, %esi\n+; DISABLE-NEXT:    callq _doSomething\n+; DISABLE-NEXT:    movl %eax, %esi\n+; DISABLE-NEXT:  LBB15_3: ## %exit\n+; DISABLE-NEXT:    movl %esi, %eax\n+; DISABLE-NEXT:    popq %rcx\n+; DISABLE-NEXT:    retq\n entry:\n   br i1 %bool1, label %master, label %else\n \n@@ -913,17 +1359,6 @@ attributes #3 = { nounwind }\n ; and since we use that information to do the placement, we may end up\n ; inserting the prologue/epilogue at incorrect places.\n ; PR25988.\n-;\n-; CHECK-LABEL: irreducibleCFG:\n-; CHECK: %entry\n-; Make sure the prologue happens in the entry block.\n-; CHECK-NEXT: pushq\n-; ...\n-; Make sure the epilogue happens in the exit block.\n-; CHECK-NOT: popq\n-; CHECK: popq\n-; CHECK-NEXT: popq\n-; CHECK-NEXT: retq\n ; Make sure we emit missed optimization remarks for this.\n ; REMARKS: Pass:            shrink-wrap\n ; REMARKS-NEXT: Name:            UnsupportedIrreducibleCFG\n@@ -932,6 +1367,93 @@ attributes #3 = { nounwind }\n ; REMARKS-NEXT:   - String:          Irreducible CFGs are not supported yet\n \n define i32 @irreducibleCFG() #4 {\n+; ENABLE-LABEL: irreducibleCFG:\n+; ENABLE:       ## %bb.0: ## %entry\n+; ENABLE-NEXT:    pushq %rbp\n+; ENABLE-NEXT:    .cfi_def_cfa_offset 16\n+; ENABLE-NEXT:    .cfi_offset %rbp, -16\n+; ENABLE-NEXT:    movq %rsp, %rbp\n+; ENABLE-NEXT:    .cfi_def_cfa_register %rbp\n+; ENABLE-NEXT:    pushq %rbx\n+; ENABLE-NEXT:    pushq %rax\n+; ENABLE-NEXT:    .cfi_offset %rbx, -24\n+; ENABLE-NEXT:    movq _irreducibleCFGf@{{.*}}(%rip), %rax\n+; ENABLE-NEXT:    cmpb $0, (%rax)\n+; ENABLE-NEXT:    je LBB16_2\n+; ENABLE-NEXT:    .p2align 4, 0x90\n+; ENABLE-NEXT:  LBB16_1: ## %preheader\n+; ENABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    jmp LBB16_1\n+; ENABLE-NEXT:  LBB16_2: ## %split\n+; ENABLE-NEXT:    movq _irreducibleCFGb@{{.*}}(%rip), %rax\n+; ENABLE-NEXT:    movl (%rax), %eax\n+; ENABLE-NEXT:    testl %eax, %eax\n+; ENABLE-NEXT:    je LBB16_3\n+; ENABLE-NEXT:  ## %bb.4: ## %for.body4.i\n+; ENABLE-NEXT:    movq _irreducibleCFGa@{{.*}}(%rip), %rax\n+; ENABLE-NEXT:    movl (%rax), %edi\n+; ENABLE-NEXT:    xorl %ebx, %ebx\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    callq _something\n+; ENABLE-NEXT:    jmp LBB16_5\n+; ENABLE-NEXT:  LBB16_3:\n+; ENABLE-NEXT:    xorl %ebx, %ebx\n+; ENABLE-NEXT:    .p2align 4, 0x90\n+; ENABLE-NEXT:  LBB16_5: ## %for.inc\n+; ENABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    incl %ebx\n+; ENABLE-NEXT:    cmpl $7, %ebx\n+; ENABLE-NEXT:    jl LBB16_5\n+; ENABLE-NEXT:  ## %bb.6: ## %fn1.exit\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    addq $8, %rsp\n+; ENABLE-NEXT:    popq %rbx\n+; ENABLE-NEXT:    popq %rbp\n+; ENABLE-NEXT:    retq\n+;\n+; DISABLE-LABEL: irreducibleCFG:\n+; DISABLE:       ## %bb.0: ## %entry\n+; DISABLE-NEXT:    pushq %rbp\n+; DISABLE-NEXT:    .cfi_def_cfa_offset 16\n+; DISABLE-NEXT:    .cfi_offset %rbp, -16\n+; DISABLE-NEXT:    movq %rsp, %rbp\n+; DISABLE-NEXT:    .cfi_def_cfa_register %rbp\n+; DISABLE-NEXT:    pushq %rbx\n+; DISABLE-NEXT:    pushq %rax\n+; DISABLE-NEXT:    .cfi_offset %rbx, -24\n+; DISABLE-NEXT:    movq _irreducibleCFGf@{{.*}}(%rip), %rax\n+; DISABLE-NEXT:    cmpb $0, (%rax)\n+; DISABLE-NEXT:    je LBB16_2\n+; DISABLE-NEXT:    .p2align 4, 0x90\n+; DISABLE-NEXT:  LBB16_1: ## %preheader\n+; DISABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    jmp LBB16_1\n+; DISABLE-NEXT:  LBB16_2: ## %split\n+; DISABLE-NEXT:    movq _irreducibleCFGb@{{.*}}(%rip), %rax\n+; DISABLE-NEXT:    movl (%rax), %eax\n+; DISABLE-NEXT:    testl %eax, %eax\n+; DISABLE-NEXT:    je LBB16_3\n+; DISABLE-NEXT:  ## %bb.4: ## %for.body4.i\n+; DISABLE-NEXT:    movq _irreducibleCFGa@{{.*}}(%rip), %rax\n+; DISABLE-NEXT:    movl (%rax), %edi\n+; DISABLE-NEXT:    xorl %ebx, %ebx\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    callq _something\n+; DISABLE-NEXT:    jmp LBB16_5\n+; DISABLE-NEXT:  LBB16_3:\n+; DISABLE-NEXT:    xorl %ebx, %ebx\n+; DISABLE-NEXT:    .p2align 4, 0x90\n+; DISABLE-NEXT:  LBB16_5: ## %for.inc\n+; DISABLE-NEXT:    ## =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    incl %ebx\n+; DISABLE-NEXT:    cmpl $7, %ebx\n+; DISABLE-NEXT:    jl LBB16_5\n+; DISABLE-NEXT:  ## %bb.6: ## %fn1.exit\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    addq $8, %rsp\n+; DISABLE-NEXT:    popq %rbx\n+; DISABLE-NEXT:    popq %rbp\n+; DISABLE-NEXT:    retq\n entry:\n   %i0 = load i32, i32* @irreducibleCFGa, align 4\n   %.pr = load i8, i8* @irreducibleCFGf, align 1\n@@ -978,20 +1500,60 @@ attributes #4 = { \"no-frame-pointer-elim\"=\"true\" }\n ; loop, which can occur into a misplacement of the restore block, if we're\n ; looking for the nearest common post-dominator of an \"unreachable\" block.\n \n-; CHECK-LABEL: infiniteLoopNoSuccessor:\n-; CHECK: ## %bb.0:\n-; Make sure the prologue happens in the entry block.\n-; CHECK-NEXT: pushq %rbp\n-; ...\n-; Make sure we don't shrink-wrap.\n-; CHECK: ## %bb.1\n-; CHECK-NOT: pushq %rbp\n-; ...\n-; Make sure the epilogue happens in the exit block.\n-; CHECK: ## %bb.5\n-; CHECK: popq %rbp\n-; CHECK-NEXT: retq\n define void @infiniteLoopNoSuccessor() #5 {\n+; ENABLE-LABEL: infiniteLoopNoSuccessor:\n+; ENABLE:       ## %bb.0:\n+; ENABLE-NEXT:    pushq %rbp\n+; ENABLE-NEXT:    movq %rsp, %rbp\n+; ENABLE-NEXT:    movq _x@{{.*}}(%rip), %rax\n+; ENABLE-NEXT:    cmpl $0, (%rax)\n+; ENABLE-NEXT:    je LBB17_2\n+; ENABLE-NEXT:  ## %bb.1:\n+; ENABLE-NEXT:    movl $0, (%rax)\n+; ENABLE-NEXT:  LBB17_2:\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    callq _somethingElse\n+; ENABLE-NEXT:    movq _y@{{.*}}(%rip), %rax\n+; ENABLE-NEXT:    cmpl $0, (%rax)\n+; ENABLE-NEXT:    je LBB17_3\n+; ENABLE-NEXT:  ## %bb.5:\n+; ENABLE-NEXT:    popq %rbp\n+; ENABLE-NEXT:    retq\n+; ENABLE-NEXT:  LBB17_3:\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    callq _something\n+; ENABLE-NEXT:    .p2align 4, 0x90\n+; ENABLE-NEXT:  LBB17_4: ## =>This Inner Loop Header: Depth=1\n+; ENABLE-NEXT:    xorl %eax, %eax\n+; ENABLE-NEXT:    callq _somethingElse\n+; ENABLE-NEXT:    jmp LBB17_4\n+;\n+; DISABLE-LABEL: infiniteLoopNoSuccessor:\n+; DISABLE:       ## %bb.0:\n+; DISABLE-NEXT:    pushq %rbp\n+; DISABLE-NEXT:    movq %rsp, %rbp\n+; DISABLE-NEXT:    movq _x@{{.*}}(%rip), %rax\n+; DISABLE-NEXT:    cmpl $0, (%rax)\n+; DISABLE-NEXT:    je LBB17_2\n+; DISABLE-NEXT:  ## %bb.1:\n+; DISABLE-NEXT:    movl $0, (%rax)\n+; DISABLE-NEXT:  LBB17_2:\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    callq _somethingElse\n+; DISABLE-NEXT:    movq _y@{{.*}}(%rip), %rax\n+; DISABLE-NEXT:    cmpl $0, (%rax)\n+; DISABLE-NEXT:    je LBB17_3\n+; DISABLE-NEXT:  ## %bb.5:\n+; DISABLE-NEXT:    popq %rbp\n+; DISABLE-NEXT:    retq\n+; DISABLE-NEXT:  LBB17_3:\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    callq _something\n+; DISABLE-NEXT:    .p2align 4, 0x90\n+; DISABLE-NEXT:  LBB17_4: ## =>This Inner Loop Header: Depth=1\n+; DISABLE-NEXT:    xorl %eax, %eax\n+; DISABLE-NEXT:    callq _somethingElse\n+; DISABLE-NEXT:    jmp LBB17_4\n   %1 = load i32, i32* @x, align 4\n   %2 = icmp ne i32 %1, 0\n   br i1 %2, label %3, label %4"
            },
            {
                "fn": "llvm/test/CodeGen/X86/xchg-nofold.ll",
                "patch": "@@ -9,6 +9,7 @@\n define zeroext i1 @_Z3fooRSt6atomicIbEb(%\"struct.std::atomic\"* nocapture dereferenceable(1) %a, i1 returned zeroext %b) nounwind {\n ; CHECK-LABEL: _Z3fooRSt6atomicIbEb:\n ; CHECK:       # %bb.0: # %entry\n+; CHECK-NEXT:    pushq %rax\n ; CHECK-NEXT:    movl %esi, %eax\n ; CHECK-NEXT:    movq %rdi, %rcx\n ; CHECK-NEXT:    shrq $3, %rcx\n@@ -24,9 +25,9 @@ define zeroext i1 @_Z3fooRSt6atomicIbEb(%\"struct.std::atomic\"* nocapture derefer\n ; CHECK-NEXT:    movl %eax, %ecx\n ; CHECK-NEXT:    xchgb %cl, (%rdi)\n ; CHECK-NEXT:    # kill: def $al killed $al killed $eax\n+; CHECK-NEXT:    popq %rcx\n ; CHECK-NEXT:    retq\n ; CHECK-NEXT:  .LBB0_2:\n-; CHECK-NEXT:    pushq %rax\n ; CHECK-NEXT:    callq __asan_report_store1\n ; CHECK-NEXT:    #APP\n ; CHECK-NEXT:    #NO_APP"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/2010-08-04-MaskedSignedCompare.ll (1 of 1)\nTesting Time: 0.22s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/2010-08-04-MaskedSignedCompare.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/MachineSink-eflags.ll (1 of 1)\nTesting Time: 0.09s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/MachineSink-eflags.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/cmov.ll (1 of 1)\nTesting Time: 0.19s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/cmov.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/copy-eflags.ll (1 of 1)\nTesting Time: 0.24s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/copy-eflags.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/fold-pcmpeqd-2.ll (1 of 1)\nTesting Time: 0.10s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/fold-pcmpeqd-2.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/i386-shrink-wrapping.ll (1 of 1)\nTesting Time: 0.09s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/i386-shrink-wrapping.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/shrink-wrap-chkstk-x86_64.ll (1 of 1)\nTesting Time: 0.09s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/shrink-wrap-chkstk-x86_64.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/x86-shrink-wrapping.ll (1 of 1)\nTesting Time: 0.30s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/x86-shrink-wrapping.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/xchg-nofold.ll (1 of 1)\nTesting Time: 0.09s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/xchg-nofold.ll\n\n  Unexpected Failures: 1\n"
    },
    "26b2c114515a8d011a952fe414ac92417298ea00___DAGCombiner.cpp": {
        "prefix": "static char isNegatibleForFree(SDValue Op, bool LegalOperations,\n                               const TargetLowering &TLI,\n                               const TargetOptions *Options,\n                               bool ForCodeSize,\n                               unsigned Depth = 0) {\n  // fneg is removable even if it has multiple uses.\n  if (Op.getOpcode() == ISD::FNEG)\n    return 2;\n\n  // Don't allow anything with multiple uses unless we know it is free.\n  EVT VT = Op.getValueType();\n  const SDNodeFlags Flags = Op->getFlags();\n  if (!Op.hasOneUse() &&\n      !(Op.getOpcode() == ISD::FP_EXTEND &&\n        TLI.isFPExtFree(VT, Op.getOperand(0).getValueType())))\n    return 0;\n\n  // Don't recurse exponentially.\n  if (Depth > 6)\n    return 0;\n\n  switch (Op.getOpcode()) {\n  default: return false;\n  case ISD::ConstantFP: {\n    if (!LegalOperations)\n      return 1;\n\n    // Don't invert constant FP values after legalization unless the target says\n    // the negated constant is legal.\n    return TLI.isOperationLegal(ISD::ConstantFP, VT) ||\n           TLI.isFPImmLegal(neg(cast<ConstantFPSDNode>(Op)->getValueAPF()), VT,\n                            ForCodeSize);\n  }\n  case ISD::BUILD_VECTOR: {\n    // Only permit BUILD_VECTOR of constants.\n    if (llvm::any_of(Op->op_values(), [&](SDValue N) {\n          return !N.isUndef() && !isa<ConstantFPSDNode>(N);\n        }))\n      return 0;\n    if (!LegalOperations)\n      return 1;\n    if (TLI.isOperationLegal(ISD::ConstantFP, VT) &&\n        TLI.isOperationLegal(ISD::BUILD_VECTOR, VT))\n      return 1;\n    return llvm::all_of(Op->op_values(), [&](SDValue N) {\n      return N.isUndef() ||\n             TLI.isFPImmLegal(neg(cast<ConstantFPSDNode>(N)->getValueAPF()), VT,\n                              ForCodeSize);\n    });\n  }\n  case ISD::FADD:\n    if (!Options->NoSignedZerosFPMath && !Flags.hasNoSignedZeros())\n      return 0;\n\n    // After operation legalization, it might not be legal to create new FSUBs.\n    if (LegalOperations && !TLI.isOperationLegalOrCustom(ISD::FSUB, VT))\n      return 0;\n\n    // fold (fneg (fadd A, B)) -> (fsub (fneg A), B)\n    if (char V = isNegatibleForFree(Op.getOperand(0), LegalOperations, TLI,\n                                    Options, ForCodeSize, Depth + 1))\n      return V;\n    // fold (fneg (fadd A, B)) -> (fsub (fneg B), A)\n    return isNegatibleForFree(Op.getOperand(1), LegalOperations, TLI, Options,\n                              ForCodeSize, Depth + 1);\n  case ISD::FSUB:\n    // We can't turn -(A-B) into B-A when we honor signed zeros.\n    if (!Options->NoSignedZerosFPMath && !Flags.hasNoSignedZeros())\n      return 0;\n\n    // fold (fneg (fsub A, B)) -> (fsub B, A)\n    return 1;\n\n  case ISD::FMUL:\n  case ISD::FDIV:\n    // fold (fneg (fmul X, Y)) -> (fmul (fneg X), Y) or (fmul X, (fneg Y))\n    if (char V = isNegatibleForFree(Op.getOperand(0), LegalOperations, TLI,\n                                    Options, ForCodeSize, Depth + 1))\n      return V;\n\n",
        "suffix": "                              ForCodeSize, Depth + 1);\n\n  case ISD::FP_EXTEND:\n  case ISD::FP_ROUND:\n  case ISD::FSIN:\n    return isNegatibleForFree(Op.getOperand(0), LegalOperations, TLI, Options,\n                              ForCodeSize, Depth + 1);\n  }\n}\n",
        "start": 791,
        "end": 880,
        "buggy": "static char isNegatibleForFree(SDValue Op, bool LegalOperations,\n                               const TargetLowering &TLI,\n                               const TargetOptions *Options,\n                               bool ForCodeSize,\n                               unsigned Depth = 0) {\n  // fneg is removable even if it has multiple uses.\n  if (Op.getOpcode() == ISD::FNEG)\n    return 2;\n\n  // Don't allow anything with multiple uses unless we know it is free.\n  EVT VT = Op.getValueType();\n  const SDNodeFlags Flags = Op->getFlags();\n  if (!Op.hasOneUse() &&\n      !(Op.getOpcode() == ISD::FP_EXTEND &&\n        TLI.isFPExtFree(VT, Op.getOperand(0).getValueType())))\n    return 0;\n\n  // Don't recurse exponentially.\n  if (Depth > 6)\n    return 0;\n\n  switch (Op.getOpcode()) {\n  default: return false;\n  case ISD::ConstantFP: {\n    if (!LegalOperations)\n      return 1;\n\n    // Don't invert constant FP values after legalization unless the target says\n    // the negated constant is legal.\n    return TLI.isOperationLegal(ISD::ConstantFP, VT) ||\n           TLI.isFPImmLegal(neg(cast<ConstantFPSDNode>(Op)->getValueAPF()), VT,\n                            ForCodeSize);\n  }\n  case ISD::BUILD_VECTOR: {\n    // Only permit BUILD_VECTOR of constants.\n    if (llvm::any_of(Op->op_values(), [&](SDValue N) {\n          return !N.isUndef() && !isa<ConstantFPSDNode>(N);\n        }))\n      return 0;\n    if (!LegalOperations)\n      return 1;\n    if (TLI.isOperationLegal(ISD::ConstantFP, VT) &&\n        TLI.isOperationLegal(ISD::BUILD_VECTOR, VT))\n      return 1;\n    return llvm::all_of(Op->op_values(), [&](SDValue N) {\n      return N.isUndef() ||\n             TLI.isFPImmLegal(neg(cast<ConstantFPSDNode>(N)->getValueAPF()), VT,\n                              ForCodeSize);\n    });\n  }\n  case ISD::FADD:\n    if (!Options->NoSignedZerosFPMath && !Flags.hasNoSignedZeros())\n      return 0;\n\n    // After operation legalization, it might not be legal to create new FSUBs.\n    if (LegalOperations && !TLI.isOperationLegalOrCustom(ISD::FSUB, VT))\n      return 0;\n\n    // fold (fneg (fadd A, B)) -> (fsub (fneg A), B)\n    if (char V = isNegatibleForFree(Op.getOperand(0), LegalOperations, TLI,\n                                    Options, ForCodeSize, Depth + 1))\n      return V;\n    // fold (fneg (fadd A, B)) -> (fsub (fneg B), A)\n    return isNegatibleForFree(Op.getOperand(1), LegalOperations, TLI, Options,\n                              ForCodeSize, Depth + 1);\n  case ISD::FSUB:\n    // We can't turn -(A-B) into B-A when we honor signed zeros.\n    if (!Options->NoSignedZerosFPMath && !Flags.hasNoSignedZeros())\n      return 0;\n\n    // fold (fneg (fsub A, B)) -> (fsub B, A)\n    return 1;\n\n  case ISD::FMUL:\n  case ISD::FDIV:\n    // fold (fneg (fmul X, Y)) -> (fmul (fneg X), Y) or (fmul X, (fneg Y))\n    if (char V = isNegatibleForFree(Op.getOperand(0), LegalOperations, TLI,\n                                    Options, ForCodeSize, Depth + 1))\n      return V;\n\n    return isNegatibleForFree(Op.getOperand(1), LegalOperations, TLI, Options,\n                              ForCodeSize, Depth + 1);\n\n  case ISD::FP_EXTEND:\n  case ISD::FP_ROUND:\n  case ISD::FSIN:\n    return isNegatibleForFree(Op.getOperand(0), LegalOperations, TLI, Options,\n                              ForCodeSize, Depth + 1);\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    return isNegatibleForFree(Op.getOperand(1), LegalOperations, TLI, Options,\n",
        "src_path": "26b2c114515a8d011a952fe414ac92417298ea00___DAGCombiner.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/26b2c114515a8d011a952fe414ac92417298ea00",
        "commit_msg": "[DAGCombiner] exclude x*2.0 from normal negation profitability rules\n\nThis is the codegen part of fixing:\nhttps://bugs.llvm.org/show_bug.cgi?id=32939\n\nEven with the optimal/canonical IR that is ideally created by D65954,\nwe would reverse that transform in DAGCombiner and end up with the same\nasm on AArch64 or x86.\n\nI see 2 options for trying to correct this:\n\n  1. Limit isNegatibleForFree() by special-casing the fmul pattern (this patch).\n  2. Avoid creating (fmul X, 2.0) in the 1st place by adding a special-case\n     transform to SelectionDAG::getNode() and/or SelectionDAGBuilder::visitFMul()\n     that matches the transform done by DAGCombiner.\n\nThis seems like the less intrusive patch, but if there's some other reason to\nprefer 1 option over the other, we can change to the other option.\n\nDifferential Revision: https://reviews.llvm.org/D66016\n\nllvm-svn: 368490",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/AArch64/fadd-combines.ll",
                "patch": "@@ -169,10 +169,9 @@ define float @fadd_const_multiuse_attr(float %x) {\n define double @fmul2_negated(double %a, double %b, double %c) {\n ; CHECK-LABEL: fmul2_negated:\n ; CHECK:       // %bb.0:\n-; CHECK-NEXT:    fmov d3, #-2.00000000\n-; CHECK-NEXT:    fmul d1, d1, d3\n+; CHECK-NEXT:    fadd d1, d1, d1\n ; CHECK-NEXT:    fmul d1, d1, d2\n-; CHECK-NEXT:    fadd d0, d0, d1\n+; CHECK-NEXT:    fsub d0, d0, d1\n ; CHECK-NEXT:    ret\n   %mul = fmul double %b, 2.0\n   %mul1 = fmul double %mul, %c\n@@ -183,10 +182,9 @@ define double @fmul2_negated(double %a, double %b, double %c) {\n define <2 x double> @fmul2_negated_vec(<2 x double> %a, <2 x double> %b, <2 x double> %c) {\n ; CHECK-LABEL: fmul2_negated_vec:\n ; CHECK:       // %bb.0:\n-; CHECK-NEXT:    fmov v3.2d, #-2.00000000\n-; CHECK-NEXT:    fmul v1.2d, v1.2d, v3.2d\n+; CHECK-NEXT:    fadd v1.2d, v1.2d, v1.2d\n ; CHECK-NEXT:    fmul v1.2d, v1.2d, v2.2d\n-; CHECK-NEXT:    fadd v0.2d, v0.2d, v1.2d\n+; CHECK-NEXT:    fsub v0.2d, v0.2d, v1.2d\n ; CHECK-NEXT:    ret\n   %mul = fmul <2 x double> %b, <double 2.0, double 2.0>\n   %mul1 = fmul <2 x double> %mul, %c"
            },
            {
                "fn": "llvm/test/CodeGen/X86/fadd-combines.ll",
                "patch": "@@ -252,9 +252,9 @@ define float @fadd_const_multiuse_attr(float %x) #0 {\n define double @fmul2_negated(double %a, double %b, double %c) {\n ; CHECK-LABEL: fmul2_negated:\n ; CHECK:       # %bb.0:\n-; CHECK-NEXT:    mulsd {{.*}}(%rip), %xmm1\n+; CHECK-NEXT:    addsd %xmm1, %xmm1\n ; CHECK-NEXT:    mulsd %xmm2, %xmm1\n-; CHECK-NEXT:    addsd %xmm1, %xmm0\n+; CHECK-NEXT:    subsd %xmm1, %xmm0\n ; CHECK-NEXT:    retq\n   %mul = fmul double %b, 2.0\n   %mul1 = fmul double %mul, %c\n@@ -265,9 +265,9 @@ define double @fmul2_negated(double %a, double %b, double %c) {\n define <2 x double> @fmul2_negated_vec(<2 x double> %a, <2 x double> %b, <2 x double> %c) {\n ; CHECK-LABEL: fmul2_negated_vec:\n ; CHECK:       # %bb.0:\n-; CHECK-NEXT:    mulpd {{.*}}(%rip), %xmm1\n+; CHECK-NEXT:    addpd %xmm1, %xmm1\n ; CHECK-NEXT:    mulpd %xmm2, %xmm1\n-; CHECK-NEXT:    addpd %xmm1, %xmm0\n+; CHECK-NEXT:    subpd %xmm1, %xmm0\n ; CHECK-NEXT:    retq\n   %mul = fmul <2 x double> %b, <double 2.0, double 2.0>\n   %mul1 = fmul <2 x double> %mul, %c"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/fadd-combines.ll (1 of 1)\nTesting Time: 0.27s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/fadd-combines.ll\n\n  Unexpected Failures: 1\n"
    },
    "2f32e5d84d3483a0d6170fc61d2cceb49fc930a3___InlineCost.cpp": {
        "prefix": "bool CallAnalyzer::visitSwitchInst(SwitchInst &SI) {\n  // We model unconditional switches as free, see the comments on handling\n  // branches.\n  if (isa<ConstantInt>(SI.getCondition()))\n    return true;\n  if (Value *V = SimplifiedValues.lookup(SI.getCondition()))\n    if (isa<ConstantInt>(V))\n      return true;\n\n  // Assume the most general case where the switch is lowered into\n  // either a jump table, bit test, or a balanced binary tree consisting of\n  // case clusters without merging adjacent clusters with the same\n  // destination. We do not consider the switches that are lowered with a mix\n  // of jump table/bit test/binary search tree. The cost of the switch is\n  // proportional to the size of the tree or the size of jump table range.\n  //\n  // NB: We convert large switches which are just used to initialize large phi\n  // nodes to lookup tables instead in simplify-cfg, so this shouldn't prevent\n  // inlining those. It will prevent inlining in cases where the optimization\n  // does not (yet) fire.\n\n  // Maximum valid cost increased in this function.\n  int CostUpperBound = INT_MAX - InlineConstants::InstrCost - 1;\n\n",
        "suffix": "  unsigned NumCaseCluster =\n      TTI.getEstimatedNumberOfCaseClusters(SI, JumpTableSize);\n\n  // If suitable for a jump table, consider the cost for the table size and\n  // branch to destination.\n  if (JumpTableSize) {\n    int64_t JTCost = (int64_t)JumpTableSize * InlineConstants::InstrCost +\n                     4 * InlineConstants::InstrCost;\n\n    addCost(JTCost, (int64_t)CostUpperBound);\n    return false;\n  }\n\n  // Considering forming a binary search, we should find the number of nodes\n  // which is same as the number of comparisons when lowered. For a given\n  // number of clusters, n, we can define a recursive function, f(n), to find\n  // the number of nodes in the tree. The recursion is :\n  // f(n) = 1 + f(n/2) + f (n - n/2), when n > 3,\n  // and f(n) = n, when n <= 3.\n  // This will lead a binary tree where the leaf should be either f(2) or f(3)\n  // when n > 3.  So, the number of comparisons from leaves should be n, while\n  // the number of non-leaf should be :\n  //   2^(log2(n) - 1) - 1\n  //   = 2^log2(n) * 2^-1 - 1\n  //   = n / 2 - 1.\n  // Considering comparisons from leaf and non-leaf nodes, we can estimate the\n  // number of comparisons in a simple closed form :\n  //   n + n / 2 - 1 = n * 3 / 2 - 1\n  if (NumCaseCluster <= 3) {\n    // Suppose a comparison includes one compare and one conditional branch.\n    addCost(NumCaseCluster * 2 * InlineConstants::InstrCost);\n    return false;\n  }\n\n  int64_t ExpectedNumberOfCompare = 3 * (int64_t)NumCaseCluster / 2 - 1;\n  int64_t SwitchCost =\n      ExpectedNumberOfCompare * 2 * InlineConstants::InstrCost;\n\n  addCost(SwitchCost, (int64_t)CostUpperBound);\n  return false;\n}\n",
        "start": 1432,
        "end": 1510,
        "buggy": "bool CallAnalyzer::visitSwitchInst(SwitchInst &SI) {\n  // We model unconditional switches as free, see the comments on handling\n  // branches.\n  if (isa<ConstantInt>(SI.getCondition()))\n    return true;\n  if (Value *V = SimplifiedValues.lookup(SI.getCondition()))\n    if (isa<ConstantInt>(V))\n      return true;\n\n  // Assume the most general case where the switch is lowered into\n  // either a jump table, bit test, or a balanced binary tree consisting of\n  // case clusters without merging adjacent clusters with the same\n  // destination. We do not consider the switches that are lowered with a mix\n  // of jump table/bit test/binary search tree. The cost of the switch is\n  // proportional to the size of the tree or the size of jump table range.\n  //\n  // NB: We convert large switches which are just used to initialize large phi\n  // nodes to lookup tables instead in simplify-cfg, so this shouldn't prevent\n  // inlining those. It will prevent inlining in cases where the optimization\n  // does not (yet) fire.\n\n  // Maximum valid cost increased in this function.\n  int CostUpperBound = INT_MAX - InlineConstants::InstrCost - 1;\n\n  // Exit early for a large switch, assuming one case needs at least one\n  // instruction.\n  // FIXME: This is not true for a bit test, but ignore such case for now to\n  // save compile-time.\n  int64_t CostLowerBound =\n      std::min((int64_t)CostUpperBound,\n               (int64_t)SI.getNumCases() * InlineConstants::InstrCost + Cost);\n\n  if (CostLowerBound > Threshold && !ComputeFullInlineCost) {\n    addCost((int64_t)SI.getNumCases() * InlineConstants::InstrCost);\n    return false;\n  }\n\n  unsigned JumpTableSize = 0;\n  unsigned NumCaseCluster =\n      TTI.getEstimatedNumberOfCaseClusters(SI, JumpTableSize);\n\n  // If suitable for a jump table, consider the cost for the table size and\n  // branch to destination.\n  if (JumpTableSize) {\n    int64_t JTCost = (int64_t)JumpTableSize * InlineConstants::InstrCost +\n                     4 * InlineConstants::InstrCost;\n\n    addCost(JTCost, (int64_t)CostUpperBound);\n    return false;\n  }\n\n  // Considering forming a binary search, we should find the number of nodes\n  // which is same as the number of comparisons when lowered. For a given\n  // number of clusters, n, we can define a recursive function, f(n), to find\n  // the number of nodes in the tree. The recursion is :\n  // f(n) = 1 + f(n/2) + f (n - n/2), when n > 3,\n  // and f(n) = n, when n <= 3.\n  // This will lead a binary tree where the leaf should be either f(2) or f(3)\n  // when n > 3.  So, the number of comparisons from leaves should be n, while\n  // the number of non-leaf should be :\n  //   2^(log2(n) - 1) - 1\n  //   = 2^log2(n) * 2^-1 - 1\n  //   = n / 2 - 1.\n  // Considering comparisons from leaf and non-leaf nodes, we can estimate the\n  // number of comparisons in a simple closed form :\n  //   n + n / 2 - 1 = n * 3 / 2 - 1\n  if (NumCaseCluster <= 3) {\n    // Suppose a comparison includes one compare and one conditional branch.\n    addCost(NumCaseCluster * 2 * InlineConstants::InstrCost);\n    return false;\n  }\n\n  int64_t ExpectedNumberOfCompare = 3 * (int64_t)NumCaseCluster / 2 - 1;\n  int64_t SwitchCost =\n      ExpectedNumberOfCompare * 2 * InlineConstants::InstrCost;\n\n  addCost(SwitchCost, (int64_t)CostUpperBound);\n  return false;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  // Exit early for a large switch, assuming one case needs at least one\n  // instruction.\n  // FIXME: This is not true for a bit test, but ignore such case for now to\n  // save compile-time.\n  int64_t CostLowerBound =\n      std::min((int64_t)CostUpperBound,\n               (int64_t)SI.getNumCases() * InlineConstants::InstrCost + Cost);\n\n  if (CostLowerBound > Threshold && !ComputeFullInlineCost) {\n    addCost((int64_t)SI.getNumCases() * InlineConstants::InstrCost);\n    return false;\n  }\n\n  unsigned JumpTableSize = 0;\n",
        "src_path": "2f32e5d84d3483a0d6170fc61d2cceb49fc930a3___InlineCost.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/2f32e5d84d3483a0d6170fc61d2cceb49fc930a3",
        "commit_msg": "[Inliner] Remove incorrect early exit during switch cost computation\n\nSummary:\nThe CallAnalyzer::visitSwitchInst has an early exit when the estimated\nlower bound of the switch cost will put the overall cost of the inline\nabove the threshold. However, this code is not correctly estimating the\nlower bound for switches that can be transformed into bit tests, leading\nto unnecessary lost inlines, and also differing behavior with\noptimization remarks enabled.\n\nFirst, the early exit is controlled by whether ComputeFullInlineCost is\nenabled or not, and that in turn is disabled by default but enabled when\nenabling -pass-remarks=missed. This by itself wouldn't lead to a\nproblem, except that as described below, the lower bound can be above\nthe real lower bound, so we can sometimes get different inline decisions\nwith inline remarks enabled, which is problematic.\n\nThe early exit was added in along with a new switch cost model in D31085.\nThe reason why this early exit was added is due to a concern one reviewer\nraised about compile time for large switches:\nhttps://reviews.llvm.org/D31085?id=94559#inline-276200\n\nHowever, the code just below there calls\ngetEstimatedNumberOfCaseClusters, which in turn immediately calls\nBasicTTIImpl getEstimatedNumberOfCaseClusters, which in the worst case\ndoes a linear scan of the cases to get the high and low values. The\nbit test handling in particular is guarded by whether the number of\ncases fits into the max bit width. There is no suggestion that anyone\nmeasured a compile time issue, it appears to be theoretical.\n\nThe problem is that the reviewer's comment about the lower bound\ncalculation is incorrect, specifically in the case of a switch that can\nbe lowered to a bit test. This isn't followed up on the comment\nthread, but the author does add a FIXME to that effect above the early\nexit added when they subsequently revised the patch.\n\nAs a result, we were incorrectly early exiting and not inlining\nfunctions with switch statements that would be lowered to bit tests in\ncases where we were nearing the threshold. Combined with the fact that\nthis early exit was skipped with opt remarks enabled, this caused\ndifferent inlining decisions to be made when -pass-remarks=missed is\nenabled to debug the missing inline.\n\nRemove the early exit for the above reasons.\n\nI also copied over an existing AArch64 inlining test to X86, and\nadjusted the threshold so that the bit test inline only occurs with the\nfix in this patch.\n\nReviewers: davidxl\n\nSubscribers: eraman, kristof.beyls, haicheng, llvm-commits\n\nTags: #llvm\n\nDifferential Revision: https://reviews.llvm.org/D67716\n\nllvm-svn: 372440",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/Inline/X86/switch.ll",
                "patch": "@@ -0,0 +1,160 @@\n+; RUN: opt < %s -inline -inline-threshold=1 -S -mtriple=x86_64-unknown-linux-gnu  | FileCheck %s\n+; RUN: opt < %s -passes='cgscc(inline)' -inline-threshold=1 -S -mtriple=x86_64-unknown-linux-gnu | FileCheck %s\n+\n+define i32 @callee_range(i32 %a, i32* %P) {\n+  switch i32 %a, label %sw.default [\n+    i32 0, label %sw.bb0\n+    i32 1000, label %sw.bb1\n+    i32 2000, label %sw.bb1\n+    i32 3000, label %sw.bb1\n+    i32 4000, label %sw.bb1\n+    i32 5000, label %sw.bb1\n+    i32 6000, label %sw.bb1\n+    i32 7000, label %sw.bb1\n+    i32 8000, label %sw.bb1\n+    i32 9000, label %sw.bb1\n+  ]\n+\n+sw.default:\n+  store volatile i32 %a, i32* %P\n+  br label %return\n+sw.bb0:\n+  store volatile i32 %a, i32* %P\n+  br label %return\n+sw.bb1:\n+  store volatile i32 %a, i32* %P\n+  br label %return\n+return:\n+  ret i32 42\n+}\n+\n+define i32 @caller_range(i32 %a, i32* %P) {\n+; CHECK-LABEL: @caller_range(\n+; CHECK: call i32 @callee_range\n+  %r = call i32 @callee_range(i32 %a, i32* %P)\n+  ret i32 %r\n+}\n+\n+define i32 @callee_bittest(i32 %a, i32* %P) {\n+  switch i32 %a, label %sw.default [\n+    i32 0, label %sw.bb0\n+    i32 1, label %sw.bb1\n+    i32 2, label %sw.bb2\n+    i32 3, label %sw.bb0\n+    i32 4, label %sw.bb1\n+    i32 5, label %sw.bb2\n+    i32 6, label %sw.bb0\n+    i32 7, label %sw.bb1\n+    i32 8, label %sw.bb2\n+  ]\n+\n+sw.default:\n+  store volatile i32 %a, i32* %P\n+  br label %return\n+\n+sw.bb0:\n+  store volatile i32 %a, i32* %P\n+  br label %return\n+\n+sw.bb1:\n+  store volatile i32 %a, i32* %P\n+  br label %return\n+\n+sw.bb2:\n+  br label %return\n+\n+return:\n+  ret i32 42\n+}\n+\n+\n+define i32 @caller_bittest(i32 %a, i32* %P) {\n+; CHECK-LABEL: @caller_bittest(\n+; CHECK-NOT: call i32 @callee_bittest\n+  %r= call i32 @callee_bittest(i32 %a, i32* %P)\n+  ret i32 %r\n+}\n+\n+define i32 @callee_jumptable(i32 %a, i32* %P) {\n+  switch i32 %a, label %sw.default [\n+    i32 1001, label %sw.bb101\n+    i32 1002, label %sw.bb102\n+    i32 1003, label %sw.bb103\n+    i32 1004, label %sw.bb104\n+    i32 1005, label %sw.bb101\n+    i32 1006, label %sw.bb102\n+    i32 1007, label %sw.bb103\n+    i32 1008, label %sw.bb104\n+    i32 1009, label %sw.bb101\n+    i32 1010, label %sw.bb102\n+    i32 1011, label %sw.bb103\n+    i32 1012, label %sw.bb104\n+ ]\n+\n+sw.default:\n+  br label %return\n+\n+sw.bb101:\n+  store volatile i32 %a, i32* %P\n+  br label %return\n+\n+sw.bb102:\n+  store volatile i32 %a, i32* %P\n+  br label %return\n+\n+sw.bb103:\n+  store volatile i32 %a, i32* %P\n+  br label %return\n+\n+sw.bb104:\n+  store volatile i32 %a, i32* %P\n+  br label %return\n+\n+return:\n+  ret i32 42\n+}\n+\n+define i32 @caller_jumptable(i32 %a, i32 %b, i32* %P) {\n+; CHECK-LABEL: @caller_jumptable(\n+; CHECK: call i32 @callee_jumptable\n+  %r = call i32 @callee_jumptable(i32 %b, i32* %P)\n+  ret i32 %r\n+}\n+\n+\n+define internal i32 @callee_negativeCost(i32 %t)  {\n+entry:\n+  switch i32 %t, label %sw.default [\n+    i32 1, label %sw.bb\n+    i32 0, label %sw.bb1\n+    i32 42, label %sw.bb2\n+    i32 43, label %sw.bb3\n+  ]\n+\n+sw.bb:                                            ; preds = %entry\n+  br label %cleanup\n+\n+sw.bb1:                                           ; preds = %entry\n+  br label %cleanup\n+\n+sw.bb2:                                           ; preds = %entry\n+  br label %cleanup\n+\n+sw.bb3:                                           ; preds = %entry\n+  br label %cleanup\n+\n+sw.default:                                       ; preds = %entry\n+  br label %cleanup\n+\n+cleanup:                                          ; preds = %sw.default, %sw.bb3, %sw.bb2, %sw.bb1, %sw.bb\n+  %retval.0 = phi i32 [ 1, %sw.default ], [ 3, %sw.bb3 ], [ 2, %sw.bb2 ], [ 0, %sw.bb1 ], [ 0, %sw.bb ]\n+  ret i32 %retval.0\n+}\n+\n+define i32 @caller_negativeCost(i32 %t) {\n+; CHECK-LABEL: @caller_negativeCost(\n+; CHECK-NOT: call i32 @callee_negativeCost\n+entry:\n+  %call = call i32 @callee_negativeCost(i32 %t)\n+  ret i32 %call\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/Inline/X86/switch.ll (1 of 1)\nTesting Time: 0.33s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/Inline/X86/switch.ll\n\n  Unexpected Failures: 1\n"
    },
    "d30093bb8a3f12d35d176a85cf93e354a38ff116___DivRemPairs.cpp": {
        "prefix": "static bool optimizeDivRem(Function &F, const TargetTransformInfo &TTI,\n                           const DominatorTree &DT) {\n  bool Changed = false;\n\n  // Get the matching pairs of div-rem instructions. We want this extra\n  // indirection to avoid dealing with having to RAUW the keys of the maps.\n  DivRemWorklistTy Worklist = getWorklist(F);\n\n  // Process each entry in the worklist.\n  for (DivRemPairWorklistEntry &E : Worklist) {\n    if (!DebugCounter::shouldExecute(DRPCounter))\n      continue;\n\n    bool HasDivRemOp = TTI.hasDivRemOp(E.getType(), E.isSigned());\n\n    auto &DivInst = E.DivInst;\n    auto &RemInst = E.RemInst;\n\n    const bool RemOriginallyWasInExpandedForm = E.isRemExpanded();\n    (void)RemOriginallyWasInExpandedForm; // suppress unused variable warning\n\n    if (HasDivRemOp && E.isRemExpanded()) {\n      // The target supports div+rem but the rem is expanded.\n      // We should recompose it first.\n      Value *X = E.getDividend();\n      Value *Y = E.getDivisor();\n      Instruction *RealRem = E.isSigned() ? BinaryOperator::CreateSRem(X, Y)\n                                          : BinaryOperator::CreateURem(X, Y);\n      // Note that we place it right next to the original expanded instruction,\n      // and letting further handling to move it if needed.\n      RealRem->setName(RemInst->getName() + \".recomposed\");\n      RealRem->insertAfter(RemInst);\n      Instruction *OrigRemInst = RemInst;\n      // Update AssertingVH<> with new instruction so it doesn't assert.\n      RemInst = RealRem;\n      // And replace the original instruction with the new one.\n      OrigRemInst->replaceAllUsesWith(RealRem);\n      OrigRemInst->eraseFromParent();\n      NumRecomposed++;\n      // Note that we have left ((X / Y) * Y) around.\n      // If it had other uses we could rewrite it as X - X % Y\n    }\n\n    assert((!E.isRemExpanded() || !HasDivRemOp) &&\n           \"*If* the target supports div-rem, then by now the RemInst *is* \"\n           \"Instruction::[US]Rem.\");\n\n    // If the target supports div+rem and the instructions are in the same block\n    // already, there's nothing to do. The backend should handle this. If the\n    // target does not support div+rem, then we will decompose the rem.\n    if (HasDivRemOp && RemInst->getParent() == DivInst->getParent())\n      continue;\n\n    bool DivDominates = DT.dominates(DivInst, RemInst);\n    if (!DivDominates && !DT.dominates(RemInst, DivInst)) {\n      // We have matching div-rem pair, but they are in two different blocks,\n      // neither of which dominates one another.\n",
        "suffix": "      continue;\n    }\n\n    // The target does not have a single div/rem operation,\n    // and the rem is already in expanded form. Nothing to do.\n    if (!HasDivRemOp && E.isRemExpanded())\n      continue;\n\n    if (HasDivRemOp) {\n      // The target has a single div/rem operation. Hoist the lower instruction\n      // to make the matched pair visible to the backend.\n      if (DivDominates)\n        RemInst->moveAfter(DivInst);\n      else\n        DivInst->moveAfter(RemInst);\n      NumHoisted++;\n    } else {\n      // The target does not have a single div/rem operation,\n      // and the rem is *not* in a already-expanded form.\n      // Decompose the remainder calculation as:\n      // X % Y --> X - ((X / Y) * Y).\n\n      assert(!RemOriginallyWasInExpandedForm &&\n             \"We should not be expanding if the rem was in expanded form to \"\n             \"begin with.\");\n\n      Value *X = E.getDividend();\n      Value *Y = E.getDivisor();\n      Instruction *Mul = BinaryOperator::CreateMul(DivInst, Y);\n      Instruction *Sub = BinaryOperator::CreateSub(X, Mul);\n\n      // If the remainder dominates, then hoist the division up to that block:\n      //\n      // bb1:\n      //   %rem = srem %x, %y\n      // bb2:\n      //   %div = sdiv %x, %y\n      // -->\n      // bb1:\n      //   %div = sdiv %x, %y\n      //   %mul = mul %div, %y\n      //   %rem = sub %x, %mul\n      //\n      // If the division dominates, it's already in the right place. The mul+sub\n      // will be in a different block because we don't assume that they are\n      // cheap to speculatively execute:\n      //\n      // bb1:\n      //   %div = sdiv %x, %y\n      // bb2:\n      //   %rem = srem %x, %y\n      // -->\n      // bb1:\n      //   %div = sdiv %x, %y\n      // bb2:\n      //   %mul = mul %div, %y\n      //   %rem = sub %x, %mul\n      //\n      // If the div and rem are in the same block, we do the same transform,\n      // but any code movement would be within the same block.\n\n      if (!DivDominates)\n        DivInst->moveBefore(RemInst);\n      Mul->insertAfter(RemInst);\n      Sub->insertAfter(Mul);\n\n      // Now kill the explicit remainder. We have replaced it with:\n      // (sub X, (mul (div X, Y), Y)\n      Sub->setName(RemInst->getName() + \".decomposed\");\n      Instruction *OrigRemInst = RemInst;\n      // Update AssertingVH<> with new instruction so it doesn't assert.\n      RemInst = Sub;\n      // And replace the original instruction with the new one.\n      OrigRemInst->replaceAllUsesWith(Sub);\n      OrigRemInst->eraseFromParent();\n      NumDecomposed++;\n    }\n    Changed = true;\n  }\n\n  return Changed;\n}\n",
        "start": 179,
        "end": 320,
        "buggy": "static bool optimizeDivRem(Function &F, const TargetTransformInfo &TTI,\n                           const DominatorTree &DT) {\n  bool Changed = false;\n\n  // Get the matching pairs of div-rem instructions. We want this extra\n  // indirection to avoid dealing with having to RAUW the keys of the maps.\n  DivRemWorklistTy Worklist = getWorklist(F);\n\n  // Process each entry in the worklist.\n  for (DivRemPairWorklistEntry &E : Worklist) {\n    if (!DebugCounter::shouldExecute(DRPCounter))\n      continue;\n\n    bool HasDivRemOp = TTI.hasDivRemOp(E.getType(), E.isSigned());\n\n    auto &DivInst = E.DivInst;\n    auto &RemInst = E.RemInst;\n\n    const bool RemOriginallyWasInExpandedForm = E.isRemExpanded();\n    (void)RemOriginallyWasInExpandedForm; // suppress unused variable warning\n\n    if (HasDivRemOp && E.isRemExpanded()) {\n      // The target supports div+rem but the rem is expanded.\n      // We should recompose it first.\n      Value *X = E.getDividend();\n      Value *Y = E.getDivisor();\n      Instruction *RealRem = E.isSigned() ? BinaryOperator::CreateSRem(X, Y)\n                                          : BinaryOperator::CreateURem(X, Y);\n      // Note that we place it right next to the original expanded instruction,\n      // and letting further handling to move it if needed.\n      RealRem->setName(RemInst->getName() + \".recomposed\");\n      RealRem->insertAfter(RemInst);\n      Instruction *OrigRemInst = RemInst;\n      // Update AssertingVH<> with new instruction so it doesn't assert.\n      RemInst = RealRem;\n      // And replace the original instruction with the new one.\n      OrigRemInst->replaceAllUsesWith(RealRem);\n      OrigRemInst->eraseFromParent();\n      NumRecomposed++;\n      // Note that we have left ((X / Y) * Y) around.\n      // If it had other uses we could rewrite it as X - X % Y\n    }\n\n    assert((!E.isRemExpanded() || !HasDivRemOp) &&\n           \"*If* the target supports div-rem, then by now the RemInst *is* \"\n           \"Instruction::[US]Rem.\");\n\n    // If the target supports div+rem and the instructions are in the same block\n    // already, there's nothing to do. The backend should handle this. If the\n    // target does not support div+rem, then we will decompose the rem.\n    if (HasDivRemOp && RemInst->getParent() == DivInst->getParent())\n      continue;\n\n    bool DivDominates = DT.dominates(DivInst, RemInst);\n    if (!DivDominates && !DT.dominates(RemInst, DivInst)) {\n      // We have matching div-rem pair, but they are in two different blocks,\n      // neither of which dominates one another.\n      assert(!RemOriginallyWasInExpandedForm &&\n             \"Won't happen for expanded-form rem.\");\n      // FIXME: We could hoist both ops to the common predecessor block?\n      continue;\n    }\n\n    // The target does not have a single div/rem operation,\n    // and the rem is already in expanded form. Nothing to do.\n    if (!HasDivRemOp && E.isRemExpanded())\n      continue;\n\n    if (HasDivRemOp) {\n      // The target has a single div/rem operation. Hoist the lower instruction\n      // to make the matched pair visible to the backend.\n      if (DivDominates)\n        RemInst->moveAfter(DivInst);\n      else\n        DivInst->moveAfter(RemInst);\n      NumHoisted++;\n    } else {\n      // The target does not have a single div/rem operation,\n      // and the rem is *not* in a already-expanded form.\n      // Decompose the remainder calculation as:\n      // X % Y --> X - ((X / Y) * Y).\n\n      assert(!RemOriginallyWasInExpandedForm &&\n             \"We should not be expanding if the rem was in expanded form to \"\n             \"begin with.\");\n\n      Value *X = E.getDividend();\n      Value *Y = E.getDivisor();\n      Instruction *Mul = BinaryOperator::CreateMul(DivInst, Y);\n      Instruction *Sub = BinaryOperator::CreateSub(X, Mul);\n\n      // If the remainder dominates, then hoist the division up to that block:\n      //\n      // bb1:\n      //   %rem = srem %x, %y\n      // bb2:\n      //   %div = sdiv %x, %y\n      // -->\n      // bb1:\n      //   %div = sdiv %x, %y\n      //   %mul = mul %div, %y\n      //   %rem = sub %x, %mul\n      //\n      // If the division dominates, it's already in the right place. The mul+sub\n      // will be in a different block because we don't assume that they are\n      // cheap to speculatively execute:\n      //\n      // bb1:\n      //   %div = sdiv %x, %y\n      // bb2:\n      //   %rem = srem %x, %y\n      // -->\n      // bb1:\n      //   %div = sdiv %x, %y\n      // bb2:\n      //   %mul = mul %div, %y\n      //   %rem = sub %x, %mul\n      //\n      // If the div and rem are in the same block, we do the same transform,\n      // but any code movement would be within the same block.\n\n      if (!DivDominates)\n        DivInst->moveBefore(RemInst);\n      Mul->insertAfter(RemInst);\n      Sub->insertAfter(Mul);\n\n      // Now kill the explicit remainder. We have replaced it with:\n      // (sub X, (mul (div X, Y), Y)\n      Sub->setName(RemInst->getName() + \".decomposed\");\n      Instruction *OrigRemInst = RemInst;\n      // Update AssertingVH<> with new instruction so it doesn't assert.\n      RemInst = Sub;\n      // And replace the original instruction with the new one.\n      OrigRemInst->replaceAllUsesWith(Sub);\n      OrigRemInst->eraseFromParent();\n      NumDecomposed++;\n    }\n    Changed = true;\n  }\n\n  return Changed;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      assert(!RemOriginallyWasInExpandedForm &&\n             \"Won't happen for expanded-form rem.\");\n      // FIXME: We could hoist both ops to the common predecessor block?\n",
        "src_path": "d30093bb8a3f12d35d176a85cf93e354a38ff116___DivRemPairs.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/d30093bb8a3f12d35d176a85cf93e354a38ff116",
        "commit_msg": "[DivRemPairs] Don't assert that we won't ever get expanded-form rem pairs in different BB's (PR43500)\n\nIf we happen to have the same div in two basic blocks,\nand in one of those we also happen to have the rem part,\nwe'd match the div-rem pair, but the wrong ones.\nSo let's drop overly-ambiguous assert.\n\nFixes https://bugs.llvm.org/show_bug.cgi?id=43500\n\nllvm-svn: 373167",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/DivRemPairs/X86/div-expanded-rem-pair.ll",
                "patch": "@@ -168,3 +168,39 @@ end:\n   %ret = phi i128 [ %rem, %if ], [ 3, %entry ]\n   ret i128 %ret\n }\n+\n+; Even in expanded form, we can end up with div and rem in different basic\n+; blocks neither of which dominates each another.\n+define i32 @can_have_divrem_in_mutually_nondominating_bbs(i1 %cmp, i32 %a, i32 %b) {\n+; CHECK-LABEL: @can_have_divrem_in_mutually_nondominating_bbs(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    br i1 [[CMP:%.*]], label [[IF_THEN:%.*]], label [[IF_ELSE:%.*]]\n+; CHECK:       if.then:\n+; CHECK-NEXT:    [[T0:%.*]] = udiv i32 [[A:%.*]], [[B:%.*]]\n+; CHECK-NEXT:    [[T1:%.*]] = mul nuw i32 [[T0]], [[B]]\n+; CHECK-NEXT:    [[T2_RECOMPOSED:%.*]] = urem i32 [[A]], [[B]]\n+; CHECK-NEXT:    br label [[END:%.*]]\n+; CHECK:       if.else:\n+; CHECK-NEXT:    [[T3:%.*]] = udiv i32 [[A]], [[B]]\n+; CHECK-NEXT:    br label [[END]]\n+; CHECK:       end:\n+; CHECK-NEXT:    [[RET:%.*]] = phi i32 [ [[T2_RECOMPOSED]], [[IF_THEN]] ], [ [[T3]], [[IF_ELSE]] ]\n+; CHECK-NEXT:    ret i32 [[RET]]\n+;\n+entry:\n+  br i1 %cmp, label %if.then, label %if.else\n+\n+if.then:\n+  %t0 = udiv i32 %a, %b\n+  %t1 = mul nuw i32 %t0, %b\n+  %t2 = sub i32 %a, %t1\n+  br label %end\n+\n+if.else:\n+  %t3 = udiv i32 %a, %b\n+  br label %end\n+\n+end:\n+  %ret = phi i32 [ %t2, %if.then ], [ %t3, %if.else ]\n+  ret i32 %ret\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/DivRemPairs/X86/div-expanded-rem-pair.ll (1 of 1)\nTesting Time: 1.43s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/DivRemPairs/X86/div-expanded-rem-pair.ll\n\n  Unexpected Failures: 1\n"
    },
    "fde8eb00e1466cecd0fc6697f8c2ab837c5b7cf3___InstCombineAndOrXor.cpp": {
        "prefix": "static Instruction *visitMaskedMerge(BinaryOperator &I,\n                                     InstCombiner::BuilderTy &Builder) {\n  Value *B, *X, *D;\n  Value *M;\n  if (!match(&I, m_c_Xor(m_Value(B),\n                         m_OneUse(m_c_And(\n                             m_CombineAnd(m_c_Xor(m_Deferred(B), m_Value(X)),\n                                          m_Value(D)),\n                             m_Value(M))))))\n    return nullptr;\n\n  Value *NotM;\n  if (match(M, m_Not(m_Value(NotM)))) {\n    // De-invert the mask and swap the value in B part.\n    Value *NewA = Builder.CreateAnd(D, NotM);\n    return BinaryOperator::CreateXor(NewA, X);\n  }\n\n  Constant *C;\n  if (D->hasOneUse() && match(M, m_Constant(C))) {\n",
        "suffix": "    Value *LHS = Builder.CreateAnd(X, C);\n    Value *NotC = Builder.CreateNot(C);\n    Value *RHS = Builder.CreateAnd(B, NotC);\n    return BinaryOperator::CreateOr(LHS, RHS);\n  }\n\n  return nullptr;\n}\n",
        "start": 3032,
        "end": 3060,
        "buggy": "static Instruction *visitMaskedMerge(BinaryOperator &I,\n                                     InstCombiner::BuilderTy &Builder) {\n  Value *B, *X, *D;\n  Value *M;\n  if (!match(&I, m_c_Xor(m_Value(B),\n                         m_OneUse(m_c_And(\n                             m_CombineAnd(m_c_Xor(m_Deferred(B), m_Value(X)),\n                                          m_Value(D)),\n                             m_Value(M))))))\n    return nullptr;\n\n  Value *NotM;\n  if (match(M, m_Not(m_Value(NotM)))) {\n    // De-invert the mask and swap the value in B part.\n    Value *NewA = Builder.CreateAnd(D, NotM);\n    return BinaryOperator::CreateXor(NewA, X);\n  }\n\n  Constant *C;\n  if (D->hasOneUse() && match(M, m_Constant(C))) {\n    // Unfold.\n    Value *LHS = Builder.CreateAnd(X, C);\n    Value *NotC = Builder.CreateNot(C);\n    Value *RHS = Builder.CreateAnd(B, NotC);\n    return BinaryOperator::CreateOr(LHS, RHS);\n  }\n\n  return nullptr;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    // Unfold.\n",
        "src_path": "fde8eb00e1466cecd0fc6697f8c2ab837c5b7cf3___InstCombineAndOrXor.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/fde8eb00e1466cecd0fc6697f8c2ab837c5b7cf3",
        "commit_msg": "[InstCombine] visitMaskedMerge(): when unfolding, sanitize undef constants (PR45955)\n\nWe can't leave undef vector element constants as-is,\nit is a miscompile, so we need to sanitize them.\n\nWe have two vectors (C and ~C):\n* We can't replace undef with 0 in both of them\n* We can't replace undef with 0 in only one of them\n* We could replace undef with -1 in both of them\n* We could replace undef with -1 in only one(!) of them\n* We could replace undef with -1 in one and 0 in another one of them.\n\nTherefore, it seems best to go with the last option, since otherwise\nwe'd loose knowledge that C and ~C have no common bits set,\nwhich seems more important than preserving partial undef knowledge.\n\nFixes https://bugs.llvm.org/show_bug.cgi?id=45955",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/unfold-masked-merge-with-const-mask-vector.ll",
                "patch": "@@ -21,8 +21,8 @@ define <2 x i4> @splat (<2 x i4> %x, <2 x i4> %y) {\n \n define <3 x i4> @splat_undef (<3 x i4> %x, <3 x i4> %y) {\n ; CHECK-LABEL: @splat_undef(\n-; CHECK-NEXT:    [[TMP1:%.*]] = and <3 x i4> [[X:%.*]], <i4 -2, i4 undef, i4 -2>\n-; CHECK-NEXT:    [[TMP2:%.*]] = and <3 x i4> [[Y:%.*]], <i4 1, i4 undef, i4 1>\n+; CHECK-NEXT:    [[TMP1:%.*]] = and <3 x i4> [[X:%.*]], <i4 -2, i4 -1, i4 -2>\n+; CHECK-NEXT:    [[TMP2:%.*]] = and <3 x i4> [[Y:%.*]], <i4 1, i4 0, i4 1>\n ; CHECK-NEXT:    [[R:%.*]] = or <3 x i4> [[TMP1]], [[TMP2]]\n ; CHECK-NEXT:    ret <3 x i4> [[R]]\n ;\n@@ -85,8 +85,8 @@ define <2 x i4> @in_constant_varx_14_nonsplat(<2 x i4> %x, <2 x i4> %mask) {\n \n define <3 x i4> @in_constant_varx_14_undef(<3 x i4> %x, <3 x i4> %mask) {\n ; CHECK-LABEL: @in_constant_varx_14_undef(\n-; CHECK-NEXT:    [[TMP1:%.*]] = and <3 x i4> [[X:%.*]], <i4 1, i4 undef, i4 1>\n-; CHECK-NEXT:    [[R:%.*]] = or <3 x i4> [[TMP1]], <i4 -2, i4 undef, i4 6>\n+; CHECK-NEXT:    [[TMP1:%.*]] = and <3 x i4> [[X:%.*]], <i4 1, i4 -1, i4 1>\n+; CHECK-NEXT:    [[R:%.*]] = or <3 x i4> [[TMP1]], <i4 -2, i4 0, i4 6>\n ; CHECK-NEXT:    ret <3 x i4> [[R]]\n ;\n   %n0 = xor <3 x i4> %x, <i4 14, i4 undef, i4 7> ; %x\n@@ -133,7 +133,7 @@ define <2 x i4> @in_constant_14_vary_nonsplat(<2 x i4> %y, <2 x i4> %mask) {\n \n define <3 x i4> @in_constant_14_vary_undef(<3 x i4> %y, <3 x i4> %mask) {\n ; CHECK-LABEL: @in_constant_14_vary_undef(\n-; CHECK-NEXT:    [[TMP1:%.*]] = and <3 x i4> [[Y:%.*]], <i4 -2, i4 undef, i4 -2>\n+; CHECK-NEXT:    [[TMP1:%.*]] = and <3 x i4> [[Y:%.*]], <i4 -2, i4 0, i4 -2>\n ; CHECK-NEXT:    [[R:%.*]] = or <3 x i4> [[TMP1]], <i4 0, i4 undef, i4 1>\n ; CHECK-NEXT:    ret <3 x i4> [[R]]\n ;"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/unfold-masked-merge-with-const-mask-vector.ll (1 of 1)\n********************\nFailing Tests (1):\n  LLVM :: Transforms/InstCombine/unfold-masked-merge-with-const-mask-vector.ll\n\n\nTesting Time: 0.41s\n  Unexpected Failures: 1\n"
    },
    "4c735439fd9a0cfea9ae366df8b36281436d4708___SelectionDAGBuilder.cpp": {
        "prefix": "void SelectionDAGBuilder::visitInvoke(const InvokeInst &I) {\n  MachineBasicBlock *InvokeMBB = FuncInfo.MBB;\n\n  // Retrieve successors. Look through artificial IR level blocks like\n  // catchswitch for successors.\n  MachineBasicBlock *Return = FuncInfo.MBBMap[I.getSuccessor(0)];\n  const BasicBlock *EHPadBB = I.getSuccessor(1);\n\n  // Deopt bundles are lowered in LowerCallSiteWithDeoptBundle, and we don't\n  // have to do anything here to lower funclet bundles.\n  assert(!I.hasOperandBundlesOtherThan({LLVMContext::OB_deopt,\n                                        LLVMContext::OB_gc_transition,\n",
        "suffix": "                                        LLVMContext::OB_cfguardtarget}) &&\n         \"Cannot lower invokes with arbitrary operand bundles yet!\");\n\n  const Value *Callee(I.getCalledOperand());\n  const Function *Fn = dyn_cast<Function>(Callee);\n  if (isa<InlineAsm>(Callee))\n    visitInlineAsm(I);\n  else if (Fn && Fn->isIntrinsic()) {\n    switch (Fn->getIntrinsicID()) {\n    default:\n      llvm_unreachable(\"Cannot invoke this intrinsic\");\n    case Intrinsic::donothing:\n      // Ignore invokes to @llvm.donothing: jump directly to the next BB.\n      break;\n    case Intrinsic::experimental_patchpoint_void:\n    case Intrinsic::experimental_patchpoint_i64:\n      visitPatchpoint(I, EHPadBB);\n      break;\n    case Intrinsic::experimental_gc_statepoint:\n      LowerStatepoint(cast<GCStatepointInst>(I), EHPadBB);\n      break;\n    case Intrinsic::wasm_rethrow_in_catch: {\n      // This is usually done in visitTargetIntrinsic, but this intrinsic is\n      // special because it can be invoked, so we manually lower it to a DAG\n      // node here.\n      SmallVector<SDValue, 8> Ops;\n      Ops.push_back(getRoot()); // inchain\n      const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n      Ops.push_back(\n          DAG.getTargetConstant(Intrinsic::wasm_rethrow_in_catch, getCurSDLoc(),\n                                TLI.getPointerTy(DAG.getDataLayout())));\n      SDVTList VTs = DAG.getVTList(ArrayRef<EVT>({MVT::Other})); // outchain\n      DAG.setRoot(DAG.getNode(ISD::INTRINSIC_VOID, getCurSDLoc(), VTs, Ops));\n      break;\n    }\n    }\n  } else if (I.countOperandBundlesOfType(LLVMContext::OB_deopt)) {\n    // Currently we do not lower any intrinsic calls with deopt operand bundles.\n    // Eventually we will support lowering the @llvm.experimental.deoptimize\n    // intrinsic, and right now there are no plans to support other intrinsics\n    // with deopt state.\n    LowerCallSiteWithDeoptBundle(&I, getValue(Callee), EHPadBB);\n  } else {\n    LowerCallTo(I, getValue(Callee), false, EHPadBB);\n  }\n\n  // If the value of the invoke is used outside of its defining block, make it\n  // available as a virtual register.\n  // We already took care of the exported value for the statepoint instruction\n  // during call to the LowerStatepoint.\n  if (!isa<GCStatepointInst>(I)) {\n    CopyToExportRegsIfNeeded(&I);\n  }\n\n  SmallVector<std::pair<MachineBasicBlock *, BranchProbability>, 1> UnwindDests;\n  BranchProbabilityInfo *BPI = FuncInfo.BPI;\n  BranchProbability EHPadBBProb =\n      BPI ? BPI->getEdgeProbability(InvokeMBB->getBasicBlock(), EHPadBB)\n          : BranchProbability::getZero();\n  findUnwindDestinations(FuncInfo, EHPadBB, EHPadBBProb, UnwindDests);\n\n  // Update successor info.\n  addSuccessorWithProb(InvokeMBB, Return);\n  for (auto &UnwindDest : UnwindDests) {\n    UnwindDest.first->setIsEHPad();\n    addSuccessorWithProb(InvokeMBB, UnwindDest.first, UnwindDest.second);\n  }\n  InvokeMBB->normalizeSuccProbs();\n\n  // Drop into normal successor.\n  DAG.setRoot(DAG.getNode(ISD::BR, getCurSDLoc(), MVT::Other, getControlRoot(),\n                          DAG.getBasicBlock(Return)));\n}\n",
        "start": 2770,
        "end": 2855,
        "buggy": "void SelectionDAGBuilder::visitInvoke(const InvokeInst &I) {\n  MachineBasicBlock *InvokeMBB = FuncInfo.MBB;\n\n  // Retrieve successors. Look through artificial IR level blocks like\n  // catchswitch for successors.\n  MachineBasicBlock *Return = FuncInfo.MBBMap[I.getSuccessor(0)];\n  const BasicBlock *EHPadBB = I.getSuccessor(1);\n\n  // Deopt bundles are lowered in LowerCallSiteWithDeoptBundle, and we don't\n  // have to do anything here to lower funclet bundles.\n  assert(!I.hasOperandBundlesOtherThan({LLVMContext::OB_deopt,\n                                        LLVMContext::OB_gc_transition,\n                                        LLVMContext::OB_funclet,\n                                        LLVMContext::OB_cfguardtarget}) &&\n         \"Cannot lower invokes with arbitrary operand bundles yet!\");\n\n  const Value *Callee(I.getCalledOperand());\n  const Function *Fn = dyn_cast<Function>(Callee);\n  if (isa<InlineAsm>(Callee))\n    visitInlineAsm(I);\n  else if (Fn && Fn->isIntrinsic()) {\n    switch (Fn->getIntrinsicID()) {\n    default:\n      llvm_unreachable(\"Cannot invoke this intrinsic\");\n    case Intrinsic::donothing:\n      // Ignore invokes to @llvm.donothing: jump directly to the next BB.\n      break;\n    case Intrinsic::experimental_patchpoint_void:\n    case Intrinsic::experimental_patchpoint_i64:\n      visitPatchpoint(I, EHPadBB);\n      break;\n    case Intrinsic::experimental_gc_statepoint:\n      LowerStatepoint(cast<GCStatepointInst>(I), EHPadBB);\n      break;\n    case Intrinsic::wasm_rethrow_in_catch: {\n      // This is usually done in visitTargetIntrinsic, but this intrinsic is\n      // special because it can be invoked, so we manually lower it to a DAG\n      // node here.\n      SmallVector<SDValue, 8> Ops;\n      Ops.push_back(getRoot()); // inchain\n      const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n      Ops.push_back(\n          DAG.getTargetConstant(Intrinsic::wasm_rethrow_in_catch, getCurSDLoc(),\n                                TLI.getPointerTy(DAG.getDataLayout())));\n      SDVTList VTs = DAG.getVTList(ArrayRef<EVT>({MVT::Other})); // outchain\n      DAG.setRoot(DAG.getNode(ISD::INTRINSIC_VOID, getCurSDLoc(), VTs, Ops));\n      break;\n    }\n    }\n  } else if (I.countOperandBundlesOfType(LLVMContext::OB_deopt)) {\n    // Currently we do not lower any intrinsic calls with deopt operand bundles.\n    // Eventually we will support lowering the @llvm.experimental.deoptimize\n    // intrinsic, and right now there are no plans to support other intrinsics\n    // with deopt state.\n    LowerCallSiteWithDeoptBundle(&I, getValue(Callee), EHPadBB);\n  } else {\n    LowerCallTo(I, getValue(Callee), false, EHPadBB);\n  }\n\n  // If the value of the invoke is used outside of its defining block, make it\n  // available as a virtual register.\n  // We already took care of the exported value for the statepoint instruction\n  // during call to the LowerStatepoint.\n  if (!isa<GCStatepointInst>(I)) {\n    CopyToExportRegsIfNeeded(&I);\n  }\n\n  SmallVector<std::pair<MachineBasicBlock *, BranchProbability>, 1> UnwindDests;\n  BranchProbabilityInfo *BPI = FuncInfo.BPI;\n  BranchProbability EHPadBBProb =\n      BPI ? BPI->getEdgeProbability(InvokeMBB->getBasicBlock(), EHPadBB)\n          : BranchProbability::getZero();\n  findUnwindDestinations(FuncInfo, EHPadBB, EHPadBBProb, UnwindDests);\n\n  // Update successor info.\n  addSuccessorWithProb(InvokeMBB, Return);\n  for (auto &UnwindDest : UnwindDests) {\n    UnwindDest.first->setIsEHPad();\n    addSuccessorWithProb(InvokeMBB, UnwindDest.first, UnwindDest.second);\n  }\n  InvokeMBB->normalizeSuccProbs();\n\n  // Drop into normal successor.\n  DAG.setRoot(DAG.getNode(ISD::BR, getCurSDLoc(), MVT::Other, getControlRoot(),\n                          DAG.getBasicBlock(Return)));\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                                        LLVMContext::OB_funclet,\n",
        "src_path": "4c735439fd9a0cfea9ae366df8b36281436d4708___SelectionDAGBuilder.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/4c735439fd9a0cfea9ae366df8b36281436d4708",
        "commit_msg": "[Statepoint] Migrate a few tests to gc-live bundle format and fix assert\n\nThe assert was missed in 0e7c7705, migrating the test revealed the problem.",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/statepoint-allocas.ll",
                "patch": "@@ -26,7 +26,7 @@ define i32 addrspace(1)* @test(i32 addrspace(1)* %ptr) gc \"statepoint-example\" {\n entry:\n   %alloca = alloca i32 addrspace(1)*, align 8\n   store i32 addrspace(1)* %ptr, i32 addrspace(1)** %alloca\n-  call token (i64, i32, i1 ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_i1f(i64 0, i32 0, i1 ()* @return_i1, i32 0, i32 0, i32 0, i32 0, i32 addrspace(1)** %alloca)\n+  call token (i64, i32, i1 ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_i1f(i64 0, i32 0, i1 ()* @return_i1, i32 0, i32 0, i32 0, i32 0) [\"gc-live\" (i32 addrspace(1)** %alloca)]\n   %rel = load i32 addrspace(1)*, i32 addrspace(1)** %alloca\n   ret i32 addrspace(1)* %rel\n }"
            },
            {
                "fn": "llvm/test/CodeGen/X86/statepoint-call-lowering.ll",
                "patch": "@@ -110,8 +110,8 @@ define i1 @test_relocate(i32 addrspace(1)* %a) gc \"statepoint-example\" {\n ; CHECK-NEXT:    retq\n ; Check that an ununsed relocate has no code-generation impact\n entry:\n-  %safepoint_token = tail call token (i64, i32, i1 ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_i1f(i64 0, i32 0, i1 ()* @return_i1, i32 0, i32 0, i32 0, i32 0, i32 addrspace(1)* %a)\n-  %call1 = call i32 addrspace(1)* @llvm.experimental.gc.relocate.p1i32(token %safepoint_token,  i32 7, i32 7)\n+  %safepoint_token = tail call token (i64, i32, i1 ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_i1f(i64 0, i32 0, i1 ()* @return_i1, i32 0, i32 0, i32 0, i32 0) [\"gc-live\" (i32 addrspace(1)* %a)]\n+  %call1 = call i32 addrspace(1)* @llvm.experimental.gc.relocate.p1i32(token %safepoint_token,  i32 0, i32 0)\n   %call2 = call zeroext i1 @llvm.experimental.gc.result.i1(token %safepoint_token)\n   ret i1 %call2\n }\n@@ -189,11 +189,11 @@ define i1 @test_cross_bb(i32 addrspace(1)* %a, i1 %external_cond) gc \"statepoint\n ; CHECK-NEXT:    .cfi_def_cfa_offset 8\n ; CHECK-NEXT:    retq\n entry:\n-  %safepoint_token = tail call token (i64, i32, i1 ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_i1f(i64 0, i32 0, i1 ()* @return_i1, i32 0, i32 0, i32 0, i32 0, i32 addrspace(1)* %a)\n+  %safepoint_token = tail call token (i64, i32, i1 ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_i1f(i64 0, i32 0, i1 ()* @return_i1, i32 0, i32 0, i32 0, i32 0) [\"gc-live\" (i32 addrspace(1)* %a)]\n   br i1 %external_cond, label %left, label %right\n \n left:\n-  %call1 = call i32 addrspace(1)* @llvm.experimental.gc.relocate.p1i32(token %safepoint_token,  i32 7, i32 7)\n+  %call1 = call i32 addrspace(1)* @llvm.experimental.gc.relocate.p1i32(token %safepoint_token,  i32 0, i32 0)\n   %call2 = call zeroext i1 @llvm.experimental.gc.result.i1(token %safepoint_token)\n   call void @consume(i32 addrspace(1)* %call1)\n   ret i1 %call2"
            },
            {
                "fn": "llvm/test/CodeGen/X86/statepoint-invoke.ll",
                "patch": "@@ -34,12 +34,12 @@ define i64 addrspace(1)* @test_basic(i64 addrspace(1)* %obj,\n                                      i64 addrspace(1)* %obj1)\n gc \"statepoint-example\" personality i32 ()* @\"personality_function\" {\n entry:\n-  %0 = invoke token (i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64 0, i32 0, void (i64 addrspace(1)*)* @some_call, i32 1, i32 0, i64 addrspace(1)* %obj, i32 0, i32 0, i64 addrspace(1)* %obj, i64 addrspace(1)* %obj1) [\"deopt\" (i32 0, i32 -1, i32 0, i32 0, i32 0)]\n+  %0 = invoke token (i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64 0, i32 0, void (i64 addrspace(1)*)* @some_call, i32 1, i32 0, i64 addrspace(1)* %obj, i32 0, i32 0) [\"gc-live\" (i64 addrspace(1)* %obj, i64 addrspace(1)* %obj1), \"deopt\" (i32 0, i32 -1, i32 0, i32 0, i32 0)]\n           to label %invoke_safepoint_normal_dest unwind label %exceptional_return\n \n invoke_safepoint_normal_dest:\n-  %obj.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %0, i32 8, i32 8)\n-  %obj1.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %0, i32 9, i32 9)\n+  %obj.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %0, i32 0, i32 0)\n+  %obj1.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %0, i32 1, i32 1)\n   br label %normal_return\n \n normal_return:\n@@ -48,8 +48,8 @@ normal_return:\n exceptional_return:\n   %landing_pad = landingpad token\n           cleanup\n-  %obj.relocated1 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 8, i32 8)\n-  %obj1.relocated1 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 9, i32 9)\n+  %obj.relocated1 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 0, i32 0)\n+  %obj1.relocated1 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 1, i32 1)\n   ret i64 addrspace(1)* %obj1.relocated1\n }\n ; CHECK-LABEL: GCC_except_table{{[0-9]+}}:\n@@ -82,7 +82,7 @@ define i64 addrspace(1)* @test_result(i64 addrspace(1)* %obj,\n                                       i64 addrspace(1)* %obj1)\n   gc \"statepoint-example\" personality i32 ()* @personality_function {\n entry:\n-  %0 = invoke token (i64, i32, i64 addrspace(1)* (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_p1i64p1i64f(i64 0, i32 0, i64 addrspace(1)* (i64 addrspace(1)*)* @some_other_call, i32 1, i32 0, i64 addrspace(1)* %obj, i32 0, i32 0, i64 addrspace(1)* %obj, i64 addrspace(1)* %obj1)\n+  %0 = invoke token (i64, i32, i64 addrspace(1)* (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_p1i64p1i64f(i64 0, i32 0, i64 addrspace(1)* (i64 addrspace(1)*)* @some_other_call, i32 1, i32 0, i64 addrspace(1)* %obj, i32 0, i32 0) [\"gc-live\"(i64 addrspace(1)* %obj, i64 addrspace(1)* %obj1)]\n           to label %normal_return unwind label %exceptional_return\n \n normal_return:\n@@ -92,7 +92,7 @@ normal_return:\n exceptional_return:\n   %landing_pad = landingpad token\n           cleanup\n-  %obj.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 8, i32 8)\n+  %obj.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 0, i32 0)\n   ret i64 addrspace(1)* %obj.relocated\n }\n ; CHECK-LABEL: GCC_except_table{{[0-9]+}}:\n@@ -158,21 +158,21 @@ entry:\n   br i1 %cond, label %left, label %right\n \n left:\n-  %sp1 = invoke token (i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64 0, i32 0, void (i64 addrspace(1)*)* @some_call, i32 1, i32 0, i64 addrspace(1)* %val1, i32 0, i32 0, i64 addrspace(1)* %val1, i64 addrspace(1)* %val2)\n+  %sp1 = invoke token (i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64 0, i32 0, void (i64 addrspace(1)*)* @some_call, i32 1, i32 0, i64 addrspace(1)* %val1, i32 0, i32 0) [\"gc-live\"(i64 addrspace(1)* %val1, i64 addrspace(1)* %val2)]\n            to label %left.relocs unwind label %exceptional_return.left\n \n left.relocs:\n-  %val1.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp1, i32 8, i32 8)\n-  %val2.relocated_left = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp1, i32 9, i32 9)\n+  %val1.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp1, i32 0, i32 0)\n+  %val2.relocated_left = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp1, i32 1, i32 1)\n   br label %normal_return\n \n right:\n-  %sp2 = invoke token (i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64 0, i32 0, void (i64 addrspace(1)*)* @some_call, i32 1, i32 0, i64 addrspace(1)* %val1, i32 0, i32 0, i64 addrspace(1)* %val2, i64 addrspace(1)* %val3)\n+  %sp2 = invoke token (i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64 0, i32 0, void (i64 addrspace(1)*)* @some_call, i32 1, i32 0, i64 addrspace(1)* %val1, i32 0, i32 0) [\"gc-live\"(i64 addrspace(1)* %val2, i64 addrspace(1)* %val3)]\n            to label %right.relocs unwind label %exceptional_return.right\n \n right.relocs:\n-  %val2.relocated_right = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp2, i32 8, i32 8)\n-  %val3.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp2, i32 9, i32 9)\n+  %val2.relocated_right = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp2, i32 0, i32 0)\n+  %val3.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp2, i32 1, i32 1)\n   br label %normal_return\n \n normal_return:\n@@ -184,13 +184,13 @@ normal_return:\n exceptional_return.left:\n   %landing_pad = landingpad token\n           cleanup\n-  %val.relocated2 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 8, i32 8)\n+  %val.relocated2 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 0, i32 0)\n   ret i64 addrspace(1)* %val.relocated2\n \n exceptional_return.right:\n   %landing_pad1 = landingpad token\n           cleanup\n-  %val.relocated3 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad1, i32 8, i32 8)\n+  %val.relocated3 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad1, i32 0, i32 0)\n   ret i64 addrspace(1)* %val.relocated3\n }\n \n@@ -214,19 +214,19 @@ define i64 addrspace(1)* @test_null_undef(i64 addrspace(1)* %val1)\n ; CHECK-NEXT:    jmp .LBB3_1\n        gc \"statepoint-example\" personality i32 ()* @\"personality_function\" {\n entry:\n-  %sp1 = invoke token (i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64 0, i32 0, void (i64 addrspace(1)*)* @some_call, i32 1, i32 0, i64 addrspace(1)* %val1, i32 0, i32 0, i64 addrspace(1)* null, i64 addrspace(1)* undef)\n+  %sp1 = invoke token (i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64 0, i32 0, void (i64 addrspace(1)*)* @some_call, i32 1, i32 0, i64 addrspace(1)* %val1, i32 0, i32 0) [\"gc-live\"(i64 addrspace(1)* null, i64 addrspace(1)* undef)]\n            to label %normal_return unwind label %exceptional_return\n \n normal_return:\n-  %null.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp1, i32 8, i32 8)\n-  %undef.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp1, i32 9, i32 9)\n+  %null.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp1, i32 0, i32 0)\n+  %undef.relocated = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %sp1, i32 1, i32 1)\n   ret i64 addrspace(1)* %null.relocated\n \n exceptional_return:\n   %landing_pad = landingpad token\n           cleanup\n-  %null.relocated2 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 8, i32 8)\n-  %undef.relocated2 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 9, i32 9)\n+  %null.relocated2 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 0, i32 0)\n+  %undef.relocated2 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 1, i32 1)\n   ret i64 addrspace(1)* %null.relocated2\n }\n \n@@ -256,18 +256,18 @@ entry:\n   %a = alloca i32\n   %aa = addrspacecast i32* %a to i32 addrspace(1)*\n   %c = inttoptr i64 15 to i64 addrspace(1)*\n-  %sp = invoke token (i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64 0, i32 0, void (i64 addrspace(1)*)* @some_call, i32 1, i32 0, i64 addrspace(1)* %val1, i32 0, i32 0, i32 addrspace(1)* %aa, i64 addrspace(1)* %c)\n+  %sp = invoke token (i64, i32, void (i64 addrspace(1)*)*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidp1i64f(i64 0, i32 0, void (i64 addrspace(1)*)* @some_call, i32 1, i32 0, i64 addrspace(1)* %val1, i32 0, i32 0) [\"gc-live\"(i32 addrspace(1)* %aa, i64 addrspace(1)* %c)]\n            to label %normal_return unwind label %exceptional_return\n \n normal_return:\n-  %aa.rel = call coldcc i32 addrspace(1)* @llvm.experimental.gc.relocate.p1i32(token %sp, i32 8, i32 8)\n+  %aa.rel = call coldcc i32 addrspace(1)* @llvm.experimental.gc.relocate.p1i32(token %sp, i32 0, i32 0)\n   %aa.converted = bitcast i32 addrspace(1)* %aa.rel to i64 addrspace(1)*\n   ret i64 addrspace(1)* %aa.converted\n \n exceptional_return:\n   %landing_pad = landingpad token\n           cleanup\n-  %aa.rel2 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 9, i32 9)\n+  %aa.rel2 = call coldcc i64 addrspace(1)* @llvm.experimental.gc.relocate.p1i64(token %landing_pad, i32 1, i32 1)\n   ret i64 addrspace(1)* %aa.rel2\n }\n "
            },
            {
                "fn": "llvm/test/CodeGen/X86/statepoint-live-in.ll",
                "patch": "@@ -99,8 +99,8 @@ define  i32 addrspace(1)* @test5(i32 %a, i32 addrspace(1)* %p) gc \"statepoint-ex\n ; CHECK-NEXT:    popq %rcx\n ; CHECK-NEXT:    retq\n entry:\n-  %token = call token (i64, i32, void ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @bar, i32 0, i32 2, i32 0, i32 0, i32 addrspace(1)* %p, i32 addrspace(1)* %p) [\"deopt\"(i32 %a)]\n-  %p2 = call i32 addrspace(1)* @llvm.experimental.gc.relocate.p1i32(token %token,  i32 8, i32 8)\n+  %token = call token (i64, i32, void ()*, i32, i32, ...) @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 2882400000, i32 0, void ()* @bar, i32 0, i32 2, i32 0, i32 0) [\"gc-live\"(i32 addrspace(1)* %p), \"deopt\"(i32 %a)]\n+  %p2 = call i32 addrspace(1)* @llvm.experimental.gc.relocate.p1i32(token %token,  i32 0, i32 0)\n   ret i32 addrspace(1)* %p2\n }\n "
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/statepoint-invoke.ll (1 of 1)\n********************\nFailing Tests (1):\n  LLVM :: CodeGen/X86/statepoint-invoke.ll\n\n\nTesting Time: 2.91s\n  Unexpected Failures: 1\n"
    },
    "ac375c2fe316dae6eb770b38f90d6b67fadd22ec___BitcodeReader.cpp": {
        "prefix": "Error BitcodeReader::materializeMetadata() {\n  for (uint64_t BitPos : DeferredMetadataInfo) {\n    // Move the bit stream to the saved position.\n    if (Error JumpFailed = Stream.JumpToBit(BitPos))\n      return JumpFailed;\n    if (Error Err = MDLoader->parseModuleMetadata())\n      return Err;\n  }\n\n  // Upgrade \"Linker Options\" module flag to \"llvm.linker.options\" module-level\n",
        "suffix": "\n  DeferredMetadataInfo.clear();\n  return Error::success();\n}\n",
        "start": 2962,
        "end": 2982,
        "buggy": "Error BitcodeReader::materializeMetadata() {\n  for (uint64_t BitPos : DeferredMetadataInfo) {\n    // Move the bit stream to the saved position.\n    if (Error JumpFailed = Stream.JumpToBit(BitPos))\n      return JumpFailed;\n    if (Error Err = MDLoader->parseModuleMetadata())\n      return Err;\n  }\n\n  // Upgrade \"Linker Options\" module flag to \"llvm.linker.options\" module-level\n  // metadata.\n  if (Metadata *Val = TheModule->getModuleFlag(\"Linker Options\")) {\n    NamedMDNode *LinkerOpts =\n        TheModule->getOrInsertNamedMetadata(\"llvm.linker.options\");\n    for (const MDOperand &MDOptions : cast<MDNode>(Val)->operands())\n      LinkerOpts->addOperand(cast<MDNode>(MDOptions));\n  }\n\n  DeferredMetadataInfo.clear();\n  return Error::success();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  // metadata.\n  if (Metadata *Val = TheModule->getModuleFlag(\"Linker Options\")) {\n    NamedMDNode *LinkerOpts =\n        TheModule->getOrInsertNamedMetadata(\"llvm.linker.options\");\n    for (const MDOperand &MDOptions : cast<MDNode>(Val)->operands())\n      LinkerOpts->addOperand(cast<MDNode>(MDOptions));\n  }\n",
        "src_path": "ac375c2fe316dae6eb770b38f90d6b67fadd22ec___BitcodeReader.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/ac375c2fe316dae6eb770b38f90d6b67fadd22ec",
        "commit_msg": "[Bitcode] Avoid duplicating linker option when upgrading\n\nSummary:\nThe upgrading path from old ModuleFlag based linker options to the new\nNamedMetadata based linker option in in materializeMetadata() which gets\ncalled once for the module and once for every GV. The linker options are\ngetting dup'ed every time and it can create massive amount of the linker\noptions in the object file that gets created from old bitcode. Fix the\nproblem by checking if the new option exists or not before upgrade\nagain.\n\nrdar://64543389\n\nReviewers: pcc, t.p.northover, dexonsmith, arphaman\n\nReviewed By: arphaman\n\nSubscribers: hiraditya, jkorous, ributzka, llvm-commits\n\nTags: #llvm\n\nDifferential Revision: https://reviews.llvm.org/D83688",
        "test_func_diff": [
            {
                "fn": "llvm/test/Bitcode/upgrade-linker-options-2.ll",
                "patch": "@@ -0,0 +1,12 @@\n+;; Test upgrade linker option doesn't create duplicated linker options.\n+;; Inputs is generated from IR and checked in as bitcode as it will get rejected by verifier.\n+;; define void @test() {\n+;;   ret void\n+;; }\n+;; !llvm.module.flags = !{!0}\n+;; !0 = !{i32 6, !\"Linker Options\", !1}\n+;; !1 = !{!2}\n+;; !2 = !{!\"-framework\", !\"Foundation\"}\n+\n+; RUN: llvm-dis %S/Inputs/linker-options.bc -o - | FileCheck %s\n+; CHECK: !llvm.linker.options = !{!2}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Bitcode/upgrade-linker-options-2.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Bitcode/upgrade-linker-options-2.ll\n\n\nTesting Time: 0.11s\n  Failed: 1\n"
    },
    "ee1c12708a4519361729205168dedb2b61bc2638___ScalarEvolution.cpp": {
        "prefix": "ScalarEvolution::ExitLimit\nScalarEvolution::howManyGreaterThans(const SCEV *LHS, const SCEV *RHS,\n                                     const Loop *L, bool IsSigned,\n                                     bool ControlsExit, bool AllowPredicates) {\n  SmallPtrSet<const SCEVPredicate *, 4> Predicates;\n  // We handle only IV > Invariant\n  if (!isLoopInvariant(RHS, L))\n    return getCouldNotCompute();\n\n  const SCEVAddRecExpr *IV = dyn_cast<SCEVAddRecExpr>(LHS);\n  if (!IV && AllowPredicates)\n    // Try to make this an AddRec using runtime tests, in the first X\n    // iterations of this loop, where X is the SCEV expression found by the\n    // algorithm below.\n    IV = convertSCEVToAddRecWithPredicates(LHS, L, Predicates);\n\n  // Avoid weird loops\n  if (!IV || IV->getLoop() != L || !IV->isAffine())\n    return getCouldNotCompute();\n\n  bool NoWrap = ControlsExit &&\n                IV->getNoWrapFlags(IsSigned ? SCEV::FlagNSW : SCEV::FlagNUW);\n\n  const SCEV *Stride = getNegativeSCEV(IV->getStepRecurrence(*this));\n\n  // Avoid negative or zero stride values\n  if (!isKnownPositive(Stride))\n    return getCouldNotCompute();\n\n  // Avoid proven overflow cases: this will ensure that the backedge taken count\n  // will not generate any unsigned overflow. Relaxed no-overflow conditions\n  // exploit NoWrapFlags, allowing to optimize in presence of undefined\n  // behaviors like the case of C language.\n  if (!Stride->isOne() && doesIVOverflowOnGT(RHS, Stride, IsSigned, NoWrap))\n    return getCouldNotCompute();\n\n  ICmpInst::Predicate Cond = IsSigned ? ICmpInst::ICMP_SGT\n                                      : ICmpInst::ICMP_UGT;\n\n  const SCEV *Start = IV->getStart();\n  const SCEV *End = RHS;\n",
        "suffix": "  const SCEV *BECount = computeBECount(getMinusSCEV(Start, End), Stride, false);\n\n  APInt MaxStart = IsSigned ? getSignedRangeMax(Start)\n                            : getUnsignedRangeMax(Start);\n\n  APInt MinStride = IsSigned ? getSignedRangeMin(Stride)\n                             : getUnsignedRangeMin(Stride);\n\n  unsigned BitWidth = getTypeSizeInBits(LHS->getType());\n  APInt Limit = IsSigned ? APInt::getSignedMinValue(BitWidth) + (MinStride - 1)\n                         : APInt::getMinValue(BitWidth) + (MinStride - 1);\n\n  // Although End can be a MIN expression we estimate MinEnd considering only\n  // the case End = RHS. This is safe because in the other case (Start - End)\n  // is zero, leading to a zero maximum backedge taken count.\n  APInt MinEnd =\n    IsSigned ? APIntOps::smax(getSignedRangeMin(RHS), Limit)\n             : APIntOps::umax(getUnsignedRangeMin(RHS), Limit);\n\n  const SCEV *MaxBECount = isa<SCEVConstant>(BECount)\n                               ? BECount\n                               : computeBECount(getConstant(MaxStart - MinEnd),\n                                                getConstant(MinStride), false);\n\n  if (isa<SCEVCouldNotCompute>(MaxBECount))\n    MaxBECount = BECount;\n\n  return ExitLimit(BECount, MaxBECount, false, Predicates);\n}\n",
        "start": 10590,
        "end": 10662,
        "buggy": "ScalarEvolution::ExitLimit\nScalarEvolution::howManyGreaterThans(const SCEV *LHS, const SCEV *RHS,\n                                     const Loop *L, bool IsSigned,\n                                     bool ControlsExit, bool AllowPredicates) {\n  SmallPtrSet<const SCEVPredicate *, 4> Predicates;\n  // We handle only IV > Invariant\n  if (!isLoopInvariant(RHS, L))\n    return getCouldNotCompute();\n\n  const SCEVAddRecExpr *IV = dyn_cast<SCEVAddRecExpr>(LHS);\n  if (!IV && AllowPredicates)\n    // Try to make this an AddRec using runtime tests, in the first X\n    // iterations of this loop, where X is the SCEV expression found by the\n    // algorithm below.\n    IV = convertSCEVToAddRecWithPredicates(LHS, L, Predicates);\n\n  // Avoid weird loops\n  if (!IV || IV->getLoop() != L || !IV->isAffine())\n    return getCouldNotCompute();\n\n  bool NoWrap = ControlsExit &&\n                IV->getNoWrapFlags(IsSigned ? SCEV::FlagNSW : SCEV::FlagNUW);\n\n  const SCEV *Stride = getNegativeSCEV(IV->getStepRecurrence(*this));\n\n  // Avoid negative or zero stride values\n  if (!isKnownPositive(Stride))\n    return getCouldNotCompute();\n\n  // Avoid proven overflow cases: this will ensure that the backedge taken count\n  // will not generate any unsigned overflow. Relaxed no-overflow conditions\n  // exploit NoWrapFlags, allowing to optimize in presence of undefined\n  // behaviors like the case of C language.\n  if (!Stride->isOne() && doesIVOverflowOnGT(RHS, Stride, IsSigned, NoWrap))\n    return getCouldNotCompute();\n\n  ICmpInst::Predicate Cond = IsSigned ? ICmpInst::ICMP_SGT\n                                      : ICmpInst::ICMP_UGT;\n\n  const SCEV *Start = IV->getStart();\n  const SCEV *End = RHS;\n  if (!isLoopEntryGuardedByCond(L, Cond, getAddExpr(Start, Stride), RHS))\n    End = IsSigned ? getSMinExpr(RHS, Start) : getUMinExpr(RHS, Start);\n\n  const SCEV *BECount = computeBECount(getMinusSCEV(Start, End), Stride, false);\n\n  APInt MaxStart = IsSigned ? getSignedRangeMax(Start)\n                            : getUnsignedRangeMax(Start);\n\n  APInt MinStride = IsSigned ? getSignedRangeMin(Stride)\n                             : getUnsignedRangeMin(Stride);\n\n  unsigned BitWidth = getTypeSizeInBits(LHS->getType());\n  APInt Limit = IsSigned ? APInt::getSignedMinValue(BitWidth) + (MinStride - 1)\n                         : APInt::getMinValue(BitWidth) + (MinStride - 1);\n\n  // Although End can be a MIN expression we estimate MinEnd considering only\n  // the case End = RHS. This is safe because in the other case (Start - End)\n  // is zero, leading to a zero maximum backedge taken count.\n  APInt MinEnd =\n    IsSigned ? APIntOps::smax(getSignedRangeMin(RHS), Limit)\n             : APIntOps::umax(getUnsignedRangeMin(RHS), Limit);\n\n  const SCEV *MaxBECount = isa<SCEVConstant>(BECount)\n                               ? BECount\n                               : computeBECount(getConstant(MaxStart - MinEnd),\n                                                getConstant(MinStride), false);\n\n  if (isa<SCEVCouldNotCompute>(MaxBECount))\n    MaxBECount = BECount;\n\n  return ExitLimit(BECount, MaxBECount, false, Predicates);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  if (!isLoopEntryGuardedByCond(L, Cond, getAddExpr(Start, Stride), RHS))\n    End = IsSigned ? getSMinExpr(RHS, Start) : getUMinExpr(RHS, Start);\n\n",
        "src_path": "ee1c12708a4519361729205168dedb2b61bc2638___ScalarEvolution.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/ee1c12708a4519361729205168dedb2b61bc2638",
        "commit_msg": "[SCEV] If Start>=RHS, simplify (Start smin RHS) = RHS for trip counts.\n\nIn some cases, it seems like we can get rid of unnecessary s/umins by\nusing information from the loop guards (unless I am missing something).\n\nOne place where this seems to be helpful in practice is when computing\nloop trip counts. This patch just changes howManyGreaterThans for now.\nNote that this requires a loop for which we can check 'is guarded'.\n\nOn SPEC2000/SPEC2006/MultiSource, there are some notable changes for\nsome programs in the number of loops unrolled and trip counts computed.\n\n```\nSame hash: 179 (filtered out)\nRemaining: 58\nMetric: scalar-evolution.NumTripCountsComputed\n\nProgram                                        base    patch   diff\n test-suite...langs-C/compiler/compiler.test    25.00   31.00  24.0%\n test-suite.../Applications/SPASS/SPASS.test   2020.00 2323.00 15.0%\n test-suite...langs-C/allroots/allroots.test    29.00   32.00  10.3%\n test-suite.../Prolangs-C/loader/loader.test    17.00   18.00   5.9%\n test-suite...fice-ispell/office-ispell.test   253.00  265.00   4.7%\n test-suite...006/450.soplex/450.soplex.test   3552.00 3692.00  3.9%\n test-suite...chmarks/MallocBench/gs/gs.test   453.00  470.00   3.8%\n test-suite...ngs-C/assembler/assembler.test    29.00   30.00   3.4%\n test-suite.../Benchmarks/Ptrdist/bc/bc.test   263.00  270.00   2.7%\n test-suite...rks/FreeBench/pifft/pifft.test   722.00  741.00   2.6%\n test-suite...count/automotive-bitcount.test    41.00   42.00   2.4%\n test-suite...0/253.perlbmk/253.perlbmk.test   1417.00 1451.00  2.4%\n test-suite...000/197.parser/197.parser.test   387.00  396.00   2.3%\n test-suite...lications/sqlite3/sqlite3.test   1168.00 1189.00  1.8%\n test-suite...000/255.vortex/255.vortex.test   173.00  176.00   1.7%\n\nMetric: loop-unroll.NumUnrolled\n\nProgram                                        base   patch  diff\n test-suite...langs-C/compiler/compiler.test     1.00   3.00 200.0%\n test-suite.../Applications/SPASS/SPASS.test   134.00 234.00 74.6%\n test-suite...count/automotive-bitcount.test     3.00   4.00 33.3%\n test-suite.../Prolangs-C/loader/loader.test     3.00   4.00 33.3%\n test-suite...langs-C/allroots/allroots.test     3.00   4.00 33.3%\n test-suite...Source/Benchmarks/sim/sim.test    10.00  12.00 20.0%\n test-suite...fice-ispell/office-ispell.test    21.00  25.00 19.0%\n test-suite.../Benchmarks/Ptrdist/bc/bc.test    32.00  38.00 18.8%\n test-suite...006/450.soplex/450.soplex.test   300.00 352.00 17.3%\n test-suite...rks/FreeBench/pifft/pifft.test    60.00  69.00 15.0%\n test-suite...chmarks/MallocBench/gs/gs.test    57.00  63.00 10.5%\n test-suite...ngs-C/assembler/assembler.test    10.00  11.00 10.0%\n test-suite...0/253.perlbmk/253.perlbmk.test   145.00 157.00  8.3%\n test-suite...000/197.parser/197.parser.test    43.00  46.00  7.0%\n test-suite...TimberWolfMC/timberwolfmc.test   205.00 214.00  4.4%\n Geomean difference                                           7.6%\n```\n\nFixes https://bugs.llvm.org/show_bug.cgi?id=46939\nFixes https://bugs.llvm.org/show_bug.cgi?id=46924 on X86.\n\nReviewed By: mkazantsev\n\nDifferential Revision: https://reviews.llvm.org/D85046",
        "test_func_diff": [
            {
                "fn": "llvm/test/Analysis/ScalarEvolution/pr46939-trip-count-count-down.ll",
                "patch": "@@ -6,13 +6,13 @@ define void @reverse_loop(i32 %n) {\n ; CHECK-LABEL: 'reverse_loop'\n ; CHECK-NEXT:  Classifying expressions for: @reverse_loop\n ; CHECK-NEXT:    %i.011 = phi i32 [ %n, %for.body.lr.ph ], [ %dec, %for.body ]\n-; CHECK-NEXT:    --> {%n,+,-1}<nsw><%for.body> U: full-set S: full-set Exits: (0 smin %n) LoopDispositions: { %for.body: Computable }\n+; CHECK-NEXT:    --> {%n,+,-1}<nsw><%for.body> U: full-set S: full-set Exits: 0 LoopDispositions: { %for.body: Computable }\n ; CHECK-NEXT:    %dec = add nsw i32 %i.011, -1\n-; CHECK-NEXT:    --> {(-1 + %n),+,-1}<nw><%for.body> U: full-set S: full-set Exits: (-1 + (0 smin %n)) LoopDispositions: { %for.body: Computable }\n+; CHECK-NEXT:    --> {(-1 + %n),+,-1}<nw><%for.body> U: full-set S: full-set Exits: -1 LoopDispositions: { %for.body: Computable }\n ; CHECK-NEXT:  Determining loop execution counts for: @reverse_loop\n-; CHECK-NEXT:  Loop %for.body: backedge-taken count is ((-1 * (0 smin %n)) + %n)\n+; CHECK-NEXT:  Loop %for.body: backedge-taken count is %n\n ; CHECK-NEXT:  Loop %for.body: max backedge-taken count is 2147483647\n-; CHECK-NEXT:  Loop %for.body: Predicated backedge-taken count is ((-1 * (0 smin %n)) + %n)\n+; CHECK-NEXT:  Loop %for.body: Predicated backedge-taken count is %n\n ; CHECK-NEXT:   Predicates:\n ; CHECK:       Loop %for.body: Trip multiple is 1\n ;"
            },
            {
                "fn": "llvm/test/Transforms/HardwareLoops/scalar-while.ll",
                "patch": "@@ -76,18 +76,14 @@ while.end:\n ; CHECK-GUARD:   br i1 %cmp4, label %while.end, label %while.body.preheader\n ; CHECK-GUARD: while.body.preheader:\n ; CHECK-GUARD:   [[ADD:%[^ ]+]] = add i32 %i, 1\n-; CHECK-GUARD:   [[SEL:%[^ ]+]] = icmp slt i32 %N, %i\n-; CHECK-GUARD:   [[MIN:%[^ ]+]] = select i1 [[SEL]], i32 %N, i32 %i\n-; CHECK-GUARD:   [[COUNT:%[^ ]+]] = sub i32 [[ADD]], [[MIN]]\n+; CHECK-GUARD:   [[COUNT:%[^ ]+]] = sub i32 [[ADD]], %N\n ; CHECK-GUARD:   call void @llvm.set.loop.iterations.i32(i32 [[COUNT]])\n ; CHECK-GUARD:   br label %while.body\n \n ; CHECK-LABEL: while_gte\n ; CHECK: while.body.preheader:\n ; CHECK: [[ADD:%[^ ]+]] = add i32 %i, 1\n-; CHECK: [[SEL:%[^ ]+]] = icmp slt i32 %N, %i\n-; CHECK: [[MIN:%[^ ]+]] = select i1 [[SEL]], i32 %N, i32 %i\n-; CHECK: [[COUNT:%[^ ]+]] = sub i32 [[ADD]], [[MIN]]\n+; CHECK: [[COUNT:%[^ ]+]] = sub i32 [[ADD]], %N\n ; CHECK: call void @llvm.set.loop.iterations.i32(i32 [[COUNT]])\n ; CHECK: br label %while.body\n "
            }
        ],
        "error_msg": "FAIL: LLVM :: Analysis/ScalarEvolution/pr46939-trip-count-count-down.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Analysis/ScalarEvolution/pr46939-trip-count-count-down.ll\n\n\nTesting Time: 0.33s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/HardwareLoops/scalar-while.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/HardwareLoops/scalar-while.ll\n\n\nTesting Time: 0.13s\n  Failed: 1\n"
    },
    "e082dee2b5885bba65e20b22b088bcaca5546984___DeadStoreElimination.cpp": {
        "prefix": "  bool isWriteAtEndOfFunction(MemoryDef *Def) {\n    LLVM_DEBUG(dbgs() << \"  Check if def \" << *Def << \" (\"\n                      << *Def->getMemoryInst()\n                      << \") is at the end the function \\n\");\n\n    auto MaybeLoc = getLocForWriteEx(Def->getMemoryInst());\n    if (!MaybeLoc) {\n      LLVM_DEBUG(dbgs() << \"  ... could not get location for write.\\n\");\n      return false;\n    }\n\n    SmallVector<MemoryAccess *, 4> WorkList;\n    SmallPtrSet<MemoryAccess *, 8> Visited;\n    auto PushMemUses = [&WorkList, &Visited](MemoryAccess *Acc) {\n      if (!Visited.insert(Acc).second)\n        return;\n      for (Use &U : Acc->uses())\n        WorkList.push_back(cast<MemoryAccess>(U.getUser()));\n    };\n    PushMemUses(Def);\n    for (unsigned I = 0; I < WorkList.size(); I++) {\n      if (WorkList.size() >= MemorySSAScanLimit) {\n        LLVM_DEBUG(dbgs() << \"  ... hit exploration limit.\\n\");\n        return false;\n      }\n\n      MemoryAccess *UseAccess = WorkList[I];\n",
        "suffix": "      // TODO: Checking for aliasing is expensive. Consider reducing the amount\n      // of times this is called and/or caching it.\n      Instruction *UseInst = cast<MemoryUseOrDef>(UseAccess)->getMemoryInst();\n      if (isReadClobber(*MaybeLoc, UseInst)) {\n        LLVM_DEBUG(dbgs() << \"  ... hit read clobber \" << *UseInst << \".\\n\");\n        return false;\n      }\n\n      if (MemoryDef *UseDef = dyn_cast<MemoryDef>(UseAccess))\n        PushMemUses(UseDef);\n    }\n    return true;\n  }\n",
        "start": 1752,
        "end": 1796,
        "buggy": "  bool isWriteAtEndOfFunction(MemoryDef *Def) {\n    LLVM_DEBUG(dbgs() << \"  Check if def \" << *Def << \" (\"\n                      << *Def->getMemoryInst()\n                      << \") is at the end the function \\n\");\n\n    auto MaybeLoc = getLocForWriteEx(Def->getMemoryInst());\n    if (!MaybeLoc) {\n      LLVM_DEBUG(dbgs() << \"  ... could not get location for write.\\n\");\n      return false;\n    }\n\n    SmallVector<MemoryAccess *, 4> WorkList;\n    SmallPtrSet<MemoryAccess *, 8> Visited;\n    auto PushMemUses = [&WorkList, &Visited](MemoryAccess *Acc) {\n      if (!Visited.insert(Acc).second)\n        return;\n      for (Use &U : Acc->uses())\n        WorkList.push_back(cast<MemoryAccess>(U.getUser()));\n    };\n    PushMemUses(Def);\n    for (unsigned I = 0; I < WorkList.size(); I++) {\n      if (WorkList.size() >= MemorySSAScanLimit) {\n        LLVM_DEBUG(dbgs() << \"  ... hit exploration limit.\\n\");\n        return false;\n      }\n\n      MemoryAccess *UseAccess = WorkList[I];\n      if (isa<MemoryPhi>(UseAccess)) {\n        PushMemUses(UseAccess);\n        continue;\n      }\n\n      // TODO: Checking for aliasing is expensive. Consider reducing the amount\n      // of times this is called and/or caching it.\n      Instruction *UseInst = cast<MemoryUseOrDef>(UseAccess)->getMemoryInst();\n      if (isReadClobber(*MaybeLoc, UseInst)) {\n        LLVM_DEBUG(dbgs() << \"  ... hit read clobber \" << *UseInst << \".\\n\");\n        return false;\n      }\n\n      if (MemoryDef *UseDef = dyn_cast<MemoryDef>(UseAccess))\n        PushMemUses(UseDef);\n    }\n    return true;\n  }\n",
        "fix": null,
        "buggy_hunk_masked": "      if (isa<MemoryPhi>(UseAccess)) {\n        PushMemUses(UseAccess);\n        continue;\n      }\n\n",
        "src_path": "e082dee2b5885bba65e20b22b088bcaca5546984___DeadStoreElimination.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/e082dee2b5885bba65e20b22b088bcaca5546984",
        "commit_msg": "[DSE] Bail out on MemoryPhis when deleting stores at end of function.\n\nWhen deleting stores at the end of a function, we have to do PHI\ntranslation, otherwise we might miss reads in different iterations of a\nloop. See multiblock-loop-carried-dependence.ll for details.\n\nThis fixes a mis-compile and surprisingly also increases the number of\neliminated stores from 26047 to 26572 for MultiSource/SPEC2000/SPEC2006\non X86 with -O3 -flto. This is most likely because we save budget by not\nexploring through MemoryPhis, which are less likely to result in valid\ncandidates for elimination.\n\nThe issue was reported post-commit for fb109c42d91c.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/DeadStoreElimination/MSSA/multiblock-loop-carried-dependence.ll",
                "patch": "@@ -29,6 +29,9 @@ define void @test.1() {\n ; CHECK-NEXT:    [[PTR_IV_2:%.*]] = getelementptr inbounds [100 x i32], [100 x i32]* [[A]], i64 0, i64 [[IV_2]]\n ; CHECK-NEXT:    [[L_0:%.*]] = load i32, i32* [[PTR_IV_2]], align 4\n ; CHECK-NEXT:    call void @use(i32 [[L_0]])\n+; CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[IV_2]], 1\n+; CHECK-NEXT:    [[PTR_IV_2_ADD_1:%.*]] = getelementptr inbounds [100 x i32], [100 x i32]* [[A]], i64 0, i64 [[ADD]]\n+; CHECK-NEXT:    store i32 10, i32* [[PTR_IV_2_ADD_1]], align 4\n ; CHECK-NEXT:    [[L_1:%.*]] = load i32, i32* [[PTR_IV_2]], align 4\n ; CHECK-NEXT:    call void @use(i32 [[L_1]])\n ; CHECK-NEXT:    [[IV_2_NEXT]] = add nsw i64 [[IV_2]], 1"
            },
            {
                "fn": "llvm/test/Transforms/DeadStoreElimination/MSSA/multiblock-malloc-free.ll",
                "patch": "@@ -180,6 +180,7 @@ define void @test27() {\n ; CHECK-NEXT:    br i1 true, label [[BB2:%.*]], label [[BB3:%.*]]\n ; CHECK:       bb2:\n ; CHECK-NEXT:    [[M:%.*]] = call noalias i8* @malloc(i64 10)\n+; CHECK-NEXT:    store i8 1, i8* [[M]], align 1\n ; CHECK-NEXT:    br label [[BB3]]\n ; CHECK:       bb3:\n ; CHECK-NEXT:    [[R:%.*]] = phi i8* [ null, [[BB1:%.*]] ], [ [[M]], [[BB2]] ]"
            },
            {
                "fn": "llvm/test/Transforms/DeadStoreElimination/MSSA/multiblock-memintrinsics.ll",
                "patch": "@@ -123,10 +123,18 @@ bb3:\n define void @alloca_1(i1 %c) {\n ; CHECK-LABEL: @alloca_1(\n ; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    [[P_ALLOCA:%.*]] = alloca [32 x i32], align 4\n+; CHECK-NEXT:    [[P:%.*]] = bitcast [32 x i32]* [[P_ALLOCA]] to i32*\n+; CHECK-NEXT:    [[ARRAYIDX0:%.*]] = getelementptr inbounds i32, i32* [[P]], i64 1\n+; CHECK-NEXT:    [[P3:%.*]] = bitcast i32* [[ARRAYIDX0]] to i8*\n+; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, i8* [[P3]], i64 4\n+; CHECK-NEXT:    call void @llvm.memset.p0i8.i64(i8* align 4 [[TMP0]], i8 0, i64 24, i1 false)\n ; CHECK-NEXT:    br i1 [[C:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]\n ; CHECK:       bb1:\n ; CHECK-NEXT:    br label [[BB3:%.*]]\n ; CHECK:       bb2:\n+; CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds i32, i32* [[P]], i64 1\n+; CHECK-NEXT:    store i32 1, i32* [[ARRAYIDX1]], align 4\n ; CHECK-NEXT:    br label [[BB3]]\n ; CHECK:       bb3:\n ; CHECK-NEXT:    ret void\n@@ -152,10 +160,20 @@ bb3:\n define void @alloca_2(i1 %c) {\n ; CHECK-LABEL: @alloca_2(\n ; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    [[P_ALLOCA:%.*]] = alloca [32 x i32], align 4\n+; CHECK-NEXT:    [[P:%.*]] = bitcast [32 x i32]* [[P_ALLOCA]] to i32*\n+; CHECK-NEXT:    [[ARRAYIDX0:%.*]] = getelementptr inbounds i32, i32* [[P]], i64 1\n+; CHECK-NEXT:    [[P3:%.*]] = bitcast i32* [[ARRAYIDX0]] to i8*\n+; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, i8* [[P3]], i64 4\n+; CHECK-NEXT:    call void @llvm.memset.p0i8.i64(i8* align 4 [[TMP0]], i8 0, i64 24, i1 false)\n ; CHECK-NEXT:    br i1 [[C:%.*]], label [[BB1:%.*]], label [[BB2:%.*]]\n ; CHECK:       bb1:\n+; CHECK-NEXT:    [[ARRAYIDX1:%.*]] = getelementptr inbounds i32, i32* [[P]], i64 1\n+; CHECK-NEXT:    store i32 1, i32* [[ARRAYIDX1]], align 4\n ; CHECK-NEXT:    br label [[BB3:%.*]]\n ; CHECK:       bb2:\n+; CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i32, i32* [[P]], i64 1\n+; CHECK-NEXT:    store i32 1, i32* [[ARRAYIDX2]], align 4\n ; CHECK-NEXT:    br label [[BB3]]\n ; CHECK:       bb3:\n ; CHECK-NEXT:    ret void"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/DeadStoreElimination/MSSA/multiblock-loop-carried-dependence.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/DeadStoreElimination/MSSA/multiblock-loop-carried-dependence.ll\n\n\nTesting Time: 1.00s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/DeadStoreElimination/MSSA/multiblock-malloc-free.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/DeadStoreElimination/MSSA/multiblock-malloc-free.ll\n\n\nTesting Time: 0.26s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/DeadStoreElimination/MSSA/multiblock-memintrinsics.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/DeadStoreElimination/MSSA/multiblock-memintrinsics.ll\n\n\nTesting Time: 0.29s\n  Failed: 1\n"
    },
    "aa57c1c967078a8c02e7fc2c837853dbd7cc66f4___SimplifyLibCalls.cpp": {
        "prefix": "Value *LibCallSimplifier::optimizePow(CallInst *Pow, IRBuilderBase &B) {\n  Value *Base = Pow->getArgOperand(0);\n  Value *Expo = Pow->getArgOperand(1);\n  Function *Callee = Pow->getCalledFunction();\n  StringRef Name = Callee->getName();\n  Type *Ty = Pow->getType();\n  Module *M = Pow->getModule();\n  Value *Shrunk = nullptr;\n  bool AllowApprox = Pow->hasApproxFunc();\n  bool Ignored;\n\n  // Propagate the math semantics from the call to any created instructions.\n  IRBuilderBase::FastMathFlagGuard Guard(B);\n  B.setFastMathFlags(Pow->getFastMathFlags());\n\n  // Shrink pow() to powf() if the arguments are single precision,\n  // unless the result is expected to be double precision.\n  if (UnsafeFPShrink && Name == TLI->getName(LibFunc_pow) &&\n      hasFloatVersion(Name))\n    Shrunk = optimizeBinaryDoubleFP(Pow, B, true);\n\n  // Evaluate special cases related to the base.\n\n  // pow(1.0, x) -> 1.0\n  if (match(Base, m_FPOne()))\n    return Base;\n\n  if (Value *Exp = replacePowWithExp(Pow, B))\n    return Exp;\n\n  // Evaluate special cases related to the exponent.\n\n  // pow(x, -1.0) -> 1.0 / x\n  if (match(Expo, m_SpecificFP(-1.0)))\n    return B.CreateFDiv(ConstantFP::get(Ty, 1.0), Base, \"reciprocal\");\n\n  // pow(x, +/-0.0) -> 1.0\n  if (match(Expo, m_AnyZeroFP()))\n    return ConstantFP::get(Ty, 1.0);\n\n  // pow(x, 1.0) -> x\n  if (match(Expo, m_FPOne()))\n    return Base;\n\n  // pow(x, 2.0) -> x * x\n  if (match(Expo, m_SpecificFP(2.0)))\n    return B.CreateFMul(Base, Base, \"square\");\n\n  if (Value *Sqrt = replacePowWithSqrt(Pow, B))\n    return Sqrt;\n\n  // pow(x, n) -> x * x * x * ...\n  const APFloat *ExpoF;\n  if (AllowApprox && match(Expo, m_APFloat(ExpoF))) {\n    // We limit to a max of 7 multiplications, thus the maximum exponent is 32.\n    // If the exponent is an integer+0.5 we generate a call to sqrt and an\n    // additional fmul.\n    // TODO: This whole transformation should be backend specific (e.g. some\n    //       backends might prefer libcalls or the limit for the exponent might\n    //       be different) and it should also consider optimizing for size.\n    APFloat LimF(ExpoF->getSemantics(), 33),\n            ExpoA(abs(*ExpoF));\n    if (ExpoA < LimF) {\n      // This transformation applies to integer or integer+0.5 exponents only.\n      // For integer+0.5, we create a sqrt(Base) call.\n      Value *Sqrt = nullptr;\n      if (!ExpoA.isInteger()) {\n        APFloat Expo2 = ExpoA;\n        // To check if ExpoA is an integer + 0.5, we add it to itself. If there\n        // is no floating point exception and the result is an integer, then\n        // ExpoA == integer + 0.5\n        if (Expo2.add(ExpoA, APFloat::rmNearestTiesToEven) != APFloat::opOK)\n          return nullptr;\n\n        if (!Expo2.isInteger())\n          return nullptr;\n\n        Sqrt = getSqrtCall(Base, Pow->getCalledFunction()->getAttributes(),\n                           Pow->doesNotAccessMemory(), M, B, TLI);\n",
        "suffix": "\n      // We will memoize intermediate products of the Addition Chain.\n      Value *InnerChain[33] = {nullptr};\n      InnerChain[1] = Base;\n      InnerChain[2] = B.CreateFMul(Base, Base, \"square\");\n\n      // We cannot readily convert a non-double type (like float) to a double.\n      // So we first convert it to something which could be converted to double.\n      ExpoA.convert(APFloat::IEEEdouble(), APFloat::rmTowardZero, &Ignored);\n      Value *FMul = getPow(InnerChain, ExpoA.convertToDouble(), B);\n\n      // Expand pow(x, y+0.5) to pow(x, y) * sqrt(x).\n      if (Sqrt)\n        FMul = B.CreateFMul(FMul, Sqrt);\n\n      // If the exponent is negative, then get the reciprocal.\n      if (ExpoF->isNegative())\n        FMul = B.CreateFDiv(ConstantFP::get(Ty, 1.0), FMul, \"reciprocal\");\n\n      return FMul;\n    }\n\n    APSInt IntExpo(32, /*isUnsigned=*/false);\n    // powf(x, n) -> powi(x, n) if n is a constant signed integer value\n    if (ExpoF->isInteger() &&\n        ExpoF->convertToInteger(IntExpo, APFloat::rmTowardZero, &Ignored) ==\n            APFloat::opOK) {\n      return createPowWithIntegerExponent(\n          Base, ConstantInt::get(B.getInt32Ty(), IntExpo), M, B);\n    }\n  }\n\n  // powf(x, itofp(y)) -> powi(x, y)\n  if (AllowApprox && (isa<SIToFPInst>(Expo) || isa<UIToFPInst>(Expo))) {\n    if (Value *ExpoI = getIntToFPVal(Expo, B))\n      return createPowWithIntegerExponent(Base, ExpoI, M, B);\n  }\n\n  return Shrunk;\n}\n",
        "start": 1672,
        "end": 1791,
        "buggy": "Value *LibCallSimplifier::optimizePow(CallInst *Pow, IRBuilderBase &B) {\n  Value *Base = Pow->getArgOperand(0);\n  Value *Expo = Pow->getArgOperand(1);\n  Function *Callee = Pow->getCalledFunction();\n  StringRef Name = Callee->getName();\n  Type *Ty = Pow->getType();\n  Module *M = Pow->getModule();\n  Value *Shrunk = nullptr;\n  bool AllowApprox = Pow->hasApproxFunc();\n  bool Ignored;\n\n  // Propagate the math semantics from the call to any created instructions.\n  IRBuilderBase::FastMathFlagGuard Guard(B);\n  B.setFastMathFlags(Pow->getFastMathFlags());\n\n  // Shrink pow() to powf() if the arguments are single precision,\n  // unless the result is expected to be double precision.\n  if (UnsafeFPShrink && Name == TLI->getName(LibFunc_pow) &&\n      hasFloatVersion(Name))\n    Shrunk = optimizeBinaryDoubleFP(Pow, B, true);\n\n  // Evaluate special cases related to the base.\n\n  // pow(1.0, x) -> 1.0\n  if (match(Base, m_FPOne()))\n    return Base;\n\n  if (Value *Exp = replacePowWithExp(Pow, B))\n    return Exp;\n\n  // Evaluate special cases related to the exponent.\n\n  // pow(x, -1.0) -> 1.0 / x\n  if (match(Expo, m_SpecificFP(-1.0)))\n    return B.CreateFDiv(ConstantFP::get(Ty, 1.0), Base, \"reciprocal\");\n\n  // pow(x, +/-0.0) -> 1.0\n  if (match(Expo, m_AnyZeroFP()))\n    return ConstantFP::get(Ty, 1.0);\n\n  // pow(x, 1.0) -> x\n  if (match(Expo, m_FPOne()))\n    return Base;\n\n  // pow(x, 2.0) -> x * x\n  if (match(Expo, m_SpecificFP(2.0)))\n    return B.CreateFMul(Base, Base, \"square\");\n\n  if (Value *Sqrt = replacePowWithSqrt(Pow, B))\n    return Sqrt;\n\n  // pow(x, n) -> x * x * x * ...\n  const APFloat *ExpoF;\n  if (AllowApprox && match(Expo, m_APFloat(ExpoF))) {\n    // We limit to a max of 7 multiplications, thus the maximum exponent is 32.\n    // If the exponent is an integer+0.5 we generate a call to sqrt and an\n    // additional fmul.\n    // TODO: This whole transformation should be backend specific (e.g. some\n    //       backends might prefer libcalls or the limit for the exponent might\n    //       be different) and it should also consider optimizing for size.\n    APFloat LimF(ExpoF->getSemantics(), 33),\n            ExpoA(abs(*ExpoF));\n    if (ExpoA < LimF) {\n      // This transformation applies to integer or integer+0.5 exponents only.\n      // For integer+0.5, we create a sqrt(Base) call.\n      Value *Sqrt = nullptr;\n      if (!ExpoA.isInteger()) {\n        APFloat Expo2 = ExpoA;\n        // To check if ExpoA is an integer + 0.5, we add it to itself. If there\n        // is no floating point exception and the result is an integer, then\n        // ExpoA == integer + 0.5\n        if (Expo2.add(ExpoA, APFloat::rmNearestTiesToEven) != APFloat::opOK)\n          return nullptr;\n\n        if (!Expo2.isInteger())\n          return nullptr;\n\n        Sqrt = getSqrtCall(Base, Pow->getCalledFunction()->getAttributes(),\n                           Pow->doesNotAccessMemory(), M, B, TLI);\n      }\n\n      // We will memoize intermediate products of the Addition Chain.\n      Value *InnerChain[33] = {nullptr};\n      InnerChain[1] = Base;\n      InnerChain[2] = B.CreateFMul(Base, Base, \"square\");\n\n      // We cannot readily convert a non-double type (like float) to a double.\n      // So we first convert it to something which could be converted to double.\n      ExpoA.convert(APFloat::IEEEdouble(), APFloat::rmTowardZero, &Ignored);\n      Value *FMul = getPow(InnerChain, ExpoA.convertToDouble(), B);\n\n      // Expand pow(x, y+0.5) to pow(x, y) * sqrt(x).\n      if (Sqrt)\n        FMul = B.CreateFMul(FMul, Sqrt);\n\n      // If the exponent is negative, then get the reciprocal.\n      if (ExpoF->isNegative())\n        FMul = B.CreateFDiv(ConstantFP::get(Ty, 1.0), FMul, \"reciprocal\");\n\n      return FMul;\n    }\n\n    APSInt IntExpo(32, /*isUnsigned=*/false);\n    // powf(x, n) -> powi(x, n) if n is a constant signed integer value\n    if (ExpoF->isInteger() &&\n        ExpoF->convertToInteger(IntExpo, APFloat::rmTowardZero, &Ignored) ==\n            APFloat::opOK) {\n      return createPowWithIntegerExponent(\n          Base, ConstantInt::get(B.getInt32Ty(), IntExpo), M, B);\n    }\n  }\n\n  // powf(x, itofp(y)) -> powi(x, y)\n  if (AllowApprox && (isa<SIToFPInst>(Expo) || isa<UIToFPInst>(Expo))) {\n    if (Value *ExpoI = getIntToFPVal(Expo, B))\n      return createPowWithIntegerExponent(Base, ExpoI, M, B);\n  }\n\n  return Shrunk;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      }\n",
        "src_path": "aa57c1c967078a8c02e7fc2c837853dbd7cc66f4___SimplifyLibCalls.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/aa57c1c967078a8c02e7fc2c837853dbd7cc66f4",
        "commit_msg": "[InstCombine] fix bug in pow expansion\n\nThere at least one other bug related to pow -> sqrt transforms:\nhttp://lists.llvm.org/pipermail/llvm-dev/2020-September/145051.html\n...but we probably can't solve that without fixing this first.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/pow-4.ll",
                "patch": "@@ -152,7 +152,6 @@ define double @test_simplify_neg_16_5(double %x) {\n }\n \n ; pow(x, 16.5) with double\n-; FIXME: This is wrong without sqrt.\n \n define double @test_simplify_16_5_libcall(double %x) {\n ; SQRT-LABEL: @test_simplify_16_5_libcall(\n@@ -165,18 +164,14 @@ define double @test_simplify_16_5_libcall(double %x) {\n ; SQRT-NEXT:    ret double [[TMP4]]\n ;\n ; NOSQRT-LABEL: @test_simplify_16_5_libcall(\n-; NOSQRT-NEXT:    [[SQUARE:%.*]] = fmul fast double [[X:%.*]], [[X]]\n-; NOSQRT-NEXT:    [[TMP1:%.*]] = fmul fast double [[SQUARE]], [[SQUARE]]\n-; NOSQRT-NEXT:    [[TMP2:%.*]] = fmul fast double [[TMP1]], [[TMP1]]\n-; NOSQRT-NEXT:    [[TMP3:%.*]] = fmul fast double [[TMP2]], [[TMP2]]\n-; NOSQRT-NEXT:    ret double [[TMP3]]\n+; NOSQRT-NEXT:    [[TMP1:%.*]] = call fast double @pow(double [[X:%.*]], double 1.650000e+01)\n+; NOSQRT-NEXT:    ret double [[TMP1]]\n ;\n   %1 = call fast double @pow(double %x, double 1.650000e+01)\n   ret double %1\n }\n \n ; pow(x, -16.5) with double\n-; FIXME: This is wrong without sqrt.\n \n define double @test_simplify_neg_16_5_libcall(double %x) {\n ; SQRT-LABEL: @test_simplify_neg_16_5_libcall(\n@@ -190,12 +185,8 @@ define double @test_simplify_neg_16_5_libcall(double %x) {\n ; SQRT-NEXT:    ret double [[RECIPROCAL]]\n ;\n ; NOSQRT-LABEL: @test_simplify_neg_16_5_libcall(\n-; NOSQRT-NEXT:    [[SQUARE:%.*]] = fmul fast double [[X:%.*]], [[X]]\n-; NOSQRT-NEXT:    [[TMP1:%.*]] = fmul fast double [[SQUARE]], [[SQUARE]]\n-; NOSQRT-NEXT:    [[TMP2:%.*]] = fmul fast double [[TMP1]], [[TMP1]]\n-; NOSQRT-NEXT:    [[TMP3:%.*]] = fmul fast double [[TMP2]], [[TMP2]]\n-; NOSQRT-NEXT:    [[RECIPROCAL:%.*]] = fdiv fast double 1.000000e+00, [[TMP3]]\n-; NOSQRT-NEXT:    ret double [[RECIPROCAL]]\n+; NOSQRT-NEXT:    [[TMP1:%.*]] = call fast double @pow(double [[X:%.*]], double -1.650000e+01)\n+; NOSQRT-NEXT:    ret double [[TMP1]]\n ;\n   %1 = call fast double @pow(double %x, double -1.650000e+01)\n   ret double %1"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/pow-4.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/pow-4.ll\n\n\nTesting Time: 0.44s\n  Failed: 1\n"
    },
    "32c9991dab5cb1454959561c77f9d0089d981429___SimplifyLibCalls.cpp": {
        "prefix": "Value *LibCallSimplifier::replacePowWithSqrt(CallInst *Pow, IRBuilderBase &B) {\n  Value *Sqrt, *Base = Pow->getArgOperand(0), *Expo = Pow->getArgOperand(1);\n  AttributeList Attrs; // Attributes are only meaningful on the original call\n  Module *Mod = Pow->getModule();\n  Type *Ty = Pow->getType();\n\n  const APFloat *ExpoF;\n  if (!match(Expo, m_APFloat(ExpoF)) ||\n      (!ExpoF->isExactlyValue(0.5) && !ExpoF->isExactlyValue(-0.5)))\n    return nullptr;\n\n  // Converting pow(X, -0.5) to 1/sqrt(X) may introduce an extra rounding step,\n  // so that requires fast-math-flags (afn or reassoc).\n  if (ExpoF->isNegative() && (!Pow->hasApproxFunc() && !Pow->hasAllowReassoc()))\n    return nullptr;\n\n",
        "suffix": "  if (!Sqrt)\n    return nullptr;\n\n  // Handle signed zero base by expanding to fabs(sqrt(x)).\n  if (!Pow->hasNoSignedZeros()) {\n    Function *FAbsFn = Intrinsic::getDeclaration(Mod, Intrinsic::fabs, Ty);\n    Sqrt = B.CreateCall(FAbsFn, Sqrt, \"abs\");\n  }\n\n  // Handle non finite base by expanding to\n  // (x == -infinity ? +infinity : sqrt(x)).\n  if (!Pow->hasNoInfs()) {\n    Value *PosInf = ConstantFP::getInfinity(Ty),\n          *NegInf = ConstantFP::getInfinity(Ty, true);\n    Value *FCmp = B.CreateFCmpOEQ(Base, NegInf, \"isinf\");\n    Sqrt = B.CreateSelect(FCmp, PosInf, Sqrt);\n  }\n\n  // If the exponent is negative, then get the reciprocal.\n  if (ExpoF->isNegative())\n    Sqrt = B.CreateFDiv(ConstantFP::get(Ty, 1.0), Sqrt, \"reciprocal\");\n\n  return Sqrt;\n}\n",
        "start": 1623,
        "end": 1663,
        "buggy": "Value *LibCallSimplifier::replacePowWithSqrt(CallInst *Pow, IRBuilderBase &B) {\n  Value *Sqrt, *Base = Pow->getArgOperand(0), *Expo = Pow->getArgOperand(1);\n  AttributeList Attrs; // Attributes are only meaningful on the original call\n  Module *Mod = Pow->getModule();\n  Type *Ty = Pow->getType();\n\n  const APFloat *ExpoF;\n  if (!match(Expo, m_APFloat(ExpoF)) ||\n      (!ExpoF->isExactlyValue(0.5) && !ExpoF->isExactlyValue(-0.5)))\n    return nullptr;\n\n  // Converting pow(X, -0.5) to 1/sqrt(X) may introduce an extra rounding step,\n  // so that requires fast-math-flags (afn or reassoc).\n  if (ExpoF->isNegative() && (!Pow->hasApproxFunc() && !Pow->hasAllowReassoc()))\n    return nullptr;\n\n  Sqrt = getSqrtCall(Base, Attrs, Pow->doesNotAccessMemory(), Mod, B, TLI);\n  if (!Sqrt)\n    return nullptr;\n\n  // Handle signed zero base by expanding to fabs(sqrt(x)).\n  if (!Pow->hasNoSignedZeros()) {\n    Function *FAbsFn = Intrinsic::getDeclaration(Mod, Intrinsic::fabs, Ty);\n    Sqrt = B.CreateCall(FAbsFn, Sqrt, \"abs\");\n  }\n\n  // Handle non finite base by expanding to\n  // (x == -infinity ? +infinity : sqrt(x)).\n  if (!Pow->hasNoInfs()) {\n    Value *PosInf = ConstantFP::getInfinity(Ty),\n          *NegInf = ConstantFP::getInfinity(Ty, true);\n    Value *FCmp = B.CreateFCmpOEQ(Base, NegInf, \"isinf\");\n    Sqrt = B.CreateSelect(FCmp, PosInf, Sqrt);\n  }\n\n  // If the exponent is negative, then get the reciprocal.\n  if (ExpoF->isNegative())\n    Sqrt = B.CreateFDiv(ConstantFP::get(Ty, 1.0), Sqrt, \"reciprocal\");\n\n  return Sqrt;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  Sqrt = getSqrtCall(Base, Attrs, Pow->doesNotAccessMemory(), Mod, B, TLI);\n",
        "src_path": "32c9991dab5cb1454959561c77f9d0089d981429___SimplifyLibCalls.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/32c9991dab5cb1454959561c77f9d0089d981429",
        "commit_msg": "[InstCombine] Fix errno bug in pow expansion to sqrt\n\nA conversion from `pow` to `sqrt` shall not call an `errno`-setting\n`sqrt` with -//infinity//: the `sqrt` will set `EDOM` where the `pow`\ncall need not.\n\nThis patch avoids the erroneous (pun not intended) transformation by\napplying the restrictions discussed in the thread for\nhttps://lists.llvm.org/pipermail/llvm-dev/2020-September/145051.html.\n\nThe existing tests are updated (depending on emphasis in the checks for\nlibrary calls, avoidance of overlap, and overall coverage):\n  - to add `ninf`, retaining the intended library call,\n  - to use the intrinsic, retaining the use of `select`, or\n  - to expect the replacement to not occur.\n\nThe following is tested:\n  - The pow intrinsic folds to a `select` instruction to\n    handle -//infinity//.\n  - The pow library call folds, with `ninf`, to `sqrt` without the\n    `select` instruction associated with handling -//infinity//.\n  - The pow library call does not fold to `sqrt` without `ninf`.\n\nReviewed By: spatel\n\nDifferential Revision: https://reviews.llvm.org/D87877",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/pow-1.ll",
                "patch": "@@ -19,6 +19,7 @@\n ; in the cases below where pow is transformed into another function call.\n \n declare float @powf(float, float) nounwind readonly\n+declare float @llvm.pow.f32(float, float)\n declare double @pow(double, double) nounwind readonly\n declare double @llvm.pow.f64(double, double)\n declare <2 x float> @llvm.pow.v2f32(<2 x float>, <2 x float>) nounwind readonly\n@@ -247,43 +248,34 @@ define <2 x double> @test_simplify6v(<2 x double> %x) {\n \n ; Check pow(x, 0.5) -> fabs(sqrt(x)), where x != -infinity.\n \n-define float @powf_libcall_to_select_sqrt(float %x) {\n-; CHECK-LABEL: @powf_libcall_to_select_sqrt(\n-; ANY-NEXT:    [[SQRTF:%.*]] = call float @sqrtf(float [[X:%.*]])\n-; ANY-NEXT:    [[ABS:%.*]] = call float @llvm.fabs.f32(float [[SQRTF]])\n-; ANY-NEXT:    [[ISINF:%.*]] = fcmp oeq float [[X]], 0xFFF0000000000000\n-; ANY-NEXT:    [[TMP1:%.*]] = select i1 [[ISINF]], float 0x7FF0000000000000, float [[ABS]]\n-; ANY-NEXT:    ret float [[TMP1]]\n-; VC32-NEXT:   [[POW:%.*]] = call float @powf(float [[X:%.*]], float 5.000000e-01)\n+define float @powf_libcall_half_ninf(float %x) {\n+; CHECK-LABEL: @powf_libcall_half_ninf(\n+; ANY-NEXT:    [[SQRTF:%.*]] = call ninf float @sqrtf(float [[X:%.*]])\n+; ANY-NEXT:    [[ABS:%.*]] = call ninf float @llvm.fabs.f32(float [[SQRTF]])\n+; ANY-NEXT:    ret float [[ABS]]\n+; VC32-NEXT:   [[POW:%.*]] = call ninf float @powf(float [[X:%.*]], float 5.000000e-01)\n ; VC32-NEXT:   ret float [[POW]]\n-; VC51-NEXT:   [[POW:%.*]] = call float @powf(float [[X:%.*]], float 5.000000e-01)\n+; VC51-NEXT:   [[POW:%.*]] = call ninf float @powf(float [[X:%.*]], float 5.000000e-01)\n ; VC51-NEXT:   ret float [[POW]]\n-; VC64-NEXT:   [[SQRTF:%.*]] = call float @sqrtf(float [[X:%.*]])\n-; VC64-NEXT:   [[ABS:%.*]] = call float @llvm.fabs.f32(float [[SQRTF]])\n-; VC64-NEXT:   [[ISINF:%.*]] = fcmp oeq float [[X]], 0xFFF0000000000000\n-; VC64-NEXT:   [[TMP1:%.*]] = select i1 [[ISINF]], float 0x7FF0000000000000, float [[ABS]]\n-; VC64-NEXT:   ret float [[TMP1]]\n-; VC83-NEXT:   [[SQRTF:%.*]] = call float @sqrtf(float [[X:%.*]])\n-; VC83-NEXT:   [[ABS:%.*]] = call float @llvm.fabs.f32(float [[SQRTF]])\n-; VC83-NEXT:   [[ISINF:%.*]] = fcmp oeq float [[X]], 0xFFF0000000000000\n-; VC83-NEXT:   [[TMP1:%.*]] = select i1 [[ISINF]], float 0x7FF0000000000000, float [[ABS]]\n-; VC83-NEXT:   ret float [[TMP1]]\n-; NOLIB-NEXT:    [[POW:%.*]] = call float @powf(float [[X:%.*]], float 5.000000e-01)\n+; VC64-NEXT:   [[SQRTF:%.*]] = call ninf float @sqrtf(float [[X:%.*]])\n+; VC64-NEXT:   [[ABS:%.*]] = call ninf float @llvm.fabs.f32(float [[SQRTF]])\n+; VC64-NEXT:   ret float [[ABS]]\n+; VC83-NEXT:   [[SQRTF:%.*]] = call ninf float @sqrtf(float [[X:%.*]])\n+; VC83-NEXT:   [[ABS:%.*]] = call ninf float @llvm.fabs.f32(float [[SQRTF]])\n+; VC83-NEXT:   ret float [[ABS]]\n+; NOLIB-NEXT:    [[POW:%.*]] = call ninf float @powf(float [[X:%.*]], float 5.000000e-01)\n ; NOLIB-NEXT:    ret float [[POW]]\n ;\n-  %retval = call float @powf(float %x, float 0.5)\n+  %retval = call ninf float @powf(float %x, float 0.5)\n   ret float %retval\n }\n \n-define double @pow_libcall_to_select_sqrt(double %x) {\n-; CHECK-LABEL: @pow_libcall_to_select_sqrt(\n-; LIB-NEXT:    [[SQRT:%.*]] = call double @sqrt(double [[X:%.*]])\n-; LIB-NEXT:    [[ABS:%.*]] = call double @llvm.fabs.f64(double [[SQRT]])\n-; LIB-NEXT:    [[ISINF:%.*]] = fcmp oeq double [[X]], 0xFFF0000000000000\n-; LIB-NEXT:    [[TMP1:%.*]] = select i1 [[ISINF]], double 0x7FF0000000000000, double [[ABS]]\n-; LIB-NEXT:    ret double [[TMP1]]\n-; NOLIB-NEXT:    [[POW:%.*]] = call double @pow(double [[X:%.*]], double 5.000000e-01)\n-; NOLIB-NEXT:    ret double [[POW]]\n+; Check pow(x, 0.5) where x may be -infinity does not call a library sqrt function.\n+\n+define double @pow_libcall_half_no_FMF(double %x) {\n+; CHECK-LABEL: @pow_libcall_half_no_FMF(\n+; CHECK-NEXT:    [[POW:%.*]] = call double @pow(double [[X:%.*]], double 5.000000e-01)\n+; CHECK-NEXT:    ret double [[POW]]\n ;\n   %retval = call double @pow(double %x, double 0.5)\n   ret double %retval\n@@ -293,27 +285,17 @@ define double @pow_libcall_to_select_sqrt(double %x) {\n \n define float @test_simplify9(float %x) {\n ; CHECK-LABEL: @test_simplify9(\n-; ANY-NEXT:    ret float 0x7FF0000000000000\n-; VC32-NEXT:   [[POW:%.*]] = call float @powf(float 0xFFF0000000000000, float 5.000000e-01)\n-; VC32-NEXT:   ret float [[POW]]\n-; VC51-NEXT:   [[POW:%.*]] = call float @powf(float 0xFFF0000000000000, float 5.000000e-01)\n-; VC51-NEXT:   ret float [[POW]]\n-; VC64-NEXT:   ret float 0x7FF0000000000000\n-; VC83-NEXT:   ret float 0x7FF0000000000000\n-; NOLIB-NEXT:    [[POW:%.*]] = call float @powf(float 0xFFF0000000000000, float 5.000000e-01)\n-; NOLIB-NEXT:    ret float [[POW]]\n+; CHECK-NEXT:    ret float 0x7FF0000000000000\n ;\n-  %retval = call float @powf(float 0xFFF0000000000000, float 0.5)\n+  %retval = call float @llvm.pow.f32(float 0xFFF0000000000000, float 0.5)\n   ret float %retval\n }\n \n define double @test_simplify10(double %x) {\n ; CHECK-LABEL: @test_simplify10(\n-; LIB-NEXT:    ret double 0x7FF0000000000000\n-; NOLIB-NEXT:    [[POW:%.*]] = call double @pow(double 0xFFF0000000000000, double 5.000000e-01)\n-; NOLIB-NEXT:    ret double [[POW]]\n+; CHECK-NEXT:    ret double 0x7FF0000000000000\n ;\n-  %retval = call double @pow(double 0xFFF0000000000000, double 0.5)\n+  %retval = call double @llvm.pow.f64(double 0xFFF0000000000000, double 0.5)\n   ret double %retval\n }\n \n@@ -482,8 +464,8 @@ define <2 x double> @pow_neg1_double_fastv(<2 x double> %x) {\n   ret <2 x double> %r\n }\n \n-define double @test_simplify17(double %x) {\n-; CHECK-LABEL: @test_simplify17(\n+define double @pow_intrinsic_half_no_FMF(double %x) {\n+; CHECK-LABEL: @pow_intrinsic_half_no_FMF(\n ; CHECK-NEXT:    [[SQRT:%.*]] = call double @llvm.sqrt.f64(double [[X:%.*]])\n ; CHECK-NEXT:    [[ABS:%.*]] = call double @llvm.fabs.f64(double [[SQRT]])\n ; CHECK-NEXT:    [[ISINF:%.*]] = fcmp oeq double [[X]], 0xFFF0000000000000"
            },
            {
                "fn": "llvm/test/Transforms/InstCombine/pow-sqrt.ll",
                "patch": "@@ -3,20 +3,19 @@\n \n ; Check the libcall and the intrinsic for each case with differing FMF.\n \n-; The transform to sqrt is allowed as long as we deal with -0.0 and -INF.\n+; The transform to sqrt is not allowed if we risk setting errno due to -INF.\n \n define double @pow_libcall_half_no_FMF(double %x) {\n ; CHECK-LABEL: @pow_libcall_half_no_FMF(\n-; CHECK-NEXT:    [[SQRT:%.*]] = call double @sqrt(double [[X:%.*]])\n-; CHECK-NEXT:    [[ABS:%.*]] = call double @llvm.fabs.f64(double [[SQRT]])\n-; CHECK-NEXT:    [[ISINF:%.*]] = fcmp oeq double [[X]], 0xFFF0000000000000\n-; CHECK-NEXT:    [[TMP1:%.*]] = select i1 [[ISINF]], double 0x7FF0000000000000, double [[ABS]]\n-; CHECK-NEXT:    ret double [[TMP1]]\n+; CHECK-NEXT:    [[POW:%.*]] = call double @pow(double [[X:%.*]], double 5.000000e-01)\n+; CHECK-NEXT:    ret double [[POW]]\n ;\n   %pow = call double @pow(double %x, double 5.0e-01)\n   ret double %pow\n }\n \n+; The transform to (non-errno setting) sqrt is allowed as long as we deal with -0.0 and -INF.\n+\n define double @pow_intrinsic_half_no_FMF(double %x) {\n ; CHECK-LABEL: @pow_intrinsic_half_no_FMF(\n ; CHECK-NEXT:    [[SQRT:%.*]] = call double @llvm.sqrt.f64(double [[X:%.*]])\n@@ -29,20 +28,25 @@ define double @pow_intrinsic_half_no_FMF(double %x) {\n   ret double %pow\n }\n \n-; This makes no difference, but FMF are propagated.\n+; `afn` makes no difference, but FMF are propagated/retained.\n+\n+; (As above) the transform to sqrt may generate EDOM due to -INF. Generally, EDOM implies\n+; formation of a NaN (which then propagates). `afn` may justify returning NaN (along with\n+; setting EDOM); however, the conservatively correct approach is to avoid both the NaN and\n+; the EDOM.\n \n define double @pow_libcall_half_approx(double %x) {\n ; CHECK-LABEL: @pow_libcall_half_approx(\n-; CHECK-NEXT:    [[SQRT:%.*]] = call afn double @sqrt(double [[X:%.*]])\n-; CHECK-NEXT:    [[ABS:%.*]] = call afn double @llvm.fabs.f64(double [[SQRT]])\n-; CHECK-NEXT:    [[ISINF:%.*]] = fcmp afn oeq double [[X]], 0xFFF0000000000000\n-; CHECK-NEXT:    [[TMP1:%.*]] = select afn i1 [[ISINF]], double 0x7FF0000000000000, double [[ABS]]\n-; CHECK-NEXT:    ret double [[TMP1]]\n+; CHECK-NEXT:    [[POW:%.*]] = call afn double @pow(double [[X:%.*]], double 5.000000e-01)\n+; CHECK-NEXT:    ret double [[POW]]\n ;\n   %pow = call afn double @pow(double %x, double 5.0e-01)\n   ret double %pow\n }\n \n+; (As above) the transform to (non-errno setting) sqrt is allowed as long as we deal with -0.0\n+; and -INF.\n+\n define <2 x double> @pow_intrinsic_half_approx(<2 x double> %x) {\n ; CHECK-LABEL: @pow_intrinsic_half_approx(\n ; CHECK-NEXT:    [[SQRT:%.*]] = call afn <2 x double> @llvm.sqrt.v2f64(<2 x double> [[X:%.*]])\n@@ -86,14 +90,12 @@ define <2 x double> @pow_intrinsic_half_ninf(<2 x double> %x) {\n   ret <2 x double> %pow\n }\n \n-; If we can disregard -0.0, no need for fabs.\n+; If we can disregard -0.0, no need for fabs, but still (because of -INF) cannot use library sqrt.\n \n define double @pow_libcall_half_nsz(double %x) {\n ; CHECK-LABEL: @pow_libcall_half_nsz(\n-; CHECK-NEXT:    [[SQRT:%.*]] = call nsz double @sqrt(double [[X:%.*]])\n-; CHECK-NEXT:    [[ISINF:%.*]] = fcmp nsz oeq double [[X]], 0xFFF0000000000000\n-; CHECK-NEXT:    [[TMP1:%.*]] = select nsz i1 [[ISINF]], double 0x7FF0000000000000, double [[SQRT]]\n-; CHECK-NEXT:    ret double [[TMP1]]\n+; CHECK-NEXT:    [[POW:%.*]] = call nsz double @pow(double [[X:%.*]], double 5.000000e-01)\n+; CHECK-NEXT:    ret double [[POW]]\n ;\n   %pow = call nsz double @pow(double %x, double 5.0e-01)\n   ret double %pow\n@@ -162,35 +164,27 @@ define float @pow_libcall_neghalf_no_FMF(float %x) {\n   ret float %pow\n }\n \n+; If we can disregard INFs, a call to a library sqrt is okay.\n ; Transform to sqrt+fdiv because 'reassoc' allows an extra rounding step.\n ; Use 'fabs' to handle -0.0 correctly.\n-; Use 'select' to handle -INF correctly.\n \n-define float @pow_libcall_neghalf_reassoc(float %x) {\n-; CHECK-LABEL: @pow_libcall_neghalf_reassoc(\n-; CHECK-NEXT:    [[SQRTF:%.*]] = call reassoc float @sqrtf(float [[X:%.*]])\n-; CHECK-NEXT:    [[ABS:%.*]] = call reassoc float @llvm.fabs.f32(float [[SQRTF]])\n-; CHECK-NEXT:    [[ISINF:%.*]] = fcmp reassoc oeq float [[X]], 0xFFF0000000000000\n-; CHECK-NEXT:    [[ABS_OP:%.*]] = fdiv reassoc float 1.000000e+00, [[ABS]]\n-; CHECK-NEXT:    [[RECIPROCAL:%.*]] = select i1 [[ISINF]], float 0.000000e+00, float [[ABS_OP]]\n+define float @pow_libcall_neghalf_reassoc_ninf(float %x) {\n+; CHECK-LABEL: @pow_libcall_neghalf_reassoc_ninf(\n+; CHECK-NEXT:    [[SQRTF:%.*]] = call reassoc ninf float @sqrtf(float [[X:%.*]])\n+; CHECK-NEXT:    [[ABS:%.*]] = call reassoc ninf float @llvm.fabs.f32(float [[SQRTF]])\n+; CHECK-NEXT:    [[RECIPROCAL:%.*]] = fdiv reassoc ninf float 1.000000e+00, [[ABS]]\n ; CHECK-NEXT:    ret float [[RECIPROCAL]]\n ;\n-  %pow = call reassoc float @powf(float %x, float -5.0e-01)\n+  %pow = call reassoc ninf float @powf(float %x, float -5.0e-01)\n   ret float %pow\n }\n \n-; Transform to sqrt+fdiv because 'afn' allows an extra rounding step.\n-; Use 'fabs' to handle -0.0 correctly.\n-; Use 'select' to handle -INF correctly.\n+; If we cannot disregard INFs, a call to a library sqrt is not okay.\n \n define float @pow_libcall_neghalf_afn(float %x) {\n ; CHECK-LABEL: @pow_libcall_neghalf_afn(\n-; CHECK-NEXT:    [[SQRTF:%.*]] = call afn float @sqrtf(float [[X:%.*]])\n-; CHECK-NEXT:    [[ABS:%.*]] = call afn float @llvm.fabs.f32(float [[SQRTF]])\n-; CHECK-NEXT:    [[ISINF:%.*]] = fcmp afn oeq float [[X]], 0xFFF0000000000000\n-; CHECK-NEXT:    [[ABS_OP:%.*]] = fdiv afn float 1.000000e+00, [[ABS]]\n-; CHECK-NEXT:    [[RECIPROCAL:%.*]] = select i1 [[ISINF]], float 0.000000e+00, float [[ABS_OP]]\n-; CHECK-NEXT:    ret float [[RECIPROCAL]]\n+; CHECK-NEXT:    [[POW:%.*]] = call afn float @powf(float [[X:%.*]], float -5.000000e-01)\n+; CHECK-NEXT:    ret float [[POW]]\n ;\n   %pow = call afn float @powf(float %x, float -5.0e-01)\n   ret float %pow\n@@ -265,15 +259,12 @@ define <2 x double> @pow_intrinsic_neghalf_ninf(<2 x double> %x) {\n   ret <2 x double> %pow\n }\n \n-; If we can disregard -0.0, no need for fabs.\n+; If we can disregard -0.0, no need for fabs, but still (because of -INF) cannot use library sqrt.\n \n define double @pow_libcall_neghalf_nsz(double %x) {\n ; CHECK-LABEL: @pow_libcall_neghalf_nsz(\n-; CHECK-NEXT:    [[SQRT:%.*]] = call nsz afn double @sqrt(double [[X:%.*]])\n-; CHECK-NEXT:    [[ISINF:%.*]] = fcmp nsz afn oeq double [[X]], 0xFFF0000000000000\n-; CHECK-NEXT:    [[SQRT_OP:%.*]] = fdiv nsz afn double 1.000000e+00, [[SQRT]]\n-; CHECK-NEXT:    [[RECIPROCAL:%.*]] = select i1 [[ISINF]], double 0.000000e+00, double [[SQRT_OP]]\n-; CHECK-NEXT:    ret double [[RECIPROCAL]]\n+; CHECK-NEXT:    [[POW:%.*]] = call nsz afn double @pow(double [[X:%.*]], double -5.000000e-01)\n+; CHECK-NEXT:    ret double [[POW]]\n ;\n   %pow = call afn nsz double @pow(double %x, double -5.0e-01)\n   ret double %pow"
            },
            {
                "fn": "llvm/test/Transforms/InstCombine/win-math.ll",
                "patch": "@@ -330,6 +330,6 @@ define float @float_powsqrt(float %x) nounwind readnone {\n ; MINGW64-NOT: float @powf\n ; MINGW64: float @sqrtf\n ; MINGW64: float @llvm.fabs.f32(\n-    %1 = call float @powf(float %x, float 0.5)\n+    %1 = call ninf float @powf(float %x, float 0.5)\n     ret float %1\n }"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/pow-1.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/pow-1.ll\n\n\nTesting Time: 0.36s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/InstCombine/pow-sqrt.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/pow-sqrt.ll\n\n\nTesting Time: 0.17s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nPASS: LLVM :: Transforms/InstCombine/win-math.ll (1 of 1)\n\nTesting Time: 2.03s\n  Passed: 1\n"
    },
    "f192a27ed3bacdf727f27857adeb6d3762383295___Sink.cpp": {
        "prefix": "static bool SinkInstruction(Instruction *Inst,\n                            SmallPtrSetImpl<Instruction *> &Stores,\n                            DominatorTree &DT, LoopInfo &LI, AAResults &AA) {\n\n  // Don't sink static alloca instructions.  CodeGen assumes allocas outside the\n  // entry block are dynamically sized stack objects.\n  if (AllocaInst *AI = dyn_cast<AllocaInst>(Inst))\n    if (AI->isStaticAlloca())\n      return false;\n\n  // Check if it's safe to move the instruction.\n  if (!isSafeToMove(Inst, AA, Stores))\n    return false;\n\n  // FIXME: This should include support for sinking instructions within the\n  // block they are currently in to shorten the live ranges.  We often get\n  // instructions sunk into the top of a large block, but it would be better to\n  // also sink them down before their first use in the block.  This xform has to\n  // be careful not to *increase* register pressure though, e.g. sinking\n  // \"x = y + z\" down if it kills y and z would increase the live ranges of y\n  // and z and only shrink the live range of x.\n\n  // SuccToSinkTo - This is the successor to sink this instruction to, once we\n  // decide.\n  BasicBlock *SuccToSinkTo = nullptr;\n\n  // Find the nearest common dominator of all users as the candidate.\n  BasicBlock *BB = Inst->getParent();\n  for (Use &U : Inst->uses()) {\n    Instruction *UseInst = cast<Instruction>(U.getUser());\n    BasicBlock *UseBlock = UseInst->getParent();\n",
        "suffix": "      // PHI nodes use the operand in the predecessor block, not the block with\n      // the PHI.\n      unsigned Num = PHINode::getIncomingValueNumForOperand(U.getOperandNo());\n      UseBlock = PN->getIncomingBlock(Num);\n    }\n    if (SuccToSinkTo)\n      SuccToSinkTo = DT.findNearestCommonDominator(SuccToSinkTo, UseBlock);\n    else\n      SuccToSinkTo = UseBlock;\n    // The current basic block needs to dominate the candidate.\n    if (!DT.dominates(BB, SuccToSinkTo))\n      return false;\n  }\n\n  if (SuccToSinkTo) {\n    // The nearest common dominator may be in a parent loop of BB, which may not\n    // be beneficial. Find an ancestor.\n    while (SuccToSinkTo != BB &&\n           !IsAcceptableTarget(Inst, SuccToSinkTo, DT, LI))\n      SuccToSinkTo = DT.getNode(SuccToSinkTo)->getIDom()->getBlock();\n    if (SuccToSinkTo == BB)\n      SuccToSinkTo = nullptr;\n  }\n\n  // If we couldn't find a block to sink to, ignore this instruction.\n  if (!SuccToSinkTo)\n    return false;\n\n  LLVM_DEBUG(dbgs() << \"Sink\" << *Inst << \" (\";\n             Inst->getParent()->printAsOperand(dbgs(), false); dbgs() << \" -> \";\n             SuccToSinkTo->printAsOperand(dbgs(), false); dbgs() << \")\\n\");\n\n  // Move the instruction.\n  Inst->moveBefore(&*SuccToSinkTo->getFirstInsertionPt());\n  return true;\n}\n",
        "start": 107,
        "end": 174,
        "buggy": "static bool SinkInstruction(Instruction *Inst,\n                            SmallPtrSetImpl<Instruction *> &Stores,\n                            DominatorTree &DT, LoopInfo &LI, AAResults &AA) {\n\n  // Don't sink static alloca instructions.  CodeGen assumes allocas outside the\n  // entry block are dynamically sized stack objects.\n  if (AllocaInst *AI = dyn_cast<AllocaInst>(Inst))\n    if (AI->isStaticAlloca())\n      return false;\n\n  // Check if it's safe to move the instruction.\n  if (!isSafeToMove(Inst, AA, Stores))\n    return false;\n\n  // FIXME: This should include support for sinking instructions within the\n  // block they are currently in to shorten the live ranges.  We often get\n  // instructions sunk into the top of a large block, but it would be better to\n  // also sink them down before their first use in the block.  This xform has to\n  // be careful not to *increase* register pressure though, e.g. sinking\n  // \"x = y + z\" down if it kills y and z would increase the live ranges of y\n  // and z and only shrink the live range of x.\n\n  // SuccToSinkTo - This is the successor to sink this instruction to, once we\n  // decide.\n  BasicBlock *SuccToSinkTo = nullptr;\n\n  // Find the nearest common dominator of all users as the candidate.\n  BasicBlock *BB = Inst->getParent();\n  for (Use &U : Inst->uses()) {\n    Instruction *UseInst = cast<Instruction>(U.getUser());\n    BasicBlock *UseBlock = UseInst->getParent();\n    if (PHINode *PN = dyn_cast<PHINode>(UseInst)) {\n      // PHI nodes use the operand in the predecessor block, not the block with\n      // the PHI.\n      unsigned Num = PHINode::getIncomingValueNumForOperand(U.getOperandNo());\n      UseBlock = PN->getIncomingBlock(Num);\n    }\n    if (SuccToSinkTo)\n      SuccToSinkTo = DT.findNearestCommonDominator(SuccToSinkTo, UseBlock);\n    else\n      SuccToSinkTo = UseBlock;\n    // The current basic block needs to dominate the candidate.\n    if (!DT.dominates(BB, SuccToSinkTo))\n      return false;\n  }\n\n  if (SuccToSinkTo) {\n    // The nearest common dominator may be in a parent loop of BB, which may not\n    // be beneficial. Find an ancestor.\n    while (SuccToSinkTo != BB &&\n           !IsAcceptableTarget(Inst, SuccToSinkTo, DT, LI))\n      SuccToSinkTo = DT.getNode(SuccToSinkTo)->getIDom()->getBlock();\n    if (SuccToSinkTo == BB)\n      SuccToSinkTo = nullptr;\n  }\n\n  // If we couldn't find a block to sink to, ignore this instruction.\n  if (!SuccToSinkTo)\n    return false;\n\n  LLVM_DEBUG(dbgs() << \"Sink\" << *Inst << \" (\";\n             Inst->getParent()->printAsOperand(dbgs(), false); dbgs() << \" -> \";\n             SuccToSinkTo->printAsOperand(dbgs(), false); dbgs() << \")\\n\");\n\n  // Move the instruction.\n  Inst->moveBefore(&*SuccToSinkTo->getFirstInsertionPt());\n  return true;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (PHINode *PN = dyn_cast<PHINode>(UseInst)) {\n",
        "src_path": "f192a27ed3bacdf727f27857adeb6d3762383295___Sink.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/f192a27ed3bacdf727f27857adeb6d3762383295",
        "commit_msg": "Sink: Handle instruction sink when a user is dead\n\nSummary:\n  The current instruction sink pass uses findNearestCommonDominator of all users to find block to sink the instruction to.\nHowever, a user may be in a dead block, which will result in unexpected behavior.\n\nThis patch handles such cases by skipping dead blocks. This patch fixes:\nhttps://bugs.llvm.org/show_bug.cgi?id=47415\n\nReviewers:\n  MaskRay, arsenm\n\nDifferential Revision:\n  https://reviews.llvm.org/D89166",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/Sink/dead-user.ll",
                "patch": "@@ -0,0 +1,42 @@\n+; Compiler should not be broken with a dead user.\n+; RUN: opt -sink -S < %s | FileCheck %s\n+\n+; CHECK-LABEL: @test(\n+; CHECK:       bb.0:\n+; CHECK-NEXT:    %conv = sext i16 %p1 to i32\n+; CHECK-NEXT:    br i1 undef, label %bb.1, label %bb.3\n+\n+; CHECK:       bb.1:                                             ; preds = %bb.0\n+; CHECK-NEXT:    br label %bb.2\n+\n+; CHECK:       bb.2:                                             ; preds = %bb.2, %bb.1\n+; CHECK-NEXT:    %and.2 = and i32 undef, %conv\n+; CHECK-NEXT:    br label %bb.2\n+\n+; CHECK:       bb.3:                                             ; preds = %bb.3, %bb.0\n+; CHECK-NEXT:    %and.3 = and i32 undef, %conv\n+; CHECK-NEXT:    br label %bb.3\n+\n+; CHECK:       dead:                                             ; preds = %dead\n+; CHECK-NEXT:    %and.dead = and i32 undef, %conv\n+; CHECK-NEXT:    br label %dead\n+define void @test(i16 %p1) {\n+bb.0:\n+  %conv = sext i16 %p1 to i32\n+  br i1 undef, label %bb.1, label %bb.3\n+\n+bb.1:                                             ; preds = %bb.0\n+  br label %bb.2\n+\n+bb.2:                                             ; preds = %bb.2, %bb.1\n+  %and.2 = and i32 undef, %conv\n+  br label %bb.2\n+\n+bb.3:                                             ; preds = %bb.3, %bb.0\n+  %and.3 = and i32 undef, %conv\n+  br label %bb.3\n+\n+dead:                                             ; preds = %dead\n+  %and.dead = and i32 undef, %conv\n+  br label %dead\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/Sink/dead-user.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/Sink/dead-user.ll\n\n\nTesting Time: 1.94s\n  Failed: 1\n"
    },
    "7669455df49e6fc8ae7d9f4bd4ee95bb20e7eb6e___X86FastISel.cpp": {
        "prefix": "bool X86FastISel::foldX86XALUIntrinsic(X86::CondCode &CC, const Instruction *I,\n                                       const Value *Cond) {\n  if (!isa<ExtractValueInst>(Cond))\n    return false;\n\n  const auto *EV = cast<ExtractValueInst>(Cond);\n  if (!isa<IntrinsicInst>(EV->getAggregateOperand()))\n    return false;\n\n  const auto *II = cast<IntrinsicInst>(EV->getAggregateOperand());\n  MVT RetVT;\n  const Function *Callee = II->getCalledFunction();\n  Type *RetTy =\n    cast<StructType>(Callee->getReturnType())->getTypeAtIndex(0U);\n  if (!isTypeLegal(RetTy, RetVT))\n    return false;\n\n  if (RetVT != MVT::i32 && RetVT != MVT::i64)\n    return false;\n\n  X86::CondCode TmpCC;\n  switch (II->getIntrinsicID()) {\n  default: return false;\n  case Intrinsic::sadd_with_overflow:\n  case Intrinsic::ssub_with_overflow:\n  case Intrinsic::smul_with_overflow:\n  case Intrinsic::umul_with_overflow: TmpCC = X86::COND_O; break;\n  case Intrinsic::uadd_with_overflow:\n  case Intrinsic::usub_with_overflow: TmpCC = X86::COND_B; break;\n  }\n\n  // Check if both instructions are in the same basic block.\n  if (II->getParent() != I->getParent())\n    return false;\n\n  // Make sure nothing is in the way\n  BasicBlock::const_iterator Start(I);\n  BasicBlock::const_iterator End(II);\n  for (auto Itr = std::prev(Start); Itr != End; --Itr) {\n    // We only expect extractvalue instructions between the intrinsic and the\n    // instruction to be selected.\n    if (!isa<ExtractValueInst>(Itr))\n      return false;\n\n    // Check that the extractvalue operand comes from the intrinsic.\n    const auto *EVI = cast<ExtractValueInst>(Itr);\n    if (EVI->getAggregateOperand() != II)\n      return false;\n  }\n\n",
        "suffix": "  return true;\n}\n",
        "start": 237,
        "end": 289,
        "buggy": "bool X86FastISel::foldX86XALUIntrinsic(X86::CondCode &CC, const Instruction *I,\n                                       const Value *Cond) {\n  if (!isa<ExtractValueInst>(Cond))\n    return false;\n\n  const auto *EV = cast<ExtractValueInst>(Cond);\n  if (!isa<IntrinsicInst>(EV->getAggregateOperand()))\n    return false;\n\n  const auto *II = cast<IntrinsicInst>(EV->getAggregateOperand());\n  MVT RetVT;\n  const Function *Callee = II->getCalledFunction();\n  Type *RetTy =\n    cast<StructType>(Callee->getReturnType())->getTypeAtIndex(0U);\n  if (!isTypeLegal(RetTy, RetVT))\n    return false;\n\n  if (RetVT != MVT::i32 && RetVT != MVT::i64)\n    return false;\n\n  X86::CondCode TmpCC;\n  switch (II->getIntrinsicID()) {\n  default: return false;\n  case Intrinsic::sadd_with_overflow:\n  case Intrinsic::ssub_with_overflow:\n  case Intrinsic::smul_with_overflow:\n  case Intrinsic::umul_with_overflow: TmpCC = X86::COND_O; break;\n  case Intrinsic::uadd_with_overflow:\n  case Intrinsic::usub_with_overflow: TmpCC = X86::COND_B; break;\n  }\n\n  // Check if both instructions are in the same basic block.\n  if (II->getParent() != I->getParent())\n    return false;\n\n  // Make sure nothing is in the way\n  BasicBlock::const_iterator Start(I);\n  BasicBlock::const_iterator End(II);\n  for (auto Itr = std::prev(Start); Itr != End; --Itr) {\n    // We only expect extractvalue instructions between the intrinsic and the\n    // instruction to be selected.\n    if (!isa<ExtractValueInst>(Itr))\n      return false;\n\n    // Check that the extractvalue operand comes from the intrinsic.\n    const auto *EVI = cast<ExtractValueInst>(Itr);\n    if (EVI->getAggregateOperand() != II)\n      return false;\n  }\n\n  CC = TmpCC;\n  return true;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  CC = TmpCC;\n",
        "src_path": "7669455df49e6fc8ae7d9f4bd4ee95bb20e7eb6e___X86FastISel.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/7669455df49e6fc8ae7d9f4bd4ee95bb20e7eb6e",
        "commit_msg": "[X86][FastISel] Fix with.overflow eflags clobber (PR49587)\n\nIf the successor block has a phi node, then additional moves may\nbe inserted into predecessors, which may clobber eflags. Don't try\nto fold the with.overflow result into the branch in that case.\n\nThis is done by explicitly checking for any phis in successor\nblocks, not sure if there's some more principled way to address\nthis. Other fused compare and branch patterns avoid the issue by\nemitting the comparison when handling the branch, so that no\ninstructions may be inserted in between. In this case, the\nwith.overflow call is emitted separately (and I don't think this\nis avoidable, as it will generally have at least two users).\n\nFixes https://bugs.llvm.org/show_bug.cgi?id=49587.\n\nDifferential Revision: https://reviews.llvm.org/D98600",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/pr49587.ll",
                "patch": "@@ -5,10 +5,11 @@ define i32 @test(i64 %arg) nounwind {\n ; CHECK-LABEL: test:\n ; CHECK:       # %bb.0: # %entry\n ; CHECK-NEXT:    subq $1, %rdi\n-; CHECK-NEXT:    setb %al\n+; CHECK-NEXT:    setb %cl\n ; CHECK-NEXT:    xorl %eax, %eax\n+; CHECK-NEXT:    testb $1, %cl\n ; CHECK-NEXT:    movl %eax, {{[-0-9]+}}(%r{{[sb]}}p) # 4-byte Spill\n-; CHECK-NEXT:    jb .LBB0_2\n+; CHECK-NEXT:    jne .LBB0_2\n ; CHECK-NEXT:  # %bb.1: # %no_overflow\n ; CHECK-NEXT:    movl $1, %eax\n ; CHECK-NEXT:    movl %eax, {{[-0-9]+}}(%r{{[sb]}}p) # 4-byte Spill"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/pr49587.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/pr49587.ll\n\n\nTesting Time: 0.12s\n  Failed: 1\n"
    },
    "514bc01ca3b9f97945dd49aa40e01922fed0e41d___SimplifyCFG.cpp": {
        "prefix": "static void CloneInstructionsIntoPredecessorBlockAndUpdateSSAUses(\n    BasicBlock *BB, BasicBlock *PredBlock, ValueToValueMapTy &VMap) {\n  Instruction *PTI = PredBlock->getTerminator();\n\n  // If we have bonus instructions, clone them into the predecessor block.\n  // Note that there may be multiple predecessor blocks, so we cannot move\n  // bonus instructions to a predecessor block.\n  for (Instruction &BonusInst : *BB) {\n    if (isa<DbgInfoIntrinsic>(BonusInst) || BonusInst.isTerminator())\n      continue;\n\n    Instruction *NewBonusInst = BonusInst.clone();\n\n    if (PTI->getDebugLoc() != NewBonusInst->getDebugLoc()) {\n      // Unless the instruction has the same !dbg location as the original\n      // branch, drop it. When we fold the bonus instructions we want to make\n      // sure we reset their debug locations in order to avoid stepping on\n      // dead code caused by folding dead branches.\n      NewBonusInst->setDebugLoc(DebugLoc());\n    }\n\n    RemapInstruction(NewBonusInst, VMap,\n                     RF_NoModuleLevelChanges | RF_IgnoreMissingLocals);\n    VMap[&BonusInst] = NewBonusInst;\n\n    // If we moved a load, we cannot any longer claim any knowledge about\n    // its potential value. The previous information might have been valid\n    // only given the branch precondition.\n    // For an analogous reason, we must also drop all the metadata whose\n    // semantics we don't understand. We *can* preserve !annotation, because\n    // it is tied to the instruction itself, not the value or position.\n    NewBonusInst->dropUnknownNonDebugMetadata(LLVMContext::MD_annotation);\n\n    PredBlock->getInstList().insert(PTI->getIterator(), NewBonusInst);\n    NewBonusInst->takeName(&BonusInst);\n    BonusInst.setName(NewBonusInst->getName() + \".old\");\n\n    // Update (liveout) uses of bonus instructions,\n    // now that the bonus instruction has been cloned into predecessor.\n    SSAUpdater SSAUpdate;\n    SSAUpdate.Initialize(BonusInst.getType(),\n                         (NewBonusInst->getName() + \".merge\").str());\n    SSAUpdate.AddAvailableValue(BB, &BonusInst);\n    SSAUpdate.AddAvailableValue(PredBlock, NewBonusInst);\n",
        "suffix": "}\n",
        "start": 1056,
        "end": 1103,
        "buggy": "static void CloneInstructionsIntoPredecessorBlockAndUpdateSSAUses(\n    BasicBlock *BB, BasicBlock *PredBlock, ValueToValueMapTy &VMap) {\n  Instruction *PTI = PredBlock->getTerminator();\n\n  // If we have bonus instructions, clone them into the predecessor block.\n  // Note that there may be multiple predecessor blocks, so we cannot move\n  // bonus instructions to a predecessor block.\n  for (Instruction &BonusInst : *BB) {\n    if (isa<DbgInfoIntrinsic>(BonusInst) || BonusInst.isTerminator())\n      continue;\n\n    Instruction *NewBonusInst = BonusInst.clone();\n\n    if (PTI->getDebugLoc() != NewBonusInst->getDebugLoc()) {\n      // Unless the instruction has the same !dbg location as the original\n      // branch, drop it. When we fold the bonus instructions we want to make\n      // sure we reset their debug locations in order to avoid stepping on\n      // dead code caused by folding dead branches.\n      NewBonusInst->setDebugLoc(DebugLoc());\n    }\n\n    RemapInstruction(NewBonusInst, VMap,\n                     RF_NoModuleLevelChanges | RF_IgnoreMissingLocals);\n    VMap[&BonusInst] = NewBonusInst;\n\n    // If we moved a load, we cannot any longer claim any knowledge about\n    // its potential value. The previous information might have been valid\n    // only given the branch precondition.\n    // For an analogous reason, we must also drop all the metadata whose\n    // semantics we don't understand. We *can* preserve !annotation, because\n    // it is tied to the instruction itself, not the value or position.\n    NewBonusInst->dropUnknownNonDebugMetadata(LLVMContext::MD_annotation);\n\n    PredBlock->getInstList().insert(PTI->getIterator(), NewBonusInst);\n    NewBonusInst->takeName(&BonusInst);\n    BonusInst.setName(NewBonusInst->getName() + \".old\");\n\n    // Update (liveout) uses of bonus instructions,\n    // now that the bonus instruction has been cloned into predecessor.\n    SSAUpdater SSAUpdate;\n    SSAUpdate.Initialize(BonusInst.getType(),\n                         (NewBonusInst->getName() + \".merge\").str());\n    SSAUpdate.AddAvailableValue(BB, &BonusInst);\n    SSAUpdate.AddAvailableValue(PredBlock, NewBonusInst);\n    for (Use &U : make_early_inc_range(BonusInst.uses()))\n      SSAUpdate.RewriteUseAfterInsertions(U);\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    for (Use &U : make_early_inc_range(BonusInst.uses()))\n      SSAUpdate.RewriteUseAfterInsertions(U);\n  }\n",
        "src_path": "514bc01ca3b9f97945dd49aa40e01922fed0e41d___SimplifyCFG.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/514bc01ca3b9f97945dd49aa40e01922fed0e41d",
        "commit_msg": "[SimplifyCFG] FoldBranchToCommonDest(): properly handle same-block external uses (PR49510/PR49689)\n\nWe clone bonus instructions to the end of the predecessor block,\nand then use `SSAUpdater::RewriteUseAfterInsertions()`.\nBut that only deals with the cases where the use-to-be-rewritten\nare either in different block from the def, or come after the def.\n\nBut in some loop cases, the external use may be in the beginning of\npredecessor block, before the newly cloned bonus instruction.\n`SSAUpdater::RewriteUseAfterInsertions()` does not deal with that.\nNotably, the external use can't happen to be both in the same block\nand *after* the newly-cloned instruction, because of the fold preconditions.\n\nTo properly handle these cases, when the use is in the same block,\nwe should instead use `SSAUpdater::RewriteUse()`.\nTBN, they do the same thing for PHI users.\n\nFixes https://bugs.llvm.org/show_bug.cgi?id=49510\nLikely Fixes https://bugs.llvm.org/show_bug.cgi?id=49689",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/SimplifyCFG/fold-branch-to-common-dest.ll",
                "patch": "@@ -894,3 +894,37 @@ if.end7:\n cleanup:\n   unreachable\n }\n+\n+@global_pr49510 = external global i16, align 1\n+\n+define void @pr49510() {\n+; CHECK-LABEL: @pr49510(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    [[DOTOLD:%.*]] = load i16, i16* @global_pr49510, align 1\n+; CHECK-NEXT:    [[TOBOOL_OLD:%.*]] = icmp ne i16 [[DOTOLD]], 0\n+; CHECK-NEXT:    br i1 [[TOBOOL_OLD]], label [[LAND_RHS:%.*]], label [[FOR_END:%.*]]\n+; CHECK:       land.rhs:\n+; CHECK-NEXT:    [[DOTMERGE:%.*]] = phi i16 [ [[TMP0:%.*]], [[LAND_RHS]] ], [ [[DOTOLD]], [[ENTRY:%.*]] ]\n+; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i16 [[DOTMERGE]], 0\n+; CHECK-NEXT:    [[TMP0]] = load i16, i16* @global_pr49510, align 1\n+; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp ne i16 [[TMP0]], 0\n+; CHECK-NEXT:    [[OR_COND:%.*]] = select i1 [[CMP]], i1 [[TOBOOL]], i1 false\n+; CHECK-NEXT:    br i1 [[OR_COND]], label [[LAND_RHS]], label [[FOR_END]]\n+; CHECK:       for.end:\n+; CHECK-NEXT:    ret void\n+;\n+entry:\n+  br label %for.cond\n+\n+for.cond:\n+  %0 = load i16, i16* @global_pr49510, align 1\n+  %tobool = icmp ne i16 %0, 0\n+  br i1 %tobool, label %land.rhs, label %for.end\n+\n+land.rhs:\n+  %cmp = icmp slt i16 %0, 0\n+  br i1 %cmp, label %for.cond, label %for.end\n+\n+for.end:\n+  ret void\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/SimplifyCFG/fold-branch-to-common-dest.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SimplifyCFG/fold-branch-to-common-dest.ll\n\n\nTesting Time: 6.33s\n  Failed: 1\n"
    },
    "db357891f0cf76253be3cd75f682b68544a411da___Loads.cpp": {
        "prefix": "static bool isDereferenceableAndAlignedPointer(\n    const Value *V, Align Alignment, const APInt &Size, const DataLayout &DL,\n    const Instruction *CtxI, const DominatorTree *DT,\n    const TargetLibraryInfo *TLI, SmallPtrSetImpl<const Value *> &Visited,\n    unsigned MaxDepth) {\n  assert(V->getType()->isPointerTy() && \"Base must be pointer\");\n\n  // Recursion limit.\n  if (MaxDepth-- == 0)\n    return false;\n\n  // Already visited?  Bail out, we've likely hit unreachable code.\n  if (!Visited.insert(V).second)\n    return false;\n\n  // Note that it is not safe to speculate into a malloc'd region because\n  // malloc may return null.\n\n  // bitcast instructions are no-ops as far as dereferenceability is concerned.\n  if (const BitCastOperator *BC = dyn_cast<BitCastOperator>(V)) {\n    if (BC->getSrcTy()->isPointerTy())\n      return isDereferenceableAndAlignedPointer(\n          BC->getOperand(0), Alignment, Size, DL, CtxI, DT, TLI,\n          Visited, MaxDepth);\n  }\n\n  bool CheckForNonNull, CheckForFreed;\n  APInt KnownDerefBytes(Size.getBitWidth(),\n                        V->getPointerDereferenceableBytes(DL, CheckForNonNull,\n                                                          CheckForFreed));\n  if (KnownDerefBytes.getBoolValue() && KnownDerefBytes.uge(Size) &&\n      !CheckForFreed)\n    if (!CheckForNonNull || isKnownNonZero(V, DL, 0, nullptr, CtxI, DT)) {\n      // As we recursed through GEPs to get here, we've incrementally checked\n      // that each step advanced by a multiple of the alignment. If our base is\n      // properly aligned, then the original offset accessed must also be.\n      Type *Ty = V->getType();\n      assert(Ty->isSized() && \"must be sized\");\n      APInt Offset(DL.getTypeStoreSizeInBits(Ty), 0);\n      return isAligned(V, Offset, Alignment, DL);\n    }\n\n  if (CtxI) {\n    /// Look through assumes to see if both dereferencability and alignment can\n    /// be provent by an assume\n    RetainedKnowledge AlignRK;\n    RetainedKnowledge DerefRK;\n    if (getKnowledgeForValue(\n            V, {Attribute::Dereferenceable, Attribute::Alignment}, nullptr,\n            [&](RetainedKnowledge RK, Instruction *Assume, auto) {\n              if (!isValidAssumeForContext(Assume, CtxI))\n                return false;\n              if (RK.AttrKind == Attribute::Alignment)\n                AlignRK = std::max(AlignRK, RK);\n              if (RK.AttrKind == Attribute::Dereferenceable)\n                DerefRK = std::max(DerefRK, RK);\n              if (AlignRK && DerefRK && AlignRK.ArgValue >= Alignment.value() &&\n                  DerefRK.ArgValue >= Size.getZExtValue())\n                return true; // We have found what we needed so we stop looking\n              return false;  // Other assumes may have better information. so\n                             // keep looking\n            }))\n      return true;\n  }\n  /// TODO refactor this function to be able to search independently for\n  /// Dereferencability and Alignment requirements.\n\n  // For GEPs, determine if the indexing lands within the allocated object.\n  if (const GEPOperator *GEP = dyn_cast<GEPOperator>(V)) {\n    const Value *Base = GEP->getPointerOperand();\n\n    APInt Offset(DL.getIndexTypeSizeInBits(GEP->getType()), 0);\n    if (!GEP->accumulateConstantOffset(DL, Offset) || Offset.isNegative() ||\n        !Offset.urem(APInt(Offset.getBitWidth(), Alignment.value()))\n             .isMinValue())\n      return false;\n\n    // If the base pointer is dereferenceable for Offset+Size bytes, then the\n    // GEP (== Base + Offset) is dereferenceable for Size bytes.  If the base\n    // pointer is aligned to Align bytes, and the Offset is divisible by Align\n    // then the GEP (== Base + Offset == k_0 * Align + k_1 * Align) is also\n    // aligned to Align bytes.\n\n    // Offset and Size may have different bit widths if we have visited an\n    // addrspacecast, so we can't do arithmetic directly on the APInt values.\n    return isDereferenceableAndAlignedPointer(\n        Base, Alignment, Offset + Size.sextOrTrunc(Offset.getBitWidth()), DL,\n        CtxI, DT, TLI, Visited, MaxDepth);\n  }\n\n  // For gc.relocate, look through relocations\n  if (const GCRelocateInst *RelocateInst = dyn_cast<GCRelocateInst>(V))\n    return isDereferenceableAndAlignedPointer(RelocateInst->getDerivedPtr(),\n                                              Alignment, Size, DL, CtxI, DT,\n                                              TLI, Visited, MaxDepth);\n\n  if (const AddrSpaceCastInst *ASC = dyn_cast<AddrSpaceCastInst>(V))\n    return isDereferenceableAndAlignedPointer(ASC->getOperand(0), Alignment,\n                                              Size, DL, CtxI, DT, TLI,\n                                              Visited, MaxDepth);\n\n  if (const auto *Call = dyn_cast<CallBase>(V)) {\n    if (auto *RP = getArgumentAliasingToReturnedPointer(Call, true))\n      return isDereferenceableAndAlignedPointer(RP, Alignment, Size, DL, CtxI,\n                                                DT, TLI, Visited, MaxDepth);\n\n    // If we have a call we can't recurse through, check to see if this is an\n    // allocation function for which we can establish an minimum object size.\n    // Such a minimum object size is analogous to a deref_or_null attribute in\n    // that we still need to prove the result non-null at point of use.\n    // NOTE: We can only use the object size as a base fact as we a) need to\n    // prove alignment too, and b) don't want the compile time impact of a\n    // separate recursive walk.\n    ObjectSizeOpts Opts;\n    // TODO: It may be okay to round to align, but that would imply that\n    // accessing slightly out of bounds was legal, and we're currently\n    // inconsistent about that.  For the moment, be conservative.\n    Opts.RoundToAlign = false;\n    Opts.NullIsUnknownSize = true;\n    uint64_t ObjSize;\n",
        "suffix": "      if (KnownDerefBytes.getBoolValue() && KnownDerefBytes.uge(Size) &&\n          isKnownNonZero(V, DL, 0, nullptr, CtxI, DT) && !V->canBeFreed()) {\n        // As we recursed through GEPs to get here, we've incrementally\n        // checked that each step advanced by a multiple of the alignment. If\n        // our base is properly aligned, then the original offset accessed\n        // must also be. \n        Type *Ty = V->getType();\n        assert(Ty->isSized() && \"must be sized\");\n        APInt Offset(DL.getTypeStoreSizeInBits(Ty), 0);\n        return isAligned(V, Offset, Alignment, DL);\n      }\n    }\n  }\n\n  // If we don't know, assume the worst.\n  return false;\n}\n",
        "start": 45,
        "end": 184,
        "buggy": "static bool isDereferenceableAndAlignedPointer(\n    const Value *V, Align Alignment, const APInt &Size, const DataLayout &DL,\n    const Instruction *CtxI, const DominatorTree *DT,\n    const TargetLibraryInfo *TLI, SmallPtrSetImpl<const Value *> &Visited,\n    unsigned MaxDepth) {\n  assert(V->getType()->isPointerTy() && \"Base must be pointer\");\n\n  // Recursion limit.\n  if (MaxDepth-- == 0)\n    return false;\n\n  // Already visited?  Bail out, we've likely hit unreachable code.\n  if (!Visited.insert(V).second)\n    return false;\n\n  // Note that it is not safe to speculate into a malloc'd region because\n  // malloc may return null.\n\n  // bitcast instructions are no-ops as far as dereferenceability is concerned.\n  if (const BitCastOperator *BC = dyn_cast<BitCastOperator>(V)) {\n    if (BC->getSrcTy()->isPointerTy())\n      return isDereferenceableAndAlignedPointer(\n          BC->getOperand(0), Alignment, Size, DL, CtxI, DT, TLI,\n          Visited, MaxDepth);\n  }\n\n  bool CheckForNonNull, CheckForFreed;\n  APInt KnownDerefBytes(Size.getBitWidth(),\n                        V->getPointerDereferenceableBytes(DL, CheckForNonNull,\n                                                          CheckForFreed));\n  if (KnownDerefBytes.getBoolValue() && KnownDerefBytes.uge(Size) &&\n      !CheckForFreed)\n    if (!CheckForNonNull || isKnownNonZero(V, DL, 0, nullptr, CtxI, DT)) {\n      // As we recursed through GEPs to get here, we've incrementally checked\n      // that each step advanced by a multiple of the alignment. If our base is\n      // properly aligned, then the original offset accessed must also be.\n      Type *Ty = V->getType();\n      assert(Ty->isSized() && \"must be sized\");\n      APInt Offset(DL.getTypeStoreSizeInBits(Ty), 0);\n      return isAligned(V, Offset, Alignment, DL);\n    }\n\n  if (CtxI) {\n    /// Look through assumes to see if both dereferencability and alignment can\n    /// be provent by an assume\n    RetainedKnowledge AlignRK;\n    RetainedKnowledge DerefRK;\n    if (getKnowledgeForValue(\n            V, {Attribute::Dereferenceable, Attribute::Alignment}, nullptr,\n            [&](RetainedKnowledge RK, Instruction *Assume, auto) {\n              if (!isValidAssumeForContext(Assume, CtxI))\n                return false;\n              if (RK.AttrKind == Attribute::Alignment)\n                AlignRK = std::max(AlignRK, RK);\n              if (RK.AttrKind == Attribute::Dereferenceable)\n                DerefRK = std::max(DerefRK, RK);\n              if (AlignRK && DerefRK && AlignRK.ArgValue >= Alignment.value() &&\n                  DerefRK.ArgValue >= Size.getZExtValue())\n                return true; // We have found what we needed so we stop looking\n              return false;  // Other assumes may have better information. so\n                             // keep looking\n            }))\n      return true;\n  }\n  /// TODO refactor this function to be able to search independently for\n  /// Dereferencability and Alignment requirements.\n\n  // For GEPs, determine if the indexing lands within the allocated object.\n  if (const GEPOperator *GEP = dyn_cast<GEPOperator>(V)) {\n    const Value *Base = GEP->getPointerOperand();\n\n    APInt Offset(DL.getIndexTypeSizeInBits(GEP->getType()), 0);\n    if (!GEP->accumulateConstantOffset(DL, Offset) || Offset.isNegative() ||\n        !Offset.urem(APInt(Offset.getBitWidth(), Alignment.value()))\n             .isMinValue())\n      return false;\n\n    // If the base pointer is dereferenceable for Offset+Size bytes, then the\n    // GEP (== Base + Offset) is dereferenceable for Size bytes.  If the base\n    // pointer is aligned to Align bytes, and the Offset is divisible by Align\n    // then the GEP (== Base + Offset == k_0 * Align + k_1 * Align) is also\n    // aligned to Align bytes.\n\n    // Offset and Size may have different bit widths if we have visited an\n    // addrspacecast, so we can't do arithmetic directly on the APInt values.\n    return isDereferenceableAndAlignedPointer(\n        Base, Alignment, Offset + Size.sextOrTrunc(Offset.getBitWidth()), DL,\n        CtxI, DT, TLI, Visited, MaxDepth);\n  }\n\n  // For gc.relocate, look through relocations\n  if (const GCRelocateInst *RelocateInst = dyn_cast<GCRelocateInst>(V))\n    return isDereferenceableAndAlignedPointer(RelocateInst->getDerivedPtr(),\n                                              Alignment, Size, DL, CtxI, DT,\n                                              TLI, Visited, MaxDepth);\n\n  if (const AddrSpaceCastInst *ASC = dyn_cast<AddrSpaceCastInst>(V))\n    return isDereferenceableAndAlignedPointer(ASC->getOperand(0), Alignment,\n                                              Size, DL, CtxI, DT, TLI,\n                                              Visited, MaxDepth);\n\n  if (const auto *Call = dyn_cast<CallBase>(V)) {\n    if (auto *RP = getArgumentAliasingToReturnedPointer(Call, true))\n      return isDereferenceableAndAlignedPointer(RP, Alignment, Size, DL, CtxI,\n                                                DT, TLI, Visited, MaxDepth);\n\n    // If we have a call we can't recurse through, check to see if this is an\n    // allocation function for which we can establish an minimum object size.\n    // Such a minimum object size is analogous to a deref_or_null attribute in\n    // that we still need to prove the result non-null at point of use.\n    // NOTE: We can only use the object size as a base fact as we a) need to\n    // prove alignment too, and b) don't want the compile time impact of a\n    // separate recursive walk.\n    ObjectSizeOpts Opts;\n    // TODO: It may be okay to round to align, but that would imply that\n    // accessing slightly out of bounds was legal, and we're currently\n    // inconsistent about that.  For the moment, be conservative.\n    Opts.RoundToAlign = false;\n    Opts.NullIsUnknownSize = true;\n    uint64_t ObjSize;\n    // TODO: Plumb through TLI so that malloc routines and such work.\n    if (getObjectSize(V, ObjSize, DL, nullptr, Opts)) {\n      APInt KnownDerefBytes(Size.getBitWidth(), ObjSize);\n      if (KnownDerefBytes.getBoolValue() && KnownDerefBytes.uge(Size) &&\n          isKnownNonZero(V, DL, 0, nullptr, CtxI, DT) && !V->canBeFreed()) {\n        // As we recursed through GEPs to get here, we've incrementally\n        // checked that each step advanced by a multiple of the alignment. If\n        // our base is properly aligned, then the original offset accessed\n        // must also be. \n        Type *Ty = V->getType();\n        assert(Ty->isSized() && \"must be sized\");\n        APInt Offset(DL.getTypeStoreSizeInBits(Ty), 0);\n        return isAligned(V, Offset, Alignment, DL);\n      }\n    }\n  }\n\n  // If we don't know, assume the worst.\n  return false;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    // TODO: Plumb through TLI so that malloc routines and such work.\n    if (getObjectSize(V, ObjSize, DL, nullptr, Opts)) {\n      APInt KnownDerefBytes(Size.getBitWidth(), ObjSize);\n",
        "src_path": "db357891f0cf76253be3cd75f682b68544a411da___Loads.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/db357891f0cf76253be3cd75f682b68544a411da",
        "commit_msg": "Infer dereferenceability from malloc and friends\n\nHookup TLI when inferring object size from allocation calls. This allows the analysis to prove dereferenceability for known allocation functions (such as malloc/new/etc) in addition to those marked explicitly with the allocsize attribute.\n\nThis is a follow up to 0129cd5 now that the bug fixed by e2c6621e6 is resolved.\n\nAs noted in the test, this relies on being able to prove that there is no free between allocation and context (e.g. hoist location). At the moment, this is handled conservatively. I'm working strengthening out ability to reason about no-free regions separately.\n\nDifferential Revision: https://reviews.llvm.org/D99737",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/LICM/hoist-alloc.ll",
                "patch": "@@ -130,7 +130,8 @@ for.end:\n   ret i8 %res\n }\n \n-; TODO: We can hoist the load in this case.\n+; TODO: We can hoist the load in this case, but only once we have\n+; some form of context sensitive free analysis.\n define i8 @test_hoist_malloc() {\n ; CHECK-LABEL: @test_hoist_malloc(\n ; CHECK-NEXT:  entry:\n@@ -171,18 +172,17 @@ for.end:\n   ret i8 %res\n }\n \n-; TODO: We can hoist the load in this case.\n-define i8 @test_hoist_malloc_leak() {\n+define i8 @test_hoist_malloc_leak() nofree nosync {\n ; CHECK-LABEL: @test_hoist_malloc_leak(\n ; CHECK-NEXT:  entry:\n ; CHECK-NEXT:    [[A_RAW:%.*]] = call nonnull i8* @malloc(i64 32)\n ; CHECK-NEXT:    call void @init(i8* [[A_RAW]])\n ; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr i8, i8* [[A_RAW]], i32 31\n+; CHECK-NEXT:    [[RES:%.*]] = load i8, i8* [[ADDR]], align 1\n ; CHECK-NEXT:    br label [[FOR_BODY:%.*]]\n ; CHECK:       for.body:\n ; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ [[IV_NEXT:%.*]], [[FOR_BODY]] ], [ 0, [[ENTRY:%.*]] ]\n ; CHECK-NEXT:    call void @unknown()\n-; CHECK-NEXT:    [[RES:%.*]] = load i8, i8* [[ADDR]], align 1\n ; CHECK-NEXT:    call void @use(i8 [[RES]])\n ; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1\n ; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[IV_NEXT]], 200"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/LICM/hoist-alloc.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LICM/hoist-alloc.ll\n\n\nTesting Time: 0.39s\n  Failed: 1\n"
    },
    "077bff39d46364035a5dcfa32fc69910ad0975d0___Loads.cpp": {
        "prefix": "static bool isDereferenceableAndAlignedPointer(\n    const Value *V, Align Alignment, const APInt &Size, const DataLayout &DL,\n    const Instruction *CtxI, const DominatorTree *DT,\n    const TargetLibraryInfo *TLI, SmallPtrSetImpl<const Value *> &Visited,\n    unsigned MaxDepth) {\n  assert(V->getType()->isPointerTy() && \"Base must be pointer\");\n\n  // Recursion limit.\n  if (MaxDepth-- == 0)\n    return false;\n\n  // Already visited?  Bail out, we've likely hit unreachable code.\n  if (!Visited.insert(V).second)\n    return false;\n\n  // Note that it is not safe to speculate into a malloc'd region because\n  // malloc may return null.\n\n",
        "suffix": "  if (const BitCastOperator *BC = dyn_cast<BitCastOperator>(V)) {\n    if (BC->getSrcTy()->isPointerTy())\n      return isDereferenceableAndAlignedPointer(\n          BC->getOperand(0), Alignment, Size, DL, CtxI, DT, TLI,\n          Visited, MaxDepth);\n  }\n\n  bool CheckForNonNull, CheckForFreed;\n  APInt KnownDerefBytes(Size.getBitWidth(),\n                        V->getPointerDereferenceableBytes(DL, CheckForNonNull,\n                                                          CheckForFreed));\n  if (KnownDerefBytes.getBoolValue() && KnownDerefBytes.uge(Size) &&\n      !CheckForFreed)\n    if (!CheckForNonNull || isKnownNonZero(V, DL, 0, nullptr, CtxI, DT)) {\n      // As we recursed through GEPs to get here, we've incrementally checked\n      // that each step advanced by a multiple of the alignment. If our base is\n      // properly aligned, then the original offset accessed must also be.\n      Type *Ty = V->getType();\n      assert(Ty->isSized() && \"must be sized\");\n      APInt Offset(DL.getTypeStoreSizeInBits(Ty), 0);\n      return isAligned(V, Offset, Alignment, DL);\n    }\n\n  if (CtxI) {\n    /// Look through assumes to see if both dereferencability and alignment can\n    /// be provent by an assume\n    RetainedKnowledge AlignRK;\n    RetainedKnowledge DerefRK;\n    if (getKnowledgeForValue(\n            V, {Attribute::Dereferenceable, Attribute::Alignment}, nullptr,\n            [&](RetainedKnowledge RK, Instruction *Assume, auto) {\n              if (!isValidAssumeForContext(Assume, CtxI))\n                return false;\n              if (RK.AttrKind == Attribute::Alignment)\n                AlignRK = std::max(AlignRK, RK);\n              if (RK.AttrKind == Attribute::Dereferenceable)\n                DerefRK = std::max(DerefRK, RK);\n              if (AlignRK && DerefRK && AlignRK.ArgValue >= Alignment.value() &&\n                  DerefRK.ArgValue >= Size.getZExtValue())\n                return true; // We have found what we needed so we stop looking\n              return false;  // Other assumes may have better information. so\n                             // keep looking\n            }))\n      return true;\n  }\n  /// TODO refactor this function to be able to search independently for\n  /// Dereferencability and Alignment requirements.\n\n  // For GEPs, determine if the indexing lands within the allocated object.\n  if (const GEPOperator *GEP = dyn_cast<GEPOperator>(V)) {\n    const Value *Base = GEP->getPointerOperand();\n\n    APInt Offset(DL.getIndexTypeSizeInBits(GEP->getType()), 0);\n    if (!GEP->accumulateConstantOffset(DL, Offset) || Offset.isNegative() ||\n        !Offset.urem(APInt(Offset.getBitWidth(), Alignment.value()))\n             .isMinValue())\n      return false;\n\n    // If the base pointer is dereferenceable for Offset+Size bytes, then the\n    // GEP (== Base + Offset) is dereferenceable for Size bytes.  If the base\n    // pointer is aligned to Align bytes, and the Offset is divisible by Align\n    // then the GEP (== Base + Offset == k_0 * Align + k_1 * Align) is also\n    // aligned to Align bytes.\n\n    // Offset and Size may have different bit widths if we have visited an\n    // addrspacecast, so we can't do arithmetic directly on the APInt values.\n    return isDereferenceableAndAlignedPointer(\n        Base, Alignment, Offset + Size.sextOrTrunc(Offset.getBitWidth()), DL,\n        CtxI, DT, TLI, Visited, MaxDepth);\n  }\n\n  // For gc.relocate, look through relocations\n  if (const GCRelocateInst *RelocateInst = dyn_cast<GCRelocateInst>(V))\n    return isDereferenceableAndAlignedPointer(RelocateInst->getDerivedPtr(),\n                                              Alignment, Size, DL, CtxI, DT,\n                                              TLI, Visited, MaxDepth);\n\n  if (const AddrSpaceCastInst *ASC = dyn_cast<AddrSpaceCastInst>(V))\n    return isDereferenceableAndAlignedPointer(ASC->getOperand(0), Alignment,\n                                              Size, DL, CtxI, DT, TLI,\n                                              Visited, MaxDepth);\n\n  if (const auto *Call = dyn_cast<CallBase>(V)) {\n    if (auto *RP = getArgumentAliasingToReturnedPointer(Call, true))\n      return isDereferenceableAndAlignedPointer(RP, Alignment, Size, DL, CtxI,\n                                                DT, TLI, Visited, MaxDepth);\n\n    // If we have a call we can't recurse through, check to see if this is an\n    // allocation function for which we can establish an minimum object size.\n    // Such a minimum object size is analogous to a deref_or_null attribute in\n    // that we still need to prove the result non-null at point of use.\n    // NOTE: We can only use the object size as a base fact as we a) need to\n    // prove alignment too, and b) don't want the compile time impact of a\n    // separate recursive walk.\n    ObjectSizeOpts Opts;\n    // TODO: It may be okay to round to align, but that would imply that\n    // accessing slightly out of bounds was legal, and we're currently\n    // inconsistent about that.  For the moment, be conservative.\n    Opts.RoundToAlign = false;\n    Opts.NullIsUnknownSize = true;\n    uint64_t ObjSize;\n    if (getObjectSize(V, ObjSize, DL, TLI, Opts)) {\n      APInt KnownDerefBytes(Size.getBitWidth(), ObjSize);\n      if (KnownDerefBytes.getBoolValue() && KnownDerefBytes.uge(Size) &&\n          isKnownNonZero(V, DL, 0, nullptr, CtxI, DT) && !V->canBeFreed()) {\n        // As we recursed through GEPs to get here, we've incrementally\n        // checked that each step advanced by a multiple of the alignment. If\n        // our base is properly aligned, then the original offset accessed\n        // must also be. \n        Type *Ty = V->getType();\n        assert(Ty->isSized() && \"must be sized\");\n        APInt Offset(DL.getTypeStoreSizeInBits(Ty), 0);\n        return isAligned(V, Offset, Alignment, DL);\n      }\n    }\n  }\n\n  // If we don't know, assume the worst.\n  return false;\n}\n",
        "start": 44,
        "end": 182,
        "buggy": "static bool isDereferenceableAndAlignedPointer(\n    const Value *V, Align Alignment, const APInt &Size, const DataLayout &DL,\n    const Instruction *CtxI, const DominatorTree *DT,\n    const TargetLibraryInfo *TLI, SmallPtrSetImpl<const Value *> &Visited,\n    unsigned MaxDepth) {\n  assert(V->getType()->isPointerTy() && \"Base must be pointer\");\n\n  // Recursion limit.\n  if (MaxDepth-- == 0)\n    return false;\n\n  // Already visited?  Bail out, we've likely hit unreachable code.\n  if (!Visited.insert(V).second)\n    return false;\n\n  // Note that it is not safe to speculate into a malloc'd region because\n  // malloc may return null.\n\n  // bitcast instructions are no-ops as far as dereferenceability is concerned.\n  if (const BitCastOperator *BC = dyn_cast<BitCastOperator>(V)) {\n    if (BC->getSrcTy()->isPointerTy())\n      return isDereferenceableAndAlignedPointer(\n          BC->getOperand(0), Alignment, Size, DL, CtxI, DT, TLI,\n          Visited, MaxDepth);\n  }\n\n  bool CheckForNonNull, CheckForFreed;\n  APInt KnownDerefBytes(Size.getBitWidth(),\n                        V->getPointerDereferenceableBytes(DL, CheckForNonNull,\n                                                          CheckForFreed));\n  if (KnownDerefBytes.getBoolValue() && KnownDerefBytes.uge(Size) &&\n      !CheckForFreed)\n    if (!CheckForNonNull || isKnownNonZero(V, DL, 0, nullptr, CtxI, DT)) {\n      // As we recursed through GEPs to get here, we've incrementally checked\n      // that each step advanced by a multiple of the alignment. If our base is\n      // properly aligned, then the original offset accessed must also be.\n      Type *Ty = V->getType();\n      assert(Ty->isSized() && \"must be sized\");\n      APInt Offset(DL.getTypeStoreSizeInBits(Ty), 0);\n      return isAligned(V, Offset, Alignment, DL);\n    }\n\n  if (CtxI) {\n    /// Look through assumes to see if both dereferencability and alignment can\n    /// be provent by an assume\n    RetainedKnowledge AlignRK;\n    RetainedKnowledge DerefRK;\n    if (getKnowledgeForValue(\n            V, {Attribute::Dereferenceable, Attribute::Alignment}, nullptr,\n            [&](RetainedKnowledge RK, Instruction *Assume, auto) {\n              if (!isValidAssumeForContext(Assume, CtxI))\n                return false;\n              if (RK.AttrKind == Attribute::Alignment)\n                AlignRK = std::max(AlignRK, RK);\n              if (RK.AttrKind == Attribute::Dereferenceable)\n                DerefRK = std::max(DerefRK, RK);\n              if (AlignRK && DerefRK && AlignRK.ArgValue >= Alignment.value() &&\n                  DerefRK.ArgValue >= Size.getZExtValue())\n                return true; // We have found what we needed so we stop looking\n              return false;  // Other assumes may have better information. so\n                             // keep looking\n            }))\n      return true;\n  }\n  /// TODO refactor this function to be able to search independently for\n  /// Dereferencability and Alignment requirements.\n\n  // For GEPs, determine if the indexing lands within the allocated object.\n  if (const GEPOperator *GEP = dyn_cast<GEPOperator>(V)) {\n    const Value *Base = GEP->getPointerOperand();\n\n    APInt Offset(DL.getIndexTypeSizeInBits(GEP->getType()), 0);\n    if (!GEP->accumulateConstantOffset(DL, Offset) || Offset.isNegative() ||\n        !Offset.urem(APInt(Offset.getBitWidth(), Alignment.value()))\n             .isMinValue())\n      return false;\n\n    // If the base pointer is dereferenceable for Offset+Size bytes, then the\n    // GEP (== Base + Offset) is dereferenceable for Size bytes.  If the base\n    // pointer is aligned to Align bytes, and the Offset is divisible by Align\n    // then the GEP (== Base + Offset == k_0 * Align + k_1 * Align) is also\n    // aligned to Align bytes.\n\n    // Offset and Size may have different bit widths if we have visited an\n    // addrspacecast, so we can't do arithmetic directly on the APInt values.\n    return isDereferenceableAndAlignedPointer(\n        Base, Alignment, Offset + Size.sextOrTrunc(Offset.getBitWidth()), DL,\n        CtxI, DT, TLI, Visited, MaxDepth);\n  }\n\n  // For gc.relocate, look through relocations\n  if (const GCRelocateInst *RelocateInst = dyn_cast<GCRelocateInst>(V))\n    return isDereferenceableAndAlignedPointer(RelocateInst->getDerivedPtr(),\n                                              Alignment, Size, DL, CtxI, DT,\n                                              TLI, Visited, MaxDepth);\n\n  if (const AddrSpaceCastInst *ASC = dyn_cast<AddrSpaceCastInst>(V))\n    return isDereferenceableAndAlignedPointer(ASC->getOperand(0), Alignment,\n                                              Size, DL, CtxI, DT, TLI,\n                                              Visited, MaxDepth);\n\n  if (const auto *Call = dyn_cast<CallBase>(V)) {\n    if (auto *RP = getArgumentAliasingToReturnedPointer(Call, true))\n      return isDereferenceableAndAlignedPointer(RP, Alignment, Size, DL, CtxI,\n                                                DT, TLI, Visited, MaxDepth);\n\n    // If we have a call we can't recurse through, check to see if this is an\n    // allocation function for which we can establish an minimum object size.\n    // Such a minimum object size is analogous to a deref_or_null attribute in\n    // that we still need to prove the result non-null at point of use.\n    // NOTE: We can only use the object size as a base fact as we a) need to\n    // prove alignment too, and b) don't want the compile time impact of a\n    // separate recursive walk.\n    ObjectSizeOpts Opts;\n    // TODO: It may be okay to round to align, but that would imply that\n    // accessing slightly out of bounds was legal, and we're currently\n    // inconsistent about that.  For the moment, be conservative.\n    Opts.RoundToAlign = false;\n    Opts.NullIsUnknownSize = true;\n    uint64_t ObjSize;\n    if (getObjectSize(V, ObjSize, DL, TLI, Opts)) {\n      APInt KnownDerefBytes(Size.getBitWidth(), ObjSize);\n      if (KnownDerefBytes.getBoolValue() && KnownDerefBytes.uge(Size) &&\n          isKnownNonZero(V, DL, 0, nullptr, CtxI, DT) && !V->canBeFreed()) {\n        // As we recursed through GEPs to get here, we've incrementally\n        // checked that each step advanced by a multiple of the alignment. If\n        // our base is properly aligned, then the original offset accessed\n        // must also be. \n        Type *Ty = V->getType();\n        assert(Ty->isSized() && \"must be sized\");\n        APInt Offset(DL.getTypeStoreSizeInBits(Ty), 0);\n        return isAligned(V, Offset, Alignment, DL);\n      }\n    }\n  }\n\n  // If we don't know, assume the worst.\n  return false;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  // bitcast instructions are no-ops as far as dereferenceability is concerned.\n",
        "src_path": "077bff39d46364035a5dcfa32fc69910ad0975d0___Loads.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/077bff39d46364035a5dcfa32fc69910ad0975d0",
        "commit_msg": "[Analysis] isDereferenceableAndAlignedPointer(): recurse into select's hands\n\nBy doing this within the method itself,\nwe support traversing multiple levels of selects (TODO: PHI's),\nfixing the SROA `std::clamp()` testcase.\n\nFixes https://bugs.llvm.org/show_bug.cgi?id=47271\nMostly fixes https://bugs.llvm.org/show_bug.cgi?id=49909",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/SROA/std-clamp.ll",
                "patch": "@@ -6,18 +6,14 @@ target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16\n define float @_Z8stdclampfff(float %x, float %lo, float %hi) {\n ; CHECK-LABEL: @_Z8stdclampfff(\n ; CHECK-NEXT:  bb:\n-; CHECK-NEXT:    [[I:%.*]] = alloca float, align 4\n-; CHECK-NEXT:    [[I3:%.*]] = alloca float, align 4\n ; CHECK-NEXT:    [[I4:%.*]] = alloca float, align 4\n-; CHECK-NEXT:    store float [[X:%.*]], float* [[I]], align 4\n-; CHECK-NEXT:    store float [[LO:%.*]], float* [[I3]], align 4\n ; CHECK-NEXT:    store float [[HI:%.*]], float* [[I4]], align 4\n-; CHECK-NEXT:    [[I5:%.*]] = fcmp fast olt float [[X]], [[LO]]\n+; CHECK-NEXT:    [[I5:%.*]] = fcmp fast olt float [[X:%.*]], [[LO:%.*]]\n ; CHECK-NEXT:    [[I6:%.*]] = fcmp fast olt float [[HI]], [[X]]\n-; CHECK-NEXT:    [[I7:%.*]] = select i1 [[I6]], float* [[I4]], float* [[I]]\n-; CHECK-NEXT:    [[I8:%.*]] = select i1 [[I5]], float* [[I3]], float* [[I7]]\n-; CHECK-NEXT:    [[I9:%.*]] = load float, float* [[I8]], align 4\n-; CHECK-NEXT:    ret float [[I9]]\n+; CHECK-NEXT:    [[I9_SROA_SPECULATE_LOAD_FALSE_SROA_SPECULATE_LOAD_TRUE:%.*]] = load float, float* [[I4]], align 4\n+; CHECK-NEXT:    [[I9_SROA_SPECULATE_LOAD_FALSE_SROA_SPECULATED:%.*]] = select i1 [[I6]], float [[I9_SROA_SPECULATE_LOAD_FALSE_SROA_SPECULATE_LOAD_TRUE]], float [[X]]\n+; CHECK-NEXT:    [[I9_SROA_SPECULATED:%.*]] = select i1 [[I5]], float [[LO]], float [[I9_SROA_SPECULATE_LOAD_FALSE_SROA_SPECULATED]]\n+; CHECK-NEXT:    ret float [[I9_SROA_SPECULATED]]\n ;\n bb:\n   %i = alloca float, align 4"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/SROA/std-clamp.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SROA/std-clamp.ll\n\n\nTesting Time: 0.35s\n  Failed: 1\n"
    },
    "3f8be15f2911a3d3645030911be83a115bfe9e5c___LoopInterchange.cpp": {
        "prefix": "static void moveLCSSAPhis(BasicBlock *InnerExit, BasicBlock *InnerHeader,\n                          BasicBlock *InnerLatch, BasicBlock *OuterHeader,\n                          BasicBlock *OuterLatch, BasicBlock *OuterExit,\n                          Loop *InnerLoop, LoopInfo *LI) {\n\n  // Deal with LCSSA PHI nodes in the exit block of the inner loop, that are\n  // defined either in the header or latch. Those blocks will become header and\n  // latch of the new outer loop, and the only possible users can PHI nodes\n  // in the exit block of the loop nest or the outer loop header (reduction\n  // PHIs, in that case, the incoming value must be defined in the inner loop\n  // header). We can just substitute the user with the incoming value and remove\n  // the PHI.\n  for (PHINode &P : make_early_inc_range(InnerExit->phis())) {\n    assert(P.getNumIncomingValues() == 1 &&\n           \"Only loops with a single exit are supported!\");\n\n    // Incoming values are guaranteed be instructions currently.\n    auto IncI = cast<Instruction>(P.getIncomingValueForBlock(InnerLatch));\n    // Skip phis with incoming values from the inner loop body, excluding the\n    // header and latch.\n    if (IncI->getParent() != InnerLatch && IncI->getParent() != InnerHeader)\n      continue;\n\n    assert(all_of(P.users(),\n                  [OuterHeader, OuterExit, IncI, InnerHeader](User *U) {\n                    return (cast<PHINode>(U)->getParent() == OuterHeader &&\n                            IncI->getParent() == InnerHeader) ||\n                           cast<PHINode>(U)->getParent() == OuterExit;\n                  }) &&\n           \"Can only replace phis iff the uses are in the loop nest exit or \"\n           \"the incoming value is defined in the inner header (it will \"\n           \"dominate all loop blocks after interchanging)\");\n    P.replaceAllUsesWith(IncI);\n    P.eraseFromParent();\n  }\n\n  SmallVector<PHINode *, 8> LcssaInnerExit;\n  for (PHINode &P : InnerExit->phis())\n    LcssaInnerExit.push_back(&P);\n\n  SmallVector<PHINode *, 8> LcssaInnerLatch;\n  for (PHINode &P : InnerLatch->phis())\n    LcssaInnerLatch.push_back(&P);\n\n  // Lcssa PHIs for values used outside the inner loop are in InnerExit.\n  // If a PHI node has users outside of InnerExit, it has a use outside the\n  // interchanged loop and we have to preserve it. We move these to\n  // InnerLatch, which will become the new exit block for the innermost\n  // loop after interchanging.\n  for (PHINode *P : LcssaInnerExit)\n    P->moveBefore(InnerLatch->getFirstNonPHI());\n\n  // If the inner loop latch contains LCSSA PHIs, those come from a child loop\n  // and we have to move them to the new inner latch.\n  for (PHINode *P : LcssaInnerLatch)\n    P->moveBefore(InnerExit->getFirstNonPHI());\n\n  // Deal with LCSSA PHI nodes in the loop nest exit block. For PHIs that have\n  // incoming values defined in the outer loop, we have to add a new PHI\n  // in the inner loop latch, which became the exit block of the outer loop,\n  // after interchanging.\n  if (OuterExit) {\n    for (PHINode &P : OuterExit->phis()) {\n      if (P.getNumIncomingValues() != 1)\n        continue;\n      // Skip Phis with incoming values defined in the inner loop. Those should\n      // already have been updated.\n      auto I = dyn_cast<Instruction>(P.getIncomingValue(0));\n      if (!I || LI->getLoopFor(I->getParent()) == InnerLoop)\n        continue;\n\n      PHINode *NewPhi = dyn_cast<PHINode>(P.clone());\n      NewPhi->setIncomingValue(0, P.getIncomingValue(0));\n      NewPhi->setIncomingBlock(0, OuterLatch);\n",
        "suffix": "      P.setIncomingValue(0, NewPhi);\n    }\n  }\n\n  // Now adjust the incoming blocks for the LCSSA PHIs.\n  // For PHIs moved from Inner's exit block, we need to replace Inner's latch\n  // with the new latch.\n  InnerLatch->replacePhiUsesWith(InnerLatch, OuterLatch);\n}\n",
        "start": 1458,
        "end": 1541,
        "buggy": "static void moveLCSSAPhis(BasicBlock *InnerExit, BasicBlock *InnerHeader,\n                          BasicBlock *InnerLatch, BasicBlock *OuterHeader,\n                          BasicBlock *OuterLatch, BasicBlock *OuterExit,\n                          Loop *InnerLoop, LoopInfo *LI) {\n\n  // Deal with LCSSA PHI nodes in the exit block of the inner loop, that are\n  // defined either in the header or latch. Those blocks will become header and\n  // latch of the new outer loop, and the only possible users can PHI nodes\n  // in the exit block of the loop nest or the outer loop header (reduction\n  // PHIs, in that case, the incoming value must be defined in the inner loop\n  // header). We can just substitute the user with the incoming value and remove\n  // the PHI.\n  for (PHINode &P : make_early_inc_range(InnerExit->phis())) {\n    assert(P.getNumIncomingValues() == 1 &&\n           \"Only loops with a single exit are supported!\");\n\n    // Incoming values are guaranteed be instructions currently.\n    auto IncI = cast<Instruction>(P.getIncomingValueForBlock(InnerLatch));\n    // Skip phis with incoming values from the inner loop body, excluding the\n    // header and latch.\n    if (IncI->getParent() != InnerLatch && IncI->getParent() != InnerHeader)\n      continue;\n\n    assert(all_of(P.users(),\n                  [OuterHeader, OuterExit, IncI, InnerHeader](User *U) {\n                    return (cast<PHINode>(U)->getParent() == OuterHeader &&\n                            IncI->getParent() == InnerHeader) ||\n                           cast<PHINode>(U)->getParent() == OuterExit;\n                  }) &&\n           \"Can only replace phis iff the uses are in the loop nest exit or \"\n           \"the incoming value is defined in the inner header (it will \"\n           \"dominate all loop blocks after interchanging)\");\n    P.replaceAllUsesWith(IncI);\n    P.eraseFromParent();\n  }\n\n  SmallVector<PHINode *, 8> LcssaInnerExit;\n  for (PHINode &P : InnerExit->phis())\n    LcssaInnerExit.push_back(&P);\n\n  SmallVector<PHINode *, 8> LcssaInnerLatch;\n  for (PHINode &P : InnerLatch->phis())\n    LcssaInnerLatch.push_back(&P);\n\n  // Lcssa PHIs for values used outside the inner loop are in InnerExit.\n  // If a PHI node has users outside of InnerExit, it has a use outside the\n  // interchanged loop and we have to preserve it. We move these to\n  // InnerLatch, which will become the new exit block for the innermost\n  // loop after interchanging.\n  for (PHINode *P : LcssaInnerExit)\n    P->moveBefore(InnerLatch->getFirstNonPHI());\n\n  // If the inner loop latch contains LCSSA PHIs, those come from a child loop\n  // and we have to move them to the new inner latch.\n  for (PHINode *P : LcssaInnerLatch)\n    P->moveBefore(InnerExit->getFirstNonPHI());\n\n  // Deal with LCSSA PHI nodes in the loop nest exit block. For PHIs that have\n  // incoming values defined in the outer loop, we have to add a new PHI\n  // in the inner loop latch, which became the exit block of the outer loop,\n  // after interchanging.\n  if (OuterExit) {\n    for (PHINode &P : OuterExit->phis()) {\n      if (P.getNumIncomingValues() != 1)\n        continue;\n      // Skip Phis with incoming values defined in the inner loop. Those should\n      // already have been updated.\n      auto I = dyn_cast<Instruction>(P.getIncomingValue(0));\n      if (!I || LI->getLoopFor(I->getParent()) == InnerLoop)\n        continue;\n\n      PHINode *NewPhi = dyn_cast<PHINode>(P.clone());\n      NewPhi->setIncomingValue(0, P.getIncomingValue(0));\n      NewPhi->setIncomingBlock(0, OuterLatch);\n      NewPhi->insertBefore(InnerLatch->getFirstNonPHI());\n      P.setIncomingValue(0, NewPhi);\n    }\n  }\n\n  // Now adjust the incoming blocks for the LCSSA PHIs.\n  // For PHIs moved from Inner's exit block, we need to replace Inner's latch\n  // with the new latch.\n  InnerLatch->replacePhiUsesWith(InnerLatch, OuterLatch);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      NewPhi->insertBefore(InnerLatch->getFirstNonPHI());\n",
        "src_path": "3f8be15f2911a3d3645030911be83a115bfe9e5c___LoopInterchange.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/3f8be15f2911a3d3645030911be83a115bfe9e5c",
        "commit_msg": "[LoopInterchange] Handle lcssa PHIs with multiple predecessors\n\nThis is a bugfix in the transformation phase.\n\nIf the original outer loop header branches to both the inner loop\n(header) and the outer loop latch, and if there is an lcssa PHI\nnode outside the loop nest, then after interchange the new outer latch\nwill have an lcssa PHI node inserted which has two predecessors, i.e.,\nthe original outer header and the original outer latch. Currently\nthe transformation assumes it has only one predecessor (the original\nouter latch) and crashes, since the inserted lcssa PHI node does\nnot take both predecessors as incoming BBs.\n\nReviewed By: Whitney\n\nDifferential Revision: https://reviews.llvm.org/D100792",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/LoopInterchange/lcssa.ll",
                "patch": "@@ -298,3 +298,35 @@ for.exit:                                         ; preds = %outer.inc\n for.end16:                                        ; preds = %for.exit\n   ret void\n }\n+\n+; Should not crash when the outer header branches to\n+; both the inner loop and the outer latch, and there\n+; is an lcssa phi node outside the loopnest.\n+; REMARK: Interchanged\n+; REMARK-NEXT: lcssa_08\n+define i64 @lcssa_08([100 x [100 x i64]]* %Arr) {\n+entry:\n+  br label %for1.header\n+\n+for1.header:                                         ; preds = %for1.inc, %entry\n+  %indvars.iv23 = phi i64 [ 0, %entry ], [ %indvars.iv.next24, %for1.inc ]\n+  br i1 undef, label %for2, label %for1.inc\n+\n+for2:                                        ; preds = %for2, %for1.header\n+  %indvars.iv = phi i64 [ 0, %for1.header ], [ %indvars.iv.next.3, %for2 ]\n+  %arrayidx = getelementptr inbounds [100 x [100 x i64]], [100 x [100 x i64]]* %Arr, i64 0, i64 %indvars.iv, i64 %indvars.iv23\n+  %lv = load i64, i64* %arrayidx, align 4\n+  %indvars.iv.next.3 = add nuw nsw i64 %indvars.iv, 1\n+  %exit1 = icmp eq i64 %indvars.iv.next.3, 100\n+  br i1 %exit1, label %for1.inc, label %for2\n+\n+for1.inc:                                ; preds = %for2, %for1.header\n+  %indvars.iv.next24 = add nuw nsw i64 %indvars.iv23, 1\n+  %exit2 = icmp eq i64 %indvars.iv.next24, 100\n+  br i1 %exit2, label %for1.loopexit, label %for1.header\n+\n+for1.loopexit:                                 ; preds = %for1.inc\n+  %sum.outer.lcssa = phi i64 [ %indvars.iv23, %for1.inc ]\n+  ret i64 %sum.outer.lcssa\n+}\n+"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/LoopInterchange/lcssa.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopInterchange/lcssa.ll\n\n\nTesting Time: 1.72s\n  Failed: 1\n"
    },
    "fae7debadcea335d4aaddee82406a8d10426e730___ControlHeightReduction.cpp": {
        "prefix": "CHRScope * CHR::findScope(Region *R) {\n  CHRScope *Result = nullptr;\n  BasicBlock *Entry = R->getEntry();\n  BasicBlock *Exit = R->getExit();  // null if top level.\n  assert(Entry && \"Entry must not be null\");\n  assert((Exit == nullptr) == (R->isTopLevelRegion()) &&\n         \"Only top level region has a null exit\");\n  if (Entry)\n    CHR_DEBUG(dbgs() << \"Entry \" << Entry->getName() << \"\\n\");\n  else\n    CHR_DEBUG(dbgs() << \"Entry null\\n\");\n  if (Exit)\n    CHR_DEBUG(dbgs() << \"Exit \" << Exit->getName() << \"\\n\");\n  else\n    CHR_DEBUG(dbgs() << \"Exit null\\n\");\n  // Exclude cases where Entry is part of a subregion (hence it doesn't belong\n  // to this region).\n  bool EntryInSubregion = RI.getRegionFor(Entry) != R;\n  if (EntryInSubregion)\n    return nullptr;\n  // Exclude loops\n  for (BasicBlock *Pred : predecessors(Entry))\n    if (R->contains(Pred))\n      return nullptr;\n",
        "suffix": "    // Try to find an if-then block (check if R is an if-then).\n    // if (cond) {\n    //  ...\n    // }\n    auto *BI = dyn_cast<BranchInst>(Entry->getTerminator());\n    if (BI)\n      CHR_DEBUG(dbgs() << \"BI.isConditional \" << BI->isConditional() << \"\\n\");\n    else\n      CHR_DEBUG(dbgs() << \"BI null\\n\");\n    if (BI && BI->isConditional()) {\n      BasicBlock *S0 = BI->getSuccessor(0);\n      BasicBlock *S1 = BI->getSuccessor(1);\n      CHR_DEBUG(dbgs() << \"S0 \" << S0->getName() << \"\\n\");\n      CHR_DEBUG(dbgs() << \"S1 \" << S1->getName() << \"\\n\");\n      if (S0 != S1 && (S0 == Exit || S1 == Exit)) {\n        RegInfo RI(R);\n        RI.HasBranch = checkBiasedBranch(\n            BI, R, TrueBiasedRegionsGlobal, FalseBiasedRegionsGlobal,\n            BranchBiasMap);\n        Result = new CHRScope(RI);\n        Scopes.insert(Result);\n        CHR_DEBUG(dbgs() << \"Found a region with a branch\\n\");\n        ++Stats.NumBranches;\n        if (!RI.HasBranch) {\n          ORE.emit([&]() {\n            return OptimizationRemarkMissed(DEBUG_TYPE, \"BranchNotBiased\", BI)\n                << \"Branch not biased\";\n          });\n        }\n      }\n    }\n  }\n  {\n    // Try to look for selects in the direct child blocks (as opposed to in\n    // subregions) of R.\n    // ...\n    // if (..) { // Some subregion\n    //   ...\n    // }\n    // if (..) { // Some subregion\n    //   ...\n    // }\n    // ...\n    // a = cond ? b : c;\n    // ...\n    SmallVector<SelectInst *, 8> Selects;\n    for (RegionNode *E : R->elements()) {\n      if (E->isSubRegion())\n        continue;\n      // This returns the basic block of E if E is a direct child of R (not a\n      // subregion.)\n      BasicBlock *BB = E->getEntry();\n      // Need to push in the order to make it easier to find the first Select\n      // later.\n      for (Instruction &I : *BB) {\n        if (auto *SI = dyn_cast<SelectInst>(&I)) {\n          Selects.push_back(SI);\n          ++Stats.NumBranches;\n        }\n      }\n    }\n    if (Selects.size() > 0) {\n      auto AddSelects = [&](RegInfo &RI) {\n        for (auto *SI : Selects)\n          if (checkBiasedSelect(SI, RI.R,\n                                TrueBiasedSelectsGlobal,\n                                FalseBiasedSelectsGlobal,\n                                SelectBiasMap))\n            RI.Selects.push_back(SI);\n          else\n            ORE.emit([&]() {\n              return OptimizationRemarkMissed(DEBUG_TYPE, \"SelectNotBiased\", SI)\n                  << \"Select not biased\";\n            });\n      };\n      if (!Result) {\n        CHR_DEBUG(dbgs() << \"Found a select-only region\\n\");\n        RegInfo RI(R);\n        AddSelects(RI);\n        Result = new CHRScope(RI);\n        Scopes.insert(Result);\n      } else {\n        CHR_DEBUG(dbgs() << \"Found select(s) in a region with a branch\\n\");\n        AddSelects(Result->RegInfos[0]);\n      }\n    }\n  }\n\n  if (Result) {\n    checkScopeHoistable(Result);\n  }\n  return Result;\n}\n",
        "start": 746,
        "end": 863,
        "buggy": "CHRScope * CHR::findScope(Region *R) {\n  CHRScope *Result = nullptr;\n  BasicBlock *Entry = R->getEntry();\n  BasicBlock *Exit = R->getExit();  // null if top level.\n  assert(Entry && \"Entry must not be null\");\n  assert((Exit == nullptr) == (R->isTopLevelRegion()) &&\n         \"Only top level region has a null exit\");\n  if (Entry)\n    CHR_DEBUG(dbgs() << \"Entry \" << Entry->getName() << \"\\n\");\n  else\n    CHR_DEBUG(dbgs() << \"Entry null\\n\");\n  if (Exit)\n    CHR_DEBUG(dbgs() << \"Exit \" << Exit->getName() << \"\\n\");\n  else\n    CHR_DEBUG(dbgs() << \"Exit null\\n\");\n  // Exclude cases where Entry is part of a subregion (hence it doesn't belong\n  // to this region).\n  bool EntryInSubregion = RI.getRegionFor(Entry) != R;\n  if (EntryInSubregion)\n    return nullptr;\n  // Exclude loops\n  for (BasicBlock *Pred : predecessors(Entry))\n    if (R->contains(Pred))\n      return nullptr;\n  if (Exit) {\n    // Try to find an if-then block (check if R is an if-then).\n    // if (cond) {\n    //  ...\n    // }\n    auto *BI = dyn_cast<BranchInst>(Entry->getTerminator());\n    if (BI)\n      CHR_DEBUG(dbgs() << \"BI.isConditional \" << BI->isConditional() << \"\\n\");\n    else\n      CHR_DEBUG(dbgs() << \"BI null\\n\");\n    if (BI && BI->isConditional()) {\n      BasicBlock *S0 = BI->getSuccessor(0);\n      BasicBlock *S1 = BI->getSuccessor(1);\n      CHR_DEBUG(dbgs() << \"S0 \" << S0->getName() << \"\\n\");\n      CHR_DEBUG(dbgs() << \"S1 \" << S1->getName() << \"\\n\");\n      if (S0 != S1 && (S0 == Exit || S1 == Exit)) {\n        RegInfo RI(R);\n        RI.HasBranch = checkBiasedBranch(\n            BI, R, TrueBiasedRegionsGlobal, FalseBiasedRegionsGlobal,\n            BranchBiasMap);\n        Result = new CHRScope(RI);\n        Scopes.insert(Result);\n        CHR_DEBUG(dbgs() << \"Found a region with a branch\\n\");\n        ++Stats.NumBranches;\n        if (!RI.HasBranch) {\n          ORE.emit([&]() {\n            return OptimizationRemarkMissed(DEBUG_TYPE, \"BranchNotBiased\", BI)\n                << \"Branch not biased\";\n          });\n        }\n      }\n    }\n  }\n  {\n    // Try to look for selects in the direct child blocks (as opposed to in\n    // subregions) of R.\n    // ...\n    // if (..) { // Some subregion\n    //   ...\n    // }\n    // if (..) { // Some subregion\n    //   ...\n    // }\n    // ...\n    // a = cond ? b : c;\n    // ...\n    SmallVector<SelectInst *, 8> Selects;\n    for (RegionNode *E : R->elements()) {\n      if (E->isSubRegion())\n        continue;\n      // This returns the basic block of E if E is a direct child of R (not a\n      // subregion.)\n      BasicBlock *BB = E->getEntry();\n      // Need to push in the order to make it easier to find the first Select\n      // later.\n      for (Instruction &I : *BB) {\n        if (auto *SI = dyn_cast<SelectInst>(&I)) {\n          Selects.push_back(SI);\n          ++Stats.NumBranches;\n        }\n      }\n    }\n    if (Selects.size() > 0) {\n      auto AddSelects = [&](RegInfo &RI) {\n        for (auto *SI : Selects)\n          if (checkBiasedSelect(SI, RI.R,\n                                TrueBiasedSelectsGlobal,\n                                FalseBiasedSelectsGlobal,\n                                SelectBiasMap))\n            RI.Selects.push_back(SI);\n          else\n            ORE.emit([&]() {\n              return OptimizationRemarkMissed(DEBUG_TYPE, \"SelectNotBiased\", SI)\n                  << \"Select not biased\";\n            });\n      };\n      if (!Result) {\n        CHR_DEBUG(dbgs() << \"Found a select-only region\\n\");\n        RegInfo RI(R);\n        AddSelects(RI);\n        Result = new CHRScope(RI);\n        Scopes.insert(Result);\n      } else {\n        CHR_DEBUG(dbgs() << \"Found select(s) in a region with a branch\\n\");\n        AddSelects(Result->RegInfos[0]);\n      }\n    }\n  }\n\n  if (Result) {\n    checkScopeHoistable(Result);\n  }\n  return Result;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  if (Exit) {\n",
        "src_path": "fae7debadcea335d4aaddee82406a8d10426e730___ControlHeightReduction.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/fae7debadcea335d4aaddee82406a8d10426e730",
        "commit_msg": "[CHR] Don't run ControlHeightReduction if any BB has address taken\n\nThis patch is to address https://bugs.llvm.org/show_bug.cgi?id=50610.\nIn computed goto pattern, there are usually a list of basic blocks that are all targets of indirectbr instruction, and each basic block also has address taken and stored in a variable.\nCHR pass could potentially clone these basic blocks, which would generate a cloned version of the indirectbr and clonved version of all basic blocks in the list.\nHowever these basic blocks will not have their addresses taken and stored anywhere. So latter SimplifyCFG pass will simply remove all tehse cloned basic blocks, resulting in incorrect code.\nTo fix this, when searching for scopes, we skip scopes that contains BBs with addresses taken.\nAdded a few test cases.\n\nReviewed By: aeubanks, wenlei, hoy\n\nDifferential Revision: https://reviews.llvm.org/D103867",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/PGOProfile/chr.ll",
                "patch": "@@ -2527,6 +2527,122 @@ bb3:\n   ret void\n }\n \n+; Test that chr will skip this function when addresses are taken on basic blocks.\n+@gototable1 = weak_odr dso_local local_unnamed_addr constant [2 x i8*] [i8* blockaddress(@test_chr_with_bbs_address_taken1, %bb3), i8* blockaddress(@test_chr_with_bbs_address_taken1, %bb3)]\n+define void @test_chr_with_bbs_address_taken1(i32* %i) !prof !14 {\n+; CHECK-LABEL: @test_chr_with_bbs_address_taken1(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* [[I:%.*]], align 4\n+; CHECK-NEXT:    [[TMP1:%.*]] = and i32 [[TMP0]], 1\n+; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[TMP1]], 0\n+; CHECK-NEXT:    br i1 [[TMP2]], label [[BB1:%.*]], label [[BB0:%.*]], !prof [[PROF16]]\n+; CHECK:       bb0:\n+; CHECK-NEXT:    call void @foo()\n+; CHECK-NEXT:    br label [[BB1]]\n+; CHECK:       bb1:\n+; CHECK-NEXT:    [[TMP3:%.*]] = and i32 [[TMP0]], 2\n+; CHECK-NEXT:    [[TMP4:%.*]] = icmp eq i32 [[TMP3]], 0\n+; CHECK-NEXT:    br i1 [[TMP4]], label [[BB4:%.*]], label [[BB2:%.*]], !prof [[PROF16]]\n+; CHECK:       bb2:\n+; CHECK-NEXT:    call void @foo()\n+; CHECK-NEXT:    br label [[BB4]]\n+; CHECK:       bb4:\n+; CHECK-NEXT:    ret void\n+;\n+entry:\n+  %0 = load i32, i32* %i\n+  %1 = and i32 %0, 1\n+  %2 = icmp eq i32 %1, 0\n+  br i1 %2, label %bb1, label %bb0, !prof !15\n+\n+bb0:\n+  call void @foo()\n+  br label %bb1\n+\n+bb1:\n+  %3 = and i32 %0, 2\n+  %4 = icmp eq i32 %3, 0\n+  br i1 %4, label %bb4, label %bb2, !prof !15\n+\n+bb2:\n+  call void @foo()\n+  %pc = bitcast i32* %i to i8*\n+  indirectbr i8* %pc, [label %bb3, label %bb3]\n+\n+bb3:\n+  br label %bb4\n+\n+bb4:\n+  ret void\n+}\n+\n+; Test that chr will still optimize the first 2 regions,\n+; but will skip the last one due to basic blocks have address taken.\n+@gototable2 = weak_odr dso_local local_unnamed_addr constant [2 x i8*] [i8* blockaddress(@test_chr_with_bbs_address_taken2, %bb5), i8* blockaddress(@test_chr_with_bbs_address_taken2, %bb5)]\n+define void @test_chr_with_bbs_address_taken2(i32* %i) !prof !14 {\n+; CHECK-LABEL: @test_chr_with_bbs_address_taken2(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* [[I:%.*]], align 4\n+; CHECK-NEXT:    [[TMP1:%.*]] = and i32 [[TMP0]], 3\n+; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[TMP1]], 3\n+; CHECK-NEXT:    br i1 [[TMP2]], label [[BB0:%.*]], label [[ENTRY_SPLIT_NONCHR:%.*]], !prof [[PROF15]]\n+; CHECK:       bb0:\n+; CHECK-NEXT:    call void @foo()\n+; CHECK-NEXT:    call void @foo()\n+; CHECK-NEXT:    br label [[BB3:%.*]]\n+; CHECK:       entry.split.nonchr:\n+; CHECK-NEXT:    [[TMP3:%.*]] = and i32 [[TMP0]], 1\n+; CHECK-NEXT:    [[DOTNOT:%.*]] = icmp eq i32 [[TMP3]], 0\n+; CHECK-NEXT:    br i1 [[DOTNOT]], label [[BB1_NONCHR:%.*]], label [[BB0_NONCHR:%.*]], !prof [[PROF16]]\n+; CHECK:       bb0.nonchr:\n+; CHECK-NEXT:    call void @foo()\n+; CHECK-NEXT:    br label [[BB1_NONCHR]]\n+; CHECK:       bb1.nonchr:\n+; CHECK-NEXT:    [[TMP4:%.*]] = and i32 [[TMP0]], 2\n+; CHECK-NEXT:    [[TMP5:%.*]] = icmp eq i32 [[TMP4]], 0\n+; CHECK-NEXT:    br i1 [[TMP5]], label [[BB3]], label [[BB2_NONCHR:%.*]], !prof [[PROF16]]\n+; CHECK:       bb2.nonchr:\n+; CHECK-NEXT:    call void @foo()\n+; CHECK-NEXT:    br label [[BB3]]\n+; CHECK:       bb3:\n+; CHECK-NEXT:    ret void\n+;\n+entry:\n+  %0 = load i32, i32* %i\n+  %1 = and i32 %0, 1\n+  %2 = icmp eq i32 %1, 0\n+  br i1 %2, label %bb1, label %bb0, !prof !15\n+\n+bb0:\n+  call void @foo()\n+  br label %bb1\n+\n+bb1:\n+  %3 = and i32 %0, 2\n+  %4 = icmp eq i32 %3, 0\n+  br i1 %4, label %bb3, label %bb2, !prof !15\n+\n+bb2:\n+  call void @foo()\n+  br label %bb3\n+\n+bb3:\n+  %5 = and i32 %0, 2\n+  %6 = icmp eq i32 %5, 0\n+  br i1 %6, label %bb6, label %bb4, !prof !15\n+\n+bb4:\n+  %pc = bitcast i32* %i to i8*\n+  indirectbr i8* %pc, [label %bb5, label %bb5]\n+\n+bb5:\n+  br label %bb6\n+\n+bb6:\n+  ret void\n+}\n+\n+\n !llvm.module.flags = !{!0}\n !0 = !{i32 1, !\"ProfileSummary\", !1}\n !1 = !{!2, !3, !4, !5, !6, !7, !8, !9}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/PGOProfile/chr.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/PGOProfile/chr.ll\n\n\nTesting Time: 1.05s\n  Failed: 1\n"
    },
    "eba76056a364d206de7f0ac944c8601c988b6405___FunctionSpecialization.cpp": {
        "prefix": "  bool getPossibleConstants(Argument *A,\n                            SmallVectorImpl<Constant *> &Constants) {\n    Function *F = A->getParent();\n    bool AllConstant = true;\n\n    // Iterate over all the call sites of the argument's parent function.\n    for (User *U : F->users()) {\n      if (!isa<CallInst>(U) && !isa<InvokeInst>(U))\n        continue;\n      auto &CS = *cast<CallBase>(U);\n      // If the call site has attribute minsize set, that callsite won't be\n      // specialized.\n      if (CS.hasFnAttr(Attribute::MinSize)) {\n        AllConstant = false;\n        continue;\n      }\n\n      // If the parent of the call site will never be executed, we don't need\n      // to worry about the passed value.\n      if (!Solver.isBlockExecutable(CS.getParent()))\n        continue;\n\n      auto *V = CS.getArgOperand(A->getArgNo());\n",
        "suffix": "      if (auto *GV = dyn_cast<GlobalVariable>(V)) {\n        // Check if we want to specialize on the address of non-constant\n        // global values.\n        if (!GV->isConstant())\n          if (!SpecializeOnAddresses)\n            return false;\n\n        if (!GV->getValueType()->isSingleValueType())\n          return false;\n      }\n\n      if (isa<Constant>(V) && (Solver.getLatticeValueFor(V).isConstant() ||\n                               EnableSpecializationForLiteralConstant))\n        Constants.push_back(cast<Constant>(V));\n      else\n        AllConstant = false;\n    }\n\n    // If the argument can only take on constant values, AllConstant will be\n    // true.\n    return AllConstant;\n  }\n",
        "start": 655,
        "end": 700,
        "buggy": "  bool getPossibleConstants(Argument *A,\n                            SmallVectorImpl<Constant *> &Constants) {\n    Function *F = A->getParent();\n    bool AllConstant = true;\n\n    // Iterate over all the call sites of the argument's parent function.\n    for (User *U : F->users()) {\n      if (!isa<CallInst>(U) && !isa<InvokeInst>(U))\n        continue;\n      auto &CS = *cast<CallBase>(U);\n      // If the call site has attribute minsize set, that callsite won't be\n      // specialized.\n      if (CS.hasFnAttr(Attribute::MinSize)) {\n        AllConstant = false;\n        continue;\n      }\n\n      // If the parent of the call site will never be executed, we don't need\n      // to worry about the passed value.\n      if (!Solver.isBlockExecutable(CS.getParent()))\n        continue;\n\n      auto *V = CS.getArgOperand(A->getArgNo());\n      // TrackValueOfGlobalVariable only tracks scalar global variables.\n      if (auto *GV = dyn_cast<GlobalVariable>(V)) {\n        // Check if we want to specialize on the address of non-constant\n        // global values.\n        if (!GV->isConstant())\n          if (!SpecializeOnAddresses)\n            return false;\n\n        if (!GV->getValueType()->isSingleValueType())\n          return false;\n      }\n\n      if (isa<Constant>(V) && (Solver.getLatticeValueFor(V).isConstant() ||\n                               EnableSpecializationForLiteralConstant))\n        Constants.push_back(cast<Constant>(V));\n      else\n        AllConstant = false;\n    }\n\n    // If the argument can only take on constant values, AllConstant will be\n    // true.\n    return AllConstant;\n  }\n",
        "fix": null,
        "buggy_hunk_masked": "      // TrackValueOfGlobalVariable only tracks scalar global variables.\n",
        "src_path": "eba76056a364d206de7f0ac944c8601c988b6405___FunctionSpecialization.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/eba76056a364d206de7f0ac944c8601c988b6405",
        "commit_msg": "[FuncSpec] Don't specialise (or crash) on poison or constexpr values\n\nFunction specialization was crashing on poison values and constexpr values.\nThe problem is that these values are not added to the solver, so it crashes\nwhen a lookup is performed for these values. This fixes that by not\nspecialising on these values. For poison that is obvious, but for constexpr\nthis is a change in behaviour. Thus, in one way this is a bit of a stopgap, but\nspecialising on constexpr values wasn't done very intentionally, and need some\nmore work and tests if we wanted to support this.\n\nAs a follow up, we need to look if the solver should exit more gracefully and\nreturn a \"don't know\", or that it should really support these constexprs.\n\nThis should fix PR51600 (https://bugs.llvm.org/show_bug.cgi?id=51600).\n\nDifferential Revision: https://reviews.llvm.org/D110529",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/FunctionSpecialization/function-specialization-constant-expression.ll",
                "patch": "@@ -9,15 +9,37 @@\n %struct = type { i8, i16, i32, i64, i64}\n @Global = internal constant %struct {i8 0, i16 1, i32 2, i64 3, i64 4}\n \n+define internal i64 @func2(i64 *%x) {\n+; CHECK-LABEL: @func2(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    [[VAL:%.*]] = ptrtoint i64* [[X:%.*]] to i64\n+; CHECK-NEXT:    ret i64 [[VAL]]\n+;\n+entry:\n+  %val = ptrtoint i64* %x to i64\n+  ret i64 %val\n+}\n+\n+define internal i64 @func(i64 *%x, i64 (i64*)* %binop) {\n+; CHECK-LABEL: @func(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    [[TMP0:%.*]] = call i64 [[BINOP:%.*]](i64* [[X:%.*]])\n+; CHECK-NEXT:    ret i64 [[TMP0]]\n+;\n+entry:\n+  %tmp0 = call i64 %binop(i64* %x)\n+  ret i64 %tmp0\n+}\n+\n define internal i64 @zoo(i1 %flag) {\n ; CHECK-LABEL: @zoo(\n ; CHECK-NEXT:  entry:\n ; CHECK-NEXT:    br i1 [[FLAG:%.*]], label [[PLUS:%.*]], label [[MINUS:%.*]]\n ; CHECK:       plus:\n-; CHECK-NEXT:    [[TMP0:%.*]] = call i64 @func2.1(i64* getelementptr inbounds ([[STRUCT:%.*]], %struct* @Global, i32 0, i32 3))\n+; CHECK-NEXT:    [[TMP0:%.*]] = call i64 @func2(i64* getelementptr inbounds ([[STRUCT:%.*]], %struct* @Global, i32 0, i32 3))\n ; CHECK-NEXT:    br label [[MERGE:%.*]]\n ; CHECK:       minus:\n-; CHECK-NEXT:    [[TMP1:%.*]] = call i64 @func2.2(i64* getelementptr inbounds ([[STRUCT]], %struct* @Global, i32 0, i32 4))\n+; CHECK-NEXT:    [[TMP1:%.*]] = call i64 @func2(i64* getelementptr inbounds ([[STRUCT]], %struct* @Global, i32 0, i32 4))\n ; CHECK-NEXT:    br label [[MERGE]]\n ; CHECK:       merge:\n ; CHECK-NEXT:    [[TMP2:%.*]] = phi i64 [ [[TMP0]], [[PLUS]] ], [ [[TMP1]], [[MINUS]] ]\n@@ -41,27 +63,6 @@ merge:\n   ret i64 %tmp2\n }\n \n-define internal i64 @func2(i64 *%x) {\n-; CHECK-LABEL: @func2(\n-; CHECK-NEXT:  entry:\n-; CHECK-NEXT:    [[VAL:%.*]] = ptrtoint i64* [[X:%.*]] to i64\n-; CHECK-NEXT:    ret i64 [[VAL]]\n-;\n-entry:\n-  %val = ptrtoint i64* %x to i64\n-  ret i64 %val\n-}\n-\n-define internal i64 @func(i64 *%x, i64 (i64*)* %binop) {\n-; CHECK-LABEL: @func(\n-; CHECK-NEXT:  entry:\n-; CHECK-NEXT:    [[TMP0:%.*]] = call i64 [[BINOP:%.*]](i64* [[X:%.*]])\n-; CHECK-NEXT:    ret i64 [[TMP0]]\n-;\n-entry:\n-  %tmp0 = call i64 %binop(i64* %x)\n-  ret i64 %tmp0\n-}\n \n define i64 @main() {\n ; CHECK-LABEL: @main(\n@@ -75,13 +76,3 @@ define i64 @main() {\n   %3 = add i64 %1, %2\n   ret i64 %3\n }\n-\n-; CHECK-LABEL: define internal i64 @func2.1(\n-; CHECK-NEXT:  entry:\n-; CHECK-NEXT:    ret i64 ptrtoint (i64* getelementptr inbounds (%struct, %struct* @Global, i32 0, i32 3) to i64)\n-; CHECK-NEXT:  }\n-\n-; CHECK-LABEL: define internal i64 @func2.2(\n-; CHECK-NEXT:  entry:\n-; CHECK-NEXT:    ret i64 ptrtoint (i64* getelementptr inbounds (%struct, %struct* @Global, i32 0, i32 4) to i64)\n-; CHECK-NEXT:  }"
            },
            {
                "fn": "llvm/test/Transforms/FunctionSpecialization/function-specialization-constant-expression2.ll",
                "patch": "@@ -0,0 +1,44 @@\n+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py\n+; RUN: opt -function-specialization -force-function-specialization -S < %s | FileCheck %s\n+\n+; Check that we don't crash and specialise on a constant expression.\n+\n+%struct.pluto = type { %struct.spam }\n+%struct.quux = type { i16 }\n+%struct.spam = type { i16 }\n+\n+@global.5 = external dso_local global [4 x %struct.pluto], align 1\n+@global.12 = external global %struct.quux, align 1\n+\n+define internal i16 @wobble.972(%struct.quux* byval(%struct.quux) align 1 %arg, i16 %arg1, %struct.spam* byval(%struct.spam) align 1 %arg2, %struct.quux* byval(%struct.quux) align 1 %arg3) #4 {\n+; CHECK-LABEL: @wobble.972(\n+; CHECK-NEXT:  bb:\n+; CHECK-NEXT:    [[TMP34:%.*]] = bitcast %struct.spam* [[ARG2:%.*]] to i16*\n+; CHECK-NEXT:    unreachable\n+;\n+bb:\n+  %tmp34 = bitcast %struct.spam* %arg2 to i16*\n+  unreachable\n+}\n+\n+define internal i16 @snork() {\n+; CHECK-LABEL: @snork(\n+; CHECK-NEXT:  bb4:\n+; CHECK-NEXT:    [[TMP:%.*]] = call i16 @wobble.972(%struct.quux* byval([[STRUCT_QUUX:%.*]]) align 1 undef, i16 undef, %struct.spam* byval([[STRUCT_SPAM:%.*]]) align 1 getelementptr inbounds ([4 x %struct.pluto], [4 x %struct.pluto]* @global.5, i32 0, i32 3, i32 0), %struct.quux* byval([[STRUCT_QUUX]]) align 1 @global.12)\n+; CHECK-NEXT:    unreachable\n+;\n+bb4:\n+  %tmp = call i16 @wobble.972(%struct.quux* byval(%struct.quux) align 1 undef, i16 undef, %struct.spam* byval(%struct.spam) align 1 getelementptr inbounds ([4 x %struct.pluto], [4 x %struct.pluto]* @global.5, i32 0, i32 3, i32 0), %struct.quux* byval(%struct.quux) align 1 @global.12)\n+  unreachable\n+}\n+\n+define i16 @main() {\n+; CHECK-LABEL: @main(\n+; CHECK-NEXT:  bb:\n+; CHECK-NEXT:    [[TMP:%.*]] = call i16 @snork()\n+; CHECK-NEXT:    unreachable\n+;\n+bb:\n+  %tmp = call i16 @snork()\n+  unreachable\n+}"
            },
            {
                "fn": "llvm/test/Transforms/FunctionSpecialization/function-specialization-poison.ll",
                "patch": "@@ -0,0 +1,42 @@\n+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py\n+; RUN: opt -function-specialization -force-function-specialization -S < %s | FileCheck %s\n+\n+; Check that we don't crash and specialise on a poison value.\n+\n+%struct.quux = type { i16 }\n+%struct.spam = type { i16 }\n+\n+@global.12 = external global %struct.quux, align 1\n+\n+define internal i16 @wobble(%struct.spam* byval(%struct.spam) %arg2) {\n+; CHECK-LABEL: @wobble(\n+; CHECK-NEXT:  bb:\n+; CHECK-NEXT:    [[C:%.*]] = bitcast %struct.spam* [[ARG2:%.*]] to i16*\n+; CHECK-NEXT:    unreachable\n+;\n+bb:\n+  %C = bitcast %struct.spam* %arg2 to i16*\n+  unreachable\n+}\n+\n+define internal i16 @snork() {\n+; CHECK-LABEL: @snork(\n+; CHECK-NEXT:  bb4:\n+; CHECK-NEXT:    [[B:%.*]] = call i16 @wobble(%struct.spam* poison)\n+; CHECK-NEXT:    unreachable\n+;\n+bb4:\n+  %B = call i16 @wobble(%struct.spam* poison)\n+  unreachable\n+}\n+\n+define i16 @main() {\n+; CHECK-LABEL: @main(\n+; CHECK-NEXT:  bb:\n+; CHECK-NEXT:    [[A:%.*]] = call i16 @snork()\n+; CHECK-NEXT:    unreachable\n+;\n+bb:\n+  %A = call i16 @snork()\n+  unreachable\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/FunctionSpecialization/function-specialization-constant-expression.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/FunctionSpecialization/function-specialization-constant-expression.ll\n\n\nTesting Time: 0.79s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/FunctionSpecialization/function-specialization-constant-expression2.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/FunctionSpecialization/function-specialization-constant-expression2.ll\n\n\nTesting Time: 6.59s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/FunctionSpecialization/function-specialization-poison.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/FunctionSpecialization/function-specialization-poison.ll\n\n\nTesting Time: 4.40s\n  Failed: 1\n"
    },
    "2dd883439c7886182902c0aa17b34c0a8ed88b66___Mangler.cpp": {
        "prefix": "static void addByteCountSuffix(raw_ostream &OS, const Function *F,\n                               const DataLayout &DL) {\n  // Calculate arguments size total.\n  unsigned ArgWords = 0;\n\n  const unsigned PtrSize = DL.getPointerSize();\n\n  for (const Argument &A : F->args()) {\n",
        "suffix": "    uint64_t AllocSize = A.hasPassPointeeByValueCopyAttr() ?\n      A.getPassPointeeByValueCopySize(DL) :\n      DL.getTypeAllocSize(A.getType());\n\n    // Size should be aligned to pointer size.\n    ArgWords += alignTo(AllocSize, PtrSize);\n  }\n\n  OS << '@' << ArgWords;\n}\n",
        "start": 94,
        "end": 112,
        "buggy": "static void addByteCountSuffix(raw_ostream &OS, const Function *F,\n                               const DataLayout &DL) {\n  // Calculate arguments size total.\n  unsigned ArgWords = 0;\n\n  const unsigned PtrSize = DL.getPointerSize();\n\n  for (const Argument &A : F->args()) {\n    // 'Dereference' type in case of byval or inalloca parameter attribute.\n    uint64_t AllocSize = A.hasPassPointeeByValueCopyAttr() ?\n      A.getPassPointeeByValueCopySize(DL) :\n      DL.getTypeAllocSize(A.getType());\n\n    // Size should be aligned to pointer size.\n    ArgWords += alignTo(AllocSize, PtrSize);\n  }\n\n  OS << '@' << ArgWords;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    // 'Dereference' type in case of byval or inalloca parameter attribute.\n",
        "src_path": "2dd883439c7886182902c0aa17b34c0a8ed88b66___Mangler.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/2dd883439c7886182902c0aa17b34c0a8ed88b66",
        "commit_msg": "[Mangler] Calculate the argument list byte count suffix correctly when returning large values\n\n`__stdcall`, `__fastcall` and `__vectorcall` return large values via a\nhidden pointer argument. However, the size of that argument should not\nbe included in the argument list byte count suffix added to the\nfunction's decorated name.\n\nThis patch fixes that issue so that LLVM generates the same decorated\nname as MSVC does.\n\nMSVC example: https://godbolt.org/z/nc35MKPhr\n\nReviewed By: rnk\n\nDifferential Revision: https://reviews.llvm.org/D110719",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/stdcall.ll",
                "patch": "@@ -18,6 +18,21 @@ entry:\n   ret i32 %a\n }\n \n+%struct.large_type = type { i64, i64, i64 }\n+\n+define x86_stdcallcc void @ReturnLargeType(%struct.large_type* noalias nocapture sret(%struct.large_type) align 8 %agg.result) {\n+; CHECK: ReturnLargeType@0:\n+; CHECK: retl\n+entry:\n+  %a = getelementptr inbounds %struct.large_type, %struct.large_type* %agg.result, i32 0, i32 0\n+  store i64 123, i64* %a, align 8\n+  %b = getelementptr inbounds %struct.large_type, %struct.large_type* %agg.result, i32 0, i32 1\n+  store i64 456, i64* %b, align 8\n+  %c = getelementptr inbounds %struct.large_type, %struct.large_type* %agg.result, i32 0, i32 2\n+  store i64 789, i64* %c, align 8\n+  ret void\n+}\n+\n @B = global %0 { void (...)* bitcast (void ()* @MyFunc to void (...)*) }, align 4\n ; CHECK: _B:\n ; CHECK: .long _MyFunc@0"
            },
            {
                "fn": "llvm/test/CodeGen/X86/vectorcall.ll",
                "patch": "@@ -172,8 +172,7 @@ declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture r\n declare void @llvm.memcpy.p0i8.p0i8.i32(i8* nocapture writeonly, i8* nocapture readonly, i32, i1)\n \n define x86_vectorcallcc void @test_mixed_7(%struct.HVA5* noalias sret(%struct.HVA5) %agg.result) {\n-; X86-LABEL: test_mixed_7@@4\n-; X64-LABEL: test_mixed_7@@8\n+; CHECK-LABEL: test_mixed_7@@0\n ; X64:         mov{{[ql]}}\t%rcx, %rax\n ; CHECK:       movaps\t%xmm{{[0-9]}}, 64(%{{rcx|eax}})\n ; CHECK:       movaps\t%xmm{{[0-9]}}, 48(%{{rcx|eax}})"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/stdcall.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/stdcall.ll\n\n\nTesting Time: 0.31s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vectorcall.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vectorcall.ll\n\n\nTesting Time: 0.25s\n  Failed: 1\n"
    },
    "259390de9af659e2432c5b2af041ec6576c1b26d___LazyCallGraph.cpp": {
        "prefix": "bool LazyCallGraph::invalidate(Module &, const PreservedAnalyses &PA,\n                               ModuleAnalysisManager::Invalidator &) {\n  // Check whether the analysis, all analyses on functions, or the function's\n  // CFG have been preserved.\n  auto PAC = PA.getChecker<llvm::LazyCallGraphAnalysis>();\n",
        "suffix": "",
        "start": 218,
        "end": 225,
        "buggy": "bool LazyCallGraph::invalidate(Module &, const PreservedAnalyses &PA,\n                               ModuleAnalysisManager::Invalidator &) {\n  // Check whether the analysis, all analyses on functions, or the function's\n  // CFG have been preserved.\n  auto PAC = PA.getChecker<llvm::LazyCallGraphAnalysis>();\n  return !(PAC.preserved() || PAC.preservedSet<AllAnalysesOn<Module>>() ||\n           PAC.preservedSet<CFGAnalyses>());\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  return !(PAC.preserved() || PAC.preservedSet<AllAnalysesOn<Module>>() ||\n           PAC.preservedSet<CFGAnalyses>());\n}\n",
        "src_path": "259390de9af659e2432c5b2af041ec6576c1b26d___LazyCallGraph.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/259390de9af659e2432c5b2af041ec6576c1b26d",
        "commit_msg": "[LCG] Don't skip invalidation of LazyCallGraph if CFG analyses are preserved\n\nThe CFG being changed and the overall call graph are not related, we can introduce/remove calls without changing the CFG.\n\nResolves one of the issues in PR51946.\n\nReviewed By: asbirlea\n\nDifferential Revision: https://reviews.llvm.org/D111275",
        "test_func_diff": [
            {
                "fn": "llvm/test/Analysis/LazyCallGraph/invalidate.ll",
                "patch": "@@ -0,0 +1,10 @@\n+; Make sure we invalidate lcg even when preserving domtree\n+; RUN: opt -passes='require<lcg>,function(instcombine)' -debug-pass-manager -disable-output < %s 2>&1 | FileCheck %s\n+\n+; CHECK: Invalidating {{.*}} LazyCallGraphAnalysis\n+\n+define void @f() {\n+lbl:\n+  %a = add i32 1, 2\n+  unreachable\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Analysis/LazyCallGraph/invalidate.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Analysis/LazyCallGraph/invalidate.ll\n\n\nTesting Time: 0.30s\n  Failed: 1\n"
    },
    "4c5702cb123b8fd705982c638fb18c999f69d63a___ValueTracking.cpp": {
        "prefix": "static bool canCreateUndefOrPoison(const Operator *Op, bool PoisonOnly,\n                                   bool ConsiderFlags) {\n  if (ConsiderFlags) {\n    // See whether I has flags that may create poison\n    if (const auto *OvOp = dyn_cast<OverflowingBinaryOperator>(Op)) {\n      if (OvOp->hasNoSignedWrap() || OvOp->hasNoUnsignedWrap())\n        return true;\n    }\n    if (const auto *ExactOp = dyn_cast<PossiblyExactOperator>(Op))\n      if (ExactOp->isExact())\n        return true;\n",
        "suffix": "\n  unsigned Opcode = Op->getOpcode();\n\n  // Check whether opcode is a poison/undef-generating operation\n  switch (Opcode) {\n  case Instruction::Shl:\n  case Instruction::AShr:\n  case Instruction::LShr: {\n    // Shifts return poison if shiftwidth is larger than the bitwidth.\n    if (auto *C = dyn_cast<Constant>(Op->getOperand(1))) {\n      SmallVector<Constant *, 4> ShiftAmounts;\n      if (auto *FVTy = dyn_cast<FixedVectorType>(C->getType())) {\n        unsigned NumElts = FVTy->getNumElements();\n        for (unsigned i = 0; i < NumElts; ++i)\n          ShiftAmounts.push_back(C->getAggregateElement(i));\n      } else if (isa<ScalableVectorType>(C->getType()))\n        return true; // Can't tell, just return true to be safe\n      else\n        ShiftAmounts.push_back(C);\n\n      bool Safe = llvm::all_of(ShiftAmounts, [](Constant *C) {\n        auto *CI = dyn_cast_or_null<ConstantInt>(C);\n        return CI && CI->getValue().ult(C->getType()->getIntegerBitWidth());\n      });\n      return !Safe;\n    }\n    return true;\n  }\n  case Instruction::FPToSI:\n  case Instruction::FPToUI:\n    // fptosi/ui yields poison if the resulting value does not fit in the\n    // destination type.\n    return true;\n  case Instruction::Call:\n    if (auto *II = dyn_cast<IntrinsicInst>(Op)) {\n      switch (II->getIntrinsicID()) {\n      // TODO: Add more intrinsics.\n      case Intrinsic::ctpop:\n      case Intrinsic::sadd_with_overflow:\n      case Intrinsic::ssub_with_overflow:\n      case Intrinsic::smul_with_overflow:\n      case Intrinsic::uadd_with_overflow:\n      case Intrinsic::usub_with_overflow:\n      case Intrinsic::umul_with_overflow:\n        return false;\n      }\n    }\n    LLVM_FALLTHROUGH;\n  case Instruction::CallBr:\n  case Instruction::Invoke: {\n    const auto *CB = cast<CallBase>(Op);\n    return !CB->hasRetAttr(Attribute::NoUndef);\n  }\n  case Instruction::InsertElement:\n  case Instruction::ExtractElement: {\n    // If index exceeds the length of the vector, it returns poison\n    auto *VTy = cast<VectorType>(Op->getOperand(0)->getType());\n    unsigned IdxOp = Op->getOpcode() == Instruction::InsertElement ? 2 : 1;\n    auto *Idx = dyn_cast<ConstantInt>(Op->getOperand(IdxOp));\n    if (!Idx || Idx->getValue().uge(VTy->getElementCount().getKnownMinValue()))\n      return true;\n    return false;\n  }\n  case Instruction::ShuffleVector: {\n    // shufflevector may return undef.\n    if (PoisonOnly)\n      return false;\n    ArrayRef<int> Mask = isa<ConstantExpr>(Op)\n                             ? cast<ConstantExpr>(Op)->getShuffleMask()\n                             : cast<ShuffleVectorInst>(Op)->getShuffleMask();\n    return is_contained(Mask, UndefMaskElem);\n  }\n  case Instruction::FNeg:\n  case Instruction::PHI:\n  case Instruction::Select:\n  case Instruction::URem:\n  case Instruction::SRem:\n  case Instruction::ExtractValue:\n  case Instruction::InsertValue:\n  case Instruction::Freeze:\n  case Instruction::ICmp:\n  case Instruction::FCmp:\n    return false;\n  case Instruction::GetElementPtr: {\n    const auto *GEP = cast<GEPOperator>(Op);\n    return GEP->isInBounds();\n  }\n  default: {\n    const auto *CE = dyn_cast<ConstantExpr>(Op);\n    if (isa<CastInst>(Op) || (CE && CE->isCast()))\n      return false;\n    else if (Instruction::isBinaryOp(Opcode))\n      return false;\n    // Be conservative and return true.\n    return true;\n  }\n  }\n}\n",
        "start": 4951,
        "end": 5065,
        "buggy": "static bool canCreateUndefOrPoison(const Operator *Op, bool PoisonOnly,\n                                   bool ConsiderFlags) {\n  if (ConsiderFlags) {\n    // See whether I has flags that may create poison\n    if (const auto *OvOp = dyn_cast<OverflowingBinaryOperator>(Op)) {\n      if (OvOp->hasNoSignedWrap() || OvOp->hasNoUnsignedWrap())\n        return true;\n    }\n    if (const auto *ExactOp = dyn_cast<PossiblyExactOperator>(Op))\n      if (ExactOp->isExact())\n        return true;\n    if (const auto *FP = dyn_cast<FPMathOperator>(Op)) {\n      auto FMF = FP->getFastMathFlags();\n      if (FMF.noNaNs() || FMF.noInfs())\n        return true;\n    }\n  }\n\n  unsigned Opcode = Op->getOpcode();\n\n  // Check whether opcode is a poison/undef-generating operation\n  switch (Opcode) {\n  case Instruction::Shl:\n  case Instruction::AShr:\n  case Instruction::LShr: {\n    // Shifts return poison if shiftwidth is larger than the bitwidth.\n    if (auto *C = dyn_cast<Constant>(Op->getOperand(1))) {\n      SmallVector<Constant *, 4> ShiftAmounts;\n      if (auto *FVTy = dyn_cast<FixedVectorType>(C->getType())) {\n        unsigned NumElts = FVTy->getNumElements();\n        for (unsigned i = 0; i < NumElts; ++i)\n          ShiftAmounts.push_back(C->getAggregateElement(i));\n      } else if (isa<ScalableVectorType>(C->getType()))\n        return true; // Can't tell, just return true to be safe\n      else\n        ShiftAmounts.push_back(C);\n\n      bool Safe = llvm::all_of(ShiftAmounts, [](Constant *C) {\n        auto *CI = dyn_cast_or_null<ConstantInt>(C);\n        return CI && CI->getValue().ult(C->getType()->getIntegerBitWidth());\n      });\n      return !Safe;\n    }\n    return true;\n  }\n  case Instruction::FPToSI:\n  case Instruction::FPToUI:\n    // fptosi/ui yields poison if the resulting value does not fit in the\n    // destination type.\n    return true;\n  case Instruction::Call:\n    if (auto *II = dyn_cast<IntrinsicInst>(Op)) {\n      switch (II->getIntrinsicID()) {\n      // TODO: Add more intrinsics.\n      case Intrinsic::ctpop:\n      case Intrinsic::sadd_with_overflow:\n      case Intrinsic::ssub_with_overflow:\n      case Intrinsic::smul_with_overflow:\n      case Intrinsic::uadd_with_overflow:\n      case Intrinsic::usub_with_overflow:\n      case Intrinsic::umul_with_overflow:\n        return false;\n      }\n    }\n    LLVM_FALLTHROUGH;\n  case Instruction::CallBr:\n  case Instruction::Invoke: {\n    const auto *CB = cast<CallBase>(Op);\n    return !CB->hasRetAttr(Attribute::NoUndef);\n  }\n  case Instruction::InsertElement:\n  case Instruction::ExtractElement: {\n    // If index exceeds the length of the vector, it returns poison\n    auto *VTy = cast<VectorType>(Op->getOperand(0)->getType());\n    unsigned IdxOp = Op->getOpcode() == Instruction::InsertElement ? 2 : 1;\n    auto *Idx = dyn_cast<ConstantInt>(Op->getOperand(IdxOp));\n    if (!Idx || Idx->getValue().uge(VTy->getElementCount().getKnownMinValue()))\n      return true;\n    return false;\n  }\n  case Instruction::ShuffleVector: {\n    // shufflevector may return undef.\n    if (PoisonOnly)\n      return false;\n    ArrayRef<int> Mask = isa<ConstantExpr>(Op)\n                             ? cast<ConstantExpr>(Op)->getShuffleMask()\n                             : cast<ShuffleVectorInst>(Op)->getShuffleMask();\n    return is_contained(Mask, UndefMaskElem);\n  }\n  case Instruction::FNeg:\n  case Instruction::PHI:\n  case Instruction::Select:\n  case Instruction::URem:\n  case Instruction::SRem:\n  case Instruction::ExtractValue:\n  case Instruction::InsertValue:\n  case Instruction::Freeze:\n  case Instruction::ICmp:\n  case Instruction::FCmp:\n    return false;\n  case Instruction::GetElementPtr: {\n    const auto *GEP = cast<GEPOperator>(Op);\n    return GEP->isInBounds();\n  }\n  default: {\n    const auto *CE = dyn_cast<ConstantExpr>(Op);\n    if (isa<CastInst>(Op) || (CE && CE->isCast()))\n      return false;\n    else if (Instruction::isBinaryOp(Opcode))\n      return false;\n    // Be conservative and return true.\n    return true;\n  }\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (const auto *FP = dyn_cast<FPMathOperator>(Op)) {\n      auto FMF = FP->getFastMathFlags();\n      if (FMF.noNaNs() || FMF.noInfs())\n        return true;\n    }\n  }\n",
        "src_path": "4c5702cb123b8fd705982c638fb18c999f69d63a___ValueTracking.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/4c5702cb123b8fd705982c638fb18c999f69d63a",
        "commit_msg": "Fix bug introduced with 6f34839 (poison flags on floating point ops)\n\nThe newly introduced API for checking whether poison comes solely from flags which can be dropped was out of sync.  This was noticed by a reviewer post commit.\n\nFor the moment, disable the floating point flags.  In a follow up change, I plan to add support in dropPoisonGeneratingFlags, but that deserves to be a change of it's own.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/freeze.ll",
                "patch": "@@ -374,3 +374,14 @@ define i8* @propagate_drop_gep2(i8* %arg, i64 %unknown) {\n   ret i8* %v1.fr\n }\n \n+\n+define float @propagate_drop_fadd(float %arg) {\n+; CHECK-LABEL: @propagate_drop_fadd(\n+; CHECK-NEXT:    [[V1:%.*]] = fadd ninf float [[ARG:%.*]], 2.000000e+00\n+; CHECK-NEXT:    [[V1_FR:%.*]] = freeze float [[V1]]\n+; CHECK-NEXT:    ret float [[V1_FR]]\n+;\n+  %v1 = fadd ninf float %arg, 2.0\n+  %v1.fr = freeze float %v1\n+  ret float %v1.fr\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/freeze.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/freeze.ll\n\n\nTesting Time: 0.35s\n  Failed: 1\n"
    },
    "b0319ab79bf59669803cc2475fae1d12f8eeaca9___SelectionDAGBuilder.cpp": {
        "prefix": "void SelectionDAGBuilder::visitRet(const ReturnInst &I) {\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  auto &DL = DAG.getDataLayout();\n  SDValue Chain = getControlRoot();\n  SmallVector<ISD::OutputArg, 8> Outs;\n  SmallVector<SDValue, 8> OutVals;\n\n  // Calls to @llvm.experimental.deoptimize don't generate a return value, so\n  // lower\n  //\n  //   %val = call <ty> @llvm.experimental.deoptimize()\n  //   ret <ty> %val\n  //\n  // differently.\n  if (I.getParent()->getTerminatingDeoptimizeCall()) {\n    LowerDeoptimizingReturn();\n    return;\n  }\n\n  if (!FuncInfo.CanLowerReturn) {\n    unsigned DemoteReg = FuncInfo.DemoteRegister;\n    const Function *F = I.getParent()->getParent();\n\n    // Emit a store of the return value through the virtual register.\n    // Leave Outs empty so that LowerReturn won't try to load return\n    // registers the usual way.\n    SmallVector<EVT, 1> PtrValueVTs;\n    ComputeValueVTs(TLI, DL,\n                    F->getReturnType()->getPointerTo(\n                        DAG.getDataLayout().getAllocaAddrSpace()),\n                    PtrValueVTs);\n\n",
        "suffix": "\n    SmallVector<EVT, 4> ValueVTs, MemVTs;\n    SmallVector<uint64_t, 4> Offsets;\n    ComputeValueVTs(TLI, DL, I.getOperand(0)->getType(), ValueVTs, &MemVTs,\n                    &Offsets);\n    unsigned NumValues = ValueVTs.size();\n\n    SmallVector<SDValue, 4> Chains(NumValues);\n    Align BaseAlign = DL.getPrefTypeAlign(I.getOperand(0)->getType());\n    for (unsigned i = 0; i != NumValues; ++i) {\n      // An aggregate return value cannot wrap around the address space, so\n      // offsets to its parts don't wrap either.\n      SDValue Ptr = DAG.getObjectPtrOffset(getCurSDLoc(), RetPtr,\n                                           TypeSize::Fixed(Offsets[i]));\n\n      SDValue Val = RetOp.getValue(RetOp.getResNo() + i);\n      if (MemVTs[i] != ValueVTs[i])\n        Val = DAG.getPtrExtOrTrunc(Val, getCurSDLoc(), MemVTs[i]);\n      Chains[i] = DAG.getStore(\n          Chain, getCurSDLoc(), Val,\n          // FIXME: better loc info would be nice.\n          Ptr, MachinePointerInfo::getUnknownStack(DAG.getMachineFunction()),\n          commonAlignment(BaseAlign, Offsets[i]));\n    }\n\n    Chain = DAG.getNode(ISD::TokenFactor, getCurSDLoc(),\n                        MVT::Other, Chains);\n  } else if (I.getNumOperands() != 0) {\n    SmallVector<EVT, 4> ValueVTs;\n    ComputeValueVTs(TLI, DL, I.getOperand(0)->getType(), ValueVTs);\n    unsigned NumValues = ValueVTs.size();\n    if (NumValues) {\n      SDValue RetOp = getValue(I.getOperand(0));\n\n      const Function *F = I.getParent()->getParent();\n\n      bool NeedsRegBlock = TLI.functionArgumentNeedsConsecutiveRegisters(\n          I.getOperand(0)->getType(), F->getCallingConv(),\n          /*IsVarArg*/ false, DL);\n\n      ISD::NodeType ExtendKind = ISD::ANY_EXTEND;\n      if (F->getAttributes().hasRetAttr(Attribute::SExt))\n        ExtendKind = ISD::SIGN_EXTEND;\n      else if (F->getAttributes().hasRetAttr(Attribute::ZExt))\n        ExtendKind = ISD::ZERO_EXTEND;\n\n      LLVMContext &Context = F->getContext();\n      bool RetInReg = F->getAttributes().hasRetAttr(Attribute::InReg);\n\n      for (unsigned j = 0; j != NumValues; ++j) {\n        EVT VT = ValueVTs[j];\n\n        if (ExtendKind != ISD::ANY_EXTEND && VT.isInteger())\n          VT = TLI.getTypeForExtReturn(Context, VT, ExtendKind);\n\n        CallingConv::ID CC = F->getCallingConv();\n\n        unsigned NumParts = TLI.getNumRegistersForCallingConv(Context, CC, VT);\n        MVT PartVT = TLI.getRegisterTypeForCallingConv(Context, CC, VT);\n        SmallVector<SDValue, 4> Parts(NumParts);\n        getCopyToParts(DAG, getCurSDLoc(),\n                       SDValue(RetOp.getNode(), RetOp.getResNo() + j),\n                       &Parts[0], NumParts, PartVT, &I, CC, ExtendKind);\n\n        // 'inreg' on function refers to return value\n        ISD::ArgFlagsTy Flags = ISD::ArgFlagsTy();\n        if (RetInReg)\n          Flags.setInReg();\n\n        if (I.getOperand(0)->getType()->isPointerTy()) {\n          Flags.setPointer();\n          Flags.setPointerAddrSpace(\n              cast<PointerType>(I.getOperand(0)->getType())->getAddressSpace());\n        }\n\n        if (NeedsRegBlock) {\n          Flags.setInConsecutiveRegs();\n          if (j == NumValues - 1)\n            Flags.setInConsecutiveRegsLast();\n        }\n\n        // Propagate extension type if any\n        if (ExtendKind == ISD::SIGN_EXTEND)\n          Flags.setSExt();\n        else if (ExtendKind == ISD::ZERO_EXTEND)\n          Flags.setZExt();\n\n        for (unsigned i = 0; i < NumParts; ++i) {\n          Outs.push_back(ISD::OutputArg(Flags,\n                                        Parts[i].getValueType().getSimpleVT(),\n                                        VT, /*isfixed=*/true, 0, 0));\n          OutVals.push_back(Parts[i]);\n        }\n      }\n    }\n  }\n\n  // Push in swifterror virtual register as the last element of Outs. This makes\n  // sure swifterror virtual register will be returned in the swifterror\n  // physical register.\n  const Function *F = I.getParent()->getParent();\n  if (TLI.supportSwiftError() &&\n      F->getAttributes().hasAttrSomewhere(Attribute::SwiftError)) {\n    assert(SwiftError.getFunctionArg() && \"Need a swift error argument\");\n    ISD::ArgFlagsTy Flags = ISD::ArgFlagsTy();\n    Flags.setSwiftError();\n    Outs.push_back(ISD::OutputArg(\n        Flags, /*vt=*/TLI.getPointerTy(DL), /*argvt=*/EVT(TLI.getPointerTy(DL)),\n        /*isfixed=*/true, /*origidx=*/1, /*partOffs=*/0));\n    // Create SDNode for the swifterror virtual register.\n    OutVals.push_back(\n        DAG.getRegister(SwiftError.getOrCreateVRegUseAt(\n                            &I, FuncInfo.MBB, SwiftError.getFunctionArg()),\n                        EVT(TLI.getPointerTy(DL))));\n  }\n\n  bool isVarArg = DAG.getMachineFunction().getFunction().isVarArg();\n  CallingConv::ID CallConv =\n    DAG.getMachineFunction().getFunction().getCallingConv();\n  Chain = DAG.getTargetLoweringInfo().LowerReturn(\n      Chain, CallConv, isVarArg, Outs, OutVals, getCurSDLoc(), DAG);\n\n  // Verify that the target's LowerReturn behaved as expected.\n  assert(Chain.getNode() && Chain.getValueType() == MVT::Other &&\n         \"LowerReturn didn't return a valid chain!\");\n\n  // Update the DAG with the new chain value resulting from return lowering.\n  DAG.setRoot(Chain);\n}\n",
        "start": 1891,
        "end": 2054,
        "buggy": "void SelectionDAGBuilder::visitRet(const ReturnInst &I) {\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  auto &DL = DAG.getDataLayout();\n  SDValue Chain = getControlRoot();\n  SmallVector<ISD::OutputArg, 8> Outs;\n  SmallVector<SDValue, 8> OutVals;\n\n  // Calls to @llvm.experimental.deoptimize don't generate a return value, so\n  // lower\n  //\n  //   %val = call <ty> @llvm.experimental.deoptimize()\n  //   ret <ty> %val\n  //\n  // differently.\n  if (I.getParent()->getTerminatingDeoptimizeCall()) {\n    LowerDeoptimizingReturn();\n    return;\n  }\n\n  if (!FuncInfo.CanLowerReturn) {\n    unsigned DemoteReg = FuncInfo.DemoteRegister;\n    const Function *F = I.getParent()->getParent();\n\n    // Emit a store of the return value through the virtual register.\n    // Leave Outs empty so that LowerReturn won't try to load return\n    // registers the usual way.\n    SmallVector<EVT, 1> PtrValueVTs;\n    ComputeValueVTs(TLI, DL,\n                    F->getReturnType()->getPointerTo(\n                        DAG.getDataLayout().getAllocaAddrSpace()),\n                    PtrValueVTs);\n\n    SDValue RetPtr = DAG.getCopyFromReg(DAG.getEntryNode(), getCurSDLoc(),\n                                        DemoteReg, PtrValueVTs[0]);\n    SDValue RetOp = getValue(I.getOperand(0));\n\n    SmallVector<EVT, 4> ValueVTs, MemVTs;\n    SmallVector<uint64_t, 4> Offsets;\n    ComputeValueVTs(TLI, DL, I.getOperand(0)->getType(), ValueVTs, &MemVTs,\n                    &Offsets);\n    unsigned NumValues = ValueVTs.size();\n\n    SmallVector<SDValue, 4> Chains(NumValues);\n    Align BaseAlign = DL.getPrefTypeAlign(I.getOperand(0)->getType());\n    for (unsigned i = 0; i != NumValues; ++i) {\n      // An aggregate return value cannot wrap around the address space, so\n      // offsets to its parts don't wrap either.\n      SDValue Ptr = DAG.getObjectPtrOffset(getCurSDLoc(), RetPtr,\n                                           TypeSize::Fixed(Offsets[i]));\n\n      SDValue Val = RetOp.getValue(RetOp.getResNo() + i);\n      if (MemVTs[i] != ValueVTs[i])\n        Val = DAG.getPtrExtOrTrunc(Val, getCurSDLoc(), MemVTs[i]);\n      Chains[i] = DAG.getStore(\n          Chain, getCurSDLoc(), Val,\n          // FIXME: better loc info would be nice.\n          Ptr, MachinePointerInfo::getUnknownStack(DAG.getMachineFunction()),\n          commonAlignment(BaseAlign, Offsets[i]));\n    }\n\n    Chain = DAG.getNode(ISD::TokenFactor, getCurSDLoc(),\n                        MVT::Other, Chains);\n  } else if (I.getNumOperands() != 0) {\n    SmallVector<EVT, 4> ValueVTs;\n    ComputeValueVTs(TLI, DL, I.getOperand(0)->getType(), ValueVTs);\n    unsigned NumValues = ValueVTs.size();\n    if (NumValues) {\n      SDValue RetOp = getValue(I.getOperand(0));\n\n      const Function *F = I.getParent()->getParent();\n\n      bool NeedsRegBlock = TLI.functionArgumentNeedsConsecutiveRegisters(\n          I.getOperand(0)->getType(), F->getCallingConv(),\n          /*IsVarArg*/ false, DL);\n\n      ISD::NodeType ExtendKind = ISD::ANY_EXTEND;\n      if (F->getAttributes().hasRetAttr(Attribute::SExt))\n        ExtendKind = ISD::SIGN_EXTEND;\n      else if (F->getAttributes().hasRetAttr(Attribute::ZExt))\n        ExtendKind = ISD::ZERO_EXTEND;\n\n      LLVMContext &Context = F->getContext();\n      bool RetInReg = F->getAttributes().hasRetAttr(Attribute::InReg);\n\n      for (unsigned j = 0; j != NumValues; ++j) {\n        EVT VT = ValueVTs[j];\n\n        if (ExtendKind != ISD::ANY_EXTEND && VT.isInteger())\n          VT = TLI.getTypeForExtReturn(Context, VT, ExtendKind);\n\n        CallingConv::ID CC = F->getCallingConv();\n\n        unsigned NumParts = TLI.getNumRegistersForCallingConv(Context, CC, VT);\n        MVT PartVT = TLI.getRegisterTypeForCallingConv(Context, CC, VT);\n        SmallVector<SDValue, 4> Parts(NumParts);\n        getCopyToParts(DAG, getCurSDLoc(),\n                       SDValue(RetOp.getNode(), RetOp.getResNo() + j),\n                       &Parts[0], NumParts, PartVT, &I, CC, ExtendKind);\n\n        // 'inreg' on function refers to return value\n        ISD::ArgFlagsTy Flags = ISD::ArgFlagsTy();\n        if (RetInReg)\n          Flags.setInReg();\n\n        if (I.getOperand(0)->getType()->isPointerTy()) {\n          Flags.setPointer();\n          Flags.setPointerAddrSpace(\n              cast<PointerType>(I.getOperand(0)->getType())->getAddressSpace());\n        }\n\n        if (NeedsRegBlock) {\n          Flags.setInConsecutiveRegs();\n          if (j == NumValues - 1)\n            Flags.setInConsecutiveRegsLast();\n        }\n\n        // Propagate extension type if any\n        if (ExtendKind == ISD::SIGN_EXTEND)\n          Flags.setSExt();\n        else if (ExtendKind == ISD::ZERO_EXTEND)\n          Flags.setZExt();\n\n        for (unsigned i = 0; i < NumParts; ++i) {\n          Outs.push_back(ISD::OutputArg(Flags,\n                                        Parts[i].getValueType().getSimpleVT(),\n                                        VT, /*isfixed=*/true, 0, 0));\n          OutVals.push_back(Parts[i]);\n        }\n      }\n    }\n  }\n\n  // Push in swifterror virtual register as the last element of Outs. This makes\n  // sure swifterror virtual register will be returned in the swifterror\n  // physical register.\n  const Function *F = I.getParent()->getParent();\n  if (TLI.supportSwiftError() &&\n      F->getAttributes().hasAttrSomewhere(Attribute::SwiftError)) {\n    assert(SwiftError.getFunctionArg() && \"Need a swift error argument\");\n    ISD::ArgFlagsTy Flags = ISD::ArgFlagsTy();\n    Flags.setSwiftError();\n    Outs.push_back(ISD::OutputArg(\n        Flags, /*vt=*/TLI.getPointerTy(DL), /*argvt=*/EVT(TLI.getPointerTy(DL)),\n        /*isfixed=*/true, /*origidx=*/1, /*partOffs=*/0));\n    // Create SDNode for the swifterror virtual register.\n    OutVals.push_back(\n        DAG.getRegister(SwiftError.getOrCreateVRegUseAt(\n                            &I, FuncInfo.MBB, SwiftError.getFunctionArg()),\n                        EVT(TLI.getPointerTy(DL))));\n  }\n\n  bool isVarArg = DAG.getMachineFunction().getFunction().isVarArg();\n  CallingConv::ID CallConv =\n    DAG.getMachineFunction().getFunction().getCallingConv();\n  Chain = DAG.getTargetLoweringInfo().LowerReturn(\n      Chain, CallConv, isVarArg, Outs, OutVals, getCurSDLoc(), DAG);\n\n  // Verify that the target's LowerReturn behaved as expected.\n  assert(Chain.getNode() && Chain.getValueType() == MVT::Other &&\n         \"LowerReturn didn't return a valid chain!\");\n\n  // Update the DAG with the new chain value resulting from return lowering.\n  DAG.setRoot(Chain);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    SDValue RetPtr = DAG.getCopyFromReg(DAG.getEntryNode(), getCurSDLoc(),\n                                        DemoteReg, PtrValueVTs[0]);\n    SDValue RetOp = getValue(I.getOperand(0));\n",
        "src_path": "b0319ab79bf59669803cc2475fae1d12f8eeaca9___SelectionDAGBuilder.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/b0319ab79bf59669803cc2475fae1d12f8eeaca9",
        "commit_msg": "[PR52475] Ensure a correct chain in copies to/from hidden sret parameter\n\nThis patch fixes an issue during SelectionDAG construction. When the\ntarget is unable to lower the function's return value, a hidden sret\nparameter is created. It is initialized and copied to a stored variable\n(DemoteRegister) with CopyToReg and is later fetched with\nCopyFromReg. The bug is that the chains used for each copy are\ninconsistent, and thus in rare cases the scheduler may issue them out of\norder.\n\nThe fix is to ensure that the CopyFromReg uses the DAG root which is set\nas the chain corresponding to the initial CopyToReg.\n\nFixes https://llvm.org/PR52475\n\nReviewed By: craig.topper\n\nDifferential Revision: https://reviews.llvm.org/D114795",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/RISCV/rvv/fixed-vectors-calling-conv-fastcc.ll",
                "patch": "@@ -101,56 +101,56 @@ define fastcc <64 x i32> @ret_split_v64i32(<64 x i32>* %x) {\n define fastcc <128 x i32> @ret_split_v128i32(<128 x i32>* %x) {\n ; LMULMAX8-LABEL: ret_split_v128i32:\n ; LMULMAX8:       # %bb.0:\n-; LMULMAX8-NEXT:    li a2, 32\n-; LMULMAX8-NEXT:    vsetvli zero, a2, e32, m8, ta, mu\n-; LMULMAX8-NEXT:    vle32.v v8, (a1)\n ; LMULMAX8-NEXT:    addi a2, a1, 128\n-; LMULMAX8-NEXT:    vle32.v v16, (a2)\n-; LMULMAX8-NEXT:    addi a2, a1, 384\n-; LMULMAX8-NEXT:    vle32.v v24, (a2)\n-; LMULMAX8-NEXT:    addi a1, a1, 256\n-; LMULMAX8-NEXT:    vle32.v v0, (a1)\n+; LMULMAX8-NEXT:    li a3, 32\n+; LMULMAX8-NEXT:    vsetvli zero, a3, e32, m8, ta, mu\n+; LMULMAX8-NEXT:    vle32.v v8, (a2)\n+; LMULMAX8-NEXT:    addi a2, a1, 256\n+; LMULMAX8-NEXT:    vle32.v v16, (a1)\n+; LMULMAX8-NEXT:    addi a1, a1, 384\n+; LMULMAX8-NEXT:    vle32.v v24, (a1)\n+; LMULMAX8-NEXT:    vle32.v v0, (a2)\n+; LMULMAX8-NEXT:    vse32.v v16, (a0)\n ; LMULMAX8-NEXT:    addi a1, a0, 384\n ; LMULMAX8-NEXT:    vse32.v v24, (a1)\n ; LMULMAX8-NEXT:    addi a1, a0, 256\n ; LMULMAX8-NEXT:    vse32.v v0, (a1)\n-; LMULMAX8-NEXT:    addi a1, a0, 128\n-; LMULMAX8-NEXT:    vse32.v v16, (a1)\n+; LMULMAX8-NEXT:    addi a0, a0, 128\n ; LMULMAX8-NEXT:    vse32.v v8, (a0)\n ; LMULMAX8-NEXT:    ret\n ;\n ; LMULMAX4-LABEL: ret_split_v128i32:\n ; LMULMAX4:       # %bb.0:\n-; LMULMAX4-NEXT:    vsetivli zero, 16, e32, m4, ta, mu\n-; LMULMAX4-NEXT:    vle32.v v8, (a1)\n ; LMULMAX4-NEXT:    addi a2, a1, 64\n-; LMULMAX4-NEXT:    vle32.v v12, (a2)\n+; LMULMAX4-NEXT:    vsetivli zero, 16, e32, m4, ta, mu\n+; LMULMAX4-NEXT:    vle32.v v8, (a2)\n ; LMULMAX4-NEXT:    addi a2, a1, 128\n-; LMULMAX4-NEXT:    vle32.v v16, (a2)\n+; LMULMAX4-NEXT:    vle32.v v12, (a2)\n ; LMULMAX4-NEXT:    addi a2, a1, 192\n-; LMULMAX4-NEXT:    vle32.v v20, (a2)\n+; LMULMAX4-NEXT:    vle32.v v16, (a2)\n ; LMULMAX4-NEXT:    addi a2, a1, 256\n-; LMULMAX4-NEXT:    vle32.v v24, (a2)\n+; LMULMAX4-NEXT:    vle32.v v20, (a2)\n ; LMULMAX4-NEXT:    addi a2, a1, 320\n-; LMULMAX4-NEXT:    vle32.v v28, (a2)\n-; LMULMAX4-NEXT:    addi a2, a1, 448\n-; LMULMAX4-NEXT:    vle32.v v0, (a2)\n-; LMULMAX4-NEXT:    addi a1, a1, 384\n-; LMULMAX4-NEXT:    vle32.v v4, (a1)\n+; LMULMAX4-NEXT:    vle32.v v24, (a2)\n+; LMULMAX4-NEXT:    addi a2, a1, 384\n+; LMULMAX4-NEXT:    vle32.v v28, (a1)\n+; LMULMAX4-NEXT:    addi a1, a1, 448\n+; LMULMAX4-NEXT:    vle32.v v0, (a1)\n+; LMULMAX4-NEXT:    vle32.v v4, (a2)\n+; LMULMAX4-NEXT:    vse32.v v28, (a0)\n ; LMULMAX4-NEXT:    addi a1, a0, 448\n ; LMULMAX4-NEXT:    vse32.v v0, (a1)\n ; LMULMAX4-NEXT:    addi a1, a0, 384\n ; LMULMAX4-NEXT:    vse32.v v4, (a1)\n ; LMULMAX4-NEXT:    addi a1, a0, 320\n-; LMULMAX4-NEXT:    vse32.v v28, (a1)\n-; LMULMAX4-NEXT:    addi a1, a0, 256\n ; LMULMAX4-NEXT:    vse32.v v24, (a1)\n-; LMULMAX4-NEXT:    addi a1, a0, 192\n+; LMULMAX4-NEXT:    addi a1, a0, 256\n ; LMULMAX4-NEXT:    vse32.v v20, (a1)\n-; LMULMAX4-NEXT:    addi a1, a0, 128\n+; LMULMAX4-NEXT:    addi a1, a0, 192\n ; LMULMAX4-NEXT:    vse32.v v16, (a1)\n-; LMULMAX4-NEXT:    addi a1, a0, 64\n+; LMULMAX4-NEXT:    addi a1, a0, 128\n ; LMULMAX4-NEXT:    vse32.v v12, (a1)\n+; LMULMAX4-NEXT:    addi a0, a0, 64\n ; LMULMAX4-NEXT:    vse32.v v8, (a0)\n ; LMULMAX4-NEXT:    ret\n   %v = load <128 x i32>, <128 x i32>* %x"
            },
            {
                "fn": "llvm/test/CodeGen/RISCV/rvv/fixed-vectors-calling-conv.ll",
                "patch": "@@ -233,254 +233,254 @@ define <64 x i32> @ret_split_v64i32(<64 x i32>* %x) {\n define <128 x i32> @ret_split_v128i32(<128 x i32>* %x) {\n ; LMULMAX8-LABEL: ret_split_v128i32:\n ; LMULMAX8:       # %bb.0:\n-; LMULMAX8-NEXT:    li a2, 32\n-; LMULMAX8-NEXT:    vsetvli zero, a2, e32, m8, ta, mu\n-; LMULMAX8-NEXT:    vle32.v v8, (a1)\n ; LMULMAX8-NEXT:    addi a2, a1, 128\n-; LMULMAX8-NEXT:    vle32.v v16, (a2)\n-; LMULMAX8-NEXT:    addi a2, a1, 384\n-; LMULMAX8-NEXT:    vle32.v v24, (a2)\n-; LMULMAX8-NEXT:    addi a1, a1, 256\n-; LMULMAX8-NEXT:    vle32.v v0, (a1)\n+; LMULMAX8-NEXT:    li a3, 32\n+; LMULMAX8-NEXT:    vsetvli zero, a3, e32, m8, ta, mu\n+; LMULMAX8-NEXT:    vle32.v v8, (a2)\n+; LMULMAX8-NEXT:    addi a2, a1, 256\n+; LMULMAX8-NEXT:    vle32.v v16, (a1)\n+; LMULMAX8-NEXT:    addi a1, a1, 384\n+; LMULMAX8-NEXT:    vle32.v v24, (a1)\n+; LMULMAX8-NEXT:    vle32.v v0, (a2)\n+; LMULMAX8-NEXT:    vse32.v v16, (a0)\n ; LMULMAX8-NEXT:    addi a1, a0, 384\n ; LMULMAX8-NEXT:    vse32.v v24, (a1)\n ; LMULMAX8-NEXT:    addi a1, a0, 256\n ; LMULMAX8-NEXT:    vse32.v v0, (a1)\n-; LMULMAX8-NEXT:    addi a1, a0, 128\n-; LMULMAX8-NEXT:    vse32.v v16, (a1)\n+; LMULMAX8-NEXT:    addi a0, a0, 128\n ; LMULMAX8-NEXT:    vse32.v v8, (a0)\n ; LMULMAX8-NEXT:    ret\n ;\n ; LMULMAX4-LABEL: ret_split_v128i32:\n ; LMULMAX4:       # %bb.0:\n-; LMULMAX4-NEXT:    vsetivli zero, 16, e32, m4, ta, mu\n-; LMULMAX4-NEXT:    vle32.v v8, (a1)\n ; LMULMAX4-NEXT:    addi a2, a1, 64\n-; LMULMAX4-NEXT:    vle32.v v12, (a2)\n+; LMULMAX4-NEXT:    vsetivli zero, 16, e32, m4, ta, mu\n+; LMULMAX4-NEXT:    vle32.v v8, (a2)\n ; LMULMAX4-NEXT:    addi a2, a1, 128\n-; LMULMAX4-NEXT:    vle32.v v16, (a2)\n+; LMULMAX4-NEXT:    vle32.v v12, (a2)\n ; LMULMAX4-NEXT:    addi a2, a1, 192\n-; LMULMAX4-NEXT:    vle32.v v20, (a2)\n+; LMULMAX4-NEXT:    vle32.v v16, (a2)\n ; LMULMAX4-NEXT:    addi a2, a1, 256\n-; LMULMAX4-NEXT:    vle32.v v24, (a2)\n+; LMULMAX4-NEXT:    vle32.v v20, (a2)\n ; LMULMAX4-NEXT:    addi a2, a1, 320\n-; LMULMAX4-NEXT:    vle32.v v28, (a2)\n-; LMULMAX4-NEXT:    addi a2, a1, 448\n-; LMULMAX4-NEXT:    vle32.v v0, (a2)\n-; LMULMAX4-NEXT:    addi a1, a1, 384\n-; LMULMAX4-NEXT:    vle32.v v4, (a1)\n+; LMULMAX4-NEXT:    vle32.v v24, (a2)\n+; LMULMAX4-NEXT:    addi a2, a1, 384\n+; LMULMAX4-NEXT:    vle32.v v28, (a1)\n+; LMULMAX4-NEXT:    addi a1, a1, 448\n+; LMULMAX4-NEXT:    vle32.v v0, (a1)\n+; LMULMAX4-NEXT:    vle32.v v4, (a2)\n+; LMULMAX4-NEXT:    vse32.v v28, (a0)\n ; LMULMAX4-NEXT:    addi a1, a0, 448\n ; LMULMAX4-NEXT:    vse32.v v0, (a1)\n ; LMULMAX4-NEXT:    addi a1, a0, 384\n ; LMULMAX4-NEXT:    vse32.v v4, (a1)\n ; LMULMAX4-NEXT:    addi a1, a0, 320\n-; LMULMAX4-NEXT:    vse32.v v28, (a1)\n-; LMULMAX4-NEXT:    addi a1, a0, 256\n ; LMULMAX4-NEXT:    vse32.v v24, (a1)\n-; LMULMAX4-NEXT:    addi a1, a0, 192\n+; LMULMAX4-NEXT:    addi a1, a0, 256\n ; LMULMAX4-NEXT:    vse32.v v20, (a1)\n-; LMULMAX4-NEXT:    addi a1, a0, 128\n+; LMULMAX4-NEXT:    addi a1, a0, 192\n ; LMULMAX4-NEXT:    vse32.v v16, (a1)\n-; LMULMAX4-NEXT:    addi a1, a0, 64\n+; LMULMAX4-NEXT:    addi a1, a0, 128\n ; LMULMAX4-NEXT:    vse32.v v12, (a1)\n+; LMULMAX4-NEXT:    addi a0, a0, 64\n ; LMULMAX4-NEXT:    vse32.v v8, (a0)\n ; LMULMAX4-NEXT:    ret\n ;\n ; LMULMAX2-LABEL: ret_split_v128i32:\n ; LMULMAX2:       # %bb.0:\n-; LMULMAX2-NEXT:    vsetivli zero, 8, e32, m2, ta, mu\n-; LMULMAX2-NEXT:    vle32.v v8, (a1)\n ; LMULMAX2-NEXT:    addi a2, a1, 32\n-; LMULMAX2-NEXT:    vle32.v v10, (a2)\n+; LMULMAX2-NEXT:    vsetivli zero, 8, e32, m2, ta, mu\n+; LMULMAX2-NEXT:    vle32.v v8, (a2)\n ; LMULMAX2-NEXT:    addi a2, a1, 64\n-; LMULMAX2-NEXT:    vle32.v v12, (a2)\n+; LMULMAX2-NEXT:    vle32.v v10, (a2)\n ; LMULMAX2-NEXT:    addi a2, a1, 96\n-; LMULMAX2-NEXT:    vle32.v v14, (a2)\n+; LMULMAX2-NEXT:    vle32.v v12, (a2)\n ; LMULMAX2-NEXT:    addi a2, a1, 128\n-; LMULMAX2-NEXT:    vle32.v v16, (a2)\n+; LMULMAX2-NEXT:    vle32.v v14, (a2)\n ; LMULMAX2-NEXT:    addi a2, a1, 160\n-; LMULMAX2-NEXT:    vle32.v v18, (a2)\n+; LMULMAX2-NEXT:    vle32.v v16, (a2)\n ; LMULMAX2-NEXT:    addi a2, a1, 192\n-; LMULMAX2-NEXT:    vle32.v v20, (a2)\n+; LMULMAX2-NEXT:    vle32.v v18, (a2)\n ; LMULMAX2-NEXT:    addi a2, a1, 224\n-; LMULMAX2-NEXT:    vle32.v v22, (a2)\n+; LMULMAX2-NEXT:    vle32.v v20, (a2)\n ; LMULMAX2-NEXT:    addi a2, a1, 256\n-; LMULMAX2-NEXT:    vle32.v v24, (a2)\n+; LMULMAX2-NEXT:    vle32.v v22, (a2)\n ; LMULMAX2-NEXT:    addi a2, a1, 288\n-; LMULMAX2-NEXT:    vle32.v v26, (a2)\n+; LMULMAX2-NEXT:    vle32.v v24, (a2)\n ; LMULMAX2-NEXT:    addi a2, a1, 320\n-; LMULMAX2-NEXT:    vle32.v v28, (a2)\n+; LMULMAX2-NEXT:    vle32.v v26, (a2)\n ; LMULMAX2-NEXT:    addi a2, a1, 352\n-; LMULMAX2-NEXT:    vle32.v v30, (a2)\n+; LMULMAX2-NEXT:    vle32.v v28, (a2)\n ; LMULMAX2-NEXT:    addi a2, a1, 384\n-; LMULMAX2-NEXT:    vle32.v v0, (a2)\n+; LMULMAX2-NEXT:    vle32.v v30, (a2)\n ; LMULMAX2-NEXT:    addi a2, a1, 416\n-; LMULMAX2-NEXT:    vle32.v v2, (a2)\n-; LMULMAX2-NEXT:    addi a2, a1, 480\n-; LMULMAX2-NEXT:    vle32.v v4, (a2)\n-; LMULMAX2-NEXT:    addi a1, a1, 448\n-; LMULMAX2-NEXT:    vle32.v v6, (a1)\n+; LMULMAX2-NEXT:    vle32.v v0, (a2)\n+; LMULMAX2-NEXT:    addi a2, a1, 448\n+; LMULMAX2-NEXT:    vle32.v v2, (a1)\n+; LMULMAX2-NEXT:    addi a1, a1, 480\n+; LMULMAX2-NEXT:    vle32.v v4, (a1)\n+; LMULMAX2-NEXT:    vle32.v v6, (a2)\n+; LMULMAX2-NEXT:    vse32.v v2, (a0)\n ; LMULMAX2-NEXT:    addi a1, a0, 480\n ; LMULMAX2-NEXT:    vse32.v v4, (a1)\n ; LMULMAX2-NEXT:    addi a1, a0, 448\n ; LMULMAX2-NEXT:    vse32.v v6, (a1)\n ; LMULMAX2-NEXT:    addi a1, a0, 416\n-; LMULMAX2-NEXT:    vse32.v v2, (a1)\n-; LMULMAX2-NEXT:    addi a1, a0, 384\n ; LMULMAX2-NEXT:    vse32.v v0, (a1)\n-; LMULMAX2-NEXT:    addi a1, a0, 352\n+; LMULMAX2-NEXT:    addi a1, a0, 384\n ; LMULMAX2-NEXT:    vse32.v v30, (a1)\n-; LMULMAX2-NEXT:    addi a1, a0, 320\n+; LMULMAX2-NEXT:    addi a1, a0, 352\n ; LMULMAX2-NEXT:    vse32.v v28, (a1)\n-; LMULMAX2-NEXT:    addi a1, a0, 288\n+; LMULMAX2-NEXT:    addi a1, a0, 320\n ; LMULMAX2-NEXT:    vse32.v v26, (a1)\n-; LMULMAX2-NEXT:    addi a1, a0, 256\n+; LMULMAX2-NEXT:    addi a1, a0, 288\n ; LMULMAX2-NEXT:    vse32.v v24, (a1)\n-; LMULMAX2-NEXT:    addi a1, a0, 224\n+; LMULMAX2-NEXT:    addi a1, a0, 256\n ; LMULMAX2-NEXT:    vse32.v v22, (a1)\n-; LMULMAX2-NEXT:    addi a1, a0, 192\n+; LMULMAX2-NEXT:    addi a1, a0, 224\n ; LMULMAX2-NEXT:    vse32.v v20, (a1)\n-; LMULMAX2-NEXT:    addi a1, a0, 160\n+; LMULMAX2-NEXT:    addi a1, a0, 192\n ; LMULMAX2-NEXT:    vse32.v v18, (a1)\n-; LMULMAX2-NEXT:    addi a1, a0, 128\n+; LMULMAX2-NEXT:    addi a1, a0, 160\n ; LMULMAX2-NEXT:    vse32.v v16, (a1)\n-; LMULMAX2-NEXT:    addi a1, a0, 96\n+; LMULMAX2-NEXT:    addi a1, a0, 128\n ; LMULMAX2-NEXT:    vse32.v v14, (a1)\n-; LMULMAX2-NEXT:    addi a1, a0, 64\n+; LMULMAX2-NEXT:    addi a1, a0, 96\n ; LMULMAX2-NEXT:    vse32.v v12, (a1)\n-; LMULMAX2-NEXT:    addi a1, a0, 32\n+; LMULMAX2-NEXT:    addi a1, a0, 64\n ; LMULMAX2-NEXT:    vse32.v v10, (a1)\n+; LMULMAX2-NEXT:    addi a0, a0, 32\n ; LMULMAX2-NEXT:    vse32.v v8, (a0)\n ; LMULMAX2-NEXT:    ret\n ;\n ; LMULMAX1-LABEL: ret_split_v128i32:\n ; LMULMAX1:       # %bb.0:\n-; LMULMAX1-NEXT:    vsetivli zero, 4, e32, m1, ta, mu\n-; LMULMAX1-NEXT:    vle32.v v8, (a1)\n ; LMULMAX1-NEXT:    addi a2, a1, 16\n-; LMULMAX1-NEXT:    vle32.v v9, (a2)\n+; LMULMAX1-NEXT:    vsetivli zero, 4, e32, m1, ta, mu\n+; LMULMAX1-NEXT:    vle32.v v8, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 32\n-; LMULMAX1-NEXT:    vle32.v v10, (a2)\n+; LMULMAX1-NEXT:    vle32.v v9, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 48\n-; LMULMAX1-NEXT:    vle32.v v11, (a2)\n+; LMULMAX1-NEXT:    vle32.v v10, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 64\n-; LMULMAX1-NEXT:    vle32.v v12, (a2)\n+; LMULMAX1-NEXT:    vle32.v v11, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 80\n-; LMULMAX1-NEXT:    vle32.v v13, (a2)\n+; LMULMAX1-NEXT:    vle32.v v12, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 96\n-; LMULMAX1-NEXT:    vle32.v v14, (a2)\n+; LMULMAX1-NEXT:    vle32.v v13, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 112\n-; LMULMAX1-NEXT:    vle32.v v15, (a2)\n+; LMULMAX1-NEXT:    vle32.v v14, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 128\n-; LMULMAX1-NEXT:    vle32.v v16, (a2)\n+; LMULMAX1-NEXT:    vle32.v v15, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 144\n-; LMULMAX1-NEXT:    vle32.v v17, (a2)\n+; LMULMAX1-NEXT:    vle32.v v16, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 160\n-; LMULMAX1-NEXT:    vle32.v v18, (a2)\n+; LMULMAX1-NEXT:    vle32.v v17, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 176\n-; LMULMAX1-NEXT:    vle32.v v19, (a2)\n+; LMULMAX1-NEXT:    vle32.v v18, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 192\n-; LMULMAX1-NEXT:    vle32.v v20, (a2)\n+; LMULMAX1-NEXT:    vle32.v v19, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 208\n-; LMULMAX1-NEXT:    vle32.v v21, (a2)\n+; LMULMAX1-NEXT:    vle32.v v20, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 224\n-; LMULMAX1-NEXT:    vle32.v v22, (a2)\n+; LMULMAX1-NEXT:    vle32.v v21, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 240\n-; LMULMAX1-NEXT:    vle32.v v23, (a2)\n+; LMULMAX1-NEXT:    vle32.v v22, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 256\n-; LMULMAX1-NEXT:    vle32.v v24, (a2)\n+; LMULMAX1-NEXT:    vle32.v v23, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 272\n-; LMULMAX1-NEXT:    vle32.v v25, (a2)\n+; LMULMAX1-NEXT:    vle32.v v24, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 288\n-; LMULMAX1-NEXT:    vle32.v v26, (a2)\n+; LMULMAX1-NEXT:    vle32.v v25, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 304\n-; LMULMAX1-NEXT:    vle32.v v27, (a2)\n+; LMULMAX1-NEXT:    vle32.v v26, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 320\n-; LMULMAX1-NEXT:    vle32.v v28, (a2)\n+; LMULMAX1-NEXT:    vle32.v v27, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 336\n-; LMULMAX1-NEXT:    vle32.v v29, (a2)\n+; LMULMAX1-NEXT:    vle32.v v28, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 352\n-; LMULMAX1-NEXT:    vle32.v v30, (a2)\n+; LMULMAX1-NEXT:    vle32.v v29, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 368\n-; LMULMAX1-NEXT:    vle32.v v31, (a2)\n+; LMULMAX1-NEXT:    vle32.v v30, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 384\n-; LMULMAX1-NEXT:    vle32.v v0, (a2)\n+; LMULMAX1-NEXT:    vle32.v v31, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 400\n-; LMULMAX1-NEXT:    vle32.v v1, (a2)\n+; LMULMAX1-NEXT:    vle32.v v0, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 416\n-; LMULMAX1-NEXT:    vle32.v v2, (a2)\n+; LMULMAX1-NEXT:    vle32.v v1, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 432\n-; LMULMAX1-NEXT:    vle32.v v3, (a2)\n+; LMULMAX1-NEXT:    vle32.v v2, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 448\n-; LMULMAX1-NEXT:    vle32.v v4, (a2)\n+; LMULMAX1-NEXT:    vle32.v v3, (a2)\n ; LMULMAX1-NEXT:    addi a2, a1, 464\n-; LMULMAX1-NEXT:    vle32.v v5, (a2)\n-; LMULMAX1-NEXT:    addi a2, a1, 496\n-; LMULMAX1-NEXT:    vle32.v v6, (a2)\n-; LMULMAX1-NEXT:    addi a1, a1, 480\n-; LMULMAX1-NEXT:    vle32.v v7, (a1)\n+; LMULMAX1-NEXT:    vle32.v v4, (a2)\n+; LMULMAX1-NEXT:    addi a2, a1, 480\n+; LMULMAX1-NEXT:    vle32.v v5, (a1)\n+; LMULMAX1-NEXT:    addi a1, a1, 496\n+; LMULMAX1-NEXT:    vle32.v v6, (a1)\n+; LMULMAX1-NEXT:    vle32.v v7, (a2)\n+; LMULMAX1-NEXT:    vse32.v v5, (a0)\n ; LMULMAX1-NEXT:    addi a1, a0, 496\n ; LMULMAX1-NEXT:    vse32.v v6, (a1)\n ; LMULMAX1-NEXT:    addi a1, a0, 480\n ; LMULMAX1-NEXT:    vse32.v v7, (a1)\n ; LMULMAX1-NEXT:    addi a1, a0, 464\n-; LMULMAX1-NEXT:    vse32.v v5, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 448\n ; LMULMAX1-NEXT:    vse32.v v4, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 432\n+; LMULMAX1-NEXT:    addi a1, a0, 448\n ; LMULMAX1-NEXT:    vse32.v v3, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 416\n+; LMULMAX1-NEXT:    addi a1, a0, 432\n ; LMULMAX1-NEXT:    vse32.v v2, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 400\n+; LMULMAX1-NEXT:    addi a1, a0, 416\n ; LMULMAX1-NEXT:    vse32.v v1, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 384\n+; LMULMAX1-NEXT:    addi a1, a0, 400\n ; LMULMAX1-NEXT:    vse32.v v0, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 368\n+; LMULMAX1-NEXT:    addi a1, a0, 384\n ; LMULMAX1-NEXT:    vse32.v v31, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 352\n+; LMULMAX1-NEXT:    addi a1, a0, 368\n ; LMULMAX1-NEXT:    vse32.v v30, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 336\n+; LMULMAX1-NEXT:    addi a1, a0, 352\n ; LMULMAX1-NEXT:    vse32.v v29, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 320\n+; LMULMAX1-NEXT:    addi a1, a0, 336\n ; LMULMAX1-NEXT:    vse32.v v28, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 304\n+; LMULMAX1-NEXT:    addi a1, a0, 320\n ; LMULMAX1-NEXT:    vse32.v v27, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 288\n+; LMULMAX1-NEXT:    addi a1, a0, 304\n ; LMULMAX1-NEXT:    vse32.v v26, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 272\n+; LMULMAX1-NEXT:    addi a1, a0, 288\n ; LMULMAX1-NEXT:    vse32.v v25, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 256\n+; LMULMAX1-NEXT:    addi a1, a0, 272\n ; LMULMAX1-NEXT:    vse32.v v24, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 240\n+; LMULMAX1-NEXT:    addi a1, a0, 256\n ; LMULMAX1-NEXT:    vse32.v v23, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 224\n+; LMULMAX1-NEXT:    addi a1, a0, 240\n ; LMULMAX1-NEXT:    vse32.v v22, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 208\n+; LMULMAX1-NEXT:    addi a1, a0, 224\n ; LMULMAX1-NEXT:    vse32.v v21, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 192\n+; LMULMAX1-NEXT:    addi a1, a0, 208\n ; LMULMAX1-NEXT:    vse32.v v20, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 176\n+; LMULMAX1-NEXT:    addi a1, a0, 192\n ; LMULMAX1-NEXT:    vse32.v v19, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 160\n+; LMULMAX1-NEXT:    addi a1, a0, 176\n ; LMULMAX1-NEXT:    vse32.v v18, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 144\n+; LMULMAX1-NEXT:    addi a1, a0, 160\n ; LMULMAX1-NEXT:    vse32.v v17, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 128\n+; LMULMAX1-NEXT:    addi a1, a0, 144\n ; LMULMAX1-NEXT:    vse32.v v16, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 112\n+; LMULMAX1-NEXT:    addi a1, a0, 128\n ; LMULMAX1-NEXT:    vse32.v v15, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 96\n+; LMULMAX1-NEXT:    addi a1, a0, 112\n ; LMULMAX1-NEXT:    vse32.v v14, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 80\n+; LMULMAX1-NEXT:    addi a1, a0, 96\n ; LMULMAX1-NEXT:    vse32.v v13, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 64\n+; LMULMAX1-NEXT:    addi a1, a0, 80\n ; LMULMAX1-NEXT:    vse32.v v12, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 48\n+; LMULMAX1-NEXT:    addi a1, a0, 64\n ; LMULMAX1-NEXT:    vse32.v v11, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 32\n+; LMULMAX1-NEXT:    addi a1, a0, 48\n ; LMULMAX1-NEXT:    vse32.v v10, (a1)\n-; LMULMAX1-NEXT:    addi a1, a0, 16\n+; LMULMAX1-NEXT:    addi a1, a0, 32\n ; LMULMAX1-NEXT:    vse32.v v9, (a1)\n+; LMULMAX1-NEXT:    addi a0, a0, 16\n ; LMULMAX1-NEXT:    vse32.v v8, (a0)\n ; LMULMAX1-NEXT:    ret\n   %v = load <128 x i32>, <128 x i32>* %x"
            },
            {
                "fn": "llvm/test/CodeGen/RISCV/rvv/pr52475.ll",
                "patch": "@@ -0,0 +1,44 @@\n+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py\n+; RUN: llc -mtriple=riscv32 -mattr=+experimental-v -riscv-v-vector-bits-min=128 -riscv-v-fixed-length-vector-lmul-max=4 \\\n+; RUN:   -pre-RA-sched=list-burr -disable-machine-cse -verify-machineinstrs < %s | FileCheck %s\n+; RUN: llc -mtriple=riscv64 -mattr=+experimental-v -riscv-v-vector-bits-min=128 -riscv-v-fixed-length-vector-lmul-max=4 \\\n+; RUN:   -pre-RA-sched=list-burr -disable-machine-cse -verify-machineinstrs < %s | FileCheck %s\n+\n+define <128 x i32> @ret_split_v128i32(<128 x i32>* %x) {\n+; CHECK-LABEL: ret_split_v128i32:\n+; CHECK:       # %bb.0:\n+; CHECK-NEXT:    vsetivli zero, 16, e32, m4, ta, mu\n+; CHECK-NEXT:    vle32.v v8, (a1)\n+; CHECK-NEXT:    vse32.v v8, (a0)\n+; CHECK-NEXT:    addi a2, a1, 448\n+; CHECK-NEXT:    vle32.v v8, (a2)\n+; CHECK-NEXT:    addi a2, a0, 448\n+; CHECK-NEXT:    vse32.v v8, (a2)\n+; CHECK-NEXT:    addi a2, a1, 384\n+; CHECK-NEXT:    vle32.v v8, (a2)\n+; CHECK-NEXT:    addi a2, a0, 384\n+; CHECK-NEXT:    vse32.v v8, (a2)\n+; CHECK-NEXT:    addi a2, a1, 320\n+; CHECK-NEXT:    vle32.v v8, (a2)\n+; CHECK-NEXT:    addi a2, a0, 320\n+; CHECK-NEXT:    vse32.v v8, (a2)\n+; CHECK-NEXT:    addi a2, a1, 256\n+; CHECK-NEXT:    vle32.v v8, (a2)\n+; CHECK-NEXT:    addi a2, a0, 256\n+; CHECK-NEXT:    vse32.v v8, (a2)\n+; CHECK-NEXT:    addi a2, a1, 192\n+; CHECK-NEXT:    vle32.v v8, (a2)\n+; CHECK-NEXT:    addi a2, a0, 192\n+; CHECK-NEXT:    vse32.v v8, (a2)\n+; CHECK-NEXT:    addi a2, a1, 128\n+; CHECK-NEXT:    vle32.v v8, (a2)\n+; CHECK-NEXT:    addi a2, a0, 128\n+; CHECK-NEXT:    vse32.v v8, (a2)\n+; CHECK-NEXT:    addi a1, a1, 64\n+; CHECK-NEXT:    vle32.v v8, (a1)\n+; CHECK-NEXT:    addi a0, a0, 64\n+; CHECK-NEXT:    vse32.v v8, (a0)\n+; CHECK-NEXT:    ret\n+  %v = load <128 x i32>, <128 x i32>* %x\n+  ret <128 x i32> %v\n+}"
            },
            {
                "fn": "llvm/test/CodeGen/RISCV/srem-vector-lkk.ll",
                "patch": "@@ -842,10 +842,10 @@ define <4 x i16> @dont_fold_srem_one(<4 x i16> %x) nounwind {\n ; RV32I-NEXT:    addi a1, a0, 1327\n ; RV32I-NEXT:    mv a0, s2\n ; RV32I-NEXT:    call __modsi3@plt\n-; RV32I-NEXT:    sh zero, 0(s0)\n ; RV32I-NEXT:    sh a0, 6(s0)\n ; RV32I-NEXT:    sh s1, 4(s0)\n ; RV32I-NEXT:    sh s3, 2(s0)\n+; RV32I-NEXT:    sh zero, 0(s0)\n ; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload\n ; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload\n ; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload\n@@ -919,10 +919,10 @@ define <4 x i16> @dont_fold_srem_one(<4 x i16> %x) nounwind {\n ; RV64I-NEXT:    addiw a1, a0, 1327\n ; RV64I-NEXT:    mv a0, s2\n ; RV64I-NEXT:    call __moddi3@plt\n-; RV64I-NEXT:    sh zero, 0(s0)\n ; RV64I-NEXT:    sh a0, 6(s0)\n ; RV64I-NEXT:    sh s1, 4(s0)\n ; RV64I-NEXT:    sh s3, 2(s0)\n+; RV64I-NEXT:    sh zero, 0(s0)\n ; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload\n ; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload\n ; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload\n@@ -1018,9 +1018,9 @@ define <4 x i16> @dont_fold_urem_i16_smax(<4 x i16> %x) nounwind {\n ; RV32I-NEXT:    addi a1, a0, 1327\n ; RV32I-NEXT:    mv a0, s2\n ; RV32I-NEXT:    call __modsi3@plt\n-; RV32I-NEXT:    sh zero, 0(s0)\n ; RV32I-NEXT:    sh a0, 6(s0)\n ; RV32I-NEXT:    sh s1, 4(s0)\n+; RV32I-NEXT:    sh zero, 0(s0)\n ; RV32I-NEXT:    sh s3, 2(s0)\n ; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload\n ; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload\n@@ -1090,9 +1090,9 @@ define <4 x i16> @dont_fold_urem_i16_smax(<4 x i16> %x) nounwind {\n ; RV64I-NEXT:    addiw a1, a0, 1327\n ; RV64I-NEXT:    mv a0, s2\n ; RV64I-NEXT:    call __moddi3@plt\n-; RV64I-NEXT:    sh zero, 0(s0)\n ; RV64I-NEXT:    sh a0, 6(s0)\n ; RV64I-NEXT:    sh s1, 4(s0)\n+; RV64I-NEXT:    sh zero, 0(s0)\n ; RV64I-NEXT:    sh s3, 2(s0)\n ; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload\n ; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload\n@@ -1321,10 +1321,10 @@ define <4 x i64> @dont_fold_srem_i64(<4 x i64> %x) nounwind {\n ; RV64I-NEXT:    addiw a1, a0, 1327\n ; RV64I-NEXT:    mv a0, s2\n ; RV64I-NEXT:    call __moddi3@plt\n-; RV64I-NEXT:    sd zero, 0(s0)\n ; RV64I-NEXT:    sd a0, 24(s0)\n ; RV64I-NEXT:    sd s1, 16(s0)\n ; RV64I-NEXT:    sd s3, 8(s0)\n+; RV64I-NEXT:    sd zero, 0(s0)\n ; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload\n ; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload\n ; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload"
            },
            {
                "fn": "llvm/test/CodeGen/RISCV/urem-vector-lkk.ll",
                "patch": "@@ -799,10 +799,10 @@ define <4 x i16> @dont_fold_urem_one(<4 x i16> %x) nounwind {\n ; RV32I-NEXT:    addi a1, a0, 1327\n ; RV32I-NEXT:    mv a0, s2\n ; RV32I-NEXT:    call __umodsi3@plt\n-; RV32I-NEXT:    sh zero, 0(s0)\n ; RV32I-NEXT:    sh a0, 6(s0)\n ; RV32I-NEXT:    sh s1, 4(s0)\n ; RV32I-NEXT:    sh s3, 2(s0)\n+; RV32I-NEXT:    sh zero, 0(s0)\n ; RV32I-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload\n ; RV32I-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload\n ; RV32I-NEXT:    lw s1, 20(sp) # 4-byte Folded Reload\n@@ -869,10 +869,10 @@ define <4 x i16> @dont_fold_urem_one(<4 x i16> %x) nounwind {\n ; RV64I-NEXT:    addiw a1, a0, 1327\n ; RV64I-NEXT:    mv a0, s2\n ; RV64I-NEXT:    call __umoddi3@plt\n-; RV64I-NEXT:    sh zero, 0(s0)\n ; RV64I-NEXT:    sh a0, 6(s0)\n ; RV64I-NEXT:    sh s1, 4(s0)\n ; RV64I-NEXT:    sh s3, 2(s0)\n+; RV64I-NEXT:    sh zero, 0(s0)\n ; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload\n ; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload\n ; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload\n@@ -1116,10 +1116,10 @@ define <4 x i64> @dont_fold_urem_i64(<4 x i64> %x) nounwind {\n ; RV64I-NEXT:    addiw a1, a0, 1327\n ; RV64I-NEXT:    mv a0, s2\n ; RV64I-NEXT:    call __umoddi3@plt\n-; RV64I-NEXT:    sd zero, 0(s0)\n ; RV64I-NEXT:    sd a0, 24(s0)\n ; RV64I-NEXT:    sd s1, 16(s0)\n ; RV64I-NEXT:    sd s3, 8(s0)\n+; RV64I-NEXT:    sd zero, 0(s0)\n ; RV64I-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload\n ; RV64I-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload\n ; RV64I-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload"
            },
            {
                "fn": "llvm/test/CodeGen/WebAssembly/multi-return.ll",
                "patch": "@@ -86,10 +86,10 @@ define { i64, i128 } @test5() {\n ; CHECK: i64.load\t$[[L2:[0-9]+]]=, 8($[[SP]])\n ; CHECK: i64.load\t$push2=, 16($[[SP]])\n ; CHECK: i64.store\t8($0), $pop2\n+; CHECK: i64.store\t0($0), $[[L2]]\n ; CHECK: i32.const\t$push12=, 16\n ; CHECK: i32.add \t$push3=, $0, $pop12\n ; CHECK: i64.store\t0($pop3), $[[L1]]\n-; CHECK: i64.store\t0($0), $[[L2]]\n   %t0 = call { i64, i128, i192, i128, i64 } @return_multi_multi()\n   %r0 = extractvalue { i64, i128, i192, i128, i64 } %t0, 0\n   %r1 = extractvalue { i64, i128, i192, i128, i64 } %t0, 1\n@@ -101,20 +101,20 @@ define { i64, i128 } @test5() {\n define { i128, i128 } @test6() {\n ; CHECK-LABEL: test6\n ; CHECK: call    \treturn_multi_multi\n-; CHECK: i32.const\t$push0=, 24\n+; CHECK: i32.const\t$push0=, 64\n ; CHECK: i32.add \t$push1=, $[[SP:[0-9]+]], $pop0\n ; CHECK: i64.load\t$[[L1:[0-9]+]]=, 0($pop1)\n-; CHECK: i32.const\t$push2=, 64\n+; CHECK: i32.const\t$push2=, 24\n ; CHECK: i32.add \t$push3=, $[[SP]], $pop2\n ; CHECK: i64.load\t$[[L2:[0-9]+]]=, 0($pop3)\n ; CHECK: i64.load\t$[[L3:[0-9]+]]=, 16($[[SP]])\n ; CHECK: i64.load\t$push4=, 56($[[SP]])\n ; CHECK: i64.store\t16($0), $pop4\n+; CHECK: i64.store\t0($0), $[[L3]]\n+; CHECK: i64.store\t8($0), $[[L2]]\n ; CHECK: i32.const\t$push5=, 24\n ; CHECK: i32.add \t$push6=, $0, $pop5\n-; CHECK: i64.store\t0($pop6), $[[L2]]\n-; CHECK: i64.store\t0($0), $[[L3]]\n-; CHECK: i64.store\t8($0), $[[L1]]\n+; CHECK: i64.store\t0($pop6), $[[L1]]\n   %t0 = call { i64, i128, i192, i128, i64 } @return_multi_multi()\n   %r1 = extractvalue { i64, i128, i192, i128, i64 } %t0, 1\n   %r3 = extractvalue { i64, i128, i192, i128, i64 } %t0, 3\n@@ -126,22 +126,22 @@ define { i128, i128 } @test6() {\n define { i64, i192 } @test7() {\n ; CHECK-LABEL: test7\n ; CHECK: call    \treturn_multi_multi\n-; CHECK: i32.const\t$push2=, 40\n-; CHECK: i32.add \t$push3=, $[[SP:[0-9]+]], $pop2\n-; CHECK: i64.load\t$[[L1:[0-9]+]]=, 0($pop3)\n-; CHECK: i64.load\t$[[L2:[0-9]+]]=, 8($[[SP]])\n-; CHECK: i64.load\t$[[L3:[0-9]+]]=, 32($[[SP]])\n-; CHECK: i32.const\t$push0=, 24\n-; CHECK: i32.add \t$push1=, $0, $pop0\n-; CHECK: i32.const\t$push4=, 48\n-; CHECK: i32.add \t$push5=, $[[SP]], $pop4\n-; CHECK: i64.load\t$push6=, 0($pop5)\n-; CHECK: i64.store\t0($pop1), $pop6\n-; CHECK: i64.store\t8($0), $[[L3]]\n+; CHECK: i32.const\t$push0=, 40\n+; CHECK: i32.add \t$push1=, $[[SP:[0-9]+]], $pop0\n+; CHECK: i64.load\t$[[L1:[0-9]+]]=, 0($pop1)\n+; CHECK: i32.const\t$push2=, 48\n+; CHECK: i32.add \t$push3=, $[[SP]], $pop2\n+; CHECK: i64.load\t$[[L2:[0-9]+]]=, 0($pop3)\n+; CHECK: i64.load\t$[[L3:[0-9]+]]=, 8($[[SP]])\n+; CHECK: i64.load\t$push4=, 32($[[SP]])\n+; CHECK: i64.store\t8($0), $pop4\n+; CHECK: i64.store\t0($0), $[[L3]]\n+; CHECK: i32.const\t$push5=, 24\n+; CHECK: i32.add \t$push6=, $0, $pop5\n+; CHECK: i64.store\t0($pop6), $[[L2]]\n ; CHECK: i32.const\t$push7=, 16\n ; CHECK: i32.add \t$push8=, $0, $pop7\n ; CHECK: i64.store\t0($pop8), $[[L1]]\n-; CHECK: i64.store\t0($0), $[[L2]]\n   %t0 = call { i64, i128, i192, i128, i64 } @return_multi_multi()\n   %r0 = extractvalue { i64, i128, i192, i128, i64 } %t0, 0\n   %r2 = extractvalue { i64, i128, i192, i128, i64 } %t0, 2\n@@ -153,38 +153,38 @@ define { i64, i192 } @test7() {\n define { i128, i192, i128, i64 } @test8() {\n ; CHECK-LABEL: test8\n ; CHECK: call    \treturn_multi_multi\n-; CHECK: i32.const\t$push0=, 64\n-; CHECK: i32.add \t$push1=, $[[SP:[0-9]+]], $pop0\n-; CHECK: i64.load\t$[[L1:[0-9]+]]=, 0($pop1)\n ; CHECK: i32.const\t$push20=, 8\n-; CHECK: i32.add \t$push21=, $[[SP]], $pop20\n-; CHECK: i32.const\t$push2=, 32\n-; CHECK: i32.add \t$push3=, $pop21, $pop2\n+; CHECK: i32.add \t$push21=, $[[SP:[0-9]+]], $pop20\n+; CHECK: i32.const\t$push0=, 32\n+; CHECK: i32.add \t$push1=, $pop21, $pop0\n+; CHECK: i64.load\t$[[L1:[0-9]+]]=, 0($pop1)\n+; CHECK: i32.const\t$push2=, 48\n+; CHECK: i32.add \t$push3=, $[[SP]], $pop2\n ; CHECK: i64.load\t$[[L2:[0-9]+]]=, 0($pop3)\n-; CHECK: i32.const\t$push4=, 48\n+; CHECK: i32.const\t$push4=, 24\n ; CHECK: i32.add \t$push5=, $[[SP]], $pop4\n ; CHECK: i64.load\t$[[L3:[0-9]+]]=, 0($pop5)\n-; CHECK: i32.const\t$push6=, 24\n+; CHECK: i32.const\t$push6=, 64\n ; CHECK: i32.add \t$push7=, $[[SP]], $pop6\n ; CHECK: i64.load\t$[[L4:[0-9]+]]=, 0($pop7)\n ; CHECK: i64.load\t$[[L5:[0-9]+]]=, 8($[[SP]])\n ; CHECK: i64.load\t$[[L6:[0-9]+]]=, 56($[[SP]])\n ; CHECK: i64.load\t$[[L7:[0-9]+]]=, 32($[[SP]])\n ; CHECK: i64.load\t$push8=, 16($[[SP]])\n ; CHECK: i64.store\t40($0), $pop8\n+; CHECK: i64.store\t16($0), $[[L7]]\n+; CHECK: i64.store\t0($0), $[[L6]]\n+; CHECK: i64.store\t8($0), $[[L4]]\n+; CHECK: i64.store\t56($0), $[[L5]]\n ; CHECK: i32.const\t$push9=, 48\n ; CHECK: i32.add \t$push10=, $0, $pop9\n-; CHECK: i64.store\t0($pop10), $[[L4]]\n+; CHECK: i64.store\t0($pop10), $[[L3]]\n ; CHECK: i32.const\t$push22=, 32\n ; CHECK: i32.add \t$push11=, $0, $pop22\n-; CHECK: i64.store\t0($pop11), $[[L3]]\n-; CHECK: i64.store\t16($0), $[[L7]]\n+; CHECK: i64.store\t0($pop11), $[[L2]]\n ; CHECK: i32.const\t$push12=, 24\n ; CHECK: i32.add \t$push13=, $0, $pop12\n-; CHECK: i64.store\t0($pop13), $[[L2]]\n-; CHECK: i64.store\t0($0), $[[L6]]\n-; CHECK: i64.store\t8($0), $[[L1]]\n-; CHECK: i64.store\t56($0), $[[L5]]\n+; CHECK: i64.store\t0($pop13), $[[L1]]\n   %t0 = call { i64, i128, i192, i128, i64 } @return_multi_multi()\n   %r0 = extractvalue { i64, i128, i192, i128, i64 } %t0, 0\n   %r1 = extractvalue { i64, i128, i192, i128, i64 } %t0, 1"
            },
            {
                "fn": "llvm/test/CodeGen/WebAssembly/simd-conversions.ll",
                "patch": "@@ -313,14 +313,14 @@ define <4 x double> @convert_low_s_v4f64(<8 x i32> %x) {\n ; CHECK-NEXT:  # %bb.0:\n ; CHECK-NEXT:    local.get 0\n ; CHECK-NEXT:    local.get 1\n-; CHECK-NEXT:    f64x2.convert_low_i32x4_s\n-; CHECK-NEXT:    v128.store 0\n-; CHECK-NEXT:    local.get 0\n-; CHECK-NEXT:    local.get 1\n ; CHECK-NEXT:    local.get 1\n ; CHECK-NEXT:    i8x16.shuffle 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0\n ; CHECK-NEXT:    f64x2.convert_low_i32x4_s\n ; CHECK-NEXT:    v128.store 16\n+; CHECK-NEXT:    local.get 0\n+; CHECK-NEXT:    local.get 1\n+; CHECK-NEXT:    f64x2.convert_low_i32x4_s\n+; CHECK-NEXT:    v128.store 0\n ; CHECK-NEXT:    # fallthrough-return\n   %v = shufflevector <8 x i32> %x, <8 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n   %a = sitofp <4 x i32> %v to <4 x double>\n@@ -333,14 +333,14 @@ define <4 x double> @convert_low_u_v4f64(<8 x i32> %x) {\n ; CHECK-NEXT:  # %bb.0:\n ; CHECK-NEXT:    local.get 0\n ; CHECK-NEXT:    local.get 1\n-; CHECK-NEXT:    f64x2.convert_low_i32x4_u\n-; CHECK-NEXT:    v128.store 0\n-; CHECK-NEXT:    local.get 0\n-; CHECK-NEXT:    local.get 1\n ; CHECK-NEXT:    local.get 1\n ; CHECK-NEXT:    i8x16.shuffle 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0\n ; CHECK-NEXT:    f64x2.convert_low_i32x4_u\n ; CHECK-NEXT:    v128.store 16\n+; CHECK-NEXT:    local.get 0\n+; CHECK-NEXT:    local.get 1\n+; CHECK-NEXT:    f64x2.convert_low_i32x4_u\n+; CHECK-NEXT:    v128.store 0\n ; CHECK-NEXT:    # fallthrough-return\n   %v = shufflevector <8 x i32> %x, <8 x i32> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n   %a = uitofp <4 x i32> %v to <4 x double>\n@@ -354,14 +354,14 @@ define <4 x double> @convert_low_s_v4f64_2(<8 x i32> %x) {\n ; CHECK-NEXT:  # %bb.0:\n ; CHECK-NEXT:    local.get 0\n ; CHECK-NEXT:    local.get 1\n-; CHECK-NEXT:    f64x2.convert_low_i32x4_s\n-; CHECK-NEXT:    v128.store 0\n-; CHECK-NEXT:    local.get 0\n-; CHECK-NEXT:    local.get 1\n ; CHECK-NEXT:    local.get 1\n ; CHECK-NEXT:    i8x16.shuffle 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0\n ; CHECK-NEXT:    f64x2.convert_low_i32x4_s\n ; CHECK-NEXT:    v128.store 16\n+; CHECK-NEXT:    local.get 0\n+; CHECK-NEXT:    local.get 1\n+; CHECK-NEXT:    f64x2.convert_low_i32x4_s\n+; CHECK-NEXT:    v128.store 0\n ; CHECK-NEXT:    # fallthrough-return\n   %v = sitofp <8 x i32> %x to <8 x double>\n   %a = shufflevector <8 x double> %v, <8 x double> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n@@ -374,14 +374,14 @@ define <4 x double> @convert_low_u_v4f64_2(<8 x i32> %x) {\n ; CHECK-NEXT:  # %bb.0:\n ; CHECK-NEXT:    local.get 0\n ; CHECK-NEXT:    local.get 1\n-; CHECK-NEXT:    f64x2.convert_low_i32x4_u\n-; CHECK-NEXT:    v128.store 0\n-; CHECK-NEXT:    local.get 0\n-; CHECK-NEXT:    local.get 1\n ; CHECK-NEXT:    local.get 1\n ; CHECK-NEXT:    i8x16.shuffle 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0\n ; CHECK-NEXT:    f64x2.convert_low_i32x4_u\n ; CHECK-NEXT:    v128.store 16\n+; CHECK-NEXT:    local.get 0\n+; CHECK-NEXT:    local.get 1\n+; CHECK-NEXT:    f64x2.convert_low_i32x4_u\n+; CHECK-NEXT:    v128.store 0\n ; CHECK-NEXT:    # fallthrough-return\n   %v = uitofp <8 x i32> %x to <8 x double>\n   %a = shufflevector <8 x double> %v, <8 x double> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n@@ -394,14 +394,14 @@ define <4 x double> @promote_low_v4f64(<8 x float> %x) {\n ; CHECK-NEXT:  # %bb.0:\n ; CHECK-NEXT:    local.get 0\n ; CHECK-NEXT:    local.get 1\n-; CHECK-NEXT:    f64x2.promote_low_f32x4\n-; CHECK-NEXT:    v128.store 0\n-; CHECK-NEXT:    local.get 0\n-; CHECK-NEXT:    local.get 1\n ; CHECK-NEXT:    local.get 1\n ; CHECK-NEXT:    i8x16.shuffle 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0\n ; CHECK-NEXT:    f64x2.promote_low_f32x4\n ; CHECK-NEXT:    v128.store 16\n+; CHECK-NEXT:    local.get 0\n+; CHECK-NEXT:    local.get 1\n+; CHECK-NEXT:    f64x2.promote_low_f32x4\n+; CHECK-NEXT:    v128.store 0\n ; CHECK-NEXT:    # fallthrough-return\n   %v = shufflevector <8 x float> %x, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>\n   %a = fpext <4 x float> %v to <4 x double>\n@@ -414,14 +414,14 @@ define <4 x double> @promote_low_v4f64_2(<8 x float> %x) {\n ; CHECK-NEXT:  # %bb.0:\n ; CHECK-NEXT:    local.get 0\n ; CHECK-NEXT:    local.get 1\n-; CHECK-NEXT:    f64x2.promote_low_f32x4\n-; CHECK-NEXT:    v128.store 0\n-; CHECK-NEXT:    local.get 0\n-; CHECK-NEXT:    local.get 1\n ; CHECK-NEXT:    local.get 1\n ; CHECK-NEXT:    i8x16.shuffle 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0\n ; CHECK-NEXT:    f64x2.promote_low_f32x4\n ; CHECK-NEXT:    v128.store 16\n+; CHECK-NEXT:    local.get 0\n+; CHECK-NEXT:    local.get 1\n+; CHECK-NEXT:    f64x2.promote_low_f32x4\n+; CHECK-NEXT:    v128.store 0\n ; CHECK-NEXT:    # fallthrough-return\n   %v = fpext <8 x float> %x to <8 x double>\n   %a = shufflevector <8 x double> %v, <8 x double> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>"
            },
            {
                "fn": "llvm/test/CodeGen/X86/addcarry.ll",
                "patch": "@@ -51,9 +51,9 @@ define i256 @add256(i256 %a, i256 %b) nounwind {\n ; CHECK-NEXT:    adcq {{[0-9]+}}(%rsp), %rdx\n ; CHECK-NEXT:    adcq {{[0-9]+}}(%rsp), %rcx\n ; CHECK-NEXT:    adcq {{[0-9]+}}(%rsp), %r8\n+; CHECK-NEXT:    movq %rcx, 16(%rdi)\n ; CHECK-NEXT:    movq %rdx, 8(%rdi)\n ; CHECK-NEXT:    movq %rsi, (%rdi)\n-; CHECK-NEXT:    movq %rcx, 16(%rdi)\n ; CHECK-NEXT:    movq %r8, 24(%rdi)\n ; CHECK-NEXT:    retq\n entry:"
            },
            {
                "fn": "llvm/test/CodeGen/X86/fp128-cast.ll",
                "patch": "@@ -1225,9 +1225,9 @@ define fp128 @TestPair128(i64 %a, i64 %b) nounwind {\n ; X32-NEXT:    adcl $0, %edx\n ; X32-NEXT:    adcl $0, %esi\n ; X32-NEXT:    adcl $0, %edi\n+; X32-NEXT:    movl %esi, 8(%eax)\n ; X32-NEXT:    movl %edx, 4(%eax)\n ; X32-NEXT:    movl %ecx, (%eax)\n-; X32-NEXT:    movl %esi, 8(%eax)\n ; X32-NEXT:    movl %edi, 12(%eax)\n ; X32-NEXT:    popl %esi\n ; X32-NEXT:    popl %edi"
            },
            {
                "fn": "llvm/test/CodeGen/X86/i128-add.ll",
                "patch": "@@ -20,8 +20,8 @@ define i128 @add_i128(i128 %x, i128 %y) nounwind {\n ; X86-NEXT:    adcl $0, %edi\n ; X86-NEXT:    adcl $0, %edx\n ; X86-NEXT:    adcl $0, %ecx\n-; X86-NEXT:    movl %esi, (%eax)\n ; X86-NEXT:    movl %edi, 4(%eax)\n+; X86-NEXT:    movl %esi, (%eax)\n ; X86-NEXT:    movl %edx, 8(%eax)\n ; X86-NEXT:    movl %ecx, 12(%eax)\n ; X86-NEXT:    popl %esi\n@@ -61,8 +61,8 @@ define <1 x i128> @add_v1i128(<1 x i128> %x, <1 x i128> %y) nounwind {\n ; X86-NEXT:    adcl $0, %edi\n ; X86-NEXT:    adcl $0, %edx\n ; X86-NEXT:    adcl $0, %ecx\n-; X86-NEXT:    movl %esi, (%eax)\n ; X86-NEXT:    movl %edi, 4(%eax)\n+; X86-NEXT:    movl %esi, (%eax)\n ; X86-NEXT:    movl %edx, 8(%eax)\n ; X86-NEXT:    movl %ecx, 12(%eax)\n ; X86-NEXT:    popl %esi"
            },
            {
                "fn": "llvm/test/CodeGen/X86/masked_load.ll",
                "patch": "@@ -7179,12 +7179,12 @@ define <16 x i64> @load_one_mask_bit_set6(<16 x i64>* %addr, <16 x i64> %val) {\n ; SSE2-NEXT:    movsd {{.*#+}} xmm8 = mem[0],zero\n ; SSE2-NEXT:    movlhps {{.*#+}} xmm6 = xmm6[0],xmm8[0]\n ; SSE2-NEXT:    movaps %xmm7, 112(%rdi)\n+; SSE2-NEXT:    movaps %xmm5, 80(%rdi)\n ; SSE2-NEXT:    movaps %xmm4, 64(%rdi)\n ; SSE2-NEXT:    movaps %xmm3, 48(%rdi)\n ; SSE2-NEXT:    movaps %xmm2, 32(%rdi)\n-; SSE2-NEXT:    movaps %xmm0, (%rdi)\n-; SSE2-NEXT:    movaps %xmm5, 80(%rdi)\n ; SSE2-NEXT:    movaps %xmm1, 16(%rdi)\n+; SSE2-NEXT:    movaps %xmm0, (%rdi)\n ; SSE2-NEXT:    movaps %xmm6, 96(%rdi)\n ; SSE2-NEXT:    retq\n ;\n@@ -7195,13 +7195,13 @@ define <16 x i64> @load_one_mask_bit_set6(<16 x i64>* %addr, <16 x i64> %val) {\n ; SSE42-NEXT:    pinsrq $0, 80(%rsi), %xmm5\n ; SSE42-NEXT:    pinsrq $1, 104(%rsi), %xmm6\n ; SSE42-NEXT:    movaps %xmm7, 112(%rdi)\n+; SSE42-NEXT:    movdqa %xmm6, 96(%rdi)\n+; SSE42-NEXT:    movdqa %xmm5, 80(%rdi)\n ; SSE42-NEXT:    movaps %xmm4, 64(%rdi)\n ; SSE42-NEXT:    movaps %xmm3, 48(%rdi)\n ; SSE42-NEXT:    movaps %xmm2, 32(%rdi)\n-; SSE42-NEXT:    movaps %xmm0, (%rdi)\n-; SSE42-NEXT:    movdqa %xmm6, 96(%rdi)\n-; SSE42-NEXT:    movdqa %xmm5, 80(%rdi)\n ; SSE42-NEXT:    movdqa %xmm1, 16(%rdi)\n+; SSE42-NEXT:    movaps %xmm0, (%rdi)\n ; SSE42-NEXT:    retq\n ;\n ; AVX1-LABEL: load_one_mask_bit_set6:"
            },
            {
                "fn": "llvm/test/CodeGen/X86/mul128.ll",
                "patch": "@@ -52,13 +52,13 @@ define i128 @foo(i128 %t, i128 %u) {\n ; X86-NEXT:    imull %esi, %ecx\n ; X86-NEXT:    addl %edx, %ecx\n ; X86-NEXT:    addl %ebx, %eax\n-; X86-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill\n+; X86-NEXT:    movl %eax, (%esp) # 4-byte Spill\n ; X86-NEXT:    adcl %edi, %ecx\n ; X86-NEXT:    movl %esi, %eax\n ; X86-NEXT:    movl {{[0-9]+}}(%esp), %esi\n ; X86-NEXT:    mull %esi\n ; X86-NEXT:    movl %edx, %edi\n-; X86-NEXT:    movl %eax, (%esp) # 4-byte Spill\n+; X86-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill\n ; X86-NEXT:    movl %ebp, %eax\n ; X86-NEXT:    mull %esi\n ; X86-NEXT:    movl %edx, %ebx\n@@ -77,12 +77,12 @@ define i128 @foo(i128 %t, i128 %u) {\n ; X86-NEXT:    addl %edi, %eax\n ; X86-NEXT:    movzbl %bl, %esi\n ; X86-NEXT:    adcl %esi, %edx\n-; X86-NEXT:    addl {{[-0-9]+}}(%e{{[sb]}}p), %eax # 4-byte Folded Reload\n+; X86-NEXT:    addl (%esp), %eax # 4-byte Folded Reload\n ; X86-NEXT:    adcl %ecx, %edx\n ; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n-; X86-NEXT:    movl (%esp), %esi # 4-byte Reload\n-; X86-NEXT:    movl %esi, (%ecx)\n ; X86-NEXT:    movl %ebp, 4(%ecx)\n+; X86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %esi # 4-byte Reload\n+; X86-NEXT:    movl %esi, (%ecx)\n ; X86-NEXT:    movl %eax, 8(%ecx)\n ; X86-NEXT:    movl %edx, 12(%ecx)\n ; X86-NEXT:    movl %ecx, %eax"
            },
            {
                "fn": "llvm/test/CodeGen/X86/pmulh.ll",
                "patch": "@@ -1279,29 +1279,29 @@ define <32 x i32> @mulhsw_v32i16_ashr(<32 x i16> %a, <32 x i16> %b) {\n ; SSE41:       # %bb.0:\n ; SSE41-NEXT:    movq %rdi, %rax\n ; SSE41-NEXT:    pmulhw %xmm4, %xmm0\n-; SSE41-NEXT:    pshufd {{.*#+}} xmm4 = xmm0[2,3,2,3]\n-; SSE41-NEXT:    pmovsxwd %xmm4, %xmm4\n-; SSE41-NEXT:    pmulhw %xmm5, %xmm1\n-; SSE41-NEXT:    pshufd {{.*#+}} xmm5 = xmm1[2,3,2,3]\n-; SSE41-NEXT:    pmovsxwd %xmm5, %xmm5\n-; SSE41-NEXT:    pmulhw %xmm6, %xmm2\n-; SSE41-NEXT:    pshufd {{.*#+}} xmm6 = xmm2[2,3,2,3]\n-; SSE41-NEXT:    pmovsxwd %xmm6, %xmm6\n-; SSE41-NEXT:    pmulhw %xmm7, %xmm3\n-; SSE41-NEXT:    pshufd {{.*#+}} xmm7 = xmm3[2,3,2,3]\n-; SSE41-NEXT:    pmovsxwd %xmm7, %xmm7\n+; SSE41-NEXT:    pmovsxwd %xmm0, %xmm4\n+; SSE41-NEXT:    pshufd {{.*#+}} xmm0 = xmm0[2,3,2,3]\n ; SSE41-NEXT:    pmovsxwd %xmm0, %xmm0\n+; SSE41-NEXT:    pmulhw %xmm5, %xmm1\n+; SSE41-NEXT:    pmovsxwd %xmm1, %xmm5\n+; SSE41-NEXT:    pshufd {{.*#+}} xmm1 = xmm1[2,3,2,3]\n ; SSE41-NEXT:    pmovsxwd %xmm1, %xmm1\n+; SSE41-NEXT:    pmulhw %xmm6, %xmm2\n+; SSE41-NEXT:    pmovsxwd %xmm2, %xmm6\n+; SSE41-NEXT:    pshufd {{.*#+}} xmm2 = xmm2[2,3,2,3]\n ; SSE41-NEXT:    pmovsxwd %xmm2, %xmm2\n+; SSE41-NEXT:    pmulhw %xmm7, %xmm3\n+; SSE41-NEXT:    pmovsxwd %xmm3, %xmm7\n+; SSE41-NEXT:    pshufd {{.*#+}} xmm3 = xmm3[2,3,2,3]\n ; SSE41-NEXT:    pmovsxwd %xmm3, %xmm3\n-; SSE41-NEXT:    movdqa %xmm3, 96(%rdi)\n-; SSE41-NEXT:    movdqa %xmm2, 64(%rdi)\n-; SSE41-NEXT:    movdqa %xmm1, 32(%rdi)\n-; SSE41-NEXT:    movdqa %xmm0, (%rdi)\n-; SSE41-NEXT:    movdqa %xmm7, 112(%rdi)\n-; SSE41-NEXT:    movdqa %xmm6, 80(%rdi)\n-; SSE41-NEXT:    movdqa %xmm5, 48(%rdi)\n-; SSE41-NEXT:    movdqa %xmm4, 16(%rdi)\n+; SSE41-NEXT:    movdqa %xmm3, 112(%rdi)\n+; SSE41-NEXT:    movdqa %xmm7, 96(%rdi)\n+; SSE41-NEXT:    movdqa %xmm2, 80(%rdi)\n+; SSE41-NEXT:    movdqa %xmm6, 64(%rdi)\n+; SSE41-NEXT:    movdqa %xmm1, 48(%rdi)\n+; SSE41-NEXT:    movdqa %xmm5, 32(%rdi)\n+; SSE41-NEXT:    movdqa %xmm0, 16(%rdi)\n+; SSE41-NEXT:    movdqa %xmm4, (%rdi)\n ; SSE41-NEXT:    retq\n ;\n ; AVX2-LABEL: mulhsw_v32i16_ashr:\n@@ -1770,53 +1770,53 @@ define <64 x i32> @mulhsw_v64i16_ashr(<64 x i16> %a, <64 x i16> %b) {\n ; SSE41:       # %bb.0:\n ; SSE41-NEXT:    movq %rdi, %rax\n ; SSE41-NEXT:    pmulhw {{[0-9]+}}(%rsp), %xmm0\n-; SSE41-NEXT:    pshufd {{.*#+}} xmm8 = xmm0[2,3,2,3]\n-; SSE41-NEXT:    pmovsxwd %xmm8, %xmm8\n+; SSE41-NEXT:    pmovsxwd %xmm0, %xmm8\n+; SSE41-NEXT:    pshufd {{.*#+}} xmm0 = xmm0[2,3,2,3]\n+; SSE41-NEXT:    pmovsxwd %xmm0, %xmm9\n ; SSE41-NEXT:    pmulhw {{[0-9]+}}(%rsp), %xmm1\n-; SSE41-NEXT:    pshufd {{.*#+}} xmm9 = xmm1[2,3,2,3]\n-; SSE41-NEXT:    pmovsxwd %xmm9, %xmm9\n+; SSE41-NEXT:    pmovsxwd %xmm1, %xmm10\n+; SSE41-NEXT:    pshufd {{.*#+}} xmm0 = xmm1[2,3,2,3]\n+; SSE41-NEXT:    pmovsxwd %xmm0, %xmm11\n ; SSE41-NEXT:    pmulhw {{[0-9]+}}(%rsp), %xmm2\n-; SSE41-NEXT:    pshufd {{.*#+}} xmm10 = xmm2[2,3,2,3]\n-; SSE41-NEXT:    pmovsxwd %xmm10, %xmm10\n+; SSE41-NEXT:    pmovsxwd %xmm2, %xmm12\n+; SSE41-NEXT:    pshufd {{.*#+}} xmm2 = xmm2[2,3,2,3]\n+; SSE41-NEXT:    pmovsxwd %xmm2, %xmm13\n ; SSE41-NEXT:    pmulhw {{[0-9]+}}(%rsp), %xmm3\n-; SSE41-NEXT:    pshufd {{.*#+}} xmm11 = xmm3[2,3,2,3]\n-; SSE41-NEXT:    pmovsxwd %xmm11, %xmm11\n+; SSE41-NEXT:    pmovsxwd %xmm3, %xmm14\n+; SSE41-NEXT:    pshufd {{.*#+}} xmm3 = xmm3[2,3,2,3]\n+; SSE41-NEXT:    pmovsxwd %xmm3, %xmm15\n ; SSE41-NEXT:    pmulhw {{[0-9]+}}(%rsp), %xmm4\n-; SSE41-NEXT:    pshufd {{.*#+}} xmm12 = xmm4[2,3,2,3]\n-; SSE41-NEXT:    pmovsxwd %xmm12, %xmm12\n-; SSE41-NEXT:    pmulhw {{[0-9]+}}(%rsp), %xmm5\n-; SSE41-NEXT:    pshufd {{.*#+}} xmm13 = xmm5[2,3,2,3]\n-; SSE41-NEXT:    pmovsxwd %xmm13, %xmm13\n-; SSE41-NEXT:    pmulhw {{[0-9]+}}(%rsp), %xmm6\n-; SSE41-NEXT:    pshufd {{.*#+}} xmm14 = xmm6[2,3,2,3]\n-; SSE41-NEXT:    pmovsxwd %xmm14, %xmm14\n-; SSE41-NEXT:    pmulhw {{[0-9]+}}(%rsp), %xmm7\n-; SSE41-NEXT:    pshufd {{.*#+}} xmm15 = xmm7[2,3,2,3]\n-; SSE41-NEXT:    pmovsxwd %xmm15, %xmm15\n-; SSE41-NEXT:    pmovsxwd %xmm0, %xmm0\n-; SSE41-NEXT:    pmovsxwd %xmm1, %xmm1\n-; SSE41-NEXT:    pmovsxwd %xmm2, %xmm2\n-; SSE41-NEXT:    pmovsxwd %xmm3, %xmm3\n+; SSE41-NEXT:    pmovsxwd %xmm4, %xmm0\n+; SSE41-NEXT:    pshufd {{.*#+}} xmm4 = xmm4[2,3,2,3]\n ; SSE41-NEXT:    pmovsxwd %xmm4, %xmm4\n+; SSE41-NEXT:    pmulhw {{[0-9]+}}(%rsp), %xmm5\n+; SSE41-NEXT:    pmovsxwd %xmm5, %xmm2\n+; SSE41-NEXT:    pshufd {{.*#+}} xmm5 = xmm5[2,3,2,3]\n ; SSE41-NEXT:    pmovsxwd %xmm5, %xmm5\n+; SSE41-NEXT:    pmulhw {{[0-9]+}}(%rsp), %xmm6\n+; SSE41-NEXT:    pmovsxwd %xmm6, %xmm1\n+; SSE41-NEXT:    pshufd {{.*#+}} xmm6 = xmm6[2,3,2,3]\n ; SSE41-NEXT:    pmovsxwd %xmm6, %xmm6\n+; SSE41-NEXT:    pmulhw {{[0-9]+}}(%rsp), %xmm7\n+; SSE41-NEXT:    pmovsxwd %xmm7, %xmm3\n+; SSE41-NEXT:    pshufd {{.*#+}} xmm7 = xmm7[2,3,2,3]\n ; SSE41-NEXT:    pmovsxwd %xmm7, %xmm7\n-; SSE41-NEXT:    movdqa %xmm7, 224(%rdi)\n-; SSE41-NEXT:    movdqa %xmm6, 192(%rdi)\n-; SSE41-NEXT:    movdqa %xmm5, 160(%rdi)\n-; SSE41-NEXT:    movdqa %xmm4, 128(%rdi)\n-; SSE41-NEXT:    movdqa %xmm3, 96(%rdi)\n-; SSE41-NEXT:    movdqa %xmm2, 64(%rdi)\n-; SSE41-NEXT:    movdqa %xmm1, 32(%rdi)\n-; SSE41-NEXT:    movdqa %xmm0, (%rdi)\n-; SSE41-NEXT:    movdqa %xmm15, 240(%rdi)\n-; SSE41-NEXT:    movdqa %xmm14, 208(%rdi)\n-; SSE41-NEXT:    movdqa %xmm13, 176(%rdi)\n-; SSE41-NEXT:    movdqa %xmm12, 144(%rdi)\n-; SSE41-NEXT:    movdqa %xmm11, 112(%rdi)\n-; SSE41-NEXT:    movdqa %xmm10, 80(%rdi)\n-; SSE41-NEXT:    movdqa %xmm9, 48(%rdi)\n-; SSE41-NEXT:    movdqa %xmm8, 16(%rdi)\n+; SSE41-NEXT:    movdqa %xmm7, 240(%rdi)\n+; SSE41-NEXT:    movdqa %xmm3, 224(%rdi)\n+; SSE41-NEXT:    movdqa %xmm6, 208(%rdi)\n+; SSE41-NEXT:    movdqa %xmm1, 192(%rdi)\n+; SSE41-NEXT:    movdqa %xmm5, 176(%rdi)\n+; SSE41-NEXT:    movdqa %xmm2, 160(%rdi)\n+; SSE41-NEXT:    movdqa %xmm4, 144(%rdi)\n+; SSE41-NEXT:    movdqa %xmm0, 128(%rdi)\n+; SSE41-NEXT:    movdqa %xmm15, 112(%rdi)\n+; SSE41-NEXT:    movdqa %xmm14, 96(%rdi)\n+; SSE41-NEXT:    movdqa %xmm13, 80(%rdi)\n+; SSE41-NEXT:    movdqa %xmm12, 64(%rdi)\n+; SSE41-NEXT:    movdqa %xmm11, 48(%rdi)\n+; SSE41-NEXT:    movdqa %xmm10, 32(%rdi)\n+; SSE41-NEXT:    movdqa %xmm9, 16(%rdi)\n+; SSE41-NEXT:    movdqa %xmm8, (%rdi)\n ; SSE41-NEXT:    retq\n ;\n ; AVX2-LABEL: mulhsw_v64i16_ashr:"
            },
            {
                "fn": "llvm/test/CodeGen/X86/scheduler-backtracking.ll",
                "patch": "@@ -18,42 +18,40 @@ define i256 @test1(i256 %a) nounwind {\n ; ILP-NEXT:    xorl %r8d, %r8d\n ; ILP-NEXT:    addl %esi, %esi\n ; ILP-NEXT:    leal 3(%rsi), %r9d\n-; ILP-NEXT:    movb $125, %r10b\n-; ILP-NEXT:    movl $1, %edi\n-; ILP-NEXT:    xorl %r11d, %r11d\n+; ILP-NEXT:    movl $1, %r11d\n+; ILP-NEXT:    xorl %r14d, %r14d\n ; ILP-NEXT:    movl %r9d, %ecx\n-; ILP-NEXT:    shldq %cl, %rdi, %r11\n-; ILP-NEXT:    subb %sil, %r10b\n-; ILP-NEXT:    addb $-125, %sil\n-; ILP-NEXT:    xorl %ebx, %ebx\n-; ILP-NEXT:    movl %esi, %ecx\n-; ILP-NEXT:    shldq %cl, %rdi, %rbx\n+; ILP-NEXT:    shldq %cl, %r11, %r14\n ; ILP-NEXT:    movl $1, %edx\n ; ILP-NEXT:    shlq %cl, %rdx\n-; ILP-NEXT:    movl $1, %r14d\n+; ILP-NEXT:    leal -125(%rsi), %r10d\n+; ILP-NEXT:    xorl %ebx, %ebx\n ; ILP-NEXT:    movl %r10d, %ecx\n-; ILP-NEXT:    shrdq %cl, %r8, %r14\n-; ILP-NEXT:    movl %r9d, %ecx\n-; ILP-NEXT:    shlq %cl, %rdi\n+; ILP-NEXT:    shldq %cl, %r11, %rbx\n ; ILP-NEXT:    testb $64, %r9b\n-; ILP-NEXT:    cmovneq %rdi, %r11\n-; ILP-NEXT:    cmovneq %r8, %rdi\n-; ILP-NEXT:    testb $64, %r10b\n-; ILP-NEXT:    cmovneq %r8, %r14\n-; ILP-NEXT:    testb $64, %sil\n-; ILP-NEXT:    cmovneq %rdx, %rbx\n+; ILP-NEXT:    cmovneq %rdx, %r14\n ; ILP-NEXT:    cmovneq %r8, %rdx\n+; ILP-NEXT:    movl $1, %edi\n+; ILP-NEXT:    shlq %cl, %rdi\n+; ILP-NEXT:    movb $125, %cl\n+; ILP-NEXT:    subb %sil, %cl\n+; ILP-NEXT:    shrdq %cl, %r8, %r11\n+; ILP-NEXT:    testb $64, %cl\n+; ILP-NEXT:    cmovneq %r8, %r11\n+; ILP-NEXT:    testb $64, %r10b\n+; ILP-NEXT:    cmovneq %rdi, %rbx\n+; ILP-NEXT:    cmovneq %r8, %rdi\n ; ILP-NEXT:    testb %r9b, %r9b\n-; ILP-NEXT:    cmovsq %r8, %r11\n-; ILP-NEXT:    cmovsq %r8, %rdi\n-; ILP-NEXT:    movq %r11, 8(%rax)\n-; ILP-NEXT:    movq %rdi, (%rax)\n+; ILP-NEXT:    cmovsq %r8, %r14\n+; ILP-NEXT:    cmovsq %r8, %rdx\n+; ILP-NEXT:    movq %r14, 8(%rax)\n+; ILP-NEXT:    movq %rdx, (%rax)\n ; ILP-NEXT:    cmovnsq %r8, %rbx\n ; ILP-NEXT:    cmoveq %r8, %rbx\n ; ILP-NEXT:    movq %rbx, 24(%rax)\n-; ILP-NEXT:    cmovnsq %r14, %rdx\n-; ILP-NEXT:    cmoveq %r8, %rdx\n-; ILP-NEXT:    movq %rdx, 16(%rax)\n+; ILP-NEXT:    cmovnsq %r11, %rdi\n+; ILP-NEXT:    cmoveq %r8, %rdi\n+; ILP-NEXT:    movq %rdi, 16(%rax)\n ; ILP-NEXT:    popq %rbx\n ; ILP-NEXT:    popq %r14\n ; ILP-NEXT:    retq\n@@ -252,27 +250,24 @@ define i256 @test2(i256 %a) nounwind {\n ; ILP-LABEL: test2:\n ; ILP:       # %bb.0:\n ; ILP-NEXT:    movq %rdi, %rax\n-; ILP-NEXT:    xorl %edi, %edi\n+; ILP-NEXT:    xorl %r9d, %r9d\n ; ILP-NEXT:    movq %rsi, %r11\n ; ILP-NEXT:    negq %r11\n ; ILP-NEXT:    movl $0, %r10d\n ; ILP-NEXT:    sbbq %rdx, %r10\n-; ILP-NEXT:    movl $0, %r9d\n-; ILP-NEXT:    sbbq %rcx, %r9\n-; ILP-NEXT:    sbbq %r8, %rdi\n-; ILP-NEXT:    andq %rcx, %r9\n-; ILP-NEXT:    bsrq %r9, %rcx\n-; ILP-NEXT:    xorq $63, %rcx\n-; ILP-NEXT:    andq %r8, %rdi\n-; ILP-NEXT:    bsrq %rdi, %r8\n+; ILP-NEXT:    movl $0, %edi\n+; ILP-NEXT:    sbbq %rcx, %rdi\n+; ILP-NEXT:    sbbq %r8, %r9\n+; ILP-NEXT:    andq %r8, %r9\n+; ILP-NEXT:    bsrq %r9, %r8\n ; ILP-NEXT:    andq %rdx, %r10\n ; ILP-NEXT:    bsrq %r10, %rdx\n ; ILP-NEXT:    xorq $63, %r8\n+; ILP-NEXT:    andq %rcx, %rdi\n+; ILP-NEXT:    bsrq %rdi, %rcx\n+; ILP-NEXT:    xorq $63, %rcx\n ; ILP-NEXT:    addq $64, %rcx\n-; ILP-NEXT:    testq %rdi, %rdi\n-; ILP-NEXT:    movq $0, 24(%rax)\n-; ILP-NEXT:    movq $0, 16(%rax)\n-; ILP-NEXT:    movq $0, 8(%rax)\n+; ILP-NEXT:    testq %r9, %r9\n ; ILP-NEXT:    cmovneq %r8, %rcx\n ; ILP-NEXT:    xorq $63, %rdx\n ; ILP-NEXT:    andq %rsi, %r11\n@@ -287,6 +282,9 @@ define i256 @test2(i256 %a) nounwind {\n ; ILP-NEXT:    orq %r9, %rdi\n ; ILP-NEXT:    cmovneq %rcx, %rsi\n ; ILP-NEXT:    movq %rsi, (%rax)\n+; ILP-NEXT:    movq $0, 24(%rax)\n+; ILP-NEXT:    movq $0, 16(%rax)\n+; ILP-NEXT:    movq $0, 8(%rax)\n ; ILP-NEXT:    retq\n ;\n ; HYBRID-LABEL: test2:\n@@ -457,46 +455,48 @@ define i256 @test2(i256 %a) nounwind {\n define i256 @test3(i256 %n) nounwind {\n ; ILP-LABEL: test3:\n ; ILP:       # %bb.0:\n+; ILP-NEXT:    pushq %rbx\n ; ILP-NEXT:    movq %rdi, %rax\n-; ILP-NEXT:    xorl %r10d, %r10d\n+; ILP-NEXT:    xorl %edi, %edi\n ; ILP-NEXT:    movq %rsi, %r9\n ; ILP-NEXT:    negq %r9\n+; ILP-NEXT:    movl $0, %r10d\n+; ILP-NEXT:    sbbq %rdx, %r10\n ; ILP-NEXT:    movl $0, %r11d\n-; ILP-NEXT:    sbbq %rdx, %r11\n-; ILP-NEXT:    movl $0, %edi\n-; ILP-NEXT:    sbbq %rcx, %rdi\n-; ILP-NEXT:    sbbq %r8, %r10\n+; ILP-NEXT:    sbbq %rcx, %r11\n+; ILP-NEXT:    sbbq %r8, %rdi\n+; ILP-NEXT:    notq %r8\n+; ILP-NEXT:    andq %rdi, %r8\n+; ILP-NEXT:    bsrq %r8, %rbx\n+; ILP-NEXT:    notq %rdx\n+; ILP-NEXT:    andq %r10, %rdx\n+; ILP-NEXT:    bsrq %rdx, %r10\n+; ILP-NEXT:    notq %rsi\n+; ILP-NEXT:    xorq $63, %rbx\n ; ILP-NEXT:    notq %rcx\n-; ILP-NEXT:    andq %rdi, %rcx\n+; ILP-NEXT:    andq %r11, %rcx\n ; ILP-NEXT:    bsrq %rcx, %rdi\n-; ILP-NEXT:    notq %rdx\n-; ILP-NEXT:    andq %r11, %rdx\n ; ILP-NEXT:    xorq $63, %rdi\n-; ILP-NEXT:    notq %r8\n-; ILP-NEXT:    andq %r10, %r8\n-; ILP-NEXT:    bsrq %r8, %r10\n-; ILP-NEXT:    xorq $63, %r10\n ; ILP-NEXT:    addq $64, %rdi\n-; ILP-NEXT:    bsrq %rdx, %r11\n-; ILP-NEXT:    notq %rsi\n ; ILP-NEXT:    testq %r8, %r8\n-; ILP-NEXT:    movq $0, 24(%rax)\n-; ILP-NEXT:    movq $0, 16(%rax)\n-; ILP-NEXT:    movq $0, 8(%rax)\n-; ILP-NEXT:    cmovneq %r10, %rdi\n-; ILP-NEXT:    xorq $63, %r11\n+; ILP-NEXT:    cmovneq %rbx, %rdi\n+; ILP-NEXT:    xorq $63, %r10\n ; ILP-NEXT:    andq %r9, %rsi\n-; ILP-NEXT:    movl $127, %r9d\n+; ILP-NEXT:    movl $127, %ebx\n ; ILP-NEXT:    bsrq %rsi, %rsi\n-; ILP-NEXT:    cmoveq %r9, %rsi\n+; ILP-NEXT:    cmoveq %rbx, %rsi\n ; ILP-NEXT:    xorq $63, %rsi\n ; ILP-NEXT:    addq $64, %rsi\n ; ILP-NEXT:    testq %rdx, %rdx\n-; ILP-NEXT:    cmovneq %r11, %rsi\n+; ILP-NEXT:    cmovneq %r10, %rsi\n ; ILP-NEXT:    subq $-128, %rsi\n-; ILP-NEXT:    orq %rcx, %r8\n+; ILP-NEXT:    orq %r8, %rcx\n ; ILP-NEXT:    cmovneq %rdi, %rsi\n ; ILP-NEXT:    movq %rsi, (%rax)\n+; ILP-NEXT:    movq $0, 24(%rax)\n+; ILP-NEXT:    movq $0, 16(%rax)\n+; ILP-NEXT:    movq $0, 8(%rax)\n+; ILP-NEXT:    popq %rbx\n ; ILP-NEXT:    retq\n ;\n ; HYBRID-LABEL: test3:"
            },
            {
                "fn": "llvm/test/CodeGen/X86/subcarry.ll",
                "patch": "@@ -25,9 +25,9 @@ define i256 @sub256(i256 %a, i256 %b) nounwind {\n ; CHECK-NEXT:    sbbq {{[0-9]+}}(%rsp), %rdx\n ; CHECK-NEXT:    sbbq {{[0-9]+}}(%rsp), %rcx\n ; CHECK-NEXT:    sbbq {{[0-9]+}}(%rsp), %r8\n+; CHECK-NEXT:    movq %rcx, 16(%rdi)\n ; CHECK-NEXT:    movq %rdx, 8(%rdi)\n ; CHECK-NEXT:    movq %rsi, (%rdi)\n-; CHECK-NEXT:    movq %rcx, 16(%rdi)\n ; CHECK-NEXT:    movq %r8, 24(%rdi)\n ; CHECK-NEXT:    retq\n entry:"
            },
            {
                "fn": "llvm/test/CodeGen/X86/umul-with-overflow.ll",
                "patch": "@@ -494,10 +494,10 @@ define i300 @test4(i300 %a, i300 %b) nounwind {\n ; X86-NEXT:    adcl {{[-0-9]+}}(%e{{[sb]}}p), %ecx # 4-byte Folded Reload\n ; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx\n ; X86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %esi # 4-byte Reload\n-; X86-NEXT:    movl %esi, (%edx)\n-; X86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %esi # 4-byte Reload\n ; X86-NEXT:    movl %esi, 4(%edx)\n ; X86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %esi # 4-byte Reload\n+; X86-NEXT:    movl %esi, (%edx)\n+; X86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %esi # 4-byte Reload\n ; X86-NEXT:    movl %esi, 8(%edx)\n ; X86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %esi # 4-byte Reload\n ; X86-NEXT:    movl %esi, 12(%edx)\n@@ -530,17 +530,17 @@ define i300 @test4(i300 %a, i300 %b) nounwind {\n ; X64-NEXT:    pushq %rbx\n ; X64-NEXT:    movq %r9, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill\n ; X64-NEXT:    movq %r8, %r11\n-; X64-NEXT:    movq %rcx, %r8\n+; X64-NEXT:    movq %rcx, %r10\n ; X64-NEXT:    movq %rdx, %r13\n ; X64-NEXT:    movq %rdi, %r12\n-; X64-NEXT:    movq {{[0-9]+}}(%rsp), %r10\n+; X64-NEXT:    movq {{[0-9]+}}(%rsp), %r8\n ; X64-NEXT:    movq {{[0-9]+}}(%rsp), %rbp\n ; X64-NEXT:    movq %rsi, %rax\n-; X64-NEXT:    mulq %r10\n+; X64-NEXT:    mulq %r8\n ; X64-NEXT:    movq %rdx, %r14\n ; X64-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill\n ; X64-NEXT:    movq %r13, %rax\n-; X64-NEXT:    mulq %r10\n+; X64-NEXT:    mulq %r8\n ; X64-NEXT:    movq %rdx, %rbx\n ; X64-NEXT:    movq %rax, %rdi\n ; X64-NEXT:    addq %r14, %rdi\n@@ -559,22 +559,22 @@ define i300 @test4(i300 %a, i300 %b) nounwind {\n ; X64-NEXT:    movq %rax, %rbp\n ; X64-NEXT:    addq %rcx, %rbp\n ; X64-NEXT:    adcq %rdi, %rbx\n-; X64-NEXT:    movq %r8, %rax\n-; X64-NEXT:    mulq %r10\n+; X64-NEXT:    movq %r10, %rax\n+; X64-NEXT:    mulq %r8\n ; X64-NEXT:    movq %rdx, %rcx\n ; X64-NEXT:    movq %rax, %r15\n ; X64-NEXT:    movq %r11, %rax\n-; X64-NEXT:    mulq %r10\n-; X64-NEXT:    movq %rdx, %r10\n+; X64-NEXT:    mulq %r8\n+; X64-NEXT:    movq %rdx, %r8\n ; X64-NEXT:    movq %rax, %r14\n ; X64-NEXT:    addq %rcx, %r14\n-; X64-NEXT:    adcq $0, %r10\n-; X64-NEXT:    movq %r8, %rax\n+; X64-NEXT:    adcq $0, %r8\n+; X64-NEXT:    movq %r10, %rax\n ; X64-NEXT:    movq {{[0-9]+}}(%rsp), %rcx\n ; X64-NEXT:    mulq %rcx\n ; X64-NEXT:    movq %rax, %rdi\n ; X64-NEXT:    addq %r14, %rdi\n-; X64-NEXT:    adcq %r10, %rdx\n+; X64-NEXT:    adcq %r8, %rdx\n ; X64-NEXT:    imulq %rcx, %r11\n ; X64-NEXT:    movq {{[0-9]+}}(%rsp), %r14\n ; X64-NEXT:    addq %rbp, %r15\n@@ -583,7 +583,7 @@ define i300 @test4(i300 %a, i300 %b) nounwind {\n ; X64-NEXT:    movq %rsi, %rax\n ; X64-NEXT:    mulq %r14\n ; X64-NEXT:    movq %rdx, %rcx\n-; X64-NEXT:    movq %rax, %r10\n+; X64-NEXT:    movq %rax, %r8\n ; X64-NEXT:    movq %r13, %rax\n ; X64-NEXT:    mulq %r14\n ; X64-NEXT:    movq %rdx, %rbp\n@@ -597,20 +597,20 @@ define i300 @test4(i300 %a, i300 %b) nounwind {\n ; X64-NEXT:    adcq %rbp, %rdx\n ; X64-NEXT:    imulq %rcx, %r13\n ; X64-NEXT:    addq %rdx, %r13\n-; X64-NEXT:    addq %r15, %r10\n+; X64-NEXT:    addq %r15, %r8\n ; X64-NEXT:    adcq %rdi, %rax\n ; X64-NEXT:    adcq %r11, %r13\n-; X64-NEXT:    imulq %r14, %r8\n-; X64-NEXT:    addq %r13, %r8\n+; X64-NEXT:    imulq %r14, %r10\n+; X64-NEXT:    addq %r13, %r10\n ; X64-NEXT:    movq {{[-0-9]+}}(%r{{[sb]}}p), %rcx # 8-byte Reload\n ; X64-NEXT:    imulq {{[0-9]+}}(%rsp), %rcx\n ; X64-NEXT:    imulq {{[0-9]+}}(%rsp), %rsi\n ; X64-NEXT:    addq %rcx, %rsi\n-; X64-NEXT:    addq %r8, %rsi\n+; X64-NEXT:    addq %r10, %rsi\n+; X64-NEXT:    movq %r9, 8(%r12)\n ; X64-NEXT:    movq {{[-0-9]+}}(%r{{[sb]}}p), %rcx # 8-byte Reload\n ; X64-NEXT:    movq %rcx, (%r12)\n-; X64-NEXT:    movq %r9, 8(%r12)\n-; X64-NEXT:    movq %r10, 16(%r12)\n+; X64-NEXT:    movq %r8, 16(%r12)\n ; X64-NEXT:    movq %rax, 24(%r12)\n ; X64-NEXT:    movl %esi, 32(%r12)\n ; X64-NEXT:    shrq $32, %rsi"
            },
            {
                "fn": "llvm/test/CodeGen/X86/umulo-128-legalisation-lowering.ll",
                "patch": "@@ -38,8 +38,8 @@ define { i128, i8 } @muloti_test(i128 %l, i128 %r) unnamed_addr #0 {\n ; X86-NEXT:    .cfi_def_cfa_offset 16\n ; X86-NEXT:    pushl %esi\n ; X86-NEXT:    .cfi_def_cfa_offset 20\n-; X86-NEXT:    subl $24, %esp\n-; X86-NEXT:    .cfi_def_cfa_offset 44\n+; X86-NEXT:    subl $28, %esp\n+; X86-NEXT:    .cfi_def_cfa_offset 48\n ; X86-NEXT:    .cfi_offset %esi, -20\n ; X86-NEXT:    .cfi_offset %edi, -16\n ; X86-NEXT:    .cfi_offset %ebx, -12\n@@ -60,58 +60,55 @@ define { i128, i8 } @muloti_test(i128 %l, i128 %r) unnamed_addr #0 {\n ; X86-NEXT:    movl %edi, %eax\n ; X86-NEXT:    mull %ebx\n ; X86-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill\n-; X86-NEXT:    movl %edx, %ecx\n-; X86-NEXT:    addl %esi, %ecx\n+; X86-NEXT:    movl %edx, %ebp\n+; X86-NEXT:    addl %esi, %ebp\n ; X86-NEXT:    setb {{[-0-9]+}}(%e{{[sb]}}p) # 1-byte Folded Spill\n ; X86-NEXT:    movl {{[0-9]+}}(%esp), %esi\n ; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax\n ; X86-NEXT:    mull %esi\n-; X86-NEXT:    movl %esi, %ebx\n-; X86-NEXT:    movl %eax, %esi\n+; X86-NEXT:    movl %eax, %ecx\n ; X86-NEXT:    seto {{[-0-9]+}}(%e{{[sb]}}p) # 1-byte Folded Spill\n-; X86-NEXT:    movl {{[0-9]+}}(%esp), %edi\n-; X86-NEXT:    movl %edi, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill\n+; X86-NEXT:    movl {{[0-9]+}}(%esp), %ebx\n+; X86-NEXT:    movl %ebx, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill\n ; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax\n-; X86-NEXT:    mull %edi\n-; X86-NEXT:    movl %eax, %ebp\n-; X86-NEXT:    seto {{[-0-9]+}}(%e{{[sb]}}p) # 1-byte Folded Spill\n-; X86-NEXT:    addl %esi, %ebp\n-; X86-NEXT:    movl %edi, %eax\n ; X86-NEXT:    mull %ebx\n-; X86-NEXT:    movl %ebx, %esi\n-; X86-NEXT:    movl %eax, %ebx\n-; X86-NEXT:    movl %edx, %edi\n-; X86-NEXT:    addl %ebp, %edi\n+; X86-NEXT:    movl %eax, %edi\n+; X86-NEXT:    seto {{[-0-9]+}}(%e{{[sb]}}p) # 1-byte Folded Spill\n+; X86-NEXT:    addl %ecx, %edi\n+; X86-NEXT:    movl %ebx, %eax\n+; X86-NEXT:    mull %esi\n+; X86-NEXT:    movl %edx, %ebx\n+; X86-NEXT:    addl %edi, %ebx\n ; X86-NEXT:    setb {{[-0-9]+}}(%e{{[sb]}}p) # 1-byte Folded Spill\n-; X86-NEXT:    addl {{[-0-9]+}}(%e{{[sb]}}p), %ebx # 4-byte Folded Reload\n-; X86-NEXT:    adcl %ecx, %edi\n+; X86-NEXT:    addl {{[-0-9]+}}(%e{{[sb]}}p), %eax # 4-byte Folded Reload\n+; X86-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill\n+; X86-NEXT:    adcl %ebp, %ebx\n ; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax\n-; X86-NEXT:    movl %esi, %ecx\n ; X86-NEXT:    mull %esi\n-; X86-NEXT:    movl %edx, %esi\n+; X86-NEXT:    movl %edx, %edi\n ; X86-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill\n ; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax\n-; X86-NEXT:    mull %ecx\n+; X86-NEXT:    mull %esi\n ; X86-NEXT:    movl %edx, %ebp\n ; X86-NEXT:    movl %eax, %ecx\n-; X86-NEXT:    addl %esi, %ecx\n+; X86-NEXT:    addl %edi, %ecx\n ; X86-NEXT:    adcl $0, %ebp\n ; X86-NEXT:    movl {{[0-9]+}}(%esp), %eax\n-; X86-NEXT:    movl {{[0-9]+}}(%esp), %edx\n-; X86-NEXT:    mull %edx\n+; X86-NEXT:    movl {{[0-9]+}}(%esp), %edi\n+; X86-NEXT:    mull %edi\n ; X86-NEXT:    movl %edx, %esi\n ; X86-NEXT:    addl %ecx, %eax\n ; X86-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill\n ; X86-NEXT:    adcl %ebp, %esi\n ; X86-NEXT:    setb %cl\n ; X86-NEXT:    movl {{[0-9]+}}(%esp), %ebp\n ; X86-NEXT:    movl %ebp, %eax\n-; X86-NEXT:    mull {{[0-9]+}}(%esp)\n+; X86-NEXT:    mull %edi\n ; X86-NEXT:    addl %esi, %eax\n ; X86-NEXT:    movzbl %cl, %ecx\n ; X86-NEXT:    adcl %ecx, %edx\n-; X86-NEXT:    addl %ebx, %eax\n-; X86-NEXT:    adcl %edi, %edx\n+; X86-NEXT:    addl {{[-0-9]+}}(%e{{[sb]}}p), %eax # 4-byte Folded Reload\n+; X86-NEXT:    adcl %ebx, %edx\n ; X86-NEXT:    setb {{[-0-9]+}}(%e{{[sb]}}p) # 1-byte Folded Spill\n ; X86-NEXT:    testl %ebp, %ebp\n ; X86-NEXT:    setne %cl\n@@ -124,10 +121,10 @@ define { i128, i8 } @muloti_test(i128 %l, i128 %r) unnamed_addr #0 {\n ; X86-NEXT:    orb {{[-0-9]+}}(%e{{[sb]}}p), %cl # 1-byte Folded Reload\n ; X86-NEXT:    orb %ch, %cl\n ; X86-NEXT:    movb %cl, {{[-0-9]+}}(%e{{[sb]}}p) # 1-byte Spill\n-; X86-NEXT:    cmpl $0, {{[0-9]+}}(%esp)\n-; X86-NEXT:    setne %cl\n-; X86-NEXT:    movl {{[0-9]+}}(%esp), %edi\n ; X86-NEXT:    testl %edi, %edi\n+; X86-NEXT:    setne %cl\n+; X86-NEXT:    movl {{[0-9]+}}(%esp), %ebp\n+; X86-NEXT:    testl %ebp, %ebp\n ; X86-NEXT:    setne %bh\n ; X86-NEXT:    andb %cl, %bh\n ; X86-NEXT:    movb {{[-0-9]+}}(%e{{[sb]}}p), %cl # 1-byte Reload\n@@ -136,12 +133,12 @@ define { i128, i8 } @muloti_test(i128 %l, i128 %r) unnamed_addr #0 {\n ; X86-NEXT:    movb %cl, {{[-0-9]+}}(%e{{[sb]}}p) # 1-byte Spill\n ; X86-NEXT:    orl %esi, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Folded Spill\n ; X86-NEXT:    setne %bl\n-; X86-NEXT:    orl %edi, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Folded Spill\n+; X86-NEXT:    orl %ebp, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Folded Spill\n ; X86-NEXT:    movl {{[0-9]+}}(%esp), %ecx\n ; X86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %esi # 4-byte Reload\n-; X86-NEXT:    movl %esi, (%ecx)\n-; X86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %esi # 4-byte Reload\n ; X86-NEXT:    movl %esi, 4(%ecx)\n+; X86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %esi # 4-byte Reload\n+; X86-NEXT:    movl %esi, (%ecx)\n ; X86-NEXT:    movl %eax, 8(%ecx)\n ; X86-NEXT:    movl %edx, 12(%ecx)\n ; X86-NEXT:    setne %al\n@@ -153,7 +150,7 @@ define { i128, i8 } @muloti_test(i128 %l, i128 %r) unnamed_addr #0 {\n ; X86-NEXT:    andb $1, %al\n ; X86-NEXT:    movb %al, 16(%ecx)\n ; X86-NEXT:    movl %ecx, %eax\n-; X86-NEXT:    addl $24, %esp\n+; X86-NEXT:    addl $28, %esp\n ; X86-NEXT:    .cfi_def_cfa_offset 20\n ; X86-NEXT:    popl %esi\n ; X86-NEXT:    .cfi_def_cfa_offset 16"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/addcarry.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/addcarry.ll\n\n\nTesting Time: 0.99s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/fp128-cast.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/fp128-cast.ll\n\n\nTesting Time: 2.06s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/i128-add.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/i128-add.ll\n\n\nTesting Time: 0.43s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/masked_load.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/masked_load.ll\n\n\nTesting Time: 2.36s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/mul128.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/mul128.ll\n\n\nTesting Time: 0.56s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/pmulh.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/pmulh.ll\n\n\nTesting Time: 2.22s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/scheduler-backtracking.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/scheduler-backtracking.ll\n\n\nTesting Time: 0.57s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/subcarry.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/subcarry.ll\n\n\nTesting Time: 0.65s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/umul-with-overflow.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/umul-with-overflow.ll\n\n\nTesting Time: 0.86s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/umulo-128-legalisation-lowering.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/umulo-128-legalisation-lowering.ll\n\n\nTesting Time: 0.61s\n  Failed: 1\n"
    },
    "e5a8af7a90c6a9ac46293eb3600029d43d695b8e___RelLookupTableConverter.cpp": {
        "prefix": "static void convertToRelLookupTable(GlobalVariable &LookupTable) {\n  GetElementPtrInst *GEP =\n      cast<GetElementPtrInst>(LookupTable.use_begin()->getUser());\n  LoadInst *Load = cast<LoadInst>(GEP->use_begin()->getUser());\n\n  Module &M = *LookupTable.getParent();\n  BasicBlock *BB = GEP->getParent();\n  IRBuilder<> Builder(BB);\n  Function &Func = *BB->getParent();\n\n  // Generate an array that consists of relative offsets.\n  GlobalVariable *RelLookupTable = createRelLookupTable(Func, LookupTable);\n\n  // Place new instruction sequence before GEP.\n  Builder.SetInsertPoint(GEP);\n  Value *Index = GEP->getOperand(2);\n  IntegerType *IntTy = cast<IntegerType>(Index->getType());\n  Value *Offset =\n      Builder.CreateShl(Index, ConstantInt::get(IntTy, 2), \"reltable.shift\");\n\n",
        "suffix": "      &M, Intrinsic::load_relative, {Index->getType()});\n  Value *Base = Builder.CreateBitCast(RelLookupTable, Builder.getInt8PtrTy());\n\n  // Create a call to load.relative intrinsic that computes the target address\n  // by adding base address (lookup table address) and relative offset.\n  Value *Result = Builder.CreateCall(LoadRelIntrinsic, {Base, Offset},\n                                     \"reltable.intrinsic\");\n\n  // Create a bitcast instruction if necessary.\n  if (Load->getType() != Builder.getInt8PtrTy())\n    Result = Builder.CreateBitCast(Result, Load->getType(), \"reltable.bitcast\");\n\n  // Replace load instruction with the new generated instruction sequence.\n  Load->replaceAllUsesWith(Result);\n  // Remove Load and GEP instructions.\n  Load->eraseFromParent();\n  GEP->eraseFromParent();\n}\n",
        "start": 127,
        "end": 165,
        "buggy": "static void convertToRelLookupTable(GlobalVariable &LookupTable) {\n  GetElementPtrInst *GEP =\n      cast<GetElementPtrInst>(LookupTable.use_begin()->getUser());\n  LoadInst *Load = cast<LoadInst>(GEP->use_begin()->getUser());\n\n  Module &M = *LookupTable.getParent();\n  BasicBlock *BB = GEP->getParent();\n  IRBuilder<> Builder(BB);\n  Function &Func = *BB->getParent();\n\n  // Generate an array that consists of relative offsets.\n  GlobalVariable *RelLookupTable = createRelLookupTable(Func, LookupTable);\n\n  // Place new instruction sequence before GEP.\n  Builder.SetInsertPoint(GEP);\n  Value *Index = GEP->getOperand(2);\n  IntegerType *IntTy = cast<IntegerType>(Index->getType());\n  Value *Offset =\n      Builder.CreateShl(Index, ConstantInt::get(IntTy, 2), \"reltable.shift\");\n\n  Function *LoadRelIntrinsic = llvm::Intrinsic::getDeclaration(\n      &M, Intrinsic::load_relative, {Index->getType()});\n  Value *Base = Builder.CreateBitCast(RelLookupTable, Builder.getInt8PtrTy());\n\n  // Create a call to load.relative intrinsic that computes the target address\n  // by adding base address (lookup table address) and relative offset.\n  Value *Result = Builder.CreateCall(LoadRelIntrinsic, {Base, Offset},\n                                     \"reltable.intrinsic\");\n\n  // Create a bitcast instruction if necessary.\n  if (Load->getType() != Builder.getInt8PtrTy())\n    Result = Builder.CreateBitCast(Result, Load->getType(), \"reltable.bitcast\");\n\n  // Replace load instruction with the new generated instruction sequence.\n  Load->replaceAllUsesWith(Result);\n  // Remove Load and GEP instructions.\n  Load->eraseFromParent();\n  GEP->eraseFromParent();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  Function *LoadRelIntrinsic = llvm::Intrinsic::getDeclaration(\n",
        "src_path": "e5a8af7a90c6a9ac46293eb3600029d43d695b8e___RelLookupTableConverter.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/e5a8af7a90c6a9ac46293eb3600029d43d695b8e",
        "commit_msg": "[Passes] Fix relative lookup table converter pass\n\nThis patch fixes the relative table converter pass for the lookup table\naccesses that are resulted in an instruction sequence, where gep is not\nimmediately followed by a load, such as gep being hoisted outside the loop\nor another instruction is inserted in between them. The fix inserts the\ncall to load.relative.instrinsic in the original place of load instead of gep.\nIssue is reported by FreeBSD via https://bugs.freebsd.org/259921.\n\nDifferential Revision: https://reviews.llvm.org/D115571",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/RelLookupTableConverter/X86/relative_lookup_table.ll",
                "patch": "@@ -12,6 +12,9 @@ target triple = \"x86_64-unknown-linux-gnu\"\n @.str.5 = private unnamed_addr constant [5 x i8] c\"str1\\00\", align 1\n @.str.6 = private unnamed_addr constant [5 x i8] c\"str2\\00\", align 1\n @.str.7 = private unnamed_addr constant [12 x i8] c\"singlevalue\\00\", align 1\n+@.str.8 = private unnamed_addr constant [2 x i8] c\"a\\00\", align 1\n+@.str.9 = private unnamed_addr constant [2 x i8] c\"b\\00\", align 1\n+@.str.10 = private unnamed_addr constant [2 x i8] c\"c\\00\", align 1\n \n @a1 = external global i32, align 4\n @b1 = external global i32, align 4\n@@ -56,6 +59,16 @@ target triple = \"x86_64-unknown-linux-gnu\"\n                                     i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0)\n                                    ], align 16\n \n+@table = internal constant [2 x i8*] [\n+  i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8, i32 0, i32 0),\n+  i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.9, i32 0, i32 0)\n+], align 16\n+\n+@table2 = internal constant [2 x i8*] [\n+  i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8, i32 0, i32 0),\n+  i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.9, i32 0, i32 0)\n+], align 16\n+\n ; Lookup table check for integer pointers that have external linkage\n ; CHECK: @switch.table.external_linkage = private unnamed_addr constant [3 x i32*] [i32* @a1, i32* @b1, i32* @c1], align\n \n@@ -93,6 +106,20 @@ target triple = \"x86_64-unknown-linux-gnu\"\n ; CHECK-SAME: ], align 4\n ;\n \n+; Relative lookup table for the loop hoist check test\n+; CHECK: @reltable.loop_hoist = internal unnamed_addr constant [2 x i32]\n+; CHECK-SAME: [\n+; CHECK-SAME: i32 trunc (i64 sub (i64 ptrtoint ([2 x i8]* @.str.8 to i64), i64 ptrtoint ([2 x i32]* @reltable.loop_hoist to i64)) to i32),\n+; CHECK-SAME: i32 trunc (i64 sub (i64 ptrtoint ([2 x i8]* @.str.9 to i64), i64 ptrtoint ([2 x i32]* @reltable.loop_hoist to i64)) to i32)\n+; CHECK-SAME: ], align 4\n+\n+; Relative look up table for the test where gep is not immediately followed by a load check\n+; CHECK: @reltable.gep_is_not_imm_followed_by_load = internal unnamed_addr constant [2 x i32]\n+; CHECK-SAME: [\n+; CHECK-SAME: i32 trunc (i64 sub (i64 ptrtoint ([2 x i8]* @.str.8 to i64), i64 ptrtoint ([2 x i32]* @reltable.gep_is_not_imm_followed_by_load to i64)) to i32),\n+; CHECK-SAME: i32 trunc (i64 sub (i64 ptrtoint ([2 x i8]* @.str.9 to i64), i64 ptrtoint ([2 x i32]* @reltable.gep_is_not_imm_followed_by_load to i64)) to i32)\n+; CHECK-SAME: ], align 4\n+\n ; Lookup table check for integer pointers that have external linkage\n define i32* @external_linkage(i32 %cond) {\n ; CHECK-LABEL: @external_linkage(\n@@ -260,6 +287,59 @@ cond.end:                                         ; preds = %entry, %cond.false\n   ret i8* %cond1\n }\n \n+; Check to ensure that call @llvm.load.relative is inserted before load, not before gep.\n+; When a lookup table is accessed inside a loop, and a gep is hosted outside the loop via licm,\n+; make sure that call @llvm.load.relative is inserted before load.\n+define i8* @loop_hoist(i32 %x) {\n+; CHECK-LABEL: @loop_hoist(i32 %x)\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    [[TMP0:%.*]] = icmp sgt i32 [[X:%.*]], 1\n+; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds [2 x i8], [2 x i8]* @.str.10, i32 0, i32 0\n+; CHECK-NEXT:    [[RELTABLE_SHIFT:%.*]] = shl i32 [[X:%.*]], 2\n+; CHECK-NEXT:    br i1 [[TMP0]], label %if.done, label %if.false\n+; CHECK:       if.false:\n+; CHECK-NEXT:    [[RELTABLE_INTRINSIC:%.*]] = call i8* @llvm.load.relative.i32(i8* bitcast ([2 x i32]* @reltable.loop_hoist to i8*), i32 [[RELTABLE_SHIFT]])\n+; CHECK-NEXT:    br label %if.done\n+; CHECK:       if.done:\n+; CHECK-NEXT:    [[TMP2:%.*]] = phi i8* [ [[TMP1]], %entry ], [ [[RELTABLE_INTRINSIC]], %if.false ]\n+; CHECK-NEXT:    ret i8* [[TMP2]]\n+;\n+entry:\n+  %0 = icmp sgt i32 %x, 1\n+  %1 = getelementptr inbounds [2 x i8], [2 x i8]* @.str.10, i32 0, i32 0\n+  %2 = getelementptr [2 x i8*], [2 x i8*]* @table, i32 0, i32 %x\n+  br i1 %0, label %if.done, label %if.false\n+\n+if.false:\n+  %3 = load i8*, i8** %2\n+  br label %if.done\n+\n+if.done:\n+  %4 = phi i8* [ %1, %entry ], [ %3, %if.false ]\n+  ret i8* %4\n+}\n+\n+; Another check to ensure that call @llvm.load.relative is inserted before load but not before gep.\n+; When a lookup table is accessed, and gep is not immediately followed by a load (like if there is a function call\n+; or an exception in between), make sure that call @llvm.load.relative is inserted before load.\n+; CHECK-LABEL: @may_not_return()\n+declare void @may_not_return()\n+\n+define i8* @gep_is_not_imm_followed_by_load(i32 %x) {\n+; CHECK-LABEL: @gep_is_not_imm_followed_by_load(i32 %x)\n+; CHECK:       entry:\n+; CHECK-NEXT:    [[RELTABLE_SHIFT:%.*]] = shl i32 [[X:%.*]], 2\n+; CHECK-NEXT:    call void @may_not_return()\n+; CHECK-NEXT:    [[RELTABLE_INTRINSIC:%.*]] = call i8* @llvm.load.relative.i32(i8* bitcast ([2 x i32]* @reltable.gep_is_not_imm_followed_by_load to i8*), i32 [[RELTABLE_SHIFT]])\n+; CHECK-NEXT:    ret i8* [[RELTABLE_INTRINSIC]]\n+;\n+entry:\n+  %0 = getelementptr [2 x i8*], [2 x i8*]* @table2, i32 0, i32 %x\n+  call void @may_not_return()\n+  %1 = load i8*, i8** %0\n+  ret i8* %1\n+}\n+\n !llvm.module.flags = !{!0, !1}\n !0 = !{i32 7, !\"PIC Level\", i32 2}\n !1 = !{i32 1, !\"Code Model\", i32 1}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/RelLookupTableConverter/X86/relative_lookup_table.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/RelLookupTableConverter/X86/relative_lookup_table.ll\n\n\nTesting Time: 0.34s\n  Failed: 1\n"
    },
    "930a68765dff96927d706d258ef0c2ad9c7ec2ab___Loads.cpp": {
        "prefix": "static Value *getAvailableLoadStore(Instruction *Inst, const Value *Ptr,\n                                    Type *AccessTy, bool AtLeastAtomic,\n                                    const DataLayout &DL, bool *IsLoadCSE) {\n  // If this is a load of Ptr, the loaded value is available.\n  // (This is true even if the load is volatile or atomic, although\n  // those cases are unlikely.)\n  if (LoadInst *LI = dyn_cast<LoadInst>(Inst)) {\n    // We can value forward from an atomic to a non-atomic, but not the\n    // other way around.\n    if (LI->isAtomic() < AtLeastAtomic)\n      return nullptr;\n\n    Value *LoadPtr = LI->getPointerOperand()->stripPointerCasts();\n    if (!AreEquivalentAddressValues(LoadPtr, Ptr))\n      return nullptr;\n\n    if (CastInst::isBitOrNoopPointerCastable(LI->getType(), AccessTy, DL)) {\n      if (IsLoadCSE)\n        *IsLoadCSE = true;\n      return LI;\n    }\n  }\n\n  // If this is a store through Ptr, the value is available!\n  // (This is true even if the store is volatile or atomic, although\n  // those cases are unlikely.)\n  if (StoreInst *SI = dyn_cast<StoreInst>(Inst)) {\n    // We can value forward from an atomic to a non-atomic, but not the\n    // other way around.\n    if (SI->isAtomic() < AtLeastAtomic)\n      return nullptr;\n\n    Value *StorePtr = SI->getPointerOperand()->stripPointerCasts();\n    if (!AreEquivalentAddressValues(StorePtr, Ptr))\n      return nullptr;\n\n    if (IsLoadCSE)\n      *IsLoadCSE = false;\n\n    Value *Val = SI->getValueOperand();\n    if (CastInst::isBitOrNoopPointerCastable(Val->getType(), AccessTy, DL))\n      return Val;\n\n",
        "suffix": "      if (auto *C = dyn_cast<Constant>(Val))\n        return ConstantFoldLoadFromConst(C, AccessTy, DL);\n  }\n\n  return nullptr;\n}\n",
        "start": 464,
        "end": 515,
        "buggy": "static Value *getAvailableLoadStore(Instruction *Inst, const Value *Ptr,\n                                    Type *AccessTy, bool AtLeastAtomic,\n                                    const DataLayout &DL, bool *IsLoadCSE) {\n  // If this is a load of Ptr, the loaded value is available.\n  // (This is true even if the load is volatile or atomic, although\n  // those cases are unlikely.)\n  if (LoadInst *LI = dyn_cast<LoadInst>(Inst)) {\n    // We can value forward from an atomic to a non-atomic, but not the\n    // other way around.\n    if (LI->isAtomic() < AtLeastAtomic)\n      return nullptr;\n\n    Value *LoadPtr = LI->getPointerOperand()->stripPointerCasts();\n    if (!AreEquivalentAddressValues(LoadPtr, Ptr))\n      return nullptr;\n\n    if (CastInst::isBitOrNoopPointerCastable(LI->getType(), AccessTy, DL)) {\n      if (IsLoadCSE)\n        *IsLoadCSE = true;\n      return LI;\n    }\n  }\n\n  // If this is a store through Ptr, the value is available!\n  // (This is true even if the store is volatile or atomic, although\n  // those cases are unlikely.)\n  if (StoreInst *SI = dyn_cast<StoreInst>(Inst)) {\n    // We can value forward from an atomic to a non-atomic, but not the\n    // other way around.\n    if (SI->isAtomic() < AtLeastAtomic)\n      return nullptr;\n\n    Value *StorePtr = SI->getPointerOperand()->stripPointerCasts();\n    if (!AreEquivalentAddressValues(StorePtr, Ptr))\n      return nullptr;\n\n    if (IsLoadCSE)\n      *IsLoadCSE = false;\n\n    Value *Val = SI->getValueOperand();\n    if (CastInst::isBitOrNoopPointerCastable(Val->getType(), AccessTy, DL))\n      return Val;\n\n    TypeSize StoreSize = DL.getTypeStoreSize(Val->getType());\n    TypeSize LoadSize = DL.getTypeStoreSize(AccessTy);\n    if (TypeSize::isKnownLE(LoadSize, StoreSize))\n      if (auto *C = dyn_cast<Constant>(Val))\n        return ConstantFoldLoadFromConst(C, AccessTy, DL);\n  }\n\n  return nullptr;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    TypeSize StoreSize = DL.getTypeStoreSize(Val->getType());\n    TypeSize LoadSize = DL.getTypeStoreSize(AccessTy);\n    if (TypeSize::isKnownLE(LoadSize, StoreSize))\n",
        "src_path": "930a68765dff96927d706d258ef0c2ad9c7ec2ab___Loads.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/930a68765dff96927d706d258ef0c2ad9c7ec2ab",
        "commit_msg": "[Loads] Check type size in bits during store to load forwarding\n\nRather than checking the rounded type store size, check the type\nsize in bits. We don't want to forward a store of i1 to a load\nof i8 for example, even though they have the same type store size.\nThe padding bits have unspecified contents.\n\nThis is a partial fix for the issue reported at\nhttps://reviews.llvm.org/D115924#inline-1179482,\nthe problem also needs to be addressed more generally in the\nconstant folding code.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/load-store-forward.ll",
                "patch": "@@ -293,7 +293,9 @@ entry:\n define i8 @load_i8_store_i1(i1* %a) {\n ; CHECK-LABEL: @load_i8_store_i1(\n ; CHECK-NEXT:    store i1 true, i1* [[A:%.*]], align 1\n-; CHECK-NEXT:    ret i8 -1\n+; CHECK-NEXT:    [[A_I8:%.*]] = bitcast i1* [[A]] to i8*\n+; CHECK-NEXT:    [[V:%.*]] = load i8, i8* [[A_I8]], align 1\n+; CHECK-NEXT:    ret i8 [[V]]\n ;\n   store i1 true, i1* %a\n   %a.i8 = bitcast i1* %a to i8*"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/load-store-forward.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/load-store-forward.ll\n\n\nTesting Time: 0.39s\n  Failed: 1\n"
    },
    "4f046bc8e0b9439efeb2906ced7930f831495ee4___PHITransAddr.cpp": {
        "prefix": "bool PHITransAddr::PHITranslateValue(BasicBlock *CurBB, BasicBlock *PredBB,\n                                     const DominatorTree *DT,\n                                     bool MustDominate) {\n  assert(DT || !MustDominate);\n  assert(Verify() && \"Invalid PHITransAddr!\");\n  if (DT && DT->isReachableFromEntry(PredBB))\n",
        "suffix": "    Addr = nullptr;\n  assert(Verify() && \"Invalid PHITransAddr!\");\n\n  if (MustDominate)\n    // Make sure the value is live in the predecessor.\n    if (Instruction *Inst = dyn_cast_or_null<Instruction>(Addr))\n      if (!DT->dominates(Inst->getParent(), PredBB))\n        Addr = nullptr;\n\n  return Addr == nullptr;\n}\n",
        "start": 314,
        "end": 333,
        "buggy": "bool PHITransAddr::PHITranslateValue(BasicBlock *CurBB, BasicBlock *PredBB,\n                                     const DominatorTree *DT,\n                                     bool MustDominate) {\n  assert(DT || !MustDominate);\n  assert(Verify() && \"Invalid PHITransAddr!\");\n  if (DT && DT->isReachableFromEntry(PredBB))\n    Addr =\n        PHITranslateSubExpr(Addr, CurBB, PredBB, MustDominate ? DT : nullptr);\n  else\n    Addr = nullptr;\n  assert(Verify() && \"Invalid PHITransAddr!\");\n\n  if (MustDominate)\n    // Make sure the value is live in the predecessor.\n    if (Instruction *Inst = dyn_cast_or_null<Instruction>(Addr))\n      if (!DT->dominates(Inst->getParent(), PredBB))\n        Addr = nullptr;\n\n  return Addr == nullptr;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    Addr =\n        PHITranslateSubExpr(Addr, CurBB, PredBB, MustDominate ? DT : nullptr);\n  else\n",
        "src_path": "4f046bc8e0b9439efeb2906ced7930f831495ee4___PHITransAddr.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/4f046bc8e0b9439efeb2906ced7930f831495ee4",
        "commit_msg": "[PHITranslateAddr] Require dominance when searching for translated address (PR57025)\n\nThis is a fix for PR57025 and an alternative to D131776. The problem\nin the phi-translation-to-wrong-context.ll test case is that phi\ntranslation of %gep.j into if2 pick %gep.i as the result. While this\ninstruction has the correct pointer address, it occurs in a context\nwhere %i != 0. As such, we get a NoAlias result for the store in\nif2, even though they do alias for %i == 0 (which is legal in the\noriginal context of the pointer).\n\nPHITranslateValue already has a MustDominate option, which can be\nused to restrict PHI translation results to values that dominate the\ntranslated-into block. However, this is more aggressive than what we\nneed and would significantly regress GVN results. In particular, if\nwe have a pointer value that does not require any translation, then\nit is fine to continue using that value in the predecessor, because\nthe context is still correct for the original query. We only run into\nproblems if PHITranslateSubExpr() picks a completely random\ninstruction in a context that may have preconditions that do not hold.\n\nFix this by always performing the dominance checks in\nPHITranslateSubExpr(), without enabling the more general MustDominate\nrequirement.\n\nFixes https://github.com/llvm/llvm-project/issues/57025. This also\nfixes the test case for https://github.com/llvm/llvm-project/issues/30999,\nbut I'm not sure whether that's just the particular test case,\nor a general solution to the problem.\n\nDifferential Revision: https://reviews.llvm.org/D132935",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/GVN/condprop-memdep-invalidation.ll",
                "patch": "@@ -35,23 +35,18 @@ define i16 @test_PR31651(ptr %ub.16) {\n ; CHECK-NEXT:    call void @use(i16 [[L_3]])\n ; CHECK-NEXT:    br label [[LOOP_1_LATCH]]\n ; CHECK:       loop.1.latch:\n-; CHECK-NEXT:    [[L_42:%.*]] = phi i16 [ [[L_3]], [[ELSE_2]] ], [ [[L_2]], [[THEN_2]] ]\n ; CHECK-NEXT:    [[IV_1_NEXT]] = add i16 [[IV_1]], 1\n ; CHECK-NEXT:    [[CMP_3:%.*]] = icmp slt i16 [[IV_1_NEXT]], 2\n ; CHECK-NEXT:    br i1 [[CMP_3]], label [[LOOP_1_HEADER]], label [[LOOP_2:%.*]]\n ; CHECK:       loop.2:\n-; CHECK-NEXT:    [[L_4:%.*]] = phi i16 [ [[L_42]], [[LOOP_1_LATCH]] ], [ [[L_4_PRE:%.*]], [[LOOP_2_LOOP_2_CRIT_EDGE:%.*]] ]\n-; CHECK-NEXT:    [[IV_2:%.*]] = phi i16 [ 0, [[LOOP_1_LATCH]] ], [ [[IV_2_NEXT:%.*]], [[LOOP_2_LOOP_2_CRIT_EDGE]] ]\n-; CHECK-NEXT:    [[SUM:%.*]] = phi i16 [ 0, [[LOOP_1_LATCH]] ], [ [[SUM_NEXT:%.*]], [[LOOP_2_LOOP_2_CRIT_EDGE]] ]\n+; CHECK-NEXT:    [[IV_2:%.*]] = phi i16 [ 0, [[LOOP_1_LATCH]] ], [ [[IV_2_NEXT:%.*]], [[LOOP_2]] ]\n+; CHECK-NEXT:    [[SUM:%.*]] = phi i16 [ 0, [[LOOP_1_LATCH]] ], [ [[SUM_NEXT:%.*]], [[LOOP_2]] ]\n ; CHECK-NEXT:    [[GEP_5:%.*]] = getelementptr [4 x i16], ptr [[UB_16]], i16 1, i16 [[IV_2]]\n+; CHECK-NEXT:    [[L_4:%.*]] = load i16, ptr [[GEP_5]], align 2\n ; CHECK-NEXT:    [[SUM_NEXT]] = add i16 [[SUM]], [[L_4]]\n ; CHECK-NEXT:    [[IV_2_NEXT]] = add i16 [[IV_2]], 1\n ; CHECK-NEXT:    [[CMP_4:%.*]] = icmp slt i16 [[IV_2_NEXT]], 2\n-; CHECK-NEXT:    br i1 [[CMP_4]], label [[LOOP_2_LOOP_2_CRIT_EDGE]], label [[EXIT:%.*]]\n-; CHECK:       loop.2.loop.2_crit_edge:\n-; CHECK-NEXT:    [[GEP_5_PHI_TRANS_INSERT:%.*]] = getelementptr [4 x i16], ptr [[UB_16]], i16 1, i16 [[IV_2_NEXT]]\n-; CHECK-NEXT:    [[L_4_PRE]] = load i16, ptr [[GEP_5_PHI_TRANS_INSERT]], align 2\n-; CHECK-NEXT:    br label [[LOOP_2]]\n+; CHECK-NEXT:    br i1 [[CMP_4]], label [[LOOP_2]], label [[EXIT:%.*]]\n ; CHECK:       exit:\n ; CHECK-NEXT:    ret i16 [[SUM_NEXT]]\n ;"
            },
            {
                "fn": "llvm/test/Transforms/GVN/memdep-unknown-deadblocks.ll",
                "patch": "@@ -26,11 +26,6 @@\n ; Expected semantic of the function is that verify() will be called three\n ; times, with the values 7, 42 and 42.\n \n-; FIXME: The value passed to the verify function is loaded by\n-;           %value = load i16, ptr %arr.j, align 1\n-;        but currently GVN is replacing it with a faulty PHI in the\n-;        store.done block.\n-\n declare void @verify(i16)\n \n define void @test(i16 %g) {\n@@ -39,8 +34,7 @@ define void @test(i16 %g) {\n ; CHECK-GVN-NEXT:    [[ARR:%.*]] = alloca [4 x i16], align 1\n ; CHECK-GVN-NEXT:    br label [[FOR_BODY:%.*]]\n ; CHECK-GVN:       for.body:\n-; CHECK-GVN-NEXT:    [[VALUE2:%.*]] = phi i16 [ undef, [[ENTRY:%.*]] ], [ [[DEAD:%.*]], [[WHILE_END:%.*]] ]\n-; CHECK-GVN-NEXT:    [[I:%.*]] = phi i16 [ 0, [[ENTRY]] ], [ [[NEXT_I:%.*]], [[WHILE_END]] ]\n+; CHECK-GVN-NEXT:    [[I:%.*]] = phi i16 [ 0, [[ENTRY:%.*]] ], [ [[NEXT_I:%.*]], [[WHILE_END:%.*]] ]\n ; CHECK-GVN-NEXT:    [[CMP0:%.*]] = icmp eq i16 [[I]], 0\n ; CHECK-GVN-NEXT:    br i1 [[CMP0]], label [[STORE_IDX_0:%.*]], label [[STORE_IDX_I:%.*]]\n ; CHECK-GVN:       store.idx.0:\n@@ -51,26 +45,25 @@ define void @test(i16 %g) {\n ; CHECK-GVN-NEXT:    store i16 42, ptr [[ARR_I]], align 1\n ; CHECK-GVN-NEXT:    br label [[STORE_DONE]]\n ; CHECK-GVN:       store.done:\n-; CHECK-GVN-NEXT:    [[VALUE:%.*]] = phi i16 [ 42, [[STORE_IDX_I]] ], [ [[VALUE2]], [[STORE_IDX_0]] ]\n ; CHECK-GVN-NEXT:    br label [[WHILE_BODY:%.*]]\n ; CHECK-GVN:       while.body:\n ; CHECK-GVN-NEXT:    br i1 false, label [[WHILE_BODY_WHILE_BODY_CRIT_EDGE:%.*]], label [[WHILE_END]]\n ; CHECK-GVN:       while.body.while.body_crit_edge:\n ; CHECK-GVN-NEXT:    br label [[WHILE_BODY]]\n ; CHECK-GVN:       while.end:\n ; CHECK-GVN-NEXT:    [[ARR_J:%.*]] = getelementptr [4 x i16], ptr [[ARR]], i16 0, i16 [[I]]\n+; CHECK-GVN-NEXT:    [[VALUE:%.*]] = load i16, ptr [[ARR_J]], align 1\n ; CHECK-GVN-NEXT:    tail call void @verify(i16 [[VALUE]])\n ; CHECK-GVN-NEXT:    [[NEXT_I]] = add i16 [[I]], 1\n ; CHECK-GVN-NEXT:    [[ARR_NEXT_I:%.*]] = getelementptr [4 x i16], ptr [[ARR]], i16 0, i16 [[NEXT_I]]\n-; CHECK-GVN-NEXT:    [[DEAD]] = load i16, ptr [[ARR_NEXT_I]], align 1\n ; CHECK-GVN-NEXT:    [[CMP4:%.*]] = icmp slt i16 [[NEXT_I]], 3\n ; CHECK-GVN-NEXT:    br i1 [[CMP4]], label [[FOR_BODY]], label [[FOR_END:%.*]]\n ; CHECK-GVN:       for.end:\n ; CHECK-GVN-NEXT:    ret void\n ;\n ; CHECK-GVN-O1-LABEL: @test(\n ; CHECK-GVN-O1-NEXT:  entry:\n-; CHECK-GVN-O1-NEXT:    tail call void @verify(i16 42)\n+; CHECK-GVN-O1-NEXT:    tail call void @verify(i16 7)\n ; CHECK-GVN-O1-NEXT:    tail call void @verify(i16 42)\n ; CHECK-GVN-O1-NEXT:    tail call void @verify(i16 42)\n ; CHECK-GVN-O1-NEXT:    ret void"
            },
            {
                "fn": "llvm/test/Transforms/GVN/phi-translation-to-wrong-context.ll",
                "patch": "@@ -1,7 +1,6 @@\n ; NOTE: Assertions have been autogenerated by utils/update_test_checks.py\n ; RUN: opt -S -gvn < %s | FileCheck %s\n \n-; FIXME\n ; Phi translation of %gep.j cannot use %gep.i, which is located in a context\n ; where %i != 0, and would result in incorrect NoAlias results in a context\n ; where %i == 0 may hold.\n@@ -15,14 +14,17 @@ define i32 @test(i64 %i, i1 %c1, i1 %c2) {\n ; CHECK-NEXT:    br i1 [[C2:%.*]], label [[IF2:%.*]], label [[ELSE2:%.*]]\n ; CHECK:       if2:\n ; CHECK-NEXT:    store i32 1, ptr [[PTR]], align 4\n+; CHECK-NEXT:    [[GEP_J_PHI_TRANS_INSERT:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[I:%.*]]\n+; CHECK-NEXT:    [[V_PRE:%.*]] = load i32, ptr [[GEP_J_PHI_TRANS_INSERT]], align 4\n ; CHECK-NEXT:    br label [[JOIN:%.*]]\n ; CHECK:       else2:\n ; CHECK-NEXT:    store i32 2, ptr [[PTR]], align 4\n ; CHECK-NEXT:    br label [[JOIN]]\n ; CHECK:       join:\n-; CHECK-NEXT:    [[J:%.*]] = phi i64 [ [[I:%.*]], [[IF2]] ], [ 0, [[ELSE2]] ]\n+; CHECK-NEXT:    [[V:%.*]] = phi i32 [ [[V_PRE]], [[IF2]] ], [ 2, [[ELSE2]] ]\n+; CHECK-NEXT:    [[J:%.*]] = phi i64 [ [[I]], [[IF2]] ], [ 0, [[ELSE2]] ]\n ; CHECK-NEXT:    [[GEP_J:%.*]] = getelementptr inbounds i32, ptr [[PTR]], i64 [[J]]\n-; CHECK-NEXT:    ret i32 2\n+; CHECK-NEXT:    ret i32 [[V]]\n ; CHECK:       else:\n ; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i64 [[I]], 0\n ; CHECK-NEXT:    call void @llvm.assume(i1 [[CMP]])"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/GVN/condprop-memdep-invalidation.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/GVN/condprop-memdep-invalidation.ll\n\n\nTesting Time: 0.33s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/GVN/memdep-unknown-deadblocks.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/GVN/memdep-unknown-deadblocks.ll\n\n\nTesting Time: 0.09s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/GVN/phi-translation-to-wrong-context.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/GVN/phi-translation-to-wrong-context.ll\n\n\nTesting Time: 0.11s\n  Failed: 1\n"
    },
    "6acf6661dd17af9f9858f3d3ff67eb88f7675d31___ConstantFolding.cpp": {
        "prefix": "static Constant *constantFoldCanonicalize(const Type *Ty, const CallBase *CI,\n                                          const APFloat &Src) {\n  // Zero, positive and negative, is always OK to fold.\n  if (Src.isZero()) {\n    // Get a fresh 0, since ppc_fp128 does have non-canonical zeros.\n    return ConstantFP::get(\n        CI->getContext(),\n        APFloat::getZero(Src.getSemantics(), Src.isNegative()));\n  }\n\n  if (!Ty->isIEEELikeFPTy())\n    return nullptr;\n\n  // Zero is always canonical and the sign must be preserved.\n  //\n  // Denorms and nans may have special encodings, but it should be OK to fold a\n  // totally average number.\n  if (Src.isNormal() || Src.isInfinity())\n    return ConstantFP::get(CI->getContext(), Src);\n\n  if (Src.isDenormal() && CI->getParent() && CI->getFunction()) {\n    DenormalMode DenormMode =\n        CI->getFunction()->getDenormalMode(Src.getSemantics());\n    if (DenormMode == DenormalMode::getIEEE())\n      return nullptr;\n\n",
        "suffix": "                           APFloat::getZero(Src.getSemantics(), !IsPositive));\n  }\n\n  return nullptr;\n}\n",
        "start": 1947,
        "end": 1981,
        "buggy": "static Constant *constantFoldCanonicalize(const Type *Ty, const CallBase *CI,\n                                          const APFloat &Src) {\n  // Zero, positive and negative, is always OK to fold.\n  if (Src.isZero()) {\n    // Get a fresh 0, since ppc_fp128 does have non-canonical zeros.\n    return ConstantFP::get(\n        CI->getContext(),\n        APFloat::getZero(Src.getSemantics(), Src.isNegative()));\n  }\n\n  if (!Ty->isIEEELikeFPTy())\n    return nullptr;\n\n  // Zero is always canonical and the sign must be preserved.\n  //\n  // Denorms and nans may have special encodings, but it should be OK to fold a\n  // totally average number.\n  if (Src.isNormal() || Src.isInfinity())\n    return ConstantFP::get(CI->getContext(), Src);\n\n  if (Src.isDenormal() && CI->getParent() && CI->getFunction()) {\n    DenormalMode DenormMode =\n        CI->getFunction()->getDenormalMode(Src.getSemantics());\n    if (DenormMode == DenormalMode::getIEEE())\n      return nullptr;\n\n    bool IsPositive = !Src.isNegative() ||\n                      DenormMode.Input == DenormalMode::PositiveZero ||\n                      DenormMode.Output == DenormalMode::PositiveZero;\n    return ConstantFP::get(CI->getContext(),\n                           APFloat::getZero(Src.getSemantics(), !IsPositive));\n  }\n\n  return nullptr;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    bool IsPositive = !Src.isNegative() ||\n                      DenormMode.Input == DenormalMode::PositiveZero ||\n                      DenormMode.Output == DenormalMode::PositiveZero;\n    return ConstantFP::get(CI->getContext(),\n",
        "src_path": "6acf6661dd17af9f9858f3d3ff67eb88f7675d31___ConstantFolding.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/6acf6661dd17af9f9858f3d3ff67eb88f7675d31",
        "commit_msg": "ConstantFolding: Ignore output denorm mode for canonicalize\n\nAlive2 opt plugin is now happy with the test. Fixes issue 59245",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstSimplify/canonicalize.ll",
                "patch": "@@ -238,7 +238,7 @@ define float @canonicalize_neg_denorm_preserve_sign_output_positive_zero_input()\n \n define float @canonicalize_neg_denorm_positive_zero_output_preserve_sign_input() \"denormal-fp-math\"=\"positive-zero,preserve-sign\" {\n ; CHECK-LABEL: @canonicalize_neg_denorm_positive_zero_output_preserve_sign_input(\n-; CHECK-NEXT:    ret float 0.000000e+00\n+; CHECK-NEXT:    ret float -0.000000e+00\n ;\n   %ret = call float @llvm.canonicalize.f32(float bitcast (i32 -2139095041 to float))\n   ret float %ret"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstSimplify/canonicalize.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstSimplify/canonicalize.ll\n\n\nTesting Time: 0.40s\n  Failed: 1\n"
    },
    "68469a80cb7468c577701d725a56a86454b8f0cb___LoopVectorize.cpp": {
        "prefix": "void LoopVectorizationPlanner::executePlan(ElementCount BestVF, unsigned BestUF,\n                                           VPlan &BestVPlan,\n                                           InnerLoopVectorizer &ILV,\n                                           DominatorTree *DT,\n                                           bool IsEpilogueVectorization) {\n  assert(BestVPlan.hasVF(BestVF) &&\n         \"Trying to execute plan with unsupported VF\");\n  assert(BestVPlan.hasUF(BestUF) &&\n         \"Trying to execute plan with unsupported UF\");\n\n  LLVM_DEBUG(dbgs() << \"Executing best plan with VF=\" << BestVF << \", UF=\" << BestUF\n                    << '\\n');\n\n  // Workaround!  Compute the trip count of the original loop and cache it\n  // before we start modifying the CFG.  This code has a systemic problem\n  // wherein it tries to run analysis over partially constructed IR; this is\n  // wrong, and not simply for SCEV.  The trip count of the original loop\n  // simply happens to be prone to hitting this in practice.  In theory, we\n  // can hit the same issue for any SCEV, or ValueTracking query done during\n  // mutation.  See PR49900.\n  ILV.getOrCreateTripCount(OrigLoop->getLoopPreheader());\n\n  if (!IsEpilogueVectorization)\n    VPlanTransforms::optimizeForVFAndUF(BestVPlan, BestVF, BestUF, PSE);\n\n  // Perform the actual loop transformation.\n\n  // 1. Set up the skeleton for vectorization, including vector pre-header and\n  // middle block. The vector loop is created during VPlan execution.\n  VPTransformState State{BestVF, BestUF, LI, DT, ILV.Builder, &ILV, &BestVPlan};\n  Value *CanonicalIVStartValue;\n  std::tie(State.CFG.PrevBB, CanonicalIVStartValue) =\n      ILV.createVectorizedLoopSkeleton();\n\n  // Only use noalias metadata when using memory checks guaranteeing no overlap\n  // across all iterations.\n  const LoopAccessInfo *LAI = ILV.Legal->getLAI();\n  if (LAI && !LAI->getRuntimePointerChecking()->getChecks().empty() &&\n      !LAI->getRuntimePointerChecking()->getDiffChecks()) {\n\n    //  We currently don't use LoopVersioning for the actual loop cloning but we\n    //  still use it to add the noalias metadata.\n    //  TODO: Find a better way to re-use LoopVersioning functionality to add\n    //        metadata.\n    State.LVer = std::make_unique<LoopVersioning>(\n        *LAI, LAI->getRuntimePointerChecking()->getChecks(), OrigLoop, LI, DT,\n        PSE.getSE());\n    State.LVer->prepareNoAliasMetadata();\n  }\n\n  ILV.collectPoisonGeneratingRecipes(State);\n\n  ILV.printDebugTracesAtStart();\n\n  //===------------------------------------------------===//\n  //\n  // Notice: any optimization or new instruction that go\n  // into the code below should also be implemented in\n  // the cost-model.\n  //\n  //===------------------------------------------------===//\n\n  // 2. Copy and widen instructions from the old loop into the new loop.\n  BestVPlan.prepareToExecute(ILV.getOrCreateTripCount(nullptr),\n                             ILV.getOrCreateVectorTripCount(nullptr),\n                             CanonicalIVStartValue, State,\n                             IsEpilogueVectorization);\n\n  BestVPlan.execute(&State);\n\n  // Keep all loop hints from the original loop on the vector loop (we'll\n  // replace the vectorizer-specific hints below).\n  MDNode *OrigLoopID = OrigLoop->getLoopID();\n\n  std::optional<MDNode *> VectorizedLoopID =\n      makeFollowupLoopID(OrigLoopID, {LLVMLoopVectorizeFollowupAll,\n                                      LLVMLoopVectorizeFollowupVectorized});\n\n  VPBasicBlock *HeaderVPBB =\n      BestVPlan.getVectorLoopRegion()->getEntryBasicBlock();\n  Loop *L = LI->getLoopFor(State.CFG.VPBB2IRBB[HeaderVPBB]);\n  if (VectorizedLoopID)\n    L->setLoopID(*VectorizedLoopID);\n  else {\n    // Keep all loop hints from the original loop on the vector loop (we'll\n    // replace the vectorizer-specific hints below).\n    if (MDNode *LID = OrigLoop->getLoopID())\n      L->setLoopID(LID);\n\n    LoopVectorizeHints Hints(L, true, *ORE);\n    Hints.setAlreadyVectorized();\n  }\n",
        "suffix": "  // 3. Fix the vectorized code: take care of header phi's, live-outs,\n  //    predication, updating analyses.\n  ILV.fixVectorizedLoop(State, BestVPlan);\n\n  ILV.printDebugTracesAtEnd();\n}\n",
        "start": 7609,
        "end": 7710,
        "buggy": "void LoopVectorizationPlanner::executePlan(ElementCount BestVF, unsigned BestUF,\n                                           VPlan &BestVPlan,\n                                           InnerLoopVectorizer &ILV,\n                                           DominatorTree *DT,\n                                           bool IsEpilogueVectorization) {\n  assert(BestVPlan.hasVF(BestVF) &&\n         \"Trying to execute plan with unsupported VF\");\n  assert(BestVPlan.hasUF(BestUF) &&\n         \"Trying to execute plan with unsupported UF\");\n\n  LLVM_DEBUG(dbgs() << \"Executing best plan with VF=\" << BestVF << \", UF=\" << BestUF\n                    << '\\n');\n\n  // Workaround!  Compute the trip count of the original loop and cache it\n  // before we start modifying the CFG.  This code has a systemic problem\n  // wherein it tries to run analysis over partially constructed IR; this is\n  // wrong, and not simply for SCEV.  The trip count of the original loop\n  // simply happens to be prone to hitting this in practice.  In theory, we\n  // can hit the same issue for any SCEV, or ValueTracking query done during\n  // mutation.  See PR49900.\n  ILV.getOrCreateTripCount(OrigLoop->getLoopPreheader());\n\n  if (!IsEpilogueVectorization)\n    VPlanTransforms::optimizeForVFAndUF(BestVPlan, BestVF, BestUF, PSE);\n\n  // Perform the actual loop transformation.\n\n  // 1. Set up the skeleton for vectorization, including vector pre-header and\n  // middle block. The vector loop is created during VPlan execution.\n  VPTransformState State{BestVF, BestUF, LI, DT, ILV.Builder, &ILV, &BestVPlan};\n  Value *CanonicalIVStartValue;\n  std::tie(State.CFG.PrevBB, CanonicalIVStartValue) =\n      ILV.createVectorizedLoopSkeleton();\n\n  // Only use noalias metadata when using memory checks guaranteeing no overlap\n  // across all iterations.\n  const LoopAccessInfo *LAI = ILV.Legal->getLAI();\n  if (LAI && !LAI->getRuntimePointerChecking()->getChecks().empty() &&\n      !LAI->getRuntimePointerChecking()->getDiffChecks()) {\n\n    //  We currently don't use LoopVersioning for the actual loop cloning but we\n    //  still use it to add the noalias metadata.\n    //  TODO: Find a better way to re-use LoopVersioning functionality to add\n    //        metadata.\n    State.LVer = std::make_unique<LoopVersioning>(\n        *LAI, LAI->getRuntimePointerChecking()->getChecks(), OrigLoop, LI, DT,\n        PSE.getSE());\n    State.LVer->prepareNoAliasMetadata();\n  }\n\n  ILV.collectPoisonGeneratingRecipes(State);\n\n  ILV.printDebugTracesAtStart();\n\n  //===------------------------------------------------===//\n  //\n  // Notice: any optimization or new instruction that go\n  // into the code below should also be implemented in\n  // the cost-model.\n  //\n  //===------------------------------------------------===//\n\n  // 2. Copy and widen instructions from the old loop into the new loop.\n  BestVPlan.prepareToExecute(ILV.getOrCreateTripCount(nullptr),\n                             ILV.getOrCreateVectorTripCount(nullptr),\n                             CanonicalIVStartValue, State,\n                             IsEpilogueVectorization);\n\n  BestVPlan.execute(&State);\n\n  // Keep all loop hints from the original loop on the vector loop (we'll\n  // replace the vectorizer-specific hints below).\n  MDNode *OrigLoopID = OrigLoop->getLoopID();\n\n  std::optional<MDNode *> VectorizedLoopID =\n      makeFollowupLoopID(OrigLoopID, {LLVMLoopVectorizeFollowupAll,\n                                      LLVMLoopVectorizeFollowupVectorized});\n\n  VPBasicBlock *HeaderVPBB =\n      BestVPlan.getVectorLoopRegion()->getEntryBasicBlock();\n  Loop *L = LI->getLoopFor(State.CFG.VPBB2IRBB[HeaderVPBB]);\n  if (VectorizedLoopID)\n    L->setLoopID(*VectorizedLoopID);\n  else {\n    // Keep all loop hints from the original loop on the vector loop (we'll\n    // replace the vectorizer-specific hints below).\n    if (MDNode *LID = OrigLoop->getLoopID())\n      L->setLoopID(LID);\n\n    LoopVectorizeHints Hints(L, true, *ORE);\n    Hints.setAlreadyVectorized();\n  }\n  // Disable runtime unrolling when vectorizing the epilogue loop.\n  if (CanonicalIVStartValue)\n    AddRuntimeUnrollDisableMetaData(L);\n\n  // 3. Fix the vectorized code: take care of header phi's, live-outs,\n  //    predication, updating analyses.\n  ILV.fixVectorizedLoop(State, BestVPlan);\n\n  ILV.printDebugTracesAtEnd();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  // Disable runtime unrolling when vectorizing the epilogue loop.\n  if (CanonicalIVStartValue)\n    AddRuntimeUnrollDisableMetaData(L);\n\n",
        "src_path": "68469a80cb7468c577701d725a56a86454b8f0cb___LoopVectorize.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/68469a80cb7468c577701d725a56a86454b8f0cb",
        "commit_msg": "[LV] Disable runtime unrolling for vectorized loops.\n\nThis patch adds metadata to disable runtime unrolling to the vectorized\nloop. If runtime unrolling/interleaving is considered profitable, LV\nwill interleave the loop directly. There should be no need to perform\nruntime unrolling at a later stage.\n\nNote that we already add metadata to disable runtime unrolling to the\nscalar loop after vectorization.\n\nThe additional unrolling unnecessarily increases code size and compile\ntime. In addition to that we have several bug reports of unncessary\nruntime unrolling for vectorized loops, e.g. PR40961\n\nCompile-time improvements:\n\n  NewPM-O3: -1.04%\n  NewPM-ReleaseThinLTO: -0.59%\n  NewPM-ReleaseLTO-g: -0.97%\n\nhttps://llvm-compile-time-tracker.com/compare.php?from=ce1be13a868d0f8afa367975558c1a6175cce33a&to=78bc2e67f22e9e10e61cdb6cdac4bb857d95eb1b&stat=instructions:u\n\nFixes #40306.\n\nReviewed By: lebedev.ri, nikic\n\nDifferential Revision: https://reviews.llvm.org/D115261",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/LoopVectorize/ARM/pointer_iv.ll",
                "patch": "@@ -62,8 +62,8 @@ define hidden void @pointer_phi_v4i32_add2(ptr noalias nocapture readonly %A, pt\n ; CHECK-NEXT:    [[TMP2:%.*]] = add nsw <4 x i32> [[STRIDED_VEC]], [[BROADCAST_SPLAT]]\n ; CHECK-NEXT:    store <4 x i32> [[TMP2]], ptr [[NEXT_GEP4]], align 4\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 4\n-; CHECK-NEXT:    [[TMP3:%.*]] = icmp eq i32 [[INDEX_NEXT]], 996\n-; CHECK-NEXT:    br i1 [[TMP3]], label [[FOR_BODY:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP2:![0-9]+]]\n+; CHECK-NEXT:    [[TMP4:%.*]] = icmp eq i32 [[INDEX_NEXT]], 996\n+; CHECK-NEXT:    br i1 [[TMP4]], label [[FOR_BODY:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ; CHECK:       for.body:\n ; CHECK-NEXT:    [[A_ADDR_09:%.*]] = phi ptr [ [[ADD_PTR:%.*]], [[FOR_BODY]] ], [ [[IND_END]], [[VECTOR_BODY]] ]\n ; CHECK-NEXT:    [[I_08:%.*]] = phi i32 [ [[INC:%.*]], [[FOR_BODY]] ], [ 996, [[VECTOR_BODY]] ]\n@@ -75,7 +75,7 @@ define hidden void @pointer_phi_v4i32_add2(ptr noalias nocapture readonly %A, pt\n ; CHECK-NEXT:    [[INCDEC_PTR]] = getelementptr inbounds i32, ptr [[B_ADDR_07]], i32 1\n ; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_08]], 1\n ; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[INC]], 1000\n-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[END:%.*]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EXITCOND]], label [[END:%.*]], label [[FOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]\n ; CHECK:       end:\n ; CHECK-NEXT:    ret void\n ;"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/ARM/tail-folding-loop-hint.ll",
                "patch": "@@ -74,11 +74,11 @@ for.body:\n   br i1 %exitcond, label %for.cond.cleanup, label %for.body, !llvm.loop !6\n }\n \n-; CHECK:      [[VEC_LOOP1]] = distinct !{[[VEC_LOOP1]], [[MD_IS_VEC:![0-9]+]]}\n+; CHECK:      [[VEC_LOOP1]] = distinct !{[[VEC_LOOP1]], [[MD_IS_VEC:![0-9]+]], [[MD_RT_UNROLL_DIS:![0-9]+]]}\n ; CHECK-NEXT: [[MD_IS_VEC:![0-9]+]] = !{!\"llvm.loop.isvectorized\", i32 1}\n-; CHECK-NEXT: [[SCALAR_LOOP1]] = distinct !{[[SCALAR_LOOP1]], [[MD_RT_UNROLL_DIS:![0-9]+]], [[MD_IS_VEC]]}\n ; CHECK-NEXT: [[MD_RT_UNROLL_DIS]] = !{!\"llvm.loop.unroll.runtime.disable\"}\n-; CHECK-NEXT: [[VEC_LOOP2]] = distinct !{[[VEC_LOOP2]], [[MD_IS_VEC]]}\n+; CHECK-NEXT: [[SCALAR_LOOP1]] = distinct !{[[SCALAR_LOOP1]], [[MD_RT_UNROLL_DIS]], [[MD_IS_VEC]]}\n+; CHECK-NEXT: [[VEC_LOOP2]] = distinct !{[[VEC_LOOP2]], [[MD_IS_VEC]], [[MD_RT_UNROLL_DIS]]}\n ; CHECK-NEXT: [[SCALAR_LOOP2]] = distinct !{[[SCALAR_LOOP2]], [[MD_RT_UNROLL_DIS]], [[MD_IS_VEC]]}\n \n !6 = distinct !{!6, !7, !8}"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/PowerPC/optimal-epilog-vectorization.ll",
                "patch": "@@ -1003,13 +1003,13 @@ for.end:                                          ; preds = %for.end.loopexit, %\n   ret i32 0\n }\n \n-; VF-TWO-CHECK-DAG: [[LOOPID_MV]] = distinct !{[[LOOPID_MV]], [[LOOPID_DISABLE_VECT:!.*]]}\n-; VF-TWO-CHECK-DAG: [[LOOPID_EV]] = distinct !{[[LOOPID_EV]], [[LOOPID_DISABLE_VECT]], [[LOOPID_DISABLE_UNROLL:!.*]]}\n+; VF-TWO-CHECK-DAG: [[LOOPID_MV]] = distinct !{[[LOOPID_MV]], [[LOOPID_DISABLE_VECT:!.*]], [[LOOPID_DISABLE_UNROLL:!.*]]}\n+; VF-TWO-CHECK-DAG: [[LOOPID_EV]] = distinct !{[[LOOPID_EV]], [[LOOPID_DISABLE_VECT]], [[LOOPID_DISABLE_UNROLL]]}\n ; VF-TWO-CHECK-DAG: [[LOOPID_DISABLE_VECT]] = [[DISABLE_VECT_STR:!{!\"llvm.loop.isvectorized\".*}.*]]\n ; VF-TWO-CHECK-DAG: [[LOOPID_DISABLE_UNROLL]] = [[DISABLE_UNROLL_STR:!{!\"llvm.loop.unroll.runtime.disable\"}.*]]\n ;\n-; VF-FOUR-CHECK-DAG: [[LOOPID_MV_CM]] = distinct !{[[LOOPID_MV_CM]], [[LOOPID_DISABLE_VECT_CM:!.*]]}\n-; VF-FOUR-CHECK-DAG: [[LOOPID_EV_CM]] = distinct !{[[LOOPID_EV_CM]], [[LOOPID_DISABLE_VECT_CM]], [[LOOPID_DISABLE_UNROLL_CM:!.*]]}\n+; VF-FOUR-CHECK-DAG: [[LOOPID_MV_CM]] = distinct !{[[LOOPID_MV_CM]], [[LOOPID_DISABLE_VECT_CM:!.*]], [[LOOPID_DISABLE_UNROLL_CM:!.*]]}\n+; VF-FOUR-CHECK-DAG: [[LOOPID_EV_CM]] = distinct !{[[LOOPID_EV_CM]], [[LOOPID_DISABLE_VECT_CM]], [[LOOPID_DISABLE_UNROLL_CM]]}\n ; VF-FOUR-CHECK-DAG: [[LOOPID_DISABLE_VECT_CM]] = [[DISABLE_VECT_STR_CM:!{!\"llvm.loop.isvectorized\".*}.*]]\n ; VF-FOUR-CHECK-DAG: [[LOOPID_DISABLE_UNROLL_CM]] = [[DISABLE_UNROLL_STR_CM:!{!\"llvm.loop.unroll.runtime.disable\"}.*]]\n ;"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/X86/already-vectorized.ll",
                "patch": "@@ -41,8 +41,7 @@ for.end:                                          ; preds = %for.body\n }\n \n ; Now, we check for the Hint metadata\n-; CHECK: [[vect]] = distinct !{[[vect]], [[width:![0-9]+]]}\n+; CHECK: [[vect]] = distinct !{[[vect]], [[width:![0-9]+]], [[runtime_unroll:![0-9]+]]}\n ; CHECK: [[width]] = !{!\"llvm.loop.isvectorized\", i32 1}\n-; CHECK: [[scalar]] = distinct !{[[scalar]], [[runtime_unroll:![0-9]+]], [[width]]}\n ; CHECK: [[runtime_unroll]] = !{!\"llvm.loop.unroll.runtime.disable\"}\n-\n+; CHECK: [[scalar]] = distinct !{[[scalar]], [[runtime_unroll]], [[width]]}"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/X86/float-induction-x86.ll",
                "patch": "@@ -25,102 +25,28 @@ define void @fp_iv_loop1(ptr noalias nocapture %A, i32 %N) #0 {\n ; AUTO_VEC-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[FOR_BODY:%.*]], label [[VECTOR_PH:%.*]]\n ; AUTO_VEC:       vector.ph:\n ; AUTO_VEC-NEXT:    [[N_VEC:%.*]] = and i64 [[ZEXT]], 4294967264\n-; AUTO_VEC-NEXT:    [[CAST_VTC:%.*]] = sitofp i64 [[N_VEC]] to float\n-; AUTO_VEC-NEXT:    [[TMP0:%.*]] = fmul fast float [[CAST_VTC]], 5.000000e-01\n+; AUTO_VEC-NEXT:    [[DOTCAST:%.*]] = sitofp i64 [[N_VEC]] to float\n+; AUTO_VEC-NEXT:    [[TMP0:%.*]] = fmul fast float [[DOTCAST]], 5.000000e-01\n ; AUTO_VEC-NEXT:    [[IND_END:%.*]] = fadd fast float [[TMP0]], 1.000000e+00\n-; AUTO_VEC-NEXT:    [[TMP1:%.*]] = add nsw i64 [[ZEXT]], -32\n-; AUTO_VEC-NEXT:    [[TMP2:%.*]] = lshr i64 [[TMP1]], 5\n-; AUTO_VEC-NEXT:    [[TMP3:%.*]] = add nuw nsw i64 [[TMP2]], 1\n-; AUTO_VEC-NEXT:    [[XTRAITER:%.*]] = and i64 [[TMP3]], 3\n-; AUTO_VEC-NEXT:    [[TMP4:%.*]] = icmp ult i64 [[TMP1]], 96\n-; AUTO_VEC-NEXT:    br i1 [[TMP4]], label [[MIDDLE_BLOCK_UNR_LCSSA:%.*]], label [[VECTOR_PH_NEW:%.*]]\n-; AUTO_VEC:       vector.ph.new:\n-; AUTO_VEC-NEXT:    [[UNROLL_ITER:%.*]] = and i64 [[TMP3]], -4\n ; AUTO_VEC-NEXT:    br label [[VECTOR_BODY:%.*]]\n ; AUTO_VEC:       vector.body:\n-; AUTO_VEC-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH_NEW]] ], [ [[INDEX_NEXT_3:%.*]], [[VECTOR_BODY]] ]\n-; AUTO_VEC-NEXT:    [[VEC_IND:%.*]] = phi <8 x float> [ <float 1.000000e+00, float 1.500000e+00, float 2.000000e+00, float 2.500000e+00, float 3.000000e+00, float 3.500000e+00, float 4.000000e+00, float 4.500000e+00>, [[VECTOR_PH_NEW]] ], [ [[VEC_IND_NEXT_3:%.*]], [[VECTOR_BODY]] ]\n-; AUTO_VEC-NEXT:    [[NITER:%.*]] = phi i64 [ 0, [[VECTOR_PH_NEW]] ], [ [[NITER_NEXT_3:%.*]], [[VECTOR_BODY]] ]\n+; AUTO_VEC-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]\n+; AUTO_VEC-NEXT:    [[VEC_IND:%.*]] = phi <8 x float> [ <float 1.000000e+00, float 1.500000e+00, float 2.000000e+00, float 2.500000e+00, float 3.000000e+00, float 3.500000e+00, float 4.000000e+00, float 4.500000e+00>, [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]\n ; AUTO_VEC-NEXT:    [[STEP_ADD:%.*]] = fadd fast <8 x float> [[VEC_IND]], <float 4.000000e+00, float 4.000000e+00, float 4.000000e+00, float 4.000000e+00, float 4.000000e+00, float 4.000000e+00, float 4.000000e+00, float 4.000000e+00>\n ; AUTO_VEC-NEXT:    [[STEP_ADD2:%.*]] = fadd fast <8 x float> [[VEC_IND]], <float 8.000000e+00, float 8.000000e+00, float 8.000000e+00, float 8.000000e+00, float 8.000000e+00, float 8.000000e+00, float 8.000000e+00, float 8.000000e+00>\n ; AUTO_VEC-NEXT:    [[STEP_ADD3:%.*]] = fadd fast <8 x float> [[VEC_IND]], <float 1.200000e+01, float 1.200000e+01, float 1.200000e+01, float 1.200000e+01, float 1.200000e+01, float 1.200000e+01, float 1.200000e+01, float 1.200000e+01>\n-; AUTO_VEC-NEXT:    [[TMP5:%.*]] = getelementptr inbounds float, ptr [[A:%.*]], i64 [[INDEX]]\n-; AUTO_VEC-NEXT:    store <8 x float> [[VEC_IND]], ptr [[TMP5]], align 4\n-; AUTO_VEC-NEXT:    [[TMP7:%.*]] = getelementptr inbounds float, ptr [[TMP5]], i64 8\n-; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD]], ptr [[TMP7]], align 4\n-; AUTO_VEC-NEXT:    [[TMP9:%.*]] = getelementptr inbounds float, ptr [[TMP5]], i64 16\n-; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD2]], ptr [[TMP9]], align 4\n-; AUTO_VEC-NEXT:    [[TMP11:%.*]] = getelementptr inbounds float, ptr [[TMP5]], i64 24\n-; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD3]], ptr [[TMP11]], align 4\n-; AUTO_VEC-NEXT:    [[INDEX_NEXT:%.*]] = or i64 [[INDEX]], 32\n-; AUTO_VEC-NEXT:    [[VEC_IND_NEXT:%.*]] = fadd fast <8 x float> [[VEC_IND]], <float 1.600000e+01, float 1.600000e+01, float 1.600000e+01, float 1.600000e+01, float 1.600000e+01, float 1.600000e+01, float 1.600000e+01, float 1.600000e+01>\n-; AUTO_VEC-NEXT:    [[STEP_ADD_1:%.*]] = fadd fast <8 x float> [[VEC_IND]], <float 2.000000e+01, float 2.000000e+01, float 2.000000e+01, float 2.000000e+01, float 2.000000e+01, float 2.000000e+01, float 2.000000e+01, float 2.000000e+01>\n-; AUTO_VEC-NEXT:    [[STEP_ADD2_1:%.*]] = fadd fast <8 x float> [[VEC_IND]], <float 2.400000e+01, float 2.400000e+01, float 2.400000e+01, float 2.400000e+01, float 2.400000e+01, float 2.400000e+01, float 2.400000e+01, float 2.400000e+01>\n-; AUTO_VEC-NEXT:    [[STEP_ADD3_1:%.*]] = fadd fast <8 x float> [[VEC_IND]], <float 2.800000e+01, float 2.800000e+01, float 2.800000e+01, float 2.800000e+01, float 2.800000e+01, float 2.800000e+01, float 2.800000e+01, float 2.800000e+01>\n-; AUTO_VEC-NEXT:    [[TMP13:%.*]] = getelementptr inbounds float, ptr [[A]], i64 [[INDEX_NEXT]]\n-; AUTO_VEC-NEXT:    store <8 x float> [[VEC_IND_NEXT]], ptr [[TMP13]], align 4\n-; AUTO_VEC-NEXT:    [[TMP15:%.*]] = getelementptr inbounds float, ptr [[TMP13]], i64 8\n-; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD_1]], ptr [[TMP15]], align 4\n-; AUTO_VEC-NEXT:    [[TMP17:%.*]] = getelementptr inbounds float, ptr [[TMP13]], i64 16\n-; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD2_1]], ptr [[TMP17]], align 4\n-; AUTO_VEC-NEXT:    [[TMP19:%.*]] = getelementptr inbounds float, ptr [[TMP13]], i64 24\n-; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD3_1]], ptr [[TMP19]], align 4\n-; AUTO_VEC-NEXT:    [[INDEX_NEXT_1:%.*]] = or i64 [[INDEX]], 64\n-; AUTO_VEC-NEXT:    [[VEC_IND_NEXT_1:%.*]] = fadd fast <8 x float> [[VEC_IND]], <float 3.200000e+01, float 3.200000e+01, float 3.200000e+01, float 3.200000e+01, float 3.200000e+01, float 3.200000e+01, float 3.200000e+01, float 3.200000e+01>\n-; AUTO_VEC-NEXT:    [[STEP_ADD_2:%.*]] = fadd fast <8 x float> [[VEC_IND]], <float 3.600000e+01, float 3.600000e+01, float 3.600000e+01, float 3.600000e+01, float 3.600000e+01, float 3.600000e+01, float 3.600000e+01, float 3.600000e+01>\n-; AUTO_VEC-NEXT:    [[STEP_ADD2_2:%.*]] = fadd fast <8 x float> [[VEC_IND]], <float 4.000000e+01, float 4.000000e+01, float 4.000000e+01, float 4.000000e+01, float 4.000000e+01, float 4.000000e+01, float 4.000000e+01, float 4.000000e+01>\n-; AUTO_VEC-NEXT:    [[STEP_ADD3_2:%.*]] = fadd fast <8 x float> [[VEC_IND]], <float 4.400000e+01, float 4.400000e+01, float 4.400000e+01, float 4.400000e+01, float 4.400000e+01, float 4.400000e+01, float 4.400000e+01, float 4.400000e+01>\n-; AUTO_VEC-NEXT:    [[TMP21:%.*]] = getelementptr inbounds float, ptr [[A]], i64 [[INDEX_NEXT_1]]\n-; AUTO_VEC-NEXT:    store <8 x float> [[VEC_IND_NEXT_1]], ptr [[TMP21]], align 4\n-; AUTO_VEC-NEXT:    [[TMP23:%.*]] = getelementptr inbounds float, ptr [[TMP21]], i64 8\n-; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD_2]], ptr [[TMP23]], align 4\n-; AUTO_VEC-NEXT:    [[TMP25:%.*]] = getelementptr inbounds float, ptr [[TMP21]], i64 16\n-; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD2_2]], ptr [[TMP25]], align 4\n-; AUTO_VEC-NEXT:    [[TMP27:%.*]] = getelementptr inbounds float, ptr [[TMP21]], i64 24\n-; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD3_2]], ptr [[TMP27]], align 4\n-; AUTO_VEC-NEXT:    [[INDEX_NEXT_2:%.*]] = or i64 [[INDEX]], 96\n-; AUTO_VEC-NEXT:    [[VEC_IND_NEXT_2:%.*]] = fadd fast <8 x float> [[VEC_IND]], <float 4.800000e+01, float 4.800000e+01, float 4.800000e+01, float 4.800000e+01, float 4.800000e+01, float 4.800000e+01, float 4.800000e+01, float 4.800000e+01>\n-; AUTO_VEC-NEXT:    [[STEP_ADD_3:%.*]] = fadd fast <8 x float> [[VEC_IND]], <float 5.200000e+01, float 5.200000e+01, float 5.200000e+01, float 5.200000e+01, float 5.200000e+01, float 5.200000e+01, float 5.200000e+01, float 5.200000e+01>\n-; AUTO_VEC-NEXT:    [[STEP_ADD2_3:%.*]] = fadd fast <8 x float> [[VEC_IND]], <float 5.600000e+01, float 5.600000e+01, float 5.600000e+01, float 5.600000e+01, float 5.600000e+01, float 5.600000e+01, float 5.600000e+01, float 5.600000e+01>\n-; AUTO_VEC-NEXT:    [[STEP_ADD3_3:%.*]] = fadd fast <8 x float> [[VEC_IND]], <float 6.000000e+01, float 6.000000e+01, float 6.000000e+01, float 6.000000e+01, float 6.000000e+01, float 6.000000e+01, float 6.000000e+01, float 6.000000e+01>\n-; AUTO_VEC-NEXT:    [[TMP29:%.*]] = getelementptr inbounds float, ptr [[A]], i64 [[INDEX_NEXT_2]]\n-; AUTO_VEC-NEXT:    store <8 x float> [[VEC_IND_NEXT_2]], ptr [[TMP29]], align 4\n-; AUTO_VEC-NEXT:    [[TMP31:%.*]] = getelementptr inbounds float, ptr [[TMP29]], i64 8\n-; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD_3]], ptr [[TMP31]], align 4\n-; AUTO_VEC-NEXT:    [[TMP33:%.*]] = getelementptr inbounds float, ptr [[TMP29]], i64 16\n-; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD2_3]], ptr [[TMP33]], align 4\n-; AUTO_VEC-NEXT:    [[TMP35:%.*]] = getelementptr inbounds float, ptr [[TMP29]], i64 24\n-; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD3_3]], ptr [[TMP35]], align 4\n-; AUTO_VEC-NEXT:    [[INDEX_NEXT_3]] = add nuw i64 [[INDEX]], 128\n-; AUTO_VEC-NEXT:    [[VEC_IND_NEXT_3]] = fadd fast <8 x float> [[VEC_IND]], <float 6.400000e+01, float 6.400000e+01, float 6.400000e+01, float 6.400000e+01, float 6.400000e+01, float 6.400000e+01, float 6.400000e+01, float 6.400000e+01>\n-; AUTO_VEC-NEXT:    [[NITER_NEXT_3]] = add i64 [[NITER]], 4\n-; AUTO_VEC-NEXT:    [[NITER_NCMP_3:%.*]] = icmp eq i64 [[NITER_NEXT_3]], [[UNROLL_ITER]]\n-; AUTO_VEC-NEXT:    br i1 [[NITER_NCMP_3]], label [[MIDDLE_BLOCK_UNR_LCSSA]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]\n-; AUTO_VEC:       middle.block.unr-lcssa:\n-; AUTO_VEC-NEXT:    [[INDEX_UNR:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT_3]], [[VECTOR_BODY]] ]\n-; AUTO_VEC-NEXT:    [[VEC_IND_UNR:%.*]] = phi <8 x float> [ <float 1.000000e+00, float 1.500000e+00, float 2.000000e+00, float 2.500000e+00, float 3.000000e+00, float 3.500000e+00, float 4.000000e+00, float 4.500000e+00>, [[VECTOR_PH]] ], [ [[VEC_IND_NEXT_3]], [[VECTOR_BODY]] ]\n-; AUTO_VEC-NEXT:    [[LCMP_MOD_NOT:%.*]] = icmp eq i64 [[XTRAITER]], 0\n-; AUTO_VEC-NEXT:    br i1 [[LCMP_MOD_NOT]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY_EPIL:%.*]]\n-; AUTO_VEC:       vector.body.epil:\n-; AUTO_VEC-NEXT:    [[INDEX_EPIL:%.*]] = phi i64 [ [[INDEX_NEXT_EPIL:%.*]], [[VECTOR_BODY_EPIL]] ], [ [[INDEX_UNR]], [[MIDDLE_BLOCK_UNR_LCSSA]] ]\n-; AUTO_VEC-NEXT:    [[VEC_IND_EPIL:%.*]] = phi <8 x float> [ [[VEC_IND_NEXT_EPIL:%.*]], [[VECTOR_BODY_EPIL]] ], [ [[VEC_IND_UNR]], [[MIDDLE_BLOCK_UNR_LCSSA]] ]\n-; AUTO_VEC-NEXT:    [[EPIL_ITER:%.*]] = phi i64 [ [[EPIL_ITER_NEXT:%.*]], [[VECTOR_BODY_EPIL]] ], [ 0, [[MIDDLE_BLOCK_UNR_LCSSA]] ]\n-; AUTO_VEC-NEXT:    [[STEP_ADD_EPIL:%.*]] = fadd fast <8 x float> [[VEC_IND_EPIL]], <float 4.000000e+00, float 4.000000e+00, float 4.000000e+00, float 4.000000e+00, float 4.000000e+00, float 4.000000e+00, float 4.000000e+00, float 4.000000e+00>\n-; AUTO_VEC-NEXT:    [[STEP_ADD2_EPIL:%.*]] = fadd fast <8 x float> [[VEC_IND_EPIL]], <float 8.000000e+00, float 8.000000e+00, float 8.000000e+00, float 8.000000e+00, float 8.000000e+00, float 8.000000e+00, float 8.000000e+00, float 8.000000e+00>\n-; AUTO_VEC-NEXT:    [[STEP_ADD3_EPIL:%.*]] = fadd fast <8 x float> [[VEC_IND_EPIL]], <float 1.200000e+01, float 1.200000e+01, float 1.200000e+01, float 1.200000e+01, float 1.200000e+01, float 1.200000e+01, float 1.200000e+01, float 1.200000e+01>\n-; AUTO_VEC-NEXT:    [[TMP37:%.*]] = getelementptr inbounds float, ptr [[A]], i64 [[INDEX_EPIL]]\n-; AUTO_VEC-NEXT:    store <8 x float> [[VEC_IND_EPIL]], ptr [[TMP37]], align 4\n-; AUTO_VEC-NEXT:    [[TMP39:%.*]] = getelementptr inbounds float, ptr [[TMP37]], i64 8\n-; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD_EPIL]], ptr [[TMP39]], align 4\n-; AUTO_VEC-NEXT:    [[TMP41:%.*]] = getelementptr inbounds float, ptr [[TMP37]], i64 16\n-; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD2_EPIL]], ptr [[TMP41]], align 4\n-; AUTO_VEC-NEXT:    [[TMP43:%.*]] = getelementptr inbounds float, ptr [[TMP37]], i64 24\n-; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD3_EPIL]], ptr [[TMP43]], align 4\n-; AUTO_VEC-NEXT:    [[INDEX_NEXT_EPIL]] = add nuw i64 [[INDEX_EPIL]], 32\n-; AUTO_VEC-NEXT:    [[VEC_IND_NEXT_EPIL]] = fadd fast <8 x float> [[VEC_IND_EPIL]], <float 1.600000e+01, float 1.600000e+01, float 1.600000e+01, float 1.600000e+01, float 1.600000e+01, float 1.600000e+01, float 1.600000e+01, float 1.600000e+01>\n-; AUTO_VEC-NEXT:    [[EPIL_ITER_NEXT]] = add i64 [[EPIL_ITER]], 1\n-; AUTO_VEC-NEXT:    [[EPIL_ITER_CMP_NOT:%.*]] = icmp eq i64 [[EPIL_ITER_NEXT]], [[XTRAITER]]\n-; AUTO_VEC-NEXT:    br i1 [[EPIL_ITER_CMP_NOT]], label [[MIDDLE_BLOCK]], label [[VECTOR_BODY_EPIL]], !llvm.loop [[LOOP2:![0-9]+]]\n+; AUTO_VEC-NEXT:    [[TMP1:%.*]] = getelementptr inbounds float, ptr [[A:%.*]], i64 [[INDEX]]\n+; AUTO_VEC-NEXT:    store <8 x float> [[VEC_IND]], ptr [[TMP1]], align 4\n+; AUTO_VEC-NEXT:    [[TMP2:%.*]] = getelementptr inbounds float, ptr [[TMP1]], i64 8\n+; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD]], ptr [[TMP2]], align 4\n+; AUTO_VEC-NEXT:    [[TMP3:%.*]] = getelementptr inbounds float, ptr [[TMP1]], i64 16\n+; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD2]], ptr [[TMP3]], align 4\n+; AUTO_VEC-NEXT:    [[TMP4:%.*]] = getelementptr inbounds float, ptr [[TMP1]], i64 24\n+; AUTO_VEC-NEXT:    store <8 x float> [[STEP_ADD3]], ptr [[TMP4]], align 4\n+; AUTO_VEC-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 32\n+; AUTO_VEC-NEXT:    [[VEC_IND_NEXT]] = fadd fast <8 x float> [[VEC_IND]], <float 1.600000e+01, float 1.600000e+01, float 1.600000e+01, float 1.600000e+01, float 1.600000e+01, float 1.600000e+01, float 1.600000e+01, float 1.600000e+01>\n+; AUTO_VEC-NEXT:    [[TMP5:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n+; AUTO_VEC-NEXT:    br i1 [[TMP5]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]\n ; AUTO_VEC:       middle.block:\n ; AUTO_VEC-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N_VEC]], [[ZEXT]]\n ; AUTO_VEC-NEXT:    br i1 [[CMP_N]], label [[FOR_END]], label [[FOR_BODY]]\n@@ -131,8 +57,8 @@ define void @fp_iv_loop1(ptr noalias nocapture %A, i32 %N) #0 {\n ; AUTO_VEC-NEXT:    store float [[X_06]], ptr [[ARRAYIDX]], align 4\n ; AUTO_VEC-NEXT:    [[CONV1]] = fadd fast float [[X_06]], 5.000000e-01\n ; AUTO_VEC-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n-; AUTO_VEC-NEXT:    [[TMP45:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[ZEXT]]\n-; AUTO_VEC-NEXT:    br i1 [[TMP45]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]\n+; AUTO_VEC-NEXT:    [[TMP6:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[ZEXT]]\n+; AUTO_VEC-NEXT:    br i1 [[TMP6]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ; AUTO_VEC:       for.end:\n ; AUTO_VEC-NEXT:    ret void\n ;\n@@ -238,7 +164,7 @@ define void @fp_iv_loop2(ptr noalias nocapture %A, i32 %N) {\n ; AUTO_VEC-NEXT:    [[INDVARS_IV_NEXT_EPIL]] = add nuw nsw i64 [[INDVARS_IV_EPIL]], 1\n ; AUTO_VEC-NEXT:    [[EPIL_ITER_NEXT]] = add i64 [[EPIL_ITER]], 1\n ; AUTO_VEC-NEXT:    [[EPIL_ITER_CMP_NOT:%.*]] = icmp eq i64 [[EPIL_ITER_NEXT]], [[XTRAITER]]\n-; AUTO_VEC-NEXT:    br i1 [[EPIL_ITER_CMP_NOT]], label [[FOR_END]], label [[FOR_BODY_EPIL]], !llvm.loop [[LOOP6:![0-9]+]]\n+; AUTO_VEC-NEXT:    br i1 [[EPIL_ITER_CMP_NOT]], label [[FOR_END]], label [[FOR_BODY_EPIL]], !llvm.loop [[LOOP4:![0-9]+]]\n ; AUTO_VEC:       for.end:\n ; AUTO_VEC-NEXT:    ret void\n ;\n@@ -275,106 +201,32 @@ define double @external_use_with_fast_math(ptr %a, i64 %n) {\n ; AUTO_VEC-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[FOR_BODY:%.*]], label [[VECTOR_PH:%.*]]\n ; AUTO_VEC:       vector.ph:\n ; AUTO_VEC-NEXT:    [[N_VEC:%.*]] = and i64 [[SMAX]], 9223372036854775792\n-; AUTO_VEC-NEXT:    [[CAST_VTC:%.*]] = sitofp i64 [[N_VEC]] to double\n-; AUTO_VEC-NEXT:    [[TMP0:%.*]] = fmul fast double [[CAST_VTC]], 3.000000e+00\n-; AUTO_VEC-NEXT:    [[TMP1:%.*]] = add nsw i64 [[SMAX]], -16\n-; AUTO_VEC-NEXT:    [[TMP2:%.*]] = lshr i64 [[TMP1]], 4\n-; AUTO_VEC-NEXT:    [[TMP3:%.*]] = add nuw nsw i64 [[TMP2]], 1\n-; AUTO_VEC-NEXT:    [[XTRAITER:%.*]] = and i64 [[TMP3]], 3\n-; AUTO_VEC-NEXT:    [[TMP4:%.*]] = icmp ult i64 [[TMP1]], 48\n-; AUTO_VEC-NEXT:    br i1 [[TMP4]], label [[MIDDLE_BLOCK_UNR_LCSSA:%.*]], label [[VECTOR_PH_NEW:%.*]]\n-; AUTO_VEC:       vector.ph.new:\n-; AUTO_VEC-NEXT:    [[UNROLL_ITER:%.*]] = and i64 [[TMP3]], -4\n+; AUTO_VEC-NEXT:    [[DOTCAST:%.*]] = sitofp i64 [[N_VEC]] to double\n+; AUTO_VEC-NEXT:    [[TMP0:%.*]] = fmul fast double [[DOTCAST]], 3.000000e+00\n ; AUTO_VEC-NEXT:    br label [[VECTOR_BODY:%.*]]\n ; AUTO_VEC:       vector.body:\n-; AUTO_VEC-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH_NEW]] ], [ [[INDEX_NEXT_3:%.*]], [[VECTOR_BODY]] ]\n-; AUTO_VEC-NEXT:    [[VEC_IND:%.*]] = phi <4 x double> [ <double 0.000000e+00, double 3.000000e+00, double 6.000000e+00, double 9.000000e+00>, [[VECTOR_PH_NEW]] ], [ [[VEC_IND_NEXT_3:%.*]], [[VECTOR_BODY]] ]\n-; AUTO_VEC-NEXT:    [[NITER:%.*]] = phi i64 [ 0, [[VECTOR_PH_NEW]] ], [ [[NITER_NEXT_3:%.*]], [[VECTOR_BODY]] ]\n+; AUTO_VEC-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]\n+; AUTO_VEC-NEXT:    [[VEC_IND:%.*]] = phi <4 x double> [ <double 0.000000e+00, double 3.000000e+00, double 6.000000e+00, double 9.000000e+00>, [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]\n ; AUTO_VEC-NEXT:    [[STEP_ADD:%.*]] = fadd fast <4 x double> [[VEC_IND]], <double 1.200000e+01, double 1.200000e+01, double 1.200000e+01, double 1.200000e+01>\n ; AUTO_VEC-NEXT:    [[STEP_ADD2:%.*]] = fadd fast <4 x double> [[VEC_IND]], <double 2.400000e+01, double 2.400000e+01, double 2.400000e+01, double 2.400000e+01>\n ; AUTO_VEC-NEXT:    [[STEP_ADD3:%.*]] = fadd fast <4 x double> [[VEC_IND]], <double 3.600000e+01, double 3.600000e+01, double 3.600000e+01, double 3.600000e+01>\n-; AUTO_VEC-NEXT:    [[TMP5:%.*]] = getelementptr double, ptr [[A:%.*]], i64 [[INDEX]]\n-; AUTO_VEC-NEXT:    store <4 x double> [[VEC_IND]], ptr [[TMP5]], align 8\n-; AUTO_VEC-NEXT:    [[TMP7:%.*]] = getelementptr double, ptr [[TMP5]], i64 4\n-; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD]], ptr [[TMP7]], align 8\n-; AUTO_VEC-NEXT:    [[TMP9:%.*]] = getelementptr double, ptr [[TMP5]], i64 8\n-; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD2]], ptr [[TMP9]], align 8\n-; AUTO_VEC-NEXT:    [[TMP11:%.*]] = getelementptr double, ptr [[TMP5]], i64 12\n-; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD3]], ptr [[TMP11]], align 8\n-; AUTO_VEC-NEXT:    [[INDEX_NEXT:%.*]] = or i64 [[INDEX]], 16\n-; AUTO_VEC-NEXT:    [[VEC_IND_NEXT:%.*]] = fadd fast <4 x double> [[VEC_IND]], <double 4.800000e+01, double 4.800000e+01, double 4.800000e+01, double 4.800000e+01>\n-; AUTO_VEC-NEXT:    [[STEP_ADD_1:%.*]] = fadd fast <4 x double> [[VEC_IND]], <double 6.000000e+01, double 6.000000e+01, double 6.000000e+01, double 6.000000e+01>\n-; AUTO_VEC-NEXT:    [[STEP_ADD2_1:%.*]] = fadd fast <4 x double> [[VEC_IND]], <double 7.200000e+01, double 7.200000e+01, double 7.200000e+01, double 7.200000e+01>\n-; AUTO_VEC-NEXT:    [[STEP_ADD3_1:%.*]] = fadd fast <4 x double> [[VEC_IND]], <double 8.400000e+01, double 8.400000e+01, double 8.400000e+01, double 8.400000e+01>\n-; AUTO_VEC-NEXT:    [[TMP13:%.*]] = getelementptr double, ptr [[A]], i64 [[INDEX_NEXT]]\n-; AUTO_VEC-NEXT:    store <4 x double> [[VEC_IND_NEXT]], ptr [[TMP13]], align 8\n-; AUTO_VEC-NEXT:    [[TMP15:%.*]] = getelementptr double, ptr [[TMP13]], i64 4\n-; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD_1]], ptr [[TMP15]], align 8\n-; AUTO_VEC-NEXT:    [[TMP17:%.*]] = getelementptr double, ptr [[TMP13]], i64 8\n-; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD2_1]], ptr [[TMP17]], align 8\n-; AUTO_VEC-NEXT:    [[TMP19:%.*]] = getelementptr double, ptr [[TMP13]], i64 12\n-; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD3_1]], ptr [[TMP19]], align 8\n-; AUTO_VEC-NEXT:    [[INDEX_NEXT_1:%.*]] = or i64 [[INDEX]], 32\n-; AUTO_VEC-NEXT:    [[VEC_IND_NEXT_1:%.*]] = fadd fast <4 x double> [[VEC_IND]], <double 9.600000e+01, double 9.600000e+01, double 9.600000e+01, double 9.600000e+01>\n-; AUTO_VEC-NEXT:    [[STEP_ADD_2:%.*]] = fadd fast <4 x double> [[VEC_IND]], <double 1.080000e+02, double 1.080000e+02, double 1.080000e+02, double 1.080000e+02>\n-; AUTO_VEC-NEXT:    [[STEP_ADD2_2:%.*]] = fadd fast <4 x double> [[VEC_IND]], <double 1.200000e+02, double 1.200000e+02, double 1.200000e+02, double 1.200000e+02>\n-; AUTO_VEC-NEXT:    [[STEP_ADD3_2:%.*]] = fadd fast <4 x double> [[VEC_IND]], <double 1.320000e+02, double 1.320000e+02, double 1.320000e+02, double 1.320000e+02>\n-; AUTO_VEC-NEXT:    [[TMP21:%.*]] = getelementptr double, ptr [[A]], i64 [[INDEX_NEXT_1]]\n-; AUTO_VEC-NEXT:    store <4 x double> [[VEC_IND_NEXT_1]], ptr [[TMP21]], align 8\n-; AUTO_VEC-NEXT:    [[TMP23:%.*]] = getelementptr double, ptr [[TMP21]], i64 4\n-; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD_2]], ptr [[TMP23]], align 8\n-; AUTO_VEC-NEXT:    [[TMP25:%.*]] = getelementptr double, ptr [[TMP21]], i64 8\n-; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD2_2]], ptr [[TMP25]], align 8\n-; AUTO_VEC-NEXT:    [[TMP27:%.*]] = getelementptr double, ptr [[TMP21]], i64 12\n-; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD3_2]], ptr [[TMP27]], align 8\n-; AUTO_VEC-NEXT:    [[INDEX_NEXT_2:%.*]] = or i64 [[INDEX]], 48\n-; AUTO_VEC-NEXT:    [[VEC_IND_NEXT_2:%.*]] = fadd fast <4 x double> [[VEC_IND]], <double 1.440000e+02, double 1.440000e+02, double 1.440000e+02, double 1.440000e+02>\n-; AUTO_VEC-NEXT:    [[STEP_ADD_3:%.*]] = fadd fast <4 x double> [[VEC_IND]], <double 1.560000e+02, double 1.560000e+02, double 1.560000e+02, double 1.560000e+02>\n-; AUTO_VEC-NEXT:    [[STEP_ADD2_3:%.*]] = fadd fast <4 x double> [[VEC_IND]], <double 1.680000e+02, double 1.680000e+02, double 1.680000e+02, double 1.680000e+02>\n-; AUTO_VEC-NEXT:    [[STEP_ADD3_3:%.*]] = fadd fast <4 x double> [[VEC_IND]], <double 1.800000e+02, double 1.800000e+02, double 1.800000e+02, double 1.800000e+02>\n-; AUTO_VEC-NEXT:    [[TMP29:%.*]] = getelementptr double, ptr [[A]], i64 [[INDEX_NEXT_2]]\n-; AUTO_VEC-NEXT:    store <4 x double> [[VEC_IND_NEXT_2]], ptr [[TMP29]], align 8\n-; AUTO_VEC-NEXT:    [[TMP31:%.*]] = getelementptr double, ptr [[TMP29]], i64 4\n-; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD_3]], ptr [[TMP31]], align 8\n-; AUTO_VEC-NEXT:    [[TMP33:%.*]] = getelementptr double, ptr [[TMP29]], i64 8\n-; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD2_3]], ptr [[TMP33]], align 8\n-; AUTO_VEC-NEXT:    [[TMP35:%.*]] = getelementptr double, ptr [[TMP29]], i64 12\n-; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD3_3]], ptr [[TMP35]], align 8\n-; AUTO_VEC-NEXT:    [[INDEX_NEXT_3]] = add nuw i64 [[INDEX]], 64\n-; AUTO_VEC-NEXT:    [[VEC_IND_NEXT_3]] = fadd fast <4 x double> [[VEC_IND]], <double 1.920000e+02, double 1.920000e+02, double 1.920000e+02, double 1.920000e+02>\n-; AUTO_VEC-NEXT:    [[NITER_NEXT_3]] = add i64 [[NITER]], 4\n-; AUTO_VEC-NEXT:    [[NITER_NCMP_3:%.*]] = icmp eq i64 [[NITER_NEXT_3]], [[UNROLL_ITER]]\n-; AUTO_VEC-NEXT:    br i1 [[NITER_NCMP_3]], label [[MIDDLE_BLOCK_UNR_LCSSA]], label [[VECTOR_BODY]], !llvm.loop [[LOOP7:![0-9]+]]\n-; AUTO_VEC:       middle.block.unr-lcssa:\n-; AUTO_VEC-NEXT:    [[INDEX_UNR:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT_3]], [[VECTOR_BODY]] ]\n-; AUTO_VEC-NEXT:    [[VEC_IND_UNR:%.*]] = phi <4 x double> [ <double 0.000000e+00, double 3.000000e+00, double 6.000000e+00, double 9.000000e+00>, [[VECTOR_PH]] ], [ [[VEC_IND_NEXT_3]], [[VECTOR_BODY]] ]\n-; AUTO_VEC-NEXT:    [[LCMP_MOD_NOT:%.*]] = icmp eq i64 [[XTRAITER]], 0\n-; AUTO_VEC-NEXT:    br i1 [[LCMP_MOD_NOT]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY_EPIL:%.*]]\n-; AUTO_VEC:       vector.body.epil:\n-; AUTO_VEC-NEXT:    [[INDEX_EPIL:%.*]] = phi i64 [ [[INDEX_NEXT_EPIL:%.*]], [[VECTOR_BODY_EPIL]] ], [ [[INDEX_UNR]], [[MIDDLE_BLOCK_UNR_LCSSA]] ]\n-; AUTO_VEC-NEXT:    [[VEC_IND_EPIL:%.*]] = phi <4 x double> [ [[VEC_IND_NEXT_EPIL:%.*]], [[VECTOR_BODY_EPIL]] ], [ [[VEC_IND_UNR]], [[MIDDLE_BLOCK_UNR_LCSSA]] ]\n-; AUTO_VEC-NEXT:    [[EPIL_ITER:%.*]] = phi i64 [ [[EPIL_ITER_NEXT:%.*]], [[VECTOR_BODY_EPIL]] ], [ 0, [[MIDDLE_BLOCK_UNR_LCSSA]] ]\n-; AUTO_VEC-NEXT:    [[STEP_ADD_EPIL:%.*]] = fadd fast <4 x double> [[VEC_IND_EPIL]], <double 1.200000e+01, double 1.200000e+01, double 1.200000e+01, double 1.200000e+01>\n-; AUTO_VEC-NEXT:    [[STEP_ADD2_EPIL:%.*]] = fadd fast <4 x double> [[VEC_IND_EPIL]], <double 2.400000e+01, double 2.400000e+01, double 2.400000e+01, double 2.400000e+01>\n-; AUTO_VEC-NEXT:    [[STEP_ADD3_EPIL:%.*]] = fadd fast <4 x double> [[VEC_IND_EPIL]], <double 3.600000e+01, double 3.600000e+01, double 3.600000e+01, double 3.600000e+01>\n-; AUTO_VEC-NEXT:    [[TMP37:%.*]] = getelementptr double, ptr [[A]], i64 [[INDEX_EPIL]]\n-; AUTO_VEC-NEXT:    store <4 x double> [[VEC_IND_EPIL]], ptr [[TMP37]], align 8\n-; AUTO_VEC-NEXT:    [[TMP39:%.*]] = getelementptr double, ptr [[TMP37]], i64 4\n-; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD_EPIL]], ptr [[TMP39]], align 8\n-; AUTO_VEC-NEXT:    [[TMP41:%.*]] = getelementptr double, ptr [[TMP37]], i64 8\n-; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD2_EPIL]], ptr [[TMP41]], align 8\n-; AUTO_VEC-NEXT:    [[TMP43:%.*]] = getelementptr double, ptr [[TMP37]], i64 12\n-; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD3_EPIL]], ptr [[TMP43]], align 8\n-; AUTO_VEC-NEXT:    [[INDEX_NEXT_EPIL]] = add nuw i64 [[INDEX_EPIL]], 16\n-; AUTO_VEC-NEXT:    [[VEC_IND_NEXT_EPIL]] = fadd fast <4 x double> [[VEC_IND_EPIL]], <double 4.800000e+01, double 4.800000e+01, double 4.800000e+01, double 4.800000e+01>\n-; AUTO_VEC-NEXT:    [[EPIL_ITER_NEXT]] = add i64 [[EPIL_ITER]], 1\n-; AUTO_VEC-NEXT:    [[EPIL_ITER_CMP_NOT:%.*]] = icmp eq i64 [[EPIL_ITER_NEXT]], [[XTRAITER]]\n-; AUTO_VEC-NEXT:    br i1 [[EPIL_ITER_CMP_NOT]], label [[MIDDLE_BLOCK]], label [[VECTOR_BODY_EPIL]], !llvm.loop [[LOOP8:![0-9]+]]\n+; AUTO_VEC-NEXT:    [[TMP1:%.*]] = getelementptr double, ptr [[A:%.*]], i64 [[INDEX]]\n+; AUTO_VEC-NEXT:    store <4 x double> [[VEC_IND]], ptr [[TMP1]], align 8\n+; AUTO_VEC-NEXT:    [[TMP2:%.*]] = getelementptr double, ptr [[TMP1]], i64 4\n+; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD]], ptr [[TMP2]], align 8\n+; AUTO_VEC-NEXT:    [[TMP3:%.*]] = getelementptr double, ptr [[TMP1]], i64 8\n+; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD2]], ptr [[TMP3]], align 8\n+; AUTO_VEC-NEXT:    [[TMP4:%.*]] = getelementptr double, ptr [[TMP1]], i64 12\n+; AUTO_VEC-NEXT:    store <4 x double> [[STEP_ADD3]], ptr [[TMP4]], align 8\n+; AUTO_VEC-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 16\n+; AUTO_VEC-NEXT:    [[VEC_IND_NEXT]] = fadd fast <4 x double> [[VEC_IND]], <double 4.800000e+01, double 4.800000e+01, double 4.800000e+01, double 4.800000e+01>\n+; AUTO_VEC-NEXT:    [[TMP5:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n+; AUTO_VEC-NEXT:    br i1 [[TMP5]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP6:![0-9]+]]\n ; AUTO_VEC:       middle.block:\n ; AUTO_VEC-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[SMAX]], [[N_VEC]]\n-; AUTO_VEC-NEXT:    [[TMP45:%.*]] = add nsw i64 [[N_VEC]], -1\n-; AUTO_VEC-NEXT:    [[CAST_CMO:%.*]] = sitofp i64 [[TMP45]] to double\n-; AUTO_VEC-NEXT:    [[TMP46:%.*]] = fmul fast double [[CAST_CMO]], 3.000000e+00\n+; AUTO_VEC-NEXT:    [[CMO:%.*]] = add nsw i64 [[N_VEC]], -1\n+; AUTO_VEC-NEXT:    [[DOTCAST6:%.*]] = sitofp i64 [[CMO]] to double\n+; AUTO_VEC-NEXT:    [[TMP6:%.*]] = fmul fast double [[DOTCAST6]], 3.000000e+00\n ; AUTO_VEC-NEXT:    br i1 [[CMP_N]], label [[FOR_END:%.*]], label [[FOR_BODY]]\n ; AUTO_VEC:       for.body:\n ; AUTO_VEC-NEXT:    [[I:%.*]] = phi i64 [ [[I_NEXT:%.*]], [[FOR_BODY]] ], [ 0, [[ENTRY:%.*]] ], [ [[N_VEC]], [[MIDDLE_BLOCK]] ]\n@@ -384,9 +236,9 @@ define double @external_use_with_fast_math(ptr %a, i64 %n) {\n ; AUTO_VEC-NEXT:    [[I_NEXT]] = add nuw nsw i64 [[I]], 1\n ; AUTO_VEC-NEXT:    [[J_NEXT]] = fadd fast double [[J]], 3.000000e+00\n ; AUTO_VEC-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[I_NEXT]], [[SMAX]]\n-; AUTO_VEC-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP9:![0-9]+]]\n+; AUTO_VEC-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP7:![0-9]+]]\n ; AUTO_VEC:       for.end:\n-; AUTO_VEC-NEXT:    [[J_LCSSA:%.*]] = phi double [ [[TMP46]], [[MIDDLE_BLOCK]] ], [ [[J]], [[FOR_BODY]] ]\n+; AUTO_VEC-NEXT:    [[J_LCSSA:%.*]] = phi double [ [[TMP6]], [[MIDDLE_BLOCK]] ], [ [[J]], [[FOR_BODY]] ]\n ; AUTO_VEC-NEXT:    ret double [[J_LCSSA]]\n ;\n entry:\n@@ -473,7 +325,7 @@ define double @external_use_without_fast_math(ptr %a, i64 %n) {\n ; AUTO_VEC-NEXT:    [[J_NEXT_EPIL]] = fadd double [[J_EPIL]], 3.000000e+00\n ; AUTO_VEC-NEXT:    [[EPIL_ITER_NEXT]] = add i64 [[EPIL_ITER]], 1\n ; AUTO_VEC-NEXT:    [[EPIL_ITER_CMP_NOT:%.*]] = icmp eq i64 [[EPIL_ITER_NEXT]], [[XTRAITER]]\n-; AUTO_VEC-NEXT:    br i1 [[EPIL_ITER_CMP_NOT]], label [[FOR_END]], label [[FOR_BODY_EPIL]], !llvm.loop [[LOOP10:![0-9]+]]\n+; AUTO_VEC-NEXT:    br i1 [[EPIL_ITER_CMP_NOT]], label [[FOR_END]], label [[FOR_BODY_EPIL]], !llvm.loop [[LOOP8:![0-9]+]]\n ; AUTO_VEC:       for.end:\n ; AUTO_VEC-NEXT:    [[J_LCSSA:%.*]] = phi double [ [[J_LCSSA_PH]], [[FOR_END_UNR_LCSSA]] ], [ [[J_EPIL]], [[FOR_BODY_EPIL]] ]\n ; AUTO_VEC-NEXT:    ret double [[J_LCSSA]]\n@@ -515,93 +367,36 @@ define void @fadd_reassoc_FMF(ptr nocapture %p, i32 %N) {\n ; AUTO_VEC-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[FOR_BODY:%.*]], label [[VECTOR_PH:%.*]]\n ; AUTO_VEC:       vector.ph:\n ; AUTO_VEC-NEXT:    [[N_VEC:%.*]] = and i64 [[TMP0]], 4294967264\n-; AUTO_VEC-NEXT:    [[CAST_VTC:%.*]] = sitofp i64 [[N_VEC]] to float\n-; AUTO_VEC-NEXT:    [[TMP1:%.*]] = fmul reassoc float [[CAST_VTC]], 4.200000e+01\n+; AUTO_VEC-NEXT:    [[DOTCAST:%.*]] = sitofp i64 [[N_VEC]] to float\n+; AUTO_VEC-NEXT:    [[TMP1:%.*]] = fmul reassoc float [[DOTCAST]], 4.200000e+01\n ; AUTO_VEC-NEXT:    [[IND_END:%.*]] = fadd reassoc float [[TMP1]], 1.000000e+00\n-; AUTO_VEC-NEXT:    [[TMP2:%.*]] = add nsw i64 [[TMP0]], -32\n-; AUTO_VEC-NEXT:    [[TMP3:%.*]] = lshr i64 [[TMP2]], 5\n-; AUTO_VEC-NEXT:    [[TMP4:%.*]] = add nuw nsw i64 [[TMP3]], 1\n-; AUTO_VEC-NEXT:    [[XTRAITER:%.*]] = and i64 [[TMP4]], 1\n-; AUTO_VEC-NEXT:    [[TMP5:%.*]] = icmp ult i64 [[TMP2]], 32\n-; AUTO_VEC-NEXT:    br i1 [[TMP5]], label [[MIDDLE_BLOCK_UNR_LCSSA:%.*]], label [[VECTOR_PH_NEW:%.*]]\n-; AUTO_VEC:       vector.ph.new:\n-; AUTO_VEC-NEXT:    [[UNROLL_ITER:%.*]] = and i64 [[TMP4]], -2\n ; AUTO_VEC-NEXT:    br label [[VECTOR_BODY:%.*]]\n ; AUTO_VEC:       vector.body:\n-; AUTO_VEC-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH_NEW]] ], [ [[INDEX_NEXT_1:%.*]], [[VECTOR_BODY]] ]\n-; AUTO_VEC-NEXT:    [[VEC_IND:%.*]] = phi <8 x float> [ <float 1.000000e+00, float 4.300000e+01, float 8.500000e+01, float 1.270000e+02, float 1.690000e+02, float 2.110000e+02, float 2.530000e+02, float 2.950000e+02>, [[VECTOR_PH_NEW]] ], [ [[VEC_IND_NEXT_1:%.*]], [[VECTOR_BODY]] ]\n-; AUTO_VEC-NEXT:    [[NITER:%.*]] = phi i64 [ 0, [[VECTOR_PH_NEW]] ], [ [[NITER_NEXT_1:%.*]], [[VECTOR_BODY]] ]\n+; AUTO_VEC-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]\n+; AUTO_VEC-NEXT:    [[VEC_IND:%.*]] = phi <8 x float> [ <float 1.000000e+00, float 4.300000e+01, float 8.500000e+01, float 1.270000e+02, float 1.690000e+02, float 2.110000e+02, float 2.530000e+02, float 2.950000e+02>, [[VECTOR_PH]] ], [ [[VEC_IND_NEXT:%.*]], [[VECTOR_BODY]] ]\n ; AUTO_VEC-NEXT:    [[STEP_ADD:%.*]] = fadd reassoc <8 x float> [[VEC_IND]], <float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02>\n ; AUTO_VEC-NEXT:    [[STEP_ADD2:%.*]] = fadd reassoc <8 x float> [[STEP_ADD]], <float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02>\n ; AUTO_VEC-NEXT:    [[STEP_ADD3:%.*]] = fadd reassoc <8 x float> [[STEP_ADD2]], <float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02>\n-; AUTO_VEC-NEXT:    [[TMP6:%.*]] = getelementptr inbounds float, ptr [[P:%.*]], i64 [[INDEX]]\n-; AUTO_VEC-NEXT:    [[WIDE_LOAD:%.*]] = load <8 x float>, ptr [[TMP6]], align 4\n-; AUTO_VEC-NEXT:    [[TMP8:%.*]] = getelementptr inbounds float, ptr [[TMP6]], i64 8\n-; AUTO_VEC-NEXT:    [[WIDE_LOAD5:%.*]] = load <8 x float>, ptr [[TMP8]], align 4\n-; AUTO_VEC-NEXT:    [[TMP10:%.*]] = getelementptr inbounds float, ptr [[TMP6]], i64 16\n-; AUTO_VEC-NEXT:    [[WIDE_LOAD6:%.*]] = load <8 x float>, ptr [[TMP10]], align 4\n-; AUTO_VEC-NEXT:    [[TMP12:%.*]] = getelementptr inbounds float, ptr [[TMP6]], i64 24\n-; AUTO_VEC-NEXT:    [[WIDE_LOAD7:%.*]] = load <8 x float>, ptr [[TMP12]], align 4\n-; AUTO_VEC-NEXT:    [[TMP14:%.*]] = fadd reassoc <8 x float> [[VEC_IND]], [[WIDE_LOAD]]\n-; AUTO_VEC-NEXT:    [[TMP15:%.*]] = fadd reassoc <8 x float> [[STEP_ADD]], [[WIDE_LOAD5]]\n-; AUTO_VEC-NEXT:    [[TMP16:%.*]] = fadd reassoc <8 x float> [[STEP_ADD2]], [[WIDE_LOAD6]]\n-; AUTO_VEC-NEXT:    [[TMP17:%.*]] = fadd reassoc <8 x float> [[STEP_ADD3]], [[WIDE_LOAD7]]\n-; AUTO_VEC-NEXT:    store <8 x float> [[TMP14]], ptr [[TMP6]], align 4\n-; AUTO_VEC-NEXT:    store <8 x float> [[TMP15]], ptr [[TMP8]], align 4\n-; AUTO_VEC-NEXT:    store <8 x float> [[TMP16]], ptr [[TMP10]], align 4\n-; AUTO_VEC-NEXT:    store <8 x float> [[TMP17]], ptr [[TMP12]], align 4\n-; AUTO_VEC-NEXT:    [[INDEX_NEXT:%.*]] = or i64 [[INDEX]], 32\n-; AUTO_VEC-NEXT:    [[VEC_IND_NEXT:%.*]] = fadd reassoc <8 x float> [[STEP_ADD3]], <float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02>\n-; AUTO_VEC-NEXT:    [[STEP_ADD_1:%.*]] = fadd reassoc <8 x float> [[VEC_IND_NEXT]], <float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02>\n-; AUTO_VEC-NEXT:    [[STEP_ADD2_1:%.*]] = fadd reassoc <8 x float> [[STEP_ADD_1]], <float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02>\n-; AUTO_VEC-NEXT:    [[STEP_ADD3_1:%.*]] = fadd reassoc <8 x float> [[STEP_ADD2_1]], <float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02>\n-; AUTO_VEC-NEXT:    [[TMP22:%.*]] = getelementptr inbounds float, ptr [[P]], i64 [[INDEX_NEXT]]\n-; AUTO_VEC-NEXT:    [[WIDE_LOAD_1:%.*]] = load <8 x float>, ptr [[TMP22]], align 4\n-; AUTO_VEC-NEXT:    [[TMP24:%.*]] = getelementptr inbounds float, ptr [[TMP22]], i64 8\n-; AUTO_VEC-NEXT:    [[WIDE_LOAD5_1:%.*]] = load <8 x float>, ptr [[TMP24]], align 4\n-; AUTO_VEC-NEXT:    [[TMP26:%.*]] = getelementptr inbounds float, ptr [[TMP22]], i64 16\n-; AUTO_VEC-NEXT:    [[WIDE_LOAD6_1:%.*]] = load <8 x float>, ptr [[TMP26]], align 4\n-; AUTO_VEC-NEXT:    [[TMP28:%.*]] = getelementptr inbounds float, ptr [[TMP22]], i64 24\n-; AUTO_VEC-NEXT:    [[WIDE_LOAD7_1:%.*]] = load <8 x float>, ptr [[TMP28]], align 4\n-; AUTO_VEC-NEXT:    [[TMP30:%.*]] = fadd reassoc <8 x float> [[VEC_IND_NEXT]], [[WIDE_LOAD_1]]\n-; AUTO_VEC-NEXT:    [[TMP31:%.*]] = fadd reassoc <8 x float> [[STEP_ADD_1]], [[WIDE_LOAD5_1]]\n-; AUTO_VEC-NEXT:    [[TMP32:%.*]] = fadd reassoc <8 x float> [[STEP_ADD2_1]], [[WIDE_LOAD6_1]]\n-; AUTO_VEC-NEXT:    [[TMP33:%.*]] = fadd reassoc <8 x float> [[STEP_ADD3_1]], [[WIDE_LOAD7_1]]\n-; AUTO_VEC-NEXT:    store <8 x float> [[TMP30]], ptr [[TMP22]], align 4\n-; AUTO_VEC-NEXT:    store <8 x float> [[TMP31]], ptr [[TMP24]], align 4\n-; AUTO_VEC-NEXT:    store <8 x float> [[TMP32]], ptr [[TMP26]], align 4\n-; AUTO_VEC-NEXT:    store <8 x float> [[TMP33]], ptr [[TMP28]], align 4\n-; AUTO_VEC-NEXT:    [[INDEX_NEXT_1]] = add nuw i64 [[INDEX]], 64\n-; AUTO_VEC-NEXT:    [[VEC_IND_NEXT_1]] = fadd reassoc <8 x float> [[STEP_ADD3_1]], <float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02>\n-; AUTO_VEC-NEXT:    [[NITER_NEXT_1]] = add i64 [[NITER]], 2\n-; AUTO_VEC-NEXT:    [[NITER_NCMP_1:%.*]] = icmp eq i64 [[NITER_NEXT_1]], [[UNROLL_ITER]]\n-; AUTO_VEC-NEXT:    br i1 [[NITER_NCMP_1]], label [[MIDDLE_BLOCK_UNR_LCSSA]], label [[VECTOR_BODY]], !llvm.loop [[LOOP11:![0-9]+]]\n-; AUTO_VEC:       middle.block.unr-lcssa:\n-; AUTO_VEC-NEXT:    [[INDEX_UNR:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT_1]], [[VECTOR_BODY]] ]\n-; AUTO_VEC-NEXT:    [[VEC_IND_UNR:%.*]] = phi <8 x float> [ <float 1.000000e+00, float 4.300000e+01, float 8.500000e+01, float 1.270000e+02, float 1.690000e+02, float 2.110000e+02, float 2.530000e+02, float 2.950000e+02>, [[VECTOR_PH]] ], [ [[VEC_IND_NEXT_1]], [[VECTOR_BODY]] ]\n-; AUTO_VEC-NEXT:    [[LCMP_MOD_NOT:%.*]] = icmp eq i64 [[XTRAITER]], 0\n-; AUTO_VEC-NEXT:    br i1 [[LCMP_MOD_NOT]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY_EPIL:%.*]]\n-; AUTO_VEC:       vector.body.epil:\n-; AUTO_VEC-NEXT:    [[STEP_ADD_EPIL:%.*]] = fadd reassoc <8 x float> [[VEC_IND_UNR]], <float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02>\n-; AUTO_VEC-NEXT:    [[STEP_ADD2_EPIL:%.*]] = fadd reassoc <8 x float> [[STEP_ADD_EPIL]], <float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02>\n-; AUTO_VEC-NEXT:    [[STEP_ADD3_EPIL:%.*]] = fadd reassoc <8 x float> [[STEP_ADD2_EPIL]], <float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02>\n-; AUTO_VEC-NEXT:    [[TMP38:%.*]] = getelementptr inbounds float, ptr [[P]], i64 [[INDEX_UNR]]\n-; AUTO_VEC-NEXT:    [[WIDE_LOAD_EPIL:%.*]] = load <8 x float>, ptr [[TMP38]], align 4\n-; AUTO_VEC-NEXT:    [[TMP40:%.*]] = getelementptr inbounds float, ptr [[TMP38]], i64 8\n-; AUTO_VEC-NEXT:    [[WIDE_LOAD5_EPIL:%.*]] = load <8 x float>, ptr [[TMP40]], align 4\n-; AUTO_VEC-NEXT:    [[TMP42:%.*]] = getelementptr inbounds float, ptr [[TMP38]], i64 16\n-; AUTO_VEC-NEXT:    [[WIDE_LOAD6_EPIL:%.*]] = load <8 x float>, ptr [[TMP42]], align 4\n-; AUTO_VEC-NEXT:    [[TMP44:%.*]] = getelementptr inbounds float, ptr [[TMP38]], i64 24\n-; AUTO_VEC-NEXT:    [[WIDE_LOAD7_EPIL:%.*]] = load <8 x float>, ptr [[TMP44]], align 4\n-; AUTO_VEC-NEXT:    [[TMP46:%.*]] = fadd reassoc <8 x float> [[VEC_IND_UNR]], [[WIDE_LOAD_EPIL]]\n-; AUTO_VEC-NEXT:    [[TMP47:%.*]] = fadd reassoc <8 x float> [[STEP_ADD_EPIL]], [[WIDE_LOAD5_EPIL]]\n-; AUTO_VEC-NEXT:    [[TMP48:%.*]] = fadd reassoc <8 x float> [[STEP_ADD2_EPIL]], [[WIDE_LOAD6_EPIL]]\n-; AUTO_VEC-NEXT:    [[TMP49:%.*]] = fadd reassoc <8 x float> [[STEP_ADD3_EPIL]], [[WIDE_LOAD7_EPIL]]\n-; AUTO_VEC-NEXT:    store <8 x float> [[TMP46]], ptr [[TMP38]], align 4\n-; AUTO_VEC-NEXT:    store <8 x float> [[TMP47]], ptr [[TMP40]], align 4\n-; AUTO_VEC-NEXT:    store <8 x float> [[TMP48]], ptr [[TMP42]], align 4\n-; AUTO_VEC-NEXT:    store <8 x float> [[TMP49]], ptr [[TMP44]], align 4\n-; AUTO_VEC-NEXT:    br label [[MIDDLE_BLOCK]]\n+; AUTO_VEC-NEXT:    [[TMP2:%.*]] = getelementptr inbounds float, ptr [[P:%.*]], i64 [[INDEX]]\n+; AUTO_VEC-NEXT:    [[WIDE_LOAD:%.*]] = load <8 x float>, ptr [[TMP2]], align 4\n+; AUTO_VEC-NEXT:    [[TMP3:%.*]] = getelementptr inbounds float, ptr [[TMP2]], i64 8\n+; AUTO_VEC-NEXT:    [[WIDE_LOAD5:%.*]] = load <8 x float>, ptr [[TMP3]], align 4\n+; AUTO_VEC-NEXT:    [[TMP4:%.*]] = getelementptr inbounds float, ptr [[TMP2]], i64 16\n+; AUTO_VEC-NEXT:    [[WIDE_LOAD6:%.*]] = load <8 x float>, ptr [[TMP4]], align 4\n+; AUTO_VEC-NEXT:    [[TMP5:%.*]] = getelementptr inbounds float, ptr [[TMP2]], i64 24\n+; AUTO_VEC-NEXT:    [[WIDE_LOAD7:%.*]] = load <8 x float>, ptr [[TMP5]], align 4\n+; AUTO_VEC-NEXT:    [[TMP6:%.*]] = fadd reassoc <8 x float> [[VEC_IND]], [[WIDE_LOAD]]\n+; AUTO_VEC-NEXT:    [[TMP7:%.*]] = fadd reassoc <8 x float> [[STEP_ADD]], [[WIDE_LOAD5]]\n+; AUTO_VEC-NEXT:    [[TMP8:%.*]] = fadd reassoc <8 x float> [[STEP_ADD2]], [[WIDE_LOAD6]]\n+; AUTO_VEC-NEXT:    [[TMP9:%.*]] = fadd reassoc <8 x float> [[STEP_ADD3]], [[WIDE_LOAD7]]\n+; AUTO_VEC-NEXT:    store <8 x float> [[TMP6]], ptr [[TMP2]], align 4\n+; AUTO_VEC-NEXT:    store <8 x float> [[TMP7]], ptr [[TMP3]], align 4\n+; AUTO_VEC-NEXT:    store <8 x float> [[TMP8]], ptr [[TMP4]], align 4\n+; AUTO_VEC-NEXT:    store <8 x float> [[TMP9]], ptr [[TMP5]], align 4\n+; AUTO_VEC-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 32\n+; AUTO_VEC-NEXT:    [[VEC_IND_NEXT]] = fadd reassoc <8 x float> [[STEP_ADD3]], <float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02, float 3.360000e+02>\n+; AUTO_VEC-NEXT:    [[TMP10:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n+; AUTO_VEC-NEXT:    br i1 [[TMP10]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP9:![0-9]+]]\n ; AUTO_VEC:       middle.block:\n ; AUTO_VEC-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N_VEC]], [[TMP0]]\n ; AUTO_VEC-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]]\n@@ -611,13 +406,13 @@ define void @fadd_reassoc_FMF(ptr nocapture %p, i32 %N) {\n ; AUTO_VEC-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ], [ 0, [[FOR_BODY_PREHEADER]] ], [ [[N_VEC]], [[MIDDLE_BLOCK]] ]\n ; AUTO_VEC-NEXT:    [[X_012:%.*]] = phi float [ [[ADD3:%.*]], [[FOR_BODY]] ], [ 1.000000e+00, [[FOR_BODY_PREHEADER]] ], [ [[IND_END]], [[MIDDLE_BLOCK]] ]\n ; AUTO_VEC-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[P]], i64 [[INDVARS_IV]]\n-; AUTO_VEC-NEXT:    [[TMP54:%.*]] = load float, ptr [[ARRAYIDX]], align 4\n-; AUTO_VEC-NEXT:    [[ADD:%.*]] = fadd reassoc float [[X_012]], [[TMP54]]\n+; AUTO_VEC-NEXT:    [[TMP11:%.*]] = load float, ptr [[ARRAYIDX]], align 4\n+; AUTO_VEC-NEXT:    [[ADD:%.*]] = fadd reassoc float [[X_012]], [[TMP11]]\n ; AUTO_VEC-NEXT:    store float [[ADD]], ptr [[ARRAYIDX]], align 4\n ; AUTO_VEC-NEXT:    [[ADD3]] = fadd reassoc float [[X_012]], 4.200000e+01\n ; AUTO_VEC-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; AUTO_VEC-NEXT:    [[CMP_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[TMP0]]\n-; AUTO_VEC-NEXT:    br i1 [[CMP_NOT]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP12:![0-9]+]]\n+; AUTO_VEC-NEXT:    br i1 [[CMP_NOT]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP10:![0-9]+]]\n ;\n entry:\n   %cmp.not11 = icmp eq i32 %N, 0"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/X86/gather_scatter.ll",
                "patch": "@@ -67,7 +67,7 @@ define void @foo1(ptr noalias %in, ptr noalias %out, ptr noalias %trigger, ptr n\n ; AVX512:       for.inc:\n ; AVX512-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; AVX512-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 4096\n-; AVX512-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP2:![0-9]+]]\n+; AVX512-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ; AVX512:       for.end:\n ; AVX512-NEXT:    ret void\n ;\n@@ -116,7 +116,7 @@ define void @foo1(ptr noalias %in, ptr noalias %out, ptr noalias %trigger, ptr n\n ; FVW2:       for.inc:\n ; FVW2-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; FVW2-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 4096\n-; FVW2-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP2:![0-9]+]]\n+; FVW2-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ; FVW2:       for.end:\n ; FVW2-NEXT:    ret void\n ;"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/X86/invariant-load-gather.ll",
                "patch": "@@ -59,13 +59,13 @@ define i32 @inv_load_conditional(ptr %a, i64 %n, ptr %b, i32 %k) {\n ; CHECK:       vec.epilog.vector.body:\n ; CHECK-NEXT:    [[INDEX9:%.*]] = phi i64 [ [[VEC_EPILOG_RESUME_VAL]], [[VEC_EPILOG_PH]] ], [ [[INDEX_NEXT17:%.*]], [[VEC_EPILOG_VECTOR_BODY]] ]\n ; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i32, ptr [[B]], i64 [[INDEX9]]\n-; CHECK-NEXT:    store <8 x i32> [[BROADCAST_SPLAT14]], ptr [[TMP5]], align 4, !alias.scope !7, !noalias !10\n+; CHECK-NEXT:    store <8 x i32> [[BROADCAST_SPLAT14]], ptr [[TMP5]], align 4, !alias.scope !8, !noalias !11\n ; CHECK-NEXT:    [[INDEX_NEXT17]] = add nuw i64 [[INDEX9]], 8\n ; CHECK-NEXT:    [[TMP6:%.*]] = icmp eq i64 [[INDEX_NEXT17]], [[N_VEC7]]\n-; CHECK-NEXT:    br i1 [[TMP6]], label [[VEC_EPILOG_MIDDLE_BLOCK:%.*]], label [[VEC_EPILOG_VECTOR_BODY]], !llvm.loop [[LOOP12:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP6]], label [[VEC_EPILOG_MIDDLE_BLOCK:%.*]], label [[VEC_EPILOG_VECTOR_BODY]], !llvm.loop [[LOOP13:![0-9]+]]\n ; CHECK:       vec.epilog.middle.block:\n ; CHECK-NEXT:    [[TMP7:%.*]] = icmp ne <8 x ptr> [[BROADCAST_SPLAT12]], zeroinitializer\n-; CHECK-NEXT:    [[WIDE_MASKED_GATHER15:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0(<8 x ptr> [[BROADCAST_SPLAT12]], i32 4, <8 x i1> [[TMP7]], <8 x i32> poison), !alias.scope !10\n+; CHECK-NEXT:    [[WIDE_MASKED_GATHER15:%.*]] = call <8 x i32> @llvm.masked.gather.v8i32.v8p0(<8 x ptr> [[BROADCAST_SPLAT12]], i32 4, <8 x i1> [[TMP7]], <8 x i32> poison), !alias.scope !11\n ; CHECK-NEXT:    [[PREDPHI16:%.*]] = select <8 x i1> [[TMP7]], <8 x i32> [[WIDE_MASKED_GATHER15]], <8 x i32> <i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 poison, i32 1>\n ; CHECK-NEXT:    [[TMP8:%.*]] = extractelement <8 x i32> [[PREDPHI16]], i64 7\n ; CHECK-NEXT:    [[CMP_N8:%.*]] = icmp eq i64 [[SMAX2]], [[N_VEC7]]"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/X86/invariant-store-vectorization.ll",
                "patch": "@@ -72,12 +72,12 @@ define i32 @inv_val_store_to_inv_address_with_reduction(ptr %a, i64 %n, ptr %b)\n ; CHECK-NEXT:    [[INDEX15:%.*]] = phi i64 [ [[VEC_EPILOG_RESUME_VAL]], [[VEC_EPILOG_PH]] ], [ [[INDEX_NEXT18:%.*]], [[VEC_EPILOG_VECTOR_BODY]] ]\n ; CHECK-NEXT:    [[VEC_PHI16:%.*]] = phi <8 x i32> [ [[TMP11]], [[VEC_EPILOG_PH]] ], [ [[TMP13:%.*]], [[VEC_EPILOG_VECTOR_BODY]] ]\n ; CHECK-NEXT:    [[TMP12:%.*]] = getelementptr inbounds i32, ptr [[B]], i64 [[INDEX15]]\n-; CHECK-NEXT:    [[WIDE_LOAD17:%.*]] = load <8 x i32>, ptr [[TMP12]], align 8, !alias.scope !7\n+; CHECK-NEXT:    [[WIDE_LOAD17:%.*]] = load <8 x i32>, ptr [[TMP12]], align 8, !alias.scope !8\n ; CHECK-NEXT:    [[TMP13]] = add <8 x i32> [[VEC_PHI16]], [[WIDE_LOAD17]]\n-; CHECK-NEXT:    store i32 [[NTRUNC]], ptr [[A]], align 4, !alias.scope !10, !noalias !7\n+; CHECK-NEXT:    store i32 [[NTRUNC]], ptr [[A]], align 4, !alias.scope !11, !noalias !8\n ; CHECK-NEXT:    [[INDEX_NEXT18]] = add nuw i64 [[INDEX15]], 8\n ; CHECK-NEXT:    [[TMP14:%.*]] = icmp eq i64 [[INDEX_NEXT18]], [[N_VEC13]]\n-; CHECK-NEXT:    br i1 [[TMP14]], label [[VEC_EPILOG_MIDDLE_BLOCK:%.*]], label [[VEC_EPILOG_VECTOR_BODY]], !llvm.loop [[LOOP12:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP14]], label [[VEC_EPILOG_MIDDLE_BLOCK:%.*]], label [[VEC_EPILOG_VECTOR_BODY]], !llvm.loop [[LOOP13:![0-9]+]]\n ; CHECK:       vec.epilog.middle.block:\n ; CHECK-NEXT:    [[TMP15:%.*]] = call i32 @llvm.vector.reduce.add.v8i32(<8 x i32> [[TMP13]])\n ; CHECK-NEXT:    [[CMP_N14:%.*]] = icmp eq i64 [[SMAX2]], [[N_VEC13]]"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/X86/masked_load_store.ll",
                "patch": "@@ -72,7 +72,7 @@ define void @foo1(ptr nocapture %A, ptr nocapture readonly %B, ptr nocapture rea\n ; AVX1:       for.inc:\n ; AVX1-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; AVX1-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 10000\n-; AVX1-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP2:![0-9]+]]\n+; AVX1-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ; AVX1:       for.end:\n ; AVX1-NEXT:    ret void\n ;\n@@ -166,7 +166,7 @@ define void @foo1(ptr nocapture %A, ptr nocapture readonly %B, ptr nocapture rea\n ; AVX2:       for.inc:\n ; AVX2-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; AVX2-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 10000\n-; AVX2-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP2:![0-9]+]]\n+; AVX2-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ; AVX2:       for.end:\n ; AVX2-NEXT:    ret void\n ;\n@@ -264,7 +264,7 @@ define void @foo1(ptr nocapture %A, ptr nocapture readonly %B, ptr nocapture rea\n ; AVX512-NEXT:    call void @llvm.masked.store.v8i32.p0(<8 x i32> [[TMP45]], ptr [[TMP47]], i32 4, <8 x i1> [[TMP42]])\n ; AVX512-NEXT:    [[INDEX_NEXT15]] = add nuw i64 [[INDEX12]], 8\n ; AVX512-NEXT:    [[TMP48:%.*]] = icmp eq i64 [[INDEX_NEXT15]], 10000\n-; AVX512-NEXT:    br i1 [[TMP48]], label [[VEC_EPILOG_MIDDLE_BLOCK:%.*]], label [[VEC_EPILOG_VECTOR_BODY]], !llvm.loop [[LOOP2:![0-9]+]]\n+; AVX512-NEXT:    br i1 [[TMP48]], label [[VEC_EPILOG_MIDDLE_BLOCK:%.*]], label [[VEC_EPILOG_VECTOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ; AVX512:       vec.epilog.middle.block:\n ; AVX512-NEXT:    [[CMP_N11:%.*]] = icmp eq i64 10000, 10000\n ; AVX512-NEXT:    br i1 [[CMP_N11]], label [[FOR_END]], label [[VEC_EPILOG_SCALAR_PH]]\n@@ -352,7 +352,7 @@ define void @foo1_addrspace1(ptr addrspace(1) nocapture %A, ptr addrspace(1) noc\n ; AVX1-NEXT:    call void @llvm.masked.store.v8i32.p1(<8 x i32> [[TMP8]], ptr addrspace(1) [[TMP10]], i32 4, <8 x i1> [[TMP5]])\n ; AVX1-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 8\n ; AVX1-NEXT:    [[TMP11:%.*]] = icmp eq i64 [[INDEX_NEXT]], 10000\n-; AVX1-NEXT:    br i1 [[TMP11]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n+; AVX1-NEXT:    br i1 [[TMP11]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]\n ; AVX1:       middle.block:\n ; AVX1-NEXT:    [[CMP_N:%.*]] = icmp eq i64 10000, 10000\n ; AVX1-NEXT:    br i1 [[CMP_N]], label [[FOR_END:%.*]], label [[SCALAR_PH]]\n@@ -375,7 +375,7 @@ define void @foo1_addrspace1(ptr addrspace(1) nocapture %A, ptr addrspace(1) noc\n ; AVX1:       for.inc:\n ; AVX1-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; AVX1-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 10000\n-; AVX1-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]\n+; AVX1-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP5:![0-9]+]]\n ; AVX1:       for.end:\n ; AVX1-NEXT:    ret void\n ;\n@@ -446,7 +446,7 @@ define void @foo1_addrspace1(ptr addrspace(1) nocapture %A, ptr addrspace(1) noc\n ; AVX2-NEXT:    call void @llvm.masked.store.v8i32.p1(<8 x i32> [[TMP29]], ptr addrspace(1) [[TMP37]], i32 4, <8 x i1> [[TMP17]])\n ; AVX2-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 32\n ; AVX2-NEXT:    [[TMP38:%.*]] = icmp eq i64 [[INDEX_NEXT]], 9984\n-; AVX2-NEXT:    br i1 [[TMP38]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n+; AVX2-NEXT:    br i1 [[TMP38]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]\n ; AVX2:       middle.block:\n ; AVX2-NEXT:    [[CMP_N:%.*]] = icmp eq i64 10000, 9984\n ; AVX2-NEXT:    br i1 [[CMP_N]], label [[FOR_END:%.*]], label [[SCALAR_PH]]\n@@ -469,7 +469,7 @@ define void @foo1_addrspace1(ptr addrspace(1) nocapture %A, ptr addrspace(1) noc\n ; AVX2:       for.inc:\n ; AVX2-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; AVX2-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 10000\n-; AVX2-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]\n+; AVX2-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP5:![0-9]+]]\n ; AVX2:       for.end:\n ; AVX2-NEXT:    ret void\n ;\n@@ -665,7 +665,7 @@ define void @foo2(ptr nocapture %A, ptr nocapture readonly %B, ptr nocapture rea\n ; AVX1-NEXT:    call void @llvm.masked.store.v8f32.p0(<8 x float> [[TMP9]], ptr [[TMP11]], i32 4, <8 x i1> [[TMP5]])\n ; AVX1-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 8\n ; AVX1-NEXT:    [[TMP12:%.*]] = icmp eq i64 [[INDEX_NEXT]], 10000\n-; AVX1-NEXT:    br i1 [[TMP12]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP5:![0-9]+]]\n+; AVX1-NEXT:    br i1 [[TMP12]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP6:![0-9]+]]\n ; AVX1:       middle.block:\n ; AVX1-NEXT:    [[CMP_N:%.*]] = icmp eq i64 10000, 10000\n ; AVX1-NEXT:    br i1 [[CMP_N]], label [[FOR_END:%.*]], label [[SCALAR_PH]]\n@@ -689,7 +689,7 @@ define void @foo2(ptr nocapture %A, ptr nocapture readonly %B, ptr nocapture rea\n ; AVX1:       for.inc:\n ; AVX1-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; AVX1-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 10000\n-; AVX1-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP6:![0-9]+]]\n+; AVX1-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP7:![0-9]+]]\n ; AVX1:       for.end:\n ; AVX1-NEXT:    ret void\n ;\n@@ -764,7 +764,7 @@ define void @foo2(ptr nocapture %A, ptr nocapture readonly %B, ptr nocapture rea\n ; AVX2-NEXT:    call void @llvm.masked.store.v8f32.p0(<8 x float> [[TMP33]], ptr [[TMP41]], i32 4, <8 x i1> [[TMP17]])\n ; AVX2-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 32\n ; AVX2-NEXT:    [[TMP42:%.*]] = icmp eq i64 [[INDEX_NEXT]], 9984\n-; AVX2-NEXT:    br i1 [[TMP42]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP5:![0-9]+]]\n+; AVX2-NEXT:    br i1 [[TMP42]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP6:![0-9]+]]\n ; AVX2:       middle.block:\n ; AVX2-NEXT:    [[CMP_N:%.*]] = icmp eq i64 10000, 9984\n ; AVX2-NEXT:    br i1 [[CMP_N]], label [[FOR_END:%.*]], label [[SCALAR_PH]]\n@@ -788,7 +788,7 @@ define void @foo2(ptr nocapture %A, ptr nocapture readonly %B, ptr nocapture rea\n ; AVX2:       for.inc:\n ; AVX2-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; AVX2-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 10000\n-; AVX2-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP6:![0-9]+]]\n+; AVX2-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP7:![0-9]+]]\n ; AVX2:       for.end:\n ; AVX2-NEXT:    ret void\n ;\n@@ -987,13 +987,13 @@ define void @foo3(ptr nocapture %A, ptr nocapture readonly %B, ptr nocapture rea\n ; AVX-NEXT:    [[TMP6:%.*]] = getelementptr inbounds i32, ptr [[TRIGGER]], i64 [[TMP2]]\n ; AVX-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, ptr [[TRIGGER]], i64 [[TMP3]]\n ; AVX-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], i32 0\n-; AVX-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i32>, ptr [[TMP8]], align 4, !alias.scope !7\n+; AVX-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i32>, ptr [[TMP8]], align 4, !alias.scope !8\n ; AVX-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], i32 4\n-; AVX-NEXT:    [[WIDE_LOAD6:%.*]] = load <4 x i32>, ptr [[TMP9]], align 4, !alias.scope !7\n+; AVX-NEXT:    [[WIDE_LOAD6:%.*]] = load <4 x i32>, ptr [[TMP9]], align 4, !alias.scope !8\n ; AVX-NEXT:    [[TMP10:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], i32 8\n-; AVX-NEXT:    [[WIDE_LOAD7:%.*]] = load <4 x i32>, ptr [[TMP10]], align 4, !alias.scope !7\n+; AVX-NEXT:    [[WIDE_LOAD7:%.*]] = load <4 x i32>, ptr [[TMP10]], align 4, !alias.scope !8\n ; AVX-NEXT:    [[TMP11:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], i32 12\n-; AVX-NEXT:    [[WIDE_LOAD8:%.*]] = load <4 x i32>, ptr [[TMP11]], align 4, !alias.scope !7\n+; AVX-NEXT:    [[WIDE_LOAD8:%.*]] = load <4 x i32>, ptr [[TMP11]], align 4, !alias.scope !8\n ; AVX-NEXT:    [[TMP12:%.*]] = icmp slt <4 x i32> [[WIDE_LOAD]], <i32 100, i32 100, i32 100, i32 100>\n ; AVX-NEXT:    [[TMP13:%.*]] = icmp slt <4 x i32> [[WIDE_LOAD6]], <i32 100, i32 100, i32 100, i32 100>\n ; AVX-NEXT:    [[TMP14:%.*]] = icmp slt <4 x i32> [[WIDE_LOAD7]], <i32 100, i32 100, i32 100, i32 100>\n@@ -1003,13 +1003,13 @@ define void @foo3(ptr nocapture %A, ptr nocapture readonly %B, ptr nocapture rea\n ; AVX-NEXT:    [[TMP18:%.*]] = getelementptr double, ptr [[B]], i64 [[TMP2]]\n ; AVX-NEXT:    [[TMP19:%.*]] = getelementptr double, ptr [[B]], i64 [[TMP3]]\n ; AVX-NEXT:    [[TMP20:%.*]] = getelementptr double, ptr [[TMP16]], i32 0\n-; AVX-NEXT:    [[WIDE_MASKED_LOAD:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP20]], i32 8, <4 x i1> [[TMP12]], <4 x double> poison), !alias.scope !10\n+; AVX-NEXT:    [[WIDE_MASKED_LOAD:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP20]], i32 8, <4 x i1> [[TMP12]], <4 x double> poison), !alias.scope !11\n ; AVX-NEXT:    [[TMP21:%.*]] = getelementptr double, ptr [[TMP16]], i32 4\n-; AVX-NEXT:    [[WIDE_MASKED_LOAD9:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP21]], i32 8, <4 x i1> [[TMP13]], <4 x double> poison), !alias.scope !10\n+; AVX-NEXT:    [[WIDE_MASKED_LOAD9:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP21]], i32 8, <4 x i1> [[TMP13]], <4 x double> poison), !alias.scope !11\n ; AVX-NEXT:    [[TMP22:%.*]] = getelementptr double, ptr [[TMP16]], i32 8\n-; AVX-NEXT:    [[WIDE_MASKED_LOAD10:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP22]], i32 8, <4 x i1> [[TMP14]], <4 x double> poison), !alias.scope !10\n+; AVX-NEXT:    [[WIDE_MASKED_LOAD10:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP22]], i32 8, <4 x i1> [[TMP14]], <4 x double> poison), !alias.scope !11\n ; AVX-NEXT:    [[TMP23:%.*]] = getelementptr double, ptr [[TMP16]], i32 12\n-; AVX-NEXT:    [[WIDE_MASKED_LOAD11:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP23]], i32 8, <4 x i1> [[TMP15]], <4 x double> poison), !alias.scope !10\n+; AVX-NEXT:    [[WIDE_MASKED_LOAD11:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP23]], i32 8, <4 x i1> [[TMP15]], <4 x double> poison), !alias.scope !11\n ; AVX-NEXT:    [[TMP24:%.*]] = sitofp <4 x i32> [[WIDE_LOAD]] to <4 x double>\n ; AVX-NEXT:    [[TMP25:%.*]] = sitofp <4 x i32> [[WIDE_LOAD6]] to <4 x double>\n ; AVX-NEXT:    [[TMP26:%.*]] = sitofp <4 x i32> [[WIDE_LOAD7]] to <4 x double>\n@@ -1023,16 +1023,16 @@ define void @foo3(ptr nocapture %A, ptr nocapture readonly %B, ptr nocapture rea\n ; AVX-NEXT:    [[TMP34:%.*]] = getelementptr double, ptr [[A]], i64 [[TMP2]]\n ; AVX-NEXT:    [[TMP35:%.*]] = getelementptr double, ptr [[A]], i64 [[TMP3]]\n ; AVX-NEXT:    [[TMP36:%.*]] = getelementptr double, ptr [[TMP32]], i32 0\n-; AVX-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[TMP28]], ptr [[TMP36]], i32 8, <4 x i1> [[TMP12]]), !alias.scope !12, !noalias !14\n+; AVX-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[TMP28]], ptr [[TMP36]], i32 8, <4 x i1> [[TMP12]]), !alias.scope !13, !noalias !15\n ; AVX-NEXT:    [[TMP37:%.*]] = getelementptr double, ptr [[TMP32]], i32 4\n-; AVX-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[TMP29]], ptr [[TMP37]], i32 8, <4 x i1> [[TMP13]]), !alias.scope !12, !noalias !14\n+; AVX-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[TMP29]], ptr [[TMP37]], i32 8, <4 x i1> [[TMP13]]), !alias.scope !13, !noalias !15\n ; AVX-NEXT:    [[TMP38:%.*]] = getelementptr double, ptr [[TMP32]], i32 8\n-; AVX-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[TMP30]], ptr [[TMP38]], i32 8, <4 x i1> [[TMP14]]), !alias.scope !12, !noalias !14\n+; AVX-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[TMP30]], ptr [[TMP38]], i32 8, <4 x i1> [[TMP14]]), !alias.scope !13, !noalias !15\n ; AVX-NEXT:    [[TMP39:%.*]] = getelementptr double, ptr [[TMP32]], i32 12\n-; AVX-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[TMP31]], ptr [[TMP39]], i32 8, <4 x i1> [[TMP15]]), !alias.scope !12, !noalias !14\n+; AVX-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[TMP31]], ptr [[TMP39]], i32 8, <4 x i1> [[TMP15]]), !alias.scope !13, !noalias !15\n ; AVX-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 16\n ; AVX-NEXT:    [[TMP40:%.*]] = icmp eq i64 [[INDEX_NEXT]], 10000\n-; AVX-NEXT:    br i1 [[TMP40]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP15:![0-9]+]]\n+; AVX-NEXT:    br i1 [[TMP40]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP16:![0-9]+]]\n ; AVX:       middle.block:\n ; AVX-NEXT:    [[CMP_N:%.*]] = icmp eq i64 10000, 10000\n ; AVX-NEXT:    br i1 [[CMP_N]], label [[FOR_END:%.*]], label [[SCALAR_PH]]\n@@ -1056,7 +1056,7 @@ define void @foo3(ptr nocapture %A, ptr nocapture readonly %B, ptr nocapture rea\n ; AVX:       for.inc:\n ; AVX-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; AVX-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 10000\n-; AVX-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP16:![0-9]+]]\n+; AVX-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP17:![0-9]+]]\n ; AVX:       for.end:\n ; AVX-NEXT:    ret void\n ;\n@@ -1384,19 +1384,19 @@ define void @foo6(ptr nocapture readonly %in, ptr nocapture %out, i32 %size, ptr\n ; AVX2-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, ptr [[TRIGGER]], i64 [[TMP3]]\n ; AVX2-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], i32 0\n ; AVX2-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i32, ptr [[TMP8]], i32 -3\n-; AVX2-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i32>, ptr [[TMP9]], align 4, !alias.scope !17\n+; AVX2-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i32>, ptr [[TMP9]], align 4, !alias.scope !18\n ; AVX2-NEXT:    [[REVERSE:%.*]] = shufflevector <4 x i32> [[WIDE_LOAD]], <4 x i32> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n ; AVX2-NEXT:    [[TMP10:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], i32 -4\n ; AVX2-NEXT:    [[TMP11:%.*]] = getelementptr inbounds i32, ptr [[TMP10]], i32 -3\n-; AVX2-NEXT:    [[WIDE_LOAD6:%.*]] = load <4 x i32>, ptr [[TMP11]], align 4, !alias.scope !17\n+; AVX2-NEXT:    [[WIDE_LOAD6:%.*]] = load <4 x i32>, ptr [[TMP11]], align 4, !alias.scope !18\n ; AVX2-NEXT:    [[REVERSE7:%.*]] = shufflevector <4 x i32> [[WIDE_LOAD6]], <4 x i32> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n ; AVX2-NEXT:    [[TMP12:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], i32 -8\n ; AVX2-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i32, ptr [[TMP12]], i32 -3\n-; AVX2-NEXT:    [[WIDE_LOAD8:%.*]] = load <4 x i32>, ptr [[TMP13]], align 4, !alias.scope !17\n+; AVX2-NEXT:    [[WIDE_LOAD8:%.*]] = load <4 x i32>, ptr [[TMP13]], align 4, !alias.scope !18\n ; AVX2-NEXT:    [[REVERSE9:%.*]] = shufflevector <4 x i32> [[WIDE_LOAD8]], <4 x i32> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n ; AVX2-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i32, ptr [[TMP4]], i32 -12\n ; AVX2-NEXT:    [[TMP15:%.*]] = getelementptr inbounds i32, ptr [[TMP14]], i32 -3\n-; AVX2-NEXT:    [[WIDE_LOAD10:%.*]] = load <4 x i32>, ptr [[TMP15]], align 4, !alias.scope !17\n+; AVX2-NEXT:    [[WIDE_LOAD10:%.*]] = load <4 x i32>, ptr [[TMP15]], align 4, !alias.scope !18\n ; AVX2-NEXT:    [[REVERSE11:%.*]] = shufflevector <4 x i32> [[WIDE_LOAD10]], <4 x i32> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n ; AVX2-NEXT:    [[TMP16:%.*]] = icmp sgt <4 x i32> [[REVERSE]], zeroinitializer\n ; AVX2-NEXT:    [[TMP17:%.*]] = icmp sgt <4 x i32> [[REVERSE7]], zeroinitializer\n@@ -1409,22 +1409,22 @@ define void @foo6(ptr nocapture readonly %in, ptr nocapture %out, i32 %size, ptr\n ; AVX2-NEXT:    [[TMP24:%.*]] = getelementptr double, ptr [[TMP20]], i32 0\n ; AVX2-NEXT:    [[TMP25:%.*]] = getelementptr double, ptr [[TMP24]], i32 -3\n ; AVX2-NEXT:    [[REVERSE12:%.*]] = shufflevector <4 x i1> [[TMP16]], <4 x i1> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n-; AVX2-NEXT:    [[WIDE_MASKED_LOAD:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP25]], i32 8, <4 x i1> [[REVERSE12]], <4 x double> poison), !alias.scope !20\n+; AVX2-NEXT:    [[WIDE_MASKED_LOAD:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP25]], i32 8, <4 x i1> [[REVERSE12]], <4 x double> poison), !alias.scope !21\n ; AVX2-NEXT:    [[REVERSE13:%.*]] = shufflevector <4 x double> [[WIDE_MASKED_LOAD]], <4 x double> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n ; AVX2-NEXT:    [[TMP26:%.*]] = getelementptr double, ptr [[TMP20]], i32 -4\n ; AVX2-NEXT:    [[TMP27:%.*]] = getelementptr double, ptr [[TMP26]], i32 -3\n ; AVX2-NEXT:    [[REVERSE14:%.*]] = shufflevector <4 x i1> [[TMP17]], <4 x i1> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n-; AVX2-NEXT:    [[WIDE_MASKED_LOAD15:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP27]], i32 8, <4 x i1> [[REVERSE14]], <4 x double> poison), !alias.scope !20\n+; AVX2-NEXT:    [[WIDE_MASKED_LOAD15:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP27]], i32 8, <4 x i1> [[REVERSE14]], <4 x double> poison), !alias.scope !21\n ; AVX2-NEXT:    [[REVERSE16:%.*]] = shufflevector <4 x double> [[WIDE_MASKED_LOAD15]], <4 x double> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n ; AVX2-NEXT:    [[TMP28:%.*]] = getelementptr double, ptr [[TMP20]], i32 -8\n ; AVX2-NEXT:    [[TMP29:%.*]] = getelementptr double, ptr [[TMP28]], i32 -3\n ; AVX2-NEXT:    [[REVERSE17:%.*]] = shufflevector <4 x i1> [[TMP18]], <4 x i1> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n-; AVX2-NEXT:    [[WIDE_MASKED_LOAD18:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP29]], i32 8, <4 x i1> [[REVERSE17]], <4 x double> poison), !alias.scope !20\n+; AVX2-NEXT:    [[WIDE_MASKED_LOAD18:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP29]], i32 8, <4 x i1> [[REVERSE17]], <4 x double> poison), !alias.scope !21\n ; AVX2-NEXT:    [[REVERSE19:%.*]] = shufflevector <4 x double> [[WIDE_MASKED_LOAD18]], <4 x double> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n ; AVX2-NEXT:    [[TMP30:%.*]] = getelementptr double, ptr [[TMP20]], i32 -12\n ; AVX2-NEXT:    [[TMP31:%.*]] = getelementptr double, ptr [[TMP30]], i32 -3\n ; AVX2-NEXT:    [[REVERSE20:%.*]] = shufflevector <4 x i1> [[TMP19]], <4 x i1> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n-; AVX2-NEXT:    [[WIDE_MASKED_LOAD21:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP31]], i32 8, <4 x i1> [[REVERSE20]], <4 x double> poison), !alias.scope !20\n+; AVX2-NEXT:    [[WIDE_MASKED_LOAD21:%.*]] = call <4 x double> @llvm.masked.load.v4f64.p0(ptr [[TMP31]], i32 8, <4 x i1> [[REVERSE20]], <4 x double> poison), !alias.scope !21\n ; AVX2-NEXT:    [[REVERSE22:%.*]] = shufflevector <4 x double> [[WIDE_MASKED_LOAD21]], <4 x double> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n ; AVX2-NEXT:    [[TMP32:%.*]] = fadd <4 x double> [[REVERSE13]], <double 5.000000e-01, double 5.000000e-01, double 5.000000e-01, double 5.000000e-01>\n ; AVX2-NEXT:    [[TMP33:%.*]] = fadd <4 x double> [[REVERSE16]], <double 5.000000e-01, double 5.000000e-01, double 5.000000e-01, double 5.000000e-01>\n@@ -1437,22 +1437,22 @@ define void @foo6(ptr nocapture readonly %in, ptr nocapture %out, i32 %size, ptr\n ; AVX2-NEXT:    [[REVERSE23:%.*]] = shufflevector <4 x double> [[TMP32]], <4 x double> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n ; AVX2-NEXT:    [[TMP40:%.*]] = getelementptr double, ptr [[TMP36]], i32 0\n ; AVX2-NEXT:    [[TMP41:%.*]] = getelementptr double, ptr [[TMP40]], i32 -3\n-; AVX2-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[REVERSE23]], ptr [[TMP41]], i32 8, <4 x i1> [[REVERSE12]]), !alias.scope !22, !noalias !24\n+; AVX2-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[REVERSE23]], ptr [[TMP41]], i32 8, <4 x i1> [[REVERSE12]]), !alias.scope !23, !noalias !25\n ; AVX2-NEXT:    [[REVERSE25:%.*]] = shufflevector <4 x double> [[TMP33]], <4 x double> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n ; AVX2-NEXT:    [[TMP42:%.*]] = getelementptr double, ptr [[TMP36]], i32 -4\n ; AVX2-NEXT:    [[TMP43:%.*]] = getelementptr double, ptr [[TMP42]], i32 -3\n-; AVX2-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[REVERSE25]], ptr [[TMP43]], i32 8, <4 x i1> [[REVERSE14]]), !alias.scope !22, !noalias !24\n+; AVX2-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[REVERSE25]], ptr [[TMP43]], i32 8, <4 x i1> [[REVERSE14]]), !alias.scope !23, !noalias !25\n ; AVX2-NEXT:    [[REVERSE27:%.*]] = shufflevector <4 x double> [[TMP34]], <4 x double> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n ; AVX2-NEXT:    [[TMP44:%.*]] = getelementptr double, ptr [[TMP36]], i32 -8\n ; AVX2-NEXT:    [[TMP45:%.*]] = getelementptr double, ptr [[TMP44]], i32 -3\n-; AVX2-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[REVERSE27]], ptr [[TMP45]], i32 8, <4 x i1> [[REVERSE17]]), !alias.scope !22, !noalias !24\n+; AVX2-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[REVERSE27]], ptr [[TMP45]], i32 8, <4 x i1> [[REVERSE17]]), !alias.scope !23, !noalias !25\n ; AVX2-NEXT:    [[REVERSE29:%.*]] = shufflevector <4 x double> [[TMP35]], <4 x double> poison, <4 x i32> <i32 3, i32 2, i32 1, i32 0>\n ; AVX2-NEXT:    [[TMP46:%.*]] = getelementptr double, ptr [[TMP36]], i32 -12\n ; AVX2-NEXT:    [[TMP47:%.*]] = getelementptr double, ptr [[TMP46]], i32 -3\n-; AVX2-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[REVERSE29]], ptr [[TMP47]], i32 8, <4 x i1> [[REVERSE20]]), !alias.scope !22, !noalias !24\n+; AVX2-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> [[REVERSE29]], ptr [[TMP47]], i32 8, <4 x i1> [[REVERSE20]]), !alias.scope !23, !noalias !25\n ; AVX2-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 16\n ; AVX2-NEXT:    [[TMP48:%.*]] = icmp eq i64 [[INDEX_NEXT]], 4096\n-; AVX2-NEXT:    br i1 [[TMP48]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP25:![0-9]+]]\n+; AVX2-NEXT:    br i1 [[TMP48]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP26:![0-9]+]]\n ; AVX2:       middle.block:\n ; AVX2-NEXT:    [[CMP_N:%.*]] = icmp eq i64 4096, 4096\n ; AVX2-NEXT:    br i1 [[CMP_N]], label [[FOR_END:%.*]], label [[SCALAR_PH]]\n@@ -1475,7 +1475,7 @@ define void @foo6(ptr nocapture readonly %in, ptr nocapture %out, i32 %size, ptr\n ; AVX2:       for.inc:\n ; AVX2-NEXT:    [[INDVARS_IV_NEXT]] = add nsw i64 [[INDVARS_IV]], -1\n ; AVX2-NEXT:    [[CMP:%.*]] = icmp eq i64 [[INDVARS_IV]], 0\n-; AVX2-NEXT:    br i1 [[CMP]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP26:![0-9]+]]\n+; AVX2-NEXT:    br i1 [[CMP]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP27:![0-9]+]]\n ; AVX2:       for.end:\n ; AVX2-NEXT:    ret void\n ;\n@@ -1720,7 +1720,7 @@ define void @foo7(ptr noalias nocapture %out, ptr noalias nocapture readonly %in\n ; AVX1-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> <double 5.000000e-01, double 5.000000e-01, double 5.000000e-01, double 5.000000e-01>, ptr [[TMP51]], i32 8, <4 x i1> [[TMP47]])\n ; AVX1-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 16\n ; AVX1-NEXT:    [[TMP52:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n-; AVX1-NEXT:    br i1 [[TMP52]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP17:![0-9]+]]\n+; AVX1-NEXT:    br i1 [[TMP52]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP18:![0-9]+]]\n ; AVX1:       middle.block:\n ; AVX1-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]\n ; AVX1-NEXT:    br i1 [[CMP_N]], label [[FOR_END_LOOPEXIT:%.*]], label [[SCALAR_PH]]\n@@ -1746,7 +1746,7 @@ define void @foo7(ptr noalias nocapture %out, ptr noalias nocapture readonly %in\n ; AVX1:       for.inc:\n ; AVX1-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; AVX1-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]\n-; AVX1-NEXT:    br i1 [[EXITCOND]], label [[FOR_END_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP18:![0-9]+]]\n+; AVX1-NEXT:    br i1 [[EXITCOND]], label [[FOR_END_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP19:![0-9]+]]\n ; AVX1:       for.end.loopexit:\n ; AVX1-NEXT:    br label [[FOR_END]]\n ; AVX1:       for.end:\n@@ -1832,7 +1832,7 @@ define void @foo7(ptr noalias nocapture %out, ptr noalias nocapture readonly %in\n ; AVX2-NEXT:    call void @llvm.masked.store.v4f64.p0(<4 x double> <double 5.000000e-01, double 5.000000e-01, double 5.000000e-01, double 5.000000e-01>, ptr [[TMP51]], i32 8, <4 x i1> [[TMP47]])\n ; AVX2-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 16\n ; AVX2-NEXT:    [[TMP52:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n-; AVX2-NEXT:    br i1 [[TMP52]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP27:![0-9]+]]\n+; AVX2-NEXT:    br i1 [[TMP52]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP28:![0-9]+]]\n ; AVX2:       middle.block:\n ; AVX2-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[WIDE_TRIP_COUNT]], [[N_VEC]]\n ; AVX2-NEXT:    br i1 [[CMP_N]], label [[FOR_END_LOOPEXIT:%.*]], label [[SCALAR_PH]]\n@@ -1858,7 +1858,7 @@ define void @foo7(ptr noalias nocapture %out, ptr noalias nocapture readonly %in\n ; AVX2:       for.inc:\n ; AVX2-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; AVX2-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]\n-; AVX2-NEXT:    br i1 [[EXITCOND]], label [[FOR_END_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP28:![0-9]+]]\n+; AVX2-NEXT:    br i1 [[EXITCOND]], label [[FOR_END_LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP29:![0-9]+]]\n ; AVX2:       for.end.loopexit:\n ; AVX2-NEXT:    br label [[FOR_END]]\n ; AVX2:       for.end:"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/X86/metadata-enable.ll",
                "patch": "@@ -1211,7 +1211,7 @@ define i32 @nopragma(ptr noalias nocapture %a, ptr noalias nocapture readonly %b\n ; O1VEC2-NEXT:    store i32 [[ADD]], ptr [[ARRAYIDX2]], align 4\n ; O1VEC2-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; O1VEC2-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 64\n-; O1VEC2-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP2:![0-9]+]]\n+; O1VEC2-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ; O1VEC2:       for.end:\n ; O1VEC2-NEXT:    [[TMP8:%.*]] = load i32, ptr [[A]], align 4\n ; O1VEC2-NEXT:    ret i32 [[TMP8]]\n@@ -1251,7 +1251,7 @@ define i32 @nopragma(ptr noalias nocapture %a, ptr noalias nocapture readonly %b\n ; OzVEC2-NEXT:    store i32 [[ADD]], ptr [[ARRAYIDX2]], align 4\n ; OzVEC2-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; OzVEC2-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 64\n-; OzVEC2-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP2:![0-9]+]]\n+; OzVEC2-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ; OzVEC2:       for.end:\n ; OzVEC2-NEXT:    [[TMP8:%.*]] = load i32, ptr [[A]], align 4\n ; OzVEC2-NEXT:    ret i32 [[TMP8]]"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/X86/tail_loop_folding.ll",
                "patch": "@@ -49,7 +49,7 @@ define dso_local void @tail_folding_enabled(ptr noalias nocapture %A, ptr noalia\n ; CHECK-NEXT:    store i32 [[ADD]], ptr [[ARRAYIDX4]], align 4\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 430\n-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP2:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ;\n entry:\n   br label %for.body"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/X86/uniform_mem_op.ll",
                "patch": "@@ -31,7 +31,7 @@ define i32 @uniform_load(ptr align(4) %addr) {\n ; CHECK-NEXT:    [[LOAD:%.*]] = load i32, ptr [[ADDR]], align 4\n ; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1\n ; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[IV]], 4096\n-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP2:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EXITCOND]], label [[LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ; CHECK:       loopexit:\n ; CHECK-NEXT:    [[LOAD_LCSSA:%.*]] = phi i32 [ [[LOAD]], [[FOR_BODY]] ], [ [[TMP0]], [[MIDDLE_BLOCK]] ]\n ; CHECK-NEXT:    ret i32 [[LOAD_LCSSA]]"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/followup.ll",
                "patch": "@@ -36,8 +36,9 @@ for.end:\n ; CHECK-LABEL: for.body:\n ; CHECK: br i1 %exitcond, label %for.end.loopexit, label %for.body, !llvm.loop ![[LOOP_EPILOGUE:[0-9]+]]\n \n-; CHECK: ![[LOOP_VECTOR]] = distinct !{![[LOOP_VECTOR]], ![[FOLLOWUP_ALL:[0-9]+]], ![[FOLLOWUP_VECTORIZED:[0-9]+]]}\n+; CHECK: ![[LOOP_VECTOR]] = distinct !{![[LOOP_VECTOR]], ![[FOLLOWUP_ALL:[0-9]+]], ![[FOLLOWUP_VECTORIZED:[0-9]+]], ![[RT_UNROLL_DIS:[0-9]+]]}\n ; CHECK: ![[FOLLOWUP_ALL]] = !{!\"FollowupAll\"}\n ; CHECK: ![[FOLLOWUP_VECTORIZED:[0-9]+]] = !{!\"FollowupVectorized\"}\n+; CHECK: ![[RT_UNROLL_DIS]] = !{!\"llvm.loop.unroll.runtime.disable\"}\n ; CHECK: ![[LOOP_EPILOGUE]] = distinct !{![[LOOP_EPILOGUE]], ![[FOLLOWUP_ALL]], ![[FOLLOWUP_EPILOGUE:[0-9]+]]}\n ; CHECK: ![[FOLLOWUP_EPILOGUE]] = !{!\"FollowupEpilogue\"}"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/if-pred-non-void.ll",
                "patch": "@@ -165,7 +165,7 @@ define void @test(ptr nocapture %asd, ptr nocapture %aud,\n ; CHECK-NEXT:    store i32 [[YUR_0]], ptr [[IUR]], align 4\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 128\n-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP18:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP19:![0-9]+]]\n ;\n ; UNROLL-NO-VF-LABEL: @test(\n ; UNROLL-NO-VF-NEXT:  entry:\n@@ -317,7 +317,7 @@ define void @test(ptr nocapture %asd, ptr nocapture %aud,\n ; UNROLL-NO-VF-NEXT:    store i32 [[YUR_0]], ptr [[IUR]], align 4\n ; UNROLL-NO-VF-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; UNROLL-NO-VF-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 128\n-; UNROLL-NO-VF-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP18:![0-9]+]]\n+; UNROLL-NO-VF-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP19:![0-9]+]]\n ;\n   ptr nocapture %asr, ptr nocapture %aur) {\n entry:\n@@ -378,10 +378,10 @@ define void @test_scalar2scalar(ptr nocapture %asd, ptr nocapture %bsd) {\n ; CHECK-NEXT:    [[TMP0:%.*]] = add i64 [[INDEX]], 0\n ; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i32, ptr [[ASD]], i64 [[TMP0]]\n ; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, ptr [[TMP1]], i32 0\n-; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i32>, ptr [[TMP2]], align 4, !alias.scope !19, !noalias !22\n+; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i32>, ptr [[TMP2]], align 4, !alias.scope !20, !noalias !23\n ; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr [[BSD]], i64 [[TMP0]]\n ; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i32, ptr [[TMP3]], i32 0\n-; CHECK-NEXT:    [[WIDE_LOAD2:%.*]] = load <2 x i32>, ptr [[TMP4]], align 4, !alias.scope !22\n+; CHECK-NEXT:    [[WIDE_LOAD2:%.*]] = load <2 x i32>, ptr [[TMP4]], align 4, !alias.scope !23\n ; CHECK-NEXT:    [[TMP5:%.*]] = add nsw <2 x i32> [[WIDE_LOAD]], <i32 23, i32 23>\n ; CHECK-NEXT:    [[TMP6:%.*]] = icmp slt <2 x i32> [[WIDE_LOAD]], <i32 100, i32 100>\n ; CHECK-NEXT:    [[TMP7:%.*]] = extractelement <2 x i1> [[TMP6]], i32 0\n@@ -413,10 +413,10 @@ define void @test_scalar2scalar(ptr nocapture %asd, ptr nocapture %bsd) {\n ; CHECK-NEXT:    [[TMP25:%.*]] = xor <2 x i1> [[TMP6]], <i1 true, i1 true>\n ; CHECK-NEXT:    [[PREDPHI:%.*]] = select <2 x i1> [[TMP25]], <2 x i32> [[TMP5]], <2 x i32> [[TMP24]]\n ; CHECK-NEXT:    [[TMP26:%.*]] = getelementptr inbounds i32, ptr [[TMP1]], i32 0\n-; CHECK-NEXT:    store <2 x i32> [[PREDPHI]], ptr [[TMP26]], align 4, !alias.scope !19, !noalias !22\n+; CHECK-NEXT:    store <2 x i32> [[PREDPHI]], ptr [[TMP26]], align 4, !alias.scope !20, !noalias !23\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 2\n ; CHECK-NEXT:    [[TMP27:%.*]] = icmp eq i64 [[INDEX_NEXT]], 128\n-; CHECK-NEXT:    br i1 [[TMP27]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP24:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP27]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP25:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 128, 128\n ; CHECK-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP:%.*]], label [[SCALAR_PH]]\n@@ -443,7 +443,7 @@ define void @test_scalar2scalar(ptr nocapture %asd, ptr nocapture %bsd) {\n ; CHECK-NEXT:    store i32 [[YSD_0]], ptr [[ISD]], align 4\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 128\n-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP25:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP26:![0-9]+]]\n ;\n ; UNROLL-NO-VF-LABEL: @test_scalar2scalar(\n ; UNROLL-NO-VF-NEXT:  entry:\n@@ -463,16 +463,16 @@ define void @test_scalar2scalar(ptr nocapture %asd, ptr nocapture %bsd) {\n ; UNROLL-NO-VF-NEXT:    [[TMP1:%.*]] = add i64 [[INDEX]], 1\n ; UNROLL-NO-VF-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, ptr [[ASD]], i64 [[TMP0]]\n ; UNROLL-NO-VF-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr [[ASD]], i64 [[TMP1]]\n-; UNROLL-NO-VF-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP2]], align 4, !alias.scope !19, !noalias !22\n-; UNROLL-NO-VF-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP3]], align 4, !alias.scope !19, !noalias !22\n+; UNROLL-NO-VF-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP2]], align 4, !alias.scope !20, !noalias !23\n+; UNROLL-NO-VF-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP3]], align 4, !alias.scope !20, !noalias !23\n ; UNROLL-NO-VF-NEXT:    [[TMP6:%.*]] = add nsw i32 [[TMP4]], 23\n ; UNROLL-NO-VF-NEXT:    [[TMP7:%.*]] = add nsw i32 [[TMP5]], 23\n ; UNROLL-NO-VF-NEXT:    [[TMP8:%.*]] = icmp slt i32 [[TMP4]], 100\n ; UNROLL-NO-VF-NEXT:    [[TMP9:%.*]] = icmp slt i32 [[TMP5]], 100\n ; UNROLL-NO-VF-NEXT:    br i1 [[TMP8]], label [[PRED_SDIV_IF:%.*]], label [[PRED_SDIV_CONTINUE:%.*]]\n ; UNROLL-NO-VF:       pred.sdiv.if:\n ; UNROLL-NO-VF-NEXT:    [[TMP10:%.*]] = getelementptr inbounds i32, ptr [[BSD]], i64 [[TMP0]]\n-; UNROLL-NO-VF-NEXT:    [[TMP11:%.*]] = load i32, ptr [[TMP10]], align 4, !alias.scope !22\n+; UNROLL-NO-VF-NEXT:    [[TMP11:%.*]] = load i32, ptr [[TMP10]], align 4, !alias.scope !23\n ; UNROLL-NO-VF-NEXT:    [[TMP12:%.*]] = sdiv i32 [[TMP6]], [[TMP4]]\n ; UNROLL-NO-VF-NEXT:    [[TMP13:%.*]] = sdiv i32 [[TMP11]], [[TMP12]]\n ; UNROLL-NO-VF-NEXT:    br label [[PRED_SDIV_CONTINUE]]\n@@ -482,7 +482,7 @@ define void @test_scalar2scalar(ptr nocapture %asd, ptr nocapture %bsd) {\n ; UNROLL-NO-VF-NEXT:    br i1 [[TMP9]], label [[PRED_SDIV_IF2:%.*]], label [[PRED_SDIV_CONTINUE3]]\n ; UNROLL-NO-VF:       pred.sdiv.if2:\n ; UNROLL-NO-VF-NEXT:    [[TMP16:%.*]] = getelementptr inbounds i32, ptr [[BSD]], i64 [[TMP1]]\n-; UNROLL-NO-VF-NEXT:    [[TMP17:%.*]] = load i32, ptr [[TMP16]], align 4, !alias.scope !22\n+; UNROLL-NO-VF-NEXT:    [[TMP17:%.*]] = load i32, ptr [[TMP16]], align 4, !alias.scope !23\n ; UNROLL-NO-VF-NEXT:    [[TMP18:%.*]] = sdiv i32 [[TMP7]], [[TMP5]]\n ; UNROLL-NO-VF-NEXT:    [[TMP19:%.*]] = sdiv i32 [[TMP17]], [[TMP18]]\n ; UNROLL-NO-VF-NEXT:    br label [[PRED_SDIV_CONTINUE3]]\n@@ -493,11 +493,11 @@ define void @test_scalar2scalar(ptr nocapture %asd, ptr nocapture %bsd) {\n ; UNROLL-NO-VF-NEXT:    [[TMP23:%.*]] = xor i1 [[TMP9]], true\n ; UNROLL-NO-VF-NEXT:    [[PREDPHI:%.*]] = select i1 [[TMP22]], i32 [[TMP6]], i32 [[TMP15]]\n ; UNROLL-NO-VF-NEXT:    [[PREDPHI4:%.*]] = select i1 [[TMP23]], i32 [[TMP7]], i32 [[TMP21]]\n-; UNROLL-NO-VF-NEXT:    store i32 [[PREDPHI]], ptr [[TMP2]], align 4, !alias.scope !19, !noalias !22\n-; UNROLL-NO-VF-NEXT:    store i32 [[PREDPHI4]], ptr [[TMP3]], align 4, !alias.scope !19, !noalias !22\n+; UNROLL-NO-VF-NEXT:    store i32 [[PREDPHI]], ptr [[TMP2]], align 4, !alias.scope !20, !noalias !23\n+; UNROLL-NO-VF-NEXT:    store i32 [[PREDPHI4]], ptr [[TMP3]], align 4, !alias.scope !20, !noalias !23\n ; UNROLL-NO-VF-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 2\n ; UNROLL-NO-VF-NEXT:    [[TMP24:%.*]] = icmp eq i64 [[INDEX_NEXT]], 128\n-; UNROLL-NO-VF-NEXT:    br i1 [[TMP24]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP24:![0-9]+]]\n+; UNROLL-NO-VF-NEXT:    br i1 [[TMP24]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP25:![0-9]+]]\n ; UNROLL-NO-VF:       middle.block:\n ; UNROLL-NO-VF-NEXT:    [[CMP_N:%.*]] = icmp eq i64 128, 128\n ; UNROLL-NO-VF-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP:%.*]], label [[SCALAR_PH]]\n@@ -524,7 +524,7 @@ define void @test_scalar2scalar(ptr nocapture %asd, ptr nocapture %bsd) {\n ; UNROLL-NO-VF-NEXT:    store i32 [[YSD_0]], ptr [[ISD]], align 4\n ; UNROLL-NO-VF-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; UNROLL-NO-VF-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 128\n-; UNROLL-NO-VF-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP25:![0-9]+]]\n+; UNROLL-NO-VF-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP26:![0-9]+]]\n ;\n entry:\n   br label %for.body\n@@ -570,15 +570,15 @@ define void @pr30172(ptr nocapture %asd, ptr nocapture %bsd) !dbg !5 {;\n ; CHECK-NEXT:    [[TMP0:%.*]] = add i64 [[INDEX]], 0\n ; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i32, ptr [[ASD]], i64 [[TMP0]]\n ; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, ptr [[TMP1]], i32 0\n-; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i32>, ptr [[TMP2]], align 4, !alias.scope !28, !noalias !31\n+; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i32>, ptr [[TMP2]], align 4, !alias.scope !29, !noalias !32\n ; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr [[BSD]], i64 [[TMP0]]\n ; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i32, ptr [[TMP3]], i32 0\n-; CHECK-NEXT:    [[WIDE_LOAD2:%.*]] = load <2 x i32>, ptr [[TMP4]], align 4, !alias.scope !31\n+; CHECK-NEXT:    [[WIDE_LOAD2:%.*]] = load <2 x i32>, ptr [[TMP4]], align 4, !alias.scope !32\n ; CHECK-NEXT:    [[TMP5:%.*]] = add nsw <2 x i32> [[WIDE_LOAD]], <i32 23, i32 23>\n ; CHECK-NEXT:    [[TMP6:%.*]] = icmp slt <2 x i32> [[WIDE_LOAD]], <i32 100, i32 100>\n ; CHECK-NEXT:    [[TMP7:%.*]] = icmp sge <2 x i32> [[WIDE_LOAD]], <i32 200, i32 200>\n-; CHECK-NEXT:    [[TMP8:%.*]] = xor <2 x i1> [[TMP6]], <i1 true, i1 true>, !dbg [[DBG33:![0-9]+]]\n-; CHECK-NEXT:    [[TMP9:%.*]] = select <2 x i1> [[TMP8]], <2 x i1> [[TMP7]], <2 x i1> zeroinitializer, !dbg [[DBG34:![0-9]+]]\n+; CHECK-NEXT:    [[TMP8:%.*]] = xor <2 x i1> [[TMP6]], <i1 true, i1 true>, !dbg [[DBG34:![0-9]+]]\n+; CHECK-NEXT:    [[TMP9:%.*]] = select <2 x i1> [[TMP8]], <2 x i1> [[TMP7]], <2 x i1> zeroinitializer, !dbg [[DBG35:![0-9]+]]\n ; CHECK-NEXT:    [[TMP10:%.*]] = or <2 x i1> [[TMP9]], [[TMP6]]\n ; CHECK-NEXT:    [[TMP11:%.*]] = extractelement <2 x i1> [[TMP10]], i32 0\n ; CHECK-NEXT:    br i1 [[TMP11]], label [[PRED_SDIV_IF:%.*]], label [[PRED_SDIV_CONTINUE:%.*]]\n@@ -606,14 +606,14 @@ define void @pr30172(ptr nocapture %asd, ptr nocapture %bsd) !dbg !5 {;\n ; CHECK:       pred.sdiv.continue4:\n ; CHECK-NEXT:    [[TMP27:%.*]] = phi i32 [ poison, [[PRED_SDIV_CONTINUE]] ], [ [[TMP23]], [[PRED_SDIV_IF3]] ]\n ; CHECK-NEXT:    [[TMP28:%.*]] = phi <2 x i32> [ [[TMP19]], [[PRED_SDIV_CONTINUE]] ], [ [[TMP26]], [[PRED_SDIV_IF3]] ]\n-; CHECK-NEXT:    [[TMP29:%.*]] = xor <2 x i1> [[TMP7]], <i1 true, i1 true>, !dbg [[DBG34]]\n-; CHECK-NEXT:    [[TMP30:%.*]] = select <2 x i1> [[TMP8]], <2 x i1> [[TMP29]], <2 x i1> zeroinitializer, !dbg [[DBG34]]\n+; CHECK-NEXT:    [[TMP29:%.*]] = xor <2 x i1> [[TMP7]], <i1 true, i1 true>, !dbg [[DBG35]]\n+; CHECK-NEXT:    [[TMP30:%.*]] = select <2 x i1> [[TMP8]], <2 x i1> [[TMP29]], <2 x i1> zeroinitializer, !dbg [[DBG35]]\n ; CHECK-NEXT:    [[PREDPHI:%.*]] = select <2 x i1> [[TMP30]], <2 x i32> [[TMP5]], <2 x i32> [[TMP28]]\n ; CHECK-NEXT:    [[TMP31:%.*]] = getelementptr inbounds i32, ptr [[TMP1]], i32 0\n-; CHECK-NEXT:    store <2 x i32> [[PREDPHI]], ptr [[TMP31]], align 4, !alias.scope !28, !noalias !31\n+; CHECK-NEXT:    store <2 x i32> [[PREDPHI]], ptr [[TMP31]], align 4, !alias.scope !29, !noalias !32\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 2\n ; CHECK-NEXT:    [[TMP32:%.*]] = icmp eq i64 [[INDEX_NEXT]], 128\n-; CHECK-NEXT:    br i1 [[TMP32]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP35:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP32]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP36:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 128, 128\n ; CHECK-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP:%.*]], label [[SCALAR_PH]]\n@@ -631,8 +631,8 @@ define void @pr30172(ptr nocapture %asd, ptr nocapture %bsd) !dbg !5 {;\n ; CHECK-NEXT:    [[PSD:%.*]] = add nsw i32 [[LSD]], 23\n ; CHECK-NEXT:    [[CMP1:%.*]] = icmp slt i32 [[LSD]], 100\n ; CHECK-NEXT:    [[CMP2:%.*]] = icmp sge i32 [[LSD]], 200\n-; CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP1]], [[CMP2]], !dbg [[DBG33]]\n-; CHECK-NEXT:    br i1 [[OR_COND]], label [[IF_THEN:%.*]], label [[IF_END]], !dbg [[DBG33]]\n+; CHECK-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP1]], [[CMP2]], !dbg [[DBG34]]\n+; CHECK-NEXT:    br i1 [[OR_COND]], label [[IF_THEN:%.*]], label [[IF_END]], !dbg [[DBG34]]\n ; CHECK:       if.then:\n ; CHECK-NEXT:    [[SD1:%.*]] = sdiv i32 [[PSD]], [[LSD]]\n ; CHECK-NEXT:    [[RSD:%.*]] = sdiv i32 [[LSD_B]], [[SD1]]\n@@ -642,7 +642,7 @@ define void @pr30172(ptr nocapture %asd, ptr nocapture %bsd) !dbg !5 {;\n ; CHECK-NEXT:    store i32 [[YSD_0]], ptr [[ISD]], align 4\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 128\n-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP36:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP37:![0-9]+]]\n ;\n ; UNROLL-NO-VF-LABEL: @pr30172(\n ; UNROLL-NO-VF-NEXT:  entry:\n@@ -662,24 +662,24 @@ define void @pr30172(ptr nocapture %asd, ptr nocapture %bsd) !dbg !5 {;\n ; UNROLL-NO-VF-NEXT:    [[TMP1:%.*]] = add i64 [[INDEX]], 1\n ; UNROLL-NO-VF-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i32, ptr [[ASD]], i64 [[TMP0]]\n ; UNROLL-NO-VF-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr [[ASD]], i64 [[TMP1]]\n-; UNROLL-NO-VF-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP2]], align 4, !alias.scope !28, !noalias !31\n-; UNROLL-NO-VF-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP3]], align 4, !alias.scope !28, !noalias !31\n+; UNROLL-NO-VF-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP2]], align 4, !alias.scope !29, !noalias !32\n+; UNROLL-NO-VF-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP3]], align 4, !alias.scope !29, !noalias !32\n ; UNROLL-NO-VF-NEXT:    [[TMP6:%.*]] = add nsw i32 [[TMP4]], 23\n ; UNROLL-NO-VF-NEXT:    [[TMP7:%.*]] = add nsw i32 [[TMP5]], 23\n ; UNROLL-NO-VF-NEXT:    [[TMP8:%.*]] = icmp slt i32 [[TMP4]], 100\n ; UNROLL-NO-VF-NEXT:    [[TMP9:%.*]] = icmp slt i32 [[TMP5]], 100\n ; UNROLL-NO-VF-NEXT:    [[TMP10:%.*]] = icmp sge i32 [[TMP4]], 200\n ; UNROLL-NO-VF-NEXT:    [[TMP11:%.*]] = icmp sge i32 [[TMP5]], 200\n-; UNROLL-NO-VF-NEXT:    [[TMP12:%.*]] = xor i1 [[TMP8]], true, !dbg [[DBG33:![0-9]+]]\n-; UNROLL-NO-VF-NEXT:    [[TMP13:%.*]] = xor i1 [[TMP9]], true, !dbg [[DBG33]]\n-; UNROLL-NO-VF-NEXT:    [[TMP14:%.*]] = select i1 [[TMP12]], i1 [[TMP10]], i1 false, !dbg [[DBG34:![0-9]+]]\n-; UNROLL-NO-VF-NEXT:    [[TMP15:%.*]] = select i1 [[TMP13]], i1 [[TMP11]], i1 false, !dbg [[DBG34]]\n+; UNROLL-NO-VF-NEXT:    [[TMP12:%.*]] = xor i1 [[TMP8]], true, !dbg [[DBG34:![0-9]+]]\n+; UNROLL-NO-VF-NEXT:    [[TMP13:%.*]] = xor i1 [[TMP9]], true, !dbg [[DBG34]]\n+; UNROLL-NO-VF-NEXT:    [[TMP14:%.*]] = select i1 [[TMP12]], i1 [[TMP10]], i1 false, !dbg [[DBG35:![0-9]+]]\n+; UNROLL-NO-VF-NEXT:    [[TMP15:%.*]] = select i1 [[TMP13]], i1 [[TMP11]], i1 false, !dbg [[DBG35]]\n ; UNROLL-NO-VF-NEXT:    [[TMP16:%.*]] = or i1 [[TMP14]], [[TMP8]]\n ; UNROLL-NO-VF-NEXT:    [[TMP17:%.*]] = or i1 [[TMP15]], [[TMP9]]\n ; UNROLL-NO-VF-NEXT:    br i1 [[TMP16]], label [[PRED_SDIV_IF:%.*]], label [[PRED_SDIV_CONTINUE:%.*]]\n ; UNROLL-NO-VF:       pred.sdiv.if:\n ; UNROLL-NO-VF-NEXT:    [[TMP18:%.*]] = getelementptr inbounds i32, ptr [[BSD]], i64 [[TMP0]]\n-; UNROLL-NO-VF-NEXT:    [[TMP19:%.*]] = load i32, ptr [[TMP18]], align 4, !alias.scope !31\n+; UNROLL-NO-VF-NEXT:    [[TMP19:%.*]] = load i32, ptr [[TMP18]], align 4, !alias.scope !32\n ; UNROLL-NO-VF-NEXT:    [[TMP20:%.*]] = sdiv i32 [[TMP6]], [[TMP4]]\n ; UNROLL-NO-VF-NEXT:    [[TMP21:%.*]] = sdiv i32 [[TMP19]], [[TMP20]]\n ; UNROLL-NO-VF-NEXT:    br label [[PRED_SDIV_CONTINUE]]\n@@ -689,24 +689,24 @@ define void @pr30172(ptr nocapture %asd, ptr nocapture %bsd) !dbg !5 {;\n ; UNROLL-NO-VF-NEXT:    br i1 [[TMP17]], label [[PRED_SDIV_IF2:%.*]], label [[PRED_SDIV_CONTINUE3]]\n ; UNROLL-NO-VF:       pred.sdiv.if2:\n ; UNROLL-NO-VF-NEXT:    [[TMP24:%.*]] = getelementptr inbounds i32, ptr [[BSD]], i64 [[TMP1]]\n-; UNROLL-NO-VF-NEXT:    [[TMP25:%.*]] = load i32, ptr [[TMP24]], align 4, !alias.scope !31\n+; UNROLL-NO-VF-NEXT:    [[TMP25:%.*]] = load i32, ptr [[TMP24]], align 4, !alias.scope !32\n ; UNROLL-NO-VF-NEXT:    [[TMP26:%.*]] = sdiv i32 [[TMP7]], [[TMP5]]\n ; UNROLL-NO-VF-NEXT:    [[TMP27:%.*]] = sdiv i32 [[TMP25]], [[TMP26]]\n ; UNROLL-NO-VF-NEXT:    br label [[PRED_SDIV_CONTINUE3]]\n ; UNROLL-NO-VF:       pred.sdiv.continue3:\n ; UNROLL-NO-VF-NEXT:    [[TMP28:%.*]] = phi i32 [ poison, [[PRED_SDIV_CONTINUE]] ], [ [[TMP26]], [[PRED_SDIV_IF2]] ]\n ; UNROLL-NO-VF-NEXT:    [[TMP29:%.*]] = phi i32 [ poison, [[PRED_SDIV_CONTINUE]] ], [ [[TMP27]], [[PRED_SDIV_IF2]] ]\n-; UNROLL-NO-VF-NEXT:    [[TMP30:%.*]] = xor i1 [[TMP10]], true, !dbg [[DBG34]]\n-; UNROLL-NO-VF-NEXT:    [[TMP31:%.*]] = xor i1 [[TMP11]], true, !dbg [[DBG34]]\n-; UNROLL-NO-VF-NEXT:    [[TMP32:%.*]] = select i1 [[TMP12]], i1 [[TMP30]], i1 false, !dbg [[DBG34]]\n-; UNROLL-NO-VF-NEXT:    [[TMP33:%.*]] = select i1 [[TMP13]], i1 [[TMP31]], i1 false, !dbg [[DBG34]]\n+; UNROLL-NO-VF-NEXT:    [[TMP30:%.*]] = xor i1 [[TMP10]], true, !dbg [[DBG35]]\n+; UNROLL-NO-VF-NEXT:    [[TMP31:%.*]] = xor i1 [[TMP11]], true, !dbg [[DBG35]]\n+; UNROLL-NO-VF-NEXT:    [[TMP32:%.*]] = select i1 [[TMP12]], i1 [[TMP30]], i1 false, !dbg [[DBG35]]\n+; UNROLL-NO-VF-NEXT:    [[TMP33:%.*]] = select i1 [[TMP13]], i1 [[TMP31]], i1 false, !dbg [[DBG35]]\n ; UNROLL-NO-VF-NEXT:    [[PREDPHI:%.*]] = select i1 [[TMP32]], i32 [[TMP6]], i32 [[TMP23]]\n ; UNROLL-NO-VF-NEXT:    [[PREDPHI4:%.*]] = select i1 [[TMP33]], i32 [[TMP7]], i32 [[TMP29]]\n-; UNROLL-NO-VF-NEXT:    store i32 [[PREDPHI]], ptr [[TMP2]], align 4, !alias.scope !28, !noalias !31\n-; UNROLL-NO-VF-NEXT:    store i32 [[PREDPHI4]], ptr [[TMP3]], align 4, !alias.scope !28, !noalias !31\n+; UNROLL-NO-VF-NEXT:    store i32 [[PREDPHI]], ptr [[TMP2]], align 4, !alias.scope !29, !noalias !32\n+; UNROLL-NO-VF-NEXT:    store i32 [[PREDPHI4]], ptr [[TMP3]], align 4, !alias.scope !29, !noalias !32\n ; UNROLL-NO-VF-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 2\n ; UNROLL-NO-VF-NEXT:    [[TMP34:%.*]] = icmp eq i64 [[INDEX_NEXT]], 128\n-; UNROLL-NO-VF-NEXT:    br i1 [[TMP34]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP35:![0-9]+]]\n+; UNROLL-NO-VF-NEXT:    br i1 [[TMP34]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP36:![0-9]+]]\n ; UNROLL-NO-VF:       middle.block:\n ; UNROLL-NO-VF-NEXT:    [[CMP_N:%.*]] = icmp eq i64 128, 128\n ; UNROLL-NO-VF-NEXT:    br i1 [[CMP_N]], label [[FOR_COND_CLEANUP:%.*]], label [[SCALAR_PH]]\n@@ -723,10 +723,10 @@ define void @pr30172(ptr nocapture %asd, ptr nocapture %bsd) !dbg !5 {;\n ; UNROLL-NO-VF-NEXT:    [[LSD_B:%.*]] = load i32, ptr [[ISD_B]], align 4\n ; UNROLL-NO-VF-NEXT:    [[PSD:%.*]] = add nsw i32 [[LSD]], 23\n ; UNROLL-NO-VF-NEXT:    [[CMP1:%.*]] = icmp slt i32 [[LSD]], 100\n-; UNROLL-NO-VF-NEXT:    br i1 [[CMP1]], label [[IF_THEN:%.*]], label [[CHECKBB:%.*]], !dbg [[DBG33]]\n+; UNROLL-NO-VF-NEXT:    br i1 [[CMP1]], label [[IF_THEN:%.*]], label [[CHECKBB:%.*]], !dbg [[DBG34]]\n ; UNROLL-NO-VF:       checkbb:\n ; UNROLL-NO-VF-NEXT:    [[CMP2:%.*]] = icmp sge i32 [[LSD]], 200\n-; UNROLL-NO-VF-NEXT:    br i1 [[CMP2]], label [[IF_THEN]], label [[IF_END]], !dbg [[DBG34]]\n+; UNROLL-NO-VF-NEXT:    br i1 [[CMP2]], label [[IF_THEN]], label [[IF_END]], !dbg [[DBG35]]\n ; UNROLL-NO-VF:       if.then:\n ; UNROLL-NO-VF-NEXT:    [[SD1:%.*]] = sdiv i32 [[PSD]], [[LSD]]\n ; UNROLL-NO-VF-NEXT:    [[RSD:%.*]] = sdiv i32 [[LSD_B]], [[SD1]]\n@@ -736,7 +736,7 @@ define void @pr30172(ptr nocapture %asd, ptr nocapture %bsd) !dbg !5 {;\n ; UNROLL-NO-VF-NEXT:    store i32 [[YSD_0]], ptr [[ISD]], align 4\n ; UNROLL-NO-VF-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; UNROLL-NO-VF-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 128\n-; UNROLL-NO-VF-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP36:![0-9]+]]\n+; UNROLL-NO-VF-NEXT:    br i1 [[EXITCOND]], label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP37:![0-9]+]]\n ;\n entry:\n   br label %for.body\n@@ -817,7 +817,7 @@ define i32 @predicated_udiv_scalarized_operand(ptr %a, i1 %c, i32 %x, i64 %n) {\n ; CHECK-NEXT:    [[TMP18]] = add <2 x i32> [[VEC_PHI]], [[PREDPHI]]\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 2\n ; CHECK-NEXT:    [[TMP19:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n-; CHECK-NEXT:    br i1 [[TMP19]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP37:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP19]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP38:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[TMP20:%.*]] = call i32 @llvm.vector.reduce.add.v2i32(<2 x i32> [[TMP18]])\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[SMAX]], [[N_VEC]]\n@@ -841,7 +841,7 @@ define i32 @predicated_udiv_scalarized_operand(ptr %a, i1 %c, i32 %x, i64 %n) {\n ; CHECK-NEXT:    [[T6]] = add i32 [[R]], [[T5]]\n ; CHECK-NEXT:    [[I_NEXT]] = add nuw nsw i64 [[I]], 1\n ; CHECK-NEXT:    [[COND:%.*]] = icmp slt i64 [[I_NEXT]], [[N]]\n-; CHECK-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END]], !llvm.loop [[LOOP38:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END]], !llvm.loop [[LOOP39:![0-9]+]]\n ; CHECK:       for.end:\n ; CHECK-NEXT:    [[T7:%.*]] = phi i32 [ [[T6]], [[FOR_INC]] ], [ [[TMP20]], [[MIDDLE_BLOCK]] ]\n ; CHECK-NEXT:    ret i32 [[T7]]\n@@ -887,7 +887,7 @@ define i32 @predicated_udiv_scalarized_operand(ptr %a, i1 %c, i32 %x, i64 %n) {\n ; UNROLL-NO-VF-NEXT:    [[TMP15]] = add i32 [[VEC_PHI1]], [[PREDPHI4]]\n ; UNROLL-NO-VF-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 2\n ; UNROLL-NO-VF-NEXT:    [[TMP16:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n-; UNROLL-NO-VF-NEXT:    br i1 [[TMP16]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP37:![0-9]+]]\n+; UNROLL-NO-VF-NEXT:    br i1 [[TMP16]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP38:![0-9]+]]\n ; UNROLL-NO-VF:       middle.block:\n ; UNROLL-NO-VF-NEXT:    [[BIN_RDX:%.*]] = add i32 [[TMP15]], [[TMP14]]\n ; UNROLL-NO-VF-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[SMAX]], [[N_VEC]]\n@@ -911,7 +911,7 @@ define i32 @predicated_udiv_scalarized_operand(ptr %a, i1 %c, i32 %x, i64 %n) {\n ; UNROLL-NO-VF-NEXT:    [[T6]] = add i32 [[R]], [[T5]]\n ; UNROLL-NO-VF-NEXT:    [[I_NEXT]] = add nuw nsw i64 [[I]], 1\n ; UNROLL-NO-VF-NEXT:    [[COND:%.*]] = icmp slt i64 [[I_NEXT]], [[N]]\n-; UNROLL-NO-VF-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END]], !llvm.loop [[LOOP38:![0-9]+]]\n+; UNROLL-NO-VF-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END]], !llvm.loop [[LOOP39:![0-9]+]]\n ; UNROLL-NO-VF:       for.end:\n ; UNROLL-NO-VF-NEXT:    [[T7:%.*]] = phi i32 [ [[T6]], [[FOR_INC]] ], [ [[BIN_RDX]], [[MIDDLE_BLOCK]] ]\n ; UNROLL-NO-VF-NEXT:    ret i32 [[T7]]"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/induction.ll",
                "patch": "@@ -50,7 +50,7 @@ define void @multi_int_induction(ptr %A, i32 %N) {\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add i64 [[INDVARS_IV]], 1\n ; CHECK-NEXT:    [[LFTR_WIDEIV:%.*]] = trunc i64 [[INDVARS_IV_NEXT]] to i32\n ; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[LFTR_WIDEIV]], [[N]]\n-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY]], label [[FOR_END]], !llvm.loop [[LOOP2:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY]], label [[FOR_END]], !llvm.loop [[LOOP3:![0-9]+]]\n ; CHECK:       for.end:\n ; CHECK-NEXT:    ret void\n ;\n@@ -91,7 +91,7 @@ define void @multi_int_induction(ptr %A, i32 %N) {\n ; IND-NEXT:    [[INDVARS_IV_NEXT]] = add i64 [[INDVARS_IV]], 1\n ; IND-NEXT:    [[LFTR_WIDEIV:%.*]] = trunc i64 [[INDVARS_IV_NEXT]] to i32\n ; IND-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[LFTR_WIDEIV]], [[N]]\n-; IND-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP2:![0-9]+]]\n+; IND-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ; IND:       for.end:\n ; IND-NEXT:    ret void\n ;\n@@ -135,7 +135,7 @@ define void @multi_int_induction(ptr %A, i32 %N) {\n ; UNROLL-NEXT:    [[INDVARS_IV_NEXT]] = add i64 [[INDVARS_IV]], 1\n ; UNROLL-NEXT:    [[LFTR_WIDEIV:%.*]] = trunc i64 [[INDVARS_IV_NEXT]] to i32\n ; UNROLL-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[LFTR_WIDEIV]], [[N]]\n-; UNROLL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP2:![0-9]+]]\n+; UNROLL-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ; UNROLL:       for.end:\n ; UNROLL-NEXT:    ret void\n ;\n@@ -184,7 +184,7 @@ define void @multi_int_induction(ptr %A, i32 %N) {\n ; UNROLL-NO-IC-NEXT:    [[INDVARS_IV_NEXT]] = add i64 [[INDVARS_IV]], 1\n ; UNROLL-NO-IC-NEXT:    [[LFTR_WIDEIV:%.*]] = trunc i64 [[INDVARS_IV_NEXT]] to i32\n ; UNROLL-NO-IC-NEXT:    [[EXITCOND:%.*]] = icmp ne i32 [[LFTR_WIDEIV]], [[N]]\n-; UNROLL-NO-IC-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY]], label [[FOR_END]], !llvm.loop [[LOOP2:![0-9]+]]\n+; UNROLL-NO-IC-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY]], label [[FOR_END]], !llvm.loop [[LOOP3:![0-9]+]]\n ; UNROLL-NO-IC:       for.end:\n ; UNROLL-NO-IC-NEXT:    ret void\n ;\n@@ -228,7 +228,7 @@ define void @multi_int_induction(ptr %A, i32 %N) {\n ; INTERLEAVE-NEXT:    [[INDVARS_IV_NEXT]] = add i64 [[INDVARS_IV]], 1\n ; INTERLEAVE-NEXT:    [[LFTR_WIDEIV:%.*]] = trunc i64 [[INDVARS_IV_NEXT]] to i32\n ; INTERLEAVE-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i32 [[LFTR_WIDEIV]], [[N]]\n-; INTERLEAVE-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP2:![0-9]+]]\n+; INTERLEAVE-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ; INTERLEAVE:       for.end:\n ; INTERLEAVE-NEXT:    ret void\n ;"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/interleaved-accesses.ll",
                "patch": "@@ -55,7 +55,7 @@ define void @test_array_load2_store2(i32 %C, i32 %D) {\n ; CHECK:       scalar.ph:\n ; CHECK-NEXT:    br label [[FOR_BODY:%.*]]\n ; CHECK:       for.body:\n-; CHECK-NEXT:    br i1 poison, label [[FOR_BODY]], label [[FOR_END]], !llvm.loop [[LOOP2:![0-9]+]]\n+; CHECK-NEXT:    br i1 poison, label [[FOR_BODY]], label [[FOR_END]], !llvm.loop [[LOOP3:![0-9]+]]\n ; CHECK:       for.end:\n ; CHECK-NEXT:    ret void\n ;"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/invariant-store-vectorization-2.ll",
                "patch": "@@ -74,7 +74,7 @@ define void @inv_val_store_to_inv_address_conditional_diff_values_ic(ptr %a, i64\n ; CHECK-NEXT:    store i32 [[STOREVAL]], ptr [[A]], align 4\n ; CHECK-NEXT:    [[I_NEXT]] = add nuw nsw i64 [[I]], 1\n ; CHECK-NEXT:    [[COND:%.*]] = icmp slt i64 [[I_NEXT]], [[N]]\n-; CHECK-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END_LOOPEXIT:%.*]], !llvm.loop [[LOOP7:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END_LOOPEXIT:%.*]], !llvm.loop [[LOOP8:![0-9]+]]\n ; CHECK:       for.end.loopexit:\n ; CHECK-NEXT:    br label [[FOR_END]]\n ; CHECK:       for.end:\n@@ -146,11 +146,11 @@ define void @inv_val_store_to_inv_address_conditional_inv(ptr %a, i64 %n, ptr %b\n ; CHECK:       vector.body:\n ; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]\n ; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i32, ptr [[B]], i64 [[INDEX]]\n-; CHECK-NEXT:    store <4 x i32> [[BROADCAST_SPLAT]], ptr [[TMP3]], align 4, !alias.scope !8, !noalias !11\n-; CHECK-NEXT:    store i32 [[TMP2]], ptr [[A]], align 4, !alias.scope !11\n+; CHECK-NEXT:    store <4 x i32> [[BROADCAST_SPLAT]], ptr [[TMP3]], align 4, !alias.scope !9, !noalias !12\n+; CHECK-NEXT:    store i32 [[TMP2]], ptr [[A]], align 4, !alias.scope !12\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 4\n ; CHECK-NEXT:    [[TMP4:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n-; CHECK-NEXT:    br i1 [[TMP4]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP13:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP4]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP14:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[SMAX2]], [[N_VEC]]\n ; CHECK-NEXT:    br i1 [[CMP_N]], label [[FOR_END:%.*]], label [[SCALAR_PH]]\n@@ -171,7 +171,7 @@ define void @inv_val_store_to_inv_address_conditional_inv(ptr %a, i64 %n, ptr %b\n ; CHECK-NEXT:    store i32 [[STOREVAL]], ptr [[A]], align 4\n ; CHECK-NEXT:    [[I_NEXT]] = add nuw nsw i64 [[I]], 1\n ; CHECK-NEXT:    [[COND:%.*]] = icmp slt i64 [[I_NEXT]], [[N]]\n-; CHECK-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END_LOOPEXIT:%.*]], !llvm.loop [[LOOP14:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END_LOOPEXIT:%.*]], !llvm.loop [[LOOP15:![0-9]+]]\n ; CHECK:       for.end.loopexit:\n ; CHECK-NEXT:    br label [[FOR_END]]\n ; CHECK:       for.end:\n@@ -231,13 +231,13 @@ define i32 @variant_val_store_to_inv_address(ptr %a, i64 %n, ptr %b, i32 %k) {\n ; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]\n ; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <4 x i32> [ zeroinitializer, [[VECTOR_PH]] ], [ [[TMP3:%.*]], [[VECTOR_BODY]] ]\n ; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i32, ptr [[B]], i64 [[INDEX]]\n-; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i32>, ptr [[TMP1]], align 8, !alias.scope !15\n+; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i32>, ptr [[TMP1]], align 8, !alias.scope !16\n ; CHECK-NEXT:    [[TMP2:%.*]] = extractelement <4 x i32> [[WIDE_LOAD]], i64 3\n-; CHECK-NEXT:    store i32 [[TMP2]], ptr [[A]], align 4, !alias.scope !18, !noalias !15\n+; CHECK-NEXT:    store i32 [[TMP2]], ptr [[A]], align 4, !alias.scope !19, !noalias !16\n ; CHECK-NEXT:    [[TMP3]] = add <4 x i32> [[VEC_PHI]], [[WIDE_LOAD]]\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 4\n ; CHECK-NEXT:    [[TMP4:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n-; CHECK-NEXT:    br i1 [[TMP4]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP20:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP4]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP21:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[DOTLCSSA:%.*]] = phi <4 x i32> [ [[TMP3]], [[VECTOR_BODY]] ]\n ; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> [[DOTLCSSA]])\n@@ -256,7 +256,7 @@ define i32 @variant_val_store_to_inv_address(ptr %a, i64 %n, ptr %b, i32 %k) {\n ; CHECK-NEXT:    [[I3]] = add i32 [[I0]], [[I2]]\n ; CHECK-NEXT:    [[I_NEXT]] = add nuw nsw i64 [[I]], 1\n ; CHECK-NEXT:    [[COND:%.*]] = icmp slt i64 [[I_NEXT]], [[N]]\n-; CHECK-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END_LOOPEXIT:%.*]], !llvm.loop [[LOOP21:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END_LOOPEXIT:%.*]], !llvm.loop [[LOOP22:![0-9]+]]\n ; CHECK:       for.end.loopexit:\n ; CHECK-NEXT:    [[I3_LCSSA:%.*]] = phi i32 [ [[I3]], [[FOR_BODY]] ]\n ; CHECK-NEXT:    br label [[FOR_END]]"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/invariant-store-vectorization.ll",
                "patch": "@@ -63,7 +63,7 @@ define i32 @inv_val_store_to_inv_address_with_reduction(ptr %a, i64 %n, ptr %b)\n ; CHECK-NEXT:    store i32 [[NTRUNC]], ptr [[A]], align 4\n ; CHECK-NEXT:    [[I_NEXT]] = add nuw nsw i64 [[I]], 1\n ; CHECK-NEXT:    [[COND:%.*]] = icmp slt i64 [[I_NEXT]], [[N]]\n-; CHECK-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END_LOOPEXIT:%.*]], !llvm.loop [[LOOP7:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END_LOOPEXIT:%.*]], !llvm.loop [[LOOP8:![0-9]+]]\n ; CHECK:       for.end.loopexit:\n ; CHECK-NEXT:    [[I3_LCSSA:%.*]] = phi i32 [ [[I3]], [[FOR_BODY]] ]\n ; CHECK-NEXT:    br label [[FOR_END]]\n@@ -115,11 +115,11 @@ define void @inv_val_store_to_inv_address(ptr %a, i64 %n, ptr %b) {\n ; CHECK:       vector.body:\n ; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]\n ; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i32, ptr [[B]], i64 [[INDEX]]\n-; CHECK-NEXT:    store i32 [[NTRUNC]], ptr [[A]], align 4, !alias.scope !8, !noalias !11\n-; CHECK-NEXT:    store <4 x i32> [[BROADCAST_SPLAT]], ptr [[TMP1]], align 4, !alias.scope !11\n+; CHECK-NEXT:    store i32 [[NTRUNC]], ptr [[A]], align 4, !alias.scope !9, !noalias !12\n+; CHECK-NEXT:    store <4 x i32> [[BROADCAST_SPLAT]], ptr [[TMP1]], align 4, !alias.scope !12\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 4\n ; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n-; CHECK-NEXT:    br i1 [[TMP2]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP13:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP2]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP14:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[SMAX2]], [[N_VEC]]\n ; CHECK-NEXT:    br i1 [[CMP_N]], label [[FOR_END:%.*]], label [[SCALAR_PH]]\n@@ -133,7 +133,7 @@ define void @inv_val_store_to_inv_address(ptr %a, i64 %n, ptr %b) {\n ; CHECK-NEXT:    store i32 [[NTRUNC]], ptr [[I1]], align 4\n ; CHECK-NEXT:    [[I_NEXT]] = add nuw nsw i64 [[I]], 1\n ; CHECK-NEXT:    [[COND:%.*]] = icmp slt i64 [[I_NEXT]], [[N]]\n-; CHECK-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END_LOOPEXIT:%.*]], !llvm.loop [[LOOP14:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END_LOOPEXIT:%.*]], !llvm.loop [[LOOP15:![0-9]+]]\n ; CHECK:       for.end.loopexit:\n ; CHECK-NEXT:    br label [[FOR_END]]\n ; CHECK:       for.end:\n@@ -193,36 +193,36 @@ define void @inv_val_store_to_inv_address_conditional(ptr %a, i64 %n, ptr %b, i3\n ; CHECK:       vector.body:\n ; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[PRED_STORE_CONTINUE10:%.*]] ]\n ; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i32, ptr [[B]], i64 [[INDEX]]\n-; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i32>, ptr [[TMP1]], align 8, !alias.scope !15, !noalias !18\n+; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i32>, ptr [[TMP1]], align 8, !alias.scope !16, !noalias !19\n ; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq <4 x i32> [[WIDE_LOAD]], [[BROADCAST_SPLAT]]\n-; CHECK-NEXT:    store <4 x i32> [[BROADCAST_SPLAT4]], ptr [[TMP1]], align 4, !alias.scope !15, !noalias !18\n+; CHECK-NEXT:    store <4 x i32> [[BROADCAST_SPLAT4]], ptr [[TMP1]], align 4, !alias.scope !16, !noalias !19\n ; CHECK-NEXT:    [[TMP3:%.*]] = extractelement <4 x i1> [[TMP2]], i64 0\n ; CHECK-NEXT:    br i1 [[TMP3]], label [[PRED_STORE_IF:%.*]], label [[PRED_STORE_CONTINUE:%.*]]\n ; CHECK:       pred.store.if:\n-; CHECK-NEXT:    store i32 [[NTRUNC]], ptr [[A]], align 4, !alias.scope !18\n+; CHECK-NEXT:    store i32 [[NTRUNC]], ptr [[A]], align 4, !alias.scope !19\n ; CHECK-NEXT:    br label [[PRED_STORE_CONTINUE]]\n ; CHECK:       pred.store.continue:\n ; CHECK-NEXT:    [[TMP4:%.*]] = extractelement <4 x i1> [[TMP2]], i64 1\n ; CHECK-NEXT:    br i1 [[TMP4]], label [[PRED_STORE_IF5:%.*]], label [[PRED_STORE_CONTINUE6:%.*]]\n ; CHECK:       pred.store.if5:\n-; CHECK-NEXT:    store i32 [[NTRUNC]], ptr [[A]], align 4, !alias.scope !18\n+; CHECK-NEXT:    store i32 [[NTRUNC]], ptr [[A]], align 4, !alias.scope !19\n ; CHECK-NEXT:    br label [[PRED_STORE_CONTINUE6]]\n ; CHECK:       pred.store.continue6:\n ; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <4 x i1> [[TMP2]], i64 2\n ; CHECK-NEXT:    br i1 [[TMP5]], label [[PRED_STORE_IF7:%.*]], label [[PRED_STORE_CONTINUE8:%.*]]\n ; CHECK:       pred.store.if7:\n-; CHECK-NEXT:    store i32 [[NTRUNC]], ptr [[A]], align 4, !alias.scope !18\n+; CHECK-NEXT:    store i32 [[NTRUNC]], ptr [[A]], align 4, !alias.scope !19\n ; CHECK-NEXT:    br label [[PRED_STORE_CONTINUE8]]\n ; CHECK:       pred.store.continue8:\n ; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <4 x i1> [[TMP2]], i64 3\n ; CHECK-NEXT:    br i1 [[TMP6]], label [[PRED_STORE_IF9:%.*]], label [[PRED_STORE_CONTINUE10]]\n ; CHECK:       pred.store.if9:\n-; CHECK-NEXT:    store i32 [[NTRUNC]], ptr [[A]], align 4, !alias.scope !18\n+; CHECK-NEXT:    store i32 [[NTRUNC]], ptr [[A]], align 4, !alias.scope !19\n ; CHECK-NEXT:    br label [[PRED_STORE_CONTINUE10]]\n ; CHECK:       pred.store.continue10:\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 4\n ; CHECK-NEXT:    [[TMP7:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n-; CHECK-NEXT:    br i1 [[TMP7]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP20:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP7]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP21:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[SMAX2]], [[N_VEC]]\n ; CHECK-NEXT:    br i1 [[CMP_N]], label [[FOR_END:%.*]], label [[SCALAR_PH]]\n@@ -242,7 +242,7 @@ define void @inv_val_store_to_inv_address_conditional(ptr %a, i64 %n, ptr %b, i3\n ; CHECK:       latch:\n ; CHECK-NEXT:    [[I_NEXT]] = add nuw nsw i64 [[I]], 1\n ; CHECK-NEXT:    [[COND:%.*]] = icmp slt i64 [[I_NEXT]], [[N]]\n-; CHECK-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END_LOOPEXIT:%.*]], !llvm.loop [[LOOP21:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[COND]], label [[FOR_BODY]], label [[FOR_END_LOOPEXIT:%.*]], !llvm.loop [[LOOP22:![0-9]+]]\n ; CHECK:       for.end.loopexit:\n ; CHECK-NEXT:    br label [[FOR_END]]\n ; CHECK:       for.end:\n@@ -390,12 +390,12 @@ define i32 @multiple_uniform_stores(ptr nocapture %var1, ptr nocapture readonly\n ; CHECK-NEXT:    [[VEC_PHI:%.*]] = phi <4 x i32> [ [[TMP13]], [[VECTOR_PH]] ], [ [[TMP16:%.*]], [[VECTOR_BODY]] ]\n ; CHECK-NEXT:    [[OFFSET_IDX:%.*]] = add i64 [[INDEX]], [[TMP2]]\n ; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr inbounds i32, ptr [[VAR2]], i64 [[OFFSET_IDX]]\n-; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i32>, ptr [[TMP14]], align 4, !alias.scope !22\n+; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i32>, ptr [[TMP14]], align 4, !alias.scope !23\n ; CHECK-NEXT:    [[TMP15:%.*]] = add <4 x i32> [[VEC_PHI]], [[WIDE_LOAD]]\n ; CHECK-NEXT:    [[TMP16]] = add <4 x i32> [[TMP15]], <i32 1, i32 1, i32 1, i32 1>\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 4\n ; CHECK-NEXT:    [[TMP17:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n-; CHECK-NEXT:    br i1 [[TMP17]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP25:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP17]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP26:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[DOTLCSSA:%.*]] = phi <4 x i32> [ [[TMP16]], [[VECTOR_BODY]] ]\n ; CHECK-NEXT:    [[TMP18:%.*]] = call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> [[DOTLCSSA]])\n@@ -417,7 +417,7 @@ define i32 @multiple_uniform_stores(ptr nocapture %var1, ptr nocapture readonly\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; CHECK-NEXT:    [[LFTR_WIDEIV:%.*]] = trunc i64 [[INDVARS_IV_NEXT]] to i32\n ; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[LFTR_WIDEIV]], [[ITR]]\n-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_INC8_LOOPEXIT_LOOPEXIT:%.*]], label [[FOR_BODY3]], !llvm.loop [[LOOP26:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_INC8_LOOPEXIT_LOOPEXIT:%.*]], label [[FOR_BODY3]], !llvm.loop [[LOOP27:![0-9]+]]\n ; CHECK:       for.inc8.loopexit.loopexit:\n ; CHECK-NEXT:    br label [[FOR_INC8_LOOPEXIT]]\n ; CHECK:       for.inc8.loopexit:"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/memdep-fold-tail.ll",
                "patch": "@@ -67,7 +67,7 @@ define void @maxvf3() {\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add i32 [[INDEX]], 2\n ; CHECK-NEXT:    [[VEC_IND_NEXT]] = add <2 x i32> [[VEC_IND]], <i32 2, i32 2>\n ; CHECK-NEXT:    [[TMP14:%.*]] = icmp eq i32 [[INDEX_NEXT]], 16\n-; CHECK-NEXT:    br i1 [[TMP14]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop !0\n+; CHECK-NEXT:    br i1 [[TMP14]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    br i1 true, label [[FOR_END:%.*]], label [[SCALAR_PH]]\n ; CHECK:       scalar.ph:\n@@ -82,7 +82,7 @@ define void @maxvf3() {\n ; CHECK-NEXT:    store i8 7, ptr [[AJP3]], align 8\n ; CHECK-NEXT:    [[J_NEXT]] = add nuw nsw i32 [[J]], 1\n ; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[J_NEXT]], 15\n-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop !2\n+; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ; CHECK:       for.end:\n ; CHECK-NEXT:    ret void\n ;"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/optsize.ll",
                "patch": "@@ -253,7 +253,7 @@ define void @stride1(ptr noalias %B, i32 %BStride) optsize {\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add i32 [[INDEX]], 2\n ; CHECK-NEXT:    [[VEC_IND_NEXT]] = add <2 x i32> [[VEC_IND]], <i32 2, i32 2>\n ; CHECK-NEXT:    [[TMP8:%.*]] = icmp eq i32 [[INDEX_NEXT]], 1026\n-; CHECK-NEXT:    br i1 [[TMP8]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop !21\n+; CHECK-NEXT:    br i1 [[TMP8]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    br i1 true, label [[FOR_END:%.*]], label [[SCALAR_PH]]\n ; CHECK:       scalar.ph:"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/pointer-select-runtime-checks.ll",
                "patch": "@@ -51,7 +51,7 @@ define void @test1_select_invariant(ptr %src.1, ptr %src.2, ptr %dst, i1 %c, i8\n ; CHECK-NEXT:    store i8 [[L_1]], ptr [[GEP_DST]], align 2\n ; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i8 [[IV]], 1\n ; CHECK-NEXT:    [[EC:%.*]] = icmp eq i8 [[IV_NEXT]], [[N]]\n-; CHECK-NEXT:    br i1 [[EC]], label [[EXIT]], label [[LOOP]], !llvm.loop [[LOOP7:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EC]], label [[EXIT]], label [[LOOP]], !llvm.loop [[LOOP8:![0-9]+]]\n ; CHECK:       exit:\n ; CHECK-NEXT:    ret void\n ;\n@@ -118,7 +118,7 @@ define void @test_loop_dependent_select1(ptr %src.1, ptr %src.2, ptr %dst, i1 %c\n ; CHECK-NEXT:    store i8 [[TMP12]], ptr [[TMP14]], align 2\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 2\n ; CHECK-NEXT:    [[TMP15:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]\n-; CHECK-NEXT:    br i1 [[TMP15]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP8:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP15]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP9:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i32 [[TMP2]], [[N_VEC]]\n ; CHECK-NEXT:    br i1 [[CMP_N]], label [[EXIT:%.*]], label [[SCALAR_PH]]\n@@ -135,7 +135,7 @@ define void @test_loop_dependent_select1(ptr %src.1, ptr %src.2, ptr %dst, i1 %c\n ; CHECK-NEXT:    store i8 [[L_1]], ptr [[GEP_DST]], align 2\n ; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i8 [[IV]], 1\n ; CHECK-NEXT:    [[EC:%.*]] = icmp eq i8 [[IV_NEXT]], [[N]]\n-; CHECK-NEXT:    br i1 [[EC]], label [[EXIT]], label [[LOOP]], !llvm.loop [[LOOP9:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EC]], label [[EXIT]], label [[LOOP]], !llvm.loop [[LOOP10:![0-9]+]]\n ; CHECK:       exit:\n ; CHECK-NEXT:    ret void\n ;\n@@ -200,15 +200,15 @@ define void @test_loop_dependent_select2(ptr %src.1, ptr %src.2, ptr %dst, i8 %n\n ; CHECK-NEXT:    [[TMP7:%.*]] = icmp ult i8 [[INDUCTION6]], [[X]]\n ; CHECK-NEXT:    [[TMP8:%.*]] = select i1 [[TMP6]], ptr [[SRC_1]], ptr [[SRC_2]]\n ; CHECK-NEXT:    [[TMP9:%.*]] = select i1 [[TMP7]], ptr [[SRC_1]], ptr [[SRC_2]]\n-; CHECK-NEXT:    [[TMP10:%.*]] = load i8, ptr [[TMP8]], align 8, !alias.scope !10\n-; CHECK-NEXT:    [[TMP11:%.*]] = load i8, ptr [[TMP9]], align 8, !alias.scope !10\n+; CHECK-NEXT:    [[TMP10:%.*]] = load i8, ptr [[TMP8]], align 8, !alias.scope !11\n+; CHECK-NEXT:    [[TMP11:%.*]] = load i8, ptr [[TMP9]], align 8, !alias.scope !11\n ; CHECK-NEXT:    [[TMP12:%.*]] = getelementptr i8, ptr [[DST]], i8 [[INDUCTION]]\n ; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr i8, ptr [[DST]], i8 [[INDUCTION6]]\n-; CHECK-NEXT:    store i8 [[TMP10]], ptr [[TMP12]], align 2, !alias.scope !13, !noalias !15\n-; CHECK-NEXT:    store i8 [[TMP11]], ptr [[TMP13]], align 2, !alias.scope !13, !noalias !15\n+; CHECK-NEXT:    store i8 [[TMP10]], ptr [[TMP12]], align 2, !alias.scope !14, !noalias !16\n+; CHECK-NEXT:    store i8 [[TMP11]], ptr [[TMP13]], align 2, !alias.scope !14, !noalias !16\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 2\n ; CHECK-NEXT:    [[TMP14:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]\n-; CHECK-NEXT:    br i1 [[TMP14]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP17:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP14]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP18:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i32 [[TMP2]], [[N_VEC]]\n ; CHECK-NEXT:    br i1 [[CMP_N]], label [[EXIT:%.*]], label [[SCALAR_PH]]\n@@ -224,7 +224,7 @@ define void @test_loop_dependent_select2(ptr %src.1, ptr %src.2, ptr %dst, i8 %n\n ; CHECK-NEXT:    store i8 [[L_1]], ptr [[GEP_DST]], align 2\n ; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i8 [[IV]], 1\n ; CHECK-NEXT:    [[EC:%.*]] = icmp eq i8 [[IV_NEXT]], [[N]]\n-; CHECK-NEXT:    br i1 [[EC]], label [[EXIT]], label [[LOOP]], !llvm.loop [[LOOP18:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EC]], label [[EXIT]], label [[LOOP]], !llvm.loop [[LOOP19:![0-9]+]]\n ; CHECK:       exit:\n ; CHECK-NEXT:    ret void\n ;\n@@ -285,15 +285,15 @@ define void @test_loop_dependent_select_first_ptr_noundef(ptr noundef %src.1, pt\n ; CHECK-NEXT:    [[TMP7:%.*]] = icmp ult i8 [[INDUCTION6]], [[X]]\n ; CHECK-NEXT:    [[TMP8:%.*]] = select i1 [[TMP6]], ptr [[SRC_1]], ptr [[SRC_2]]\n ; CHECK-NEXT:    [[TMP9:%.*]] = select i1 [[TMP7]], ptr [[SRC_1]], ptr [[SRC_2]]\n-; CHECK-NEXT:    [[TMP10:%.*]] = load i8, ptr [[TMP8]], align 8, !alias.scope !19\n-; CHECK-NEXT:    [[TMP11:%.*]] = load i8, ptr [[TMP9]], align 8, !alias.scope !19\n+; CHECK-NEXT:    [[TMP10:%.*]] = load i8, ptr [[TMP8]], align 8, !alias.scope !20\n+; CHECK-NEXT:    [[TMP11:%.*]] = load i8, ptr [[TMP9]], align 8, !alias.scope !20\n ; CHECK-NEXT:    [[TMP12:%.*]] = getelementptr i8, ptr [[DST]], i8 [[INDUCTION]]\n ; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr i8, ptr [[DST]], i8 [[INDUCTION6]]\n-; CHECK-NEXT:    store i8 [[TMP10]], ptr [[TMP12]], align 2, !alias.scope !22, !noalias !24\n-; CHECK-NEXT:    store i8 [[TMP11]], ptr [[TMP13]], align 2, !alias.scope !22, !noalias !24\n+; CHECK-NEXT:    store i8 [[TMP10]], ptr [[TMP12]], align 2, !alias.scope !23, !noalias !25\n+; CHECK-NEXT:    store i8 [[TMP11]], ptr [[TMP13]], align 2, !alias.scope !23, !noalias !25\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 2\n ; CHECK-NEXT:    [[TMP14:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]\n-; CHECK-NEXT:    br i1 [[TMP14]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP26:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP14]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP27:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i32 [[TMP2]], [[N_VEC]]\n ; CHECK-NEXT:    br i1 [[CMP_N]], label [[EXIT:%.*]], label [[SCALAR_PH]]\n@@ -309,7 +309,7 @@ define void @test_loop_dependent_select_first_ptr_noundef(ptr noundef %src.1, pt\n ; CHECK-NEXT:    store i8 [[L_1]], ptr [[GEP_DST]], align 2\n ; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i8 [[IV]], 1\n ; CHECK-NEXT:    [[EC:%.*]] = icmp eq i8 [[IV_NEXT]], [[N]]\n-; CHECK-NEXT:    br i1 [[EC]], label [[EXIT]], label [[LOOP]], !llvm.loop [[LOOP27:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EC]], label [[EXIT]], label [[LOOP]], !llvm.loop [[LOOP28:![0-9]+]]\n ; CHECK:       exit:\n ; CHECK-NEXT:    ret void\n ;\n@@ -370,15 +370,15 @@ define void @test_loop_dependent_select_second_ptr_noundef(ptr %src.1, ptr nound\n ; CHECK-NEXT:    [[TMP7:%.*]] = icmp ult i8 [[INDUCTION6]], [[X]]\n ; CHECK-NEXT:    [[TMP8:%.*]] = select i1 [[TMP6]], ptr [[SRC_1]], ptr [[SRC_2]]\n ; CHECK-NEXT:    [[TMP9:%.*]] = select i1 [[TMP7]], ptr [[SRC_1]], ptr [[SRC_2]]\n-; CHECK-NEXT:    [[TMP10:%.*]] = load i8, ptr [[TMP8]], align 8, !alias.scope !28\n-; CHECK-NEXT:    [[TMP11:%.*]] = load i8, ptr [[TMP9]], align 8, !alias.scope !28\n+; CHECK-NEXT:    [[TMP10:%.*]] = load i8, ptr [[TMP8]], align 8, !alias.scope !29\n+; CHECK-NEXT:    [[TMP11:%.*]] = load i8, ptr [[TMP9]], align 8, !alias.scope !29\n ; CHECK-NEXT:    [[TMP12:%.*]] = getelementptr i8, ptr [[DST]], i8 [[INDUCTION]]\n ; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr i8, ptr [[DST]], i8 [[INDUCTION6]]\n-; CHECK-NEXT:    store i8 [[TMP10]], ptr [[TMP12]], align 2, !alias.scope !31, !noalias !33\n-; CHECK-NEXT:    store i8 [[TMP11]], ptr [[TMP13]], align 2, !alias.scope !31, !noalias !33\n+; CHECK-NEXT:    store i8 [[TMP10]], ptr [[TMP12]], align 2, !alias.scope !32, !noalias !34\n+; CHECK-NEXT:    store i8 [[TMP11]], ptr [[TMP13]], align 2, !alias.scope !32, !noalias !34\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 2\n ; CHECK-NEXT:    [[TMP14:%.*]] = icmp eq i32 [[INDEX_NEXT]], [[N_VEC]]\n-; CHECK-NEXT:    br i1 [[TMP14]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP35:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP14]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP36:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i32 [[TMP2]], [[N_VEC]]\n ; CHECK-NEXT:    br i1 [[CMP_N]], label [[EXIT:%.*]], label [[SCALAR_PH]]\n@@ -394,7 +394,7 @@ define void @test_loop_dependent_select_second_ptr_noundef(ptr %src.1, ptr nound\n ; CHECK-NEXT:    store i8 [[L_1]], ptr [[GEP_DST]], align 2\n ; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i8 [[IV]], 1\n ; CHECK-NEXT:    [[EC:%.*]] = icmp eq i8 [[IV_NEXT]], [[N]]\n-; CHECK-NEXT:    br i1 [[EC]], label [[EXIT]], label [[LOOP]], !llvm.loop [[LOOP36:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EC]], label [[EXIT]], label [[LOOP]], !llvm.loop [[LOOP37:![0-9]+]]\n ; CHECK:       exit:\n ; CHECK-NEXT:    ret void\n ;"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/reduction-with-invariant-store.ll",
                "patch": "@@ -188,10 +188,10 @@ for.end:\n ; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i32, i32* [[SRC]], i64 [[TMP1]]\n ; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds i32, i32* [[SRC]], i64 [[TMP2]]\n ; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds i32, i32* [[SRC]], i64 [[TMP3]]\n-; CHECK-NEXT:    [[TMP8:%.*]] = load i32, i32* [[TMP4]], align 4, !alias.scope !11\n-; CHECK-NEXT:    [[TMP9:%.*]] = load i32, i32* [[TMP5]], align 4, !alias.scope !11\n-; CHECK-NEXT:    [[TMP10:%.*]] = load i32, i32* [[TMP6]], align 4, !alias.scope !11\n-; CHECK-NEXT:    [[TMP11:%.*]] = load i32, i32* [[TMP7]], align 4, !alias.scope !11\n+; CHECK-NEXT:    [[TMP8:%.*]] = load i32, i32* [[TMP4]], align 4, !alias.scope !12\n+; CHECK-NEXT:    [[TMP9:%.*]] = load i32, i32* [[TMP5]], align 4, !alias.scope !12\n+; CHECK-NEXT:    [[TMP10:%.*]] = load i32, i32* [[TMP6]], align 4, !alias.scope !12\n+; CHECK-NEXT:    [[TMP11:%.*]] = load i32, i32* [[TMP7]], align 4, !alias.scope !12\n ; CHECK-NEXT:    [[TMP12:%.*]] = insertelement <4 x i32> poison, i32 [[TMP8]], i32 0\n ; CHECK-NEXT:    [[TMP13:%.*]] = insertelement <4 x i32> [[TMP12]], i32 [[TMP9]], i32 1\n ; CHECK-NEXT:    [[TMP14:%.*]] = insertelement <4 x i32> [[TMP13]], i32 [[TMP10]], i32 2\n@@ -206,10 +206,10 @@ for.end:\n ; CHECK-NEXT:    [[TMP23:%.*]] = getelementptr inbounds i32, i32* [[SRC]], i64 [[TMP22]]\n ; CHECK-NEXT:    [[TMP24:%.*]] = extractelement <4 x i64> [[TMP17]], i32 3\n ; CHECK-NEXT:    [[TMP25:%.*]] = getelementptr inbounds i32, i32* [[SRC]], i64 [[TMP24]]\n-; CHECK-NEXT:    [[TMP26:%.*]] = load i32, i32* [[TMP19]], align 4, !alias.scope !11\n-; CHECK-NEXT:    [[TMP27:%.*]] = load i32, i32* [[TMP21]], align 4, !alias.scope !11\n-; CHECK-NEXT:    [[TMP28:%.*]] = load i32, i32* [[TMP23]], align 4, !alias.scope !11\n-; CHECK-NEXT:    [[TMP29:%.*]] = load i32, i32* [[TMP25]], align 4, !alias.scope !11\n+; CHECK-NEXT:    [[TMP26:%.*]] = load i32, i32* [[TMP19]], align 4, !alias.scope !12\n+; CHECK-NEXT:    [[TMP27:%.*]] = load i32, i32* [[TMP21]], align 4, !alias.scope !12\n+; CHECK-NEXT:    [[TMP28:%.*]] = load i32, i32* [[TMP23]], align 4, !alias.scope !12\n+; CHECK-NEXT:    [[TMP29:%.*]] = load i32, i32* [[TMP25]], align 4, !alias.scope !12\n ; CHECK-NEXT:    [[TMP30:%.*]] = insertelement <4 x i32> poison, i32 [[TMP26]], i32 0\n ; CHECK-NEXT:    [[TMP31:%.*]] = insertelement <4 x i32> [[TMP30]], i32 [[TMP27]], i32 1\n ; CHECK-NEXT:    [[TMP32:%.*]] = insertelement <4 x i32> [[TMP31]], i32 [[TMP28]], i32 2"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/runtime-check.ll",
                "patch": "@@ -58,11 +58,11 @@ define i32 @foo(float* nocapture %a, float* nocapture %b, i32 %n) nounwind uwtab\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add i64 [[INDVARS_IV]], 1, !dbg [[DBG9]]\n ; CHECK-NEXT:    [[LFTR_WIDEIV:%.*]] = trunc i64 [[INDVARS_IV_NEXT]] to i32, !dbg [[DBG9]]\n ; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i32 [[LFTR_WIDEIV]], [[N]], !dbg [[DBG9]]\n-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_END_LOOPEXIT]], label [[FOR_BODY]], !dbg [[DBG9]], !llvm.loop [[LOOP12:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_END_LOOPEXIT]], label [[FOR_BODY]], !dbg [[DBG9]], !llvm.loop [[LOOP13:![0-9]+]]\n ; CHECK:       for.end.loopexit:\n-; CHECK-NEXT:    br label [[FOR_END]], !dbg [[DBG13:![0-9]+]]\n+; CHECK-NEXT:    br label [[FOR_END]], !dbg [[DBG14:![0-9]+]]\n ; CHECK:       for.end:\n-; CHECK-NEXT:    ret i32 undef, !dbg [[DBG13]]\n+; CHECK-NEXT:    ret i32 undef, !dbg [[DBG14]]\n ;\n ; FORCED_OPTSIZE-LABEL: @foo(\n ; FORCED_OPTSIZE-NEXT:  entry:\n@@ -135,18 +135,18 @@ define void @test_runtime_check(float* %a, float %b, i64 %offset, i64 %offset2,\n ; CHECK-NEXT:    [[TMP2:%.*]] = add i64 [[INDEX]], [[OFFSET]]\n ; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds float, float* [[A]], i64 [[TMP2]]\n ; CHECK-NEXT:    [[TMP4:%.*]] = bitcast float* [[TMP3]] to <4 x float>*\n-; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x float>, <4 x float>* [[TMP4]], align 4, !alias.scope !14, !noalias !17\n+; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x float>, <4 x float>* [[TMP4]], align 4, !alias.scope !15, !noalias !18\n ; CHECK-NEXT:    [[TMP5:%.*]] = add i64 [[INDEX]], [[OFFSET2]]\n ; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds float, float* [[A]], i64 [[TMP5]]\n ; CHECK-NEXT:    [[TMP7:%.*]] = bitcast float* [[TMP6]] to <4 x float>*\n-; CHECK-NEXT:    [[WIDE_LOAD8:%.*]] = load <4 x float>, <4 x float>* [[TMP7]], align 4, !alias.scope !17\n+; CHECK-NEXT:    [[WIDE_LOAD8:%.*]] = load <4 x float>, <4 x float>* [[TMP7]], align 4, !alias.scope !18\n ; CHECK-NEXT:    [[TMP8:%.*]] = fmul fast <4 x float> [[BROADCAST_SPLAT]], [[WIDE_LOAD8]]\n ; CHECK-NEXT:    [[TMP9:%.*]] = fadd fast <4 x float> [[WIDE_LOAD]], [[TMP8]]\n ; CHECK-NEXT:    [[TMP10:%.*]] = bitcast float* [[TMP3]] to <4 x float>*\n-; CHECK-NEXT:    store <4 x float> [[TMP9]], <4 x float>* [[TMP10]], align 4, !alias.scope !14, !noalias !17\n+; CHECK-NEXT:    store <4 x float> [[TMP9]], <4 x float>* [[TMP10]], align 4, !alias.scope !15, !noalias !18\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 4\n ; CHECK-NEXT:    [[TMP11:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n-; CHECK-NEXT:    br i1 [[TMP11]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP19:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP11]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP20:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N_VEC]], [[N]]\n ; CHECK-NEXT:    br i1 [[CMP_N]], label [[LOOPEXIT:%.*]], label [[SCALAR_PH]]\n@@ -166,7 +166,7 @@ define void @test_runtime_check(float* %a, float %b, i64 %offset, i64 %offset2,\n ; CHECK-NEXT:    store float [[AD]], float* [[ARR_IDX]], align 4\n ; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1\n ; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[IV_NEXT]], [[N]]\n-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP20:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EXITCOND]], label [[LOOPEXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP21:![0-9]+]]\n ; CHECK:       loopexit:\n ; CHECK-NEXT:    ret void\n ;\n@@ -304,9 +304,37 @@ loopexit:\n   ret void\n }\n \n-; CHECK: !9 = !DILocation(line: 101, column: 1, scope: !{{.*}})\n \n define dso_local void @forced_optsize(i64* noalias nocapture readonly %x_p, i64* noalias nocapture readonly %y_p, i64* noalias nocapture %z_p) minsize optsize {\n+; CHECK-LABEL: @forced_optsize(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    br i1 false, label [[SCALAR_PH:%.*]], label [[VECTOR_PH:%.*]]\n+; CHECK:       vector.ph:\n+; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]\n+; CHECK:       vector.body:\n+; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]\n+; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i64, i64* [[X_P:%.*]], i64 [[INDEX]]\n+; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i64* [[TMP0]] to <2 x i64>*\n+; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x i64>, <2 x i64>* [[TMP1]], align 8\n+; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i64, i64* [[Y_P:%.*]], i64 [[INDEX]]\n+; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i64* [[TMP2]] to <2 x i64>*\n+; CHECK-NEXT:    [[WIDE_LOAD1:%.*]] = load <2 x i64>, <2 x i64>* [[TMP3]], align 8\n+; CHECK-NEXT:    [[TMP4:%.*]] = add nsw <2 x i64> [[WIDE_LOAD1]], [[WIDE_LOAD]]\n+; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds i64, i64* [[Z_P:%.*]], i64 [[INDEX]]\n+; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i64* [[TMP5]] to <2 x i64>*\n+; CHECK-NEXT:    store <2 x i64> [[TMP4]], <2 x i64>* [[TMP6]], align 8\n+; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 2\n+; CHECK-NEXT:    [[TMP7:%.*]] = icmp eq i64 [[INDEX_NEXT]], 128\n+; CHECK-NEXT:    br i1 [[TMP7]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP22:![0-9]+]]\n+; CHECK:       middle.block:\n+; CHECK-NEXT:    br i1 true, label [[FOR_COND_CLEANUP:%.*]], label [[SCALAR_PH]]\n+; CHECK:       scalar.ph:\n+; CHECK-NEXT:    br label [[FOR_BODY:%.*]]\n+; CHECK:       for.cond.cleanup:\n+; CHECK-NEXT:    ret void\n+; CHECK:       for.body:\n+; CHECK-NEXT:    br i1 poison, label [[FOR_COND_CLEANUP]], label [[FOR_BODY]], !llvm.loop [[LOOP23:![0-9]+]]\n+;\n ; FORCED_OPTSIZE-LABEL: @forced_optsize(\n ; FORCED_OPTSIZE-NEXT:  entry:\n ; FORCED_OPTSIZE-NEXT:    br label [[FOR_BODY:%.*]]\n@@ -345,6 +373,8 @@ for.body:\n   br i1 %exitcond, label %for.cond.cleanup, label %for.body, !llvm.loop !12\n }\n \n+; CHECK: !9 = !DILocation(line: 101, column: 1, scope: !{{.*}})\n+\n !llvm.module.flags = !{!0, !1}\n !llvm.dbg.cu = !{!9}\n !0 = !{i32 2, !\"Dwarf Version\", i32 4}"
            },
            {
                "fn": "llvm/test/Transforms/LoopVectorize/vectorize-once.ll",
                "patch": "@@ -69,10 +69,10 @@ _ZSt10accumulateIPiiET0_T_S2_S1_.exit:            ; preds = %for.body.i, %entry\n \n attributes #0 = { nounwind readonly ssp uwtable \"fp-contract-model\"=\"standard\" \"frame-pointer\"=\"non-leaf\" \"realign-stack\" \"relocation-model\"=\"pic\" \"ssp-buffers-size\"=\"8\" }\n \n-; CHECK:      [[VEC_LOOP1]] = distinct !{[[VEC_LOOP1]], [[MD_IS_VEC:![0-9]+]]}\n+; CHECK:      [[VEC_LOOP1]] = distinct !{[[VEC_LOOP1]], [[MD_IS_VEC:![0-9]+]], [[MD_RT_UNROLL_DIS:![0-9]+]]}\n ; CHECK-NEXT: [[MD_IS_VEC:![0-9]+]] = !{!\"llvm.loop.isvectorized\", i32 1}\n-; CHECK-NEXT: [[SCALAR_LOOP1]] = distinct !{[[SCALAR_LOOP1]], [[MD_RT_UNROLL_DIS:![0-9]+]], [[MD_IS_VEC]]}\n ; CHECK-NEXT: [[MD_RT_UNROLL_DIS]] = !{!\"llvm.loop.unroll.runtime.disable\"}\n+; CHECK-NEXT: [[SCALAR_LOOP1]] = distinct !{[[SCALAR_LOOP1]], [[MD_RT_UNROLL_DIS:![0-9]+]], [[MD_IS_VEC]]}\n ; CHECK-NEXT: [[SCALAR_LOOP2]] = distinct !{[[SCALAR_LOOP2]], [[VEC_WIDTH_1:![0-9]+]]}\n ; CHECK-NEXT: [[VEC_WIDTH_1]] = !{!\"llvm.loop.vectorize.width\", i32 1}\n "
            },
            {
                "fn": "llvm/test/Transforms/PhaseOrdering/AArch64/hoisting-sinking-required-for-vectorization.ll",
                "patch": "@@ -83,7 +83,7 @@ define void @loop(ptr %X, ptr %Y) {\n ; CHECK-NEXT:    store double [[RETVAL_0_I]], ptr [[ARRAYIDX2]], align 8\n ; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[I_04]], 1\n ; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[I_04]], 19999\n-; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP]], !llvm.loop [[LOOP2:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_COND_CLEANUP]], !llvm.loop [[LOOP3:![0-9]+]]\n ;\n entry:\n   %X.addr = alloca ptr, align 8\n@@ -151,19 +151,19 @@ define void @loop2(ptr %A, ptr %B, ptr %C, float %x) {\n ; CHECK:       vector.body:\n ; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]\n ; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i32, ptr [[C]], i64 [[INDEX]]\n-; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i32>, ptr [[TMP0]], align 4, !alias.scope !3\n+; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i32>, ptr [[TMP0]], align 4, !alias.scope !4\n ; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq <4 x i32> [[WIDE_LOAD]], <i32 20, i32 20, i32 20, i32 20>\n ; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds float, ptr [[A]], i64 [[INDEX]]\n-; CHECK-NEXT:    [[WIDE_LOAD7:%.*]] = load <4 x float>, ptr [[TMP2]], align 4, !alias.scope !6\n+; CHECK-NEXT:    [[WIDE_LOAD7:%.*]] = load <4 x float>, ptr [[TMP2]], align 4, !alias.scope !7\n ; CHECK-NEXT:    [[TMP3:%.*]] = fmul <4 x float> [[WIDE_LOAD7]], [[BROADCAST_SPLAT]]\n ; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr float, ptr [[B]], i64 [[INDEX]]\n-; CHECK-NEXT:    [[WIDE_LOAD8:%.*]] = load <4 x float>, ptr [[TMP4]], align 4, !alias.scope !8, !noalias !10\n+; CHECK-NEXT:    [[WIDE_LOAD8:%.*]] = load <4 x float>, ptr [[TMP4]], align 4, !alias.scope !9, !noalias !11\n ; CHECK-NEXT:    [[TMP5:%.*]] = select <4 x i1> [[TMP1]], <4 x float> <float -0.000000e+00, float -0.000000e+00, float -0.000000e+00, float -0.000000e+00>, <4 x float> [[WIDE_LOAD8]]\n ; CHECK-NEXT:    [[PREDPHI:%.*]] = fadd <4 x float> [[TMP3]], [[TMP5]]\n-; CHECK-NEXT:    store <4 x float> [[PREDPHI]], ptr [[TMP4]], align 4, !alias.scope !8, !noalias !10\n+; CHECK-NEXT:    store <4 x float> [[PREDPHI]], ptr [[TMP4]], align 4, !alias.scope !9, !noalias !11\n ; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 4\n ; CHECK-NEXT:    [[TMP6:%.*]] = icmp eq i64 [[INDEX_NEXT]], 10000\n-; CHECK-NEXT:    br i1 [[TMP6]], label [[EXIT:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP11:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[TMP6]], label [[EXIT:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP12:![0-9]+]]\n ; CHECK:       loop.body:\n ; CHECK-NEXT:    [[IV1:%.*]] = phi i64 [ [[IV_NEXT:%.*]], [[LOOP_LATCH:%.*]] ], [ 0, [[ENTRY:%.*]] ]\n ; CHECK-NEXT:    [[C_GEP:%.*]] = getelementptr inbounds i32, ptr [[C]], i64 [[IV1]]\n@@ -183,7 +183,7 @@ define void @loop2(ptr %A, ptr %B, ptr %C, float %x) {\n ; CHECK-NEXT:    store float [[ADD_SINK]], ptr [[B_GEP_0]], align 4\n ; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV1]], 1\n ; CHECK-NEXT:    [[CMP_0:%.*]] = icmp ult i64 [[IV1]], 9999\n-; CHECK-NEXT:    br i1 [[CMP_0]], label [[LOOP_BODY]], label [[EXIT]], !llvm.loop [[LOOP12:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[CMP_0]], label [[LOOP_BODY]], label [[EXIT]], !llvm.loop [[LOOP13:![0-9]+]]\n ; CHECK:       exit:\n ; CHECK-NEXT:    ret void\n ;"
            },
            {
                "fn": "llvm/test/Transforms/PhaseOrdering/X86/excessive-unrolling.ll",
                "patch": "@@ -176,166 +176,26 @@ define void @test_runtime_trip_count(i32 %N) {\n ; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[FOR_BODY_PREHEADER7:%.*]], label [[VECTOR_PH:%.*]]\n ; CHECK:       vector.ph:\n ; CHECK-NEXT:    [[N_VEC:%.*]] = and i64 [[WIDE_TRIP_COUNT]], 4294967292\n-; CHECK-NEXT:    [[TMP0:%.*]] = add nsw i64 [[WIDE_TRIP_COUNT]], -4\n-; CHECK-NEXT:    [[TMP1:%.*]] = lshr i64 [[TMP0]], 2\n-; CHECK-NEXT:    [[TMP2:%.*]] = add nuw nsw i64 [[TMP1]], 1\n-; CHECK-NEXT:    [[XTRAITER:%.*]] = and i64 [[TMP2]], 7\n-; CHECK-NEXT:    [[TMP3:%.*]] = icmp ult i64 [[TMP0]], 28\n-; CHECK-NEXT:    br i1 [[TMP3]], label [[MIDDLE_BLOCK_UNR_LCSSA:%.*]], label [[VECTOR_PH_NEW:%.*]]\n-; CHECK:       vector.ph.new:\n-; CHECK-NEXT:    [[UNROLL_ITER:%.*]] = and i64 [[TMP2]], -8\n ; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]\n ; CHECK:       vector.body:\n-; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH_NEW]] ], [ [[INDEX_NEXT_7:%.*]], [[VECTOR_BODY]] ]\n-; CHECK-NEXT:    [[NITER:%.*]] = phi i64 [ 0, [[VECTOR_PH_NEW]] ], [ [[NITER_NEXT_7:%.*]], [[VECTOR_BODY]] ]\n-; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds [58 x double], ptr @b, i64 0, i64 [[INDEX]]\n-; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x double>, ptr [[TMP4]], align 16\n-; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds double, ptr [[TMP4]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD4:%.*]] = load <2 x double>, ptr [[TMP5]], align 16\n-; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds [58 x double], ptr @c, i64 0, i64 [[INDEX]]\n-; CHECK-NEXT:    [[WIDE_LOAD5:%.*]] = load <2 x double>, ptr [[TMP6]], align 16\n+; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]\n+; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds [58 x double], ptr @b, i64 0, i64 [[INDEX]]\n+; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <2 x double>, ptr [[TMP0]], align 16\n+; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds double, ptr [[TMP0]], i64 2\n+; CHECK-NEXT:    [[WIDE_LOAD4:%.*]] = load <2 x double>, ptr [[TMP1]], align 16\n+; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds [58 x double], ptr @c, i64 0, i64 [[INDEX]]\n+; CHECK-NEXT:    [[WIDE_LOAD5:%.*]] = load <2 x double>, ptr [[TMP2]], align 16\n+; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds double, ptr [[TMP2]], i64 2\n+; CHECK-NEXT:    [[WIDE_LOAD6:%.*]] = load <2 x double>, ptr [[TMP3]], align 16\n+; CHECK-NEXT:    [[TMP4:%.*]] = fadd <2 x double> [[WIDE_LOAD]], [[WIDE_LOAD5]]\n+; CHECK-NEXT:    [[TMP5:%.*]] = fadd <2 x double> [[WIDE_LOAD4]], [[WIDE_LOAD6]]\n+; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds [58 x double], ptr @a, i64 0, i64 [[INDEX]]\n+; CHECK-NEXT:    store <2 x double> [[TMP4]], ptr [[TMP6]], align 16\n ; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds double, ptr [[TMP6]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD6:%.*]] = load <2 x double>, ptr [[TMP7]], align 16\n-; CHECK-NEXT:    [[TMP8:%.*]] = fadd <2 x double> [[WIDE_LOAD]], [[WIDE_LOAD5]]\n-; CHECK-NEXT:    [[TMP9:%.*]] = fadd <2 x double> [[WIDE_LOAD4]], [[WIDE_LOAD6]]\n-; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds [58 x double], ptr @a, i64 0, i64 [[INDEX]]\n-; CHECK-NEXT:    store <2 x double> [[TMP8]], ptr [[TMP10]], align 16\n-; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr inbounds double, ptr [[TMP10]], i64 2\n-; CHECK-NEXT:    store <2 x double> [[TMP9]], ptr [[TMP11]], align 16\n-; CHECK-NEXT:    [[INDEX_NEXT:%.*]] = or i64 [[INDEX]], 4\n-; CHECK-NEXT:    [[TMP12:%.*]] = getelementptr inbounds [58 x double], ptr @b, i64 0, i64 [[INDEX_NEXT]]\n-; CHECK-NEXT:    [[WIDE_LOAD_1:%.*]] = load <2 x double>, ptr [[TMP12]], align 16\n-; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr inbounds double, ptr [[TMP12]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD4_1:%.*]] = load <2 x double>, ptr [[TMP13]], align 16\n-; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr inbounds [58 x double], ptr @c, i64 0, i64 [[INDEX_NEXT]]\n-; CHECK-NEXT:    [[WIDE_LOAD5_1:%.*]] = load <2 x double>, ptr [[TMP14]], align 16\n-; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr inbounds double, ptr [[TMP14]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD6_1:%.*]] = load <2 x double>, ptr [[TMP15]], align 16\n-; CHECK-NEXT:    [[TMP16:%.*]] = fadd <2 x double> [[WIDE_LOAD_1]], [[WIDE_LOAD5_1]]\n-; CHECK-NEXT:    [[TMP17:%.*]] = fadd <2 x double> [[WIDE_LOAD4_1]], [[WIDE_LOAD6_1]]\n-; CHECK-NEXT:    [[TMP18:%.*]] = getelementptr inbounds [58 x double], ptr @a, i64 0, i64 [[INDEX_NEXT]]\n-; CHECK-NEXT:    store <2 x double> [[TMP16]], ptr [[TMP18]], align 16\n-; CHECK-NEXT:    [[TMP19:%.*]] = getelementptr inbounds double, ptr [[TMP18]], i64 2\n-; CHECK-NEXT:    store <2 x double> [[TMP17]], ptr [[TMP19]], align 16\n-; CHECK-NEXT:    [[INDEX_NEXT_1:%.*]] = or i64 [[INDEX]], 8\n-; CHECK-NEXT:    [[TMP20:%.*]] = getelementptr inbounds [58 x double], ptr @b, i64 0, i64 [[INDEX_NEXT_1]]\n-; CHECK-NEXT:    [[WIDE_LOAD_2:%.*]] = load <2 x double>, ptr [[TMP20]], align 16\n-; CHECK-NEXT:    [[TMP21:%.*]] = getelementptr inbounds double, ptr [[TMP20]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD4_2:%.*]] = load <2 x double>, ptr [[TMP21]], align 16\n-; CHECK-NEXT:    [[TMP22:%.*]] = getelementptr inbounds [58 x double], ptr @c, i64 0, i64 [[INDEX_NEXT_1]]\n-; CHECK-NEXT:    [[WIDE_LOAD5_2:%.*]] = load <2 x double>, ptr [[TMP22]], align 16\n-; CHECK-NEXT:    [[TMP23:%.*]] = getelementptr inbounds double, ptr [[TMP22]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD6_2:%.*]] = load <2 x double>, ptr [[TMP23]], align 16\n-; CHECK-NEXT:    [[TMP24:%.*]] = fadd <2 x double> [[WIDE_LOAD_2]], [[WIDE_LOAD5_2]]\n-; CHECK-NEXT:    [[TMP25:%.*]] = fadd <2 x double> [[WIDE_LOAD4_2]], [[WIDE_LOAD6_2]]\n-; CHECK-NEXT:    [[TMP26:%.*]] = getelementptr inbounds [58 x double], ptr @a, i64 0, i64 [[INDEX_NEXT_1]]\n-; CHECK-NEXT:    store <2 x double> [[TMP24]], ptr [[TMP26]], align 16\n-; CHECK-NEXT:    [[TMP27:%.*]] = getelementptr inbounds double, ptr [[TMP26]], i64 2\n-; CHECK-NEXT:    store <2 x double> [[TMP25]], ptr [[TMP27]], align 16\n-; CHECK-NEXT:    [[INDEX_NEXT_2:%.*]] = or i64 [[INDEX]], 12\n-; CHECK-NEXT:    [[TMP28:%.*]] = getelementptr inbounds [58 x double], ptr @b, i64 0, i64 [[INDEX_NEXT_2]]\n-; CHECK-NEXT:    [[WIDE_LOAD_3:%.*]] = load <2 x double>, ptr [[TMP28]], align 16\n-; CHECK-NEXT:    [[TMP29:%.*]] = getelementptr inbounds double, ptr [[TMP28]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD4_3:%.*]] = load <2 x double>, ptr [[TMP29]], align 16\n-; CHECK-NEXT:    [[TMP30:%.*]] = getelementptr inbounds [58 x double], ptr @c, i64 0, i64 [[INDEX_NEXT_2]]\n-; CHECK-NEXT:    [[WIDE_LOAD5_3:%.*]] = load <2 x double>, ptr [[TMP30]], align 16\n-; CHECK-NEXT:    [[TMP31:%.*]] = getelementptr inbounds double, ptr [[TMP30]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD6_3:%.*]] = load <2 x double>, ptr [[TMP31]], align 16\n-; CHECK-NEXT:    [[TMP32:%.*]] = fadd <2 x double> [[WIDE_LOAD_3]], [[WIDE_LOAD5_3]]\n-; CHECK-NEXT:    [[TMP33:%.*]] = fadd <2 x double> [[WIDE_LOAD4_3]], [[WIDE_LOAD6_3]]\n-; CHECK-NEXT:    [[TMP34:%.*]] = getelementptr inbounds [58 x double], ptr @a, i64 0, i64 [[INDEX_NEXT_2]]\n-; CHECK-NEXT:    store <2 x double> [[TMP32]], ptr [[TMP34]], align 16\n-; CHECK-NEXT:    [[TMP35:%.*]] = getelementptr inbounds double, ptr [[TMP34]], i64 2\n-; CHECK-NEXT:    store <2 x double> [[TMP33]], ptr [[TMP35]], align 16\n-; CHECK-NEXT:    [[INDEX_NEXT_3:%.*]] = or i64 [[INDEX]], 16\n-; CHECK-NEXT:    [[TMP36:%.*]] = getelementptr inbounds [58 x double], ptr @b, i64 0, i64 [[INDEX_NEXT_3]]\n-; CHECK-NEXT:    [[WIDE_LOAD_4:%.*]] = load <2 x double>, ptr [[TMP36]], align 16\n-; CHECK-NEXT:    [[TMP37:%.*]] = getelementptr inbounds double, ptr [[TMP36]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD4_4:%.*]] = load <2 x double>, ptr [[TMP37]], align 16\n-; CHECK-NEXT:    [[TMP38:%.*]] = getelementptr inbounds [58 x double], ptr @c, i64 0, i64 [[INDEX_NEXT_3]]\n-; CHECK-NEXT:    [[WIDE_LOAD5_4:%.*]] = load <2 x double>, ptr [[TMP38]], align 16\n-; CHECK-NEXT:    [[TMP39:%.*]] = getelementptr inbounds double, ptr [[TMP38]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD6_4:%.*]] = load <2 x double>, ptr [[TMP39]], align 16\n-; CHECK-NEXT:    [[TMP40:%.*]] = fadd <2 x double> [[WIDE_LOAD_4]], [[WIDE_LOAD5_4]]\n-; CHECK-NEXT:    [[TMP41:%.*]] = fadd <2 x double> [[WIDE_LOAD4_4]], [[WIDE_LOAD6_4]]\n-; CHECK-NEXT:    [[TMP42:%.*]] = getelementptr inbounds [58 x double], ptr @a, i64 0, i64 [[INDEX_NEXT_3]]\n-; CHECK-NEXT:    store <2 x double> [[TMP40]], ptr [[TMP42]], align 16\n-; CHECK-NEXT:    [[TMP43:%.*]] = getelementptr inbounds double, ptr [[TMP42]], i64 2\n-; CHECK-NEXT:    store <2 x double> [[TMP41]], ptr [[TMP43]], align 16\n-; CHECK-NEXT:    [[INDEX_NEXT_4:%.*]] = or i64 [[INDEX]], 20\n-; CHECK-NEXT:    [[TMP44:%.*]] = getelementptr inbounds [58 x double], ptr @b, i64 0, i64 [[INDEX_NEXT_4]]\n-; CHECK-NEXT:    [[WIDE_LOAD_5:%.*]] = load <2 x double>, ptr [[TMP44]], align 16\n-; CHECK-NEXT:    [[TMP45:%.*]] = getelementptr inbounds double, ptr [[TMP44]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD4_5:%.*]] = load <2 x double>, ptr [[TMP45]], align 16\n-; CHECK-NEXT:    [[TMP46:%.*]] = getelementptr inbounds [58 x double], ptr @c, i64 0, i64 [[INDEX_NEXT_4]]\n-; CHECK-NEXT:    [[WIDE_LOAD5_5:%.*]] = load <2 x double>, ptr [[TMP46]], align 16\n-; CHECK-NEXT:    [[TMP47:%.*]] = getelementptr inbounds double, ptr [[TMP46]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD6_5:%.*]] = load <2 x double>, ptr [[TMP47]], align 16\n-; CHECK-NEXT:    [[TMP48:%.*]] = fadd <2 x double> [[WIDE_LOAD_5]], [[WIDE_LOAD5_5]]\n-; CHECK-NEXT:    [[TMP49:%.*]] = fadd <2 x double> [[WIDE_LOAD4_5]], [[WIDE_LOAD6_5]]\n-; CHECK-NEXT:    [[TMP50:%.*]] = getelementptr inbounds [58 x double], ptr @a, i64 0, i64 [[INDEX_NEXT_4]]\n-; CHECK-NEXT:    store <2 x double> [[TMP48]], ptr [[TMP50]], align 16\n-; CHECK-NEXT:    [[TMP51:%.*]] = getelementptr inbounds double, ptr [[TMP50]], i64 2\n-; CHECK-NEXT:    store <2 x double> [[TMP49]], ptr [[TMP51]], align 16\n-; CHECK-NEXT:    [[INDEX_NEXT_5:%.*]] = or i64 [[INDEX]], 24\n-; CHECK-NEXT:    [[TMP52:%.*]] = getelementptr inbounds [58 x double], ptr @b, i64 0, i64 [[INDEX_NEXT_5]]\n-; CHECK-NEXT:    [[WIDE_LOAD_6:%.*]] = load <2 x double>, ptr [[TMP52]], align 16\n-; CHECK-NEXT:    [[TMP53:%.*]] = getelementptr inbounds double, ptr [[TMP52]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD4_6:%.*]] = load <2 x double>, ptr [[TMP53]], align 16\n-; CHECK-NEXT:    [[TMP54:%.*]] = getelementptr inbounds [58 x double], ptr @c, i64 0, i64 [[INDEX_NEXT_5]]\n-; CHECK-NEXT:    [[WIDE_LOAD5_6:%.*]] = load <2 x double>, ptr [[TMP54]], align 16\n-; CHECK-NEXT:    [[TMP55:%.*]] = getelementptr inbounds double, ptr [[TMP54]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD6_6:%.*]] = load <2 x double>, ptr [[TMP55]], align 16\n-; CHECK-NEXT:    [[TMP56:%.*]] = fadd <2 x double> [[WIDE_LOAD_6]], [[WIDE_LOAD5_6]]\n-; CHECK-NEXT:    [[TMP57:%.*]] = fadd <2 x double> [[WIDE_LOAD4_6]], [[WIDE_LOAD6_6]]\n-; CHECK-NEXT:    [[TMP58:%.*]] = getelementptr inbounds [58 x double], ptr @a, i64 0, i64 [[INDEX_NEXT_5]]\n-; CHECK-NEXT:    store <2 x double> [[TMP56]], ptr [[TMP58]], align 16\n-; CHECK-NEXT:    [[TMP59:%.*]] = getelementptr inbounds double, ptr [[TMP58]], i64 2\n-; CHECK-NEXT:    store <2 x double> [[TMP57]], ptr [[TMP59]], align 16\n-; CHECK-NEXT:    [[INDEX_NEXT_6:%.*]] = or i64 [[INDEX]], 28\n-; CHECK-NEXT:    [[TMP60:%.*]] = getelementptr inbounds [58 x double], ptr @b, i64 0, i64 [[INDEX_NEXT_6]]\n-; CHECK-NEXT:    [[WIDE_LOAD_7:%.*]] = load <2 x double>, ptr [[TMP60]], align 16\n-; CHECK-NEXT:    [[TMP61:%.*]] = getelementptr inbounds double, ptr [[TMP60]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD4_7:%.*]] = load <2 x double>, ptr [[TMP61]], align 16\n-; CHECK-NEXT:    [[TMP62:%.*]] = getelementptr inbounds [58 x double], ptr @c, i64 0, i64 [[INDEX_NEXT_6]]\n-; CHECK-NEXT:    [[WIDE_LOAD5_7:%.*]] = load <2 x double>, ptr [[TMP62]], align 16\n-; CHECK-NEXT:    [[TMP63:%.*]] = getelementptr inbounds double, ptr [[TMP62]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD6_7:%.*]] = load <2 x double>, ptr [[TMP63]], align 16\n-; CHECK-NEXT:    [[TMP64:%.*]] = fadd <2 x double> [[WIDE_LOAD_7]], [[WIDE_LOAD5_7]]\n-; CHECK-NEXT:    [[TMP65:%.*]] = fadd <2 x double> [[WIDE_LOAD4_7]], [[WIDE_LOAD6_7]]\n-; CHECK-NEXT:    [[TMP66:%.*]] = getelementptr inbounds [58 x double], ptr @a, i64 0, i64 [[INDEX_NEXT_6]]\n-; CHECK-NEXT:    store <2 x double> [[TMP64]], ptr [[TMP66]], align 16\n-; CHECK-NEXT:    [[TMP67:%.*]] = getelementptr inbounds double, ptr [[TMP66]], i64 2\n-; CHECK-NEXT:    store <2 x double> [[TMP65]], ptr [[TMP67]], align 16\n-; CHECK-NEXT:    [[INDEX_NEXT_7]] = add nuw i64 [[INDEX]], 32\n-; CHECK-NEXT:    [[NITER_NEXT_7]] = add i64 [[NITER]], 8\n-; CHECK-NEXT:    [[NITER_NCMP_7:%.*]] = icmp eq i64 [[NITER_NEXT_7]], [[UNROLL_ITER]]\n-; CHECK-NEXT:    br i1 [[NITER_NCMP_7]], label [[MIDDLE_BLOCK_UNR_LCSSA]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]\n-; CHECK:       middle.block.unr-lcssa:\n-; CHECK-NEXT:    [[INDEX_UNR:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT_7]], [[VECTOR_BODY]] ]\n-; CHECK-NEXT:    [[LCMP_MOD_NOT:%.*]] = icmp eq i64 [[XTRAITER]], 0\n-; CHECK-NEXT:    br i1 [[LCMP_MOD_NOT]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY_EPIL:%.*]]\n-; CHECK:       vector.body.epil:\n-; CHECK-NEXT:    [[INDEX_EPIL:%.*]] = phi i64 [ [[INDEX_NEXT_EPIL:%.*]], [[VECTOR_BODY_EPIL]] ], [ [[INDEX_UNR]], [[MIDDLE_BLOCK_UNR_LCSSA]] ]\n-; CHECK-NEXT:    [[EPIL_ITER:%.*]] = phi i64 [ [[EPIL_ITER_NEXT:%.*]], [[VECTOR_BODY_EPIL]] ], [ 0, [[MIDDLE_BLOCK_UNR_LCSSA]] ]\n-; CHECK-NEXT:    [[TMP68:%.*]] = getelementptr inbounds [58 x double], ptr @b, i64 0, i64 [[INDEX_EPIL]]\n-; CHECK-NEXT:    [[WIDE_LOAD_EPIL:%.*]] = load <2 x double>, ptr [[TMP68]], align 16\n-; CHECK-NEXT:    [[TMP69:%.*]] = getelementptr inbounds double, ptr [[TMP68]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD4_EPIL:%.*]] = load <2 x double>, ptr [[TMP69]], align 16\n-; CHECK-NEXT:    [[TMP70:%.*]] = getelementptr inbounds [58 x double], ptr @c, i64 0, i64 [[INDEX_EPIL]]\n-; CHECK-NEXT:    [[WIDE_LOAD5_EPIL:%.*]] = load <2 x double>, ptr [[TMP70]], align 16\n-; CHECK-NEXT:    [[TMP71:%.*]] = getelementptr inbounds double, ptr [[TMP70]], i64 2\n-; CHECK-NEXT:    [[WIDE_LOAD6_EPIL:%.*]] = load <2 x double>, ptr [[TMP71]], align 16\n-; CHECK-NEXT:    [[TMP72:%.*]] = fadd <2 x double> [[WIDE_LOAD_EPIL]], [[WIDE_LOAD5_EPIL]]\n-; CHECK-NEXT:    [[TMP73:%.*]] = fadd <2 x double> [[WIDE_LOAD4_EPIL]], [[WIDE_LOAD6_EPIL]]\n-; CHECK-NEXT:    [[TMP74:%.*]] = getelementptr inbounds [58 x double], ptr @a, i64 0, i64 [[INDEX_EPIL]]\n-; CHECK-NEXT:    store <2 x double> [[TMP72]], ptr [[TMP74]], align 16\n-; CHECK-NEXT:    [[TMP75:%.*]] = getelementptr inbounds double, ptr [[TMP74]], i64 2\n-; CHECK-NEXT:    store <2 x double> [[TMP73]], ptr [[TMP75]], align 16\n-; CHECK-NEXT:    [[INDEX_NEXT_EPIL]] = add nuw i64 [[INDEX_EPIL]], 4\n-; CHECK-NEXT:    [[EPIL_ITER_NEXT]] = add i64 [[EPIL_ITER]], 1\n-; CHECK-NEXT:    [[EPIL_ITER_CMP_NOT:%.*]] = icmp eq i64 [[EPIL_ITER_NEXT]], [[XTRAITER]]\n-; CHECK-NEXT:    br i1 [[EPIL_ITER_CMP_NOT]], label [[MIDDLE_BLOCK]], label [[VECTOR_BODY_EPIL]], !llvm.loop [[LOOP2:![0-9]+]]\n+; CHECK-NEXT:    store <2 x double> [[TMP5]], ptr [[TMP7]], align 16\n+; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 4\n+; CHECK-NEXT:    [[TMP8:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n+; CHECK-NEXT:    br i1 [[TMP8]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N_VEC]], [[WIDE_TRIP_COUNT]]\n ; CHECK-NEXT:    br i1 [[CMP_N]], label [[EXIT]], label [[FOR_BODY_PREHEADER7]]\n@@ -345,15 +205,15 @@ define void @test_runtime_trip_count(i32 %N) {\n ; CHECK:       for.body:\n ; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ], [ [[INDVARS_IV_PH]], [[FOR_BODY_PREHEADER7]] ]\n ; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [58 x double], ptr @b, i64 0, i64 [[INDVARS_IV]]\n-; CHECK-NEXT:    [[TMP76:%.*]] = load double, ptr [[ARRAYIDX]], align 8\n+; CHECK-NEXT:    [[TMP9:%.*]] = load double, ptr [[ARRAYIDX]], align 8\n ; CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [58 x double], ptr @c, i64 0, i64 [[INDVARS_IV]]\n-; CHECK-NEXT:    [[TMP77:%.*]] = load double, ptr [[ARRAYIDX2]], align 8\n-; CHECK-NEXT:    [[ADD:%.*]] = fadd double [[TMP76]], [[TMP77]]\n+; CHECK-NEXT:    [[TMP10:%.*]] = load double, ptr [[ARRAYIDX2]], align 8\n+; CHECK-NEXT:    [[ADD:%.*]] = fadd double [[TMP9]], [[TMP10]]\n ; CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [58 x double], ptr @a, i64 0, i64 [[INDVARS_IV]]\n ; CHECK-NEXT:    store double [[ADD]], ptr [[ARRAYIDX4]], align 8\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], [[WIDE_TRIP_COUNT]]\n-; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[EXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP4:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[EXIT]], label [[FOR_BODY]], !llvm.loop [[LOOP3:![0-9]+]]\n ; CHECK:       exit:\n ; CHECK-NEXT:    ret void\n ;"
            },
            {
                "fn": "llvm/test/Transforms/PhaseOrdering/X86/vdiv.ll",
                "patch": "@@ -35,188 +35,127 @@ define void @vdiv(ptr %x, ptr %y, double %a, i32 %N) #0 {\n ; CHECK-NEXT:    [[BROADCAST_SPLAT12:%.*]] = shufflevector <4 x double> [[BROADCAST_SPLATINSERT11]], <4 x double> poison, <4 x i32> zeroinitializer\n ; CHECK-NEXT:    [[BROADCAST_SPLATINSERT13:%.*]] = insertelement <4 x double> poison, double [[A]], i64 0\n ; CHECK-NEXT:    [[BROADCAST_SPLAT14:%.*]] = shufflevector <4 x double> [[BROADCAST_SPLATINSERT13]], <4 x double> poison, <4 x i32> zeroinitializer\n-; CHECK-NEXT:    [[TMP1:%.*]] = add nsw i64 [[WIDE_TRIP_COUNT]], -16\n-; CHECK-NEXT:    [[TMP2:%.*]] = lshr i64 [[TMP1]], 4\n-; CHECK-NEXT:    [[TMP3:%.*]] = add nuw nsw i64 [[TMP2]], 1\n-; CHECK-NEXT:    [[XTRAITER:%.*]] = and i64 [[TMP3]], 1\n-; CHECK-NEXT:    [[TMP4:%.*]] = icmp ult i64 [[TMP1]], 16\n-; CHECK-NEXT:    br i1 [[TMP4]], label [[MIDDLE_BLOCK_UNR_LCSSA:%.*]], label [[VECTOR_PH_NEW:%.*]]\n-; CHECK:       vector.ph.new:\n-; CHECK-NEXT:    [[UNROLL_ITER:%.*]] = and i64 [[TMP3]], -2\n-; CHECK-NEXT:    [[TMP5:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT]]\n-; CHECK-NEXT:    [[TMP6:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT10]]\n-; CHECK-NEXT:    [[TMP7:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT12]]\n-; CHECK-NEXT:    [[TMP8:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT14]]\n-; CHECK-NEXT:    [[TMP9:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT]]\n-; CHECK-NEXT:    [[TMP10:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT10]]\n-; CHECK-NEXT:    [[TMP11:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT12]]\n-; CHECK-NEXT:    [[TMP12:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT14]]\n+; CHECK-NEXT:    [[TMP1:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT]]\n+; CHECK-NEXT:    [[TMP2:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT10]]\n+; CHECK-NEXT:    [[TMP3:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT12]]\n+; CHECK-NEXT:    [[TMP4:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT14]]\n ; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]\n ; CHECK:       vector.body:\n-; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH_NEW]] ], [ [[INDEX_NEXT_1:%.*]], [[VECTOR_BODY]] ]\n-; CHECK-NEXT:    [[NITER:%.*]] = phi i64 [ 0, [[VECTOR_PH_NEW]] ], [ [[NITER_NEXT_1:%.*]], [[VECTOR_BODY]] ]\n-; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr inbounds double, ptr [[Y]], i64 [[INDEX]]\n-; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x double>, ptr [[TMP13]], align 8, !tbaa [[TBAA3:![0-9]+]]\n-; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr inbounds double, ptr [[TMP13]], i64 4\n-; CHECK-NEXT:    [[WIDE_LOAD6:%.*]] = load <4 x double>, ptr [[TMP15]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP17:%.*]] = getelementptr inbounds double, ptr [[TMP13]], i64 8\n-; CHECK-NEXT:    [[WIDE_LOAD7:%.*]] = load <4 x double>, ptr [[TMP17]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP19:%.*]] = getelementptr inbounds double, ptr [[TMP13]], i64 12\n-; CHECK-NEXT:    [[WIDE_LOAD8:%.*]] = load <4 x double>, ptr [[TMP19]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP21:%.*]] = fmul fast <4 x double> [[WIDE_LOAD]], [[TMP5]]\n-; CHECK-NEXT:    [[TMP22:%.*]] = fmul fast <4 x double> [[WIDE_LOAD6]], [[TMP6]]\n-; CHECK-NEXT:    [[TMP23:%.*]] = fmul fast <4 x double> [[WIDE_LOAD7]], [[TMP7]]\n-; CHECK-NEXT:    [[TMP24:%.*]] = fmul fast <4 x double> [[WIDE_LOAD8]], [[TMP8]]\n-; CHECK-NEXT:    [[TMP25:%.*]] = getelementptr inbounds double, ptr [[X]], i64 [[INDEX]]\n-; CHECK-NEXT:    store <4 x double> [[TMP21]], ptr [[TMP25]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP27:%.*]] = getelementptr inbounds double, ptr [[TMP25]], i64 4\n-; CHECK-NEXT:    store <4 x double> [[TMP22]], ptr [[TMP27]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP29:%.*]] = getelementptr inbounds double, ptr [[TMP25]], i64 8\n-; CHECK-NEXT:    store <4 x double> [[TMP23]], ptr [[TMP29]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP31:%.*]] = getelementptr inbounds double, ptr [[TMP25]], i64 12\n-; CHECK-NEXT:    store <4 x double> [[TMP24]], ptr [[TMP31]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[INDEX_NEXT:%.*]] = or i64 [[INDEX]], 16\n-; CHECK-NEXT:    [[TMP33:%.*]] = getelementptr inbounds double, ptr [[Y]], i64 [[INDEX_NEXT]]\n-; CHECK-NEXT:    [[WIDE_LOAD_1:%.*]] = load <4 x double>, ptr [[TMP33]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP35:%.*]] = getelementptr inbounds double, ptr [[TMP33]], i64 4\n-; CHECK-NEXT:    [[WIDE_LOAD6_1:%.*]] = load <4 x double>, ptr [[TMP35]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP37:%.*]] = getelementptr inbounds double, ptr [[TMP33]], i64 8\n-; CHECK-NEXT:    [[WIDE_LOAD7_1:%.*]] = load <4 x double>, ptr [[TMP37]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP39:%.*]] = getelementptr inbounds double, ptr [[TMP33]], i64 12\n-; CHECK-NEXT:    [[WIDE_LOAD8_1:%.*]] = load <4 x double>, ptr [[TMP39]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP41:%.*]] = fmul fast <4 x double> [[WIDE_LOAD_1]], [[TMP9]]\n-; CHECK-NEXT:    [[TMP42:%.*]] = fmul fast <4 x double> [[WIDE_LOAD6_1]], [[TMP10]]\n-; CHECK-NEXT:    [[TMP43:%.*]] = fmul fast <4 x double> [[WIDE_LOAD7_1]], [[TMP11]]\n-; CHECK-NEXT:    [[TMP44:%.*]] = fmul fast <4 x double> [[WIDE_LOAD8_1]], [[TMP12]]\n-; CHECK-NEXT:    [[TMP45:%.*]] = getelementptr inbounds double, ptr [[X]], i64 [[INDEX_NEXT]]\n-; CHECK-NEXT:    store <4 x double> [[TMP41]], ptr [[TMP45]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP47:%.*]] = getelementptr inbounds double, ptr [[TMP45]], i64 4\n-; CHECK-NEXT:    store <4 x double> [[TMP42]], ptr [[TMP47]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP49:%.*]] = getelementptr inbounds double, ptr [[TMP45]], i64 8\n-; CHECK-NEXT:    store <4 x double> [[TMP43]], ptr [[TMP49]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP51:%.*]] = getelementptr inbounds double, ptr [[TMP45]], i64 12\n-; CHECK-NEXT:    store <4 x double> [[TMP44]], ptr [[TMP51]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[INDEX_NEXT_1]] = add nuw i64 [[INDEX]], 32\n-; CHECK-NEXT:    [[NITER_NEXT_1]] = add i64 [[NITER]], 2\n-; CHECK-NEXT:    [[NITER_NCMP_1:%.*]] = icmp eq i64 [[NITER_NEXT_1]], [[UNROLL_ITER]]\n-; CHECK-NEXT:    br i1 [[NITER_NCMP_1]], label [[MIDDLE_BLOCK_UNR_LCSSA]], label [[VECTOR_BODY]], !llvm.loop [[LOOP7:![0-9]+]]\n-; CHECK:       middle.block.unr-lcssa:\n-; CHECK-NEXT:    [[INDEX_UNR:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT_1]], [[VECTOR_BODY]] ]\n-; CHECK-NEXT:    [[LCMP_MOD_NOT:%.*]] = icmp eq i64 [[XTRAITER]], 0\n-; CHECK-NEXT:    br i1 [[LCMP_MOD_NOT]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY_EPIL:%.*]]\n-; CHECK:       vector.body.epil:\n-; CHECK-NEXT:    [[TMP53:%.*]] = getelementptr inbounds double, ptr [[Y]], i64 [[INDEX_UNR]]\n-; CHECK-NEXT:    [[WIDE_LOAD_EPIL:%.*]] = load <4 x double>, ptr [[TMP53]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP55:%.*]] = getelementptr inbounds double, ptr [[TMP53]], i64 4\n-; CHECK-NEXT:    [[WIDE_LOAD6_EPIL:%.*]] = load <4 x double>, ptr [[TMP55]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP57:%.*]] = getelementptr inbounds double, ptr [[TMP53]], i64 8\n-; CHECK-NEXT:    [[WIDE_LOAD7_EPIL:%.*]] = load <4 x double>, ptr [[TMP57]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP59:%.*]] = getelementptr inbounds double, ptr [[TMP53]], i64 12\n-; CHECK-NEXT:    [[WIDE_LOAD8_EPIL:%.*]] = load <4 x double>, ptr [[TMP59]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP61:%.*]] = fdiv fast <4 x double> [[WIDE_LOAD_EPIL]], [[BROADCAST_SPLAT]]\n-; CHECK-NEXT:    [[TMP62:%.*]] = fdiv fast <4 x double> [[WIDE_LOAD6_EPIL]], [[BROADCAST_SPLAT10]]\n-; CHECK-NEXT:    [[TMP63:%.*]] = fdiv fast <4 x double> [[WIDE_LOAD7_EPIL]], [[BROADCAST_SPLAT12]]\n-; CHECK-NEXT:    [[TMP64:%.*]] = fdiv fast <4 x double> [[WIDE_LOAD8_EPIL]], [[BROADCAST_SPLAT14]]\n-; CHECK-NEXT:    [[TMP65:%.*]] = getelementptr inbounds double, ptr [[X]], i64 [[INDEX_UNR]]\n-; CHECK-NEXT:    store <4 x double> [[TMP61]], ptr [[TMP65]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP67:%.*]] = getelementptr inbounds double, ptr [[TMP65]], i64 4\n-; CHECK-NEXT:    store <4 x double> [[TMP62]], ptr [[TMP67]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP69:%.*]] = getelementptr inbounds double, ptr [[TMP65]], i64 8\n-; CHECK-NEXT:    store <4 x double> [[TMP63]], ptr [[TMP69]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP71:%.*]] = getelementptr inbounds double, ptr [[TMP65]], i64 12\n-; CHECK-NEXT:    store <4 x double> [[TMP64]], ptr [[TMP71]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    br label [[MIDDLE_BLOCK]]\n+; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]\n+; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds double, ptr [[Y]], i64 [[INDEX]]\n+; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x double>, ptr [[TMP5]], align 8, !tbaa [[TBAA3:![0-9]+]]\n+; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds double, ptr [[TMP5]], i64 4\n+; CHECK-NEXT:    [[WIDE_LOAD6:%.*]] = load <4 x double>, ptr [[TMP6]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds double, ptr [[TMP5]], i64 8\n+; CHECK-NEXT:    [[WIDE_LOAD7:%.*]] = load <4 x double>, ptr [[TMP7]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds double, ptr [[TMP5]], i64 12\n+; CHECK-NEXT:    [[WIDE_LOAD8:%.*]] = load <4 x double>, ptr [[TMP8]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    [[TMP9:%.*]] = fmul fast <4 x double> [[WIDE_LOAD]], [[TMP1]]\n+; CHECK-NEXT:    [[TMP10:%.*]] = fmul fast <4 x double> [[WIDE_LOAD6]], [[TMP2]]\n+; CHECK-NEXT:    [[TMP11:%.*]] = fmul fast <4 x double> [[WIDE_LOAD7]], [[TMP3]]\n+; CHECK-NEXT:    [[TMP12:%.*]] = fmul fast <4 x double> [[WIDE_LOAD8]], [[TMP4]]\n+; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr inbounds double, ptr [[X]], i64 [[INDEX]]\n+; CHECK-NEXT:    store <4 x double> [[TMP9]], ptr [[TMP13]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    [[TMP14:%.*]] = getelementptr inbounds double, ptr [[TMP13]], i64 4\n+; CHECK-NEXT:    store <4 x double> [[TMP10]], ptr [[TMP14]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    [[TMP15:%.*]] = getelementptr inbounds double, ptr [[TMP13]], i64 8\n+; CHECK-NEXT:    store <4 x double> [[TMP11]], ptr [[TMP15]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    [[TMP16:%.*]] = getelementptr inbounds double, ptr [[TMP13]], i64 12\n+; CHECK-NEXT:    store <4 x double> [[TMP12]], ptr [[TMP16]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i64 [[INDEX]], 16\n+; CHECK-NEXT:    [[TMP17:%.*]] = icmp eq i64 [[INDEX_NEXT]], [[N_VEC]]\n+; CHECK-NEXT:    br i1 [[TMP17]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP7:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N_VEC]], [[WIDE_TRIP_COUNT]]\n ; CHECK-NEXT:    br i1 [[CMP_N]], label [[FOR_END]], label [[FOR_BODY_PREHEADER15]]\n ; CHECK:       for.body.preheader15:\n ; CHECK-NEXT:    [[INDVARS_IV_PH:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[N_VEC]], [[MIDDLE_BLOCK]] ]\n-; CHECK-NEXT:    [[TMP73:%.*]] = xor i64 [[INDVARS_IV_PH]], -1\n-; CHECK-NEXT:    [[TMP74:%.*]] = add nsw i64 [[TMP73]], [[WIDE_TRIP_COUNT]]\n-; CHECK-NEXT:    [[XTRAITER16:%.*]] = and i64 [[WIDE_TRIP_COUNT]], 7\n-; CHECK-NEXT:    [[LCMP_MOD17_NOT:%.*]] = icmp eq i64 [[XTRAITER16]], 0\n-; CHECK-NEXT:    br i1 [[LCMP_MOD17_NOT]], label [[FOR_BODY_PROL_LOOPEXIT:%.*]], label [[FOR_BODY_PROL_PREHEADER:%.*]]\n+; CHECK-NEXT:    [[TMP18:%.*]] = xor i64 [[INDVARS_IV_PH]], -1\n+; CHECK-NEXT:    [[TMP19:%.*]] = add nsw i64 [[TMP18]], [[WIDE_TRIP_COUNT]]\n+; CHECK-NEXT:    [[XTRAITER:%.*]] = and i64 [[WIDE_TRIP_COUNT]], 7\n+; CHECK-NEXT:    [[LCMP_MOD_NOT:%.*]] = icmp eq i64 [[XTRAITER]], 0\n+; CHECK-NEXT:    br i1 [[LCMP_MOD_NOT]], label [[FOR_BODY_PROL_LOOPEXIT:%.*]], label [[FOR_BODY_PROL_PREHEADER:%.*]]\n ; CHECK:       for.body.prol.preheader:\n-; CHECK-NEXT:    [[TMP75:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n+; CHECK-NEXT:    [[TMP20:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n ; CHECK-NEXT:    br label [[FOR_BODY_PROL:%.*]]\n ; CHECK:       for.body.prol:\n ; CHECK-NEXT:    [[INDVARS_IV_PROL:%.*]] = phi i64 [ [[INDVARS_IV_NEXT_PROL:%.*]], [[FOR_BODY_PROL]] ], [ [[INDVARS_IV_PH]], [[FOR_BODY_PROL_PREHEADER]] ]\n ; CHECK-NEXT:    [[PROL_ITER:%.*]] = phi i64 [ [[PROL_ITER_NEXT:%.*]], [[FOR_BODY_PROL]] ], [ 0, [[FOR_BODY_PROL_PREHEADER]] ]\n ; CHECK-NEXT:    [[ARRAYIDX_PROL:%.*]] = getelementptr inbounds double, ptr [[Y]], i64 [[INDVARS_IV_PROL]]\n ; CHECK-NEXT:    [[T0_PROL:%.*]] = load double, ptr [[ARRAYIDX_PROL]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP76:%.*]] = fmul fast double [[T0_PROL]], [[TMP75]]\n+; CHECK-NEXT:    [[TMP21:%.*]] = fmul fast double [[T0_PROL]], [[TMP20]]\n ; CHECK-NEXT:    [[ARRAYIDX2_PROL:%.*]] = getelementptr inbounds double, ptr [[X]], i64 [[INDVARS_IV_PROL]]\n-; CHECK-NEXT:    store double [[TMP76]], ptr [[ARRAYIDX2_PROL]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    store double [[TMP21]], ptr [[ARRAYIDX2_PROL]], align 8, !tbaa [[TBAA3]]\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT_PROL]] = add nuw nsw i64 [[INDVARS_IV_PROL]], 1\n ; CHECK-NEXT:    [[PROL_ITER_NEXT]] = add i64 [[PROL_ITER]], 1\n-; CHECK-NEXT:    [[PROL_ITER_CMP_NOT:%.*]] = icmp eq i64 [[PROL_ITER_NEXT]], [[XTRAITER16]]\n-; CHECK-NEXT:    br i1 [[PROL_ITER_CMP_NOT]], label [[FOR_BODY_PROL_LOOPEXIT]], label [[FOR_BODY_PROL]], !llvm.loop [[LOOP9:![0-9]+]]\n+; CHECK-NEXT:    [[PROL_ITER_CMP_NOT:%.*]] = icmp eq i64 [[PROL_ITER_NEXT]], [[XTRAITER]]\n+; CHECK-NEXT:    br i1 [[PROL_ITER_CMP_NOT]], label [[FOR_BODY_PROL_LOOPEXIT]], label [[FOR_BODY_PROL]], !llvm.loop [[LOOP10:![0-9]+]]\n ; CHECK:       for.body.prol.loopexit:\n ; CHECK-NEXT:    [[INDVARS_IV_UNR:%.*]] = phi i64 [ [[INDVARS_IV_PH]], [[FOR_BODY_PREHEADER15]] ], [ [[INDVARS_IV_NEXT_PROL]], [[FOR_BODY_PROL]] ]\n-; CHECK-NEXT:    [[TMP77:%.*]] = icmp ult i64 [[TMP74]], 7\n-; CHECK-NEXT:    br i1 [[TMP77]], label [[FOR_END]], label [[FOR_BODY_PREHEADER15_NEW:%.*]]\n+; CHECK-NEXT:    [[TMP22:%.*]] = icmp ult i64 [[TMP19]], 7\n+; CHECK-NEXT:    br i1 [[TMP22]], label [[FOR_END]], label [[FOR_BODY_PREHEADER15_NEW:%.*]]\n ; CHECK:       for.body.preheader15.new:\n-; CHECK-NEXT:    [[TMP78:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n-; CHECK-NEXT:    [[TMP79:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n-; CHECK-NEXT:    [[TMP80:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n-; CHECK-NEXT:    [[TMP81:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n-; CHECK-NEXT:    [[TMP82:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n-; CHECK-NEXT:    [[TMP83:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n-; CHECK-NEXT:    [[TMP84:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n-; CHECK-NEXT:    [[TMP85:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n+; CHECK-NEXT:    [[TMP23:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n+; CHECK-NEXT:    [[TMP24:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n+; CHECK-NEXT:    [[TMP25:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n+; CHECK-NEXT:    [[TMP26:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n+; CHECK-NEXT:    [[TMP27:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n+; CHECK-NEXT:    [[TMP28:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n+; CHECK-NEXT:    [[TMP29:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n+; CHECK-NEXT:    [[TMP30:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n ; CHECK-NEXT:    br label [[FOR_BODY:%.*]]\n ; CHECK:       for.body:\n ; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_UNR]], [[FOR_BODY_PREHEADER15_NEW]] ], [ [[INDVARS_IV_NEXT_7:%.*]], [[FOR_BODY]] ]\n ; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds double, ptr [[Y]], i64 [[INDVARS_IV]]\n ; CHECK-NEXT:    [[T0:%.*]] = load double, ptr [[ARRAYIDX]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP86:%.*]] = fmul fast double [[T0]], [[TMP78]]\n+; CHECK-NEXT:    [[TMP31:%.*]] = fmul fast double [[T0]], [[TMP23]]\n ; CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds double, ptr [[X]], i64 [[INDVARS_IV]]\n-; CHECK-NEXT:    store double [[TMP86]], ptr [[ARRAYIDX2]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    store double [[TMP31]], ptr [[ARRAYIDX2]], align 8, !tbaa [[TBAA3]]\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT:%.*]] = add nuw nsw i64 [[INDVARS_IV]], 1\n ; CHECK-NEXT:    [[ARRAYIDX_1:%.*]] = getelementptr inbounds double, ptr [[Y]], i64 [[INDVARS_IV_NEXT]]\n ; CHECK-NEXT:    [[T0_1:%.*]] = load double, ptr [[ARRAYIDX_1]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP87:%.*]] = fmul fast double [[T0_1]], [[TMP79]]\n+; CHECK-NEXT:    [[TMP32:%.*]] = fmul fast double [[T0_1]], [[TMP24]]\n ; CHECK-NEXT:    [[ARRAYIDX2_1:%.*]] = getelementptr inbounds double, ptr [[X]], i64 [[INDVARS_IV_NEXT]]\n-; CHECK-NEXT:    store double [[TMP87]], ptr [[ARRAYIDX2_1]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    store double [[TMP32]], ptr [[ARRAYIDX2_1]], align 8, !tbaa [[TBAA3]]\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT_1:%.*]] = add nuw nsw i64 [[INDVARS_IV]], 2\n ; CHECK-NEXT:    [[ARRAYIDX_2:%.*]] = getelementptr inbounds double, ptr [[Y]], i64 [[INDVARS_IV_NEXT_1]]\n ; CHECK-NEXT:    [[T0_2:%.*]] = load double, ptr [[ARRAYIDX_2]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP88:%.*]] = fmul fast double [[T0_2]], [[TMP80]]\n+; CHECK-NEXT:    [[TMP33:%.*]] = fmul fast double [[T0_2]], [[TMP25]]\n ; CHECK-NEXT:    [[ARRAYIDX2_2:%.*]] = getelementptr inbounds double, ptr [[X]], i64 [[INDVARS_IV_NEXT_1]]\n-; CHECK-NEXT:    store double [[TMP88]], ptr [[ARRAYIDX2_2]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    store double [[TMP33]], ptr [[ARRAYIDX2_2]], align 8, !tbaa [[TBAA3]]\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT_2:%.*]] = add nuw nsw i64 [[INDVARS_IV]], 3\n ; CHECK-NEXT:    [[ARRAYIDX_3:%.*]] = getelementptr inbounds double, ptr [[Y]], i64 [[INDVARS_IV_NEXT_2]]\n ; CHECK-NEXT:    [[T0_3:%.*]] = load double, ptr [[ARRAYIDX_3]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP89:%.*]] = fmul fast double [[T0_3]], [[TMP81]]\n+; CHECK-NEXT:    [[TMP34:%.*]] = fmul fast double [[T0_3]], [[TMP26]]\n ; CHECK-NEXT:    [[ARRAYIDX2_3:%.*]] = getelementptr inbounds double, ptr [[X]], i64 [[INDVARS_IV_NEXT_2]]\n-; CHECK-NEXT:    store double [[TMP89]], ptr [[ARRAYIDX2_3]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    store double [[TMP34]], ptr [[ARRAYIDX2_3]], align 8, !tbaa [[TBAA3]]\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT_3:%.*]] = add nuw nsw i64 [[INDVARS_IV]], 4\n ; CHECK-NEXT:    [[ARRAYIDX_4:%.*]] = getelementptr inbounds double, ptr [[Y]], i64 [[INDVARS_IV_NEXT_3]]\n ; CHECK-NEXT:    [[T0_4:%.*]] = load double, ptr [[ARRAYIDX_4]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP90:%.*]] = fmul fast double [[T0_4]], [[TMP82]]\n+; CHECK-NEXT:    [[TMP35:%.*]] = fmul fast double [[T0_4]], [[TMP27]]\n ; CHECK-NEXT:    [[ARRAYIDX2_4:%.*]] = getelementptr inbounds double, ptr [[X]], i64 [[INDVARS_IV_NEXT_3]]\n-; CHECK-NEXT:    store double [[TMP90]], ptr [[ARRAYIDX2_4]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    store double [[TMP35]], ptr [[ARRAYIDX2_4]], align 8, !tbaa [[TBAA3]]\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT_4:%.*]] = add nuw nsw i64 [[INDVARS_IV]], 5\n ; CHECK-NEXT:    [[ARRAYIDX_5:%.*]] = getelementptr inbounds double, ptr [[Y]], i64 [[INDVARS_IV_NEXT_4]]\n ; CHECK-NEXT:    [[T0_5:%.*]] = load double, ptr [[ARRAYIDX_5]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP91:%.*]] = fmul fast double [[T0_5]], [[TMP83]]\n+; CHECK-NEXT:    [[TMP36:%.*]] = fmul fast double [[T0_5]], [[TMP28]]\n ; CHECK-NEXT:    [[ARRAYIDX2_5:%.*]] = getelementptr inbounds double, ptr [[X]], i64 [[INDVARS_IV_NEXT_4]]\n-; CHECK-NEXT:    store double [[TMP91]], ptr [[ARRAYIDX2_5]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    store double [[TMP36]], ptr [[ARRAYIDX2_5]], align 8, !tbaa [[TBAA3]]\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT_5:%.*]] = add nuw nsw i64 [[INDVARS_IV]], 6\n ; CHECK-NEXT:    [[ARRAYIDX_6:%.*]] = getelementptr inbounds double, ptr [[Y]], i64 [[INDVARS_IV_NEXT_5]]\n ; CHECK-NEXT:    [[T0_6:%.*]] = load double, ptr [[ARRAYIDX_6]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP92:%.*]] = fmul fast double [[T0_6]], [[TMP84]]\n+; CHECK-NEXT:    [[TMP37:%.*]] = fmul fast double [[T0_6]], [[TMP29]]\n ; CHECK-NEXT:    [[ARRAYIDX2_6:%.*]] = getelementptr inbounds double, ptr [[X]], i64 [[INDVARS_IV_NEXT_5]]\n-; CHECK-NEXT:    store double [[TMP92]], ptr [[ARRAYIDX2_6]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    store double [[TMP37]], ptr [[ARRAYIDX2_6]], align 8, !tbaa [[TBAA3]]\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT_6:%.*]] = add nuw nsw i64 [[INDVARS_IV]], 7\n ; CHECK-NEXT:    [[ARRAYIDX_7:%.*]] = getelementptr inbounds double, ptr [[Y]], i64 [[INDVARS_IV_NEXT_6]]\n ; CHECK-NEXT:    [[T0_7:%.*]] = load double, ptr [[ARRAYIDX_7]], align 8, !tbaa [[TBAA3]]\n-; CHECK-NEXT:    [[TMP93:%.*]] = fmul fast double [[T0_7]], [[TMP85]]\n+; CHECK-NEXT:    [[TMP38:%.*]] = fmul fast double [[T0_7]], [[TMP30]]\n ; CHECK-NEXT:    [[ARRAYIDX2_7:%.*]] = getelementptr inbounds double, ptr [[X]], i64 [[INDVARS_IV_NEXT_6]]\n-; CHECK-NEXT:    store double [[TMP93]], ptr [[ARRAYIDX2_7]], align 8, !tbaa [[TBAA3]]\n+; CHECK-NEXT:    store double [[TMP38]], ptr [[ARRAYIDX2_7]], align 8, !tbaa [[TBAA3]]\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT_7]] = add nuw nsw i64 [[INDVARS_IV]], 8\n ; CHECK-NEXT:    [[EXITCOND_NOT_7:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT_7]], [[WIDE_TRIP_COUNT]]\n-; CHECK-NEXT:    br i1 [[EXITCOND_NOT_7]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP11:![0-9]+]]\n+; CHECK-NEXT:    br i1 [[EXITCOND_NOT_7]], label [[FOR_END]], label [[FOR_BODY]], !llvm.loop [[LOOP12:![0-9]+]]\n ; CHECK:       for.end:\n ; CHECK-NEXT:    ret void\n ;"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/LoopVectorize/X86/already-vectorized.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/X86/already-vectorized.ll\n\n\nTesting Time: 0.23s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopVectorize/X86/float-induction-x86.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/X86/float-induction-x86.ll\n\n\nTesting Time: 0.44s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nPASS: LLVM :: Transforms/LoopVectorize/X86/gather_scatter.ll (1 of 1)\n\nTesting Time: 0.42s\n  Passed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopVectorize/X86/invariant-load-gather.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/X86/invariant-load-gather.ll\n\n\nTesting Time: 0.26s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopVectorize/X86/invariant-store-vectorization.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/X86/invariant-store-vectorization.ll\n\n\nTesting Time: 0.35s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopVectorize/X86/masked_load_store.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/X86/masked_load_store.ll\n\n\nTesting Time: 0.68s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nPASS: LLVM :: Transforms/LoopVectorize/X86/metadata-enable.ll (1 of 1)\n\nTesting Time: 3.78s\n  Passed: 1\n-- Testing: 1 tests, 1 workers --\nPASS: LLVM :: Transforms/LoopVectorize/X86/tail_loop_folding.ll (1 of 1)\n\nTesting Time: 0.76s\n  Passed: 1\n-- Testing: 1 tests, 1 workers --\nPASS: LLVM :: Transforms/LoopVectorize/X86/uniform_mem_op.ll (1 of 1)\n\nTesting Time: 0.34s\n  Passed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopVectorize/followup.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/followup.ll\n\n\nTesting Time: 0.44s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopVectorize/if-p"
    },
    "7b54a29c2e72e3e6bf7bb8cb5acfe254335584d7___X86ISelLowering.cpp": {
        "prefix": "static bool checkBitcastSrcVectorSize(SDValue Src, unsigned Size,\n                                      bool AllowTruncate) {\n  switch (Src.getOpcode()) {\n  case ISD::TRUNCATE:\n    if (!AllowTruncate)\n      return false;\n    [[fallthrough]];\n  case ISD::SETCC:\n    return Src.getOperand(0).getValueSizeInBits() == Size;\n  case ISD::AND:\n  case ISD::XOR:\n  case ISD::OR:\n    return checkBitcastSrcVectorSize(Src.getOperand(0), Size, AllowTruncate) &&\n           checkBitcastSrcVectorSize(Src.getOperand(1), Size, AllowTruncate);\n  case ISD::VSELECT:\n    return Src.getOperand(0).getScalarValueSizeInBits() == 1 &&\n           checkBitcastSrcVectorSize(Src.getOperand(1), Size, AllowTruncate) &&\n           checkBitcastSrcVectorSize(Src.getOperand(2), Size, AllowTruncate);\n  case ISD::BUILD_VECTOR:\n",
        "suffix": "  return false;\n}\n",
        "start": 43660,
        "end": 43683,
        "buggy": "static bool checkBitcastSrcVectorSize(SDValue Src, unsigned Size,\n                                      bool AllowTruncate) {\n  switch (Src.getOpcode()) {\n  case ISD::TRUNCATE:\n    if (!AllowTruncate)\n      return false;\n    [[fallthrough]];\n  case ISD::SETCC:\n    return Src.getOperand(0).getValueSizeInBits() == Size;\n  case ISD::AND:\n  case ISD::XOR:\n  case ISD::OR:\n    return checkBitcastSrcVectorSize(Src.getOperand(0), Size, AllowTruncate) &&\n           checkBitcastSrcVectorSize(Src.getOperand(1), Size, AllowTruncate);\n  case ISD::VSELECT:\n    return Src.getOperand(0).getScalarValueSizeInBits() == 1 &&\n           checkBitcastSrcVectorSize(Src.getOperand(1), Size, AllowTruncate) &&\n           checkBitcastSrcVectorSize(Src.getOperand(2), Size, AllowTruncate);\n  case ISD::BUILD_VECTOR:\n    return ISD::isBuildVectorAllZeros(Src.getNode());\n\n  }\n  return false;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    return ISD::isBuildVectorAllZeros(Src.getNode());\n\n  }\n",
        "src_path": "7b54a29c2e72e3e6bf7bb8cb5acfe254335584d7___X86ISelLowering.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/7b54a29c2e72e3e6bf7bb8cb5acfe254335584d7",
        "commit_msg": "[X86] combineBitcastvxi1/checkBitcastSrcVectorSize - sign-extend vXi1 allones vselect operands\n\nMinor fix to Issue #61104",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/bitcast-and-setcc-256.ll",
                "patch": "@@ -463,30 +463,22 @@ define i8 @v8i32_or_select(<8 x i32> %a0, <8 x i32> %a1, <8 x i32> %a2) {\n ;\n ; AVX1-LABEL: v8i32_or_select:\n ; AVX1:       # %bb.0:\n-; AVX1-NEXT:    vpcmpeqd %xmm1, %xmm0, %xmm3\n-; AVX1-NEXT:    vextractf128 $1, %ymm1, %xmm1\n-; AVX1-NEXT:    vextractf128 $1, %ymm0, %xmm0\n+; AVX1-NEXT:    vextractf128 $1, %ymm1, %xmm3\n+; AVX1-NEXT:    vextractf128 $1, %ymm0, %xmm4\n+; AVX1-NEXT:    vpcmpeqd %xmm3, %xmm4, %xmm3\n ; AVX1-NEXT:    vpcmpeqd %xmm1, %xmm0, %xmm0\n-; AVX1-NEXT:    vextractf128 $1, %ymm2, %xmm1\n-; AVX1-NEXT:    vpor %xmm1, %xmm0, %xmm0\n-; AVX1-NEXT:    vpor %xmm2, %xmm3, %xmm1\n-; AVX1-NEXT:    vpackssdw %xmm0, %xmm1, %xmm0\n-; AVX1-NEXT:    vpacksswb %xmm0, %xmm0, %xmm0\n-; AVX1-NEXT:    vpmovmskb %xmm0, %eax\n+; AVX1-NEXT:    vinsertf128 $1, %xmm3, %ymm0, %ymm0\n+; AVX1-NEXT:    vorps %ymm2, %ymm0, %ymm0\n+; AVX1-NEXT:    vmovmskps %ymm0, %eax\n ; AVX1-NEXT:    # kill: def $al killed $al killed $eax\n ; AVX1-NEXT:    vzeroupper\n ; AVX1-NEXT:    retq\n ;\n ; AVX2-LABEL: v8i32_or_select:\n ; AVX2:       # %bb.0:\n ; AVX2-NEXT:    vpcmpeqd %ymm1, %ymm0, %ymm0\n-; AVX2-NEXT:    vpxor %xmm1, %xmm1, %xmm1\n-; AVX2-NEXT:    vpcmpgtd %ymm2, %ymm1, %ymm1\n-; AVX2-NEXT:    vpor %ymm1, %ymm0, %ymm0\n-; AVX2-NEXT:    vextracti128 $1, %ymm0, %xmm1\n-; AVX2-NEXT:    vpackssdw %xmm1, %xmm0, %xmm0\n-; AVX2-NEXT:    vpacksswb %xmm0, %xmm0, %xmm0\n-; AVX2-NEXT:    vpmovmskb %xmm0, %eax\n+; AVX2-NEXT:    vpor %ymm2, %ymm0, %ymm0\n+; AVX2-NEXT:    vmovmskps %ymm0, %eax\n ; AVX2-NEXT:    # kill: def $al killed $al killed $eax\n ; AVX2-NEXT:    vzeroupper\n ; AVX2-NEXT:    retq"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/bitcast-and-setcc-256.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/bitcast-and-setcc-256.ll\n\n\nTesting Time: 0.74s\n  Failed: 1\n"
    },
    "9cf1881f8f12a70c28432278a2878a6113c017c1___LoopAccessAnalysis.cpp": {
        "prefix": "static Value *getStrideFromPointer(Value *Ptr, ScalarEvolution *SE, Loop *Lp) {\n  auto *PtrTy = dyn_cast<PointerType>(Ptr->getType());\n  if (!PtrTy || PtrTy->isAggregateType())\n    return nullptr;\n\n  // Try to remove a gep instruction to make the pointer (actually index at this\n  // point) easier analyzable. If OrigPtr is equal to Ptr we are analyzing the\n  // pointer, otherwise, we are analyzing the index.\n  Value *OrigPtr = Ptr;\n\n  // The size of the pointer access.\n  int64_t PtrAccessSize = 1;\n\n  Ptr = stripGetElementPtr(Ptr, SE, Lp);\n  const SCEV *V = SE->getSCEV(Ptr);\n\n  if (Ptr != OrigPtr)\n    // Strip off casts.\n    while (const SCEVIntegralCastExpr *C = dyn_cast<SCEVIntegralCastExpr>(V))\n      V = C->getOperand();\n\n  const SCEVAddRecExpr *S = dyn_cast<SCEVAddRecExpr>(V);\n  if (!S)\n    return nullptr;\n\n",
        "suffix": "  if (!V)\n    return nullptr;\n\n  // Strip off the size of access multiplication if we are still analyzing the\n  // pointer.\n  if (OrigPtr == Ptr) {\n    if (const SCEVMulExpr *M = dyn_cast<SCEVMulExpr>(V)) {\n      if (M->getOperand(0)->getSCEVType() != scConstant)\n        return nullptr;\n\n      const APInt &APStepVal = cast<SCEVConstant>(M->getOperand(0))->getAPInt();\n\n      // Huge step value - give up.\n      if (APStepVal.getBitWidth() > 64)\n        return nullptr;\n\n      int64_t StepVal = APStepVal.getSExtValue();\n      if (PtrAccessSize != StepVal)\n        return nullptr;\n      V = M->getOperand(1);\n    }\n  }\n\n  // Strip off casts.\n  Type *StripedOffRecurrenceCast = nullptr;\n  if (const SCEVIntegralCastExpr *C = dyn_cast<SCEVIntegralCastExpr>(V)) {\n    StripedOffRecurrenceCast = C->getType();\n    V = C->getOperand();\n  }\n\n  // Look for the loop invariant symbolic value.\n  const SCEVUnknown *U = dyn_cast<SCEVUnknown>(V);\n  if (!U)\n    return nullptr;\n\n  Value *Stride = U->getValue();\n  if (!Lp->isLoopInvariant(Stride))\n    return nullptr;\n\n  // If we have stripped off the recurrence cast we have to make sure that we\n  // return the value that is used in this loop so that we can replace it later.\n  if (StripedOffRecurrenceCast)\n    Stride = getUniqueCastUse(Stride, Lp, StripedOffRecurrenceCast);\n\n  return Stride;\n}\n",
        "start": 2620,
        "end": 2691,
        "buggy": "static Value *getStrideFromPointer(Value *Ptr, ScalarEvolution *SE, Loop *Lp) {\n  auto *PtrTy = dyn_cast<PointerType>(Ptr->getType());\n  if (!PtrTy || PtrTy->isAggregateType())\n    return nullptr;\n\n  // Try to remove a gep instruction to make the pointer (actually index at this\n  // point) easier analyzable. If OrigPtr is equal to Ptr we are analyzing the\n  // pointer, otherwise, we are analyzing the index.\n  Value *OrigPtr = Ptr;\n\n  // The size of the pointer access.\n  int64_t PtrAccessSize = 1;\n\n  Ptr = stripGetElementPtr(Ptr, SE, Lp);\n  const SCEV *V = SE->getSCEV(Ptr);\n\n  if (Ptr != OrigPtr)\n    // Strip off casts.\n    while (const SCEVIntegralCastExpr *C = dyn_cast<SCEVIntegralCastExpr>(V))\n      V = C->getOperand();\n\n  const SCEVAddRecExpr *S = dyn_cast<SCEVAddRecExpr>(V);\n  if (!S)\n    return nullptr;\n\n  V = S->getStepRecurrence(*SE);\n  if (!V)\n    return nullptr;\n\n  // Strip off the size of access multiplication if we are still analyzing the\n  // pointer.\n  if (OrigPtr == Ptr) {\n    if (const SCEVMulExpr *M = dyn_cast<SCEVMulExpr>(V)) {\n      if (M->getOperand(0)->getSCEVType() != scConstant)\n        return nullptr;\n\n      const APInt &APStepVal = cast<SCEVConstant>(M->getOperand(0))->getAPInt();\n\n      // Huge step value - give up.\n      if (APStepVal.getBitWidth() > 64)\n        return nullptr;\n\n      int64_t StepVal = APStepVal.getSExtValue();\n      if (PtrAccessSize != StepVal)\n        return nullptr;\n      V = M->getOperand(1);\n    }\n  }\n\n  // Strip off casts.\n  Type *StripedOffRecurrenceCast = nullptr;\n  if (const SCEVIntegralCastExpr *C = dyn_cast<SCEVIntegralCastExpr>(V)) {\n    StripedOffRecurrenceCast = C->getType();\n    V = C->getOperand();\n  }\n\n  // Look for the loop invariant symbolic value.\n  const SCEVUnknown *U = dyn_cast<SCEVUnknown>(V);\n  if (!U)\n    return nullptr;\n\n  Value *Stride = U->getValue();\n  if (!Lp->isLoopInvariant(Stride))\n    return nullptr;\n\n  // If we have stripped off the recurrence cast we have to make sure that we\n  // return the value that is used in this loop so that we can replace it later.\n  if (StripedOffRecurrenceCast)\n    Stride = getUniqueCastUse(Stride, Lp, StripedOffRecurrenceCast);\n\n  return Stride;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  V = S->getStepRecurrence(*SE);\n",
        "src_path": "9cf1881f8f12a70c28432278a2878a6113c017c1___LoopAccessAnalysis.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/9cf1881f8f12a70c28432278a2878a6113c017c1",
        "commit_msg": "[SCEV] Do not plant SCEV checks unnecessarily\n\nThe vectorisation analysis collects strides for loop invariant\npointers, which is wrong because they are not strided. We don't\nneed to generate SCEV checks (which are costly performancewise)\nfor such pointers, we just need to do the appropriate aliasing\nchecks.\n\nThis patch fixes the problem by changing getStrideFromPointer()\nto treat loop invariant pointers as having no stride.\n\nOriginally proposed by David Sherwood with further suggestions\nfrom Florian Hahn.\n\nReviewed By: fhahn\n\nDifferential Revision: https://reviews.llvm.org/D146958",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/LoopVectorize/vector-no-scevcheck.ll",
                "patch": "@@ -5,8 +5,7 @@\n \n define void @foo(ptr %pout, ptr %pin, i64 %val0, i64 %val1, i64 %val2) {\n ; CHECK-LABEL: @foo(\n-; FIXME: CHECK below needs to be changed to CHECK-NOT to confirm the change.\n-; CHECK: vector.scevcheck\n+; CHECK-NOT: vector.scevcheck\n ; CHECK: vector.body\n entry:\n   %0 = getelementptr double, ptr %pin, i64 %val0\n@@ -45,8 +44,7 @@ exit:                                             ; preds = %loop1.latch\n \n define void @bar(ptr %pout, ptr %pin, i64 %val0, i64 %val1, i64 %val2) {\n ; CHECK-LABEL: @bar(\n-; FIXME: CHECK below needs to be changed to CHECK-NOT to confirm the change.\n-; CHECK: vector.scevcheck\n+; CHECK-NOT: vector.scevcheck\n ; CHECK: vector.body\n entry:\n   %0 = getelementptr double, ptr %pin, i64 %val0"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/LoopVectorize/vector-no-scevcheck.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/vector-no-scevcheck.ll\n\n\nTesting Time: 0.37s\n  Failed: 1\n"
    },
    "dc81e69eb126ea1dbab202733ae34b1a3d6eb0cf___SimplifyIndVar.cpp": {
        "prefix": "bool SimplifyIndvar::makeIVComparisonInvariant(ICmpInst *ICmp,\n                                               Instruction *IVOperand) {\n  auto *Preheader = L->getLoopPreheader();\n  if (!Preheader)\n    return false;\n  unsigned IVOperIdx = 0;\n  ICmpInst::Predicate Pred = ICmp->getPredicate();\n  if (IVOperand != ICmp->getOperand(0)) {\n    // Swapped\n    assert(IVOperand == ICmp->getOperand(1) && \"Can't find IVOperand\");\n    IVOperIdx = 1;\n    Pred = ICmpInst::getSwappedPredicate(Pred);\n  }\n\n  // Get the SCEVs for the ICmp operands (in the specific context of the\n  // current loop)\n  const Loop *ICmpLoop = LI->getLoopFor(ICmp->getParent());\n  const SCEV *S = SE->getSCEVAtScope(ICmp->getOperand(IVOperIdx), ICmpLoop);\n  const SCEV *X = SE->getSCEVAtScope(ICmp->getOperand(1 - IVOperIdx), ICmpLoop);\n  auto LIP = SE->getLoopInvariantPredicate(Pred, S, X, L, ICmp);\n  if (!LIP)\n    return false;\n  ICmpInst::Predicate InvariantPredicate = LIP->Pred;\n  const SCEV *InvariantLHS = LIP->LHS;\n  const SCEV *InvariantRHS = LIP->RHS;\n\n  // Do not generate something ridiculous.\n  auto *PHTerm = Preheader->getTerminator();\n",
        "suffix": "  auto *NewLHS =\n      Rewriter.expandCodeFor(InvariantLHS, IVOperand->getType(), PHTerm);\n  auto *NewRHS =\n      Rewriter.expandCodeFor(InvariantRHS, IVOperand->getType(), PHTerm);\n  LLVM_DEBUG(dbgs() << \"INDVARS: Simplified comparison: \" << *ICmp << '\\n');\n  ICmp->setPredicate(InvariantPredicate);\n  ICmp->setOperand(0, NewLHS);\n  ICmp->setOperand(1, NewRHS);\n  return true;\n}\n",
        "start": 192,
        "end": 232,
        "buggy": "bool SimplifyIndvar::makeIVComparisonInvariant(ICmpInst *ICmp,\n                                               Instruction *IVOperand) {\n  auto *Preheader = L->getLoopPreheader();\n  if (!Preheader)\n    return false;\n  unsigned IVOperIdx = 0;\n  ICmpInst::Predicate Pred = ICmp->getPredicate();\n  if (IVOperand != ICmp->getOperand(0)) {\n    // Swapped\n    assert(IVOperand == ICmp->getOperand(1) && \"Can't find IVOperand\");\n    IVOperIdx = 1;\n    Pred = ICmpInst::getSwappedPredicate(Pred);\n  }\n\n  // Get the SCEVs for the ICmp operands (in the specific context of the\n  // current loop)\n  const Loop *ICmpLoop = LI->getLoopFor(ICmp->getParent());\n  const SCEV *S = SE->getSCEVAtScope(ICmp->getOperand(IVOperIdx), ICmpLoop);\n  const SCEV *X = SE->getSCEVAtScope(ICmp->getOperand(1 - IVOperIdx), ICmpLoop);\n  auto LIP = SE->getLoopInvariantPredicate(Pred, S, X, L, ICmp);\n  if (!LIP)\n    return false;\n  ICmpInst::Predicate InvariantPredicate = LIP->Pred;\n  const SCEV *InvariantLHS = LIP->LHS;\n  const SCEV *InvariantRHS = LIP->RHS;\n\n  // Do not generate something ridiculous.\n  auto *PHTerm = Preheader->getTerminator();\n  if (Rewriter.isHighCostExpansion({ InvariantLHS, InvariantRHS }, L,\n                                   2 * SCEVCheapExpansionBudget, TTI, PHTerm))\n    return false;\n  auto *NewLHS =\n      Rewriter.expandCodeFor(InvariantLHS, IVOperand->getType(), PHTerm);\n  auto *NewRHS =\n      Rewriter.expandCodeFor(InvariantRHS, IVOperand->getType(), PHTerm);\n  LLVM_DEBUG(dbgs() << \"INDVARS: Simplified comparison: \" << *ICmp << '\\n');\n  ICmp->setPredicate(InvariantPredicate);\n  ICmp->setOperand(0, NewLHS);\n  ICmp->setOperand(1, NewRHS);\n  return true;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  if (Rewriter.isHighCostExpansion({ InvariantLHS, InvariantRHS }, L,\n                                   2 * SCEVCheapExpansionBudget, TTI, PHTerm))\n    return false;\n",
        "src_path": "dc81e69eb126ea1dbab202733ae34b1a3d6eb0cf___SimplifyIndVar.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/dc81e69eb126ea1dbab202733ae34b1a3d6eb0cf",
        "commit_msg": "[IndVars] Check expansion safety in makeIVComparisonInvariant() (PR62992)\n\nMake sure the invariant expressions are safe to expand. In\nparticular, we should not speculative a trapping division into\nthe preheader.\n\nFixes https://github.com/llvm/llvm-project/issues/62992.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/IndVarSimplify/pr62992.ll",
                "patch": "@@ -0,0 +1,46 @@\n+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2\n+; RUN: opt -S -passes=indvars < %s | FileCheck %s\n+\n+declare void @use(i1)\n+\n+; Make sure the division does not get expanded into the preheader.\n+\n+define i32 @test(i32 %arg) {\n+; CHECK-LABEL: define i32 @test\n+; CHECK-SAME: (i32 [[ARG:%.*]]) {\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    br label [[LOOP:%.*]]\n+; CHECK:       loop:\n+; CHECK-NEXT:    br i1 false, label [[IF:%.*]], label [[LOOP_LATCH:%.*]]\n+; CHECK:       if:\n+; CHECK-NEXT:    [[DIV:%.*]] = udiv i32 7, [[ARG]]\n+; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i32 1, [[DIV]]\n+; CHECK-NEXT:    call void @use(i1 [[CMP2]])\n+; CHECK-NEXT:    br label [[LOOP_LATCH]]\n+; CHECK:       loop.latch:\n+; CHECK-NEXT:    br i1 false, label [[LOOP]], label [[EXIT:%.*]]\n+; CHECK:       exit:\n+; CHECK-NEXT:    ret i32 1\n+;\n+entry:\n+  br label %loop\n+\n+loop:\n+  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop.latch ]\n+  %iv.next = add i32 %iv, 1\n+  %cmp = icmp eq i32 %iv, 1\n+  br i1 %cmp, label %if, label %loop.latch\n+\n+if:\n+  %div = udiv i32 7, %arg\n+  %cmp2 = icmp ult i32 %iv.next, %div\n+  call void @use(i1 %cmp2)\n+  br label %loop.latch\n+\n+loop.latch:\n+  br i1 false, label %loop, label %exit\n+\n+exit:\n+  %inc.lcssa = phi i32 [ %iv.next, %loop.latch ]\n+  ret i32 %inc.lcssa\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/IndVarSimplify/pr62992.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/IndVarSimplify/pr62992.ll\n\n\nTesting Time: 0.36s\n  Failed: 1\n"
    },
    "5a406b63e9d70225cd56fd5c3b791e78f4aed3cc___AttributorAttributes.cpp": {
        "prefix": "  bool checkUse(Attributor &A, AANoCapture::StateType &State, const Use &U,\n                bool &Follow) {\n    Instruction *UInst = cast<Instruction>(U.getUser());\n    LLVM_DEBUG(dbgs() << \"[AANoCapture] Check use: \" << *U.get() << \" in \"\n                      << *UInst << \"\\n\");\n\n    // Deal with ptr2int by following uses.\n    if (isa<PtrToIntInst>(UInst)) {\n      LLVM_DEBUG(dbgs() << \" - ptr2int assume the worst!\\n\");\n      return isCapturedIn(State, /* Memory */ true, /* Integer */ true,\n                          /* Return */ true);\n    }\n\n    // For stores we already checked if we can follow them, if they make it\n    // here we give up.\n    if (isa<StoreInst>(UInst))\n",
        "suffix": "    // Explicitly catch return instructions.\n    if (isa<ReturnInst>(UInst)) {\n      if (UInst->getFunction() == getAnchorScope())\n        return isCapturedIn(State, /* Memory */ false, /* Integer */ false,\n                            /* Return */ true);\n      return isCapturedIn(State, /* Memory */ true, /* Integer */ true,\n                          /* Return */ true);\n    }\n\n    // For now we only use special logic for call sites. However, the tracker\n    // itself knows about a lot of other non-capturing cases already.\n    auto *CB = dyn_cast<CallBase>(UInst);\n    if (!CB || !CB->isArgOperand(&U))\n      return isCapturedIn(State, /* Memory */ true, /* Integer */ true,\n                          /* Return */ true);\n\n    unsigned ArgNo = CB->getArgOperandNo(&U);\n    const IRPosition &CSArgPos = IRPosition::callsite_argument(*CB, ArgNo);\n    // If we have a abstract no-capture attribute for the argument we can use\n    // it to justify a non-capture attribute here. This allows recursion!\n    bool IsKnownNoCapture;\n    const AANoCapture *ArgNoCaptureAA = nullptr;\n    bool IsAssumedNoCapture = AA::hasAssumedIRAttr<Attribute::NoCapture>(\n        A, this, CSArgPos, DepClassTy::REQUIRED, IsKnownNoCapture, false,\n        &ArgNoCaptureAA);\n    if (IsAssumedNoCapture)\n      return isCapturedIn(State, /* Memory */ false, /* Integer */ false,\n                          /* Return */ false);\n    if (ArgNoCaptureAA && ArgNoCaptureAA->isAssumedNoCaptureMaybeReturned()) {\n      Follow = true;\n      return isCapturedIn(State, /* Memory */ false, /* Integer */ false,\n                          /* Return */ false);\n    }\n\n    // Lastly, we could not find a reason no-capture can be assumed so we don't.\n    return isCapturedIn(State, /* Memory */ true, /* Integer */ true,\n                        /* Return */ true);\n  }\n",
        "start": 5872,
        "end": 5928,
        "buggy": "  bool checkUse(Attributor &A, AANoCapture::StateType &State, const Use &U,\n                bool &Follow) {\n    Instruction *UInst = cast<Instruction>(U.getUser());\n    LLVM_DEBUG(dbgs() << \"[AANoCapture] Check use: \" << *U.get() << \" in \"\n                      << *UInst << \"\\n\");\n\n    // Deal with ptr2int by following uses.\n    if (isa<PtrToIntInst>(UInst)) {\n      LLVM_DEBUG(dbgs() << \" - ptr2int assume the worst!\\n\");\n      return isCapturedIn(State, /* Memory */ true, /* Integer */ true,\n                          /* Return */ true);\n    }\n\n    // For stores we already checked if we can follow them, if they make it\n    // here we give up.\n    if (isa<StoreInst>(UInst))\n      return isCapturedIn(State, /* Memory */ true, /* Integer */ false,\n                          /* Return */ false);\n\n    // Explicitly catch return instructions.\n    if (isa<ReturnInst>(UInst)) {\n      if (UInst->getFunction() == getAnchorScope())\n        return isCapturedIn(State, /* Memory */ false, /* Integer */ false,\n                            /* Return */ true);\n      return isCapturedIn(State, /* Memory */ true, /* Integer */ true,\n                          /* Return */ true);\n    }\n\n    // For now we only use special logic for call sites. However, the tracker\n    // itself knows about a lot of other non-capturing cases already.\n    auto *CB = dyn_cast<CallBase>(UInst);\n    if (!CB || !CB->isArgOperand(&U))\n      return isCapturedIn(State, /* Memory */ true, /* Integer */ true,\n                          /* Return */ true);\n\n    unsigned ArgNo = CB->getArgOperandNo(&U);\n    const IRPosition &CSArgPos = IRPosition::callsite_argument(*CB, ArgNo);\n    // If we have a abstract no-capture attribute for the argument we can use\n    // it to justify a non-capture attribute here. This allows recursion!\n    bool IsKnownNoCapture;\n    const AANoCapture *ArgNoCaptureAA = nullptr;\n    bool IsAssumedNoCapture = AA::hasAssumedIRAttr<Attribute::NoCapture>(\n        A, this, CSArgPos, DepClassTy::REQUIRED, IsKnownNoCapture, false,\n        &ArgNoCaptureAA);\n    if (IsAssumedNoCapture)\n      return isCapturedIn(State, /* Memory */ false, /* Integer */ false,\n                          /* Return */ false);\n    if (ArgNoCaptureAA && ArgNoCaptureAA->isAssumedNoCaptureMaybeReturned()) {\n      Follow = true;\n      return isCapturedIn(State, /* Memory */ false, /* Integer */ false,\n                          /* Return */ false);\n    }\n\n    // Lastly, we could not find a reason no-capture can be assumed so we don't.\n    return isCapturedIn(State, /* Memory */ true, /* Integer */ true,\n                        /* Return */ true);\n  }\n",
        "fix": null,
        "buggy_hunk_masked": "      return isCapturedIn(State, /* Memory */ true, /* Integer */ false,\n                          /* Return */ false);\n\n",
        "src_path": "5a406b63e9d70225cd56fd5c3b791e78f4aed3cc___AttributorAttributes.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/5a406b63e9d70225cd56fd5c3b791e78f4aed3cc",
        "commit_msg": "[Attributor][FIX] Stores capture, even for readonly functions\n\nIf we end up visiting a store use, we couldn't follow to the \"reloads\".\nThe capture effect of a store is more than memory as the reloads are\nunknown.\n\nFixes: https://github.com/llvm/llvm-project/issues/64613",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/Attributor/nocapture-2.ll",
                "patch": "@@ -756,7 +756,7 @@ define ptr @b64613_a(ptr noundef %p) {\n define ptr @b64613_b(ptr noundef %p, i32 %i) {\n ; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)\n ; TUNIT-LABEL: define ptr @b64613_b\n-; TUNIT-SAME: (ptr nocapture nofree noundef [[P:%.*]], i32 [[I:%.*]]) #[[ATTR11]] {\n+; TUNIT-SAME: (ptr nofree noundef [[P:%.*]], i32 [[I:%.*]]) #[[ATTR11]] {\n ; TUNIT-NEXT:    [[P_ADDR:%.*]] = alloca <2 x ptr>, align 1\n ; TUNIT-NEXT:    [[G:%.*]] = getelementptr i8, ptr [[P_ADDR]], i32 [[I]]\n ; TUNIT-NEXT:    store ptr [[P]], ptr [[G]], align 1\n@@ -765,7 +765,7 @@ define ptr @b64613_b(ptr noundef %p, i32 %i) {\n ;\n ; CGSCC: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)\n ; CGSCC-LABEL: define ptr @b64613_b\n-; CGSCC-SAME: (ptr nocapture nofree noundef [[P:%.*]], i32 [[I:%.*]]) #[[ATTR12]] {\n+; CGSCC-SAME: (ptr nofree noundef [[P:%.*]], i32 [[I:%.*]]) #[[ATTR12]] {\n ; CGSCC-NEXT:    [[P_ADDR:%.*]] = alloca <2 x ptr>, align 1\n ; CGSCC-NEXT:    [[G:%.*]] = getelementptr i8, ptr [[P_ADDR]], i32 [[I]]\n ; CGSCC-NEXT:    store ptr [[P]], ptr [[G]], align 1"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/Attributor/nocapture-2.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/Attributor/nocapture-2.ll\n\n\nTesting Time: 1.05s\n  Failed: 1\n"
    },
    "e8d5db206c2f5c4afac8288ab96193a5638270ae___LoopPeel.cpp": {
        "prefix": "static void updateBranchWeights(Instruction *Term, WeightInfo &Info) {\n  MDBuilder MDB(Term->getContext());\n  Term->setMetadata(LLVMContext::MD_prof,\n                    MDB.createBranchWeights(Info.Weights));\n  for (auto [Idx, SubWeight] : enumerate(Info.SubWeights))\n    if (SubWeight != 0)\n",
        "suffix": "",
        "start": 633,
        "end": 642,
        "buggy": "static void updateBranchWeights(Instruction *Term, WeightInfo &Info) {\n  MDBuilder MDB(Term->getContext());\n  Term->setMetadata(LLVMContext::MD_prof,\n                    MDB.createBranchWeights(Info.Weights));\n  for (auto [Idx, SubWeight] : enumerate(Info.SubWeights))\n    if (SubWeight != 0)\n      Info.Weights[Idx] = Info.Weights[Idx] > SubWeight\n                              ? Info.Weights[Idx] - SubWeight\n                              : 1;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      Info.Weights[Idx] = Info.Weights[Idx] > SubWeight\n                              ? Info.Weights[Idx] - SubWeight\n                              : 1;\n}\n",
        "src_path": "e8d5db206c2f5c4afac8288ab96193a5638270ae___LoopPeel.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/e8d5db206c2f5c4afac8288ab96193a5638270ae",
        "commit_msg": "[LoopPeeling] Fix weights updating of peeled off branches (#70094)\n\nIn https://reviews.llvm.org/D64235 a new algorithm has been introduced\r\nfor updating the branch weights of latch blocks and their copies.\r\n\r\nIt increases the probability of going to the exit block for each next\r\npeel iteration, calculating weights by (F - I * E, E), where:\r\n- F is a weight of the edge from latch to header.\r\n- E is a weight of the edge from latch to exit.\r\n- I is a number of peeling iteration.\r\n\r\nE.g: Let's say the latch branch weights are (100,300) and the estimated\r\ntrip count is 4. If we peel off all 4 iterations the weights of the\r\ncopied branches will be:\r\n0: (100,300)\r\n1: (100,200)\r\n2: (100,100)\r\n3: (100,1)\r\n\r\nhttps://godbolt.org/z/93KnoEsT6\r\n\r\nSo we make the original loop almost unreachable from the 3rd peeled copy\r\naccording to the profile data. But that's only true if the profiling\r\ndata is accurate.\r\nUnderestimated trip count can lead to a performance issues with the\r\nregister allocator, which may decide to spill intervals inside the loop\r\nassuming it's unreachable.\r\n\r\nSince we don't know how accurate the profiling data is, it seems better\r\nto set neutral 1/1 weights on the last peeled latch branch. After this\r\nchange, the weights in the example above will look like this:\r\n0: (100,300)\r\n1: (100,200)\r\n2: (100,100)\r\n3: (100,100)\r\n\r\nCo-authored-by: Aleksandr Popov <apopov@azul.com>",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/LoopUnroll/peel-loop-pgo-deopt.ll",
                "patch": "@@ -21,7 +21,7 @@\n ; CHECK: br i1 %{{.*}}, label %[[NEXT2:.*]], label %for.cond.for.end_crit_edge, !prof !18\n ; CHECK: [[NEXT2]]:\n ; CHECK: br i1 %c, label %{{.*}}, label %side_exit.loopexit, !prof !15\n-; CHECK: br i1 %{{.*}}, label %for.body, label %{{.*}}, !prof !19\n+; CHECK: br i1 %{{.*}}, label %for.body, label %{{.*}}, !prof !18\n \n define i32 @basic(ptr %p, i32 %k, i1 %c) #0 !prof !15 {\n entry:\n@@ -85,6 +85,5 @@ attributes #1 = { nounwind optsize }\n ; This is a weights of latch and its copies.\n ;CHECK: !16 = !{!\"branch_weights\", i32 3001, i32 1001}\n ;CHECK: !17 = !{!\"branch_weights\", i32 2000, i32 1001}\n-;CHECK: !18 = !{!\"branch_weights\", i32 999, i32 1001}\n-;CHECK: !19 = !{!\"branch_weights\", i32 1, i32 1001}\n+;CHECK: !18 = !{!\"branch_weights\", i32 1001, i32 1001}\n "
            },
            {
                "fn": "llvm/test/Transforms/LoopUnroll/peel-loop-pgo.ll",
                "patch": "@@ -24,7 +24,7 @@\n ; CHECK: [[NEXT1]]:\n ; CHECK: br i1 %{{.*}}, label %[[NEXT2:.*]], label %for.cond.for.end_crit_edge, !prof !17\n ; CHECK: [[NEXT2]]:\n-; CHECK: br i1 %{{.*}}, label %for.body, label %{{.*}}, !prof !18\n+; CHECK: br i1 %{{.*}}, label %for.body, label %{{.*}}, !prof !17\n \n define void @basic(ptr %p, i32 %k) #0 !prof !15 {\n entry:\n@@ -105,6 +105,5 @@ attributes #1 = { nounwind optsize }\n \n ;CHECK: !15 = !{!\"branch_weights\", i32 3001, i32 1001}\n ;CHECK: !16 = !{!\"branch_weights\", i32 2000, i32 1001}\n-;CHECK: !17 = !{!\"branch_weights\", i32 999, i32 1001}\n-;CHECK: !18 = !{!\"branch_weights\", i32 1, i32 1001}\n+;CHECK: !17 = !{!\"branch_weights\", i32 1001, i32 1001}\n "
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/LoopUnroll/peel-loop-pgo-deopt.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopUnroll/peel-loop-pgo-deopt.ll\n\n\nTesting Time: 2.08s\n\nTotal Discovered Tests: 1\n  Failed: 1 (100.00%)\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopUnroll/peel-loop-pgo.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopUnroll/peel-loop-pgo.ll\n\n\nTesting Time: 0.59s\n\nTotal Discovered Tests: 1\n  Failed: 1 (100.00%)\n"
    },
    "9ef829097bbc4cf908698e3891af11a154e1d3e2___InstCombineSelect.cpp": {
        "prefix": "static Instruction *foldNestedSelects(SelectInst &OuterSelVal,\n                                      InstCombiner::BuilderTy &Builder) {\n  // We must start with a `select`.\n  DecomposedSelect OuterSel;\n  match(&OuterSelVal,\n        m_Select(m_Value(OuterSel.Cond), m_Value(OuterSel.TrueVal),\n                 m_Value(OuterSel.FalseVal)));\n\n  // Canonicalize inversion of the outermost `select`'s condition.\n  if (match(OuterSel.Cond, m_Not(m_Value(OuterSel.Cond))))\n    std::swap(OuterSel.TrueVal, OuterSel.FalseVal);\n\n  // The condition of the outermost select must be an `and`/`or`.\n  if (!match(OuterSel.Cond, m_c_LogicalOp(m_Value(), m_Value())))\n    return nullptr;\n\n  // Depending on the logical op, inner select might be in different hand.\n  bool IsAndVariant = match(OuterSel.Cond, m_LogicalAnd());\n  Value *InnerSelVal = IsAndVariant ? OuterSel.FalseVal : OuterSel.TrueVal;\n\n  // Profitability check - avoid increasing instruction count.\n  if (none_of(ArrayRef<Value *>({OuterSelVal.getCondition(), InnerSelVal}),\n              [](Value *V) { return V->hasOneUse(); }))\n    return nullptr;\n\n  // The appropriate hand of the outermost `select` must be a select itself.\n  DecomposedSelect InnerSel;\n  if (!match(InnerSelVal,\n             m_Select(m_Value(InnerSel.Cond), m_Value(InnerSel.TrueVal),\n                      m_Value(InnerSel.FalseVal))))\n    return nullptr;\n\n  // Canonicalize inversion of the innermost `select`'s condition.\n  if (match(InnerSel.Cond, m_Not(m_Value(InnerSel.Cond))))\n    std::swap(InnerSel.TrueVal, InnerSel.FalseVal);\n\n  Value *AltCond = nullptr;\n",
        "suffix": "\n  // Finally, match the condition that was driving the outermost `select`,\n  // it should be a logical operation between the condition that was driving\n  // the innermost `select` (after accounting for the possible inversions\n  // of the condition), and some other condition.\n  if (matchOuterCond(m_Specific(InnerSel.Cond))) {\n    // Done!\n  } else if (Value * NotInnerCond; matchOuterCond(m_CombineAnd(\n                 m_Not(m_Specific(InnerSel.Cond)), m_Value(NotInnerCond)))) {\n    // Done!\n    std::swap(InnerSel.TrueVal, InnerSel.FalseVal);\n    InnerSel.Cond = NotInnerCond;\n  } else // Not the pattern we were looking for.\n    return nullptr;\n\n  Value *SelInner = Builder.CreateSelect(\n      AltCond, IsAndVariant ? OuterSel.TrueVal : InnerSel.FalseVal,\n      IsAndVariant ? InnerSel.TrueVal : OuterSel.FalseVal);\n  SelInner->takeName(InnerSelVal);\n  return SelectInst::Create(InnerSel.Cond,\n                            IsAndVariant ? SelInner : InnerSel.TrueVal,\n                            !IsAndVariant ? SelInner : InnerSel.FalseVal);\n}\n",
        "start": 2857,
        "end": 2919,
        "buggy": "static Instruction *foldNestedSelects(SelectInst &OuterSelVal,\n                                      InstCombiner::BuilderTy &Builder) {\n  // We must start with a `select`.\n  DecomposedSelect OuterSel;\n  match(&OuterSelVal,\n        m_Select(m_Value(OuterSel.Cond), m_Value(OuterSel.TrueVal),\n                 m_Value(OuterSel.FalseVal)));\n\n  // Canonicalize inversion of the outermost `select`'s condition.\n  if (match(OuterSel.Cond, m_Not(m_Value(OuterSel.Cond))))\n    std::swap(OuterSel.TrueVal, OuterSel.FalseVal);\n\n  // The condition of the outermost select must be an `and`/`or`.\n  if (!match(OuterSel.Cond, m_c_LogicalOp(m_Value(), m_Value())))\n    return nullptr;\n\n  // Depending on the logical op, inner select might be in different hand.\n  bool IsAndVariant = match(OuterSel.Cond, m_LogicalAnd());\n  Value *InnerSelVal = IsAndVariant ? OuterSel.FalseVal : OuterSel.TrueVal;\n\n  // Profitability check - avoid increasing instruction count.\n  if (none_of(ArrayRef<Value *>({OuterSelVal.getCondition(), InnerSelVal}),\n              [](Value *V) { return V->hasOneUse(); }))\n    return nullptr;\n\n  // The appropriate hand of the outermost `select` must be a select itself.\n  DecomposedSelect InnerSel;\n  if (!match(InnerSelVal,\n             m_Select(m_Value(InnerSel.Cond), m_Value(InnerSel.TrueVal),\n                      m_Value(InnerSel.FalseVal))))\n    return nullptr;\n\n  // Canonicalize inversion of the innermost `select`'s condition.\n  if (match(InnerSel.Cond, m_Not(m_Value(InnerSel.Cond))))\n    std::swap(InnerSel.TrueVal, InnerSel.FalseVal);\n\n  Value *AltCond = nullptr;\n  auto matchOuterCond = [OuterSel, &AltCond](auto m_InnerCond) {\n    return match(OuterSel.Cond, m_c_LogicalOp(m_InnerCond, m_Value(AltCond)));\n  };\n\n  // Finally, match the condition that was driving the outermost `select`,\n  // it should be a logical operation between the condition that was driving\n  // the innermost `select` (after accounting for the possible inversions\n  // of the condition), and some other condition.\n  if (matchOuterCond(m_Specific(InnerSel.Cond))) {\n    // Done!\n  } else if (Value * NotInnerCond; matchOuterCond(m_CombineAnd(\n                 m_Not(m_Specific(InnerSel.Cond)), m_Value(NotInnerCond)))) {\n    // Done!\n    std::swap(InnerSel.TrueVal, InnerSel.FalseVal);\n    InnerSel.Cond = NotInnerCond;\n  } else // Not the pattern we were looking for.\n    return nullptr;\n\n  Value *SelInner = Builder.CreateSelect(\n      AltCond, IsAndVariant ? OuterSel.TrueVal : InnerSel.FalseVal,\n      IsAndVariant ? InnerSel.TrueVal : OuterSel.FalseVal);\n  SelInner->takeName(InnerSelVal);\n  return SelectInst::Create(InnerSel.Cond,\n                            IsAndVariant ? SelInner : InnerSel.TrueVal,\n                            !IsAndVariant ? SelInner : InnerSel.FalseVal);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  auto matchOuterCond = [OuterSel, &AltCond](auto m_InnerCond) {\n    return match(OuterSel.Cond, m_c_LogicalOp(m_InnerCond, m_Value(AltCond)));\n  };\n",
        "src_path": "9ef829097bbc4cf908698e3891af11a154e1d3e2___InstCombineSelect.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/9ef829097bbc4cf908698e3891af11a154e1d3e2",
        "commit_msg": "[InstCombine] Fix buggy transform in `foldNestedSelects`; PR 71330\n\nThe bug is that `IsAndVariant` is used to assume which arm in the\nselect the output `SelInner` should be placed but match the inner\nselect condition with `m_c_LogicalOp`. With fully simplified ops, this\nworks fine, but its possible if the select condition is not\nsimplified, for it match both `LogicalAnd` and `LogicalOr` i.e `select\ntrue, true, false`.\n\nIn PR71330 for example, the issue occurs in the following IR:\n```\ndefine i32 @bad() {\n  %..i.i = select i1 false, i32 0, i32 3\n  %brmerge = select i1 true, i1 true, i1 false\n  %not.cmp.i.i.not = xor i1 true, true\n  %.mux = zext i1 %not.cmp.i.i.not to i32\n  %retval.0.i.i = select i1 %brmerge, i32 %.mux, i32 %..i.i\n  ret i32 %retval.0.i.i\n}\n```\n\nWhen simplifying:\n```\n%retval.0.i.i = select i1 %brmerge, i32 %.mux, i32 %..i.i\n```\n\nWe end up matching `%brmerge` as `LogicalAnd` for `IsAndVariant`, but\nthe inner select (`%..i.i`) condition which is `false` with\n`LogicalOr`.\n\nCloses #71489",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/pr71330.ll",
                "patch": "@@ -15,8 +15,7 @@ define void @pr71330(i32 %conv, i1 %tobool19.not4, i16 %lb) {\n ; CHECK:       for.cond7.preheader.split.us.split:\n ; CHECK-NEXT:    ret void\n ; CHECK:       for.cond7:\n-; CHECK-NEXT:    [[ADD9:%.*]] = add i32 [[CONV]], 3\n-; CHECK-NEXT:    [[CMP12:%.*]] = icmp slt i32 [[ADD9]], 0\n+; CHECK-NEXT:    [[CMP12:%.*]] = icmp slt i32 [[CONV]], 0\n ; CHECK-NEXT:    br i1 [[CMP12]], label [[FOR_BODY14:%.*]], label [[FOR_END25]]\n ; CHECK:       for.body14:\n ; CHECK-NEXT:    ret void"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/pr71330.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/pr71330.ll\n\n\nTesting Time: 0.35s\n\nTotal Discovered Tests: 1\n  Failed: 1 (100.00%)\n"
    },
    "44af5924b1cbbb395e7e71250a5445053c4ec4a3___IntrinsicInst.cpp": {
        "prefix": "const Value *GCProjectionInst::getStatepoint() const {\n  const Value *Token = getArgOperand(0);\n  if (isa<UndefValue>(Token))\n    return Token;\n\n",
        "suffix": "  // on normal path of invoke statepoint.\n  if (!isa<LandingPadInst>(Token))\n    return cast<GCStatepointInst>(Token);\n\n  // This relocate is on exceptional path of an invoke statepoint\n  const BasicBlock *InvokeBB =\n    cast<Instruction>(Token)->getParent()->getUniquePredecessor();\n\n  assert(InvokeBB && \"safepoints should have unique landingpads\");\n  assert(InvokeBB->getTerminator() &&\n         \"safepoint block should be well formed\");\n\n  return cast<GCStatepointInst>(InvokeBB->getTerminator());\n}\n",
        "start": 868,
        "end": 887,
        "buggy": "const Value *GCProjectionInst::getStatepoint() const {\n  const Value *Token = getArgOperand(0);\n  if (isa<UndefValue>(Token))\n    return Token;\n\n  // This takes care both of relocates for call statepoints and relocates\n  // on normal path of invoke statepoint.\n  if (!isa<LandingPadInst>(Token))\n    return cast<GCStatepointInst>(Token);\n\n  // This relocate is on exceptional path of an invoke statepoint\n  const BasicBlock *InvokeBB =\n    cast<Instruction>(Token)->getParent()->getUniquePredecessor();\n\n  assert(InvokeBB && \"safepoints should have unique landingpads\");\n  assert(InvokeBB->getTerminator() &&\n         \"safepoint block should be well formed\");\n\n  return cast<GCStatepointInst>(InvokeBB->getTerminator());\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  // This takes care both of relocates for call statepoints and relocates\n",
        "src_path": "44af5924b1cbbb395e7e71250a5445053c4ec4a3___IntrinsicInst.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/44af5924b1cbbb395e7e71250a5445053c4ec4a3",
        "commit_msg": "[Statepoint] Return undef value for the statepoint of the none token (#72552)\n\nHelps avoid the crash in verifier when it tries to print the error.\r\n`none` token might be produced by llvm-reduce, since it's a default\r\nvalue, so by extension this also fixes llvm-reduce crash, allowing it to\r\njust discard invalid IR.\r\n\r\n---------\r\n\r\nCo-authored-by: arpilipe <apilipenko@azul.com>",
        "test_func_diff": [
            {
                "fn": "llvm/test/Verifier/gc_none_token.ll",
                "patch": "@@ -0,0 +1,18 @@\n+; RUN: not opt -passes=verify -S %s 2>&1 | FileCheck %s\n+; Check that verifier doesn't crash on relocate with none token\n+\n+target triple = \"x86_64-unknown-linux-gnu\"\n+\n+define i32 @check_verify_none_token() gc \"statepoint-example\" {\n+\n+entry:\n+    ret i32 0\n+\n+unreach:\n+    ; CHECK: gc relocate is incorrectly tied to the statepoint\n+    ; CHECK: (undef, undef)\n+    %token_call = call i32 addrspace(1)* @llvm.experimental.gc.relocate.p1i32(token none, i32 0, i32 0)\n+    ret i32 1\n+}\n+\n+declare i32 addrspace(1)* @llvm.experimental.gc.relocate.p1i32(token, i32, i32)"
            }
        ],
        "error_msg": "FAIL: LLVM :: Verifier/gc_none_token.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Verifier/gc_none_token.ll\n\n\nTesting Time: 5.12s\n\nTotal Discovered Tests: 1\n  Failed: 1 (100.00%)\n"
    },
    "099b4435c38dd52ddb38e6b1706d9c988699c082___preprocessor.cpp": {
        "prefix": "static void getConfigs(const simplecpp::TokenList &tokens, std::set<std::string> &defined, const std::string &userDefines, const std::set<std::string> &undefined, std::set<std::string> &ret)\n{\n    std::vector<std::string> configs_if;\n    std::vector<std::string> configs_ifndef;\n    std::string elseError;\n\n    for (const simplecpp::Token *tok = tokens.cfront(); tok; tok = tok->next) {\n        if (tok->op != '#' || sameline(tok->previous, tok))\n            continue;\n        const simplecpp::Token *cmdtok = tok->next;\n        if (!sameline(tok, cmdtok))\n            continue;\n        if (cmdtok->str == \"ifdef\" || cmdtok->str == \"ifndef\" || cmdtok->str == \"if\") {\n            std::string config;\n            if (cmdtok->str == \"ifdef\" || cmdtok->str == \"ifndef\") {\n                const simplecpp::Token *expr1 = cmdtok->next;\n                if (sameline(tok,expr1) && expr1->name && !sameline(tok,expr1->next))\n                    config = expr1->str;\n                if (defined.find(config) != defined.end())\n                    config.clear();\n            } else if (cmdtok->str == \"if\") {\n                config = readcondition(cmdtok, defined, undefined);\n            }\n\n            // skip undefined configurations..\n            if (isUndefined(config, undefined))\n                config.clear();\n\n            configs_if.push_back((cmdtok->str == \"ifndef\") ? std::string() : config);\n            configs_ifndef.push_back((cmdtok->str == \"ifndef\") ? config : std::string());\n            ret.insert(cfg(configs_if,userDefines));\n        } else if (cmdtok->str == \"elif\" || cmdtok->str == \"else\") {\n            if (getConfigsElseIsFalse(configs_if,userDefines)) {\n                tok = gotoEndIf(tok);\n                if (!tok)\n                    break;\n                tok = tok->previous;\n                continue;\n            }\n            if (cmdtok->str == \"else\" &&\n                cmdtok->next &&\n                !sameline(cmdtok,cmdtok->next) &&\n                sameline(cmdtok->next, cmdtok->next->next) &&\n                cmdtok->next->op == '#' &&\n                cmdtok->next->next->str == \"error\") {\n",
        "suffix": "            if (!configs_if.empty())\n                configs_if.pop_back();\n            if (cmdtok->str == \"elif\") {\n                std::string config = readcondition(cmdtok, defined, undefined);\n                if (isUndefined(config,undefined))\n                    config.clear();\n                configs_if.push_back(config);\n                ret.insert(cfg(configs_if, userDefines));\n            } else if (!configs_ifndef.empty()) {\n                configs_if.push_back(configs_ifndef.back());\n                ret.insert(cfg(configs_if, userDefines));\n            }\n        } else if (cmdtok->str == \"endif\" && !sameline(tok, cmdtok->next)) {\n            if (!configs_if.empty())\n                configs_if.pop_back();\n            if (!configs_ifndef.empty())\n                configs_ifndef.pop_back();\n        } else if (cmdtok->str == \"error\") {\n            if (!configs_ifndef.empty() && !configs_ifndef.back().empty()) {\n                if (configs_ifndef.size() == 1U)\n                    ret.erase(\"\");\n                std::vector<std::string> configs(configs_if);\n                configs.push_back(configs_ifndef.back());\n                ret.erase(cfg(configs, userDefines));\n                if (!elseError.empty())\n                    elseError += ';';\n                elseError += cfg(configs_ifndef, userDefines);\n            }\n            if (!configs_if.empty() && !configs_if.back().empty()) {\n                const std::string &last = configs_if.back();\n                if (last.size() > 2U && last.compare(last.size()-2U,2,\"=0\") == 0) {\n                    std::vector<std::string> configs(configs_if);\n                    ret.erase(cfg(configs, userDefines));\n                    configs[configs.size() - 1U] = last.substr(0,last.size()-2U);\n                    if (configs.size() == 1U)\n                        ret.erase(\"\");\n                    if (!elseError.empty())\n                        elseError += ';';\n                    elseError += cfg(configs, userDefines);\n                }\n            }\n        } else if (cmdtok->str == \"define\" && sameline(tok, cmdtok->next) && cmdtok->next->name) {\n            defined.insert(cmdtok->next->str);\n        }\n    }\n    if (!elseError.empty())\n        ret.insert(elseError);\n}\n",
        "start": 310,
        "end": 406,
        "buggy": "static void getConfigs(const simplecpp::TokenList &tokens, std::set<std::string> &defined, const std::string &userDefines, const std::set<std::string> &undefined, std::set<std::string> &ret)\n{\n    std::vector<std::string> configs_if;\n    std::vector<std::string> configs_ifndef;\n    std::string elseError;\n\n    for (const simplecpp::Token *tok = tokens.cfront(); tok; tok = tok->next) {\n        if (tok->op != '#' || sameline(tok->previous, tok))\n            continue;\n        const simplecpp::Token *cmdtok = tok->next;\n        if (!sameline(tok, cmdtok))\n            continue;\n        if (cmdtok->str == \"ifdef\" || cmdtok->str == \"ifndef\" || cmdtok->str == \"if\") {\n            std::string config;\n            if (cmdtok->str == \"ifdef\" || cmdtok->str == \"ifndef\") {\n                const simplecpp::Token *expr1 = cmdtok->next;\n                if (sameline(tok,expr1) && expr1->name && !sameline(tok,expr1->next))\n                    config = expr1->str;\n                if (defined.find(config) != defined.end())\n                    config.clear();\n            } else if (cmdtok->str == \"if\") {\n                config = readcondition(cmdtok, defined, undefined);\n            }\n\n            // skip undefined configurations..\n            if (isUndefined(config, undefined))\n                config.clear();\n\n            configs_if.push_back((cmdtok->str == \"ifndef\") ? std::string() : config);\n            configs_ifndef.push_back((cmdtok->str == \"ifndef\") ? config : std::string());\n            ret.insert(cfg(configs_if,userDefines));\n        } else if (cmdtok->str == \"elif\" || cmdtok->str == \"else\") {\n            if (getConfigsElseIsFalse(configs_if,userDefines)) {\n                tok = gotoEndIf(tok);\n                if (!tok)\n                    break;\n                tok = tok->previous;\n                continue;\n            }\n            if (cmdtok->str == \"else\" &&\n                cmdtok->next &&\n                !sameline(cmdtok,cmdtok->next) &&\n                sameline(cmdtok->next, cmdtok->next->next) &&\n                cmdtok->next->op == '#' &&\n                cmdtok->next->next->str == \"error\") {\n                if (!elseError.empty())\n                    elseError += ';';\n                elseError += cfg(configs_if, userDefines);\n            }\n            if (!configs_if.empty())\n                configs_if.pop_back();\n            if (cmdtok->str == \"elif\") {\n                std::string config = readcondition(cmdtok, defined, undefined);\n                if (isUndefined(config,undefined))\n                    config.clear();\n                configs_if.push_back(config);\n                ret.insert(cfg(configs_if, userDefines));\n            } else if (!configs_ifndef.empty()) {\n                configs_if.push_back(configs_ifndef.back());\n                ret.insert(cfg(configs_if, userDefines));\n            }\n        } else if (cmdtok->str == \"endif\" && !sameline(tok, cmdtok->next)) {\n            if (!configs_if.empty())\n                configs_if.pop_back();\n            if (!configs_ifndef.empty())\n                configs_ifndef.pop_back();\n        } else if (cmdtok->str == \"error\") {\n            if (!configs_ifndef.empty() && !configs_ifndef.back().empty()) {\n                if (configs_ifndef.size() == 1U)\n                    ret.erase(\"\");\n                std::vector<std::string> configs(configs_if);\n                configs.push_back(configs_ifndef.back());\n                ret.erase(cfg(configs, userDefines));\n                if (!elseError.empty())\n                    elseError += ';';\n                elseError += cfg(configs_ifndef, userDefines);\n            }\n            if (!configs_if.empty() && !configs_if.back().empty()) {\n                const std::string &last = configs_if.back();\n                if (last.size() > 2U && last.compare(last.size()-2U,2,\"=0\") == 0) {\n                    std::vector<std::string> configs(configs_if);\n                    ret.erase(cfg(configs, userDefines));\n                    configs[configs.size() - 1U] = last.substr(0,last.size()-2U);\n                    if (configs.size() == 1U)\n                        ret.erase(\"\");\n                    if (!elseError.empty())\n                        elseError += ';';\n                    elseError += cfg(configs, userDefines);\n                }\n            }\n        } else if (cmdtok->str == \"define\" && sameline(tok, cmdtok->next) && cmdtok->next->name) {\n            defined.insert(cmdtok->next->str);\n        }\n    }\n    if (!elseError.empty())\n        ret.insert(elseError);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                if (!elseError.empty())\n                    elseError += ';';\n                elseError += cfg(configs_if, userDefines);\n            }\n",
        "src_path": "099b4435c38dd52ddb38e6b1706d9c988699c082___preprocessor.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/099b4435c38dd52ddb38e6b1706d9c988699c082",
        "commit_msg": "Fixed #8074 (Preprocessor::getConfigs: wrong configuration extracted 'A;B;;')",
        "test_func_diff": [
            {
                "fn": "test/testpreprocessor.cpp",
                "patch": "@@ -79,6 +79,7 @@ class TestPreprocessor : public TestFixture {\n         TEST_CASE(error4);  // #2919 - wrong filename is reported\n         TEST_CASE(error5);\n         TEST_CASE(error6);\n+        TEST_CASE(error7);\n \n         TEST_CASE(setPlatformInfo);\n \n@@ -409,6 +410,21 @@ class TestPreprocessor : public TestFixture {\n \n     }\n \n+    void error7() { // #8074\n+        const char filedata[] = \"#define A\\n\"\n+                                \"\\n\"\n+                                \"#if defined(B)\\n\"\n+                                \"#else\\n\"\n+                                \"#error \\\"1\\\"\\n\"\n+                                \"#endif\\n\"\n+                                \"\\n\"\n+                                \"#if defined(A)\\n\"\n+                                \"#else\\n\"\n+                                \"#error \\\"2\\\"\\n\"\n+                                \"#endif\\n\";\n+        ASSERT_EQUALS(\"\\nB\\n\", getConfigsStr(filedata));\n+    }\n+\n     void setPlatformInfo() {\n         Settings settings;\n         Preprocessor preprocessor(settings, this);"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_099b4435c38dd52ddb38e6b1706d9c988699c082/build_099b4435c38dd52ddb38e6b1706d9c988699c082\nTest project /out/danmar___cppcheck/git_repo_dir_099b4435c38dd52ddb38e6b1706d9c988699c082/build_099b4435c38dd52ddb38e6b1706d9c988699c082\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   14.38 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  14.39 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n"
    },
    "4ad90bf6f1cb0149c79324dff027cf8558c041c1___checkuninitvar.cpp": {
        "prefix": "const Token* CheckUninitVar::checkLoopBodyRecursive(const Token *start, const Variable& var, const Alloc alloc, const std::string &membervar, bool &bailout) const\n{\n    assert(start->str() == \"{\");\n\n    const Token *errorToken = nullptr;\n\n    const Token *const end = start->link();\n    for (const Token *tok = start->next(); tok != end; tok = tok->next()) {\n        // skip sizeof / offsetof\n        if (isSizeOfEtc(tok)) {\n            tok = tok->linkAt(1);\n            continue;\n        }\n\n        if (Token::Match(tok, \"asm ( %str% ) ;\")) {\n            bailout = true;\n            return nullptr;\n        }\n\n        // for loop; skip third expression until loop body has been analyzed..\n        if (tok->str() == \";\" && Token::simpleMatch(tok->astParent(), \";\") && Token::simpleMatch(tok->astParent()->astParent(), \"(\")) {\n            const Token *top = tok->astParent()->astParent();\n            if (!Token::simpleMatch(top->previous(), \"for (\") || !Token::simpleMatch(top->link(), \") {\"))\n                continue;\n            const Token *bodyStart = top->link()->next();\n            const Token *errorToken1 = checkLoopBodyRecursive(bodyStart, var, alloc, membervar, bailout);\n",
        "suffix": "                return nullptr;\n        }\n        // for loop; skip loop body if there is third expression\n        if (Token::simpleMatch(tok, \") {\") &&\n            Token::simpleMatch(tok->link()->previous(), \"for (\") &&\n            Token::simpleMatch(tok->link()->astOperand2(), \";\")  &&\n            Token::simpleMatch(tok->link()->astOperand2()->astOperand2(), \";\")) {\n            tok = tok->linkAt(1);\n        }\n\n        if (tok->str() == \"{\") {\n            // switch => bailout\n            if (tok->scope() && tok->scope()->type == Scope::ScopeType::eSwitch) {\n                bailout = true;\n                return nullptr;\n            }\n\n            const Token *errorToken1 = checkLoopBodyRecursive(tok, var, alloc, membervar, bailout);\n            tok = tok->link();\n            if (Token::simpleMatch(tok, \"} else {\")) {\n                const Token *elseBody = tok->tokAt(2);\n                const Token *errorToken2 = checkLoopBodyRecursive(elseBody, var, alloc, membervar, bailout);\n                tok = elseBody->link();\n                if (errorToken1 && errorToken2)\n                    return errorToken1;\n                if (errorToken2)\n                    errorToken = errorToken2;\n            }\n            if (bailout)\n                return nullptr;\n            if (!errorToken)\n                errorToken = errorToken1;\n        }\n\n        if (tok->varId() != var.declarationId())\n            continue;\n\n        bool conditionalUsage = false;\n        for (const Token* parent = tok; parent; parent = parent->astParent()) {\n            if (Token::Match(parent->astParent(), \"%oror%|&&|?\") && astIsRHS(parent)) {\n                conditionalUsage = true;\n                break;\n            }\n        }\n\n        if (!membervar.empty()) {\n            if (isMemberVariableAssignment(tok, membervar)) {\n                bool assign = true;\n                bool rhs = false;\n                // Used for tracking if an \")\" is inner or outer\n                const Token *rpar = nullptr;\n                for (const Token *tok2 = tok->next(); tok2; tok2 = tok2->next()) {\n                    if (tok2->str() == \"=\")\n                        rhs = true;\n\n                    // Look at inner expressions but not outer expressions\n                    if (!rpar && tok2->str() == \"(\")\n                        rpar = tok2->link();\n                    else if (tok2->str() == \")\") {\n                        // No rpar => this is an outer right parenthesis\n                        if (!rpar)\n                            break;\n                        if (rpar == tok2)\n                            rpar = nullptr;\n                    }\n\n                    if (tok2->str() == \";\" || (!rpar && tok2->str() == \",\"))\n                        break;\n                    if (rhs && tok2->varId() == var.declarationId() && isMemberVariableUsage(tok2, var.isPointer(), alloc, membervar)) {\n                        assign = false;\n                        break;\n                    }\n                }\n                if (assign) {\n                    bailout = true;\n                    return nullptr;\n                }\n            }\n            if (isMemberVariableUsage(tok, var.isPointer(), alloc, membervar)) {\n                if (!conditionalUsage)\n                    return tok;\n                if (!errorToken)\n                    errorToken = tok;\n            } else if (Token::Match(tok->previous(), \"[(,] %name% [,)]\")) {\n                bailout = true;\n                return nullptr;\n            }\n        } else {\n            if (const Token *errtok = isVariableUsage(tok, var.isPointer(), alloc)) {\n                if (!conditionalUsage)\n                    return errtok;\n                if (!errorToken)\n                    errorToken = errtok;\n            } else if (tok->strAt(1) == \"=\") {\n                bool varIsUsedInRhs = false;\n                visitAstNodes(tok->next()->astOperand2(), [&](const Token * t) {\n                    if (!t)\n                        return ChildrenToVisit::none;\n                    if (t->varId() == var.declarationId()) {\n                        varIsUsedInRhs = true;\n                        return ChildrenToVisit::done;\n                    }\n                    if (isSizeOfEtc(t->previous()))\n                        return ChildrenToVisit::none;\n                    return ChildrenToVisit::op1_and_op2;\n                });\n                if (!varIsUsedInRhs) {\n                    bailout = true;\n                    return nullptr;\n                }\n            } else {\n                bailout = true;\n                return nullptr;\n            }\n        }\n    }\n\n    return errorToken;\n}\n",
        "start": 879,
        "end": 1026,
        "buggy": "const Token* CheckUninitVar::checkLoopBodyRecursive(const Token *start, const Variable& var, const Alloc alloc, const std::string &membervar, bool &bailout) const\n{\n    assert(start->str() == \"{\");\n\n    const Token *errorToken = nullptr;\n\n    const Token *const end = start->link();\n    for (const Token *tok = start->next(); tok != end; tok = tok->next()) {\n        // skip sizeof / offsetof\n        if (isSizeOfEtc(tok)) {\n            tok = tok->linkAt(1);\n            continue;\n        }\n\n        if (Token::Match(tok, \"asm ( %str% ) ;\")) {\n            bailout = true;\n            return nullptr;\n        }\n\n        // for loop; skip third expression until loop body has been analyzed..\n        if (tok->str() == \";\" && Token::simpleMatch(tok->astParent(), \";\") && Token::simpleMatch(tok->astParent()->astParent(), \"(\")) {\n            const Token *top = tok->astParent()->astParent();\n            if (!Token::simpleMatch(top->previous(), \"for (\") || !Token::simpleMatch(top->link(), \") {\"))\n                continue;\n            const Token *bodyStart = top->link()->next();\n            const Token *errorToken1 = checkLoopBodyRecursive(bodyStart, var, alloc, membervar, bailout);\n            if (errorToken1)\n                return errorToken1;\n            if (bailout)\n                return nullptr;\n        }\n        // for loop; skip loop body if there is third expression\n        if (Token::simpleMatch(tok, \") {\") &&\n            Token::simpleMatch(tok->link()->previous(), \"for (\") &&\n            Token::simpleMatch(tok->link()->astOperand2(), \";\")  &&\n            Token::simpleMatch(tok->link()->astOperand2()->astOperand2(), \";\")) {\n            tok = tok->linkAt(1);\n        }\n\n        if (tok->str() == \"{\") {\n            // switch => bailout\n            if (tok->scope() && tok->scope()->type == Scope::ScopeType::eSwitch) {\n                bailout = true;\n                return nullptr;\n            }\n\n            const Token *errorToken1 = checkLoopBodyRecursive(tok, var, alloc, membervar, bailout);\n            tok = tok->link();\n            if (Token::simpleMatch(tok, \"} else {\")) {\n                const Token *elseBody = tok->tokAt(2);\n                const Token *errorToken2 = checkLoopBodyRecursive(elseBody, var, alloc, membervar, bailout);\n                tok = elseBody->link();\n                if (errorToken1 && errorToken2)\n                    return errorToken1;\n                if (errorToken2)\n                    errorToken = errorToken2;\n            }\n            if (bailout)\n                return nullptr;\n            if (!errorToken)\n                errorToken = errorToken1;\n        }\n\n        if (tok->varId() != var.declarationId())\n            continue;\n\n        bool conditionalUsage = false;\n        for (const Token* parent = tok; parent; parent = parent->astParent()) {\n            if (Token::Match(parent->astParent(), \"%oror%|&&|?\") && astIsRHS(parent)) {\n                conditionalUsage = true;\n                break;\n            }\n        }\n\n        if (!membervar.empty()) {\n            if (isMemberVariableAssignment(tok, membervar)) {\n                bool assign = true;\n                bool rhs = false;\n                // Used for tracking if an \")\" is inner or outer\n                const Token *rpar = nullptr;\n                for (const Token *tok2 = tok->next(); tok2; tok2 = tok2->next()) {\n                    if (tok2->str() == \"=\")\n                        rhs = true;\n\n                    // Look at inner expressions but not outer expressions\n                    if (!rpar && tok2->str() == \"(\")\n                        rpar = tok2->link();\n                    else if (tok2->str() == \")\") {\n                        // No rpar => this is an outer right parenthesis\n                        if (!rpar)\n                            break;\n                        if (rpar == tok2)\n                            rpar = nullptr;\n                    }\n\n                    if (tok2->str() == \";\" || (!rpar && tok2->str() == \",\"))\n                        break;\n                    if (rhs && tok2->varId() == var.declarationId() && isMemberVariableUsage(tok2, var.isPointer(), alloc, membervar)) {\n                        assign = false;\n                        break;\n                    }\n                }\n                if (assign) {\n                    bailout = true;\n                    return nullptr;\n                }\n            }\n            if (isMemberVariableUsage(tok, var.isPointer(), alloc, membervar)) {\n                if (!conditionalUsage)\n                    return tok;\n                if (!errorToken)\n                    errorToken = tok;\n            } else if (Token::Match(tok->previous(), \"[(,] %name% [,)]\")) {\n                bailout = true;\n                return nullptr;\n            }\n        } else {\n            if (const Token *errtok = isVariableUsage(tok, var.isPointer(), alloc)) {\n                if (!conditionalUsage)\n                    return errtok;\n                if (!errorToken)\n                    errorToken = errtok;\n            } else if (tok->strAt(1) == \"=\") {\n                bool varIsUsedInRhs = false;\n                visitAstNodes(tok->next()->astOperand2(), [&](const Token * t) {\n                    if (!t)\n                        return ChildrenToVisit::none;\n                    if (t->varId() == var.declarationId()) {\n                        varIsUsedInRhs = true;\n                        return ChildrenToVisit::done;\n                    }\n                    if (isSizeOfEtc(t->previous()))\n                        return ChildrenToVisit::none;\n                    return ChildrenToVisit::op1_and_op2;\n                });\n                if (!varIsUsedInRhs) {\n                    bailout = true;\n                    return nullptr;\n                }\n            } else {\n                bailout = true;\n                return nullptr;\n            }\n        }\n    }\n\n    return errorToken;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            if (errorToken1)\n                return errorToken1;\n            if (bailout)\n",
        "src_path": "4ad90bf6f1cb0149c79324dff027cf8558c041c1___checkuninitvar.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/4ad90bf6f1cb0149c79324dff027cf8558c041c1",
        "commit_msg": "Uninitialized variables; Fixed FP in inner for loop",
        "test_func_diff": [
            {
                "fn": "test/testuninitvar.cpp",
                "patch": "@@ -1259,6 +1259,16 @@ class TestUninitVar : public TestFixture {\n                        \"}\");\n         ASSERT_EQUALS(\"[test.cpp:6]: (error) Uninitialized variable: x\\n\", errout.str());\n \n+        checkUninitVar(\"void foo(int n) {\\n\"\n+                       \"  int one[10];\\n\"\n+                       \"  for (int rank = 0; rank < n; ++rank) {\\n\"\n+                       \"    for (int i=0;i<rank;i++)\\n\"\n+                       \"      f = one[i];\\n\"\n+                       \"    one[rank] = -1;\\n\"\n+                       \"  }\\n\"\n+                       \"}\");\n+        ASSERT_EQUALS(\"\", errout.str());\n+\n         // Ticket #2226: C++0x loop\n         checkUninitVar(\"void f() {\\n\"\n                        \"    container c;\\n\""
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_4ad90bf6f1cb0149c79324dff027cf8558c041c1/build_4ad90bf6f1cb0149c79324dff027cf8558c041c1\nTest project /out/danmar___cppcheck/git_repo_dir_4ad90bf6f1cb0149c79324dff027cf8558c041c1/build_4ad90bf6f1cb0149c79324dff027cf8558c041c1\n    Start 55: TestUninitVar\n1/1 Test #55: TestUninitVar ....................***Failed    1.26 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.27 sec\n\nThe following tests FAILED:\n\t 55 - TestUninitVar (Failed)\n"
    },
    "26bd863d0a4c5499258c9672fbb945343c3901dd___tokenize.cpp": {
        "prefix": "bool Tokenizer::simplifyTokenList2()\n{\n    // clear the _functionList so it can't contain dead pointers\n    deleteSymbolDatabase();\n\n    // Clear AST,ValueFlow. These will be created again at the end of this function.\n    for (Token *tok = list.front(); tok; tok = tok->next()) {\n        tok->clearAst();\n        tok->clearValueFlow();\n    }\n\n    // f(x=g())   =>   x=g(); f(x)\n    simplifyAssignmentInFunctionCall();\n\n    // \";a+=b;\" => \";a=a+b;\"\n    simplifyCompoundAssignment();\n\n    simplifyCharAt();\n\n    // simplify references\n    simplifyReference();\n\n    simplifyStd();\n\n    if (_settings->terminated())\n        return false;\n\n    simplifySizeof();\n\n    simplifyUndefinedSizeArray();\n\n    simplifyCasts();\n\n    // Simplify simple calculations before replace constants, this allows the replacement of constants that are calculated\n    // e.g. const static int value = sizeof(X)/sizeof(Y);\n    simplifyCalculations();\n\n    if (_settings->terminated())\n        return false;\n\n    // Replace \"*(ptr + num)\" => \"ptr[num]\"\n    simplifyOffsetPointerDereference();\n\n    // Replace \"&str[num]\" => \"(str + num)\"\n    simplifyOffsetPointerReference();\n\n    removeRedundantAssignment();\n\n    simplifyRealloc();\n\n    // Change initialisation of variable to assignment\n    simplifyInitVar();\n\n    // Simplify variable declarations\n    simplifyVarDecl(false);\n\n    simplifyErrNoInWhile();\n    simplifyIfAndWhileAssign();\n    simplifyRedundantParentheses();\n    simplifyNestedStrcat();\n    simplifyFuncInWhile();\n\n    simplifyIfAndWhileAssign();\n\n    // replace strlen(str)\n    for (Token *tok = list.front(); tok; tok = tok->next()) {\n        if (Token::Match(tok, \"strlen ( %str% )\")) {\n            tok->str(MathLib::toString(Token::getStrLength(tok->tokAt(2))));\n            tok->deleteNext(3);\n        }\n    }\n\n    bool modified = true;\n    while (modified) {\n        if (_settings->terminated())\n            return false;\n\n        modified = false;\n        modified |= simplifyConditions();\n        modified |= simplifyFunctionReturn();\n        modified |= simplifyKnownVariables();\n        modified |= simplifyStrlen();\n\n        modified |= removeRedundantConditions();\n        modified |= simplifyRedundantParentheses();\n        modified |= simplifyConstTernaryOp();\n        modified |= simplifyCalculations();\n        validate();\n    }\n\n    // simplify redundant loops\n    simplifyWhile0();\n    removeRedundantFor();\n\n    // Remove redundant parentheses in return..\n    for (Token *tok = list.front(); tok; tok = tok->next()) {\n        while (Token::simpleMatch(tok, \"return (\")) {\n            Token *tok2 = tok->next()->link();\n            if (Token::simpleMatch(tok2, \") ;\")) {\n                tok->deleteNext();\n                tok2->deleteThis();\n            } else {\n                break;\n            }\n        }\n    }\n\n    simplifyReturnStrncat();\n\n    removeRedundantAssignment();\n\n    simplifyComma();\n\n    removeRedundantSemicolons();\n\n    simplifyFlowControl();\n\n    simplifyRedundantConsecutiveBraces();\n\n    simplifyEmptyNamespaces();\n\n    simplifyMathFunctions();\n\n    validate();\n\n    Token::assignProgressValues(list.front());\n\n    list.createAst();\n",
        "suffix": "    // Create symbol database and then remove const keywords\n    createSymbolDatabase();\n    _symbolDatabase->setValueTypeInTokenList();\n\n    ValueFlow::setValues(&list, _symbolDatabase, _errorLogger, _settings);\n\n    if (_settings->terminated())\n        return false;\n\n    printDebugOutput(2);\n\n    return true;\n}\n",
        "start": 3680,
        "end": 3823,
        "buggy": "bool Tokenizer::simplifyTokenList2()\n{\n    // clear the _functionList so it can't contain dead pointers\n    deleteSymbolDatabase();\n\n    // Clear AST,ValueFlow. These will be created again at the end of this function.\n    for (Token *tok = list.front(); tok; tok = tok->next()) {\n        tok->clearAst();\n        tok->clearValueFlow();\n    }\n\n    // f(x=g())   =>   x=g(); f(x)\n    simplifyAssignmentInFunctionCall();\n\n    // \";a+=b;\" => \";a=a+b;\"\n    simplifyCompoundAssignment();\n\n    simplifyCharAt();\n\n    // simplify references\n    simplifyReference();\n\n    simplifyStd();\n\n    if (_settings->terminated())\n        return false;\n\n    simplifySizeof();\n\n    simplifyUndefinedSizeArray();\n\n    simplifyCasts();\n\n    // Simplify simple calculations before replace constants, this allows the replacement of constants that are calculated\n    // e.g. const static int value = sizeof(X)/sizeof(Y);\n    simplifyCalculations();\n\n    if (_settings->terminated())\n        return false;\n\n    // Replace \"*(ptr + num)\" => \"ptr[num]\"\n    simplifyOffsetPointerDereference();\n\n    // Replace \"&str[num]\" => \"(str + num)\"\n    simplifyOffsetPointerReference();\n\n    removeRedundantAssignment();\n\n    simplifyRealloc();\n\n    // Change initialisation of variable to assignment\n    simplifyInitVar();\n\n    // Simplify variable declarations\n    simplifyVarDecl(false);\n\n    simplifyErrNoInWhile();\n    simplifyIfAndWhileAssign();\n    simplifyRedundantParentheses();\n    simplifyNestedStrcat();\n    simplifyFuncInWhile();\n\n    simplifyIfAndWhileAssign();\n\n    // replace strlen(str)\n    for (Token *tok = list.front(); tok; tok = tok->next()) {\n        if (Token::Match(tok, \"strlen ( %str% )\")) {\n            tok->str(MathLib::toString(Token::getStrLength(tok->tokAt(2))));\n            tok->deleteNext(3);\n        }\n    }\n\n    bool modified = true;\n    while (modified) {\n        if (_settings->terminated())\n            return false;\n\n        modified = false;\n        modified |= simplifyConditions();\n        modified |= simplifyFunctionReturn();\n        modified |= simplifyKnownVariables();\n        modified |= simplifyStrlen();\n\n        modified |= removeRedundantConditions();\n        modified |= simplifyRedundantParentheses();\n        modified |= simplifyConstTernaryOp();\n        modified |= simplifyCalculations();\n        validate();\n    }\n\n    // simplify redundant loops\n    simplifyWhile0();\n    removeRedundantFor();\n\n    // Remove redundant parentheses in return..\n    for (Token *tok = list.front(); tok; tok = tok->next()) {\n        while (Token::simpleMatch(tok, \"return (\")) {\n            Token *tok2 = tok->next()->link();\n            if (Token::simpleMatch(tok2, \") ;\")) {\n                tok->deleteNext();\n                tok2->deleteThis();\n            } else {\n                break;\n            }\n        }\n    }\n\n    simplifyReturnStrncat();\n\n    removeRedundantAssignment();\n\n    simplifyComma();\n\n    removeRedundantSemicolons();\n\n    simplifyFlowControl();\n\n    simplifyRedundantConsecutiveBraces();\n\n    simplifyEmptyNamespaces();\n\n    simplifyMathFunctions();\n\n    validate();\n\n    Token::assignProgressValues(list.front());\n\n    list.createAst();\n    // skipping this here may help improve performance. Might be enabled later on demand. #7208\n    // list.validateAst();\n\n    // Create symbol database and then remove const keywords\n    createSymbolDatabase();\n    _symbolDatabase->setValueTypeInTokenList();\n\n    ValueFlow::setValues(&list, _symbolDatabase, _errorLogger, _settings);\n\n    if (_settings->terminated())\n        return false;\n\n    printDebugOutput(2);\n\n    return true;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    // skipping this here may help improve performance. Might be enabled later on demand. #7208\n    // list.validateAst();\n\n",
        "src_path": "26bd863d0a4c5499258c9672fbb945343c3901dd___tokenize.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/26bd863d0a4c5499258c9672fbb945343c3901dd",
        "commit_msg": "Fixed #7724 (hang: long expression => wrong AST)",
        "test_func_diff": [
            {
                "fn": "test/testtokenize.cpp",
                "patch": "@@ -445,6 +445,7 @@ class TestTokenizer : public TestFixture {\n \n         // AST data\n         TEST_CASE(astexpr);\n+        TEST_CASE(astexpr2); // limit large expressions\n         TEST_CASE(astpar);\n         TEST_CASE(astnewdelete);\n         TEST_CASE(astbrackets);\n@@ -7866,6 +7867,8 @@ class TestTokenizer : public TestFixture {\n         tokenList.prepareTernaryOpForAST();\n         tokenList.list.createAst();\n \n+        tokenList.list.validateAst();\n+\n         // Basic AST validation\n         for (const Token *tok = tokenList.list.front(); tok; tok = tok->next()) {\n             if (tok->astOperand2() && !tok->astOperand1() && tok->str() != \";\" && tok->str() != \":\")\n@@ -7987,6 +7990,69 @@ class TestTokenizer : public TestFixture {\n         ASSERT_EQUALS(\"ifCA_FarReadfilenew(,sizeofobjtype(,(!(\", testAst(\"if (!CA_FarRead(file, (void far *)new, sizeof(objtype)))\")); // #5910 - don't hang if C code is parsed as C++\n     }\n \n+    void astexpr2() { // limit for large expressions\n+        // #7724 - wrong AST causes hang\n+        // Ideally a proper AST is created for this code.\n+        const char code[] = \"const char * a(int type) {\\n\"\n+                            \"  return (\\n\"\n+                            \"   (type == 1) ? \\\"\\\"\\n\"\n+                            \" : (type == 2) ? \\\"\\\"\\n\"\n+                            \" : (type == 3) ? \\\"\\\"\\n\"\n+                            \" : (type == 4) ? \\\"\\\"\\n\"\n+                            \" : (type == 5) ? \\\"\\\"\\n\"\n+                            \" : (type == 6) ? \\\"\\\"\\n\"\n+                            \" : (type == 7) ? \\\"\\\"\\n\"\n+                            \" : (type == 8) ? \\\"\\\"\\n\"\n+                            \" : (type == 9) ? \\\"\\\"\\n\"\n+                            \" : (type == 10) ? \\\"\\\"\\n\"\n+                            \" : (type == 11) ? \\\"\\\"\\n\"\n+                            \" : (type == 12) ? \\\"\\\"\\n\"\n+                            \" : (type == 13) ? \\\"\\\"\\n\"\n+                            \" : (type == 14) ? \\\"\\\"\\n\"\n+                            \" : (type == 15) ? \\\"\\\"\\n\"\n+                            \" : (type == 16) ? \\\"\\\"\\n\"\n+                            \" : (type == 17) ? \\\"\\\"\\n\"\n+                            \" : (type == 18) ? \\\"\\\"\\n\"\n+                            \" : (type == 19) ? \\\"\\\"\\n\"\n+                            \" : (type == 20) ? \\\"\\\"\\n\"\n+                            \" : (type == 21) ? \\\"\\\"\\n\"\n+                            \" : (type == 22) ? \\\"\\\"\\n\"\n+                            \" : (type == 23) ? \\\"\\\"\\n\"\n+                            \" : (type == 24) ? \\\"\\\"\\n\"\n+                            \" : (type == 25) ? \\\"\\\"\\n\"\n+                            \" : (type == 26) ? \\\"\\\"\\n\"\n+                            \" : (type == 27) ? \\\"\\\"\\n\"\n+                            \" : (type == 28) ? \\\"\\\"\\n\"\n+                            \" : (type == 29) ? \\\"\\\"\\n\"\n+                            \" : (type == 30) ? \\\"\\\"\\n\"\n+                            \" : (type == 31) ? \\\"\\\"\\n\"\n+                            \" : (type == 32) ? \\\"\\\"\\n\"\n+                            \" : (type == 33) ? \\\"\\\"\\n\"\n+                            \" : (type == 34) ? \\\"\\\"\\n\"\n+                            \" : (type == 35) ? \\\"\\\"\\n\"\n+                            \" : (type == 36) ? \\\"\\\"\\n\"\n+                            \" : (type == 37) ? \\\"\\\"\\n\"\n+                            \" : (type == 38) ? \\\"\\\"\\n\"\n+                            \" : (type == 39) ? \\\"\\\"\\n\"\n+                            \" : (type == 40) ? \\\"\\\"\\n\"\n+                            \" : (type == 41) ? \\\"\\\"\\n\"\n+                            \" : (type == 42) ? \\\"\\\"\\n\"\n+                            \" : (type == 43) ? \\\"\\\"\\n\"\n+                            \" : (type == 44) ? \\\"\\\"\\n\"\n+                            \" : (type == 45) ? \\\"\\\"\\n\"\n+                            \" : (type == 46) ? \\\"\\\"\\n\"\n+                            \" : (type == 47) ? \\\"\\\"\\n\"\n+                            \" : (type == 48) ? \\\"\\\"\\n\"\n+                            \" : (type == 49) ? \\\"\\\"\\n\"\n+                            \" : (type == 50) ? \\\"\\\"\\n\"\n+                            \" : (type == 51) ? \\\"\\\"\\n\"\n+                            \" : \\\"\\\");\\n\"\n+                            \"}\\n\";\n+        // Ensure that the AST is validated for the simplified token list\n+        tokenizeAndStringify(code); // this does not crash/hang\n+        ASSERT_THROW(tokenizeAndStringify(code,true), InternalError); // when parentheses are simplified the AST will be wrong\n+    }\n+\n     void astnewdelete() {\n         ASSERT_EQUALS(\"aintnew=\", testAst(\"a = new int;\"));\n         ASSERT_EQUALS(\"aint4[new=\", testAst(\"a = new int[4];\"));"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_26bd863d0a4c5499258c9672fbb945343c3901dd/build_26bd863d0a4c5499258c9672fbb945343c3901dd\nTest project /out/danmar___cppcheck/git_repo_dir_26bd863d0a4c5499258c9672fbb945343c3901dd/build_26bd863d0a4c5499258c9672fbb945343c3901dd\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   23.62 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  23.63 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n"
    },
    "dcbcb4721dda5dab0a56d9faaaee50e6a30f7758___Config_inl.hpp": {
        "prefix": "CLI11_INLINE std::string\nConfigBase::to_config(const App *app, bool default_also, bool write_description, std::string prefix) const {\n    std::stringstream out;\n    std::string commentLead;\n    commentLead.push_back(commentChar);\n    commentLead.push_back(' ');\n\n    std::vector<std::string> groups = app->get_groups();\n    bool defaultUsed = false;\n    groups.insert(groups.begin(), std::string(\"Options\"));\n    if(write_description && (app->get_configurable() || app->get_parent() == nullptr || app->get_name().empty())) {\n        out << commentLead << detail::fix_newlines(commentLead, app->get_description()) << '\\n';\n    }\n    for(auto &group : groups) {\n        if(group == \"Options\" || group.empty()) {\n            if(defaultUsed) {\n                continue;\n            }\n            defaultUsed = true;\n        }\n        if(write_description && group != \"Options\" && !group.empty()) {\n            out << '\\n' << commentLead << group << \" Options\\n\";\n        }\n        for(const Option *opt : app->get_options({})) {\n\n            // Only process options that are configurable\n            if(opt->get_configurable()) {\n                if(opt->get_group() != group) {\n                    if(!(group == \"Options\" && opt->get_group().empty())) {\n                        continue;\n                    }\n                }\n                std::string name = prefix + opt->get_single_name();\n                std::string value = detail::ini_join(\n                    opt->reduced_results(), arraySeparator, arrayStart, arrayEnd, stringQuote, characterQuote);\n\n                if(value.empty() && default_also) {\n                    if(!opt->get_default_str().empty()) {\n                        value = detail::convert_arg_for_ini(opt->get_default_str(), stringQuote, characterQuote);\n                    } else if(opt->get_expected_min() == 0) {\n                        value = \"false\";\n                    } else if(opt->get_run_callback_for_default()) {\n                        value = \"\\\"\\\"\";  // empty string default value\n                    }\n                }\n\n                if(!value.empty()) {\n",
        "suffix": "                        out << '\\n';\n                        out << commentLead << detail::fix_newlines(commentLead, opt->get_description()) << '\\n';\n                    }\n                    out << name << valueDelimiter << value << '\\n';\n                }\n            }\n        }\n    }\n    auto subcommands = app->get_subcommands({});\n    for(const App *subcom : subcommands) {\n        if(subcom->get_name().empty()) {\n            if(write_description && !subcom->get_group().empty()) {\n                out << '\\n' << commentLead << subcom->get_group() << \" Options\\n\";\n            }\n            out << to_config(subcom, default_also, write_description, prefix);\n        }\n    }\n\n    for(const App *subcom : subcommands) {\n        if(!subcom->get_name().empty()) {\n            if(subcom->get_configurable() && app->got_subcommand(subcom)) {\n                if(!prefix.empty() || app->get_parent() == nullptr) {\n                    out << '[' << prefix << subcom->get_name() << \"]\\n\";\n                } else {\n                    std::string subname = app->get_name() + parentSeparatorChar + subcom->get_name();\n                    const auto *p = app->get_parent();\n                    while(p->get_parent() != nullptr) {\n                        subname = p->get_name() + parentSeparatorChar + subname;\n                        p = p->get_parent();\n                    }\n                    out << '[' << subname << \"]\\n\";\n                }\n                out << to_config(subcom, default_also, write_description, \"\");\n            } else {\n                out << to_config(\n                    subcom, default_also, write_description, prefix + subcom->get_name() + parentSeparatorChar);\n            }\n        }\n    }\n\n    return out.str();\n}\n",
        "start": 300,
        "end": 389,
        "buggy": "CLI11_INLINE std::string\nConfigBase::to_config(const App *app, bool default_also, bool write_description, std::string prefix) const {\n    std::stringstream out;\n    std::string commentLead;\n    commentLead.push_back(commentChar);\n    commentLead.push_back(' ');\n\n    std::vector<std::string> groups = app->get_groups();\n    bool defaultUsed = false;\n    groups.insert(groups.begin(), std::string(\"Options\"));\n    if(write_description && (app->get_configurable() || app->get_parent() == nullptr || app->get_name().empty())) {\n        out << commentLead << detail::fix_newlines(commentLead, app->get_description()) << '\\n';\n    }\n    for(auto &group : groups) {\n        if(group == \"Options\" || group.empty()) {\n            if(defaultUsed) {\n                continue;\n            }\n            defaultUsed = true;\n        }\n        if(write_description && group != \"Options\" && !group.empty()) {\n            out << '\\n' << commentLead << group << \" Options\\n\";\n        }\n        for(const Option *opt : app->get_options({})) {\n\n            // Only process options that are configurable\n            if(opt->get_configurable()) {\n                if(opt->get_group() != group) {\n                    if(!(group == \"Options\" && opt->get_group().empty())) {\n                        continue;\n                    }\n                }\n                std::string name = prefix + opt->get_single_name();\n                std::string value = detail::ini_join(\n                    opt->reduced_results(), arraySeparator, arrayStart, arrayEnd, stringQuote, characterQuote);\n\n                if(value.empty() && default_also) {\n                    if(!opt->get_default_str().empty()) {\n                        value = detail::convert_arg_for_ini(opt->get_default_str(), stringQuote, characterQuote);\n                    } else if(opt->get_expected_min() == 0) {\n                        value = \"false\";\n                    } else if(opt->get_run_callback_for_default()) {\n                        value = \"\\\"\\\"\";  // empty string default value\n                    }\n                }\n\n                if(!value.empty()) {\n                    if(write_description && opt->has_description()) {\n                        out << '\\n';\n                        out << commentLead << detail::fix_newlines(commentLead, opt->get_description()) << '\\n';\n                    }\n                    out << name << valueDelimiter << value << '\\n';\n                }\n            }\n        }\n    }\n    auto subcommands = app->get_subcommands({});\n    for(const App *subcom : subcommands) {\n        if(subcom->get_name().empty()) {\n            if(write_description && !subcom->get_group().empty()) {\n                out << '\\n' << commentLead << subcom->get_group() << \" Options\\n\";\n            }\n            out << to_config(subcom, default_also, write_description, prefix);\n        }\n    }\n\n    for(const App *subcom : subcommands) {\n        if(!subcom->get_name().empty()) {\n            if(subcom->get_configurable() && app->got_subcommand(subcom)) {\n                if(!prefix.empty() || app->get_parent() == nullptr) {\n                    out << '[' << prefix << subcom->get_name() << \"]\\n\";\n                } else {\n                    std::string subname = app->get_name() + parentSeparatorChar + subcom->get_name();\n                    const auto *p = app->get_parent();\n                    while(p->get_parent() != nullptr) {\n                        subname = p->get_name() + parentSeparatorChar + subname;\n                        p = p->get_parent();\n                    }\n                    out << '[' << subname << \"]\\n\";\n                }\n                out << to_config(subcom, default_also, write_description, \"\");\n            } else {\n                out << to_config(\n                    subcom, default_also, write_description, prefix + subcom->get_name() + parentSeparatorChar);\n            }\n        }\n    }\n\n    return out.str();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                    if(write_description && opt->has_description()) {\n",
        "src_path": "dcbcb4721dda5dab0a56d9faaaee50e6a30f7758___Config_inl.hpp",
        "uri": "https://api.github.com/repos/CLIUtils/CLI11/commits/dcbcb4721dda5dab0a56d9faaaee50e6a30f7758",
        "commit_msg": "fix: negated flag config files (#775)\n\n* add some coverage tests, and fix the issue with negated flags and config files\r\n\r\n* style: pre-commit.ci fixes\r\n\r\nCo-authored-by: pre-commit-ci[bot] <66853113+pre-commit-ci[bot]@users.noreply.github.com>",
        "test_func_diff": [
            {
                "fn": "tests/ConfigFileTest.cpp",
                "patch": "@@ -2497,6 +2497,29 @@ TEST_CASE_METHOD(TApp, \"ConfigWriteReadWrite\", \"[config]\") {\n     CHECK(config2 == config1);\n }\n \n+TEST_CASE_METHOD(TApp, \"ConfigWriteReadNegated\", \"[config]\") {\n+\n+    TempFile tmpini{\"TestIniTmp.ini\"};\n+    bool flag{true};\n+    app.add_flag(\"!--no-flag\", flag);\n+    args = {\"--no-flag\"};\n+    run();\n+\n+    // Save config, with default values too\n+    std::string config1 = app.config_to_str(false, false);\n+    {\n+        std::ofstream out{tmpini};\n+        out << config1 << std::endl;\n+    }\n+    CHECK_FALSE(flag);\n+    args.clear();\n+    flag = true;\n+    app.set_config(\"--config\", tmpini, \"Read an ini file\", true);\n+    run();\n+\n+    CHECK_FALSE(flag);\n+}\n+\n /////// INI output tests\n \n TEST_CASE_METHOD(TApp, \"IniOutputSimple\", \"[config]\") {"
            },
            {
                "fn": "tests/CreationTest.cpp",
                "patch": "@@ -549,6 +549,25 @@ TEST_CASE_METHOD(TApp, \"GetOptionList\", \"[creation]\") {\n     }\n }\n \n+TEST_CASE_METHOD(TApp, \"GetOptionListFilter\", \"[creation]\") {\n+    int two{0};\n+    auto *flag = app.add_flag(\"--one\");\n+    app.add_option(\"--two\", two);\n+\n+    const CLI::App &const_app = app;  // const alias to force use of const-methods\n+    std::vector<const CLI::Option *> opt_listc =\n+        const_app.get_options([](const CLI::Option *opt) { return opt->get_name() == \"--one\"; });\n+\n+    REQUIRE(static_cast<std::size_t>(1) == opt_listc.size());\n+    CHECK(flag == opt_listc.at(0));\n+\n+    std::vector<CLI::Option *> opt_list =\n+        app.get_options([](const CLI::Option *opt) { return opt->get_name() == \"--one\"; });\n+\n+    REQUIRE(static_cast<std::size_t>(1) == opt_list.size());\n+    CHECK(flag == opt_list.at(0));\n+}\n+\n TEST_CASE(\"ValidatorTests: TestValidatorCreation\", \"[creation]\") {\n     std::function<std::string(std::string &)> op1 = [](std::string &val) {\n         return (val.size() >= 5) ? std::string{} : val;"
            },
            {
                "fn": "tests/SubcommandTest.cpp",
                "patch": "@@ -916,6 +916,10 @@ TEST_CASE_METHOD(TApp, \"SubcomInheritCaseCheck\", \"[subcom]\") {\n     CHECK(app.get_subcommands({}).size() == 2u);\n     CHECK(app.get_subcommands([](const CLI::App *s) { return s->get_name() == \"sub1\"; }).size() == 1u);\n \n+    // check the const version of get_subcommands\n+    const auto &app_const = app;\n+    CHECK(app_const.get_subcommands([](const CLI::App *s) { return s->get_name() == \"sub1\"; }).size() == 1u);\n+\n     args = {\"SuB1\"};\n     run();\n     CHECK(app.get_subcommands().at(0) == sub1);\n@@ -1192,6 +1196,18 @@ TEST_CASE_METHOD(ManySubcommands, \"manyIndexQueryPtr\", \"[subcom]\") {\n     CHECK_THROWS_AS(app.get_subcommand_ptr(4), CLI::OptionNotFound);\n }\n \n+TEST_CASE_METHOD(ManySubcommands, \"manyIndexQueryPtrByName\", \"[subcom]\") {\n+    auto s1 = app.get_subcommand_ptr(\"sub1\");\n+    auto s2 = app.get_subcommand_ptr(\"sub2\");\n+    auto s3 = app.get_subcommand_ptr(\"sub3\");\n+    auto s4 = app.get_subcommand_ptr(\"sub4\");\n+    CHECK(sub1 == s1.get());\n+    CHECK(sub2 == s2.get());\n+    CHECK(sub3 == s3.get());\n+    CHECK(sub4 == s4.get());\n+    CHECK_THROWS_AS(app.get_subcommand_ptr(\"sub5\"), CLI::OptionNotFound);\n+}\n+\n TEST_CASE_METHOD(ManySubcommands, \"Required1Fuzzy\", \"[subcom]\") {\n \n     app.require_subcommand(0, 1);"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CLIUtils___CLI11/git_repo_dir_dcbcb4721dda5dab0a56d9faaaee50e6a30f7758/build_dcbcb4721dda5dab0a56d9faaaee50e6a30f7758\nTest project /out/CLIUtils___CLI11/git_repo_dir_dcbcb4721dda5dab0a56d9faaaee50e6a30f7758/build_dcbcb4721dda5dab0a56d9faaaee50e6a30f7758\n\nCLI11 information:\n  C++ standard: 11\n  __has_include: yes\n  No optional library found\n\n    Start 2: ConfigFileTest\n1/1 Test #2: ConfigFileTest ...................***Failed    0.04 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.04 sec\n\nThe following tests FAILED:\n\t  2 - ConfigFileTest (Failed)\n"
    },
    "dfe791684b24adc9eef81baef867f824866abdfa___width.cpp": {
        "prefix": "static bool split_line(chunk_t *start)\n{\n   LOG_FUNC_ENTRY();\n   LOG_FMT(LSPLIT, \"%s(%d): start->flags \", __func__, __LINE__);\n   log_pcf_flags(LSPLIT, start->flags);\n   LOG_FMT(LSPLIT, \"%s(%d): orig_line is %zu, column is %zu, text() '%s', type is %s,\\n\",\n           __func__, __LINE__, start->orig_line, start->column, start->text(),\n           get_token_name(start->type));\n   LOG_FMT(LSPLIT, \"   parent_type %s, (PCF_IN_FCN_DEF is %s), (PCF_IN_FCN_CALL is %s),\",\n           get_token_name(start->parent_type),\n           ((start->flags & (PCF_IN_FCN_DEF)) != 0) ? \"TRUE\" : \"FALSE\",\n           ((start->flags & (PCF_IN_FCN_CALL)) != 0) ? \"TRUE\" : \"FALSE\");\n#ifdef DEBUG\n   LOG_FMT(LSPLIT, \"\\n\");\n#endif // DEBUG\n\n   // break at maximum line length if ls_code_width is true\n   if (start->flags & PCF_ONE_LINER)\n   {\n      LOG_FMT(LSPLIT, \" ** ONCE LINER SPLIT **\\n\");\n      undo_one_liner(start);\n      newlines_cleanup_braces(false);\n",
        "suffix": "   }\n\n   LOG_FMT(LSPLIT, \"%s(%d):\\n\", __func__, __LINE__);\n   if (cpd.settings[UO_ls_code_width].b)\n   {\n   }\n   // Check to see if we are in a for statement\n   else if (start->flags & PCF_IN_FOR)\n   {\n      LOG_FMT(LSPLIT, \" ** FOR SPLIT **\\n\");\n      split_for_stmt(start);\n      if (!is_past_width(start))\n      {\n         return(true);\n      }\n      LOG_FMT(LSPLIT, \"%s(%d): for split didn't work\\n\", __func__, __LINE__);\n   }\n\n   /*\n    * If this is in a function call or prototype, split on commas or right\n    * after the open parenthesis\n    */\n   else if (  (start->flags & PCF_IN_FCN_DEF)\n           || start->parent_type == CT_FUNC_PROTO            // Issue #1169\n           || (  (start->level == (start->brace_level + 1))\n              && (start->flags & PCF_IN_FCN_CALL)))\n   {\n      LOG_FMT(LSPLIT, \" ** FUNC SPLIT **\\n\");\n\n      if (cpd.settings[UO_ls_func_split_full].b)\n      {\n         split_fcn_params_full(start);\n         if (!is_past_width(start))\n         {\n            return(true);\n         }\n      }\n      split_fcn_params(start);\n      return(true);\n   }\n\n   /*\n    * If this is in a template, split on commas, Issue #1170\n    */\n   else if (start->flags & PCF_IN_TEMPLATE)\n   {\n      LOG_FMT(LSPLIT, \" ** TEMPLATE SPLIT **\\n\");\n      split_template(start);\n      return(true);\n   }\n\n   LOG_FMT(LSPLIT, \"%s(%d):\\n\", __func__, __LINE__);\n   // Try to find the best spot to split the line\n   cw_entry ent;\n\n   memset(&ent, 0, sizeof(ent));\n   chunk_t *pc = start;\n   chunk_t *prev;\n\n   while (((pc = chunk_get_prev(pc)) != nullptr) && !chunk_is_newline(pc))\n   {\n      LOG_FMT(LSPLIT, \"%s(%d): at %s, orig_line=%zu, orig_col=%zu\\n\",\n              __func__, __LINE__, pc->text(), pc->orig_line, pc->orig_col);\n      if (pc->type != CT_SPACE)\n      {\n         try_split_here(ent, pc);\n         // break at maximum line length\n         if (ent.pc != nullptr && (cpd.settings[UO_ls_code_width].b))\n         {\n            break;\n         }\n      }\n   }\n\n   if (ent.pc == nullptr)\n   {\n      LOG_FMT(LSPLIT, \"\\n%s(%d):    TRY_SPLIT yielded NO SOLUTION for orig_line %zu at %s [%s]\\n\",\n              __func__, __LINE__, start->orig_line, start->text(), get_token_name(start->type));\n   }\n   else\n   {\n      LOG_FMT(LSPLIT, \"\\n%s(%d):    TRY_SPLIT yielded '%s' [%s] on orig_line %zu\\n\",\n              __func__, __LINE__, ent.pc->text(), get_token_name(ent.pc->type), ent.pc->orig_line);\n      LOG_FMT(LSPLIT, \"%s(%d): ent at %s, orig_col=%zu\\n\",\n              __func__, __LINE__, ent.pc->text(), ent.pc->orig_col);\n   }\n\n   // Break before the token instead of after it according to the pos_xxx rules\n   if (ent.pc == nullptr)\n   {\n      pc = nullptr;\n   }\n   else\n   {\n      if (  (  (  chunk_is_token(ent.pc, CT_ARITH)\n               || chunk_is_token(ent.pc, CT_CARET))\n            && (cpd.settings[UO_pos_arith].tp & TP_LEAD))\n         || (  chunk_is_token(ent.pc, CT_ASSIGN)\n            && (cpd.settings[UO_pos_assign].tp & TP_LEAD))\n         || (  chunk_is_token(ent.pc, CT_COMPARE)\n            && (cpd.settings[UO_pos_compare].tp & TP_LEAD))\n         || (  (  chunk_is_token(ent.pc, CT_COND_COLON)\n               || chunk_is_token(ent.pc, CT_QUESTION))\n            && (cpd.settings[UO_pos_conditional].tp & TP_LEAD))\n         || (  chunk_is_token(ent.pc, CT_BOOL)\n            && (cpd.settings[UO_pos_bool].tp & TP_LEAD)))\n      {\n         pc = ent.pc;\n      }\n      else\n      {\n         pc = chunk_get_next(ent.pc);\n      }\n      LOG_FMT(LSPLIT, \"%s(%d): at %s, col=%zu\\n\", __func__, __LINE__, pc->text(), pc->orig_col);\n   }\n\n   if (pc == nullptr)\n   {\n      pc = start;\n      // Don't break before a close, comma, or colon\n      if (  start->type == CT_PAREN_CLOSE\n         || start->type == CT_PAREN_OPEN\n         || start->type == CT_FPAREN_CLOSE\n         || start->type == CT_FPAREN_OPEN\n         || start->type == CT_SPAREN_CLOSE\n         || start->type == CT_SPAREN_OPEN\n         || start->type == CT_ANGLE_CLOSE\n         || start->type == CT_BRACE_CLOSE\n         || start->type == CT_COMMA\n         || start->type == CT_SEMICOLON\n         || start->type == CT_VSEMICOLON\n         || start->len() == 0)\n      {\n         LOG_FMT(LSPLIT, \" ** NO GO **\\n\");\n\n         // TODO: Add in logic to handle 'hard' limits by backing up a token\n         return(true);\n      }\n   }\n\n   // add a newline before pc\n   prev = chunk_get_prev(pc);\n   if (  prev != nullptr\n      && !chunk_is_newline(pc)\n      && !chunk_is_newline(prev))\n   {\n      //int plen = (pc->len() < 5) ? pc->len() : 5;\n      //int slen = (start->len() < 5) ? start->len() : 5;\n      //LOG_FMT(LSPLIT, \" '%.*s' [%s], started on token '%.*s' [%s]\\n\",\n      //        plen, pc->text(), get_token_name(pc->type),\n      //        slen, start->text(), get_token_name(start->type));\n      LOG_FMT(LSPLIT, \"  %s(%d): %s [%s], started on token '%s' [%s]\\n\",\n              __func__, __LINE__, pc->text(), get_token_name(pc->type),\n              start->text(), get_token_name(start->type));\n\n      split_before_chunk(pc);\n   }\n   return(true);\n} // split_line\n",
        "start": 319,
        "end": 500,
        "buggy": "static bool split_line(chunk_t *start)\n{\n   LOG_FUNC_ENTRY();\n   LOG_FMT(LSPLIT, \"%s(%d): start->flags \", __func__, __LINE__);\n   log_pcf_flags(LSPLIT, start->flags);\n   LOG_FMT(LSPLIT, \"%s(%d): orig_line is %zu, column is %zu, text() '%s', type is %s,\\n\",\n           __func__, __LINE__, start->orig_line, start->column, start->text(),\n           get_token_name(start->type));\n   LOG_FMT(LSPLIT, \"   parent_type %s, (PCF_IN_FCN_DEF is %s), (PCF_IN_FCN_CALL is %s),\",\n           get_token_name(start->parent_type),\n           ((start->flags & (PCF_IN_FCN_DEF)) != 0) ? \"TRUE\" : \"FALSE\",\n           ((start->flags & (PCF_IN_FCN_CALL)) != 0) ? \"TRUE\" : \"FALSE\");\n#ifdef DEBUG\n   LOG_FMT(LSPLIT, \"\\n\");\n#endif // DEBUG\n\n   // break at maximum line length if ls_code_width is true\n   if (start->flags & PCF_ONE_LINER)\n   {\n      LOG_FMT(LSPLIT, \" ** ONCE LINER SPLIT **\\n\");\n      undo_one_liner(start);\n      newlines_cleanup_braces(false);\n      return(false);\n   }\n\n   LOG_FMT(LSPLIT, \"%s(%d):\\n\", __func__, __LINE__);\n   if (cpd.settings[UO_ls_code_width].b)\n   {\n   }\n   // Check to see if we are in a for statement\n   else if (start->flags & PCF_IN_FOR)\n   {\n      LOG_FMT(LSPLIT, \" ** FOR SPLIT **\\n\");\n      split_for_stmt(start);\n      if (!is_past_width(start))\n      {\n         return(true);\n      }\n      LOG_FMT(LSPLIT, \"%s(%d): for split didn't work\\n\", __func__, __LINE__);\n   }\n\n   /*\n    * If this is in a function call or prototype, split on commas or right\n    * after the open parenthesis\n    */\n   else if (  (start->flags & PCF_IN_FCN_DEF)\n           || start->parent_type == CT_FUNC_PROTO            // Issue #1169\n           || (  (start->level == (start->brace_level + 1))\n              && (start->flags & PCF_IN_FCN_CALL)))\n   {\n      LOG_FMT(LSPLIT, \" ** FUNC SPLIT **\\n\");\n\n      if (cpd.settings[UO_ls_func_split_full].b)\n      {\n         split_fcn_params_full(start);\n         if (!is_past_width(start))\n         {\n            return(true);\n         }\n      }\n      split_fcn_params(start);\n      return(true);\n   }\n\n   /*\n    * If this is in a template, split on commas, Issue #1170\n    */\n   else if (start->flags & PCF_IN_TEMPLATE)\n   {\n      LOG_FMT(LSPLIT, \" ** TEMPLATE SPLIT **\\n\");\n      split_template(start);\n      return(true);\n   }\n\n   LOG_FMT(LSPLIT, \"%s(%d):\\n\", __func__, __LINE__);\n   // Try to find the best spot to split the line\n   cw_entry ent;\n\n   memset(&ent, 0, sizeof(ent));\n   chunk_t *pc = start;\n   chunk_t *prev;\n\n   while (((pc = chunk_get_prev(pc)) != nullptr) && !chunk_is_newline(pc))\n   {\n      LOG_FMT(LSPLIT, \"%s(%d): at %s, orig_line=%zu, orig_col=%zu\\n\",\n              __func__, __LINE__, pc->text(), pc->orig_line, pc->orig_col);\n      if (pc->type != CT_SPACE)\n      {\n         try_split_here(ent, pc);\n         // break at maximum line length\n         if (ent.pc != nullptr && (cpd.settings[UO_ls_code_width].b))\n         {\n            break;\n         }\n      }\n   }\n\n   if (ent.pc == nullptr)\n   {\n      LOG_FMT(LSPLIT, \"\\n%s(%d):    TRY_SPLIT yielded NO SOLUTION for orig_line %zu at %s [%s]\\n\",\n              __func__, __LINE__, start->orig_line, start->text(), get_token_name(start->type));\n   }\n   else\n   {\n      LOG_FMT(LSPLIT, \"\\n%s(%d):    TRY_SPLIT yielded '%s' [%s] on orig_line %zu\\n\",\n              __func__, __LINE__, ent.pc->text(), get_token_name(ent.pc->type), ent.pc->orig_line);\n      LOG_FMT(LSPLIT, \"%s(%d): ent at %s, orig_col=%zu\\n\",\n              __func__, __LINE__, ent.pc->text(), ent.pc->orig_col);\n   }\n\n   // Break before the token instead of after it according to the pos_xxx rules\n   if (ent.pc == nullptr)\n   {\n      pc = nullptr;\n   }\n   else\n   {\n      if (  (  (  chunk_is_token(ent.pc, CT_ARITH)\n               || chunk_is_token(ent.pc, CT_CARET))\n            && (cpd.settings[UO_pos_arith].tp & TP_LEAD))\n         || (  chunk_is_token(ent.pc, CT_ASSIGN)\n            && (cpd.settings[UO_pos_assign].tp & TP_LEAD))\n         || (  chunk_is_token(ent.pc, CT_COMPARE)\n            && (cpd.settings[UO_pos_compare].tp & TP_LEAD))\n         || (  (  chunk_is_token(ent.pc, CT_COND_COLON)\n               || chunk_is_token(ent.pc, CT_QUESTION))\n            && (cpd.settings[UO_pos_conditional].tp & TP_LEAD))\n         || (  chunk_is_token(ent.pc, CT_BOOL)\n            && (cpd.settings[UO_pos_bool].tp & TP_LEAD)))\n      {\n         pc = ent.pc;\n      }\n      else\n      {\n         pc = chunk_get_next(ent.pc);\n      }\n      LOG_FMT(LSPLIT, \"%s(%d): at %s, col=%zu\\n\", __func__, __LINE__, pc->text(), pc->orig_col);\n   }\n\n   if (pc == nullptr)\n   {\n      pc = start;\n      // Don't break before a close, comma, or colon\n      if (  start->type == CT_PAREN_CLOSE\n         || start->type == CT_PAREN_OPEN\n         || start->type == CT_FPAREN_CLOSE\n         || start->type == CT_FPAREN_OPEN\n         || start->type == CT_SPAREN_CLOSE\n         || start->type == CT_SPAREN_OPEN\n         || start->type == CT_ANGLE_CLOSE\n         || start->type == CT_BRACE_CLOSE\n         || start->type == CT_COMMA\n         || start->type == CT_SEMICOLON\n         || start->type == CT_VSEMICOLON\n         || start->len() == 0)\n      {\n         LOG_FMT(LSPLIT, \" ** NO GO **\\n\");\n\n         // TODO: Add in logic to handle 'hard' limits by backing up a token\n         return(true);\n      }\n   }\n\n   // add a newline before pc\n   prev = chunk_get_prev(pc);\n   if (  prev != nullptr\n      && !chunk_is_newline(pc)\n      && !chunk_is_newline(prev))\n   {\n      //int plen = (pc->len() < 5) ? pc->len() : 5;\n      //int slen = (start->len() < 5) ? start->len() : 5;\n      //LOG_FMT(LSPLIT, \" '%.*s' [%s], started on token '%.*s' [%s]\\n\",\n      //        plen, pc->text(), get_token_name(pc->type),\n      //        slen, start->text(), get_token_name(start->type));\n      LOG_FMT(LSPLIT, \"  %s(%d): %s [%s], started on token '%s' [%s]\\n\",\n              __func__, __LINE__, pc->text(), get_token_name(pc->type),\n              start->text(), get_token_name(start->type));\n\n      split_before_chunk(pc);\n   }\n   return(true);\n} // split_line\n",
        "fix": null,
        "buggy_hunk_masked": "      return(false);\n",
        "src_path": "dfe791684b24adc9eef81baef867f824866abdfa___width.cpp",
        "uri": "https://api.github.com/repos/uncrustify/uncrustify/commits/dfe791684b24adc9eef81baef867f824866abdfa",
        "commit_msg": "A bugfix for #1352.\nA new run in the loop is necessary.",
        "test_func_diff": [
            {
                "fn": "tests/output/c/00451-enum_gallery.c",
                "patch": "@@ -13,7 +13,9 @@ enum foo { bar, baz, quux };\n  * In some tests, the following line remains longer than 80\n  * characters. Perhaps a bug?\n  */\n-enum longer_enum_that { will, not, all, fit, on, one, line, as, longg, as, the, cutoff, is, reasonable, because, this, is, a, very, very, wide, line };\n+enum longer_enum_that { will, not, all, fit, on, one, line, as, longg, as, the,\n+\t                cutoff, is, reasonable, because, this, is, a, very,\n+\t                very, wide, line };\n \n enum q { w,\n \t e,r,"
            },
            {
                "fn": "tests/output/c/00453-enum_gallery.c",
                "patch": "@@ -13,7 +13,9 @@ enum foo { bar, baz, quux };\n  * In some tests, the following line remains longer than 80\n  * characters. Perhaps a bug?\n  */\n-enum longer_enum_that { will, not, all, fit, on, one, line, as, longg, as, the, cutoff, is, reasonable, because, this, is, a, very, very, wide, line };\n+enum longer_enum_that { will, not, all, fit, on, one, line, as, longg, as, the,\n+\t                cutoff, is, reasonable, because, this, is, a, very,\n+\t                very, wide, line };\n \n enum q { w,e,r,t,y}\n "
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/uncrustify___uncrustify/git_repo_dir_dfe791684b24adc9eef81baef867f824866abdfa/build_dfe791684b24adc9eef81baef867f824866abdfa\nTest project /out/uncrustify___uncrustify/git_repo_dir_dfe791684b24adc9eef81baef867f824866abdfa/build_dfe791684b24adc9eef81baef867f824866abdfa\n    Start 148: c_00451\n1/2 Test #148: c_00451 ..........................***Failed    0.01 sec\n    Start 150: c_00453\n2/2 Test #150: c_00453 ..........................***Failed    0.01 sec\n\n0% tests passed, 2 tests failed out of 2\n\nLabel Time Summary:\nc    =   0.03 sec*proc (2 tests)\n\nTotal Test time (real) =   0.07 sec\n\nThe following tests FAILED:\n\t148 - c_00451 (Failed)\n\t150 - c_00453 (Failed)\n"
    },
    "279d698e1b37f3f0a9b5c21b12198894d31c381d___format.h": {
        "prefix": "template <typename OutputIt, typename Char, typename UInt> struct int_writer {\n  OutputIt out;\n  locale_ref locale;\n  const basic_format_specs<Char>& specs;\n  UInt abs_value;\n  char prefix[4];\n  unsigned prefix_size;\n\n  using iterator =\n      remove_reference_t<decltype(reserve(std::declval<OutputIt&>(), 0))>;\n\n  string_view get_prefix() const { return string_view(prefix, prefix_size); }\n\n  template <typename Int>\n  int_writer(OutputIt output, locale_ref loc, Int value,\n             const basic_format_specs<Char>& s)\n      : out(output),\n        locale(loc),\n        specs(s),\n        abs_value(static_cast<UInt>(value)),\n        prefix_size(0) {\n    static_assert(std::is_same<uint32_or_64_or_128_t<Int>, UInt>::value, \"\");\n    if (is_negative(value)) {\n      prefix[0] = '-';\n      ++prefix_size;\n      abs_value = 0 - abs_value;\n    } else if (specs.sign != sign::none && specs.sign != sign::minus) {\n      prefix[0] = specs.sign == sign::plus ? '+' : ' ';\n      ++prefix_size;\n    }\n  }\n\n  void on_dec() {\n    auto num_digits = count_digits(abs_value);\n    out = write_int(\n        out, num_digits, get_prefix(), specs, [this, num_digits](iterator it) {\n          return format_decimal<Char>(it, abs_value, num_digits).end;\n        });\n  }\n\n  void on_hex() {\n    if (specs.alt) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = specs.type;\n    }\n    int num_digits = count_digits<4>(abs_value);\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<4, Char>(it, abs_value, num_digits,\n                                                  specs.type != 'x');\n                    });\n  }\n\n  void on_bin() {\n    if (specs.alt) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = static_cast<char>(specs.type);\n    }\n    int num_digits = count_digits<1>(abs_value);\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<1, Char>(it, abs_value, num_digits);\n                    });\n  }\n\n  void on_oct() {\n    int num_digits = count_digits<3>(abs_value);\n    if (specs.alt && specs.precision <= num_digits && abs_value != 0) {\n      // Octal prefix '0' is counted as a digit, so only add it if precision\n      // is not greater than the number of digits.\n      prefix[prefix_size++] = '0';\n    }\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<3, Char>(it, abs_value, num_digits);\n                    });\n  }\n\n  enum { sep_size = 1 };\n\n  void on_num() {\n    std::string groups = grouping<Char>(locale);\n    if (groups.empty()) return on_dec();\n    auto sep = thousands_sep<Char>(locale);\n    if (!sep) return on_dec();\n    int num_digits = count_digits(abs_value);\n    int size = num_digits, n = num_digits;\n    std::string::const_iterator group = groups.cbegin();\n    while (group != groups.cend() && n > *group && *group > 0 &&\n           *group != max_value<char>()) {\n      size += sep_size;\n      n -= *group;\n      ++group;\n    }\n    if (group == groups.cend()) size += sep_size * ((n - 1) / groups.back());\n    char digits[40];\n    format_decimal(digits, abs_value, num_digits);\n    basic_memory_buffer<Char> buffer;\n    size += prefix_size;\n    buffer.resize(size);\n    basic_string_view<Char> s(&sep, sep_size);\n    // Index of a decimal digit with the least significant digit having index 0.\n    int digit_index = 0;\n    group = groups.cbegin();\n    auto p = buffer.data() + size;\n    for (int i = num_digits - 1; i >= 0; --i) {\n      *--p = static_cast<Char>(digits[i]);\n      if (*group <= 0 || ++digit_index % *group != 0 ||\n          *group == max_value<char>())\n        continue;\n      if (group + 1 != groups.cend()) {\n        digit_index = 0;\n        ++group;\n      }\n      p -= s.size();\n      std::uninitialized_copy(s.data(), s.data() + s.size(),\n                              make_checked(p, s.size()));\n    }\n    if (prefix_size != 0) p[-1] = static_cast<Char>('-');\n",
        "suffix": "\n  void on_chr() { *out++ = static_cast<Char>(abs_value); }\n\n  FMT_NORETURN void on_error() {\n    FMT_THROW(format_error(\"invalid type specifier\"));\n  }\n};\n",
        "start": 1497,
        "end": 1625,
        "buggy": "template <typename OutputIt, typename Char, typename UInt> struct int_writer {\n  OutputIt out;\n  locale_ref locale;\n  const basic_format_specs<Char>& specs;\n  UInt abs_value;\n  char prefix[4];\n  unsigned prefix_size;\n\n  using iterator =\n      remove_reference_t<decltype(reserve(std::declval<OutputIt&>(), 0))>;\n\n  string_view get_prefix() const { return string_view(prefix, prefix_size); }\n\n  template <typename Int>\n  int_writer(OutputIt output, locale_ref loc, Int value,\n             const basic_format_specs<Char>& s)\n      : out(output),\n        locale(loc),\n        specs(s),\n        abs_value(static_cast<UInt>(value)),\n        prefix_size(0) {\n    static_assert(std::is_same<uint32_or_64_or_128_t<Int>, UInt>::value, \"\");\n    if (is_negative(value)) {\n      prefix[0] = '-';\n      ++prefix_size;\n      abs_value = 0 - abs_value;\n    } else if (specs.sign != sign::none && specs.sign != sign::minus) {\n      prefix[0] = specs.sign == sign::plus ? '+' : ' ';\n      ++prefix_size;\n    }\n  }\n\n  void on_dec() {\n    auto num_digits = count_digits(abs_value);\n    out = write_int(\n        out, num_digits, get_prefix(), specs, [this, num_digits](iterator it) {\n          return format_decimal<Char>(it, abs_value, num_digits).end;\n        });\n  }\n\n  void on_hex() {\n    if (specs.alt) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = specs.type;\n    }\n    int num_digits = count_digits<4>(abs_value);\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<4, Char>(it, abs_value, num_digits,\n                                                  specs.type != 'x');\n                    });\n  }\n\n  void on_bin() {\n    if (specs.alt) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = static_cast<char>(specs.type);\n    }\n    int num_digits = count_digits<1>(abs_value);\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<1, Char>(it, abs_value, num_digits);\n                    });\n  }\n\n  void on_oct() {\n    int num_digits = count_digits<3>(abs_value);\n    if (specs.alt && specs.precision <= num_digits && abs_value != 0) {\n      // Octal prefix '0' is counted as a digit, so only add it if precision\n      // is not greater than the number of digits.\n      prefix[prefix_size++] = '0';\n    }\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<3, Char>(it, abs_value, num_digits);\n                    });\n  }\n\n  enum { sep_size = 1 };\n\n  void on_num() {\n    std::string groups = grouping<Char>(locale);\n    if (groups.empty()) return on_dec();\n    auto sep = thousands_sep<Char>(locale);\n    if (!sep) return on_dec();\n    int num_digits = count_digits(abs_value);\n    int size = num_digits, n = num_digits;\n    std::string::const_iterator group = groups.cbegin();\n    while (group != groups.cend() && n > *group && *group > 0 &&\n           *group != max_value<char>()) {\n      size += sep_size;\n      n -= *group;\n      ++group;\n    }\n    if (group == groups.cend()) size += sep_size * ((n - 1) / groups.back());\n    char digits[40];\n    format_decimal(digits, abs_value, num_digits);\n    basic_memory_buffer<Char> buffer;\n    size += prefix_size;\n    buffer.resize(size);\n    basic_string_view<Char> s(&sep, sep_size);\n    // Index of a decimal digit with the least significant digit having index 0.\n    int digit_index = 0;\n    group = groups.cbegin();\n    auto p = buffer.data() + size;\n    for (int i = num_digits - 1; i >= 0; --i) {\n      *--p = static_cast<Char>(digits[i]);\n      if (*group <= 0 || ++digit_index % *group != 0 ||\n          *group == max_value<char>())\n        continue;\n      if (group + 1 != groups.cend()) {\n        digit_index = 0;\n        ++group;\n      }\n      p -= s.size();\n      std::uninitialized_copy(s.data(), s.data() + s.size(),\n                              make_checked(p, s.size()));\n    }\n    if (prefix_size != 0) p[-1] = static_cast<Char>('-');\n    out = write(out, basic_string_view<Char>(buffer.data(), buffer.size()),\n                specs);\n  }\n\n  void on_chr() { *out++ = static_cast<Char>(abs_value); }\n\n  FMT_NORETURN void on_error() {\n    FMT_THROW(format_error(\"invalid type specifier\"));\n  }\n};\n",
        "fix": null,
        "buggy_hunk_masked": "    out = write(out, basic_string_view<Char>(buffer.data(), buffer.size()),\n                specs);\n  }\n",
        "src_path": "279d698e1b37f3f0a9b5c21b12198894d31c381d___format.h",
        "uri": "https://api.github.com/repos/fmtlib/fmt/commits/279d698e1b37f3f0a9b5c21b12198894d31c381d",
        "commit_msg": "Fix handling of default alignmment with locale (#1801)",
        "test_func_diff": [
            {
                "fn": "test/locale-test.cc",
                "patch": "@@ -70,6 +70,11 @@ TEST(LocaleTest, Format) {\n             fmt::format(small_grouping_loc, \"{:L}\", max_value<uint32_t>()));\n }\n \n+TEST(LocaleTest, FormatDetaultAlign) {\n+  std::locale special_grouping_loc(std::locale(), new special_grouping<char>());\n+  EXPECT_EQ(\"  12,345\", fmt::format(special_grouping_loc, \"{:8L}\", 12345));\n+}\n+\n TEST(LocaleTest, WFormat) {\n   std::locale loc(std::locale(), new numpunct<wchar_t>());\n   EXPECT_EQ(L\"1234567\", fmt::format(std::locale(), L\"{:L}\", 1234567));"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_279d698e1b37f3f0a9b5c21b12198894d31c381d/build_279d698e1b37f3f0a9b5c21b12198894d31c381d\nTest project /out/fmtlib___fmt/git_repo_dir_279d698e1b37f3f0a9b5c21b12198894d31c381d/build_279d698e1b37f3f0a9b5c21b12198894d31c381d\n    Start 9: locale-test\n1/1 Test #9: locale-test ......................***Failed    0.00 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.00 sec\n\nThe following tests FAILED:\n\t  9 - locale-test (Failed)\n"
    },
    "c1d430e61ab306e0e1d454fea6e07b4f66667a65___chrono.h": {
        "prefix": "struct chrono_formatter {\n  FormatContext& context;\n  OutputIt out;\n  int precision;\n  Rep val;\n  typedef std::chrono::duration<Rep> seconds;\n  seconds s;\n  typedef std::chrono::duration<Rep, std::milli> milliseconds;\n  milliseconds ms;\n\n  typedef typename FormatContext::char_type char_type;\n\n  explicit chrono_formatter(FormatContext& ctx, OutputIt o,\n                            std::chrono::duration<Rep, Period> d)\n",
        "suffix": "  int hour() const { return to_int(mod((s.count() / 3600), 24)); }\n",
        "start": 419,
        "end": 439,
        "buggy": "struct chrono_formatter {\n  FormatContext& context;\n  OutputIt out;\n  int precision;\n  Rep val;\n  typedef std::chrono::duration<Rep> seconds;\n  seconds s;\n  typedef std::chrono::duration<Rep, std::milli> milliseconds;\n  milliseconds ms;\n\n  typedef typename FormatContext::char_type char_type;\n\n  explicit chrono_formatter(FormatContext& ctx, OutputIt o,\n                            std::chrono::duration<Rep, Period> d)\n      : context(ctx),\n        out(o),\n        val(d.count()),\n        s(std::chrono::duration_cast<seconds>(d)),\n        ms(std::chrono::duration_cast<milliseconds>(d - s)) {}\n\n  int hour() const { return to_int(mod((s.count() / 3600), 24)); }\n",
        "fix": null,
        "buggy_hunk_masked": "      : context(ctx),\n        out(o),\n        val(d.count()),\n        s(std::chrono::duration_cast<seconds>(d)),\n        ms(std::chrono::duration_cast<milliseconds>(d - s)) {}\n\n",
        "src_path": "c1d430e61ab306e0e1d454fea6e07b4f66667a65___chrono.h",
        "uri": "https://api.github.com/repos/fmtlib/fmt/commits/c1d430e61ab306e0e1d454fea6e07b4f66667a65",
        "commit_msg": "Improve handling of negative durations",
        "test_func_diff": [
            {
                "fn": "test/chrono-test.cc",
                "patch": "@@ -310,4 +310,8 @@ TEST(ChronoTest, LargeDuration) {\n   EXPECT_EQ(\"40\", fmt::format(\"{:%S}\", std::chrono::duration<double>(1e20)));\n }\n \n+TEST(ChronoTest, NegativeDuration) {\n+  EXPECT_EQ(\"-00:01\", fmt::format(\"{:%M:%S}\", std::chrono::duration<double>(-1)));\n+}\n+\n #endif  // FMT_STATIC_THOUSANDS_SEPARATOR"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_c1d430e61ab306e0e1d454fea6e07b4f66667a65/build_c1d430e61ab306e0e1d454fea6e07b4f66667a65\nTest project /out/fmtlib___fmt/git_repo_dir_c1d430e61ab306e0e1d454fea6e07b4f66667a65/build_c1d430e61ab306e0e1d454fea6e07b4f66667a65\n    Start 2: chrono-test\n1/1 Test #2: chrono-test ......................***Failed    0.00 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.00 sec\n\nThe following tests FAILED:\n\t  2 - chrono-test (Failed)\n"
    },
    "971fb584c3ea548c12dcfa813b0bafb94e1c0fde___format.h": {
        "prefix": "  basic_context<Char>::get_arg(basic_string_view<Char> name) {\n",
        "suffix": "}\n",
        "start": 3003,
        "end": 3011,
        "buggy": "  basic_context<Char>::get_arg(basic_string_view<Char> name) {\n  if (this->check_no_auto_index()) {\n    map_.init(this->args());\n    if (const format_arg *arg = map_.find(name))\n      return *arg;\n    this->on_error(\"argument not found\");\n  }\n  return format_arg();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  if (this->check_no_auto_index()) {\n    map_.init(this->args());\n    if (const format_arg *arg = map_.find(name))\n      return *arg;\n    this->on_error(\"argument not found\");\n  }\n  return format_arg();\n",
        "src_path": "971fb584c3ea548c12dcfa813b0bafb94e1c0fde___format.h",
        "uri": "https://api.github.com/repos/fmtlib/fmt/commits/971fb584c3ea548c12dcfa813b0bafb94e1c0fde",
        "commit_msg": "Allow mixing named and automatic arguments",
        "test_func_diff": [
            {
                "fn": "test/format-test.cc",
                "patch": "@@ -488,6 +488,7 @@ TEST(FormatterTest, NamedArg) {\n   EXPECT_THROW_MSG(format(\"{a}\"), format_error, \"argument not found\");\n   EXPECT_EQ(\" -42\", format(\"{0:{width}}\", -42, fmt::arg(\"width\", 4)));\n   EXPECT_EQ(\"st\", format(\"{0:.{precision}}\", \"str\", fmt::arg(\"precision\", 2)));\n+  EXPECT_EQ(\"1 2\", format(\"{} {two}\", 1, fmt::arg(\"two\", 2)));\n }\n \n TEST(FormatterTest, AutoArgIndex) {"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_971fb584c3ea548c12dcfa813b0bafb94e1c0fde/build_971fb584c3ea548c12dcfa813b0bafb94e1c0fde\nTest project /out/fmtlib___fmt/git_repo_dir_971fb584c3ea548c12dcfa813b0bafb94e1c0fde/build_971fb584c3ea548c12dcfa813b0bafb94e1c0fde\n    Start 3: format-test\n1/1 Test #3: format-test ......................***Failed    0.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.02 sec\n\nThe following tests FAILED:\n\t  3 - format-test (Failed)\n"
    },
    "c04fb91b03cb6480c4a39b214efb6b05e452b20c___format.h": {
        "prefix": "  auto format(const T &val, FormatContext &ctx) -> decltype(ctx.out()) {\n    internal::handle_dynamic_spec<internal::width_checker>(\n      specs_.width_, specs_.width_ref, ctx);\n    internal::handle_dynamic_spec<internal::precision_checker>(\n      specs_.precision_, specs_.precision_ref, ctx);\n    typedef output_range<typename FormatContext::iterator,\n                         typename FormatContext::char_type> range_type;\n",
        "suffix": "",
        "start": 3212,
        "end": 3222,
        "buggy": "  auto format(const T &val, FormatContext &ctx) -> decltype(ctx.out()) {\n    internal::handle_dynamic_spec<internal::width_checker>(\n      specs_.width_, specs_.width_ref, ctx);\n    internal::handle_dynamic_spec<internal::precision_checker>(\n      specs_.precision_, specs_.precision_ref, ctx);\n    typedef output_range<typename FormatContext::iterator,\n                         typename FormatContext::char_type> range_type;\n    visit(arg_formatter<range_type>(ctx, specs_),\n          internal::make_arg<FormatContext>(val));\n    return ctx.out();\n  }\n",
        "fix": null,
        "buggy_hunk_masked": "    visit(arg_formatter<range_type>(ctx, specs_),\n          internal::make_arg<FormatContext>(val));\n    return ctx.out();\n  }\n",
        "src_path": "c04fb91b03cb6480c4a39b214efb6b05e452b20c___format.h",
        "uri": "https://api.github.com/repos/fmtlib/fmt/commits/c04fb91b03cb6480c4a39b214efb6b05e452b20c",
        "commit_msg": "Fix handling of user-defined types in format_to (#793)",
        "test_func_diff": [
            {
                "fn": "test/format-test.cc",
                "patch": "@@ -1122,7 +1122,8 @@ class Answer {};\n FMT_BEGIN_NAMESPACE\n template <>\n struct formatter<Answer> : formatter<int> {\n-  auto format(Answer, fmt::format_context &ctx) -> decltype(ctx.out()) {\n+  template <typename FormatContext>\n+  auto format(Answer, FormatContext &ctx) -> decltype(ctx.out()) {\n     return formatter<int>::format(42, ctx);\n   }\n };\n@@ -1133,6 +1134,13 @@ TEST(FormatterTest, CustomFormat) {\n   EXPECT_EQ(\"0042\", format(\"{:04}\", Answer()));\n }\n \n+TEST(FormatterTest, CustomFormatTo) {\n+  char buf[10] = {};\n+  auto end = fmt::format_to(buf, \"{}\", Answer());\n+  EXPECT_EQ(end, buf + 2);\n+  EXPECT_STREQ(buf, \"42\");\n+}\n+\n TEST(FormatterTest, WideFormatString) {\n   EXPECT_EQ(L\"42\", format(L\"{}\", 42));\n   EXPECT_EQ(L\"4.2\", format(L\"{}\", 4.2));"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_c04fb91b03cb6480c4a39b214efb6b05e452b20c/build_c04fb91b03cb6480c4a39b214efb6b05e452b20c\nTest project /out/fmtlib___fmt/git_repo_dir_c04fb91b03cb6480c4a39b214efb6b05e452b20c/build_c04fb91b03cb6480c4a39b214efb6b05e452b20c\n    Start 3: format-test\n1/1 Test #3: format-test ......................***Failed    0.03 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.03 sec\n\nThe following tests FAILED:\n\t  3 - format-test (Failed)\n"
    }
}