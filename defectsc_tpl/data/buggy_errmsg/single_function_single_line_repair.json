{
    "ae5b5ba529753c7a653901ffc29b5ea24c3fdf3a___ldebug.c": {
        "prefix": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n",
        "suffix": "}\n",
        "start": 785,
        "end": 791,
        "buggy": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  /* no line changes in the way */\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  return 0;  /* no line changes in the way */\n",
        "src_path": "ae5b5ba529753c7a653901ffc29b5ea24c3fdf3a___ldebug.c",
        "uri": "https://api.github.com/repos/lua/lua/commits/ae5b5ba529753c7a653901ffc29b5ea24c3fdf3a",
        "commit_msg": "Fixed bug: line hooks in stripped functions\n\nLine-hook handling was accessing debug info. without checking whether\nit was present.",
        "test_func_diff": [
            {
                "fn": "testes/db.lua",
                "patch": "@@ -884,7 +884,7 @@ end\n \n \n print(\"testing debug functions on chunk without debug info\")\n-prog = [[-- program to be loaded without debug information\n+prog = [[-- program to be loaded without debug information (strip)\n local debug = require'debug'\n local a = 12  -- a local variable\n \n@@ -927,6 +927,23 @@ local f = assert(load(string.dump(load(prog), true)))\n \n assert(f() == 13)\n \n+do   -- bug in 5.4.0: line hooks in stripped code\n+  local function foo ()\n+    local a = 1\n+    local b = 2\n+    return b\n+  end\n+\n+  local s = load(string.dump(foo, true))\n+  local line = true\n+  debug.sethook(function (e, l)\n+    assert(e == \"line\")\n+    line = l\n+  end, \"l\")\n+  assert(s() == 2); debug.sethook(nil)\n+  assert(line == nil)  -- hook called withoug debug info for 1st instruction\n+end\n+\n do   -- tests for 'source' in binary dumps\n   local prog = [[\n     return function (x)"
            }
        ],
        "error_msg": "testing debug library and debug information\n+\ntesting inspection of parameters/returned values\n+\n+\ntesting traceback sizes\ntesting debug functions on chunk without debug info\n"
    },
    "1890d59905414ab84a35892b2e45833654aa5c13___tool_writeout.c": {
        "prefix": "void ourWriteOut(CURL *curl, struct OutStruct *outs, const char *writeinfo)\n{\n  FILE *stream = stdout;\n  const char *ptr = writeinfo;\n  char *stringp = NULL;\n  long longinfo;\n  double doubleinfo;\n\n  while(ptr && *ptr) {\n",
        "suffix": "      if('%' == ptr[1]) {\n        /* an escaped %-letter */\n        fputc('%', stream);\n        ptr += 2;\n      }\n      else {\n        /* this is meant as a variable to output */\n        char *end;\n        char keepit;\n        int i;\n        if('{' == ptr[1]) {\n          bool match = FALSE;\n          end = strchr(ptr, '}');\n          ptr += 2; /* pass the % and the { */\n          if(!end) {\n            fputs(\"%{\", stream);\n            continue;\n          }\n          keepit = *end;\n          *end = 0; /* zero terminate */\n          for(i = 0; replacements[i].name; i++) {\n            if(curl_strequal(ptr, replacements[i].name)) {\n              match = TRUE;\n              switch(replacements[i].id) {\n              case VAR_EFFECTIVE_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_HTTP_CODE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HTTP_CODE_PROXY:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE,\n                                     &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HEADER_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REQUEST_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_NUM_CONNECTS:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_COUNT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_TOTAL_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_NAMELOOKUP_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_CONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_APPCONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_PRETRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_STARTTRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_SIZE_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SIZE_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SPEED_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_SPEED_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_CONTENT_TYPE:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_FTP_ENTRY_PATH:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_REDIRECT_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_PROXY_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PROXY_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_EFFECTIVE_FILENAME:\n                if(outs->filename)\n                  fprintf(stream, \"%s\", outs->filename);\n                break;\n              case VAR_PRIMARY_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_PRIMARY_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_LOCAL_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_LOCAL_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_HTTP_VERSION:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_VERSION,\n                                     &longinfo)) {\n                  const char *version = \"0\";\n                  switch(longinfo) {\n                  case CURL_HTTP_VERSION_1_0:\n                    version = \"1.0\";\n                    break;\n                  case CURL_HTTP_VERSION_1_1:\n                    version = \"1.1\";\n                    break;\n                  case CURL_HTTP_VERSION_2_0:\n                    version = \"2\";\n                    break;\n                  }\n\n                  fprintf(stream, version);\n                }\n                break;\n              case VAR_SCHEME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SCHEME,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              default:\n                break;\n              }\n              break;\n            }\n          }\n          if(!match) {\n            fprintf(stderr, \"curl: unknown --write-out variable: '%s'\\n\", ptr);\n          }\n          ptr = end + 1; /* pass the end */\n          *end = keepit;\n        }\n        else {\n          /* illegal syntax, then just output the characters that are used */\n          fputc('%', stream);\n          fputc(ptr[1], stream);\n          ptr += 2;\n        }\n      }\n    }\n    else if('\\\\' == *ptr) {\n      switch(ptr[1]) {\n      case 'r':\n        fputc('\\r', stream);\n        break;\n      case 'n':\n        fputc('\\n', stream);\n        break;\n      case 't':\n        fputc('\\t', stream);\n        break;\n      default:\n        /* unknown, just output this */\n        fputc(*ptr, stream);\n        fputc(ptr[1], stream);\n        break;\n      }\n      ptr += 2;\n    }\n    else {\n      fputc(*ptr, stream);\n      ptr++;\n    }\n  }\n\n}\n",
        "start": 107,
        "end": 369,
        "buggy": "void ourWriteOut(CURL *curl, struct OutStruct *outs, const char *writeinfo)\n{\n  FILE *stream = stdout;\n  const char *ptr = writeinfo;\n  char *stringp = NULL;\n  long longinfo;\n  double doubleinfo;\n\n  while(ptr && *ptr) {\n    if('%' == *ptr) {\n      if('%' == ptr[1]) {\n        /* an escaped %-letter */\n        fputc('%', stream);\n        ptr += 2;\n      }\n      else {\n        /* this is meant as a variable to output */\n        char *end;\n        char keepit;\n        int i;\n        if('{' == ptr[1]) {\n          bool match = FALSE;\n          end = strchr(ptr, '}');\n          ptr += 2; /* pass the % and the { */\n          if(!end) {\n            fputs(\"%{\", stream);\n            continue;\n          }\n          keepit = *end;\n          *end = 0; /* zero terminate */\n          for(i = 0; replacements[i].name; i++) {\n            if(curl_strequal(ptr, replacements[i].name)) {\n              match = TRUE;\n              switch(replacements[i].id) {\n              case VAR_EFFECTIVE_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_HTTP_CODE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HTTP_CODE_PROXY:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE,\n                                     &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HEADER_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REQUEST_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_NUM_CONNECTS:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_COUNT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_TOTAL_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_NAMELOOKUP_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_CONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_APPCONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_PRETRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_STARTTRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_SIZE_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SIZE_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SPEED_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_SPEED_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_CONTENT_TYPE:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_FTP_ENTRY_PATH:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_REDIRECT_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_PROXY_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PROXY_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_EFFECTIVE_FILENAME:\n                if(outs->filename)\n                  fprintf(stream, \"%s\", outs->filename);\n                break;\n              case VAR_PRIMARY_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_PRIMARY_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_LOCAL_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_LOCAL_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_HTTP_VERSION:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_VERSION,\n                                     &longinfo)) {\n                  const char *version = \"0\";\n                  switch(longinfo) {\n                  case CURL_HTTP_VERSION_1_0:\n                    version = \"1.0\";\n                    break;\n                  case CURL_HTTP_VERSION_1_1:\n                    version = \"1.1\";\n                    break;\n                  case CURL_HTTP_VERSION_2_0:\n                    version = \"2\";\n                    break;\n                  }\n\n                  fprintf(stream, version);\n                }\n                break;\n              case VAR_SCHEME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SCHEME,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              default:\n                break;\n              }\n              break;\n            }\n          }\n          if(!match) {\n            fprintf(stderr, \"curl: unknown --write-out variable: '%s'\\n\", ptr);\n          }\n          ptr = end + 1; /* pass the end */\n          *end = keepit;\n        }\n        else {\n          /* illegal syntax, then just output the characters that are used */\n          fputc('%', stream);\n          fputc(ptr[1], stream);\n          ptr += 2;\n        }\n      }\n    }\n    else if('\\\\' == *ptr) {\n      switch(ptr[1]) {\n      case 'r':\n        fputc('\\r', stream);\n        break;\n      case 'n':\n        fputc('\\n', stream);\n        break;\n      case 't':\n        fputc('\\t', stream);\n        break;\n      default:\n        /* unknown, just output this */\n        fputc(*ptr, stream);\n        fputc(ptr[1], stream);\n        break;\n      }\n      ptr += 2;\n    }\n    else {\n      fputc(*ptr, stream);\n      ptr++;\n    }\n  }\n\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if('%' == *ptr) {\n",
        "src_path": "1890d59905414ab84a35892b2e45833654aa5c13___tool_writeout.c",
        "uri": "https://api.github.com/repos/curl/curl/commits/1890d59905414ab84a35892b2e45833654aa5c13",
        "commit_msg": "tool_writeout: fixed a buffer read overrun on --write-out\n\nIf a % ended the statement, the string's trailing NUL would be skipped\nand memory past the end of the buffer would be accessed and potentially\ndisplayed as part of the --write-out output. Added tests 1440 and 1441\nto check for this kind of condition.\n\nReported-by: Brian Carpenter",
        "test_func_diff": [
            {
                "fn": "tests/data/Makefile.inc",
                "patch": "@@ -153,7 +153,7 @@ test1408 test1409 test1410 test1411 test1412 test1413 test1414 test1415 \\\n test1416 test1417 test1418 test1419 test1420 test1421 test1422 test1423 \\\n test1424 \\\n test1428 test1429 test1430 test1431 test1432 test1433 test1434 test1435 \\\n-test1436 test1437 test1438 test1439 \\\n+test1436 test1437 test1438 test1439 test1440 test1441 \\\n \\\n test1500 test1501 test1502 test1503 test1504 test1505 test1506 test1507 \\\n test1508 test1509 test1510 test1511 test1512 test1513 test1514 test1515 \\"
            },
            {
                "fn": "tests/data/test1440",
                "patch": "@@ -0,0 +1,31 @@\n+<testcase>\n+<info>\n+<keywords>\n+--write-out\n+</keywords>\n+</info>\n+# Server-side\n+<reply>\n+</reply>\n+\n+# Client-side\n+<client>\n+<server>\n+file\n+</server>\n+\n+<name>\n+Check --write-out with trailing %{\n+</name>\n+<command>\n+file://localhost/%PWD/log/ --write-out '%{'\n+</command>\n+</client>\n+\n+# Verify data\n+<verify>\n+<stdout nonewline=\"yes\">\n+%{\n+</stdout>\n+</verify>\n+</testcase>"
            },
            {
                "fn": "tests/data/test1441",
                "patch": "@@ -0,0 +1,31 @@\n+<testcase>\n+<info>\n+<keywords>\n+--write-out\n+</keywords>\n+</info>\n+# Server-side\n+<reply>\n+</reply>\n+\n+# Client-side\n+<client>\n+<server>\n+file\n+</server>\n+\n+<name>\n+Check --write-out with trailing %\n+</name>\n+<command>\n+file://localhost/%PWD/log/ --write-out '%'\n+</command>\n+</client>\n+\n+# Verify data\n+<verify>\n+<stdout nonewline=\"yes\">\n+%\n+</stdout>\n+</verify>\n+</testcase>"
            }
        ],
        "error_msg": "********* System characteristics ******** \n* curl 7.54.0-DEV (x86_64-pc-linux-gnu) \n* libcurl/7.54.0-DEV OpenSSL/1.1.1f\n* Features: Debug TrackMemory IPv6 Largefile NTLM NTLM_WB SSL TLS-SRP UnixSockets HTTPS-proxy \n* Host: deef54515472\n* System: Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux\n* Servers: \n* Env: Valgrind \n***************************************** \ntest 1440...[Check --write-out with trailing %{]\ns-----emv- OK (1   out of 2  , remaining: 00:01)\ntest 1441...[Check --write-out with trailing %]\n\n 1441: stdout FAILED:\nBinary files log/check-expected and log/check-generated differ\n\n - abort tests\nTESTDONE: 1 tests out of 2 reported OK: 50%\nTESTFAIL: These test cases failed: 1441 \nTESTDONE: 2 tests were considered during 4 seconds.\n"
    },
    "f76e7feb41a4327d2b0978449bbdafe98d4a3771___print-isakmp.c": {
        "prefix": "void\nisakmp_rfc3948_print(netdissect_options *ndo,\n\t\t     const u_char *bp, u_int length,\n\t\t     const u_char *bp2)\n{\n",
        "suffix": "\tif(length == 1 && bp[0]==0xff) {\n\t\tND_PRINT((ndo, \"isakmp-nat-keep-alive\"));\n\t\treturn;\n\t}\n\n\tif(length < 4) {\n\t\tgoto trunc;\n\t}\n\n\t/*\n\t * see if this is an IKE packet\n\t */\n\tif(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {\n\t\tND_PRINT((ndo, \"NONESP-encap: \"));\n\t\tisakmp_print(ndo, bp+4, length-4, bp2);\n\t\treturn;\n\t}\n\n\t/* must be an ESP packet */\n\t{\n\t\tint nh, enh, padlen;\n\t\tint advance;\n\n\t\tND_PRINT((ndo, \"UDP-encap: \"));\n\n\t\tadvance = esp_print(ndo, bp, length, bp2, &enh, &padlen);\n\t\tif(advance <= 0)\n\t\t\treturn;\n\n\t\tbp += advance;\n\t\tlength -= advance + padlen;\n\t\tnh = enh & 0xff;\n\n\t\tip_print_inner(ndo, bp, length, nh, bp2);\n\t\treturn;\n\t}\n\ntrunc:\n\tND_PRINT((ndo,\"[|isakmp]\"));\n\treturn;\n}\n",
        "start": 3039,
        "end": 3085,
        "buggy": "void\nisakmp_rfc3948_print(netdissect_options *ndo,\n\t\t     const u_char *bp, u_int length,\n\t\t     const u_char *bp2)\n{\n\n\tif(length == 1 && bp[0]==0xff) {\n\t\tND_PRINT((ndo, \"isakmp-nat-keep-alive\"));\n\t\treturn;\n\t}\n\n\tif(length < 4) {\n\t\tgoto trunc;\n\t}\n\n\t/*\n\t * see if this is an IKE packet\n\t */\n\tif(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {\n\t\tND_PRINT((ndo, \"NONESP-encap: \"));\n\t\tisakmp_print(ndo, bp+4, length-4, bp2);\n\t\treturn;\n\t}\n\n\t/* must be an ESP packet */\n\t{\n\t\tint nh, enh, padlen;\n\t\tint advance;\n\n\t\tND_PRINT((ndo, \"UDP-encap: \"));\n\n\t\tadvance = esp_print(ndo, bp, length, bp2, &enh, &padlen);\n\t\tif(advance <= 0)\n\t\t\treturn;\n\n\t\tbp += advance;\n\t\tlength -= advance + padlen;\n\t\tnh = enh & 0xff;\n\n\t\tip_print_inner(ndo, bp, length, nh, bp2);\n\t\treturn;\n\t}\n\ntrunc:\n\tND_PRINT((ndo,\"[|isakmp]\"));\n\treturn;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\n",
        "src_path": "f76e7feb41a4327d2b0978449bbdafe98d4a3771___print-isakmp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/f76e7feb41a4327d2b0978449bbdafe98d4a3771",
        "commit_msg": "CVE-2017-12896/ISAKMP: Do bounds checks in isakmp_rfc3948_print().\n\nThis fixes a buffer over-read discovered by Kamil Frankowicz.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -441,6 +441,7 @@ isoclns-heapoverflow-3\tisoclns-heapoverflow-3.pcap\tisoclns-heapoverflow-3.out\t-e\n stp-v4-length-sigsegv\tstp-v4-length-sigsegv.pcap\tstp-v4-length-sigsegv.out\n hoobr_pimv1\t\thoobr_pimv1.pcap\t\thoobr_pimv1.out\n hoobr_safeputs\t\thoobr_safeputs.pcap\t\thoobr_safeputs.out\n+isakmp-rfc3948-oobr\tisakmp-rfc3948-oobr.pcap\tisakmp-rfc3948-oobr.out\n \n # bad packets from Wilfried Kirsch\n slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve"
            },
            {
                "fn": "tests/isakmp-rfc3948-oobr.out",
                "patch": "@@ -0,0 +1,67 @@\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+IP 48.48.48.48.4500 > 48.48.48.48.12336: [|isakmp]"
            }
        ],
        "error_msg": "    isakmp-rfc3948-oobr                : TEST FAILED(exit 256)\n"
    },
    "979dcefd7b259e9e233f77fe1c5312793bfd948f___print-isoclns.c": {
        "prefix": "static int\nisis_print_extd_ip_reach(netdissect_options *ndo,\n                         const uint8_t *tptr, const char *ident, uint16_t afi)\n{\n    char ident_buffer[20];\n    uint8_t prefix[sizeof(struct in6_addr)]; /* shared copy buffer for IPv4 and IPv6 prefixes */\n    u_int metric, status_byte, bit_length, byte_length, sublen, processed, subtlvtype, subtlvlen;\n\n    if (!ND_TTEST2(*tptr, 4))\n        return (0);\n    metric = EXTRACT_32BITS(tptr);\n    processed=4;\n    tptr+=4;\n\n    if (afi == AF_INET) {\n        if (!ND_TTEST2(*tptr, 1)) /* fetch status byte */\n            return (0);\n        status_byte=*(tptr++);\n        bit_length = status_byte&0x3f;\n        if (bit_length > 32) {\n            ND_PRINT((ndo, \"%sIPv4 prefix: bad bit length %u\",\n                   ident,\n                   bit_length));\n            return (0);\n        }\n        processed++;\n    } else if (afi == AF_INET6) {\n",
        "suffix": "            return (0);\n        status_byte=*(tptr++);\n        bit_length=*(tptr++);\n        if (bit_length > 128) {\n            ND_PRINT((ndo, \"%sIPv6 prefix: bad bit length %u\",\n                   ident,\n                   bit_length));\n            return (0);\n        }\n        processed+=2;\n    } else\n        return (0); /* somebody is fooling us */\n\n    byte_length = (bit_length + 7) / 8; /* prefix has variable length encoding */\n\n    if (!ND_TTEST2(*tptr, byte_length))\n        return (0);\n    memset(prefix, 0, sizeof prefix);   /* clear the copy buffer */\n    memcpy(prefix,tptr,byte_length);    /* copy as much as is stored in the TLV */\n    tptr+=byte_length;\n    processed+=byte_length;\n\n    if (afi == AF_INET)\n        ND_PRINT((ndo, \"%sIPv4 prefix: %15s/%u\",\n               ident,\n               ipaddr_string(ndo, prefix),\n               bit_length));\n    else if (afi == AF_INET6)\n        ND_PRINT((ndo, \"%sIPv6 prefix: %s/%u\",\n               ident,\n               ip6addr_string(ndo, prefix),\n               bit_length));\n\n    ND_PRINT((ndo, \", Distribution: %s, Metric: %u\",\n           ISIS_MASK_TLV_EXTD_IP_UPDOWN(status_byte) ? \"down\" : \"up\",\n           metric));\n\n    if (afi == AF_INET && ISIS_MASK_TLV_EXTD_IP_SUBTLV(status_byte))\n        ND_PRINT((ndo, \", sub-TLVs present\"));\n    else if (afi == AF_INET6)\n        ND_PRINT((ndo, \", %s%s\",\n               ISIS_MASK_TLV_EXTD_IP6_IE(status_byte) ? \"External\" : \"Internal\",\n               ISIS_MASK_TLV_EXTD_IP6_SUBTLV(status_byte) ? \", sub-TLVs present\" : \"\"));\n\n    if ((afi == AF_INET  && ISIS_MASK_TLV_EXTD_IP_SUBTLV(status_byte))\n     || (afi == AF_INET6 && ISIS_MASK_TLV_EXTD_IP6_SUBTLV(status_byte))\n\t) {\n        /* assume that one prefix can hold more\n           than one subTLV - therefore the first byte must reflect\n           the aggregate bytecount of the subTLVs for this prefix\n        */\n        if (!ND_TTEST2(*tptr, 1))\n            return (0);\n        sublen=*(tptr++);\n        processed+=sublen+1;\n        ND_PRINT((ndo, \" (%u)\", sublen));   /* print out subTLV length */\n\n        while (sublen>0) {\n            if (!ND_TTEST2(*tptr,2))\n                return (0);\n            subtlvtype=*(tptr++);\n            subtlvlen=*(tptr++);\n            /* prepend the indent string */\n            snprintf(ident_buffer, sizeof(ident_buffer), \"%s  \",ident);\n            if (!isis_print_ip_reach_subtlv(ndo, tptr, subtlvtype, subtlvlen, ident_buffer))\n                return(0);\n            tptr+=subtlvlen;\n            sublen-=(subtlvlen+2);\n        }\n    }\n    return (processed);\n}\n",
        "start": 2014,
        "end": 2113,
        "buggy": "static int\nisis_print_extd_ip_reach(netdissect_options *ndo,\n                         const uint8_t *tptr, const char *ident, uint16_t afi)\n{\n    char ident_buffer[20];\n    uint8_t prefix[sizeof(struct in6_addr)]; /* shared copy buffer for IPv4 and IPv6 prefixes */\n    u_int metric, status_byte, bit_length, byte_length, sublen, processed, subtlvtype, subtlvlen;\n\n    if (!ND_TTEST2(*tptr, 4))\n        return (0);\n    metric = EXTRACT_32BITS(tptr);\n    processed=4;\n    tptr+=4;\n\n    if (afi == AF_INET) {\n        if (!ND_TTEST2(*tptr, 1)) /* fetch status byte */\n            return (0);\n        status_byte=*(tptr++);\n        bit_length = status_byte&0x3f;\n        if (bit_length > 32) {\n            ND_PRINT((ndo, \"%sIPv4 prefix: bad bit length %u\",\n                   ident,\n                   bit_length));\n            return (0);\n        }\n        processed++;\n    } else if (afi == AF_INET6) {\n        if (!ND_TTEST2(*tptr, 1)) /* fetch status & prefix_len byte */\n            return (0);\n        status_byte=*(tptr++);\n        bit_length=*(tptr++);\n        if (bit_length > 128) {\n            ND_PRINT((ndo, \"%sIPv6 prefix: bad bit length %u\",\n                   ident,\n                   bit_length));\n            return (0);\n        }\n        processed+=2;\n    } else\n        return (0); /* somebody is fooling us */\n\n    byte_length = (bit_length + 7) / 8; /* prefix has variable length encoding */\n\n    if (!ND_TTEST2(*tptr, byte_length))\n        return (0);\n    memset(prefix, 0, sizeof prefix);   /* clear the copy buffer */\n    memcpy(prefix,tptr,byte_length);    /* copy as much as is stored in the TLV */\n    tptr+=byte_length;\n    processed+=byte_length;\n\n    if (afi == AF_INET)\n        ND_PRINT((ndo, \"%sIPv4 prefix: %15s/%u\",\n               ident,\n               ipaddr_string(ndo, prefix),\n               bit_length));\n    else if (afi == AF_INET6)\n        ND_PRINT((ndo, \"%sIPv6 prefix: %s/%u\",\n               ident,\n               ip6addr_string(ndo, prefix),\n               bit_length));\n\n    ND_PRINT((ndo, \", Distribution: %s, Metric: %u\",\n           ISIS_MASK_TLV_EXTD_IP_UPDOWN(status_byte) ? \"down\" : \"up\",\n           metric));\n\n    if (afi == AF_INET && ISIS_MASK_TLV_EXTD_IP_SUBTLV(status_byte))\n        ND_PRINT((ndo, \", sub-TLVs present\"));\n    else if (afi == AF_INET6)\n        ND_PRINT((ndo, \", %s%s\",\n               ISIS_MASK_TLV_EXTD_IP6_IE(status_byte) ? \"External\" : \"Internal\",\n               ISIS_MASK_TLV_EXTD_IP6_SUBTLV(status_byte) ? \", sub-TLVs present\" : \"\"));\n\n    if ((afi == AF_INET  && ISIS_MASK_TLV_EXTD_IP_SUBTLV(status_byte))\n     || (afi == AF_INET6 && ISIS_MASK_TLV_EXTD_IP6_SUBTLV(status_byte))\n\t) {\n        /* assume that one prefix can hold more\n           than one subTLV - therefore the first byte must reflect\n           the aggregate bytecount of the subTLVs for this prefix\n        */\n        if (!ND_TTEST2(*tptr, 1))\n            return (0);\n        sublen=*(tptr++);\n        processed+=sublen+1;\n        ND_PRINT((ndo, \" (%u)\", sublen));   /* print out subTLV length */\n\n        while (sublen>0) {\n            if (!ND_TTEST2(*tptr,2))\n                return (0);\n            subtlvtype=*(tptr++);\n            subtlvlen=*(tptr++);\n            /* prepend the indent string */\n            snprintf(ident_buffer, sizeof(ident_buffer), \"%s  \",ident);\n            if (!isis_print_ip_reach_subtlv(ndo, tptr, subtlvtype, subtlvlen, ident_buffer))\n                return(0);\n            tptr+=subtlvlen;\n            sublen-=(subtlvlen+2);\n        }\n    }\n    return (processed);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        if (!ND_TTEST2(*tptr, 1)) /* fetch status & prefix_len byte */\n",
        "src_path": "979dcefd7b259e9e233f77fe1c5312793bfd948f___print-isoclns.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/979dcefd7b259e9e233f77fe1c5312793bfd948f",
        "commit_msg": "CVE-2017-12998/IS-IS: Check for 2 bytes if we're going to fetch 2 bytes.\n\nProbably a copy-and-pasteo.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -478,6 +478,7 @@ resp_4_infiniteloop\tresp_4_infiniteloop.pcap\tresp_4_infiniteloop.out\t-vvv -e\n dns_fwdptr\t\tdns_fwdptr.pcap\t\t\tdns_fwdptr.out\t\t-vvv -e\n isis-areaaddr-oobr-1\tisis-areaaddr-oobr-1.pcap\tisis-areaaddr-oobr-1.out\t\t-vvv -e\n isis-areaaddr-oobr-2\tisis-areaaddr-oobr-2.pcap\tisis-areaaddr-oobr-2.out\t\t-vvv -e\n+isis-extd-ipreach-oobr\tisis-extd-ipreach-oobr.pcap\tisis-extd-ipreach-oobr.out\t\t-vvv -e\n \n # RTP tests\n # fuzzed pcap"
            }
        ],
        "error_msg": "    isis-extd-ipreach-oobr             : passed\n"
    },
    "a7e5f58f402e6919ec444a57946bade7dfd6b184___print-802_15_4.c": {
        "prefix": "u_int\nieee802_15_4_if_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int hdrlen;\n\tuint16_t fc;\n\tuint8_t seq;\n\tuint16_t panid = 0;\n\n\tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\treturn caplen;\n\t}\n\thdrlen = 3;\n\n\tfc = EXTRACT_LE_16BITS(p);\n\tseq = EXTRACT_LE_8BITS(p + 2);\n\n\tp += 3;\n\tcaplen -= 3;\n\n\tND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[FC_FRAME_TYPE(fc)]));\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"seq %02x \", seq));\n\n\t/*\n\t * Destination address and PAN ID, if present.\n\t */\n\tswitch (FC_DEST_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (fc & FC_PAN_ID_COMPRESSION) {\n\t\t\t/*\n\t\t\t * PAN ID compression; this requires that both\n\t\t\t * the source and destination addresses be present,\n\t\t\t * but the destination address is missing.\n\t\t\t */\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved destination addressing mode\"));\n\t\treturn hdrlen;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n",
        "suffix": "\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"< \"));\n\n\t/*\n\t * Source address and PAN ID, if present.\n\t */\n\tswitch (FC_SRC_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved source addressing mode\"));\n\t\treturn 0;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\n\tif (!ndo->ndo_suppress_default_print)\n\t\tND_DEFAULTPRINT(p, caplen);\n\n\treturn hdrlen;\n}\n",
        "start": 64,
        "end": 223,
        "buggy": "u_int\nieee802_15_4_if_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int hdrlen;\n\tuint16_t fc;\n\tuint8_t seq;\n\tuint16_t panid = 0;\n\n\tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\treturn caplen;\n\t}\n\thdrlen = 3;\n\n\tfc = EXTRACT_LE_16BITS(p);\n\tseq = EXTRACT_LE_8BITS(p + 2);\n\n\tp += 3;\n\tcaplen -= 3;\n\n\tND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[FC_FRAME_TYPE(fc)]));\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"seq %02x \", seq));\n\n\t/*\n\t * Destination address and PAN ID, if present.\n\t */\n\tswitch (FC_DEST_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (fc & FC_PAN_ID_COMPRESSION) {\n\t\t\t/*\n\t\t\t * PAN ID compression; this requires that both\n\t\t\t * the source and destination addresses be present,\n\t\t\t * but the destination address is missing.\n\t\t\t */\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved destination addressing mode\"));\n\t\treturn hdrlen;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p + 2)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"< \"));\n\n\t/*\n\t * Source address and PAN ID, if present.\n\t */\n\tswitch (FC_SRC_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved source addressing mode\"));\n\t\treturn 0;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\n\tif (!ndo->ndo_suppress_default_print)\n\t\tND_DEFAULTPRINT(p, caplen);\n\n\treturn hdrlen;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p + 2)));\n",
        "src_path": "a7e5f58f402e6919ec444a57946bade7dfd6b184___print-802_15_4.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/a7e5f58f402e6919ec444a57946bade7dfd6b184",
        "commit_msg": "CVE-2017-13000/IEEE 802.15.4: Fix bug introduced by previous fix.\n\nWe've already advanced the pointer past the PAN ID, if present; it now\npoints to the address, so don't add 2 to it.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/802_15_4-data.out",
                "patch": "@@ -0,0 +1 @@\n+IEEE 802.15.4 Data packet seq 01 ab4d:10:05:00:81:00:01:00:01 < [|802.15.4]"
            },
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -488,6 +488,7 @@ pimv2-oobr-3\t\tpimv2-oobr-3.pcap\t\tpimv2-oobr-3.out\t\t-vvv -e\n pimv2-oobr-4\t\tpimv2-oobr-4.pcap\t\tpimv2-oobr-4.out\t\t-vvv -e\n 802_15_4-oobr-1\t\t802_15_4-oobr-1.pcap\t\t802_15_4-oobr-1.out\t-vvv -e\n 802_15_4-oobr-2\t\t802_15_4-oobr-2.pcap\t\t802_15_4-oobr-2.out\t-vvv -e\n+802_15_4-data\t\t802_15_4-data.pcap\t\t802_15_4-data.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap"
            }
        ],
        "error_msg": "    802_15_4-data                      : TEST FAILED(exit 256)\n"
    },
    "8512734883227c11568bb35da1d48b9f8466f43f___print-802_15_4.c": {
        "prefix": "u_int\nieee802_15_4_if_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int hdrlen;\n\tuint16_t fc;\n\tuint8_t seq;\n\tuint16_t panid = 0;\n\n\tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\treturn caplen;\n\t}\n\thdrlen = 3;\n\n\tfc = EXTRACT_LE_16BITS(p);\n\tseq = EXTRACT_LE_8BITS(p + 2);\n\n\tp += 3;\n\tcaplen -= 3;\n\n\tND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[FC_FRAME_TYPE(fc)]));\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"seq %02x \", seq));\n\n\t/*\n\t * Destination address and PAN ID, if present.\n\t */\n\tswitch (FC_DEST_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (fc & FC_PAN_ID_COMPRESSION) {\n\t\t\t/*\n\t\t\t * PAN ID compression; this requires that both\n\t\t\t * the source and destination addresses be present,\n\t\t\t * but the destination address is missing.\n\t\t\t */\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved destination addressing mode\"));\n\t\treturn hdrlen;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n",
        "suffix": "\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"< \"));\n\n\t/*\n\t * Source address and PAN ID, if present.\n\t */\n\tswitch (FC_SRC_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved source addressing mode\"));\n\t\treturn 0;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\n\tif (!ndo->ndo_suppress_default_print)\n\t\tND_DEFAULTPRINT(p, caplen);\n\n\treturn hdrlen;\n}\n",
        "start": 64,
        "end": 223,
        "buggy": "u_int\nieee802_15_4_if_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int hdrlen;\n\tuint16_t fc;\n\tuint8_t seq;\n\tuint16_t panid = 0;\n\n\tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\treturn caplen;\n\t}\n\thdrlen = 3;\n\n\tfc = EXTRACT_LE_16BITS(p);\n\tseq = EXTRACT_LE_8BITS(p + 2);\n\n\tp += 3;\n\tcaplen -= 3;\n\n\tND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[FC_FRAME_TYPE(fc)]));\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"seq %02x \", seq));\n\n\t/*\n\t * Destination address and PAN ID, if present.\n\t */\n\tswitch (FC_DEST_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (fc & FC_PAN_ID_COMPRESSION) {\n\t\t\t/*\n\t\t\t * PAN ID compression; this requires that both\n\t\t\t * the source and destination addresses be present,\n\t\t\t * but the destination address is missing.\n\t\t\t */\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved destination addressing mode\"));\n\t\treturn hdrlen;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"< \"));\n\n\t/*\n\t * Source address and PAN ID, if present.\n\t */\n\tswitch (FC_SRC_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved source addressing mode\"));\n\t\treturn 0;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\n\tif (!ndo->ndo_suppress_default_print)\n\t\tND_DEFAULTPRINT(p, caplen);\n\n\treturn hdrlen;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));\n",
        "src_path": "8512734883227c11568bb35da1d48b9f8466f43f___print-802_15_4.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/8512734883227c11568bb35da1d48b9f8466f43f",
        "commit_msg": "CVE-2017-13000/IEEE 802.15.4: Fix bug introduced two fixes prior.\n\nWe've already advanced the pointer past the PAN ID, if present; it now\npoints to the address, so don't add 2 to it.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/802_15_4_beacon.out",
                "patch": "@@ -0,0 +1 @@\n+IEEE 802.15.4 Beacon packet seq cd ffab:cdff < [|802.15.4]"
            },
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -489,6 +489,7 @@ pimv2-oobr-4\t\tpimv2-oobr-4.pcap\t\tpimv2-oobr-4.out\t\t-vvv -e\n 802_15_4-oobr-1\t\t802_15_4-oobr-1.pcap\t\t802_15_4-oobr-1.out\t-vvv -e\n 802_15_4-oobr-2\t\t802_15_4-oobr-2.pcap\t\t802_15_4-oobr-2.out\t-vvv -e\n 802_15_4-data\t\t802_15_4-data.pcap\t\t802_15_4-data.out\t-vvv -e\n+802_15_4_beacon\t\t802_15_4_beacon.pcap\t\t802_15_4_beacon.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap"
            }
        ],
        "error_msg": "    802_15_4_beacon                    : TEST FAILED(exit 256)\n"
    },
    "ca336198e8bebccc18502de27672fdbd6eb34856___print-pktap.c": {
        "prefix": "u_int\npktap_if_print(netdissect_options *ndo,\n               const struct pcap_pkthdr *h, const u_char *p)\n{\n\tuint32_t dlt, hdrlen, rectype;\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tif_printer printer;\n\tconst pktap_header_t *hdr;\n\n\tif (caplen < sizeof(pktap_header_t) || length < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\thdr = (const pktap_header_t *)p;\n\tdlt = EXTRACT_LE_32BITS(&hdr->pkt_dlt);\n",
        "suffix": "\tif (hdrlen < sizeof(pktap_header_t)) {\n\t\t/*\n\t\t * Claimed header length < structure length.\n\t\t * XXX - does this just mean some fields aren't\n\t\t * being supplied, or is it truly an error (i.e.,\n\t\t * is the length supplied so that the header can\n\t\t * be expanded in the future)?\n\t\t */\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\tif (caplen < hdrlen || length < hdrlen) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (hdrlen);\n\t}\n\n\tif (ndo->ndo_eflag)\n\t\tpktap_header_print(ndo, p, length);\n\n\tlength -= hdrlen;\n\tcaplen -= hdrlen;\n\tp += hdrlen;\n\n\trectype = EXTRACT_LE_32BITS(&hdr->pkt_rectype);\n\tswitch (rectype) {\n\n\tcase PKT_REC_NONE:\n\t\tND_PRINT((ndo, \"no data\"));\n\t\tbreak;\n\n\tcase PKT_REC_PACKET:\n\t\tif ((printer = lookup_printer(dlt)) != NULL) {\n\t\t\thdrlen += printer(ndo, h, p);\n\t\t} else {\n\t\t\tif (!ndo->ndo_eflag)\n\t\t\t\tpktap_header_print(ndo, (const u_char *)hdr,\n\t\t\t\t\t\tlength + hdrlen);\n\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p, caplen);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn (hdrlen);\n}\n",
        "start": 98,
        "end": 160,
        "buggy": "u_int\npktap_if_print(netdissect_options *ndo,\n               const struct pcap_pkthdr *h, const u_char *p)\n{\n\tuint32_t dlt, hdrlen, rectype;\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tif_printer printer;\n\tconst pktap_header_t *hdr;\n\n\tif (caplen < sizeof(pktap_header_t) || length < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\thdr = (const pktap_header_t *)p;\n\tdlt = EXTRACT_LE_32BITS(&hdr->pkt_dlt);\n\thdrlen = EXTRACT_LE_32BITS(&hdr->pkt_len);\n\tif (hdrlen < sizeof(pktap_header_t)) {\n\t\t/*\n\t\t * Claimed header length < structure length.\n\t\t * XXX - does this just mean some fields aren't\n\t\t * being supplied, or is it truly an error (i.e.,\n\t\t * is the length supplied so that the header can\n\t\t * be expanded in the future)?\n\t\t */\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\tif (caplen < hdrlen || length < hdrlen) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (hdrlen);\n\t}\n\n\tif (ndo->ndo_eflag)\n\t\tpktap_header_print(ndo, p, length);\n\n\tlength -= hdrlen;\n\tcaplen -= hdrlen;\n\tp += hdrlen;\n\n\trectype = EXTRACT_LE_32BITS(&hdr->pkt_rectype);\n\tswitch (rectype) {\n\n\tcase PKT_REC_NONE:\n\t\tND_PRINT((ndo, \"no data\"));\n\t\tbreak;\n\n\tcase PKT_REC_PACKET:\n\t\tif ((printer = lookup_printer(dlt)) != NULL) {\n\t\t\thdrlen += printer(ndo, h, p);\n\t\t} else {\n\t\t\tif (!ndo->ndo_eflag)\n\t\t\t\tpktap_header_print(ndo, (const u_char *)hdr,\n\t\t\t\t\t\tlength + hdrlen);\n\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p, caplen);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn (hdrlen);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\thdrlen = EXTRACT_LE_32BITS(&hdr->pkt_len);\n",
        "src_path": "ca336198e8bebccc18502de27672fdbd6eb34856___print-pktap.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/ca336198e8bebccc18502de27672fdbd6eb34856",
        "commit_msg": "CVE-2017-13007/PKTAP: Pass a properly updated struct pcap_pkthdr to the sub-dissector.\n\nThe sub-dissector expects that the length and captured length will\nreflect the actual remaining data in the packet, not the raw amount\nincluding the PKTAP header; pass an updated header, just as we do for\nPPI.\n\nThis fixes a buffer over-read discovered by Yannick Formaggio.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -502,6 +502,7 @@ juniper_es\t\tjuniper_es.pcap\t\t\tjuniper_es.out\t-vvv -e\n \n # bad packets from Yannick Formaggio\n l2tp-avp-overflow\tl2tp-avp-overflow.pcap\t\tl2tp-avp-overflow.out\t-v\n+pktap-heap-overflow\tpktap-heap-overflow.pcap\tpktap-heap-overflow.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/pktap-heap-overflow.out",
                "patch": "@@ -0,0 +1,3 @@\n+[|pktap]\n+[|ppp]\n+EXIT CODE 00000100"
            }
        ],
        "error_msg": "    pktap-heap-overflow                : TEST FAILED(exit 256)\n"
    },
    "a77ff09c46560bc895dea11dc9fe643486b056ac___print-lldp.c": {
        "prefix": "static int\nlldp_mgmt_addr_tlv_print(netdissect_options *ndo,\n                         const u_char *pptr, u_int len)\n{\n    uint8_t mgmt_addr_len, intf_num_subtype, oid_len;\n    const u_char *tptr;\n    u_int tlen;\n    char *mgmt_addr;\n\n    tlen = len;\n    tptr = pptr;\n\n    if (tlen < 1) {\n        return 0;\n    }\n    mgmt_addr_len = *tptr++;\n    tlen--;\n\n    if (tlen < mgmt_addr_len) {\n        return 0;\n    }\n\n    mgmt_addr = lldp_network_addr_print(ndo, tptr, mgmt_addr_len);\n    if (mgmt_addr == NULL) {\n        return 0;\n    }\n    ND_PRINT((ndo, \"\\n\\t  Management Address length %u, %s\",\n           mgmt_addr_len, mgmt_addr));\n    tptr += mgmt_addr_len;\n    tlen -= mgmt_addr_len;\n\n    if (tlen < LLDP_INTF_NUM_LEN) {\n        return 0;\n    }\n\n    intf_num_subtype = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  %s Interface Numbering (%u): %u\",\n           tok2str(lldp_intf_numb_subtype_values, \"Unknown\", intf_num_subtype),\n           intf_num_subtype,\n           EXTRACT_32BITS(tptr + 1)));\n\n    tptr += LLDP_INTF_NUM_LEN;\n    tlen -= LLDP_INTF_NUM_LEN;\n\n    /*\n     * The OID is optional.\n     */\n    if (tlen) {\n        oid_len = *tptr;\n\n",
        "suffix": "            return 0;\n        }\n        if (oid_len) {\n            ND_PRINT((ndo, \"\\n\\t  OID length %u\", oid_len));\n            safeputs(ndo, tptr + 1, oid_len);\n        }\n    }\n\n    return 1;\n}\n",
        "start": 1354,
        "end": 1414,
        "buggy": "static int\nlldp_mgmt_addr_tlv_print(netdissect_options *ndo,\n                         const u_char *pptr, u_int len)\n{\n    uint8_t mgmt_addr_len, intf_num_subtype, oid_len;\n    const u_char *tptr;\n    u_int tlen;\n    char *mgmt_addr;\n\n    tlen = len;\n    tptr = pptr;\n\n    if (tlen < 1) {\n        return 0;\n    }\n    mgmt_addr_len = *tptr++;\n    tlen--;\n\n    if (tlen < mgmt_addr_len) {\n        return 0;\n    }\n\n    mgmt_addr = lldp_network_addr_print(ndo, tptr, mgmt_addr_len);\n    if (mgmt_addr == NULL) {\n        return 0;\n    }\n    ND_PRINT((ndo, \"\\n\\t  Management Address length %u, %s\",\n           mgmt_addr_len, mgmt_addr));\n    tptr += mgmt_addr_len;\n    tlen -= mgmt_addr_len;\n\n    if (tlen < LLDP_INTF_NUM_LEN) {\n        return 0;\n    }\n\n    intf_num_subtype = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  %s Interface Numbering (%u): %u\",\n           tok2str(lldp_intf_numb_subtype_values, \"Unknown\", intf_num_subtype),\n           intf_num_subtype,\n           EXTRACT_32BITS(tptr + 1)));\n\n    tptr += LLDP_INTF_NUM_LEN;\n    tlen -= LLDP_INTF_NUM_LEN;\n\n    /*\n     * The OID is optional.\n     */\n    if (tlen) {\n        oid_len = *tptr;\n\n        if (tlen < oid_len) {\n            return 0;\n        }\n        if (oid_len) {\n            ND_PRINT((ndo, \"\\n\\t  OID length %u\", oid_len));\n            safeputs(ndo, tptr + 1, oid_len);\n        }\n    }\n\n    return 1;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        if (tlen < oid_len) {\n",
        "src_path": "a77ff09c46560bc895dea11dc9fe643486b056ac___print-lldp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/a77ff09c46560bc895dea11dc9fe643486b056ac",
        "commit_msg": "CVE-2017-13027/LLDP: Fix a bounds check.\n\nThe total length of the OID is the OID length plus the length of the OID\nlength itself.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -532,6 +532,7 @@ isis_stlv_asan\t\tisis_stlv_asan.pcap\t\tisis_stlv_asan.out\t-v\n isis_stlv_asan-2\tisis_stlv_asan-2.pcap\t\tisis_stlv_asan-2.out\t-v\n isis_stlv_asan-3\tisis_stlv_asan-3.pcap\t\tisis_stlv_asan-3.out\t-v\n isis_stlv_asan-4\tisis_stlv_asan-4.pcap\t\tisis_stlv_asan-4.out\t-v\n+lldp_mgmt_addr_tlv_asan\tlldp_mgmt_addr_tlv_asan.pcap\tlldp_mgmt_addr_tlv_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/lldp_mgmt_addr_tlv_asan.out",
                "patch": "@@ -0,0 +1,8 @@\n+LLDP, length 1048572\n+\tManagement Address TLV (8), length 15\n+\t  Management Address length 6, AFI Reserved (0), no AF printer !\n+\t  Unknown Interface Numbering (10): 666137427\n+\t[|LLDP]\n+00:00:00:a0:d4:c3 > 06:04:e8:03:00:02, ethertype Unknown (0xb2a1), length 58785857: \n+\t0x0000:  0200 efff e5ff 804f 006e 0026 0000 0000  .......O.n.&....\n+\t0x0010:  01                                       ."
            }
        ],
        "error_msg": "    lldp_mgmt_addr_tlv_asan            : TEST FAILED(exit 256)\n"
    },
    "2d669862df7cd17f539129049f6fb70d17174125___print-frag6.c": {
        "prefix": "int\nfrag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)\n{\n\tregister const struct ip6_frag *dp;\n\tregister const struct ip6_hdr *ip6;\n\n\tdp = (const struct ip6_frag *)bp;\n\tip6 = (const struct ip6_hdr *)bp2;\n\n",
        "suffix": "\n\tif (ndo->ndo_vflag) {\n\t\tND_PRINT((ndo, \"frag (0x%08x:%d|%ld)\",\n\t\t       EXTRACT_32BITS(&dp->ip6f_ident),\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t} else {\n\t\tND_PRINT((ndo, \"frag (%d|%ld)\",\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t}\n\n\t/* it is meaningless to decode non-first fragment */\n\tif ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)\n\t\treturn -1;\n\telse\n\t{\n\t\tND_PRINT((ndo, \" \"));\n\t\treturn sizeof(struct ip6_frag);\n\t}\ntrunc:\n\tND_PRINT((ndo, \"[|frag]\"));\n\treturn -1;\n}\n",
        "start": 35,
        "end": 70,
        "buggy": "int\nfrag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)\n{\n\tregister const struct ip6_frag *dp;\n\tregister const struct ip6_hdr *ip6;\n\n\tdp = (const struct ip6_frag *)bp;\n\tip6 = (const struct ip6_hdr *)bp2;\n\n\tND_TCHECK(dp->ip6f_offlg);\n\n\tif (ndo->ndo_vflag) {\n\t\tND_PRINT((ndo, \"frag (0x%08x:%d|%ld)\",\n\t\t       EXTRACT_32BITS(&dp->ip6f_ident),\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t} else {\n\t\tND_PRINT((ndo, \"frag (%d|%ld)\",\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t}\n\n\t/* it is meaningless to decode non-first fragment */\n\tif ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)\n\t\treturn -1;\n\telse\n\t{\n\t\tND_PRINT((ndo, \" \"));\n\t\treturn sizeof(struct ip6_frag);\n\t}\ntrunc:\n\tND_PRINT((ndo, \"[|frag]\"));\n\treturn -1;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\tND_TCHECK(dp->ip6f_offlg);\n",
        "src_path": "2d669862df7cd17f539129049f6fb70d17174125___print-frag6.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/2d669862df7cd17f539129049f6fb70d17174125",
        "commit_msg": "CVE-2017-13031/Check for the presence of the entire IPv6 fragment header.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.\n\nClean up some whitespace in tests/TESTLIST while we're at it.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -536,9 +536,10 @@ isis_stlv_asan-4\tisis_stlv_asan-4.pcap\t\tisis_stlv_asan-4.out\t-v\n lldp_mgmt_addr_tlv_asan\tlldp_mgmt_addr_tlv_asan.pcap\tlldp_mgmt_addr_tlv_asan.out\t-v\n bootp_asan\t\tbootp_asan.pcap\t\t\tbootp_asan.out\t\t-v\n ppp_ccp_config_deflate_option_asan\tppp_ccp_config_deflate_option_asan.pcap\tppp_ccp_config_deflate_option_asan.out\t-v\n-pim_header_asan\t\tpim_header_asan.pcap\t\tpim_header_asan.out\t\t-v\n-pim_header_asan-2\tpim_header_asan-2.pcap\t\tpim_header_asan-2.out\t\t-v\n-pim_header_asan-3\tpim_header_asan-3.pcap\t\tpim_header_asan-3.out\t\t-v\n+pim_header_asan\t\tpim_header_asan.pcap\t\tpim_header_asan.out\t-v\n+pim_header_asan-2\tpim_header_asan-2.pcap\t\tpim_header_asan-2.out\t-v\n+pim_header_asan-3\tpim_header_asan-3.pcap\t\tpim_header_asan-3.out\t-v\n+ip6_frag_asan\t\tip6_frag_asan.pcap\t\tip6_frag_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/ip6_frag_asan.out",
                "patch": "@@ -0,0 +1 @@\n+IP6 (class 0x51, flowlabel 0xb2100, hlim 16, next-header Fragment (44) payload length: 27136) 452:22:19:0:41a:e4ff:10ff:484d > 2243:80:1400:100:19:ffff:ffff:fffb: [|frag]"
            }
        ],
        "error_msg": "    ip6_frag_asan                      : TEST FAILED(exit 256)\n"
    },
    "571a6f33f47e7a2394fa08f925e534135c29cf1e___print-isoclns.c": {
        "prefix": "static char *\nisis_print_id(const uint8_t *cp, int id_len)\n{\n    int i;\n    static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n    char *pos = id;\n\n",
        "suffix": "        snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n\tpos += strlen(pos);\n\tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}\n",
        "start": 1643,
        "end": 1663,
        "buggy": "static char *\nisis_print_id(const uint8_t *cp, int id_len)\n{\n    int i;\n    static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n    char *pos = id;\n\n    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n        snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n\tpos += strlen(pos);\n\tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n",
        "src_path": "571a6f33f47e7a2394fa08f925e534135c29cf1e___print-isoclns.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/571a6f33f47e7a2394fa08f925e534135c29cf1e",
        "commit_msg": "CVE-2017-13035/Properly handle IS-IS IDs shorter than a system ID (MAC address).\n\nSome of them are variable-length, with a field giving the total length,\nand therefore they can be shorter than 6 octets.  If one is, don't run\npast the end.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -539,6 +539,7 @@ isis_stlv_asan\t\tisis_stlv_asan.pcap\t\tisis_stlv_asan.out\t-v\n isis_stlv_asan-2\tisis_stlv_asan-2.pcap\t\tisis_stlv_asan-2.out\t-v\n isis_stlv_asan-3\tisis_stlv_asan-3.pcap\t\tisis_stlv_asan-3.out\t-v\n isis_stlv_asan-4\tisis_stlv_asan-4.pcap\t\tisis_stlv_asan-4.out\t-v\n+isis_sysid_asan\t\tisis_sysid_asan.pcap\t\tisis_sysid_asan.out\t-v\n lldp_mgmt_addr_tlv_asan\tlldp_mgmt_addr_tlv_asan.pcap\tlldp_mgmt_addr_tlv_asan.out\t-v\n bootp_asan\t\tbootp_asan.pcap\t\t\tbootp_asan.out\t\t-v\n bootp_asan-2\t\tbootp_asan-2.pcap\t\tbootp_asan-2.out\t-v"
            },
            {
                "fn": "tests/isis_sysid_asan.out",
                "patch": "@@ -0,0 +1,71 @@\n+UI 22! IS-IS, length 469869187\n+\tL2 Lan IIH, hlen: 27, v: 1, pdu-v: 1, sys-id-len: 6 (0), max-area: 224 (224)\n+\t  source-id: fed0.f90f.58af,  holding time: 34047s, Flags: [unknown circuit type 0x00]\n+\t  lan-id:    0105.0088.a204.00, Priority: 65, PDU length: 4096\n+\t    unknown TLV #64, length: 128\n+\t\t0x0000:  ff10 8e12 0001 1b01 0000 6b00 fbcf f90f\n+\t\t0x0010:  58af 84ff 1000 4901 0000 88a2 011c 000c\n+\t\t0x0020:  0281 0083 1b01 0010 019d e000 fed0 f90f\n+\t\t0x0030:  58af 84ff 1000 4101 0500 88a2 011c 0272\n+\t\t0x0040:  0c2a 2205 831b 011c 0010 0000 0583 1b01\n+\t\t0x0050:  0010 01ab e000 fe08 0808 0808 08cb 0808\n+\t\t0x0060:  0808 0808 0808 0880 0008 7f08 0808 0808\n+\t\t0x0070:  08fd 0808 080c 0608 0807 0808 0808 0408\n+\t    Padding TLV #8, length: 8\n+\t    Padding TLV #8, length: 8\n+\t    Padding TLV #8, length: 7\n+\t    Padding TLV #8, length: 8\n+\t    Padding TLV #8, length: 0\n+\t    Padding TLV #8, length: 8\n+\t    unknown TLV #100, length: 0\n+\t    unknown TLV #32, length: 16\n+\t\t0x0000:  2020 2020 3c20 2020 2020 2020 205a 1a31\n+\t    IS Neighbor(s) (variable length) TLV #7, length: 238\n+\t      LAN address length 1 bytes \n+\t\tIS Neighbor: 5a\n+\t\tIS Neighbor: 45\n+\t\tIS Neighbor: 50\n+\t\tIS Neighbor: 48\n+\t\tIS Neighbor: 59\n+\t\tIS Neighbor: 52\n+\t\tIS Neighbor: 5f\n+\t\tIS Neighbor: 43\n+\t\tIS Neighbor: 54\n+\t\tIS Neighbor: 4c\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 64\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 10\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20 [|isis]"
            }
        ],
        "error_msg": "    isis_sysid_asan                    : TEST FAILED(exit 256)\n"
    },
    "d10a0f980fe8f9407ab1ffbd612641433ebe175e___print-bgp.c": {
        "prefix": "static int\nbgp_attr_print(netdissect_options *ndo,\n               u_int atype, const u_char *pptr, u_int len)\n{\n\tint i;\n\tuint16_t af;\n\tuint8_t safi, snpa, nhlen;\n        union { /* copy buffer for bandwidth values */\n            float f;\n            uint32_t i;\n        } bw;\n\tint advance;\n\tu_int tlen;\n\tconst u_char *tptr;\n\tchar buf[MAXHOSTNAMELEN + 100];\n        int  as_size;\n\n        tptr = pptr;\n        tlen=len;\n\n\tswitch (atype) {\n\tcase BGPTYPE_ORIGIN:\n\t\tif (len != 1)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK(*tptr);\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(bgp_origin_values,\n\t\t\t\t\t\t\"Unknown Origin Typecode\",\n\t\t\t\t\t\ttptr[0])));\n\t\t}\n\t\tbreak;\n\n        /*\n         * Process AS4 byte path and AS2 byte path attributes here.\n         */\n\tcase BGPTYPE_AS4_PATH:\n\tcase BGPTYPE_AS_PATH:\n\t\tif (len % 2) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                if (!len) {\n\t\t\tND_PRINT((ndo, \"empty\"));\n\t\t\tbreak;\n                }\n\n                /*\n                 * BGP updates exchanged between New speakers that support 4\n                 * byte AS, ASs are always encoded in 4 bytes. There is no\n                 * definitive way to find this, just by the packet's\n                 * contents. So, check for packet's TLV's sanity assuming\n                 * 2 bytes first, and it does not pass, assume that ASs are\n                 * encoded in 4 bytes format and move on.\n                 */\n                as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);\n\n\t\twhile (tptr < pptr + len) {\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_open_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n\t\t\tND_TCHECK(tptr[1]);\n                        for (i = 0; i < tptr[1] * as_size; i += as_size) {\n                            ND_TCHECK2(tptr[2 + i], as_size);\n\t\t\t    ND_PRINT((ndo, \"%s \",\n\t\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\t\tas_size == 2 ?\n\t\t\t\tEXTRACT_16BITS(&tptr[2 + i]) :\n\t\t\t\tEXTRACT_32BITS(&tptr[2 + i]))));\n                        }\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_close_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n                        ND_TCHECK(tptr[1]);\n                        tptr += 2 + tptr[1] * as_size;\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_NEXT_HOP:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_MULTI_EXIT_DISC:\n\tcase BGPTYPE_LOCAL_PREF:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_ATOMIC_AGGREGATE:\n\t\tif (len != 0)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\tbreak;\n        case BGPTYPE_AGGREGATOR:\n\n                /*\n                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,\n                 * the length of this PA can be either 6 bytes or 8 bytes.\n                 */\n                if (len != 6 && len != 8) {\n                    ND_PRINT((ndo, \"invalid len\"));\n                    break;\n                }\n                ND_TCHECK2(tptr[0], len);\n                if (len == 6) {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),\n\t\t\tipaddr_string(ndo, tptr + 2)));\n                } else {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\tEXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));\n                }\n                break;\n\tcase BGPTYPE_AGGREGATOR4:\n\t\tif (len != 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 8);\n\t\tND_PRINT((ndo, \" AS #%s, origin %s\",\n\t   \t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),\n\t\t    ipaddr_string(ndo, tptr + 4)));\n\t\tbreak;\n\tcase BGPTYPE_COMMUNITIES:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\twhile (tlen>0) {\n\t\t\tuint32_t comm;\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tcomm = EXTRACT_32BITS(tptr);\n\t\t\tswitch (comm) {\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_ADVERT:\n\t\t\t\tND_PRINT((ndo, \" NO_ADVERTISE\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT_SUBCONFED:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT_SUBCONFED\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"%u:%u%s\",\n                                       (comm >> 16) & 0xffff,\n                                       comm & 0xffff,\n                                       (tlen>4) ? \", \" : \"\"));\n\t\t\t\tbreak;\n\t\t\t}\n                        tlen -=4;\n                        tptr +=4;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_ORIGINATOR_ID:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 4);\n                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                break;\n        case BGPTYPE_CLUSTER_LIST:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n\t\t\tND_TCHECK2(tptr[0], 4);\n                        ND_PRINT((ndo, \"%s%s\",\n                               ipaddr_string(ndo, tptr),\n                                (tlen>4) ? \", \" : \"\"));\n                        tlen -=4;\n                        tptr +=4;\n                }\n                break;\n\tcase BGPTYPE_MP_REACH_NLRI:\n\t\tND_TCHECK2(tptr[0], 3);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                switch(af<<8 | safi) {\n                case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n\t\tcase (AFNUM_INET<<8 | SAFNUM_MDT):\n                case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    break;\n                default:\n                    ND_TCHECK2(tptr[0], tlen);\n                    ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                    goto done;\n                    break;\n                }\n\n                tptr +=3;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tnhlen = tptr[0];\n                tlen = nhlen;\n                tptr++;\n\n\t\tif (tlen) {\n                    int nnh = 0;\n                    ND_PRINT((ndo, \"\\n\\t    nexthop: \"));\n                    while (tlen > 0) {\n                        if ( nnh++ > 0 ) {\n                            ND_PRINT((ndo,  \", \" ));\n                        }\n                        switch(af<<8 | safi) {\n                        case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n                        case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t\t    if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in_addr);\n                                tptr += sizeof(struct in_addr);\n                            }\n                            break;\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                            if (tlen < (int)sizeof(struct in6_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr));\n                                ND_PRINT((ndo, \"%s\", ip6addr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in6_addr);\n                                tptr += sizeof(struct in6_addr);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n                                tlen -= (sizeof(struct in_addr));\n                                tptr += (sizeof(struct in_addr));\n                            }\n                            break;\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"%s\", isonsap_string(ndo, tptr, tlen)));\n                            tptr += tlen;\n                            tlen = 0;\n                            break;\n\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < BGP_VPN_RD_LEN+1) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], tlen);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));\n                                /* rfc986 mapped IPv4 address ? */\n                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)\n                                    ND_PRINT((ndo, \" = %s\", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));\n                                /* rfc1888 mapped IPv6 address ? */\n                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)\n                                    ND_PRINT((ndo, \" = %s\", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));\n                                tptr += tlen;\n                                tlen = 0;\n                            }\n                            break;\n                        default:\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"no AFI %u/SAFI %u decoder\", af, safi));\n                            if (ndo->ndo_vflag <= 1)\n                                print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                            tptr += tlen;\n                            tlen = 0;\n                            goto done;\n                            break;\n                        }\n                    }\n\t\t}\n\t\tND_PRINT((ndo, \", nh-length: %u\", nhlen));\n\t\ttptr += tlen;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tsnpa = tptr[0];\n\t\ttptr++;\n\n\t\tif (snpa) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    %u SNPA\", snpa));\n\t\t\tfor (/*nothing*/; snpa > 0; snpa--) {\n\t\t\t\tND_TCHECK(tptr[0]);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      %d bytes\", tptr[0]));\n\t\t\t\ttptr += tptr[0] + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \", no SNPA\"));\n                }\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,tlen);\n                        ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n        done:\n\t\tbreak;\n\n\tcase BGPTYPE_MP_UNREACH_NLRI:\n\t\tND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                if (len == BGP_MP_NLRI_MINSIZE)\n                    ND_PRINT((ndo, \"\\n\\t      End-of-Rib Marker (empty NLRI)\"));\n\n\t\ttptr += 3;\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*(tptr-3),tlen);\n                        ND_PRINT((ndo, \"no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr-3, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_EXTD_COMMUNITIES:\n\t\tif (len % 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n                    uint16_t extd_comm;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    extd_comm=EXTRACT_16BITS(tptr);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s (0x%04x), Flags [%s]\",\n\t\t\t   tok2str(bgp_extd_comm_subtype_values,\n\t\t\t\t      \"unknown extd community typecode\",\n\t\t\t\t      extd_comm),\n\t\t\t   extd_comm,\n\t\t\t   bittok2str(bgp_extd_comm_flag_values, \"none\", extd_comm)));\n\n                    ND_TCHECK2(*(tptr+2), 6);\n                    switch(extd_comm) {\n                    case BGP_EXT_COM_RT_0:\n                    case BGP_EXT_COM_RO_0:\n                    case BGP_EXT_COM_L2VPN_RT_0:\n                        ND_PRINT((ndo, \": %u:%u (= %s)\",\n                               EXTRACT_16BITS(tptr+2),\n                               EXTRACT_32BITS(tptr+4),\n                               ipaddr_string(ndo, tptr+4)));\n                        break;\n                    case BGP_EXT_COM_RT_1:\n                    case BGP_EXT_COM_RO_1:\n                    case BGP_EXT_COM_L2VPN_RT_1:\n                    case BGP_EXT_COM_VRF_RT_IMP:\n                        ND_PRINT((ndo, \": %s:%u\",\n                               ipaddr_string(ndo, tptr+2),\n                               EXTRACT_16BITS(tptr+6)));\n                        break;\n                    case BGP_EXT_COM_RT_2:\n                    case BGP_EXT_COM_RO_2:\n\t\t\tND_PRINT((ndo, \": %s:%u\",\n\t\t\t    as_printf(ndo, astostr, sizeof(astostr),\n\t\t\t    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));\n\t\t\tbreak;\n                    case BGP_EXT_COM_LINKBAND:\n\t\t        bw.i = EXTRACT_32BITS(tptr+2);\n                        ND_PRINT((ndo, \": bandwidth: %.3f Mbps\",\n                               bw.f*8/1000000));\n                        break;\n                    case BGP_EXT_COM_VPN_ORIGIN:\n                    case BGP_EXT_COM_VPN_ORIGIN2:\n                    case BGP_EXT_COM_VPN_ORIGIN3:\n                    case BGP_EXT_COM_VPN_ORIGIN4:\n                    case BGP_EXT_COM_OSPF_RID:\n                    case BGP_EXT_COM_OSPF_RID2:\n                        ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr+2)));\n                        break;\n                    case BGP_EXT_COM_OSPF_RTYPE:\n                    case BGP_EXT_COM_OSPF_RTYPE2:\n                        ND_PRINT((ndo, \": area:%s, router-type:%s, metric-type:%s%s\",\n                               ipaddr_string(ndo, tptr+2),\n                               tok2str(bgp_extd_comm_ospf_rtype_values,\n\t\t\t\t\t  \"unknown (0x%02x)\",\n\t\t\t\t\t  *(tptr+6)),\n                               (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? \"E2\" : \"\",\n                               ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? \"E1\" : \"\"));\n                        break;\n                    case BGP_EXT_COM_L2INFO:\n                        ND_PRINT((ndo, \": %s Control Flags [0x%02x]:MTU %u\",\n                               tok2str(l2vpn_encaps_values,\n\t\t\t\t\t  \"unknown encaps\",\n\t\t\t\t\t  *(tptr+2)),\n                                       *(tptr+3),\n                               EXTRACT_16BITS(tptr+4)));\n                        break;\n                    case BGP_EXT_COM_SOURCE_AS:\n                        ND_PRINT((ndo, \": AS %u\", EXTRACT_16BITS(tptr+2)));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,8);\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", 8);\n                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n",
        "suffix": "                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {\n                case BGP_PMSI_TUNNEL_PIM_SM: /* fall through */\n                case BGP_PMSI_TUNNEL_PIM_BIDIR:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Sender %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n\n                case BGP_PMSI_TUNNEL_PIM_SSM:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_INGRESS:\n                    ND_TCHECK2(tptr[0], 4);\n                    ND_PRINT((ndo, \"\\n\\t      Tunnel-Endpoint %s\",\n                           ipaddr_string(ndo, tptr)));\n                    break;\n                case BGP_PMSI_TUNNEL_LDP_P2MP: /* fall through */\n                case BGP_PMSI_TUNNEL_LDP_MP2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, LSP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_RSVP_P2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                default:\n                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    ND_TCHECK2(tptr[0], 3);\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\t\t    tptr += 3;\n\t\t    tlen -= 3;\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    if (length < 3)\n\t\t\tgoto trunc;\n\t\t    length -= 3;\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        if (length < 8)\n\t\t            goto trunc;\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr,\"\\n\\t      \", length);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);\n                if (len < 4)\n                \tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t    Origin AS: %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));\n\t\ttptr+=4;\n                len -=4;\n\n                while (len) {\n                    u_int aflags, alenlen, alen;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    if (len < 2)\n                        goto trunc;\n                    aflags = *tptr;\n                    atype = *(tptr + 1);\n                    tptr += 2;\n                    len -= 2;\n                    alenlen = bgp_attr_lenlen(aflags, tptr);\n                    ND_TCHECK2(tptr[0], alenlen);\n                    if (len < alenlen)\n                        goto trunc;\n                    alen = bgp_attr_len(aflags, tptr);\n                    tptr += alenlen;\n                    len -= alenlen;\n\n                    ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                           tok2str(bgp_attr_values,\n                                      \"Unknown Attribute\", atype),\n                           atype,\n                           alen));\n\n                    if (aflags) {\n                        ND_PRINT((ndo, \", Flags [%s%s%s%s\",\n                               aflags & 0x80 ? \"O\" : \"\",\n                               aflags & 0x40 ? \"T\" : \"\",\n                               aflags & 0x20 ? \"P\" : \"\",\n                               aflags & 0x10 ? \"E\" : \"\"));\n                        if (aflags & 0xf)\n                            ND_PRINT((ndo, \"+%x\", aflags & 0xf));\n                        ND_PRINT((ndo, \"]: \"));\n                    }\n                    /* FIXME check for recursion */\n                    if (!bgp_attr_print(ndo, atype, tptr, alen))\n                        return 0;\n                    tptr += alen;\n                    len -= alen;\n\t\t}\n                break;\n\n\tcase BGPTYPE_LARGE_COMMUNITY:\n\t\tif (len == 0 || len % 12) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\twhile (len > 0) {\n\t\t\tND_TCHECK2(*tptr, 12);\n\t\t\tND_PRINT((ndo, \"%u:%u:%u%s\",\n\t\t\t\t EXTRACT_32BITS(tptr),\n\t\t\t\t EXTRACT_32BITS(tptr + 4),\n\t\t\t\t EXTRACT_32BITS(tptr + 8),\n\t\t\t\t (len > 12) ? \", \" : \"\"));\n                        tptr += 12;\n                        len -= 12;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t    ND_TCHECK2(*pptr,len);\n            ND_PRINT((ndo, \"\\n\\t    no Attribute %u decoder\", atype)); /* we have no decoder for the attribute */\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n            break;\n\t}\n        if (ndo->ndo_vflag > 1 && len) { /* omit zero length attributes*/\n            ND_TCHECK2(*pptr,len);\n            print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n        }\n        return 1;\n\ntrunc:\n        return 0;\n}\n",
        "start": 1349,
        "end": 2312,
        "buggy": "static int\nbgp_attr_print(netdissect_options *ndo,\n               u_int atype, const u_char *pptr, u_int len)\n{\n\tint i;\n\tuint16_t af;\n\tuint8_t safi, snpa, nhlen;\n        union { /* copy buffer for bandwidth values */\n            float f;\n            uint32_t i;\n        } bw;\n\tint advance;\n\tu_int tlen;\n\tconst u_char *tptr;\n\tchar buf[MAXHOSTNAMELEN + 100];\n        int  as_size;\n\n        tptr = pptr;\n        tlen=len;\n\n\tswitch (atype) {\n\tcase BGPTYPE_ORIGIN:\n\t\tif (len != 1)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK(*tptr);\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(bgp_origin_values,\n\t\t\t\t\t\t\"Unknown Origin Typecode\",\n\t\t\t\t\t\ttptr[0])));\n\t\t}\n\t\tbreak;\n\n        /*\n         * Process AS4 byte path and AS2 byte path attributes here.\n         */\n\tcase BGPTYPE_AS4_PATH:\n\tcase BGPTYPE_AS_PATH:\n\t\tif (len % 2) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                if (!len) {\n\t\t\tND_PRINT((ndo, \"empty\"));\n\t\t\tbreak;\n                }\n\n                /*\n                 * BGP updates exchanged between New speakers that support 4\n                 * byte AS, ASs are always encoded in 4 bytes. There is no\n                 * definitive way to find this, just by the packet's\n                 * contents. So, check for packet's TLV's sanity assuming\n                 * 2 bytes first, and it does not pass, assume that ASs are\n                 * encoded in 4 bytes format and move on.\n                 */\n                as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);\n\n\t\twhile (tptr < pptr + len) {\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_open_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n\t\t\tND_TCHECK(tptr[1]);\n                        for (i = 0; i < tptr[1] * as_size; i += as_size) {\n                            ND_TCHECK2(tptr[2 + i], as_size);\n\t\t\t    ND_PRINT((ndo, \"%s \",\n\t\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\t\tas_size == 2 ?\n\t\t\t\tEXTRACT_16BITS(&tptr[2 + i]) :\n\t\t\t\tEXTRACT_32BITS(&tptr[2 + i]))));\n                        }\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_close_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n                        ND_TCHECK(tptr[1]);\n                        tptr += 2 + tptr[1] * as_size;\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_NEXT_HOP:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_MULTI_EXIT_DISC:\n\tcase BGPTYPE_LOCAL_PREF:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_ATOMIC_AGGREGATE:\n\t\tif (len != 0)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\tbreak;\n        case BGPTYPE_AGGREGATOR:\n\n                /*\n                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,\n                 * the length of this PA can be either 6 bytes or 8 bytes.\n                 */\n                if (len != 6 && len != 8) {\n                    ND_PRINT((ndo, \"invalid len\"));\n                    break;\n                }\n                ND_TCHECK2(tptr[0], len);\n                if (len == 6) {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),\n\t\t\tipaddr_string(ndo, tptr + 2)));\n                } else {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\tEXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));\n                }\n                break;\n\tcase BGPTYPE_AGGREGATOR4:\n\t\tif (len != 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 8);\n\t\tND_PRINT((ndo, \" AS #%s, origin %s\",\n\t   \t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),\n\t\t    ipaddr_string(ndo, tptr + 4)));\n\t\tbreak;\n\tcase BGPTYPE_COMMUNITIES:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\twhile (tlen>0) {\n\t\t\tuint32_t comm;\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tcomm = EXTRACT_32BITS(tptr);\n\t\t\tswitch (comm) {\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_ADVERT:\n\t\t\t\tND_PRINT((ndo, \" NO_ADVERTISE\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT_SUBCONFED:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT_SUBCONFED\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"%u:%u%s\",\n                                       (comm >> 16) & 0xffff,\n                                       comm & 0xffff,\n                                       (tlen>4) ? \", \" : \"\"));\n\t\t\t\tbreak;\n\t\t\t}\n                        tlen -=4;\n                        tptr +=4;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_ORIGINATOR_ID:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 4);\n                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                break;\n        case BGPTYPE_CLUSTER_LIST:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n\t\t\tND_TCHECK2(tptr[0], 4);\n                        ND_PRINT((ndo, \"%s%s\",\n                               ipaddr_string(ndo, tptr),\n                                (tlen>4) ? \", \" : \"\"));\n                        tlen -=4;\n                        tptr +=4;\n                }\n                break;\n\tcase BGPTYPE_MP_REACH_NLRI:\n\t\tND_TCHECK2(tptr[0], 3);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                switch(af<<8 | safi) {\n                case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n\t\tcase (AFNUM_INET<<8 | SAFNUM_MDT):\n                case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    break;\n                default:\n                    ND_TCHECK2(tptr[0], tlen);\n                    ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                    goto done;\n                    break;\n                }\n\n                tptr +=3;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tnhlen = tptr[0];\n                tlen = nhlen;\n                tptr++;\n\n\t\tif (tlen) {\n                    int nnh = 0;\n                    ND_PRINT((ndo, \"\\n\\t    nexthop: \"));\n                    while (tlen > 0) {\n                        if ( nnh++ > 0 ) {\n                            ND_PRINT((ndo,  \", \" ));\n                        }\n                        switch(af<<8 | safi) {\n                        case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n                        case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t\t    if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in_addr);\n                                tptr += sizeof(struct in_addr);\n                            }\n                            break;\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                            if (tlen < (int)sizeof(struct in6_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr));\n                                ND_PRINT((ndo, \"%s\", ip6addr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in6_addr);\n                                tptr += sizeof(struct in6_addr);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n                                tlen -= (sizeof(struct in_addr));\n                                tptr += (sizeof(struct in_addr));\n                            }\n                            break;\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"%s\", isonsap_string(ndo, tptr, tlen)));\n                            tptr += tlen;\n                            tlen = 0;\n                            break;\n\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < BGP_VPN_RD_LEN+1) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], tlen);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));\n                                /* rfc986 mapped IPv4 address ? */\n                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)\n                                    ND_PRINT((ndo, \" = %s\", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));\n                                /* rfc1888 mapped IPv6 address ? */\n                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)\n                                    ND_PRINT((ndo, \" = %s\", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));\n                                tptr += tlen;\n                                tlen = 0;\n                            }\n                            break;\n                        default:\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"no AFI %u/SAFI %u decoder\", af, safi));\n                            if (ndo->ndo_vflag <= 1)\n                                print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                            tptr += tlen;\n                            tlen = 0;\n                            goto done;\n                            break;\n                        }\n                    }\n\t\t}\n\t\tND_PRINT((ndo, \", nh-length: %u\", nhlen));\n\t\ttptr += tlen;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tsnpa = tptr[0];\n\t\ttptr++;\n\n\t\tif (snpa) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    %u SNPA\", snpa));\n\t\t\tfor (/*nothing*/; snpa > 0; snpa--) {\n\t\t\t\tND_TCHECK(tptr[0]);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      %d bytes\", tptr[0]));\n\t\t\t\ttptr += tptr[0] + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \", no SNPA\"));\n                }\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,tlen);\n                        ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n        done:\n\t\tbreak;\n\n\tcase BGPTYPE_MP_UNREACH_NLRI:\n\t\tND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                if (len == BGP_MP_NLRI_MINSIZE)\n                    ND_PRINT((ndo, \"\\n\\t      End-of-Rib Marker (empty NLRI)\"));\n\n\t\ttptr += 3;\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*(tptr-3),tlen);\n                        ND_PRINT((ndo, \"no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr-3, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_EXTD_COMMUNITIES:\n\t\tif (len % 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n                    uint16_t extd_comm;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    extd_comm=EXTRACT_16BITS(tptr);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s (0x%04x), Flags [%s]\",\n\t\t\t   tok2str(bgp_extd_comm_subtype_values,\n\t\t\t\t      \"unknown extd community typecode\",\n\t\t\t\t      extd_comm),\n\t\t\t   extd_comm,\n\t\t\t   bittok2str(bgp_extd_comm_flag_values, \"none\", extd_comm)));\n\n                    ND_TCHECK2(*(tptr+2), 6);\n                    switch(extd_comm) {\n                    case BGP_EXT_COM_RT_0:\n                    case BGP_EXT_COM_RO_0:\n                    case BGP_EXT_COM_L2VPN_RT_0:\n                        ND_PRINT((ndo, \": %u:%u (= %s)\",\n                               EXTRACT_16BITS(tptr+2),\n                               EXTRACT_32BITS(tptr+4),\n                               ipaddr_string(ndo, tptr+4)));\n                        break;\n                    case BGP_EXT_COM_RT_1:\n                    case BGP_EXT_COM_RO_1:\n                    case BGP_EXT_COM_L2VPN_RT_1:\n                    case BGP_EXT_COM_VRF_RT_IMP:\n                        ND_PRINT((ndo, \": %s:%u\",\n                               ipaddr_string(ndo, tptr+2),\n                               EXTRACT_16BITS(tptr+6)));\n                        break;\n                    case BGP_EXT_COM_RT_2:\n                    case BGP_EXT_COM_RO_2:\n\t\t\tND_PRINT((ndo, \": %s:%u\",\n\t\t\t    as_printf(ndo, astostr, sizeof(astostr),\n\t\t\t    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));\n\t\t\tbreak;\n                    case BGP_EXT_COM_LINKBAND:\n\t\t        bw.i = EXTRACT_32BITS(tptr+2);\n                        ND_PRINT((ndo, \": bandwidth: %.3f Mbps\",\n                               bw.f*8/1000000));\n                        break;\n                    case BGP_EXT_COM_VPN_ORIGIN:\n                    case BGP_EXT_COM_VPN_ORIGIN2:\n                    case BGP_EXT_COM_VPN_ORIGIN3:\n                    case BGP_EXT_COM_VPN_ORIGIN4:\n                    case BGP_EXT_COM_OSPF_RID:\n                    case BGP_EXT_COM_OSPF_RID2:\n                        ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr+2)));\n                        break;\n                    case BGP_EXT_COM_OSPF_RTYPE:\n                    case BGP_EXT_COM_OSPF_RTYPE2:\n                        ND_PRINT((ndo, \": area:%s, router-type:%s, metric-type:%s%s\",\n                               ipaddr_string(ndo, tptr+2),\n                               tok2str(bgp_extd_comm_ospf_rtype_values,\n\t\t\t\t\t  \"unknown (0x%02x)\",\n\t\t\t\t\t  *(tptr+6)),\n                               (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? \"E2\" : \"\",\n                               ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? \"E1\" : \"\"));\n                        break;\n                    case BGP_EXT_COM_L2INFO:\n                        ND_PRINT((ndo, \": %s Control Flags [0x%02x]:MTU %u\",\n                               tok2str(l2vpn_encaps_values,\n\t\t\t\t\t  \"unknown encaps\",\n\t\t\t\t\t  *(tptr+2)),\n                                       *(tptr+3),\n                               EXTRACT_16BITS(tptr+4)));\n                        break;\n                    case BGP_EXT_COM_SOURCE_AS:\n                        ND_PRINT((ndo, \": AS %u\", EXTRACT_16BITS(tptr+2)));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,8);\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", 8);\n                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n                ND_TCHECK2(tptr[0], 5);\n                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {\n                case BGP_PMSI_TUNNEL_PIM_SM: /* fall through */\n                case BGP_PMSI_TUNNEL_PIM_BIDIR:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Sender %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n\n                case BGP_PMSI_TUNNEL_PIM_SSM:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_INGRESS:\n                    ND_TCHECK2(tptr[0], 4);\n                    ND_PRINT((ndo, \"\\n\\t      Tunnel-Endpoint %s\",\n                           ipaddr_string(ndo, tptr)));\n                    break;\n                case BGP_PMSI_TUNNEL_LDP_P2MP: /* fall through */\n                case BGP_PMSI_TUNNEL_LDP_MP2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, LSP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_RSVP_P2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                default:\n                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    ND_TCHECK2(tptr[0], 3);\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\t\t    tptr += 3;\n\t\t    tlen -= 3;\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    if (length < 3)\n\t\t\tgoto trunc;\n\t\t    length -= 3;\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        if (length < 8)\n\t\t            goto trunc;\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr,\"\\n\\t      \", length);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);\n                if (len < 4)\n                \tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t    Origin AS: %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));\n\t\ttptr+=4;\n                len -=4;\n\n                while (len) {\n                    u_int aflags, alenlen, alen;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    if (len < 2)\n                        goto trunc;\n                    aflags = *tptr;\n                    atype = *(tptr + 1);\n                    tptr += 2;\n                    len -= 2;\n                    alenlen = bgp_attr_lenlen(aflags, tptr);\n                    ND_TCHECK2(tptr[0], alenlen);\n                    if (len < alenlen)\n                        goto trunc;\n                    alen = bgp_attr_len(aflags, tptr);\n                    tptr += alenlen;\n                    len -= alenlen;\n\n                    ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                           tok2str(bgp_attr_values,\n                                      \"Unknown Attribute\", atype),\n                           atype,\n                           alen));\n\n                    if (aflags) {\n                        ND_PRINT((ndo, \", Flags [%s%s%s%s\",\n                               aflags & 0x80 ? \"O\" : \"\",\n                               aflags & 0x40 ? \"T\" : \"\",\n                               aflags & 0x20 ? \"P\" : \"\",\n                               aflags & 0x10 ? \"E\" : \"\"));\n                        if (aflags & 0xf)\n                            ND_PRINT((ndo, \"+%x\", aflags & 0xf));\n                        ND_PRINT((ndo, \"]: \"));\n                    }\n                    /* FIXME check for recursion */\n                    if (!bgp_attr_print(ndo, atype, tptr, alen))\n                        return 0;\n                    tptr += alen;\n                    len -= alen;\n\t\t}\n                break;\n\n\tcase BGPTYPE_LARGE_COMMUNITY:\n\t\tif (len == 0 || len % 12) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\twhile (len > 0) {\n\t\t\tND_TCHECK2(*tptr, 12);\n\t\t\tND_PRINT((ndo, \"%u:%u:%u%s\",\n\t\t\t\t EXTRACT_32BITS(tptr),\n\t\t\t\t EXTRACT_32BITS(tptr + 4),\n\t\t\t\t EXTRACT_32BITS(tptr + 8),\n\t\t\t\t (len > 12) ? \", \" : \"\"));\n                        tptr += 12;\n                        len -= 12;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t    ND_TCHECK2(*pptr,len);\n            ND_PRINT((ndo, \"\\n\\t    no Attribute %u decoder\", atype)); /* we have no decoder for the attribute */\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n            break;\n\t}\n        if (ndo->ndo_vflag > 1 && len) { /* omit zero length attributes*/\n            ND_TCHECK2(*pptr,len);\n            print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n        }\n        return 1;\n\ntrunc:\n        return 0;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                ND_TCHECK2(tptr[0], 5);\n",
        "src_path": "d10a0f980fe8f9407ab1ffbd612641433ebe175e___print-bgp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/d10a0f980fe8f9407ab1ffbd612641433ebe175e",
        "commit_msg": "CVE-2017-13046/BGP: fix an existing bounds check for PMSI Tunnel\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -563,6 +563,7 @@ hncp_dhcpv6data-oobr\thncp_dhcpv6data-oobr.pcap\thncp_dhcpv6data-oobr.out -v -c1\n # Same comments apply to the case below.\n hncp_dhcpv4data-oobr\thncp_dhcpv4data-oobr.pcap\thncp_dhcpv4data-oobr.out -v -c1\n vqp-oobr\t\tvqp-oobr.pcap\t\t\tvqp-oobr.out\t\t-v -c1\n+bgp_pmsi_tunnel-oobr\tbgp_pmsi_tunnel-oobr.pcap\tbgp_pmsi_tunnel-oobr.out -v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/bgp_pmsi_tunnel-oobr.out",
                "patch": "@@ -0,0 +1,11 @@\n+IP (tos 0x0, ttl 254, id 40207, offset 0, flags [+, DF, rsvd], proto TCP (6), length 296, bad cksum 8e15 (->3eaa)!)\n+    241.0.32.19.179 > 239.0.0.1.0: Flags [none], seq 2146695561:2146695813, win 56026, options [unknown-161,eol], length 252: BGP\n+\tUpdate Message (2), length: 45\n+\t  Withdrawn routes: 3 bytes\n+\t  Attribute Set (128), length: 7, Flags [OTPE+f]: \n+\t    Origin AS: 4067\n+\t      Origin (1), length: 1EGP\n+\t      Unknown Attribute (19), length: 1, Flags [+1]: \n+\t    no Attribute 19 decoder\n+\t    0x0000:  01\n+\t      PMSI Tunnel (22), length: 1, Flags [+1]: [|BGP]"
            }
        ],
        "error_msg": "    bgp_pmsi_tunnel-oobr               : passed\n"
    },
    "3c8a2b0e91d8d8947e89384dacf6b54673083e71___print-rsvp.c": {
        "prefix": "static int\nrsvp_obj_print(netdissect_options *ndo,\n               const u_char *pptr, u_int plen, const u_char *tptr,\n               const char *ident, u_int tlen,\n               const struct rsvp_common_header *rsvp_com_header)\n{\n    const struct rsvp_object_header *rsvp_obj_header;\n    const u_char *obj_tptr;\n    union {\n        const struct rsvp_obj_integrity_t *rsvp_obj_integrity;\n        const struct rsvp_obj_frr_t *rsvp_obj_frr;\n    } obj_ptr;\n\n    u_short rsvp_obj_len,rsvp_obj_ctype,obj_tlen,intserv_serv_tlen;\n    int hexdump,processed,padbytes,error_code,error_value,i,sigcheck;\n    union {\n\tfloat f;\n\tuint32_t i;\n    } bw;\n    uint8_t namelen;\n\n    u_int action, subchannel;\n\n    while(tlen>=sizeof(struct rsvp_object_header)) {\n        /* did we capture enough for fully decoding the object header ? */\n        ND_TCHECK2(*tptr, sizeof(struct rsvp_object_header));\n\n        rsvp_obj_header = (const struct rsvp_object_header *)tptr;\n        rsvp_obj_len=EXTRACT_16BITS(rsvp_obj_header->length);\n        rsvp_obj_ctype=rsvp_obj_header->ctype;\n\n        if(rsvp_obj_len % 4) {\n            ND_PRINT((ndo, \"%sERROR: object header size %u not a multiple of 4\", ident, rsvp_obj_len));\n            return -1;\n        }\n        if(rsvp_obj_len < sizeof(struct rsvp_object_header)) {\n            ND_PRINT((ndo, \"%sERROR: object header too short %u < %lu\", ident, rsvp_obj_len,\n                   (unsigned long)sizeof(const struct rsvp_object_header)));\n            return -1;\n        }\n\n        ND_PRINT((ndo, \"%s%s Object (%u) Flags: [%s\",\n               ident,\n               tok2str(rsvp_obj_values,\n                       \"Unknown\",\n                       rsvp_obj_header->class_num),\n               rsvp_obj_header->class_num,\n               ((rsvp_obj_header->class_num) & 0x80) ? \"ignore\" : \"reject\"));\n\n        if (rsvp_obj_header->class_num > 128)\n            ND_PRINT((ndo, \" %s\",\n                   ((rsvp_obj_header->class_num) & 0x40) ? \"and forward\" : \"silently\"));\n\n        ND_PRINT((ndo, \" if unknown], Class-Type: %s (%u), length: %u\",\n               tok2str(rsvp_ctype_values,\n                       \"Unknown\",\n                       ((rsvp_obj_header->class_num)<<8)+rsvp_obj_ctype),\n               rsvp_obj_ctype,\n               rsvp_obj_len));\n\n        if(tlen < rsvp_obj_len) {\n            ND_PRINT((ndo, \"%sERROR: object goes past end of objects TLV\", ident));\n            return -1;\n        }\n\n        obj_tptr=tptr+sizeof(struct rsvp_object_header);\n        obj_tlen=rsvp_obj_len-sizeof(struct rsvp_object_header);\n\n        /* did we capture enough for fully decoding the object ? */\n        if (!ND_TTEST2(*tptr, rsvp_obj_len))\n            return -1;\n        hexdump=FALSE;\n\n        switch(rsvp_obj_header->class_num) {\n        case RSVP_OBJ_SESSION:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 DestAddress: %s, Protocol ID: 0x%02x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       *(obj_tptr + sizeof(struct in_addr))));\n                ND_PRINT((ndo, \"%s  Flags: [0x%02x], DestPort %u\",\n                       ident,\n                       *(obj_tptr+5),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 DestAddress: %s, Protocol ID: 0x%02x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       *(obj_tptr + sizeof(struct in6_addr))));\n                ND_PRINT((ndo, \"%s  Flags: [0x%02x], DestPort %u\",\n                       ident,\n                       *(obj_tptr+sizeof(struct in6_addr)+1),\n                       EXTRACT_16BITS(obj_tptr + sizeof(struct in6_addr) + 2)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n\n            case RSVP_CTYPE_TUNNEL_IPV6:\n                if (obj_tlen < 36)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ip6addr_string(ndo, obj_tptr + 20)));\n                obj_tlen-=36;\n                obj_tptr+=36;\n                break;\n\n            case RSVP_CTYPE_14: /* IPv6 p2mp LSP Tunnel */\n                if (obj_tlen < 26)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 P2MP LSP ID: 0x%08x, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ip6addr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=26;\n                obj_tptr+=26;\n                break;\n            case RSVP_CTYPE_13: /* IPv4 p2mp LSP Tunnel */\n                if (obj_tlen < 12)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 P2MP LSP ID: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ipaddr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n            case RSVP_CTYPE_UNI_IPV4:\n                if (obj_tlen < 12)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ipaddr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_CONFIRM:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < sizeof(struct in_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Receiver Address: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in_addr);\n                obj_tptr+=sizeof(struct in_addr);\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < sizeof(struct in6_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 Receiver Address: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in6_addr);\n                obj_tptr+=sizeof(struct in6_addr);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_NOTIFY_REQ:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < sizeof(struct in_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Notify Node Address: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in_addr);\n                obj_tptr+=sizeof(struct in_addr);\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < sizeof(struct in6_addr))\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Notify Node Address: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in6_addr);\n                obj_tptr+=sizeof(struct in6_addr);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SUGGESTED_LABEL: /* fall through */\n        case RSVP_OBJ_UPSTREAM_LABEL:  /* fall through */\n        case RSVP_OBJ_RECOVERY_LABEL:  /* fall through */\n        case RSVP_OBJ_LABEL:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                while(obj_tlen >= 4 ) {\n                    ND_PRINT((ndo, \"%s  Label: %u\", ident, EXTRACT_32BITS(obj_tptr)));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Generalized Label: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Waveband ID: %u%s  Start Label: %u, Stop Label: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       ident,\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_STYLE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Reservation Style: %s, Flags: [0x%02x]\",\n                       ident,\n                       tok2str(rsvp_resstyle_values,\n                               \"Unknown\",\n                               EXTRACT_24BITS(obj_tptr+1)),\n                       *(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SENDER_TEMPLATE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_13: /* IPv6 p2mp LSP tunnel */\n                if (obj_tlen < 40)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ident,\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_16BITS(obj_tptr + 38)));\n                obj_tlen-=40;\n                obj_tptr+=40;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_12: /* IPv4 p2mp LSP tunnel */\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ident,\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_16BITS(obj_tptr + 12)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_LABEL_REQ:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                while(obj_tlen >= 4 ) {\n                    ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                           ident,\n                           tok2str(ethertype_values,\n                                   \"Unknown Protocol (0x%04x)\",\n                                   EXTRACT_16BITS(obj_tptr + 2))));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                       ident,\n                       tok2str(ethertype_values,\n                               \"Unknown Protocol (0x%04x)\",\n                               EXTRACT_16BITS(obj_tptr + 2))));\n                ND_PRINT((ndo, \",%s merge capability\",((*(obj_tptr + 4)) & 0x80) ? \"no\" : \"\" ));\n                ND_PRINT((ndo, \"%s  Minimum VPI/VCI: %u/%u\",\n                       ident,\n                       (EXTRACT_16BITS(obj_tptr+4))&0xfff,\n                       (EXTRACT_16BITS(obj_tptr + 6)) & 0xfff));\n                ND_PRINT((ndo, \"%s  Maximum VPI/VCI: %u/%u\",\n                       ident,\n                       (EXTRACT_16BITS(obj_tptr+8))&0xfff,\n                       (EXTRACT_16BITS(obj_tptr + 10)) & 0xfff));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                       ident,\n                       tok2str(ethertype_values,\n                               \"Unknown Protocol (0x%04x)\",\n                               EXTRACT_16BITS(obj_tptr + 2))));\n                ND_PRINT((ndo, \"%s  Minimum/Maximum DLCI: %u/%u, %s%s bit DLCI\",\n                       ident,\n                       (EXTRACT_32BITS(obj_tptr+4))&0x7fffff,\n                       (EXTRACT_32BITS(obj_tptr+8))&0x7fffff,\n                       (((EXTRACT_16BITS(obj_tptr+4)>>7)&3) == 0 ) ? \"10\" : \"\",\n                       (((EXTRACT_16BITS(obj_tptr + 4) >> 7) & 3) == 2 ) ? \"23\" : \"\"));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_4:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  LSP Encoding Type: %s (%u)\",\n                       ident,\n                       tok2str(gmpls_encoding_values,\n                               \"Unknown\",\n                               *obj_tptr),\n\t\t       *obj_tptr));\n                ND_PRINT((ndo, \"%s  Switching Type: %s (%u), Payload ID: %s (0x%04x)\",\n                       ident,\n                       tok2str(gmpls_switch_cap_values,\n                               \"Unknown\",\n                               *(obj_tptr+1)),\n\t\t       *(obj_tptr+1),\n                       tok2str(gmpls_payload_values,\n                               \"Unknown\",\n                               EXTRACT_16BITS(obj_tptr+2)),\n\t\t       EXTRACT_16BITS(obj_tptr + 2)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RRO:\n        case RSVP_OBJ_ERO:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                while(obj_tlen >= 4 ) {\n\t\t    u_char length;\n\n\t\t    ND_TCHECK2(*obj_tptr, 4);\n\t\t    length = *(obj_tptr + 1);\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s, length %u\",\n                           ident,\n                           tok2str(rsvp_obj_xro_values,\n                                   \"Unknown %u\",\n                                   RSVP_OBJ_XRO_MASK_SUBOBJ(*obj_tptr)),\n                           length));\n\n                    if (length == 0) { /* prevent infinite loops */\n                        ND_PRINT((ndo, \"%s  ERROR: zero length ERO subtype\", ident));\n                        break;\n                    }\n\n                    switch(RSVP_OBJ_XRO_MASK_SUBOBJ(*obj_tptr)) {\n\t\t    u_char prefix_length;\n\n                    case RSVP_OBJ_XRO_IPV4:\n\t\t\tif (length != 8) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: length != 8\"));\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tND_TCHECK2(*obj_tptr, 8);\n\t\t\tprefix_length = *(obj_tptr+6);\n\t\t\tif (prefix_length != 32) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: Prefix length %u != 32\",\n\t\t\t\t\t  prefix_length));\n\t\t\t\tgoto invalid;\n\t\t\t}\n                        ND_PRINT((ndo, \", %s, %s/%u, Flags: [%s]\",\n                               RSVP_OBJ_XRO_MASK_LOOSE(*obj_tptr) ? \"Loose\" : \"Strict\",\n                               ipaddr_string(ndo, obj_tptr+2),\n                               *(obj_tptr+6),\n                               bittok2str(rsvp_obj_rro_flag_values,\n                                   \"none\",\n                                   *(obj_tptr + 7)))); /* rfc3209 says that this field is rsvd. */\n                    break;\n                    case RSVP_OBJ_XRO_LABEL:\n\t\t\tif (length != 8) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: length != 8\"));\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tND_TCHECK2(*obj_tptr, 8);\n                        ND_PRINT((ndo, \", Flags: [%s] (%#x), Class-Type: %s (%u), %u\",\n                               bittok2str(rsvp_obj_rro_label_flag_values,\n                                   \"none\",\n                                   *(obj_tptr+2)),\n                               *(obj_tptr+2),\n                               tok2str(rsvp_ctype_values,\n                                       \"Unknown\",\n                                       *(obj_tptr+3) + 256*RSVP_OBJ_RRO),\n                               *(obj_tptr+3),\n                               EXTRACT_32BITS(obj_tptr + 4)));\n                    }\n                    obj_tlen-=*(obj_tptr+1);\n                    obj_tptr+=*(obj_tptr+1);\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_HELLO:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Instance: 0x%08x, Destination Instance: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RESTART_CAPABILITY:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Restart  Time: %ums, Recovery Time: %ums\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SESSION_ATTRIBUTE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 4)\n                    return-1;\n                namelen = *(obj_tptr+3);\n                if (obj_tlen < 4+namelen)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Session Name: \", ident));\n                for (i = 0; i < namelen; i++)\n                    safeputchar(ndo, *(obj_tptr + 4 + i));\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Flags: [%s] (%#x)\",\n                       ident,\n                       (int)*obj_tptr,\n                       (int)*(obj_tptr+1),\n                       bittok2str(rsvp_session_attribute_flag_values,\n                                  \"none\",\n                                  *(obj_tptr+2)),\n                       *(obj_tptr + 2)));\n                obj_tlen-=4+*(obj_tptr+3);\n                obj_tptr+=4+*(obj_tptr+3);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase RSVP_OBJ_GENERALIZED_UNI:\n            switch(rsvp_obj_ctype) {\n\t\tint subobj_type,af,subobj_len,total_subobj_len;\n\n            case RSVP_CTYPE_1:\n\n                if (obj_tlen < 4)\n                    return-1;\n\n\t\t/* read variable length subobjects */\n\t\ttotal_subobj_len = obj_tlen;\n                while(total_subobj_len > 0) {\n                    subobj_len  = EXTRACT_16BITS(obj_tptr);\n                    subobj_type = (EXTRACT_16BITS(obj_tptr+2))>>8;\n                    af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;\n\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s (%u), AF: %s (%u), length: %u\",\n                           ident,\n                           tok2str(rsvp_obj_generalized_uni_values, \"Unknown\", subobj_type),\n                           subobj_type,\n                           tok2str(af_values, \"Unknown\", af), af,\n                           subobj_len));\n\n                    if(subobj_len == 0)\n                        goto invalid;\n\n                    switch(subobj_type) {\n                    case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS:\n                    case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS:\n\n                        switch(af) {\n                        case AFNUM_INET:\n                            if (subobj_len < 8)\n                                return -1;\n                            ND_PRINT((ndo, \"%s    UNI IPv4 TNA address: %s\",\n                                   ident, ipaddr_string(ndo, obj_tptr + 4)));\n                            break;\n                        case AFNUM_INET6:\n                            if (subobj_len < 20)\n                                return -1;\n                            ND_PRINT((ndo, \"%s    UNI IPv6 TNA address: %s\",\n                                   ident, ip6addr_string(ndo, obj_tptr + 4)));\n                            break;\n                        case AFNUM_NSAP:\n                            if (subobj_len) {\n                                /* unless we have a TLV parser lets just hexdump */\n                                hexdump=TRUE;\n                            }\n                            break;\n                        }\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_DIVERSITY:\n                        if (subobj_len) {\n                            /* unless we have a TLV parser lets just hexdump */\n                            hexdump=TRUE;\n                        }\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL:\n                        if (subobj_len < 16) {\n                            return -1;\n                        }\n\n                        ND_PRINT((ndo, \"%s    U-bit: %x, Label type: %u, Logical port id: %u, Label: %u\",\n                               ident,\n                               ((EXTRACT_32BITS(obj_tptr+4))>>31),\n                               ((EXTRACT_32BITS(obj_tptr+4))&0xFF),\n                               EXTRACT_32BITS(obj_tptr+8),\n                               EXTRACT_32BITS(obj_tptr + 12)));\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL:\n                        if (subobj_len < 8) {\n                            return -1;\n                        }\n\n                        ND_PRINT((ndo, \"%s    Service level: %u\",\n                               ident, (EXTRACT_32BITS(obj_tptr + 4)) >> 24));\n                        break;\n\n                    default:\n                        hexdump=TRUE;\n                        break;\n                    }\n                    total_subobj_len-=subobj_len;\n                    obj_tptr+=subobj_len;\n                    obj_tlen+=subobj_len;\n\t\t}\n\n                if (total_subobj_len) {\n                    /* unless we have a TLV parser lets just hexdump */\n                    hexdump=TRUE;\n                }\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RSVP_HOP:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_3: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                if (obj_tlen)\n                    hexdump=TRUE; /* unless we have a TLV parser lets just hexdump */\n                break;\n            case RSVP_CTYPE_4: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 16)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                hexdump=TRUE; /* unless we have a TLV parser lets just hexdump */\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_TIME_VALUES:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Refresh Period: %ums\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        /* those three objects do share the same semantics */\n        case RSVP_OBJ_SENDER_TSPEC:\n        case RSVP_OBJ_ADSPEC:\n        case RSVP_OBJ_FLOWSPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Msg-Version: %u, length: %u\",\n                       ident,\n                       (*obj_tptr & 0xf0) >> 4,\n                       EXTRACT_16BITS(obj_tptr + 2) << 2));\n                obj_tptr+=4; /* get to the start of the service header */\n                obj_tlen-=4;\n\n                while (obj_tlen >= 4) {\n                    intserv_serv_tlen=EXTRACT_16BITS(obj_tptr+2)<<2;\n                    ND_PRINT((ndo, \"%s  Service Type: %s (%u), break bit %s set, Service length: %u\",\n                           ident,\n                           tok2str(rsvp_intserv_service_type_values,\"unknown\",*(obj_tptr)),\n                           *(obj_tptr),\n                           (*(obj_tptr+1)&0x80) ? \"\" : \"not\",\n                           intserv_serv_tlen));\n\n                    obj_tptr+=4; /* get to the start of the parameter list */\n                    obj_tlen-=4;\n\n                    while (intserv_serv_tlen>=4) {\n                        processed = rsvp_intserv_print(ndo, obj_tptr, obj_tlen);\n                        if (processed == 0)\n                            break;\n                        obj_tlen-=processed;\n                        intserv_serv_tlen-=processed;\n                        obj_tptr+=processed;\n                    }\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_FILTERSPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Flow Label: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_24BITS(obj_tptr + 17)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_13: /* IPv6 p2mp LSP tunnel */\n                if (obj_tlen < 40)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ident,\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_16BITS(obj_tptr + 38)));\n                obj_tlen-=40;\n                obj_tptr+=40;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_12: /* IPv4 p2mp LSP tunnel */\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ident,\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_16BITS(obj_tptr + 12)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_FASTREROUTE:\n            /* the differences between c-type 1 and 7 are minor */\n            obj_ptr.rsvp_obj_frr = (const struct rsvp_obj_frr_t *)obj_tptr;\n",
        "suffix": "\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1: /* new style */\n                if (obj_tlen < sizeof(struct rsvp_obj_frr_t))\n                    return-1;\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps\",\n                       ident,\n                       (int)obj_ptr.rsvp_obj_frr->setup_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hold_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hop_limit,\n                        bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Include-any: 0x%08x, Exclude-any: 0x%08x, Include-all: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->exclude_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_all)));\n                obj_tlen-=sizeof(struct rsvp_obj_frr_t);\n                obj_tptr+=sizeof(struct rsvp_obj_frr_t);\n                break;\n\n            case RSVP_CTYPE_TUNNEL_IPV4: /* old style */\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps\",\n                       ident,\n                       (int)obj_ptr.rsvp_obj_frr->setup_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hold_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hop_limit,\n                        bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Include Colors: 0x%08x, Exclude Colors: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->exclude_any)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_DETOUR:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                while(obj_tlen >= 8) {\n                    ND_PRINT((ndo, \"%s  PLR-ID: %s, Avoid-Node-ID: %s\",\n                           ident,\n                           ipaddr_string(ndo, obj_tptr),\n                           ipaddr_string(ndo, obj_tptr + 4)));\n                    obj_tlen-=8;\n                    obj_tptr+=8;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_CLASSTYPE:\n        case RSVP_OBJ_CLASSTYPE_OLD: /* fall through */\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                ND_PRINT((ndo, \"%s  CT: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr) & 0x7));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_ERROR_SPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_3: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                error_code=*(obj_tptr+5);\n                error_value=EXTRACT_16BITS(obj_tptr+6);\n                ND_PRINT((ndo, \"%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       *(obj_tptr+4),\n                       ident,\n                       tok2str(rsvp_obj_error_code_values,\"unknown\",error_code),\n                       error_code));\n                switch (error_code) {\n                case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_routing_values,\"unknown\",error_value),\n                           error_value));\n                    break;\n                case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE: /* fall through */\n                case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_diffserv_te_values,\"unknown\",error_value),\n                           error_value));\n                    break;\n                default:\n                    ND_PRINT((ndo, \", Unknown Error Value (%u)\", error_value));\n                    break;\n                }\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_4: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                error_code=*(obj_tptr+17);\n                error_value=EXTRACT_16BITS(obj_tptr+18);\n                ND_PRINT((ndo, \"%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       *(obj_tptr+16),\n                       ident,\n                       tok2str(rsvp_obj_error_code_values,\"unknown\",error_code),\n                       error_code));\n\n                switch (error_code) {\n                case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_routing_values,\"unknown\",error_value),\n\t\t\t   error_value));\n                    break;\n                default:\n                    break;\n                }\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_PROPERTIES:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                padbytes = EXTRACT_16BITS(obj_tptr+2);\n                ND_PRINT((ndo, \"%s  TLV count: %u, padding bytes: %u\",\n                       ident,\n                       EXTRACT_16BITS(obj_tptr),\n                       padbytes));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                /* loop through as long there is anything longer than the TLV header (2) */\n                while(obj_tlen >= 2 + padbytes) {\n                    ND_PRINT((ndo, \"%s    %s TLV (0x%02x), length: %u\", /* length includes header */\n                           ident,\n                           tok2str(rsvp_obj_prop_tlv_values,\"unknown\",*obj_tptr),\n                           *obj_tptr,\n                           *(obj_tptr + 1)));\n                    if (obj_tlen < *(obj_tptr+1))\n                        return-1;\n                    if (*(obj_tptr+1) < 2)\n                        return -1;\n                    print_unknown_data(ndo, obj_tptr + 2, \"\\n\\t\\t\", *(obj_tptr + 1) - 2);\n                    obj_tlen-=*(obj_tptr+1);\n                    obj_tptr+=*(obj_tptr+1);\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_MESSAGE_ID:     /* fall through */\n        case RSVP_OBJ_MESSAGE_ID_ACK: /* fall through */\n        case RSVP_OBJ_MESSAGE_ID_LIST:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Flags [0x%02x], epoch: %u\",\n                       ident,\n                       *obj_tptr,\n                       EXTRACT_24BITS(obj_tptr + 1)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                /* loop through as long there are no messages left */\n                while(obj_tlen >= 4) {\n                    ND_PRINT((ndo, \"%s    Message-ID 0x%08x (%u)\",\n                           ident,\n                           EXTRACT_32BITS(obj_tptr),\n                           EXTRACT_32BITS(obj_tptr)));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_INTEGRITY:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < sizeof(struct rsvp_obj_integrity_t))\n                    return-1;\n                obj_ptr.rsvp_obj_integrity = (const struct rsvp_obj_integrity_t *)obj_tptr;\n                ND_PRINT((ndo, \"%s  Key-ID 0x%04x%08x, Sequence 0x%08x%08x, Flags [%s]\",\n                       ident,\n                       EXTRACT_16BITS(obj_ptr.rsvp_obj_integrity->key_id),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->key_id+2),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->sequence),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->sequence+4),\n                       bittok2str(rsvp_obj_integrity_flag_values,\n                                  \"none\",\n                                  obj_ptr.rsvp_obj_integrity->flags)));\n                ND_PRINT((ndo, \"%s  MD5-sum 0x%08x%08x%08x%08x \",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest+4),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest+8),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest + 12)));\n\n                sigcheck = signature_verify(ndo, pptr, plen,\n                                            obj_ptr.rsvp_obj_integrity->digest,\n                                            rsvp_clear_checksum,\n                                            rsvp_com_header);\n                ND_PRINT((ndo, \" (%s)\", tok2str(signature_check_values, \"Unknown\", sigcheck)));\n\n                obj_tlen+=sizeof(struct rsvp_obj_integrity_t);\n                obj_tptr+=sizeof(struct rsvp_obj_integrity_t);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_ADMIN_STATUS:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Flags [%s]\", ident,\n                       bittok2str(rsvp_obj_admin_status_flag_values, \"none\",\n                                  EXTRACT_32BITS(obj_tptr))));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_LABEL_SET:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                action = (EXTRACT_16BITS(obj_tptr)>>8);\n\n                ND_PRINT((ndo, \"%s  Action: %s (%u), Label type: %u\", ident,\n                       tok2str(rsvp_obj_label_set_action_values, \"Unknown\", action),\n                       action, ((EXTRACT_32BITS(obj_tptr) & 0x7F))));\n\n                switch (action) {\n                case LABEL_SET_INCLUSIVE_RANGE:\n                case LABEL_SET_EXCLUSIVE_RANGE: /* fall through */\n\n\t\t    /* only a couple of subchannels are expected */\n\t\t    if (obj_tlen < 12)\n\t\t\treturn -1;\n\t\t    ND_PRINT((ndo, \"%s  Start range: %u, End range: %u\", ident,\n                           EXTRACT_32BITS(obj_tptr+4),\n                           EXTRACT_32BITS(obj_tptr + 8)));\n\t\t    obj_tlen-=12;\n\t\t    obj_tptr+=12;\n                    break;\n\n                default:\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                    subchannel = 1;\n                    while(obj_tlen >= 4 ) {\n                        ND_PRINT((ndo, \"%s  Subchannel #%u: %u\", ident, subchannel,\n                               EXTRACT_32BITS(obj_tptr)));\n                        obj_tptr+=4;\n                        obj_tlen-=4;\n                        subchannel++;\n                    }\n                    break;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_S2L:\n            switch (rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Sub-LSP destination address: %s\",\n                       ident, ipaddr_string(ndo, obj_tptr)));\n\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Sub-LSP destination address: %s\",\n                       ident, ip6addr_string(ndo, obj_tptr)));\n\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        /*\n         *  FIXME those are the defined objects that lack a decoder\n         *  you are welcome to contribute code ;-)\n         */\n\n        case RSVP_OBJ_SCOPE:\n        case RSVP_OBJ_POLICY_DATA:\n        case RSVP_OBJ_ACCEPT_LABEL_SET:\n        case RSVP_OBJ_PROTECTION:\n        default:\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen); /* FIXME indentation */\n            break;\n        }\n        /* do we also want to see a hex dump ? */\n        if (ndo->ndo_vflag > 1 || hexdump == TRUE)\n            print_unknown_data(ndo, tptr + sizeof(struct rsvp_object_header), \"\\n\\t    \", /* FIXME indentation */\n                               rsvp_obj_len - sizeof(struct rsvp_object_header));\n\n        tptr+=rsvp_obj_len;\n        tlen-=rsvp_obj_len;\n    }\n    return 0;\ninvalid:\n    ND_PRINT((ndo, \"%s\", istr));\n    return -1;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t\\t\"));\n    ND_PRINT((ndo, \"%s\", tstr));\n    return -1;\n}\n",
        "start": 659,
        "end": 1828,
        "buggy": "static int\nrsvp_obj_print(netdissect_options *ndo,\n               const u_char *pptr, u_int plen, const u_char *tptr,\n               const char *ident, u_int tlen,\n               const struct rsvp_common_header *rsvp_com_header)\n{\n    const struct rsvp_object_header *rsvp_obj_header;\n    const u_char *obj_tptr;\n    union {\n        const struct rsvp_obj_integrity_t *rsvp_obj_integrity;\n        const struct rsvp_obj_frr_t *rsvp_obj_frr;\n    } obj_ptr;\n\n    u_short rsvp_obj_len,rsvp_obj_ctype,obj_tlen,intserv_serv_tlen;\n    int hexdump,processed,padbytes,error_code,error_value,i,sigcheck;\n    union {\n\tfloat f;\n\tuint32_t i;\n    } bw;\n    uint8_t namelen;\n\n    u_int action, subchannel;\n\n    while(tlen>=sizeof(struct rsvp_object_header)) {\n        /* did we capture enough for fully decoding the object header ? */\n        ND_TCHECK2(*tptr, sizeof(struct rsvp_object_header));\n\n        rsvp_obj_header = (const struct rsvp_object_header *)tptr;\n        rsvp_obj_len=EXTRACT_16BITS(rsvp_obj_header->length);\n        rsvp_obj_ctype=rsvp_obj_header->ctype;\n\n        if(rsvp_obj_len % 4) {\n            ND_PRINT((ndo, \"%sERROR: object header size %u not a multiple of 4\", ident, rsvp_obj_len));\n            return -1;\n        }\n        if(rsvp_obj_len < sizeof(struct rsvp_object_header)) {\n            ND_PRINT((ndo, \"%sERROR: object header too short %u < %lu\", ident, rsvp_obj_len,\n                   (unsigned long)sizeof(const struct rsvp_object_header)));\n            return -1;\n        }\n\n        ND_PRINT((ndo, \"%s%s Object (%u) Flags: [%s\",\n               ident,\n               tok2str(rsvp_obj_values,\n                       \"Unknown\",\n                       rsvp_obj_header->class_num),\n               rsvp_obj_header->class_num,\n               ((rsvp_obj_header->class_num) & 0x80) ? \"ignore\" : \"reject\"));\n\n        if (rsvp_obj_header->class_num > 128)\n            ND_PRINT((ndo, \" %s\",\n                   ((rsvp_obj_header->class_num) & 0x40) ? \"and forward\" : \"silently\"));\n\n        ND_PRINT((ndo, \" if unknown], Class-Type: %s (%u), length: %u\",\n               tok2str(rsvp_ctype_values,\n                       \"Unknown\",\n                       ((rsvp_obj_header->class_num)<<8)+rsvp_obj_ctype),\n               rsvp_obj_ctype,\n               rsvp_obj_len));\n\n        if(tlen < rsvp_obj_len) {\n            ND_PRINT((ndo, \"%sERROR: object goes past end of objects TLV\", ident));\n            return -1;\n        }\n\n        obj_tptr=tptr+sizeof(struct rsvp_object_header);\n        obj_tlen=rsvp_obj_len-sizeof(struct rsvp_object_header);\n\n        /* did we capture enough for fully decoding the object ? */\n        if (!ND_TTEST2(*tptr, rsvp_obj_len))\n            return -1;\n        hexdump=FALSE;\n\n        switch(rsvp_obj_header->class_num) {\n        case RSVP_OBJ_SESSION:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 DestAddress: %s, Protocol ID: 0x%02x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       *(obj_tptr + sizeof(struct in_addr))));\n                ND_PRINT((ndo, \"%s  Flags: [0x%02x], DestPort %u\",\n                       ident,\n                       *(obj_tptr+5),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 DestAddress: %s, Protocol ID: 0x%02x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       *(obj_tptr + sizeof(struct in6_addr))));\n                ND_PRINT((ndo, \"%s  Flags: [0x%02x], DestPort %u\",\n                       ident,\n                       *(obj_tptr+sizeof(struct in6_addr)+1),\n                       EXTRACT_16BITS(obj_tptr + sizeof(struct in6_addr) + 2)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n\n            case RSVP_CTYPE_TUNNEL_IPV6:\n                if (obj_tlen < 36)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ip6addr_string(ndo, obj_tptr + 20)));\n                obj_tlen-=36;\n                obj_tptr+=36;\n                break;\n\n            case RSVP_CTYPE_14: /* IPv6 p2mp LSP Tunnel */\n                if (obj_tlen < 26)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 P2MP LSP ID: 0x%08x, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ip6addr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=26;\n                obj_tptr+=26;\n                break;\n            case RSVP_CTYPE_13: /* IPv4 p2mp LSP Tunnel */\n                if (obj_tlen < 12)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 P2MP LSP ID: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ipaddr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n            case RSVP_CTYPE_UNI_IPV4:\n                if (obj_tlen < 12)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ipaddr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_CONFIRM:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < sizeof(struct in_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Receiver Address: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in_addr);\n                obj_tptr+=sizeof(struct in_addr);\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < sizeof(struct in6_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 Receiver Address: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in6_addr);\n                obj_tptr+=sizeof(struct in6_addr);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_NOTIFY_REQ:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < sizeof(struct in_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Notify Node Address: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in_addr);\n                obj_tptr+=sizeof(struct in_addr);\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < sizeof(struct in6_addr))\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Notify Node Address: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in6_addr);\n                obj_tptr+=sizeof(struct in6_addr);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SUGGESTED_LABEL: /* fall through */\n        case RSVP_OBJ_UPSTREAM_LABEL:  /* fall through */\n        case RSVP_OBJ_RECOVERY_LABEL:  /* fall through */\n        case RSVP_OBJ_LABEL:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                while(obj_tlen >= 4 ) {\n                    ND_PRINT((ndo, \"%s  Label: %u\", ident, EXTRACT_32BITS(obj_tptr)));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Generalized Label: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Waveband ID: %u%s  Start Label: %u, Stop Label: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       ident,\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_STYLE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Reservation Style: %s, Flags: [0x%02x]\",\n                       ident,\n                       tok2str(rsvp_resstyle_values,\n                               \"Unknown\",\n                               EXTRACT_24BITS(obj_tptr+1)),\n                       *(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SENDER_TEMPLATE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_13: /* IPv6 p2mp LSP tunnel */\n                if (obj_tlen < 40)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ident,\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_16BITS(obj_tptr + 38)));\n                obj_tlen-=40;\n                obj_tptr+=40;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_12: /* IPv4 p2mp LSP tunnel */\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ident,\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_16BITS(obj_tptr + 12)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_LABEL_REQ:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                while(obj_tlen >= 4 ) {\n                    ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                           ident,\n                           tok2str(ethertype_values,\n                                   \"Unknown Protocol (0x%04x)\",\n                                   EXTRACT_16BITS(obj_tptr + 2))));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                       ident,\n                       tok2str(ethertype_values,\n                               \"Unknown Protocol (0x%04x)\",\n                               EXTRACT_16BITS(obj_tptr + 2))));\n                ND_PRINT((ndo, \",%s merge capability\",((*(obj_tptr + 4)) & 0x80) ? \"no\" : \"\" ));\n                ND_PRINT((ndo, \"%s  Minimum VPI/VCI: %u/%u\",\n                       ident,\n                       (EXTRACT_16BITS(obj_tptr+4))&0xfff,\n                       (EXTRACT_16BITS(obj_tptr + 6)) & 0xfff));\n                ND_PRINT((ndo, \"%s  Maximum VPI/VCI: %u/%u\",\n                       ident,\n                       (EXTRACT_16BITS(obj_tptr+8))&0xfff,\n                       (EXTRACT_16BITS(obj_tptr + 10)) & 0xfff));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                       ident,\n                       tok2str(ethertype_values,\n                               \"Unknown Protocol (0x%04x)\",\n                               EXTRACT_16BITS(obj_tptr + 2))));\n                ND_PRINT((ndo, \"%s  Minimum/Maximum DLCI: %u/%u, %s%s bit DLCI\",\n                       ident,\n                       (EXTRACT_32BITS(obj_tptr+4))&0x7fffff,\n                       (EXTRACT_32BITS(obj_tptr+8))&0x7fffff,\n                       (((EXTRACT_16BITS(obj_tptr+4)>>7)&3) == 0 ) ? \"10\" : \"\",\n                       (((EXTRACT_16BITS(obj_tptr + 4) >> 7) & 3) == 2 ) ? \"23\" : \"\"));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_4:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  LSP Encoding Type: %s (%u)\",\n                       ident,\n                       tok2str(gmpls_encoding_values,\n                               \"Unknown\",\n                               *obj_tptr),\n\t\t       *obj_tptr));\n                ND_PRINT((ndo, \"%s  Switching Type: %s (%u), Payload ID: %s (0x%04x)\",\n                       ident,\n                       tok2str(gmpls_switch_cap_values,\n                               \"Unknown\",\n                               *(obj_tptr+1)),\n\t\t       *(obj_tptr+1),\n                       tok2str(gmpls_payload_values,\n                               \"Unknown\",\n                               EXTRACT_16BITS(obj_tptr+2)),\n\t\t       EXTRACT_16BITS(obj_tptr + 2)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RRO:\n        case RSVP_OBJ_ERO:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                while(obj_tlen >= 4 ) {\n\t\t    u_char length;\n\n\t\t    ND_TCHECK2(*obj_tptr, 4);\n\t\t    length = *(obj_tptr + 1);\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s, length %u\",\n                           ident,\n                           tok2str(rsvp_obj_xro_values,\n                                   \"Unknown %u\",\n                                   RSVP_OBJ_XRO_MASK_SUBOBJ(*obj_tptr)),\n                           length));\n\n                    if (length == 0) { /* prevent infinite loops */\n                        ND_PRINT((ndo, \"%s  ERROR: zero length ERO subtype\", ident));\n                        break;\n                    }\n\n                    switch(RSVP_OBJ_XRO_MASK_SUBOBJ(*obj_tptr)) {\n\t\t    u_char prefix_length;\n\n                    case RSVP_OBJ_XRO_IPV4:\n\t\t\tif (length != 8) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: length != 8\"));\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tND_TCHECK2(*obj_tptr, 8);\n\t\t\tprefix_length = *(obj_tptr+6);\n\t\t\tif (prefix_length != 32) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: Prefix length %u != 32\",\n\t\t\t\t\t  prefix_length));\n\t\t\t\tgoto invalid;\n\t\t\t}\n                        ND_PRINT((ndo, \", %s, %s/%u, Flags: [%s]\",\n                               RSVP_OBJ_XRO_MASK_LOOSE(*obj_tptr) ? \"Loose\" : \"Strict\",\n                               ipaddr_string(ndo, obj_tptr+2),\n                               *(obj_tptr+6),\n                               bittok2str(rsvp_obj_rro_flag_values,\n                                   \"none\",\n                                   *(obj_tptr + 7)))); /* rfc3209 says that this field is rsvd. */\n                    break;\n                    case RSVP_OBJ_XRO_LABEL:\n\t\t\tif (length != 8) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: length != 8\"));\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tND_TCHECK2(*obj_tptr, 8);\n                        ND_PRINT((ndo, \", Flags: [%s] (%#x), Class-Type: %s (%u), %u\",\n                               bittok2str(rsvp_obj_rro_label_flag_values,\n                                   \"none\",\n                                   *(obj_tptr+2)),\n                               *(obj_tptr+2),\n                               tok2str(rsvp_ctype_values,\n                                       \"Unknown\",\n                                       *(obj_tptr+3) + 256*RSVP_OBJ_RRO),\n                               *(obj_tptr+3),\n                               EXTRACT_32BITS(obj_tptr + 4)));\n                    }\n                    obj_tlen-=*(obj_tptr+1);\n                    obj_tptr+=*(obj_tptr+1);\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_HELLO:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Instance: 0x%08x, Destination Instance: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RESTART_CAPABILITY:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Restart  Time: %ums, Recovery Time: %ums\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SESSION_ATTRIBUTE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 4)\n                    return-1;\n                namelen = *(obj_tptr+3);\n                if (obj_tlen < 4+namelen)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Session Name: \", ident));\n                for (i = 0; i < namelen; i++)\n                    safeputchar(ndo, *(obj_tptr + 4 + i));\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Flags: [%s] (%#x)\",\n                       ident,\n                       (int)*obj_tptr,\n                       (int)*(obj_tptr+1),\n                       bittok2str(rsvp_session_attribute_flag_values,\n                                  \"none\",\n                                  *(obj_tptr+2)),\n                       *(obj_tptr + 2)));\n                obj_tlen-=4+*(obj_tptr+3);\n                obj_tptr+=4+*(obj_tptr+3);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase RSVP_OBJ_GENERALIZED_UNI:\n            switch(rsvp_obj_ctype) {\n\t\tint subobj_type,af,subobj_len,total_subobj_len;\n\n            case RSVP_CTYPE_1:\n\n                if (obj_tlen < 4)\n                    return-1;\n\n\t\t/* read variable length subobjects */\n\t\ttotal_subobj_len = obj_tlen;\n                while(total_subobj_len > 0) {\n                    subobj_len  = EXTRACT_16BITS(obj_tptr);\n                    subobj_type = (EXTRACT_16BITS(obj_tptr+2))>>8;\n                    af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;\n\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s (%u), AF: %s (%u), length: %u\",\n                           ident,\n                           tok2str(rsvp_obj_generalized_uni_values, \"Unknown\", subobj_type),\n                           subobj_type,\n                           tok2str(af_values, \"Unknown\", af), af,\n                           subobj_len));\n\n                    if(subobj_len == 0)\n                        goto invalid;\n\n                    switch(subobj_type) {\n                    case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS:\n                    case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS:\n\n                        switch(af) {\n                        case AFNUM_INET:\n                            if (subobj_len < 8)\n                                return -1;\n                            ND_PRINT((ndo, \"%s    UNI IPv4 TNA address: %s\",\n                                   ident, ipaddr_string(ndo, obj_tptr + 4)));\n                            break;\n                        case AFNUM_INET6:\n                            if (subobj_len < 20)\n                                return -1;\n                            ND_PRINT((ndo, \"%s    UNI IPv6 TNA address: %s\",\n                                   ident, ip6addr_string(ndo, obj_tptr + 4)));\n                            break;\n                        case AFNUM_NSAP:\n                            if (subobj_len) {\n                                /* unless we have a TLV parser lets just hexdump */\n                                hexdump=TRUE;\n                            }\n                            break;\n                        }\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_DIVERSITY:\n                        if (subobj_len) {\n                            /* unless we have a TLV parser lets just hexdump */\n                            hexdump=TRUE;\n                        }\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL:\n                        if (subobj_len < 16) {\n                            return -1;\n                        }\n\n                        ND_PRINT((ndo, \"%s    U-bit: %x, Label type: %u, Logical port id: %u, Label: %u\",\n                               ident,\n                               ((EXTRACT_32BITS(obj_tptr+4))>>31),\n                               ((EXTRACT_32BITS(obj_tptr+4))&0xFF),\n                               EXTRACT_32BITS(obj_tptr+8),\n                               EXTRACT_32BITS(obj_tptr + 12)));\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL:\n                        if (subobj_len < 8) {\n                            return -1;\n                        }\n\n                        ND_PRINT((ndo, \"%s    Service level: %u\",\n                               ident, (EXTRACT_32BITS(obj_tptr + 4)) >> 24));\n                        break;\n\n                    default:\n                        hexdump=TRUE;\n                        break;\n                    }\n                    total_subobj_len-=subobj_len;\n                    obj_tptr+=subobj_len;\n                    obj_tlen+=subobj_len;\n\t\t}\n\n                if (total_subobj_len) {\n                    /* unless we have a TLV parser lets just hexdump */\n                    hexdump=TRUE;\n                }\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RSVP_HOP:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_3: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                if (obj_tlen)\n                    hexdump=TRUE; /* unless we have a TLV parser lets just hexdump */\n                break;\n            case RSVP_CTYPE_4: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 16)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                hexdump=TRUE; /* unless we have a TLV parser lets just hexdump */\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_TIME_VALUES:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Refresh Period: %ums\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        /* those three objects do share the same semantics */\n        case RSVP_OBJ_SENDER_TSPEC:\n        case RSVP_OBJ_ADSPEC:\n        case RSVP_OBJ_FLOWSPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Msg-Version: %u, length: %u\",\n                       ident,\n                       (*obj_tptr & 0xf0) >> 4,\n                       EXTRACT_16BITS(obj_tptr + 2) << 2));\n                obj_tptr+=4; /* get to the start of the service header */\n                obj_tlen-=4;\n\n                while (obj_tlen >= 4) {\n                    intserv_serv_tlen=EXTRACT_16BITS(obj_tptr+2)<<2;\n                    ND_PRINT((ndo, \"%s  Service Type: %s (%u), break bit %s set, Service length: %u\",\n                           ident,\n                           tok2str(rsvp_intserv_service_type_values,\"unknown\",*(obj_tptr)),\n                           *(obj_tptr),\n                           (*(obj_tptr+1)&0x80) ? \"\" : \"not\",\n                           intserv_serv_tlen));\n\n                    obj_tptr+=4; /* get to the start of the parameter list */\n                    obj_tlen-=4;\n\n                    while (intserv_serv_tlen>=4) {\n                        processed = rsvp_intserv_print(ndo, obj_tptr, obj_tlen);\n                        if (processed == 0)\n                            break;\n                        obj_tlen-=processed;\n                        intserv_serv_tlen-=processed;\n                        obj_tptr+=processed;\n                    }\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_FILTERSPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Flow Label: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_24BITS(obj_tptr + 17)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_13: /* IPv6 p2mp LSP tunnel */\n                if (obj_tlen < 40)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ident,\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_16BITS(obj_tptr + 38)));\n                obj_tlen-=40;\n                obj_tptr+=40;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_12: /* IPv4 p2mp LSP tunnel */\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ident,\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_16BITS(obj_tptr + 12)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_FASTREROUTE:\n            /* the differences between c-type 1 and 7 are minor */\n            obj_ptr.rsvp_obj_frr = (const struct rsvp_obj_frr_t *)obj_tptr;\n            bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);\n\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1: /* new style */\n                if (obj_tlen < sizeof(struct rsvp_obj_frr_t))\n                    return-1;\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps\",\n                       ident,\n                       (int)obj_ptr.rsvp_obj_frr->setup_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hold_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hop_limit,\n                        bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Include-any: 0x%08x, Exclude-any: 0x%08x, Include-all: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->exclude_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_all)));\n                obj_tlen-=sizeof(struct rsvp_obj_frr_t);\n                obj_tptr+=sizeof(struct rsvp_obj_frr_t);\n                break;\n\n            case RSVP_CTYPE_TUNNEL_IPV4: /* old style */\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps\",\n                       ident,\n                       (int)obj_ptr.rsvp_obj_frr->setup_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hold_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hop_limit,\n                        bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Include Colors: 0x%08x, Exclude Colors: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->exclude_any)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_DETOUR:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                while(obj_tlen >= 8) {\n                    ND_PRINT((ndo, \"%s  PLR-ID: %s, Avoid-Node-ID: %s\",\n                           ident,\n                           ipaddr_string(ndo, obj_tptr),\n                           ipaddr_string(ndo, obj_tptr + 4)));\n                    obj_tlen-=8;\n                    obj_tptr+=8;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_CLASSTYPE:\n        case RSVP_OBJ_CLASSTYPE_OLD: /* fall through */\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                ND_PRINT((ndo, \"%s  CT: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr) & 0x7));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_ERROR_SPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_3: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                error_code=*(obj_tptr+5);\n                error_value=EXTRACT_16BITS(obj_tptr+6);\n                ND_PRINT((ndo, \"%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       *(obj_tptr+4),\n                       ident,\n                       tok2str(rsvp_obj_error_code_values,\"unknown\",error_code),\n                       error_code));\n                switch (error_code) {\n                case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_routing_values,\"unknown\",error_value),\n                           error_value));\n                    break;\n                case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE: /* fall through */\n                case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_diffserv_te_values,\"unknown\",error_value),\n                           error_value));\n                    break;\n                default:\n                    ND_PRINT((ndo, \", Unknown Error Value (%u)\", error_value));\n                    break;\n                }\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_4: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                error_code=*(obj_tptr+17);\n                error_value=EXTRACT_16BITS(obj_tptr+18);\n                ND_PRINT((ndo, \"%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       *(obj_tptr+16),\n                       ident,\n                       tok2str(rsvp_obj_error_code_values,\"unknown\",error_code),\n                       error_code));\n\n                switch (error_code) {\n                case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_routing_values,\"unknown\",error_value),\n\t\t\t   error_value));\n                    break;\n                default:\n                    break;\n                }\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_PROPERTIES:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                padbytes = EXTRACT_16BITS(obj_tptr+2);\n                ND_PRINT((ndo, \"%s  TLV count: %u, padding bytes: %u\",\n                       ident,\n                       EXTRACT_16BITS(obj_tptr),\n                       padbytes));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                /* loop through as long there is anything longer than the TLV header (2) */\n                while(obj_tlen >= 2 + padbytes) {\n                    ND_PRINT((ndo, \"%s    %s TLV (0x%02x), length: %u\", /* length includes header */\n                           ident,\n                           tok2str(rsvp_obj_prop_tlv_values,\"unknown\",*obj_tptr),\n                           *obj_tptr,\n                           *(obj_tptr + 1)));\n                    if (obj_tlen < *(obj_tptr+1))\n                        return-1;\n                    if (*(obj_tptr+1) < 2)\n                        return -1;\n                    print_unknown_data(ndo, obj_tptr + 2, \"\\n\\t\\t\", *(obj_tptr + 1) - 2);\n                    obj_tlen-=*(obj_tptr+1);\n                    obj_tptr+=*(obj_tptr+1);\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_MESSAGE_ID:     /* fall through */\n        case RSVP_OBJ_MESSAGE_ID_ACK: /* fall through */\n        case RSVP_OBJ_MESSAGE_ID_LIST:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Flags [0x%02x], epoch: %u\",\n                       ident,\n                       *obj_tptr,\n                       EXTRACT_24BITS(obj_tptr + 1)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                /* loop through as long there are no messages left */\n                while(obj_tlen >= 4) {\n                    ND_PRINT((ndo, \"%s    Message-ID 0x%08x (%u)\",\n                           ident,\n                           EXTRACT_32BITS(obj_tptr),\n                           EXTRACT_32BITS(obj_tptr)));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_INTEGRITY:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < sizeof(struct rsvp_obj_integrity_t))\n                    return-1;\n                obj_ptr.rsvp_obj_integrity = (const struct rsvp_obj_integrity_t *)obj_tptr;\n                ND_PRINT((ndo, \"%s  Key-ID 0x%04x%08x, Sequence 0x%08x%08x, Flags [%s]\",\n                       ident,\n                       EXTRACT_16BITS(obj_ptr.rsvp_obj_integrity->key_id),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->key_id+2),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->sequence),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->sequence+4),\n                       bittok2str(rsvp_obj_integrity_flag_values,\n                                  \"none\",\n                                  obj_ptr.rsvp_obj_integrity->flags)));\n                ND_PRINT((ndo, \"%s  MD5-sum 0x%08x%08x%08x%08x \",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest+4),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest+8),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest + 12)));\n\n                sigcheck = signature_verify(ndo, pptr, plen,\n                                            obj_ptr.rsvp_obj_integrity->digest,\n                                            rsvp_clear_checksum,\n                                            rsvp_com_header);\n                ND_PRINT((ndo, \" (%s)\", tok2str(signature_check_values, \"Unknown\", sigcheck)));\n\n                obj_tlen+=sizeof(struct rsvp_obj_integrity_t);\n                obj_tptr+=sizeof(struct rsvp_obj_integrity_t);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_ADMIN_STATUS:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Flags [%s]\", ident,\n                       bittok2str(rsvp_obj_admin_status_flag_values, \"none\",\n                                  EXTRACT_32BITS(obj_tptr))));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_LABEL_SET:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                action = (EXTRACT_16BITS(obj_tptr)>>8);\n\n                ND_PRINT((ndo, \"%s  Action: %s (%u), Label type: %u\", ident,\n                       tok2str(rsvp_obj_label_set_action_values, \"Unknown\", action),\n                       action, ((EXTRACT_32BITS(obj_tptr) & 0x7F))));\n\n                switch (action) {\n                case LABEL_SET_INCLUSIVE_RANGE:\n                case LABEL_SET_EXCLUSIVE_RANGE: /* fall through */\n\n\t\t    /* only a couple of subchannels are expected */\n\t\t    if (obj_tlen < 12)\n\t\t\treturn -1;\n\t\t    ND_PRINT((ndo, \"%s  Start range: %u, End range: %u\", ident,\n                           EXTRACT_32BITS(obj_tptr+4),\n                           EXTRACT_32BITS(obj_tptr + 8)));\n\t\t    obj_tlen-=12;\n\t\t    obj_tptr+=12;\n                    break;\n\n                default:\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                    subchannel = 1;\n                    while(obj_tlen >= 4 ) {\n                        ND_PRINT((ndo, \"%s  Subchannel #%u: %u\", ident, subchannel,\n                               EXTRACT_32BITS(obj_tptr)));\n                        obj_tptr+=4;\n                        obj_tlen-=4;\n                        subchannel++;\n                    }\n                    break;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_S2L:\n            switch (rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Sub-LSP destination address: %s\",\n                       ident, ipaddr_string(ndo, obj_tptr)));\n\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Sub-LSP destination address: %s\",\n                       ident, ip6addr_string(ndo, obj_tptr)));\n\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        /*\n         *  FIXME those are the defined objects that lack a decoder\n         *  you are welcome to contribute code ;-)\n         */\n\n        case RSVP_OBJ_SCOPE:\n        case RSVP_OBJ_POLICY_DATA:\n        case RSVP_OBJ_ACCEPT_LABEL_SET:\n        case RSVP_OBJ_PROTECTION:\n        default:\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen); /* FIXME indentation */\n            break;\n        }\n        /* do we also want to see a hex dump ? */\n        if (ndo->ndo_vflag > 1 || hexdump == TRUE)\n            print_unknown_data(ndo, tptr + sizeof(struct rsvp_object_header), \"\\n\\t    \", /* FIXME indentation */\n                               rsvp_obj_len - sizeof(struct rsvp_object_header));\n\n        tptr+=rsvp_obj_len;\n        tlen-=rsvp_obj_len;\n    }\n    return 0;\ninvalid:\n    ND_PRINT((ndo, \"%s\", istr));\n    return -1;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t\\t\"));\n    ND_PRINT((ndo, \"%s\", tstr));\n    return -1;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);\n",
        "src_path": "3c8a2b0e91d8d8947e89384dacf6b54673083e71___print-rsvp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/3c8a2b0e91d8d8947e89384dacf6b54673083e71",
        "commit_msg": "CVE-2017-13048/RSVP: fix decoding of Fast Reroute objects\n\nIn rsvp_obj_print() the case block for Class-Num 205 (FAST_REROUTE) from\nRFC 4090 Section 4.1 could over-read accessing the buffer contents before\nmaking the bounds check. Rearrange those steps the correct way around.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -565,6 +565,7 @@ hncp_dhcpv4data-oobr\thncp_dhcpv4data-oobr.pcap\thncp_dhcpv4data-oobr.out -v -c1\n vqp-oobr\t\tvqp-oobr.pcap\t\t\tvqp-oobr.out\t\t-v -c1\n bgp_pmsi_tunnel-oobr\tbgp_pmsi_tunnel-oobr.pcap\tbgp_pmsi_tunnel-oobr.out -v -c1\n bgp_mvpn_6_and_7\tbgp_mvpn_6_and_7.pcap\t\tbgp_mvpn_6_and_7.out\t-v -c1\n+rsvp_fast_reroute-oobr\trsvp_fast_reroute-oobr.pcap\trsvp_fast_reroute-oobr.out -v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/rsvp_fast_reroute-oobr.out",
                "patch": "@@ -0,0 +1,6 @@\n+IP (tos 0x0, ttl 224, id 17920, offset 0, flags [none], proto RSVP (46), length 42024, bad cksum 3700 (->fc41)!)\n+    0.203.243.128 > 0.26.0.0: \n+\tRSVPv1 Path Message (1), Flags: [Refresh reduction capable], length: 41218, ttl: 227, checksum: 0x00f4\n+\t  Fast Re-Route Object (205) Flags: [ignore and forward if unknown], Class-Type: Unknown (0), length: 4\n+\t  Fast Re-Route Object (205) Flags: [ignore and forward if unknown], Class-Type: Unknown (0), length: 4\n+\t\t [|rsvp]"
            }
        ],
        "error_msg": "    rsvp_fast_reroute-oobr             : passed\n"
    },
    "289c672020280529fd382f3502efab7100d638ec___print-rsvp.c": {
        "prefix": "static int\nrsvp_obj_print(netdissect_options *ndo,\n               const u_char *pptr, u_int plen, const u_char *tptr,\n               const char *ident, u_int tlen,\n               const struct rsvp_common_header *rsvp_com_header)\n{\n    const struct rsvp_object_header *rsvp_obj_header;\n    const u_char *obj_tptr;\n    union {\n        const struct rsvp_obj_integrity_t *rsvp_obj_integrity;\n        const struct rsvp_obj_frr_t *rsvp_obj_frr;\n    } obj_ptr;\n\n    u_short rsvp_obj_len,rsvp_obj_ctype,obj_tlen,intserv_serv_tlen;\n    int hexdump,processed,padbytes,error_code,error_value,i,sigcheck;\n    union {\n\tfloat f;\n\tuint32_t i;\n    } bw;\n    uint8_t namelen;\n\n    u_int action, subchannel;\n\n    while(tlen>=sizeof(struct rsvp_object_header)) {\n        /* did we capture enough for fully decoding the object header ? */\n        ND_TCHECK2(*tptr, sizeof(struct rsvp_object_header));\n\n        rsvp_obj_header = (const struct rsvp_object_header *)tptr;\n        rsvp_obj_len=EXTRACT_16BITS(rsvp_obj_header->length);\n        rsvp_obj_ctype=rsvp_obj_header->ctype;\n\n        if(rsvp_obj_len % 4) {\n            ND_PRINT((ndo, \"%sERROR: object header size %u not a multiple of 4\", ident, rsvp_obj_len));\n            return -1;\n        }\n        if(rsvp_obj_len < sizeof(struct rsvp_object_header)) {\n            ND_PRINT((ndo, \"%sERROR: object header too short %u < %lu\", ident, rsvp_obj_len,\n                   (unsigned long)sizeof(const struct rsvp_object_header)));\n            return -1;\n        }\n\n        ND_PRINT((ndo, \"%s%s Object (%u) Flags: [%s\",\n               ident,\n               tok2str(rsvp_obj_values,\n                       \"Unknown\",\n                       rsvp_obj_header->class_num),\n               rsvp_obj_header->class_num,\n               ((rsvp_obj_header->class_num) & 0x80) ? \"ignore\" : \"reject\"));\n\n        if (rsvp_obj_header->class_num > 128)\n            ND_PRINT((ndo, \" %s\",\n                   ((rsvp_obj_header->class_num) & 0x40) ? \"and forward\" : \"silently\"));\n\n        ND_PRINT((ndo, \" if unknown], Class-Type: %s (%u), length: %u\",\n               tok2str(rsvp_ctype_values,\n                       \"Unknown\",\n                       ((rsvp_obj_header->class_num)<<8)+rsvp_obj_ctype),\n               rsvp_obj_ctype,\n               rsvp_obj_len));\n\n        if(tlen < rsvp_obj_len) {\n            ND_PRINT((ndo, \"%sERROR: object goes past end of objects TLV\", ident));\n            return -1;\n        }\n\n        obj_tptr=tptr+sizeof(struct rsvp_object_header);\n        obj_tlen=rsvp_obj_len-sizeof(struct rsvp_object_header);\n\n        /* did we capture enough for fully decoding the object ? */\n        if (!ND_TTEST2(*tptr, rsvp_obj_len))\n            return -1;\n        hexdump=FALSE;\n\n        switch(rsvp_obj_header->class_num) {\n        case RSVP_OBJ_SESSION:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 DestAddress: %s, Protocol ID: 0x%02x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       *(obj_tptr + sizeof(struct in_addr))));\n                ND_PRINT((ndo, \"%s  Flags: [0x%02x], DestPort %u\",\n                       ident,\n                       *(obj_tptr+5),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 DestAddress: %s, Protocol ID: 0x%02x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       *(obj_tptr + sizeof(struct in6_addr))));\n                ND_PRINT((ndo, \"%s  Flags: [0x%02x], DestPort %u\",\n                       ident,\n                       *(obj_tptr+sizeof(struct in6_addr)+1),\n                       EXTRACT_16BITS(obj_tptr + sizeof(struct in6_addr) + 2)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n\n            case RSVP_CTYPE_TUNNEL_IPV6:\n                if (obj_tlen < 36)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ip6addr_string(ndo, obj_tptr + 20)));\n                obj_tlen-=36;\n                obj_tptr+=36;\n                break;\n\n            case RSVP_CTYPE_14: /* IPv6 p2mp LSP Tunnel */\n                if (obj_tlen < 26)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 P2MP LSP ID: 0x%08x, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ip6addr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=26;\n                obj_tptr+=26;\n                break;\n            case RSVP_CTYPE_13: /* IPv4 p2mp LSP Tunnel */\n                if (obj_tlen < 12)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 P2MP LSP ID: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ipaddr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n            case RSVP_CTYPE_UNI_IPV4:\n                if (obj_tlen < 12)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ipaddr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_CONFIRM:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < sizeof(struct in_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Receiver Address: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in_addr);\n                obj_tptr+=sizeof(struct in_addr);\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < sizeof(struct in6_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 Receiver Address: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in6_addr);\n                obj_tptr+=sizeof(struct in6_addr);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_NOTIFY_REQ:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < sizeof(struct in_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Notify Node Address: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in_addr);\n                obj_tptr+=sizeof(struct in_addr);\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < sizeof(struct in6_addr))\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Notify Node Address: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in6_addr);\n                obj_tptr+=sizeof(struct in6_addr);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SUGGESTED_LABEL: /* fall through */\n        case RSVP_OBJ_UPSTREAM_LABEL:  /* fall through */\n        case RSVP_OBJ_RECOVERY_LABEL:  /* fall through */\n        case RSVP_OBJ_LABEL:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                while(obj_tlen >= 4 ) {\n                    ND_PRINT((ndo, \"%s  Label: %u\", ident, EXTRACT_32BITS(obj_tptr)));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Generalized Label: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Waveband ID: %u%s  Start Label: %u, Stop Label: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       ident,\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_STYLE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Reservation Style: %s, Flags: [0x%02x]\",\n                       ident,\n                       tok2str(rsvp_resstyle_values,\n                               \"Unknown\",\n                               EXTRACT_24BITS(obj_tptr+1)),\n                       *(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SENDER_TEMPLATE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_13: /* IPv6 p2mp LSP tunnel */\n                if (obj_tlen < 40)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ident,\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_16BITS(obj_tptr + 38)));\n                obj_tlen-=40;\n                obj_tptr+=40;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_12: /* IPv4 p2mp LSP tunnel */\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ident,\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_16BITS(obj_tptr + 12)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_LABEL_REQ:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                while(obj_tlen >= 4 ) {\n                    ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                           ident,\n                           tok2str(ethertype_values,\n                                   \"Unknown Protocol (0x%04x)\",\n                                   EXTRACT_16BITS(obj_tptr + 2))));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                       ident,\n                       tok2str(ethertype_values,\n                               \"Unknown Protocol (0x%04x)\",\n                               EXTRACT_16BITS(obj_tptr + 2))));\n                ND_PRINT((ndo, \",%s merge capability\",((*(obj_tptr + 4)) & 0x80) ? \"no\" : \"\" ));\n                ND_PRINT((ndo, \"%s  Minimum VPI/VCI: %u/%u\",\n                       ident,\n                       (EXTRACT_16BITS(obj_tptr+4))&0xfff,\n                       (EXTRACT_16BITS(obj_tptr + 6)) & 0xfff));\n                ND_PRINT((ndo, \"%s  Maximum VPI/VCI: %u/%u\",\n                       ident,\n                       (EXTRACT_16BITS(obj_tptr+8))&0xfff,\n                       (EXTRACT_16BITS(obj_tptr + 10)) & 0xfff));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                       ident,\n                       tok2str(ethertype_values,\n                               \"Unknown Protocol (0x%04x)\",\n                               EXTRACT_16BITS(obj_tptr + 2))));\n                ND_PRINT((ndo, \"%s  Minimum/Maximum DLCI: %u/%u, %s%s bit DLCI\",\n                       ident,\n                       (EXTRACT_32BITS(obj_tptr+4))&0x7fffff,\n                       (EXTRACT_32BITS(obj_tptr+8))&0x7fffff,\n                       (((EXTRACT_16BITS(obj_tptr+4)>>7)&3) == 0 ) ? \"10\" : \"\",\n                       (((EXTRACT_16BITS(obj_tptr + 4) >> 7) & 3) == 2 ) ? \"23\" : \"\"));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_4:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  LSP Encoding Type: %s (%u)\",\n                       ident,\n                       tok2str(gmpls_encoding_values,\n                               \"Unknown\",\n                               *obj_tptr),\n\t\t       *obj_tptr));\n                ND_PRINT((ndo, \"%s  Switching Type: %s (%u), Payload ID: %s (0x%04x)\",\n                       ident,\n                       tok2str(gmpls_switch_cap_values,\n                               \"Unknown\",\n                               *(obj_tptr+1)),\n\t\t       *(obj_tptr+1),\n                       tok2str(gmpls_payload_values,\n                               \"Unknown\",\n                               EXTRACT_16BITS(obj_tptr+2)),\n\t\t       EXTRACT_16BITS(obj_tptr + 2)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RRO:\n        case RSVP_OBJ_ERO:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                while(obj_tlen >= 4 ) {\n\t\t    u_char length;\n\n\t\t    ND_TCHECK2(*obj_tptr, 4);\n\t\t    length = *(obj_tptr + 1);\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s, length %u\",\n                           ident,\n                           tok2str(rsvp_obj_xro_values,\n                                   \"Unknown %u\",\n                                   RSVP_OBJ_XRO_MASK_SUBOBJ(*obj_tptr)),\n                           length));\n\n                    if (length == 0) { /* prevent infinite loops */\n                        ND_PRINT((ndo, \"%s  ERROR: zero length ERO subtype\", ident));\n                        break;\n                    }\n\n                    switch(RSVP_OBJ_XRO_MASK_SUBOBJ(*obj_tptr)) {\n\t\t    u_char prefix_length;\n\n                    case RSVP_OBJ_XRO_IPV4:\n\t\t\tif (length != 8) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: length != 8\"));\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tND_TCHECK2(*obj_tptr, 8);\n\t\t\tprefix_length = *(obj_tptr+6);\n\t\t\tif (prefix_length != 32) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: Prefix length %u != 32\",\n\t\t\t\t\t  prefix_length));\n\t\t\t\tgoto invalid;\n\t\t\t}\n                        ND_PRINT((ndo, \", %s, %s/%u, Flags: [%s]\",\n                               RSVP_OBJ_XRO_MASK_LOOSE(*obj_tptr) ? \"Loose\" : \"Strict\",\n                               ipaddr_string(ndo, obj_tptr+2),\n                               *(obj_tptr+6),\n                               bittok2str(rsvp_obj_rro_flag_values,\n                                   \"none\",\n                                   *(obj_tptr + 7)))); /* rfc3209 says that this field is rsvd. */\n                    break;\n                    case RSVP_OBJ_XRO_LABEL:\n\t\t\tif (length != 8) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: length != 8\"));\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tND_TCHECK2(*obj_tptr, 8);\n                        ND_PRINT((ndo, \", Flags: [%s] (%#x), Class-Type: %s (%u), %u\",\n                               bittok2str(rsvp_obj_rro_label_flag_values,\n                                   \"none\",\n                                   *(obj_tptr+2)),\n                               *(obj_tptr+2),\n                               tok2str(rsvp_ctype_values,\n                                       \"Unknown\",\n                                       *(obj_tptr+3) + 256*RSVP_OBJ_RRO),\n                               *(obj_tptr+3),\n                               EXTRACT_32BITS(obj_tptr + 4)));\n                    }\n                    obj_tlen-=*(obj_tptr+1);\n                    obj_tptr+=*(obj_tptr+1);\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_HELLO:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Instance: 0x%08x, Destination Instance: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RESTART_CAPABILITY:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Restart  Time: %ums, Recovery Time: %ums\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SESSION_ATTRIBUTE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 4)\n                    return-1;\n                namelen = *(obj_tptr+3);\n                if (obj_tlen < 4+namelen)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Session Name: \", ident));\n                for (i = 0; i < namelen; i++)\n                    safeputchar(ndo, *(obj_tptr + 4 + i));\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Flags: [%s] (%#x)\",\n                       ident,\n                       (int)*obj_tptr,\n                       (int)*(obj_tptr+1),\n                       bittok2str(rsvp_session_attribute_flag_values,\n                                  \"none\",\n                                  *(obj_tptr+2)),\n                       *(obj_tptr + 2)));\n                obj_tlen-=4+*(obj_tptr+3);\n                obj_tptr+=4+*(obj_tptr+3);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase RSVP_OBJ_GENERALIZED_UNI:\n            switch(rsvp_obj_ctype) {\n\t\tint subobj_type,af,subobj_len,total_subobj_len;\n\n            case RSVP_CTYPE_1:\n\n                if (obj_tlen < 4)\n                    return-1;\n\n\t\t/* read variable length subobjects */\n\t\ttotal_subobj_len = obj_tlen;\n                while(total_subobj_len > 0) {\n                    subobj_len  = EXTRACT_16BITS(obj_tptr);\n                    subobj_type = (EXTRACT_16BITS(obj_tptr+2))>>8;\n                    af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;\n\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s (%u), AF: %s (%u), length: %u\",\n                           ident,\n                           tok2str(rsvp_obj_generalized_uni_values, \"Unknown\", subobj_type),\n",
        "suffix": "                           tok2str(af_values, \"Unknown\", af), af,\n                           subobj_len));\n\n                    if(subobj_len == 0)\n                        goto invalid;\n\n                    switch(subobj_type) {\n                    case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS:\n                    case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS:\n\n                        switch(af) {\n                        case AFNUM_INET:\n                            if (subobj_len < 8)\n                                return -1;\n                            ND_PRINT((ndo, \"%s    UNI IPv4 TNA address: %s\",\n                                   ident, ipaddr_string(ndo, obj_tptr + 4)));\n                            break;\n                        case AFNUM_INET6:\n                            if (subobj_len < 20)\n                                return -1;\n                            ND_PRINT((ndo, \"%s    UNI IPv6 TNA address: %s\",\n                                   ident, ip6addr_string(ndo, obj_tptr + 4)));\n                            break;\n                        case AFNUM_NSAP:\n                            if (subobj_len) {\n                                /* unless we have a TLV parser lets just hexdump */\n                                hexdump=TRUE;\n                            }\n                            break;\n                        }\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_DIVERSITY:\n                        if (subobj_len) {\n                            /* unless we have a TLV parser lets just hexdump */\n                            hexdump=TRUE;\n                        }\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL:\n                        if (subobj_len < 16) {\n                            return -1;\n                        }\n\n                        ND_PRINT((ndo, \"%s    U-bit: %x, Label type: %u, Logical port id: %u, Label: %u\",\n                               ident,\n                               ((EXTRACT_32BITS(obj_tptr+4))>>31),\n                               ((EXTRACT_32BITS(obj_tptr+4))&0xFF),\n                               EXTRACT_32BITS(obj_tptr+8),\n                               EXTRACT_32BITS(obj_tptr + 12)));\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL:\n                        if (subobj_len < 8) {\n                            return -1;\n                        }\n\n                        ND_PRINT((ndo, \"%s    Service level: %u\",\n                               ident, (EXTRACT_32BITS(obj_tptr + 4)) >> 24));\n                        break;\n\n                    default:\n                        hexdump=TRUE;\n                        break;\n                    }\n                    total_subobj_len-=subobj_len;\n                    obj_tptr+=subobj_len;\n                    obj_tlen+=subobj_len;\n\t\t}\n\n                if (total_subobj_len) {\n                    /* unless we have a TLV parser lets just hexdump */\n                    hexdump=TRUE;\n                }\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RSVP_HOP:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_3: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                if (obj_tlen)\n                    hexdump=TRUE; /* unless we have a TLV parser lets just hexdump */\n                break;\n            case RSVP_CTYPE_4: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 16)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                hexdump=TRUE; /* unless we have a TLV parser lets just hexdump */\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_TIME_VALUES:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Refresh Period: %ums\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        /* those three objects do share the same semantics */\n        case RSVP_OBJ_SENDER_TSPEC:\n        case RSVP_OBJ_ADSPEC:\n        case RSVP_OBJ_FLOWSPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Msg-Version: %u, length: %u\",\n                       ident,\n                       (*obj_tptr & 0xf0) >> 4,\n                       EXTRACT_16BITS(obj_tptr + 2) << 2));\n                obj_tptr+=4; /* get to the start of the service header */\n                obj_tlen-=4;\n\n                while (obj_tlen >= 4) {\n                    intserv_serv_tlen=EXTRACT_16BITS(obj_tptr+2)<<2;\n                    ND_PRINT((ndo, \"%s  Service Type: %s (%u), break bit %s set, Service length: %u\",\n                           ident,\n                           tok2str(rsvp_intserv_service_type_values,\"unknown\",*(obj_tptr)),\n                           *(obj_tptr),\n                           (*(obj_tptr+1)&0x80) ? \"\" : \"not\",\n                           intserv_serv_tlen));\n\n                    obj_tptr+=4; /* get to the start of the parameter list */\n                    obj_tlen-=4;\n\n                    while (intserv_serv_tlen>=4) {\n                        processed = rsvp_intserv_print(ndo, obj_tptr, obj_tlen);\n                        if (processed == 0)\n                            break;\n                        obj_tlen-=processed;\n                        intserv_serv_tlen-=processed;\n                        obj_tptr+=processed;\n                    }\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_FILTERSPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Flow Label: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_24BITS(obj_tptr + 17)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_13: /* IPv6 p2mp LSP tunnel */\n                if (obj_tlen < 40)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ident,\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_16BITS(obj_tptr + 38)));\n                obj_tlen-=40;\n                obj_tptr+=40;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_12: /* IPv4 p2mp LSP tunnel */\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ident,\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_16BITS(obj_tptr + 12)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_FASTREROUTE:\n            /* the differences between c-type 1 and 7 are minor */\n            obj_ptr.rsvp_obj_frr = (const struct rsvp_obj_frr_t *)obj_tptr;\n\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1: /* new style */\n                if (obj_tlen < sizeof(struct rsvp_obj_frr_t))\n                    return-1;\n                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps\",\n                       ident,\n                       (int)obj_ptr.rsvp_obj_frr->setup_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hold_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hop_limit,\n                        bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Include-any: 0x%08x, Exclude-any: 0x%08x, Include-all: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->exclude_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_all)));\n                obj_tlen-=sizeof(struct rsvp_obj_frr_t);\n                obj_tptr+=sizeof(struct rsvp_obj_frr_t);\n                break;\n\n            case RSVP_CTYPE_TUNNEL_IPV4: /* old style */\n                if (obj_tlen < 16)\n                    return-1;\n                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps\",\n                       ident,\n                       (int)obj_ptr.rsvp_obj_frr->setup_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hold_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hop_limit,\n                        bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Include Colors: 0x%08x, Exclude Colors: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->exclude_any)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_DETOUR:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                while(obj_tlen >= 8) {\n                    ND_PRINT((ndo, \"%s  PLR-ID: %s, Avoid-Node-ID: %s\",\n                           ident,\n                           ipaddr_string(ndo, obj_tptr),\n                           ipaddr_string(ndo, obj_tptr + 4)));\n                    obj_tlen-=8;\n                    obj_tptr+=8;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_CLASSTYPE:\n        case RSVP_OBJ_CLASSTYPE_OLD: /* fall through */\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                ND_PRINT((ndo, \"%s  CT: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr) & 0x7));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_ERROR_SPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_3: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                error_code=*(obj_tptr+5);\n                error_value=EXTRACT_16BITS(obj_tptr+6);\n                ND_PRINT((ndo, \"%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       *(obj_tptr+4),\n                       ident,\n                       tok2str(rsvp_obj_error_code_values,\"unknown\",error_code),\n                       error_code));\n                switch (error_code) {\n                case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_routing_values,\"unknown\",error_value),\n                           error_value));\n                    break;\n                case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE: /* fall through */\n                case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_diffserv_te_values,\"unknown\",error_value),\n                           error_value));\n                    break;\n                default:\n                    ND_PRINT((ndo, \", Unknown Error Value (%u)\", error_value));\n                    break;\n                }\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_4: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                error_code=*(obj_tptr+17);\n                error_value=EXTRACT_16BITS(obj_tptr+18);\n                ND_PRINT((ndo, \"%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       *(obj_tptr+16),\n                       ident,\n                       tok2str(rsvp_obj_error_code_values,\"unknown\",error_code),\n                       error_code));\n\n                switch (error_code) {\n                case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_routing_values,\"unknown\",error_value),\n\t\t\t   error_value));\n                    break;\n                default:\n                    break;\n                }\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_PROPERTIES:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                padbytes = EXTRACT_16BITS(obj_tptr+2);\n                ND_PRINT((ndo, \"%s  TLV count: %u, padding bytes: %u\",\n                       ident,\n                       EXTRACT_16BITS(obj_tptr),\n                       padbytes));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                /* loop through as long there is anything longer than the TLV header (2) */\n                while(obj_tlen >= 2 + padbytes) {\n                    ND_PRINT((ndo, \"%s    %s TLV (0x%02x), length: %u\", /* length includes header */\n                           ident,\n                           tok2str(rsvp_obj_prop_tlv_values,\"unknown\",*obj_tptr),\n                           *obj_tptr,\n                           *(obj_tptr + 1)));\n                    if (obj_tlen < *(obj_tptr+1))\n                        return-1;\n                    if (*(obj_tptr+1) < 2)\n                        return -1;\n                    print_unknown_data(ndo, obj_tptr + 2, \"\\n\\t\\t\", *(obj_tptr + 1) - 2);\n                    obj_tlen-=*(obj_tptr+1);\n                    obj_tptr+=*(obj_tptr+1);\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_MESSAGE_ID:     /* fall through */\n        case RSVP_OBJ_MESSAGE_ID_ACK: /* fall through */\n        case RSVP_OBJ_MESSAGE_ID_LIST:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Flags [0x%02x], epoch: %u\",\n                       ident,\n                       *obj_tptr,\n                       EXTRACT_24BITS(obj_tptr + 1)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                /* loop through as long there are no messages left */\n                while(obj_tlen >= 4) {\n                    ND_PRINT((ndo, \"%s    Message-ID 0x%08x (%u)\",\n                           ident,\n                           EXTRACT_32BITS(obj_tptr),\n                           EXTRACT_32BITS(obj_tptr)));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_INTEGRITY:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < sizeof(struct rsvp_obj_integrity_t))\n                    return-1;\n                obj_ptr.rsvp_obj_integrity = (const struct rsvp_obj_integrity_t *)obj_tptr;\n                ND_PRINT((ndo, \"%s  Key-ID 0x%04x%08x, Sequence 0x%08x%08x, Flags [%s]\",\n                       ident,\n                       EXTRACT_16BITS(obj_ptr.rsvp_obj_integrity->key_id),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->key_id+2),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->sequence),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->sequence+4),\n                       bittok2str(rsvp_obj_integrity_flag_values,\n                                  \"none\",\n                                  obj_ptr.rsvp_obj_integrity->flags)));\n                ND_PRINT((ndo, \"%s  MD5-sum 0x%08x%08x%08x%08x \",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest+4),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest+8),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest + 12)));\n\n                sigcheck = signature_verify(ndo, pptr, plen,\n                                            obj_ptr.rsvp_obj_integrity->digest,\n                                            rsvp_clear_checksum,\n                                            rsvp_com_header);\n                ND_PRINT((ndo, \" (%s)\", tok2str(signature_check_values, \"Unknown\", sigcheck)));\n\n                obj_tlen+=sizeof(struct rsvp_obj_integrity_t);\n                obj_tptr+=sizeof(struct rsvp_obj_integrity_t);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_ADMIN_STATUS:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Flags [%s]\", ident,\n                       bittok2str(rsvp_obj_admin_status_flag_values, \"none\",\n                                  EXTRACT_32BITS(obj_tptr))));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_LABEL_SET:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                action = (EXTRACT_16BITS(obj_tptr)>>8);\n\n                ND_PRINT((ndo, \"%s  Action: %s (%u), Label type: %u\", ident,\n                       tok2str(rsvp_obj_label_set_action_values, \"Unknown\", action),\n                       action, ((EXTRACT_32BITS(obj_tptr) & 0x7F))));\n\n                switch (action) {\n                case LABEL_SET_INCLUSIVE_RANGE:\n                case LABEL_SET_EXCLUSIVE_RANGE: /* fall through */\n\n\t\t    /* only a couple of subchannels are expected */\n\t\t    if (obj_tlen < 12)\n\t\t\treturn -1;\n\t\t    ND_PRINT((ndo, \"%s  Start range: %u, End range: %u\", ident,\n                           EXTRACT_32BITS(obj_tptr+4),\n                           EXTRACT_32BITS(obj_tptr + 8)));\n\t\t    obj_tlen-=12;\n\t\t    obj_tptr+=12;\n                    break;\n\n                default:\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                    subchannel = 1;\n                    while(obj_tlen >= 4 ) {\n                        ND_PRINT((ndo, \"%s  Subchannel #%u: %u\", ident, subchannel,\n                               EXTRACT_32BITS(obj_tptr)));\n                        obj_tptr+=4;\n                        obj_tlen-=4;\n                        subchannel++;\n                    }\n                    break;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_S2L:\n            switch (rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Sub-LSP destination address: %s\",\n                       ident, ipaddr_string(ndo, obj_tptr)));\n\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Sub-LSP destination address: %s\",\n                       ident, ip6addr_string(ndo, obj_tptr)));\n\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        /*\n         *  FIXME those are the defined objects that lack a decoder\n         *  you are welcome to contribute code ;-)\n         */\n\n        case RSVP_OBJ_SCOPE:\n        case RSVP_OBJ_POLICY_DATA:\n        case RSVP_OBJ_ACCEPT_LABEL_SET:\n        case RSVP_OBJ_PROTECTION:\n        default:\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen); /* FIXME indentation */\n            break;\n        }\n        /* do we also want to see a hex dump ? */\n        if (ndo->ndo_vflag > 1 || hexdump == TRUE)\n            print_unknown_data(ndo, tptr + sizeof(struct rsvp_object_header), \"\\n\\t    \", /* FIXME indentation */\n                               rsvp_obj_len - sizeof(struct rsvp_object_header));\n\n        tptr+=rsvp_obj_len;\n        tlen-=rsvp_obj_len;\n    }\n    return 0;\ninvalid:\n    ND_PRINT((ndo, \"%s\", istr));\n    return -1;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t\\t\"));\n    ND_PRINT((ndo, \"%s\", tstr));\n    return -1;\n}\n",
        "start": 659,
        "end": 1829,
        "buggy": "static int\nrsvp_obj_print(netdissect_options *ndo,\n               const u_char *pptr, u_int plen, const u_char *tptr,\n               const char *ident, u_int tlen,\n               const struct rsvp_common_header *rsvp_com_header)\n{\n    const struct rsvp_object_header *rsvp_obj_header;\n    const u_char *obj_tptr;\n    union {\n        const struct rsvp_obj_integrity_t *rsvp_obj_integrity;\n        const struct rsvp_obj_frr_t *rsvp_obj_frr;\n    } obj_ptr;\n\n    u_short rsvp_obj_len,rsvp_obj_ctype,obj_tlen,intserv_serv_tlen;\n    int hexdump,processed,padbytes,error_code,error_value,i,sigcheck;\n    union {\n\tfloat f;\n\tuint32_t i;\n    } bw;\n    uint8_t namelen;\n\n    u_int action, subchannel;\n\n    while(tlen>=sizeof(struct rsvp_object_header)) {\n        /* did we capture enough for fully decoding the object header ? */\n        ND_TCHECK2(*tptr, sizeof(struct rsvp_object_header));\n\n        rsvp_obj_header = (const struct rsvp_object_header *)tptr;\n        rsvp_obj_len=EXTRACT_16BITS(rsvp_obj_header->length);\n        rsvp_obj_ctype=rsvp_obj_header->ctype;\n\n        if(rsvp_obj_len % 4) {\n            ND_PRINT((ndo, \"%sERROR: object header size %u not a multiple of 4\", ident, rsvp_obj_len));\n            return -1;\n        }\n        if(rsvp_obj_len < sizeof(struct rsvp_object_header)) {\n            ND_PRINT((ndo, \"%sERROR: object header too short %u < %lu\", ident, rsvp_obj_len,\n                   (unsigned long)sizeof(const struct rsvp_object_header)));\n            return -1;\n        }\n\n        ND_PRINT((ndo, \"%s%s Object (%u) Flags: [%s\",\n               ident,\n               tok2str(rsvp_obj_values,\n                       \"Unknown\",\n                       rsvp_obj_header->class_num),\n               rsvp_obj_header->class_num,\n               ((rsvp_obj_header->class_num) & 0x80) ? \"ignore\" : \"reject\"));\n\n        if (rsvp_obj_header->class_num > 128)\n            ND_PRINT((ndo, \" %s\",\n                   ((rsvp_obj_header->class_num) & 0x40) ? \"and forward\" : \"silently\"));\n\n        ND_PRINT((ndo, \" if unknown], Class-Type: %s (%u), length: %u\",\n               tok2str(rsvp_ctype_values,\n                       \"Unknown\",\n                       ((rsvp_obj_header->class_num)<<8)+rsvp_obj_ctype),\n               rsvp_obj_ctype,\n               rsvp_obj_len));\n\n        if(tlen < rsvp_obj_len) {\n            ND_PRINT((ndo, \"%sERROR: object goes past end of objects TLV\", ident));\n            return -1;\n        }\n\n        obj_tptr=tptr+sizeof(struct rsvp_object_header);\n        obj_tlen=rsvp_obj_len-sizeof(struct rsvp_object_header);\n\n        /* did we capture enough for fully decoding the object ? */\n        if (!ND_TTEST2(*tptr, rsvp_obj_len))\n            return -1;\n        hexdump=FALSE;\n\n        switch(rsvp_obj_header->class_num) {\n        case RSVP_OBJ_SESSION:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 DestAddress: %s, Protocol ID: 0x%02x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       *(obj_tptr + sizeof(struct in_addr))));\n                ND_PRINT((ndo, \"%s  Flags: [0x%02x], DestPort %u\",\n                       ident,\n                       *(obj_tptr+5),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 DestAddress: %s, Protocol ID: 0x%02x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       *(obj_tptr + sizeof(struct in6_addr))));\n                ND_PRINT((ndo, \"%s  Flags: [0x%02x], DestPort %u\",\n                       ident,\n                       *(obj_tptr+sizeof(struct in6_addr)+1),\n                       EXTRACT_16BITS(obj_tptr + sizeof(struct in6_addr) + 2)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n\n            case RSVP_CTYPE_TUNNEL_IPV6:\n                if (obj_tlen < 36)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ip6addr_string(ndo, obj_tptr + 20)));\n                obj_tlen-=36;\n                obj_tptr+=36;\n                break;\n\n            case RSVP_CTYPE_14: /* IPv6 p2mp LSP Tunnel */\n                if (obj_tlen < 26)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 P2MP LSP ID: 0x%08x, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ip6addr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=26;\n                obj_tptr+=26;\n                break;\n            case RSVP_CTYPE_13: /* IPv4 p2mp LSP Tunnel */\n                if (obj_tlen < 12)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 P2MP LSP ID: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ipaddr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n            case RSVP_CTYPE_UNI_IPV4:\n                if (obj_tlen < 12)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ipaddr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_CONFIRM:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < sizeof(struct in_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Receiver Address: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in_addr);\n                obj_tptr+=sizeof(struct in_addr);\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < sizeof(struct in6_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 Receiver Address: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in6_addr);\n                obj_tptr+=sizeof(struct in6_addr);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_NOTIFY_REQ:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < sizeof(struct in_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Notify Node Address: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in_addr);\n                obj_tptr+=sizeof(struct in_addr);\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < sizeof(struct in6_addr))\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Notify Node Address: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in6_addr);\n                obj_tptr+=sizeof(struct in6_addr);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SUGGESTED_LABEL: /* fall through */\n        case RSVP_OBJ_UPSTREAM_LABEL:  /* fall through */\n        case RSVP_OBJ_RECOVERY_LABEL:  /* fall through */\n        case RSVP_OBJ_LABEL:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                while(obj_tlen >= 4 ) {\n                    ND_PRINT((ndo, \"%s  Label: %u\", ident, EXTRACT_32BITS(obj_tptr)));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Generalized Label: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Waveband ID: %u%s  Start Label: %u, Stop Label: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       ident,\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_STYLE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Reservation Style: %s, Flags: [0x%02x]\",\n                       ident,\n                       tok2str(rsvp_resstyle_values,\n                               \"Unknown\",\n                               EXTRACT_24BITS(obj_tptr+1)),\n                       *(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SENDER_TEMPLATE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_13: /* IPv6 p2mp LSP tunnel */\n                if (obj_tlen < 40)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ident,\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_16BITS(obj_tptr + 38)));\n                obj_tlen-=40;\n                obj_tptr+=40;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_12: /* IPv4 p2mp LSP tunnel */\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ident,\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_16BITS(obj_tptr + 12)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_LABEL_REQ:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                while(obj_tlen >= 4 ) {\n                    ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                           ident,\n                           tok2str(ethertype_values,\n                                   \"Unknown Protocol (0x%04x)\",\n                                   EXTRACT_16BITS(obj_tptr + 2))));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                       ident,\n                       tok2str(ethertype_values,\n                               \"Unknown Protocol (0x%04x)\",\n                               EXTRACT_16BITS(obj_tptr + 2))));\n                ND_PRINT((ndo, \",%s merge capability\",((*(obj_tptr + 4)) & 0x80) ? \"no\" : \"\" ));\n                ND_PRINT((ndo, \"%s  Minimum VPI/VCI: %u/%u\",\n                       ident,\n                       (EXTRACT_16BITS(obj_tptr+4))&0xfff,\n                       (EXTRACT_16BITS(obj_tptr + 6)) & 0xfff));\n                ND_PRINT((ndo, \"%s  Maximum VPI/VCI: %u/%u\",\n                       ident,\n                       (EXTRACT_16BITS(obj_tptr+8))&0xfff,\n                       (EXTRACT_16BITS(obj_tptr + 10)) & 0xfff));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                       ident,\n                       tok2str(ethertype_values,\n                               \"Unknown Protocol (0x%04x)\",\n                               EXTRACT_16BITS(obj_tptr + 2))));\n                ND_PRINT((ndo, \"%s  Minimum/Maximum DLCI: %u/%u, %s%s bit DLCI\",\n                       ident,\n                       (EXTRACT_32BITS(obj_tptr+4))&0x7fffff,\n                       (EXTRACT_32BITS(obj_tptr+8))&0x7fffff,\n                       (((EXTRACT_16BITS(obj_tptr+4)>>7)&3) == 0 ) ? \"10\" : \"\",\n                       (((EXTRACT_16BITS(obj_tptr + 4) >> 7) & 3) == 2 ) ? \"23\" : \"\"));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_4:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  LSP Encoding Type: %s (%u)\",\n                       ident,\n                       tok2str(gmpls_encoding_values,\n                               \"Unknown\",\n                               *obj_tptr),\n\t\t       *obj_tptr));\n                ND_PRINT((ndo, \"%s  Switching Type: %s (%u), Payload ID: %s (0x%04x)\",\n                       ident,\n                       tok2str(gmpls_switch_cap_values,\n                               \"Unknown\",\n                               *(obj_tptr+1)),\n\t\t       *(obj_tptr+1),\n                       tok2str(gmpls_payload_values,\n                               \"Unknown\",\n                               EXTRACT_16BITS(obj_tptr+2)),\n\t\t       EXTRACT_16BITS(obj_tptr + 2)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RRO:\n        case RSVP_OBJ_ERO:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                while(obj_tlen >= 4 ) {\n\t\t    u_char length;\n\n\t\t    ND_TCHECK2(*obj_tptr, 4);\n\t\t    length = *(obj_tptr + 1);\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s, length %u\",\n                           ident,\n                           tok2str(rsvp_obj_xro_values,\n                                   \"Unknown %u\",\n                                   RSVP_OBJ_XRO_MASK_SUBOBJ(*obj_tptr)),\n                           length));\n\n                    if (length == 0) { /* prevent infinite loops */\n                        ND_PRINT((ndo, \"%s  ERROR: zero length ERO subtype\", ident));\n                        break;\n                    }\n\n                    switch(RSVP_OBJ_XRO_MASK_SUBOBJ(*obj_tptr)) {\n\t\t    u_char prefix_length;\n\n                    case RSVP_OBJ_XRO_IPV4:\n\t\t\tif (length != 8) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: length != 8\"));\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tND_TCHECK2(*obj_tptr, 8);\n\t\t\tprefix_length = *(obj_tptr+6);\n\t\t\tif (prefix_length != 32) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: Prefix length %u != 32\",\n\t\t\t\t\t  prefix_length));\n\t\t\t\tgoto invalid;\n\t\t\t}\n                        ND_PRINT((ndo, \", %s, %s/%u, Flags: [%s]\",\n                               RSVP_OBJ_XRO_MASK_LOOSE(*obj_tptr) ? \"Loose\" : \"Strict\",\n                               ipaddr_string(ndo, obj_tptr+2),\n                               *(obj_tptr+6),\n                               bittok2str(rsvp_obj_rro_flag_values,\n                                   \"none\",\n                                   *(obj_tptr + 7)))); /* rfc3209 says that this field is rsvd. */\n                    break;\n                    case RSVP_OBJ_XRO_LABEL:\n\t\t\tif (length != 8) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: length != 8\"));\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tND_TCHECK2(*obj_tptr, 8);\n                        ND_PRINT((ndo, \", Flags: [%s] (%#x), Class-Type: %s (%u), %u\",\n                               bittok2str(rsvp_obj_rro_label_flag_values,\n                                   \"none\",\n                                   *(obj_tptr+2)),\n                               *(obj_tptr+2),\n                               tok2str(rsvp_ctype_values,\n                                       \"Unknown\",\n                                       *(obj_tptr+3) + 256*RSVP_OBJ_RRO),\n                               *(obj_tptr+3),\n                               EXTRACT_32BITS(obj_tptr + 4)));\n                    }\n                    obj_tlen-=*(obj_tptr+1);\n                    obj_tptr+=*(obj_tptr+1);\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_HELLO:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Instance: 0x%08x, Destination Instance: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RESTART_CAPABILITY:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Restart  Time: %ums, Recovery Time: %ums\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SESSION_ATTRIBUTE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 4)\n                    return-1;\n                namelen = *(obj_tptr+3);\n                if (obj_tlen < 4+namelen)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Session Name: \", ident));\n                for (i = 0; i < namelen; i++)\n                    safeputchar(ndo, *(obj_tptr + 4 + i));\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Flags: [%s] (%#x)\",\n                       ident,\n                       (int)*obj_tptr,\n                       (int)*(obj_tptr+1),\n                       bittok2str(rsvp_session_attribute_flag_values,\n                                  \"none\",\n                                  *(obj_tptr+2)),\n                       *(obj_tptr + 2)));\n                obj_tlen-=4+*(obj_tptr+3);\n                obj_tptr+=4+*(obj_tptr+3);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase RSVP_OBJ_GENERALIZED_UNI:\n            switch(rsvp_obj_ctype) {\n\t\tint subobj_type,af,subobj_len,total_subobj_len;\n\n            case RSVP_CTYPE_1:\n\n                if (obj_tlen < 4)\n                    return-1;\n\n\t\t/* read variable length subobjects */\n\t\ttotal_subobj_len = obj_tlen;\n                while(total_subobj_len > 0) {\n                    subobj_len  = EXTRACT_16BITS(obj_tptr);\n                    subobj_type = (EXTRACT_16BITS(obj_tptr+2))>>8;\n                    af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;\n\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s (%u), AF: %s (%u), length: %u\",\n                           ident,\n                           tok2str(rsvp_obj_generalized_uni_values, \"Unknown\", subobj_type),\n                           subobj_type,\n                           tok2str(af_values, \"Unknown\", af), af,\n                           subobj_len));\n\n                    if(subobj_len == 0)\n                        goto invalid;\n\n                    switch(subobj_type) {\n                    case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS:\n                    case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS:\n\n                        switch(af) {\n                        case AFNUM_INET:\n                            if (subobj_len < 8)\n                                return -1;\n                            ND_PRINT((ndo, \"%s    UNI IPv4 TNA address: %s\",\n                                   ident, ipaddr_string(ndo, obj_tptr + 4)));\n                            break;\n                        case AFNUM_INET6:\n                            if (subobj_len < 20)\n                                return -1;\n                            ND_PRINT((ndo, \"%s    UNI IPv6 TNA address: %s\",\n                                   ident, ip6addr_string(ndo, obj_tptr + 4)));\n                            break;\n                        case AFNUM_NSAP:\n                            if (subobj_len) {\n                                /* unless we have a TLV parser lets just hexdump */\n                                hexdump=TRUE;\n                            }\n                            break;\n                        }\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_DIVERSITY:\n                        if (subobj_len) {\n                            /* unless we have a TLV parser lets just hexdump */\n                            hexdump=TRUE;\n                        }\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL:\n                        if (subobj_len < 16) {\n                            return -1;\n                        }\n\n                        ND_PRINT((ndo, \"%s    U-bit: %x, Label type: %u, Logical port id: %u, Label: %u\",\n                               ident,\n                               ((EXTRACT_32BITS(obj_tptr+4))>>31),\n                               ((EXTRACT_32BITS(obj_tptr+4))&0xFF),\n                               EXTRACT_32BITS(obj_tptr+8),\n                               EXTRACT_32BITS(obj_tptr + 12)));\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL:\n                        if (subobj_len < 8) {\n                            return -1;\n                        }\n\n                        ND_PRINT((ndo, \"%s    Service level: %u\",\n                               ident, (EXTRACT_32BITS(obj_tptr + 4)) >> 24));\n                        break;\n\n                    default:\n                        hexdump=TRUE;\n                        break;\n                    }\n                    total_subobj_len-=subobj_len;\n                    obj_tptr+=subobj_len;\n                    obj_tlen+=subobj_len;\n\t\t}\n\n                if (total_subobj_len) {\n                    /* unless we have a TLV parser lets just hexdump */\n                    hexdump=TRUE;\n                }\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RSVP_HOP:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_3: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                if (obj_tlen)\n                    hexdump=TRUE; /* unless we have a TLV parser lets just hexdump */\n                break;\n            case RSVP_CTYPE_4: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 16)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                hexdump=TRUE; /* unless we have a TLV parser lets just hexdump */\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_TIME_VALUES:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Refresh Period: %ums\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        /* those three objects do share the same semantics */\n        case RSVP_OBJ_SENDER_TSPEC:\n        case RSVP_OBJ_ADSPEC:\n        case RSVP_OBJ_FLOWSPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Msg-Version: %u, length: %u\",\n                       ident,\n                       (*obj_tptr & 0xf0) >> 4,\n                       EXTRACT_16BITS(obj_tptr + 2) << 2));\n                obj_tptr+=4; /* get to the start of the service header */\n                obj_tlen-=4;\n\n                while (obj_tlen >= 4) {\n                    intserv_serv_tlen=EXTRACT_16BITS(obj_tptr+2)<<2;\n                    ND_PRINT((ndo, \"%s  Service Type: %s (%u), break bit %s set, Service length: %u\",\n                           ident,\n                           tok2str(rsvp_intserv_service_type_values,\"unknown\",*(obj_tptr)),\n                           *(obj_tptr),\n                           (*(obj_tptr+1)&0x80) ? \"\" : \"not\",\n                           intserv_serv_tlen));\n\n                    obj_tptr+=4; /* get to the start of the parameter list */\n                    obj_tlen-=4;\n\n                    while (intserv_serv_tlen>=4) {\n                        processed = rsvp_intserv_print(ndo, obj_tptr, obj_tlen);\n                        if (processed == 0)\n                            break;\n                        obj_tlen-=processed;\n                        intserv_serv_tlen-=processed;\n                        obj_tptr+=processed;\n                    }\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_FILTERSPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Flow Label: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_24BITS(obj_tptr + 17)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_13: /* IPv6 p2mp LSP tunnel */\n                if (obj_tlen < 40)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ident,\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_16BITS(obj_tptr + 38)));\n                obj_tlen-=40;\n                obj_tptr+=40;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_12: /* IPv4 p2mp LSP tunnel */\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ident,\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_16BITS(obj_tptr + 12)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_FASTREROUTE:\n            /* the differences between c-type 1 and 7 are minor */\n            obj_ptr.rsvp_obj_frr = (const struct rsvp_obj_frr_t *)obj_tptr;\n\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1: /* new style */\n                if (obj_tlen < sizeof(struct rsvp_obj_frr_t))\n                    return-1;\n                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps\",\n                       ident,\n                       (int)obj_ptr.rsvp_obj_frr->setup_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hold_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hop_limit,\n                        bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Include-any: 0x%08x, Exclude-any: 0x%08x, Include-all: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->exclude_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_all)));\n                obj_tlen-=sizeof(struct rsvp_obj_frr_t);\n                obj_tptr+=sizeof(struct rsvp_obj_frr_t);\n                break;\n\n            case RSVP_CTYPE_TUNNEL_IPV4: /* old style */\n                if (obj_tlen < 16)\n                    return-1;\n                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps\",\n                       ident,\n                       (int)obj_ptr.rsvp_obj_frr->setup_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hold_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hop_limit,\n                        bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Include Colors: 0x%08x, Exclude Colors: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->exclude_any)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_DETOUR:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                while(obj_tlen >= 8) {\n                    ND_PRINT((ndo, \"%s  PLR-ID: %s, Avoid-Node-ID: %s\",\n                           ident,\n                           ipaddr_string(ndo, obj_tptr),\n                           ipaddr_string(ndo, obj_tptr + 4)));\n                    obj_tlen-=8;\n                    obj_tptr+=8;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_CLASSTYPE:\n        case RSVP_OBJ_CLASSTYPE_OLD: /* fall through */\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                ND_PRINT((ndo, \"%s  CT: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr) & 0x7));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_ERROR_SPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_3: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                error_code=*(obj_tptr+5);\n                error_value=EXTRACT_16BITS(obj_tptr+6);\n                ND_PRINT((ndo, \"%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       *(obj_tptr+4),\n                       ident,\n                       tok2str(rsvp_obj_error_code_values,\"unknown\",error_code),\n                       error_code));\n                switch (error_code) {\n                case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_routing_values,\"unknown\",error_value),\n                           error_value));\n                    break;\n                case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE: /* fall through */\n                case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_diffserv_te_values,\"unknown\",error_value),\n                           error_value));\n                    break;\n                default:\n                    ND_PRINT((ndo, \", Unknown Error Value (%u)\", error_value));\n                    break;\n                }\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_4: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                error_code=*(obj_tptr+17);\n                error_value=EXTRACT_16BITS(obj_tptr+18);\n                ND_PRINT((ndo, \"%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       *(obj_tptr+16),\n                       ident,\n                       tok2str(rsvp_obj_error_code_values,\"unknown\",error_code),\n                       error_code));\n\n                switch (error_code) {\n                case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_routing_values,\"unknown\",error_value),\n\t\t\t   error_value));\n                    break;\n                default:\n                    break;\n                }\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_PROPERTIES:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                padbytes = EXTRACT_16BITS(obj_tptr+2);\n                ND_PRINT((ndo, \"%s  TLV count: %u, padding bytes: %u\",\n                       ident,\n                       EXTRACT_16BITS(obj_tptr),\n                       padbytes));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                /* loop through as long there is anything longer than the TLV header (2) */\n                while(obj_tlen >= 2 + padbytes) {\n                    ND_PRINT((ndo, \"%s    %s TLV (0x%02x), length: %u\", /* length includes header */\n                           ident,\n                           tok2str(rsvp_obj_prop_tlv_values,\"unknown\",*obj_tptr),\n                           *obj_tptr,\n                           *(obj_tptr + 1)));\n                    if (obj_tlen < *(obj_tptr+1))\n                        return-1;\n                    if (*(obj_tptr+1) < 2)\n                        return -1;\n                    print_unknown_data(ndo, obj_tptr + 2, \"\\n\\t\\t\", *(obj_tptr + 1) - 2);\n                    obj_tlen-=*(obj_tptr+1);\n                    obj_tptr+=*(obj_tptr+1);\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_MESSAGE_ID:     /* fall through */\n        case RSVP_OBJ_MESSAGE_ID_ACK: /* fall through */\n        case RSVP_OBJ_MESSAGE_ID_LIST:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Flags [0x%02x], epoch: %u\",\n                       ident,\n                       *obj_tptr,\n                       EXTRACT_24BITS(obj_tptr + 1)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                /* loop through as long there are no messages left */\n                while(obj_tlen >= 4) {\n                    ND_PRINT((ndo, \"%s    Message-ID 0x%08x (%u)\",\n                           ident,\n                           EXTRACT_32BITS(obj_tptr),\n                           EXTRACT_32BITS(obj_tptr)));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_INTEGRITY:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < sizeof(struct rsvp_obj_integrity_t))\n                    return-1;\n                obj_ptr.rsvp_obj_integrity = (const struct rsvp_obj_integrity_t *)obj_tptr;\n                ND_PRINT((ndo, \"%s  Key-ID 0x%04x%08x, Sequence 0x%08x%08x, Flags [%s]\",\n                       ident,\n                       EXTRACT_16BITS(obj_ptr.rsvp_obj_integrity->key_id),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->key_id+2),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->sequence),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->sequence+4),\n                       bittok2str(rsvp_obj_integrity_flag_values,\n                                  \"none\",\n                                  obj_ptr.rsvp_obj_integrity->flags)));\n                ND_PRINT((ndo, \"%s  MD5-sum 0x%08x%08x%08x%08x \",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest+4),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest+8),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest + 12)));\n\n                sigcheck = signature_verify(ndo, pptr, plen,\n                                            obj_ptr.rsvp_obj_integrity->digest,\n                                            rsvp_clear_checksum,\n                                            rsvp_com_header);\n                ND_PRINT((ndo, \" (%s)\", tok2str(signature_check_values, \"Unknown\", sigcheck)));\n\n                obj_tlen+=sizeof(struct rsvp_obj_integrity_t);\n                obj_tptr+=sizeof(struct rsvp_obj_integrity_t);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_ADMIN_STATUS:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Flags [%s]\", ident,\n                       bittok2str(rsvp_obj_admin_status_flag_values, \"none\",\n                                  EXTRACT_32BITS(obj_tptr))));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_LABEL_SET:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                action = (EXTRACT_16BITS(obj_tptr)>>8);\n\n                ND_PRINT((ndo, \"%s  Action: %s (%u), Label type: %u\", ident,\n                       tok2str(rsvp_obj_label_set_action_values, \"Unknown\", action),\n                       action, ((EXTRACT_32BITS(obj_tptr) & 0x7F))));\n\n                switch (action) {\n                case LABEL_SET_INCLUSIVE_RANGE:\n                case LABEL_SET_EXCLUSIVE_RANGE: /* fall through */\n\n\t\t    /* only a couple of subchannels are expected */\n\t\t    if (obj_tlen < 12)\n\t\t\treturn -1;\n\t\t    ND_PRINT((ndo, \"%s  Start range: %u, End range: %u\", ident,\n                           EXTRACT_32BITS(obj_tptr+4),\n                           EXTRACT_32BITS(obj_tptr + 8)));\n\t\t    obj_tlen-=12;\n\t\t    obj_tptr+=12;\n                    break;\n\n                default:\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                    subchannel = 1;\n                    while(obj_tlen >= 4 ) {\n                        ND_PRINT((ndo, \"%s  Subchannel #%u: %u\", ident, subchannel,\n                               EXTRACT_32BITS(obj_tptr)));\n                        obj_tptr+=4;\n                        obj_tlen-=4;\n                        subchannel++;\n                    }\n                    break;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_S2L:\n            switch (rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Sub-LSP destination address: %s\",\n                       ident, ipaddr_string(ndo, obj_tptr)));\n\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Sub-LSP destination address: %s\",\n                       ident, ip6addr_string(ndo, obj_tptr)));\n\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        /*\n         *  FIXME those are the defined objects that lack a decoder\n         *  you are welcome to contribute code ;-)\n         */\n\n        case RSVP_OBJ_SCOPE:\n        case RSVP_OBJ_POLICY_DATA:\n        case RSVP_OBJ_ACCEPT_LABEL_SET:\n        case RSVP_OBJ_PROTECTION:\n        default:\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen); /* FIXME indentation */\n            break;\n        }\n        /* do we also want to see a hex dump ? */\n        if (ndo->ndo_vflag > 1 || hexdump == TRUE)\n            print_unknown_data(ndo, tptr + sizeof(struct rsvp_object_header), \"\\n\\t    \", /* FIXME indentation */\n                               rsvp_obj_len - sizeof(struct rsvp_object_header));\n\n        tptr+=rsvp_obj_len;\n        tlen-=rsvp_obj_len;\n    }\n    return 0;\ninvalid:\n    ND_PRINT((ndo, \"%s\", istr));\n    return -1;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t\\t\"));\n    ND_PRINT((ndo, \"%s\", tstr));\n    return -1;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                           subobj_type,\n",
        "src_path": "289c672020280529fd382f3502efab7100d638ec___print-rsvp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/289c672020280529fd382f3502efab7100d638ec",
        "commit_msg": "CVE-2017-13051/RSVP: fix bounds checks for UNI\n\nFixup the part of rsvp_obj_print() that decodes the GENERALIZED_UNI\nobject from RFC 3476 Section 3.1 to check the sub-objects inside that\nobject more thoroughly.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -567,6 +567,9 @@ bgp_pmsi_tunnel-oobr\tbgp_pmsi_tunnel-oobr.pcap\tbgp_pmsi_tunnel-oobr.out -v -c1\n bgp_mvpn_6_and_7\tbgp_mvpn_6_and_7.pcap\t\tbgp_mvpn_6_and_7.out\t-v -c1\n rsvp_fast_reroute-oobr\trsvp_fast_reroute-oobr.pcap\trsvp_fast_reroute-oobr.out -v -c1\n esis_opt_prot-oobr\tesis_opt_prot-oobr.pcap\t\tesis_opt_prot-oobr.out\t-v -c1\n+rsvp_uni-oobr-1\trsvp_uni-oobr-1.pcap\trsvp_uni-oobr-1.out\t-v -c1\n+rsvp_uni-oobr-2\trsvp_uni-oobr-2.pcap\trsvp_uni-oobr-2.out\t-v -c1\n+rsvp_uni-oobr-3\trsvp_uni-oobr-3.pcap\trsvp_uni-oobr-3.out\t-v -c3\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/rsvp_uni-oobr-1.out",
                "patch": "@@ -0,0 +1,5 @@\n+IP (tos 0x2,ECT(0), ttl 248, id 0, offset 0, flags [none], proto RSVP (46), length 54312, bad cksum 3743 (->7e72)!)\n+    54.35.0.0 > 58.16.0.0: \n+\tRSVPv1 Hello Message (20), Flags: [Refresh reduction capable], length: 65527, ttl: 15, checksum: 0x0902\n+\t  Generalized UNI Object (229) Flags: [ignore and forward if unknown], Class-Type: 1 (1), length: 12\n+\t    Subobject Type: Unknown (127), AF: HDLC (4), length: 2 (invalid)"
            },
            {
                "fn": "tests/rsvp_uni-oobr-2.out",
                "patch": "@@ -0,0 +1,5 @@\n+IP (tos 0x2,ECT(0), ttl 248, id 0, offset 0, flags [none], proto RSVP (46), length 54312, bad cksum 3743 (->3051)!)\n+    54.35.78.33 > 58.16.0.0: \n+\tRSVPv1 Hello Message (20), Flags: [Refresh reduction capable], length: 65527, ttl: 15, checksum: 0x0902\n+\t  Generalized UNI Object (229) Flags: [ignore and forward if unknown], Class-Type: 1 (1), length: 12\n+\t    Subobject Type: Unknown (0), AF: HDLC (4), length: 2 (invalid)"
            },
            {
                "fn": "tests/rsvp_uni-oobr-3.out",
                "patch": "@@ -0,0 +1,12 @@\n+IP (tos 0x0, ttl 48, id 25615, offset 0, flags [+, DF, rsvd], proto UDP (17), length 61735, bad cksum 8ef1 (->10e1)!)\n+    1.2.3.3.1812 > 64.112.0.96.4567:  wb-29!\n+IP (tos 0x2,ECT(0), ttl 248, id 0, offset 0, flags [none], proto RSVP (46), length 54312, bad cksum 3701 (->8972)!)\n+    54.35.0.0 > 47.16.0.0: \n+\tRSVPv1 Hello Message (20), Flags: [Refresh reduction capable], length: 65527, ttl: 15, checksum: 0x0902\n+\t  Generalized UNI Object (229) Flags: [ignore and forward if unknown], Class-Type: 1 (1), length: 12\n+\t    Subobject Type: Unknown (0), AF: HDLC (4), length: 1 (invalid)\n+IP (tos 0x2,ECT(0), ttl 248, id 0, offset 0, flags [none], proto RSVP (46), length 54312, bad cksum 3701 (->7e72)!)\n+    54.35.0.0 > 58.16.0.0: \n+\tRSVPv1 Hello Message (20), Flags: [Refresh reduction capable], length: 65527, ttl: 15, checksum: 0x0902\n+\t  Generalized UNI Object (229) Flags: [ignore and forward if unknown], Class-Type: 1 (1), length: 12\n+\t    Subobject Type: Unknown (225), AF: HDLC (4), length: 1 (invalid)"
            }
        ],
        "error_msg": "    rsvp_uni-oobr-1                    : TEST FAILED(exit 256)\n    rsvp_uni-oobr-2                    : TEST FAILED(exit 256)\n    rsvp_uni-oobr-3                    : TEST FAILED(exit 256)\n"
    },
    "5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e___print-isoclns.c": {
        "prefix": "static int\nisis_print_is_reach_subtlv(netdissect_options *ndo,\n                           const uint8_t *tptr, u_int subt, u_int subl,\n                           const char *ident)\n{\n        u_int te_class,priority_level,gmpls_switch_cap;\n        union { /* int to float conversion buffer for several subTLVs */\n            float f;\n            uint32_t i;\n        } bw;\n\n        /* first lets see if we know the subTLVs name*/\n\tND_PRINT((ndo, \"%s%s subTLV #%u, length: %u\",\n\t          ident, tok2str(isis_ext_is_reach_subtlv_values, \"unknown\", subt),\n\t          subt, subl));\n\n\tND_TCHECK2(*tptr, subl);\n\n        switch(subt) {\n        case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP:\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID:\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID:\n\t    if (subl >= 4) {\n\t      ND_PRINT((ndo, \", 0x%08x\", EXTRACT_32BITS(tptr)));\n\t      if (subl == 8) /* rfc4205 */\n\t        ND_PRINT((ndo, \", 0x%08x\", EXTRACT_32BITS(tptr+4)));\n\t    }\n\t    break;\n        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR:\n        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR:\n            if (subl >= sizeof(struct in_addr))\n              ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr)));\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW :\n\tcase ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW:\n            if (subl >= 4) {\n              bw.i = EXTRACT_32BITS(tptr);\n              ND_PRINT((ndo, \", %.3f Mbps\", bw.f * 8 / 1000000));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW :\n            if (subl >= 32) {\n              for (te_class = 0; te_class < 8; te_class++) {\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  TE-Class %u: %.3f Mbps\",\n                       ident,\n                       te_class,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n\t      }\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS: /* fall through */\n        case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD:\n            ND_PRINT((ndo, \"%sBandwidth Constraints Model ID: %s (%u)\",\n                   ident,\n                   tok2str(diffserv_te_bc_values, \"unknown\", *tptr),\n                   *tptr));\n            tptr++;\n            /* decode BCs until the subTLV ends */\n            for (te_class = 0; te_class < (subl-1)/4; te_class++) {\n",
        "suffix": "                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Bandwidth constraint CT%u: %.3f Mbps\",\n                       ident,\n                       te_class,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC:\n            if (subl >= 3)\n              ND_PRINT((ndo, \", %u\", EXTRACT_24BITS(tptr)));\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE:\n            if (subl == 2) {\n               ND_PRINT((ndo, \", [ %s ] (0x%04x)\",\n                      bittok2str(isis_subtlv_link_attribute_values,\n                                 \"Unknown\",\n                                 EXTRACT_16BITS(tptr)),\n                      EXTRACT_16BITS(tptr)));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE:\n            if (subl >= 2) {\n              ND_PRINT((ndo, \", %s, Priority %u\",\n\t\t   bittok2str(gmpls_link_prot_values, \"none\", *tptr),\n                   *(tptr+1)));\n            }\n            break;\n        case ISIS_SUBTLV_SPB_METRIC:\n            if (subl >= 6) {\n              ND_PRINT((ndo, \", LM: %u\", EXTRACT_24BITS(tptr)));\n              tptr=tptr+3;\n              ND_PRINT((ndo, \", P: %u\", *(tptr)));\n              tptr++;\n              ND_PRINT((ndo, \", P-ID: %u\", EXTRACT_16BITS(tptr)));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR:\n            if (subl >= 36) {\n              gmpls_switch_cap = *tptr;\n              ND_PRINT((ndo, \"%s  Interface Switching Capability:%s\",\n                   ident,\n                   tok2str(gmpls_switch_cap_values, \"Unknown\", gmpls_switch_cap)));\n              ND_PRINT((ndo, \", LSP Encoding: %s\",\n                   tok2str(gmpls_encoding_values, \"Unknown\", *(tptr + 1))));\n\t      tptr+=4;\n              ND_PRINT((ndo, \"%s  Max LSP Bandwidth:\", ident));\n              for (priority_level = 0; priority_level < 8; priority_level++) {\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s    priority level %d: %.3f Mbps\",\n                       ident,\n                       priority_level,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n              }\n              subl-=36;\n              switch (gmpls_switch_cap) {\n              case GMPLS_PSC1:\n              case GMPLS_PSC2:\n              case GMPLS_PSC3:\n              case GMPLS_PSC4:\n                ND_TCHECK2(*tptr, 6);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Min LSP Bandwidth: %.3f Mbps\", ident, bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Interface MTU: %u\", ident, EXTRACT_16BITS(tptr + 4)));\n                break;\n              case GMPLS_TSC:\n                ND_TCHECK2(*tptr, 8);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Min LSP Bandwidth: %.3f Mbps\", ident, bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Indication %s\", ident,\n                       tok2str(gmpls_switch_cap_tsc_indication_values, \"Unknown (%u)\", *(tptr + 4))));\n                break;\n              default:\n                /* there is some optional stuff left to decode but this is as of yet\n                   not specified so just lets hexdump what is left */\n                if(subl>0){\n                  if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t    \", subl))\n                    return(0);\n                }\n              }\n            }\n            break;\n        default:\n            if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t    \", subl))\n                return(0);\n            break;\n        }\n        return(1);\n\ntrunc:\n    return(0);\n}\n",
        "start": 1810,
        "end": 1964,
        "buggy": "static int\nisis_print_is_reach_subtlv(netdissect_options *ndo,\n                           const uint8_t *tptr, u_int subt, u_int subl,\n                           const char *ident)\n{\n        u_int te_class,priority_level,gmpls_switch_cap;\n        union { /* int to float conversion buffer for several subTLVs */\n            float f;\n            uint32_t i;\n        } bw;\n\n        /* first lets see if we know the subTLVs name*/\n\tND_PRINT((ndo, \"%s%s subTLV #%u, length: %u\",\n\t          ident, tok2str(isis_ext_is_reach_subtlv_values, \"unknown\", subt),\n\t          subt, subl));\n\n\tND_TCHECK2(*tptr, subl);\n\n        switch(subt) {\n        case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP:\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID:\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID:\n\t    if (subl >= 4) {\n\t      ND_PRINT((ndo, \", 0x%08x\", EXTRACT_32BITS(tptr)));\n\t      if (subl == 8) /* rfc4205 */\n\t        ND_PRINT((ndo, \", 0x%08x\", EXTRACT_32BITS(tptr+4)));\n\t    }\n\t    break;\n        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR:\n        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR:\n            if (subl >= sizeof(struct in_addr))\n              ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr)));\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW :\n\tcase ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW:\n            if (subl >= 4) {\n              bw.i = EXTRACT_32BITS(tptr);\n              ND_PRINT((ndo, \", %.3f Mbps\", bw.f * 8 / 1000000));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW :\n            if (subl >= 32) {\n              for (te_class = 0; te_class < 8; te_class++) {\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  TE-Class %u: %.3f Mbps\",\n                       ident,\n                       te_class,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n\t      }\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS: /* fall through */\n        case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD:\n            ND_PRINT((ndo, \"%sBandwidth Constraints Model ID: %s (%u)\",\n                   ident,\n                   tok2str(diffserv_te_bc_values, \"unknown\", *tptr),\n                   *tptr));\n            tptr++;\n            /* decode BCs until the subTLV ends */\n            for (te_class = 0; te_class < (subl-1)/4; te_class++) {\n                ND_TCHECK2(*tptr, 4);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Bandwidth constraint CT%u: %.3f Mbps\",\n                       ident,\n                       te_class,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC:\n            if (subl >= 3)\n              ND_PRINT((ndo, \", %u\", EXTRACT_24BITS(tptr)));\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE:\n            if (subl == 2) {\n               ND_PRINT((ndo, \", [ %s ] (0x%04x)\",\n                      bittok2str(isis_subtlv_link_attribute_values,\n                                 \"Unknown\",\n                                 EXTRACT_16BITS(tptr)),\n                      EXTRACT_16BITS(tptr)));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE:\n            if (subl >= 2) {\n              ND_PRINT((ndo, \", %s, Priority %u\",\n\t\t   bittok2str(gmpls_link_prot_values, \"none\", *tptr),\n                   *(tptr+1)));\n            }\n            break;\n        case ISIS_SUBTLV_SPB_METRIC:\n            if (subl >= 6) {\n              ND_PRINT((ndo, \", LM: %u\", EXTRACT_24BITS(tptr)));\n              tptr=tptr+3;\n              ND_PRINT((ndo, \", P: %u\", *(tptr)));\n              tptr++;\n              ND_PRINT((ndo, \", P-ID: %u\", EXTRACT_16BITS(tptr)));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR:\n            if (subl >= 36) {\n              gmpls_switch_cap = *tptr;\n              ND_PRINT((ndo, \"%s  Interface Switching Capability:%s\",\n                   ident,\n                   tok2str(gmpls_switch_cap_values, \"Unknown\", gmpls_switch_cap)));\n              ND_PRINT((ndo, \", LSP Encoding: %s\",\n                   tok2str(gmpls_encoding_values, \"Unknown\", *(tptr + 1))));\n\t      tptr+=4;\n              ND_PRINT((ndo, \"%s  Max LSP Bandwidth:\", ident));\n              for (priority_level = 0; priority_level < 8; priority_level++) {\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s    priority level %d: %.3f Mbps\",\n                       ident,\n                       priority_level,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n              }\n              subl-=36;\n              switch (gmpls_switch_cap) {\n              case GMPLS_PSC1:\n              case GMPLS_PSC2:\n              case GMPLS_PSC3:\n              case GMPLS_PSC4:\n                ND_TCHECK2(*tptr, 6);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Min LSP Bandwidth: %.3f Mbps\", ident, bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Interface MTU: %u\", ident, EXTRACT_16BITS(tptr + 4)));\n                break;\n              case GMPLS_TSC:\n                ND_TCHECK2(*tptr, 8);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Min LSP Bandwidth: %.3f Mbps\", ident, bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Indication %s\", ident,\n                       tok2str(gmpls_switch_cap_tsc_indication_values, \"Unknown (%u)\", *(tptr + 4))));\n                break;\n              default:\n                /* there is some optional stuff left to decode but this is as of yet\n                   not specified so just lets hexdump what is left */\n                if(subl>0){\n                  if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t    \", subl))\n                    return(0);\n                }\n              }\n            }\n            break;\n        default:\n            if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t    \", subl))\n                return(0);\n            break;\n        }\n        return(1);\n\ntrunc:\n    return(0);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                ND_TCHECK2(*tptr, 4);\n",
        "src_path": "5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e___print-isoclns.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e",
        "commit_msg": "CVE-2017-13055/IS-IS: fix an Extended IS Reachability sub-TLV\n\nIn isis_print_is_reach_subtlv() one of the case blocks did not check that\nthe sub-TLV \"V\" is actually present and could over-read the input buffer.\nAdd a length check to fix that and remove a useless boundary check from\na loop because the boundary is tested for the full length of \"V\" before\nthe switch block.\n\nUpdate one of the prior test cases as it turns out it depended on this\npreviously incorrect code path to make it to its own malformed structure\nfurther down the buffer, the bugfix has changed its output.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -574,6 +574,7 @@ rpki-rtr-oob\t\trpki-rtr-oob.pcap\trpki-rtr-oob.out\t-v -c1\n lldp_8023_mtu-oobr\tlldp_8023_mtu-oobr.pcap\tlldp_8023_mtu-oobr.out\t-v -c1\n bgp_vpn_rt-oobr\tbgp_vpn_rt-oobr.pcap\tbgp_vpn_rt-oobr.out\t-v -c1\n cfm_sender_id-oobr\tcfm_sender_id-oobr.pcap\tcfm_sender_id-oobr.out\t-v -c1\n+isis-extd-isreach-oobr\tisis-extd-isreach-oobr.pcap\tisis-extd-isreach-oobr.out -v -c4\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/isis-extd-isreach-oobr.out",
                "patch": "@@ -0,0 +1,39 @@\n+OSI NLPID 0xfe unknown, length: 33554428\n+\t0x0000:  fe7f 4a01 0066 0002 00ff ffff f200 0000\n+\t0x0010:  00c6 0000 007f e6ff 00e6 6800 0000\n+unknown CHDLC protocol (0xfafe)\n+OSI NLPID 0xfe unknown, length: 33554428\n+\t0x0000:  fe7f 4a01 f165 0002 0000 0000 0000 0000\n+\t0x0010:  00c6 0000 007f e6ff 00e6 6800 0000\n+IS-IS, length 33554427\n+\tL2 Lan IIH, hlen: 27, v: 1, pdu-v: 1, sys-id-len: 6 (0), max-area: 3 (0)\n+\t  source-id: 3801.0101.0101,  holding time: 257s, Flags: [unknown circuit type 0x00]\n+\t  lan-id:    0101.0101.0100.00, Priority: 1, PDU length: 257\n+\t    Extended IS Reachability TLV #22, length: 12\n+\t      IS Neighbor: 0d0d.0d0d.0d0d.0d, Metric: 855309, sub-TLVs present (13)\n+\t        unknown subTLV #13, length: 13\n+\t\t    0x0000:  0d0d 0d0d 0d0d 0d0d 0d0d 0d0d 0d\n+\t      IS Neighbor: 0d0d.0d0d.0d0d.0d, Metric: 855309, sub-TLVs present (13)\n+\t        unknown subTLV #13, length: 13\n+\t\t    0x0000:  0d0d 0d0d 0d0d 0d64 0d0d 0d0d 0d\n+\t      IS Neighbor: 0d0d.0d0d.0d0d.0d, Metric: 855309, sub-TLVs present (13)\n+\t        unknown subTLV #13, length: 13\n+\t\t    0x0000:  0d0d 0d0d 0d0d 0d0d 0d0d 0d0d 0d\n+\t      IS Neighbor: 0d0d.0d0d.0d0d.0d, Metric: 855309, sub-TLVs present (13)\n+\t        unknown subTLV #13, length: 13\n+\t\t    0x0000:  1c0d 0d0d 0d0d 670d 0d0d 0d0d 0d\n+\t      IS Neighbor: 0d0d.0d00.0000.40, Metric: 13391955, sub-TLVs present (3)\n+\t        unknown subTLV #41, length: 16\n+\t\t    0x0000:  0022 0000 0000 0000 0000 0000 0000 0000\n+\t      IS Neighbor: 0000.0000.0a16.00, Metric: 2097279, no sub-TLVs present\n+\t      IS Neighbor: 0000.3604.1f01.16, Metric: 70400, no sub-TLVs present\n+\t      IS Neighbor: 0012.3a01.4996.01, Metric: 8838496, no sub-TLVs present\n+\t      IS Neighbor: 00c7.8787.8766.87, Metric: 0, sub-TLVs present (64)\n+\t        unknown subTLV #120, length: 22\n+\t\t    0x0000:  0101 0100 f0ff ffff ff01 0101 434c 4945\n+\t\t    0x0010:  4e54 0101 011f\n+\t        Link Local/Remote Identifier subTLV #4, length: 4, 0x04040404\n+\t        Link Local/Remote Identifier subTLV #4, length: 4, 0x04040404\n+\t        Link Local/Remote Identifier subTLV #4, length: 4, 0x0404000a\n+\t        Bandwidth Constraints subTLV #22, length: 0\n+\t\t [|isis]"
            },
            {
                "fn": "tests/isis-seg-fault-1-v.out",
                "patch": "@@ -28,274 +28,155 @@ IS-IS, length 1497\n \t        unknown subTLV #0, length: 0\n \t        unknown subTLV #0, length: 0\n \t        Bandwidth Constraints subTLV #22, length: 0\n-\t        Bandwidth Constraints Model ID: Russian dolls (0)\n-\t          Bandwidth constraint CT0: 0.000 Mbps\n-\t          Bandwidth constraint CT1: 0.000 Mbps\n-\t          Bandwidth constraint CT2: 0.000 Mbps\n-\t          Bandwidth constraint CT3: 0.000 Mbps\n-\t          Bandwidth constraint CT4: 0.000 Mbps\n-\t          Bandwidth constraint CT5: 0.000 Mbps\n-\t          Bandwidth constraint CT6: -0.000 Mbps\n-\t          Bandwidth constraint CT7: 0.000 Mbps\n-\t          Bandwidth constraint CT8: 0.000 Mbps\n-\t          Bandwidth constraint CT9: 0.000 Mbps\n-\t          Bandwidth constraint CT10: 0.000 Mbps\n-\t          Bandwidth constraint CT11: 0.000 Mbps\n-\t          Bandwidth constraint CT12: 0.000 Mbps\n-\t          Bandwidth constraint CT13: 0.000 Mbps\n-\t          Bandwidth constraint CT14: -1267650597027719304708096.000 Mbps\n-\t          Bandwidth constraint CT15: 0.000 Mbps\n-\t          Bandwidth constraint CT16: 0.000 Mbps\n-\t          Bandwidth constraint CT17: 0.000 Mbps\n-\t          Bandwidth constraint CT18: 0.000 Mbps\n-\t          Bandwidth constraint CT19: 0.000 Mbps\n-\t          Bandwidth constraint CT20: 0.000 Mbps\n-\t          Bandwidth constraint CT21: 0.000 Mbps\n-\t          Bandwidth constraint CT22: 0.000 Mbps\n-\t          Bandwidth constraint CT23: 0.000 Mbps\n-\t          Bandwidth constraint CT24: 0.000 Mbps\n-\t          Bandwidth constraint CT25: 0.000 Mbps\n-\t          Bandwidth constraint CT26: 0.000 Mbps\n-\t          Bandwidth constraint CT27: 0.000 Mbps\n-\t          Bandwidth constraint CT28: 0.000 Mbps\n-\t          Bandwidth constraint CT29: 0.000 Mbps\n-\t          Bandwidth constraint CT30: 0.000 Mbps\n-\t          Bandwidth constraint CT31: 0.000 Mbps\n-\t          Bandwidth constraint CT32: 0.000 Mbps\n-\t          Bandwidth constraint CT33: 0.000 Mbps\n-\t          Bandwidth constraint CT34: 0.000 Mbps\n-\t          Bandwidth constraint CT35: 0.000 Mbps\n-\t          Bandwidth constraint CT36: 0.000 Mbps\n-\t          Bandwidth constraint CT37: 0.000 Mbps\n-\t          Bandwidth constraint CT38: 16.777 Mbps\n-\t          Bandwidth constraint CT39: 0.000 Mbps\n-\t          Bandwidth constraint CT40: 0.000 Mbps\n-\t          Bandwidth constraint CT41: 0.000 Mbps\n-\t          Bandwidth constraint CT42: 0.000 Mbps\n-\t          Bandwidth constraint CT43: 0.000 Mbps\n-\t          Bandwidth constraint CT44: 0.000 Mbps\n-\t          Bandwidth constraint CT45: 0.000 Mbps\n-\t          Bandwidth constraint CT46: 0.000 Mbps\n-\t          Bandwidth constraint CT47: 0.000 Mbps\n-\t          Bandwidth constraint CT48: 0.000 Mbps\n-\t          Bandwidth constraint CT49: 0.000 Mbps\n-\t          Bandwidth constraint CT50: 0.000 Mbps\n-\t          Bandwidth constraint CT51: 0.000 Mbps\n-\t          Bandwidth constraint CT52: 0.000 Mbps\n-\t          Bandwidth constraint CT53: 0.000 Mbps\n-\t          Bandwidth constraint CT54: 0.000 Mbps\n-\t          Bandwidth constraint CT55: 0.000 Mbps\n-\t          Bandwidth constraint CT56: 0.000 Mbps\n-\t          Bandwidth constraint CT57: 0.000 Mbps\n-\t          Bandwidth constraint CT58: 0.000 Mbps\n-\t          Bandwidth constraint CT59: 0.000 Mbps\n-\t          Bandwidth constraint CT60: 0.000 Mbps\n-\t          Bandwidth constraint CT61: 0.000 Mbps\n-\t          Bandwidth constraint CT62: 0.000 Mbps\n-\t          Bandwidth constraint CT63: 0.000 Mbps\n-\t          Bandwidth constraint CT64: 0.000 Mbps\n-\t          Bandwidth constraint CT65: 0.000 Mbps\n-\t          Bandwidth constraint CT66: 0.000 Mbps\n-\t          Bandwidth constraint CT67: 0.000 Mbps\n-\t          Bandwidth constraint CT68: 0.000 Mbps\n-\t          Bandwidth constraint CT69: 0.000 Mbps\n-\t          Bandwidth constraint CT70: 0.000 Mbps\n-\t          Bandwidth constraint CT71: 0.000 Mbps\n-\t          Bandwidth constraint CT72: 0.000 Mbps\n-\t          Bandwidth constraint CT73: 0.000 Mbps\n-\t          Bandwidth constraint CT74: 0.000 Mbps\n-\t          Bandwidth constraint CT75: 0.000 Mbps\n-\t          Bandwidth constraint CT76: 0.000 Mbps\n-\t          Bandwidth constraint CT77: 0.000 Mbps\n-\t          Bandwidth constraint CT78: 0.000 Mbps\n-\t          Bandwidth constraint CT79: 0.000 Mbps\n-\t          Bandwidth constraint CT80: 0.000 Mbps\n-\t          Bandwidth constraint CT81: 0.000 Mbps\n-\t          Bandwidth constraint CT82: 0.000 Mbps\n-\t          Bandwidth constraint CT83: 0.000 Mbps\n-\t          Bandwidth constraint CT84: 0.000 Mbps\n-\t          Bandwidth constraint CT85: 0.000 Mbps\n-\t          Bandwidth constraint CT86: 0.000 Mbps\n-\t          Bandwidth constraint CT87: 0.000 Mbps\n-\t          Bandwidth constraint CT88: 0.000 Mbps\n-\t          Bandwidth constraint CT89: 0.000 Mbps\n-\t          Bandwidth constraint CT90: 0.000 Mbps\n-\t          Bandwidth constraint CT91: 0.000 Mbps\n-\t          Bandwidth constraint CT92: 0.000 Mbps\n-\t          Bandwidth constraint CT93: 0.000 Mbps\n-\t          Bandwidth constraint CT94: 0.000 Mbps\n-\t          Bandwidth constraint CT95: 0.000 Mbps\n-\t          Bandwidth constraint CT96: 0.000 Mbps\n-\t          Bandwidth constraint CT97: 0.000 Mbps\n-\t          Bandwidth constraint CT98: 0.000 Mbps\n-\t          Bandwidth constraint CT99: 0.000 Mbps\n-\t          Bandwidth constraint CT100: 0.000 Mbps\n-\t          Bandwidth constraint CT101: 0.000 Mbps\n-\t          Bandwidth constraint CT102: 0.000 Mbps\n-\t          Bandwidth constraint CT103: 0.000 Mbps\n-\t          Bandwidth constraint CT104: 0.000 Mbps\n-\t          Bandwidth constraint CT105: 0.000 Mbps\n-\t          Bandwidth constraint CT106: 0.000 Mbps\n-\t          Bandwidth constraint CT107: 0.000 Mbps\n-\t          Bandwidth constraint CT108: 0.000 Mbps\n-\t          Bandwidth constraint CT109: 0.000 Mbps\n-\t          Bandwidth constraint CT110: 334903128525925002608918921216.000 Mbps\n-\t          Bandwidth constraint CT111: 0.000 Mbps\n-\t          Bandwidth constraint CT112: 0.000 Mbps\n-\t          Bandwidth constraint CT113: 0.000 Mbps\n-\t          Bandwidth constraint CT114: 0.000 Mbps\n-\t          Bandwidth constraint CT115: 0.000 Mbps\n-\t          Bandwidth constraint CT116: 0.000 Mbps\n-\t          Bandwidth constraint CT117: 0.000 Mbps\n-\t          Bandwidth constraint CT118: 0.000 Mbps\n-\t          Bandwidth constraint CT119: 0.000 Mbps\n-\t          Bandwidth constraint CT120: 0.000 Mbps\n-\t          Bandwidth constraint CT121: 0.000 Mbps\n-\t          Bandwidth constraint CT122: 0.000 Mbps\n-\t          Bandwidth constraint CT123: 0.000 Mbps\n-\t          Bandwidth constraint CT124: 0.000 Mbps\n-\t          Bandwidth constraint CT125: 0.000 Mbps\n-\t          Bandwidth constraint CT126: 0.000 Mbps\n-\t          Bandwidth constraint CT127: 0.000 Mbps\n-\t          Bandwidth constraint CT128: 0.000 Mbps\n-\t          Bandwidth constraint CT129: 0.000 Mbps\n-\t          Bandwidth constraint CT130: 0.000 Mbps\n-\t          Bandwidth constraint CT131: 0.000 Mbps\n-\t          Bandwidth constraint CT132: 0.000 Mbps\n-\t          Bandwidth constraint CT133: 0.000 Mbps\n-\t          Bandwidth constraint CT134: 0.000 Mbps\n-\t          Bandwidth constraint CT135: 0.000 Mbps\n-\t          Bandwidth constraint CT136: 0.000 Mbps\n-\t          Bandwidth constraint CT137: -4.194 Mbps\n-\t          Bandwidth constraint CT138: 0.000 Mbps\n-\t          Bandwidth constraint CT139: 0.000 Mbps\n-\t          Bandwidth constraint CT140: 0.000 Mbps\n-\t          Bandwidth constraint CT141: 0.000 Mbps\n-\t          Bandwidth constraint CT142: 0.000 Mbps\n-\t          Bandwidth constraint CT143: 0.000 Mbps\n-\t          Bandwidth constraint CT144: 0.000 Mbps\n-\t          Bandwidth constraint CT145: 0.000 Mbps\n-\t          Bandwidth constraint CT146: 0.000 Mbps\n-\t          Bandwidth constraint CT147: 0.000 Mbps\n-\t          Bandwidth constraint CT148: 0.000 Mbps\n-\t          Bandwidth constraint CT149: 0.000 Mbps\n-\t          Bandwidth constraint CT150: 0.000 Mbps\n-\t          Bandwidth constraint CT151: 0.000 Mbps\n-\t          Bandwidth constraint CT152: 0.000 Mbps\n-\t          Bandwidth constraint CT153: 0.000 Mbps\n-\t          Bandwidth constraint CT154: 16.777 Mbps\n-\t          Bandwidth constraint CT155: 0.000 Mbps\n-\t          Bandwidth constraint CT156: 0.000 Mbps\n-\t          Bandwidth constraint CT157: 0.000 Mbps\n-\t          Bandwidth constraint CT158: 0.000 Mbps\n-\t          Bandwidth constraint CT159: 0.000 Mbps\n-\t          Bandwidth constraint CT160: 0.000 Mbps\n-\t          Bandwidth constraint CT161: 0.000 Mbps\n-\t          Bandwidth constraint CT162: 0.000 Mbps\n-\t          Bandwidth constraint CT163: 0.000 Mbps\n-\t          Bandwidth constraint CT164: 0.000 Mbps\n-\t          Bandwidth constraint CT165: 0.000 Mbps\n-\t          Bandwidth constraint CT166: 0.000 Mbps\n-\t          Bandwidth constraint CT167: 0.000 Mbps\n-\t          Bandwidth constraint CT168: 0.000 Mbps\n-\t          Bandwidth constraint CT169: 0.000 Mbps\n-\t          Bandwidth constraint CT170: 0.000 Mbps\n-\t          Bandwidth constraint CT171: 0.000 Mbps\n-\t          Bandwidth constraint CT172: 0.000 Mbps\n-\t          Bandwidth constraint CT173: 0.000 Mbps\n-\t          Bandwidth constraint CT174: 0.000 Mbps\n-\t          Bandwidth constraint CT175: 0.000 Mbps\n-\t          Bandwidth constraint CT176: 0.000 Mbps\n-\t          Bandwidth constraint CT177: 0.000 Mbps\n-\t          Bandwidth constraint CT178: 0.000 Mbps\n-\t          Bandwidth constraint CT179: 1099511.625 Mbps\n-\t          Bandwidth constraint CT180: 0.000 Mbps\n-\t          Bandwidth constraint CT181: 0.000 Mbps\n-\t          Bandwidth constraint CT182: 0.000 Mbps\n-\t          Bandwidth constraint CT183: 0.000 Mbps\n-\t          Bandwidth constraint CT184: 0.000 Mbps\n-\t          Bandwidth constraint CT185: 0.000 Mbps\n-\t          Bandwidth constraint CT186: 0.000 Mbps\n-\t          Bandwidth constraint CT187: 0.000 Mbps\n-\t          Bandwidth constraint CT188: 0.000 Mbps\n-\t          Bandwidth constraint CT189: 0.000 Mbps\n-\t          Bandwidth constraint CT190: 0.000 Mbps\n-\t          Bandwidth constraint CT191: 0.000 Mbps\n-\t          Bandwidth constraint CT192: 0.000 Mbps\n-\t          Bandwidth constraint CT193: 0.000 Mbps\n-\t          Bandwidth constraint CT194: 0.000 Mbps\n-\t          Bandwidth constraint CT195: 0.000 Mbps\n-\t          Bandwidth constraint CT196: 0.000 Mbps\n-\t          Bandwidth constraint CT197: 0.000 Mbps\n-\t          Bandwidth constraint CT198: 0.000 Mbps\n-\t          Bandwidth constraint CT199: 0.000 Mbps\n-\t          Bandwidth constraint CT200: 0.000 Mbps\n-\t          Bandwidth constraint CT201: 0.000 Mbps\n-\t          Bandwidth constraint CT202: 0.000 Mbps\n-\t          Bandwidth constraint CT203: 0.000 Mbps\n-\t          Bandwidth constraint CT204: 0.000 Mbps\n-\t          Bandwidth constraint CT205: 0.000 Mbps\n-\t          Bandwidth constraint CT206: 0.000 Mbps\n-\t          Bandwidth constraint CT207: 0.000 Mbps\n-\t          Bandwidth constraint CT208: 0.000 Mbps\n-\t          Bandwidth constraint CT209: 0.000 Mbps\n-\t          Bandwidth constraint CT210: 0.000 Mbps\n-\t          Bandwidth constraint CT211: 0.000 Mbps\n-\t          Bandwidth constraint CT212: 0.000 Mbps\n-\t          Bandwidth constraint CT213: 0.000 Mbps\n-\t          Bandwidth constraint CT214: 0.000 Mbps\n-\t          Bandwidth constraint CT215: 0.000 Mbps\n-\t          Bandwidth constraint CT216: 0.000 Mbps\n-\t          Bandwidth constraint CT217: 0.000 Mbps\n-\t          Bandwidth constraint CT218: 0.000 Mbps\n-\t          Bandwidth constraint CT219: 0.000 Mbps\n-\t          Bandwidth constraint CT220: 0.000 Mbps\n-\t          Bandwidth constraint CT221: 0.000 Mbps\n-\t          Bandwidth constraint CT222: 0.000 Mbps\n-\t          Bandwidth constraint CT223: 0.000 Mbps\n-\t          Bandwidth constraint CT224: 0.000 Mbps\n-\t          Bandwidth constraint CT225: 0.000 Mbps\n-\t          Bandwidth constraint CT226: 0.000 Mbps\n-\t          Bandwidth constraint CT227: 0.000 Mbps\n-\t          Bandwidth constraint CT228: 0.000 Mbps\n-\t          Bandwidth constraint CT229: 0.000 Mbps\n-\t          Bandwidth constraint CT230: -0.000 Mbps\n-\t          Bandwidth constraint CT231: 0.000 Mbps\n-\t          Bandwidth constraint CT232: 0.000 Mbps\n-\t          Bandwidth constraint CT233: 0.000 Mbps\n-\t          Bandwidth constraint CT234: 0.000 Mbps\n-\t          Bandwidth constraint CT235: 0.000 Mbps\n-\t          Bandwidth constraint CT236: 0.000 Mbps\n-\t          Bandwidth constraint CT237: 0.000 Mbps\n-\t          Bandwidth constraint CT238: 0.000 Mbps\n-\t          Bandwidth constraint CT239: 0.000 Mbps\n-\t          Bandwidth constraint CT240: 0.000 Mbps\n-\t          Bandwidth constraint CT241: 0.000 Mbps\n-\t          Bandwidth constraint CT242: 0.000 Mbps\n-\t          Bandwidth constraint CT243: 0.000 Mbps\n-\t          Bandwidth constraint CT244: 0.000 Mbps\n-\t          Bandwidth constraint CT245: 0.000 Mbps\n-\t          Bandwidth constraint CT246: 0.000 Mbps\n-\t          Bandwidth constraint CT247: 0.000 Mbps\n-\t          Bandwidth constraint CT248: 0.000 Mbps\n-\t          Bandwidth constraint CT249: 0.000 Mbps\n-\t          Bandwidth constraint CT250: 0.000 Mbps\n-\t          Bandwidth constraint CT251: 0.000 Mbps\n-\t          Bandwidth constraint CT252: 0.000 Mbps\n-\t          Bandwidth constraint CT253: 0.000 Mbps\n-\t          Bandwidth constraint CT254: 0.000 Mbps\n-\t          Bandwidth constraint CT255: 0.000 Mbps\n-\t          Bandwidth constraint CT256: 0.000 Mbps\n-\t          Bandwidth constraint CT257: 0.000 Mbps\n-\t          Bandwidth constraint CT258: 0.000 Mbps\n-\t          Bandwidth constraint CT259: 0.000 Mbps\n-\t          Bandwidth constraint CT260: 0.000 Mbps\n-\t          Bandwidth constraint CT261: 0.000 Mbps\n-\t          Bandwidth constraint CT262: 0.000 Mbps\n-\t          Bandwidth constraint CT263: 0.000 Mbps\n-\t          Bandwidth constraint CT264: 0.000 Mbps\n-\t          Bandwidth constraint CT265: 0.000 Mbps\n-\t          Bandwidth constraint CT266: 0.000 Mbps\n-\t          Bandwidth constraint CT267: 0.000 Mbps\n-\t          Bandwidth constraint CT268: 0.000 Mbps\n-\t\t [|isis]\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #64, length: 0\n+\t        unknown subTLV #0, length: 189\n+\t\t    0x0000:  0000 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0010:  00c2 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0020:  0000 0000 0000 0000 0000 0000 0020 0000\n+\t\t    0x0030:  00f0 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0040:  0000 0000 0000 0000 0000 0000 5900 0000\n+\t\t    0x0050:  0000 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0060:  0000 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0070:  0000 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0080:  0000 0000 0000 0000 0000 7d00 0008 ff00\n+\t\t    0x0090:  004a 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x00a0:  8000 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x00b0:  0000 0000 0000 0000 0000 0000 00\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 3400.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.2302.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0069.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0200.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0067.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, sub-TLVs present (37)\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 7800.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0065.00, sub-TLVs present (128)\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #66, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 8\n+\t\t    0x0000:  0000 0008 ff00 0000\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #121, length: 1\n+\t\t    0x0000:  00\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #50, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #132, length: 8\n+\t\t    0x0000:  0000 0000 0000 0000\n+\t        unknown subTLV #0, length: 0\n+\t      IS Neighbor: 8900.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 2500.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.2500.0000.c9, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0008.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: f700.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.004f.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 3d00.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0080.0002.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.007e.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t    Padding TLV #8, length: 255\n+\t    Padding TLV #8, length: 255\n+\t    Padding TLV #8, length: 247\n+\t    unknown TLV #0, length: 0\n+\t    unknown TLV #0, length: 0\n+\t    unknown TLV #0, length: 0\n+\t    unknown TLV #0, length: 0\n+\t    Padding TLV #8, length: 155"
            }
        ],
        "error_msg": "    isis-extd-isreach-oobr             : TEST FAILED(exit 256)\n"
    },
    "2390ad111bde16a78c98ac44572090b33c3bd2d8___Client.cpp": {
        "prefix": "void CClient::EchoMessage(const CMessage& Message) {\n    CMessage EchoedMessage = Message;\n    for (CClient* pClient : GetClients()) {\n        if (pClient->HasEchoMessage() ||\n",
        "suffix": "                                 pClient->HasSelfMessage()))) {\n            EchoedMessage.SetNick(GetNickMask());\n            pClient->PutClient(EchoedMessage);\n        }\n    }\n}\n",
        "start": 888,
        "end": 898,
        "buggy": "void CClient::EchoMessage(const CMessage& Message) {\n    CMessage EchoedMessage = Message;\n    for (CClient* pClient : GetClients()) {\n        if (pClient->HasEchoMessage() ||\n            (pClient != this && (m_pNetwork->IsChan(Message.GetParam(0)) ||\n                                 pClient->HasSelfMessage()))) {\n            EchoedMessage.SetNick(GetNickMask());\n            pClient->PutClient(EchoedMessage);\n        }\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            (pClient != this && (m_pNetwork->IsChan(Message.GetParam(0)) ||\n",
        "src_path": "2390ad111bde16a78c98ac44572090b33c3bd2d8___Client.cpp",
        "uri": "https://api.github.com/repos/znc/znc/commits/2390ad111bde16a78c98ac44572090b33c3bd2d8",
        "commit_msg": "Fix null pointer dereference in echo-message\n\nThe bug was introduced while fixing #1705. If a client did not enable\necho-message, and doesn't have a network, it crashes.\n\nThanks to LunarBNC for reporting this",
        "test_func_diff": [
            {
                "fn": "test/integration/tests/core.cpp",
                "patch": "@@ -297,6 +297,14 @@ TEST_F(ZNCTest, StatusEchoMessage) {\n     client.Write(\"PRIVMSG *status :blah\");\n     client.ReadUntil(\":nick!user@irc.znc.in PRIVMSG *status :blah\");\n     client.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n+    client.Write(\"znc delnetwork test\");\n+    client.ReadUntil(\"Network deleted\");\n+    auto client2 = LoginClient();\n+    client2.Write(\"PRIVMSG *status :blah2\");\n+    client2.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n+    auto client3 = LoginClient();\n+    client3.Write(\"PRIVMSG *status :blah3\");\n+    client3.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n }\n \n }  // namespace"
            }
        ],
        "error_msg": "      <failure message=\"test/integration/framework/base.h:118&#x0A;Value of: m_device-&gt;waitForReadyRead(timeout_ms)&#x0A;  Actual: false&#x0A;Expected: true&#x0A;Wanted: :*status!znc@znc.in PRIVMSG nick :Unknown command\" type=\"\"><![CDATA[test/integration/framework/base.h:118\nValue of: m_device->waitForReadyRead(timeout_ms)\n  Actual: false\nExpected: true\nWanted: :*status!znc@znc.in PRIVMSG nick :Unknown command]]></failure>\n      <failure message=\"test/integration/framework/base.cpp:52&#x0A;Expected equality of these values:&#x0A;  m_proc.exitStatus()&#x0A;    Which is: 1&#x0A;  QProcess::NormalExit&#x0A;    Which is: 0\" type=\"\"><![CDATA[test/integration/framework/base.cpp:52\nExpected equality of these values:\n  m_proc.exitStatus()\n    Which is: 1\n  QProcess::NormalExit\n    Which is: 0]]></failure>\n      <failure message=\"test/integration/framework/base.cpp:56&#x0A;Expected equality of these values:&#x0A;  m_proc.exitCode()&#x0A;    Which is: 11&#x0A;  m_exit&#x0A;    Which is: 0\" type=\"\"><![CDATA[test/integration/framework/base.cpp:56\nExpected equality of these values:\n  m_proc.exitCode()\n    Which is: 11\n  m_exit\n    Which is: 0]]></failure>\n"
    },
    "0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84___bson-iter.c": {
        "prefix": "static bool\n_bson_iter_next_internal (bson_iter_t *iter,    /* INOUT */\n                          uint32_t next_keylen, /* IN */\n                          const char **key,     /* OUT */\n                          uint32_t *bson_type,  /* OUT */\n                          bool *unsupported)    /* OUT */\n{\n   const uint8_t *data;\n   uint32_t o;\n   unsigned int len;\n\n   BSON_ASSERT (iter);\n\n   *unsupported = false;\n\n   if (!iter->raw) {\n      *key = NULL;\n      *bson_type = BSON_TYPE_EOD;\n      return false;\n   }\n\n   data = iter->raw;\n   len = iter->len;\n\n   iter->off = iter->next_off;\n   iter->type = iter->off;\n   iter->key = iter->off + 1;\n   iter->d1 = 0;\n   iter->d2 = 0;\n   iter->d3 = 0;\n   iter->d4 = 0;\n\n   if (next_keylen == 0) {\n      /* iterate from start to end of NULL-terminated key string */\n      for (o = iter->key; o < len; o++) {\n         if (!data[o]) {\n            iter->d1 = ++o;\n            goto fill_data_fields;\n         }\n      }\n   } else {\n      o = iter->key + next_keylen + 1;\n      iter->d1 = o;\n      goto fill_data_fields;\n   }\n\n   goto mark_invalid;\n\nfill_data_fields:\n\n   *key = bson_iter_key_unsafe (iter);\n   *bson_type = ITER_TYPE (iter);\n\n   switch (*bson_type) {\n   case BSON_TYPE_DATE_TIME:\n   case BSON_TYPE_DOUBLE:\n   case BSON_TYPE_INT64:\n   case BSON_TYPE_TIMESTAMP:\n      iter->next_off = o + 8;\n      break;\n   case BSON_TYPE_CODE:\n   case BSON_TYPE_SYMBOL:\n   case BSON_TYPE_UTF8: {\n      uint32_t l;\n\n      if ((o + 4) >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l > (len - (o + 4))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 4 + l;\n\n      /*\n       * Make sure the string length includes the NUL byte.\n       */\n      if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      /*\n       * Make sure the last byte is a NUL byte.\n       */\n      if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {\n         iter->err_off = o + 4 + l - 1;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_BINARY: {\n      bson_subtype_t subtype;\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      iter->d3 = o + 5;\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n",
        "suffix": "         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      subtype = *(iter->raw + iter->d2);\n\n      if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {\n         int32_t binary_len;\n\n         if (l < 4) {\n            iter->err_off = o;\n            goto mark_invalid;\n         }\n\n         /* subtype 2 has a redundant length header in the data */\n         memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));\n         binary_len = BSON_UINT32_FROM_LE (binary_len);\n         if (binary_len + 4 != l) {\n            iter->err_off = iter->d3;\n            goto mark_invalid;\n         }\n      }\n\n      iter->next_off = o + 5 + l;\n   } break;\n   case BSON_TYPE_ARRAY:\n   case BSON_TYPE_DOCUMENT: {\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if ((l > len) || (l > (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + l;\n   } break;\n   case BSON_TYPE_OID:\n      iter->next_off = o + 12;\n      break;\n   case BSON_TYPE_BOOL: {\n      char val;\n\n      if (iter->d1 >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&val, iter->raw + iter->d1, 1);\n      if (val != 0x00 && val != 0x01) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_REGEX: {\n      bool eor = false;\n      bool eoo = false;\n\n      for (; o < len; o++) {\n         if (!data[o]) {\n            iter->d2 = ++o;\n            eor = true;\n            break;\n         }\n      }\n\n      if (!eor) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }\n\n      for (; o < len; o++) {\n         if (!data[o]) {\n            eoo = true;\n            break;\n         }\n      }\n\n      if (!eoo) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_DBPOINTER: {\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      /* Check valid string length. l counts '\\0' but not 4 bytes for itself. */\n      if (l == 0 || l > (len - o - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      if (*(iter->raw + o + l + 3)) {\n         /* not null terminated */\n         iter->err_off = o + l + 3;\n         goto mark_invalid;\n      }\n\n      iter->d3 = o + 4 + l;\n      iter->next_off = o + 4 + l + 12;\n   } break;\n   case BSON_TYPE_CODEWSCOPE: {\n      uint32_t l;\n      uint32_t doclen;\n\n      if ((len < 19) || (o >= (len - 14))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      iter->d3 = o + 8;\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if ((l < 14) || (l >= (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + l;\n\n      if (iter->next_off >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&l, iter->raw + iter->d2, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l == 0 || l >= (len - o - 4 - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      if ((o + 4 + 4 + l + 4) >= iter->next_off) {\n         iter->err_off = o + 4;\n         goto mark_invalid;\n      }\n\n      iter->d4 = o + 4 + 4 + l;\n      memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));\n      doclen = BSON_UINT32_FROM_LE (doclen);\n\n      if ((o + 4 + 4 + l + doclen) != iter->next_off) {\n         iter->err_off = o + 4 + 4 + l;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_INT32:\n      iter->next_off = o + 4;\n      break;\n   case BSON_TYPE_DECIMAL128:\n      iter->next_off = o + 16;\n      break;\n   case BSON_TYPE_MAXKEY:\n   case BSON_TYPE_MINKEY:\n   case BSON_TYPE_NULL:\n   case BSON_TYPE_UNDEFINED:\n      iter->next_off = o;\n      break;\n   default:\n      *unsupported = true;\n   /* FALL THROUGH */\n   case BSON_TYPE_EOD:\n      iter->err_off = o;\n      goto mark_invalid;\n   }\n\n   /*\n    * Check to see if any of the field locations would overflow the\n    * current BSON buffer. If so, set the error location to the offset\n    * of where the field starts.\n    */\n   if (iter->next_off >= len) {\n      iter->err_off = o;\n      goto mark_invalid;\n   }\n\n   iter->err_off = 0;\n\n   return true;\n\nmark_invalid:\n   iter->raw = NULL;\n   iter->len = 0;\n   iter->next_off = 0;\n\n   return false;\n}\n",
        "start": 509,
        "end": 832,
        "buggy": "static bool\n_bson_iter_next_internal (bson_iter_t *iter,    /* INOUT */\n                          uint32_t next_keylen, /* IN */\n                          const char **key,     /* OUT */\n                          uint32_t *bson_type,  /* OUT */\n                          bool *unsupported)    /* OUT */\n{\n   const uint8_t *data;\n   uint32_t o;\n   unsigned int len;\n\n   BSON_ASSERT (iter);\n\n   *unsupported = false;\n\n   if (!iter->raw) {\n      *key = NULL;\n      *bson_type = BSON_TYPE_EOD;\n      return false;\n   }\n\n   data = iter->raw;\n   len = iter->len;\n\n   iter->off = iter->next_off;\n   iter->type = iter->off;\n   iter->key = iter->off + 1;\n   iter->d1 = 0;\n   iter->d2 = 0;\n   iter->d3 = 0;\n   iter->d4 = 0;\n\n   if (next_keylen == 0) {\n      /* iterate from start to end of NULL-terminated key string */\n      for (o = iter->key; o < len; o++) {\n         if (!data[o]) {\n            iter->d1 = ++o;\n            goto fill_data_fields;\n         }\n      }\n   } else {\n      o = iter->key + next_keylen + 1;\n      iter->d1 = o;\n      goto fill_data_fields;\n   }\n\n   goto mark_invalid;\n\nfill_data_fields:\n\n   *key = bson_iter_key_unsafe (iter);\n   *bson_type = ITER_TYPE (iter);\n\n   switch (*bson_type) {\n   case BSON_TYPE_DATE_TIME:\n   case BSON_TYPE_DOUBLE:\n   case BSON_TYPE_INT64:\n   case BSON_TYPE_TIMESTAMP:\n      iter->next_off = o + 8;\n      break;\n   case BSON_TYPE_CODE:\n   case BSON_TYPE_SYMBOL:\n   case BSON_TYPE_UTF8: {\n      uint32_t l;\n\n      if ((o + 4) >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l > (len - (o + 4))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 4 + l;\n\n      /*\n       * Make sure the string length includes the NUL byte.\n       */\n      if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      /*\n       * Make sure the last byte is a NUL byte.\n       */\n      if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {\n         iter->err_off = o + 4 + l - 1;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_BINARY: {\n      bson_subtype_t subtype;\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      iter->d3 = o + 5;\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l >= (len - o)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      subtype = *(iter->raw + iter->d2);\n\n      if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {\n         int32_t binary_len;\n\n         if (l < 4) {\n            iter->err_off = o;\n            goto mark_invalid;\n         }\n\n         /* subtype 2 has a redundant length header in the data */\n         memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));\n         binary_len = BSON_UINT32_FROM_LE (binary_len);\n         if (binary_len + 4 != l) {\n            iter->err_off = iter->d3;\n            goto mark_invalid;\n         }\n      }\n\n      iter->next_off = o + 5 + l;\n   } break;\n   case BSON_TYPE_ARRAY:\n   case BSON_TYPE_DOCUMENT: {\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if ((l > len) || (l > (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + l;\n   } break;\n   case BSON_TYPE_OID:\n      iter->next_off = o + 12;\n      break;\n   case BSON_TYPE_BOOL: {\n      char val;\n\n      if (iter->d1 >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&val, iter->raw + iter->d1, 1);\n      if (val != 0x00 && val != 0x01) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_REGEX: {\n      bool eor = false;\n      bool eoo = false;\n\n      for (; o < len; o++) {\n         if (!data[o]) {\n            iter->d2 = ++o;\n            eor = true;\n            break;\n         }\n      }\n\n      if (!eor) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }\n\n      for (; o < len; o++) {\n         if (!data[o]) {\n            eoo = true;\n            break;\n         }\n      }\n\n      if (!eoo) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_DBPOINTER: {\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      /* Check valid string length. l counts '\\0' but not 4 bytes for itself. */\n      if (l == 0 || l > (len - o - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      if (*(iter->raw + o + l + 3)) {\n         /* not null terminated */\n         iter->err_off = o + l + 3;\n         goto mark_invalid;\n      }\n\n      iter->d3 = o + 4 + l;\n      iter->next_off = o + 4 + l + 12;\n   } break;\n   case BSON_TYPE_CODEWSCOPE: {\n      uint32_t l;\n      uint32_t doclen;\n\n      if ((len < 19) || (o >= (len - 14))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      iter->d3 = o + 8;\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if ((l < 14) || (l >= (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + l;\n\n      if (iter->next_off >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&l, iter->raw + iter->d2, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l == 0 || l >= (len - o - 4 - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      if ((o + 4 + 4 + l + 4) >= iter->next_off) {\n         iter->err_off = o + 4;\n         goto mark_invalid;\n      }\n\n      iter->d4 = o + 4 + 4 + l;\n      memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));\n      doclen = BSON_UINT32_FROM_LE (doclen);\n\n      if ((o + 4 + 4 + l + doclen) != iter->next_off) {\n         iter->err_off = o + 4 + 4 + l;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_INT32:\n      iter->next_off = o + 4;\n      break;\n   case BSON_TYPE_DECIMAL128:\n      iter->next_off = o + 16;\n      break;\n   case BSON_TYPE_MAXKEY:\n   case BSON_TYPE_MINKEY:\n   case BSON_TYPE_NULL:\n   case BSON_TYPE_UNDEFINED:\n      iter->next_off = o;\n      break;\n   default:\n      *unsupported = true;\n   /* FALL THROUGH */\n   case BSON_TYPE_EOD:\n      iter->err_off = o;\n      goto mark_invalid;\n   }\n\n   /*\n    * Check to see if any of the field locations would overflow the\n    * current BSON buffer. If so, set the error location to the offset\n    * of where the field starts.\n    */\n   if (iter->next_off >= len) {\n      iter->err_off = o;\n      goto mark_invalid;\n   }\n\n   iter->err_off = 0;\n\n   return true;\n\nmark_invalid:\n   iter->raw = NULL;\n   iter->len = 0;\n   iter->next_off = 0;\n\n   return false;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      if (l >= (len - o)) {\n",
        "src_path": "0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84___bson-iter.c",
        "uri": "https://api.github.com/repos/mongodb/mongo-c-driver/commits/0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84",
        "commit_msg": "Fix for CVE-2018-16790 -- Verify bounds before binary length read.\n\nAs reported here: https://jira.mongodb.org/browse/CDRIVER-2819,\na heap overread occurs due a failure to correctly verify data\nbounds.\n\nIn the original check, len - o returns the data left including the\nsizeof(l) we just read. Instead, the comparison should check\nagainst the data left NOT including the binary int32, i.e. just\nsubtype (byte*) instead of int32 subtype (byte*).\n\nAdded in test for corrupted BSON example.",
        "test_func_diff": [
            {
                "fn": "src/libbson/tests/test-bson.c",
                "patch": "@@ -1249,6 +1249,11 @@ test_bson_validate (void)\n                   12,\n                   BSON_VALIDATE_NONE,\n                   \"corrupt BSON\");\n+   VALIDATE_TEST (\"test59.bson\",\n+                  BSON_VALIDATE_NONE,\n+                  9,\n+                  BSON_VALIDATE_NONE,\n+                  \"corrupt BSON\");\n \n    /* DBRef validation */\n    b = BCON_NEW (\"my_dbref\","
            }
        ],
        "error_msg": "FAIL\n\nAssert Failure: 14 == 9\n/out/mongodb___mongo-c-driver/git_repo_dir_0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84/src/libbson/tests/test-bson.c:1256  test_bson_validate()\n"
    },
    "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd___pragma.c": {
        "prefix": "void sqlite3Pragma(\n  Parse *pParse, \n  Token *pId1,        /* First part of [schema.]id field */\n  Token *pId2,        /* Second part of [schema.]id field, or NULL */\n  Token *pValue,      /* Token for <value>, or NULL */\n  int minusFlag       /* True if a '-' sign preceded <value> */\n){\n  char *zLeft = 0;       /* Nul-terminated UTF-8 string <id> */\n  char *zRight = 0;      /* Nul-terminated UTF-8 string <value>, or NULL */\n  const char *zDb = 0;   /* The database name */\n  Token *pId;            /* Pointer to <id> token */\n  char *aFcntl[4];       /* Argument to SQLITE_FCNTL_PRAGMA */\n  int iDb;               /* Database index for <database> */\n  int rc;                      /* return value form SQLITE_FCNTL_PRAGMA */\n  sqlite3 *db = pParse->db;    /* The database connection */\n  Db *pDb;                     /* The specific database being pragmaed */\n  Vdbe *v = sqlite3GetVdbe(pParse);  /* Prepared statement */\n  const PragmaName *pPragma;   /* The pragma */\n\n  if( v==0 ) return;\n  sqlite3VdbeRunOnlyOnce(v);\n  pParse->nMem = 2;\n\n  /* Interpret the [schema.] part of the pragma statement. iDb is the\n  ** index of the database this pragma is being applied to in db.aDb[]. */\n  iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);\n  if( iDb<0 ) return;\n  pDb = &db->aDb[iDb];\n\n  /* If the temp database has been explicitly named as part of the \n  ** pragma, make sure it is open. \n  */\n  if( iDb==1 && sqlite3OpenTempDatabase(pParse) ){\n    return;\n  }\n\n  zLeft = sqlite3NameFromToken(db, pId);\n  if( !zLeft ) return;\n  if( minusFlag ){\n    zRight = sqlite3MPrintf(db, \"-%T\", pValue);\n  }else{\n    zRight = sqlite3NameFromToken(db, pValue);\n  }\n\n  assert( pId2 );\n  zDb = pId2->n>0 ? pDb->zDbSName : 0;\n  if( sqlite3AuthCheck(pParse, SQLITE_PRAGMA, zLeft, zRight, zDb) ){\n    goto pragma_out;\n  }\n\n  /* Send an SQLITE_FCNTL_PRAGMA file-control to the underlying VFS\n  ** connection.  If it returns SQLITE_OK, then assume that the VFS\n  ** handled the pragma and generate a no-op prepared statement.\n  **\n  ** IMPLEMENTATION-OF: R-12238-55120 Whenever a PRAGMA statement is parsed,\n  ** an SQLITE_FCNTL_PRAGMA file control is sent to the open sqlite3_file\n  ** object corresponding to the database file to which the pragma\n  ** statement refers.\n  **\n  ** IMPLEMENTATION-OF: R-29875-31678 The argument to the SQLITE_FCNTL_PRAGMA\n  ** file control is an array of pointers to strings (char**) in which the\n  ** second element of the array is the name of the pragma and the third\n  ** element is the argument to the pragma or NULL if the pragma has no\n  ** argument.\n  */\n  aFcntl[0] = 0;\n  aFcntl[1] = zLeft;\n  aFcntl[2] = zRight;\n  aFcntl[3] = 0;\n  db->busyHandler.nBusy = 0;\n  rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_PRAGMA, (void*)aFcntl);\n  if( rc==SQLITE_OK ){\n    sqlite3VdbeSetNumCols(v, 1);\n    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, aFcntl[0], SQLITE_TRANSIENT);\n    returnSingleText(v, aFcntl[0]);\n    sqlite3_free(aFcntl[0]);\n    goto pragma_out;\n  }\n  if( rc!=SQLITE_NOTFOUND ){\n    if( aFcntl[0] ){\n      sqlite3ErrorMsg(pParse, \"%s\", aFcntl[0]);\n      sqlite3_free(aFcntl[0]);\n    }\n    pParse->nErr++;\n    pParse->rc = rc;\n    goto pragma_out;\n  }\n\n  /* Locate the pragma in the lookup table */\n  pPragma = pragmaLocate(zLeft);\n  if( pPragma==0 ) goto pragma_out;\n\n  /* Make sure the database schema is loaded if the pragma requires that */\n  if( (pPragma->mPragFlg & PragFlg_NeedSchema)!=0 ){\n    if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n  }\n\n  /* Register the result column names for pragmas that return results */\n  if( (pPragma->mPragFlg & PragFlg_NoColumns)==0 \n   && ((pPragma->mPragFlg & PragFlg_NoColumns1)==0 || zRight==0)\n  ){\n    setPragmaResultColumnNames(v, pPragma);\n  }\n\n  /* Jump to the appropriate pragma handler */\n  switch( pPragma->ePragTyp ){\n  \n#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) && !defined(SQLITE_OMIT_DEPRECATED)\n  /*\n  **  PRAGMA [schema.]default_cache_size\n  **  PRAGMA [schema.]default_cache_size=N\n  **\n  ** The first form reports the current persistent setting for the\n  ** page cache size.  The value returned is the maximum number of\n  ** pages in the page cache.  The second form sets both the current\n  ** page cache size value and the persistent page cache size value\n  ** stored in the database file.\n  **\n  ** Older versions of SQLite would set the default cache size to a\n  ** negative number to indicate synchronous=OFF.  These days, synchronous\n  ** is always on by default regardless of the sign of the default cache\n  ** size.  But continue to take the absolute value of the default cache\n  ** size of historical compatibility.\n  */\n  case PragTyp_DEFAULT_CACHE_SIZE: {\n    static const int iLn = VDBE_OFFSET_LINENO(2);\n    static const VdbeOpList getCacheSize[] = {\n      { OP_Transaction, 0, 0,        0},                         /* 0 */\n      { OP_ReadCookie,  0, 1,        BTREE_DEFAULT_CACHE_SIZE},  /* 1 */\n      { OP_IfPos,       1, 8,        0},\n      { OP_Integer,     0, 2,        0},\n      { OP_Subtract,    1, 2,        1},\n      { OP_IfPos,       1, 8,        0},\n      { OP_Integer,     0, 1,        0},                         /* 6 */\n      { OP_Noop,        0, 0,        0},\n      { OP_ResultRow,   1, 1,        0},\n    };\n    VdbeOp *aOp;\n    sqlite3VdbeUsesBtree(v, iDb);\n    if( !zRight ){\n      pParse->nMem += 2;\n      sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(getCacheSize));\n      aOp = sqlite3VdbeAddOpList(v, ArraySize(getCacheSize), getCacheSize, iLn);\n      if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;\n      aOp[0].p1 = iDb;\n      aOp[1].p1 = iDb;\n      aOp[6].p1 = SQLITE_DEFAULT_CACHE_SIZE;\n    }else{\n      int size = sqlite3AbsInt32(sqlite3Atoi(zRight));\n      sqlite3BeginWriteOperation(pParse, 0, iDb);\n      sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_DEFAULT_CACHE_SIZE, size);\n      assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n      pDb->pSchema->cache_size = size;\n      sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n    }\n    break;\n  }\n#endif /* !SQLITE_OMIT_PAGER_PRAGMAS && !SQLITE_OMIT_DEPRECATED */\n\n#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)\n  /*\n  **  PRAGMA [schema.]page_size\n  **  PRAGMA [schema.]page_size=N\n  **\n  ** The first form reports the current setting for the\n  ** database page size in bytes.  The second form sets the\n  ** database page size value.  The value can only be set if\n  ** the database has not yet been created.\n  */\n  case PragTyp_PAGE_SIZE: {\n    Btree *pBt = pDb->pBt;\n    assert( pBt!=0 );\n    if( !zRight ){\n      int size = ALWAYS(pBt) ? sqlite3BtreeGetPageSize(pBt) : 0;\n      returnSingleInt(v, size);\n    }else{\n      /* Malloc may fail when setting the page-size, as there is an internal\n      ** buffer that the pager module resizes using sqlite3_realloc().\n      */\n      db->nextPagesize = sqlite3Atoi(zRight);\n      if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db->nextPagesize,-1,0) ){\n        sqlite3OomFault(db);\n      }\n    }\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]secure_delete\n  **  PRAGMA [schema.]secure_delete=ON/OFF/FAST\n  **\n  ** The first form reports the current setting for the\n  ** secure_delete flag.  The second form changes the secure_delete\n  ** flag setting and reports the new value.\n  */\n  case PragTyp_SECURE_DELETE: {\n    Btree *pBt = pDb->pBt;\n    int b = -1;\n    assert( pBt!=0 );\n    if( zRight ){\n      if( sqlite3_stricmp(zRight, \"fast\")==0 ){\n        b = 2;\n      }else{\n        b = sqlite3GetBoolean(zRight, 0);\n      }\n    }\n    if( pId2->n==0 && b>=0 ){\n      int ii;\n      for(ii=0; ii<db->nDb; ii++){\n        sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);\n      }\n    }\n    b = sqlite3BtreeSecureDelete(pBt, b);\n    returnSingleInt(v, b);\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]max_page_count\n  **  PRAGMA [schema.]max_page_count=N\n  **\n  ** The first form reports the current setting for the\n  ** maximum number of pages in the database file.  The \n  ** second form attempts to change this setting.  Both\n  ** forms return the current setting.\n  **\n  ** The absolute value of N is used.  This is undocumented and might\n  ** change.  The only purpose is to provide an easy way to test\n  ** the sqlite3AbsInt32() function.\n  **\n  **  PRAGMA [schema.]page_count\n  **\n  ** Return the number of pages in the specified database.\n  */\n  case PragTyp_PAGE_COUNT: {\n    int iReg;\n    sqlite3CodeVerifySchema(pParse, iDb);\n    iReg = ++pParse->nMem;\n    if( sqlite3Tolower(zLeft[0])=='p' ){\n      sqlite3VdbeAddOp2(v, OP_Pagecount, iDb, iReg);\n    }else{\n      sqlite3VdbeAddOp3(v, OP_MaxPgcnt, iDb, iReg, \n                        sqlite3AbsInt32(sqlite3Atoi(zRight)));\n    }\n    sqlite3VdbeAddOp2(v, OP_ResultRow, iReg, 1);\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]locking_mode\n  **  PRAGMA [schema.]locking_mode = (normal|exclusive)\n  */\n  case PragTyp_LOCKING_MODE: {\n    const char *zRet = \"normal\";\n    int eMode = getLockingMode(zRight);\n\n    if( pId2->n==0 && eMode==PAGER_LOCKINGMODE_QUERY ){\n      /* Simple \"PRAGMA locking_mode;\" statement. This is a query for\n      ** the current default locking mode (which may be different to\n      ** the locking-mode of the main database).\n      */\n      eMode = db->dfltLockMode;\n    }else{\n      Pager *pPager;\n      if( pId2->n==0 ){\n        /* This indicates that no database name was specified as part\n        ** of the PRAGMA command. In this case the locking-mode must be\n        ** set on all attached databases, as well as the main db file.\n        **\n        ** Also, the sqlite3.dfltLockMode variable is set so that\n        ** any subsequently attached databases also use the specified\n        ** locking mode.\n        */\n        int ii;\n        assert(pDb==&db->aDb[0]);\n        for(ii=2; ii<db->nDb; ii++){\n          pPager = sqlite3BtreePager(db->aDb[ii].pBt);\n          sqlite3PagerLockingMode(pPager, eMode);\n        }\n        db->dfltLockMode = (u8)eMode;\n      }\n      pPager = sqlite3BtreePager(pDb->pBt);\n      eMode = sqlite3PagerLockingMode(pPager, eMode);\n    }\n\n    assert( eMode==PAGER_LOCKINGMODE_NORMAL\n            || eMode==PAGER_LOCKINGMODE_EXCLUSIVE );\n    if( eMode==PAGER_LOCKINGMODE_EXCLUSIVE ){\n      zRet = \"exclusive\";\n    }\n    returnSingleText(v, zRet);\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]journal_mode\n  **  PRAGMA [schema.]journal_mode =\n  **                      (delete|persist|off|truncate|memory|wal|off)\n  */\n  case PragTyp_JOURNAL_MODE: {\n    int eMode;        /* One of the PAGER_JOURNALMODE_XXX symbols */\n    int ii;           /* Loop counter */\n\n    if( zRight==0 ){\n      /* If there is no \"=MODE\" part of the pragma, do a query for the\n      ** current mode */\n      eMode = PAGER_JOURNALMODE_QUERY;\n    }else{\n      const char *zMode;\n      int n = sqlite3Strlen30(zRight);\n      for(eMode=0; (zMode = sqlite3JournalModename(eMode))!=0; eMode++){\n        if( sqlite3StrNICmp(zRight, zMode, n)==0 ) break;\n      }\n      if( !zMode ){\n        /* If the \"=MODE\" part does not match any known journal mode,\n        ** then do a query */\n        eMode = PAGER_JOURNALMODE_QUERY;\n      }\n      if( eMode==PAGER_JOURNALMODE_OFF && (db->flags & SQLITE_Defensive)!=0 ){\n        /* Do not allow journal-mode \"OFF\" in defensive since the database\n        ** can become corrupted using ordinary SQL when the journal is off */\n        eMode = PAGER_JOURNALMODE_QUERY;\n      }\n    }\n    if( eMode==PAGER_JOURNALMODE_QUERY && pId2->n==0 ){\n      /* Convert \"PRAGMA journal_mode\" into \"PRAGMA main.journal_mode\" */\n      iDb = 0;\n      pId2->n = 1;\n    }\n    for(ii=db->nDb-1; ii>=0; ii--){\n      if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){\n        sqlite3VdbeUsesBtree(v, ii);\n        sqlite3VdbeAddOp3(v, OP_JournalMode, ii, 1, eMode);\n      }\n    }\n    sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]journal_size_limit\n  **  PRAGMA [schema.]journal_size_limit=N\n  **\n  ** Get or set the size limit on rollback journal files.\n  */\n  case PragTyp_JOURNAL_SIZE_LIMIT: {\n    Pager *pPager = sqlite3BtreePager(pDb->pBt);\n    i64 iLimit = -2;\n    if( zRight ){\n      sqlite3DecOrHexToI64(zRight, &iLimit);\n      if( iLimit<-1 ) iLimit = -1;\n    }\n    iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit);\n    returnSingleInt(v, iLimit);\n    break;\n  }\n\n#endif /* SQLITE_OMIT_PAGER_PRAGMAS */\n\n  /*\n  **  PRAGMA [schema.]auto_vacuum\n  **  PRAGMA [schema.]auto_vacuum=N\n  **\n  ** Get or set the value of the database 'auto-vacuum' parameter.\n  ** The value is one of:  0 NONE 1 FULL 2 INCREMENTAL\n  */\n#ifndef SQLITE_OMIT_AUTOVACUUM\n  case PragTyp_AUTO_VACUUM: {\n    Btree *pBt = pDb->pBt;\n    assert( pBt!=0 );\n    if( !zRight ){\n      returnSingleInt(v, sqlite3BtreeGetAutoVacuum(pBt));\n    }else{\n      int eAuto = getAutoVacuum(zRight);\n      assert( eAuto>=0 && eAuto<=2 );\n      db->nextAutovac = (u8)eAuto;\n      /* Call SetAutoVacuum() to set initialize the internal auto and\n      ** incr-vacuum flags. This is required in case this connection\n      ** creates the database file. It is important that it is created\n      ** as an auto-vacuum capable db.\n      */\n      rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto);\n      if( rc==SQLITE_OK && (eAuto==1 || eAuto==2) ){\n        /* When setting the auto_vacuum mode to either \"full\" or \n        ** \"incremental\", write the value of meta[6] in the database\n        ** file. Before writing to meta[6], check that meta[3] indicates\n        ** that this really is an auto-vacuum capable database.\n        */\n        static const int iLn = VDBE_OFFSET_LINENO(2);\n        static const VdbeOpList setMeta6[] = {\n          { OP_Transaction,    0,         1,                 0},    /* 0 */\n          { OP_ReadCookie,     0,         1,         BTREE_LARGEST_ROOT_PAGE},\n          { OP_If,             1,         0,                 0},    /* 2 */\n          { OP_Halt,           SQLITE_OK, OE_Abort,          0},    /* 3 */\n          { OP_SetCookie,      0,         BTREE_INCR_VACUUM, 0},    /* 4 */\n        };\n        VdbeOp *aOp;\n        int iAddr = sqlite3VdbeCurrentAddr(v);\n        sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setMeta6));\n        aOp = sqlite3VdbeAddOpList(v, ArraySize(setMeta6), setMeta6, iLn);\n        if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;\n        aOp[0].p1 = iDb;\n        aOp[1].p1 = iDb;\n        aOp[2].p2 = iAddr+4;\n        aOp[4].p1 = iDb;\n        aOp[4].p3 = eAuto - 1;\n        sqlite3VdbeUsesBtree(v, iDb);\n      }\n    }\n    break;\n  }\n#endif\n\n  /*\n  **  PRAGMA [schema.]incremental_vacuum(N)\n  **\n  ** Do N steps of incremental vacuuming on a database.\n  */\n#ifndef SQLITE_OMIT_AUTOVACUUM\n  case PragTyp_INCREMENTAL_VACUUM: {\n    int iLimit, addr;\n    if( zRight==0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit<=0 ){\n      iLimit = 0x7fffffff;\n    }\n    sqlite3BeginWriteOperation(pParse, 0, iDb);\n    sqlite3VdbeAddOp2(v, OP_Integer, iLimit, 1);\n    addr = sqlite3VdbeAddOp1(v, OP_IncrVacuum, iDb); VdbeCoverage(v);\n    sqlite3VdbeAddOp1(v, OP_ResultRow, 1);\n    sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1);\n    sqlite3VdbeAddOp2(v, OP_IfPos, 1, addr); VdbeCoverage(v);\n    sqlite3VdbeJumpHere(v, addr);\n    break;\n  }\n#endif\n\n#ifndef SQLITE_OMIT_PAGER_PRAGMAS\n  /*\n  **  PRAGMA [schema.]cache_size\n  **  PRAGMA [schema.]cache_size=N\n  **\n  ** The first form reports the current local setting for the\n  ** page cache size. The second form sets the local\n  ** page cache size value.  If N is positive then that is the\n  ** number of pages in the cache.  If N is negative, then the\n  ** number of pages is adjusted so that the cache uses -N kibibytes\n  ** of memory.\n  */\n  case PragTyp_CACHE_SIZE: {\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    if( !zRight ){\n      returnSingleInt(v, pDb->pSchema->cache_size);\n    }else{\n      int size = sqlite3Atoi(zRight);\n      pDb->pSchema->cache_size = size;\n      sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n    }\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]cache_spill\n  **  PRAGMA cache_spill=BOOLEAN\n  **  PRAGMA [schema.]cache_spill=N\n  **\n  ** The first form reports the current local setting for the\n  ** page cache spill size. The second form turns cache spill on\n  ** or off.  When turnning cache spill on, the size is set to the\n  ** current cache_size.  The third form sets a spill size that\n  ** may be different form the cache size.\n  ** If N is positive then that is the\n  ** number of pages in the cache.  If N is negative, then the\n  ** number of pages is adjusted so that the cache uses -N kibibytes\n  ** of memory.\n  **\n  ** If the number of cache_spill pages is less then the number of\n  ** cache_size pages, no spilling occurs until the page count exceeds\n  ** the number of cache_size pages.\n  **\n  ** The cache_spill=BOOLEAN setting applies to all attached schemas,\n  ** not just the schema specified.\n  */\n  case PragTyp_CACHE_SPILL: {\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    if( !zRight ){\n      returnSingleInt(v,\n         (db->flags & SQLITE_CacheSpill)==0 ? 0 : \n            sqlite3BtreeSetSpillSize(pDb->pBt,0));\n    }else{\n      int size = 1;\n      if( sqlite3GetInt32(zRight, &size) ){\n        sqlite3BtreeSetSpillSize(pDb->pBt, size);\n      }\n      if( sqlite3GetBoolean(zRight, size!=0) ){\n        db->flags |= SQLITE_CacheSpill;\n      }else{\n        db->flags &= ~(u64)SQLITE_CacheSpill;\n      }\n      setAllPagerFlags(db);\n    }\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]mmap_size(N)\n  **\n  ** Used to set mapping size limit. The mapping size limit is\n  ** used to limit the aggregate size of all memory mapped regions of the\n  ** database file. If this parameter is set to zero, then memory mapping\n  ** is not used at all.  If N is negative, then the default memory map\n  ** limit determined by sqlite3_config(SQLITE_CONFIG_MMAP_SIZE) is set.\n  ** The parameter N is measured in bytes.\n  **\n  ** This value is advisory.  The underlying VFS is free to memory map\n  ** as little or as much as it wants.  Except, if N is set to 0 then the\n  ** upper layers will never invoke the xFetch interfaces to the VFS.\n  */\n  case PragTyp_MMAP_SIZE: {\n    sqlite3_int64 sz;\n#if SQLITE_MAX_MMAP_SIZE>0\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    if( zRight ){\n      int ii;\n      sqlite3DecOrHexToI64(zRight, &sz);\n      if( sz<0 ) sz = sqlite3GlobalConfig.szMmap;\n      if( pId2->n==0 ) db->szMmap = sz;\n      for(ii=db->nDb-1; ii>=0; ii--){\n        if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){\n          sqlite3BtreeSetMmapLimit(db->aDb[ii].pBt, sz);\n        }\n      }\n    }\n    sz = -1;\n    rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_MMAP_SIZE, &sz);\n#else\n    sz = 0;\n    rc = SQLITE_OK;\n#endif\n    if( rc==SQLITE_OK ){\n      returnSingleInt(v, sz);\n    }else if( rc!=SQLITE_NOTFOUND ){\n      pParse->nErr++;\n      pParse->rc = rc;\n    }\n    break;\n  }\n\n  /*\n  **   PRAGMA temp_store\n  **   PRAGMA temp_store = \"default\"|\"memory\"|\"file\"\n  **\n  ** Return or set the local value of the temp_store flag.  Changing\n  ** the local value does not make changes to the disk file and the default\n  ** value will be restored the next time the database is opened.\n  **\n  ** Note that it is possible for the library compile-time options to\n  ** override this setting\n  */\n  case PragTyp_TEMP_STORE: {\n    if( !zRight ){\n      returnSingleInt(v, db->temp_store);\n    }else{\n      changeTempStorage(pParse, zRight);\n    }\n    break;\n  }\n\n  /*\n  **   PRAGMA temp_store_directory\n  **   PRAGMA temp_store_directory = \"\"|\"directory_name\"\n  **\n  ** Return or set the local value of the temp_store_directory flag.  Changing\n  ** the value sets a specific directory to be used for temporary files.\n  ** Setting to a null string reverts to the default temporary directory search.\n  ** If temporary directory is changed, then invalidateTempStorage.\n  **\n  */\n  case PragTyp_TEMP_STORE_DIRECTORY: {\n    if( !zRight ){\n      returnSingleText(v, sqlite3_temp_directory);\n    }else{\n#ifndef SQLITE_OMIT_WSD\n      if( zRight[0] ){\n        int res;\n        rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);\n        if( rc!=SQLITE_OK || res==0 ){\n          sqlite3ErrorMsg(pParse, \"not a writable directory\");\n          goto pragma_out;\n        }\n      }\n      if( SQLITE_TEMP_STORE==0\n       || (SQLITE_TEMP_STORE==1 && db->temp_store<=1)\n       || (SQLITE_TEMP_STORE==2 && db->temp_store==1)\n      ){\n        invalidateTempStorage(pParse);\n      }\n      sqlite3_free(sqlite3_temp_directory);\n      if( zRight[0] ){\n        sqlite3_temp_directory = sqlite3_mprintf(\"%s\", zRight);\n      }else{\n        sqlite3_temp_directory = 0;\n      }\n#endif /* SQLITE_OMIT_WSD */\n    }\n    break;\n  }\n\n#if SQLITE_OS_WIN\n  /*\n  **   PRAGMA data_store_directory\n  **   PRAGMA data_store_directory = \"\"|\"directory_name\"\n  **\n  ** Return or set the local value of the data_store_directory flag.  Changing\n  ** the value sets a specific directory to be used for database files that\n  ** were specified with a relative pathname.  Setting to a null string reverts\n  ** to the default database directory, which for database files specified with\n  ** a relative path will probably be based on the current directory for the\n  ** process.  Database file specified with an absolute path are not impacted\n  ** by this setting, regardless of its value.\n  **\n  */\n  case PragTyp_DATA_STORE_DIRECTORY: {\n    if( !zRight ){\n      returnSingleText(v, sqlite3_data_directory);\n    }else{\n#ifndef SQLITE_OMIT_WSD\n      if( zRight[0] ){\n        int res;\n        rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);\n        if( rc!=SQLITE_OK || res==0 ){\n          sqlite3ErrorMsg(pParse, \"not a writable directory\");\n          goto pragma_out;\n        }\n      }\n      sqlite3_free(sqlite3_data_directory);\n      if( zRight[0] ){\n        sqlite3_data_directory = sqlite3_mprintf(\"%s\", zRight);\n      }else{\n        sqlite3_data_directory = 0;\n      }\n#endif /* SQLITE_OMIT_WSD */\n    }\n    break;\n  }\n#endif\n\n#if SQLITE_ENABLE_LOCKING_STYLE\n  /*\n  **   PRAGMA [schema.]lock_proxy_file\n  **   PRAGMA [schema.]lock_proxy_file = \":auto:\"|\"lock_file_path\"\n  **\n  ** Return or set the value of the lock_proxy_file flag.  Changing\n  ** the value sets a specific file to be used for database access locks.\n  **\n  */\n  case PragTyp_LOCK_PROXY_FILE: {\n    if( !zRight ){\n      Pager *pPager = sqlite3BtreePager(pDb->pBt);\n      char *proxy_file_path = NULL;\n      sqlite3_file *pFile = sqlite3PagerFile(pPager);\n      sqlite3OsFileControlHint(pFile, SQLITE_GET_LOCKPROXYFILE, \n                           &proxy_file_path);\n      returnSingleText(v, proxy_file_path);\n    }else{\n      Pager *pPager = sqlite3BtreePager(pDb->pBt);\n      sqlite3_file *pFile = sqlite3PagerFile(pPager);\n      int res;\n      if( zRight[0] ){\n        res=sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE, \n                                     zRight);\n      } else {\n        res=sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE, \n                                     NULL);\n      }\n      if( res!=SQLITE_OK ){\n        sqlite3ErrorMsg(pParse, \"failed to set lock proxy file\");\n        goto pragma_out;\n      }\n    }\n    break;\n  }\n#endif /* SQLITE_ENABLE_LOCKING_STYLE */      \n    \n  /*\n  **   PRAGMA [schema.]synchronous\n  **   PRAGMA [schema.]synchronous=OFF|ON|NORMAL|FULL|EXTRA\n  **\n  ** Return or set the local value of the synchronous flag.  Changing\n  ** the local value does not make changes to the disk file and the\n  ** default value will be restored the next time the database is\n  ** opened.\n  */\n  case PragTyp_SYNCHRONOUS: {\n    if( !zRight ){\n      returnSingleInt(v, pDb->safety_level-1);\n    }else{\n      if( !db->autoCommit ){\n        sqlite3ErrorMsg(pParse, \n            \"Safety level may not be changed inside a transaction\");\n      }else if( iDb!=1 ){\n        int iLevel = (getSafetyLevel(zRight,0,1)+1) & PAGER_SYNCHRONOUS_MASK;\n        if( iLevel==0 ) iLevel = 1;\n        pDb->safety_level = iLevel;\n        pDb->bSyncSet = 1;\n        setAllPagerFlags(db);\n      }\n    }\n    break;\n  }\n#endif /* SQLITE_OMIT_PAGER_PRAGMAS */\n\n#ifndef SQLITE_OMIT_FLAG_PRAGMAS\n  case PragTyp_FLAG: {\n    if( zRight==0 ){\n      setPragmaResultColumnNames(v, pPragma);\n      returnSingleInt(v, (db->flags & pPragma->iArg)!=0 );\n    }else{\n      u64 mask = pPragma->iArg;    /* Mask of bits to set or clear. */\n      if( db->autoCommit==0 ){\n        /* Foreign key support may not be enabled or disabled while not\n        ** in auto-commit mode.  */\n        mask &= ~(SQLITE_ForeignKeys);\n      }\n#if SQLITE_USER_AUTHENTICATION\n      if( db->auth.authLevel==UAUTH_User ){\n        /* Do not allow non-admin users to modify the schema arbitrarily */\n        mask &= ~(SQLITE_WriteSchema);\n      }\n#endif\n\n      if( sqlite3GetBoolean(zRight, 0) ){\n        db->flags |= mask;\n      }else{\n        db->flags &= ~mask;\n        if( mask==SQLITE_DeferFKs ) db->nDeferredImmCons = 0;\n      }\n\n      /* Many of the flag-pragmas modify the code generated by the SQL \n      ** compiler (eg. count_changes). So add an opcode to expire all\n      ** compiled SQL statements after modifying a pragma value.\n      */\n      sqlite3VdbeAddOp0(v, OP_Expire);\n      setAllPagerFlags(db);\n    }\n    break;\n  }\n#endif /* SQLITE_OMIT_FLAG_PRAGMAS */\n\n#ifndef SQLITE_OMIT_SCHEMA_PRAGMAS\n  /*\n  **   PRAGMA table_info(<table>)\n  **\n  ** Return a single row for each column of the named table. The columns of\n  ** the returned data set are:\n  **\n  ** cid:        Column id (numbered from left to right, starting at 0)\n  ** name:       Column name\n  ** type:       Column declaration type.\n  ** notnull:    True if 'NOT NULL' is part of column declaration\n  ** dflt_value: The default value for the column, if any.\n  ** pk:         Non-zero for PK fields.\n  */\n  case PragTyp_TABLE_INFO: if( zRight ){\n    Table *pTab;\n    pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);\n    if( pTab ){\n      int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n      int i, k;\n      int nHidden = 0;\n      Column *pCol;\n      Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n      pParse->nMem = 7;\n      sqlite3CodeVerifySchema(pParse, iTabDb);\n      sqlite3ViewGetColumnNames(pParse, pTab);\n      for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){\n        int isHidden = 0;\n        if( pCol->colFlags & COLFLAG_NOINSERT ){\n          if( pPragma->iArg==0 ){\n            nHidden++;\n            continue;\n          }\n          if( pCol->colFlags & COLFLAG_VIRTUAL ){\n            isHidden = 2;  /* GENERATED ALWAYS AS ... VIRTUAL */\n          }else if( pCol->colFlags & COLFLAG_STORED ){\n            isHidden = 3;  /* GENERATED ALWAYS AS ... STORED */\n          }else{ assert( pCol->colFlags & COLFLAG_HIDDEN );\n            isHidden = 1;  /* HIDDEN */\n          }\n        }\n        if( (pCol->colFlags & COLFLAG_PRIMKEY)==0 ){\n          k = 0;\n        }else if( pPk==0 ){\n          k = 1;\n        }else{\n          for(k=1; k<=pTab->nCol && pPk->aiColumn[k-1]!=i; k++){}\n        }\n        assert( pCol->pDflt==0 || pCol->pDflt->op==TK_SPAN || isHidden>=2 );\n        sqlite3VdbeMultiLoad(v, 1, pPragma->iArg ? \"issisii\" : \"issisi\",\n               i-nHidden,\n               pCol->zName,\n               sqlite3ColumnType(pCol,\"\"),\n               pCol->notNull ? 1 : 0,\n               pCol->pDflt && isHidden<2 ? pCol->pDflt->u.zToken : 0,\n               k,\n               isHidden);\n      }\n    }\n  }\n  break;\n\n#ifdef SQLITE_DEBUG\n  case PragTyp_STATS: {\n    Index *pIdx;\n    HashElem *i;\n    pParse->nMem = 5;\n    sqlite3CodeVerifySchema(pParse, iDb);\n    for(i=sqliteHashFirst(&pDb->pSchema->tblHash); i; i=sqliteHashNext(i)){\n      Table *pTab = sqliteHashData(i);\n      sqlite3VdbeMultiLoad(v, 1, \"ssiii\",\n           pTab->zName,\n           0,\n           pTab->szTabRow,\n           pTab->nRowLogEst,\n           pTab->tabFlags);\n      for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n        sqlite3VdbeMultiLoad(v, 2, \"siiiX\",\n           pIdx->zName,\n           pIdx->szIdxRow,\n           pIdx->aiRowLogEst[0],\n           pIdx->hasStat1);\n        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 5);\n      }\n    }\n  }\n  break;\n#endif\n\n  case PragTyp_INDEX_INFO: if( zRight ){\n    Index *pIdx;\n    Table *pTab;\n    pIdx = sqlite3FindIndex(db, zRight, zDb);\n    if( pIdx==0 ){\n      /* If there is no index named zRight, check to see if there is a\n      ** WITHOUT ROWID table named zRight, and if there is, show the\n      ** structure of the PRIMARY KEY index for that table. */\n      pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);\n      if( pTab && !HasRowid(pTab) ){\n        pIdx = sqlite3PrimaryKeyIndex(pTab);\n      }\n    }\n    if( pIdx ){\n      int iIdxDb = sqlite3SchemaToIndex(db, pIdx->pSchema);\n      int i;\n      int mx;\n      if( pPragma->iArg ){\n        /* PRAGMA index_xinfo (newer version with more rows and columns) */\n        mx = pIdx->nColumn;\n        pParse->nMem = 6;\n      }else{\n        /* PRAGMA index_info (legacy version) */\n        mx = pIdx->nKeyCol;\n        pParse->nMem = 3;\n      }\n      pTab = pIdx->pTable;\n      sqlite3CodeVerifySchema(pParse, iIdxDb);\n      assert( pParse->nMem<=pPragma->nPragCName );\n      for(i=0; i<mx; i++){\n        i16 cnum = pIdx->aiColumn[i];\n        sqlite3VdbeMultiLoad(v, 1, \"iisX\", i, cnum,\n                             cnum<0 ? 0 : pTab->aCol[cnum].zName);\n        if( pPragma->iArg ){\n          sqlite3VdbeMultiLoad(v, 4, \"isiX\",\n            pIdx->aSortOrder[i],\n            pIdx->azColl[i],\n            i<pIdx->nKeyCol);\n        }\n        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, pParse->nMem);\n      }\n    }\n  }\n  break;\n\n  case PragTyp_INDEX_LIST: if( zRight ){\n    Index *pIdx;\n    Table *pTab;\n    int i;\n    pTab = sqlite3FindTable(db, zRight, zDb);\n    if( pTab ){\n      int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n      pParse->nMem = 5;\n      sqlite3CodeVerifySchema(pParse, iTabDb);\n      for(pIdx=pTab->pIndex, i=0; pIdx; pIdx=pIdx->pNext, i++){\n        const char *azOrigin[] = { \"c\", \"u\", \"pk\" };\n        sqlite3VdbeMultiLoad(v, 1, \"isisi\",\n           i,\n           pIdx->zName,\n           IsUniqueIndex(pIdx),\n           azOrigin[pIdx->idxType],\n           pIdx->pPartIdxWhere!=0);\n      }\n    }\n  }\n  break;\n\n  case PragTyp_DATABASE_LIST: {\n    int i;\n    pParse->nMem = 3;\n    for(i=0; i<db->nDb; i++){\n      if( db->aDb[i].pBt==0 ) continue;\n      assert( db->aDb[i].zDbSName!=0 );\n      sqlite3VdbeMultiLoad(v, 1, \"iss\",\n         i,\n         db->aDb[i].zDbSName,\n         sqlite3BtreeGetFilename(db->aDb[i].pBt));\n    }\n  }\n  break;\n\n  case PragTyp_COLLATION_LIST: {\n    int i = 0;\n    HashElem *p;\n    pParse->nMem = 2;\n    for(p=sqliteHashFirst(&db->aCollSeq); p; p=sqliteHashNext(p)){\n      CollSeq *pColl = (CollSeq *)sqliteHashData(p);\n      sqlite3VdbeMultiLoad(v, 1, \"is\", i++, pColl->zName);\n    }\n  }\n  break;\n\n#ifndef SQLITE_OMIT_INTROSPECTION_PRAGMAS\n  case PragTyp_FUNCTION_LIST: {\n    int i;\n    HashElem *j;\n    FuncDef *p;\n    pParse->nMem = 2;\n    for(i=0; i<SQLITE_FUNC_HASH_SZ; i++){\n      for(p=sqlite3BuiltinFunctions.a[i]; p; p=p->u.pHash ){\n        if( p->funcFlags & SQLITE_FUNC_INTERNAL ) continue;\n        sqlite3VdbeMultiLoad(v, 1, \"si\", p->zName, 1);\n      }\n    }\n    for(j=sqliteHashFirst(&db->aFunc); j; j=sqliteHashNext(j)){\n      p = (FuncDef*)sqliteHashData(j);\n      sqlite3VdbeMultiLoad(v, 1, \"si\", p->zName, 0);\n    }\n  }\n  break;\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  case PragTyp_MODULE_LIST: {\n    HashElem *j;\n    pParse->nMem = 1;\n    for(j=sqliteHashFirst(&db->aModule); j; j=sqliteHashNext(j)){\n      Module *pMod = (Module*)sqliteHashData(j);\n      sqlite3VdbeMultiLoad(v, 1, \"s\", pMod->zName);\n    }\n  }\n  break;\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n  case PragTyp_PRAGMA_LIST: {\n    int i;\n    for(i=0; i<ArraySize(aPragmaName); i++){\n      sqlite3VdbeMultiLoad(v, 1, \"s\", aPragmaName[i].zName);\n    }\n  }\n  break;\n#endif /* SQLITE_INTROSPECTION_PRAGMAS */\n\n#endif /* SQLITE_OMIT_SCHEMA_PRAGMAS */\n\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n  case PragTyp_FOREIGN_KEY_LIST: if( zRight ){\n    FKey *pFK;\n    Table *pTab;\n    pTab = sqlite3FindTable(db, zRight, zDb);\n    if( pTab ){\n      pFK = pTab->pFKey;\n      if( pFK ){\n        int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n        int i = 0; \n        pParse->nMem = 8;\n        sqlite3CodeVerifySchema(pParse, iTabDb);\n        while(pFK){\n          int j;\n          for(j=0; j<pFK->nCol; j++){\n            sqlite3VdbeMultiLoad(v, 1, \"iissssss\",\n                   i,\n                   j,\n                   pFK->zTo,\n                   pTab->aCol[pFK->aCol[j].iFrom].zName,\n                   pFK->aCol[j].zCol,\n                   actionName(pFK->aAction[1]),  /* ON UPDATE */\n                   actionName(pFK->aAction[0]),  /* ON DELETE */\n                   \"NONE\");\n          }\n          ++i;\n          pFK = pFK->pNextFrom;\n        }\n      }\n    }\n  }\n  break;\n#endif /* !defined(SQLITE_OMIT_FOREIGN_KEY) */\n\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n#ifndef SQLITE_OMIT_TRIGGER\n  case PragTyp_FOREIGN_KEY_CHECK: {\n    FKey *pFK;             /* A foreign key constraint */\n    Table *pTab;           /* Child table contain \"REFERENCES\" keyword */\n    Table *pParent;        /* Parent table that child points to */\n    Index *pIdx;           /* Index in the parent table */\n    int i;                 /* Loop counter:  Foreign key number for pTab */\n    int j;                 /* Loop counter:  Field of the foreign key */\n    HashElem *k;           /* Loop counter:  Next table in schema */\n    int x;                 /* result variable */\n    int regResult;         /* 3 registers to hold a result row */\n    int regKey;            /* Register to hold key for checking the FK */\n    int regRow;            /* Registers to hold a row from pTab */\n    int addrTop;           /* Top of a loop checking foreign keys */\n    int addrOk;            /* Jump here if the key is OK */\n    int *aiCols;           /* child to parent column mapping */\n\n    regResult = pParse->nMem+1;\n    pParse->nMem += 4;\n    regKey = ++pParse->nMem;\n    regRow = ++pParse->nMem;\n    k = sqliteHashFirst(&db->aDb[iDb].pSchema->tblHash);\n    while( k ){\n      int iTabDb;\n      if( zRight ){\n        pTab = sqlite3LocateTable(pParse, 0, zRight, zDb);\n        k = 0;\n      }else{\n        pTab = (Table*)sqliteHashData(k);\n        k = sqliteHashNext(k);\n      }\n      if( pTab==0 || pTab->pFKey==0 ) continue;\n      iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n      sqlite3CodeVerifySchema(pParse, iTabDb);\n      sqlite3TableLock(pParse, iTabDb, pTab->tnum, 0, pTab->zName);\n      if( pTab->nCol+regRow>pParse->nMem ) pParse->nMem = pTab->nCol + regRow;\n      sqlite3OpenTable(pParse, 0, iTabDb, pTab, OP_OpenRead);\n      sqlite3VdbeLoadString(v, regResult, pTab->zName);\n      for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom){\n        pParent = sqlite3FindTable(db, pFK->zTo, zDb);\n        if( pParent==0 ) continue;\n        pIdx = 0;\n        sqlite3TableLock(pParse, iTabDb, pParent->tnum, 0, pParent->zName);\n        x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, 0);\n        if( x==0 ){\n          if( pIdx==0 ){\n            sqlite3OpenTable(pParse, i, iTabDb, pParent, OP_OpenRead);\n          }else{\n            sqlite3VdbeAddOp3(v, OP_OpenRead, i, pIdx->tnum, iTabDb);\n            sqlite3VdbeSetP4KeyInfo(pParse, pIdx);\n          }\n        }else{\n          k = 0;\n          break;\n        }\n      }\n      assert( pParse->nErr>0 || pFK==0 );\n      if( pFK ) break;\n      if( pParse->nTab<i ) pParse->nTab = i;\n      addrTop = sqlite3VdbeAddOp1(v, OP_Rewind, 0); VdbeCoverage(v);\n      for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom){\n        pParent = sqlite3FindTable(db, pFK->zTo, zDb);\n        pIdx = 0;\n        aiCols = 0;\n        if( pParent ){\n          x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, &aiCols);\n          assert( x==0 );\n        }\n        addrOk = sqlite3VdbeMakeLabel(pParse);\n\n        /* Generate code to read the child key values into registers\n        ** regRow..regRow+n. If any of the child key values are NULL, this \n        ** row cannot cause an FK violation. Jump directly to addrOk in \n        ** this case. */\n        for(j=0; j<pFK->nCol; j++){\n          int iCol = aiCols ? aiCols[j] : pFK->aCol[j].iFrom;\n          sqlite3ExprCodeGetColumnOfTable(v, pTab, 0, iCol, regRow+j);\n          sqlite3VdbeAddOp2(v, OP_IsNull, regRow+j, addrOk); VdbeCoverage(v);\n        }\n\n        /* Generate code to query the parent index for a matching parent\n        ** key. If a match is found, jump to addrOk. */\n        if( pIdx ){\n          sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, pFK->nCol, regKey,\n              sqlite3IndexAffinityStr(db,pIdx), pFK->nCol);\n          sqlite3VdbeAddOp4Int(v, OP_Found, i, addrOk, regKey, 0);\n          VdbeCoverage(v);\n        }else if( pParent ){\n          int jmp = sqlite3VdbeCurrentAddr(v)+2;\n          sqlite3VdbeAddOp3(v, OP_SeekRowid, i, jmp, regRow); VdbeCoverage(v);\n          sqlite3VdbeGoto(v, addrOk);\n          assert( pFK->nCol==1 );\n        }\n\n        /* Generate code to report an FK violation to the caller. */\n        if( HasRowid(pTab) ){\n          sqlite3VdbeAddOp2(v, OP_Rowid, 0, regResult+1);\n        }else{\n          sqlite3VdbeAddOp2(v, OP_Null, 0, regResult+1);\n        }\n        sqlite3VdbeMultiLoad(v, regResult+2, \"siX\", pFK->zTo, i-1);\n        sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, 4);\n        sqlite3VdbeResolveLabel(v, addrOk);\n        sqlite3DbFree(db, aiCols);\n      }\n      sqlite3VdbeAddOp2(v, OP_Next, 0, addrTop+1); VdbeCoverage(v);\n      sqlite3VdbeJumpHere(v, addrTop);\n    }\n  }\n  break;\n#endif /* !defined(SQLITE_OMIT_TRIGGER) */\n#endif /* !defined(SQLITE_OMIT_FOREIGN_KEY) */\n\n#ifndef SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA\n  /* Reinstall the LIKE and GLOB functions.  The variant of LIKE\n  ** used will be case sensitive or not depending on the RHS.\n  */\n  case PragTyp_CASE_SENSITIVE_LIKE: {\n    if( zRight ){\n      sqlite3RegisterLikeFunctions(db, sqlite3GetBoolean(zRight, 0));\n    }\n  }\n  break;\n#endif /* SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA */\n\n#ifndef SQLITE_INTEGRITY_CHECK_ERROR_MAX\n# define SQLITE_INTEGRITY_CHECK_ERROR_MAX 100\n#endif\n\n#ifndef SQLITE_OMIT_INTEGRITY_CHECK\n  /*    PRAGMA integrity_check\n  **    PRAGMA integrity_check(N)\n  **    PRAGMA quick_check\n  **    PRAGMA quick_check(N)\n  **\n  ** Verify the integrity of the database.\n  **\n  ** The \"quick_check\" is reduced version of \n  ** integrity_check designed to detect most database corruption\n  ** without the overhead of cross-checking indexes.  Quick_check\n  ** is linear time wherease integrity_check is O(NlogN).\n  */\n  case PragTyp_INTEGRITY_CHECK: {\n    int i, j, addr, mxErr;\n\n    int isQuick = (sqlite3Tolower(zLeft[0])=='q');\n\n    /* If the PRAGMA command was of the form \"PRAGMA <db>.integrity_check\",\n    ** then iDb is set to the index of the database identified by <db>.\n    ** In this case, the integrity of database iDb only is verified by\n    ** the VDBE created below.\n    **\n    ** Otherwise, if the command was simply \"PRAGMA integrity_check\" (or\n    ** \"PRAGMA quick_check\"), then iDb is set to 0. In this case, set iDb\n    ** to -1 here, to indicate that the VDBE should verify the integrity\n    ** of all attached databases.  */\n    assert( iDb>=0 );\n    assert( iDb==0 || pId2->z );\n    if( pId2->z==0 ) iDb = -1;\n\n    /* Initialize the VDBE program */\n    pParse->nMem = 6;\n\n    /* Set the maximum error count */\n    mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;\n    if( zRight ){\n      sqlite3GetInt32(zRight, &mxErr);\n      if( mxErr<=0 ){\n        mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;\n      }\n    }\n    sqlite3VdbeAddOp2(v, OP_Integer, mxErr-1, 1); /* reg[1] holds errors left */\n\n    /* Do an integrity check on each database file */\n    for(i=0; i<db->nDb; i++){\n      HashElem *x;     /* For looping over tables in the schema */\n      Hash *pTbls;     /* Set of all tables in the schema */\n      int *aRoot;      /* Array of root page numbers of all btrees */\n      int cnt = 0;     /* Number of entries in aRoot[] */\n      int mxIdx = 0;   /* Maximum number of indexes for any table */\n\n      if( OMIT_TEMPDB && i==1 ) continue;\n      if( iDb>=0 && i!=iDb ) continue;\n\n      sqlite3CodeVerifySchema(pParse, i);\n\n      /* Do an integrity check of the B-Tree\n      **\n      ** Begin by finding the root pages numbers\n      ** for all tables and indices in the database.\n      */\n      assert( sqlite3SchemaMutexHeld(db, i, 0) );\n      pTbls = &db->aDb[i].pSchema->tblHash;\n      for(cnt=0, x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){\n        Table *pTab = sqliteHashData(x);  /* Current table */\n        Index *pIdx;                      /* An index on pTab */\n        int nIdx;                         /* Number of indexes on pTab */\n        if( HasRowid(pTab) ) cnt++;\n        for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){ cnt++; }\n        if( nIdx>mxIdx ) mxIdx = nIdx;\n      }\n      aRoot = sqlite3DbMallocRawNN(db, sizeof(int)*(cnt+1));\n      if( aRoot==0 ) break;\n      for(cnt=0, x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){\n        Table *pTab = sqliteHashData(x);\n        Index *pIdx;\n        if( HasRowid(pTab) ) aRoot[++cnt] = pTab->tnum;\n        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n          aRoot[++cnt] = pIdx->tnum;\n        }\n      }\n      aRoot[0] = cnt;\n\n      /* Make sure sufficient number of registers have been allocated */\n      pParse->nMem = MAX( pParse->nMem, 8+mxIdx );\n      sqlite3ClearTempRegCache(pParse);\n\n      /* Do the b-tree integrity checks */\n      sqlite3VdbeAddOp4(v, OP_IntegrityCk, 2, cnt, 1, (char*)aRoot,P4_INTARRAY);\n      sqlite3VdbeChangeP5(v, (u8)i);\n      addr = sqlite3VdbeAddOp1(v, OP_IsNull, 2); VdbeCoverage(v);\n      sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0,\n         sqlite3MPrintf(db, \"*** in database %s ***\\n\", db->aDb[i].zDbSName),\n         P4_DYNAMIC);\n      sqlite3VdbeAddOp3(v, OP_Concat, 2, 3, 3);\n      integrityCheckResultRow(v);\n      sqlite3VdbeJumpHere(v, addr);\n\n      /* Make sure all the indices are constructed correctly.\n      */\n      for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){\n        Table *pTab = sqliteHashData(x);\n        Index *pIdx, *pPk;\n        Index *pPrior = 0;\n        int loopTop;\n        int iDataCur, iIdxCur;\n        int r1 = -1;\n\n        if( pTab->tnum<1 ) continue;  /* Skip VIEWs or VIRTUAL TABLEs */\n        pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);\n        sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenRead, 0,\n                                   1, 0, &iDataCur, &iIdxCur);\n        /* reg[7] counts the number of entries in the table.\n        ** reg[8+i] counts the number of entries in the i-th index \n        */\n        sqlite3VdbeAddOp2(v, OP_Integer, 0, 7);\n        for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){\n          sqlite3VdbeAddOp2(v, OP_Integer, 0, 8+j); /* index entries counter */\n        }\n        assert( pParse->nMem>=8+j );\n        assert( sqlite3NoTempsInRange(pParse,1,7+j) );\n        sqlite3VdbeAddOp2(v, OP_Rewind, iDataCur, 0); VdbeCoverage(v);\n        loopTop = sqlite3VdbeAddOp2(v, OP_AddImm, 7, 1);\n        if( !isQuick ){\n          /* Sanity check on record header decoding */\n          sqlite3VdbeAddOp3(v, OP_Column, iDataCur, pTab->nNVCol-1,3);\n          sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n        }\n        /* Verify that all NOT NULL columns really are NOT NULL */\n        for(j=0; j<pTab->nCol; j++){\n          char *zErr;\n          int jmp2;\n          if( j==pTab->iPKey ) continue;\n          if( pTab->aCol[j].notNull==0 ) continue;\n          sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n",
        "suffix": "          jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);\n          zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,\n                              pTab->aCol[j].zName);\n          sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n          integrityCheckResultRow(v);\n          sqlite3VdbeJumpHere(v, jmp2);\n        }\n        /* Verify CHECK constraints */\n        if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){\n          ExprList *pCheck = sqlite3ExprListDup(db, pTab->pCheck, 0);\n          if( db->mallocFailed==0 ){\n            int addrCkFault = sqlite3VdbeMakeLabel(pParse);\n            int addrCkOk = sqlite3VdbeMakeLabel(pParse);\n            char *zErr;\n            int k;\n            pParse->iSelfTab = iDataCur + 1;\n            for(k=pCheck->nExpr-1; k>0; k--){\n              sqlite3ExprIfFalse(pParse, pCheck->a[k].pExpr, addrCkFault, 0);\n            }\n            sqlite3ExprIfTrue(pParse, pCheck->a[0].pExpr, addrCkOk, \n                SQLITE_JUMPIFNULL);\n            sqlite3VdbeResolveLabel(v, addrCkFault);\n            pParse->iSelfTab = 0;\n            zErr = sqlite3MPrintf(db, \"CHECK constraint failed in %s\",\n                pTab->zName);\n            sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n            integrityCheckResultRow(v);\n            sqlite3VdbeResolveLabel(v, addrCkOk);\n          }\n          sqlite3ExprListDelete(db, pCheck);\n        }\n        if( !isQuick ){ /* Omit the remaining tests for quick_check */\n          /* Validate index entries for the current row */\n          for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){\n            int jmp2, jmp3, jmp4, jmp5;\n            int ckUniq = sqlite3VdbeMakeLabel(pParse);\n            if( pPk==pIdx ) continue;\n            r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 0, &jmp3,\n                                         pPrior, r1);\n            pPrior = pIdx;\n            sqlite3VdbeAddOp2(v, OP_AddImm, 8+j, 1);/* increment entry count */\n            /* Verify that an index entry exists for the current table row */\n            jmp2 = sqlite3VdbeAddOp4Int(v, OP_Found, iIdxCur+j, ckUniq, r1,\n                                        pIdx->nColumn); VdbeCoverage(v);\n            sqlite3VdbeLoadString(v, 3, \"row \");\n            sqlite3VdbeAddOp3(v, OP_Concat, 7, 3, 3);\n            sqlite3VdbeLoadString(v, 4, \" missing from index \");\n            sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);\n            jmp5 = sqlite3VdbeLoadString(v, 4, pIdx->zName);\n            sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);\n            jmp4 = integrityCheckResultRow(v);\n            sqlite3VdbeJumpHere(v, jmp2);\n            /* For UNIQUE indexes, verify that only one entry exists with the\n            ** current key.  The entry is unique if (1) any column is NULL\n            ** or (2) the next entry has a different key */\n            if( IsUniqueIndex(pIdx) ){\n              int uniqOk = sqlite3VdbeMakeLabel(pParse);\n              int jmp6;\n              int kk;\n              for(kk=0; kk<pIdx->nKeyCol; kk++){\n                int iCol = pIdx->aiColumn[kk];\n                assert( iCol!=XN_ROWID && iCol<pTab->nCol );\n                if( iCol>=0 && pTab->aCol[iCol].notNull ) continue;\n                sqlite3VdbeAddOp2(v, OP_IsNull, r1+kk, uniqOk);\n                VdbeCoverage(v);\n              }\n              jmp6 = sqlite3VdbeAddOp1(v, OP_Next, iIdxCur+j); VdbeCoverage(v);\n              sqlite3VdbeGoto(v, uniqOk);\n              sqlite3VdbeJumpHere(v, jmp6);\n              sqlite3VdbeAddOp4Int(v, OP_IdxGT, iIdxCur+j, uniqOk, r1,\n                                   pIdx->nKeyCol); VdbeCoverage(v);\n              sqlite3VdbeLoadString(v, 3, \"non-unique entry in index \");\n              sqlite3VdbeGoto(v, jmp5);\n              sqlite3VdbeResolveLabel(v, uniqOk);\n            }\n            sqlite3VdbeJumpHere(v, jmp4);\n            sqlite3ResolvePartIdxLabel(pParse, jmp3);\n          }\n        }\n        sqlite3VdbeAddOp2(v, OP_Next, iDataCur, loopTop); VdbeCoverage(v);\n        sqlite3VdbeJumpHere(v, loopTop-1);\n#ifndef SQLITE_OMIT_BTREECOUNT\n        if( !isQuick ){\n          sqlite3VdbeLoadString(v, 2, \"wrong # of entries in index \");\n          for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){\n            if( pPk==pIdx ) continue;\n            sqlite3VdbeAddOp2(v, OP_Count, iIdxCur+j, 3);\n            addr = sqlite3VdbeAddOp3(v, OP_Eq, 8+j, 0, 3); VdbeCoverage(v);\n            sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);\n            sqlite3VdbeLoadString(v, 4, pIdx->zName);\n            sqlite3VdbeAddOp3(v, OP_Concat, 4, 2, 3);\n            integrityCheckResultRow(v);\n            sqlite3VdbeJumpHere(v, addr);\n          }\n        }\n#endif /* SQLITE_OMIT_BTREECOUNT */\n      } \n    }\n    {\n      static const int iLn = VDBE_OFFSET_LINENO(2);\n      static const VdbeOpList endCode[] = {\n        { OP_AddImm,      1, 0,        0},    /* 0 */\n        { OP_IfNotZero,   1, 4,        0},    /* 1 */\n        { OP_String8,     0, 3,        0},    /* 2 */\n        { OP_ResultRow,   3, 1,        0},    /* 3 */\n        { OP_Halt,        0, 0,        0},    /* 4 */\n        { OP_String8,     0, 3,        0},    /* 5 */\n        { OP_Goto,        0, 3,        0},    /* 6 */\n      };\n      VdbeOp *aOp;\n\n      aOp = sqlite3VdbeAddOpList(v, ArraySize(endCode), endCode, iLn);\n      if( aOp ){\n        aOp[0].p2 = 1-mxErr;\n        aOp[2].p4type = P4_STATIC;\n        aOp[2].p4.z = \"ok\";\n        aOp[5].p4type = P4_STATIC;\n        aOp[5].p4.z = (char*)sqlite3ErrStr(SQLITE_CORRUPT);\n      }\n      sqlite3VdbeChangeP3(v, 0, sqlite3VdbeCurrentAddr(v)-2);\n    }\n  }\n  break;\n#endif /* SQLITE_OMIT_INTEGRITY_CHECK */\n\n#ifndef SQLITE_OMIT_UTF16\n  /*\n  **   PRAGMA encoding\n  **   PRAGMA encoding = \"utf-8\"|\"utf-16\"|\"utf-16le\"|\"utf-16be\"\n  **\n  ** In its first form, this pragma returns the encoding of the main\n  ** database. If the database is not initialized, it is initialized now.\n  **\n  ** The second form of this pragma is a no-op if the main database file\n  ** has not already been initialized. In this case it sets the default\n  ** encoding that will be used for the main database file if a new file\n  ** is created. If an existing main database file is opened, then the\n  ** default text encoding for the existing database is used.\n  ** \n  ** In all cases new databases created using the ATTACH command are\n  ** created to use the same default text encoding as the main database. If\n  ** the main database has not been initialized and/or created when ATTACH\n  ** is executed, this is done before the ATTACH operation.\n  **\n  ** In the second form this pragma sets the text encoding to be used in\n  ** new database files created using this database handle. It is only\n  ** useful if invoked immediately after the main database i\n  */\n  case PragTyp_ENCODING: {\n    static const struct EncName {\n      char *zName;\n      u8 enc;\n    } encnames[] = {\n      { \"UTF8\",     SQLITE_UTF8        },\n      { \"UTF-8\",    SQLITE_UTF8        },  /* Must be element [1] */\n      { \"UTF-16le\", SQLITE_UTF16LE     },  /* Must be element [2] */\n      { \"UTF-16be\", SQLITE_UTF16BE     },  /* Must be element [3] */\n      { \"UTF16le\",  SQLITE_UTF16LE     },\n      { \"UTF16be\",  SQLITE_UTF16BE     },\n      { \"UTF-16\",   0                  }, /* SQLITE_UTF16NATIVE */\n      { \"UTF16\",    0                  }, /* SQLITE_UTF16NATIVE */\n      { 0, 0 }\n    };\n    const struct EncName *pEnc;\n    if( !zRight ){    /* \"PRAGMA encoding\" */\n      if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n      assert( encnames[SQLITE_UTF8].enc==SQLITE_UTF8 );\n      assert( encnames[SQLITE_UTF16LE].enc==SQLITE_UTF16LE );\n      assert( encnames[SQLITE_UTF16BE].enc==SQLITE_UTF16BE );\n      returnSingleText(v, encnames[ENC(pParse->db)].zName);\n    }else{                        /* \"PRAGMA encoding = XXX\" */\n      /* Only change the value of sqlite.enc if the database handle is not\n      ** initialized. If the main database exists, the new sqlite.enc value\n      ** will be overwritten when the schema is next loaded. If it does not\n      ** already exists, it will be created to use the new encoding value.\n      */\n      if( \n        !(DbHasProperty(db, 0, DB_SchemaLoaded)) || \n        DbHasProperty(db, 0, DB_Empty) \n      ){\n        for(pEnc=&encnames[0]; pEnc->zName; pEnc++){\n          if( 0==sqlite3StrICmp(zRight, pEnc->zName) ){\n            SCHEMA_ENC(db) = ENC(db) =\n                pEnc->enc ? pEnc->enc : SQLITE_UTF16NATIVE;\n            break;\n          }\n        }\n        if( !pEnc->zName ){\n          sqlite3ErrorMsg(pParse, \"unsupported encoding: %s\", zRight);\n        }\n      }\n    }\n  }\n  break;\n#endif /* SQLITE_OMIT_UTF16 */\n\n#ifndef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS\n  /*\n  **   PRAGMA [schema.]schema_version\n  **   PRAGMA [schema.]schema_version = <integer>\n  **\n  **   PRAGMA [schema.]user_version\n  **   PRAGMA [schema.]user_version = <integer>\n  **\n  **   PRAGMA [schema.]freelist_count\n  **\n  **   PRAGMA [schema.]data_version\n  **\n  **   PRAGMA [schema.]application_id\n  **   PRAGMA [schema.]application_id = <integer>\n  **\n  ** The pragma's schema_version and user_version are used to set or get\n  ** the value of the schema-version and user-version, respectively. Both\n  ** the schema-version and the user-version are 32-bit signed integers\n  ** stored in the database header.\n  **\n  ** The schema-cookie is usually only manipulated internally by SQLite. It\n  ** is incremented by SQLite whenever the database schema is modified (by\n  ** creating or dropping a table or index). The schema version is used by\n  ** SQLite each time a query is executed to ensure that the internal cache\n  ** of the schema used when compiling the SQL query matches the schema of\n  ** the database against which the compiled query is actually executed.\n  ** Subverting this mechanism by using \"PRAGMA schema_version\" to modify\n  ** the schema-version is potentially dangerous and may lead to program\n  ** crashes or database corruption. Use with caution!\n  **\n  ** The user-version is not used internally by SQLite. It may be used by\n  ** applications for any purpose.\n  */\n  case PragTyp_HEADER_VALUE: {\n    int iCookie = pPragma->iArg;  /* Which cookie to read or write */\n    sqlite3VdbeUsesBtree(v, iDb);\n    if( zRight && (pPragma->mPragFlg & PragFlg_ReadOnly)==0 ){\n      /* Write the specified cookie value */\n      static const VdbeOpList setCookie[] = {\n        { OP_Transaction,    0,  1,  0},    /* 0 */\n        { OP_SetCookie,      0,  0,  0},    /* 1 */\n      };\n      VdbeOp *aOp;\n      sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setCookie));\n      aOp = sqlite3VdbeAddOpList(v, ArraySize(setCookie), setCookie, 0);\n      if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;\n      aOp[0].p1 = iDb;\n      aOp[1].p1 = iDb;\n      aOp[1].p2 = iCookie;\n      aOp[1].p3 = sqlite3Atoi(zRight);\n    }else{\n      /* Read the specified cookie value */\n      static const VdbeOpList readCookie[] = {\n        { OP_Transaction,     0,  0,  0},    /* 0 */\n        { OP_ReadCookie,      0,  1,  0},    /* 1 */\n        { OP_ResultRow,       1,  1,  0}\n      };\n      VdbeOp *aOp;\n      sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(readCookie));\n      aOp = sqlite3VdbeAddOpList(v, ArraySize(readCookie),readCookie,0);\n      if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;\n      aOp[0].p1 = iDb;\n      aOp[1].p1 = iDb;\n      aOp[1].p3 = iCookie;\n      sqlite3VdbeReusable(v);\n    }\n  }\n  break;\n#endif /* SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS */\n\n#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS\n  /*\n  **   PRAGMA compile_options\n  **\n  ** Return the names of all compile-time options used in this build,\n  ** one option per row.\n  */\n  case PragTyp_COMPILE_OPTIONS: {\n    int i = 0;\n    const char *zOpt;\n    pParse->nMem = 1;\n    while( (zOpt = sqlite3_compileoption_get(i++))!=0 ){\n      sqlite3VdbeLoadString(v, 1, zOpt);\n      sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n    }\n    sqlite3VdbeReusable(v);\n  }\n  break;\n#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */\n\n#ifndef SQLITE_OMIT_WAL\n  /*\n  **   PRAGMA [schema.]wal_checkpoint = passive|full|restart|truncate\n  **\n  ** Checkpoint the database.\n  */\n  case PragTyp_WAL_CHECKPOINT: {\n    int iBt = (pId2->z?iDb:SQLITE_MAX_ATTACHED);\n    int eMode = SQLITE_CHECKPOINT_PASSIVE;\n    if( zRight ){\n      if( sqlite3StrICmp(zRight, \"full\")==0 ){\n        eMode = SQLITE_CHECKPOINT_FULL;\n      }else if( sqlite3StrICmp(zRight, \"restart\")==0 ){\n        eMode = SQLITE_CHECKPOINT_RESTART;\n      }else if( sqlite3StrICmp(zRight, \"truncate\")==0 ){\n        eMode = SQLITE_CHECKPOINT_TRUNCATE;\n      }\n    }\n    pParse->nMem = 3;\n    sqlite3VdbeAddOp3(v, OP_Checkpoint, iBt, eMode, 1);\n    sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);\n  }\n  break;\n\n  /*\n  **   PRAGMA wal_autocheckpoint\n  **   PRAGMA wal_autocheckpoint = N\n  **\n  ** Configure a database connection to automatically checkpoint a database\n  ** after accumulating N frames in the log. Or query for the current value\n  ** of N.\n  */\n  case PragTyp_WAL_AUTOCHECKPOINT: {\n    if( zRight ){\n      sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));\n    }\n    returnSingleInt(v, \n       db->xWalCallback==sqlite3WalDefaultHook ? \n           SQLITE_PTR_TO_INT(db->pWalArg) : 0);\n  }\n  break;\n#endif\n\n  /*\n  **  PRAGMA shrink_memory\n  **\n  ** IMPLEMENTATION-OF: R-23445-46109 This pragma causes the database\n  ** connection on which it is invoked to free up as much memory as it\n  ** can, by calling sqlite3_db_release_memory().\n  */\n  case PragTyp_SHRINK_MEMORY: {\n    sqlite3_db_release_memory(db);\n    break;\n  }\n\n  /*\n  **  PRAGMA optimize\n  **  PRAGMA optimize(MASK)\n  **  PRAGMA schema.optimize\n  **  PRAGMA schema.optimize(MASK)\n  **\n  ** Attempt to optimize the database.  All schemas are optimized in the first\n  ** two forms, and only the specified schema is optimized in the latter two.\n  **\n  ** The details of optimizations performed by this pragma are expected\n  ** to change and improve over time.  Applications should anticipate that\n  ** this pragma will perform new optimizations in future releases.\n  **\n  ** The optional argument is a bitmask of optimizations to perform:\n  **\n  **    0x0001    Debugging mode.  Do not actually perform any optimizations\n  **              but instead return one line of text for each optimization\n  **              that would have been done.  Off by default.\n  **\n  **    0x0002    Run ANALYZE on tables that might benefit.  On by default.\n  **              See below for additional information.\n  **\n  **    0x0004    (Not yet implemented) Record usage and performance \n  **              information from the current session in the\n  **              database file so that it will be available to \"optimize\"\n  **              pragmas run by future database connections.\n  **\n  **    0x0008    (Not yet implemented) Create indexes that might have\n  **              been helpful to recent queries\n  **\n  ** The default MASK is and always shall be 0xfffe.  0xfffe means perform all\n  ** of the optimizations listed above except Debug Mode, including new\n  ** optimizations that have not yet been invented.  If new optimizations are\n  ** ever added that should be off by default, those off-by-default \n  ** optimizations will have bitmasks of 0x10000 or larger.\n  **\n  ** DETERMINATION OF WHEN TO RUN ANALYZE\n  **\n  ** In the current implementation, a table is analyzed if only if all of\n  ** the following are true:\n  **\n  ** (1) MASK bit 0x02 is set.\n  **\n  ** (2) The query planner used sqlite_stat1-style statistics for one or\n  **     more indexes of the table at some point during the lifetime of\n  **     the current connection.\n  **\n  ** (3) One or more indexes of the table are currently unanalyzed OR\n  **     the number of rows in the table has increased by 25 times or more\n  **     since the last time ANALYZE was run.\n  **\n  ** The rules for when tables are analyzed are likely to change in\n  ** future releases.\n  */\n  case PragTyp_OPTIMIZE: {\n    int iDbLast;           /* Loop termination point for the schema loop */\n    int iTabCur;           /* Cursor for a table whose size needs checking */\n    HashElem *k;           /* Loop over tables of a schema */\n    Schema *pSchema;       /* The current schema */\n    Table *pTab;           /* A table in the schema */\n    Index *pIdx;           /* An index of the table */\n    LogEst szThreshold;    /* Size threshold above which reanalysis is needd */\n    char *zSubSql;         /* SQL statement for the OP_SqlExec opcode */\n    u32 opMask;            /* Mask of operations to perform */\n\n    if( zRight ){\n      opMask = (u32)sqlite3Atoi(zRight);\n      if( (opMask & 0x02)==0 ) break;\n    }else{\n      opMask = 0xfffe;\n    }\n    iTabCur = pParse->nTab++;\n    for(iDbLast = zDb?iDb:db->nDb-1; iDb<=iDbLast; iDb++){\n      if( iDb==1 ) continue;\n      sqlite3CodeVerifySchema(pParse, iDb);\n      pSchema = db->aDb[iDb].pSchema;\n      for(k=sqliteHashFirst(&pSchema->tblHash); k; k=sqliteHashNext(k)){\n        pTab = (Table*)sqliteHashData(k);\n\n        /* If table pTab has not been used in a way that would benefit from\n        ** having analysis statistics during the current session, then skip it.\n        ** This also has the effect of skipping virtual tables and views */\n        if( (pTab->tabFlags & TF_StatsUsed)==0 ) continue;\n\n        /* Reanalyze if the table is 25 times larger than the last analysis */\n        szThreshold = pTab->nRowLogEst + 46; assert( sqlite3LogEst(25)==46 );\n        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n          if( !pIdx->hasStat1 ){\n            szThreshold = 0; /* Always analyze if any index lacks statistics */\n            break;\n          }\n        }\n        if( szThreshold ){\n          sqlite3OpenTable(pParse, iTabCur, iDb, pTab, OP_OpenRead);\n          sqlite3VdbeAddOp3(v, OP_IfSmaller, iTabCur, \n                         sqlite3VdbeCurrentAddr(v)+2+(opMask&1), szThreshold);\n          VdbeCoverage(v);\n        }\n        zSubSql = sqlite3MPrintf(db, \"ANALYZE \\\"%w\\\".\\\"%w\\\"\",\n                                 db->aDb[iDb].zDbSName, pTab->zName);\n        if( opMask & 0x01 ){\n          int r1 = sqlite3GetTempReg(pParse);\n          sqlite3VdbeAddOp4(v, OP_String8, 0, r1, 0, zSubSql, P4_DYNAMIC);\n          sqlite3VdbeAddOp2(v, OP_ResultRow, r1, 1);\n        }else{\n          sqlite3VdbeAddOp4(v, OP_SqlExec, 0, 0, 0, zSubSql, P4_DYNAMIC);\n        }\n      }\n    }\n    sqlite3VdbeAddOp0(v, OP_Expire);\n    break;\n  }\n\n  /*\n  **   PRAGMA busy_timeout\n  **   PRAGMA busy_timeout = N\n  **\n  ** Call sqlite3_busy_timeout(db, N).  Return the current timeout value\n  ** if one is set.  If no busy handler or a different busy handler is set\n  ** then 0 is returned.  Setting the busy_timeout to 0 or negative\n  ** disables the timeout.\n  */\n  /*case PragTyp_BUSY_TIMEOUT*/ default: {\n    assert( pPragma->ePragTyp==PragTyp_BUSY_TIMEOUT );\n    if( zRight ){\n      sqlite3_busy_timeout(db, sqlite3Atoi(zRight));\n    }\n    returnSingleInt(v, db->busyTimeout);\n    break;\n  }\n\n  /*\n  **   PRAGMA soft_heap_limit\n  **   PRAGMA soft_heap_limit = N\n  **\n  ** IMPLEMENTATION-OF: R-26343-45930 This pragma invokes the\n  ** sqlite3_soft_heap_limit64() interface with the argument N, if N is\n  ** specified and is a non-negative integer.\n  ** IMPLEMENTATION-OF: R-64451-07163 The soft_heap_limit pragma always\n  ** returns the same integer that would be returned by the\n  ** sqlite3_soft_heap_limit64(-1) C-language function.\n  */\n  case PragTyp_SOFT_HEAP_LIMIT: {\n    sqlite3_int64 N;\n    if( zRight && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK ){\n      sqlite3_soft_heap_limit64(N);\n    }\n    returnSingleInt(v, sqlite3_soft_heap_limit64(-1));\n    break;\n  }\n\n  /*\n  **   PRAGMA hard_heap_limit\n  **   PRAGMA hard_heap_limit = N\n  **\n  ** Invoke sqlite3_hard_heap_limit64() to query or set the hard heap\n  ** limit.  The hard heap limit can be activated or lowered by this\n  ** pragma, but not raised or deactivated.  Only the\n  ** sqlite3_hard_heap_limit64() C-language API can raise or deactivate\n  ** the hard heap limit.  This allows an application to set a heap limit\n  ** constraint that cannot be relaxed by an untrusted SQL script.\n  */\n  case PragTyp_HARD_HEAP_LIMIT: {\n    sqlite3_int64 N;\n    if( zRight && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK ){\n      sqlite3_int64 iPrior = sqlite3_hard_heap_limit64(-1);\n      if( N>0 && (iPrior==0 || iPrior>N) ) sqlite3_hard_heap_limit64(N);\n    }\n    returnSingleInt(v, sqlite3_hard_heap_limit64(-1));\n    break;\n  }\n\n  /*\n  **   PRAGMA threads\n  **   PRAGMA threads = N\n  **\n  ** Configure the maximum number of worker threads.  Return the new\n  ** maximum, which might be less than requested.\n  */\n  case PragTyp_THREADS: {\n    sqlite3_int64 N;\n    if( zRight\n     && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK\n     && N>=0\n    ){\n      sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, (int)(N&0x7fffffff));\n    }\n    returnSingleInt(v, sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, -1));\n    break;\n  }\n\n#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)\n  /*\n  ** Report the current state of file logs for all databases\n  */\n  case PragTyp_LOCK_STATUS: {\n    static const char *const azLockName[] = {\n      \"unlocked\", \"shared\", \"reserved\", \"pending\", \"exclusive\"\n    };\n    int i;\n    pParse->nMem = 2;\n    for(i=0; i<db->nDb; i++){\n      Btree *pBt;\n      const char *zState = \"unknown\";\n      int j;\n      if( db->aDb[i].zDbSName==0 ) continue;\n      pBt = db->aDb[i].pBt;\n      if( pBt==0 || sqlite3BtreePager(pBt)==0 ){\n        zState = \"closed\";\n      }else if( sqlite3_file_control(db, i ? db->aDb[i].zDbSName : 0, \n                                     SQLITE_FCNTL_LOCKSTATE, &j)==SQLITE_OK ){\n         zState = azLockName[j];\n      }\n      sqlite3VdbeMultiLoad(v, 1, \"ss\", db->aDb[i].zDbSName, zState);\n    }\n    break;\n  }\n#endif\n\n#ifdef SQLITE_HAS_CODEC\n  /* Pragma        iArg\n  ** ----------   ------\n  **  key           0\n  **  rekey         1\n  **  hexkey        2\n  **  hexrekey      3\n  **  textkey       4\n  **  textrekey     5\n  */\n  case PragTyp_KEY: {\n    if( zRight ){\n      char zBuf[40];\n      const char *zKey = zRight;\n      int n;\n      if( pPragma->iArg==2 || pPragma->iArg==3 ){\n        u8 iByte;\n        int i;\n        for(i=0, iByte=0; i<sizeof(zBuf)*2 && sqlite3Isxdigit(zRight[i]); i++){\n          iByte = (iByte<<4) + sqlite3HexToInt(zRight[i]);\n          if( (i&1)!=0 ) zBuf[i/2] = iByte;\n        }\n        zKey = zBuf;\n        n = i/2;\n      }else{\n        n = pPragma->iArg<4 ? sqlite3Strlen30(zRight) : -1;\n      }\n      if( (pPragma->iArg & 1)==0 ){\n        rc = sqlite3_key_v2(db, zDb, zKey, n);\n      }else{\n        rc = sqlite3_rekey_v2(db, zDb, zKey, n);\n      }\n      if( rc==SQLITE_OK && n!=0 ){\n        sqlite3VdbeSetNumCols(v, 1);\n        sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"ok\", SQLITE_STATIC);\n        returnSingleText(v, \"ok\");\n      }\n    }\n    break;\n  }\n#endif\n#if defined(SQLITE_HAS_CODEC) || defined(SQLITE_ENABLE_CEROD)\n  case PragTyp_ACTIVATE_EXTENSIONS: if( zRight ){\n#ifdef SQLITE_HAS_CODEC\n    if( sqlite3StrNICmp(zRight, \"see-\", 4)==0 ){\n      sqlite3_activate_see(&zRight[4]);\n    }\n#endif\n#ifdef SQLITE_ENABLE_CEROD\n    if( sqlite3StrNICmp(zRight, \"cerod-\", 6)==0 ){\n      sqlite3_activate_cerod(&zRight[6]);\n    }\n#endif\n  }\n  break;\n#endif\n\n  } /* End of the PRAGMA switch */\n\n  /* The following block is a no-op unless SQLITE_DEBUG is defined. Its only\n  ** purpose is to execute assert() statements to verify that if the\n  ** PragFlg_NoColumns1 flag is set and the caller specified an argument\n  ** to the PRAGMA, the implementation has not added any OP_ResultRow \n  ** instructions to the VM.  */\n  if( (pPragma->mPragFlg & PragFlg_NoColumns1) && zRight ){\n    sqlite3VdbeVerifyNoResultRow(v);\n  }\n\npragma_out:\n  sqlite3DbFree(db, zLeft);\n  sqlite3DbFree(db, zRight);\n}\n",
        "start": 329,
        "end": 2231,
        "buggy": "void sqlite3Pragma(\n  Parse *pParse, \n  Token *pId1,        /* First part of [schema.]id field */\n  Token *pId2,        /* Second part of [schema.]id field, or NULL */\n  Token *pValue,      /* Token for <value>, or NULL */\n  int minusFlag       /* True if a '-' sign preceded <value> */\n){\n  char *zLeft = 0;       /* Nul-terminated UTF-8 string <id> */\n  char *zRight = 0;      /* Nul-terminated UTF-8 string <value>, or NULL */\n  const char *zDb = 0;   /* The database name */\n  Token *pId;            /* Pointer to <id> token */\n  char *aFcntl[4];       /* Argument to SQLITE_FCNTL_PRAGMA */\n  int iDb;               /* Database index for <database> */\n  int rc;                      /* return value form SQLITE_FCNTL_PRAGMA */\n  sqlite3 *db = pParse->db;    /* The database connection */\n  Db *pDb;                     /* The specific database being pragmaed */\n  Vdbe *v = sqlite3GetVdbe(pParse);  /* Prepared statement */\n  const PragmaName *pPragma;   /* The pragma */\n\n  if( v==0 ) return;\n  sqlite3VdbeRunOnlyOnce(v);\n  pParse->nMem = 2;\n\n  /* Interpret the [schema.] part of the pragma statement. iDb is the\n  ** index of the database this pragma is being applied to in db.aDb[]. */\n  iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);\n  if( iDb<0 ) return;\n  pDb = &db->aDb[iDb];\n\n  /* If the temp database has been explicitly named as part of the \n  ** pragma, make sure it is open. \n  */\n  if( iDb==1 && sqlite3OpenTempDatabase(pParse) ){\n    return;\n  }\n\n  zLeft = sqlite3NameFromToken(db, pId);\n  if( !zLeft ) return;\n  if( minusFlag ){\n    zRight = sqlite3MPrintf(db, \"-%T\", pValue);\n  }else{\n    zRight = sqlite3NameFromToken(db, pValue);\n  }\n\n  assert( pId2 );\n  zDb = pId2->n>0 ? pDb->zDbSName : 0;\n  if( sqlite3AuthCheck(pParse, SQLITE_PRAGMA, zLeft, zRight, zDb) ){\n    goto pragma_out;\n  }\n\n  /* Send an SQLITE_FCNTL_PRAGMA file-control to the underlying VFS\n  ** connection.  If it returns SQLITE_OK, then assume that the VFS\n  ** handled the pragma and generate a no-op prepared statement.\n  **\n  ** IMPLEMENTATION-OF: R-12238-55120 Whenever a PRAGMA statement is parsed,\n  ** an SQLITE_FCNTL_PRAGMA file control is sent to the open sqlite3_file\n  ** object corresponding to the database file to which the pragma\n  ** statement refers.\n  **\n  ** IMPLEMENTATION-OF: R-29875-31678 The argument to the SQLITE_FCNTL_PRAGMA\n  ** file control is an array of pointers to strings (char**) in which the\n  ** second element of the array is the name of the pragma and the third\n  ** element is the argument to the pragma or NULL if the pragma has no\n  ** argument.\n  */\n  aFcntl[0] = 0;\n  aFcntl[1] = zLeft;\n  aFcntl[2] = zRight;\n  aFcntl[3] = 0;\n  db->busyHandler.nBusy = 0;\n  rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_PRAGMA, (void*)aFcntl);\n  if( rc==SQLITE_OK ){\n    sqlite3VdbeSetNumCols(v, 1);\n    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, aFcntl[0], SQLITE_TRANSIENT);\n    returnSingleText(v, aFcntl[0]);\n    sqlite3_free(aFcntl[0]);\n    goto pragma_out;\n  }\n  if( rc!=SQLITE_NOTFOUND ){\n    if( aFcntl[0] ){\n      sqlite3ErrorMsg(pParse, \"%s\", aFcntl[0]);\n      sqlite3_free(aFcntl[0]);\n    }\n    pParse->nErr++;\n    pParse->rc = rc;\n    goto pragma_out;\n  }\n\n  /* Locate the pragma in the lookup table */\n  pPragma = pragmaLocate(zLeft);\n  if( pPragma==0 ) goto pragma_out;\n\n  /* Make sure the database schema is loaded if the pragma requires that */\n  if( (pPragma->mPragFlg & PragFlg_NeedSchema)!=0 ){\n    if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n  }\n\n  /* Register the result column names for pragmas that return results */\n  if( (pPragma->mPragFlg & PragFlg_NoColumns)==0 \n   && ((pPragma->mPragFlg & PragFlg_NoColumns1)==0 || zRight==0)\n  ){\n    setPragmaResultColumnNames(v, pPragma);\n  }\n\n  /* Jump to the appropriate pragma handler */\n  switch( pPragma->ePragTyp ){\n  \n#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) && !defined(SQLITE_OMIT_DEPRECATED)\n  /*\n  **  PRAGMA [schema.]default_cache_size\n  **  PRAGMA [schema.]default_cache_size=N\n  **\n  ** The first form reports the current persistent setting for the\n  ** page cache size.  The value returned is the maximum number of\n  ** pages in the page cache.  The second form sets both the current\n  ** page cache size value and the persistent page cache size value\n  ** stored in the database file.\n  **\n  ** Older versions of SQLite would set the default cache size to a\n  ** negative number to indicate synchronous=OFF.  These days, synchronous\n  ** is always on by default regardless of the sign of the default cache\n  ** size.  But continue to take the absolute value of the default cache\n  ** size of historical compatibility.\n  */\n  case PragTyp_DEFAULT_CACHE_SIZE: {\n    static const int iLn = VDBE_OFFSET_LINENO(2);\n    static const VdbeOpList getCacheSize[] = {\n      { OP_Transaction, 0, 0,        0},                         /* 0 */\n      { OP_ReadCookie,  0, 1,        BTREE_DEFAULT_CACHE_SIZE},  /* 1 */\n      { OP_IfPos,       1, 8,        0},\n      { OP_Integer,     0, 2,        0},\n      { OP_Subtract,    1, 2,        1},\n      { OP_IfPos,       1, 8,        0},\n      { OP_Integer,     0, 1,        0},                         /* 6 */\n      { OP_Noop,        0, 0,        0},\n      { OP_ResultRow,   1, 1,        0},\n    };\n    VdbeOp *aOp;\n    sqlite3VdbeUsesBtree(v, iDb);\n    if( !zRight ){\n      pParse->nMem += 2;\n      sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(getCacheSize));\n      aOp = sqlite3VdbeAddOpList(v, ArraySize(getCacheSize), getCacheSize, iLn);\n      if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;\n      aOp[0].p1 = iDb;\n      aOp[1].p1 = iDb;\n      aOp[6].p1 = SQLITE_DEFAULT_CACHE_SIZE;\n    }else{\n      int size = sqlite3AbsInt32(sqlite3Atoi(zRight));\n      sqlite3BeginWriteOperation(pParse, 0, iDb);\n      sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_DEFAULT_CACHE_SIZE, size);\n      assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n      pDb->pSchema->cache_size = size;\n      sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n    }\n    break;\n  }\n#endif /* !SQLITE_OMIT_PAGER_PRAGMAS && !SQLITE_OMIT_DEPRECATED */\n\n#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)\n  /*\n  **  PRAGMA [schema.]page_size\n  **  PRAGMA [schema.]page_size=N\n  **\n  ** The first form reports the current setting for the\n  ** database page size in bytes.  The second form sets the\n  ** database page size value.  The value can only be set if\n  ** the database has not yet been created.\n  */\n  case PragTyp_PAGE_SIZE: {\n    Btree *pBt = pDb->pBt;\n    assert( pBt!=0 );\n    if( !zRight ){\n      int size = ALWAYS(pBt) ? sqlite3BtreeGetPageSize(pBt) : 0;\n      returnSingleInt(v, size);\n    }else{\n      /* Malloc may fail when setting the page-size, as there is an internal\n      ** buffer that the pager module resizes using sqlite3_realloc().\n      */\n      db->nextPagesize = sqlite3Atoi(zRight);\n      if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db->nextPagesize,-1,0) ){\n        sqlite3OomFault(db);\n      }\n    }\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]secure_delete\n  **  PRAGMA [schema.]secure_delete=ON/OFF/FAST\n  **\n  ** The first form reports the current setting for the\n  ** secure_delete flag.  The second form changes the secure_delete\n  ** flag setting and reports the new value.\n  */\n  case PragTyp_SECURE_DELETE: {\n    Btree *pBt = pDb->pBt;\n    int b = -1;\n    assert( pBt!=0 );\n    if( zRight ){\n      if( sqlite3_stricmp(zRight, \"fast\")==0 ){\n        b = 2;\n      }else{\n        b = sqlite3GetBoolean(zRight, 0);\n      }\n    }\n    if( pId2->n==0 && b>=0 ){\n      int ii;\n      for(ii=0; ii<db->nDb; ii++){\n        sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);\n      }\n    }\n    b = sqlite3BtreeSecureDelete(pBt, b);\n    returnSingleInt(v, b);\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]max_page_count\n  **  PRAGMA [schema.]max_page_count=N\n  **\n  ** The first form reports the current setting for the\n  ** maximum number of pages in the database file.  The \n  ** second form attempts to change this setting.  Both\n  ** forms return the current setting.\n  **\n  ** The absolute value of N is used.  This is undocumented and might\n  ** change.  The only purpose is to provide an easy way to test\n  ** the sqlite3AbsInt32() function.\n  **\n  **  PRAGMA [schema.]page_count\n  **\n  ** Return the number of pages in the specified database.\n  */\n  case PragTyp_PAGE_COUNT: {\n    int iReg;\n    sqlite3CodeVerifySchema(pParse, iDb);\n    iReg = ++pParse->nMem;\n    if( sqlite3Tolower(zLeft[0])=='p' ){\n      sqlite3VdbeAddOp2(v, OP_Pagecount, iDb, iReg);\n    }else{\n      sqlite3VdbeAddOp3(v, OP_MaxPgcnt, iDb, iReg, \n                        sqlite3AbsInt32(sqlite3Atoi(zRight)));\n    }\n    sqlite3VdbeAddOp2(v, OP_ResultRow, iReg, 1);\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]locking_mode\n  **  PRAGMA [schema.]locking_mode = (normal|exclusive)\n  */\n  case PragTyp_LOCKING_MODE: {\n    const char *zRet = \"normal\";\n    int eMode = getLockingMode(zRight);\n\n    if( pId2->n==0 && eMode==PAGER_LOCKINGMODE_QUERY ){\n      /* Simple \"PRAGMA locking_mode;\" statement. This is a query for\n      ** the current default locking mode (which may be different to\n      ** the locking-mode of the main database).\n      */\n      eMode = db->dfltLockMode;\n    }else{\n      Pager *pPager;\n      if( pId2->n==0 ){\n        /* This indicates that no database name was specified as part\n        ** of the PRAGMA command. In this case the locking-mode must be\n        ** set on all attached databases, as well as the main db file.\n        **\n        ** Also, the sqlite3.dfltLockMode variable is set so that\n        ** any subsequently attached databases also use the specified\n        ** locking mode.\n        */\n        int ii;\n        assert(pDb==&db->aDb[0]);\n        for(ii=2; ii<db->nDb; ii++){\n          pPager = sqlite3BtreePager(db->aDb[ii].pBt);\n          sqlite3PagerLockingMode(pPager, eMode);\n        }\n        db->dfltLockMode = (u8)eMode;\n      }\n      pPager = sqlite3BtreePager(pDb->pBt);\n      eMode = sqlite3PagerLockingMode(pPager, eMode);\n    }\n\n    assert( eMode==PAGER_LOCKINGMODE_NORMAL\n            || eMode==PAGER_LOCKINGMODE_EXCLUSIVE );\n    if( eMode==PAGER_LOCKINGMODE_EXCLUSIVE ){\n      zRet = \"exclusive\";\n    }\n    returnSingleText(v, zRet);\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]journal_mode\n  **  PRAGMA [schema.]journal_mode =\n  **                      (delete|persist|off|truncate|memory|wal|off)\n  */\n  case PragTyp_JOURNAL_MODE: {\n    int eMode;        /* One of the PAGER_JOURNALMODE_XXX symbols */\n    int ii;           /* Loop counter */\n\n    if( zRight==0 ){\n      /* If there is no \"=MODE\" part of the pragma, do a query for the\n      ** current mode */\n      eMode = PAGER_JOURNALMODE_QUERY;\n    }else{\n      const char *zMode;\n      int n = sqlite3Strlen30(zRight);\n      for(eMode=0; (zMode = sqlite3JournalModename(eMode))!=0; eMode++){\n        if( sqlite3StrNICmp(zRight, zMode, n)==0 ) break;\n      }\n      if( !zMode ){\n        /* If the \"=MODE\" part does not match any known journal mode,\n        ** then do a query */\n        eMode = PAGER_JOURNALMODE_QUERY;\n      }\n      if( eMode==PAGER_JOURNALMODE_OFF && (db->flags & SQLITE_Defensive)!=0 ){\n        /* Do not allow journal-mode \"OFF\" in defensive since the database\n        ** can become corrupted using ordinary SQL when the journal is off */\n        eMode = PAGER_JOURNALMODE_QUERY;\n      }\n    }\n    if( eMode==PAGER_JOURNALMODE_QUERY && pId2->n==0 ){\n      /* Convert \"PRAGMA journal_mode\" into \"PRAGMA main.journal_mode\" */\n      iDb = 0;\n      pId2->n = 1;\n    }\n    for(ii=db->nDb-1; ii>=0; ii--){\n      if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){\n        sqlite3VdbeUsesBtree(v, ii);\n        sqlite3VdbeAddOp3(v, OP_JournalMode, ii, 1, eMode);\n      }\n    }\n    sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]journal_size_limit\n  **  PRAGMA [schema.]journal_size_limit=N\n  **\n  ** Get or set the size limit on rollback journal files.\n  */\n  case PragTyp_JOURNAL_SIZE_LIMIT: {\n    Pager *pPager = sqlite3BtreePager(pDb->pBt);\n    i64 iLimit = -2;\n    if( zRight ){\n      sqlite3DecOrHexToI64(zRight, &iLimit);\n      if( iLimit<-1 ) iLimit = -1;\n    }\n    iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit);\n    returnSingleInt(v, iLimit);\n    break;\n  }\n\n#endif /* SQLITE_OMIT_PAGER_PRAGMAS */\n\n  /*\n  **  PRAGMA [schema.]auto_vacuum\n  **  PRAGMA [schema.]auto_vacuum=N\n  **\n  ** Get or set the value of the database 'auto-vacuum' parameter.\n  ** The value is one of:  0 NONE 1 FULL 2 INCREMENTAL\n  */\n#ifndef SQLITE_OMIT_AUTOVACUUM\n  case PragTyp_AUTO_VACUUM: {\n    Btree *pBt = pDb->pBt;\n    assert( pBt!=0 );\n    if( !zRight ){\n      returnSingleInt(v, sqlite3BtreeGetAutoVacuum(pBt));\n    }else{\n      int eAuto = getAutoVacuum(zRight);\n      assert( eAuto>=0 && eAuto<=2 );\n      db->nextAutovac = (u8)eAuto;\n      /* Call SetAutoVacuum() to set initialize the internal auto and\n      ** incr-vacuum flags. This is required in case this connection\n      ** creates the database file. It is important that it is created\n      ** as an auto-vacuum capable db.\n      */\n      rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto);\n      if( rc==SQLITE_OK && (eAuto==1 || eAuto==2) ){\n        /* When setting the auto_vacuum mode to either \"full\" or \n        ** \"incremental\", write the value of meta[6] in the database\n        ** file. Before writing to meta[6], check that meta[3] indicates\n        ** that this really is an auto-vacuum capable database.\n        */\n        static const int iLn = VDBE_OFFSET_LINENO(2);\n        static const VdbeOpList setMeta6[] = {\n          { OP_Transaction,    0,         1,                 0},    /* 0 */\n          { OP_ReadCookie,     0,         1,         BTREE_LARGEST_ROOT_PAGE},\n          { OP_If,             1,         0,                 0},    /* 2 */\n          { OP_Halt,           SQLITE_OK, OE_Abort,          0},    /* 3 */\n          { OP_SetCookie,      0,         BTREE_INCR_VACUUM, 0},    /* 4 */\n        };\n        VdbeOp *aOp;\n        int iAddr = sqlite3VdbeCurrentAddr(v);\n        sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setMeta6));\n        aOp = sqlite3VdbeAddOpList(v, ArraySize(setMeta6), setMeta6, iLn);\n        if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;\n        aOp[0].p1 = iDb;\n        aOp[1].p1 = iDb;\n        aOp[2].p2 = iAddr+4;\n        aOp[4].p1 = iDb;\n        aOp[4].p3 = eAuto - 1;\n        sqlite3VdbeUsesBtree(v, iDb);\n      }\n    }\n    break;\n  }\n#endif\n\n  /*\n  **  PRAGMA [schema.]incremental_vacuum(N)\n  **\n  ** Do N steps of incremental vacuuming on a database.\n  */\n#ifndef SQLITE_OMIT_AUTOVACUUM\n  case PragTyp_INCREMENTAL_VACUUM: {\n    int iLimit, addr;\n    if( zRight==0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit<=0 ){\n      iLimit = 0x7fffffff;\n    }\n    sqlite3BeginWriteOperation(pParse, 0, iDb);\n    sqlite3VdbeAddOp2(v, OP_Integer, iLimit, 1);\n    addr = sqlite3VdbeAddOp1(v, OP_IncrVacuum, iDb); VdbeCoverage(v);\n    sqlite3VdbeAddOp1(v, OP_ResultRow, 1);\n    sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1);\n    sqlite3VdbeAddOp2(v, OP_IfPos, 1, addr); VdbeCoverage(v);\n    sqlite3VdbeJumpHere(v, addr);\n    break;\n  }\n#endif\n\n#ifndef SQLITE_OMIT_PAGER_PRAGMAS\n  /*\n  **  PRAGMA [schema.]cache_size\n  **  PRAGMA [schema.]cache_size=N\n  **\n  ** The first form reports the current local setting for the\n  ** page cache size. The second form sets the local\n  ** page cache size value.  If N is positive then that is the\n  ** number of pages in the cache.  If N is negative, then the\n  ** number of pages is adjusted so that the cache uses -N kibibytes\n  ** of memory.\n  */\n  case PragTyp_CACHE_SIZE: {\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    if( !zRight ){\n      returnSingleInt(v, pDb->pSchema->cache_size);\n    }else{\n      int size = sqlite3Atoi(zRight);\n      pDb->pSchema->cache_size = size;\n      sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n    }\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]cache_spill\n  **  PRAGMA cache_spill=BOOLEAN\n  **  PRAGMA [schema.]cache_spill=N\n  **\n  ** The first form reports the current local setting for the\n  ** page cache spill size. The second form turns cache spill on\n  ** or off.  When turnning cache spill on, the size is set to the\n  ** current cache_size.  The third form sets a spill size that\n  ** may be different form the cache size.\n  ** If N is positive then that is the\n  ** number of pages in the cache.  If N is negative, then the\n  ** number of pages is adjusted so that the cache uses -N kibibytes\n  ** of memory.\n  **\n  ** If the number of cache_spill pages is less then the number of\n  ** cache_size pages, no spilling occurs until the page count exceeds\n  ** the number of cache_size pages.\n  **\n  ** The cache_spill=BOOLEAN setting applies to all attached schemas,\n  ** not just the schema specified.\n  */\n  case PragTyp_CACHE_SPILL: {\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    if( !zRight ){\n      returnSingleInt(v,\n         (db->flags & SQLITE_CacheSpill)==0 ? 0 : \n            sqlite3BtreeSetSpillSize(pDb->pBt,0));\n    }else{\n      int size = 1;\n      if( sqlite3GetInt32(zRight, &size) ){\n        sqlite3BtreeSetSpillSize(pDb->pBt, size);\n      }\n      if( sqlite3GetBoolean(zRight, size!=0) ){\n        db->flags |= SQLITE_CacheSpill;\n      }else{\n        db->flags &= ~(u64)SQLITE_CacheSpill;\n      }\n      setAllPagerFlags(db);\n    }\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]mmap_size(N)\n  **\n  ** Used to set mapping size limit. The mapping size limit is\n  ** used to limit the aggregate size of all memory mapped regions of the\n  ** database file. If this parameter is set to zero, then memory mapping\n  ** is not used at all.  If N is negative, then the default memory map\n  ** limit determined by sqlite3_config(SQLITE_CONFIG_MMAP_SIZE) is set.\n  ** The parameter N is measured in bytes.\n  **\n  ** This value is advisory.  The underlying VFS is free to memory map\n  ** as little or as much as it wants.  Except, if N is set to 0 then the\n  ** upper layers will never invoke the xFetch interfaces to the VFS.\n  */\n  case PragTyp_MMAP_SIZE: {\n    sqlite3_int64 sz;\n#if SQLITE_MAX_MMAP_SIZE>0\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    if( zRight ){\n      int ii;\n      sqlite3DecOrHexToI64(zRight, &sz);\n      if( sz<0 ) sz = sqlite3GlobalConfig.szMmap;\n      if( pId2->n==0 ) db->szMmap = sz;\n      for(ii=db->nDb-1; ii>=0; ii--){\n        if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){\n          sqlite3BtreeSetMmapLimit(db->aDb[ii].pBt, sz);\n        }\n      }\n    }\n    sz = -1;\n    rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_MMAP_SIZE, &sz);\n#else\n    sz = 0;\n    rc = SQLITE_OK;\n#endif\n    if( rc==SQLITE_OK ){\n      returnSingleInt(v, sz);\n    }else if( rc!=SQLITE_NOTFOUND ){\n      pParse->nErr++;\n      pParse->rc = rc;\n    }\n    break;\n  }\n\n  /*\n  **   PRAGMA temp_store\n  **   PRAGMA temp_store = \"default\"|\"memory\"|\"file\"\n  **\n  ** Return or set the local value of the temp_store flag.  Changing\n  ** the local value does not make changes to the disk file and the default\n  ** value will be restored the next time the database is opened.\n  **\n  ** Note that it is possible for the library compile-time options to\n  ** override this setting\n  */\n  case PragTyp_TEMP_STORE: {\n    if( !zRight ){\n      returnSingleInt(v, db->temp_store);\n    }else{\n      changeTempStorage(pParse, zRight);\n    }\n    break;\n  }\n\n  /*\n  **   PRAGMA temp_store_directory\n  **   PRAGMA temp_store_directory = \"\"|\"directory_name\"\n  **\n  ** Return or set the local value of the temp_store_directory flag.  Changing\n  ** the value sets a specific directory to be used for temporary files.\n  ** Setting to a null string reverts to the default temporary directory search.\n  ** If temporary directory is changed, then invalidateTempStorage.\n  **\n  */\n  case PragTyp_TEMP_STORE_DIRECTORY: {\n    if( !zRight ){\n      returnSingleText(v, sqlite3_temp_directory);\n    }else{\n#ifndef SQLITE_OMIT_WSD\n      if( zRight[0] ){\n        int res;\n        rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);\n        if( rc!=SQLITE_OK || res==0 ){\n          sqlite3ErrorMsg(pParse, \"not a writable directory\");\n          goto pragma_out;\n        }\n      }\n      if( SQLITE_TEMP_STORE==0\n       || (SQLITE_TEMP_STORE==1 && db->temp_store<=1)\n       || (SQLITE_TEMP_STORE==2 && db->temp_store==1)\n      ){\n        invalidateTempStorage(pParse);\n      }\n      sqlite3_free(sqlite3_temp_directory);\n      if( zRight[0] ){\n        sqlite3_temp_directory = sqlite3_mprintf(\"%s\", zRight);\n      }else{\n        sqlite3_temp_directory = 0;\n      }\n#endif /* SQLITE_OMIT_WSD */\n    }\n    break;\n  }\n\n#if SQLITE_OS_WIN\n  /*\n  **   PRAGMA data_store_directory\n  **   PRAGMA data_store_directory = \"\"|\"directory_name\"\n  **\n  ** Return or set the local value of the data_store_directory flag.  Changing\n  ** the value sets a specific directory to be used for database files that\n  ** were specified with a relative pathname.  Setting to a null string reverts\n  ** to the default database directory, which for database files specified with\n  ** a relative path will probably be based on the current directory for the\n  ** process.  Database file specified with an absolute path are not impacted\n  ** by this setting, regardless of its value.\n  **\n  */\n  case PragTyp_DATA_STORE_DIRECTORY: {\n    if( !zRight ){\n      returnSingleText(v, sqlite3_data_directory);\n    }else{\n#ifndef SQLITE_OMIT_WSD\n      if( zRight[0] ){\n        int res;\n        rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);\n        if( rc!=SQLITE_OK || res==0 ){\n          sqlite3ErrorMsg(pParse, \"not a writable directory\");\n          goto pragma_out;\n        }\n      }\n      sqlite3_free(sqlite3_data_directory);\n      if( zRight[0] ){\n        sqlite3_data_directory = sqlite3_mprintf(\"%s\", zRight);\n      }else{\n        sqlite3_data_directory = 0;\n      }\n#endif /* SQLITE_OMIT_WSD */\n    }\n    break;\n  }\n#endif\n\n#if SQLITE_ENABLE_LOCKING_STYLE\n  /*\n  **   PRAGMA [schema.]lock_proxy_file\n  **   PRAGMA [schema.]lock_proxy_file = \":auto:\"|\"lock_file_path\"\n  **\n  ** Return or set the value of the lock_proxy_file flag.  Changing\n  ** the value sets a specific file to be used for database access locks.\n  **\n  */\n  case PragTyp_LOCK_PROXY_FILE: {\n    if( !zRight ){\n      Pager *pPager = sqlite3BtreePager(pDb->pBt);\n      char *proxy_file_path = NULL;\n      sqlite3_file *pFile = sqlite3PagerFile(pPager);\n      sqlite3OsFileControlHint(pFile, SQLITE_GET_LOCKPROXYFILE, \n                           &proxy_file_path);\n      returnSingleText(v, proxy_file_path);\n    }else{\n      Pager *pPager = sqlite3BtreePager(pDb->pBt);\n      sqlite3_file *pFile = sqlite3PagerFile(pPager);\n      int res;\n      if( zRight[0] ){\n        res=sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE, \n                                     zRight);\n      } else {\n        res=sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE, \n                                     NULL);\n      }\n      if( res!=SQLITE_OK ){\n        sqlite3ErrorMsg(pParse, \"failed to set lock proxy file\");\n        goto pragma_out;\n      }\n    }\n    break;\n  }\n#endif /* SQLITE_ENABLE_LOCKING_STYLE */      \n    \n  /*\n  **   PRAGMA [schema.]synchronous\n  **   PRAGMA [schema.]synchronous=OFF|ON|NORMAL|FULL|EXTRA\n  **\n  ** Return or set the local value of the synchronous flag.  Changing\n  ** the local value does not make changes to the disk file and the\n  ** default value will be restored the next time the database is\n  ** opened.\n  */\n  case PragTyp_SYNCHRONOUS: {\n    if( !zRight ){\n      returnSingleInt(v, pDb->safety_level-1);\n    }else{\n      if( !db->autoCommit ){\n        sqlite3ErrorMsg(pParse, \n            \"Safety level may not be changed inside a transaction\");\n      }else if( iDb!=1 ){\n        int iLevel = (getSafetyLevel(zRight,0,1)+1) & PAGER_SYNCHRONOUS_MASK;\n        if( iLevel==0 ) iLevel = 1;\n        pDb->safety_level = iLevel;\n        pDb->bSyncSet = 1;\n        setAllPagerFlags(db);\n      }\n    }\n    break;\n  }\n#endif /* SQLITE_OMIT_PAGER_PRAGMAS */\n\n#ifndef SQLITE_OMIT_FLAG_PRAGMAS\n  case PragTyp_FLAG: {\n    if( zRight==0 ){\n      setPragmaResultColumnNames(v, pPragma);\n      returnSingleInt(v, (db->flags & pPragma->iArg)!=0 );\n    }else{\n      u64 mask = pPragma->iArg;    /* Mask of bits to set or clear. */\n      if( db->autoCommit==0 ){\n        /* Foreign key support may not be enabled or disabled while not\n        ** in auto-commit mode.  */\n        mask &= ~(SQLITE_ForeignKeys);\n      }\n#if SQLITE_USER_AUTHENTICATION\n      if( db->auth.authLevel==UAUTH_User ){\n        /* Do not allow non-admin users to modify the schema arbitrarily */\n        mask &= ~(SQLITE_WriteSchema);\n      }\n#endif\n\n      if( sqlite3GetBoolean(zRight, 0) ){\n        db->flags |= mask;\n      }else{\n        db->flags &= ~mask;\n        if( mask==SQLITE_DeferFKs ) db->nDeferredImmCons = 0;\n      }\n\n      /* Many of the flag-pragmas modify the code generated by the SQL \n      ** compiler (eg. count_changes). So add an opcode to expire all\n      ** compiled SQL statements after modifying a pragma value.\n      */\n      sqlite3VdbeAddOp0(v, OP_Expire);\n      setAllPagerFlags(db);\n    }\n    break;\n  }\n#endif /* SQLITE_OMIT_FLAG_PRAGMAS */\n\n#ifndef SQLITE_OMIT_SCHEMA_PRAGMAS\n  /*\n  **   PRAGMA table_info(<table>)\n  **\n  ** Return a single row for each column of the named table. The columns of\n  ** the returned data set are:\n  **\n  ** cid:        Column id (numbered from left to right, starting at 0)\n  ** name:       Column name\n  ** type:       Column declaration type.\n  ** notnull:    True if 'NOT NULL' is part of column declaration\n  ** dflt_value: The default value for the column, if any.\n  ** pk:         Non-zero for PK fields.\n  */\n  case PragTyp_TABLE_INFO: if( zRight ){\n    Table *pTab;\n    pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);\n    if( pTab ){\n      int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n      int i, k;\n      int nHidden = 0;\n      Column *pCol;\n      Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n      pParse->nMem = 7;\n      sqlite3CodeVerifySchema(pParse, iTabDb);\n      sqlite3ViewGetColumnNames(pParse, pTab);\n      for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){\n        int isHidden = 0;\n        if( pCol->colFlags & COLFLAG_NOINSERT ){\n          if( pPragma->iArg==0 ){\n            nHidden++;\n            continue;\n          }\n          if( pCol->colFlags & COLFLAG_VIRTUAL ){\n            isHidden = 2;  /* GENERATED ALWAYS AS ... VIRTUAL */\n          }else if( pCol->colFlags & COLFLAG_STORED ){\n            isHidden = 3;  /* GENERATED ALWAYS AS ... STORED */\n          }else{ assert( pCol->colFlags & COLFLAG_HIDDEN );\n            isHidden = 1;  /* HIDDEN */\n          }\n        }\n        if( (pCol->colFlags & COLFLAG_PRIMKEY)==0 ){\n          k = 0;\n        }else if( pPk==0 ){\n          k = 1;\n        }else{\n          for(k=1; k<=pTab->nCol && pPk->aiColumn[k-1]!=i; k++){}\n        }\n        assert( pCol->pDflt==0 || pCol->pDflt->op==TK_SPAN || isHidden>=2 );\n        sqlite3VdbeMultiLoad(v, 1, pPragma->iArg ? \"issisii\" : \"issisi\",\n               i-nHidden,\n               pCol->zName,\n               sqlite3ColumnType(pCol,\"\"),\n               pCol->notNull ? 1 : 0,\n               pCol->pDflt && isHidden<2 ? pCol->pDflt->u.zToken : 0,\n               k,\n               isHidden);\n      }\n    }\n  }\n  break;\n\n#ifdef SQLITE_DEBUG\n  case PragTyp_STATS: {\n    Index *pIdx;\n    HashElem *i;\n    pParse->nMem = 5;\n    sqlite3CodeVerifySchema(pParse, iDb);\n    for(i=sqliteHashFirst(&pDb->pSchema->tblHash); i; i=sqliteHashNext(i)){\n      Table *pTab = sqliteHashData(i);\n      sqlite3VdbeMultiLoad(v, 1, \"ssiii\",\n           pTab->zName,\n           0,\n           pTab->szTabRow,\n           pTab->nRowLogEst,\n           pTab->tabFlags);\n      for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n        sqlite3VdbeMultiLoad(v, 2, \"siiiX\",\n           pIdx->zName,\n           pIdx->szIdxRow,\n           pIdx->aiRowLogEst[0],\n           pIdx->hasStat1);\n        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 5);\n      }\n    }\n  }\n  break;\n#endif\n\n  case PragTyp_INDEX_INFO: if( zRight ){\n    Index *pIdx;\n    Table *pTab;\n    pIdx = sqlite3FindIndex(db, zRight, zDb);\n    if( pIdx==0 ){\n      /* If there is no index named zRight, check to see if there is a\n      ** WITHOUT ROWID table named zRight, and if there is, show the\n      ** structure of the PRIMARY KEY index for that table. */\n      pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);\n      if( pTab && !HasRowid(pTab) ){\n        pIdx = sqlite3PrimaryKeyIndex(pTab);\n      }\n    }\n    if( pIdx ){\n      int iIdxDb = sqlite3SchemaToIndex(db, pIdx->pSchema);\n      int i;\n      int mx;\n      if( pPragma->iArg ){\n        /* PRAGMA index_xinfo (newer version with more rows and columns) */\n        mx = pIdx->nColumn;\n        pParse->nMem = 6;\n      }else{\n        /* PRAGMA index_info (legacy version) */\n        mx = pIdx->nKeyCol;\n        pParse->nMem = 3;\n      }\n      pTab = pIdx->pTable;\n      sqlite3CodeVerifySchema(pParse, iIdxDb);\n      assert( pParse->nMem<=pPragma->nPragCName );\n      for(i=0; i<mx; i++){\n        i16 cnum = pIdx->aiColumn[i];\n        sqlite3VdbeMultiLoad(v, 1, \"iisX\", i, cnum,\n                             cnum<0 ? 0 : pTab->aCol[cnum].zName);\n        if( pPragma->iArg ){\n          sqlite3VdbeMultiLoad(v, 4, \"isiX\",\n            pIdx->aSortOrder[i],\n            pIdx->azColl[i],\n            i<pIdx->nKeyCol);\n        }\n        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, pParse->nMem);\n      }\n    }\n  }\n  break;\n\n  case PragTyp_INDEX_LIST: if( zRight ){\n    Index *pIdx;\n    Table *pTab;\n    int i;\n    pTab = sqlite3FindTable(db, zRight, zDb);\n    if( pTab ){\n      int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n      pParse->nMem = 5;\n      sqlite3CodeVerifySchema(pParse, iTabDb);\n      for(pIdx=pTab->pIndex, i=0; pIdx; pIdx=pIdx->pNext, i++){\n        const char *azOrigin[] = { \"c\", \"u\", \"pk\" };\n        sqlite3VdbeMultiLoad(v, 1, \"isisi\",\n           i,\n           pIdx->zName,\n           IsUniqueIndex(pIdx),\n           azOrigin[pIdx->idxType],\n           pIdx->pPartIdxWhere!=0);\n      }\n    }\n  }\n  break;\n\n  case PragTyp_DATABASE_LIST: {\n    int i;\n    pParse->nMem = 3;\n    for(i=0; i<db->nDb; i++){\n      if( db->aDb[i].pBt==0 ) continue;\n      assert( db->aDb[i].zDbSName!=0 );\n      sqlite3VdbeMultiLoad(v, 1, \"iss\",\n         i,\n         db->aDb[i].zDbSName,\n         sqlite3BtreeGetFilename(db->aDb[i].pBt));\n    }\n  }\n  break;\n\n  case PragTyp_COLLATION_LIST: {\n    int i = 0;\n    HashElem *p;\n    pParse->nMem = 2;\n    for(p=sqliteHashFirst(&db->aCollSeq); p; p=sqliteHashNext(p)){\n      CollSeq *pColl = (CollSeq *)sqliteHashData(p);\n      sqlite3VdbeMultiLoad(v, 1, \"is\", i++, pColl->zName);\n    }\n  }\n  break;\n\n#ifndef SQLITE_OMIT_INTROSPECTION_PRAGMAS\n  case PragTyp_FUNCTION_LIST: {\n    int i;\n    HashElem *j;\n    FuncDef *p;\n    pParse->nMem = 2;\n    for(i=0; i<SQLITE_FUNC_HASH_SZ; i++){\n      for(p=sqlite3BuiltinFunctions.a[i]; p; p=p->u.pHash ){\n        if( p->funcFlags & SQLITE_FUNC_INTERNAL ) continue;\n        sqlite3VdbeMultiLoad(v, 1, \"si\", p->zName, 1);\n      }\n    }\n    for(j=sqliteHashFirst(&db->aFunc); j; j=sqliteHashNext(j)){\n      p = (FuncDef*)sqliteHashData(j);\n      sqlite3VdbeMultiLoad(v, 1, \"si\", p->zName, 0);\n    }\n  }\n  break;\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  case PragTyp_MODULE_LIST: {\n    HashElem *j;\n    pParse->nMem = 1;\n    for(j=sqliteHashFirst(&db->aModule); j; j=sqliteHashNext(j)){\n      Module *pMod = (Module*)sqliteHashData(j);\n      sqlite3VdbeMultiLoad(v, 1, \"s\", pMod->zName);\n    }\n  }\n  break;\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n  case PragTyp_PRAGMA_LIST: {\n    int i;\n    for(i=0; i<ArraySize(aPragmaName); i++){\n      sqlite3VdbeMultiLoad(v, 1, \"s\", aPragmaName[i].zName);\n    }\n  }\n  break;\n#endif /* SQLITE_INTROSPECTION_PRAGMAS */\n\n#endif /* SQLITE_OMIT_SCHEMA_PRAGMAS */\n\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n  case PragTyp_FOREIGN_KEY_LIST: if( zRight ){\n    FKey *pFK;\n    Table *pTab;\n    pTab = sqlite3FindTable(db, zRight, zDb);\n    if( pTab ){\n      pFK = pTab->pFKey;\n      if( pFK ){\n        int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n        int i = 0; \n        pParse->nMem = 8;\n        sqlite3CodeVerifySchema(pParse, iTabDb);\n        while(pFK){\n          int j;\n          for(j=0; j<pFK->nCol; j++){\n            sqlite3VdbeMultiLoad(v, 1, \"iissssss\",\n                   i,\n                   j,\n                   pFK->zTo,\n                   pTab->aCol[pFK->aCol[j].iFrom].zName,\n                   pFK->aCol[j].zCol,\n                   actionName(pFK->aAction[1]),  /* ON UPDATE */\n                   actionName(pFK->aAction[0]),  /* ON DELETE */\n                   \"NONE\");\n          }\n          ++i;\n          pFK = pFK->pNextFrom;\n        }\n      }\n    }\n  }\n  break;\n#endif /* !defined(SQLITE_OMIT_FOREIGN_KEY) */\n\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n#ifndef SQLITE_OMIT_TRIGGER\n  case PragTyp_FOREIGN_KEY_CHECK: {\n    FKey *pFK;             /* A foreign key constraint */\n    Table *pTab;           /* Child table contain \"REFERENCES\" keyword */\n    Table *pParent;        /* Parent table that child points to */\n    Index *pIdx;           /* Index in the parent table */\n    int i;                 /* Loop counter:  Foreign key number for pTab */\n    int j;                 /* Loop counter:  Field of the foreign key */\n    HashElem *k;           /* Loop counter:  Next table in schema */\n    int x;                 /* result variable */\n    int regResult;         /* 3 registers to hold a result row */\n    int regKey;            /* Register to hold key for checking the FK */\n    int regRow;            /* Registers to hold a row from pTab */\n    int addrTop;           /* Top of a loop checking foreign keys */\n    int addrOk;            /* Jump here if the key is OK */\n    int *aiCols;           /* child to parent column mapping */\n\n    regResult = pParse->nMem+1;\n    pParse->nMem += 4;\n    regKey = ++pParse->nMem;\n    regRow = ++pParse->nMem;\n    k = sqliteHashFirst(&db->aDb[iDb].pSchema->tblHash);\n    while( k ){\n      int iTabDb;\n      if( zRight ){\n        pTab = sqlite3LocateTable(pParse, 0, zRight, zDb);\n        k = 0;\n      }else{\n        pTab = (Table*)sqliteHashData(k);\n        k = sqliteHashNext(k);\n      }\n      if( pTab==0 || pTab->pFKey==0 ) continue;\n      iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n      sqlite3CodeVerifySchema(pParse, iTabDb);\n      sqlite3TableLock(pParse, iTabDb, pTab->tnum, 0, pTab->zName);\n      if( pTab->nCol+regRow>pParse->nMem ) pParse->nMem = pTab->nCol + regRow;\n      sqlite3OpenTable(pParse, 0, iTabDb, pTab, OP_OpenRead);\n      sqlite3VdbeLoadString(v, regResult, pTab->zName);\n      for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom){\n        pParent = sqlite3FindTable(db, pFK->zTo, zDb);\n        if( pParent==0 ) continue;\n        pIdx = 0;\n        sqlite3TableLock(pParse, iTabDb, pParent->tnum, 0, pParent->zName);\n        x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, 0);\n        if( x==0 ){\n          if( pIdx==0 ){\n            sqlite3OpenTable(pParse, i, iTabDb, pParent, OP_OpenRead);\n          }else{\n            sqlite3VdbeAddOp3(v, OP_OpenRead, i, pIdx->tnum, iTabDb);\n            sqlite3VdbeSetP4KeyInfo(pParse, pIdx);\n          }\n        }else{\n          k = 0;\n          break;\n        }\n      }\n      assert( pParse->nErr>0 || pFK==0 );\n      if( pFK ) break;\n      if( pParse->nTab<i ) pParse->nTab = i;\n      addrTop = sqlite3VdbeAddOp1(v, OP_Rewind, 0); VdbeCoverage(v);\n      for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom){\n        pParent = sqlite3FindTable(db, pFK->zTo, zDb);\n        pIdx = 0;\n        aiCols = 0;\n        if( pParent ){\n          x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, &aiCols);\n          assert( x==0 );\n        }\n        addrOk = sqlite3VdbeMakeLabel(pParse);\n\n        /* Generate code to read the child key values into registers\n        ** regRow..regRow+n. If any of the child key values are NULL, this \n        ** row cannot cause an FK violation. Jump directly to addrOk in \n        ** this case. */\n        for(j=0; j<pFK->nCol; j++){\n          int iCol = aiCols ? aiCols[j] : pFK->aCol[j].iFrom;\n          sqlite3ExprCodeGetColumnOfTable(v, pTab, 0, iCol, regRow+j);\n          sqlite3VdbeAddOp2(v, OP_IsNull, regRow+j, addrOk); VdbeCoverage(v);\n        }\n\n        /* Generate code to query the parent index for a matching parent\n        ** key. If a match is found, jump to addrOk. */\n        if( pIdx ){\n          sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, pFK->nCol, regKey,\n              sqlite3IndexAffinityStr(db,pIdx), pFK->nCol);\n          sqlite3VdbeAddOp4Int(v, OP_Found, i, addrOk, regKey, 0);\n          VdbeCoverage(v);\n        }else if( pParent ){\n          int jmp = sqlite3VdbeCurrentAddr(v)+2;\n          sqlite3VdbeAddOp3(v, OP_SeekRowid, i, jmp, regRow); VdbeCoverage(v);\n          sqlite3VdbeGoto(v, addrOk);\n          assert( pFK->nCol==1 );\n        }\n\n        /* Generate code to report an FK violation to the caller. */\n        if( HasRowid(pTab) ){\n          sqlite3VdbeAddOp2(v, OP_Rowid, 0, regResult+1);\n        }else{\n          sqlite3VdbeAddOp2(v, OP_Null, 0, regResult+1);\n        }\n        sqlite3VdbeMultiLoad(v, regResult+2, \"siX\", pFK->zTo, i-1);\n        sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, 4);\n        sqlite3VdbeResolveLabel(v, addrOk);\n        sqlite3DbFree(db, aiCols);\n      }\n      sqlite3VdbeAddOp2(v, OP_Next, 0, addrTop+1); VdbeCoverage(v);\n      sqlite3VdbeJumpHere(v, addrTop);\n    }\n  }\n  break;\n#endif /* !defined(SQLITE_OMIT_TRIGGER) */\n#endif /* !defined(SQLITE_OMIT_FOREIGN_KEY) */\n\n#ifndef SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA\n  /* Reinstall the LIKE and GLOB functions.  The variant of LIKE\n  ** used will be case sensitive or not depending on the RHS.\n  */\n  case PragTyp_CASE_SENSITIVE_LIKE: {\n    if( zRight ){\n      sqlite3RegisterLikeFunctions(db, sqlite3GetBoolean(zRight, 0));\n    }\n  }\n  break;\n#endif /* SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA */\n\n#ifndef SQLITE_INTEGRITY_CHECK_ERROR_MAX\n# define SQLITE_INTEGRITY_CHECK_ERROR_MAX 100\n#endif\n\n#ifndef SQLITE_OMIT_INTEGRITY_CHECK\n  /*    PRAGMA integrity_check\n  **    PRAGMA integrity_check(N)\n  **    PRAGMA quick_check\n  **    PRAGMA quick_check(N)\n  **\n  ** Verify the integrity of the database.\n  **\n  ** The \"quick_check\" is reduced version of \n  ** integrity_check designed to detect most database corruption\n  ** without the overhead of cross-checking indexes.  Quick_check\n  ** is linear time wherease integrity_check is O(NlogN).\n  */\n  case PragTyp_INTEGRITY_CHECK: {\n    int i, j, addr, mxErr;\n\n    int isQuick = (sqlite3Tolower(zLeft[0])=='q');\n\n    /* If the PRAGMA command was of the form \"PRAGMA <db>.integrity_check\",\n    ** then iDb is set to the index of the database identified by <db>.\n    ** In this case, the integrity of database iDb only is verified by\n    ** the VDBE created below.\n    **\n    ** Otherwise, if the command was simply \"PRAGMA integrity_check\" (or\n    ** \"PRAGMA quick_check\"), then iDb is set to 0. In this case, set iDb\n    ** to -1 here, to indicate that the VDBE should verify the integrity\n    ** of all attached databases.  */\n    assert( iDb>=0 );\n    assert( iDb==0 || pId2->z );\n    if( pId2->z==0 ) iDb = -1;\n\n    /* Initialize the VDBE program */\n    pParse->nMem = 6;\n\n    /* Set the maximum error count */\n    mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;\n    if( zRight ){\n      sqlite3GetInt32(zRight, &mxErr);\n      if( mxErr<=0 ){\n        mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;\n      }\n    }\n    sqlite3VdbeAddOp2(v, OP_Integer, mxErr-1, 1); /* reg[1] holds errors left */\n\n    /* Do an integrity check on each database file */\n    for(i=0; i<db->nDb; i++){\n      HashElem *x;     /* For looping over tables in the schema */\n      Hash *pTbls;     /* Set of all tables in the schema */\n      int *aRoot;      /* Array of root page numbers of all btrees */\n      int cnt = 0;     /* Number of entries in aRoot[] */\n      int mxIdx = 0;   /* Maximum number of indexes for any table */\n\n      if( OMIT_TEMPDB && i==1 ) continue;\n      if( iDb>=0 && i!=iDb ) continue;\n\n      sqlite3CodeVerifySchema(pParse, i);\n\n      /* Do an integrity check of the B-Tree\n      **\n      ** Begin by finding the root pages numbers\n      ** for all tables and indices in the database.\n      */\n      assert( sqlite3SchemaMutexHeld(db, i, 0) );\n      pTbls = &db->aDb[i].pSchema->tblHash;\n      for(cnt=0, x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){\n        Table *pTab = sqliteHashData(x);  /* Current table */\n        Index *pIdx;                      /* An index on pTab */\n        int nIdx;                         /* Number of indexes on pTab */\n        if( HasRowid(pTab) ) cnt++;\n        for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){ cnt++; }\n        if( nIdx>mxIdx ) mxIdx = nIdx;\n      }\n      aRoot = sqlite3DbMallocRawNN(db, sizeof(int)*(cnt+1));\n      if( aRoot==0 ) break;\n      for(cnt=0, x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){\n        Table *pTab = sqliteHashData(x);\n        Index *pIdx;\n        if( HasRowid(pTab) ) aRoot[++cnt] = pTab->tnum;\n        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n          aRoot[++cnt] = pIdx->tnum;\n        }\n      }\n      aRoot[0] = cnt;\n\n      /* Make sure sufficient number of registers have been allocated */\n      pParse->nMem = MAX( pParse->nMem, 8+mxIdx );\n      sqlite3ClearTempRegCache(pParse);\n\n      /* Do the b-tree integrity checks */\n      sqlite3VdbeAddOp4(v, OP_IntegrityCk, 2, cnt, 1, (char*)aRoot,P4_INTARRAY);\n      sqlite3VdbeChangeP5(v, (u8)i);\n      addr = sqlite3VdbeAddOp1(v, OP_IsNull, 2); VdbeCoverage(v);\n      sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0,\n         sqlite3MPrintf(db, \"*** in database %s ***\\n\", db->aDb[i].zDbSName),\n         P4_DYNAMIC);\n      sqlite3VdbeAddOp3(v, OP_Concat, 2, 3, 3);\n      integrityCheckResultRow(v);\n      sqlite3VdbeJumpHere(v, addr);\n\n      /* Make sure all the indices are constructed correctly.\n      */\n      for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){\n        Table *pTab = sqliteHashData(x);\n        Index *pIdx, *pPk;\n        Index *pPrior = 0;\n        int loopTop;\n        int iDataCur, iIdxCur;\n        int r1 = -1;\n\n        if( pTab->tnum<1 ) continue;  /* Skip VIEWs or VIRTUAL TABLEs */\n        pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);\n        sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenRead, 0,\n                                   1, 0, &iDataCur, &iIdxCur);\n        /* reg[7] counts the number of entries in the table.\n        ** reg[8+i] counts the number of entries in the i-th index \n        */\n        sqlite3VdbeAddOp2(v, OP_Integer, 0, 7);\n        for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){\n          sqlite3VdbeAddOp2(v, OP_Integer, 0, 8+j); /* index entries counter */\n        }\n        assert( pParse->nMem>=8+j );\n        assert( sqlite3NoTempsInRange(pParse,1,7+j) );\n        sqlite3VdbeAddOp2(v, OP_Rewind, iDataCur, 0); VdbeCoverage(v);\n        loopTop = sqlite3VdbeAddOp2(v, OP_AddImm, 7, 1);\n        if( !isQuick ){\n          /* Sanity check on record header decoding */\n          sqlite3VdbeAddOp3(v, OP_Column, iDataCur, pTab->nNVCol-1,3);\n          sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n        }\n        /* Verify that all NOT NULL columns really are NOT NULL */\n        for(j=0; j<pTab->nCol; j++){\n          char *zErr;\n          int jmp2;\n          if( j==pTab->iPKey ) continue;\n          if( pTab->aCol[j].notNull==0 ) continue;\n          sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n          sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n          jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);\n          zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,\n                              pTab->aCol[j].zName);\n          sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n          integrityCheckResultRow(v);\n          sqlite3VdbeJumpHere(v, jmp2);\n        }\n        /* Verify CHECK constraints */\n        if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){\n          ExprList *pCheck = sqlite3ExprListDup(db, pTab->pCheck, 0);\n          if( db->mallocFailed==0 ){\n            int addrCkFault = sqlite3VdbeMakeLabel(pParse);\n            int addrCkOk = sqlite3VdbeMakeLabel(pParse);\n            char *zErr;\n            int k;\n            pParse->iSelfTab = iDataCur + 1;\n            for(k=pCheck->nExpr-1; k>0; k--){\n              sqlite3ExprIfFalse(pParse, pCheck->a[k].pExpr, addrCkFault, 0);\n            }\n            sqlite3ExprIfTrue(pParse, pCheck->a[0].pExpr, addrCkOk, \n                SQLITE_JUMPIFNULL);\n            sqlite3VdbeResolveLabel(v, addrCkFault);\n            pParse->iSelfTab = 0;\n            zErr = sqlite3MPrintf(db, \"CHECK constraint failed in %s\",\n                pTab->zName);\n            sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n            integrityCheckResultRow(v);\n            sqlite3VdbeResolveLabel(v, addrCkOk);\n          }\n          sqlite3ExprListDelete(db, pCheck);\n        }\n        if( !isQuick ){ /* Omit the remaining tests for quick_check */\n          /* Validate index entries for the current row */\n          for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){\n            int jmp2, jmp3, jmp4, jmp5;\n            int ckUniq = sqlite3VdbeMakeLabel(pParse);\n            if( pPk==pIdx ) continue;\n            r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 0, &jmp3,\n                                         pPrior, r1);\n            pPrior = pIdx;\n            sqlite3VdbeAddOp2(v, OP_AddImm, 8+j, 1);/* increment entry count */\n            /* Verify that an index entry exists for the current table row */\n            jmp2 = sqlite3VdbeAddOp4Int(v, OP_Found, iIdxCur+j, ckUniq, r1,\n                                        pIdx->nColumn); VdbeCoverage(v);\n            sqlite3VdbeLoadString(v, 3, \"row \");\n            sqlite3VdbeAddOp3(v, OP_Concat, 7, 3, 3);\n            sqlite3VdbeLoadString(v, 4, \" missing from index \");\n            sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);\n            jmp5 = sqlite3VdbeLoadString(v, 4, pIdx->zName);\n            sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);\n            jmp4 = integrityCheckResultRow(v);\n            sqlite3VdbeJumpHere(v, jmp2);\n            /* For UNIQUE indexes, verify that only one entry exists with the\n            ** current key.  The entry is unique if (1) any column is NULL\n            ** or (2) the next entry has a different key */\n            if( IsUniqueIndex(pIdx) ){\n              int uniqOk = sqlite3VdbeMakeLabel(pParse);\n              int jmp6;\n              int kk;\n              for(kk=0; kk<pIdx->nKeyCol; kk++){\n                int iCol = pIdx->aiColumn[kk];\n                assert( iCol!=XN_ROWID && iCol<pTab->nCol );\n                if( iCol>=0 && pTab->aCol[iCol].notNull ) continue;\n                sqlite3VdbeAddOp2(v, OP_IsNull, r1+kk, uniqOk);\n                VdbeCoverage(v);\n              }\n              jmp6 = sqlite3VdbeAddOp1(v, OP_Next, iIdxCur+j); VdbeCoverage(v);\n              sqlite3VdbeGoto(v, uniqOk);\n              sqlite3VdbeJumpHere(v, jmp6);\n              sqlite3VdbeAddOp4Int(v, OP_IdxGT, iIdxCur+j, uniqOk, r1,\n                                   pIdx->nKeyCol); VdbeCoverage(v);\n              sqlite3VdbeLoadString(v, 3, \"non-unique entry in index \");\n              sqlite3VdbeGoto(v, jmp5);\n              sqlite3VdbeResolveLabel(v, uniqOk);\n            }\n            sqlite3VdbeJumpHere(v, jmp4);\n            sqlite3ResolvePartIdxLabel(pParse, jmp3);\n          }\n        }\n        sqlite3VdbeAddOp2(v, OP_Next, iDataCur, loopTop); VdbeCoverage(v);\n        sqlite3VdbeJumpHere(v, loopTop-1);\n#ifndef SQLITE_OMIT_BTREECOUNT\n        if( !isQuick ){\n          sqlite3VdbeLoadString(v, 2, \"wrong # of entries in index \");\n          for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){\n            if( pPk==pIdx ) continue;\n            sqlite3VdbeAddOp2(v, OP_Count, iIdxCur+j, 3);\n            addr = sqlite3VdbeAddOp3(v, OP_Eq, 8+j, 0, 3); VdbeCoverage(v);\n            sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);\n            sqlite3VdbeLoadString(v, 4, pIdx->zName);\n            sqlite3VdbeAddOp3(v, OP_Concat, 4, 2, 3);\n            integrityCheckResultRow(v);\n            sqlite3VdbeJumpHere(v, addr);\n          }\n        }\n#endif /* SQLITE_OMIT_BTREECOUNT */\n      } \n    }\n    {\n      static const int iLn = VDBE_OFFSET_LINENO(2);\n      static const VdbeOpList endCode[] = {\n        { OP_AddImm,      1, 0,        0},    /* 0 */\n        { OP_IfNotZero,   1, 4,        0},    /* 1 */\n        { OP_String8,     0, 3,        0},    /* 2 */\n        { OP_ResultRow,   3, 1,        0},    /* 3 */\n        { OP_Halt,        0, 0,        0},    /* 4 */\n        { OP_String8,     0, 3,        0},    /* 5 */\n        { OP_Goto,        0, 3,        0},    /* 6 */\n      };\n      VdbeOp *aOp;\n\n      aOp = sqlite3VdbeAddOpList(v, ArraySize(endCode), endCode, iLn);\n      if( aOp ){\n        aOp[0].p2 = 1-mxErr;\n        aOp[2].p4type = P4_STATIC;\n        aOp[2].p4.z = \"ok\";\n        aOp[5].p4type = P4_STATIC;\n        aOp[5].p4.z = (char*)sqlite3ErrStr(SQLITE_CORRUPT);\n      }\n      sqlite3VdbeChangeP3(v, 0, sqlite3VdbeCurrentAddr(v)-2);\n    }\n  }\n  break;\n#endif /* SQLITE_OMIT_INTEGRITY_CHECK */\n\n#ifndef SQLITE_OMIT_UTF16\n  /*\n  **   PRAGMA encoding\n  **   PRAGMA encoding = \"utf-8\"|\"utf-16\"|\"utf-16le\"|\"utf-16be\"\n  **\n  ** In its first form, this pragma returns the encoding of the main\n  ** database. If the database is not initialized, it is initialized now.\n  **\n  ** The second form of this pragma is a no-op if the main database file\n  ** has not already been initialized. In this case it sets the default\n  ** encoding that will be used for the main database file if a new file\n  ** is created. If an existing main database file is opened, then the\n  ** default text encoding for the existing database is used.\n  ** \n  ** In all cases new databases created using the ATTACH command are\n  ** created to use the same default text encoding as the main database. If\n  ** the main database has not been initialized and/or created when ATTACH\n  ** is executed, this is done before the ATTACH operation.\n  **\n  ** In the second form this pragma sets the text encoding to be used in\n  ** new database files created using this database handle. It is only\n  ** useful if invoked immediately after the main database i\n  */\n  case PragTyp_ENCODING: {\n    static const struct EncName {\n      char *zName;\n      u8 enc;\n    } encnames[] = {\n      { \"UTF8\",     SQLITE_UTF8        },\n      { \"UTF-8\",    SQLITE_UTF8        },  /* Must be element [1] */\n      { \"UTF-16le\", SQLITE_UTF16LE     },  /* Must be element [2] */\n      { \"UTF-16be\", SQLITE_UTF16BE     },  /* Must be element [3] */\n      { \"UTF16le\",  SQLITE_UTF16LE     },\n      { \"UTF16be\",  SQLITE_UTF16BE     },\n      { \"UTF-16\",   0                  }, /* SQLITE_UTF16NATIVE */\n      { \"UTF16\",    0                  }, /* SQLITE_UTF16NATIVE */\n      { 0, 0 }\n    };\n    const struct EncName *pEnc;\n    if( !zRight ){    /* \"PRAGMA encoding\" */\n      if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n      assert( encnames[SQLITE_UTF8].enc==SQLITE_UTF8 );\n      assert( encnames[SQLITE_UTF16LE].enc==SQLITE_UTF16LE );\n      assert( encnames[SQLITE_UTF16BE].enc==SQLITE_UTF16BE );\n      returnSingleText(v, encnames[ENC(pParse->db)].zName);\n    }else{                        /* \"PRAGMA encoding = XXX\" */\n      /* Only change the value of sqlite.enc if the database handle is not\n      ** initialized. If the main database exists, the new sqlite.enc value\n      ** will be overwritten when the schema is next loaded. If it does not\n      ** already exists, it will be created to use the new encoding value.\n      */\n      if( \n        !(DbHasProperty(db, 0, DB_SchemaLoaded)) || \n        DbHasProperty(db, 0, DB_Empty) \n      ){\n        for(pEnc=&encnames[0]; pEnc->zName; pEnc++){\n          if( 0==sqlite3StrICmp(zRight, pEnc->zName) ){\n            SCHEMA_ENC(db) = ENC(db) =\n                pEnc->enc ? pEnc->enc : SQLITE_UTF16NATIVE;\n            break;\n          }\n        }\n        if( !pEnc->zName ){\n          sqlite3ErrorMsg(pParse, \"unsupported encoding: %s\", zRight);\n        }\n      }\n    }\n  }\n  break;\n#endif /* SQLITE_OMIT_UTF16 */\n\n#ifndef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS\n  /*\n  **   PRAGMA [schema.]schema_version\n  **   PRAGMA [schema.]schema_version = <integer>\n  **\n  **   PRAGMA [schema.]user_version\n  **   PRAGMA [schema.]user_version = <integer>\n  **\n  **   PRAGMA [schema.]freelist_count\n  **\n  **   PRAGMA [schema.]data_version\n  **\n  **   PRAGMA [schema.]application_id\n  **   PRAGMA [schema.]application_id = <integer>\n  **\n  ** The pragma's schema_version and user_version are used to set or get\n  ** the value of the schema-version and user-version, respectively. Both\n  ** the schema-version and the user-version are 32-bit signed integers\n  ** stored in the database header.\n  **\n  ** The schema-cookie is usually only manipulated internally by SQLite. It\n  ** is incremented by SQLite whenever the database schema is modified (by\n  ** creating or dropping a table or index). The schema version is used by\n  ** SQLite each time a query is executed to ensure that the internal cache\n  ** of the schema used when compiling the SQL query matches the schema of\n  ** the database against which the compiled query is actually executed.\n  ** Subverting this mechanism by using \"PRAGMA schema_version\" to modify\n  ** the schema-version is potentially dangerous and may lead to program\n  ** crashes or database corruption. Use with caution!\n  **\n  ** The user-version is not used internally by SQLite. It may be used by\n  ** applications for any purpose.\n  */\n  case PragTyp_HEADER_VALUE: {\n    int iCookie = pPragma->iArg;  /* Which cookie to read or write */\n    sqlite3VdbeUsesBtree(v, iDb);\n    if( zRight && (pPragma->mPragFlg & PragFlg_ReadOnly)==0 ){\n      /* Write the specified cookie value */\n      static const VdbeOpList setCookie[] = {\n        { OP_Transaction,    0,  1,  0},    /* 0 */\n        { OP_SetCookie,      0,  0,  0},    /* 1 */\n      };\n      VdbeOp *aOp;\n      sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setCookie));\n      aOp = sqlite3VdbeAddOpList(v, ArraySize(setCookie), setCookie, 0);\n      if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;\n      aOp[0].p1 = iDb;\n      aOp[1].p1 = iDb;\n      aOp[1].p2 = iCookie;\n      aOp[1].p3 = sqlite3Atoi(zRight);\n    }else{\n      /* Read the specified cookie value */\n      static const VdbeOpList readCookie[] = {\n        { OP_Transaction,     0,  0,  0},    /* 0 */\n        { OP_ReadCookie,      0,  1,  0},    /* 1 */\n        { OP_ResultRow,       1,  1,  0}\n      };\n      VdbeOp *aOp;\n      sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(readCookie));\n      aOp = sqlite3VdbeAddOpList(v, ArraySize(readCookie),readCookie,0);\n      if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;\n      aOp[0].p1 = iDb;\n      aOp[1].p1 = iDb;\n      aOp[1].p3 = iCookie;\n      sqlite3VdbeReusable(v);\n    }\n  }\n  break;\n#endif /* SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS */\n\n#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS\n  /*\n  **   PRAGMA compile_options\n  **\n  ** Return the names of all compile-time options used in this build,\n  ** one option per row.\n  */\n  case PragTyp_COMPILE_OPTIONS: {\n    int i = 0;\n    const char *zOpt;\n    pParse->nMem = 1;\n    while( (zOpt = sqlite3_compileoption_get(i++))!=0 ){\n      sqlite3VdbeLoadString(v, 1, zOpt);\n      sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n    }\n    sqlite3VdbeReusable(v);\n  }\n  break;\n#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */\n\n#ifndef SQLITE_OMIT_WAL\n  /*\n  **   PRAGMA [schema.]wal_checkpoint = passive|full|restart|truncate\n  **\n  ** Checkpoint the database.\n  */\n  case PragTyp_WAL_CHECKPOINT: {\n    int iBt = (pId2->z?iDb:SQLITE_MAX_ATTACHED);\n    int eMode = SQLITE_CHECKPOINT_PASSIVE;\n    if( zRight ){\n      if( sqlite3StrICmp(zRight, \"full\")==0 ){\n        eMode = SQLITE_CHECKPOINT_FULL;\n      }else if( sqlite3StrICmp(zRight, \"restart\")==0 ){\n        eMode = SQLITE_CHECKPOINT_RESTART;\n      }else if( sqlite3StrICmp(zRight, \"truncate\")==0 ){\n        eMode = SQLITE_CHECKPOINT_TRUNCATE;\n      }\n    }\n    pParse->nMem = 3;\n    sqlite3VdbeAddOp3(v, OP_Checkpoint, iBt, eMode, 1);\n    sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);\n  }\n  break;\n\n  /*\n  **   PRAGMA wal_autocheckpoint\n  **   PRAGMA wal_autocheckpoint = N\n  **\n  ** Configure a database connection to automatically checkpoint a database\n  ** after accumulating N frames in the log. Or query for the current value\n  ** of N.\n  */\n  case PragTyp_WAL_AUTOCHECKPOINT: {\n    if( zRight ){\n      sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));\n    }\n    returnSingleInt(v, \n       db->xWalCallback==sqlite3WalDefaultHook ? \n           SQLITE_PTR_TO_INT(db->pWalArg) : 0);\n  }\n  break;\n#endif\n\n  /*\n  **  PRAGMA shrink_memory\n  **\n  ** IMPLEMENTATION-OF: R-23445-46109 This pragma causes the database\n  ** connection on which it is invoked to free up as much memory as it\n  ** can, by calling sqlite3_db_release_memory().\n  */\n  case PragTyp_SHRINK_MEMORY: {\n    sqlite3_db_release_memory(db);\n    break;\n  }\n\n  /*\n  **  PRAGMA optimize\n  **  PRAGMA optimize(MASK)\n  **  PRAGMA schema.optimize\n  **  PRAGMA schema.optimize(MASK)\n  **\n  ** Attempt to optimize the database.  All schemas are optimized in the first\n  ** two forms, and only the specified schema is optimized in the latter two.\n  **\n  ** The details of optimizations performed by this pragma are expected\n  ** to change and improve over time.  Applications should anticipate that\n  ** this pragma will perform new optimizations in future releases.\n  **\n  ** The optional argument is a bitmask of optimizations to perform:\n  **\n  **    0x0001    Debugging mode.  Do not actually perform any optimizations\n  **              but instead return one line of text for each optimization\n  **              that would have been done.  Off by default.\n  **\n  **    0x0002    Run ANALYZE on tables that might benefit.  On by default.\n  **              See below for additional information.\n  **\n  **    0x0004    (Not yet implemented) Record usage and performance \n  **              information from the current session in the\n  **              database file so that it will be available to \"optimize\"\n  **              pragmas run by future database connections.\n  **\n  **    0x0008    (Not yet implemented) Create indexes that might have\n  **              been helpful to recent queries\n  **\n  ** The default MASK is and always shall be 0xfffe.  0xfffe means perform all\n  ** of the optimizations listed above except Debug Mode, including new\n  ** optimizations that have not yet been invented.  If new optimizations are\n  ** ever added that should be off by default, those off-by-default \n  ** optimizations will have bitmasks of 0x10000 or larger.\n  **\n  ** DETERMINATION OF WHEN TO RUN ANALYZE\n  **\n  ** In the current implementation, a table is analyzed if only if all of\n  ** the following are true:\n  **\n  ** (1) MASK bit 0x02 is set.\n  **\n  ** (2) The query planner used sqlite_stat1-style statistics for one or\n  **     more indexes of the table at some point during the lifetime of\n  **     the current connection.\n  **\n  ** (3) One or more indexes of the table are currently unanalyzed OR\n  **     the number of rows in the table has increased by 25 times or more\n  **     since the last time ANALYZE was run.\n  **\n  ** The rules for when tables are analyzed are likely to change in\n  ** future releases.\n  */\n  case PragTyp_OPTIMIZE: {\n    int iDbLast;           /* Loop termination point for the schema loop */\n    int iTabCur;           /* Cursor for a table whose size needs checking */\n    HashElem *k;           /* Loop over tables of a schema */\n    Schema *pSchema;       /* The current schema */\n    Table *pTab;           /* A table in the schema */\n    Index *pIdx;           /* An index of the table */\n    LogEst szThreshold;    /* Size threshold above which reanalysis is needd */\n    char *zSubSql;         /* SQL statement for the OP_SqlExec opcode */\n    u32 opMask;            /* Mask of operations to perform */\n\n    if( zRight ){\n      opMask = (u32)sqlite3Atoi(zRight);\n      if( (opMask & 0x02)==0 ) break;\n    }else{\n      opMask = 0xfffe;\n    }\n    iTabCur = pParse->nTab++;\n    for(iDbLast = zDb?iDb:db->nDb-1; iDb<=iDbLast; iDb++){\n      if( iDb==1 ) continue;\n      sqlite3CodeVerifySchema(pParse, iDb);\n      pSchema = db->aDb[iDb].pSchema;\n      for(k=sqliteHashFirst(&pSchema->tblHash); k; k=sqliteHashNext(k)){\n        pTab = (Table*)sqliteHashData(k);\n\n        /* If table pTab has not been used in a way that would benefit from\n        ** having analysis statistics during the current session, then skip it.\n        ** This also has the effect of skipping virtual tables and views */\n        if( (pTab->tabFlags & TF_StatsUsed)==0 ) continue;\n\n        /* Reanalyze if the table is 25 times larger than the last analysis */\n        szThreshold = pTab->nRowLogEst + 46; assert( sqlite3LogEst(25)==46 );\n        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n          if( !pIdx->hasStat1 ){\n            szThreshold = 0; /* Always analyze if any index lacks statistics */\n            break;\n          }\n        }\n        if( szThreshold ){\n          sqlite3OpenTable(pParse, iTabCur, iDb, pTab, OP_OpenRead);\n          sqlite3VdbeAddOp3(v, OP_IfSmaller, iTabCur, \n                         sqlite3VdbeCurrentAddr(v)+2+(opMask&1), szThreshold);\n          VdbeCoverage(v);\n        }\n        zSubSql = sqlite3MPrintf(db, \"ANALYZE \\\"%w\\\".\\\"%w\\\"\",\n                                 db->aDb[iDb].zDbSName, pTab->zName);\n        if( opMask & 0x01 ){\n          int r1 = sqlite3GetTempReg(pParse);\n          sqlite3VdbeAddOp4(v, OP_String8, 0, r1, 0, zSubSql, P4_DYNAMIC);\n          sqlite3VdbeAddOp2(v, OP_ResultRow, r1, 1);\n        }else{\n          sqlite3VdbeAddOp4(v, OP_SqlExec, 0, 0, 0, zSubSql, P4_DYNAMIC);\n        }\n      }\n    }\n    sqlite3VdbeAddOp0(v, OP_Expire);\n    break;\n  }\n\n  /*\n  **   PRAGMA busy_timeout\n  **   PRAGMA busy_timeout = N\n  **\n  ** Call sqlite3_busy_timeout(db, N).  Return the current timeout value\n  ** if one is set.  If no busy handler or a different busy handler is set\n  ** then 0 is returned.  Setting the busy_timeout to 0 or negative\n  ** disables the timeout.\n  */\n  /*case PragTyp_BUSY_TIMEOUT*/ default: {\n    assert( pPragma->ePragTyp==PragTyp_BUSY_TIMEOUT );\n    if( zRight ){\n      sqlite3_busy_timeout(db, sqlite3Atoi(zRight));\n    }\n    returnSingleInt(v, db->busyTimeout);\n    break;\n  }\n\n  /*\n  **   PRAGMA soft_heap_limit\n  **   PRAGMA soft_heap_limit = N\n  **\n  ** IMPLEMENTATION-OF: R-26343-45930 This pragma invokes the\n  ** sqlite3_soft_heap_limit64() interface with the argument N, if N is\n  ** specified and is a non-negative integer.\n  ** IMPLEMENTATION-OF: R-64451-07163 The soft_heap_limit pragma always\n  ** returns the same integer that would be returned by the\n  ** sqlite3_soft_heap_limit64(-1) C-language function.\n  */\n  case PragTyp_SOFT_HEAP_LIMIT: {\n    sqlite3_int64 N;\n    if( zRight && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK ){\n      sqlite3_soft_heap_limit64(N);\n    }\n    returnSingleInt(v, sqlite3_soft_heap_limit64(-1));\n    break;\n  }\n\n  /*\n  **   PRAGMA hard_heap_limit\n  **   PRAGMA hard_heap_limit = N\n  **\n  ** Invoke sqlite3_hard_heap_limit64() to query or set the hard heap\n  ** limit.  The hard heap limit can be activated or lowered by this\n  ** pragma, but not raised or deactivated.  Only the\n  ** sqlite3_hard_heap_limit64() C-language API can raise or deactivate\n  ** the hard heap limit.  This allows an application to set a heap limit\n  ** constraint that cannot be relaxed by an untrusted SQL script.\n  */\n  case PragTyp_HARD_HEAP_LIMIT: {\n    sqlite3_int64 N;\n    if( zRight && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK ){\n      sqlite3_int64 iPrior = sqlite3_hard_heap_limit64(-1);\n      if( N>0 && (iPrior==0 || iPrior>N) ) sqlite3_hard_heap_limit64(N);\n    }\n    returnSingleInt(v, sqlite3_hard_heap_limit64(-1));\n    break;\n  }\n\n  /*\n  **   PRAGMA threads\n  **   PRAGMA threads = N\n  **\n  ** Configure the maximum number of worker threads.  Return the new\n  ** maximum, which might be less than requested.\n  */\n  case PragTyp_THREADS: {\n    sqlite3_int64 N;\n    if( zRight\n     && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK\n     && N>=0\n    ){\n      sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, (int)(N&0x7fffffff));\n    }\n    returnSingleInt(v, sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, -1));\n    break;\n  }\n\n#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)\n  /*\n  ** Report the current state of file logs for all databases\n  */\n  case PragTyp_LOCK_STATUS: {\n    static const char *const azLockName[] = {\n      \"unlocked\", \"shared\", \"reserved\", \"pending\", \"exclusive\"\n    };\n    int i;\n    pParse->nMem = 2;\n    for(i=0; i<db->nDb; i++){\n      Btree *pBt;\n      const char *zState = \"unknown\";\n      int j;\n      if( db->aDb[i].zDbSName==0 ) continue;\n      pBt = db->aDb[i].pBt;\n      if( pBt==0 || sqlite3BtreePager(pBt)==0 ){\n        zState = \"closed\";\n      }else if( sqlite3_file_control(db, i ? db->aDb[i].zDbSName : 0, \n                                     SQLITE_FCNTL_LOCKSTATE, &j)==SQLITE_OK ){\n         zState = azLockName[j];\n      }\n      sqlite3VdbeMultiLoad(v, 1, \"ss\", db->aDb[i].zDbSName, zState);\n    }\n    break;\n  }\n#endif\n\n#ifdef SQLITE_HAS_CODEC\n  /* Pragma        iArg\n  ** ----------   ------\n  **  key           0\n  **  rekey         1\n  **  hexkey        2\n  **  hexrekey      3\n  **  textkey       4\n  **  textrekey     5\n  */\n  case PragTyp_KEY: {\n    if( zRight ){\n      char zBuf[40];\n      const char *zKey = zRight;\n      int n;\n      if( pPragma->iArg==2 || pPragma->iArg==3 ){\n        u8 iByte;\n        int i;\n        for(i=0, iByte=0; i<sizeof(zBuf)*2 && sqlite3Isxdigit(zRight[i]); i++){\n          iByte = (iByte<<4) + sqlite3HexToInt(zRight[i]);\n          if( (i&1)!=0 ) zBuf[i/2] = iByte;\n        }\n        zKey = zBuf;\n        n = i/2;\n      }else{\n        n = pPragma->iArg<4 ? sqlite3Strlen30(zRight) : -1;\n      }\n      if( (pPragma->iArg & 1)==0 ){\n        rc = sqlite3_key_v2(db, zDb, zKey, n);\n      }else{\n        rc = sqlite3_rekey_v2(db, zDb, zKey, n);\n      }\n      if( rc==SQLITE_OK && n!=0 ){\n        sqlite3VdbeSetNumCols(v, 1);\n        sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"ok\", SQLITE_STATIC);\n        returnSingleText(v, \"ok\");\n      }\n    }\n    break;\n  }\n#endif\n#if defined(SQLITE_HAS_CODEC) || defined(SQLITE_ENABLE_CEROD)\n  case PragTyp_ACTIVATE_EXTENSIONS: if( zRight ){\n#ifdef SQLITE_HAS_CODEC\n    if( sqlite3StrNICmp(zRight, \"see-\", 4)==0 ){\n      sqlite3_activate_see(&zRight[4]);\n    }\n#endif\n#ifdef SQLITE_ENABLE_CEROD\n    if( sqlite3StrNICmp(zRight, \"cerod-\", 6)==0 ){\n      sqlite3_activate_cerod(&zRight[6]);\n    }\n#endif\n  }\n  break;\n#endif\n\n  } /* End of the PRAGMA switch */\n\n  /* The following block is a no-op unless SQLITE_DEBUG is defined. Its only\n  ** purpose is to execute assert() statements to verify that if the\n  ** PragFlg_NoColumns1 flag is set and the caller specified an argument\n  ** to the PRAGMA, the implementation has not added any OP_ResultRow \n  ** instructions to the VM.  */\n  if( (pPragma->mPragFlg & PragFlg_NoColumns1) && zRight ){\n    sqlite3VdbeVerifyNoResultRow(v);\n  }\n\npragma_out:\n  sqlite3DbFree(db, zLeft);\n  sqlite3DbFree(db, zRight);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "          sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n",
        "src_path": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd___pragma.c",
        "uri": "https://api.github.com/repos/sqlite/sqlite/commits/ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd",
        "commit_msg": "Fix the NOT NULL verification logic in PRAGMA integrity_check so that it\nworks for generated columns whose value is the result of a comparison operator.\nTicket [bd8c280671ba44a7]\n\nFossilOrigin-Name: f3b39c71b88cb6721f443de56cdce4c08252453a5e340b00a2bd88dc10c42400",
        "test_func_diff": [
            {
                "fn": "test/gencol1.test",
                "patch": "@@ -328,4 +328,18 @@ do_catchsql_test gencol1-11.80 {\n   INSERT OR REPLACE INTO t0(c0, c1) VALUES (2, 1), (1, 0)\n } {1 {FOREIGN KEY constraint failed}}\n \n+# 2019-12-09 ticket bd8c280671ba44a7\n+# With generated columns, the sqlite3ExprGetColumnOfTable() routine might\n+# generate a code sequence that does not end with OP_Column.  So check to\n+# make sure that the last instruction generated is an OP_column prior to\n+# applying the OPFLAG_TYPEOFARG optimization to NOT NULL checks in the\n+# PRAGMA integrity_check code.\n+#\n+sqlite3 db :memory:\n+do_execsql_test gencol1-12.10 {\n+  CREATE TABLE t0 (c0, c1 NOT NULL AS (c0==0));\n+  INSERT INTO t0(c0) VALUES (0);\n+  PRAGMA integrity_check;\n+} {ok}\n+\n finish_test"
            }
        ],
        "error_msg": "warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\ngencol1-12.10...Exception ignored in: <gdb._GdbOutputFile object at 0x7f8ee7d2d790>\nTraceback (most recent call last):\n  File \"/usr/share/gdb/python/gdb/__init__.py\", line 43, in flush\n    def flush(self):\nKeyboardInterrupt: \n"
    },
    "a6c1a71cde082e09750465d5675699062922e387___select.c": {
        "prefix": "static int selectExpander(Walker *pWalker, Select *p){\n  Parse *pParse = pWalker->pParse;\n  int i, j, k;\n  SrcList *pTabList;\n  ExprList *pEList;\n  struct SrcList_item *pFrom;\n  sqlite3 *db = pParse->db;\n  Expr *pE, *pRight, *pExpr;\n  u16 selFlags = p->selFlags;\n  u32 elistFlags = 0;\n\n  p->selFlags |= SF_Expanded;\n  if( db->mallocFailed  ){\n    return WRC_Abort;\n  }\n  assert( p->pSrc!=0 );\n  if( (selFlags & SF_Expanded)!=0 ){\n    return WRC_Prune;\n  }\n  if( pWalker->eCode ){\n    /* Renumber selId because it has been copied from a view */\n    p->selId = ++pParse->nSelect;\n  }\n  pTabList = p->pSrc;\n  pEList = p->pEList;\n  sqlite3WithPush(pParse, p->pWith, 0);\n\n  /* Make sure cursor numbers have been assigned to all entries in\n  ** the FROM clause of the SELECT statement.\n  */\n  sqlite3SrcListAssignCursors(pParse, pTabList);\n\n  /* Look up every table named in the FROM clause of the select.  If\n  ** an entry of the FROM clause is a subquery instead of a table or view,\n  ** then create a transient table structure to describe the subquery.\n  */\n  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n    Table *pTab;\n    assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );\n    if( pFrom->fg.isRecursive ) continue;\n    assert( pFrom->pTab==0 );\n#ifndef SQLITE_OMIT_CTE\n    if( withExpand(pWalker, pFrom) ) return WRC_Abort;\n    if( pFrom->pTab ) {} else\n#endif\n    if( pFrom->zName==0 ){\n#ifndef SQLITE_OMIT_SUBQUERY\n      Select *pSel = pFrom->pSelect;\n      /* A sub-query in the FROM clause of a SELECT */\n      assert( pSel!=0 );\n      assert( pFrom->pTab==0 );\n      if( sqlite3WalkSelect(pWalker, pSel) ) return WRC_Abort;\n      if( sqlite3ExpandSubquery(pParse, pFrom) ) return WRC_Abort;\n#endif\n    }else{\n      /* An ordinary table or view name in the FROM clause */\n      assert( pFrom->pTab==0 );\n      pFrom->pTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);\n      if( pTab==0 ) return WRC_Abort;\n      if( pTab->nTabRef>=0xffff ){\n        sqlite3ErrorMsg(pParse, \"too many references to \\\"%s\\\": max 65535\",\n           pTab->zName);\n        pFrom->pTab = 0;\n        return WRC_Abort;\n      }\n      pTab->nTabRef++;\n      if( !IsVirtual(pTab) && cannotBeFunction(pParse, pFrom) ){\n        return WRC_Abort;\n      }\n#if !defined(SQLITE_OMIT_VIEW) || !defined (SQLITE_OMIT_VIRTUALTABLE)\n      if( IsVirtual(pTab) || pTab->pSelect ){\n        i16 nCol;\n        u8 eCodeOrig = pWalker->eCode;\n        if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;\n        assert( pFrom->pSelect==0 );\n        if( pTab->pSelect && (db->flags & SQLITE_EnableView)==0 ){\n          sqlite3ErrorMsg(pParse, \"access to view \\\"%s\\\" prohibited\",\n              pTab->zName);\n        }\n        pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);\n        nCol = pTab->nCol;\n        pTab->nCol = -1;\n        pWalker->eCode = 1;  /* Turn on Select.selId renumbering */\n        sqlite3WalkSelect(pWalker, pFrom->pSelect);\n        pWalker->eCode = eCodeOrig;\n        pTab->nCol = nCol;\n      }\n#endif\n    }\n\n    /* Locate the index named by the INDEXED BY clause, if any. */\n    if( sqlite3IndexedByLookup(pParse, pFrom) ){\n      return WRC_Abort;\n    }\n  }\n\n  /* Process NATURAL keywords, and ON and USING clauses of joins.\n  */\n",
        "suffix": "    return WRC_Abort;\n  }\n\n  /* For every \"*\" that occurs in the column list, insert the names of\n  ** all columns in all tables.  And for every TABLE.* insert the names\n  ** of all columns in TABLE.  The parser inserted a special expression\n  ** with the TK_ASTERISK operator for each \"*\" that it found in the column\n  ** list.  The following code just has to locate the TK_ASTERISK\n  ** expressions and expand each one to the list of all columns in\n  ** all tables.\n  **\n  ** The first loop just checks to see if there are any \"*\" operators\n  ** that need expanding.\n  */\n  for(k=0; k<pEList->nExpr; k++){\n    pE = pEList->a[k].pExpr;\n    if( pE->op==TK_ASTERISK ) break;\n    assert( pE->op!=TK_DOT || pE->pRight!=0 );\n    assert( pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) );\n    if( pE->op==TK_DOT && pE->pRight->op==TK_ASTERISK ) break;\n    elistFlags |= pE->flags;\n  }\n  if( k<pEList->nExpr ){\n    /*\n    ** If we get here it means the result set contains one or more \"*\"\n    ** operators that need to be expanded.  Loop through each expression\n    ** in the result set and expand them one by one.\n    */\n    struct ExprList_item *a = pEList->a;\n    ExprList *pNew = 0;\n    int flags = pParse->db->flags;\n    int longNames = (flags & SQLITE_FullColNames)!=0\n                      && (flags & SQLITE_ShortColNames)==0;\n\n    for(k=0; k<pEList->nExpr; k++){\n      pE = a[k].pExpr;\n      elistFlags |= pE->flags;\n      pRight = pE->pRight;\n      assert( pE->op!=TK_DOT || pRight!=0 );\n      if( pE->op!=TK_ASTERISK\n       && (pE->op!=TK_DOT || pRight->op!=TK_ASTERISK)\n      ){\n        /* This particular expression does not need to be expanded.\n        */\n        pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);\n        if( pNew ){\n          pNew->a[pNew->nExpr-1].zName = a[k].zName;\n          pNew->a[pNew->nExpr-1].zSpan = a[k].zSpan;\n          a[k].zName = 0;\n          a[k].zSpan = 0;\n        }\n        a[k].pExpr = 0;\n      }else{\n        /* This expression is a \"*\" or a \"TABLE.*\" and needs to be\n        ** expanded. */\n        int tableSeen = 0;      /* Set to 1 when TABLE matches */\n        char *zTName = 0;       /* text of name of TABLE */\n        if( pE->op==TK_DOT ){\n          assert( pE->pLeft!=0 );\n          assert( !ExprHasProperty(pE->pLeft, EP_IntValue) );\n          zTName = pE->pLeft->u.zToken;\n        }\n        for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n          Table *pTab = pFrom->pTab;\n          Select *pSub = pFrom->pSelect;\n          char *zTabName = pFrom->zAlias;\n          const char *zSchemaName = 0;\n          int iDb;\n          if( zTabName==0 ){\n            zTabName = pTab->zName;\n          }\n          if( db->mallocFailed ) break;\n          if( pSub==0 || (pSub->selFlags & SF_NestedFrom)==0 ){\n            pSub = 0;\n            if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){\n              continue;\n            }\n            iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n            zSchemaName = iDb>=0 ? db->aDb[iDb].zDbSName : \"*\";\n          }\n          for(j=0; j<pTab->nCol; j++){\n            char *zName = pTab->aCol[j].zName;\n            char *zColname;  /* The computed column name */\n            char *zToFree;   /* Malloced string that needs to be freed */\n            Token sColname;  /* Computed column name as a token */\n\n            assert( zName );\n            if( zTName && pSub\n             && sqlite3MatchSpanName(pSub->pEList->a[j].zSpan, 0, zTName, 0)==0\n            ){\n              continue;\n            }\n\n            /* If a column is marked as 'hidden', omit it from the expanded\n            ** result-set list unless the SELECT has the SF_IncludeHidden\n            ** bit set.\n            */\n            if( (p->selFlags & SF_IncludeHidden)==0\n             && IsHiddenColumn(&pTab->aCol[j]) \n            ){\n              continue;\n            }\n            tableSeen = 1;\n\n            if( i>0 && zTName==0 ){\n              if( (pFrom->fg.jointype & JT_NATURAL)!=0\n                && tableAndColumnIndex(pTabList, i, zName, 0, 0)\n              ){\n                /* In a NATURAL join, omit the join columns from the \n                ** table to the right of the join */\n                continue;\n              }\n              if( sqlite3IdListIndex(pFrom->pUsing, zName)>=0 ){\n                /* In a join with a USING clause, omit columns in the\n                ** using clause from the table on the right. */\n                continue;\n              }\n            }\n            pRight = sqlite3Expr(db, TK_ID, zName);\n            zColname = zName;\n            zToFree = 0;\n            if( longNames || pTabList->nSrc>1 ){\n              Expr *pLeft;\n              pLeft = sqlite3Expr(db, TK_ID, zTabName);\n              pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);\n              if( zSchemaName ){\n                pLeft = sqlite3Expr(db, TK_ID, zSchemaName);\n                pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pExpr);\n              }\n              if( longNames ){\n                zColname = sqlite3MPrintf(db, \"%s.%s\", zTabName, zName);\n                zToFree = zColname;\n              }\n            }else{\n              pExpr = pRight;\n            }\n            pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);\n            sqlite3TokenInit(&sColname, zColname);\n            sqlite3ExprListSetName(pParse, pNew, &sColname, 0);\n            if( pNew && (p->selFlags & SF_NestedFrom)!=0 ){\n              struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];\n              if( pSub ){\n                pX->zSpan = sqlite3DbStrDup(db, pSub->pEList->a[j].zSpan);\n                testcase( pX->zSpan==0 );\n              }else{\n                pX->zSpan = sqlite3MPrintf(db, \"%s.%s.%s\",\n                                           zSchemaName, zTabName, zColname);\n                testcase( pX->zSpan==0 );\n              }\n              pX->bSpanIsTab = 1;\n            }\n            sqlite3DbFree(db, zToFree);\n          }\n        }\n        if( !tableSeen ){\n          if( zTName ){\n            sqlite3ErrorMsg(pParse, \"no such table: %s\", zTName);\n          }else{\n            sqlite3ErrorMsg(pParse, \"no tables specified\");\n          }\n        }\n      }\n    }\n    sqlite3ExprListDelete(db, pEList);\n    p->pEList = pNew;\n  }\n  if( p->pEList ){\n    if( p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n      sqlite3ErrorMsg(pParse, \"too many columns in result set\");\n      return WRC_Abort;\n    }\n    if( (elistFlags & (EP_HasFunc|EP_Subquery))!=0 ){\n      p->selFlags |= SF_ComplexResult;\n    }\n  }\n  return WRC_Continue;\n}\n",
        "start": 4883,
        "end": 5158,
        "buggy": "static int selectExpander(Walker *pWalker, Select *p){\n  Parse *pParse = pWalker->pParse;\n  int i, j, k;\n  SrcList *pTabList;\n  ExprList *pEList;\n  struct SrcList_item *pFrom;\n  sqlite3 *db = pParse->db;\n  Expr *pE, *pRight, *pExpr;\n  u16 selFlags = p->selFlags;\n  u32 elistFlags = 0;\n\n  p->selFlags |= SF_Expanded;\n  if( db->mallocFailed  ){\n    return WRC_Abort;\n  }\n  assert( p->pSrc!=0 );\n  if( (selFlags & SF_Expanded)!=0 ){\n    return WRC_Prune;\n  }\n  if( pWalker->eCode ){\n    /* Renumber selId because it has been copied from a view */\n    p->selId = ++pParse->nSelect;\n  }\n  pTabList = p->pSrc;\n  pEList = p->pEList;\n  sqlite3WithPush(pParse, p->pWith, 0);\n\n  /* Make sure cursor numbers have been assigned to all entries in\n  ** the FROM clause of the SELECT statement.\n  */\n  sqlite3SrcListAssignCursors(pParse, pTabList);\n\n  /* Look up every table named in the FROM clause of the select.  If\n  ** an entry of the FROM clause is a subquery instead of a table or view,\n  ** then create a transient table structure to describe the subquery.\n  */\n  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n    Table *pTab;\n    assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );\n    if( pFrom->fg.isRecursive ) continue;\n    assert( pFrom->pTab==0 );\n#ifndef SQLITE_OMIT_CTE\n    if( withExpand(pWalker, pFrom) ) return WRC_Abort;\n    if( pFrom->pTab ) {} else\n#endif\n    if( pFrom->zName==0 ){\n#ifndef SQLITE_OMIT_SUBQUERY\n      Select *pSel = pFrom->pSelect;\n      /* A sub-query in the FROM clause of a SELECT */\n      assert( pSel!=0 );\n      assert( pFrom->pTab==0 );\n      if( sqlite3WalkSelect(pWalker, pSel) ) return WRC_Abort;\n      if( sqlite3ExpandSubquery(pParse, pFrom) ) return WRC_Abort;\n#endif\n    }else{\n      /* An ordinary table or view name in the FROM clause */\n      assert( pFrom->pTab==0 );\n      pFrom->pTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);\n      if( pTab==0 ) return WRC_Abort;\n      if( pTab->nTabRef>=0xffff ){\n        sqlite3ErrorMsg(pParse, \"too many references to \\\"%s\\\": max 65535\",\n           pTab->zName);\n        pFrom->pTab = 0;\n        return WRC_Abort;\n      }\n      pTab->nTabRef++;\n      if( !IsVirtual(pTab) && cannotBeFunction(pParse, pFrom) ){\n        return WRC_Abort;\n      }\n#if !defined(SQLITE_OMIT_VIEW) || !defined (SQLITE_OMIT_VIRTUALTABLE)\n      if( IsVirtual(pTab) || pTab->pSelect ){\n        i16 nCol;\n        u8 eCodeOrig = pWalker->eCode;\n        if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;\n        assert( pFrom->pSelect==0 );\n        if( pTab->pSelect && (db->flags & SQLITE_EnableView)==0 ){\n          sqlite3ErrorMsg(pParse, \"access to view \\\"%s\\\" prohibited\",\n              pTab->zName);\n        }\n        pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);\n        nCol = pTab->nCol;\n        pTab->nCol = -1;\n        pWalker->eCode = 1;  /* Turn on Select.selId renumbering */\n        sqlite3WalkSelect(pWalker, pFrom->pSelect);\n        pWalker->eCode = eCodeOrig;\n        pTab->nCol = nCol;\n      }\n#endif\n    }\n\n    /* Locate the index named by the INDEXED BY clause, if any. */\n    if( sqlite3IndexedByLookup(pParse, pFrom) ){\n      return WRC_Abort;\n    }\n  }\n\n  /* Process NATURAL keywords, and ON and USING clauses of joins.\n  */\n  if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n    return WRC_Abort;\n  }\n\n  /* For every \"*\" that occurs in the column list, insert the names of\n  ** all columns in all tables.  And for every TABLE.* insert the names\n  ** of all columns in TABLE.  The parser inserted a special expression\n  ** with the TK_ASTERISK operator for each \"*\" that it found in the column\n  ** list.  The following code just has to locate the TK_ASTERISK\n  ** expressions and expand each one to the list of all columns in\n  ** all tables.\n  **\n  ** The first loop just checks to see if there are any \"*\" operators\n  ** that need expanding.\n  */\n  for(k=0; k<pEList->nExpr; k++){\n    pE = pEList->a[k].pExpr;\n    if( pE->op==TK_ASTERISK ) break;\n    assert( pE->op!=TK_DOT || pE->pRight!=0 );\n    assert( pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) );\n    if( pE->op==TK_DOT && pE->pRight->op==TK_ASTERISK ) break;\n    elistFlags |= pE->flags;\n  }\n  if( k<pEList->nExpr ){\n    /*\n    ** If we get here it means the result set contains one or more \"*\"\n    ** operators that need to be expanded.  Loop through each expression\n    ** in the result set and expand them one by one.\n    */\n    struct ExprList_item *a = pEList->a;\n    ExprList *pNew = 0;\n    int flags = pParse->db->flags;\n    int longNames = (flags & SQLITE_FullColNames)!=0\n                      && (flags & SQLITE_ShortColNames)==0;\n\n    for(k=0; k<pEList->nExpr; k++){\n      pE = a[k].pExpr;\n      elistFlags |= pE->flags;\n      pRight = pE->pRight;\n      assert( pE->op!=TK_DOT || pRight!=0 );\n      if( pE->op!=TK_ASTERISK\n       && (pE->op!=TK_DOT || pRight->op!=TK_ASTERISK)\n      ){\n        /* This particular expression does not need to be expanded.\n        */\n        pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);\n        if( pNew ){\n          pNew->a[pNew->nExpr-1].zName = a[k].zName;\n          pNew->a[pNew->nExpr-1].zSpan = a[k].zSpan;\n          a[k].zName = 0;\n          a[k].zSpan = 0;\n        }\n        a[k].pExpr = 0;\n      }else{\n        /* This expression is a \"*\" or a \"TABLE.*\" and needs to be\n        ** expanded. */\n        int tableSeen = 0;      /* Set to 1 when TABLE matches */\n        char *zTName = 0;       /* text of name of TABLE */\n        if( pE->op==TK_DOT ){\n          assert( pE->pLeft!=0 );\n          assert( !ExprHasProperty(pE->pLeft, EP_IntValue) );\n          zTName = pE->pLeft->u.zToken;\n        }\n        for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n          Table *pTab = pFrom->pTab;\n          Select *pSub = pFrom->pSelect;\n          char *zTabName = pFrom->zAlias;\n          const char *zSchemaName = 0;\n          int iDb;\n          if( zTabName==0 ){\n            zTabName = pTab->zName;\n          }\n          if( db->mallocFailed ) break;\n          if( pSub==0 || (pSub->selFlags & SF_NestedFrom)==0 ){\n            pSub = 0;\n            if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){\n              continue;\n            }\n            iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n            zSchemaName = iDb>=0 ? db->aDb[iDb].zDbSName : \"*\";\n          }\n          for(j=0; j<pTab->nCol; j++){\n            char *zName = pTab->aCol[j].zName;\n            char *zColname;  /* The computed column name */\n            char *zToFree;   /* Malloced string that needs to be freed */\n            Token sColname;  /* Computed column name as a token */\n\n            assert( zName );\n            if( zTName && pSub\n             && sqlite3MatchSpanName(pSub->pEList->a[j].zSpan, 0, zTName, 0)==0\n            ){\n              continue;\n            }\n\n            /* If a column is marked as 'hidden', omit it from the expanded\n            ** result-set list unless the SELECT has the SF_IncludeHidden\n            ** bit set.\n            */\n            if( (p->selFlags & SF_IncludeHidden)==0\n             && IsHiddenColumn(&pTab->aCol[j]) \n            ){\n              continue;\n            }\n            tableSeen = 1;\n\n            if( i>0 && zTName==0 ){\n              if( (pFrom->fg.jointype & JT_NATURAL)!=0\n                && tableAndColumnIndex(pTabList, i, zName, 0, 0)\n              ){\n                /* In a NATURAL join, omit the join columns from the \n                ** table to the right of the join */\n                continue;\n              }\n              if( sqlite3IdListIndex(pFrom->pUsing, zName)>=0 ){\n                /* In a join with a USING clause, omit columns in the\n                ** using clause from the table on the right. */\n                continue;\n              }\n            }\n            pRight = sqlite3Expr(db, TK_ID, zName);\n            zColname = zName;\n            zToFree = 0;\n            if( longNames || pTabList->nSrc>1 ){\n              Expr *pLeft;\n              pLeft = sqlite3Expr(db, TK_ID, zTabName);\n              pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);\n              if( zSchemaName ){\n                pLeft = sqlite3Expr(db, TK_ID, zSchemaName);\n                pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pExpr);\n              }\n              if( longNames ){\n                zColname = sqlite3MPrintf(db, \"%s.%s\", zTabName, zName);\n                zToFree = zColname;\n              }\n            }else{\n              pExpr = pRight;\n            }\n            pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);\n            sqlite3TokenInit(&sColname, zColname);\n            sqlite3ExprListSetName(pParse, pNew, &sColname, 0);\n            if( pNew && (p->selFlags & SF_NestedFrom)!=0 ){\n              struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];\n              if( pSub ){\n                pX->zSpan = sqlite3DbStrDup(db, pSub->pEList->a[j].zSpan);\n                testcase( pX->zSpan==0 );\n              }else{\n                pX->zSpan = sqlite3MPrintf(db, \"%s.%s.%s\",\n                                           zSchemaName, zTabName, zColname);\n                testcase( pX->zSpan==0 );\n              }\n              pX->bSpanIsTab = 1;\n            }\n            sqlite3DbFree(db, zToFree);\n          }\n        }\n        if( !tableSeen ){\n          if( zTName ){\n            sqlite3ErrorMsg(pParse, \"no such table: %s\", zTName);\n          }else{\n            sqlite3ErrorMsg(pParse, \"no tables specified\");\n          }\n        }\n      }\n    }\n    sqlite3ExprListDelete(db, pEList);\n    p->pEList = pNew;\n  }\n  if( p->pEList ){\n    if( p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n      sqlite3ErrorMsg(pParse, \"too many columns in result set\");\n      return WRC_Abort;\n    }\n    if( (elistFlags & (EP_HasFunc|EP_Subquery))!=0 ){\n      p->selFlags |= SF_ComplexResult;\n    }\n  }\n  return WRC_Continue;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n",
        "src_path": "a6c1a71cde082e09750465d5675699062922e387___select.c",
        "uri": "https://api.github.com/repos/sqlite/sqlite/commits/a6c1a71cde082e09750465d5675699062922e387",
        "commit_msg": "Do not attempt to unwind the WITH stack in the Parse object following an error. This fixes a separate case to [de6e6d68].\n\nFossilOrigin-Name: d29edef93451cc67a5d69c1cce1b1832d9ca8fff1f600afdd51338b74d077b92",
        "test_func_diff": [
            {
                "fn": "test/altertab3.test",
                "patch": "@@ -531,4 +531,26 @@ do_catchsql_test 23.2 {\n   ALTER TABLE t1 RENAME TO t1x;\n } {1 {error in trigger r1: no such table: main.t2}}\n \n+#------------------------------------------------------------------------\n+#\n+reset_db\n+do_execsql_test 23.1 {\n+  CREATE TABLE v0 (a);\n+  CREATE VIEW v2 (v3) AS \n+    WITH x1 AS (SELECT * FROM v2) \n+    SELECT v3 AS x, v3 AS y FROM v2; \n+}\n+\n+do_catchsql_test 23.2 {\n+  SELECT * FROM v2\n+} {1 {view v2 is circularly defined}}\n+\n+db close\n+sqlite3 db test.db\n+\n+do_catchsql_test 23.3 {\n+  ALTER TABLE v0 RENAME TO t3 ;\n+} {1 {error in view v2: view v2 is circularly defined}}\n+\n finish_test\n+"
            }
        ],
        "error_msg": "warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n[Detaching after fork from child process 42845]\nSQLite 2019-12-27 20:54:42 d29edef93451cc67a5d69c1cce1b1832d9ca8fff1f600afdd51338b74d077b92\n0 errors out of 71 tests on deef54515472 Linux 64-bit little-endian\nAll memory allocations freed - no leaks\nMemory used:          now          0  max     392328  max-size     120000\nAllocation count:     now          0  max        402\nPage-cache used:      now          0  max          0  max-size       1288\nPage-cache overflow:  now          0  max       6960\nMaximum memory usage: 392328 bytes\nCurrent memory usage: 0 bytes\nNumber of malloc()  : -1 calls\n[Inferior 1 (process 39996) exited normally]\n"
    },
    "77f619d48259383628c3ec4654b1ad578e9eb40e___gd.c": {
        "prefix": "BGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit, rightLimit;\n\tint i;\n\tint restoreAlphaBleding;\n\n",
        "suffix": "\t\t/* Refuse to fill to a non-solid border */\n\t\treturn;\n\t}\n\n\tleftLimit = (-1);\n\n\trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\t\n\tfor (i = x; (i >= 0); i--) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == (-1)) {\n\t\tim->alphaBlendingFlag = restoreAlphaBleding;\n\t\treturn;\n\t}\n\t/* Seek right */\n\trightLimit = x;\n\tfor (i = (x + 1); (i < im->sx); i++) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t/* Look at lines above and below and start paints */\n\t/* Above */\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c;\n\t\t\tc = gdImageGetPixel (im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\t/* Below */\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c = gdImageGetPixel (im, i, y + 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBleding;\n}\n",
        "start": 1923,
        "end": 2005,
        "buggy": "BGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit, rightLimit;\n\tint i;\n\tint restoreAlphaBleding;\n\n\tif (border < 0) {\n\t\t/* Refuse to fill to a non-solid border */\n\t\treturn;\n\t}\n\n\tleftLimit = (-1);\n\n\trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\t\n\tfor (i = x; (i >= 0); i--) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == (-1)) {\n\t\tim->alphaBlendingFlag = restoreAlphaBleding;\n\t\treturn;\n\t}\n\t/* Seek right */\n\trightLimit = x;\n\tfor (i = (x + 1); (i < im->sx); i++) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t/* Look at lines above and below and start paints */\n\t/* Above */\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c;\n\t\t\tc = gdImageGetPixel (im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\t/* Below */\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c = gdImageGetPixel (im, i, y + 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBleding;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\tif (border < 0) {\n",
        "src_path": "77f619d48259383628c3ec4654b1ad578e9eb40e___gd.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/77f619d48259383628c3ec4654b1ad578e9eb40e",
        "commit_msg": "fix #215 gdImageFillToBorder stack-overflow when invalid color is used",
        "test_func_diff": [
            {
                "fn": "tests/gdimagefilltoborder/.gitignore",
                "patch": "@@ -1 +1,2 @@\n /bug00037\n+/github_bug_215"
            },
            {
                "fn": "tests/gdimagefilltoborder/CMakeLists.txt",
                "patch": "@@ -1,5 +1,6 @@\n SET(TESTS_FILES\n \tbug00037\n+\tgithub_bug_215\n )\n \n ADD_GD_TESTS()"
            },
            {
                "fn": "tests/gdimagefilltoborder/Makemodule.am",
                "patch": "@@ -1,6 +1,7 @@\n if HAVE_LIBPNG\n libgd_test_programs += \\\n-\tgdimagefilltoborder/bug00037\n+\tgdimagefilltoborder/bug00037 \\\n+\tgdimagefilltoborder/github_bug_215\n endif\n \n EXTRA_DIST += \\"
            }
        ],
        "error_msg": "====================================\n   GD 2.2.1: tests/test-suite.log\n====================================\n\n# TOTAL: 107\n# PASS:  103\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  4\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:35: Total pixels changed: 9 with a maximum channel difference of 255.\nReference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gdimagefilltoborder/github_bug_215\n========================================\n\nFAIL gdimagefilltoborder/github_bug_215 (exit status: 139)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\n(491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\nFAIL: gif/bug00006\n==================\n\ngif/bug00006.c:49: assert failed in <%s:%i>\nFAIL gif/bug00006 (exit status: 1)\n\n"
    },
    "58b6dde319c301b0eae27d12e2a659e067d80558___gd_tga.c": {
        "prefix": "int read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tint* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint encoded_pixels;\n\tint rle_size;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\trle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);\n\t\tif (rle_size <= 0) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < rle_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n",
        "suffix": "\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + pixel_block_size > rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));\n\t\t\t\t\tbitmap_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));\n\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n",
        "start": 206,
        "end": 338,
        "buggy": "int read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tint* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint encoded_pixels;\n\tint rle_size;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\trle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);\n\t\tif (rle_size <= 0) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < rle_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n\t\t\t\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + pixel_block_size > rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));\n\t\t\t\t\tbitmap_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));\n\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\t\n",
        "src_path": "58b6dde319c301b0eae27d12e2a659e067d80558___gd_tga.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/58b6dde319c301b0eae27d12e2a659e067d80558",
        "commit_msg": "Fix OOB reads of the TGA decompression buffer\n\nIt is possible to craft TGA files which will overflow the decompression\nbuffer, but not the image's bitmap. Therefore we also have to check for\npotential decompression buffer overflows.\n\nThis issue had been reported by Ibrahim El-Sayed to security@libgd.org;\na modified case exposing an off-by-one error of the first patch had been\nprovided by Konrad Beckmann.\n\nThis commit is an amendment to commit fb0e0cce, so we use CVE-2016-6906\nas well.",
        "test_func_diff": [
            {
                "fn": "tests/tga/Makemodule.am",
                "patch": "@@ -15,7 +15,8 @@ EXTRA_DIST += \\\n \ttga/bug00247a.tga \\\n \ttga/bug00248.tga \\\n \ttga/bug00248a.tga \\\n-\ttga/heap_overflow.tga \\\n+\ttga/heap_overflow_1.tga \\\n+\ttga/heap_overflow_2.tga \\\n \ttga/tga_read_rgb.png \\\n \ttga/tga_read_rgb.tga \\\n \ttga/tga_read_rgb_rle.tga"
            },
            {
                "fn": "tests/tga/heap_overflow.c",
                "patch": "@@ -1,27 +1,35 @@\n /**\n- * Test that the crafted TGA file doesn't trigger OOB reads.\n+ * Test that crafted TGA files don't trigger OOB reads.\n  */\n \n \n #include \"gd.h\"\n #include \"gdtest.h\"\n \n \n+static void check_file(char *basename);\n static size_t read_test_file(char **buffer, char *basename);\n \n \n int main()\n+{\n+    check_file(\"heap_overflow_1.tga\");\n+    check_file(\"heap_overflow_2.tga\");\n+\n+    return gdNumFailures();\n+}\n+\n+\n+static void check_file(char *basename)\n {\n     gdImagePtr im;\n     char *buffer;\n     size_t size;\n \n-    size = read_test_file(&buffer, \"heap_overflow.tga\");\n+    size = read_test_file(&buffer, basename);\n     im = gdImageCreateFromTgaPtr(size, (void *) buffer);\n     gdTestAssert(im == NULL);\n     free(buffer);\n-\n-    return gdNumFailures();\n }\n \n "
            }
        ],
        "error_msg": "========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 155\n# PASS:  153\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  2\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:31: Total pixels changed: 9 with a maximum channel difference of 255.\nfreetype/bug00132.c:33: Reference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\ngdimagestringft/gdimagestringft_bbox.c:56: (491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\n"
    },
    "28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5___spl_dllist.c": {
        "prefix": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = Z_SPLDLLIST_P(getThis());\n\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\t/* $obj[] = ... */\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\t/* $obj[$foo] = ... */\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\n\t\tindex = spl_offset_convert_to_long(zindex);\n\n\t\tif (index < 0 || index >= intern->llist->count) {\n",
        "suffix": "\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\n\t\tif (element != NULL) {\n\t\t\t/* call dtor on the old element as in spl_ptr_llist_pop */\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\n\t\t\t/* the element is replaced, delref the old one as in\n\t\t\t * SplDoublyLinkedList::pop() */\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\n\t\t\t/* new element, call ctor as in spl_ptr_llist_push */\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} /* }}} */\n",
        "start": 811,
        "end": 861,
        "buggy": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = Z_SPLDLLIST_P(getThis());\n\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\t/* $obj[] = ... */\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\t/* $obj[$foo] = ... */\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\n\t\tindex = spl_offset_convert_to_long(zindex);\n\n\t\tif (index < 0 || index >= intern->llist->count) {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\n\t\tif (element != NULL) {\n\t\t\t/* call dtor on the old element as in spl_ptr_llist_pop */\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\n\t\t\t/* the element is replaced, delref the old one as in\n\t\t\t * SplDoublyLinkedList::pop() */\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\n\t\t\t/* new element, call ctor as in spl_ptr_llist_push */\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} /* }}} */\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tzval_ptr_dtor(value);\n",
        "src_path": "28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5___spl_dllist.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5",
        "commit_msg": "Fix bug #71735: Double-free in SplDoublyLinkedList::offsetSet",
        "test_func_diff": [
            {
                "fn": "ext/spl/tests/bug71735.phpt",
                "patch": "@@ -0,0 +1,15 @@\n+--TEST--\n+Bug #71735 (Double-free in SplDoublyLinkedList::offsetSet)\n+--FILE--\n+<?php\n+try {\n+$var_1=new SplStack();\n+$var_1->offsetSet(100,new DateTime('2000-01-01'));\n+} catch(OutOfRangeException $e) {\n+\tprint $e->getMessage().\"\\n\";\n+}\n+?>\n+===DONE===\n+--EXPECT--\n+Offset invalid or out of range\n+===DONE===\n\\ No newline at end of file"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 7.0.6-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5 More .INIs : CWD : /out/php___php-src/git_repo_dir_28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. FAIL Bug #71735 (Double-free in SplDoublyLinkedList::offsetSet) [ext/spl/tests/bug71735.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #71735 (Double-free in SplDoublyLinkedList::offsetSet) [ext/spl/tests/bug71735.phpt] =====================================================================\n"
    },
    "6dbb1ee46b5f4725cc6519abf91e512a2a10dfed___exif.c": {
        "prefix": "static int exif_process_IFD_in_TIFF(image_info_type *ImageInfo, size_t dir_offset, int section_index TSRMLS_DC)\n{\n\tint i, sn, num_entries, sub_section_index = 0;\n\tunsigned char *dir_entry;\n\tchar tagname[64];\n\tsize_t ifd_size, dir_size, entry_offset, next_offset, entry_length, entry_value=0, fgot;\n\tint entry_tag , entry_type;\n\ttag_table_type tag_table = exif_get_tag_table(section_index);\n\n\tif (ImageInfo->ifd_nesting_level > MAX_IFD_NESTING_LEVEL) {\n                return FALSE;\n        }\n\n\tif (ImageInfo->FileSize >= dir_offset+2) {\n\t\tsn = exif_file_sections_add(ImageInfo, M_PSEUDO, 2, NULL);\n#ifdef EXIF_DEBUG\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: filesize(x%04X), IFD dir(x%04X + x%04X)\", ImageInfo->FileSize, dir_offset, 2);\n#endif\n\t\tphp_stream_seek(ImageInfo->infile, dir_offset, SEEK_SET); /* we do not know the order of sections */\n\t\tphp_stream_read(ImageInfo->infile, (char*)ImageInfo->file.list[sn].data, 2);\n\t\tnum_entries = php_ifd_get16u(ImageInfo->file.list[sn].data, ImageInfo->motorola_intel);\n\t\tdir_size = 2/*num dir entries*/ +12/*length of entry*/*num_entries +4/* offset to next ifd (points to thumbnail or NULL)*/;\n\t\tif (ImageInfo->FileSize >= dir_offset+dir_size) {\n#ifdef EXIF_DEBUG\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: filesize(x%04X), IFD dir(x%04X + x%04X), IFD entries(%d)\", ImageInfo->FileSize, dir_offset+2, dir_size-2, num_entries);\n#endif\n\t\t\tif (exif_file_sections_realloc(ImageInfo, sn, dir_size TSRMLS_CC)) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tphp_stream_read(ImageInfo->infile, (char*)(ImageInfo->file.list[sn].data+2), dir_size-2);\n\t\t\t/*exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Dump: %s\", exif_char_dump(ImageInfo->file.list[sn].data, dir_size, 0));*/\n\t\t\tnext_offset = php_ifd_get32u(ImageInfo->file.list[sn].data + dir_size - 4, ImageInfo->motorola_intel);\n#ifdef EXIF_DEBUG\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF done, next offset x%04X\", next_offset);\n#endif\n\t\t\t/* now we have the directory we can look how long it should be */\n\t\t\tifd_size = dir_size;\n\t\t\tfor(i=0;i<num_entries;i++) {\n\t\t\t\tdir_entry \t = ImageInfo->file.list[sn].data+2+i*12;\n\t\t\t\tentry_tag    = php_ifd_get16u(dir_entry+0, ImageInfo->motorola_intel);\n\t\t\t\tentry_type   = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);\n\t\t\t\tif (entry_type > NUM_FORMATS) {\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: tag(0x%04X,%12s): Illegal format code 0x%04X, switching to BYTE\", entry_tag, exif_get_tagname(entry_tag, tagname, -12, tag_table TSRMLS_CC), entry_type);\n\t\t\t\t\t/* Since this is repeated in exif_process_IFD_TAG make it a notice here */\n\t\t\t\t\t/* and make it a warning in the exif_process_IFD_TAG which is called    */\n\t\t\t\t\t/* elsewhere. */\n\t\t\t\t\tentry_type = TAG_FMT_BYTE;\n\t\t\t\t\t/*The next line would break the image on writeback: */\n\t\t\t\t\t/* php_ifd_set16u(dir_entry+2, entry_type, ImageInfo->motorola_intel);*/\n\t\t\t\t}\n\t\t\t\tentry_length = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel) * php_tiff_bytes_per_format[entry_type];\n\t\t\t\tif (entry_length <= 4) {\n\t\t\t\t\tswitch(entry_type) {\n\t\t\t\t\t\tcase TAG_FMT_USHORT:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get16u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_FMT_SSHORT:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get16s(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_FMT_ULONG:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_FMT_SLONG:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get32s(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tswitch(entry_tag) {\n\t\t\t\t\t\tcase TAG_IMAGEWIDTH:\n\t\t\t\t\t\tcase TAG_COMP_IMAGE_WIDTH:\n\t\t\t\t\t\t\tImageInfo->Width  = entry_value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_IMAGEHEIGHT:\n\t\t\t\t\t\tcase TAG_COMP_IMAGE_HEIGHT:\n\t\t\t\t\t\t\tImageInfo->Height = entry_value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_PHOTOMETRIC_INTERPRETATION:\n\t\t\t\t\t\t\tswitch (entry_value) {\n\t\t\t\t\t\t\t\tcase PMI_BLACK_IS_ZERO:\n\t\t\t\t\t\t\t\tcase PMI_WHITE_IS_ZERO:\n\t\t\t\t\t\t\t\tcase PMI_TRANSPARENCY_MASK:\n\t\t\t\t\t\t\t\t\tImageInfo->IsColor = 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase PMI_RGB:\n\t\t\t\t\t\t\t\tcase PMI_PALETTE_COLOR:\n\t\t\t\t\t\t\t\tcase PMI_SEPARATED:\n\t\t\t\t\t\t\t\tcase PMI_YCBCR:\n\t\t\t\t\t\t\t\tcase PMI_CIELAB:\n\t\t\t\t\t\t\t\t\tImageInfo->IsColor = 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tentry_offset = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t/* if entry needs expading ifd cache and entry is at end of current ifd cache. */\n\t\t\t\t\t/* otherwise there may be huge holes between two entries */\n\t\t\t\t\tif (entry_offset + entry_length > dir_offset + ifd_size\n\t\t\t\t\t  && entry_offset == dir_offset + ifd_size) {\n\t\t\t\t\t\tifd_size = entry_offset + entry_length - dir_offset;\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Resize struct: x%04X + x%04X - x%04X = x%04X\", entry_offset, entry_length, dir_offset, ifd_size);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ImageInfo->FileSize >= dir_offset + ImageInfo->file.list[sn].size) {\n\t\t\t\tif (ifd_size > dir_size) {\n\t\t\t\t\tif (dir_offset + ifd_size > ImageInfo->FileSize) {\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than size of IFD(x%04X + x%04X)\", ImageInfo->FileSize, dir_offset, ifd_size);\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tif (exif_file_sections_realloc(ImageInfo, sn, ifd_size TSRMLS_CC)) {\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t\t/* read values not stored in directory itself */\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: filesize(x%04X), IFD(x%04X + x%04X)\", ImageInfo->FileSize, dir_offset, ifd_size);\n#endif\n\t\t\t\t\tphp_stream_read(ImageInfo->infile, (char*)(ImageInfo->file.list[sn].data+dir_size), ifd_size-dir_size);\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF, done\");\n#endif\n\t\t\t\t}\n\t\t\t\t/* now process the tags */\n\t\t\t\tfor(i=0;i<num_entries;i++) {\n\t\t\t\t\tdir_entry \t = ImageInfo->file.list[sn].data+2+i*12;\n\t\t\t\t\tentry_tag    = php_ifd_get16u(dir_entry+0, ImageInfo->motorola_intel);\n\t\t\t\t\tentry_type   = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);\n\t\t\t\t\t/*entry_length = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel);*/\n\t\t\t\t\tif (entry_tag == TAG_EXIF_IFD_POINTER ||\n\t\t\t\t\t\tentry_tag == TAG_INTEROP_IFD_POINTER ||\n\t\t\t\t\t\tentry_tag == TAG_GPS_IFD_POINTER ||\n\t\t\t\t\t\tentry_tag == TAG_SUB_IFD\n\t\t\t\t\t) {\n\t\t\t\t\t\tswitch(entry_tag) {\n\t\t\t\t\t\t\tcase TAG_EXIF_IFD_POINTER:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_EXIF;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_EXIF;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TAG_GPS_IFD_POINTER:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_GPS;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_GPS;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TAG_INTEROP_IFD_POINTER:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_INTEROP;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_INTEROP;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TAG_SUB_IFD:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_THUMBNAIL;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_THUMBNAIL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tentry_offset = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Next IFD: %s @x%04X\", exif_get_sectionname(sub_section_index), entry_offset);\n#endif\n\t\t\t\t\t\tImageInfo->ifd_nesting_level++;\n\t\t\t\t\t\texif_process_IFD_in_TIFF(ImageInfo, entry_offset, sub_section_index TSRMLS_CC);\n\t\t\t\t\t\tif (section_index!=SECTION_THUMBNAIL && entry_tag==TAG_SUB_IFD) {\n\t\t\t\t\t\t\tif (ImageInfo->Thumbnail.filetype != IMAGE_FILETYPE_UNKNOWN\n\t\t\t\t\t\t\t&&  ImageInfo->Thumbnail.size\n\t\t\t\t\t\t\t&&  ImageInfo->Thumbnail.offset\n\t\t\t\t\t\t\t&&  ImageInfo->read_thumbnail\n\t\t\t\t\t\t\t) {\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"%s THUMBNAIL @0x%04X + 0x%04X\", ImageInfo->Thumbnail.data ? \"Ignore\" : \"Read\", ImageInfo->Thumbnail.offset, ImageInfo->Thumbnail.size);\n#endif\n\t\t\t\t\t\t\t\tif (!ImageInfo->Thumbnail.data) {\n\t\t\t\t\t\t\t\t\tImageInfo->Thumbnail.data = safe_emalloc(ImageInfo->Thumbnail.size, 1, 0);\n\t\t\t\t\t\t\t\t\tphp_stream_seek(ImageInfo->infile, ImageInfo->Thumbnail.offset, SEEK_SET);\n\t\t\t\t\t\t\t\t\tfgot = php_stream_read(ImageInfo->infile, ImageInfo->Thumbnail.data, ImageInfo->Thumbnail.size);\n\t\t\t\t\t\t\t\t\tif (fgot < ImageInfo->Thumbnail.size) {\n\t\t\t\t\t\t\t\t\t\tEXIF_ERRLOG_THUMBEOF(ImageInfo)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\texif_thumbnail_build(ImageInfo TSRMLS_CC);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Next IFD: %s done\", exif_get_sectionname(sub_section_index));\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!exif_process_IFD_TAG(ImageInfo, (char*)dir_entry,\n\t\t\t\t\t\t\t\t\t\t\t\t  (char*)(ImageInfo->file.list[sn].data-dir_offset),\n\t\t\t\t\t\t\t\t\t\t\t\t  ifd_size, 0, section_index, 0, tag_table TSRMLS_CC)) {\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* If we had a thumbnail in a SUB_IFD we have ANOTHER image in NEXT IFD */\n\t\t\t\tif (next_offset && section_index != SECTION_THUMBNAIL) {\n\t\t\t\t\t/* this should be a thumbnail IFD */\n\t\t\t\t\t/* the thumbnail itself is stored at Tag=StripOffsets */\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read next IFD (THUMBNAIL) at x%04X\", next_offset);\n#endif\n\t\t\t\t\tImageInfo->ifd_nesting_level++;\n\t\t\t\t\texif_process_IFD_in_TIFF(ImageInfo, next_offset, SECTION_THUMBNAIL TSRMLS_CC);\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"%s THUMBNAIL @0x%04X + 0x%04X\", ImageInfo->Thumbnail.data ? \"Ignore\" : \"Read\", ImageInfo->Thumbnail.offset, ImageInfo->Thumbnail.size);\n#endif\n\t\t\t\t\tif (!ImageInfo->Thumbnail.data && ImageInfo->Thumbnail.offset && ImageInfo->Thumbnail.size && ImageInfo->read_thumbnail) {\n\t\t\t\t\t\tImageInfo->Thumbnail.data = safe_emalloc(ImageInfo->Thumbnail.size, 1, 0);\n\t\t\t\t\t\tphp_stream_seek(ImageInfo->infile, ImageInfo->Thumbnail.offset, SEEK_SET);\n\t\t\t\t\t\tfgot = php_stream_read(ImageInfo->infile, ImageInfo->Thumbnail.data, ImageInfo->Thumbnail.size);\n\t\t\t\t\t\tif (fgot < ImageInfo->Thumbnail.size) {\n\t\t\t\t\t\t\tEXIF_ERRLOG_THUMBEOF(ImageInfo)\n\t\t\t\t\t\t}\n",
        "suffix": "\t\t\t\t\t}\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read next IFD (THUMBNAIL) done\");\n#endif\n\t\t\t\t}\n\t\t\t\treturn TRUE;\n\t\t\t} else {\n\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than size of IFD(x%04X)\", ImageInfo->FileSize, dir_offset+ImageInfo->file.list[sn].size);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than size of IFD dir(x%04X)\", ImageInfo->FileSize, dir_offset+dir_size);\n\t\t\treturn FALSE;\n\t\t}\n\t} else {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than start of IFD dir(x%04X)\", ImageInfo->FileSize, dir_offset+2);\n\t\treturn FALSE;\n\t}\n}\n",
        "start": 3564,
        "end": 3791,
        "buggy": "static int exif_process_IFD_in_TIFF(image_info_type *ImageInfo, size_t dir_offset, int section_index TSRMLS_DC)\n{\n\tint i, sn, num_entries, sub_section_index = 0;\n\tunsigned char *dir_entry;\n\tchar tagname[64];\n\tsize_t ifd_size, dir_size, entry_offset, next_offset, entry_length, entry_value=0, fgot;\n\tint entry_tag , entry_type;\n\ttag_table_type tag_table = exif_get_tag_table(section_index);\n\n\tif (ImageInfo->ifd_nesting_level > MAX_IFD_NESTING_LEVEL) {\n                return FALSE;\n        }\n\n\tif (ImageInfo->FileSize >= dir_offset+2) {\n\t\tsn = exif_file_sections_add(ImageInfo, M_PSEUDO, 2, NULL);\n#ifdef EXIF_DEBUG\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: filesize(x%04X), IFD dir(x%04X + x%04X)\", ImageInfo->FileSize, dir_offset, 2);\n#endif\n\t\tphp_stream_seek(ImageInfo->infile, dir_offset, SEEK_SET); /* we do not know the order of sections */\n\t\tphp_stream_read(ImageInfo->infile, (char*)ImageInfo->file.list[sn].data, 2);\n\t\tnum_entries = php_ifd_get16u(ImageInfo->file.list[sn].data, ImageInfo->motorola_intel);\n\t\tdir_size = 2/*num dir entries*/ +12/*length of entry*/*num_entries +4/* offset to next ifd (points to thumbnail or NULL)*/;\n\t\tif (ImageInfo->FileSize >= dir_offset+dir_size) {\n#ifdef EXIF_DEBUG\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: filesize(x%04X), IFD dir(x%04X + x%04X), IFD entries(%d)\", ImageInfo->FileSize, dir_offset+2, dir_size-2, num_entries);\n#endif\n\t\t\tif (exif_file_sections_realloc(ImageInfo, sn, dir_size TSRMLS_CC)) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tphp_stream_read(ImageInfo->infile, (char*)(ImageInfo->file.list[sn].data+2), dir_size-2);\n\t\t\t/*exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Dump: %s\", exif_char_dump(ImageInfo->file.list[sn].data, dir_size, 0));*/\n\t\t\tnext_offset = php_ifd_get32u(ImageInfo->file.list[sn].data + dir_size - 4, ImageInfo->motorola_intel);\n#ifdef EXIF_DEBUG\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF done, next offset x%04X\", next_offset);\n#endif\n\t\t\t/* now we have the directory we can look how long it should be */\n\t\t\tifd_size = dir_size;\n\t\t\tfor(i=0;i<num_entries;i++) {\n\t\t\t\tdir_entry \t = ImageInfo->file.list[sn].data+2+i*12;\n\t\t\t\tentry_tag    = php_ifd_get16u(dir_entry+0, ImageInfo->motorola_intel);\n\t\t\t\tentry_type   = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);\n\t\t\t\tif (entry_type > NUM_FORMATS) {\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: tag(0x%04X,%12s): Illegal format code 0x%04X, switching to BYTE\", entry_tag, exif_get_tagname(entry_tag, tagname, -12, tag_table TSRMLS_CC), entry_type);\n\t\t\t\t\t/* Since this is repeated in exif_process_IFD_TAG make it a notice here */\n\t\t\t\t\t/* and make it a warning in the exif_process_IFD_TAG which is called    */\n\t\t\t\t\t/* elsewhere. */\n\t\t\t\t\tentry_type = TAG_FMT_BYTE;\n\t\t\t\t\t/*The next line would break the image on writeback: */\n\t\t\t\t\t/* php_ifd_set16u(dir_entry+2, entry_type, ImageInfo->motorola_intel);*/\n\t\t\t\t}\n\t\t\t\tentry_length = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel) * php_tiff_bytes_per_format[entry_type];\n\t\t\t\tif (entry_length <= 4) {\n\t\t\t\t\tswitch(entry_type) {\n\t\t\t\t\t\tcase TAG_FMT_USHORT:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get16u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_FMT_SSHORT:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get16s(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_FMT_ULONG:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_FMT_SLONG:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get32s(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tswitch(entry_tag) {\n\t\t\t\t\t\tcase TAG_IMAGEWIDTH:\n\t\t\t\t\t\tcase TAG_COMP_IMAGE_WIDTH:\n\t\t\t\t\t\t\tImageInfo->Width  = entry_value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_IMAGEHEIGHT:\n\t\t\t\t\t\tcase TAG_COMP_IMAGE_HEIGHT:\n\t\t\t\t\t\t\tImageInfo->Height = entry_value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_PHOTOMETRIC_INTERPRETATION:\n\t\t\t\t\t\t\tswitch (entry_value) {\n\t\t\t\t\t\t\t\tcase PMI_BLACK_IS_ZERO:\n\t\t\t\t\t\t\t\tcase PMI_WHITE_IS_ZERO:\n\t\t\t\t\t\t\t\tcase PMI_TRANSPARENCY_MASK:\n\t\t\t\t\t\t\t\t\tImageInfo->IsColor = 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase PMI_RGB:\n\t\t\t\t\t\t\t\tcase PMI_PALETTE_COLOR:\n\t\t\t\t\t\t\t\tcase PMI_SEPARATED:\n\t\t\t\t\t\t\t\tcase PMI_YCBCR:\n\t\t\t\t\t\t\t\tcase PMI_CIELAB:\n\t\t\t\t\t\t\t\t\tImageInfo->IsColor = 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tentry_offset = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t/* if entry needs expading ifd cache and entry is at end of current ifd cache. */\n\t\t\t\t\t/* otherwise there may be huge holes between two entries */\n\t\t\t\t\tif (entry_offset + entry_length > dir_offset + ifd_size\n\t\t\t\t\t  && entry_offset == dir_offset + ifd_size) {\n\t\t\t\t\t\tifd_size = entry_offset + entry_length - dir_offset;\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Resize struct: x%04X + x%04X - x%04X = x%04X\", entry_offset, entry_length, dir_offset, ifd_size);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ImageInfo->FileSize >= dir_offset + ImageInfo->file.list[sn].size) {\n\t\t\t\tif (ifd_size > dir_size) {\n\t\t\t\t\tif (dir_offset + ifd_size > ImageInfo->FileSize) {\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than size of IFD(x%04X + x%04X)\", ImageInfo->FileSize, dir_offset, ifd_size);\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tif (exif_file_sections_realloc(ImageInfo, sn, ifd_size TSRMLS_CC)) {\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t\t/* read values not stored in directory itself */\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: filesize(x%04X), IFD(x%04X + x%04X)\", ImageInfo->FileSize, dir_offset, ifd_size);\n#endif\n\t\t\t\t\tphp_stream_read(ImageInfo->infile, (char*)(ImageInfo->file.list[sn].data+dir_size), ifd_size-dir_size);\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF, done\");\n#endif\n\t\t\t\t}\n\t\t\t\t/* now process the tags */\n\t\t\t\tfor(i=0;i<num_entries;i++) {\n\t\t\t\t\tdir_entry \t = ImageInfo->file.list[sn].data+2+i*12;\n\t\t\t\t\tentry_tag    = php_ifd_get16u(dir_entry+0, ImageInfo->motorola_intel);\n\t\t\t\t\tentry_type   = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);\n\t\t\t\t\t/*entry_length = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel);*/\n\t\t\t\t\tif (entry_tag == TAG_EXIF_IFD_POINTER ||\n\t\t\t\t\t\tentry_tag == TAG_INTEROP_IFD_POINTER ||\n\t\t\t\t\t\tentry_tag == TAG_GPS_IFD_POINTER ||\n\t\t\t\t\t\tentry_tag == TAG_SUB_IFD\n\t\t\t\t\t) {\n\t\t\t\t\t\tswitch(entry_tag) {\n\t\t\t\t\t\t\tcase TAG_EXIF_IFD_POINTER:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_EXIF;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_EXIF;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TAG_GPS_IFD_POINTER:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_GPS;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_GPS;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TAG_INTEROP_IFD_POINTER:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_INTEROP;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_INTEROP;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TAG_SUB_IFD:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_THUMBNAIL;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_THUMBNAIL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tentry_offset = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Next IFD: %s @x%04X\", exif_get_sectionname(sub_section_index), entry_offset);\n#endif\n\t\t\t\t\t\tImageInfo->ifd_nesting_level++;\n\t\t\t\t\t\texif_process_IFD_in_TIFF(ImageInfo, entry_offset, sub_section_index TSRMLS_CC);\n\t\t\t\t\t\tif (section_index!=SECTION_THUMBNAIL && entry_tag==TAG_SUB_IFD) {\n\t\t\t\t\t\t\tif (ImageInfo->Thumbnail.filetype != IMAGE_FILETYPE_UNKNOWN\n\t\t\t\t\t\t\t&&  ImageInfo->Thumbnail.size\n\t\t\t\t\t\t\t&&  ImageInfo->Thumbnail.offset\n\t\t\t\t\t\t\t&&  ImageInfo->read_thumbnail\n\t\t\t\t\t\t\t) {\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"%s THUMBNAIL @0x%04X + 0x%04X\", ImageInfo->Thumbnail.data ? \"Ignore\" : \"Read\", ImageInfo->Thumbnail.offset, ImageInfo->Thumbnail.size);\n#endif\n\t\t\t\t\t\t\t\tif (!ImageInfo->Thumbnail.data) {\n\t\t\t\t\t\t\t\t\tImageInfo->Thumbnail.data = safe_emalloc(ImageInfo->Thumbnail.size, 1, 0);\n\t\t\t\t\t\t\t\t\tphp_stream_seek(ImageInfo->infile, ImageInfo->Thumbnail.offset, SEEK_SET);\n\t\t\t\t\t\t\t\t\tfgot = php_stream_read(ImageInfo->infile, ImageInfo->Thumbnail.data, ImageInfo->Thumbnail.size);\n\t\t\t\t\t\t\t\t\tif (fgot < ImageInfo->Thumbnail.size) {\n\t\t\t\t\t\t\t\t\t\tEXIF_ERRLOG_THUMBEOF(ImageInfo)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\texif_thumbnail_build(ImageInfo TSRMLS_CC);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Next IFD: %s done\", exif_get_sectionname(sub_section_index));\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!exif_process_IFD_TAG(ImageInfo, (char*)dir_entry,\n\t\t\t\t\t\t\t\t\t\t\t\t  (char*)(ImageInfo->file.list[sn].data-dir_offset),\n\t\t\t\t\t\t\t\t\t\t\t\t  ifd_size, 0, section_index, 0, tag_table TSRMLS_CC)) {\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* If we had a thumbnail in a SUB_IFD we have ANOTHER image in NEXT IFD */\n\t\t\t\tif (next_offset && section_index != SECTION_THUMBNAIL) {\n\t\t\t\t\t/* this should be a thumbnail IFD */\n\t\t\t\t\t/* the thumbnail itself is stored at Tag=StripOffsets */\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read next IFD (THUMBNAIL) at x%04X\", next_offset);\n#endif\n\t\t\t\t\tImageInfo->ifd_nesting_level++;\n\t\t\t\t\texif_process_IFD_in_TIFF(ImageInfo, next_offset, SECTION_THUMBNAIL TSRMLS_CC);\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"%s THUMBNAIL @0x%04X + 0x%04X\", ImageInfo->Thumbnail.data ? \"Ignore\" : \"Read\", ImageInfo->Thumbnail.offset, ImageInfo->Thumbnail.size);\n#endif\n\t\t\t\t\tif (!ImageInfo->Thumbnail.data && ImageInfo->Thumbnail.offset && ImageInfo->Thumbnail.size && ImageInfo->read_thumbnail) {\n\t\t\t\t\t\tImageInfo->Thumbnail.data = safe_emalloc(ImageInfo->Thumbnail.size, 1, 0);\n\t\t\t\t\t\tphp_stream_seek(ImageInfo->infile, ImageInfo->Thumbnail.offset, SEEK_SET);\n\t\t\t\t\t\tfgot = php_stream_read(ImageInfo->infile, ImageInfo->Thumbnail.data, ImageInfo->Thumbnail.size);\n\t\t\t\t\t\tif (fgot < ImageInfo->Thumbnail.size) {\n\t\t\t\t\t\t\tEXIF_ERRLOG_THUMBEOF(ImageInfo)\n\t\t\t\t\t\t}\n\t\t\t\t\t\texif_thumbnail_build(ImageInfo TSRMLS_CC);\n\t\t\t\t\t}\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read next IFD (THUMBNAIL) done\");\n#endif\n\t\t\t\t}\n\t\t\t\treturn TRUE;\n\t\t\t} else {\n\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than size of IFD(x%04X)\", ImageInfo->FileSize, dir_offset+ImageInfo->file.list[sn].size);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than size of IFD dir(x%04X)\", ImageInfo->FileSize, dir_offset+dir_size);\n\t\t\treturn FALSE;\n\t\t}\n\t} else {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than start of IFD dir(x%04X)\", ImageInfo->FileSize, dir_offset+2);\n\t\treturn FALSE;\n\t}\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\t\t\t\texif_thumbnail_build(ImageInfo TSRMLS_CC);\n",
        "src_path": "6dbb1ee46b5f4725cc6519abf91e512a2a10dfed___exif.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/6dbb1ee46b5f4725cc6519abf91e512a2a10dfed",
        "commit_msg": "Fixed bug #72627: Memory Leakage In exif_process_IFD_in_TIFF",
        "test_func_diff": [
            {
                "fn": "ext/exif/tests/bug72627.phpt",
                "patch": "@@ -0,0 +1,71 @@\n+--TEST--\n+Bug #72627 (Memory Leakage In exif_process_IFD_in_TIFF)\n+--SKIPIF--\n+<?php if (!extension_loaded('exif')) print 'skip exif extension not available';?>\n+--FILE--\n+<?php\n+\t$exif = exif_read_data(__DIR__ . '/bug72627.tiff',0,0,true);\n+\tvar_dump($exif);\n+?>\n+--EXPECTF--\n+Warning: exif_read_data(%s): Thumbnail goes IFD boundary or end of file reached in %sbug72627.php on line %d\n+\n+Warning: exif_read_data(%s): Error in TIFF: filesize(x04E2) less than start of IFD dir(x829A0004) in %sbug72627.php on line %d\n+\n+Warning: exif_read_data(%s): Thumbnail goes IFD boundary or end of file reached in %sbug72627.php on line %d\n+array(11) {\n+  [\"FileName\"]=>\n+  string(13) \"bug72627.tiff\"\n+  [\"FileDateTime\"]=>\n+  int(%d)\n+  [\"FileSize\"]=>\n+  int(1250)\n+  [\"FileType\"]=>\n+  int(7)\n+  [\"MimeType\"]=>\n+  string(10) \"image/tiff\"\n+  [\"SectionsFound\"]=>\n+  string(30) \"ANY_TAG, IFD0, THUMBNAIL, EXIF\"\n+  [\"COMPUTED\"]=>\n+  array(10) {\n+    [\"html\"]=>\n+    string(24) \"width=\"128\" height=\"132\"\"\n+    [\"Height\"]=>\n+    int(132)\n+    [\"Width\"]=>\n+    int(128)\n+    [\"IsColor\"]=>\n+    int(0)\n+    [\"ByteOrderMotorola\"]=>\n+    int(0)\n+    [\"ApertureFNumber\"]=>\n+    string(5) \"f/1.0\"\n+    [\"Thumbnail.FileType\"]=>\n+    int(2)\n+    [\"Thumbnail.MimeType\"]=>\n+    string(10) \"image/jpeg\"\n+    [\"Thumbnail.Height\"]=>\n+    int(132)\n+    [\"Thumbnail.Width\"]=>\n+    int(128)\n+  }\n+  [\"XResolution\"]=>\n+  string(21) \"1414812756/1414812756\"\n+  [\"THUMBNAIL\"]=>\n+  array(5) {\n+    [\"ImageWidth\"]=>\n+    int(128)\n+    [\"ImageLength\"]=>\n+    int(132)\n+    [\"JPEGInterchangeFormat\"]=>\n+    int(1280)\n+    [\"JPEGInterchangeFormatLength\"]=>\n+    int(100)\n+    [\"THUMBNAIL\"]=>\n+    NULL\n+  }\n+  [\"ExposureTime\"]=>\n+  string(21) \"1414812756/1414812756\"\n+  [\"FNumber\"]=>\n+  string(21) \"1414812756/1414812756\"\n+}"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.26-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_6dbb1ee46b5f4725cc6519abf91e512a2a10dfed More .INIs : CWD : /out/php___php-src/git_repo_dir_6dbb1ee46b5f4725cc6519abf91e512a2a10dfed Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/exif/tests/bug72627.phpt]\rFAIL Bug #72627 (Memory Leakage In exif_process_IFD_in_TIFF) [ext/exif/tests/bug72627.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 1 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72627 (Memory Leakage In exif_process_IFD_in_TIFF) [ext/exif/tests/bug72627.phpt] =====================================================================\n"
    },
    "b88393f08a558eec14964a55d3c680fe67407712___wddx.c": {
        "prefix": "static int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n",
        "suffix": "\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;\n}\n",
        "start": 227,
        "end": 244,
        "buggy": "static int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n",
        "src_path": "b88393f08a558eec14964a55d3c680fe67407712___wddx.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/b88393f08a558eec14964a55d3c680fe67407712",
        "commit_msg": "Fix bug #72860: wddx_deserialize use-after-free",
        "test_func_diff": [
            {
                "fn": "ext/wddx/tests/bug72860.phpt",
                "patch": "@@ -0,0 +1,27 @@\n+--TEST--\n+Bug #72860: wddx_deserialize use-after-free\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+\n+$xml=<<<XML\n+<?xml version='1.0'?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+       <recordset fieldNames='F'>\n+               <field name='F'>\n+       </recordset>\n+</wddxPacket>\n+XML;\n+\n+var_dump(wddx_deserialize($xml));\n+?>\n+DONE\n+--EXPECT--\n+NULL\n+DONE\n\\ No newline at end of file"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.27-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_b88393f08a558eec14964a55d3c680fe67407712 More .INIs : CWD : /out/php___php-src/git_repo_dir_b88393f08a558eec14964a55d3c680fe67407712 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/wddx/tests/bug72860.phpt]\r \r===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 0 ( 0.0%) ( 0.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 1 (100.0%) (100.0%) --------------------------------------------------------------------- Time taken : 0 seconds =====================================================================\n"
    },
    "863d37ea66d5c960db08d6f4a2cbd2518f0f80d1___gd.c": {
        "prefix": "void gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit = -1, rightLimit;\n\tint i, restoreAlphaBlending = 0;\n\n",
        "suffix": "\t\t/* Refuse to fill to a non-solid border */\n\t\treturn;\n\t}\n\n\tif (!im->trueColor) {\n\t\tif ((color > (im->colorsTotal - 1)) || (border > (im->colorsTotal - 1)) || (color < 0)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\trestoreAlphaBlending = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\n\tfor (i = x; i >= 0; i--) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == -1) {\n\t\tim->alphaBlendingFlag = restoreAlphaBlending;\n\t\treturn;\n\t}\n\t/* Seek right */\n\trightLimit = x;\n\tfor (i = (x + 1); i < im->sx; i++) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t/* Look at lines above and below and start paints */\n\t/* Above */\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Below */\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y + 1);\n\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBlending;\n}\n",
        "start": 1743,
        "end": 1829,
        "buggy": "void gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit = -1, rightLimit;\n\tint i, restoreAlphaBlending = 0;\n\n\tif (border < 0) {\n\t\t/* Refuse to fill to a non-solid border */\n\t\treturn;\n\t}\n\n\tif (!im->trueColor) {\n\t\tif ((color > (im->colorsTotal - 1)) || (border > (im->colorsTotal - 1)) || (color < 0)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\trestoreAlphaBlending = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\n\tfor (i = x; i >= 0; i--) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == -1) {\n\t\tim->alphaBlendingFlag = restoreAlphaBlending;\n\t\treturn;\n\t}\n\t/* Seek right */\n\trightLimit = x;\n\tfor (i = (x + 1); i < im->sx; i++) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t/* Look at lines above and below and start paints */\n\t/* Above */\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Below */\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y + 1);\n\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBlending;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\tif (border < 0) {\n",
        "src_path": "863d37ea66d5c960db08d6f4a2cbd2518f0f80d1___gd.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/863d37ea66d5c960db08d6f4a2cbd2518f0f80d1",
        "commit_msg": "Fix #72696: imagefilltoborder stackoverflow on truecolor images\n\nWe must not allow negative color values be passed to\ngdImageFillToBorder(), because that can lead to infinite recursion\nsince the recursion termination condition will not necessarily be met.",
        "test_func_diff": [
            {
                "fn": "ext/gd/tests/bug72696.phpt",
                "patch": "@@ -0,0 +1,14 @@\n+--TEST--\n+Bug #72696 (imagefilltoborder stackoverflow on truecolor images)\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('gd')) die('skip gd extension not available');\n+?>\n+--FILE--\n+<?php\n+$im = imagecreatetruecolor(10, 10);\n+imagefilltoborder($im, 0, 0, 1, -2);\n+?>\n+===DONE===\n+--EXPECT--\n+===DONE==="
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.28-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_863d37ea66d5c960db08d6f4a2cbd2518f0f80d1 More .INIs : CWD : /out/php___php-src/git_repo_dir_863d37ea66d5c960db08d6f4a2cbd2518f0f80d1 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/gd/tests/bug72696.phpt]\rFAIL Bug #72696 (imagefilltoborder stackoverflow on truecolor images) [ext/gd/tests/bug72696.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72696 (imagefilltoborder stackoverflow on truecolor images) [ext/gd/tests/bug72696.phpt] =====================================================================\n"
    },
    "1cda0d7c2ffb62d8331c64e703131d9cabdc03ea___exif.c": {
        "prefix": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n",
        "suffix": "\t\t\t}\n\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\n\t\t/* Not sure if this is correct (never seen float used in Exif format) */\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}\n",
        "start": 1281,
        "end": 1325,
        "buggy": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n\t\t\t}\n\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\n\t\t/* Not sure if this is correct (never seen float used in Exif format) */\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n",
        "src_path": "1cda0d7c2ffb62d8331c64e703131d9cabdc03ea___exif.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/1cda0d7c2ffb62d8331c64e703131d9cabdc03ea",
        "commit_msg": "Fix bug #73737 FPE when parsing a tag format",
        "test_func_diff": [
            {
                "fn": "ext/exif/tests/bug73737.phpt",
                "patch": "@@ -0,0 +1,12 @@\n+--TEST--\n+Bug #73737 (Crash when parsing a tag format)\n+--SKIPIF--\n+<?php if (!extension_loaded('exif')) print 'skip exif extension not available';?>\n+--FILE--\n+<?php\n+\t$exif = exif_thumbnail(__DIR__ . '/bug73737.tiff');\n+\tvar_dump($exif);\n+?>\n+--EXPECTF--\n+Warning: exif_thumbnail(bug73737.tiff): Error in TIFF: filesize(x0030) less than start of IFD dir(x10102) in %s line %d\n+bool(false)"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.30-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_1cda0d7c2ffb62d8331c64e703131d9cabdc03ea More .INIs : CWD : /out/php___php-src/git_repo_dir_1cda0d7c2ffb62d8331c64e703131d9cabdc03ea Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/exif/tests/bug73737.phpt]\rFAIL Bug #73737 (Crash when parsing a tag format) [ext/exif/tests/bug73737.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #73737 (Crash when parsing a tag format) [ext/exif/tests/bug73737.phpt] =====================================================================\n"
    },
    "ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1___njs_module.c": {
        "prefix": "static njs_int_t\nnjs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n\n    trail = 0;\n    length = info->name.length;\n\n    if (dir != NULL) {\n",
        "suffix": "\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n\n        trail = (dir->start[dir->length - 1] != '/');\n\n        if (trail) {\n            length++;\n        }\n    }\n\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n\n    p = &src[0];\n\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n\n\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n\n    return NJS_OK;\n}\n",
        "start": 109,
        "end": 166,
        "buggy": "static njs_int_t\nnjs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n\n    trail = 0;\n    length = info->name.length;\n\n    if (dir != NULL) {\n        length = dir->length;\n\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n\n        trail = (dir->start[dir->length - 1] != '/');\n\n        if (trail) {\n            length++;\n        }\n    }\n\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n\n    p = &src[0];\n\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n\n\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n\n    return NJS_OK;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        length = dir->length;\n",
        "src_path": "ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1___njs_module.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1",
        "commit_msg": "Fixed typo while calculating module path length.\n\nThe issue was introduced in 77c398f26d7e (not released yet).",
        "test_func_diff": [
            {
                "fn": "test/js/import_very_long_path.t.js",
                "patch": "@@ -0,0 +1,9 @@\n+/*---\n+: []\n+paths: [test/js/module/]\n+negative:\n+  phase: runtime\n+---*/\n+\n+import name from 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';\n+ "
            }
        ],
        "error_msg": "=================================================================\n==34629==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7f1114001021 at pc 0x555b8d071436 bp 0x7ffcad5d4af0 sp 0x7ffcad5d42b8\nWRITE of size 4097 at 0x7f1114001021 thread T0\n    #0 0x555b8d071435 in __asan_memcpy /src/llvm-project/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:22:3\n    #1 0x555b8d135ab1 in njs_module_path /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_module.c:148:18\n    #2 0x555b8d135ab1 in njs_module_lookup /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_module.c:83:11\n    #3 0x555b8d135ab1 in njs_default_module_loader /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_module.c:377:11\n    #4 0x555b8d135119 in njs_parser_module /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_module.c:56:14\n    #5 0x555b8d172465 in njs_parser_import /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_parser.c:7793:24\n    #6 0x555b8d146bd1 in njs_parser /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_parser.c:598:23\n    #7 0x555b8d0c10fd in njs_vm_compile /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_vm.c:159:11\n    #8 0x555b8d0af293 in njs_process_script /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_shell.c:886:11\n    #9 0x555b8d0ae6a5 in njs_process_file /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_shell.c:619:11\n    #10 0x555b8d0ae6a5 in main /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_shell.c:303:15\n    #11 0x7f111602b082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #12 0x555b8cfd9abd in _start (/out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/build_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/njs+0x55abd)\n\nAddress 0x7f1114001021 is located in stack of th"
    },
    "8b39afdad9a0761e0a5d4af1a762bd9a6daef572___njs_array.c": {
        "prefix": "static njs_int_t\nnjs_array_prototype_sort(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t                i, und, len, nlen, length;\n    njs_int_t              ret, fast_path;\n    njs_array_t            *array;\n    njs_value_t            *this, *comparefn, *start, *strings;\n    njs_array_sort_ctx_t   ctx;\n    njs_array_sort_slot_t  *p, *end, *slots, *nslots;\n\n    comparefn = njs_arg(args, nargs, 1);\n\n    if (njs_is_defined(comparefn)) {\n        if (njs_slow_path(!njs_is_function(comparefn))) {\n            njs_type_error(vm, \"comparefn must be callable or undefined\");\n            return NJS_ERROR;\n        }\n\n        ctx.function = njs_function(comparefn);\n\n    } else {\n        ctx.function = NULL;\n    }\n\n    this = njs_argument(args, 0);\n\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_value_length(vm, this, &length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    if (njs_slow_path(length < 2)) {\n        vm->retval = *this;\n        return NJS_OK;\n    }\n\n    slots = NULL;\n    ctx.vm = vm;\n    ctx.strings.separate = 0;\n    ctx.strings.pointer = 0;\n    ctx.exception = 0;\n\n    fast_path = njs_is_fast_array(this);\n\n    if (njs_fast_path(fast_path)) {\n        array = njs_array(this);\n        start = array->start;\n\n        slots = njs_mp_alloc(vm->mem_pool,\n                             sizeof(njs_array_sort_slot_t) * length);\n        if (njs_slow_path(slots == NULL)) {\n                return NJS_ERROR;\n        }\n\n        und = 0;\n        p = slots;\n\n        for (i = 0; i < length; i++) {\n            if (njs_slow_path(!njs_is_valid(&start[i]))) {\n                fast_path = 0;\n                njs_mp_free(vm->mem_pool, slots);\n                slots = NULL;\n                goto slow_path;\n            }\n\n            if (njs_slow_path(njs_is_undefined(&start[i]))) {\n                und++;\n                continue;\n            }\n\n            p->value = start[i];\n            p->pos = i;\n            p->str = NULL;\n            p++;\n        }\n\n        len = p - slots;\n\n    } else {\n\nslow_path:\n\n        und = 0;\n        p = NULL;\n        end = NULL;\n\n        for (i = 0; i < length; i++) {\n            if (p >= end) {\n                nlen = njs_min(njs_max((p - slots) * 2, 8), length);\n                nslots = njs_mp_alloc(vm->mem_pool,\n                                      sizeof(njs_array_sort_slot_t) * nlen);\n                if (njs_slow_path(nslots == NULL)) {\n                    njs_memory_error(vm);\n                    return NJS_ERROR;\n                }\n\n                if (slots != NULL) {\n                    p = (void *) njs_cpymem(nslots, slots,\n                                  sizeof(njs_array_sort_slot_t) * (p - slots));\n                    njs_mp_free(vm->mem_pool, slots);\n\n                } else {\n                    p = nslots;\n                }\n\n                slots = nslots;\n                end = slots + nlen;\n            }\n\n            ret = njs_value_property_i64(vm, this, i, &p->value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                ret = NJS_ERROR;\n                goto exception;\n            }\n\n            if (ret == NJS_DECLINED) {\n                continue;\n            }\n\n            if (njs_is_undefined(&p->value)) {\n                und++;\n                continue;\n            }\n\n            p->pos = i;\n            p->str = NULL;\n            p++;\n        }\n\n        len = p - slots;\n    }\n\n    strings = njs_arr_init(vm->mem_pool, &ctx.strings, NULL, len + 1,\n                           sizeof(njs_value_t));\n    if (njs_slow_path(strings == NULL)) {\n        ret = NJS_ERROR;\n        goto exception;\n    }\n\n    njs_qsort(slots, len, sizeof(njs_array_sort_slot_t), njs_array_compare,\n              &ctx);\n\n    if (ctx.exception) {\n        ret = NJS_ERROR;\n        goto exception;\n    }\n\n",
        "suffix": "        array = njs_array(this);\n        start = array->start;\n\n        for (i = 0; i < len; i++) {\n            start[i] = slots[i].value;\n        }\n\n        for (i = len; und-- > 0; i++) {\n            start[i] = njs_value_undefined;\n        }\n\n    } else {\n        for (i = 0; i < len; i++) {\n            if (slots[i].pos != i) {\n                ret = njs_value_property_i64_set(vm, this, i, &slots[i].value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto exception;\n                }\n            }\n        }\n\n        for (i = len; und-- > 0; i++) {\n            ret = njs_value_property_i64_set(vm, this, i,\n                                          njs_value_arg(&njs_value_undefined));\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                goto exception;\n            }\n        }\n\n        for (; i < length; i++) {\n            ret = njs_value_property_i64_delete(vm, this, i, NULL);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                goto exception;\n            }\n        }\n    }\n\n    vm->retval = *this;\n\n    ret = NJS_OK;\n\nexception:\n\n    if (slots != NULL) {\n        njs_mp_free(vm->mem_pool, slots);\n    }\n\n    njs_arr_destroy(&ctx.strings);\n\n    return ret;\n}\n",
        "start": 2546,
        "end": 2750,
        "buggy": "static njs_int_t\nnjs_array_prototype_sort(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t                i, und, len, nlen, length;\n    njs_int_t              ret, fast_path;\n    njs_array_t            *array;\n    njs_value_t            *this, *comparefn, *start, *strings;\n    njs_array_sort_ctx_t   ctx;\n    njs_array_sort_slot_t  *p, *end, *slots, *nslots;\n\n    comparefn = njs_arg(args, nargs, 1);\n\n    if (njs_is_defined(comparefn)) {\n        if (njs_slow_path(!njs_is_function(comparefn))) {\n            njs_type_error(vm, \"comparefn must be callable or undefined\");\n            return NJS_ERROR;\n        }\n\n        ctx.function = njs_function(comparefn);\n\n    } else {\n        ctx.function = NULL;\n    }\n\n    this = njs_argument(args, 0);\n\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_value_length(vm, this, &length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    if (njs_slow_path(length < 2)) {\n        vm->retval = *this;\n        return NJS_OK;\n    }\n\n    slots = NULL;\n    ctx.vm = vm;\n    ctx.strings.separate = 0;\n    ctx.strings.pointer = 0;\n    ctx.exception = 0;\n\n    fast_path = njs_is_fast_array(this);\n\n    if (njs_fast_path(fast_path)) {\n        array = njs_array(this);\n        start = array->start;\n\n        slots = njs_mp_alloc(vm->mem_pool,\n                             sizeof(njs_array_sort_slot_t) * length);\n        if (njs_slow_path(slots == NULL)) {\n                return NJS_ERROR;\n        }\n\n        und = 0;\n        p = slots;\n\n        for (i = 0; i < length; i++) {\n            if (njs_slow_path(!njs_is_valid(&start[i]))) {\n                fast_path = 0;\n                njs_mp_free(vm->mem_pool, slots);\n                slots = NULL;\n                goto slow_path;\n            }\n\n            if (njs_slow_path(njs_is_undefined(&start[i]))) {\n                und++;\n                continue;\n            }\n\n            p->value = start[i];\n            p->pos = i;\n            p->str = NULL;\n            p++;\n        }\n\n        len = p - slots;\n\n    } else {\n\nslow_path:\n\n        und = 0;\n        p = NULL;\n        end = NULL;\n\n        for (i = 0; i < length; i++) {\n            if (p >= end) {\n                nlen = njs_min(njs_max((p - slots) * 2, 8), length);\n                nslots = njs_mp_alloc(vm->mem_pool,\n                                      sizeof(njs_array_sort_slot_t) * nlen);\n                if (njs_slow_path(nslots == NULL)) {\n                    njs_memory_error(vm);\n                    return NJS_ERROR;\n                }\n\n                if (slots != NULL) {\n                    p = (void *) njs_cpymem(nslots, slots,\n                                  sizeof(njs_array_sort_slot_t) * (p - slots));\n                    njs_mp_free(vm->mem_pool, slots);\n\n                } else {\n                    p = nslots;\n                }\n\n                slots = nslots;\n                end = slots + nlen;\n            }\n\n            ret = njs_value_property_i64(vm, this, i, &p->value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                ret = NJS_ERROR;\n                goto exception;\n            }\n\n            if (ret == NJS_DECLINED) {\n                continue;\n            }\n\n            if (njs_is_undefined(&p->value)) {\n                und++;\n                continue;\n            }\n\n            p->pos = i;\n            p->str = NULL;\n            p++;\n        }\n\n        len = p - slots;\n    }\n\n    strings = njs_arr_init(vm->mem_pool, &ctx.strings, NULL, len + 1,\n                           sizeof(njs_value_t));\n    if (njs_slow_path(strings == NULL)) {\n        ret = NJS_ERROR;\n        goto exception;\n    }\n\n    njs_qsort(slots, len, sizeof(njs_array_sort_slot_t), njs_array_compare,\n              &ctx);\n\n    if (ctx.exception) {\n        ret = NJS_ERROR;\n        goto exception;\n    }\n\n    if (njs_fast_path(fast_path)) {\n        array = njs_array(this);\n        start = array->start;\n\n        for (i = 0; i < len; i++) {\n            start[i] = slots[i].value;\n        }\n\n        for (i = len; und-- > 0; i++) {\n            start[i] = njs_value_undefined;\n        }\n\n    } else {\n        for (i = 0; i < len; i++) {\n            if (slots[i].pos != i) {\n                ret = njs_value_property_i64_set(vm, this, i, &slots[i].value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto exception;\n                }\n            }\n        }\n\n        for (i = len; und-- > 0; i++) {\n            ret = njs_value_property_i64_set(vm, this, i,\n                                          njs_value_arg(&njs_value_undefined));\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                goto exception;\n            }\n        }\n\n        for (; i < length; i++) {\n            ret = njs_value_property_i64_delete(vm, this, i, NULL);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                goto exception;\n            }\n        }\n    }\n\n    vm->retval = *this;\n\n    ret = NJS_OK;\n\nexception:\n\n    if (slots != NULL) {\n        njs_mp_free(vm->mem_pool, slots);\n    }\n\n    njs_arr_destroy(&ctx.strings);\n\n    return ret;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (njs_fast_path(fast_path)) {\n",
        "src_path": "8b39afdad9a0761e0a5d4af1a762bd9a6daef572___njs_array.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/8b39afdad9a0761e0a5d4af1a762bd9a6daef572",
        "commit_msg": "Fixed Array.prototype.sort() when arr size is changed in a comparator.\n\nThis fixed #468 issue on Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -6989,6 +6989,9 @@ static njs_unit_test_t  njs_test[] =\n     { njs_str(\"[1,2].sort(1)\"),\n       njs_str(\"TypeError: comparefn must be callable or undefined\") },\n \n+    { njs_str(\"var a = [1,2]; a.sort(() => {a.length = 65535}); a.length\"),\n+      njs_str(\"65535\") },\n+\n     /*\n       Array.prototype.keys()\n       Array.prototype.values()"
            }
        ],
        "error_msg": "AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==37996==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7f3998c1eaf3 bp 0x7ffed53854f0 sp 0x7ffed5384ca8 T0)\n==37996==The signal is caused by a WRITE memory access.\n==37996==Hint: address points to the zero page.\n    #0 0x7f3998c1eaf3 in memcpy /build/glibc-wuryBv/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:144\n    #1 0x55da5fde01a3 in __asan_memcpy /src/llvm-project/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:22:3\n    #2 0x55da5fe7e39f in njs_array_prototype_sort /out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/src/njs_array.c:2704:33\n    #3 0x55da5fe92031 in njs_function_native_call /out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/src/njs_function.c:739:11\n    #4 0x55da5fe3f2cf in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/src/njs_vmcode.c:810:23\n    #5 0x55da5fe37caa in njs_vm_start /out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/src/njs_vm.c:553:11\n    #6 0x55da5fe1efb0 in njs_process_test /out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/src/test/njs_unit_test.c:21966:15\n    #7 0x55da5fe1efb0 in njs_unit_test /out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/src/test/njs_unit_test.c:22118:23\n    #8 0x55da5fe1e261 in main /out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/src/test/njs_unit_test.c:23608:15\n    #9 0x7f3998b87082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #10 0x55da5fd48acd in _start (/out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/build_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/njs_unit_test+0x11eacd)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV /build/glibc-wuryBv/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:144 in memcpy\n=="
    },
    "d72ccf06c98259d7261e0f3ac4fd8717778782c1___extracts.cpp": {
        "prefix": "void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) {\n",
        "suffix": "  Trackage track = {0};\n\n  AtomicInfo *mvhdAtom = APar_FindAtom(\"moov.mvhd\", false, VERSIONED_ATOM, 0);\n  if (mvhdAtom != NULL) {\n    APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom);\n    fprintf(stdout,\n            \"Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate \"\n            \"(*=approximate)\\n\",\n            movie_info.seconds,\n            secsTOtime(movie_info.seconds),\n            movie_info.simple_bitrate_calc);\n    if (optional_output & SHOW_DATE_INFO) {\n      fprintf(stdout,\n              \"  Presentation Creation Date (UTC):     %s\\n\",\n              APar_extract_UTC(movie_info.creation_time));\n      fprintf(stdout,\n              \"  Presentation Modification Date (UTC): %s\\n\",\n              APar_extract_UTC(movie_info.modified_time));\n    }\n  }\n\n  AtomicInfo *iodsAtom = APar_FindAtom(\"moov.iods\", false, VERSIONED_ATOM, 0);\n  if (iodsAtom != NULL) {\n    movie_info.contains_iods = true;\n    APar_Extract_iods_Info(isofile, iodsAtom);\n  }\n\n  if (optional_output & SHOW_TRACK_INFO) {\n    APar_TrackLevelInfo(&track,\n                        NULL); // With track_num set to 0, it will return the\n                               // total trak atom into total_tracks here.\n\n    fprintf(\n        stdout, \"Low-level details. Total tracks: %u\\n\", track.total_tracks);\n    fprintf(stdout,\n            \"Trk  Type  Handler                    Kind  Lang  Bytes\\n\");\n\n    if (track.total_tracks > 0) {\n      while (track.total_tracks > track.track_num) {\n        track.track_num += 1;\n        TrackInfo track_info = {0};\n\n        // tracknum, handler type, handler name\n        APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info);\n        uint16_t more_whitespace =\n            purge_extraneous_characters(track_info.track_hdlr_name);\n\n        if (strlen(track_info.track_hdlr_name) == 0) {\n          memcpy(track_info.track_hdlr_name, \"[none listed]\", 13);\n        }\n        fprintf(stdout,\n                \"%u    %s  %s\",\n                track.track_num,\n                uint32tochar4(track_info.track_type, uint32_buffer),\n                track_info.track_hdlr_name);\n\n        uint16_t handler_len = strlen(track_info.track_hdlr_name);\n        if (handler_len < 25 + more_whitespace) {\n          for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) {\n            fprintf(stdout, \" \");\n          }\n        }\n\n        // codec, language\n        fprintf(stdout,\n                \"  %s  %s   %\" PRIu64,\n                uint32tochar4(track_info.track_codec, uint32_buffer),\n                track_info.unpacked_lang,\n                track_info.sample_aggregate);\n\n        if (track_info.encoder_name[0] != 0 && track_info.contains_esds) {\n          purge_extraneous_characters(track_info.encoder_name);\n          fprintf(stdout, \"   Encoder: %s\", track_info.encoder_name);\n        }\n        if (track_info.type_of_track & DRM_PROTECTED_TRACK) {\n          fprintf(stdout,\n                  \" (protected %s)\",\n                  uint32tochar4(track_info.protected_codec, uint32_buffer));\n        }\n\n        fprintf(stdout, \"\\n\");\n        /*---------------------------------*/\n\n        if (track_info.type_of_track & VIDEO_TRACK ||\n            track_info.type_of_track & AUDIO_TRACK) {\n          APar_Print_TrackDetails(&track_info);\n        }\n\n        if (optional_output & SHOW_DATE_INFO) {\n          fprintf(stdout,\n                  \"       Creation Date (UTC):     %s\\n\",\n                  APar_extract_UTC(track_info.creation_time));\n          fprintf(stdout,\n                  \"       Modification Date (UTC): %s\\n\",\n                  APar_extract_UTC(track_info.modified_time));\n        }\n      }\n    }\n  }\n}\n",
        "start": 1590,
        "end": 1691,
        "buggy": "void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) {\n  char uint32_buffer[5];\n  Trackage track = {0};\n\n  AtomicInfo *mvhdAtom = APar_FindAtom(\"moov.mvhd\", false, VERSIONED_ATOM, 0);\n  if (mvhdAtom != NULL) {\n    APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom);\n    fprintf(stdout,\n            \"Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate \"\n            \"(*=approximate)\\n\",\n            movie_info.seconds,\n            secsTOtime(movie_info.seconds),\n            movie_info.simple_bitrate_calc);\n    if (optional_output & SHOW_DATE_INFO) {\n      fprintf(stdout,\n              \"  Presentation Creation Date (UTC):     %s\\n\",\n              APar_extract_UTC(movie_info.creation_time));\n      fprintf(stdout,\n              \"  Presentation Modification Date (UTC): %s\\n\",\n              APar_extract_UTC(movie_info.modified_time));\n    }\n  }\n\n  AtomicInfo *iodsAtom = APar_FindAtom(\"moov.iods\", false, VERSIONED_ATOM, 0);\n  if (iodsAtom != NULL) {\n    movie_info.contains_iods = true;\n    APar_Extract_iods_Info(isofile, iodsAtom);\n  }\n\n  if (optional_output & SHOW_TRACK_INFO) {\n    APar_TrackLevelInfo(&track,\n                        NULL); // With track_num set to 0, it will return the\n                               // total trak atom into total_tracks here.\n\n    fprintf(\n        stdout, \"Low-level details. Total tracks: %u\\n\", track.total_tracks);\n    fprintf(stdout,\n            \"Trk  Type  Handler                    Kind  Lang  Bytes\\n\");\n\n    if (track.total_tracks > 0) {\n      while (track.total_tracks > track.track_num) {\n        track.track_num += 1;\n        TrackInfo track_info = {0};\n\n        // tracknum, handler type, handler name\n        APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info);\n        uint16_t more_whitespace =\n            purge_extraneous_characters(track_info.track_hdlr_name);\n\n        if (strlen(track_info.track_hdlr_name) == 0) {\n          memcpy(track_info.track_hdlr_name, \"[none listed]\", 13);\n        }\n        fprintf(stdout,\n                \"%u    %s  %s\",\n                track.track_num,\n                uint32tochar4(track_info.track_type, uint32_buffer),\n                track_info.track_hdlr_name);\n\n        uint16_t handler_len = strlen(track_info.track_hdlr_name);\n        if (handler_len < 25 + more_whitespace) {\n          for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) {\n            fprintf(stdout, \" \");\n          }\n        }\n\n        // codec, language\n        fprintf(stdout,\n                \"  %s  %s   %\" PRIu64,\n                uint32tochar4(track_info.track_codec, uint32_buffer),\n                track_info.unpacked_lang,\n                track_info.sample_aggregate);\n\n        if (track_info.encoder_name[0] != 0 && track_info.contains_esds) {\n          purge_extraneous_characters(track_info.encoder_name);\n          fprintf(stdout, \"   Encoder: %s\", track_info.encoder_name);\n        }\n        if (track_info.type_of_track & DRM_PROTECTED_TRACK) {\n          fprintf(stdout,\n                  \" (protected %s)\",\n                  uint32tochar4(track_info.protected_codec, uint32_buffer));\n        }\n\n        fprintf(stdout, \"\\n\");\n        /*---------------------------------*/\n\n        if (track_info.type_of_track & VIDEO_TRACK ||\n            track_info.type_of_track & AUDIO_TRACK) {\n          APar_Print_TrackDetails(&track_info);\n        }\n\n        if (optional_output & SHOW_DATE_INFO) {\n          fprintf(stdout,\n                  \"       Creation Date (UTC):     %s\\n\",\n                  APar_extract_UTC(track_info.creation_time));\n          fprintf(stdout,\n                  \"       Modification Date (UTC): %s\\n\",\n                  APar_extract_UTC(track_info.modified_time));\n        }\n      }\n    }\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  char uint32_buffer[5];\n",
        "src_path": "d72ccf06c98259d7261e0f3ac4fd8717778782c1___extracts.cpp",
        "uri": "https://api.github.com/repos/wez/atomicparsley/commits/d72ccf06c98259d7261e0f3ac4fd8717778782c1",
        "commit_msg": "Avoid stack overflow\n\nrefs: https://github.com/wez/atomicparsley/issues/32",
        "test_func_diff": [
            {
                "fn": "tests/test.sh",
                "patch": "@@ -0,0 +1,3 @@\n+#!/bin/bash\n+set -xe\n+./AtomicParsley ./tests/issue-32.mp4 -T 1 -t +"
            }
        ],
        "error_msg": "==36043==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7f637ec00225 at pc 0x55b16f893bc1 bp 0x7fff8a8c0340 sp 0x7fff8a8bfb10\nWRITE of size 8 at 0x7f637ec00225 thread T0\n    #0 0x55b16f893bc0 in __interceptor_fread /src/llvm-project/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors.inc:1091:16\n    #1 0x55b16f9a63ec in APar_read64(char*, _IO_FILE*, unsigned long) /out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/src/util.cpp:299:10\n    #2 0x55b16f952652 in APar_ExtractTrackDetails(char*, _IO_FILE*, Trackage*, TrackInfo*) /out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/src/extracts.cpp:1247:9\n    #3 0x55b16f954f00 in APar_ExtractDetails(_IO_FILE*, unsigned char) /out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/src/extracts.cpp:1635:9\n    #4 0x55b16f96e236 in real_main(int, char**) /out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/src/main.cpp\n    #5 0x7f6380f70082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: eebe5d5f4b608b8a53ec446b63981bba373ca0ca)\n    #6 0x55b16f87656d in _start (/out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/build_d72ccf06c98259d7261e0f3ac4fd8717778782c1/AtomicParsley+0x5f56d)\n\nAddress 0x7f637ec00225 is located in stack of thread T0 at offset 37 in frame\n    #0 0x55b16f954a9f in APar_ExtractDetails(_IO_FILE*, unsigned char) /out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/src/extracts.cpp:1590\n\n  This frame has 3 object(s):\n    [32, 37) 'uint32_buffer' (line 1591) <== Memory access at offset 37 overflows this variable\n    [64, 68) 'track' (line 1592)\n    [80, 416) 'track_info' (line 1632)\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /src/llvm-project/compiler-rt/lib/asan/../sanitizer_common/"
    },
    "71c2ab509a8628dbbad4bc7b3f98a64aa90d3297___jv.c": {
        "prefix": "static const char* jvp_literal_number_literal(jv n) {\n  assert(JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL));\n  decNumber *pdec = jvp_dec_number_ptr(n);\n  jvp_literal_number* plit = jvp_literal_number_ptr(n);\n\n  if (decNumberIsNaN(pdec)) {\n    return \"null\";\n  }\n\n  if (decNumberIsInfinite(pdec)) {\n    // We cannot preserve the literal data of numbers outside the limited\n    // range of exponent. Since `decNumberToString` returns \"Infinity\"\n    // (or \"-Infinity\"), and to reduce stack allocations as possible, we\n    // normalize infinities in the callers instead of printing the maximum\n    // (or minimum) double here.\n    return NULL;\n  }\n\n  if (plit->literal_data == NULL) {\n",
        "suffix": "    plit->literal_data = jv_mem_alloc(len);\n\n    // Preserve the actual precision as we have parsed it\n    // don't do decNumberTrim(pdec);\n\n    decNumberToString(pdec, plit->literal_data);\n  }\n\n  return plit->literal_data;\n}\n",
        "start": 619,
        "end": 648,
        "buggy": "static const char* jvp_literal_number_literal(jv n) {\n  assert(JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL));\n  decNumber *pdec = jvp_dec_number_ptr(n);\n  jvp_literal_number* plit = jvp_literal_number_ptr(n);\n\n  if (decNumberIsNaN(pdec)) {\n    return \"null\";\n  }\n\n  if (decNumberIsInfinite(pdec)) {\n    // We cannot preserve the literal data of numbers outside the limited\n    // range of exponent. Since `decNumberToString` returns \"Infinity\"\n    // (or \"-Infinity\"), and to reduce stack allocations as possible, we\n    // normalize infinities in the callers instead of printing the maximum\n    // (or minimum) double here.\n    return NULL;\n  }\n\n  if (plit->literal_data == NULL) {\n    int len = jvp_dec_number_ptr(n)->digits + 14;\n    plit->literal_data = jv_mem_alloc(len);\n\n    // Preserve the actual precision as we have parsed it\n    // don't do decNumberTrim(pdec);\n\n    decNumberToString(pdec, plit->literal_data);\n  }\n\n  return plit->literal_data;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    int len = jvp_dec_number_ptr(n)->digits + 14;\n",
        "src_path": "71c2ab509a8628dbbad4bc7b3f98a64aa90d3297___jv.c",
        "uri": "https://api.github.com/repos/jqlang/jq/commits/71c2ab509a8628dbbad4bc7b3f98a64aa90d3297",
        "commit_msg": "Merge pull request from GHSA-686w-5m7m-54vc\n\ndecNumberToString calls for a buffer that can hold a string of digits+14\ncharacters, not a buffer of size digits+14.\nWe need to allocate an extra byte for the NUL byte.\n\n-10E-1000010001, for example, will be stringified as -1.0E-1000010000\nand decNumberToString will currently write an extra NUL byte after the\nallocated buffer in the heap.\n\nOriginally reported by @SEU-SSL on GitHub.\n\nRef: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=64574\n\nFixes GHSA-686w-5m7m-54vc",
        "test_func_diff": [
            {
                "fn": "tests/shtest",
                "patch": "@@ -609,4 +609,9 @@ if ! r=$($JQ --args -rn 1 -- '$ARGS.positional[0]' bar) || [ \"$r\" != 1 ]; then\n     exit 1\n fi\n \n+# CVE-2023-50246: No heap overflow for '-10E-1000000001'\n+$VALGRIND $Q $JQ . <<\\NUM\n+-10E-1000000001\n+NUM\n+\n exit 0"
            }
        ],
        "error_msg": "+ . ./setup\n+ [ -n  ]\n+ set -eu\n+ dirname ./xtest.sh\n+ cd .\n+ pwd\n+ JQTESTDIR=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests\n+ JQBASEDIR=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/..\n+ JQ=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/../jq\n+ [ -z  ]\n+ which valgrind\n+ VALGRIND=valgrind --error-exitcode=1 --leak-check=full                        --suppressions=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/onig.supp                        --suppressions=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/local.supp\n+ VG_EXIT0=--error-exitcode=0\n+ Q=-q\n+ mods=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/modules\n+ clean=true\n+ d=\n+ trap clean EXIT\n+ mktemp -d -t jqXXXXXX\n+ d=/tmp/jq0tafW2\n+ [ -z /tmp/jq0tafW2 ]\n+ msys=false\n+ mingw=false\n+ uname -s\n+ JQ_NO_B=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/../jq\n+ JQ=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/../jq -b\n+ valgrind --error-exitcode=1 --leak-check=full --suppressions=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/onig.supp --suppressions=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/local.supp -q /out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/../jq -b .\n==49532== Invalid write of size 1\n==49532==    at 0x130E25: decToString (in /out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/jq)\n==49532==    by 0x1306DA: decNumberToString (in /out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/jq)\n==49532==    by 0x11BDCA: jv_number_get_literal (in /out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/jq)\n==49532==    by 0x12C8FD: jv_dump_term.30 (in /out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/jq)\n==49532==    by 0x11473F: process (in /out/jqlang___jq/git_"
    },
    "be749d7efa7c9021da746e685bd6dec79f9dd99b___cJSON.c": {
        "prefix": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n    current_element = object->child;\n    if (case_sensitive)\n    {\n",
        "suffix": "        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n\n    return current_element;\n}\n",
        "start": 1772,
        "end": 1798,
        "buggy": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n    current_element = object->child;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n\n    return current_element;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n",
        "src_path": "be749d7efa7c9021da746e685bd6dec79f9dd99b___cJSON.c",
        "uri": "https://api.github.com/repos/DaveGamble/cJSON/commits/be749d7efa7c9021da746e685bd6dec79f9dd99b",
        "commit_msg": "Fix crash of cJSON_GetObjectItemCaseSensitive when calling it on arrays",
        "test_func_diff": [
            {
                "fn": "tests/misc_tests.c",
                "patch": "@@ -127,6 +127,28 @@ static void cjson_get_object_item_case_sensitive_should_get_object_items(void)\n     cJSON_Delete(item);\n }\n \n+static void cjson_get_object_item_should_not_crash_with_array(void) {\n+    cJSON *array = NULL;\n+    cJSON *found = NULL;\n+    array = cJSON_Parse(\"[1]\");\n+\n+    found = cJSON_GetObjectItem(array, \"name\");\n+    TEST_ASSERT_NULL(found);\n+\n+    cJSON_Delete(array);\n+}\n+\n+static void cjson_get_object_item_case_sensitive_should_not_crash_with_array(void) {\n+    cJSON *array = NULL;\n+    cJSON *found = NULL;\n+    array = cJSON_Parse(\"[1]\");\n+\n+    found = cJSON_GetObjectItemCaseSensitive(array, \"name\");\n+    TEST_ASSERT_NULL(found);\n+\n+    cJSON_Delete(array);\n+}\n+\n static void typecheck_functions_should_check_type(void)\n {\n     cJSON invalid[1];\n@@ -535,6 +557,8 @@ int CJSON_CDECL main(void)\n     RUN_TEST(cjson_array_foreach_should_not_dereference_null_pointer);\n     RUN_TEST(cjson_get_object_item_should_get_object_items);\n     RUN_TEST(cjson_get_object_item_case_sensitive_should_get_object_items);\n+    RUN_TEST(cjson_get_object_item_should_not_crash_with_array);\n+    RUN_TEST(cjson_get_object_item_case_sensitive_should_not_crash_with_array);\n     RUN_TEST(typecheck_functions_should_check_type);\n     RUN_TEST(cjson_should_not_parse_to_deeply_nested_jsons);\n     RUN_TEST(cjson_set_number_value_should_set_numbers);"
            }
        ],
        "error_msg": "/out/DaveGamble___cJSON/git_repo_dir_be749d7efa7c9021da746e685bd6dec79f9dd99b/tests/../cJSON.c:1784:59: runtime error: null pointer passed as argument 2, which is declared to never be null\n/usr/include/string.h:138:33: note: nonnull attribute specified here\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /out/DaveGamble___cJSON/git_repo_dir_be749d7efa7c9021da746e685bd6dec79f9dd99b/tests/../cJSON.c:1784:59 in \n"
    },
    "4a342f01e5439b9bb901aff1c6c23c536baeeb3f___object.c": {
        "prefix": "int yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n\n  int i;\n  int count;\n\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n\n  array = object_as_array(object);\n\n  if (array->items == NULL)\n  {\n",
        "suffix": "\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n\n    array->items->count = count;\n  }\n\n  item->parent = object;\n  array->items->objects[index] = item;\n\n  return ERROR_SUCCESS;\n}\n",
        "start": 711,
        "end": 760,
        "buggy": "int yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n\n  int i;\n  int count;\n\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n\n  array = object_as_array(object);\n\n  if (array->items == NULL)\n  {\n    count = yr_max(64, (index + 1) * 2);\n\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n\n    array->items->count = count;\n  }\n\n  item->parent = object;\n  array->items->objects[index] = item;\n\n  return ERROR_SUCCESS;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    count = yr_max(64, (index + 1) * 2);\n",
        "src_path": "4a342f01e5439b9bb901aff1c6c23c536baeeb3f___object.c",
        "uri": "https://api.github.com/repos/VirusTotal/yara/commits/4a342f01e5439b9bb901aff1c6c23c536baeeb3f",
        "commit_msg": "Fix heap overflow (reported by Jurriaan Bremer)\n\nWhen setting a new array item with yr_object_array_set_item() the array size is doubled if the index for the new item is larger than the already allocated ones. No further checks were made to ensure that the index fits into the array after doubling its capacity. If the array capacity was for example 64, and a new object is assigned to an index larger than 128 the overflow occurs. As yr_object_array_set_item() is usually invoked with indexes that increase monotonically by one, this bug never triggered before. But the new \"dotnet\" module has the potential to allow the exploitation of this bug by scanning a specially crafted .NET binary.",
        "test_func_diff": [
            {
                "fn": "libyara/modules/tests.c",
                "patch": "@@ -176,6 +176,7 @@ int module_load(\n   set_integer(0, module_object, \"integer_array[%i]\", 0);\n   set_integer(1, module_object, \"integer_array[%i]\", 1);\n   set_integer(2, module_object, \"integer_array[%i]\", 2);\n+  set_integer(256, module_object, \"integer_array[%i]\", 256);\n \n   set_string(\"foo\", module_object, \"string_array[%i]\", 0);\n   set_string(\"bar\", module_object, \"string_array[%i]\", 1);"
            },
            {
                "fn": "tests/test-rules.c",
                "patch": "@@ -1395,6 +1395,13 @@ static void test_modules()\n       }\",\n       NULL);\n \n+  assert_true_rule(\n+      \"import \\\"tests\\\" \\\n+       rule test { \\\n+        condition: tests.integer_array[256] == 256 \\\n+      }\",\n+      NULL);\n+\n   assert_true_rule(\n       \"import \\\"tests\\\" \\\n        rule test { \\"
            }
        ],
        "error_msg": "FAIL: test-rules\n================\n\ntests/test-rules.c:1403: rule does not match (but should)\n\n=================================================================\n==63499==ERROR: LeakSanitizer: detected memory leaks\n\nDirect leak of 40 byte(s) in 1 object(s) allocated from:\n    #0 0x55be3b6b1bae in malloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:69:3\n    #1 0x55be3b709a90 in yr_object_create /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/object.c:90:22\n    #2 0x55be3b70c356 in yr_object_array_get_item /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/object.c:701:5\n    #3 0x55be3b70c356 in _yr_object_lookup /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/object.c:510:17\n    #4 0x55be3b70b0b6 in yr_object_set_integer /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/object.c:985:19\n    #5 0x55be3b72e5d0 in tests__load /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/modules/tests.c:179:3\n    #6 0x55be3b7624e2 in yr_execute_code /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/exec.c:847:18\n    #7 0x55be3b7269ac in yr_rules_scan_mem_blocks /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/rules.c:472:3\n    #8 0x55be3b72788b in yr_rules_scan_mem /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/rules.c:586:10\n    #9 0x55be3b6f7e5b in matches_blob /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/tests/util.c:122:21\n    #10 0x55be3b6f416d in test_modules /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/tests/test-rules.c:1377:3\n    #11 0x55be3b6f416d in main /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/tests/test-rules.c:1699:3\n    #12 0x7f953fff9082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n\n"
    },
    "50a51cb7e67268e6ad417eb07c9de9bfea5cc55a___pcre2_jit_compile.c": {
        "prefix": "static void compile_xclass_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\njump_list *found = NULL;\njump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks;\nsljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin;\nint compares, invertcmp, numberofcmps;\n#if defined SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\nBOOL utf = common->utf;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == [8|16] */\n\n#ifdef SUPPORT_UNICODE\nsljit_u32 unicode_status = 0;\nint typereg = TMP1;\nconst sljit_u32 *other_cases;\nsljit_uw typeoffset;\n#endif /* SUPPORT_UNICODE */\n\n/* Scanning the necessary info. */\ncc++;\nccbegin = cc;\ncompares = 0;\n\nif (cc[-1] & XCL_MAP)\n  {\n  min = 0;\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\nwhile (*cc != XCL_END)\n  {\n  compares++;\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n    if (c < min) min = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c < min) min = c;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    cc++;\n",
        "suffix": "      {\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n      while (*other_cases != NOTACHAR)\n        {\n        if (*other_cases > max) max = *other_cases;\n        if (*other_cases < min) min = *other_cases;\n        other_cases++;\n        }\n      }\n    else\n      {\n      max = READ_CHAR_MAX;\n      min = 0;\n      }\n\n    switch(*cc)\n      {\n      case PT_ANY:\n      /* Any either accepts everything or ignored. */\n      if (cc[-1] == XCL_PROP)\n        {\n        compile_char1_matchingpath(common, OP_ALLANY, cc, backtracks, FALSE);\n        if (list == backtracks)\n          add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n        return;\n        }\n      break;\n\n      case PT_LAMP:\n      case PT_GC:\n      case PT_PC:\n      case PT_ALNUM:\n      unicode_status |= XCLASS_HAS_TYPE;\n      break;\n\n      case PT_SCX:\n      unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;\n      if (cc[-1] == XCL_NOTPROP)\n        {\n        unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;\n        break;\n        }\n      compares++;\n      /* Fall through */ \n\n      case PT_SC:\n      unicode_status |= XCLASS_HAS_SCRIPT;\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      case PT_WORD:\n      case PT_PXGRAPH:\n      case PT_PXPRINT:\n      case PT_PXPUNCT:\n      unicode_status |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;\n      break;\n\n      case PT_CLIST:\n      case PT_UCNC:\n      unicode_status |= XCLASS_SAVE_CHAR;\n      break;\n\n      case PT_BOOL:\n      unicode_status |= XCLASS_HAS_BOOL;\n      break;\n\n      case PT_BIDICL:\n      unicode_status |= XCLASS_HAS_BIDICL;\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n  }\nSLJIT_ASSERT(compares > 0);\n\n/* We are not necessary in utf mode even in 8 bit mode. */\ncc = ccbegin;\nif ((cc[-1] & XCL_NOT) != 0)\n  read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\nelse\n  {\n#ifdef SUPPORT_UNICODE\n  read_char(common, min, max, (unicode_status & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0);\n#else /* !SUPPORT_UNICODE */\n  read_char(common, min, max, NULL, 0);\n#endif /* SUPPORT_UNICODE */\n  }\n\nif ((cc[-1] & XCL_HASPROP) == 0)\n  {\n  if ((cc[-1] & XCL_MAP) != 0)\n    {\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n    if (!optimize_class(common, (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))\n      {\n      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n      OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n      OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n      add_jump(compiler, &found, JUMP(SLJIT_NOT_ZERO));\n      }\n\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(jump);\n\n    cc += 32 / sizeof(PCRE2_UCHAR);\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n    add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, max - min));\n    }\n  }\nelse if ((cc[-1] & XCL_MAP) != 0)\n  {\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n#ifdef SUPPORT_UNICODE\n  unicode_status |= XCLASS_CHAR_SAVED;\n#endif /* SUPPORT_UNICODE */\n  if (!optimize_class(common, (const sljit_u8 *)cc, FALSE, TRUE, list))\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump = NULL;\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n\n    OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n    add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      JUMPHERE(jump);\n    }\n\n  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\n#ifdef SUPPORT_UNICODE\nif (unicode_status & XCLASS_NEEDS_UCD)\n  {\n  if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (!common->utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n    JUMPHERE(jump);\n    }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n  OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  ccbegin = cc;\n\n  if (unicode_status & XCLASS_HAS_BIDICL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BIDICL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n          jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);\n          add_jump(compiler, compares > 0 ? list : backtracks, jump);\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_BOOL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, bprops));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BOOL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT)\n    {\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        switch (*cc)\n          {\n          case PT_SCX:\n          if (cc[-1] == XCL_NOTPROP)\n            break;\n          /* Fall through */ \n\n          case PT_SC:\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)\n      {\n      if (unicode_status & XCLASS_HAS_TYPE)\n        {\n        if (unicode_status & XCLASS_SAVE_CHAR)\n          {\n          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;\n          }\n        else\n          {\n          OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;\n          }\n        }\n      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n      }\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_SCX)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n\n          jump = NULL;\n          if (cc[-1] == XCL_NOTPROP)\n            {\n            jump = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);\n            if (invertcmp)\n              {\n              add_jump(compiler, backtracks, jump);\n              jump = NULL;\n              }\n            invertcmp ^= 0x1;\n            }\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n\n          if (jump != NULL)\n            JUMPHERE(jump);\n          }\n        cc += 2;\n        }\n      }\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n    else if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)\n      OP1(SLJIT_MOV, TMP2, 0, RETURN_ADDR, 0);\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n\n  if (unicode_status & XCLASS_HAS_TYPE)\n    {\n    if (unicode_status & XCLASS_SAVE_CHAR)\n      typereg = RETURN_ADDR;\n\n    OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\n    }\n  }\n#endif /* SUPPORT_UNICODE */\n\n/* Generating code. */\ncharoffset = 0;\nnumberofcmps = 0;\n#ifdef SUPPORT_UNICODE\ntypeoffset = 0;\n#endif /* SUPPORT_UNICODE */\n\nwhile (*cc != XCL_END)\n  {\n  compares--;\n  invertcmp = (compares == 0 && list != backtracks);\n  jump = NULL;\n\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    SET_CHAR_OFFSET(c);\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    if (*cc == XCL_NOTPROP)\n      invertcmp ^= 0x1;\n    cc++;\n    switch(*cc)\n      {\n      case PT_ANY:\n      if (!invertcmp)\n        jump = JUMP(SLJIT_JUMP);\n      break;\n\n      case PT_LAMP:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lu - typeoffset);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_GC:\n      c = PRIV(ucp_typerange)[(int)cc[1] * 2];\n      SET_TYPE_OFFSET(c);\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);\n      break;\n\n      case PT_PC:\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, (int)cc[1] - typeoffset);\n      break;\n\n      case PT_SC:\n      case PT_SCX:\n      case PT_BOOL:\n      case PT_BIDICL:\n      compares++;\n      /* Do nothing. */\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      SET_CHAR_OFFSET(9);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Zl);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Zl);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_WORD:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      /* Fall through. */\n\n      case PT_ALNUM:\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n      OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_TYPE_OFFSET(ucp_Nd);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_CLIST:\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n\n      /* At least three characters are required.\n         Otherwise this case would be handled by the normal code path. */\n      SLJIT_ASSERT(other_cases[0] != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);\n      SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);\n\n      /* Optimizing character pairs, if their difference is power of 2. */\n      if (is_powerof2(other_cases[1] ^ other_cases[0]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        other_cases += 2;\n        }\n      else if (is_powerof2(other_cases[2] ^ other_cases[1]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[2] ^ other_cases[1]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));\n        OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n\n        other_cases += 3;\n        }\n      else\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        }\n\n      while (*other_cases != NOTACHAR)\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n        }\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_UCNC:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_CHAR_OFFSET(0xa0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_PXGRAPH:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPRINT:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Ll);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPUNCT:\n      SET_TYPE_OFFSET(ucp_Sc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x7f);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Pc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n\n  if (jump != NULL)\n    add_jump(compiler, compares > 0 ? list : backtracks, jump);\n  }\n\nif (found != NULL)\n  set_jumps(found, LABEL());\n}\n",
        "start": 7432,
        "end": 8165,
        "buggy": "static void compile_xclass_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\njump_list *found = NULL;\njump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks;\nsljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin;\nint compares, invertcmp, numberofcmps;\n#if defined SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\nBOOL utf = common->utf;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == [8|16] */\n\n#ifdef SUPPORT_UNICODE\nsljit_u32 unicode_status = 0;\nint typereg = TMP1;\nconst sljit_u32 *other_cases;\nsljit_uw typeoffset;\n#endif /* SUPPORT_UNICODE */\n\n/* Scanning the necessary info. */\ncc++;\nccbegin = cc;\ncompares = 0;\n\nif (cc[-1] & XCL_MAP)\n  {\n  min = 0;\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\nwhile (*cc != XCL_END)\n  {\n  compares++;\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n    if (c < min) min = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c < min) min = c;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    cc++;\n    if (*cc == PT_CLIST)\n      {\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n      while (*other_cases != NOTACHAR)\n        {\n        if (*other_cases > max) max = *other_cases;\n        if (*other_cases < min) min = *other_cases;\n        other_cases++;\n        }\n      }\n    else\n      {\n      max = READ_CHAR_MAX;\n      min = 0;\n      }\n\n    switch(*cc)\n      {\n      case PT_ANY:\n      /* Any either accepts everything or ignored. */\n      if (cc[-1] == XCL_PROP)\n        {\n        compile_char1_matchingpath(common, OP_ALLANY, cc, backtracks, FALSE);\n        if (list == backtracks)\n          add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n        return;\n        }\n      break;\n\n      case PT_LAMP:\n      case PT_GC:\n      case PT_PC:\n      case PT_ALNUM:\n      unicode_status |= XCLASS_HAS_TYPE;\n      break;\n\n      case PT_SCX:\n      unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;\n      if (cc[-1] == XCL_NOTPROP)\n        {\n        unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;\n        break;\n        }\n      compares++;\n      /* Fall through */ \n\n      case PT_SC:\n      unicode_status |= XCLASS_HAS_SCRIPT;\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      case PT_WORD:\n      case PT_PXGRAPH:\n      case PT_PXPRINT:\n      case PT_PXPUNCT:\n      unicode_status |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;\n      break;\n\n      case PT_CLIST:\n      case PT_UCNC:\n      unicode_status |= XCLASS_SAVE_CHAR;\n      break;\n\n      case PT_BOOL:\n      unicode_status |= XCLASS_HAS_BOOL;\n      break;\n\n      case PT_BIDICL:\n      unicode_status |= XCLASS_HAS_BIDICL;\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n  }\nSLJIT_ASSERT(compares > 0);\n\n/* We are not necessary in utf mode even in 8 bit mode. */\ncc = ccbegin;\nif ((cc[-1] & XCL_NOT) != 0)\n  read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\nelse\n  {\n#ifdef SUPPORT_UNICODE\n  read_char(common, min, max, (unicode_status & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0);\n#else /* !SUPPORT_UNICODE */\n  read_char(common, min, max, NULL, 0);\n#endif /* SUPPORT_UNICODE */\n  }\n\nif ((cc[-1] & XCL_HASPROP) == 0)\n  {\n  if ((cc[-1] & XCL_MAP) != 0)\n    {\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n    if (!optimize_class(common, (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))\n      {\n      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n      OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n      OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n      add_jump(compiler, &found, JUMP(SLJIT_NOT_ZERO));\n      }\n\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(jump);\n\n    cc += 32 / sizeof(PCRE2_UCHAR);\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n    add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, max - min));\n    }\n  }\nelse if ((cc[-1] & XCL_MAP) != 0)\n  {\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n#ifdef SUPPORT_UNICODE\n  unicode_status |= XCLASS_CHAR_SAVED;\n#endif /* SUPPORT_UNICODE */\n  if (!optimize_class(common, (const sljit_u8 *)cc, FALSE, TRUE, list))\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump = NULL;\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n\n    OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n    add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      JUMPHERE(jump);\n    }\n\n  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\n#ifdef SUPPORT_UNICODE\nif (unicode_status & XCLASS_NEEDS_UCD)\n  {\n  if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (!common->utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n    JUMPHERE(jump);\n    }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n  OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  ccbegin = cc;\n\n  if (unicode_status & XCLASS_HAS_BIDICL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BIDICL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n          jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);\n          add_jump(compiler, compares > 0 ? list : backtracks, jump);\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_BOOL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, bprops));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BOOL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT)\n    {\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        switch (*cc)\n          {\n          case PT_SCX:\n          if (cc[-1] == XCL_NOTPROP)\n            break;\n          /* Fall through */ \n\n          case PT_SC:\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)\n      {\n      if (unicode_status & XCLASS_HAS_TYPE)\n        {\n        if (unicode_status & XCLASS_SAVE_CHAR)\n          {\n          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;\n          }\n        else\n          {\n          OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;\n          }\n        }\n      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n      }\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_SCX)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n\n          jump = NULL;\n          if (cc[-1] == XCL_NOTPROP)\n            {\n            jump = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);\n            if (invertcmp)\n              {\n              add_jump(compiler, backtracks, jump);\n              jump = NULL;\n              }\n            invertcmp ^= 0x1;\n            }\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n\n          if (jump != NULL)\n            JUMPHERE(jump);\n          }\n        cc += 2;\n        }\n      }\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n    else if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)\n      OP1(SLJIT_MOV, TMP2, 0, RETURN_ADDR, 0);\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n\n  if (unicode_status & XCLASS_HAS_TYPE)\n    {\n    if (unicode_status & XCLASS_SAVE_CHAR)\n      typereg = RETURN_ADDR;\n\n    OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\n    }\n  }\n#endif /* SUPPORT_UNICODE */\n\n/* Generating code. */\ncharoffset = 0;\nnumberofcmps = 0;\n#ifdef SUPPORT_UNICODE\ntypeoffset = 0;\n#endif /* SUPPORT_UNICODE */\n\nwhile (*cc != XCL_END)\n  {\n  compares--;\n  invertcmp = (compares == 0 && list != backtracks);\n  jump = NULL;\n\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    SET_CHAR_OFFSET(c);\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    if (*cc == XCL_NOTPROP)\n      invertcmp ^= 0x1;\n    cc++;\n    switch(*cc)\n      {\n      case PT_ANY:\n      if (!invertcmp)\n        jump = JUMP(SLJIT_JUMP);\n      break;\n\n      case PT_LAMP:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lu - typeoffset);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_GC:\n      c = PRIV(ucp_typerange)[(int)cc[1] * 2];\n      SET_TYPE_OFFSET(c);\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);\n      break;\n\n      case PT_PC:\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, (int)cc[1] - typeoffset);\n      break;\n\n      case PT_SC:\n      case PT_SCX:\n      case PT_BOOL:\n      case PT_BIDICL:\n      compares++;\n      /* Do nothing. */\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      SET_CHAR_OFFSET(9);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Zl);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Zl);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_WORD:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      /* Fall through. */\n\n      case PT_ALNUM:\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n      OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_TYPE_OFFSET(ucp_Nd);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_CLIST:\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n\n      /* At least three characters are required.\n         Otherwise this case would be handled by the normal code path. */\n      SLJIT_ASSERT(other_cases[0] != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);\n      SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);\n\n      /* Optimizing character pairs, if their difference is power of 2. */\n      if (is_powerof2(other_cases[1] ^ other_cases[0]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        other_cases += 2;\n        }\n      else if (is_powerof2(other_cases[2] ^ other_cases[1]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[2] ^ other_cases[1]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));\n        OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n\n        other_cases += 3;\n        }\n      else\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        }\n\n      while (*other_cases != NOTACHAR)\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n        }\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_UCNC:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_CHAR_OFFSET(0xa0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_PXGRAPH:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPRINT:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Ll);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPUNCT:\n      SET_TYPE_OFFSET(ucp_Sc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x7f);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Pc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n\n  if (jump != NULL)\n    add_jump(compiler, compares > 0 ? list : backtracks, jump);\n  }\n\nif (found != NULL)\n  set_jumps(found, LABEL());\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (*cc == PT_CLIST)\n",
        "src_path": "50a51cb7e67268e6ad417eb07c9de9bfea5cc55a___pcre2_jit_compile.c",
        "uri": "https://api.github.com/repos/PCRE2Project/pcre2/commits/50a51cb7e67268e6ad417eb07c9de9bfea5cc55a",
        "commit_msg": "Fixed a unicode properrty matching issue in JIT",
        "test_func_diff": [
            {
                "fn": "src/pcre2_jit_test.c",
                "patch": "@@ -415,6 +415,7 @@ static struct regression_test_case regression_test_cases[] = {\n \t{ MUP, 0, 0, 0 | F_NOMATCH, \"[^\\\\p{Hangul}\\\\p{Z}]\", \" \" },\n \t{ MUP, 0, 0, 0, \"[\\\\p{Lu}\\\\P{Latin}]+\", \"c\\xEA\\xA4\\xAE,A,b\" },\n \t{ MUP, 0, 0, 0, \"[\\\\x{a92e}\\\\p{Lu}\\\\P{Latin}]+\", \"c\\xEA\\xA4\\xAE,A,b\" },\n+\t{ CMUP, 0, 0, 0, \"[^S]\\\\B\", \"\\xe2\\x80\\x8a\" },\n \n \t/* Possible empty brackets. */\n \t{ MU, A, 0, 0, \"(?:|ab||bc|a)+d\", \"abcxabcabd\" },"
            }
        ],
        "error_msg": "Running JIT regression tests\n  target CPU of SLJIT compiler: x86 64bit (little endian + unaligned)\n  in  8 bit mode with UTF-8  enabled:\n............................................................\n............................................................\n............................................................\n......................................................"
    },
    "509d721c2b61088c1e491c330c48b0cc01dc191e___tree_data.c": {
        "prefix": "LY_ERR\nlyd_value_store(const struct ly_ctx *ctx, struct lyd_value *val, const struct lysc_type *type, const void *value,\n        size_t value_len, ly_bool *dynamic, LY_VALUE_FORMAT format, void *prefix_data, uint32_t hints,\n        const struct lysc_node *ctx_node, ly_bool *incomplete)\n{\n    LY_ERR ret;\n    struct ly_err_item *err = NULL;\n    uint32_t options = (dynamic && *dynamic ? LYPLG_TYPE_STORE_DYNAMIC : 0);\n\n    if (!value) {\n        value = \"\";\n    }\n    if (incomplete) {\n        *incomplete = 0;\n    }\n\n    ret = type->plugin->store(ctx, type, value, value_len, options, format, prefix_data, hints, ctx_node, val, NULL, &err);\n    if (dynamic) {\n        *dynamic = 0;\n    }\n\n    if (ret == LY_EINCOMPLETE) {\n        if (incomplete) {\n            *incomplete = 1;\n        }\n    } else if (ret) {\n        if (err) {\n            LOGVAL_ERRITEM(ctx, err);\n            ly_err_free(err);\n        } else {\n",
        "suffix": "        }\n        return ret;\n    }\n\n    return LY_SUCCESS;\n}\n",
        "start": 57,
        "end": 93,
        "buggy": "LY_ERR\nlyd_value_store(const struct ly_ctx *ctx, struct lyd_value *val, const struct lysc_type *type, const void *value,\n        size_t value_len, ly_bool *dynamic, LY_VALUE_FORMAT format, void *prefix_data, uint32_t hints,\n        const struct lysc_node *ctx_node, ly_bool *incomplete)\n{\n    LY_ERR ret;\n    struct ly_err_item *err = NULL;\n    uint32_t options = (dynamic && *dynamic ? LYPLG_TYPE_STORE_DYNAMIC : 0);\n\n    if (!value) {\n        value = \"\";\n    }\n    if (incomplete) {\n        *incomplete = 0;\n    }\n\n    ret = type->plugin->store(ctx, type, value, value_len, options, format, prefix_data, hints, ctx_node, val, NULL, &err);\n    if (dynamic) {\n        *dynamic = 0;\n    }\n\n    if (ret == LY_EINCOMPLETE) {\n        if (incomplete) {\n            *incomplete = 1;\n        }\n    } else if (ret) {\n        if (err) {\n            LOGVAL_ERRITEM(ctx, err);\n            ly_err_free(err);\n        } else {\n            LOGVAL(ctx, LYVE_OTHER, \"Storing value \\\"%.*s\\\" failed.\", (int)value_len, value);\n        }\n        return ret;\n    }\n\n    return LY_SUCCESS;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            LOGVAL(ctx, LYVE_OTHER, \"Storing value \\\"%.*s\\\" failed.\", (int)value_len, value);\n",
        "src_path": "509d721c2b61088c1e491c330c48b0cc01dc191e___tree_data.c",
        "uri": "https://api.github.com/repos/CESNET/libyang/commits/509d721c2b61088c1e491c330c48b0cc01dc191e",
        "commit_msg": "tree data BUGFIX possible freed memory access",
        "test_func_diff": [
            {
                "fn": "tests/utests/types/yang_types.c",
                "patch": "@@ -147,7 +147,7 @@ test_data_xml(void **state)\n     CHECK_LOG_CTX(\"Failed to resolve prefix \\\"a\\\".\", \"Schema location /a:l2, line number 1.\");\n     TEST_ERROR_XML(\"a\\\" xmlns:yl=\\\"urn:ietf:params:xml:ns:yang:ietf-yang-library\", \"l2\",\n             \"/yl:yang-library/yl:datastore/yl::name\");\n-    CHECK_LOG_CTX(\"Storing value \\\"/yl:yang-library/yl:datastore/yl::name\\\" failed.\", \"Schema location /a:l2, line number 1.\",\n+    CHECK_LOG_CTX(\"Storing value failed.\", \"Schema location /a:l2, line number 1.\",\n             \"Invalid character 'y'[31] of expression '/yl:yang-library/yl:datastore/yl::name'.\",\n             \"Schema location /a:l2, line number 1.\");\n }"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_509d721c2b61088c1e491c330c48b0cc01dc191e/build_509d721c2b61088c1e491c330c48b0cc01dc191e\nTest project /out/CESNET___libyang/git_repo_dir_509d721c2b61088c1e491c330c48b0cc01dc191e/build_509d721c2b61088c1e491c330c48b0cc01dc191e\n    Start 13: utest_yang_types\n1/1 Test #13: utest_yang_types .................***Failed    0.03 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.04 sec\n\nThe following tests FAILED:\n\t 13 - utest_yang_types (Failed)\n"
    },
    "7c7783df75b9a5dfc6cc22c70b9467d47aa913d2___tree_schema_compile.c": {
        "prefix": "LY_ERR\nlys_compile_augment(struct lysc_ctx *ctx, struct lysp_augment *aug_p, const struct lysc_node *parent)\n{\n    LY_ERR ret = LY_SUCCESS;\n    struct lysp_node *node_p, *case_node_p;\n    struct lysc_node *target; /* target target of the augment */\n    struct lysc_node *node;\n    struct lysc_when **when, *when_shared;\n    int allow_mandatory = 0;\n    uint16_t flags = 0;\n    unsigned int u;\n    int opt_prev = ctx->options;\n\n    lysc_update_path(ctx, NULL, \"{augment}\");\n    lysc_update_path(ctx, NULL, aug_p->nodeid);\n\n    ret = lys_resolve_schema_nodeid(ctx, aug_p->nodeid, 0, parent, parent ? parent->module : ctx->mod_def,\n                                               LYS_CONTAINER | LYS_LIST | LYS_CHOICE | LYS_CASE | LYS_INOUT | LYS_NOTIF,\n                                               1, (const struct lysc_node**)&target, &flags);\n    if (ret != LY_SUCCESS) {\n        if (ret == LY_EDENIED) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Augment's %s-schema-nodeid \\\"%s\\\" refers to a %s node which is not an allowed augment's target.\",\n                   parent ? \"descendant\" : \"absolute\", aug_p->nodeid, lys_nodetype2str(target->nodetype));\n        }\n        return LY_EVALID;\n    }\n\n    /* check for mandatory nodes\n     * - new cases augmenting some choice can have mandatory nodes\n     * - mandatory nodes are allowed only in case the augmentation is made conditional with a when statement\n     */\n    if (aug_p->when || target->nodetype == LYS_CHOICE || ctx->mod == target->module) {\n        allow_mandatory = 1;\n    }\n\n    when_shared = NULL;\n    LY_LIST_FOR(aug_p->child, node_p) {\n        /* check if the subnode can be connected to the found target (e.g. case cannot be inserted into container) */\n        if (!(target->nodetype == LYS_CHOICE && node_p->nodetype == LYS_CASE)\n                && !((target->nodetype & (LYS_CONTAINER | LYS_LIST)) && (node_p->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF)))\n                && !(target->nodetype != LYS_CHOICE && node_p->nodetype == LYS_USES)\n                && !(node_p->nodetype & (LYS_ANYDATA | LYS_CONTAINER | LYS_CHOICE | LYS_LEAF | LYS_LIST | LYS_LEAFLIST))) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid augment of %s node which is not allowed to contain %s node \\\"%s\\\".\",\n                   lys_nodetype2str(target->nodetype), lys_nodetype2str(node_p->nodetype), node_p->name);\n            return LY_EVALID;\n        }\n\n        /* compile the children */\n        ctx->options |= flags;\n        if (node_p->nodetype != LYS_CASE) {\n            LY_CHECK_RET(lys_compile_node(ctx, node_p, target, 0));\n        } else {\n            LY_LIST_FOR(((struct lysp_node_case *)node_p)->child, case_node_p) {\n                LY_CHECK_RET(lys_compile_node(ctx, case_node_p, target, 0));\n            }\n        }\n        ctx->options = opt_prev;\n\n        /* since the augment node is not present in the compiled tree, we need to pass some of its statements to all its children,\n         * here we gets the last created node as last children of our parent */\n        if (target->nodetype == LYS_CASE) {\n            /* the compiled node is the last child of the target (but it is a case, so we have to be careful and stop) */\n            for (node = (struct lysc_node*)lysc_node_children(target, flags); node->next && node->next->parent == node->parent; node = node->next);\n        } else if (target->nodetype == LYS_CHOICE) {\n            /* to pass when statement, we need the last case no matter if it is explicit or implicit case */\n            node = ((struct lysc_node_choice*)target)->cases->prev;\n        } else {\n            /* the compiled node is the last child of the target */\n",
        "suffix": "        }\n\n        if (!allow_mandatory && (node->flags & LYS_CONFIG_W) && (node->flags & LYS_MAND_TRUE)) {\n            node->flags &= ~LYS_MAND_TRUE;\n            lys_compile_mandatory_parents(target, 0);\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_SEMANTICS,\n                   \"Invalid augment adding mandatory node \\\"%s\\\" without making it conditional via when statement.\", node->name);\n            return LY_EVALID;\n        }\n\n        /* pass augment's when to all the children */\n        if (aug_p->when) {\n            LY_ARRAY_NEW_GOTO(ctx->ctx, node->when, when, ret, error);\n            if (!when_shared) {\n                ret = lys_compile_when(ctx, aug_p->when, aug_p->flags, target, when);\n                LY_CHECK_GOTO(ret, error);\n\n                if (!(ctx->options & LYSC_OPT_GROUPING)) {\n                    /* do not check \"when\" semantics in a grouping */\n                    ly_set_add(&ctx->unres, node, 0);\n                }\n\n                when_shared = *when;\n            } else {\n                ++when_shared->refcount;\n                (*when) = when_shared;\n\n                if (!(ctx->options & LYSC_OPT_GROUPING)) {\n                    /* in this case check \"when\" again for all children because of dummy node check */\n                    ly_set_add(&ctx->unres, node, 0);\n                }\n            }\n        }\n    }\n\n    ctx->options |= flags;\n    switch (target->nodetype) {\n    case LYS_CONTAINER:\n        COMPILE_ARRAY1_GOTO(ctx, aug_p->actions, ((struct lysc_node_container*)target)->actions, target,\n                            u, lys_compile_action, 0, ret, error);\n        COMPILE_ARRAY1_GOTO(ctx, aug_p->notifs, ((struct lysc_node_container*)target)->notifs, target,\n                            u, lys_compile_notif, 0, ret, error);\n        break;\n    case LYS_LIST:\n        COMPILE_ARRAY1_GOTO(ctx, aug_p->actions, ((struct lysc_node_list*)target)->actions, target,\n                            u, lys_compile_action, 0, ret, error);\n        COMPILE_ARRAY1_GOTO(ctx, aug_p->notifs, ((struct lysc_node_list*)target)->notifs, target,\n                            u, lys_compile_notif, 0, ret, error);\n        break;\n    default:\n        ctx->options = opt_prev;\n        if (aug_p->actions) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid augment of %s node which is not allowed to contain RPC/action node \\\"%s\\\".\",\n                   lys_nodetype2str(target->nodetype), aug_p->actions[0].name);\n            return LY_EVALID;\n        }\n        if (aug_p->notifs) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid augment of %s node which is not allowed to contain notification node \\\"%s\\\".\",\n                   lys_nodetype2str(target->nodetype), aug_p->notifs[0].name);\n            return LY_EVALID;\n        }\n    }\n\n    lysc_update_path(ctx, NULL, NULL);\n    lysc_update_path(ctx, NULL, NULL);\nerror:\n    ctx->options = opt_prev;\n    return ret;\n}\n",
        "start": 4682,
        "end": 4823,
        "buggy": "LY_ERR\nlys_compile_augment(struct lysc_ctx *ctx, struct lysp_augment *aug_p, const struct lysc_node *parent)\n{\n    LY_ERR ret = LY_SUCCESS;\n    struct lysp_node *node_p, *case_node_p;\n    struct lysc_node *target; /* target target of the augment */\n    struct lysc_node *node;\n    struct lysc_when **when, *when_shared;\n    int allow_mandatory = 0;\n    uint16_t flags = 0;\n    unsigned int u;\n    int opt_prev = ctx->options;\n\n    lysc_update_path(ctx, NULL, \"{augment}\");\n    lysc_update_path(ctx, NULL, aug_p->nodeid);\n\n    ret = lys_resolve_schema_nodeid(ctx, aug_p->nodeid, 0, parent, parent ? parent->module : ctx->mod_def,\n                                               LYS_CONTAINER | LYS_LIST | LYS_CHOICE | LYS_CASE | LYS_INOUT | LYS_NOTIF,\n                                               1, (const struct lysc_node**)&target, &flags);\n    if (ret != LY_SUCCESS) {\n        if (ret == LY_EDENIED) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Augment's %s-schema-nodeid \\\"%s\\\" refers to a %s node which is not an allowed augment's target.\",\n                   parent ? \"descendant\" : \"absolute\", aug_p->nodeid, lys_nodetype2str(target->nodetype));\n        }\n        return LY_EVALID;\n    }\n\n    /* check for mandatory nodes\n     * - new cases augmenting some choice can have mandatory nodes\n     * - mandatory nodes are allowed only in case the augmentation is made conditional with a when statement\n     */\n    if (aug_p->when || target->nodetype == LYS_CHOICE || ctx->mod == target->module) {\n        allow_mandatory = 1;\n    }\n\n    when_shared = NULL;\n    LY_LIST_FOR(aug_p->child, node_p) {\n        /* check if the subnode can be connected to the found target (e.g. case cannot be inserted into container) */\n        if (!(target->nodetype == LYS_CHOICE && node_p->nodetype == LYS_CASE)\n                && !((target->nodetype & (LYS_CONTAINER | LYS_LIST)) && (node_p->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF)))\n                && !(target->nodetype != LYS_CHOICE && node_p->nodetype == LYS_USES)\n                && !(node_p->nodetype & (LYS_ANYDATA | LYS_CONTAINER | LYS_CHOICE | LYS_LEAF | LYS_LIST | LYS_LEAFLIST))) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid augment of %s node which is not allowed to contain %s node \\\"%s\\\".\",\n                   lys_nodetype2str(target->nodetype), lys_nodetype2str(node_p->nodetype), node_p->name);\n            return LY_EVALID;\n        }\n\n        /* compile the children */\n        ctx->options |= flags;\n        if (node_p->nodetype != LYS_CASE) {\n            LY_CHECK_RET(lys_compile_node(ctx, node_p, target, 0));\n        } else {\n            LY_LIST_FOR(((struct lysp_node_case *)node_p)->child, case_node_p) {\n                LY_CHECK_RET(lys_compile_node(ctx, case_node_p, target, 0));\n            }\n        }\n        ctx->options = opt_prev;\n\n        /* since the augment node is not present in the compiled tree, we need to pass some of its statements to all its children,\n         * here we gets the last created node as last children of our parent */\n        if (target->nodetype == LYS_CASE) {\n            /* the compiled node is the last child of the target (but it is a case, so we have to be careful and stop) */\n            for (node = (struct lysc_node*)lysc_node_children(target, flags); node->next && node->next->parent == node->parent; node = node->next);\n        } else if (target->nodetype == LYS_CHOICE) {\n            /* to pass when statement, we need the last case no matter if it is explicit or implicit case */\n            node = ((struct lysc_node_choice*)target)->cases->prev;\n        } else {\n            /* the compiled node is the last child of the target */\n            node = lysc_node_children(target, flags)->prev;\n        }\n\n        if (!allow_mandatory && (node->flags & LYS_CONFIG_W) && (node->flags & LYS_MAND_TRUE)) {\n            node->flags &= ~LYS_MAND_TRUE;\n            lys_compile_mandatory_parents(target, 0);\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_SEMANTICS,\n                   \"Invalid augment adding mandatory node \\\"%s\\\" without making it conditional via when statement.\", node->name);\n            return LY_EVALID;\n        }\n\n        /* pass augment's when to all the children */\n        if (aug_p->when) {\n            LY_ARRAY_NEW_GOTO(ctx->ctx, node->when, when, ret, error);\n            if (!when_shared) {\n                ret = lys_compile_when(ctx, aug_p->when, aug_p->flags, target, when);\n                LY_CHECK_GOTO(ret, error);\n\n                if (!(ctx->options & LYSC_OPT_GROUPING)) {\n                    /* do not check \"when\" semantics in a grouping */\n                    ly_set_add(&ctx->unres, node, 0);\n                }\n\n                when_shared = *when;\n            } else {\n                ++when_shared->refcount;\n                (*when) = when_shared;\n\n                if (!(ctx->options & LYSC_OPT_GROUPING)) {\n                    /* in this case check \"when\" again for all children because of dummy node check */\n                    ly_set_add(&ctx->unres, node, 0);\n                }\n            }\n        }\n    }\n\n    ctx->options |= flags;\n    switch (target->nodetype) {\n    case LYS_CONTAINER:\n        COMPILE_ARRAY1_GOTO(ctx, aug_p->actions, ((struct lysc_node_container*)target)->actions, target,\n                            u, lys_compile_action, 0, ret, error);\n        COMPILE_ARRAY1_GOTO(ctx, aug_p->notifs, ((struct lysc_node_container*)target)->notifs, target,\n                            u, lys_compile_notif, 0, ret, error);\n        break;\n    case LYS_LIST:\n        COMPILE_ARRAY1_GOTO(ctx, aug_p->actions, ((struct lysc_node_list*)target)->actions, target,\n                            u, lys_compile_action, 0, ret, error);\n        COMPILE_ARRAY1_GOTO(ctx, aug_p->notifs, ((struct lysc_node_list*)target)->notifs, target,\n                            u, lys_compile_notif, 0, ret, error);\n        break;\n    default:\n        ctx->options = opt_prev;\n        if (aug_p->actions) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid augment of %s node which is not allowed to contain RPC/action node \\\"%s\\\".\",\n                   lys_nodetype2str(target->nodetype), aug_p->actions[0].name);\n            return LY_EVALID;\n        }\n        if (aug_p->notifs) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid augment of %s node which is not allowed to contain notification node \\\"%s\\\".\",\n                   lys_nodetype2str(target->nodetype), aug_p->notifs[0].name);\n            return LY_EVALID;\n        }\n    }\n\n    lysc_update_path(ctx, NULL, NULL);\n    lysc_update_path(ctx, NULL, NULL);\nerror:\n    ctx->options = opt_prev;\n    return ret;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            node = lysc_node_children(target, flags)->prev;\n",
        "src_path": "7c7783df75b9a5dfc6cc22c70b9467d47aa913d2___tree_schema_compile.c",
        "uri": "https://api.github.com/repos/CESNET/libyang/commits/7c7783df75b9a5dfc6cc22c70b9467d47aa913d2",
        "commit_msg": "schema compile BUGFIX applying augments only with uses statemtns\n\nThere is a case when parsed data node maps to no compiled data node,\nwhich was not covered when applying augments. We were expecting some\ndata node, but in case the augment contains only a uses statement\nreferencing grouping with notifications or actions only (no data\nchildren), the parsed data node (uses) actually maps to no compiled data\nnode (actions/notifications). Expecting at least one compiled children\nwithout checking caused NULL pointer dereference.\n\nFixes #1041",
        "test_func_diff": [
            {
                "fn": "tests/src/test_tree_schema_compile.c",
                "patch": "@@ -2770,7 +2770,9 @@ test_augment(void **state)\n     const struct lysc_node *node;\n     const struct lysc_node_choice *ch;\n     const struct lysc_node_case *c;\n+    const struct lysc_node_container *cont;\n     const struct lysc_action *rpc;\n+    const struct lysc_notif *notif;\n \n     assert_int_equal(LY_SUCCESS, ly_ctx_new(NULL, LY_CTX_DISABLE_SEARCHDIRS, &ctx));\n \n@@ -2873,6 +2875,14 @@ test_augment(void **state)\n     assert_string_equal(\"y\", rpc->output.data->name);\n     assert_null(rpc->output.data->next);\n \n+    assert_non_null(mod = lys_parse_mem(ctx, \"module j {namespace urn:j;prefix j;yang-version 1.1; container root;\"\n+                                        \"grouping grp {notification grp-notif;}\"\n+                                        \"augment /root {uses grp;}}\", LYS_IN_YANG));\n+    assert_non_null(cont = (const struct lysc_node_container*)mod->compiled->data);\n+    assert_null(cont->child);\n+    assert_non_null(notif = cont->notifs);\n+    assert_int_equal(1, LY_ARRAY_SIZE(notif));\n+\n     assert_null(lys_parse_mem(ctx, \"module aa {namespace urn:aa;prefix aa; container c {leaf a {type string;}}\"\n                                         \"augment /x {leaf a {type int8;}}}\", LYS_IN_YANG));\n     logbuf_assert(\"Invalid absolute-schema-nodeid value \\\"/x\\\" - target node not found. /aa:{augment='/x'}\");"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_7c7783df75b9a5dfc6cc22c70b9467d47aa913d2/build_7c7783df75b9a5dfc6cc22c70b9467d47aa913d2\nTest project /out/CESNET___libyang/git_repo_dir_7c7783df75b9a5dfc6cc22c70b9467d47aa913d2/build_7c7783df75b9a5dfc6cc22c70b9467d47aa913d2\n    Start 9: src_tree_schema_compile\n1/1 Test #9: src_tree_schema_compile ..........***Failed    0.12 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.13 sec\n\nThe following tests FAILED:\n\t  9 - src_tree_schema_compile (Failed)\n"
    },
    "cdcace7230352a25eb21a488e7f42d004b3de3e1___log.c": {
        "prefix": "void\nly_vlog_build_path_reverse(enum LY_VLOG_ELEM elem_type, const void *elem, char *path, uint16_t *index)\n{\n    int i, j;\n    struct lys_node_list *slist;\n    struct lys_node *sparent = NULL;\n    struct lyd_node *dlist, *diter;\n    const struct lys_module *top_smodule = NULL;\n    const char *name, *prefix = NULL, *val_end, *val_start;\n    char *str;\n    size_t len;\n\n    while (elem) {\n        switch (elem_type) {\n        case LY_VLOG_XML:\n            name = ((struct lyxml_elem *)elem)->name;\n            prefix = ((struct lyxml_elem *)elem)->ns ? ((struct lyxml_elem *)elem)->ns->prefix : NULL;\n            elem = ((struct lyxml_elem *)elem)->parent;\n            break;\n        case LY_VLOG_LYS:\n            if (!top_smodule) {\n                /* remember the top module, it will act as the current module */\n                top_smodule = lys_node_module((struct lys_node *)elem);\n            }\n\n            if (((struct lys_node *)elem)->nodetype & (LYS_AUGMENT | LYS_GROUPING)) {\n                --(*index);\n                path[*index] = ']';\n\n                name = ((struct lys_node *)elem)->name;\n                len = strlen(name);\n                (*index) -= len;\n                memcpy(&path[*index], name, len);\n\n                if (((struct lys_node *)elem)->nodetype == LYS_GROUPING) {\n                    name = \"{grouping}[\";\n                } else { /* augment */\n                    name = \"{augment}[\";\n                }\n            } else if (((struct lys_node *)elem)->nodetype == LYS_EXT) {\n                name = ((struct lys_ext_instance *)elem)->def->name;\n            } else {\n                name = ((struct lys_node *)elem)->name;\n            }\n\n",
        "suffix": "                prefix = lys_node_module((struct lys_node *)elem)->name;\n            } else {\n                prefix = NULL;\n            }\n            if (((struct lys_node *)elem)->nodetype == LYS_EXT) {\n                if (((struct lys_ext_instance*)elem)->parent_type == LYEXT_PAR_NODE) {\n                    elem = (struct lys_node*)((struct lys_ext_instance*)elem)->parent;\n                } else {\n                    sparent = NULL;\n                    elem = NULL;\n                }\n                break;\n            }\n\n            /* need to find the parent again because we don't want to skip augments */\n            do {\n                sparent = ((struct lys_node *)elem)->parent;\n                elem = lys_parent((struct lys_node *)elem);\n            } while (elem && (((struct lys_node *)elem)->nodetype == LYS_USES));\n            break;\n        case LY_VLOG_LYD:\n            name = ((struct lyd_node *)elem)->schema->name;\n            if (!((struct lyd_node *)elem)->parent ||\n                    lyd_node_module((struct lyd_node *)elem) != lyd_node_module(((struct lyd_node *)elem)->parent)) {\n                prefix = lyd_node_module((struct lyd_node *)elem)->name;\n            } else {\n                prefix = NULL;\n            }\n\n            /* handle predicates (keys) in case of lists */\n            if (((struct lyd_node *)elem)->schema->nodetype == LYS_LIST) {\n                dlist = (struct lyd_node *)elem;\n                slist = (struct lys_node_list *)((struct lyd_node *)elem)->schema;\n                if (slist->keys_size) {\n                    /* schema list with keys - use key values in predicates */\n                    for (i = slist->keys_size - 1; i > -1; i--) {\n                        LY_TREE_FOR(dlist->child, diter) {\n                            if (diter->schema == (struct lys_node *)slist->keys[i]) {\n                                break;\n                            }\n                        }\n                        if (diter && ((struct lyd_node_leaf_list *)diter)->value_str) {\n                            if (strchr(((struct lyd_node_leaf_list *)diter)->value_str, '\\'')) {\n                                val_start = \"=\\\"\";\n                                val_end = \"\\\"]\";\n                            } else {\n                                val_start = \"='\";\n                                val_end = \"']\";\n                            }\n\n                            (*index) -= 2;\n                            memcpy(&path[(*index)], val_end, 2);\n                            len = strlen(((struct lyd_node_leaf_list *)diter)->value_str);\n                            (*index) -= len;\n                            memcpy(&path[(*index)], ((struct lyd_node_leaf_list *)diter)->value_str, len);\n                            (*index) -= 2;\n                            memcpy(&path[(*index)], val_start, 2);\n                            len = strlen(diter->schema->name);\n                            (*index) -= len;\n                            memcpy(&path[(*index)], diter->schema->name, len);\n                            if (lyd_node_module(dlist) != lyd_node_module(diter)) {\n                                path[--(*index)] = ':';\n                                len = strlen(lyd_node_module(diter)->name);\n                                (*index) -= len;\n                                memcpy(&path[(*index)], lyd_node_module(diter)->name, len);\n                            }\n                            path[--(*index)] = '[';\n                        }\n                    }\n                } else {\n                    /* schema list without keys - use instance position */\n                    path[--(*index)] = ']';\n\n                    i = j = lyd_list_pos(dlist);\n                    len = 1;\n                    while (j > 9) {\n                        ++len;\n                        j /= 10;\n                    }\n\n                    str = malloc(len + 1);\n                    LY_CHECK_ERR_RETURN(!str, LOGMEM, );\n                    sprintf(str, \"%d\", i);\n\n                    (*index) -= len;\n                    strncpy(&path[(*index)], str, len);\n\n                    free(str);\n\n                    --(*index);\n                    path[*index] = '[';\n                }\n            } else if (((struct lyd_node *)elem)->schema->nodetype == LYS_LEAFLIST &&\n                    ((struct lyd_node_leaf_list *)elem)->value_str) {\n                if (strchr(((struct lyd_node_leaf_list *)elem)->value_str, '\\'')) {\n                    val_start = \"[.=\\\"\";\n                    val_end = \"\\\"]\";\n                } else {\n                    val_start = \"[.='\";\n                    val_end = \"']\";\n                }\n\n                (*index) -= 2;\n                memcpy(&path[(*index)], val_end, 2);\n                len = strlen(((struct lyd_node_leaf_list *)elem)->value_str);\n                (*index) -= len;\n                memcpy(&path[(*index)], ((struct lyd_node_leaf_list *)elem)->value_str, len);\n                (*index) -= 4;\n                memcpy(&path[(*index)], val_start, 4);\n            }\n\n            elem = ((struct lyd_node *)elem)->parent;\n            break;\n        case LY_VLOG_STR:\n            len = strlen((const char *)elem) + 1;\n            if (len > LY_BUF_SIZE) {\n                len = LY_BUF_SIZE - 1;\n            }\n            (*index) = LY_BUF_SIZE - len;\n            memcpy(&path[(*index)], (const char *)elem, len - 1);\n            return;\n        default:\n            /* shouldn't be here */\n            LOGINT;\n            return;\n        }\n        if (name) {\n            len = strlen(name);\n            (*index) -= len;\n            memcpy(&path[*index], name, len);\n            if (prefix) {\n                path[--(*index)] = ':';\n                len = strlen(prefix);\n                (*index) = (*index) - len;\n                memcpy(&path[(*index)], prefix, len);\n            }\n        }\n        path[--(*index)] = '/';\n        if (elem_type == LY_VLOG_LYS && !elem && sparent && sparent->nodetype == LYS_AUGMENT) {\n            len = strlen(((struct lys_node_augment *)sparent)->target_name);\n            (*index) = (*index) - len;\n            memcpy(&path[(*index)], ((struct lys_node_augment *)sparent)->target_name, len);\n        }\n    }\n}\n",
        "start": 430,
        "end": 620,
        "buggy": "void\nly_vlog_build_path_reverse(enum LY_VLOG_ELEM elem_type, const void *elem, char *path, uint16_t *index)\n{\n    int i, j;\n    struct lys_node_list *slist;\n    struct lys_node *sparent = NULL;\n    struct lyd_node *dlist, *diter;\n    const struct lys_module *top_smodule = NULL;\n    const char *name, *prefix = NULL, *val_end, *val_start;\n    char *str;\n    size_t len;\n\n    while (elem) {\n        switch (elem_type) {\n        case LY_VLOG_XML:\n            name = ((struct lyxml_elem *)elem)->name;\n            prefix = ((struct lyxml_elem *)elem)->ns ? ((struct lyxml_elem *)elem)->ns->prefix : NULL;\n            elem = ((struct lyxml_elem *)elem)->parent;\n            break;\n        case LY_VLOG_LYS:\n            if (!top_smodule) {\n                /* remember the top module, it will act as the current module */\n                top_smodule = lys_node_module((struct lys_node *)elem);\n            }\n\n            if (((struct lys_node *)elem)->nodetype & (LYS_AUGMENT | LYS_GROUPING)) {\n                --(*index);\n                path[*index] = ']';\n\n                name = ((struct lys_node *)elem)->name;\n                len = strlen(name);\n                (*index) -= len;\n                memcpy(&path[*index], name, len);\n\n                if (((struct lys_node *)elem)->nodetype == LYS_GROUPING) {\n                    name = \"{grouping}[\";\n                } else { /* augment */\n                    name = \"{augment}[\";\n                }\n            } else if (((struct lys_node *)elem)->nodetype == LYS_EXT) {\n                name = ((struct lys_ext_instance *)elem)->def->name;\n            } else {\n                name = ((struct lys_node *)elem)->name;\n            }\n\n            if (lys_node_module((struct lys_node *)elem) != top_smodule) {\n                prefix = lys_node_module((struct lys_node *)elem)->name;\n            } else {\n                prefix = NULL;\n            }\n            if (((struct lys_node *)elem)->nodetype == LYS_EXT) {\n                if (((struct lys_ext_instance*)elem)->parent_type == LYEXT_PAR_NODE) {\n                    elem = (struct lys_node*)((struct lys_ext_instance*)elem)->parent;\n                } else {\n                    sparent = NULL;\n                    elem = NULL;\n                }\n                break;\n            }\n\n            /* need to find the parent again because we don't want to skip augments */\n            do {\n                sparent = ((struct lys_node *)elem)->parent;\n                elem = lys_parent((struct lys_node *)elem);\n            } while (elem && (((struct lys_node *)elem)->nodetype == LYS_USES));\n            break;\n        case LY_VLOG_LYD:\n            name = ((struct lyd_node *)elem)->schema->name;\n            if (!((struct lyd_node *)elem)->parent ||\n                    lyd_node_module((struct lyd_node *)elem) != lyd_node_module(((struct lyd_node *)elem)->parent)) {\n                prefix = lyd_node_module((struct lyd_node *)elem)->name;\n            } else {\n                prefix = NULL;\n            }\n\n            /* handle predicates (keys) in case of lists */\n            if (((struct lyd_node *)elem)->schema->nodetype == LYS_LIST) {\n                dlist = (struct lyd_node *)elem;\n                slist = (struct lys_node_list *)((struct lyd_node *)elem)->schema;\n                if (slist->keys_size) {\n                    /* schema list with keys - use key values in predicates */\n                    for (i = slist->keys_size - 1; i > -1; i--) {\n                        LY_TREE_FOR(dlist->child, diter) {\n                            if (diter->schema == (struct lys_node *)slist->keys[i]) {\n                                break;\n                            }\n                        }\n                        if (diter && ((struct lyd_node_leaf_list *)diter)->value_str) {\n                            if (strchr(((struct lyd_node_leaf_list *)diter)->value_str, '\\'')) {\n                                val_start = \"=\\\"\";\n                                val_end = \"\\\"]\";\n                            } else {\n                                val_start = \"='\";\n                                val_end = \"']\";\n                            }\n\n                            (*index) -= 2;\n                            memcpy(&path[(*index)], val_end, 2);\n                            len = strlen(((struct lyd_node_leaf_list *)diter)->value_str);\n                            (*index) -= len;\n                            memcpy(&path[(*index)], ((struct lyd_node_leaf_list *)diter)->value_str, len);\n                            (*index) -= 2;\n                            memcpy(&path[(*index)], val_start, 2);\n                            len = strlen(diter->schema->name);\n                            (*index) -= len;\n                            memcpy(&path[(*index)], diter->schema->name, len);\n                            if (lyd_node_module(dlist) != lyd_node_module(diter)) {\n                                path[--(*index)] = ':';\n                                len = strlen(lyd_node_module(diter)->name);\n                                (*index) -= len;\n                                memcpy(&path[(*index)], lyd_node_module(diter)->name, len);\n                            }\n                            path[--(*index)] = '[';\n                        }\n                    }\n                } else {\n                    /* schema list without keys - use instance position */\n                    path[--(*index)] = ']';\n\n                    i = j = lyd_list_pos(dlist);\n                    len = 1;\n                    while (j > 9) {\n                        ++len;\n                        j /= 10;\n                    }\n\n                    str = malloc(len + 1);\n                    LY_CHECK_ERR_RETURN(!str, LOGMEM, );\n                    sprintf(str, \"%d\", i);\n\n                    (*index) -= len;\n                    strncpy(&path[(*index)], str, len);\n\n                    free(str);\n\n                    --(*index);\n                    path[*index] = '[';\n                }\n            } else if (((struct lyd_node *)elem)->schema->nodetype == LYS_LEAFLIST &&\n                    ((struct lyd_node_leaf_list *)elem)->value_str) {\n                if (strchr(((struct lyd_node_leaf_list *)elem)->value_str, '\\'')) {\n                    val_start = \"[.=\\\"\";\n                    val_end = \"\\\"]\";\n                } else {\n                    val_start = \"[.='\";\n                    val_end = \"']\";\n                }\n\n                (*index) -= 2;\n                memcpy(&path[(*index)], val_end, 2);\n                len = strlen(((struct lyd_node_leaf_list *)elem)->value_str);\n                (*index) -= len;\n                memcpy(&path[(*index)], ((struct lyd_node_leaf_list *)elem)->value_str, len);\n                (*index) -= 4;\n                memcpy(&path[(*index)], val_start, 4);\n            }\n\n            elem = ((struct lyd_node *)elem)->parent;\n            break;\n        case LY_VLOG_STR:\n            len = strlen((const char *)elem) + 1;\n            if (len > LY_BUF_SIZE) {\n                len = LY_BUF_SIZE - 1;\n            }\n            (*index) = LY_BUF_SIZE - len;\n            memcpy(&path[(*index)], (const char *)elem, len - 1);\n            return;\n        default:\n            /* shouldn't be here */\n            LOGINT;\n            return;\n        }\n        if (name) {\n            len = strlen(name);\n            (*index) -= len;\n            memcpy(&path[*index], name, len);\n            if (prefix) {\n                path[--(*index)] = ':';\n                len = strlen(prefix);\n                (*index) = (*index) - len;\n                memcpy(&path[(*index)], prefix, len);\n            }\n        }\n        path[--(*index)] = '/';\n        if (elem_type == LY_VLOG_LYS && !elem && sparent && sparent->nodetype == LYS_AUGMENT) {\n            len = strlen(((struct lys_node_augment *)sparent)->target_name);\n            (*index) = (*index) - len;\n            memcpy(&path[(*index)], ((struct lys_node_augment *)sparent)->target_name, len);\n        }\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            if (lys_node_module((struct lys_node *)elem) != top_smodule) {\n",
        "src_path": "cdcace7230352a25eb21a488e7f42d004b3de3e1___log.c",
        "uri": "https://api.github.com/repos/CESNET/libyang/commits/cdcace7230352a25eb21a488e7f42d004b3de3e1",
        "commit_msg": "log BUGFIX provide prefix on top-level nodes",
        "test_func_diff": [
            {
                "fn": "tests/api/test_tree_schema.c",
                "patch": "@@ -1299,7 +1299,7 @@ test_lys_path(void **state)\n     module = lys_parse_mem(ctx, lys_module_a, yang_format);\n     assert_ptr_not_equal(module, NULL);\n \n-    template = \"/x/bar-gggg\";\n+    template = \"/a:x/bar-gggg\";\n     set = lys_find_path(module, NULL, template);\n     assert_ptr_not_equal(set, NULL);\n     node = set->set.s[0];"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_cdcace7230352a25eb21a488e7f42d004b3de3e1/build_cdcace7230352a25eb21a488e7f42d004b3de3e1\nTest project /out/CESNET___libyang/git_repo_dir_cdcace7230352a25eb21a488e7f42d004b3de3e1/build_cdcace7230352a25eb21a488e7f42d004b3de3e1\n    Start 2: test_tree_schema\n1/1 Test #2: test_tree_schema .................***Failed    0.12 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.13 sec\n\nThe following tests FAILED:\n\t  2 - test_tree_schema (Failed)\n"
    },
    "350a6bf69e03d19fe996cba992b49556ae2ce8ab___json.c": {
        "prefix": "static LY_ERR\nlyjson_number(struct lyjson_ctx *jsonctx)\n{\n    size_t offset = 0, exponent = 0;\n    const char *in = jsonctx->in->current;\n    uint8_t minus = 0;\n\n    if (in[offset] == '-') {\n        ++offset;\n        minus = 1;\n    }\n\n    if (in[offset] == '0') {\n        ++offset;\n    } else if (isdigit(in[offset])) {\n        ++offset;\n        while (isdigit(in[offset])) {\n            ++offset;\n        }\n    } else {\ninvalid_character:\n        if (in[offset]) {\n            LOGVAL(jsonctx->ctx, LYVE_SYNTAX, \"Invalid character in JSON Number value (\\\"%c\\\").\", in[offset]);\n        } else {\n            LOGVAL(jsonctx->ctx, LY_VCODE_EOF);\n        }\n        return LY_EVALID;\n    }\n\n    if (in[offset] == '.') {\n        ++offset;\n        if (!isdigit(in[offset])) {\n            goto invalid_character;\n        }\n        while (isdigit(in[offset])) {\n            ++offset;\n        }\n    }\n\n    if ((in[offset] == 'e') || (in[offset] == 'E')) {\n        exponent = offset++;\n        if ((in[offset] == '+') || (in[offset] == '-')) {\n            ++offset;\n        }\n        if (!isdigit(in[offset])) {\n            goto invalid_character;\n        }\n        while (isdigit(in[offset])) {\n            ++offset;\n        }\n    }\n\n    if (exponent) {\n        /* convert JSON number with exponent into the representation used by YANG */\n        long int  e_val;\n        char *ptr, *dec_point, *num;\n        const char *e_ptr = &in[exponent + 1];\n        size_t num_len, i;\n        int64_t dp_position; /* final position of the deciaml point */\n\n        errno = 0;\n        e_val = strtol(e_ptr, &ptr, LY_BASE_DEC);\n        if (errno) {\n            LOGVAL(jsonctx->ctx, LYVE_SEMANTICS, \"Exponent out-of-bounds in a JSON Number value (%.*s).\",\n                    (int)(offset - minus - (e_ptr - in)), e_ptr);\n            return LY_EVALID;\n        }\n\n        if (!e_val) {\n            /* exponent is zero, so just cut the part with the exponent */\n            num_len = exponent;\n            LY_CHECK_RET(lyjson_get_buffer_for_number(jsonctx, num_len, &num));\n            memcpy(num, in, num_len);\n            num[num_len] = '\\0';\n            goto store_exp_number;\n        }\n\n        dec_point = ly_strnchr(in, '.', exponent);\n        if (!dec_point) {\n            /* value is integer, we are just ... */\n            if (e_val >= 0) {\n                /* adding zeros at the end */\n                num_len = exponent + e_val;\n                dp_position = num_len; /* decimal point is behind the actual value */\n",
        "suffix": "                /* adding decimal point between the integer's digits */\n                num_len = exponent + 1;\n                dp_position = exponent + e_val;\n            } else {\n                /* adding decimal point before the integer with adding leading zero(s) */\n                num_len = labs(e_val) + 2 + minus;\n                dp_position = exponent + e_val;\n            }\n            dp_position -= minus;\n        } else {\n            /* value is decimal, we are moving the decimal point */\n            dp_position = dec_point - in + e_val - minus;\n            if (dp_position > (ssize_t)exponent) {\n                /* moving decimal point after the decimal value make the integer result */\n                num_len = dp_position;\n            } else if (dp_position < 0) {\n                /* moving decimal point before the decimal value requires additional zero(s)\n                 * (decimal point is already count in exponent value) */\n                num_len = exponent + labs(dp_position) + 1;\n            } else if (dp_position == 0) {\n                /* moving the decimal point exactly to the beginning will cause a zero character to be added. */\n                num_len = exponent + 1;\n            } else {\n                /* moving decimal point just inside the decimal value does not make any change in length */\n                num_len = exponent;\n            }\n        }\n\n        LY_CHECK_RET(lyjson_get_buffer_for_number(jsonctx, num_len, &num));\n\n        /* compose the resulting vlaue */\n        i = 0;\n        if (minus) {\n            num[i++] = '-';\n        }\n        /* add leading zeros */\n        if (dp_position <= 0) {\n            num[i++] = '0';\n            num[i++] = '.';\n            for ( ; dp_position; dp_position++) {\n                num[i++] = '0';\n            }\n        }\n        /* copy the value */\n        ly_bool dp_placed;\n        size_t j;\n        for (dp_placed = dp_position ? 0 : 1, j = minus; j < exponent; j++) {\n            if (in[j] == '.') {\n                continue;\n            }\n            if (!dp_placed) {\n                if (!dp_position) {\n                    num[i++] = '.';\n                    dp_placed = 1;\n                } else {\n                    dp_position--;\n                    if (in[j] == '0') {\n                        num_len--;\n                        continue;\n                    }\n                }\n            }\n\n            num[i++] = in[j];\n        }\n        /* trailing zeros */\n        while (dp_position--) {\n            num[i++] = '0';\n        }\n        /* terminating NULL byte */\n        num[i] = '\\0';\n\nstore_exp_number:\n        /* store the modified number */\n        lyjson_ctx_set_value(jsonctx, num, num_len, 1);\n    } else {\n        /* store the number */\n        lyjson_ctx_set_value(jsonctx, jsonctx->in->current, offset, 0);\n    }\n    ly_in_skip(jsonctx->in, offset);\n\n    JSON_PUSH_STATUS_RET(jsonctx, LYJSON_NUMBER);\n    LY_CHECK_RET(lyjson_check_next(jsonctx));\n\n    return LY_SUCCESS;\n}\n",
        "start": 347,
        "end": 517,
        "buggy": "static LY_ERR\nlyjson_number(struct lyjson_ctx *jsonctx)\n{\n    size_t offset = 0, exponent = 0;\n    const char *in = jsonctx->in->current;\n    uint8_t minus = 0;\n\n    if (in[offset] == '-') {\n        ++offset;\n        minus = 1;\n    }\n\n    if (in[offset] == '0') {\n        ++offset;\n    } else if (isdigit(in[offset])) {\n        ++offset;\n        while (isdigit(in[offset])) {\n            ++offset;\n        }\n    } else {\ninvalid_character:\n        if (in[offset]) {\n            LOGVAL(jsonctx->ctx, LYVE_SYNTAX, \"Invalid character in JSON Number value (\\\"%c\\\").\", in[offset]);\n        } else {\n            LOGVAL(jsonctx->ctx, LY_VCODE_EOF);\n        }\n        return LY_EVALID;\n    }\n\n    if (in[offset] == '.') {\n        ++offset;\n        if (!isdigit(in[offset])) {\n            goto invalid_character;\n        }\n        while (isdigit(in[offset])) {\n            ++offset;\n        }\n    }\n\n    if ((in[offset] == 'e') || (in[offset] == 'E')) {\n        exponent = offset++;\n        if ((in[offset] == '+') || (in[offset] == '-')) {\n            ++offset;\n        }\n        if (!isdigit(in[offset])) {\n            goto invalid_character;\n        }\n        while (isdigit(in[offset])) {\n            ++offset;\n        }\n    }\n\n    if (exponent) {\n        /* convert JSON number with exponent into the representation used by YANG */\n        long int  e_val;\n        char *ptr, *dec_point, *num;\n        const char *e_ptr = &in[exponent + 1];\n        size_t num_len, i;\n        int64_t dp_position; /* final position of the deciaml point */\n\n        errno = 0;\n        e_val = strtol(e_ptr, &ptr, LY_BASE_DEC);\n        if (errno) {\n            LOGVAL(jsonctx->ctx, LYVE_SEMANTICS, \"Exponent out-of-bounds in a JSON Number value (%.*s).\",\n                    (int)(offset - minus - (e_ptr - in)), e_ptr);\n            return LY_EVALID;\n        }\n\n        if (!e_val) {\n            /* exponent is zero, so just cut the part with the exponent */\n            num_len = exponent;\n            LY_CHECK_RET(lyjson_get_buffer_for_number(jsonctx, num_len, &num));\n            memcpy(num, in, num_len);\n            num[num_len] = '\\0';\n            goto store_exp_number;\n        }\n\n        dec_point = ly_strnchr(in, '.', exponent);\n        if (!dec_point) {\n            /* value is integer, we are just ... */\n            if (e_val >= 0) {\n                /* adding zeros at the end */\n                num_len = exponent + e_val;\n                dp_position = num_len; /* decimal point is behind the actual value */\n            } else if ((size_t)labs(e_val) < exponent) {\n                /* adding decimal point between the integer's digits */\n                num_len = exponent + 1;\n                dp_position = exponent + e_val;\n            } else {\n                /* adding decimal point before the integer with adding leading zero(s) */\n                num_len = labs(e_val) + 2 + minus;\n                dp_position = exponent + e_val;\n            }\n            dp_position -= minus;\n        } else {\n            /* value is decimal, we are moving the decimal point */\n            dp_position = dec_point - in + e_val - minus;\n            if (dp_position > (ssize_t)exponent) {\n                /* moving decimal point after the decimal value make the integer result */\n                num_len = dp_position;\n            } else if (dp_position < 0) {\n                /* moving decimal point before the decimal value requires additional zero(s)\n                 * (decimal point is already count in exponent value) */\n                num_len = exponent + labs(dp_position) + 1;\n            } else if (dp_position == 0) {\n                /* moving the decimal point exactly to the beginning will cause a zero character to be added. */\n                num_len = exponent + 1;\n            } else {\n                /* moving decimal point just inside the decimal value does not make any change in length */\n                num_len = exponent;\n            }\n        }\n\n        LY_CHECK_RET(lyjson_get_buffer_for_number(jsonctx, num_len, &num));\n\n        /* compose the resulting vlaue */\n        i = 0;\n        if (minus) {\n            num[i++] = '-';\n        }\n        /* add leading zeros */\n        if (dp_position <= 0) {\n            num[i++] = '0';\n            num[i++] = '.';\n            for ( ; dp_position; dp_position++) {\n                num[i++] = '0';\n            }\n        }\n        /* copy the value */\n        ly_bool dp_placed;\n        size_t j;\n        for (dp_placed = dp_position ? 0 : 1, j = minus; j < exponent; j++) {\n            if (in[j] == '.') {\n                continue;\n            }\n            if (!dp_placed) {\n                if (!dp_position) {\n                    num[i++] = '.';\n                    dp_placed = 1;\n                } else {\n                    dp_position--;\n                    if (in[j] == '0') {\n                        num_len--;\n                        continue;\n                    }\n                }\n            }\n\n            num[i++] = in[j];\n        }\n        /* trailing zeros */\n        while (dp_position--) {\n            num[i++] = '0';\n        }\n        /* terminating NULL byte */\n        num[i] = '\\0';\n\nstore_exp_number:\n        /* store the modified number */\n        lyjson_ctx_set_value(jsonctx, num, num_len, 1);\n    } else {\n        /* store the number */\n        lyjson_ctx_set_value(jsonctx, jsonctx->in->current, offset, 0);\n    }\n    ly_in_skip(jsonctx->in, offset);\n\n    JSON_PUSH_STATUS_RET(jsonctx, LYJSON_NUMBER);\n    LY_CHECK_RET(lyjson_check_next(jsonctx));\n\n    return LY_SUCCESS;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            } else if ((size_t)labs(e_val) < exponent) {\n",
        "src_path": "350a6bf69e03d19fe996cba992b49556ae2ce8ab___json.c",
        "uri": "https://api.github.com/repos/CESNET/libyang/commits/350a6bf69e03d19fe996cba992b49556ae2ce8ab",
        "commit_msg": "json BUGFIX in lyjson_number\n\nThe minus sign was taken as part of the number, which is not correct\nin this expression.",
        "test_func_diff": [
            {
                "fn": "tests/utests/basic/test_json.c",
                "patch": "@@ -132,6 +132,24 @@ test_number(void **state)\n     assert_int_equal(1, jsonctx->dynamic);\n     lyjson_ctx_free(jsonctx);\n \n+    str = \"15E-2\";\n+    assert_non_null(ly_in_memory(in, str));\n+    assert_int_equal(LY_SUCCESS, lyjson_ctx_new(UTEST_LYCTX, in, &jsonctx));\n+    assert_int_equal(LYJSON_NUMBER, lyjson_ctx_status(jsonctx, 0));\n+    assert_string_equal(\"0.15\", jsonctx->value);\n+    assert_int_equal(4, jsonctx->value_len);\n+    assert_int_equal(1, jsonctx->dynamic);\n+    lyjson_ctx_free(jsonctx);\n+\n+    str = \"-15E-2\";\n+    assert_non_null(ly_in_memory(in, str));\n+    assert_int_equal(LY_SUCCESS, lyjson_ctx_new(UTEST_LYCTX, in, &jsonctx));\n+    assert_int_equal(LYJSON_NUMBER, lyjson_ctx_status(jsonctx, 0));\n+    assert_string_equal(\"-0.15\", jsonctx->value);\n+    assert_int_equal(5, jsonctx->value_len);\n+    assert_int_equal(1, jsonctx->dynamic);\n+    lyjson_ctx_free(jsonctx);\n+\n     str = \"15E-3\";\n     assert_non_null(ly_in_memory(in, str));\n     assert_int_equal(LY_SUCCESS, lyjson_ctx_new(UTEST_LYCTX, in, &jsonctx));"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_350a6bf69e03d19fe996cba992b49556ae2ce8ab/build_350a6bf69e03d19fe996cba992b49556ae2ce8ab\nTest project /out/CESNET___libyang/git_repo_dir_350a6bf69e03d19fe996cba992b49556ae2ce8ab/build_350a6bf69e03d19fe996cba992b49556ae2ce8ab\n    Start 18: utest_json\n1/1 Test #18: utest_json .......................***Failed    0.03 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.03 sec\n\nThe following tests FAILED:\n\t 18 - utest_json (Failed)\n"
    },
    "b6ecaeaa0391745ec9054cc4351ac4049317576c___xpath.c": {
        "prefix": "static enum lyxp_node_type\nlyxp_get_root_type(const struct lyd_node *ctx_node, const struct lysc_node *ctx_scnode, uint32_t options)\n{\n    const struct lysc_node *op;\n\n    if (options & LYXP_SCNODE_ALL) {\n        /* schema */\n        for (op = ctx_scnode; op && !(op->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF)); op = op->parent) {}\n\n        if (op || (options & LYXP_SCNODE)) {\n            /* general root that can access everything */\n            return LYXP_NODE_ROOT;\n        } else if (!ctx_scnode || (ctx_scnode->flags & LYS_CONFIG_W)) {\n            /* root context node can access only config data (because we said so, it is unspecified) */\n            return LYXP_NODE_ROOT_CONFIG;\n        }\n        return LYXP_NODE_ROOT;\n    }\n\n    /* data */\n    op = ctx_node ? ctx_node->schema : NULL;\n    for ( ; op && !(op->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF)); op = op->parent) {}\n\n    if (op || !(options & LYXP_SCHEMA)) {\n        /* general root that can access everything */\n        return LYXP_NODE_ROOT;\n",
        "suffix": "        /* root context node can access only config data (because we said so, it is unspecified) */\n        return LYXP_NODE_ROOT_CONFIG;\n    }\n    return LYXP_NODE_ROOT;\n}\n",
        "start": 8409,
        "end": 8440,
        "buggy": "static enum lyxp_node_type\nlyxp_get_root_type(const struct lyd_node *ctx_node, const struct lysc_node *ctx_scnode, uint32_t options)\n{\n    const struct lysc_node *op;\n\n    if (options & LYXP_SCNODE_ALL) {\n        /* schema */\n        for (op = ctx_scnode; op && !(op->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF)); op = op->parent) {}\n\n        if (op || (options & LYXP_SCNODE)) {\n            /* general root that can access everything */\n            return LYXP_NODE_ROOT;\n        } else if (!ctx_scnode || (ctx_scnode->flags & LYS_CONFIG_W)) {\n            /* root context node can access only config data (because we said so, it is unspecified) */\n            return LYXP_NODE_ROOT_CONFIG;\n        }\n        return LYXP_NODE_ROOT;\n    }\n\n    /* data */\n    op = ctx_node ? ctx_node->schema : NULL;\n    for ( ; op && !(op->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF)); op = op->parent) {}\n\n    if (op || !(options & LYXP_SCHEMA)) {\n        /* general root that can access everything */\n        return LYXP_NODE_ROOT;\n    } else if (!ctx_node || (ctx_node->schema->flags & LYS_CONFIG_W)) {\n        /* root context node can access only config data (because we said so, it is unspecified) */\n        return LYXP_NODE_ROOT_CONFIG;\n    }\n    return LYXP_NODE_ROOT;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    } else if (!ctx_node || (ctx_node->schema->flags & LYS_CONFIG_W)) {\n",
        "src_path": "b6ecaeaa0391745ec9054cc4351ac4049317576c___xpath.c",
        "uri": "https://api.github.com/repos/CESNET/libyang/commits/b6ecaeaa0391745ec9054cc4351ac4049317576c",
        "commit_msg": "data tree BUGFIX handle when in mandatory true node",
        "test_func_diff": [
            {
                "fn": "tests/utests/data/test_validation.c",
                "patch": "@@ -72,6 +72,55 @@ test_when(void **state)\n     lyd_free_all(tree);\n }\n \n+static void\n+test_mandatory_when(void **state)\n+{\n+    struct lyd_node *tree;\n+    const char *schema =\n+            \"module a {\\n\"\n+            \"    namespace urn:tests:a;\\n\"\n+            \"    prefix a;\\n\"\n+            \"    yang-version 1.1;\\n\"\n+            \"\\n\"\n+            \"    container cont {\\n\"\n+            \"        leaf a {\\n\"\n+            \"            type string;\\n\"\n+            \"        }\\n\"\n+            \"        leaf b {\\n\"\n+            \"            when \\\"../a = 'val_a'\\\";\\n\"\n+            \"            mandatory true;\\n\"\n+            \"            type string;\\n\"\n+            \"        }\\n\"\n+            \"    }\\n\"\n+            \"    leaf c {\\n\"\n+            \"        type string;\\n\"\n+            \"    }\\n\"\n+            \"    leaf d {\\n\"\n+            \"        when \\\"../c = 'val_c'\\\";\\n\"\n+            \"        mandatory true;\\n\"\n+            \"        type string;\\n\"\n+            \"    }\\n\"\n+            \"}\";\n+\n+    UTEST_ADD_MODULE(schema, LYS_IN_YANG, NULL, NULL);\n+\n+    CHECK_PARSE_LYD_PARAM(\"<d xmlns=\\\"urn:tests:a\\\">hey</d>\", LYD_XML, 0, LYD_VALIDATE_PRESENT, LY_EVALID, tree);\n+    CHECK_LOG_CTX(\"When condition \\\"../c = 'val_c'\\\" not satisfied.\", \"Schema location /a:d, data location /a:d.\");\n+\n+    CHECK_PARSE_LYD_PARAM(\"<cont xmlns=\\\"urn:tests:a\\\"><b>hey</b></cont>\", LYD_XML, 0, LYD_VALIDATE_PRESENT, LY_EVALID, tree);\n+    CHECK_LOG_CTX(\"When condition \\\"../a = 'val_a'\\\" not satisfied.\", \"Schema location /a:cont/b, data location /a:cont/b.\");\n+\n+    LYD_TREE_CREATE(\"<c xmlns=\\\"urn:tests:a\\\">val_c</c><d xmlns=\\\"urn:tests:a\\\">hey</d>\", tree);\n+    CHECK_LYSC_NODE(tree->next->next->schema, NULL, 0, LYS_CONFIG_W | LYS_STATUS_CURR | LYS_MAND_TRUE, 1, \"d\", 0, LYS_LEAF, 0, 0, NULL, 1);\n+    assert_int_equal(LYD_WHEN_TRUE, tree->next->next->flags);\n+    lyd_free_all(tree);\n+\n+    LYD_TREE_CREATE(\"<cont xmlns=\\\"urn:tests:a\\\"><a>val_a</a><b>hey</b></cont>\", tree);\n+    CHECK_LYSC_NODE(lyd_child(tree)->next->schema, NULL, 0, LYS_CONFIG_W | LYS_STATUS_CURR | LYS_MAND_TRUE, 1, \"b\", 0, LYS_LEAF, tree->schema, 0, NULL, 1);\n+    assert_int_equal(LYD_WHEN_TRUE, lyd_child(tree)->next->flags);\n+    lyd_free_all(tree);\n+}\n+\n static void\n test_mandatory(void **state)\n {\n@@ -1173,6 +1222,7 @@ main(void)\n     const struct CMUnitTest tests[] = {\n         UTEST(test_when),\n         UTEST(test_mandatory),\n+        UTEST(test_mandatory_when),\n         UTEST(test_minmax),\n         UTEST(test_unique),\n         UTEST(test_unique_nested),"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_b6ecaeaa0391745ec9054cc4351ac4049317576c/build_b6ecaeaa0391745ec9054cc4351ac4049317576c\nTest project /out/CESNET___libyang/git_repo_dir_b6ecaeaa0391745ec9054cc4351ac4049317576c/build_b6ecaeaa0391745ec9054cc4351ac4049317576c\n    Start 25: utest_validation\n1/1 Test #25: utest_validation .................***Failed    0.12 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.12 sec\n\nThe following tests FAILED:\n\t 25 - utest_validation (Failed)\n"
    },
    "a353cce850560bea761d67a2fbcaf9cb271f586f___xpath.c": {
        "prefix": "static LY_ERR\nmoveto_axis_scnode_next(const struct lysc_node **iter, enum lyxp_node_type *iter_type, const struct lys_module **iter_mod,\n        uint32_t *iter_mod_idx, const struct lysc_node *scnode, enum lyxp_node_type node_type, enum lyxp_axis axis,\n        struct lyxp_set *set, uint32_t getnext_opts)\n{\n    const struct lysc_node *next = NULL, *dfs_stop;\n    enum lyxp_node_type next_type = 0;\n\n    if (!*iter_type) {\n        /* first returned node */\n        return moveto_axis_scnode_next_first(iter, iter_type, iter_mod, iter_mod_idx, scnode, node_type, axis, set,\n                getnext_opts);\n    }\n\n    switch (axis) {\n    case LYXP_AXIS_PARENT:\n    case LYXP_AXIS_SELF:\n        /* parent/self was returned before */\n        break;\n\n    case LYXP_AXIS_ANCESTOR_OR_SELF:\n        if ((*iter == scnode) && (*iter_type == node_type)) {\n            /* fake first ancestor, we returned self before */\n            *iter = NULL;\n            *iter_type = 0;\n            return moveto_axis_scnode_next_first(iter, iter_type, iter_mod, iter_mod_idx, scnode, node_type,\n                    LYXP_AXIS_ANCESTOR, set, getnext_opts);\n        } /* else continue ancestor */\n\n    /* fallthrough */\n    case LYXP_AXIS_ANCESTOR:\n        if (*iter_type == LYXP_NODE_ELEM) {\n            next = lysc_data_parent(*iter);\n            next_type = next ? LYXP_NODE_ELEM : set->root_type;\n        } /* else no ancestor */\n        break;\n\n    case LYXP_AXIS_DESCENDANT_OR_SELF:\n        if ((*iter == scnode) && (*iter_type == node_type)) {\n            /* fake first descendant, we returned self before */\n            *iter = NULL;\n            *iter_type = 0;\n            return moveto_axis_scnode_next_first(iter, iter_type, iter_mod, iter_mod_idx, scnode, node_type,\n                    LYXP_AXIS_DESCENDANT, set, getnext_opts);\n        } /* else DFS until context node */\n        dfs_stop = scnode;\n\n    /* fallthrough */\n    case LYXP_AXIS_DESCENDANT:\n        if (axis == LYXP_AXIS_DESCENDANT) {\n            /* DFS until the context node */\n            dfs_stop = scnode;\n        }\n\n    /* fallthrough */\n    case LYXP_AXIS_PRECEDING:\n        if (axis == LYXP_AXIS_PRECEDING) {\n            /* DFS until the previous sibling */\n            dfs_stop = moveto_axis_scnode_preceding_sibling(scnode, getnext_opts);\n            assert(dfs_stop);\n\n            if (*iter == dfs_stop) {\n                /* we are done */\n                break;\n            }\n        }\n\n    /* fallthrough */\n    case LYXP_AXIS_FOLLOWING:\n        if (axis == LYXP_AXIS_FOLLOWING) {\n            /* DFS through the whole module */\n            dfs_stop = NULL;\n        }\n\n        /* nested nodes */\n        assert(*iter);\n        next = moveto_axis_scnode_next_dfs_forward(*iter, dfs_stop, getnext_opts);\n        if (next) {\n            next_type = LYXP_NODE_ELEM;\n            break;\n        } /* else get next top-level node just like a child */\n\n    /* fallthrough */\n    case LYXP_AXIS_CHILD:\n    case LYXP_AXIS_FOLLOWING_SIBLING:\n        if (!*iter_mod) {\n            /* nodes from a single module */\n            if ((next = lys_getnext(*iter, lysc_data_parent(*iter), (*iter)->module->compiled, getnext_opts))) {\n                next_type = LYXP_NODE_ELEM;\n                break;\n            }\n\n            assert(scnode);\n",
        "suffix": "                /* iterating over top-level nodes, find next */\n                while (lysc_data_parent(*iter)) {\n                    *iter = lysc_data_parent(*iter);\n                }\n                if ((next = lys_getnext(*iter, NULL, (*iter)->module->compiled, getnext_opts))) {\n                    next_type = LYXP_NODE_ELEM;\n                    break;\n                }\n            }\n        }\n\n        while (*iter_mod) {\n            /* module top-level nodes */\n            if ((next = lys_getnext(*iter, NULL, (*iter_mod)->compiled, getnext_opts))) {\n                next_type = LYXP_NODE_ELEM;\n                break;\n            }\n\n            /* get next module */\n            while ((*iter_mod = ly_ctx_get_module_iter(set->ctx, iter_mod_idx))) {\n                /* module may not be implemented or not compiled yet */\n                if ((*iter_mod)->compiled) {\n                    break;\n                }\n            }\n\n            /* new module, start over */\n            *iter = NULL;\n        }\n        break;\n\n    case LYXP_AXIS_PRECEDING_SIBLING:\n        assert(*iter);\n\n        /* next parent sibling until scnode */\n        next = lys_getnext(*iter, lysc_data_parent(*iter), (*iter)->module->compiled, getnext_opts);\n        if (next == scnode) {\n            /* no previous sibling */\n            next = NULL;\n        }\n        next_type = next ? LYXP_NODE_ELEM : 0;\n        break;\n\n    case LYXP_AXIS_ATTRIBUTE:\n        /* unreachable */\n        assert(0);\n        LOGINT(set->ctx);\n        break;\n    }\n\n    *iter = next;\n    *iter_type = next_type;\n    return next_type ? LY_SUCCESS : LY_ENOTFOUND;\n}\n",
        "start": 6494,
        "end": 6641,
        "buggy": "static LY_ERR\nmoveto_axis_scnode_next(const struct lysc_node **iter, enum lyxp_node_type *iter_type, const struct lys_module **iter_mod,\n        uint32_t *iter_mod_idx, const struct lysc_node *scnode, enum lyxp_node_type node_type, enum lyxp_axis axis,\n        struct lyxp_set *set, uint32_t getnext_opts)\n{\n    const struct lysc_node *next = NULL, *dfs_stop;\n    enum lyxp_node_type next_type = 0;\n\n    if (!*iter_type) {\n        /* first returned node */\n        return moveto_axis_scnode_next_first(iter, iter_type, iter_mod, iter_mod_idx, scnode, node_type, axis, set,\n                getnext_opts);\n    }\n\n    switch (axis) {\n    case LYXP_AXIS_PARENT:\n    case LYXP_AXIS_SELF:\n        /* parent/self was returned before */\n        break;\n\n    case LYXP_AXIS_ANCESTOR_OR_SELF:\n        if ((*iter == scnode) && (*iter_type == node_type)) {\n            /* fake first ancestor, we returned self before */\n            *iter = NULL;\n            *iter_type = 0;\n            return moveto_axis_scnode_next_first(iter, iter_type, iter_mod, iter_mod_idx, scnode, node_type,\n                    LYXP_AXIS_ANCESTOR, set, getnext_opts);\n        } /* else continue ancestor */\n\n    /* fallthrough */\n    case LYXP_AXIS_ANCESTOR:\n        if (*iter_type == LYXP_NODE_ELEM) {\n            next = lysc_data_parent(*iter);\n            next_type = next ? LYXP_NODE_ELEM : set->root_type;\n        } /* else no ancestor */\n        break;\n\n    case LYXP_AXIS_DESCENDANT_OR_SELF:\n        if ((*iter == scnode) && (*iter_type == node_type)) {\n            /* fake first descendant, we returned self before */\n            *iter = NULL;\n            *iter_type = 0;\n            return moveto_axis_scnode_next_first(iter, iter_type, iter_mod, iter_mod_idx, scnode, node_type,\n                    LYXP_AXIS_DESCENDANT, set, getnext_opts);\n        } /* else DFS until context node */\n        dfs_stop = scnode;\n\n    /* fallthrough */\n    case LYXP_AXIS_DESCENDANT:\n        if (axis == LYXP_AXIS_DESCENDANT) {\n            /* DFS until the context node */\n            dfs_stop = scnode;\n        }\n\n    /* fallthrough */\n    case LYXP_AXIS_PRECEDING:\n        if (axis == LYXP_AXIS_PRECEDING) {\n            /* DFS until the previous sibling */\n            dfs_stop = moveto_axis_scnode_preceding_sibling(scnode, getnext_opts);\n            assert(dfs_stop);\n\n            if (*iter == dfs_stop) {\n                /* we are done */\n                break;\n            }\n        }\n\n    /* fallthrough */\n    case LYXP_AXIS_FOLLOWING:\n        if (axis == LYXP_AXIS_FOLLOWING) {\n            /* DFS through the whole module */\n            dfs_stop = NULL;\n        }\n\n        /* nested nodes */\n        assert(*iter);\n        next = moveto_axis_scnode_next_dfs_forward(*iter, dfs_stop, getnext_opts);\n        if (next) {\n            next_type = LYXP_NODE_ELEM;\n            break;\n        } /* else get next top-level node just like a child */\n\n    /* fallthrough */\n    case LYXP_AXIS_CHILD:\n    case LYXP_AXIS_FOLLOWING_SIBLING:\n        if (!*iter_mod) {\n            /* nodes from a single module */\n            if ((next = lys_getnext(*iter, lysc_data_parent(*iter), (*iter)->module->compiled, getnext_opts))) {\n                next_type = LYXP_NODE_ELEM;\n                break;\n            }\n\n            assert(scnode);\n            if (!lysc_data_parent(scnode)) {\n                /* iterating over top-level nodes, find next */\n                while (lysc_data_parent(*iter)) {\n                    *iter = lysc_data_parent(*iter);\n                }\n                if ((next = lys_getnext(*iter, NULL, (*iter)->module->compiled, getnext_opts))) {\n                    next_type = LYXP_NODE_ELEM;\n                    break;\n                }\n            }\n        }\n\n        while (*iter_mod) {\n            /* module top-level nodes */\n            if ((next = lys_getnext(*iter, NULL, (*iter_mod)->compiled, getnext_opts))) {\n                next_type = LYXP_NODE_ELEM;\n                break;\n            }\n\n            /* get next module */\n            while ((*iter_mod = ly_ctx_get_module_iter(set->ctx, iter_mod_idx))) {\n                /* module may not be implemented or not compiled yet */\n                if ((*iter_mod)->compiled) {\n                    break;\n                }\n            }\n\n            /* new module, start over */\n            *iter = NULL;\n        }\n        break;\n\n    case LYXP_AXIS_PRECEDING_SIBLING:\n        assert(*iter);\n\n        /* next parent sibling until scnode */\n        next = lys_getnext(*iter, lysc_data_parent(*iter), (*iter)->module->compiled, getnext_opts);\n        if (next == scnode) {\n            /* no previous sibling */\n            next = NULL;\n        }\n        next_type = next ? LYXP_NODE_ELEM : 0;\n        break;\n\n    case LYXP_AXIS_ATTRIBUTE:\n        /* unreachable */\n        assert(0);\n        LOGINT(set->ctx);\n        break;\n    }\n\n    *iter = next;\n    *iter_type = next_type;\n    return next_type ? LY_SUCCESS : LY_ENOTFOUND;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            if (!lysc_data_parent(scnode)) {\n",
        "src_path": "a353cce850560bea761d67a2fbcaf9cb271f586f___xpath.c",
        "uri": "https://api.github.com/repos/CESNET/libyang/commits/a353cce850560bea761d67a2fbcaf9cb271f586f",
        "commit_msg": "xpath BUGFIX child axis does not include siblings\n\nFixes #1938",
        "test_func_diff": [
            {
                "fn": "tests/utests/basic/test_xpath.c",
                "patch": "@@ -96,6 +96,7 @@ setup(void **state)\n     UTEST_SETUP;\n \n     UTEST_ADD_MODULE(schema_a, LYS_IN_YANG, NULL, NULL);\n+    lys_parse_path(UTEST_LYCTX, TESTS_DIR_MODULES_YANG \"/ietf-interfaces@2014-05-08.yang\", LYS_IN_YANG, NULL);\n \n     return 0;\n }\n@@ -485,6 +486,14 @@ test_atomize(void **state)\n     assert_int_equal(6, set->count);\n     ly_set_free(set, NULL);\n \n+    assert_int_equal(LY_SUCCESS, lys_find_xpath_atoms(UTEST_LYCTX, NULL, \"/ietf-interfaces:interfaces/*\", 0, &set));\n+    assert_int_equal(2, set->count);\n+    ly_set_free(set, NULL);\n+\n+    assert_int_equal(LY_SUCCESS, lys_find_xpath_atoms(UTEST_LYCTX, NULL, \"/*\", 0, &set));\n+    assert_int_equal(13, set->count);\n+    ly_set_free(set, NULL);\n+\n     /*\n      * axes\n      */"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_a353cce850560bea761d67a2fbcaf9cb271f586f/build_a353cce850560bea761d67a2fbcaf9cb271f586f\nTest project /out/CESNET___libyang/git_repo_dir_a353cce850560bea761d67a2fbcaf9cb271f586f/build_a353cce850560bea761d67a2fbcaf9cb271f586f\n    Start 34: utest_xpath\n1/1 Test #34: utest_xpath ......................***Failed    0.13 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.13 sec\n\nThe following tests FAILED:\n\t 34 - utest_xpath (Failed)\n"
    },
    "fff4dca0da454cdff4c8fab70b4a62c0674fb862___xpath.c": {
        "prefix": "static LY_ERR\neval_predicate(const struct lyxp_expr *exp, uint16_t *tok_idx, struct lyxp_set *set, uint32_t options, ly_bool parent_pos_pred)\n{\n    LY_ERR rc;\n    uint16_t orig_exp;\n    uint32_t i, orig_pos, orig_size;\n    int32_t pred_in_ctx;\n",
        "suffix": "    struct lyd_node *orig_parent;\n\n    /* '[' */\n    LOGDBG(LY_LDGXPATH, \"%-27s %s %s[%u]\", __func__, (options & LYXP_SKIP_EXPR ? \"skipped\" : \"parsed\"),\n            lyxp_print_token(exp->tokens[*tok_idx]), exp->tok_pos[*tok_idx]);\n    ++(*tok_idx);\n\n    if (options & LYXP_SKIP_EXPR) {\nonly_parse:\n        rc = eval_expr_select(exp, tok_idx, 0, set, options | LYXP_SKIP_EXPR);\n        LY_CHECK_RET(rc);\n    } else if (set->type == LYXP_SET_NODE_SET) {\n        /* we (possibly) need the set sorted, it can affect the result (if the predicate result is a number) */\n        assert(!set_sort(set));\n\n        /* empty set, nothing to evaluate */\n        if (!set->used) {\n            goto only_parse;\n        }\n\n        orig_exp = *tok_idx;\n        orig_pos = 0;\n        orig_size = set->used;\n        orig_parent = NULL;\n        for (i = 0; i < set->used; ++i) {\n            set_init(&set2, set);\n            set_insert_node(&set2, set->val.nodes[i].node, set->val.nodes[i].pos, set->val.nodes[i].type, 0);\n            /* remember the node context position for position() and context size for last(),\n             * predicates should always be evaluated with respect to the child axis (since we do\n             * not support explicit axes) so we assign positions based on their parents */\n            if (parent_pos_pred && (lyd_parent(set->val.nodes[i].node) != orig_parent)) {\n                orig_parent = lyd_parent(set->val.nodes[i].node);\n                orig_pos = 1;\n            } else {\n                ++orig_pos;\n            }\n\n            set2.ctx_pos = orig_pos;\n            set2.ctx_size = orig_size;\n            *tok_idx = orig_exp;\n\n            rc = eval_expr_select(exp, tok_idx, 0, &set2, options);\n            if (rc != LY_SUCCESS) {\n                lyxp_set_free_content(&set2);\n                return rc;\n            }\n\n            /* number is a position */\n            if (set2.type == LYXP_SET_NUMBER) {\n                if ((long long)set2.val.num == orig_pos) {\n                    set2.val.num = 1;\n                } else {\n                    set2.val.num = 0;\n                }\n            }\n            lyxp_set_cast(&set2, LYXP_SET_BOOLEAN);\n\n            /* predicate satisfied or not? */\n            if (!set2.val.bln) {\n                set_remove_node_none(set, i);\n            }\n        }\n        set_remove_nodes_none(set);\n\n    } else if (set->type == LYXP_SET_SCNODE_SET) {\n        for (i = 0; i < set->used; ++i) {\n            if (set->val.scnodes[i].in_ctx == LYXP_SET_SCNODE_ATOM_CTX) {\n                /* there is a currently-valid node */\n                break;\n            }\n        }\n        /* empty set, nothing to evaluate */\n        if (i == set->used) {\n            goto only_parse;\n        }\n\n        orig_exp = *tok_idx;\n\n        /* set special in_ctx to all the valid snodes */\n        pred_in_ctx = set_scnode_new_in_ctx(set);\n\n        /* use the valid snodes one-by-one */\n        for (i = 0; i < set->used; ++i) {\n            if (set->val.scnodes[i].in_ctx != pred_in_ctx) {\n                continue;\n            }\n            set->val.scnodes[i].in_ctx = LYXP_SET_SCNODE_ATOM_CTX;\n\n            *tok_idx = orig_exp;\n\n            rc = eval_expr_select(exp, tok_idx, 0, set, options);\n            LY_CHECK_RET(rc);\n\n            set->val.scnodes[i].in_ctx = pred_in_ctx;\n        }\n\n        /* restore the state as it was before the predicate */\n        for (i = 0; i < set->used; ++i) {\n            if (set->val.scnodes[i].in_ctx == LYXP_SET_SCNODE_ATOM_CTX) {\n                set->val.scnodes[i].in_ctx = LYXP_SET_SCNODE_ATOM_NODE;\n            } else if (set->val.scnodes[i].in_ctx == pred_in_ctx) {\n                set->val.scnodes[i].in_ctx = LYXP_SET_SCNODE_ATOM_CTX;\n            }\n        }\n\n    } else {\n        set2.type = LYXP_SET_NODE_SET;\n        set_fill_set(&set2, set);\n\n        rc = eval_expr_select(exp, tok_idx, 0, &set2, options);\n        if (rc != LY_SUCCESS) {\n            lyxp_set_free_content(&set2);\n            return rc;\n        }\n\n        lyxp_set_cast(&set2, LYXP_SET_BOOLEAN);\n        if (!set2.val.bln) {\n            lyxp_set_free_content(set);\n        }\n        lyxp_set_free_content(&set2);\n    }\n\n    /* ']' */\n    assert(exp->tokens[*tok_idx] == LYXP_TOKEN_BRACK2);\n    LOGDBG(LY_LDGXPATH, \"%-27s %s %s[%u]\", __func__, (options & LYXP_SKIP_EXPR ? \"skipped\" : \"parsed\"),\n            lyxp_print_token(exp->tokens[*tok_idx]), exp->tok_pos[*tok_idx]);\n    ++(*tok_idx);\n\n    return LY_SUCCESS;\n}\n",
        "start": 6777,
        "end": 6914,
        "buggy": "static LY_ERR\neval_predicate(const struct lyxp_expr *exp, uint16_t *tok_idx, struct lyxp_set *set, uint32_t options, ly_bool parent_pos_pred)\n{\n    LY_ERR rc;\n    uint16_t orig_exp;\n    uint32_t i, orig_pos, orig_size;\n    int32_t pred_in_ctx;\n    struct lyxp_set set2;\n    struct lyd_node *orig_parent;\n\n    /* '[' */\n    LOGDBG(LY_LDGXPATH, \"%-27s %s %s[%u]\", __func__, (options & LYXP_SKIP_EXPR ? \"skipped\" : \"parsed\"),\n            lyxp_print_token(exp->tokens[*tok_idx]), exp->tok_pos[*tok_idx]);\n    ++(*tok_idx);\n\n    if (options & LYXP_SKIP_EXPR) {\nonly_parse:\n        rc = eval_expr_select(exp, tok_idx, 0, set, options | LYXP_SKIP_EXPR);\n        LY_CHECK_RET(rc);\n    } else if (set->type == LYXP_SET_NODE_SET) {\n        /* we (possibly) need the set sorted, it can affect the result (if the predicate result is a number) */\n        assert(!set_sort(set));\n\n        /* empty set, nothing to evaluate */\n        if (!set->used) {\n            goto only_parse;\n        }\n\n        orig_exp = *tok_idx;\n        orig_pos = 0;\n        orig_size = set->used;\n        orig_parent = NULL;\n        for (i = 0; i < set->used; ++i) {\n            set_init(&set2, set);\n            set_insert_node(&set2, set->val.nodes[i].node, set->val.nodes[i].pos, set->val.nodes[i].type, 0);\n            /* remember the node context position for position() and context size for last(),\n             * predicates should always be evaluated with respect to the child axis (since we do\n             * not support explicit axes) so we assign positions based on their parents */\n            if (parent_pos_pred && (lyd_parent(set->val.nodes[i].node) != orig_parent)) {\n                orig_parent = lyd_parent(set->val.nodes[i].node);\n                orig_pos = 1;\n            } else {\n                ++orig_pos;\n            }\n\n            set2.ctx_pos = orig_pos;\n            set2.ctx_size = orig_size;\n            *tok_idx = orig_exp;\n\n            rc = eval_expr_select(exp, tok_idx, 0, &set2, options);\n            if (rc != LY_SUCCESS) {\n                lyxp_set_free_content(&set2);\n                return rc;\n            }\n\n            /* number is a position */\n            if (set2.type == LYXP_SET_NUMBER) {\n                if ((long long)set2.val.num == orig_pos) {\n                    set2.val.num = 1;\n                } else {\n                    set2.val.num = 0;\n                }\n            }\n            lyxp_set_cast(&set2, LYXP_SET_BOOLEAN);\n\n            /* predicate satisfied or not? */\n            if (!set2.val.bln) {\n                set_remove_node_none(set, i);\n            }\n        }\n        set_remove_nodes_none(set);\n\n    } else if (set->type == LYXP_SET_SCNODE_SET) {\n        for (i = 0; i < set->used; ++i) {\n            if (set->val.scnodes[i].in_ctx == LYXP_SET_SCNODE_ATOM_CTX) {\n                /* there is a currently-valid node */\n                break;\n            }\n        }\n        /* empty set, nothing to evaluate */\n        if (i == set->used) {\n            goto only_parse;\n        }\n\n        orig_exp = *tok_idx;\n\n        /* set special in_ctx to all the valid snodes */\n        pred_in_ctx = set_scnode_new_in_ctx(set);\n\n        /* use the valid snodes one-by-one */\n        for (i = 0; i < set->used; ++i) {\n            if (set->val.scnodes[i].in_ctx != pred_in_ctx) {\n                continue;\n            }\n            set->val.scnodes[i].in_ctx = LYXP_SET_SCNODE_ATOM_CTX;\n\n            *tok_idx = orig_exp;\n\n            rc = eval_expr_select(exp, tok_idx, 0, set, options);\n            LY_CHECK_RET(rc);\n\n            set->val.scnodes[i].in_ctx = pred_in_ctx;\n        }\n\n        /* restore the state as it was before the predicate */\n        for (i = 0; i < set->used; ++i) {\n            if (set->val.scnodes[i].in_ctx == LYXP_SET_SCNODE_ATOM_CTX) {\n                set->val.scnodes[i].in_ctx = LYXP_SET_SCNODE_ATOM_NODE;\n            } else if (set->val.scnodes[i].in_ctx == pred_in_ctx) {\n                set->val.scnodes[i].in_ctx = LYXP_SET_SCNODE_ATOM_CTX;\n            }\n        }\n\n    } else {\n        set2.type = LYXP_SET_NODE_SET;\n        set_fill_set(&set2, set);\n\n        rc = eval_expr_select(exp, tok_idx, 0, &set2, options);\n        if (rc != LY_SUCCESS) {\n            lyxp_set_free_content(&set2);\n            return rc;\n        }\n\n        lyxp_set_cast(&set2, LYXP_SET_BOOLEAN);\n        if (!set2.val.bln) {\n            lyxp_set_free_content(set);\n        }\n        lyxp_set_free_content(&set2);\n    }\n\n    /* ']' */\n    assert(exp->tokens[*tok_idx] == LYXP_TOKEN_BRACK2);\n    LOGDBG(LY_LDGXPATH, \"%-27s %s %s[%u]\", __func__, (options & LYXP_SKIP_EXPR ? \"skipped\" : \"parsed\"),\n            lyxp_print_token(exp->tokens[*tok_idx]), exp->tok_pos[*tok_idx]);\n    ++(*tok_idx);\n\n    return LY_SUCCESS;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    struct lyxp_set set2;\n",
        "src_path": "fff4dca0da454cdff4c8fab70b4a62c0674fb862___xpath.c",
        "uri": "https://api.github.com/repos/CESNET/libyang/commits/fff4dca0da454cdff4c8fab70b4a62c0674fb862",
        "commit_msg": "xpath BUGFIX in eval_predicate\n\nUninitialized local variable.",
        "test_func_diff": [
            {
                "fn": "tests/utests/basic/test_xpath.c",
                "patch": "@@ -95,6 +95,25 @@ setup(void **state)\n     return 0;\n }\n \n+static void\n+test_predicate(void **state)\n+{\n+    const char *data;\n+    struct lyd_node *tree;\n+    struct ly_set *set;\n+\n+    data =\n+            \"<foo2 xmlns=\\\"urn:tests:a\\\">50</foo2>\";\n+    assert_int_equal(LY_SUCCESS, lyd_parse_data_mem(UTEST_LYCTX, data, LYD_XML, LYD_PARSE_STRICT, LYD_VALIDATE_PRESENT, &tree));\n+    assert_non_null(tree);\n+\n+    /* Predicate after number. */\n+    assert_int_equal(LY_SUCCESS, lyd_find_xpath(tree, \"/foo2[4[3 = 3]]\", &set));\n+    ly_set_free(set, NULL);\n+\n+    lyd_free_all(tree);\n+}\n+\n static void\n test_invalid(void **state)\n {\n@@ -440,6 +459,7 @@ int\n main(void)\n {\n     const struct CMUnitTest tests[] = {\n+        UTEST(test_predicate, setup),\n         UTEST(test_invalid, setup),\n         UTEST(test_hash, setup),\n         UTEST(test_toplevel, setup),"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_fff4dca0da454cdff4c8fab70b4a62c0674fb862/build_fff4dca0da454cdff4c8fab70b4a62c0674fb862\nTest project /out/CESNET___libyang/git_repo_dir_fff4dca0da454cdff4c8fab70b4a62c0674fb862/build_fff4dca0da454cdff4c8fab70b4a62c0674fb862\n    Start 34: utest_xpath\n1/1 Test #34: utest_xpath ......................***Failed    0.06 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.07 sec\n\nThe following tests FAILED:\n\t 34 - utest_xpath (Failed)\n"
    },
    "140ede9c075c604632a87ee3bf0e881fb485d0e7___tree_data.c": {
        "prefix": "static LY_ERR\nlyd_parse_op_(const struct ly_ctx *ctx, const struct lysc_ext_instance *ext, struct lyd_node *parent,\n        struct ly_in *in, LYD_FORMAT format, enum lyd_type data_type, struct lyd_node **tree, struct lyd_node **op)\n{\n    LY_ERR rc = LY_SUCCESS;\n    struct lyd_ctx *lydctx = NULL;\n    struct ly_set parsed = {0};\n    struct lyd_node *first = NULL, *envp = NULL;\n    uint32_t i, parse_opts, val_opts;\n\n    if (!ctx) {\n        ctx = LYD_CTX(parent);\n    }\n    if (tree) {\n        *tree = NULL;\n    }\n    if (op) {\n        *op = NULL;\n    }\n\n    format = lyd_parse_get_format(in, format);\n\n    /* remember input position */\n    in->func_start = in->current;\n\n    /* check params based on the data type */\n    if ((data_type == LYD_TYPE_RPC_NETCONF) || (data_type == LYD_TYPE_NOTIF_NETCONF)) {\n        LY_CHECK_ARG_RET(ctx, format == LYD_XML, !parent, tree, op, LY_EINVAL);\n    } else if (data_type == LYD_TYPE_REPLY_NETCONF) {\n        LY_CHECK_ARG_RET(ctx, format == LYD_XML, parent, parent->schema->nodetype & (LYS_RPC | LYS_ACTION), tree, !op,\n                LY_EINVAL);\n    }\n",
        "suffix": "    val_opts = 0;\n\n    /* parse the data */\n    switch (format) {\n    case LYD_XML:\n        rc = lyd_parse_xml(ctx, ext, parent, &first, in, parse_opts, val_opts, data_type, &envp, &parsed, NULL, &lydctx);\n        if (rc && envp) {\n            /* special situation when the envelopes were parsed successfully */\n            if (tree) {\n                *tree = envp;\n            }\n            ly_set_erase(&parsed, NULL);\n            return rc;\n        }\n        break;\n    case LYD_JSON:\n        rc = lyd_parse_json(ctx, ext, parent, &first, in, parse_opts, val_opts, data_type, &parsed, NULL, &lydctx);\n        break;\n    case LYD_LYB:\n        rc = lyd_parse_lyb(ctx, ext, parent, &first, in, parse_opts, val_opts, data_type, &parsed, NULL, &lydctx);\n        break;\n    case LYD_UNKNOWN:\n        LOGARG(ctx, format);\n        rc = LY_EINVAL;\n        break;\n    }\n    LY_CHECK_GOTO(rc, cleanup);\n\n    /* set out params correctly */\n    if (tree) {\n        if (envp) {\n            /* special out param meaning */\n            *tree = envp;\n        } else {\n            *tree = parent ? NULL : first;\n        }\n    }\n    if (op) {\n        *op = lydctx->op_node;\n    }\n\ncleanup:\n    if (lydctx) {\n        lydctx->free(lydctx);\n    }\n    if (rc) {\n        if (parent) {\n            /* free all the parsed subtrees */\n            for (i = 0; i < parsed.count; ++i) {\n                lyd_free_tree(parsed.dnodes[i]);\n            }\n        } else {\n            /* free everything (cannot occur in the current code, a safety) */\n            lyd_free_all(first);\n            if (tree) {\n                *tree = NULL;\n            }\n            if (op) {\n                *op = NULL;\n            }\n        }\n    }\n    ly_set_erase(&parsed, NULL);\n    return rc;\n}\n",
        "start": 529,
        "end": 626,
        "buggy": "static LY_ERR\nlyd_parse_op_(const struct ly_ctx *ctx, const struct lysc_ext_instance *ext, struct lyd_node *parent,\n        struct ly_in *in, LYD_FORMAT format, enum lyd_type data_type, struct lyd_node **tree, struct lyd_node **op)\n{\n    LY_ERR rc = LY_SUCCESS;\n    struct lyd_ctx *lydctx = NULL;\n    struct ly_set parsed = {0};\n    struct lyd_node *first = NULL, *envp = NULL;\n    uint32_t i, parse_opts, val_opts;\n\n    if (!ctx) {\n        ctx = LYD_CTX(parent);\n    }\n    if (tree) {\n        *tree = NULL;\n    }\n    if (op) {\n        *op = NULL;\n    }\n\n    format = lyd_parse_get_format(in, format);\n\n    /* remember input position */\n    in->func_start = in->current;\n\n    /* check params based on the data type */\n    if ((data_type == LYD_TYPE_RPC_NETCONF) || (data_type == LYD_TYPE_NOTIF_NETCONF)) {\n        LY_CHECK_ARG_RET(ctx, format == LYD_XML, !parent, tree, op, LY_EINVAL);\n    } else if (data_type == LYD_TYPE_REPLY_NETCONF) {\n        LY_CHECK_ARG_RET(ctx, format == LYD_XML, parent, parent->schema->nodetype & (LYS_RPC | LYS_ACTION), tree, !op,\n                LY_EINVAL);\n    }\n    parse_opts = LYD_PARSE_ONLY | LYD_PARSE_OPAQ;\n    val_opts = 0;\n\n    /* parse the data */\n    switch (format) {\n    case LYD_XML:\n        rc = lyd_parse_xml(ctx, ext, parent, &first, in, parse_opts, val_opts, data_type, &envp, &parsed, NULL, &lydctx);\n        if (rc && envp) {\n            /* special situation when the envelopes were parsed successfully */\n            if (tree) {\n                *tree = envp;\n            }\n            ly_set_erase(&parsed, NULL);\n            return rc;\n        }\n        break;\n    case LYD_JSON:\n        rc = lyd_parse_json(ctx, ext, parent, &first, in, parse_opts, val_opts, data_type, &parsed, NULL, &lydctx);\n        break;\n    case LYD_LYB:\n        rc = lyd_parse_lyb(ctx, ext, parent, &first, in, parse_opts, val_opts, data_type, &parsed, NULL, &lydctx);\n        break;\n    case LYD_UNKNOWN:\n        LOGARG(ctx, format);\n        rc = LY_EINVAL;\n        break;\n    }\n    LY_CHECK_GOTO(rc, cleanup);\n\n    /* set out params correctly */\n    if (tree) {\n        if (envp) {\n            /* special out param meaning */\n            *tree = envp;\n        } else {\n            *tree = parent ? NULL : first;\n        }\n    }\n    if (op) {\n        *op = lydctx->op_node;\n    }\n\ncleanup:\n    if (lydctx) {\n        lydctx->free(lydctx);\n    }\n    if (rc) {\n        if (parent) {\n            /* free all the parsed subtrees */\n            for (i = 0; i < parsed.count; ++i) {\n                lyd_free_tree(parsed.dnodes[i]);\n            }\n        } else {\n            /* free everything (cannot occur in the current code, a safety) */\n            lyd_free_all(first);\n            if (tree) {\n                *tree = NULL;\n            }\n            if (op) {\n                *op = NULL;\n            }\n        }\n    }\n    ly_set_erase(&parsed, NULL);\n    return rc;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    parse_opts = LYD_PARSE_ONLY | LYD_PARSE_OPAQ;\n",
        "src_path": "140ede9c075c604632a87ee3bf0e881fb485d0e7___tree_data.c",
        "uri": "https://api.github.com/repos/CESNET/libyang/commits/140ede9c075c604632a87ee3bf0e881fb485d0e7",
        "commit_msg": "tree data UPDATE use strict instead of opaq for op parsing\n\nOpaque nodes are actually not expected normally,\nonly in anyxml/anydata where they are accepted\nin any case.",
        "test_func_diff": [
            {
                "fn": "tests/utests/data/test_validation.c",
                "patch": "@@ -1249,18 +1249,10 @@ test_rpc(void **state)\n             \"   <new-password>123</new-password>\\n\"\n             \"</modify-user-password>\";\n     assert_int_equal(LY_SUCCESS, ly_in_new_memory(data, &in));\n-    /* Success, although the validation found a violation of\n-     * the restriction. An \\\"opaq\\\" node was created instead of\n-     * the \\\"new-password\\\" node from schema.\n-     */\n-    assert_int_equal(LY_SUCCESS, lyd_parse_op(UTEST_LYCTX, NULL, in, LYD_XML, LYD_TYPE_RPC_YANG, &tree, NULL));\n-    assert_non_null(tree);\n-    /* Validate data as RPC request. */\n-    assert_int_equal(LY_EVALID, lyd_validate_op(tree, NULL, LYD_TYPE_RPC_YANG, NULL));\n-    CHECK_LOG_CTX(\"Unsatisfied length - string \\\"123\\\" length is not allowed.\",\n-            \"Data location /val-str:modify-user-password/new-password.\");\n+    assert_int_equal(LY_EVALID, lyd_parse_op(UTEST_LYCTX, NULL, in, LYD_XML, LYD_TYPE_RPC_YANG, &tree, NULL));\n+    CHECK_LOG_CTX(\"Unsatisfied length - string \\\"123\\\" length is not allowed.\", \"Schema location \"\n+            \"/val-str:modify-user-password/input/new-password, data location /val-str:modify-user-password, line number 3.\");\n     ly_in_free(in, 0);\n-    lyd_free_all(tree);\n }\n \n static void"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_140ede9c075c604632a87ee3bf0e881fb485d0e7/build_140ede9c075c604632a87ee3bf0e881fb485d0e7\nTest project /out/CESNET___libyang/git_repo_dir_140ede9c075c604632a87ee3bf0e881fb485d0e7/build_140ede9c075c604632a87ee3bf0e881fb485d0e7\n    Start 48: utest_validation\n1/1 Test #48: utest_validation .................***Failed    0.10 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.11 sec\n\nThe following tests FAILED:\n\t 48 - utest_validation (Failed)\n"
    },
    "9cdb9e6f60d6bae42675bc3b46f5741e50b62e68___parser_xml.c": {
        "prefix": "static LY_ERR\nlydxml_data_skip(struct lyxml_ctx *xmlctx)\n{\n    uint32_t parents_count;\n\n    /* remember current number of parents */\n    parents_count = xmlctx->elements.count;\n\n    /* skip after the content */\n    while (xmlctx->status != LYXML_ELEM_CONTENT) {\n        LY_CHECK_RET(lyxml_ctx_next(xmlctx));\n    }\n    LY_CHECK_RET(lyxml_ctx_next(xmlctx));\n\n",
        "suffix": "    while (parents_count < xmlctx->elements.count) {\n        LY_CHECK_RET(lyxml_ctx_next(xmlctx));\n    }\n\n    /* close element */\n    assert(xmlctx->status == LYXML_ELEM_CLOSE);\n    LY_CHECK_RET(lyxml_ctx_next(xmlctx));\n\n    return LY_SUCCESS;\n}\n",
        "start": 289,
        "end": 313,
        "buggy": "static LY_ERR\nlydxml_data_skip(struct lyxml_ctx *xmlctx)\n{\n    uint32_t parents_count;\n\n    /* remember current number of parents */\n    parents_count = xmlctx->elements.count;\n\n    /* skip after the content */\n    while (xmlctx->status != LYXML_ELEM_CONTENT) {\n        LY_CHECK_RET(lyxml_ctx_next(xmlctx));\n    }\n    LY_CHECK_RET(lyxml_ctx_next(xmlctx));\n\n    /* skip all children elements, recursively, if any */\n    while (parents_count < xmlctx->elements.count) {\n        LY_CHECK_RET(lyxml_ctx_next(xmlctx));\n    }\n\n    /* close element */\n    assert(xmlctx->status == LYXML_ELEM_CLOSE);\n    LY_CHECK_RET(lyxml_ctx_next(xmlctx));\n\n    return LY_SUCCESS;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    /* skip all children elements, recursively, if any */\n",
        "src_path": "9cdb9e6f60d6bae42675bc3b46f5741e50b62e68___parser_xml.c",
        "uri": "https://api.github.com/repos/CESNET/libyang/commits/9cdb9e6f60d6bae42675bc3b46f5741e50b62e68",
        "commit_msg": "parser xml BUGFIX in function lydxml_data_skip\n\nThe xml children's elements are skipped to the parent's closing tag.",
        "test_func_diff": [
            {
                "fn": "tests/utests/data/test_parser_xml.c",
                "patch": "@@ -726,6 +726,32 @@ test_netconf_reply_or_notification(void **state)\n     /* TODO */\n }\n \n+static void\n+test_data_skip(void **state)\n+{\n+    const char *data;\n+    struct lyd_node *tree;\n+    struct lyd_node_term *leaf;\n+\n+    /* add invalid data to a module that is not implemented */\n+    data = \"<foo xmlns=\\\"urn:ietf:params:xml:ns:yang:ietf-yang-metadata\\\"><u/></foo>\";\n+    assert_int_equal(LY_SUCCESS, lyd_parse_data_mem(_UC->ctx, data, LYD_XML, 0, LYD_VALIDATE_PRESENT, &tree));\n+    assert_null(tree);\n+\n+    /* add invalid data to a module that is implemented */\n+    data = \"<fooX xmlns=\\\"urn:tests:a\\\"><u/><list><value/></list></fooX>\";\n+    assert_int_equal(LY_SUCCESS, lyd_parse_data_mem(_UC->ctx, data, LYD_XML, 0, LYD_VALIDATE_PRESENT, &tree));\n+    assert_null(tree);\n+\n+    /* first invalid, next valid */\n+    data = \"<fooX xmlns=\\\"urn:tests:a\\\"><u/></fooX>  <foo xmlns=\\\"urn:tests:a\\\">foo value</foo>\";\n+    CHECK_PARSE_LYD(data, 0, LYD_VALIDATE_PRESENT, tree);\n+    CHECK_LYSC_NODE(tree->schema, NULL, 0, LYS_CONFIG_W | LYS_STATUS_CURR, 1, \"foo\", 1, LYS_LEAF, 0, 0, NULL, 0);\n+    leaf = (struct lyd_node_term *)tree;\n+    CHECK_LYD_VALUE(leaf->value, STRING, \"foo value\");\n+    lyd_free_all(tree);\n+}\n+\n int\n main(void)\n {\n@@ -742,6 +768,7 @@ main(void)\n         UTEST(test_netconf_rpc, setup),\n         UTEST(test_netconf_action, setup),\n         UTEST(test_netconf_reply_or_notification, setup),\n+        UTEST(test_data_skip, setup),\n     };\n \n     return cmocka_run_group_tests(tests, NULL, NULL);"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_9cdb9e6f60d6bae42675bc3b46f5741e50b62e68/build_9cdb9e6f60d6bae42675bc3b46f5741e50b62e68\nTest project /out/CESNET___libyang/git_repo_dir_9cdb9e6f60d6bae42675bc3b46f5741e50b62e68/build_9cdb9e6f60d6bae42675bc3b46f5741e50b62e68\n    Start 30: utest_parser_xml\n1/1 Test #30: utest_parser_xml .................***Failed    0.08 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.08 sec\n\nThe following tests FAILED:\n\t 30 - utest_parser_xml (Failed)\n"
    },
    "24bd22f5e40f37fb6ae796bb8eebc9de58bae00e___xpath.c": {
        "prefix": "static LY_ERR\nmoveto_scnode_check(const struct lysc_node *node, const struct lysc_node *ctx_scnode, const struct lyxp_set *set,\n        const char *node_name, const struct lys_module *moveto_mod)\n{\n",
        "suffix": "        switch (set->format) {\n        case LY_VALUE_SCHEMA:\n        case LY_VALUE_SCHEMA_RESOLVED:\n            /* use current module */\n            moveto_mod = set->cur_mod;\n            break;\n        case LY_VALUE_JSON:\n        case LY_VALUE_LYB:\n            /* inherit module of the context node, if any */\n            if (ctx_scnode) {\n                moveto_mod = ctx_scnode->module;\n            }\n            break;\n        case LY_VALUE_CANON:\n        case LY_VALUE_XML:\n            /* not defined */\n            LOGINT(set->ctx);\n            return LY_EINVAL;\n        }\n    }\n\n    /* module check */\n    if (moveto_mod && (node->module != moveto_mod)) {\n        return LY_ENOT;\n    }\n\n    /* context check */\n    if ((set->root_type == LYXP_NODE_ROOT_CONFIG) && (node->flags & LYS_CONFIG_R)) {\n        return LY_EINVAL;\n    } else if (set->context_op && (node->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF)) && (node != set->context_op)) {\n        return LY_EINVAL;\n    }\n\n    /* name check */\n    if (node_name && strcmp(node_name, \"*\") && (node->name != node_name)) {\n        return LY_ENOT;\n    }\n\n    /* match */\n    return LY_SUCCESS;\n}\n",
        "start": 5471,
        "end": 5516,
        "buggy": "static LY_ERR\nmoveto_scnode_check(const struct lysc_node *node, const struct lysc_node *ctx_scnode, const struct lyxp_set *set,\n        const char *node_name, const struct lys_module *moveto_mod)\n{\n    if (!moveto_mod && (!node_name || strcmp(node_name, \"*\"))) {\n        switch (set->format) {\n        case LY_VALUE_SCHEMA:\n        case LY_VALUE_SCHEMA_RESOLVED:\n            /* use current module */\n            moveto_mod = set->cur_mod;\n            break;\n        case LY_VALUE_JSON:\n        case LY_VALUE_LYB:\n            /* inherit module of the context node, if any */\n            if (ctx_scnode) {\n                moveto_mod = ctx_scnode->module;\n            }\n            break;\n        case LY_VALUE_CANON:\n        case LY_VALUE_XML:\n            /* not defined */\n            LOGINT(set->ctx);\n            return LY_EINVAL;\n        }\n    }\n\n    /* module check */\n    if (moveto_mod && (node->module != moveto_mod)) {\n        return LY_ENOT;\n    }\n\n    /* context check */\n    if ((set->root_type == LYXP_NODE_ROOT_CONFIG) && (node->flags & LYS_CONFIG_R)) {\n        return LY_EINVAL;\n    } else if (set->context_op && (node->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF)) && (node != set->context_op)) {\n        return LY_EINVAL;\n    }\n\n    /* name check */\n    if (node_name && strcmp(node_name, \"*\") && (node->name != node_name)) {\n        return LY_ENOT;\n    }\n\n    /* match */\n    return LY_SUCCESS;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (!moveto_mod && (!node_name || strcmp(node_name, \"*\"))) {\n",
        "src_path": "24bd22f5e40f37fb6ae796bb8eebc9de58bae00e___xpath.c",
        "uri": "https://api.github.com/repos/CESNET/libyang/commits/24bd22f5e40f37fb6ae796bb8eebc9de58bae00e",
        "commit_msg": "xpath BUGFIX evaluation of * on schema\n\nAll modules of the nodes must match.\nRefs #1780",
        "test_func_diff": [
            {
                "fn": "tests/utests/schema/test_tree_schema_compile.c",
                "patch": "@@ -3727,6 +3727,47 @@ test_when(void **state)\n             LYS_IN_YANG, NULL));\n }\n \n+static void\n+test_must(void **state)\n+{\n+    /* \"*\" must not be restricted to any module */\n+    ly_ctx_set_module_imp_clb(UTEST_LYCTX, test_imp_clb,\n+            \"module a {\"\n+            \"  namespace urn:a;\"\n+            \"  prefix a;\"\n+            \"  container cont {\"\n+            \"    leaf l {\"\n+            \"      type empty;\"\n+            \"    }\"\n+            \"    list lst {\"\n+            \"      key \\\"k\\\";\"\n+            \"      leaf k {\"\n+            \"        type uint8;\"\n+            \"      }\"\n+            \"    }\"\n+            \"  }\"\n+            \"}\");\n+    assert_int_equal(LY_SUCCESS, lys_parse_mem(UTEST_LYCTX,\n+            \"module a-aug {\"\n+            \"  namespace urn:aa;\"\n+            \"  prefix aa;\"\n+            \"  import a {\"\n+            \"    prefix a;\"\n+            \"  }\"\n+            \"  augment /a:cont {\"\n+            \"    container cont2 {\"\n+            \"      must \\\"/a:cont/*/a:k\\\";\"\n+            \"      leaf aug {\"\n+            \"        type empty;\"\n+            \"      }\"\n+            \"    }\"\n+            \"  }\"\n+            \"}\",\n+            LYS_IN_YANG, NULL));\n+    /* no warnings */\n+    CHECK_LOG_CTX(NULL, NULL);\n+}\n+\n int\n main(void)\n {\n@@ -3759,6 +3800,7 @@ main(void)\n         UTEST(test_augment, setup),\n         UTEST(test_deviation, setup),\n         UTEST(test_when, setup),\n+        UTEST(test_must, setup),\n     };\n \n     return cmocka_run_group_tests(tests, NULL, NULL);"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_24bd22f5e40f37fb6ae796bb8eebc9de58bae00e/build_24bd22f5e40f37fb6ae796bb8eebc9de58bae00e\nTest project /out/CESNET___libyang/git_repo_dir_24bd22f5e40f37fb6ae796bb8eebc9de58bae00e/build_24bd22f5e40f37fb6ae796bb8eebc9de58bae00e\n    Start 38: utest_tree_schema_compile\n1/1 Test #38: utest_tree_schema_compile ........***Failed    0.26 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.27 sec\n\nThe following tests FAILED:\n\t 38 - utest_tree_schema_compile (Failed)\n"
    },
    "cc8ded6152c51ac853d2915273eed3e6f9af029b___compaction_iterator.cc": {
        "prefix": "std::unique_ptr<BlobFetcher> CompactionIterator::CreateBlobFetcherIfNeeded(\n    const CompactionProxy* compaction) {\n  if (!compaction) {\n    return nullptr;\n  }\n\n  const Version* const version = compaction->input_version();\n  if (!version) {\n    return nullptr;\n  }\n\n",
        "suffix": "}\n",
        "start": 1276,
        "end": 1288,
        "buggy": "std::unique_ptr<BlobFetcher> CompactionIterator::CreateBlobFetcherIfNeeded(\n    const CompactionProxy* compaction) {\n  if (!compaction) {\n    return nullptr;\n  }\n\n  const Version* const version = compaction->input_version();\n  if (!version) {\n    return nullptr;\n  }\n\n  return std::unique_ptr<BlobFetcher>(new BlobFetcher(version, ReadOptions()));\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  return std::unique_ptr<BlobFetcher>(new BlobFetcher(version, ReadOptions()));\n",
        "src_path": "cc8ded6152c51ac853d2915273eed3e6f9af029b___compaction_iterator.cc",
        "uri": "https://api.github.com/repos/facebook/rocksdb/commits/cc8ded6152c51ac853d2915273eed3e6f9af029b",
        "commit_msg": "Do not put blobs read during compaction into cache (#10457)\n\nSummary:\nDuring compaction, blobs are currently read using the default\n`ReadOptions`, which has the `fill_cache` flag set to true. Earlier,\nthis didn't make any difference since we didn't have a blob cache;\nhowever, now we have to explicitly set this flag to false to avoid\npolluting the cache during compaction.\n\nPull Request resolved: https://github.com/facebook/rocksdb/pull/10457\n\nTest Plan: `make check`\n\nReviewed By: riversand963\n\nDifferential Revision: D38333528\n\nPulled By: ltamasi\n\nfbshipit-source-id: 5b4d49a1e39543bee73c7df2aa9194fb101875e2",
        "test_func_diff": [
            {
                "fn": "db/blob/db_blob_compaction_test.cc",
                "patch": "@@ -798,6 +798,42 @@ TEST_F(DBBlobCompactionTest, CompactionReadaheadMerge) {\n   Close();\n }\n \n+TEST_F(DBBlobCompactionTest, CompactionDoNotFillCache) {\n+  Options options = GetDefaultOptions();\n+\n+  options.enable_blob_files = true;\n+  options.min_blob_size = 0;\n+  options.enable_blob_garbage_collection = true;\n+  options.blob_garbage_collection_age_cutoff = 1.0;\n+  options.disable_auto_compactions = true;\n+  options.statistics = CreateDBStatistics();\n+\n+  LRUCacheOptions cache_options;\n+  cache_options.capacity = 1 << 20;\n+  cache_options.metadata_charge_policy = kDontChargeCacheMetadata;\n+\n+  options.blob_cache = NewLRUCache(cache_options);\n+\n+  Reopen(options);\n+\n+  ASSERT_OK(Put(\"key\", \"lime\"));\n+  ASSERT_OK(Put(\"foo\", \"bar\"));\n+  ASSERT_OK(Flush());\n+\n+  ASSERT_OK(Put(\"key\", \"pie\"));\n+  ASSERT_OK(Put(\"foo\", \"baz\"));\n+  ASSERT_OK(Flush());\n+\n+  constexpr Slice* begin = nullptr;\n+  constexpr Slice* end = nullptr;\n+\n+  ASSERT_OK(db_->CompactRange(CompactRangeOptions(), begin, end));\n+\n+  ASSERT_EQ(options.statistics->getTickerCount(BLOB_DB_CACHE_ADD), 0);\n+\n+  Close();\n+}\n+\n }  // namespace ROCKSDB_NAMESPACE\n \n int main(int argc, char** argv) {"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/facebook___rocksdb/git_repo_dir_cc8ded6152c51ac853d2915273eed3e6f9af029b/build_cc8ded6152c51ac853d2915273eed3e6f9af029b\nTest project /out/facebook___rocksdb/git_repo_dir_cc8ded6152c51ac853d2915273eed3e6f9af029b/build_cc8ded6152c51ac853d2915273eed3e6f9af029b\n    Start 523: DBBlobCompactionTest.CompactionDoNotFillCache\n1/1 Test #523: DBBlobCompactionTest.CompactionDoNotFillCache ...***Failed    0.14 sec\n\u001b[0;33mNote: Google Test filter = DBBlobCompactionTest.CompactionDoNotFillCache\n\u001b[m\u001b[0;32m[==========] \u001b[mRunning 1 test from 1 test case.\n\u001b[0;32m[----------] \u001b[mGlobal test environment set-up.\n\u001b[0;32m[----------] \u001b[m1 test from DBBlobCompactionTest\n\u001b[0;32m[ RUN      ] \u001b[mDBBlobCompactionTest.CompactionDoNotFillCache\n/out/facebook___rocksdb/git_repo_dir_cc8ded6152c51ac853d2915273eed3e6f9af029b/db/blob/db_blob_compaction_test.cc:832: Failure\nExpected equality of these values:\n  options.statistics->getTickerCount(BLOB_DB_CACHE_ADD)\n    Which is: 2\n  0\n\u001b[0;31m[  FAILED  ] \u001b[mDBBlobCompactionTest.CompactionDoNotFillCache (116 ms)\n\u001b[0;32m[----------] \u001b[m1 test from DBBlobCompactionTest (116 ms total)\n\n\u001b[0;32m[----------] \u001b[mGlobal test environment tear-down\n\u001b[0;32m[==========] \u001b[m1 test from 1 test case ran. (116 ms total)\n\u001b[0;32m[  PASSED  ] \u001b[m0 tests.\n\u001b[0;31m[  FAILED  ] \u001b[m1 test, listed below:\n\u001b[0;31m[  FAILED  ] \u001b[mDBBlobCompactionTest.CompactionDoNotFillCache\n\n 1 FAILED TEST\n\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.03 sec\n\nThe following tests FAILED:\n\t523 - DBBlobCompactionTest.CompactionDoNotFillCache (Failed)\n"
    },
    "b87c355772c0e1a643cbbd9799809d376073a6fe___db_iter.cc": {
        "prefix": "void DBIter::SeekToLast() {\n  if (iterate_upper_bound_ != nullptr) {\n    // Seek to last key strictly less than ReadOptions.iterate_upper_bound.\n    SeekForPrev(*iterate_upper_bound_);\n    const bool is_ikey = (timestamp_size_ > 0 && timestamp_lb_ != nullptr);\n    Slice k = Valid() ? key() : Slice();\n",
        "suffix": "      k.remove_suffix(kNumInternalBytes + timestamp_size_);\n    }\n    while (Valid() && 0 == user_comparator_.CompareWithoutTimestamp(\n                               *iterate_upper_bound_, /*a_has_ts=*/false, k,\n                               /*b_has_ts=*/false)) {\n      ReleaseTempPinnedData();\n      PrevInternal(nullptr);\n\n      k = key();\n      if (is_ikey) {\n        k.remove_suffix(kNumInternalBytes + timestamp_size_);\n      }\n    }\n    return;\n  }\n\n  PERF_CPU_TIMER_GUARD(iter_seek_cpu_nanos, clock_);\n  // Don't use iter_::Seek() if we set a prefix extractor\n  // because prefix seek will be used.\n  if (!expect_total_order_inner_iter()) {\n    max_skip_ = std::numeric_limits<uint64_t>::max();\n  }\n  status_ = Status::OK();\n  direction_ = kReverse;\n  ReleaseTempPinnedData();\n  ResetInternalKeysSkippedCounter();\n  ClearSavedValue();\n  is_key_seqnum_zero_ = false;\n\n  {\n    PERF_TIMER_GUARD(seek_internal_seek_time);\n    iter_.SeekToLast();\n    range_del_agg_.InvalidateRangeDelMapPositions();\n  }\n  PrevInternal(nullptr);\n  if (statistics_ != nullptr) {\n    RecordTick(statistics_, NUMBER_DB_SEEK);\n    if (valid_) {\n      RecordTick(statistics_, NUMBER_DB_SEEK_FOUND);\n      RecordTick(statistics_, ITER_BYTES_READ, key().size() + value().size());\n      PERF_COUNTER_ADD(iter_read_bytes, key().size() + value().size());\n    }\n  }\n  if (valid_ && prefix_same_as_start_) {\n    assert(prefix_extractor_ != nullptr);\n    prefix_.SetUserKey(prefix_extractor_->Transform(\n        StripTimestampFromUserKey(saved_key_.GetUserKey(), timestamp_size_)));\n  }\n}\n",
        "start": 1609,
        "end": 1664,
        "buggy": "void DBIter::SeekToLast() {\n  if (iterate_upper_bound_ != nullptr) {\n    // Seek to last key strictly less than ReadOptions.iterate_upper_bound.\n    SeekForPrev(*iterate_upper_bound_);\n    const bool is_ikey = (timestamp_size_ > 0 && timestamp_lb_ != nullptr);\n    Slice k = Valid() ? key() : Slice();\n    if (is_ikey) {\n      k.remove_suffix(kNumInternalBytes + timestamp_size_);\n    }\n    while (Valid() && 0 == user_comparator_.CompareWithoutTimestamp(\n                               *iterate_upper_bound_, /*a_has_ts=*/false, k,\n                               /*b_has_ts=*/false)) {\n      ReleaseTempPinnedData();\n      PrevInternal(nullptr);\n\n      k = key();\n      if (is_ikey) {\n        k.remove_suffix(kNumInternalBytes + timestamp_size_);\n      }\n    }\n    return;\n  }\n\n  PERF_CPU_TIMER_GUARD(iter_seek_cpu_nanos, clock_);\n  // Don't use iter_::Seek() if we set a prefix extractor\n  // because prefix seek will be used.\n  if (!expect_total_order_inner_iter()) {\n    max_skip_ = std::numeric_limits<uint64_t>::max();\n  }\n  status_ = Status::OK();\n  direction_ = kReverse;\n  ReleaseTempPinnedData();\n  ResetInternalKeysSkippedCounter();\n  ClearSavedValue();\n  is_key_seqnum_zero_ = false;\n\n  {\n    PERF_TIMER_GUARD(seek_internal_seek_time);\n    iter_.SeekToLast();\n    range_del_agg_.InvalidateRangeDelMapPositions();\n  }\n  PrevInternal(nullptr);\n  if (statistics_ != nullptr) {\n    RecordTick(statistics_, NUMBER_DB_SEEK);\n    if (valid_) {\n      RecordTick(statistics_, NUMBER_DB_SEEK_FOUND);\n      RecordTick(statistics_, ITER_BYTES_READ, key().size() + value().size());\n      PERF_COUNTER_ADD(iter_read_bytes, key().size() + value().size());\n    }\n  }\n  if (valid_ && prefix_same_as_start_) {\n    assert(prefix_extractor_ != nullptr);\n    prefix_.SetUserKey(prefix_extractor_->Transform(\n        StripTimestampFromUserKey(saved_key_.GetUserKey(), timestamp_size_)));\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (is_ikey) {\n",
        "src_path": "b87c355772c0e1a643cbbd9799809d376073a6fe___db_iter.cc",
        "uri": "https://api.github.com/repos/facebook/rocksdb/commits/b87c355772c0e1a643cbbd9799809d376073a6fe",
        "commit_msg": "Fix assertion error with read_opts.iter_start_ts (#10279)\n\nSummary:\nIf the internal iterator is not valid, `SeekToLast` with iter_start_ts should have `valid_` is false without assertion failure.\nTest plan\nmake check\n\nPull Request resolved: https://github.com/facebook/rocksdb/pull/10279\n\nReviewed By: ltamasi\n\nDifferential Revision: D37539393\n\nPulled By: riversand963\n\nfbshipit-source-id: 8e94057838f8a05144fad5768f4d62f1893ec315",
        "test_func_diff": [
            {
                "fn": "db/db_with_timestamp_basic_test.cc",
                "patch": "@@ -1193,6 +1193,14 @@ TEST_F(DBBasicTestWithTimestamp, SimpleBackwardIterateLowerTsBound) {\n     it->SeekToLast();\n     CheckIterEntry(it.get(), \"a\", kTypeSingleDeletion, Slice(),\n                    Timestamp(1, 0));\n+\n+    key_ub_str = \"a\";  // exclusive\n+    key_ub = key_ub_str;\n+    read_opts.iterate_upper_bound = &key_ub;\n+    it.reset(db_->NewIterator(read_opts));\n+    it->SeekToLast();\n+    ASSERT_FALSE(it->Valid());\n+    ASSERT_OK(it->status());\n   }\n \n   Close();"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/facebook___rocksdb/git_repo_dir_b87c355772c0e1a643cbbd9799809d376073a6fe/build_b87c355772c0e1a643cbbd9799809d376073a6fe\nTest project /out/facebook___rocksdb/git_repo_dir_b87c355772c0e1a643cbbd9799809d376073a6fe/build_b87c355772c0e1a643cbbd9799809d376073a6fe\n    Start 985: DBBasicTestWithTimestamp.SimpleBackwardIterateLowerTsBound\n1/1 Test #985: DBBasicTestWithTimestamp.SimpleBackwardIterateLowerTsBound ...Subprocess aborted***Exception:   0.84 sec\n\u001b[0;33mNote: Google Test filter = DBBasicTestWithTimestamp.SimpleBackwardIterateLowerTsBound\n\u001b[m\u001b[0;32m[==========] \u001b[mRunning 1 test from 1 test case.\n\u001b[0;32m[----------] \u001b[mGlobal test environment set-up.\n\u001b[0;32m[----------] \u001b[m1 test from DBBasicTestWithTimestamp\n\u001b[0;32m[ RUN      ] \u001b[mDBBasicTestWithTimestamp.SimpleBackwardIterateLowerTsBound\ndb_with_timestamp_basic_test: /out/facebook___rocksdb/git_repo_dir_b87c355772c0e1a643cbbd9799809d376073a6fe/include/rocksdb/slice.h:86: void rocksdb::Slice::remove_suffix(size_t): Assertion `n <= size()' failed.\n\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   2.70 sec\n\nThe following tests FAILED:\n\t985 - DBBasicTestWithTimestamp.SimpleBackwardIterateLowerTsBound (Subprocess aborted)\n"
    },
    "1d2950b8dd38009d0719e4a857f5a42bb1bc9675___options_parser.cc": {
        "prefix": "Status RocksDBOptionsParser::EndSection(\n    const ConfigOptions& config_options, const OptionSection section,\n    const std::string& section_title, const std::string& section_arg,\n    const std::unordered_map<std::string, std::string>& opt_map) {\n  Status s;\n  if (section == kOptionSectionDBOptions) {\n    s = GetDBOptionsFromMap(config_options, DBOptions(), opt_map, &db_opt_);\n    if (!s.ok()) {\n      return s;\n    }\n    db_opt_map_ = opt_map;\n  } else if (section == kOptionSectionCFOptions) {\n    // This condition should be ensured earlier in ParseSection\n    // so we make an assertion here.\n    assert(GetCFOptions(section_arg) == nullptr);\n    cf_names_.emplace_back(section_arg);\n    cf_opts_.emplace_back();\n    s = GetColumnFamilyOptionsFromMap(config_options, ColumnFamilyOptions(),\n                                      opt_map, &cf_opts_.back());\n    if (!s.ok()) {\n      return s;\n    }\n    // keep the parsed string.\n    cf_opt_maps_.emplace_back(opt_map);\n  } else if (section == kOptionSectionTableOptions) {\n    assert(GetCFOptions(section_arg) != nullptr);\n    auto* cf_opt = GetCFOptionsImpl(section_arg);\n    if (cf_opt == nullptr) {\n      return Status::InvalidArgument(\n          \"The specified column family must be defined before the \"\n          \"TableOptions section:\",\n          section_arg);\n    }\n    // Ignore error as table factory deserialization is optional\n    s = TableFactory::CreateFromString(\n        config_options,\n        section_title.substr(\n            opt_section_titles[kOptionSectionTableOptions].size()),\n        &(cf_opt->table_factory));\n",
        "suffix": "      s = cf_opt->table_factory->ConfigureFromMap(config_options, opt_map);\n      // Translate any errors (NotFound, NotSupported, to InvalidArgument\n      if (s.ok() || s.IsInvalidArgument()) {\n        return s;\n      } else {\n        return Status::InvalidArgument(s.getState());\n      }\n    } else {\n      // Return OK for not supported table factories as TableFactory\n      // Deserialization is optional.\n      cf_opt->table_factory.reset();\n      return Status::OK();\n    }\n  } else if (section == kOptionSectionVersion) {\n    for (const auto& pair : opt_map) {\n      if (pair.first == \"rocksdb_version\") {\n        s = ParseVersionNumber(pair.first, pair.second, 3, db_version);\n        if (!s.ok()) {\n          return s;\n        }\n      } else if (pair.first == \"options_file_version\") {\n        s = ParseVersionNumber(pair.first, pair.second, 2, opt_file_version);\n        if (!s.ok()) {\n          return s;\n        }\n        if (opt_file_version[0] < 1) {\n          return Status::InvalidArgument(\n              \"A valid options_file_version must be at least 1.\");\n        }\n      }\n    }\n  }\n  return s;\n}\n",
        "start": 422,
        "end": 495,
        "buggy": "Status RocksDBOptionsParser::EndSection(\n    const ConfigOptions& config_options, const OptionSection section,\n    const std::string& section_title, const std::string& section_arg,\n    const std::unordered_map<std::string, std::string>& opt_map) {\n  Status s;\n  if (section == kOptionSectionDBOptions) {\n    s = GetDBOptionsFromMap(config_options, DBOptions(), opt_map, &db_opt_);\n    if (!s.ok()) {\n      return s;\n    }\n    db_opt_map_ = opt_map;\n  } else if (section == kOptionSectionCFOptions) {\n    // This condition should be ensured earlier in ParseSection\n    // so we make an assertion here.\n    assert(GetCFOptions(section_arg) == nullptr);\n    cf_names_.emplace_back(section_arg);\n    cf_opts_.emplace_back();\n    s = GetColumnFamilyOptionsFromMap(config_options, ColumnFamilyOptions(),\n                                      opt_map, &cf_opts_.back());\n    if (!s.ok()) {\n      return s;\n    }\n    // keep the parsed string.\n    cf_opt_maps_.emplace_back(opt_map);\n  } else if (section == kOptionSectionTableOptions) {\n    assert(GetCFOptions(section_arg) != nullptr);\n    auto* cf_opt = GetCFOptionsImpl(section_arg);\n    if (cf_opt == nullptr) {\n      return Status::InvalidArgument(\n          \"The specified column family must be defined before the \"\n          \"TableOptions section:\",\n          section_arg);\n    }\n    // Ignore error as table factory deserialization is optional\n    s = TableFactory::CreateFromString(\n        config_options,\n        section_title.substr(\n            opt_section_titles[kOptionSectionTableOptions].size()),\n        &(cf_opt->table_factory));\n    if (s.ok()) {\n      s = cf_opt->table_factory->ConfigureFromMap(config_options, opt_map);\n      // Translate any errors (NotFound, NotSupported, to InvalidArgument\n      if (s.ok() || s.IsInvalidArgument()) {\n        return s;\n      } else {\n        return Status::InvalidArgument(s.getState());\n      }\n    } else {\n      // Return OK for not supported table factories as TableFactory\n      // Deserialization is optional.\n      cf_opt->table_factory.reset();\n      return Status::OK();\n    }\n  } else if (section == kOptionSectionVersion) {\n    for (const auto& pair : opt_map) {\n      if (pair.first == \"rocksdb_version\") {\n        s = ParseVersionNumber(pair.first, pair.second, 3, db_version);\n        if (!s.ok()) {\n          return s;\n        }\n      } else if (pair.first == \"options_file_version\") {\n        s = ParseVersionNumber(pair.first, pair.second, 2, opt_file_version);\n        if (!s.ok()) {\n          return s;\n        }\n        if (opt_file_version[0] < 1) {\n          return Status::InvalidArgument(\n              \"A valid options_file_version must be at least 1.\");\n        }\n      }\n    }\n  }\n  return s;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (s.ok()) {\n",
        "src_path": "1d2950b8dd38009d0719e4a857f5a42bb1bc9675___options_parser.cc",
        "uri": "https://api.github.com/repos/facebook/rocksdb/commits/1d2950b8dd38009d0719e4a857f5a42bb1bc9675",
        "commit_msg": "fix a false positive case of parsing table factory from options file (#10094)\n\nSummary:\nDuring options file parsing, reset table factory before attempting to parse it\nfrom string. This avoids mistakenly treating the default table factory as a\nnewly created one.\n\nSigned-off-by: tabokie <xy.tao@outlook.com>\n\nPull Request resolved: https://github.com/facebook/rocksdb/pull/10094\n\nReviewed By: akankshamahajan15\n\nDifferential Revision: D36945378\n\nPulled By: ajkr\n\nfbshipit-source-id: 94b2604e5e87682063b4b78f6370f3e8f101dc44",
        "test_func_diff": [
            {
                "fn": "options/options_test.cc",
                "patch": "@@ -47,6 +47,22 @@ namespace ROCKSDB_NAMESPACE {\n \n class OptionsTest : public testing::Test {};\n \n+class UnregisteredTableFactory : public TableFactory {\n+ public:\n+  UnregisteredTableFactory() {}\n+  const char* Name() const override { return \"Unregistered\"; }\n+  using TableFactory::NewTableReader;\n+  Status NewTableReader(const ReadOptions&, const TableReaderOptions&,\n+                        std::unique_ptr<RandomAccessFileReader>&&, uint64_t,\n+                        std::unique_ptr<TableReader>*, bool) const override {\n+    return Status::NotSupported();\n+  }\n+  TableBuilder* NewTableBuilder(const TableBuilderOptions&,\n+                                WritableFileWriter*) const override {\n+    return nullptr;\n+  }\n+};\n+\n #ifndef ROCKSDB_LITE  // GetOptionsFromMap is not supported in ROCKSDB_LITE\n TEST_F(OptionsTest, GetOptionsFromMapTest) {\n   std::unordered_map<std::string, std::string> cf_options_map = {\n@@ -3662,6 +3678,10 @@ TEST_F(OptionsParserTest, DumpAndParse) {\n       cf_opt.table_factory.reset(test::RandomTableFactory(&rnd, c));\n     } else if (c == 4) {\n       cf_opt.table_factory.reset(NewBlockBasedTableFactory(special_bbto));\n+    } else if (c == 5) {\n+      // A table factory that doesn't support deserialization should be\n+      // supported.\n+      cf_opt.table_factory.reset(new UnregisteredTableFactory());\n     }\n     base_cf_opts.emplace_back(cf_opt);\n   }"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/facebook___rocksdb/git_repo_dir_1d2950b8dd38009d0719e4a857f5a42bb1bc9675/build_1d2950b8dd38009d0719e4a857f5a42bb1bc9675\nTest project /out/facebook___rocksdb/git_repo_dir_1d2950b8dd38009d0719e4a857f5a42bb1bc9675/build_1d2950b8dd38009d0719e4a857f5a42bb1bc9675\n    Start 6305: OptionsParserTest.DumpAndParse\n1/1 Test #6305: OptionsParserTest.DumpAndParse ...***Failed    0.04 sec\n\u001b[0;33mNote: Google Test filter = OptionsParserTest.DumpAndParse\n\u001b[m\u001b[0;32m[==========] \u001b[mRunning 1 test from 1 test case.\n\u001b[0;32m[----------] \u001b[mGlobal test environment set-up.\n\u001b[0;32m[----------] \u001b[m1 test from OptionsParserTest\n\u001b[0;32m[ RUN      ] \u001b[mOptionsParserTest.DumpAndParse\n/out/facebook___rocksdb/git_repo_dir_1d2950b8dd38009d0719e4a857f5a42bb1bc9675/options/options_test.cc:3692: Failure\nPersistRocksDBOptions(base_db_opt, cf_names, base_cf_opts, kOptionsFileName, fs_.get())\nCorruption: [RocksDBOptionsParser]: failed the verification on TableFactory->Name()\n\u001b[0;31m[  FAILED  ] \u001b[mOptionsParserTest.DumpAndParse (21 ms)\n\u001b[0;32m[----------] \u001b[m1 test from OptionsParserTest (21 ms total)\n\n\u001b[0;32m[----------] \u001b[mGlobal test environment tear-down\n\u001b[0;32m[==========] \u001b[m1 test from 1 test case ran. (21 ms total)\n\u001b[0;32m[  PASSED  ] \u001b[m0 tests.\n\u001b[0;31m[  FAILED  ] \u001b[m1 test, listed below:\n\u001b[0;31m[  FAILED  ] \u001b[mOptionsParserTest.DumpAndParse\n\n 1 FAILED TEST\n\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.02 sec\n\nThe following tests FAILED:\n\t6305 - OptionsParserTest.DumpAndParse (Failed)\n"
    },
    "3367d5d13173664bc5018f5405adfa4d395c87ce___encoding.c": {
        "prefix": "",
        "suffix": "\n    uint8_t decode_value = BASE64_DECODING_TABLE[(size_t)to_decode];\n    if (decode_value != 0xDD && (decode_value != BASE64_SENTIANAL_VALUE || allow_sentinal)) {\n        *value = decode_value;\n        return AWS_OP_SUCCESS;\n    }\n\n    return AWS_OP_ERR;\n}\n",
        "start": 267,
        "end": 276,
        "buggy": "static inline int s_base64_get_decoded_value(char to_decode, uint8_t *value, int8_t allow_sentinal) {\n\n    uint8_t decode_value = BASE64_DECODING_TABLE[(size_t)to_decode];\n    if (decode_value != 0xDD && (decode_value != BASE64_SENTIANAL_VALUE || allow_sentinal)) {\n        *value = decode_value;\n        return AWS_OP_SUCCESS;\n    }\n\n    return AWS_OP_ERR;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "static inline int s_base64_get_decoded_value(char to_decode, uint8_t *value, int8_t allow_sentinal) {\n",
        "src_path": "3367d5d13173664bc5018f5405adfa4d395c87ce___encoding.c",
        "uri": "https://api.github.com/repos/awslabs/aws-c-common/commits/3367d5d13173664bc5018f5405adfa4d395c87ce",
        "commit_msg": "Fix buffer underrun in base64 encoder (#142)\n\nDue to a sign-extended character type bring used as the index for the base64 decoder table,\r\nthe base64 decoder could behave incorrectly (accepting invalid base64, etc) when presented\r\nwith \"base64\" input with characters over 0x80.",
        "test_func_diff": [
            {
                "fn": "tests/CMakeLists.txt",
                "patch": "@@ -87,6 +87,7 @@ add_test_case(hex_encoding_test_case_fooba_test)\n add_test_case(hex_encoding_test_case_foobar_test)\n add_test_case(hex_encoding_test_case_missing_leading_zero)\n add_test_case(hex_encoding_invalid_buffer_size_test)\n+add_test_case(hex_encoding_highbyte_string_test)\n add_test_case(hex_encoding_overflow_test)\n add_test_case(hex_encoding_invalid_string_test)\n add_test_case(base64_encoding_test_case_empty_test)\n@@ -100,6 +101,7 @@ add_test_case(base64_encoding_buffer_size_too_small_test)\n add_test_case(base64_encoding_buffer_size_overflow_test)\n add_test_case(base64_encoding_buffer_size_invalid_test)\n add_test_case(base64_encoding_invalid_buffer_test)\n+add_test_case(base64_encoding_highbyte_string_test)\n add_test_case(base64_encoding_invalid_padding_test)\n add_test_case(base64_encoding_test_zeros)\n add_test_case(base64_encoding_test_all_values)"
            },
            {
                "fn": "tests/encoding_test.c",
                "patch": "@@ -213,6 +213,22 @@ static int s_hex_encoding_invalid_buffer_size_test_fn(struct aws_allocator *allo\n \n AWS_TEST_CASE(hex_encoding_invalid_buffer_size_test, s_hex_encoding_invalid_buffer_size_test_fn)\n \n+static int s_hex_encoding_highbyte_string_test_fn(struct aws_allocator *allocator, void *ctx) {\n+    (void)allocator;\n+    (void)ctx;\n+\n+    char bad_input[] = \"66\\xb6\\xb6\"\n+                       \"6f6f6617\";\n+    uint8_t output[sizeof(bad_input)] = {0};\n+\n+    struct aws_byte_buf bad_buf = aws_byte_buf_from_c_str(bad_input);\n+    struct aws_byte_buf output_buf = aws_byte_buf_from_array(output, sizeof(output));\n+\n+    ASSERT_ERROR(AWS_ERROR_INVALID_HEX_STR, aws_hex_decode(&bad_buf, &output_buf));\n+    return 0;\n+}\n+AWS_TEST_CASE(hex_encoding_highbyte_string_test, s_hex_encoding_highbyte_string_test_fn)\n+\n static int s_hex_encoding_overflow_test_fn(struct aws_allocator *allocator, void *ctx) {\n     (void)allocator;\n     (void)ctx;\n@@ -537,6 +553,22 @@ static int s_base64_encoding_invalid_buffer_test_fn(struct aws_allocator *alloca\n \n AWS_TEST_CASE(base64_encoding_invalid_buffer_test, s_base64_encoding_invalid_buffer_test_fn)\n \n+static int s_base64_encoding_highbyte_string_test_fn(struct aws_allocator *allocator, void *ctx) {\n+    (void)allocator;\n+    (void)ctx;\n+\n+    char bad_input[] = \"AAAA\\xC1\"\n+                       \"AAA\";\n+    uint8_t output[sizeof(bad_input)] = {0};\n+\n+    struct aws_byte_buf bad_buf = aws_byte_buf_from_c_str(bad_input);\n+    struct aws_byte_buf output_buf = aws_byte_buf_from_array(output, sizeof(output));\n+\n+    ASSERT_ERROR(AWS_ERROR_INVALID_BASE64_STR, aws_base64_decode(&bad_buf, &output_buf));\n+    return 0;\n+}\n+AWS_TEST_CASE(base64_encoding_highbyte_string_test, s_base64_encoding_highbyte_string_test_fn)\n+\n static int s_base64_encoding_invalid_padding_test_fn(struct aws_allocator *allocator, void *ctx) {\n     (void)allocator;\n     (void)ctx;"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/awslabs___aws-c-common/git_repo_dir_3367d5d13173664bc5018f5405adfa4d395c87ce/build_3367d5d13173664bc5018f5405adfa4d395c87ce\nTest project /out/awslabs___aws-c-common/git_repo_dir_3367d5d13173664bc5018f5405adfa4d395c87ce/build_3367d5d13173664bc5018f5405adfa4d395c87ce\n    Start 73: base64_encoding_highbyte_string_test\n1/1 Test #73: base64_encoding_highbyte_string_test ...***Failed    0.00 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.01 sec\n\nThe following tests FAILED:\n\t 73 - base64_encoding_highbyte_string_test (Failed)\n"
    },
    "445027a5dcfe0acce431b7d4065d2ac1f6b270d7___event.c": {
        "prefix": "static int\nevent_process_active_single_queue(struct event_base *base,\n    struct evcallback_list *activeq,\n    int max_to_process, const struct timeval *endtime)\n{\n\tstruct event_callback *evcb;\n\tint count = 0;\n\n\tEVUTIL_ASSERT(activeq != NULL);\n\n\tfor (evcb = TAILQ_FIRST(activeq); evcb; evcb = TAILQ_FIRST(activeq)) {\n\t\tstruct event *ev=NULL;\n\t\tif (evcb->evcb_flags & EVLIST_INIT) {\n\t\t\tev = event_callback_to_event(evcb);\n\n\t\t\tif (ev->ev_events & EV_PERSIST || ev->ev_flags & EVLIST_FINALIZING)\n\t\t\t\tevent_queue_remove_active(base, evcb);\n\t\t\telse\n\t\t\t\tevent_del_nolock_(ev, EVENT_DEL_NOBLOCK);\n\t\t\tevent_debug((\n\t\t\t    \"event_process_active: event: %p, %s%s%scall %p\",\n\t\t\t    ev,\n\t\t\t    ev->ev_res & EV_READ ? \"EV_READ \" : \" \",\n\t\t\t    ev->ev_res & EV_WRITE ? \"EV_WRITE \" : \" \",\n\t\t\t    ev->ev_res & EV_CLOSED ? \"EV_CLOSED \" : \" \",\n\t\t\t    ev->ev_callback));\n\t\t} else {\n\t\t\tevent_queue_remove_active(base, evcb);\n\t\t\tevent_debug((\"event_process_active: event_callback %p, \"\n\t\t\t\t\"closure %d, call %p\",\n\t\t\t\tevcb, evcb->evcb_closure, evcb->evcb_cb_union.evcb_callback));\n\t\t}\n\n\t\tif (!(evcb->evcb_flags & EVLIST_INTERNAL))\n\t\t\t++count;\n\n\n\t\tbase->current_event = evcb;\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\t\tbase->current_event_waiters = 0;\n#endif\n\n\t\tswitch (evcb->evcb_closure) {\n\t\tcase EV_CLOSURE_EVENT_SIGNAL:\n\t\t\tEVUTIL_ASSERT(ev != NULL);\n\t\t\tevent_signal_closure(base, ev);\n\t\t\tbreak;\n\t\tcase EV_CLOSURE_EVENT_PERSIST:\n\t\t\tEVUTIL_ASSERT(ev != NULL);\n\t\t\tevent_persist_closure(base, ev);\n\t\t\tbreak;\n\t\tcase EV_CLOSURE_EVENT: {\n\t\t\tvoid (*evcb_callback)(evutil_socket_t, short, void *);\n\t\t\tshort res;\n\t\t\tEVUTIL_ASSERT(ev != NULL);\n\t\t\tevcb_callback = *ev->ev_callback;\n\t\t\tres = ev->ev_res;\n\t\t\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n\t\t\tevcb_callback(ev->ev_fd, res, ev->ev_arg);\n\t\t}\n\t\tbreak;\n\t\tcase EV_CLOSURE_CB_SELF: {\n\t\t\tvoid (*evcb_selfcb)(struct event_callback *, void *) = evcb->evcb_cb_union.evcb_selfcb;\n\t\t\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n\t\t\tevcb_selfcb(evcb, evcb->evcb_arg);\n\t\t}\n\t\tbreak;\n\t\tcase EV_CLOSURE_EVENT_FINALIZE:\n\t\tcase EV_CLOSURE_EVENT_FINALIZE_FREE: {\n\t\t\tvoid (*evcb_evfinalize)(struct event *, void *);\n\t\t\tint evcb_closure = evcb->evcb_closure;\n\t\t\tEVUTIL_ASSERT(ev != NULL);\n\t\t\tbase->current_event = NULL;\n\t\t\tevcb_evfinalize = ev->ev_evcallback.evcb_cb_union.evcb_evfinalize;\n\t\t\tEVUTIL_ASSERT((evcb->evcb_flags & EVLIST_FINALIZING));\n\t\t\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n",
        "suffix": "\t\t\tevent_debug_note_teardown_(ev);\n\t\t\tif (evcb_closure == EV_CLOSURE_EVENT_FINALIZE_FREE)\n\t\t\t\tmm_free(ev);\n\t\t}\n\t\tbreak;\n\t\tcase EV_CLOSURE_CB_FINALIZE: {\n\t\t\tvoid (*evcb_cbfinalize)(struct event_callback *, void *) = evcb->evcb_cb_union.evcb_cbfinalize;\n\t\t\tbase->current_event = NULL;\n\t\t\tEVUTIL_ASSERT((evcb->evcb_flags & EVLIST_FINALIZING));\n\t\t\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n\t\t\tevcb_cbfinalize(evcb, evcb->evcb_arg);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\tEVUTIL_ASSERT(0);\n\t\t}\n\n\t\tEVBASE_ACQUIRE_LOCK(base, th_base_lock);\n\t\tbase->current_event = NULL;\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\t\tif (base->current_event_waiters) {\n\t\t\tbase->current_event_waiters = 0;\n\t\t\tEVTHREAD_COND_BROADCAST(base->current_event_cond);\n\t\t}\n#endif\n\n\t\tif (base->event_break)\n\t\t\treturn -1;\n\t\tif (count >= max_to_process)\n\t\t\treturn count;\n\t\tif (count && endtime) {\n\t\t\tstruct timeval now;\n\t\t\tupdate_time_cache(base);\n\t\t\tgettime(base, &now);\n\t\t\tif (evutil_timercmp(&now, endtime, >=))\n\t\t\t\treturn count;\n\t\t}\n\t\tif (base->event_continue)\n\t\t\tbreak;\n\t}\n\treturn count;\n}\n",
        "start": 1655,
        "end": 1773,
        "buggy": "static int\nevent_process_active_single_queue(struct event_base *base,\n    struct evcallback_list *activeq,\n    int max_to_process, const struct timeval *endtime)\n{\n\tstruct event_callback *evcb;\n\tint count = 0;\n\n\tEVUTIL_ASSERT(activeq != NULL);\n\n\tfor (evcb = TAILQ_FIRST(activeq); evcb; evcb = TAILQ_FIRST(activeq)) {\n\t\tstruct event *ev=NULL;\n\t\tif (evcb->evcb_flags & EVLIST_INIT) {\n\t\t\tev = event_callback_to_event(evcb);\n\n\t\t\tif (ev->ev_events & EV_PERSIST || ev->ev_flags & EVLIST_FINALIZING)\n\t\t\t\tevent_queue_remove_active(base, evcb);\n\t\t\telse\n\t\t\t\tevent_del_nolock_(ev, EVENT_DEL_NOBLOCK);\n\t\t\tevent_debug((\n\t\t\t    \"event_process_active: event: %p, %s%s%scall %p\",\n\t\t\t    ev,\n\t\t\t    ev->ev_res & EV_READ ? \"EV_READ \" : \" \",\n\t\t\t    ev->ev_res & EV_WRITE ? \"EV_WRITE \" : \" \",\n\t\t\t    ev->ev_res & EV_CLOSED ? \"EV_CLOSED \" : \" \",\n\t\t\t    ev->ev_callback));\n\t\t} else {\n\t\t\tevent_queue_remove_active(base, evcb);\n\t\t\tevent_debug((\"event_process_active: event_callback %p, \"\n\t\t\t\t\"closure %d, call %p\",\n\t\t\t\tevcb, evcb->evcb_closure, evcb->evcb_cb_union.evcb_callback));\n\t\t}\n\n\t\tif (!(evcb->evcb_flags & EVLIST_INTERNAL))\n\t\t\t++count;\n\n\n\t\tbase->current_event = evcb;\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\t\tbase->current_event_waiters = 0;\n#endif\n\n\t\tswitch (evcb->evcb_closure) {\n\t\tcase EV_CLOSURE_EVENT_SIGNAL:\n\t\t\tEVUTIL_ASSERT(ev != NULL);\n\t\t\tevent_signal_closure(base, ev);\n\t\t\tbreak;\n\t\tcase EV_CLOSURE_EVENT_PERSIST:\n\t\t\tEVUTIL_ASSERT(ev != NULL);\n\t\t\tevent_persist_closure(base, ev);\n\t\t\tbreak;\n\t\tcase EV_CLOSURE_EVENT: {\n\t\t\tvoid (*evcb_callback)(evutil_socket_t, short, void *);\n\t\t\tshort res;\n\t\t\tEVUTIL_ASSERT(ev != NULL);\n\t\t\tevcb_callback = *ev->ev_callback;\n\t\t\tres = ev->ev_res;\n\t\t\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n\t\t\tevcb_callback(ev->ev_fd, res, ev->ev_arg);\n\t\t}\n\t\tbreak;\n\t\tcase EV_CLOSURE_CB_SELF: {\n\t\t\tvoid (*evcb_selfcb)(struct event_callback *, void *) = evcb->evcb_cb_union.evcb_selfcb;\n\t\t\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n\t\t\tevcb_selfcb(evcb, evcb->evcb_arg);\n\t\t}\n\t\tbreak;\n\t\tcase EV_CLOSURE_EVENT_FINALIZE:\n\t\tcase EV_CLOSURE_EVENT_FINALIZE_FREE: {\n\t\t\tvoid (*evcb_evfinalize)(struct event *, void *);\n\t\t\tint evcb_closure = evcb->evcb_closure;\n\t\t\tEVUTIL_ASSERT(ev != NULL);\n\t\t\tbase->current_event = NULL;\n\t\t\tevcb_evfinalize = ev->ev_evcallback.evcb_cb_union.evcb_evfinalize;\n\t\t\tEVUTIL_ASSERT((evcb->evcb_flags & EVLIST_FINALIZING));\n\t\t\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n\t\t\tevcb_evfinalize(ev, ev->ev_arg);\n\t\t\tevent_debug_note_teardown_(ev);\n\t\t\tif (evcb_closure == EV_CLOSURE_EVENT_FINALIZE_FREE)\n\t\t\t\tmm_free(ev);\n\t\t}\n\t\tbreak;\n\t\tcase EV_CLOSURE_CB_FINALIZE: {\n\t\t\tvoid (*evcb_cbfinalize)(struct event_callback *, void *) = evcb->evcb_cb_union.evcb_cbfinalize;\n\t\t\tbase->current_event = NULL;\n\t\t\tEVUTIL_ASSERT((evcb->evcb_flags & EVLIST_FINALIZING));\n\t\t\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n\t\t\tevcb_cbfinalize(evcb, evcb->evcb_arg);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\tEVUTIL_ASSERT(0);\n\t\t}\n\n\t\tEVBASE_ACQUIRE_LOCK(base, th_base_lock);\n\t\tbase->current_event = NULL;\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\t\tif (base->current_event_waiters) {\n\t\t\tbase->current_event_waiters = 0;\n\t\t\tEVTHREAD_COND_BROADCAST(base->current_event_cond);\n\t\t}\n#endif\n\n\t\tif (base->event_break)\n\t\t\treturn -1;\n\t\tif (count >= max_to_process)\n\t\t\treturn count;\n\t\tif (count && endtime) {\n\t\t\tstruct timeval now;\n\t\t\tupdate_time_cache(base);\n\t\t\tgettime(base, &now);\n\t\t\tif (evutil_timercmp(&now, endtime, >=))\n\t\t\t\treturn count;\n\t\t}\n\t\tif (base->event_continue)\n\t\t\tbreak;\n\t}\n\treturn count;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tevcb_evfinalize(ev, ev->ev_arg);\n",
        "src_path": "445027a5dcfe0acce431b7d4065d2ac1f6b270d7___event.c",
        "uri": "https://api.github.com/repos/libevent/libevent/commits/445027a5dcfe0acce431b7d4065d2ac1f6b270d7",
        "commit_msg": "Fix memory corruption in EV_CLOSURE_EVENT_FINALIZE with debug enabled\n\nCall event_debug_note_teardown_ before evcb_evfinalize to avoid possible\nUAF (if finalizer free's event).",
        "test_func_diff": [
            {
                "fn": "test/regress_finalize.c",
                "patch": "@@ -290,6 +290,53 @@ test_fin_within_cb(void *arg)\n \t;\n }\n \n+static void\n+event_finalize_callback_free(struct event *ev, void *arg)\n+{\n+\tstruct event_base *base = arg;\n+\tint err;\n+\tif (base) {\n+\t\terr = event_assign(ev, base, -1, EV_TIMEOUT, NULL, NULL);\n+\t\ttt_int_op(err, ==, 0);\n+\t\ttest_ok += 1;\n+\t} else {\n+\t\tfree(ev);\n+\t\ttest_ok += 1;\n+\t}\n+\n+end:\n+\t;\n+}\n+static void\n+test_fin_debug_use_after_free(void *arg)\n+{\n+\tstruct basic_test_data *data = arg;\n+\tstruct event_base *base = data->base;\n+\tstruct event *ev;\n+\n+\ttt_ptr_op(ev = event_new(base, -1, EV_TIMEOUT, NULL, base), !=, NULL);\n+\ttt_int_op(event_add(ev, NULL), ==, 0);\n+\ttt_int_op(event_finalize(0, ev, event_finalize_callback_free), ==, 0);\n+\n+\t// Dispatch base to trigger callbacks\n+\tevent_base_dispatch(base);\n+\tevent_base_assert_ok_(base);\n+\ttt_int_op(test_ok, ==, 1);\n+\n+\t// Now add again, since we did event_assign in event_finalize_callback_free\n+\t// This used to fail in event_debug_assert_is_setup_\n+\ttt_int_op(event_add(ev, NULL), ==, 0);\n+\n+\t// Finalize and dispatch again\n+\ttt_int_op(event_finalize(0, ev, event_finalize_callback_free), ==, 0);\n+\tevent_base_dispatch(base);\n+\tevent_base_assert_ok_(base);\n+\ttt_int_op(test_ok, ==, 2);\n+\n+end:\n+\t;\n+}\n+\n #if 0\n static void\n timer_callback_3(evutil_socket_t *fd, short what, void *arg)\n@@ -339,6 +386,7 @@ struct testcase_t finalize_testcases[] = {\n \tTEST(cb_invoked, TT_FORK|TT_NEED_BASE),\n \tTEST(free_finalize, TT_FORK),\n \tTEST(within_cb, TT_FORK|TT_NEED_BASE),\n+\tTEST(debug_use_after_free, TT_FORK|TT_NEED_BASE|TT_ENABLE_DEBUG_MODE),\n //\tTEST(many, TT_FORK|TT_NEED_BASE),\n \n "
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/libevent___libevent/git_repo_dir_445027a5dcfe0acce431b7d4065d2ac1f6b270d7/build_445027a5dcfe0acce431b7d4065d2ac1f6b270d7\nTest project /out/libevent___libevent/git_repo_dir_445027a5dcfe0acce431b7d4065d2ac1f6b270d7/build_445027a5dcfe0acce431b7d4065d2ac1f6b270d7\n      Start  8: regress__timerfd_EPOLL\n 1/10 Test  #8: regress__timerfd_EPOLL ....................***Failed   91.50 sec\n      Start  9: regress__timerfd_EPOLL_debug\n 2/10 Test  #9: regress__timerfd_EPOLL_debug ..............***Failed   92.80 sec\n      Start 17: regress__changelist_EPOLL\n 3/10 Test #17: regress__changelist_EPOLL .................***Failed   92.28 sec\n      Start 18: regress__changelist_EPOLL_debug\n 4/10 Test #18: regress__changelist_EPOLL_debug ...........***Failed   91.28 sec\n      Start 26: regress__timerfd_changelist_EPOLL\n 5/10 Test #26: regress__timerfd_changelist_EPOLL .........***Failed   89.68 sec\n      Start 27: regress__timerfd_changelist_EPOLL_debug\n 6/10 Test #27: regress__timerfd_changelist_EPOLL_debug ...***Failed   88.88 sec\n      Start 35: regress__SELECT\n 7/10 Test #35: regress__SELECT ...........................***Failed   89.06 sec\n      Start 36: regress__SELECT_debug\n 8/10 Test #36: regress__SELECT_debug .....................***Failed   89.13 sec\n      Start 44: regress__POLL\n 9/10 Test #44: regress__POLL .............................***Failed   91.51 sec\n      Start 45: regress__POLL_debug\n10/10 Test #45: regress__POLL_debug .......................***Failed   91.51 sec\n\n0% tests passed, 10 tests failed out of 10\n\nTotal Test time (real) = 907.66 sec\n\nThe following tests FAILED:\n\t  8 - regress__timerfd_EPOLL (Failed)\n\t  9 - regress__timerfd_EPOLL_debug (Failed)\n\t 17 - regress__changelist_EPOLL (Failed)\n\t 18 - regress__changelist_EPOLL_debug (Failed)\n\t 26 - regress__timerfd_changelist_EPOLL (Failed)\n\t 27 - regress__timerfd_changelist_EPOLL_debug (Failed)\n\t 35 - regress__SELECT (Failed)\n\t 36 - regress__SELECT_debug (Failed)\n\t 44 - regress__POLL (Failed)\n\t 45 - regress__POLL_debug"
    },
    "972b456bf60e9a2f550ec45a14921c06e252c793___epoll.c": {
        "prefix": "static int\nepoll_dispatch(struct event_base *base, struct timeval *tv)\n{\n\tstruct epollop *epollop = base->evbase;\n\tstruct epoll_event *events = epollop->events;\n\tint i, res;\n\tlong timeout = -1;\n\n#ifdef USING_TIMERFD\n\tif (epollop->timerfd >= 0) {\n\t\tstruct itimerspec is;\n\t\tis.it_interval.tv_sec = 0;\n\t\tis.it_interval.tv_nsec = 0;\n\t\tif (tv == NULL) {\n\t\t\t/* No timeout; disarm the timer. */\n\t\t\tis.it_value.tv_sec = 0;\n\t\t\tis.it_value.tv_nsec = 0;\n\t\t} else {\n\t\t\tif (tv->tv_sec == 0 && tv->tv_usec == 0) {\n\t\t\t\t/* we need to exit immediately; timerfd can't\n\t\t\t\t * do that. */\n\t\t\t\ttimeout = 0;\n\t\t\t}\n\t\t\tis.it_value.tv_sec = tv->tv_sec;\n\t\t\tis.it_value.tv_nsec = tv->tv_usec * 1000;\n\t\t}\n\t\t/* TODO: we could avoid unnecessary syscalls here by only\n\t\t   calling timerfd_settime when the top timeout changes, or\n\t\t   when we're called with a different timeval.\n\t\t*/\n\t\tif (timerfd_settime(epollop->timerfd, 0, &is, NULL) < 0) {\n\t\t\tevent_warn(\"timerfd_settime\");\n\t\t}\n\t} else\n#endif\n\tif (tv != NULL) {\n\t\ttimeout = evutil_tv_to_msec_(tv);\n\t\tif (timeout < 0 || timeout > MAX_EPOLL_TIMEOUT_MSEC) {\n\t\t\t/* Linux kernels can wait forever if the timeout is\n\t\t\t * too big; see comment on MAX_EPOLL_TIMEOUT_MSEC. */\n\t\t\ttimeout = MAX_EPOLL_TIMEOUT_MSEC;\n\t\t}\n\t}\n\n\tepoll_apply_changes(base);\n\tevent_changelist_remove_all_(&base->changelist, base);\n\n\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n\n\tres = epoll_wait(epollop->epfd, events, epollop->nevents, timeout);\n\n\tEVBASE_ACQUIRE_LOCK(base, th_base_lock);\n\n\tif (res == -1) {\n\t\tif (errno != EINTR) {\n\t\t\tevent_warn(\"epoll_wait\");\n\t\t\treturn (-1);\n\t\t}\n\n\t\treturn (0);\n\t}\n\n\tevent_debug((\"%s: epoll_wait reports %d\", __func__, res));\n\tEVUTIL_ASSERT(res <= epollop->nevents);\n\n\tfor (i = 0; i < res; i++) {\n\t\tint what = events[i].events;\n\t\tshort ev = 0;\n#ifdef USING_TIMERFD\n\t\tif (events[i].data.fd == epollop->timerfd)\n\t\t\tcontinue;\n#endif\n\n",
        "suffix": "\t\t\tev = EV_READ | EV_WRITE;\n\t\t} else {\n\t\t\tif (what & EPOLLIN)\n\t\t\t\tev |= EV_READ;\n\t\t\tif (what & EPOLLOUT)\n\t\t\t\tev |= EV_WRITE;\n\t\t\tif (what & EPOLLRDHUP)\n\t\t\t\tev |= EV_CLOSED;\n\t\t}\n\n\t\tif (!ev)\n\t\t\tcontinue;\n\n\t\tevmap_io_active_(base, events[i].data.fd, ev | EV_ET);\n\t}\n\n\tif (res == epollop->nevents && epollop->nevents < MAX_NEVENT) {\n\t\t/* We used all of the event space this time.  We should\n\t\t   be ready for more events next time. */\n\t\tint new_nevents = epollop->nevents * 2;\n\t\tstruct epoll_event *new_events;\n\n\t\tnew_events = mm_realloc(epollop->events,\n\t\t    new_nevents * sizeof(struct epoll_event));\n\t\tif (new_events) {\n\t\t\tepollop->events = new_events;\n\t\t\tepollop->nevents = new_nevents;\n\t\t}\n\t}\n\n\treturn (0);\n}\n",
        "start": 417,
        "end": 522,
        "buggy": "static int\nepoll_dispatch(struct event_base *base, struct timeval *tv)\n{\n\tstruct epollop *epollop = base->evbase;\n\tstruct epoll_event *events = epollop->events;\n\tint i, res;\n\tlong timeout = -1;\n\n#ifdef USING_TIMERFD\n\tif (epollop->timerfd >= 0) {\n\t\tstruct itimerspec is;\n\t\tis.it_interval.tv_sec = 0;\n\t\tis.it_interval.tv_nsec = 0;\n\t\tif (tv == NULL) {\n\t\t\t/* No timeout; disarm the timer. */\n\t\t\tis.it_value.tv_sec = 0;\n\t\t\tis.it_value.tv_nsec = 0;\n\t\t} else {\n\t\t\tif (tv->tv_sec == 0 && tv->tv_usec == 0) {\n\t\t\t\t/* we need to exit immediately; timerfd can't\n\t\t\t\t * do that. */\n\t\t\t\ttimeout = 0;\n\t\t\t}\n\t\t\tis.it_value.tv_sec = tv->tv_sec;\n\t\t\tis.it_value.tv_nsec = tv->tv_usec * 1000;\n\t\t}\n\t\t/* TODO: we could avoid unnecessary syscalls here by only\n\t\t   calling timerfd_settime when the top timeout changes, or\n\t\t   when we're called with a different timeval.\n\t\t*/\n\t\tif (timerfd_settime(epollop->timerfd, 0, &is, NULL) < 0) {\n\t\t\tevent_warn(\"timerfd_settime\");\n\t\t}\n\t} else\n#endif\n\tif (tv != NULL) {\n\t\ttimeout = evutil_tv_to_msec_(tv);\n\t\tif (timeout < 0 || timeout > MAX_EPOLL_TIMEOUT_MSEC) {\n\t\t\t/* Linux kernels can wait forever if the timeout is\n\t\t\t * too big; see comment on MAX_EPOLL_TIMEOUT_MSEC. */\n\t\t\ttimeout = MAX_EPOLL_TIMEOUT_MSEC;\n\t\t}\n\t}\n\n\tepoll_apply_changes(base);\n\tevent_changelist_remove_all_(&base->changelist, base);\n\n\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n\n\tres = epoll_wait(epollop->epfd, events, epollop->nevents, timeout);\n\n\tEVBASE_ACQUIRE_LOCK(base, th_base_lock);\n\n\tif (res == -1) {\n\t\tif (errno != EINTR) {\n\t\t\tevent_warn(\"epoll_wait\");\n\t\t\treturn (-1);\n\t\t}\n\n\t\treturn (0);\n\t}\n\n\tevent_debug((\"%s: epoll_wait reports %d\", __func__, res));\n\tEVUTIL_ASSERT(res <= epollop->nevents);\n\n\tfor (i = 0; i < res; i++) {\n\t\tint what = events[i].events;\n\t\tshort ev = 0;\n#ifdef USING_TIMERFD\n\t\tif (events[i].data.fd == epollop->timerfd)\n\t\t\tcontinue;\n#endif\n\n\t\tif (what & (EPOLLHUP|EPOLLERR)) {\n\t\t\tev = EV_READ | EV_WRITE;\n\t\t} else {\n\t\t\tif (what & EPOLLIN)\n\t\t\t\tev |= EV_READ;\n\t\t\tif (what & EPOLLOUT)\n\t\t\t\tev |= EV_WRITE;\n\t\t\tif (what & EPOLLRDHUP)\n\t\t\t\tev |= EV_CLOSED;\n\t\t}\n\n\t\tif (!ev)\n\t\t\tcontinue;\n\n\t\tevmap_io_active_(base, events[i].data.fd, ev | EV_ET);\n\t}\n\n\tif (res == epollop->nevents && epollop->nevents < MAX_NEVENT) {\n\t\t/* We used all of the event space this time.  We should\n\t\t   be ready for more events next time. */\n\t\tint new_nevents = epollop->nevents * 2;\n\t\tstruct epoll_event *new_events;\n\n\t\tnew_events = mm_realloc(epollop->events,\n\t\t    new_nevents * sizeof(struct epoll_event));\n\t\tif (new_events) {\n\t\t\tepollop->events = new_events;\n\t\t\tepollop->nevents = new_nevents;\n\t\t}\n\t}\n\n\treturn (0);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\tif (what & (EPOLLHUP|EPOLLERR)) {\n",
        "src_path": "972b456bf60e9a2f550ec45a14921c06e252c793___epoll.c",
        "uri": "https://api.github.com/repos/libevent/libevent/commits/972b456bf60e9a2f550ec45a14921c06e252c793",
        "commit_msg": "Fix EV_CLOSED detection/reporting (epoll only)\n\n- EV_CLOSED is EPOLLRDHUP in epoll\n- EPOLLRDHUP reported w/o EPOLLHUP if the socket closed with shutdown(SHUT_WR)\n- EPOLLRDHUP reported w/  EPOLLHUP if the socket closed with close()\n  so in this case epoll backend will detect this event as error\n  (EV_READ|EV_WRITE), since the epoll_ctl() will return EPOLLRDHUP with\n  EPOLLHUP set, but this is not correct, let's fix this.\n\nFixes: #984",
        "test_func_diff": [
            {
                "fn": "test/regress.c",
                "patch": "@@ -512,13 +512,8 @@ test_simpleclose(void *ptr)\n \t\ttt_assert(!event_base_loopexit(base, &tv));\n \t}\n \n-\t/* via close() */\n-\tif (pair[1] == -1) {\n-\t\ttt_int_op(event_base_loop(base, EVLOOP_NONBLOCK), ==, 0);\n-\t} else {\n-\t\ttt_int_op(event_base_loop(base, EVLOOP_NONBLOCK), ==, !persist);\n-\t\ttt_int_op(got_event, ==, (events & ~EV_PERSIST));\n-\t}\n+\ttt_int_op(event_base_loop(base, EVLOOP_NONBLOCK), ==, !persist);\n+\ttt_int_op(got_event, ==, (events & ~EV_PERSIST));\n \n end:\n \tif (ev)"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/libevent___libevent/git_repo_dir_972b456bf60e9a2f550ec45a14921c06e252c793/build_972b456bf60e9a2f550ec45a14921c06e252c793\nTest project /out/libevent___libevent/git_repo_dir_972b456bf60e9a2f550ec45a14921c06e252c793/build_972b456bf60e9a2f550ec45a14921c06e252c793\n    Start  9: regress__timerfd_EPOLL\n1/6 Test  #9: regress__timerfd_EPOLL ....................***Failed   93.38 sec\n    Start 10: regress__timerfd_EPOLL_debug\n2/6 Test #10: regress__timerfd_EPOLL_debug ..............***Failed   95.12 sec\n    Start 19: regress__changelist_EPOLL\n3/6 Test #19: regress__changelist_EPOLL .................***Failed   94.78 sec\n    Start 20: regress__changelist_EPOLL_debug\n4/6 Test #20: regress__changelist_EPOLL_debug ...........***Failed   95.68 sec\n    Start 29: regress__timerfd_changelist_EPOLL\n5/6 Test #29: regress__timerfd_changelist_EPOLL .........***Failed   93.83 sec\n    Start 30: regress__timerfd_changelist_EPOLL_debug\n6/6 Test #30: regress__timerfd_changelist_EPOLL_debug ...***Failed   92.92 sec\n\n0% tests passed, 6 tests failed out of 6\n\nTotal Test time (real) = 565.72 sec\n\nThe following tests FAILED:\n\t  9 - regress__timerfd_EPOLL (Failed)\n\t 10 - regress__timerfd_EPOLL_debug (Failed)\n\t 19 - regress__changelist_EPOLL (Failed)\n\t 20 - regress__changelist_EPOLL_debug (Failed)\n\t 29 - regress__timerfd_changelist_EPOLL (Failed)\n\t 30 - regress__timerfd_changelist_EPOLL_debug (Failed)\n"
    },
    "eea4a54f66a36137f4204876a68e6d5ed913cbc5___adapter.cc": {
        "prefix": "  Status SelectIndices(liborc::RowReaderOptions* opts,\n                       const std::vector<int>& include_indices) {\n    std::list<uint64_t> include_indices_list;\n    for (auto it = include_indices.begin(); it != include_indices.end(); ++it) {\n      ARROW_RETURN_IF(*it < 0, Status::Invalid(\"Negative field index\"));\n      include_indices_list.push_back(*it);\n    }\n",
        "suffix": "    return Status::OK();\n  }\n",
        "start": 407,
        "end": 416,
        "buggy": "  Status SelectIndices(liborc::RowReaderOptions* opts,\n                       const std::vector<int>& include_indices) {\n    std::list<uint64_t> include_indices_list;\n    for (auto it = include_indices.begin(); it != include_indices.end(); ++it) {\n      ARROW_RETURN_IF(*it < 0, Status::Invalid(\"Negative field index\"));\n      include_indices_list.push_back(*it);\n    }\n    opts->includeTypes(include_indices_list);\n    return Status::OK();\n  }\n",
        "fix": null,
        "buggy_hunk_masked": "    opts->includeTypes(include_indices_list);\n",
        "src_path": "eea4a54f66a36137f4204876a68e6d5ed913cbc5___adapter.cc",
        "uri": "https://api.github.com/repos/apache/arrow/commits/eea4a54f66a36137f4204876a68e6d5ed913cbc5",
        "commit_msg": "ARROW-17524: [C++] Correction for fields included when reading an ORC table (#13962)\n\nI think there is a bug in the ORC reader : when we specify the fields indexes that we want to keep, it does not work correctly. Looking at the code, it seems to be because we do \"includeTypes\" in lieue of \"include\" when setting the ORC options.\r\nIt can be problematic when we want to import an ORC table containing Union types as it will do an error at the import, even if we try not to import these specific fields.\r\n\r\nThe definitions of the corresponding ORC methods are here : \r\nhttps://github.com/apache/orc/blob/72220851cbde164a22706f8d47741fd1ad3db190/c%2B%2B/src/Options.hh#L185-L191\r\n\r\nand \r\nhttps://github.com/apache/orc/blob/72220851cbde164a22706f8d47741fd1ad3db190/c%2B%2B/src/Options.hh#L201-L207\n\nLead-authored-by: LouisClt <louis1110@hotmail.fr>\nCo-authored-by: Antoine Pitrou <antoine@python.org>\nCo-authored-by: Antoine Pitrou <pitrou@free.fr>\nSigned-off-by: Antoine Pitrou <antoine@python.org>",
        "test_func_diff": [
            {
                "fn": "c_glib/test/test-orc-file-reader.rb",
                "patch": "@@ -185,8 +185,8 @@ def all_columns\n     test(\"select fields\") do\n       require_gi_bindings(3, 2, 6)\n       @reader.field_indices = [1, 3]\n-      assert_equal(build_table(\"boolean1\" => build_boolean_array([false, true]),\n-                               \"short1\" => build_int16_array([1024, 2048])),\n+      assert_equal(build_table(\"byte1\" => build_int8_array([1, 100]),\n+                               \"int1\" => build_int32_array([65536, 65536])),\n                    @reader.read_stripes)\n     end\n   end\n@@ -200,10 +200,8 @@ def all_columns\n     test(\"select fields\") do\n       require_gi_bindings(3, 2, 6)\n       @reader.field_indices = [1, 3]\n-      boolean1 = build_boolean_array([false, true])\n-      short1 = build_int16_array([1024, 2048])\n-      assert_equal(build_record_batch(\"boolean1\" => boolean1,\n-                                      \"short1\" => short1),\n+      assert_equal(build_record_batch(\"byte1\" => build_int8_array([1, 100]),\n+                                      \"int1\" => build_int32_array([65536, 65536])),\n                    @reader.read_stripe(0))\n     end\n   end"
            },
            {
                "fn": "cpp/src/arrow/adapters/orc/adapter_test.cc",
                "patch": "@@ -226,7 +226,8 @@ std::shared_ptr<Table> GenerateRandomTable(const std::shared_ptr<Schema>& schema\n \n void AssertTableWriteReadEqual(const std::shared_ptr<Table>& input_table,\n                                const std::shared_ptr<Table>& expected_output_table,\n-                               const int64_t max_size = kDefaultSmallMemStreamSize) {\n+                               const int64_t max_size = kDefaultSmallMemStreamSize,\n+                               std::vector<int>* opt_selected_read_indices = nullptr) {\n   EXPECT_OK_AND_ASSIGN(auto buffer_output_stream,\n                        io::BufferOutputStream::Create(max_size));\n   auto write_options = adapters::orc::WriteOptions();\n@@ -250,7 +251,11 @@ void AssertTableWriteReadEqual(const std::shared_ptr<Table>& input_table,\n   ASSERT_EQ(reader->GetCompression(), write_options.compression);\n   ASSERT_EQ(reader->GetCompressionSize(), write_options.compression_block_size);\n   ASSERT_EQ(reader->GetRowIndexStride(), write_options.row_index_stride);\n-  EXPECT_OK_AND_ASSIGN(auto actual_output_table, reader->Read());\n+  EXPECT_OK_AND_ASSIGN(auto actual_output_table,\n+                       opt_selected_read_indices == nullptr\n+                           ? reader->Read()\n+                           : reader->Read(*opt_selected_read_indices));\n+  ASSERT_OK(actual_output_table->ValidateFull());\n   AssertTablesEqual(*expected_output_table, *actual_output_table, false, false);\n }\n \n@@ -451,6 +456,37 @@ TEST_F(TestORCWriterTrivialNoConversion, writeChunkless) {\n   std::shared_ptr<Table> table = TableFromJSON(table_schema, {});\n   AssertTableWriteReadEqual(table, table, kDefaultSmallMemStreamSize / 16);\n }\n+TEST_F(TestORCWriterTrivialNoConversion, writeTrivialChunkAndSelectField) {\n+  std::shared_ptr<Table> table = TableFromJSON(table_schema, {R\"([])\"});\n+  std::shared_ptr<Schema> schema_selected =\n+      schema({field(\"int8\", int8()), field(\"int32\", int32())});\n+  std::shared_ptr<Table> table_selected = TableFromJSON(schema_selected, {R\"([])\"});\n+  std::vector<int> selected_indices = {1, 3};\n+  AssertTableWriteReadEqual(table, table_selected, kDefaultSmallMemStreamSize / 16,\n+                            &selected_indices);\n+}\n+TEST_F(TestORCWriterTrivialNoConversion, writeFilledChunkAndSelectField) {\n+  std::vector<int> selected_indices = {1, 7};\n+  random::RandomArrayGenerator rand(kRandomSeed);\n+  std::shared_ptr<Schema> local_schema = schema({\n+      field(\"bool\", boolean()),\n+      field(\"int32\", int32()),\n+      field(\"int64\", int64()),\n+      field(\"float\", float32()),\n+      field(\"struct\", struct_({field(\"a\", utf8()), field(\"b\", int64())})),\n+      field(\"double\", float64()),\n+      field(\"date32\", date32()),\n+      field(\"ts3\", timestamp(TimeUnit::NANO)),\n+      field(\"string\", utf8()),\n+      field(\"binary\", binary()),\n+  });\n+  auto batch = rand.BatchOf(local_schema->fields(), 100);\n+  std::shared_ptr<Table> table = Table::Make(local_schema, batch->columns());\n+  EXPECT_OK_AND_ASSIGN(auto table_selected, table->SelectColumns(selected_indices));\n+  AssertTableWriteReadEqual(table, table_selected, kDefaultSmallMemStreamSize,\n+                            &selected_indices);\n+}\n+\n class TestORCWriterTrivialWithConversion : public ::testing::Test {\n  public:\n   TestORCWriterTrivialWithConversion() {"
            },
            {
                "fn": "ruby/red-arrow/test/test-orc.rb",
                "patch": "@@ -164,8 +164,8 @@ def pp_values(values)\n         ]\n       end\n       assert_equal([\n-                     [\"boolean1: bool\", [pp_values([false, true])]],\n-                     [\"short1: int16\", [pp_values([1024, 2048])]],\n+                     [\"byte1: int8\", [pp_values([1, 100])]],\n+                     [\"int1: int32\", [pp_values([65536, 65536])]],\n                    ],\n                    dump)\n     end"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_eea4a54f66a36137f4204876a68e6d5ed913cbc5/build_eea4a54f66a36137f4204876a68e6d5ed913cbc5\nTest project /out/apache___arrow/git_repo_dir_eea4a54f66a36137f4204876a68e6d5ed913cbc5/build_eea4a54f66a36137f4204876a68e6d5ed913cbc5\n    Start 40: arrow-orc-adapter-test\n1/1 Test #40: arrow-orc-adapter-test ...........***Failed    0.73 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow-tests    =   0.73 sec*proc (1 test)\nunittest       =   0.73 sec*proc (1 test)\n\nTotal Test time (real) =   0.74 sec\n\nThe following tests FAILED:\n\t 40 - arrow-orc-adapter-test (Failed)\n"
    },
    "0b4fa2a2bf80bf3a91f9f8f42fe313f78b8a1282___table_builder.cc": {
        "prefix": "Status RecordBatchBuilder::Flush(bool reset_builders,\n                                 std::shared_ptr<RecordBatch>* batch) {\n  std::vector<std::shared_ptr<Array>> fields;\n  fields.resize(this->num_fields());\n\n  int64_t length = 0;\n  for (int i = 0; i < this->num_fields(); ++i) {\n    RETURN_NOT_OK(raw_field_builders_[i]->Finish(&fields[i]));\n    if (i > 0 && fields[i]->length() != length) {\n      return Status::Invalid(\"All fields must be same length when calling Flush\");\n    }\n    length = fields[i]->length();\n  }\n",
        "suffix": "  if (reset_builders) {\n    return InitBuilders();\n  } else {\n    return Status::OK();\n  }\n}\n",
        "start": 52,
        "end": 71,
        "buggy": "Status RecordBatchBuilder::Flush(bool reset_builders,\n                                 std::shared_ptr<RecordBatch>* batch) {\n  std::vector<std::shared_ptr<Array>> fields;\n  fields.resize(this->num_fields());\n\n  int64_t length = 0;\n  for (int i = 0; i < this->num_fields(); ++i) {\n    RETURN_NOT_OK(raw_field_builders_[i]->Finish(&fields[i]));\n    if (i > 0 && fields[i]->length() != length) {\n      return Status::Invalid(\"All fields must be same length when calling Flush\");\n    }\n    length = fields[i]->length();\n  }\n  *batch = RecordBatch::Make(schema_, length, std::move(fields));\n  if (reset_builders) {\n    return InitBuilders();\n  } else {\n    return Status::OK();\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  *batch = RecordBatch::Make(schema_, length, std::move(fields));\n",
        "src_path": "0b4fa2a2bf80bf3a91f9f8f42fe313f78b8a1282___table_builder.cc",
        "uri": "https://api.github.com/repos/apache/arrow/commits/0b4fa2a2bf80bf3a91f9f8f42fe313f78b8a1282",
        "commit_msg": "ARROW-9969: [C++] Fix RecordBatchBuilder with dictionary types\n\nSome types, such as some dictionary types, can not be fully determined\nbefore a RecordBatch has been built.\n\nEnsure that the RecordBatch schema contains the correct types, when\nthe RecordBatchBuilder has finished building the RecordBatch.\n\nCloses #8178 from troels/recordbatch-schema-correct-types\n\nAuthored-by: Troels Nielsen <bn.troels@gmail.com>\nSigned-off-by: Antoine Pitrou <antoine@python.org>",
        "test_func_diff": [
            {
                "fn": "cpp/src/arrow/table_builder_test.cc",
                "patch": "@@ -151,4 +151,31 @@ TEST_F(TestRecordBatchBuilder, InvalidFieldLength) {\n   ASSERT_RAISES(Invalid, builder->Flush(&dummy));\n }\n \n+// In #ARROW-9969 dictionary types were not updated\n+// in schema when the index width grew.\n+TEST_F(TestRecordBatchBuilder, DictionaryTypes) {\n+  const int num_rows = static_cast<int>(UINT8_MAX) + 2;\n+  std::vector<std::string> f0_values;\n+  std::vector<bool> is_valid(num_rows, true);\n+  for (int i = 0; i < num_rows; i++) {\n+    f0_values.push_back(std::to_string(i));\n+  }\n+\n+  auto f0 = field(\"f0\", dictionary(int8(), utf8()));\n+\n+  auto schema = ::arrow::schema({f0});\n+\n+  std::unique_ptr<RecordBatchBuilder> builder;\n+  ASSERT_OK(RecordBatchBuilder::Make(schema, pool_, &builder));\n+\n+  auto b0 = builder->GetFieldAs<StringDictionaryBuilder>(0);\n+\n+  AppendValues<StringDictionaryBuilder, std::string>(b0, f0_values, is_valid);\n+\n+  std::shared_ptr<RecordBatch> batch;\n+  ASSERT_OK(builder->Flush(&batch));\n+\n+  AssertTypeEqual(batch->column(0)->type(), batch->schema()->field(0)->type());\n+}\n+\n }  // namespace arrow"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_0b4fa2a2bf80bf3a91f9f8f42fe313f78b8a1282/build_0b4fa2a2bf80bf3a91f9f8f42fe313f78b8a1282\nTest project /out/apache___arrow/git_repo_dir_0b4fa2a2bf80bf3a91f9f8f42fe313f78b8a1282/build_0b4fa2a2bf80bf3a91f9f8f42fe313f78b8a1282\n    Start 8: arrow-table-test\n1/1 Test #8: arrow-table-test .................***Failed    0.07 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow-tests    =   0.07 sec*proc (1 test)\nunittest       =   0.07 sec*proc (1 test)\n\nTotal Test time (real) =   0.07 sec\n\nThe following tests FAILED:\n\t  8 - arrow-table-test (Failed)\n"
    },
    "db004443e631fd72c0fd9a16a02294cd14b456e5___partition.cc": {
        "prefix": "Result<PartitionPathFormat> HivePartitioning::FormatValues(\n    const ScalarVector& values) const {\n  std::vector<std::string> segments(static_cast<size_t>(schema_->num_fields()));\n\n  for (int i = 0; i < schema_->num_fields(); ++i) {\n    const std::string& name = schema_->field(i)->name();\n\n    if (values[i] == nullptr) {\n      segments[i] = \"\";\n    } else if (!values[i]->is_valid) {\n      // If no key is available just provide a placeholder segment to maintain the\n      // field_index <-> path nesting relation\n      segments[i] = name + \"=\" + hive_options_.null_fallback;\n    } else {\n",
        "suffix": "    }\n  }\n\n  return PartitionPathFormat{fs::internal::JoinAbstractPath(std::move(segments)), \"\"};\n}\n",
        "start": 769,
        "end": 788,
        "buggy": "Result<PartitionPathFormat> HivePartitioning::FormatValues(\n    const ScalarVector& values) const {\n  std::vector<std::string> segments(static_cast<size_t>(schema_->num_fields()));\n\n  for (int i = 0; i < schema_->num_fields(); ++i) {\n    const std::string& name = schema_->field(i)->name();\n\n    if (values[i] == nullptr) {\n      segments[i] = \"\";\n    } else if (!values[i]->is_valid) {\n      // If no key is available just provide a placeholder segment to maintain the\n      // field_index <-> path nesting relation\n      segments[i] = name + \"=\" + hive_options_.null_fallback;\n    } else {\n      segments[i] = name + \"=\" + values[i]->ToString();\n    }\n  }\n\n  return PartitionPathFormat{fs::internal::JoinAbstractPath(std::move(segments)), \"\"};\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      segments[i] = name + \"=\" + values[i]->ToString();\n",
        "src_path": "db004443e631fd72c0fd9a16a02294cd14b456e5___partition.cc",
        "uri": "https://api.github.com/repos/apache/arrow/commits/db004443e631fd72c0fd9a16a02294cd14b456e5",
        "commit_msg": "ARROW-18269: [C++] Handle slash character in Hive-style partition values (#14646)\n\nThis PR includes a modification to the partition key generation. Expecting input data column with URI data for partition, the URI encoding is added to consider that situation. \n\nLead-authored-by: Vibhatha Lakmal Abeykoon <vibhatha@gmail.com>\nCo-authored-by: Antoine Pitrou <antoine@python.org>\nSigned-off-by: Antoine Pitrou <antoine@python.org>",
        "test_func_diff": [
            {
                "fn": "cpp/src/arrow/dataset/partition_test.cc",
                "patch": "@@ -28,12 +28,15 @@\n \n #include \"arrow/compute/api_scalar.h\"\n #include \"arrow/compute/api_vector.h\"\n+#include \"arrow/dataset/dataset.h\"\n+#include \"arrow/dataset/file_ipc.h\"\n #include \"arrow/dataset/test_util.h\"\n #include \"arrow/filesystem/path_util.h\"\n #include \"arrow/status.h\"\n #include \"arrow/testing/builder.h\"\n #include \"arrow/testing/gtest_util.h\"\n #include \"arrow/util/range.h\"\n+#include \"arrow/util/uri.h\"\n \n namespace arrow {\n \n@@ -862,6 +865,62 @@ TEST_F(TestPartitioning, UrlEncodedHiveWithKeyEncoded) {\n       partitioning_->Parse(\"/%AF=2021-05-04/%BF=2021-05-04 07%3A27%3A00/str=%24/\"));\n }\n \n+TEST_F(TestPartitioning, WriteHiveWithSlashesInValues) {\n+  // ARROW-18269: partition values should be URI-encoded when writing a Hive-like dataset\n+  fs::TimePoint mock_now = std::chrono::system_clock::now();\n+  ASSERT_OK_AND_ASSIGN(std::shared_ptr<fs::FileSystem> filesystem,\n+                       fs::internal::MockFileSystem::Make(mock_now, {}));\n+  auto base_path = \"\";\n+  ASSERT_OK(filesystem->CreateDir(base_path));\n+  // Create an Arrow Table\n+  auto schema = arrow::schema(\n+      {arrow::field(\"a\", arrow::int64()), arrow::field(\"part\", arrow::utf8())});\n+\n+  auto table = TableFromJSON(schema, {\n+                                         R\"([\n+    [0, \"experiment/A/f.csv\"],\n+    [1, \"experiment/B/f.csv\"],\n+    [2, \"experiment/A/f.csv\"],\n+    [3, \"experiment/C/k.csv\"],\n+    [4, \"experiment/M/i.csv\"]\n+  ])\",\n+                                     });\n+\n+  // Write it using Datasets\n+  auto dataset = std::make_shared<dataset::InMemoryDataset>(table);\n+  ASSERT_OK_AND_ASSIGN(auto scanner_builder, dataset->NewScan());\n+  ASSERT_OK_AND_ASSIGN(auto scanner, scanner_builder->Finish());\n+\n+  auto partition_schema = arrow::schema({arrow::field(\"part\", arrow::utf8())});\n+  auto partitioning = std::make_shared<dataset::HivePartitioning>(partition_schema);\n+  auto ipc_format = std::make_shared<dataset::IpcFileFormat>();\n+  dataset::FileSystemDatasetWriteOptions write_options;\n+  write_options.file_write_options = ipc_format->DefaultWriteOptions();\n+  write_options.filesystem = filesystem;\n+  write_options.base_dir = base_path;\n+  write_options.partitioning = partitioning;\n+  write_options.basename_template = \"part{i}.arrow\";\n+  ASSERT_OK(dataset::FileSystemDataset::Write(write_options, scanner));\n+\n+  auto mockfs =\n+      arrow::internal::checked_pointer_cast<fs::internal::MockFileSystem>(filesystem);\n+  auto all_dirs = mockfs->AllDirs();\n+\n+  std::vector<std::string> encoded_paths;\n+  std::vector<std::string> unique_partitions = {\n+      \"experiment/A/f.csv\", \"experiment/B/f.csv\", \"experiment/C/k.csv\",\n+      \"experiment/M/i.csv\"};\n+  for (auto partition : unique_partitions) {\n+    encoded_paths.push_back(\"part=\" + arrow::internal::UriEscape(partition));\n+  }\n+\n+  ASSERT_EQ(all_dirs.size(), encoded_paths.size());\n+\n+  for (size_t i = 0; i < all_dirs.size(); i++) {\n+    ASSERT_EQ(all_dirs[i].full_path, encoded_paths[i]);\n+  }\n+}\n+\n TEST_F(TestPartitioning, EtlThenHive) {\n   FieldVector etl_fields{field(\"year\", int16()), field(\"month\", int8()),\n                          field(\"day\", int8()), field(\"hour\", int8())};"
            },
            {
                "fn": "python/pyarrow/tests/test_dataset.py",
                "patch": "@@ -27,6 +27,8 @@\n import threading\n import time\n \n+from urllib.parse import quote\n+\n import numpy as np\n import pytest\n \n@@ -4912,3 +4914,40 @@ def test_read_table_nested_columns(tempdir, format):\n         {'user_id': 'qrs456', 'type': 'scroll', 'values': [None, 3, 4],\n          'structs': [{'fizz': 'buzz', 'foo': None}], 'a.dotted.field': 2}\n     ]\n+\n+\n+def test_dataset_partition_with_slash(tmpdir):\n+    from pyarrow import dataset as ds\n+\n+    path = tmpdir / \"slash-writer-x\"\n+\n+    dt_table = pa.Table.from_arrays([\n+        pa.array([1, 2, 3, 4, 5], pa.int32()),\n+        pa.array([\"experiment/A/f.csv\", \"experiment/B/f.csv\",\n+                  \"experiment/A/f.csv\", \"experiment/C/k.csv\",\n+                  \"experiment/M/i.csv\"], pa.utf8())], [\"exp_id\", \"exp_meta\"])\n+\n+    ds.write_dataset(\n+        data=dt_table,\n+        base_dir=path,\n+        format='ipc',\n+        partitioning=['exp_meta'],\n+        partitioning_flavor='hive',\n+    )\n+\n+    read_table = ds.dataset(\n+        source=path,\n+        format='ipc',\n+        partitioning='hive',\n+        schema=pa.schema([pa.field(\"exp_id\", pa.int32()),\n+                          pa.field(\"exp_meta\", pa.utf8())])\n+    ).to_table().combine_chunks()\n+\n+    assert dt_table == read_table.sort_by(\"exp_id\")\n+\n+    exp_meta = dt_table.column(1).to_pylist()\n+    exp_meta = sorted(set(exp_meta))  # take unique\n+    encoded_paths = [\"exp_meta=\" + quote(path, safe='') for path in exp_meta]\n+    file_paths = sorted(os.listdir(path))\n+\n+    assert encoded_paths == file_paths"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_db004443e631fd72c0fd9a16a02294cd14b456e5/build_db004443e631fd72c0fd9a16a02294cd14b456e5\nTest project /out/apache___arrow/git_repo_dir_db004443e631fd72c0fd9a16a02294cd14b456e5/build_db004443e631fd72c0fd9a16a02294cd14b456e5\n    Start 42: arrow-dataset-partition-test\n1/1 Test #42: arrow-dataset-partition-test .....***Failed    0.08 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow_dataset    =   0.08 sec*proc (1 test)\nunittest         =   0.08 sec*proc (1 test)\n\nTotal Test time (real) =   0.08 sec\n\nThe following tests FAILED:\n\t 42 - arrow-dataset-partition-test (Failed)\n"
    },
    "171e8bfe5fe13467a1763227e495fae6bc5d011d___vector_selection.cc": {
        "prefix": "void NullTake(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n  if (TakeState::Get(ctx).boundscheck) {\n    KERNEL_RETURN_IF_ERROR(ctx, CheckIndexBounds(*batch[1].array(), batch[0].length()));\n  }\n",
        "suffix": "}\n",
        "start": 1170,
        "end": 1175,
        "buggy": "void NullTake(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n  if (TakeState::Get(ctx).boundscheck) {\n    KERNEL_RETURN_IF_ERROR(ctx, CheckIndexBounds(*batch[1].array(), batch[0].length()));\n  }\n  out->value = std::make_shared<NullArray>(batch.length)->data();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  out->value = std::make_shared<NullArray>(batch.length)->data();\n",
        "src_path": "171e8bfe5fe13467a1763227e495fae6bc5d011d___vector_selection.cc",
        "uri": "https://api.github.com/repos/apache/arrow/commits/171e8bfe5fe13467a1763227e495fae6bc5d011d",
        "commit_msg": "ARROW-10027: [C++] Fix Take array kernel for NullType\n\nCloses #8209 from jorisvandenbossche/ARROW-10027-filter-null\n\nAuthored-by: Joris Van den Bossche <jorisvandenbossche@gmail.com>\nSigned-off-by: Antoine Pitrou <antoine@python.org>",
        "test_func_diff": [
            {
                "fn": "cpp/src/arrow/compute/kernels/vector_selection_test.cc",
                "patch": "@@ -928,6 +928,7 @@ class TestTakeKernel : public ::testing::Test {};\n \n TEST(TestTakeKernel, TakeNull) {\n   AssertTakeNull(\"[null, null, null]\", \"[0, 1, 0]\", \"[null, null, null]\");\n+  AssertTakeNull(\"[null, null, null]\", \"[0, 2]\", \"[null, null]\");\n \n   std::shared_ptr<Array> arr;\n   ASSERT_RAISES(IndexError,"
            },
            {
                "fn": "python/pyarrow/tests/test_compute.py",
                "patch": "@@ -518,6 +518,20 @@ def test_take_dictionary(ordered):\n     assert result.type.ordered is ordered\n \n \n+def test_take_null_type():\n+    # ARROW-10027\n+    arr = pa.array([None] * 10)\n+    chunked_arr = pa.chunked_array([[None] * 5] * 2)\n+    batch = pa.record_batch([arr], names=['a'])\n+    table = pa.table({'a': arr})\n+\n+    indices = pa.array([1, 3, 7, None])\n+    assert len(arr.take(indices)) == 4\n+    assert len(chunked_arr.take(indices)) == 4\n+    assert len(batch.take(indices).column(0)) == 4\n+    assert len(table.take(indices).column(0)) == 4\n+\n+\n @pytest.mark.parametrize(('ty', 'values'), all_array_types)\n def test_filter(ty, values):\n     arr = pa.array(values, type=ty)\n@@ -613,6 +627,20 @@ def test_filter_errors():\n             obj.filter(mask)\n \n \n+def test_filter_null_type():\n+    # ARROW-10027\n+    arr = pa.array([None] * 10)\n+    chunked_arr = pa.chunked_array([[None] * 5] * 2)\n+    batch = pa.record_batch([arr], names=['a'])\n+    table = pa.table({'a': arr})\n+\n+    mask = pa.array([True, False] * 5)\n+    assert len(arr.filter(mask)) == 5\n+    assert len(chunked_arr.filter(mask)) == 5\n+    assert len(batch.filter(mask).column(0)) == 5\n+    assert len(table.filter(mask).column(0)) == 5\n+\n+\n @pytest.mark.parametrize(\"typ\", [\"array\", \"chunked_array\"])\n def test_compare_array(typ):\n     if typ == \"array\":"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_171e8bfe5fe13467a1763227e495fae6bc5d011d/build_171e8bfe5fe13467a1763227e495fae6bc5d011d\nTest project /out/apache___arrow/git_repo_dir_171e8bfe5fe13467a1763227e495fae6bc5d011d/build_171e8bfe5fe13467a1763227e495fae6bc5d011d\n    Start 24: arrow-compute-vector-test\n1/1 Test #24: arrow-compute-vector-test ........***Failed    1.17 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow_compute    =   1.17 sec*proc (1 test)\nunittest         =   1.17 sec*proc (1 test)\n\nTotal Test time (real) =   1.17 sec\n\nThe following tests FAILED:\n\t 24 - arrow-compute-vector-test (Failed)\n"
    },
    "4a7e19e118907d0b1c7e1505697a5b74a541c9f7___function.h": {
        "prefix": "struct ARROW_EXPORT Arity {\n  /// \\brief A function taking no arguments\n  static Arity Nullary() { return Arity(0, false); }\n\n  /// \\brief A function taking 1 argument\n  static Arity Unary() { return Arity(1, false); }\n\n  /// \\brief A function taking 2 arguments\n  static Arity Binary() { return Arity(2, false); }\n\n  /// \\brief A function taking 3 arguments\n  static Arity Ternary() { return Arity(3, false); }\n\n  /// \\brief A function taking a variable number of arguments\n",
        "suffix": "\n  explicit Arity(int num_args, bool is_varargs = false)\n      : num_args(num_args), is_varargs(is_varargs) {}\n\n  /// The number of required arguments (or the minimum number for varargs\n  /// functions).\n  int num_args;\n\n  /// If true, then the num_args is the minimum number of required arguments.\n  bool is_varargs = false;\n};\n",
        "start": 49,
        "end": 74,
        "buggy": "struct ARROW_EXPORT Arity {\n  /// \\brief A function taking no arguments\n  static Arity Nullary() { return Arity(0, false); }\n\n  /// \\brief A function taking 1 argument\n  static Arity Unary() { return Arity(1, false); }\n\n  /// \\brief A function taking 2 arguments\n  static Arity Binary() { return Arity(2, false); }\n\n  /// \\brief A function taking 3 arguments\n  static Arity Ternary() { return Arity(3, false); }\n\n  /// \\brief A function taking a variable number of arguments\n  static Arity VarArgs(int min_args = 1) { return Arity(min_args, true); }\n\n  explicit Arity(int num_args, bool is_varargs = false)\n      : num_args(num_args), is_varargs(is_varargs) {}\n\n  /// The number of required arguments (or the minimum number for varargs\n  /// functions).\n  int num_args;\n\n  /// If true, then the num_args is the minimum number of required arguments.\n  bool is_varargs = false;\n};\n",
        "fix": null,
        "buggy_hunk_masked": "  static Arity VarArgs(int min_args = 1) { return Arity(min_args, true); }\n",
        "src_path": "4a7e19e118907d0b1c7e1505697a5b74a541c9f7___function.h",
        "uri": "https://api.github.com/repos/apache/arrow/commits/4a7e19e118907d0b1c7e1505697a5b74a541c9f7",
        "commit_msg": "ARROW-8929: [C++] Set the default for compute::Arity::VarArgs to 0\n\nAs Micah pointed out, 0 is a more reasonable default for the minimum number of arguments than 1 is.\n\nCloses #7322 from wesm/ARROW-8929\n\nAuthored-by: Wes McKinney <wesm+git@apache.org>\nSigned-off-by: Wes McKinney <wesm+git@apache.org>",
        "test_func_diff": [
            {
                "fn": "cpp/src/arrow/compute/function_test.cc",
                "patch": "@@ -48,7 +48,7 @@ TEST(Arity, Basics) {\n   ASSERT_EQ(3, ternary.num_args);\n \n   auto varargs = Arity::VarArgs();\n-  ASSERT_EQ(1, varargs.num_args);\n+  ASSERT_EQ(0, varargs.num_args);\n   ASSERT_TRUE(varargs.is_varargs);\n \n   auto varargs2 = Arity::VarArgs(2);"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_4a7e19e118907d0b1c7e1505697a5b74a541c9f7/build_4a7e19e118907d0b1c7e1505697a5b74a541c9f7\nTest project /out/apache___arrow/git_repo_dir_4a7e19e118907d0b1c7e1505697a5b74a541c9f7/build_4a7e19e118907d0b1c7e1505697a5b74a541c9f7\n    Start 21: arrow-compute-internals-test\n1/1 Test #21: arrow-compute-internals-test .....***Failed    0.81 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow_compute    =   0.81 sec*proc (1 test)\nunittest         =   0.81 sec*proc (1 test)\n\nTotal Test time (real) =   0.82 sec\n\nThe following tests FAILED:\n\t 21 - arrow-compute-internals-test (Failed)\n"
    },
    "912e2bb3345536c271580e3a9e88baaffb7f2836___dataset_writer.cc": {
        "prefix": "Status EnsureDestinationValid(const FileSystemDatasetWriteOptions& options) {\n  if (options.existing_data_behavior == ExistingDataBehavior::kError) {\n    fs::FileSelector selector;\n    selector.base_dir = options.base_dir;\n    selector.recursive = true;\n    Result<std::vector<fs::FileInfo>> maybe_files =\n        options.filesystem->GetFileInfo(selector);\n    if (!maybe_files.ok()) {\n      // If the path doesn't exist then continue\n      return Status::OK();\n    }\n",
        "suffix": "      return Status::Invalid(\n          \"Could not write to \", options.base_dir,\n          \" as the directory is not empty and existing_data_behavior is to error\");\n    }\n  }\n  return Status::OK();\n}\n",
        "start": 415,
        "end": 433,
        "buggy": "Status EnsureDestinationValid(const FileSystemDatasetWriteOptions& options) {\n  if (options.existing_data_behavior == ExistingDataBehavior::kError) {\n    fs::FileSelector selector;\n    selector.base_dir = options.base_dir;\n    selector.recursive = true;\n    Result<std::vector<fs::FileInfo>> maybe_files =\n        options.filesystem->GetFileInfo(selector);\n    if (!maybe_files.ok()) {\n      // If the path doesn't exist then continue\n      return Status::OK();\n    }\n    if (maybe_files->size() > 1) {\n      return Status::Invalid(\n          \"Could not write to \", options.base_dir,\n          \" as the directory is not empty and existing_data_behavior is to error\");\n    }\n  }\n  return Status::OK();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (maybe_files->size() > 1) {\n",
        "src_path": "912e2bb3345536c271580e3a9e88baaffb7f2836___dataset_writer.cc",
        "uri": "https://api.github.com/repos/apache/arrow/commits/912e2bb3345536c271580e3a9e88baaffb7f2836",
        "commit_msg": "ARROW-16204: [C++][Dataset] Default error existing_data_behaviour for writing dataset ignores a single file\n\nCloses #12898 from jorisvandenbossche/ARROW-16204\n\nAuthored-by: Joris Van den Bossche <jorisvandenbossche@gmail.com>\nSigned-off-by: Joris Van den Bossche <jorisvandenbossche@gmail.com>",
        "test_func_diff": [
            {
                "fn": "cpp/src/arrow/dataset/dataset_writer_test.cc",
                "patch": "@@ -453,6 +453,18 @@ TEST_F(DatasetWriterTestFixture, ErrOnExistingData) {\n   ASSERT_RAISES(Invalid, DatasetWriter::Make(write_options_));\n   AssertEmptyFiles(\n       {\"testdir/chunk-0.arrow\", \"testdir/chunk-5.arrow\", \"testdir/blah.txt\"});\n+\n+  // only a single file in the target directory\n+  fs::TimePoint mock_now2 = std::chrono::system_clock::now();\n+  ASSERT_OK_AND_ASSIGN(\n+      std::shared_ptr<fs::FileSystem> fs2,\n+      MockFileSystem::Make(\n+          mock_now2, {::arrow::fs::Dir(\"testdir\"), fs::File(\"testdir/part-0.arrow\")}));\n+  filesystem_ = std::dynamic_pointer_cast<MockFileSystem>(fs2);\n+  write_options_.filesystem = filesystem_;\n+  write_options_.base_dir = \"testdir\";\n+  ASSERT_RAISES(Invalid, DatasetWriter::Make(write_options_));\n+  AssertEmptyFiles({\"testdir/part-0.arrow\"});\n }\n \n }  // namespace internal"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_912e2bb3345536c271580e3a9e88baaffb7f2836/build_912e2bb3345536c271580e3a9e88baaffb7f2836\nTest project /out/apache___arrow/git_repo_dir_912e2bb3345536c271580e3a9e88baaffb7f2836/build_912e2bb3345536c271580e3a9e88baaffb7f2836\n    Start 36: arrow-dataset-dataset-writer-test\n1/1 Test #36: arrow-dataset-dataset-writer-test ...***Failed    0.08 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow_dataset    =   0.08 sec*proc (1 test)\nunittest         =   0.08 sec*proc (1 test)\n\nTotal Test time (real) =   0.09 sec\n\nThe following tests FAILED:\n\t 36 - arrow-dataset-dataset-writer-test (Failed)\n"
    },
    "948577c5df3a6f0d337ab417b26edcc344eb65e2___folding_rules.cpp": {
        "prefix": "FoldingRule CompositeConstructFeedingExtract() {\n  return [](IRContext* context, Instruction* inst,\n            const std::vector<const analysis::Constant*>&) {\n    // If the input to an OpCompositeExtract is an OpCompositeConstruct,\n    // then we can simply use the appropriate element in the construction.\n    assert(inst->opcode() == SpvOpCompositeExtract &&\n           \"Wrong opcode.  Should be OpCompositeExtract.\");\n    analysis::DefUseManager* def_use_mgr = context->get_def_use_mgr();\n    analysis::TypeManager* type_mgr = context->get_type_mgr();\n\n    // If there are no index operands, then this rule cannot do anything.\n    if (inst->NumInOperands() <= 1) {\n      return false;\n    }\n\n    uint32_t cid = inst->GetSingleWordInOperand(kExtractCompositeIdInIdx);\n    Instruction* cinst = def_use_mgr->GetDef(cid);\n\n    if (cinst->opcode() != SpvOpCompositeConstruct) {\n      return false;\n    }\n\n    std::vector<Operand> operands;\n    analysis::Type* composite_type = type_mgr->GetType(cinst->type_id());\n    if (composite_type->AsVector() == nullptr) {\n      // Get the element being extracted from the OpCompositeConstruct\n      // Since it is not a vector, it is simple to extract the single element.\n      uint32_t element_index = inst->GetSingleWordInOperand(1);\n      uint32_t element_id = cinst->GetSingleWordInOperand(element_index);\n      operands.push_back({SPV_OPERAND_TYPE_ID, {element_id}});\n\n      // Add the remaining indices for extraction.\n      for (uint32_t i = 2; i < inst->NumInOperands(); ++i) {\n        operands.push_back({SPV_OPERAND_TYPE_LITERAL_INTEGER,\n                            {inst->GetSingleWordInOperand(i)}});\n      }\n\n    } else {\n      // With vectors we have to handle the case where it is concatenating\n      // vectors.\n      assert(inst->NumInOperands() == 2 &&\n             \"Expecting a vector of scalar values.\");\n\n      uint32_t element_index = inst->GetSingleWordInOperand(1);\n      for (uint32_t construct_index = 0;\n           construct_index < cinst->NumInOperands(); ++construct_index) {\n        uint32_t element_id = cinst->GetSingleWordInOperand(construct_index);\n        Instruction* element_def = def_use_mgr->GetDef(element_id);\n        analysis::Vector* element_type =\n            type_mgr->GetType(element_def->type_id())->AsVector();\n        if (element_type) {\n          uint32_t vector_size = element_type->element_count();\n",
        "suffix": "            // The element we want comes after this vector.\n            element_index -= vector_size;\n          } else {\n            // We want an element of this vector.\n            operands.push_back({SPV_OPERAND_TYPE_ID, {element_id}});\n            operands.push_back(\n                {SPV_OPERAND_TYPE_LITERAL_INTEGER, {element_index}});\n            break;\n          }\n        } else {\n          if (element_index == 0) {\n            // This is a scalar, and we this is the element we are extracting.\n            operands.push_back({SPV_OPERAND_TYPE_ID, {element_id}});\n            break;\n          } else {\n            // Skip over this scalar value.\n            --element_index;\n          }\n        }\n      }\n    }\n\n    // If there were no extra indices, then we have the final object.  No need\n    // to extract even more.\n    if (operands.size() == 1) {\n      inst->SetOpcode(SpvOpCopyObject);\n    }\n\n    inst->SetInOperands(std::move(operands));\n    return true;\n  };\n}\n",
        "start": 1418,
        "end": 1502,
        "buggy": "FoldingRule CompositeConstructFeedingExtract() {\n  return [](IRContext* context, Instruction* inst,\n            const std::vector<const analysis::Constant*>&) {\n    // If the input to an OpCompositeExtract is an OpCompositeConstruct,\n    // then we can simply use the appropriate element in the construction.\n    assert(inst->opcode() == SpvOpCompositeExtract &&\n           \"Wrong opcode.  Should be OpCompositeExtract.\");\n    analysis::DefUseManager* def_use_mgr = context->get_def_use_mgr();\n    analysis::TypeManager* type_mgr = context->get_type_mgr();\n\n    // If there are no index operands, then this rule cannot do anything.\n    if (inst->NumInOperands() <= 1) {\n      return false;\n    }\n\n    uint32_t cid = inst->GetSingleWordInOperand(kExtractCompositeIdInIdx);\n    Instruction* cinst = def_use_mgr->GetDef(cid);\n\n    if (cinst->opcode() != SpvOpCompositeConstruct) {\n      return false;\n    }\n\n    std::vector<Operand> operands;\n    analysis::Type* composite_type = type_mgr->GetType(cinst->type_id());\n    if (composite_type->AsVector() == nullptr) {\n      // Get the element being extracted from the OpCompositeConstruct\n      // Since it is not a vector, it is simple to extract the single element.\n      uint32_t element_index = inst->GetSingleWordInOperand(1);\n      uint32_t element_id = cinst->GetSingleWordInOperand(element_index);\n      operands.push_back({SPV_OPERAND_TYPE_ID, {element_id}});\n\n      // Add the remaining indices for extraction.\n      for (uint32_t i = 2; i < inst->NumInOperands(); ++i) {\n        operands.push_back({SPV_OPERAND_TYPE_LITERAL_INTEGER,\n                            {inst->GetSingleWordInOperand(i)}});\n      }\n\n    } else {\n      // With vectors we have to handle the case where it is concatenating\n      // vectors.\n      assert(inst->NumInOperands() == 2 &&\n             \"Expecting a vector of scalar values.\");\n\n      uint32_t element_index = inst->GetSingleWordInOperand(1);\n      for (uint32_t construct_index = 0;\n           construct_index < cinst->NumInOperands(); ++construct_index) {\n        uint32_t element_id = cinst->GetSingleWordInOperand(construct_index);\n        Instruction* element_def = def_use_mgr->GetDef(element_id);\n        analysis::Vector* element_type =\n            type_mgr->GetType(element_def->type_id())->AsVector();\n        if (element_type) {\n          uint32_t vector_size = element_type->element_count();\n          if (vector_size < element_index) {\n            // The element we want comes after this vector.\n            element_index -= vector_size;\n          } else {\n            // We want an element of this vector.\n            operands.push_back({SPV_OPERAND_TYPE_ID, {element_id}});\n            operands.push_back(\n                {SPV_OPERAND_TYPE_LITERAL_INTEGER, {element_index}});\n            break;\n          }\n        } else {\n          if (element_index == 0) {\n            // This is a scalar, and we this is the element we are extracting.\n            operands.push_back({SPV_OPERAND_TYPE_ID, {element_id}});\n            break;\n          } else {\n            // Skip over this scalar value.\n            --element_index;\n          }\n        }\n      }\n    }\n\n    // If there were no extra indices, then we have the final object.  No need\n    // to extract even more.\n    if (operands.size() == 1) {\n      inst->SetOpcode(SpvOpCopyObject);\n    }\n\n    inst->SetInOperands(std::move(operands));\n    return true;\n  };\n}\n",
        "fix": null,
        "buggy_hunk_masked": "          if (vector_size < element_index) {\n",
        "src_path": "948577c5df3a6f0d337ab417b26edcc344eb65e2___folding_rules.cpp",
        "uri": "https://api.github.com/repos/KhronosGroup/SPIRV-Tools/commits/948577c5df3a6f0d337ab417b26edcc344eb65e2",
        "commit_msg": "Fix the bug (#3680)",
        "test_func_diff": [
            {
                "fn": "test/opt/fold_test.cpp",
                "patch": "@@ -3464,7 +3464,18 @@ ::testing::Values(\n             \"%3 = OpCompositeExtract %float %2 4\\n\" +\n             \"OpReturn\\n\" +\n             \"OpFunctionEnd\",\n-        3, 0)\n+        3, 0),\n+    // Test case 14: https://github.com/KhronosGroup/SPIRV-Tools/issues/3631\n+    // Extract the component right after the vector constituent.\n+    InstructionFoldingCase<uint32_t>(\n+        Header() + \"%main = OpFunction %void None %void_func\\n\" +\n+            \"%main_lab = OpLabel\\n\" +\n+            \"%2 = OpCompositeConstruct %v2int %int_0 %int_0\\n\" +\n+            \"%3 = OpCompositeConstruct %v4int %2 %100 %int_0\\n\" +\n+            \"%4 = OpCompositeExtract %int %3 2\\n\" +\n+            \"OpReturn\\n\" +\n+            \"OpFunctionEnd\",\n+        4, INT_0_ID)\n ));\n \n INSTANTIATE_TEST_SUITE_P(CompositeConstructFoldingTest, GeneralInstructionFoldingTest,"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_948577c5df3a6f0d337ab417b26edcc344eb65e2/build_948577c5df3a6f0d337ab417b26edcc344eb65e2\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_948577c5df3a6f0d337ab417b26edcc344eb65e2/build_948577c5df3a6f0d337ab417b26edcc344eb65e2\n    Start 13: spirv-tools-test_opt\n1/2 Test #13: spirv-tools-test_opt .............***Exception: SegFault 24.12 sec\n    Start 15: spirv-tools-test_opt_loops\n2/2 Test #15: spirv-tools-test_opt_loops .......   Passed    4.84 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  28.97 sec\n\nThe following tests FAILED:\n\t 13 - spirv-tools-test_opt (SEGFAULT)\n"
    },
    "ab3cdcaef56e9311f299eebfd044f9646100c9dc___upgrade_memory_model.cpp": {
        "prefix": "std::pair<bool, bool> UpgradeMemoryModel::CheckType(\n    uint32_t type_id, const std::vector<uint32_t>& indices) {\n  bool is_coherent = false;\n  bool is_volatile = false;\n  Instruction* type_inst = context()->get_def_use_mgr()->GetDef(type_id);\n  assert(type_inst->opcode() == SpvOpTypePointer);\n  Instruction* element_inst = context()->get_def_use_mgr()->GetDef(\n      type_inst->GetSingleWordInOperand(1u));\n  for (int i = (int)indices.size() - 1; i >= 0; --i) {\n    if (is_coherent && is_volatile) break;\n\n    if (element_inst->opcode() == SpvOpTypePointer) {\n      element_inst = context()->get_def_use_mgr()->GetDef(\n          element_inst->GetSingleWordInOperand(1u));\n    } else if (element_inst->opcode() == SpvOpTypeStruct) {\n      uint32_t index = indices.at(i);\n      Instruction* index_inst = context()->get_def_use_mgr()->GetDef(index);\n      assert(index_inst->opcode() == SpvOpConstant);\n      uint64_t value = GetIndexValue(index_inst);\n      is_coherent |= HasDecoration(element_inst, static_cast<uint32_t>(value),\n                                   SpvDecorationCoherent);\n      is_volatile |= HasDecoration(element_inst, static_cast<uint32_t>(value),\n                                   SpvDecorationVolatile);\n      element_inst = context()->get_def_use_mgr()->GetDef(\n          element_inst->GetSingleWordInOperand(static_cast<uint32_t>(value)));\n    } else {\n      assert(spvOpcodeIsComposite(element_inst->opcode()));\n      element_inst = context()->get_def_use_mgr()->GetDef(\n",
        "suffix": "    }\n  }\n\n  if (!is_coherent || !is_volatile) {\n    bool remaining_coherent = false;\n    bool remaining_volatile = false;\n    std::tie(remaining_coherent, remaining_volatile) =\n        CheckAllTypes(element_inst);\n    is_coherent |= remaining_coherent;\n    is_volatile |= remaining_volatile;\n  }\n\n  return std::make_pair(is_coherent, is_volatile);\n}\n",
        "start": 404,
        "end": 446,
        "buggy": "std::pair<bool, bool> UpgradeMemoryModel::CheckType(\n    uint32_t type_id, const std::vector<uint32_t>& indices) {\n  bool is_coherent = false;\n  bool is_volatile = false;\n  Instruction* type_inst = context()->get_def_use_mgr()->GetDef(type_id);\n  assert(type_inst->opcode() == SpvOpTypePointer);\n  Instruction* element_inst = context()->get_def_use_mgr()->GetDef(\n      type_inst->GetSingleWordInOperand(1u));\n  for (int i = (int)indices.size() - 1; i >= 0; --i) {\n    if (is_coherent && is_volatile) break;\n\n    if (element_inst->opcode() == SpvOpTypePointer) {\n      element_inst = context()->get_def_use_mgr()->GetDef(\n          element_inst->GetSingleWordInOperand(1u));\n    } else if (element_inst->opcode() == SpvOpTypeStruct) {\n      uint32_t index = indices.at(i);\n      Instruction* index_inst = context()->get_def_use_mgr()->GetDef(index);\n      assert(index_inst->opcode() == SpvOpConstant);\n      uint64_t value = GetIndexValue(index_inst);\n      is_coherent |= HasDecoration(element_inst, static_cast<uint32_t>(value),\n                                   SpvDecorationCoherent);\n      is_volatile |= HasDecoration(element_inst, static_cast<uint32_t>(value),\n                                   SpvDecorationVolatile);\n      element_inst = context()->get_def_use_mgr()->GetDef(\n          element_inst->GetSingleWordInOperand(static_cast<uint32_t>(value)));\n    } else {\n      assert(spvOpcodeIsComposite(element_inst->opcode()));\n      element_inst = context()->get_def_use_mgr()->GetDef(\n          element_inst->GetSingleWordInOperand(1u));\n    }\n  }\n\n  if (!is_coherent || !is_volatile) {\n    bool remaining_coherent = false;\n    bool remaining_volatile = false;\n    std::tie(remaining_coherent, remaining_volatile) =\n        CheckAllTypes(element_inst);\n    is_coherent |= remaining_coherent;\n    is_volatile |= remaining_volatile;\n  }\n\n  return std::make_pair(is_coherent, is_volatile);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "          element_inst->GetSingleWordInOperand(1u));\n",
        "src_path": "ab3cdcaef56e9311f299eebfd044f9646100c9dc___upgrade_memory_model.cpp",
        "uri": "https://api.github.com/repos/KhronosGroup/SPIRV-Tools/commits/ab3cdcaef56e9311f299eebfd044f9646100c9dc",
        "commit_msg": "Fix operand access of composite in upgrade memory model (#3021)\n\nFixes #2992\r\n\r\n* Accessing aggregate subtype used the wrong operand\r\n* Added a test",
        "test_func_diff": [
            {
                "fn": "test/opt/upgrade_memory_model_test.cpp",
                "patch": "@@ -2236,4 +2236,37 @@ OpFunctionEnd\n   SinglePassRunAndMatch<opt::UpgradeMemoryModel>(text, true);\n }\n \n+TEST_F(UpgradeMemoryModelTest, CoherentStructMemberInArray) {\n+  const std::string text = R\"(\n+; CHECK-NOT: OpMemberDecorate\n+; CHECK: [[int:%[a-zA-Z0-9_]+]] = OpTypeInt 32 0\n+; CHECK: [[device:%[a-zA-Z0-9_]+]] = OpConstant [[int]] 1\n+; CHECK: OpLoad [[int]] {{.*}} MakePointerVisible|NonPrivatePointer\n+OpCapability Shader\n+OpCapability Linkage\n+OpMemoryModel Logical GLSL450\n+OpMemberDecorate %inner 1 Coherent\n+%void = OpTypeVoid\n+%int = OpTypeInt 32 0\n+%int_0 = OpConstant %int 0\n+%int_1 = OpConstant %int 1\n+%int_4 = OpConstant %int 4\n+%inner = OpTypeStruct %int %int\n+%array = OpTypeArray %inner %int_4\n+%struct = OpTypeStruct %array\n+%ptr_ssbo_struct = OpTypePointer StorageBuffer %struct\n+%ptr_ssbo_int = OpTypePointer StorageBuffer %int\n+%ssbo_var = OpVariable %ptr_ssbo_struct StorageBuffer\n+%void_fn = OpTypeFunction %void\n+%func = OpFunction %void None %void_fn\n+%entry = OpLabel\n+%gep = OpAccessChain %ptr_ssbo_int %ssbo_var %int_0 %int_0 %int_1\n+%ld = OpLoad %int %gep\n+OpReturn\n+OpFunctionEnd\n+)\";\n+\n+  SinglePassRunAndMatch<opt::UpgradeMemoryModel>(text, true);\n+}\n+\n }  // namespace"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_ab3cdcaef56e9311f299eebfd044f9646100c9dc/build_ab3cdcaef56e9311f299eebfd044f9646100c9dc\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_ab3cdcaef56e9311f299eebfd044f9646100c9dc/build_ab3cdcaef56e9311f299eebfd044f9646100c9dc\n    Start 13: spirv-tools-test_opt\n1/2 Test #13: spirv-tools-test_opt .............Subprocess aborted***Exception:  15.87 sec\n    Start 15: spirv-tools-test_opt_loops\n2/2 Test #15: spirv-tools-test_opt_loops .......   Passed    4.88 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  20.76 sec\n\nThe following tests FAILED:\n\t 13 - spirv-tools-test_opt (Subprocess aborted)\n"
    },
    "286b3095dd187da747f85baf9ce3120580565df0___ccp_pass.cpp": {
        "prefix": "SSAPropagator::PropStatus CCPPass::VisitAssignment(Instruction* instr) {\n  assert(instr->result_id() != 0 &&\n         \"Expecting an instruction that produces a result\");\n\n  // If this is a copy operation, and the RHS is a known constant, assign its\n  // value to the LHS.\n  if (instr->opcode() == SpvOpCopyObject) {\n    uint32_t rhs_id = instr->GetSingleWordInOperand(0);\n    auto it = values_.find(rhs_id);\n    if (it != values_.end()) {\n      if (IsVaryingValue(it->second)) {\n        return MarkInstructionVarying(instr);\n      } else {\n        values_[instr->result_id()] = it->second;\n        return SSAPropagator::kInteresting;\n      }\n    }\n    return SSAPropagator::kNotInteresting;\n  }\n\n  // Instructions with a RHS that cannot produce a constant are always varying.\n  if (!instr->IsFoldable()) {\n    return MarkInstructionVarying(instr);\n  }\n\n  // See if the RHS of the assignment folds into a constant value.\n  auto map_func = [this](uint32_t id) {\n    auto it = values_.find(id);\n    if (it == values_.end() || IsVaryingValue(it->second)) {\n      return id;\n    }\n    return it->second;\n  };\n  uint32_t next_id = context()->module()->IdBound();\n  Instruction* folded_inst =\n      context()->get_instruction_folder().FoldInstructionToConstant(instr,\n                                                                    map_func);\n  if (folded_inst != nullptr) {\n    // We do not want to change the body of the function by adding new\n    // instructions.  When folding we can only generate new constants.\n    assert(folded_inst->IsConstant() && \"CCP is only interested in constant.\");\n    values_[instr->result_id()] = folded_inst->result_id();\n\n    // If the folded instruction has just been created, its result ID will\n    // match the previous ID bound. When this happens, we need to indicate\n    // that CCP has modified the IR, independently of whether the constant is\n    // actually propagated. See\n    // https://github.com/KhronosGroup/SPIRV-Tools/issues/3636 for details.\n",
        "suffix": "\n    return SSAPropagator::kInteresting;\n  }\n\n  // Conservatively mark this instruction as varying if any input id is varying.\n  if (!instr->WhileEachInId([this](uint32_t* op_id) {\n        auto iter = values_.find(*op_id);\n        if (iter != values_.end() && IsVaryingValue(iter->second)) return false;\n        return true;\n      })) {\n    return MarkInstructionVarying(instr);\n  }\n\n  // If not, see if there is a least one unknown operand to the instruction.  If\n  // so, we might be able to fold it later.\n  if (!instr->WhileEachInId([this](uint32_t* op_id) {\n        auto it = values_.find(*op_id);\n        if (it == values_.end()) return false;\n        return true;\n      })) {\n    return SSAPropagator::kNotInteresting;\n  }\n\n  // Otherwise, we will never be able to fold this instruction, so mark it\n  // varying.\n  return MarkInstructionVarying(instr);\n}\n",
        "start": 105,
        "end": 180,
        "buggy": "SSAPropagator::PropStatus CCPPass::VisitAssignment(Instruction* instr) {\n  assert(instr->result_id() != 0 &&\n         \"Expecting an instruction that produces a result\");\n\n  // If this is a copy operation, and the RHS is a known constant, assign its\n  // value to the LHS.\n  if (instr->opcode() == SpvOpCopyObject) {\n    uint32_t rhs_id = instr->GetSingleWordInOperand(0);\n    auto it = values_.find(rhs_id);\n    if (it != values_.end()) {\n      if (IsVaryingValue(it->second)) {\n        return MarkInstructionVarying(instr);\n      } else {\n        values_[instr->result_id()] = it->second;\n        return SSAPropagator::kInteresting;\n      }\n    }\n    return SSAPropagator::kNotInteresting;\n  }\n\n  // Instructions with a RHS that cannot produce a constant are always varying.\n  if (!instr->IsFoldable()) {\n    return MarkInstructionVarying(instr);\n  }\n\n  // See if the RHS of the assignment folds into a constant value.\n  auto map_func = [this](uint32_t id) {\n    auto it = values_.find(id);\n    if (it == values_.end() || IsVaryingValue(it->second)) {\n      return id;\n    }\n    return it->second;\n  };\n  uint32_t next_id = context()->module()->IdBound();\n  Instruction* folded_inst =\n      context()->get_instruction_folder().FoldInstructionToConstant(instr,\n                                                                    map_func);\n  if (folded_inst != nullptr) {\n    // We do not want to change the body of the function by adding new\n    // instructions.  When folding we can only generate new constants.\n    assert(folded_inst->IsConstant() && \"CCP is only interested in constant.\");\n    values_[instr->result_id()] = folded_inst->result_id();\n\n    // If the folded instruction has just been created, its result ID will\n    // match the previous ID bound. When this happens, we need to indicate\n    // that CCP has modified the IR, independently of whether the constant is\n    // actually propagated. See\n    // https://github.com/KhronosGroup/SPIRV-Tools/issues/3636 for details.\n    if (folded_inst->result_id() == next_id) created_new_constant_ = true;\n\n    return SSAPropagator::kInteresting;\n  }\n\n  // Conservatively mark this instruction as varying if any input id is varying.\n  if (!instr->WhileEachInId([this](uint32_t* op_id) {\n        auto iter = values_.find(*op_id);\n        if (iter != values_.end() && IsVaryingValue(iter->second)) return false;\n        return true;\n      })) {\n    return MarkInstructionVarying(instr);\n  }\n\n  // If not, see if there is a least one unknown operand to the instruction.  If\n  // so, we might be able to fold it later.\n  if (!instr->WhileEachInId([this](uint32_t* op_id) {\n        auto it = values_.find(*op_id);\n        if (it == values_.end()) return false;\n        return true;\n      })) {\n    return SSAPropagator::kNotInteresting;\n  }\n\n  // Otherwise, we will never be able to fold this instruction, so mark it\n  // varying.\n  return MarkInstructionVarying(instr);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (folded_inst->result_id() == next_id) created_new_constant_ = true;\n",
        "src_path": "286b3095dd187da747f85baf9ce3120580565df0___ccp_pass.cpp",
        "uri": "https://api.github.com/repos/KhronosGroup/SPIRV-Tools/commits/286b3095dd187da747f85baf9ce3120580565df0",
        "commit_msg": "Properly mark IR changed if instruction folder creates more than one constant. (#3799)\n\nIn #3636, I missed that the instruction folder may create more than a\r\nsingle constant per call.  Since CCP was only checking whether one\r\nconstant had been created after folding, it was wrongly thinking that\r\nthe IR had not changed.\r\n\r\nFixes #3738.",
        "test_func_diff": [
            {
                "fn": "test/opt/ccp_test.cpp",
                "patch": "@@ -1105,6 +1105,59 @@ TEST_F(CCPTest, CCPNoChangeFailure) {\n   EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);\n }\n \n+// Test from https://github.com/KhronosGroup/SPIRV-Tools/issues/3738\n+// Similar to the previous one but more than one constant is generated in a\n+// single call to the instruction folder.\n+TEST_F(CCPTest, CCPNoChangeFailureSeveralConstantsDuringFolding) {\n+  const std::string text = R\"(\n+               OpCapability Shader\n+          %1 = OpExtInstImport \"GLSL.std.450\"\n+               OpMemoryModel Logical GLSL450\n+               OpEntryPoint Fragment %2 \"main\"\n+               OpExecutionMode %2 OriginUpperLeft\n+       %void = OpTypeVoid\n+          %4 = OpTypeFunction %void\n+      %float = OpTypeFloat 32\n+    %v3float = OpTypeVector %float 3\n+       %uint = OpTypeInt 32 0\n+     %uint_0 = OpConstant %uint 0\n+       %bool = OpTypeBool\n+     %v3bool = OpTypeVector %bool 3\n+    %float_0 = OpConstant %float 0\n+         %12 = OpConstantComposite %v3float %float_0 %float_0 %float_0\n+%float_0_300000012 = OpConstant %float 0.300000012\n+         %14 = OpConstantComposite %v3float %float_0_300000012 %float_0_300000012 %float_0_300000012\n+\n+; CCP is generating several constants during a single instruction evaluation.\n+; When folding %19, it generates the constants %true and %24.  They are dead\n+; because they cannot be replaced anywhere in the IR.  CCP was wrongly\n+; considering the IR to be unmodified because of this.\n+;\n+; CHECK: %true = OpConstantTrue %bool\n+; CHECK: %24 = OpConstantComposite %v3bool %true %true %true\n+; CHECK: %float_1 = OpConstant %float 1\n+; CHECK: %float_0_699999988 = OpConstant %float 0.699999988\n+\n+          %2 = OpFunction %void None %4\n+         %15 = OpLabel\n+               OpBranch %16\n+         %16 = OpLabel\n+         %17 = OpPhi %v3float %12 %15 %14 %18\n+         %19 = OpFOrdLessThan %v3bool %17 %14\n+         %20 = OpAll %bool %19\n+               OpLoopMerge %21 %18 None\n+               OpBranchConditional %20 %18 %21\n+         %18 = OpLabel\n+               OpBranch %16\n+         %21 = OpLabel\n+         %22 = OpExtInst %v3float %1 FMix %12 %17 %14\n+               OpReturn\n+               OpFunctionEnd\n+)\";\n+\n+  auto result = SinglePassRunAndMatch<CCPPass>(text, true);\n+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);\n+}\n }  // namespace\n }  // namespace opt\n }  // namespace spvtools"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_286b3095dd187da747f85baf9ce3120580565df0/build_286b3095dd187da747f85baf9ce3120580565df0\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_286b3095dd187da747f85baf9ce3120580565df0/build_286b3095dd187da747f85baf9ce3120580565df0\n    Start 13: spirv-tools-test_opt\n1/2 Test #13: spirv-tools-test_opt .............***Failed   34.28 sec\n    Start 15: spirv-tools-test_opt_loops\n2/2 Test #15: spirv-tools-test_opt_loops .......   Passed    4.76 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  39.05 sec\n\nThe following tests FAILED:\n\t 13 - spirv-tools-test_opt (Failed)\n"
    },
    "4fa1a6f9b497193e54a814112f17ab3c2cf58053___ccp_pass.cpp": {
        "prefix": "SSAPropagator::PropStatus CCPPass::VisitAssignment(Instruction* instr) {\n  assert(instr->result_id() != 0 &&\n         \"Expecting an instruction that produces a result\");\n\n  // If this is a copy operation, and the RHS is a known constant, assign its\n  // value to the LHS.\n  if (instr->opcode() == SpvOpCopyObject) {\n    uint32_t rhs_id = instr->GetSingleWordInOperand(0);\n    auto it = values_.find(rhs_id);\n    if (it != values_.end()) {\n      if (IsVaryingValue(it->second)) {\n        return MarkInstructionVarying(instr);\n      } else {\n        uint32_t new_val = ComputeLatticeMeet(instr, it->second);\n        values_[instr->result_id()] = new_val;\n        return IsVaryingValue(new_val) ? SSAPropagator::kVarying\n                                       : SSAPropagator::kInteresting;\n      }\n    }\n    return SSAPropagator::kNotInteresting;\n  }\n\n  // Instructions with a RHS that cannot produce a constant are always varying.\n  if (!instr->IsFoldable()) {\n    return MarkInstructionVarying(instr);\n  }\n\n  // See if the RHS of the assignment folds into a constant value.\n  auto map_func = [this](uint32_t id) {\n    auto it = values_.find(id);\n    if (it == values_.end() || IsVaryingValue(it->second)) {\n      return id;\n    }\n    return it->second;\n  };\n  Instruction* folded_inst =\n      context()->get_instruction_folder().FoldInstructionToConstant(instr,\n                                                                    map_func);\n\n  if (folded_inst != nullptr) {\n    // We do not want to change the body of the function by adding new\n    // instructions.  When folding we can only generate new constants.\n",
        "suffix": "           \"CCP is only interested in constant values.\");\n    uint32_t new_val = ComputeLatticeMeet(instr, folded_inst->result_id());\n    values_[instr->result_id()] = new_val;\n    return IsVaryingValue(new_val) ? SSAPropagator::kVarying\n                                   : SSAPropagator::kInteresting;\n  }\n\n  // Conservatively mark this instruction as varying if any input id is varying.\n  if (!instr->WhileEachInId([this](uint32_t* op_id) {\n        auto iter = values_.find(*op_id);\n        if (iter != values_.end() && IsVaryingValue(iter->second)) return false;\n        return true;\n      })) {\n    return MarkInstructionVarying(instr);\n  }\n\n  // If not, see if there is a least one unknown operand to the instruction.  If\n  // so, we might be able to fold it later.\n  if (!instr->WhileEachInId([this](uint32_t* op_id) {\n        auto it = values_.find(*op_id);\n        if (it == values_.end()) return false;\n        return true;\n      })) {\n    return SSAPropagator::kNotInteresting;\n  }\n\n  // Otherwise, we will never be able to fold this instruction, so mark it\n  // varying.\n  return MarkInstructionVarying(instr);\n}\n",
        "start": 133,
        "end": 205,
        "buggy": "SSAPropagator::PropStatus CCPPass::VisitAssignment(Instruction* instr) {\n  assert(instr->result_id() != 0 &&\n         \"Expecting an instruction that produces a result\");\n\n  // If this is a copy operation, and the RHS is a known constant, assign its\n  // value to the LHS.\n  if (instr->opcode() == SpvOpCopyObject) {\n    uint32_t rhs_id = instr->GetSingleWordInOperand(0);\n    auto it = values_.find(rhs_id);\n    if (it != values_.end()) {\n      if (IsVaryingValue(it->second)) {\n        return MarkInstructionVarying(instr);\n      } else {\n        uint32_t new_val = ComputeLatticeMeet(instr, it->second);\n        values_[instr->result_id()] = new_val;\n        return IsVaryingValue(new_val) ? SSAPropagator::kVarying\n                                       : SSAPropagator::kInteresting;\n      }\n    }\n    return SSAPropagator::kNotInteresting;\n  }\n\n  // Instructions with a RHS that cannot produce a constant are always varying.\n  if (!instr->IsFoldable()) {\n    return MarkInstructionVarying(instr);\n  }\n\n  // See if the RHS of the assignment folds into a constant value.\n  auto map_func = [this](uint32_t id) {\n    auto it = values_.find(id);\n    if (it == values_.end() || IsVaryingValue(it->second)) {\n      return id;\n    }\n    return it->second;\n  };\n  Instruction* folded_inst =\n      context()->get_instruction_folder().FoldInstructionToConstant(instr,\n                                                                    map_func);\n\n  if (folded_inst != nullptr) {\n    // We do not want to change the body of the function by adding new\n    // instructions.  When folding we can only generate new constants.\n    assert(folded_inst->IsConstant() &&\n           \"CCP is only interested in constant values.\");\n    uint32_t new_val = ComputeLatticeMeet(instr, folded_inst->result_id());\n    values_[instr->result_id()] = new_val;\n    return IsVaryingValue(new_val) ? SSAPropagator::kVarying\n                                   : SSAPropagator::kInteresting;\n  }\n\n  // Conservatively mark this instruction as varying if any input id is varying.\n  if (!instr->WhileEachInId([this](uint32_t* op_id) {\n        auto iter = values_.find(*op_id);\n        if (iter != values_.end() && IsVaryingValue(iter->second)) return false;\n        return true;\n      })) {\n    return MarkInstructionVarying(instr);\n  }\n\n  // If not, see if there is a least one unknown operand to the instruction.  If\n  // so, we might be able to fold it later.\n  if (!instr->WhileEachInId([this](uint32_t* op_id) {\n        auto it = values_.find(*op_id);\n        if (it == values_.end()) return false;\n        return true;\n      })) {\n    return SSAPropagator::kNotInteresting;\n  }\n\n  // Otherwise, we will never be able to fold this instruction, so mark it\n  // varying.\n  return MarkInstructionVarying(instr);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    assert(folded_inst->IsConstant() &&\n",
        "src_path": "4fa1a6f9b497193e54a814112f17ab3c2cf58053___ccp_pass.cpp",
        "uri": "https://api.github.com/repos/KhronosGroup/SPIRV-Tools/commits/4fa1a6f9b497193e54a814112f17ab3c2cf58053",
        "commit_msg": "Generalize assert in ccp (#4735)\n\nCCP does not want to fold an instruction unless it folds to a constant.\r\nThere is an asser to check for this.  The question if a spec constant\r\ncounts as a constant.  The constant folder considers a spec constant a\r\nconstand, but CCP does not.  I've fixed the assert in CCP to match what\r\nthe folder does.  It should not require any new changes to CCP.",
        "test_func_diff": [
            {
                "fn": "test/opt/ccp_test.cpp",
                "patch": "@@ -582,6 +582,35 @@ TEST_F(CCPTest, SkipSpecConstantInstrucitons) {\n   EXPECT_EQ(std::get<1>(res), Pass::Status::SuccessWithoutChange);\n }\n \n+TEST_F(CCPTest, FoldConstantCompositeInstrucitonsWithSpecConst) {\n+  const std::string spv_asm = R\"(\n+               OpCapability Shader\n+               OpMemoryModel Logical GLSL450\n+               OpEntryPoint Fragment %1 \"main\"\n+               OpExecutionMode %1 OriginUpperLeft\n+       %void = OpTypeVoid\n+          %4 = OpTypeFunction %void\n+       %bool = OpTypeBool\n+     %v3bool = OpTypeVector %bool 3\n+  %_struct_8 = OpTypeStruct %v3bool\n+       %true = OpConstantTrue %bool\n+; CHECK: [[spec_const:%\\w+]] = OpSpecConstantComposite %v3bool\n+         %11 = OpSpecConstantComposite %v3bool %true %true %true\n+         %12 = OpConstantComposite %_struct_8 %11\n+; CHECK: OpFunction\n+          %1 = OpFunction %void None %4\n+         %29 = OpLabel\n+         %31 = OpCompositeExtract %v3bool %12 0\n+; CHECK: OpCompositeExtract %bool [[spec_const]] 0\n+         %32 = OpCompositeExtract %bool %31 0\n+               OpReturn\n+               OpFunctionEnd\n+  )\";\n+\n+  auto result = SinglePassRunAndMatch<CCPPass>(spv_asm, true);\n+  EXPECT_EQ(std::get<1>(result), Pass::Status::SuccessWithChange);\n+}\n+\n TEST_F(CCPTest, UpdateSubsequentPhisToVarying) {\n   const std::string text = R\"(\n OpCapability Shader"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_4fa1a6f9b497193e54a814112f17ab3c2cf58053/build_4fa1a6f9b497193e54a814112f17ab3c2cf58053\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_4fa1a6f9b497193e54a814112f17ab3c2cf58053/build_4fa1a6f9b497193e54a814112f17ab3c2cf58053\n    Start 18: spirv-tools-test_opt\n1/2 Test #18: spirv-tools-test_opt .............Subprocess aborted***Exception:   2.95 sec\n    Start 20: spirv-tools-test_opt_loops\n2/2 Test #20: spirv-tools-test_opt_loops .......   Passed    5.09 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =   8.04 sec\n\nThe following tests FAILED:\n\t 18 - spirv-tools-test_opt (Subprocess aborted)\n"
    },
    "0a43a84e02245cca40ce187d1e427a5d0b4f3d13___folding_rules.cpp": {
        "prefix": "FoldingRule VectorShuffleFeedingShuffle() {\n  return [](IRContext* context, Instruction* inst,\n            const std::vector<const analysis::Constant*>&) {\n    assert(inst->opcode() == SpvOpVectorShuffle &&\n           \"Wrong opcode.  Should be OpVectorShuffle.\");\n\n    analysis::DefUseManager* def_use_mgr = context->get_def_use_mgr();\n    analysis::TypeManager* type_mgr = context->get_type_mgr();\n\n    Instruction* feeding_shuffle_inst =\n        def_use_mgr->GetDef(inst->GetSingleWordInOperand(0));\n    analysis::Vector* op0_type =\n        type_mgr->GetType(feeding_shuffle_inst->type_id())->AsVector();\n    uint32_t op0_length = op0_type->element_count();\n\n    bool feeder_is_op0 = true;\n    if (feeding_shuffle_inst->opcode() != SpvOpVectorShuffle) {\n      feeding_shuffle_inst =\n          def_use_mgr->GetDef(inst->GetSingleWordInOperand(1));\n      feeder_is_op0 = false;\n    }\n\n    if (feeding_shuffle_inst->opcode() != SpvOpVectorShuffle) {\n      return false;\n    }\n\n    Instruction* feeder2 =\n        def_use_mgr->GetDef(feeding_shuffle_inst->GetSingleWordInOperand(0));\n    analysis::Vector* feeder_op0_type =\n        type_mgr->GetType(feeder2->type_id())->AsVector();\n    uint32_t feeder_op0_length = feeder_op0_type->element_count();\n\n    uint32_t new_feeder_id = 0;\n    std::vector<Operand> new_operands;\n    new_operands.resize(\n        2, {SPV_OPERAND_TYPE_ID, {0}});  // Place holders for vector operands.\n    const uint32_t undef_literal = 0xffffffff;\n    for (uint32_t op = 2; op < inst->NumInOperands(); ++op) {\n      uint32_t component_index = inst->GetSingleWordInOperand(op);\n\n      // Do not interpret the undefined value literal as coming from operand 1.\n      if (component_index != undef_literal &&\n          feeder_is_op0 == (component_index < op0_length)) {\n        // This component comes from the feeding_shuffle_inst.  Update\n        // |component_index| to be the index into the operand of the feeder.\n\n        // Adjust component_index to get the index into the operands of the\n        // feeding_shuffle_inst.\n        if (component_index >= op0_length) {\n          component_index -= op0_length;\n        }\n        component_index =\n            feeding_shuffle_inst->GetSingleWordInOperand(component_index + 2);\n\n        // Check if we are using a component from the first or second operand of\n        // the feeding instruction.\n        if (component_index < feeder_op0_length) {\n          if (new_feeder_id == 0) {\n            // First time through, save the id of the operand the element comes\n            // from.\n            new_feeder_id = feeding_shuffle_inst->GetSingleWordInOperand(0);\n          } else if (new_feeder_id !=\n                     feeding_shuffle_inst->GetSingleWordInOperand(0)) {\n            // We need both elements of the feeding_shuffle_inst, so we cannot\n            // fold.\n            return false;\n          }\n        } else if (component_index != undef_literal) {\n          if (new_feeder_id == 0) {\n            // First time through, save the id of the operand the element comes\n            // from.\n            new_feeder_id = feeding_shuffle_inst->GetSingleWordInOperand(1);\n          } else if (new_feeder_id !=\n                     feeding_shuffle_inst->GetSingleWordInOperand(1)) {\n            // We need both elements of the feeding_shuffle_inst, so we cannot\n            // fold.\n            return false;\n          }\n          component_index -= feeder_op0_length;\n        }\n\n        if (!feeder_is_op0 && component_index != undef_literal) {\n          component_index += op0_length;\n        }\n      }\n      new_operands.push_back(\n          {SPV_OPERAND_TYPE_LITERAL_INTEGER, {component_index}});\n    }\n\n    if (new_feeder_id == 0) {\n      analysis::ConstantManager* const_mgr = context->get_constant_mgr();\n      const analysis::Type* type =\n          type_mgr->GetType(feeding_shuffle_inst->type_id());\n      const analysis::Constant* null_const = const_mgr->GetConstant(type, {});\n      new_feeder_id =\n          const_mgr->GetDefiningInstruction(null_const, 0)->result_id();\n    }\n\n    if (feeder_is_op0) {\n      // If the size of the first vector operand changed then the indices\n      // referring to the second operand need to be adjusted.\n      Instruction* new_feeder_inst = def_use_mgr->GetDef(new_feeder_id);\n      analysis::Type* new_feeder_type =\n          type_mgr->GetType(new_feeder_inst->type_id());\n      uint32_t new_op0_size = new_feeder_type->AsVector()->element_count();\n      int32_t adjustment = op0_length - new_op0_size;\n\n      if (adjustment != 0) {\n        for (uint32_t i = 2; i < new_operands.size(); i++) {\n",
        "suffix": "            new_operands[i].words[0] -= adjustment;\n          }\n        }\n      }\n\n      new_operands[0].words[0] = new_feeder_id;\n      new_operands[1] = inst->GetInOperand(1);\n    } else {\n      new_operands[1].words[0] = new_feeder_id;\n      new_operands[0] = inst->GetInOperand(0);\n    }\n\n    inst->SetInOperands(std::move(new_operands));\n    return true;\n  };\n}\n",
        "start": 2642,
        "end": 2767,
        "buggy": "FoldingRule VectorShuffleFeedingShuffle() {\n  return [](IRContext* context, Instruction* inst,\n            const std::vector<const analysis::Constant*>&) {\n    assert(inst->opcode() == SpvOpVectorShuffle &&\n           \"Wrong opcode.  Should be OpVectorShuffle.\");\n\n    analysis::DefUseManager* def_use_mgr = context->get_def_use_mgr();\n    analysis::TypeManager* type_mgr = context->get_type_mgr();\n\n    Instruction* feeding_shuffle_inst =\n        def_use_mgr->GetDef(inst->GetSingleWordInOperand(0));\n    analysis::Vector* op0_type =\n        type_mgr->GetType(feeding_shuffle_inst->type_id())->AsVector();\n    uint32_t op0_length = op0_type->element_count();\n\n    bool feeder_is_op0 = true;\n    if (feeding_shuffle_inst->opcode() != SpvOpVectorShuffle) {\n      feeding_shuffle_inst =\n          def_use_mgr->GetDef(inst->GetSingleWordInOperand(1));\n      feeder_is_op0 = false;\n    }\n\n    if (feeding_shuffle_inst->opcode() != SpvOpVectorShuffle) {\n      return false;\n    }\n\n    Instruction* feeder2 =\n        def_use_mgr->GetDef(feeding_shuffle_inst->GetSingleWordInOperand(0));\n    analysis::Vector* feeder_op0_type =\n        type_mgr->GetType(feeder2->type_id())->AsVector();\n    uint32_t feeder_op0_length = feeder_op0_type->element_count();\n\n    uint32_t new_feeder_id = 0;\n    std::vector<Operand> new_operands;\n    new_operands.resize(\n        2, {SPV_OPERAND_TYPE_ID, {0}});  // Place holders for vector operands.\n    const uint32_t undef_literal = 0xffffffff;\n    for (uint32_t op = 2; op < inst->NumInOperands(); ++op) {\n      uint32_t component_index = inst->GetSingleWordInOperand(op);\n\n      // Do not interpret the undefined value literal as coming from operand 1.\n      if (component_index != undef_literal &&\n          feeder_is_op0 == (component_index < op0_length)) {\n        // This component comes from the feeding_shuffle_inst.  Update\n        // |component_index| to be the index into the operand of the feeder.\n\n        // Adjust component_index to get the index into the operands of the\n        // feeding_shuffle_inst.\n        if (component_index >= op0_length) {\n          component_index -= op0_length;\n        }\n        component_index =\n            feeding_shuffle_inst->GetSingleWordInOperand(component_index + 2);\n\n        // Check if we are using a component from the first or second operand of\n        // the feeding instruction.\n        if (component_index < feeder_op0_length) {\n          if (new_feeder_id == 0) {\n            // First time through, save the id of the operand the element comes\n            // from.\n            new_feeder_id = feeding_shuffle_inst->GetSingleWordInOperand(0);\n          } else if (new_feeder_id !=\n                     feeding_shuffle_inst->GetSingleWordInOperand(0)) {\n            // We need both elements of the feeding_shuffle_inst, so we cannot\n            // fold.\n            return false;\n          }\n        } else if (component_index != undef_literal) {\n          if (new_feeder_id == 0) {\n            // First time through, save the id of the operand the element comes\n            // from.\n            new_feeder_id = feeding_shuffle_inst->GetSingleWordInOperand(1);\n          } else if (new_feeder_id !=\n                     feeding_shuffle_inst->GetSingleWordInOperand(1)) {\n            // We need both elements of the feeding_shuffle_inst, so we cannot\n            // fold.\n            return false;\n          }\n          component_index -= feeder_op0_length;\n        }\n\n        if (!feeder_is_op0 && component_index != undef_literal) {\n          component_index += op0_length;\n        }\n      }\n      new_operands.push_back(\n          {SPV_OPERAND_TYPE_LITERAL_INTEGER, {component_index}});\n    }\n\n    if (new_feeder_id == 0) {\n      analysis::ConstantManager* const_mgr = context->get_constant_mgr();\n      const analysis::Type* type =\n          type_mgr->GetType(feeding_shuffle_inst->type_id());\n      const analysis::Constant* null_const = const_mgr->GetConstant(type, {});\n      new_feeder_id =\n          const_mgr->GetDefiningInstruction(null_const, 0)->result_id();\n    }\n\n    if (feeder_is_op0) {\n      // If the size of the first vector operand changed then the indices\n      // referring to the second operand need to be adjusted.\n      Instruction* new_feeder_inst = def_use_mgr->GetDef(new_feeder_id);\n      analysis::Type* new_feeder_type =\n          type_mgr->GetType(new_feeder_inst->type_id());\n      uint32_t new_op0_size = new_feeder_type->AsVector()->element_count();\n      int32_t adjustment = op0_length - new_op0_size;\n\n      if (adjustment != 0) {\n        for (uint32_t i = 2; i < new_operands.size(); i++) {\n          if (inst->GetSingleWordInOperand(i) >= op0_length) {\n            new_operands[i].words[0] -= adjustment;\n          }\n        }\n      }\n\n      new_operands[0].words[0] = new_feeder_id;\n      new_operands[1] = inst->GetInOperand(1);\n    } else {\n      new_operands[1].words[0] = new_feeder_id;\n      new_operands[0] = inst->GetInOperand(0);\n    }\n\n    inst->SetInOperands(std::move(new_operands));\n    return true;\n  };\n}\n",
        "fix": null,
        "buggy_hunk_masked": "          if (inst->GetSingleWordInOperand(i) >= op0_length) {\n",
        "src_path": "0a43a84e02245cca40ce187d1e427a5d0b4f3d13___folding_rules.cpp",
        "uri": "https://api.github.com/repos/KhronosGroup/SPIRV-Tools/commits/0a43a84e02245cca40ce187d1e427a5d0b4f3d13",
        "commit_msg": "Fix shuffle feeding shuffle with undef literal (#4883)\n\nWhen folding a vector shuffle with an undef literal, it is possible that the\r\nliteral is adjusted so that it will then be interpreted as an index into\r\nthe input operands.  This is fixed by special casing that case, and not\r\nadjusting those operands.\r\n\r\nFixes #4859",
        "test_func_diff": [
            {
                "fn": "test/opt/fold_test.cpp",
                "patch": "@@ -7963,6 +7963,27 @@ ::testing::Values(\n             \"%9 = OpVectorShuffle %v4double %7 %8 2 0 1 4294967295\\n\" +\n             \"OpReturn\\n\" +\n             \"OpFunctionEnd\",\n+        9, true),\n+    // Test case 14: Shuffle with undef literal and change size of first input vector.\n+    InstructionFoldingCase<bool>(\n+        Header() +\n+            \"; CHECK: [[double:%\\\\w+]] = OpTypeFloat 64\\n\" +\n+            \"; CHECK: [[v4double:%\\\\w+]] = OpTypeVector [[double]] 2\\n\" +\n+            \"; CHECK: OpVectorShuffle\\n\" +\n+            \"; CHECK: OpVectorShuffle {{%\\\\w+}} %5 %7 0 1 4 4294967295\\n\" +\n+            \"; CHECK: OpReturn\\n\" +\n+            \"%main = OpFunction %void None %void_func\\n\" +\n+            \"%main_lab = OpLabel\\n\" +\n+            \"%2 = OpVariable %_ptr_v4double Function\\n\" +\n+            \"%3 = OpVariable %_ptr_v4double Function\\n\" +\n+            \"%4 = OpVariable %_ptr_v4double Function\\n\" +\n+            \"%5 = OpLoad %v4double %2\\n\" +\n+            \"%6 = OpLoad %v4double %3\\n\" +\n+            \"%7 = OpLoad %v4double %4\\n\" +\n+            \"%8 = OpVectorShuffle %v2double %5 %5 0 1\\n\" +\n+            \"%9 = OpVectorShuffle %v4double %8 %7 0 1 2 4294967295\\n\" +\n+            \"OpReturn\\n\" +\n+            \"OpFunctionEnd\",\n         9, true)\n ));\n "
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0a43a84e02245cca40ce187d1e427a5d0b4f3d13/build_0a43a84e02245cca40ce187d1e427a5d0b4f3d13\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0a43a84e02245cca40ce187d1e427a5d0b4f3d13/build_0a43a84e02245cca40ce187d1e427a5d0b4f3d13\n    Start 18: spirv-tools-test_opt\n1/2 Test #18: spirv-tools-test_opt .............***Failed   60.75 sec\n    Start 20: spirv-tools-test_opt_loops\n2/2 Test #20: spirv-tools-test_opt_loops .......   Passed    7.01 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  67.78 sec\n\nThe following tests FAILED:\n\t 18 - spirv-tools-test_opt (Failed)\n"
    },
    "0391d0823ebfd7c37c07a54b8726cc417183a95f___value_number_table.cpp": {
        "prefix": "uint32_t ValueNumberTable::AssignValueNumber(Instruction* inst) {\n  // If it already has a value return that.\n  uint32_t value = GetValueNumber(inst);\n  if (value != 0) {\n    return value;\n  }\n\n  // If the instruction has other side effects, then it must\n  // have its own value number.\n  // OpSampledImage and OpImage must remain in the same basic block in which\n  // they are used, because of this we will assign each one it own value number.\n  if (!context()->IsCombinatorInstruction(inst)) {\n    value = TakeNextValueNumber();\n    id_to_value_[inst->result_id()] = value;\n    return value;\n  }\n\n  switch (inst->opcode()) {\n    case SpvOpSampledImage:\n    case SpvOpImage:\n    case SpvOpVariable:\n      value = TakeNextValueNumber();\n      id_to_value_[inst->result_id()] = value;\n      return value;\n    default:\n      break;\n  }\n\n  // If it is a load from memory that can be modified, we have to assume the\n  // memory has been modified, so we give it a new value number.\n  //\n  // Note that this test will also handle volatile loads because they are not\n  // read only.  However, if this is ever relaxed because we analyze stores, we\n  // will have to add a new case for volatile loads.\n  if (inst->IsLoad() && !inst->IsReadOnlyLoad()) {\n    value = TakeNextValueNumber();\n    id_to_value_[inst->result_id()] = value;\n    return value;\n  }\n\n  analysis::DecorationManager* dec_mgr = context()->get_decoration_mgr();\n\n  // When we copy an object, the value numbers should be the same.\n  if (inst->opcode() == SpvOpCopyObject &&\n      dec_mgr->HaveTheSameDecorations(inst->result_id(),\n                                      inst->GetSingleWordInOperand(0))) {\n    value = GetValueNumber(inst->GetSingleWordInOperand(0));\n    if (value != 0) {\n      id_to_value_[inst->result_id()] = value;\n      return value;\n    }\n  }\n\n  // Phi nodes are a type of copy.  If all of the inputs have the same value\n  // number, then we can assign the result of the phi the same value number.\n",
        "suffix": "      dec_mgr->HaveTheSameDecorations(inst->result_id(),\n                                      inst->GetSingleWordInOperand(0))) {\n    value = GetValueNumber(inst->GetSingleWordInOperand(0));\n    if (value != 0) {\n      for (uint32_t op = 2; op < inst->NumInOperands(); op += 2) {\n        if (value != GetValueNumber(inst->GetSingleWordInOperand(op))) {\n          value = 0;\n          break;\n        }\n      }\n      if (value != 0) {\n        id_to_value_[inst->result_id()] = value;\n        return value;\n      }\n    }\n  }\n\n  // Replace all of the operands by their value number.  The sign bit will be\n  // set to distinguish between an id and a value number.\n  Instruction value_ins(context(), inst->opcode(), inst->type_id(),\n                        inst->result_id(), {});\n  for (uint32_t o = 0; o < inst->NumInOperands(); ++o) {\n    const Operand& op = inst->GetInOperand(o);\n    if (spvIsIdType(op.type)) {\n      uint32_t id_value = op.words[0];\n      auto use_id_to_val = id_to_value_.find(id_value);\n      if (use_id_to_val != id_to_value_.end()) {\n        id_value = (1 << 31) | use_id_to_val->second;\n      }\n      value_ins.AddOperand(Operand(op.type, {id_value}));\n    } else {\n      value_ins.AddOperand(Operand(op.type, op.words));\n    }\n  }\n\n  // TODO: Implement a normal form for opcodes that commute like integer\n  // addition.  This will let us know that a+b is the same value as b+a.\n\n  // Otherwise, we check if this value has been computed before.\n  auto value_iterator = instruction_to_value_.find(value_ins);\n  if (value_iterator != instruction_to_value_.end()) {\n    value = id_to_value_[value_iterator->first.result_id()];\n    id_to_value_[inst->result_id()] = value;\n    return value;\n  }\n\n  // If not, assign it a new value number.\n  value = TakeNextValueNumber();\n  id_to_value_[inst->result_id()] = value;\n  instruction_to_value_[value_ins] = value;\n  return value;\n}\n",
        "start": 41,
        "end": 148,
        "buggy": "uint32_t ValueNumberTable::AssignValueNumber(Instruction* inst) {\n  // If it already has a value return that.\n  uint32_t value = GetValueNumber(inst);\n  if (value != 0) {\n    return value;\n  }\n\n  // If the instruction has other side effects, then it must\n  // have its own value number.\n  // OpSampledImage and OpImage must remain in the same basic block in which\n  // they are used, because of this we will assign each one it own value number.\n  if (!context()->IsCombinatorInstruction(inst)) {\n    value = TakeNextValueNumber();\n    id_to_value_[inst->result_id()] = value;\n    return value;\n  }\n\n  switch (inst->opcode()) {\n    case SpvOpSampledImage:\n    case SpvOpImage:\n    case SpvOpVariable:\n      value = TakeNextValueNumber();\n      id_to_value_[inst->result_id()] = value;\n      return value;\n    default:\n      break;\n  }\n\n  // If it is a load from memory that can be modified, we have to assume the\n  // memory has been modified, so we give it a new value number.\n  //\n  // Note that this test will also handle volatile loads because they are not\n  // read only.  However, if this is ever relaxed because we analyze stores, we\n  // will have to add a new case for volatile loads.\n  if (inst->IsLoad() && !inst->IsReadOnlyLoad()) {\n    value = TakeNextValueNumber();\n    id_to_value_[inst->result_id()] = value;\n    return value;\n  }\n\n  analysis::DecorationManager* dec_mgr = context()->get_decoration_mgr();\n\n  // When we copy an object, the value numbers should be the same.\n  if (inst->opcode() == SpvOpCopyObject &&\n      dec_mgr->HaveTheSameDecorations(inst->result_id(),\n                                      inst->GetSingleWordInOperand(0))) {\n    value = GetValueNumber(inst->GetSingleWordInOperand(0));\n    if (value != 0) {\n      id_to_value_[inst->result_id()] = value;\n      return value;\n    }\n  }\n\n  // Phi nodes are a type of copy.  If all of the inputs have the same value\n  // number, then we can assign the result of the phi the same value number.\n  if (inst->opcode() == SpvOpPhi &&\n      dec_mgr->HaveTheSameDecorations(inst->result_id(),\n                                      inst->GetSingleWordInOperand(0))) {\n    value = GetValueNumber(inst->GetSingleWordInOperand(0));\n    if (value != 0) {\n      for (uint32_t op = 2; op < inst->NumInOperands(); op += 2) {\n        if (value != GetValueNumber(inst->GetSingleWordInOperand(op))) {\n          value = 0;\n          break;\n        }\n      }\n      if (value != 0) {\n        id_to_value_[inst->result_id()] = value;\n        return value;\n      }\n    }\n  }\n\n  // Replace all of the operands by their value number.  The sign bit will be\n  // set to distinguish between an id and a value number.\n  Instruction value_ins(context(), inst->opcode(), inst->type_id(),\n                        inst->result_id(), {});\n  for (uint32_t o = 0; o < inst->NumInOperands(); ++o) {\n    const Operand& op = inst->GetInOperand(o);\n    if (spvIsIdType(op.type)) {\n      uint32_t id_value = op.words[0];\n      auto use_id_to_val = id_to_value_.find(id_value);\n      if (use_id_to_val != id_to_value_.end()) {\n        id_value = (1 << 31) | use_id_to_val->second;\n      }\n      value_ins.AddOperand(Operand(op.type, {id_value}));\n    } else {\n      value_ins.AddOperand(Operand(op.type, op.words));\n    }\n  }\n\n  // TODO: Implement a normal form for opcodes that commute like integer\n  // addition.  This will let us know that a+b is the same value as b+a.\n\n  // Otherwise, we check if this value has been computed before.\n  auto value_iterator = instruction_to_value_.find(value_ins);\n  if (value_iterator != instruction_to_value_.end()) {\n    value = id_to_value_[value_iterator->first.result_id()];\n    id_to_value_[inst->result_id()] = value;\n    return value;\n  }\n\n  // If not, assign it a new value number.\n  value = TakeNextValueNumber();\n  id_to_value_[inst->result_id()] = value;\n  instruction_to_value_[value_ins] = value;\n  return value;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  if (inst->opcode() == SpvOpPhi &&\n",
        "src_path": "0391d0823ebfd7c37c07a54b8726cc417183a95f___value_number_table.cpp",
        "uri": "https://api.github.com/repos/KhronosGroup/SPIRV-Tools/commits/0391d0823ebfd7c37c07a54b8726cc417183a95f",
        "commit_msg": "Handle OpPhi with no in operands in value numbering (#3056)\n\nFixes #3043",
        "test_func_diff": [
            {
                "fn": "test/opt/value_table_test.cpp",
                "patch": "@@ -653,6 +653,37 @@ TEST_F(ValueTableTest, PhiLoopTest) {\n   EXPECT_NE(vtable.GetValueNumber(phi1), vtable.GetValueNumber(phi2));\n }\n \n+// Test to make sure that OpPhi instructions with no in operands are handled\n+// correctly.\n+TEST_F(ValueTableTest, EmptyPhiTest) {\n+  const std::string text = R\"(\n+               OpCapability Shader\n+          %1 = OpExtInstImport \"GLSL.std.450\"\n+               OpMemoryModel Logical GLSL450\n+               OpEntryPoint Fragment %2 \"main\"\n+               OpExecutionMode %2 OriginUpperLeft\n+               OpSource GLSL 430\n+       %void = OpTypeVoid\n+          %4 = OpTypeFunction %void\n+       %bool = OpTypeBool\n+       %true = OpConstantTrue %bool\n+          %2 = OpFunction %void None %4\n+          %7 = OpLabel\n+               OpSelectionMerge %8 None\n+               OpBranchConditional %true %9 %8\n+          %9 = OpLabel\n+               OpKill\n+          %8 = OpLabel\n+         %10 = OpPhi %bool\n+               OpReturn\n+               OpFunctionEnd\n+  )\";\n+  auto context = BuildModule(SPV_ENV_UNIVERSAL_1_2, nullptr, text);\n+  ValueNumberTable vtable(context.get());\n+  Instruction* inst = context->get_def_use_mgr()->GetDef(10);\n+  vtable.GetValueNumber(inst);\n+}\n+\n }  // namespace\n }  // namespace opt\n }  // namespace spvtools"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0391d0823ebfd7c37c07a54b8726cc417183a95f/build_0391d0823ebfd7c37c07a54b8726cc417183a95f\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0391d0823ebfd7c37c07a54b8726cc417183a95f/build_0391d0823ebfd7c37c07a54b8726cc417183a95f\n    Start 13: spirv-tools-test_opt\n1/2 Test #13: spirv-tools-test_opt .............Subprocess aborted***Exception:  16.33 sec\n    Start 15: spirv-tools-test_opt_loops\n2/2 Test #15: spirv-tools-test_opt_loops .......   Passed    5.51 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  21.84 sec\n\nThe following tests FAILED:\n\t 13 - spirv-tools-test_opt (Subprocess aborted)\n"
    },
    "0ad83f9139daf70a791560f5c72f94b0be5b8390___diff.cpp": {
        "prefix": "void Differ::MatchConstants() {\n  // Bunch all of constant ids as potential matches.\n  PotentialIdMap potential_id_map;\n  auto get_result_id = [](const opt::Instruction& inst) {\n    return inst.result_id();\n  };\n  auto accept_type_ops = [](const opt::Instruction& inst) {\n    return spvOpcodeIsConstant(inst.opcode());\n  };\n\n  PoolPotentialIds(src_->types_values(), potential_id_map.src_ids,\n                   accept_type_ops, get_result_id);\n  PoolPotentialIds(dst_->types_values(), potential_id_map.dst_ids,\n                   accept_type_ops, get_result_id);\n\n  // Then match the ids.  Constants are matched exactly, except for float types\n  // that are first matched exactly, then leftovers are matched with a small\n  // error.\n  for (uint32_t flexibility = 0; flexibility < 2; ++flexibility) {\n    MatchIds(potential_id_map, [this, flexibility](\n                                   const opt::Instruction* src_inst,\n                                   const opt::Instruction* dst_inst) {\n      const SpvOp src_op = src_inst->opcode();\n      const SpvOp dst_op = dst_inst->opcode();\n\n      // Don't match if the opcode is not the same.\n      if (src_op != dst_op) {\n        return false;\n      }\n\n      switch (src_op) {\n        case SpvOpConstantTrue:\n        case SpvOpConstantFalse:\n          // true and false are unique, match them.\n          return true;\n        case SpvOpConstant:\n          return MatchOpConstant(src_inst, dst_inst, flexibility);\n        case SpvOpConstantComposite:\n          // Composite constants must match in type and value.\n          //\n          // TODO: match OpConstantNull with OpConstantComposite with all zeros\n          // at flexibility == 1\n          // TODO: match constants from structs that have been flexibly-matched.\n          if (src_inst->NumInOperandWords() != dst_inst->NumInOperandWords()) {\n            return false;\n",
        "suffix": "          return DoesOperandMatch(src_inst->GetOperand(0),\n                                  dst_inst->GetOperand(0)) &&\n                 DoOperandsMatch(src_inst, dst_inst, 0,\n                                 src_inst->NumInOperandWords());\n        case SpvOpConstantSampler:\n          // Match sampler constants exactly.\n          // TODO: Allow flexibility in parameters to better diff shaders where\n          // the sampler param has changed.\n          assert(src_inst->NumInOperandWords() ==\n                 dst_inst->NumInOperandWords());\n          return DoOperandsMatch(src_inst, dst_inst, 0,\n                                 src_inst->NumInOperandWords());\n        case SpvOpConstantNull:\n          // Match null constants as long as the type matches.\n          return DoesOperandMatch(src_inst->GetOperand(0),\n                                  dst_inst->GetOperand(0));\n\n        case SpvOpSpecConstantTrue:\n        case SpvOpSpecConstantFalse:\n        case SpvOpSpecConstant:\n        case SpvOpSpecConstantComposite:\n        case SpvOpSpecConstantOp:\n          // Match spec constants by name if available, then by the SpecId\n          // decoration.\n          return MatchOpSpecConstant(src_inst, dst_inst);\n\n        default:\n          return false;\n      }\n    });\n  }\n}\n",
        "start": 2029,
        "end": 2106,
        "buggy": "void Differ::MatchConstants() {\n  // Bunch all of constant ids as potential matches.\n  PotentialIdMap potential_id_map;\n  auto get_result_id = [](const opt::Instruction& inst) {\n    return inst.result_id();\n  };\n  auto accept_type_ops = [](const opt::Instruction& inst) {\n    return spvOpcodeIsConstant(inst.opcode());\n  };\n\n  PoolPotentialIds(src_->types_values(), potential_id_map.src_ids,\n                   accept_type_ops, get_result_id);\n  PoolPotentialIds(dst_->types_values(), potential_id_map.dst_ids,\n                   accept_type_ops, get_result_id);\n\n  // Then match the ids.  Constants are matched exactly, except for float types\n  // that are first matched exactly, then leftovers are matched with a small\n  // error.\n  for (uint32_t flexibility = 0; flexibility < 2; ++flexibility) {\n    MatchIds(potential_id_map, [this, flexibility](\n                                   const opt::Instruction* src_inst,\n                                   const opt::Instruction* dst_inst) {\n      const SpvOp src_op = src_inst->opcode();\n      const SpvOp dst_op = dst_inst->opcode();\n\n      // Don't match if the opcode is not the same.\n      if (src_op != dst_op) {\n        return false;\n      }\n\n      switch (src_op) {\n        case SpvOpConstantTrue:\n        case SpvOpConstantFalse:\n          // true and false are unique, match them.\n          return true;\n        case SpvOpConstant:\n          return MatchOpConstant(src_inst, dst_inst, flexibility);\n        case SpvOpConstantComposite:\n          // Composite constants must match in type and value.\n          //\n          // TODO: match OpConstantNull with OpConstantComposite with all zeros\n          // at flexibility == 1\n          // TODO: match constants from structs that have been flexibly-matched.\n          if (src_inst->NumInOperandWords() != dst_inst->NumInOperandWords()) {\n            return false;\n          }\n          return DoesOperandMatch(src_inst->GetOperand(0),\n                                  dst_inst->GetOperand(0)) &&\n                 DoOperandsMatch(src_inst, dst_inst, 0,\n                                 src_inst->NumInOperandWords());\n        case SpvOpConstantSampler:\n          // Match sampler constants exactly.\n          // TODO: Allow flexibility in parameters to better diff shaders where\n          // the sampler param has changed.\n          assert(src_inst->NumInOperandWords() ==\n                 dst_inst->NumInOperandWords());\n          return DoOperandsMatch(src_inst, dst_inst, 0,\n                                 src_inst->NumInOperandWords());\n        case SpvOpConstantNull:\n          // Match null constants as long as the type matches.\n          return DoesOperandMatch(src_inst->GetOperand(0),\n                                  dst_inst->GetOperand(0));\n\n        case SpvOpSpecConstantTrue:\n        case SpvOpSpecConstantFalse:\n        case SpvOpSpecConstant:\n        case SpvOpSpecConstantComposite:\n        case SpvOpSpecConstantOp:\n          // Match spec constants by name if available, then by the SpecId\n          // decoration.\n          return MatchOpSpecConstant(src_inst, dst_inst);\n\n        default:\n          return false;\n      }\n    });\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "          }\n",
        "src_path": "0ad83f9139daf70a791560f5c72f94b0be5b8390___diff.cpp",
        "uri": "https://api.github.com/repos/KhronosGroup/SPIRV-Tools/commits/0ad83f9139daf70a791560f5c72f94b0be5b8390",
        "commit_msg": "spirv-diff: Match OpSpecConstantComposite correctly (#4704)\n\nOpSpecConstantComposite is not decorated with SpecId, and so is matched\r\nsimilarly to OpConstantComposite.",
        "test_func_diff": [
            {
                "fn": "test/diff/diff_files/diff_test_files_autogen.cmake",
                "patch": "@@ -33,5 +33,6 @@ list(APPEND DIFF_TEST_FILES\n \"diff_files/reordered_switch_blocks_autogen.cpp\"\n \"diff_files/small_functions_small_diffs_autogen.cpp\"\n \"diff_files/spec_constant_array_size_autogen.cpp\"\n+\"diff_files/spec_constant_composite_autogen.cpp\"\n \"diff_files/unrelated_shaders_autogen.cpp\"\n )"
            },
            {
                "fn": "test/diff/diff_files/spec_constant_composite_autogen.cpp",
                "patch": "@@ -0,0 +1,186 @@\n+// GENERATED FILE - DO NOT EDIT.\n+// Generated by generate_tests.py\n+//\n+// Copyright (c) 2022 Google LLC.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include \"../diff_test_utils.h\"\n+\n+#include \"gtest/gtest.h\"\n+\n+namespace spvtools {\n+namespace diff {\n+namespace {\n+\n+// Tests OpSpecConstantComposite matching.\n+constexpr char kSrc[] = R\"(               OpCapability Shader\n+          %1 = OpExtInstImport \"GLSL.std.450\"\n+               OpMemoryModel Logical GLSL450\n+               OpEntryPoint GLCompute %main \"main\"\n+               OpExecutionMode %main LocalSize 1 1 1\n+               OpSource GLSL 450\n+               OpName %main \"main\"\n+               OpDecorate %7 SpecId 3\n+               OpDecorate %8 SpecId 4\n+               OpDecorate %gl_WorkGroupSize BuiltIn WorkgroupSize\n+       %void = OpTypeVoid\n+          %3 = OpTypeFunction %void\n+       %uint = OpTypeInt 32 0\n+          %7 = OpSpecConstant %uint 1\n+          %8 = OpSpecConstant %uint 1\n+     %uint_1 = OpConstant %uint 1\n+     %v3uint = OpTypeVector %uint 3\n+%gl_WorkGroupSize = OpSpecConstantComposite %v3uint %7 %8 %uint_1\n+       %main = OpFunction %void None %3\n+          %5 = OpLabel\n+               OpReturn\n+               OpFunctionEnd)\";\n+constexpr char kDst[] = R\"(               OpCapability Shader\n+          %1 = OpExtInstImport \"GLSL.std.450\"\n+               OpMemoryModel Logical GLSL450\n+               OpEntryPoint GLCompute %main \"main\"\n+               OpExecutionMode %main LocalSize 1 1 1\n+               OpSource GLSL 450\n+               OpName %main \"main\"\n+               OpDecorate %7 SpecId 3\n+               OpDecorate %8 SpecId 4\n+               OpDecorate %gl_WorkGroupSize BuiltIn WorkgroupSize\n+       %void = OpTypeVoid\n+          %3 = OpTypeFunction %void\n+       %uint = OpTypeInt 32 0\n+          %7 = OpSpecConstant %uint 2048\n+          %8 = OpSpecConstant %uint 1\n+     %uint_1 = OpConstant %uint 1\n+     %v3uint = OpTypeVector %uint 3\n+%gl_WorkGroupSize = OpSpecConstantComposite %v3uint %7 %8 %uint_1\n+       %main = OpFunction %void None %3\n+          %5 = OpLabel\n+               OpReturn\n+               OpFunctionEnd\n+)\";\n+\n+TEST(DiffTest, SpecConstantComposite) {\n+  constexpr char kDiff[] = R\"( ; SPIR-V\n+ ; Version: 1.6\n+ ; Generator: Khronos SPIR-V Tools Assembler; 0\n+ ; Bound: 12\n+ ; Schema: 0\n+ OpCapability Shader\n+ %1 = OpExtInstImport \"GLSL.std.450\"\n+ OpMemoryModel Logical GLSL450\n+ OpEntryPoint GLCompute %2 \"main\"\n+ OpExecutionMode %2 LocalSize 1 1 1\n+ OpSource GLSL 450\n+ OpName %2 \"main\"\n+ OpDecorate %7 SpecId 3\n+ OpDecorate %8 SpecId 4\n+ OpDecorate %4 BuiltIn WorkgroupSize\n+ %6 = OpTypeVoid\n+ %3 = OpTypeFunction %6\n+ %9 = OpTypeInt 32 0\n+-%7 = OpSpecConstant %9 1\n++%7 = OpSpecConstant %9 2048\n+ %8 = OpSpecConstant %9 1\n+ %10 = OpConstant %9 1\n+ %11 = OpTypeVector %9 3\n+ %4 = OpSpecConstantComposite %11 %7 %8 %10\n+ %2 = OpFunction %6 None %3\n+ %5 = OpLabel\n+ OpReturn\n+ OpFunctionEnd\n+)\";\n+  Options options;\n+  DoStringDiffTest(kSrc, kDst, kDiff, options);\n+}\n+\n+TEST(DiffTest, SpecConstantCompositeNoDebug) {\n+  constexpr char kSrcNoDebug[] = R\"(               OpCapability Shader\n+          %1 = OpExtInstImport \"GLSL.std.450\"\n+               OpMemoryModel Logical GLSL450\n+               OpEntryPoint GLCompute %main \"main\"\n+               OpExecutionMode %main LocalSize 1 1 1\n+               OpSource GLSL 450\n+               OpDecorate %7 SpecId 3\n+               OpDecorate %8 SpecId 4\n+               OpDecorate %gl_WorkGroupSize BuiltIn WorkgroupSize\n+       %void = OpTypeVoid\n+          %3 = OpTypeFunction %void\n+       %uint = OpTypeInt 32 0\n+          %7 = OpSpecConstant %uint 1\n+          %8 = OpSpecConstant %uint 1\n+     %uint_1 = OpConstant %uint 1\n+     %v3uint = OpTypeVector %uint 3\n+%gl_WorkGroupSize = OpSpecConstantComposite %v3uint %7 %8 %uint_1\n+       %main = OpFunction %void None %3\n+          %5 = OpLabel\n+               OpReturn\n+               OpFunctionEnd\n+)\";\n+  constexpr char kDstNoDebug[] = R\"(               OpCapability Shader\n+          %1 = OpExtInstImport \"GLSL.std.450\"\n+               OpMemoryModel Logical GLSL450\n+               OpEntryPoint GLCompute %main \"main\"\n+               OpExecutionMode %main LocalSize 1 1 1\n+               OpSource GLSL 450\n+               OpDecorate %7 SpecId 3\n+               OpDecorate %8 SpecId 4\n+               OpDecorate %gl_WorkGroupSize BuiltIn WorkgroupSize\n+       %void = OpTypeVoid\n+          %3 = OpTypeFunction %void\n+       %uint = OpTypeInt 32 0\n+          %7 = OpSpecConstant %uint 2048\n+          %8 = OpSpecConstant %uint 1\n+     %uint_1 = OpConstant %uint 1\n+     %v3uint = OpTypeVector %uint 3\n+%gl_WorkGroupSize = OpSpecConstantComposite %v3uint %7 %8 %uint_1\n+       %main = OpFunction %void None %3\n+          %5 = OpLabel\n+               OpReturn\n+               OpFunctionEnd\n+)\";\n+  constexpr char kDiff[] = R\"( ; SPIR-V\n+ ; Version: 1.6\n+ ; Generator: Khronos SPIR-V Tools Assembler; 0\n+ ; Bound: 12\n+ ; Schema: 0\n+ OpCapability Shader\n+ %1 = OpExtInstImport \"GLSL.std.450\"\n+ OpMemoryModel Logical GLSL450\n+ OpEntryPoint GLCompute %2 \"main\"\n+ OpExecutionMode %2 LocalSize 1 1 1\n+ OpSource GLSL 450\n+ OpDecorate %7 SpecId 3\n+ OpDecorate %8 SpecId 4\n+ OpDecorate %4 BuiltIn WorkgroupSize\n+ %6 = OpTypeVoid\n+ %3 = OpTypeFunction %6\n+ %9 = OpTypeInt 32 0\n+-%7 = OpSpecConstant %9 1\n++%7 = OpSpecConstant %9 2048\n+ %8 = OpSpecConstant %9 1\n+ %10 = OpConstant %9 1\n+ %11 = OpTypeVector %9 3\n+ %4 = OpSpecConstantComposite %11 %7 %8 %10\n+ %2 = OpFunction %6 None %3\n+ %5 = OpLabel\n+ OpReturn\n+ OpFunctionEnd\n+)\";\n+  Options options;\n+  DoStringDiffTest(kSrcNoDebug, kDstNoDebug, kDiff, options);\n+}\n+\n+}  // namespace\n+}  // namespace diff\n+}  // namespace spvtools"
            },
            {
                "fn": "test/diff/diff_files/spec_constant_composite_dst.spvasm",
                "patch": "@@ -0,0 +1,22 @@\n+               OpCapability Shader\n+          %1 = OpExtInstImport \"GLSL.std.450\"\n+               OpMemoryModel Logical GLSL450\n+               OpEntryPoint GLCompute %main \"main\"\n+               OpExecutionMode %main LocalSize 1 1 1\n+               OpSource GLSL 450\n+               OpName %main \"main\"\n+               OpDecorate %7 SpecId 3\n+               OpDecorate %8 SpecId 4\n+               OpDecorate %gl_WorkGroupSize BuiltIn WorkgroupSize\n+       %void = OpTypeVoid\n+          %3 = OpTypeFunction %void\n+       %uint = OpTypeInt 32 0\n+          %7 = OpSpecConstant %uint 2048\n+          %8 = OpSpecConstant %uint 1\n+     %uint_1 = OpConstant %uint 1\n+     %v3uint = OpTypeVector %uint 3\n+%gl_WorkGroupSize = OpSpecConstantComposite %v3uint %7 %8 %uint_1\n+       %main = OpFunction %void None %3\n+          %5 = OpLabel\n+               OpReturn\n+               OpFunctionEnd"
            },
            {
                "fn": "test/diff/diff_files/spec_constant_composite_src.spvasm",
                "patch": "@@ -0,0 +1,23 @@\n+;; Tests OpSpecConstantComposite matching.\n+               OpCapability Shader\n+          %1 = OpExtInstImport \"GLSL.std.450\"\n+               OpMemoryModel Logical GLSL450\n+               OpEntryPoint GLCompute %main \"main\"\n+               OpExecutionMode %main LocalSize 1 1 1\n+               OpSource GLSL 450\n+               OpName %main \"main\"\n+               OpDecorate %7 SpecId 3\n+               OpDecorate %8 SpecId 4\n+               OpDecorate %gl_WorkGroupSize BuiltIn WorkgroupSize\n+       %void = OpTypeVoid\n+          %3 = OpTypeFunction %void\n+       %uint = OpTypeInt 32 0\n+          %7 = OpSpecConstant %uint 1\n+          %8 = OpSpecConstant %uint 1\n+     %uint_1 = OpConstant %uint 1\n+     %v3uint = OpTypeVector %uint 3\n+%gl_WorkGroupSize = OpSpecConstantComposite %v3uint %7 %8 %uint_1\n+       %main = OpFunction %void None %3\n+          %5 = OpLabel\n+               OpReturn\n+               OpFunctionEnd"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0ad83f9139daf70a791560f5c72f94b0be5b8390/build_0ad83f9139daf70a791560f5c72f94b0be5b8390\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0ad83f9139daf70a791560f5c72f94b0be5b8390/build_0ad83f9139daf70a791560f5c72f94b0be5b8390\n    Start 15: spirv-tools-test_diff\n1/1 Test #15: spirv-tools-test_diff ............Subprocess aborted***Exception:   0.38 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.39 sec\n\nThe following tests FAILED:\n\t 15 - spirv-tools-test_diff (Subprocess aborted)\n"
    },
    "545a9b0f51d105041b472f8649a8179550576c72___LLParser.cpp": {
        "prefix": "bool LLParser::ParseInstructionMetadata(Instruction *Inst,\n                                        PerFunctionState *PFS) {\n  do {\n    if (Lex.getKind() != lltok::MetadataVar)\n      return TokError(\"expected metadata after comma\");\n\n    std::string Name = Lex.getStrVal();\n    unsigned MDK = M->getMDKindID(Name);\n    Lex.Lex();\n\n    MDNode *Node;\n    SMLoc Loc = Lex.getLoc();\n\n    if (ParseToken(lltok::exclaim, \"expected '!' here\"))\n      return true;\n\n    // This code is similar to that of ParseMetadataValue, however it needs to\n    // have special-case code for a forward reference; see the comments on\n    // ForwardRefInstMetadata for details. Also, MDStrings are not supported\n    // at the top level here.\n    if (Lex.getKind() == lltok::lbrace) {\n      ValID ID;\n      if (ParseMetadataListValue(ID, PFS))\n        return true;\n      assert(ID.Kind == ValID::t_MDNode);\n      if (ID.MDNodeVal->isFunctionLocal())\n",
        "suffix": "      Inst->setMetadata(MDK, ID.MDNodeVal);\n    } else {\n      unsigned NodeID = 0;\n      if (ParseMDNodeID(Node, NodeID))\n        return true;\n      if (Node) {\n        // If we got the node, add it to the instruction.\n        Inst->setMetadata(MDK, Node);\n      } else {\n        MDRef R = { Loc, MDK, NodeID };\n        // Otherwise, remember that this should be resolved later.\n        ForwardRefInstMetadata[Inst].push_back(R);\n      }\n    }\n\n    if (MDK == LLVMContext::MD_tbaa)\n      InstsWithTBAATag.push_back(Inst);\n\n    // If this is the end of the list, we're done.\n  } while (EatIfPresent(lltok::comma));\n  return false;\n}\n",
        "start": 1509,
        "end": 1557,
        "buggy": "bool LLParser::ParseInstructionMetadata(Instruction *Inst,\n                                        PerFunctionState *PFS) {\n  do {\n    if (Lex.getKind() != lltok::MetadataVar)\n      return TokError(\"expected metadata after comma\");\n\n    std::string Name = Lex.getStrVal();\n    unsigned MDK = M->getMDKindID(Name);\n    Lex.Lex();\n\n    MDNode *Node;\n    SMLoc Loc = Lex.getLoc();\n\n    if (ParseToken(lltok::exclaim, \"expected '!' here\"))\n      return true;\n\n    // This code is similar to that of ParseMetadataValue, however it needs to\n    // have special-case code for a forward reference; see the comments on\n    // ForwardRefInstMetadata for details. Also, MDStrings are not supported\n    // at the top level here.\n    if (Lex.getKind() == lltok::lbrace) {\n      ValID ID;\n      if (ParseMetadataListValue(ID, PFS))\n        return true;\n      assert(ID.Kind == ValID::t_MDNode);\n      if (ID.MDNodeVal->isFunctionLocal())\n        return TokError(\"unexpected function-local metadata\");\n      Inst->setMetadata(MDK, ID.MDNodeVal);\n    } else {\n      unsigned NodeID = 0;\n      if (ParseMDNodeID(Node, NodeID))\n        return true;\n      if (Node) {\n        // If we got the node, add it to the instruction.\n        Inst->setMetadata(MDK, Node);\n      } else {\n        MDRef R = { Loc, MDK, NodeID };\n        // Otherwise, remember that this should be resolved later.\n        ForwardRefInstMetadata[Inst].push_back(R);\n      }\n    }\n\n    if (MDK == LLVMContext::MD_tbaa)\n      InstsWithTBAATag.push_back(Inst);\n\n    // If this is the end of the list, we're done.\n  } while (EatIfPresent(lltok::comma));\n  return false;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        return TokError(\"unexpected function-local metadata\");\n",
        "src_path": "545a9b0f51d105041b472f8649a8179550576c72___LLParser.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/545a9b0f51d105041b472f8649a8179550576c72",
        "commit_msg": "IR: Add missing tests for function-local metadata\n\nAdd assembly and bitcode tests that I neglected to add in r223564 (IR:\nDisallow complicated function-local metadata) and r223574 (IR: Disallow\nfunction-local metadata attachments).\n\nFound a couple of bugs:\n\n  - The error message for function-local attachments gave the wrong line\n    number -- it indicated the next token (typically on the next line)\n    instead of the token that started the attachment.  Fixed.\n\n  - Metadata arguments of the form `!{i32 0, i32 %v}` (or with the\n    arguments reversed) fired an assertion in `ValueEnumerator` in LLVM\n    v3.5, so I suppose this never really worked.  I suppose this was\n    \"fixed\" by r223564.\n\n(Thanks to dblaikie for pointing out my omission.)\n\nPart of PR21532.\n\nllvm-svn: 223616",
        "test_func_diff": [
            {
                "fn": "llvm/test/Assembler/functionlocal-metadata-attachments.ll",
                "patch": "@@ -0,0 +1,7 @@\n+; RUN: not llvm-as < %s -disable-output 2>&1 | FileCheck %s\n+\n+define void @foo(i32 %v) {\n+entry:\n+; CHECK: <stdin>:[[@LINE+1]]:{{[0-9]+}}: error: unexpected function-local metadata\n+  ret void, !foo !{i32 %v}\n+}"
            },
            {
                "fn": "llvm/test/Assembler/functionlocal-metadata-complex-1.ll",
                "patch": "@@ -0,0 +1,10 @@\n+; RUN: not llvm-as < %s -disable-output 2>&1 | FileCheck %s\n+\n+define void @foo(i32 %v) {\n+entry:\n+; CHECK: <stdin>:[[@LINE+1]]:{{[0-9]+}}: error: unexpected operand after function-local metadata\n+  call void @llvm.bar(metadata !{i32 %v, i32 0})\n+  ret void\n+}\n+\n+declare void @llvm.bar(metadata)"
            },
            {
                "fn": "llvm/test/Assembler/functionlocal-metadata-complex-2.ll",
                "patch": "@@ -0,0 +1,10 @@\n+; RUN: not llvm-as < %s -disable-output 2>&1 | FileCheck %s\n+\n+define void @foo(i32 %v) {\n+entry:\n+; CHECK: <stdin>:[[@LINE+1]]:{{[0-9]+}}: error: unexpected function-local metadata\n+  call void @llvm.bar(metadata !{i32 0, i32 %v})\n+  ret void\n+}\n+\n+declare void @llvm.bar(metadata)"
            },
            {
                "fn": "llvm/test/Assembler/functionlocal-metadata-complex-3.ll",
                "patch": "@@ -0,0 +1,10 @@\n+; RUN: not llvm-as < %s -disable-output 2>&1 | FileCheck %s\n+\n+define void @foo(i32 %v) {\n+entry:\n+; CHECK: <stdin>:[[@LINE+1]]:{{[0-9]+}}: error: unexpected nested function-local metadata\n+  call void @llvm.bar(metadata !{metadata !{i32 %v}})\n+  ret void\n+}\n+\n+declare void @llvm.bar(metadata)"
            },
            {
                "fn": "llvm/test/Bitcode/function-local-metadata.ll",
                "patch": "@@ -0,0 +1,35 @@\n+; RUN: llvm-dis < %s.bc | FileCheck %s\n+\n+; Check that function-local metadata is dropped correctly when it's not a\n+; direct argument to a call instruction.\n+;\n+; Bitcode assembled by llvm-as v3.5.0.\n+\n+define void @foo(i32 %v) {\n+; CHECK: entry:\n+entry:\n+; CHECK-NEXT: call void @llvm.bar(metadata !{i32 %v})\n+  call void @llvm.bar(metadata !{i32 %v})\n+\n+; Note: these supposedly legal instructions fired an assertion in llvm-as:\n+;\n+; Assertion failed: (I != ValueMap.end() && \"Value not in slotcalculator!\"), function getValueID, file lib/Bitcode/Writer/ValueEnumerator.cpp, line 138.\n+;\n+; So, I didn't test them; it looks like bitcode compatability is irrelevant.\n+  ; call void @llvm.bar(metadata !{i32 0, i32 %v})\n+  ; call void @llvm.bar(metadata !{i32 %v, i32 0})\n+  ; call void @llvm.bar(metadata !{metadata !{}, i32 %v})\n+  ; call void @llvm.bar(metadata !{i32 %v, metadata !{}})\n+\n+; CHECK-NEXT: call void @llvm.bar(metadata !0)\n+; CHECK-NEXT: call void @llvm.bar(metadata !0)\n+  call void @llvm.bar(metadata !{i32 %v, i32 %v})\n+  call void @llvm.bar(metadata !{metadata !{i32 %v}})\n+\n+; CHECK-NEXT: ret void{{$}}\n+  ret void, !baz !{i32 %v}\n+}\n+\n+declare void @llvm.bar(metadata)\n+\n+; CHECK: !0 = metadata !{}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Assembler/functionlocal-metadata-attachments.ll (1 of 1)\nTesting Time: 0.04s\n********************\nFailing Tests (1):\n    LLVM :: Assembler/functionlocal-metadata-attachments.ll\n\n  Unexpected Failures: 1\n"
    },
    "27de9b0f7001d3da9423e3e9b7b17565a38c1b51___X86AsmBackend.cpp": {
        "prefix": "  uint32_t encodeCompactUnwindRegistersWithoutFrame(unsigned RegCount) const {\n    // The saved registers are numbered from 1 to 6. In order to encode the\n    // order in which they were saved, we re-number them according to their\n    // place in the register order. The re-numbering is relative to the last\n    // re-numbered register. E.g., if we have registers {6, 2, 4, 5} saved in\n    // that order:\n    //\n    //    Orig  Re-Num\n    //    ----  ------\n    //     6       6\n    //     2       2\n    //     4       3\n    //     5       3\n    //\n",
        "suffix": "      int CUReg = getCompactUnwindRegNum(SavedRegs[i]);\n      if (CUReg == -1) return ~0U;\n      SavedRegs[i] = CUReg;\n    }\n\n    // Reverse the list.\n    std::reverse(&SavedRegs[0], &SavedRegs[CU_NUM_SAVED_REGS]);\n\n    uint32_t RenumRegs[CU_NUM_SAVED_REGS];\n    for (unsigned i = CU_NUM_SAVED_REGS - RegCount; i < CU_NUM_SAVED_REGS; ++i){\n      unsigned Countless = 0;\n      for (unsigned j = CU_NUM_SAVED_REGS - RegCount; j < i; ++j)\n        if (SavedRegs[j] < SavedRegs[i])\n          ++Countless;\n\n      RenumRegs[i] = SavedRegs[i] - Countless - 1;\n    }\n\n    // Take the renumbered values and encode them into a 10-bit number.\n    uint32_t permutationEncoding = 0;\n    switch (RegCount) {\n    case 6:\n      permutationEncoding |= 120 * RenumRegs[0] + 24 * RenumRegs[1]\n                             + 6 * RenumRegs[2] +  2 * RenumRegs[3]\n                             +     RenumRegs[4];\n      break;\n    case 5:\n      permutationEncoding |= 120 * RenumRegs[1] + 24 * RenumRegs[2]\n                             + 6 * RenumRegs[3] +  2 * RenumRegs[4]\n                             +     RenumRegs[5];\n      break;\n    case 4:\n      permutationEncoding |=  60 * RenumRegs[2] + 12 * RenumRegs[3]\n                             + 3 * RenumRegs[4] +      RenumRegs[5];\n      break;\n    case 3:\n      permutationEncoding |=  20 * RenumRegs[3] +  4 * RenumRegs[4]\n                             +     RenumRegs[5];\n      break;\n    case 2:\n      permutationEncoding |=   5 * RenumRegs[4] +      RenumRegs[5];\n      break;\n    case 1:\n      permutationEncoding |=       RenumRegs[5];\n      break;\n    }\n\n    assert((permutationEncoding & 0x3FF) == permutationEncoding &&\n           \"Invalid compact register encoding!\");\n    return permutationEncoding;\n  }\n",
        "start": 671,
        "end": 736,
        "buggy": "  uint32_t encodeCompactUnwindRegistersWithoutFrame(unsigned RegCount) const {\n    // The saved registers are numbered from 1 to 6. In order to encode the\n    // order in which they were saved, we re-number them according to their\n    // place in the register order. The re-numbering is relative to the last\n    // re-numbered register. E.g., if we have registers {6, 2, 4, 5} saved in\n    // that order:\n    //\n    //    Orig  Re-Num\n    //    ----  ------\n    //     6       6\n    //     2       2\n    //     4       3\n    //     5       3\n    //\n    for (unsigned i = 0; i != CU_NUM_SAVED_REGS; ++i) {\n      int CUReg = getCompactUnwindRegNum(SavedRegs[i]);\n      if (CUReg == -1) return ~0U;\n      SavedRegs[i] = CUReg;\n    }\n\n    // Reverse the list.\n    std::reverse(&SavedRegs[0], &SavedRegs[CU_NUM_SAVED_REGS]);\n\n    uint32_t RenumRegs[CU_NUM_SAVED_REGS];\n    for (unsigned i = CU_NUM_SAVED_REGS - RegCount; i < CU_NUM_SAVED_REGS; ++i){\n      unsigned Countless = 0;\n      for (unsigned j = CU_NUM_SAVED_REGS - RegCount; j < i; ++j)\n        if (SavedRegs[j] < SavedRegs[i])\n          ++Countless;\n\n      RenumRegs[i] = SavedRegs[i] - Countless - 1;\n    }\n\n    // Take the renumbered values and encode them into a 10-bit number.\n    uint32_t permutationEncoding = 0;\n    switch (RegCount) {\n    case 6:\n      permutationEncoding |= 120 * RenumRegs[0] + 24 * RenumRegs[1]\n                             + 6 * RenumRegs[2] +  2 * RenumRegs[3]\n                             +     RenumRegs[4];\n      break;\n    case 5:\n      permutationEncoding |= 120 * RenumRegs[1] + 24 * RenumRegs[2]\n                             + 6 * RenumRegs[3] +  2 * RenumRegs[4]\n                             +     RenumRegs[5];\n      break;\n    case 4:\n      permutationEncoding |=  60 * RenumRegs[2] + 12 * RenumRegs[3]\n                             + 3 * RenumRegs[4] +      RenumRegs[5];\n      break;\n    case 3:\n      permutationEncoding |=  20 * RenumRegs[3] +  4 * RenumRegs[4]\n                             +     RenumRegs[5];\n      break;\n    case 2:\n      permutationEncoding |=   5 * RenumRegs[4] +      RenumRegs[5];\n      break;\n    case 1:\n      permutationEncoding |=       RenumRegs[5];\n      break;\n    }\n\n    assert((permutationEncoding & 0x3FF) == permutationEncoding &&\n           \"Invalid compact register encoding!\");\n    return permutationEncoding;\n  }\n",
        "fix": null,
        "buggy_hunk_masked": "    for (unsigned i = 0; i != CU_NUM_SAVED_REGS; ++i) {\n",
        "src_path": "27de9b0f7001d3da9423e3e9b7b17565a38c1b51___X86AsmBackend.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/27de9b0f7001d3da9423e3e9b7b17565a38c1b51",
        "commit_msg": "[CompactUnwind] Fix register encoding logic\n\nFix a compact unwind encoding logic bug which would try to encode\nmore callee saved registers than it should, leading to early bail out\nin the encoding logic and abusive use of DWARF frame mode unnecessarily.\n\nAlso remove no-compact-unwind.ll which was testing the wrong thing\nbased on this bug and move it to valid 'compact unwind' tests. Added\nother few more tests too.\n\nllvm-svn: 223676",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/compact-unwind.ll",
                "patch": "@@ -1,12 +1,20 @@\n ; RUN: llc < %s -disable-fp-elim -mtriple x86_64-apple-darwin11 -mcpu corei7 | FileCheck -check-prefix=ASM %s\n ; RUN: llc < %s -disable-fp-elim -mtriple x86_64-apple-darwin11 -mcpu corei7 -filetype=obj -o - \\\n-; RUN:  | llvm-objdump -triple x86_64-apple-darwin11 -s - \\\n+; RUN:  | llvm-objdump -triple x86_64-apple-darwin11 -unwind-info - \\\n ; RUN:  | FileCheck -check-prefix=CU %s\n ; RUN: llc < %s -disable-fp-elim -mtriple x86_64-apple-darwin11 -mcpu corei7 \\\n ; RUN:  | llvm-mc -triple x86_64-apple-darwin11 -filetype=obj -o - \\\n-; RUN:  | llvm-objdump -triple x86_64-apple-darwin11 -s - \\\n+; RUN:  | llvm-objdump -triple x86_64-apple-darwin11 -unwind-info - \\\n ; RUN:  | FileCheck -check-prefix=FROM-ASM %s\n \n+; RUN: llc < %s -mtriple x86_64-apple-macosx10.8.0 -mcpu corei7 -filetype=obj -o - \\\n+; RUN:  | llvm-objdump -triple x86_64-apple-macosx10.8.0 -unwind-info - \\\n+; RUN:  | FileCheck -check-prefix=NOFP-CU %s\n+; RUN: llc < %s -mtriple x86_64-apple-darwin11 -mcpu corei7 \\\n+; RUN:  | llvm-mc -triple x86_64-apple-darwin11 -filetype=obj -o - \\\n+; RUN:  | llvm-objdump -triple x86_64-apple-darwin11 -unwind-info - \\\n+; RUN:  | FileCheck -check-prefix=NOFP-FROM-ASM %s\n+\n %ty = type { i8* }\n \n @gv = external global i32\n@@ -17,15 +25,19 @@\n ; Even though we can't encode %rax into the compact unwind, We still want to be\n ; able to generate a compact unwind encoding in this particular case.\n \n-; CU:      Contents of section __compact_unwind:\n-; CU-NEXT: 0020 00000000 00000000 1e000000 01000101\n-; CU-NEXT: 0030 00000000 00000000 00000000 00000000\n+; CU:    Contents of __compact_unwind section:\n+; CU-NEXT:      Entry at offset 0x0:\n+; CU-NEXT:        start:                0x0 _test0\n+; CU-NEXT:        length:               0x1e\n+; CU-NEXT:        compact encoding:     0x01010001\n \n-; FROM-ASM:      Contents of section __compact_unwind:\n-; FROM-ASM-NEXT: 0020 00000000 00000000 1e000000 01000101\n-; FROM-ASM-NEXT: 0030 00000000 00000000 00000000 00000000\n+; FROM-ASM:    Contents of __compact_unwind section:\n+; FROM-ASM-NEXT:      Entry at offset 0x0:\n+; FROM-ASM-NEXT:        start:                0x0 _test0\n+; FROM-ASM-NEXT:        length:               0x1e\n+; FROM-ASM-NEXT:        compact encoding:     0x01010001\n \n-define i8* @foo(i64 %size) {\n+define i8* @test0(i64 %size) {\n   %addr = alloca i64, align 8\n   %tmp20 = load i32* @gv, align 4\n   %tmp21 = call i32 @bar()\n@@ -39,3 +51,61 @@ define i8* @foo(i64 %size) {\n }\n \n declare i32 @bar()\n+\n+%\"struct.dyld::MappedRanges\" = type { [400 x %struct.anon], %\"struct.dyld::MappedRanges\"* }\n+%struct.anon = type { %class.ImageLoader*, i64, i64 }\n+%class.ImageLoader = type { i32 (...)**, i8*, i8*, i32, i64, i64, i32, i32, %\"struct.ImageLoader::recursive_lock\"*, i16, i16, [4 x i8] }\n+%\"struct.ImageLoader::recursive_lock\" = type { i32, i32 }\n+\n+@G1 = external hidden global %\"struct.dyld::MappedRanges\", align 8\n+\n+declare void @OSMemoryBarrier() optsize\n+\n+; Test the code below uses UNWIND_X86_64_MODE_STACK_IMMD compact unwind\n+; encoding.\n+\n+; NOFP-CU:      Entry at offset 0x20:\n+; NOFP-CU-NEXT:        start:                0x1d _test1\n+; NOFP-CU-NEXT:        length:               0x42\n+; NOFP-CU-NEXT:        compact encoding:     0x02040c0a\n+\n+; NOFP-FROM-ASM:      Entry at offset 0x20:\n+; NOFP-FROM-ASM-NEXT:        start:                0x1d _test1\n+; NOFP-FROM-ASM-NEXT:        length:               0x42\n+; NOFP-FROM-ASM-NEXT:        compact encoding:     0x02040c0a\n+\n+define void @test1(%class.ImageLoader* %image) optsize ssp uwtable {\n+entry:\n+  br label %for.cond1.preheader\n+\n+for.cond1.preheader:                              ; preds = %for.inc10, %entry\n+  %p.019 = phi %\"struct.dyld::MappedRanges\"* [ @G1, %entry ], [ %1, %for.inc10 ]\n+  br label %for.body3\n+\n+for.body3:                                        ; preds = %for.inc, %for.cond1.preheader\n+  %indvars.iv = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next, %for.inc ]\n+  %image4 = getelementptr inbounds %\"struct.dyld::MappedRanges\"* %p.019, i64 0, i32 0, i64 %indvars.iv, i32 0\n+  %0 = load %class.ImageLoader** %image4, align 8\n+  %cmp5 = icmp eq %class.ImageLoader* %0, %image\n+  br i1 %cmp5, label %if.then, label %for.inc\n+\n+if.then:                                          ; preds = %for.body3\n+  tail call void @OSMemoryBarrier() optsize\n+  store %class.ImageLoader* null, %class.ImageLoader** %image4, align 8\n+  br label %for.inc\n+\n+for.inc:                                          ; preds = %if.then, %for.body3\n+  %indvars.iv.next = add i64 %indvars.iv, 1\n+  %lftr.wideiv = trunc i64 %indvars.iv.next to i32\n+  %exitcond = icmp eq i32 %lftr.wideiv, 400\n+  br i1 %exitcond, label %for.inc10, label %for.body3\n+\n+for.inc10:                                        ; preds = %for.inc\n+  %next = getelementptr inbounds %\"struct.dyld::MappedRanges\"* %p.019, i64 0, i32 1\n+  %1 = load %\"struct.dyld::MappedRanges\"** %next, align 8\n+  %cmp = icmp eq %\"struct.dyld::MappedRanges\"* %1, null\n+  br i1 %cmp, label %for.end11, label %for.cond1.preheader\n+\n+for.end11:                                        ; preds = %for.inc10\n+  ret void\n+}"
            },
            {
                "fn": "llvm/test/CodeGen/X86/no-compact-unwind.ll",
                "patch": "@@ -1,64 +0,0 @@\n-; RUN: llc < %s -mtriple x86_64-apple-macosx10.8.0 -mcpu corei7 -filetype=obj -o - \\\n-; RUN:  | llvm-objdump -triple x86_64-apple-macosx10.8.0 -s - \\\n-; RUN:  | FileCheck -check-prefix=CU %s\n-; RUN: llc < %s -mtriple x86_64-apple-darwin11 -mcpu corei7 \\\n-; RUN:  | llvm-mc -triple x86_64-apple-darwin11 -filetype=obj -o - \\\n-; RUN:  | llvm-objdump -triple x86_64-apple-darwin11 -s - \\\n-; RUN:  | FileCheck -check-prefix=FROM-ASM %s\n-\n-%\"struct.dyld::MappedRanges\" = type { [400 x %struct.anon], %\"struct.dyld::MappedRanges\"* }\n-%struct.anon = type { %class.ImageLoader*, i64, i64 }\n-%class.ImageLoader = type { i32 (...)**, i8*, i8*, i32, i64, i64, i32, i32, %\"struct.ImageLoader::recursive_lock\"*, i16, i16, [4 x i8] }\n-%\"struct.ImageLoader::recursive_lock\" = type { i32, i32 }\n-\n-@G1 = external hidden global %\"struct.dyld::MappedRanges\", align 8\n-\n-declare void @OSMemoryBarrier() optsize\n-\n-; This compact unwind encoding indicates that we could not generate correct\n-; compact unwind encodings for this function. This then defaults to using the\n-; DWARF EH frame.\n-\n-; CU:      Contents of section __compact_unwind:\n-; CU-NEXT: 0048 00000000 00000000 42000000 00000004\n-; CU-NEXT: 0058 00000000 00000000 00000000 00000000\n-\n-; FROM-ASM:      Contents of section __compact_unwind:\n-; FROM-ASM-NEXT: 0048 00000000 00000000 42000000 00000004\n-; FROM-ASM-NEXT: 0058 00000000 00000000 00000000 00000000\n-\n-define void @func(%class.ImageLoader* %image) optsize ssp uwtable {\n-entry:\n-  br label %for.cond1.preheader\n-\n-for.cond1.preheader:                              ; preds = %for.inc10, %entry\n-  %p.019 = phi %\"struct.dyld::MappedRanges\"* [ @G1, %entry ], [ %1, %for.inc10 ]\n-  br label %for.body3\n-\n-for.body3:                                        ; preds = %for.inc, %for.cond1.preheader\n-  %indvars.iv = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next, %for.inc ]\n-  %image4 = getelementptr inbounds %\"struct.dyld::MappedRanges\"* %p.019, i64 0, i32 0, i64 %indvars.iv, i32 0\n-  %0 = load %class.ImageLoader** %image4, align 8\n-  %cmp5 = icmp eq %class.ImageLoader* %0, %image\n-  br i1 %cmp5, label %if.then, label %for.inc\n-\n-if.then:                                          ; preds = %for.body3\n-  tail call void @OSMemoryBarrier() optsize\n-  store %class.ImageLoader* null, %class.ImageLoader** %image4, align 8\n-  br label %for.inc\n-\n-for.inc:                                          ; preds = %if.then, %for.body3\n-  %indvars.iv.next = add i64 %indvars.iv, 1\n-  %lftr.wideiv = trunc i64 %indvars.iv.next to i32\n-  %exitcond = icmp eq i32 %lftr.wideiv, 400\n-  br i1 %exitcond, label %for.inc10, label %for.body3\n-\n-for.inc10:                                        ; preds = %for.inc\n-  %next = getelementptr inbounds %\"struct.dyld::MappedRanges\"* %p.019, i64 0, i32 1\n-  %1 = load %\"struct.dyld::MappedRanges\"** %next, align 8\n-  %cmp = icmp eq %\"struct.dyld::MappedRanges\"* %1, null\n-  br i1 %cmp, label %for.end11, label %for.cond1.preheader\n-\n-for.end11:                                        ; preds = %for.inc10\n-  ret void\n-}"
            },
            {
                "fn": "llvm/test/MC/X86/compact-unwind.s",
                "patch": "@@ -0,0 +1,72 @@\n+# RUN: llvm-mc -filetype=obj -triple=x86_64-apple-darwin10.0 %s | llvm-objdump -unwind-info - | FileCheck %s\n+\n+\t.section\t__TEXT,__text,regular,pure_instructions\n+\t.macosx_version_min 10, 10\n+\n+# Check that we emit compact-unwind info with UNWIND_X86_MODE_STACK_IND encoding\n+\n+# CHECK: Contents of __compact_unwind section:\n+# CHECK-NEXT:   Entry at offset 0x0:\n+# CHECK-NEXT:     start:                0x0 _test0\n+# CHECK-NEXT:     length:               0x15\n+# CHECK-NEXT:     compact encoding:     0x03056804\n+\t.globl\t_test0\n+_test0:                                  ## @test0\n+\t.cfi_startproc\n+## BB#0:                                ## %entry\n+\tpushq\t%rbp\n+Ltmp0:\n+\t.cfi_def_cfa_offset 16\n+\tpushq\t%rbx\n+Ltmp1:\n+\t.cfi_def_cfa_offset 24\n+\tsubq\t$14408, %rsp            ## imm = 0x3848\n+Ltmp2:\n+\t.cfi_def_cfa_offset 14432\n+Ltmp3:\n+\t.cfi_offset %rbx, -24\n+Ltmp4:\n+\t.cfi_offset %rbp, -16\n+\txorl\t%eax, %eax\n+\taddq\t$14408, %rsp            ## imm = 0x3848\n+\tpopq\t%rbx\n+\tpopq\t%rbp\n+\tretq\n+\t.cfi_endproc\n+\n+# Check that we emit compact-unwind info with UNWIND_X86_MODE_STACK_IMMD encoding\n+\n+# CHECK:   Entry at offset 0x20:\n+# CHECK-NEXT:     start:                0x15 _test1\n+# CHECK-NEXT:     length:               0x15\n+# CHECK-NEXT:     compact encoding:     0x02360804\n+\t.globl\t_test1\n+_test1:                                  ## @test1\n+\t.cfi_startproc\n+## BB#0:                                ## %entry\n+\tpushq\t%rbp\n+Ltmp10:\n+\t.cfi_def_cfa_offset 16\n+\tpushq\t%rbx\n+Ltmp11:\n+\t.cfi_def_cfa_offset 24\n+\tsubq\t$408, %rsp              ## imm = 0x198\n+Ltmp12:\n+\t.cfi_def_cfa_offset 432\n+Ltmp13:\n+\t.cfi_offset %rbx, -24\n+Ltmp14:\n+\t.cfi_offset %rbp, -16\n+\txorl\t%eax, %eax\n+\taddq\t$408, %rsp              ## imm = 0x198\n+\tpopq\t%rbx\n+\tpopq\t%rbp\n+\tretq\n+\t.cfi_endproc\n+\n+\t.section\t__TEXT,__cstring,cstring_literals\n+L_.str:                                 ## @.str\n+\t.asciz\t\"%d\\n\"\n+\n+\n+.subsections_via_symbols"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/compact-unwind.ll (1 of 1)\nTesting Time: 0.54s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/compact-unwind.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/compact-unwind.ll (1 of 1)\nTesting Time: 0.54s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/compact-unwind.ll\n\n  Unexpected Failures: 1\n"
    },
    "f379a6c684d47484fb1a0e47df4321fee21f4f6e___X86ShuffleDecode.cpp": {
        "prefix": "void DecodeVPPERMMask(ArrayRef<uint64_t> RawMask,\n                      SmallVectorImpl<int> &ShuffleMask) {\n  assert(RawMask.size() == 16 && \"Illegal VPPERM shuffle mask size\");\n\n  // VPPERM Operation\n  // Bits[4:0] - Byte Index (0 - 31)\n  // Bits[7:5] - Permute Operation\n  //\n  // Permute Operation:\n  // 0 - Source byte (no logical operation).\n  // 1 - Invert source byte.\n  // 2 - Bit reverse of source byte.\n  // 3 - Bit reverse of inverted source byte.\n  // 4 - 00h (zero - fill).\n  // 5 - FFh (ones - fill).\n  // 6 - Most significant bit of source byte replicated in all bit positions.\n  // 7 - Invert most significant bit of source byte and replicate in all bit positions.\n  for (int i = 0, e = RawMask.size(); i < e; ++i) {\n    uint64_t M = RawMask[i];\n    if (M == (uint64_t)SM_SentinelUndef) {\n      ShuffleMask.push_back(M);\n      continue;\n    }\n\n",
        "suffix": "    if (PermuteOp == 4) {\n      ShuffleMask.push_back(SM_SentinelZero);\n      continue;\n    }\n    if (PermuteOp != 0) {\n      ShuffleMask.clear();\n      return;\n    }\n\n    uint64_t Index = M & 0x1F;\n    ShuffleMask.push_back((int)Index);\n  }\n}\n",
        "start": 346,
        "end": 383,
        "buggy": "void DecodeVPPERMMask(ArrayRef<uint64_t> RawMask,\n                      SmallVectorImpl<int> &ShuffleMask) {\n  assert(RawMask.size() == 16 && \"Illegal VPPERM shuffle mask size\");\n\n  // VPPERM Operation\n  // Bits[4:0] - Byte Index (0 - 31)\n  // Bits[7:5] - Permute Operation\n  //\n  // Permute Operation:\n  // 0 - Source byte (no logical operation).\n  // 1 - Invert source byte.\n  // 2 - Bit reverse of source byte.\n  // 3 - Bit reverse of inverted source byte.\n  // 4 - 00h (zero - fill).\n  // 5 - FFh (ones - fill).\n  // 6 - Most significant bit of source byte replicated in all bit positions.\n  // 7 - Invert most significant bit of source byte and replicate in all bit positions.\n  for (int i = 0, e = RawMask.size(); i < e; ++i) {\n    uint64_t M = RawMask[i];\n    if (M == (uint64_t)SM_SentinelUndef) {\n      ShuffleMask.push_back(M);\n      continue;\n    }\n\n    uint64_t PermuteOp = (M >> 5) & 0x3;\n    if (PermuteOp == 4) {\n      ShuffleMask.push_back(SM_SentinelZero);\n      continue;\n    }\n    if (PermuteOp != 0) {\n      ShuffleMask.clear();\n      return;\n    }\n\n    uint64_t Index = M & 0x1F;\n    ShuffleMask.push_back((int)Index);\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    uint64_t PermuteOp = (M >> 5) & 0x3;\n",
        "src_path": "f379a6c684d47484fb1a0e47df4321fee21f4f6e___X86ShuffleDecode.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/f379a6c684d47484fb1a0e47df4321fee21f4f6e",
        "commit_msg": "[X86][XOP] Fixed VPPERM permute op decoding (PR27472).\n\nFixed issue with VPPERM target shuffle mask decoding that was incorrectly masking off the 3-bit permute op with a 2-bit mask.\n\nllvm-svn: 267346",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/vector-shuffle-combining-xop.ll",
                "patch": "@@ -23,7 +23,7 @@ define <16 x i8> @combine_vpperm_identity(<16 x i8> %a0, <16 x i8> %a1) {\n define <16 x i8> @combine_vpperm_zero(<16 x i8> %a0, <16 x i8> %a1) {\n ; CHECK-LABEL: combine_vpperm_zero:\n ; CHECK:       # BB#0:\n-; CHECK-NEXT:    vpshufb {{.*#+}} xmm0 = xmm0[0],zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,zero\n+; CHECK-NEXT:    vxorps %xmm0, %xmm0, %xmm0\n ; CHECK-NEXT:    retq\n   %res0 = call <16 x i8> @llvm.x86.xop.vpperm(<16 x i8> %a0, <16 x i8> %a1, <16 x i8> <i8 128, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>)\n   %res1 = call <16 x i8> @llvm.x86.xop.vpperm(<16 x i8> %res0, <16 x i8> undef, <16 x i8> <i8 0, i8 128, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0, i8 0>)"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/vector-shuffle-combining-xop.ll (1 of 1)\nTesting Time: 0.11s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/vector-shuffle-combining-xop.ll\n\n  Unexpected Failures: 1\n"
    },
    "ee20294af55e73f12829aefd0b6519cf81efe93d___BasicAliasAnalysis.cpp": {
        "prefix": "static AliasResult aliasSameBasePointerGEPs(const GEPOperator *GEP1,\n                                            uint64_t V1Size,\n                                            const GEPOperator *GEP2,\n                                            uint64_t V2Size,\n                                            const DataLayout &DL) {\n\n  assert(GEP1->getPointerOperand() == GEP2->getPointerOperand() &&\n         \"Expected GEPs with the same pointer operand\");\n\n  // Try to determine whether GEP1 and GEP2 index through arrays, into structs,\n  // such that the struct field accesses provably cannot alias.\n  // We also need at least two indices (the pointer, and the struct field).\n  if (GEP1->getNumIndices() != GEP2->getNumIndices() ||\n      GEP1->getNumIndices() < 2)\n    return MayAlias;\n\n  // If we don't know the size of the accesses through both GEPs, we can't\n  // determine whether the struct fields accessed can't alias.\n  if (V1Size == MemoryLocation::UnknownSize ||\n      V2Size == MemoryLocation::UnknownSize)\n    return MayAlias;\n\n  ConstantInt *C1 =\n      dyn_cast<ConstantInt>(GEP1->getOperand(GEP1->getNumOperands() - 1));\n  ConstantInt *C2 =\n      dyn_cast<ConstantInt>(GEP2->getOperand(GEP2->getNumOperands() - 1));\n\n  // If the last (struct) indices are constants and are equal, the other indices\n  // might be also be dynamically equal, so the GEPs can alias.\n",
        "suffix": "    return MayAlias;\n\n  // Find the last-indexed type of the GEP, i.e., the type you'd get if\n  // you stripped the last index.\n  // On the way, look at each indexed type.  If there's something other\n  // than an array, different indices can lead to different final types.\n  SmallVector<Value *, 8> IntermediateIndices;\n\n  // Insert the first index; we don't need to check the type indexed\n  // through it as it only drops the pointer indirection.\n  assert(GEP1->getNumIndices() > 1 && \"Not enough GEP indices to examine\");\n  IntermediateIndices.push_back(GEP1->getOperand(1));\n\n  // Insert all the remaining indices but the last one.\n  // Also, check that they all index through arrays.\n  for (unsigned i = 1, e = GEP1->getNumIndices() - 1; i != e; ++i) {\n    if (!isa<ArrayType>(GetElementPtrInst::getIndexedType(\n            GEP1->getSourceElementType(), IntermediateIndices)))\n      return MayAlias;\n    IntermediateIndices.push_back(GEP1->getOperand(i + 1));\n  }\n\n  auto *Ty = GetElementPtrInst::getIndexedType(\n    GEP1->getSourceElementType(), IntermediateIndices);\n  StructType *LastIndexedStruct = dyn_cast<StructType>(Ty);\n\n  if (isa<SequentialType>(Ty)) {\n    // We know that:\n    // - both GEPs begin indexing from the exact same pointer;\n    // - the last indices in both GEPs are constants, indexing into a sequential\n    //   type (array or pointer);\n    // - both GEPs only index through arrays prior to that.\n    //\n    // Because array indices greater than the number of elements are valid in\n    // GEPs, unless we know the intermediate indices are identical between\n    // GEP1 and GEP2 we cannot guarantee that the last indexed arrays don't\n    // partially overlap. We also need to check that the loaded size matches\n    // the element size, otherwise we could still have overlap.\n    const uint64_t ElementSize =\n        DL.getTypeStoreSize(cast<SequentialType>(Ty)->getElementType());\n    if (V1Size != ElementSize || V2Size != ElementSize)\n      return MayAlias;\n\n    for (unsigned i = 0, e = GEP1->getNumIndices() - 1; i != e; ++i)\n      if (GEP1->getOperand(i + 1) != GEP2->getOperand(i + 1))\n        return MayAlias;\n\n    // Now we know that the array/pointer that GEP1 indexes into and that\n    // that GEP2 indexes into must either precisely overlap or be disjoint.\n    // Because they cannot partially overlap and because fields in an array\n    // cannot overlap, if we can prove the final indices are different between\n    // GEP1 and GEP2, we can conclude GEP1 and GEP2 don't alias.\n    \n    // If the last indices are constants, we've already checked they don't\n    // equal each other so we can exit early.\n    if (C1 && C2)\n      return NoAlias;\n    if (isKnownNonEqual(GEP1->getOperand(GEP1->getNumOperands() - 1),\n                        GEP2->getOperand(GEP2->getNumOperands() - 1),\n                        DL))\n      return NoAlias;\n    return MayAlias;\n  } else if (!LastIndexedStruct || !C1 || !C2) {\n    return MayAlias;\n  }\n\n  // We know that:\n  // - both GEPs begin indexing from the exact same pointer;\n  // - the last indices in both GEPs are constants, indexing into a struct;\n  // - said indices are different, hence, the pointed-to fields are different;\n  // - both GEPs only index through arrays prior to that.\n  //\n  // This lets us determine that the struct that GEP1 indexes into and the\n  // struct that GEP2 indexes into must either precisely overlap or be\n  // completely disjoint.  Because they cannot partially overlap, indexing into\n  // different non-overlapping fields of the struct will never alias.\n\n  // Therefore, the only remaining thing needed to show that both GEPs can't\n  // alias is that the fields are not overlapping.\n  const StructLayout *SL = DL.getStructLayout(LastIndexedStruct);\n  const uint64_t StructSize = SL->getSizeInBytes();\n  const uint64_t V1Off = SL->getElementOffset(C1->getZExtValue());\n  const uint64_t V2Off = SL->getElementOffset(C2->getZExtValue());\n\n  auto EltsDontOverlap = [StructSize](uint64_t V1Off, uint64_t V1Size,\n                                      uint64_t V2Off, uint64_t V2Size) {\n    return V1Off < V2Off && V1Off + V1Size <= V2Off &&\n           ((V2Off + V2Size <= StructSize) ||\n            (V2Off + V2Size - StructSize <= V1Off));\n  };\n\n  if (EltsDontOverlap(V1Off, V1Size, V2Off, V2Size) ||\n      EltsDontOverlap(V2Off, V2Size, V1Off, V1Size))\n    return NoAlias;\n\n  return MayAlias;\n}\n",
        "start": 821,
        "end": 947,
        "buggy": "static AliasResult aliasSameBasePointerGEPs(const GEPOperator *GEP1,\n                                            uint64_t V1Size,\n                                            const GEPOperator *GEP2,\n                                            uint64_t V2Size,\n                                            const DataLayout &DL) {\n\n  assert(GEP1->getPointerOperand() == GEP2->getPointerOperand() &&\n         \"Expected GEPs with the same pointer operand\");\n\n  // Try to determine whether GEP1 and GEP2 index through arrays, into structs,\n  // such that the struct field accesses provably cannot alias.\n  // We also need at least two indices (the pointer, and the struct field).\n  if (GEP1->getNumIndices() != GEP2->getNumIndices() ||\n      GEP1->getNumIndices() < 2)\n    return MayAlias;\n\n  // If we don't know the size of the accesses through both GEPs, we can't\n  // determine whether the struct fields accessed can't alias.\n  if (V1Size == MemoryLocation::UnknownSize ||\n      V2Size == MemoryLocation::UnknownSize)\n    return MayAlias;\n\n  ConstantInt *C1 =\n      dyn_cast<ConstantInt>(GEP1->getOperand(GEP1->getNumOperands() - 1));\n  ConstantInt *C2 =\n      dyn_cast<ConstantInt>(GEP2->getOperand(GEP2->getNumOperands() - 1));\n\n  // If the last (struct) indices are constants and are equal, the other indices\n  // might be also be dynamically equal, so the GEPs can alias.\n  if (C1 && C2 && C1 == C2)\n    return MayAlias;\n\n  // Find the last-indexed type of the GEP, i.e., the type you'd get if\n  // you stripped the last index.\n  // On the way, look at each indexed type.  If there's something other\n  // than an array, different indices can lead to different final types.\n  SmallVector<Value *, 8> IntermediateIndices;\n\n  // Insert the first index; we don't need to check the type indexed\n  // through it as it only drops the pointer indirection.\n  assert(GEP1->getNumIndices() > 1 && \"Not enough GEP indices to examine\");\n  IntermediateIndices.push_back(GEP1->getOperand(1));\n\n  // Insert all the remaining indices but the last one.\n  // Also, check that they all index through arrays.\n  for (unsigned i = 1, e = GEP1->getNumIndices() - 1; i != e; ++i) {\n    if (!isa<ArrayType>(GetElementPtrInst::getIndexedType(\n            GEP1->getSourceElementType(), IntermediateIndices)))\n      return MayAlias;\n    IntermediateIndices.push_back(GEP1->getOperand(i + 1));\n  }\n\n  auto *Ty = GetElementPtrInst::getIndexedType(\n    GEP1->getSourceElementType(), IntermediateIndices);\n  StructType *LastIndexedStruct = dyn_cast<StructType>(Ty);\n\n  if (isa<SequentialType>(Ty)) {\n    // We know that:\n    // - both GEPs begin indexing from the exact same pointer;\n    // - the last indices in both GEPs are constants, indexing into a sequential\n    //   type (array or pointer);\n    // - both GEPs only index through arrays prior to that.\n    //\n    // Because array indices greater than the number of elements are valid in\n    // GEPs, unless we know the intermediate indices are identical between\n    // GEP1 and GEP2 we cannot guarantee that the last indexed arrays don't\n    // partially overlap. We also need to check that the loaded size matches\n    // the element size, otherwise we could still have overlap.\n    const uint64_t ElementSize =\n        DL.getTypeStoreSize(cast<SequentialType>(Ty)->getElementType());\n    if (V1Size != ElementSize || V2Size != ElementSize)\n      return MayAlias;\n\n    for (unsigned i = 0, e = GEP1->getNumIndices() - 1; i != e; ++i)\n      if (GEP1->getOperand(i + 1) != GEP2->getOperand(i + 1))\n        return MayAlias;\n\n    // Now we know that the array/pointer that GEP1 indexes into and that\n    // that GEP2 indexes into must either precisely overlap or be disjoint.\n    // Because they cannot partially overlap and because fields in an array\n    // cannot overlap, if we can prove the final indices are different between\n    // GEP1 and GEP2, we can conclude GEP1 and GEP2 don't alias.\n    \n    // If the last indices are constants, we've already checked they don't\n    // equal each other so we can exit early.\n    if (C1 && C2)\n      return NoAlias;\n    if (isKnownNonEqual(GEP1->getOperand(GEP1->getNumOperands() - 1),\n                        GEP2->getOperand(GEP2->getNumOperands() - 1),\n                        DL))\n      return NoAlias;\n    return MayAlias;\n  } else if (!LastIndexedStruct || !C1 || !C2) {\n    return MayAlias;\n  }\n\n  // We know that:\n  // - both GEPs begin indexing from the exact same pointer;\n  // - the last indices in both GEPs are constants, indexing into a struct;\n  // - said indices are different, hence, the pointed-to fields are different;\n  // - both GEPs only index through arrays prior to that.\n  //\n  // This lets us determine that the struct that GEP1 indexes into and the\n  // struct that GEP2 indexes into must either precisely overlap or be\n  // completely disjoint.  Because they cannot partially overlap, indexing into\n  // different non-overlapping fields of the struct will never alias.\n\n  // Therefore, the only remaining thing needed to show that both GEPs can't\n  // alias is that the fields are not overlapping.\n  const StructLayout *SL = DL.getStructLayout(LastIndexedStruct);\n  const uint64_t StructSize = SL->getSizeInBytes();\n  const uint64_t V1Off = SL->getElementOffset(C1->getZExtValue());\n  const uint64_t V2Off = SL->getElementOffset(C2->getZExtValue());\n\n  auto EltsDontOverlap = [StructSize](uint64_t V1Off, uint64_t V1Size,\n                                      uint64_t V2Off, uint64_t V2Size) {\n    return V1Off < V2Off && V1Off + V1Size <= V2Off &&\n           ((V2Off + V2Size <= StructSize) ||\n            (V2Off + V2Size - StructSize <= V1Off));\n  };\n\n  if (EltsDontOverlap(V1Off, V1Size, V2Off, V2Size) ||\n      EltsDontOverlap(V2Off, V2Size, V1Off, V1Size))\n    return NoAlias;\n\n  return MayAlias;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  if (C1 && C2 && C1 == C2)\n",
        "src_path": "ee20294af55e73f12829aefd0b6519cf81efe93d___BasicAliasAnalysis.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/ee20294af55e73f12829aefd0b6519cf81efe93d",
        "commit_msg": "[BasicAA] Compare GEP indices based on value (Fix PR27418)\n\nEquivalent GEP indices with different types are treated as different\nindices altogether, leading to an incorrect AA result. Fix the issue\nby comparing indices based on their values.\n\nThanks to Mikael Holm\u00e9n for reporting the issue!\n\nDifferential Revision: http://reviews.llvm.org/D19935\n\nllvm-svn: 269197",
        "test_func_diff": [
            {
                "fn": "llvm/test/Analysis/BasicAA/struct-geps.ll",
                "patch": "@@ -162,3 +162,12 @@ define void @test_struct_in_array(%struct2* %st, i64 %i, i64 %j, i64 %k) {\n   %y = getelementptr %struct2, %struct2* %st, i32 0, i32 0, i32 1, i32 1\n   ret void\n }\n+\n+; PR27418 - Treat GEP indices with the same value but different types the same\n+; CHECK-LABEL: test_different_index_types\n+; CHECK: MustAlias: i16* %tmp1, i16* %tmp2\n+define void @test_different_index_types([2 x i16]* %arr) {\n+  %tmp1 = getelementptr [2 x i16], [2 x i16]* %arr, i16 0, i32 1\n+  %tmp2 = getelementptr [2 x i16], [2 x i16]* %arr, i16 0, i16 1\n+  ret void\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Analysis/BasicAA/struct-geps.ll (1 of 1)\nTesting Time: 0.16s\n********************\nFailing Tests (1):\n    LLVM :: Analysis/BasicAA/struct-geps.ll\n\n  Unexpected Failures: 1\n"
    },
    "f28beac4196167b0ca6184625bece102b0589b03___MemCpyOptimizer.cpp": {
        "prefix": "bool MemsetRange::isProfitableToUseMemset(const DataLayout &DL) const {\n  // If we found more than 4 stores to merge or 16 bytes, use memset.\n  if (TheStores.size() >= 4 || End-Start >= 16) return true;\n\n  // If there is nothing to merge, don't do anything.\n  if (TheStores.size() < 2) return false;\n\n  // If any of the stores are a memset, then it is always good to extend the\n  // memset.\n  for (Instruction *SI : TheStores)\n    if (!isa<StoreInst>(SI))\n      return true;\n\n  // Assume that the code generator is capable of merging pairs of stores\n  // together if it wants to.\n  if (TheStores.size() == 2) return false;\n\n  // If we have fewer than 8 stores, it can still be worthwhile to do this.\n  // For example, merging 4 i8 stores into an i32 store is useful almost always.\n  // However, merging 2 32-bit stores isn't useful on a 32-bit architecture (the\n  // memset will be split into 2 32-bit stores anyway) and doing so can\n  // pessimize the llvm optimizer.\n  //\n  // Since we don't have perfect knowledge here, make some assumptions: assume\n  // the maximum GPR width is the same size as the largest legal integer\n  // size. If so, check to see whether we will end up actually reducing the\n  // number of stores used.\n  unsigned Bytes = unsigned(End-Start);\n",
        "suffix": "  if (MaxIntSize == 0)\n    MaxIntSize = 1;\n  unsigned NumPointerStores = Bytes / MaxIntSize;\n\n  // Assume the remaining bytes if any are done a byte at a time.\n  unsigned NumByteStores = Bytes % MaxIntSize;\n\n  // If we will reduce the # stores (according to this heuristic), do the\n  // transformation.  This encourages merging 4 x i8 -> i32 and 2 x i16 -> i32\n  // etc.\n  return TheStores.size() > NumPointerStores+NumByteStores;\n}\n",
        "start": 160,
        "end": 200,
        "buggy": "bool MemsetRange::isProfitableToUseMemset(const DataLayout &DL) const {\n  // If we found more than 4 stores to merge or 16 bytes, use memset.\n  if (TheStores.size() >= 4 || End-Start >= 16) return true;\n\n  // If there is nothing to merge, don't do anything.\n  if (TheStores.size() < 2) return false;\n\n  // If any of the stores are a memset, then it is always good to extend the\n  // memset.\n  for (Instruction *SI : TheStores)\n    if (!isa<StoreInst>(SI))\n      return true;\n\n  // Assume that the code generator is capable of merging pairs of stores\n  // together if it wants to.\n  if (TheStores.size() == 2) return false;\n\n  // If we have fewer than 8 stores, it can still be worthwhile to do this.\n  // For example, merging 4 i8 stores into an i32 store is useful almost always.\n  // However, merging 2 32-bit stores isn't useful on a 32-bit architecture (the\n  // memset will be split into 2 32-bit stores anyway) and doing so can\n  // pessimize the llvm optimizer.\n  //\n  // Since we don't have perfect knowledge here, make some assumptions: assume\n  // the maximum GPR width is the same size as the largest legal integer\n  // size. If so, check to see whether we will end up actually reducing the\n  // number of stores used.\n  unsigned Bytes = unsigned(End-Start);\n  unsigned MaxIntSize = DL.getLargestLegalIntTypeSize();\n  if (MaxIntSize == 0)\n    MaxIntSize = 1;\n  unsigned NumPointerStores = Bytes / MaxIntSize;\n\n  // Assume the remaining bytes if any are done a byte at a time.\n  unsigned NumByteStores = Bytes % MaxIntSize;\n\n  // If we will reduce the # stores (according to this heuristic), do the\n  // transformation.  This encourages merging 4 x i8 -> i32 and 2 x i16 -> i32\n  // etc.\n  return TheStores.size() > NumPointerStores+NumByteStores;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  unsigned MaxIntSize = DL.getLargestLegalIntTypeSize();\n",
        "src_path": "f28beac4196167b0ca6184625bece102b0589b03___MemCpyOptimizer.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/f28beac4196167b0ca6184625bece102b0589b03",
        "commit_msg": "[MemCpyOpt] Use MaxIntSize in byte instead of bit\n\nSummary: This change fix the bug in isProfitableToUseMemset() where MaxIntSize shoule be in byte, not bit.\n\nReviewers: arsenm, joker.eph, mcrosier\n\nSubscribers: mcrosier, llvm-commits\n\nDifferential Revision: http://reviews.llvm.org/D20176\n\nllvm-svn: 269433",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/MemCpyOpt/profitable-memset.ll",
                "patch": "@@ -0,0 +1,20 @@\n+; RUN: opt < %s -memcpyopt -S | FileCheck %s\n+\n+target datalayout = \"e-m:e-i64:64-i128:128-n32:64-S128\"\n+\n+; CHECK-LABEL: @foo(\n+; CHECK-NOT: store\n+; CHECK: call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 8, i32 2, i1 false)\n+\n+define void @foo(i64* nocapture %P) {\n+entry:\n+  %0 = bitcast i64* %P to i16*\n+  %arrayidx = getelementptr inbounds i16, i16* %0, i64 1\n+  %1 = bitcast i16* %arrayidx to i32*\n+  %arrayidx1 = getelementptr inbounds i16, i16* %0, i64 3\n+  store i16 0, i16* %0, align 2\n+  store i32 0, i32* %1, align 4\n+  store i16 0, i16* %arrayidx1, align 2\n+  ret void\n+}\n+"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/MemCpyOpt/profitable-memset.ll (1 of 1)\nTesting Time: 0.11s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/MemCpyOpt/profitable-memset.ll\n\n  Unexpected Failures: 1\n"
    },
    "e7d833defb62c1e4a1944cbad740f540c0ab44d2___DwarfUnit.cpp": {
        "prefix": "void DwarfUnit::constructMemberDIE(DIE &Buffer, const DIDerivedType *DT) {\n  DIE &MemberDie = createAndAddDIE(DT->getTag(), Buffer);\n  StringRef Name = DT->getName();\n  if (!Name.empty())\n    addString(MemberDie, dwarf::DW_AT_name, Name);\n\n  addType(MemberDie, resolve(DT->getBaseType()));\n\n  addSourceLine(MemberDie, DT);\n\n  if (DT->getTag() == dwarf::DW_TAG_inheritance && DT->isVirtual()) {\n\n    // For C++, virtual base classes are not at fixed offset. Use following\n    // expression to extract appropriate offset from vtable.\n    // BaseAddr = ObAddr + *((*ObAddr) - Offset)\n\n    DIELoc *VBaseLocationDie = new (DIEValueAllocator) DIELoc;\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_dup);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_constu);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_udata, DT->getOffsetInBits());\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_minus);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus);\n\n    addBlock(MemberDie, dwarf::DW_AT_data_member_location, VBaseLocationDie);\n  } else {\n    uint64_t Size = DT->getSizeInBits();\n    uint64_t FieldSize = getBaseTypeSize(DD, DT);\n    uint64_t OffsetInBytes;\n\n    if (FieldSize && Size != FieldSize) {\n      // Handle bitfield, assume bytes are 8 bits.\n",
        "suffix": "      addUInt(MemberDie, dwarf::DW_AT_bit_size, None, Size);\n\n      uint64_t Offset = DT->getOffsetInBits();\n      uint64_t Align = DT->getAlignInBits() ? DT->getAlignInBits() : FieldSize;\n      uint64_t AlignMask = ~(Align - 1);\n      // The bits from the start of the storage unit to the start of the field.\n      uint64_t StartBitOffset = Offset - (Offset & AlignMask);\n      // The byte offset of the field's aligned storage unit inside the struct.\n      OffsetInBytes = (Offset - StartBitOffset) / 8;\n\n      if (DD->getDwarfVersion() >= 4)\n        addUInt(MemberDie, dwarf::DW_AT_data_bit_offset, None, Offset);\n      else {\n        uint64_t HiMark = (Offset + FieldSize) & AlignMask;\n        uint64_t FieldOffset = (HiMark - FieldSize);\n        Offset -= FieldOffset;\n\n        // Maybe we need to work from the other end.\n        if (Asm->getDataLayout().isLittleEndian())\n          Offset = FieldSize - (Offset + Size);\n\n        addUInt(MemberDie, dwarf::DW_AT_bit_offset, None, Offset);\n        OffsetInBytes = FieldOffset >> 3;\n      }\n    } else\n      // This is not a bitfield.\n      OffsetInBytes = DT->getOffsetInBits() / 8;\n\n    if (DD->getDwarfVersion() <= 2) {\n      DIELoc *MemLocationDie = new (DIEValueAllocator) DIELoc;\n      addUInt(*MemLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus_uconst);\n      addUInt(*MemLocationDie, dwarf::DW_FORM_udata, OffsetInBytes);\n      addBlock(MemberDie, dwarf::DW_AT_data_member_location, MemLocationDie);\n    } else\n      addUInt(MemberDie, dwarf::DW_AT_data_member_location, None,\n              OffsetInBytes);\n  }\n\n  if (DT->isProtected())\n    addUInt(MemberDie, dwarf::DW_AT_accessibility, dwarf::DW_FORM_data1,\n            dwarf::DW_ACCESS_protected);\n  else if (DT->isPrivate())\n    addUInt(MemberDie, dwarf::DW_AT_accessibility, dwarf::DW_FORM_data1,\n            dwarf::DW_ACCESS_private);\n  // Otherwise C++ member and base classes are considered public.\n  else if (DT->isPublic())\n    addUInt(MemberDie, dwarf::DW_AT_accessibility, dwarf::DW_FORM_data1,\n            dwarf::DW_ACCESS_public);\n  if (DT->isVirtual())\n    addUInt(MemberDie, dwarf::DW_AT_virtuality, dwarf::DW_FORM_data1,\n            dwarf::DW_VIRTUALITY_virtual);\n\n  // Objective-C properties.\n  if (DINode *PNode = DT->getObjCProperty())\n    if (DIE *PDie = getDIE(PNode))\n      MemberDie.addValue(DIEValueAllocator, dwarf::DW_AT_APPLE_property,\n                         dwarf::DW_FORM_ref4, DIEEntry(*PDie));\n\n  if (DT->isArtificial())\n    addFlag(MemberDie, dwarf::DW_AT_artificial);\n}\n",
        "start": 1363,
        "end": 1457,
        "buggy": "void DwarfUnit::constructMemberDIE(DIE &Buffer, const DIDerivedType *DT) {\n  DIE &MemberDie = createAndAddDIE(DT->getTag(), Buffer);\n  StringRef Name = DT->getName();\n  if (!Name.empty())\n    addString(MemberDie, dwarf::DW_AT_name, Name);\n\n  addType(MemberDie, resolve(DT->getBaseType()));\n\n  addSourceLine(MemberDie, DT);\n\n  if (DT->getTag() == dwarf::DW_TAG_inheritance && DT->isVirtual()) {\n\n    // For C++, virtual base classes are not at fixed offset. Use following\n    // expression to extract appropriate offset from vtable.\n    // BaseAddr = ObAddr + *((*ObAddr) - Offset)\n\n    DIELoc *VBaseLocationDie = new (DIEValueAllocator) DIELoc;\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_dup);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_constu);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_udata, DT->getOffsetInBits());\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_minus);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus);\n\n    addBlock(MemberDie, dwarf::DW_AT_data_member_location, VBaseLocationDie);\n  } else {\n    uint64_t Size = DT->getSizeInBits();\n    uint64_t FieldSize = getBaseTypeSize(DD, DT);\n    uint64_t OffsetInBytes;\n\n    if (FieldSize && Size != FieldSize) {\n      // Handle bitfield, assume bytes are 8 bits.\n      addUInt(MemberDie, dwarf::DW_AT_byte_size, None, FieldSize/8);\n      addUInt(MemberDie, dwarf::DW_AT_bit_size, None, Size);\n\n      uint64_t Offset = DT->getOffsetInBits();\n      uint64_t Align = DT->getAlignInBits() ? DT->getAlignInBits() : FieldSize;\n      uint64_t AlignMask = ~(Align - 1);\n      // The bits from the start of the storage unit to the start of the field.\n      uint64_t StartBitOffset = Offset - (Offset & AlignMask);\n      // The byte offset of the field's aligned storage unit inside the struct.\n      OffsetInBytes = (Offset - StartBitOffset) / 8;\n\n      if (DD->getDwarfVersion() >= 4)\n        addUInt(MemberDie, dwarf::DW_AT_data_bit_offset, None, Offset);\n      else {\n        uint64_t HiMark = (Offset + FieldSize) & AlignMask;\n        uint64_t FieldOffset = (HiMark - FieldSize);\n        Offset -= FieldOffset;\n\n        // Maybe we need to work from the other end.\n        if (Asm->getDataLayout().isLittleEndian())\n          Offset = FieldSize - (Offset + Size);\n\n        addUInt(MemberDie, dwarf::DW_AT_bit_offset, None, Offset);\n        OffsetInBytes = FieldOffset >> 3;\n      }\n    } else\n      // This is not a bitfield.\n      OffsetInBytes = DT->getOffsetInBits() / 8;\n\n    if (DD->getDwarfVersion() <= 2) {\n      DIELoc *MemLocationDie = new (DIEValueAllocator) DIELoc;\n      addUInt(*MemLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus_uconst);\n      addUInt(*MemLocationDie, dwarf::DW_FORM_udata, OffsetInBytes);\n      addBlock(MemberDie, dwarf::DW_AT_data_member_location, MemLocationDie);\n    } else\n      addUInt(MemberDie, dwarf::DW_AT_data_member_location, None,\n              OffsetInBytes);\n  }\n\n  if (DT->isProtected())\n    addUInt(MemberDie, dwarf::DW_AT_accessibility, dwarf::DW_FORM_data1,\n            dwarf::DW_ACCESS_protected);\n  else if (DT->isPrivate())\n    addUInt(MemberDie, dwarf::DW_AT_accessibility, dwarf::DW_FORM_data1,\n            dwarf::DW_ACCESS_private);\n  // Otherwise C++ member and base classes are considered public.\n  else if (DT->isPublic())\n    addUInt(MemberDie, dwarf::DW_AT_accessibility, dwarf::DW_FORM_data1,\n            dwarf::DW_ACCESS_public);\n  if (DT->isVirtual())\n    addUInt(MemberDie, dwarf::DW_AT_virtuality, dwarf::DW_FORM_data1,\n            dwarf::DW_VIRTUALITY_virtual);\n\n  // Objective-C properties.\n  if (DINode *PNode = DT->getObjCProperty())\n    if (DIE *PDie = getDIE(PNode))\n      MemberDie.addValue(DIEValueAllocator, dwarf::DW_AT_APPLE_property,\n                         dwarf::DW_FORM_ref4, DIEEntry(*PDie));\n\n  if (DT->isArtificial())\n    addFlag(MemberDie, dwarf::DW_AT_artificial);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      addUInt(MemberDie, dwarf::DW_AT_byte_size, None, FieldSize/8);\n",
        "src_path": "e7d833defb62c1e4a1944cbad740f540c0ab44d2___DwarfUnit.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/e7d833defb62c1e4a1944cbad740f540c0ab44d2",
        "commit_msg": "Debug info: Don't emit a DW_AT_byte_size when emitting a DWARF4 bit field.\nThe DWARF spec clearly states that a bit field member should have either a\nDW_AT_byte_size or a DW_AT_bit_size, but not both.\nAlso the DW_AT_byte_size is redundant with the size of the type of the member.\n\nThis fixes a bug found in PR 27758.\n\nllvm-svn: 269714",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/X86/bitfields-dwarf4.ll",
                "patch": "@@ -46,7 +46,10 @@ target triple = \"x86_64-apple-macosx\"\n ; CHECK-NEXT: DW_AT_name{{.*}}\"b\"\n ; CHECK-NOT:  DW_TAG\n ; CHECK-NOT:  DW_AT_bit_offset\n-; CHECK:      DW_AT_data_bit_offset      [DW_FORM_data1]\t(0x08)\n+; CHECK-NOT:  DW_AT_byte_size\n+; CHECK:      DW_AT_bit_size             [DW_FORM_data1]\t(0x05)\n+; CHECK-NOT:  DW_AT_byte_size\n+; CHECK-NEXT: DW_AT_data_bit_offset      [DW_FORM_data1]\t(0x08)\n ; CHECK-NEXT: DW_AT_data_member_location [DW_FORM_data1]\t(0x00)\n !9 = !DIDerivedType(tag: DW_TAG_member, name: \"b\", scope: !5, file: !1, line: 6, baseType: !10, size: 5, align: 32, offset: 8)\n \n@@ -58,7 +61,9 @@ target triple = \"x86_64-apple-macosx\"\n ; CHECK-NEXT: DW_AT_name{{.*}}\"c\"\n ; CHECK-NOT:  DW_TAG\n ; CHECK-NOT:  DW_AT_bit_offset\n-; CHECK:      DW_AT_data_bit_offset      [DW_FORM_data1]\t(0x0d)\n+; CHECK-NOT:  DW_AT_byte_size\n+; CHECK:      DW_AT_bit_size             [DW_FORM_data1]\t(0x1b)\n+; CHECK-NEXT: DW_AT_data_bit_offset      [DW_FORM_data1]\t(0x0d)\n ; CHECK-NEXT: DW_AT_data_member_location [DW_FORM_data1]\t(0x00)\n !13 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !5, file: !1, line: 7, baseType: !10, size: 27, align: 32, offset: 13)\n "
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/X86/bitfields-dwarf4.ll (1 of 1)\nTesting Time: 0.06s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/bitfields-dwarf4.ll\n\n  Unexpected Failures: 1\n"
    },
    "7008ce3f989105a667eab5f34f7ba6fcdc1ba3d8___InstrProfiling.cpp": {
        "prefix": "static inline bool shouldRecordFunctionAddr(Function *F) {\n  // Check the linkage\n  if (!F->hasLinkOnceLinkage() && !F->hasLocalLinkage() &&\n      !F->hasAvailableExternallyLinkage())\n    return true;\n  // Prohibit function address recording if the function is both internal and\n  // COMDAT. This avoids the profile data variable referencing internal symbols\n  // in COMDAT.\n  if (F->hasLocalLinkage() && F->hasComdat())\n    return false;\n  // Check uses of this function for other than direct calls or invokes to it.\n",
        "suffix": "}\n",
        "start": 250,
        "end": 262,
        "buggy": "static inline bool shouldRecordFunctionAddr(Function *F) {\n  // Check the linkage\n  if (!F->hasLinkOnceLinkage() && !F->hasLocalLinkage() &&\n      !F->hasAvailableExternallyLinkage())\n    return true;\n  // Prohibit function address recording if the function is both internal and\n  // COMDAT. This avoids the profile data variable referencing internal symbols\n  // in COMDAT.\n  if (F->hasLocalLinkage() && F->hasComdat())\n    return false;\n  // Check uses of this function for other than direct calls or invokes to it.\n  return F->hasAddressTaken();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  return F->hasAddressTaken();\n",
        "src_path": "7008ce3f989105a667eab5f34f7ba6fcdc1ba3d8___InstrProfiling.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/7008ce3f989105a667eab5f34f7ba6fcdc1ba3d8",
        "commit_msg": "[profile] value profiling bug fix -- missing icall targets in profile-use\n\nInline virtual functions has linkeonceodr linkage (emitted in comdat on \nsupporting targets). If the vtable for the class is not emitted in the\ndefining module, function won't be address taken thus its address is not\nrecorded. At the mercy of the linker, if the per-func prf_data from this\nmodule (in comdat) is picked at link time, we will lose mapping from\nfunction address to its hash val. This leads to missing icall promotion.\nThe second test case (currently disabled) in compiler_rt (r271528): \ninstrprof-icall-prom.test demostrates the bug. The first profile-use\nsubtest is fine due to linker order difference.\n\nWith this change, no missing icall targets is found in instrumented clang's\nraw profile.\n\nllvm-svn: 271532",
        "test_func_diff": [
            {
                "fn": "llvm/test/Instrumentation/InstrProfiling/PR23499.ll",
                "patch": "@@ -15,13 +15,13 @@ $_Z3barIvEvv = comdat any\n \n ; CHECK: @__profn__Z3barIvEvv = private constant [11 x i8] c\"_Z3barIvEvv\", align 1\n ; CHECK: @__profc__Z3barIvEvv = linkonce_odr hidden global [1 x i64] zeroinitializer, section \"{{.*}}__llvm_prf_cnts\", comdat($__profv__Z3barIvEvv), align 8\n-; CHECK: @__profd__Z3barIvEvv = linkonce_odr hidden global { i64, i64, i64*, i8*, i8*, i32, [1 x i16] } { i64 4947693190065689389, i64 0, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @__profc__Z3barIvEvv, i32 0, i32 0), i8* null, i8* null, i32 1, [1 x i16] zeroinitializer }, section \"{{.*}}__llvm_prf_data\", comdat($__profv__Z3barIvEvv), align 8\n+; CHECK: @__profd__Z3barIvEvv = linkonce_odr hidden global { i64, i64, i64*, i8*, i8*, i32, [1 x i16] } { i64 4947693190065689389, i64 0, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @__profc__Z3barIvEvv, i32 0, i32 0), i8*{{.*}}, i8* null, i32 1, [1 x i16] zeroinitializer }, section \"{{.*}}__llvm_prf_data\", comdat($__profv__Z3barIvEvv), align 8\n ; CHECK: @__llvm_prf_nm = private constant [{{.*}} x i8] c\"{{.*}}\", section \"{{.*}}__llvm_prf_names\"\n \n \n ; COFF: @__profn__Z3barIvEvv = private constant [11 x i8] c\"_Z3barIvEvv\", align 1\n ; COFF: @__profc__Z3barIvEvv = linkonce_odr hidden global [1 x i64] zeroinitializer, section \"{{.*}}__llvm_prf_cnts\", comdat, align 8\n-; COFF: @__profd__Z3barIvEvv = linkonce_odr hidden global { i64, i64, i64*, i8*, i8*, i32, [1 x i16] } { i64 4947693190065689389, i64 0, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @__profc__Z3barIvEvv, i32 0, i32 0), i8* null, i8* null, i32 1, [1 x i16] zeroinitializer }, section \"{{.*}}__llvm_prf_data\", comdat($__profc__Z3barIvEvv), align 8\n+; COFF: @__profd__Z3barIvEvv = linkonce_odr hidden global { i64, i64, i64*, i8*, i8*, i32, [1 x i16] } { i64 4947693190065689389, i64 0, i64* getelementptr inbounds ([1 x i64], [1 x i64]* @__profc__Z3barIvEvv, i32 0, i32 0), i8*{{.*}}, i8* null, i32 1, [1 x i16] zeroinitializer }, section \"{{.*}}__llvm_prf_data\", comdat($__profc__Z3barIvEvv), align 8\n \n \n declare void @llvm.instrprof.increment(i8*, i64, i32, i32) #1"
            },
            {
                "fn": "llvm/test/Transforms/PGOProfile/indirect_call_profile.ll",
                "patch": "@@ -1,8 +1,12 @@\n ; RUN: opt < %s -pgo-instr-gen -S | FileCheck %s --check-prefix=GEN\n ; RUN: opt < %s -passes=pgo-instr-gen -S | FileCheck %s --check-prefix=GEN\n+; RUN: opt < %s -passes=pgo-instr-gen,instrprof -S | FileCheck %s --check-prefix=LOWER\n+\n target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n target triple = \"x86_64-unknown-linux-gnu\"\n \n+$foo3 = comdat any\n+\n @bar = external global void ()*, align 8\n ; GEN: @__profn_foo = private constant [3 x i8] c\"foo\"\n \n@@ -49,6 +53,13 @@ bb11:                                             ; preds = %bb2\n   resume { i8*, i32 } %tmp3\n }\n \n+; Test that comdat function's address is recorded.\n+; LOWER: @__profd_foo3 = linkonce_odr{{.*}}@foo3\n+; Function Attrs: nounwind uwtable\n+define linkonce_odr i32 @foo3()  comdat  {\n+  ret i32 1\n+}\n+\n declare i32 @__gxx_personality_v0(...)\n \n ; Function Attrs: nounwind readnone"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/PGOProfile/indirect_call_profile.ll (1 of 1)\nTesting Time: 0.20s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/PGOProfile/indirect_call_profile.ll\n\n  Unexpected Failures: 1\n"
    },
    "ea8a2111690ab56450f7ab3cedcbcdbae17a87aa___InstCombineCompares.cpp": {
        "prefix": "Instruction *InstCombiner::visitICmpInstWithCastAndCast(ICmpInst &ICI) {\n  const CastInst *LHSCI = cast<CastInst>(ICI.getOperand(0));\n  Value *LHSCIOp        = LHSCI->getOperand(0);\n  Type *SrcTy     = LHSCIOp->getType();\n  Type *DestTy    = LHSCI->getType();\n  Value *RHSCIOp;\n\n  // Turn icmp (ptrtoint x), (ptrtoint/c) into a compare of the input if the\n  // integer type is the same size as the pointer type.\n  if (LHSCI->getOpcode() == Instruction::PtrToInt &&\n      DL.getPointerTypeSizeInBits(SrcTy) == DestTy->getIntegerBitWidth()) {\n    Value *RHSOp = nullptr;\n    if (PtrToIntOperator *RHSC = dyn_cast<PtrToIntOperator>(ICI.getOperand(1))) {\n      Value *RHSCIOp = RHSC->getOperand(0);\n      if (RHSCIOp->getType()->getPointerAddressSpace() ==\n          LHSCIOp->getType()->getPointerAddressSpace()) {\n        RHSOp = RHSC->getOperand(0);\n        // If the pointer types don't match, insert a bitcast.\n        if (LHSCIOp->getType() != RHSOp->getType())\n          RHSOp = Builder->CreateBitCast(RHSOp, LHSCIOp->getType());\n      }\n    } else if (Constant *RHSC = dyn_cast<Constant>(ICI.getOperand(1)))\n      RHSOp = ConstantExpr::getIntToPtr(RHSC, SrcTy);\n\n    if (RHSOp)\n      return new ICmpInst(ICI.getPredicate(), LHSCIOp, RHSOp);\n  }\n\n  // The code below only handles extension cast instructions, so far.\n  // Enforce this.\n  if (LHSCI->getOpcode() != Instruction::ZExt &&\n      LHSCI->getOpcode() != Instruction::SExt)\n    return nullptr;\n\n  bool isSignedExt = LHSCI->getOpcode() == Instruction::SExt;\n  bool isSignedCmp = ICI.isSigned();\n\n  if (CastInst *CI = dyn_cast<CastInst>(ICI.getOperand(1))) {\n    // Not an extension from the same type?\n    RHSCIOp = CI->getOperand(0);\n    if (RHSCIOp->getType() != LHSCIOp->getType())\n      return nullptr;\n\n    // If the signedness of the two casts doesn't agree (i.e. one is a sext\n    // and the other is a zext), then we can't handle this.\n    if (CI->getOpcode() != LHSCI->getOpcode())\n      return nullptr;\n\n    // Deal with equality cases early.\n    if (ICI.isEquality())\n      return new ICmpInst(ICI.getPredicate(), LHSCIOp, RHSCIOp);\n\n    // A signed comparison of sign extended values simplifies into a\n    // signed comparison.\n    if (isSignedCmp && isSignedExt)\n      return new ICmpInst(ICI.getPredicate(), LHSCIOp, RHSCIOp);\n\n    // The other three cases all fold into an unsigned comparison.\n    return new ICmpInst(ICI.getUnsignedPredicate(), LHSCIOp, RHSCIOp);\n  }\n\n  // If we aren't dealing with a constant on the RHS, exit early.\n",
        "suffix": "  if (!CI)\n    return nullptr;\n\n  // Compute the constant that would happen if we truncated to SrcTy then\n  // re-extended to DestTy.\n  Constant *Res1 = ConstantExpr::getTrunc(CI, SrcTy);\n  Constant *Res2 = ConstantExpr::getCast(LHSCI->getOpcode(), Res1, DestTy);\n\n  // If the re-extended constant didn't change...\n  if (Res2 == CI) {\n    // Deal with equality cases early.\n    if (ICI.isEquality())\n      return new ICmpInst(ICI.getPredicate(), LHSCIOp, Res1);\n\n    // A signed comparison of sign extended values simplifies into a\n    // signed comparison.\n    if (isSignedExt && isSignedCmp)\n      return new ICmpInst(ICI.getPredicate(), LHSCIOp, Res1);\n\n    // The other three cases all fold into an unsigned comparison.\n    return new ICmpInst(ICI.getUnsignedPredicate(), LHSCIOp, Res1);\n  }\n\n  // The re-extended constant changed so the constant cannot be represented\n  // in the shorter type. Consequently, we cannot emit a simple comparison.\n  // All the cases that fold to true or false will have already been handled\n  // by SimplifyICmpInst, so only deal with the tricky case.\n\n  if (isSignedCmp || !isSignedExt)\n    return nullptr;\n\n  // Evaluate the comparison for LT (we invert for GT below). LE and GE cases\n  // should have been folded away previously and not enter in here.\n\n  // We're performing an unsigned comp with a sign extended value.\n  // This is true if the input is >= 0. [aka >s -1]\n  Constant *NegOne = Constant::getAllOnesValue(SrcTy);\n  Value *Result = Builder->CreateICmpSGT(LHSCIOp, NegOne, ICI.getName());\n\n  // Finally, return the value computed.\n  if (ICI.getPredicate() == ICmpInst::ICMP_ULT)\n    return replaceInstUsesWith(ICI, Result);\n\n  assert(ICI.getPredicate() == ICmpInst::ICMP_UGT && \"ICmp should be folded!\");\n  return BinaryOperator::CreateNot(Result);\n}\n",
        "start": 2380,
        "end": 2488,
        "buggy": "Instruction *InstCombiner::visitICmpInstWithCastAndCast(ICmpInst &ICI) {\n  const CastInst *LHSCI = cast<CastInst>(ICI.getOperand(0));\n  Value *LHSCIOp        = LHSCI->getOperand(0);\n  Type *SrcTy     = LHSCIOp->getType();\n  Type *DestTy    = LHSCI->getType();\n  Value *RHSCIOp;\n\n  // Turn icmp (ptrtoint x), (ptrtoint/c) into a compare of the input if the\n  // integer type is the same size as the pointer type.\n  if (LHSCI->getOpcode() == Instruction::PtrToInt &&\n      DL.getPointerTypeSizeInBits(SrcTy) == DestTy->getIntegerBitWidth()) {\n    Value *RHSOp = nullptr;\n    if (PtrToIntOperator *RHSC = dyn_cast<PtrToIntOperator>(ICI.getOperand(1))) {\n      Value *RHSCIOp = RHSC->getOperand(0);\n      if (RHSCIOp->getType()->getPointerAddressSpace() ==\n          LHSCIOp->getType()->getPointerAddressSpace()) {\n        RHSOp = RHSC->getOperand(0);\n        // If the pointer types don't match, insert a bitcast.\n        if (LHSCIOp->getType() != RHSOp->getType())\n          RHSOp = Builder->CreateBitCast(RHSOp, LHSCIOp->getType());\n      }\n    } else if (Constant *RHSC = dyn_cast<Constant>(ICI.getOperand(1)))\n      RHSOp = ConstantExpr::getIntToPtr(RHSC, SrcTy);\n\n    if (RHSOp)\n      return new ICmpInst(ICI.getPredicate(), LHSCIOp, RHSOp);\n  }\n\n  // The code below only handles extension cast instructions, so far.\n  // Enforce this.\n  if (LHSCI->getOpcode() != Instruction::ZExt &&\n      LHSCI->getOpcode() != Instruction::SExt)\n    return nullptr;\n\n  bool isSignedExt = LHSCI->getOpcode() == Instruction::SExt;\n  bool isSignedCmp = ICI.isSigned();\n\n  if (CastInst *CI = dyn_cast<CastInst>(ICI.getOperand(1))) {\n    // Not an extension from the same type?\n    RHSCIOp = CI->getOperand(0);\n    if (RHSCIOp->getType() != LHSCIOp->getType())\n      return nullptr;\n\n    // If the signedness of the two casts doesn't agree (i.e. one is a sext\n    // and the other is a zext), then we can't handle this.\n    if (CI->getOpcode() != LHSCI->getOpcode())\n      return nullptr;\n\n    // Deal with equality cases early.\n    if (ICI.isEquality())\n      return new ICmpInst(ICI.getPredicate(), LHSCIOp, RHSCIOp);\n\n    // A signed comparison of sign extended values simplifies into a\n    // signed comparison.\n    if (isSignedCmp && isSignedExt)\n      return new ICmpInst(ICI.getPredicate(), LHSCIOp, RHSCIOp);\n\n    // The other three cases all fold into an unsigned comparison.\n    return new ICmpInst(ICI.getUnsignedPredicate(), LHSCIOp, RHSCIOp);\n  }\n\n  // If we aren't dealing with a constant on the RHS, exit early.\n  auto *CI = dyn_cast<ConstantInt>(ICI.getOperand(1));\n  if (!CI)\n    return nullptr;\n\n  // Compute the constant that would happen if we truncated to SrcTy then\n  // re-extended to DestTy.\n  Constant *Res1 = ConstantExpr::getTrunc(CI, SrcTy);\n  Constant *Res2 = ConstantExpr::getCast(LHSCI->getOpcode(), Res1, DestTy);\n\n  // If the re-extended constant didn't change...\n  if (Res2 == CI) {\n    // Deal with equality cases early.\n    if (ICI.isEquality())\n      return new ICmpInst(ICI.getPredicate(), LHSCIOp, Res1);\n\n    // A signed comparison of sign extended values simplifies into a\n    // signed comparison.\n    if (isSignedExt && isSignedCmp)\n      return new ICmpInst(ICI.getPredicate(), LHSCIOp, Res1);\n\n    // The other three cases all fold into an unsigned comparison.\n    return new ICmpInst(ICI.getUnsignedPredicate(), LHSCIOp, Res1);\n  }\n\n  // The re-extended constant changed so the constant cannot be represented\n  // in the shorter type. Consequently, we cannot emit a simple comparison.\n  // All the cases that fold to true or false will have already been handled\n  // by SimplifyICmpInst, so only deal with the tricky case.\n\n  if (isSignedCmp || !isSignedExt)\n    return nullptr;\n\n  // Evaluate the comparison for LT (we invert for GT below). LE and GE cases\n  // should have been folded away previously and not enter in here.\n\n  // We're performing an unsigned comp with a sign extended value.\n  // This is true if the input is >= 0. [aka >s -1]\n  Constant *NegOne = Constant::getAllOnesValue(SrcTy);\n  Value *Result = Builder->CreateICmpSGT(LHSCIOp, NegOne, ICI.getName());\n\n  // Finally, return the value computed.\n  if (ICI.getPredicate() == ICmpInst::ICMP_ULT)\n    return replaceInstUsesWith(ICI, Result);\n\n  assert(ICI.getPredicate() == ICmpInst::ICMP_UGT && \"ICmp should be folded!\");\n  return BinaryOperator::CreateNot(Result);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  auto *CI = dyn_cast<ConstantInt>(ICI.getOperand(1));\n",
        "src_path": "ea8a2111690ab56450f7ab3cedcbcdbae17a87aa___InstCombineCompares.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/ea8a2111690ab56450f7ab3cedcbcdbae17a87aa",
        "commit_msg": "[InstCombine] allow vector constants for cast+icmp fold\n\nThis is step 1 of unknown towards fixing PR28001:\nhttps://llvm.org/bugs/show_bug.cgi?id=28001\n\nllvm-svn: 271810",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/cast.ll",
                "patch": "@@ -214,19 +214,26 @@ define i1 @test19(i32 %X) {\n   ret i1 %Z\n }\n \n-; FIXME: Vector should be the same as scalar.\n-\n define <2 x i1> @test19vec(<2 x i32> %X) {\n ; CHECK-LABEL: @test19vec(\n-; CHECK-NEXT:    [[C:%.*]] = sext <2 x i32> %X to <2 x i64>\n-; CHECK-NEXT:    [[Z:%.*]] = icmp slt <2 x i64> [[C]], <i64 12345, i64 2147483647>\n+; CHECK-NEXT:    [[Z:%.*]] = icmp slt <2 x i32> %X, <i32 12345, i32 2147483647>\n ; CHECK-NEXT:    ret <2 x i1> [[Z]]\n ;\n   %c = sext <2 x i32> %X to <2 x i64>\n   %Z = icmp slt <2 x i64> %c, <i64 12345, i64 2147483647>\n   ret <2 x i1> %Z\n }\n \n+define <3 x i1> @test19vec2(<3 x i1> %X) {\n+; CHECK-LABEL: @test19vec2(\n+; CHECK-NEXT:    [[CMPEQ:%.*]] = icmp eq <3 x i1> %X, zeroinitializer\n+; CHECK-NEXT:    ret <3 x i1> [[CMPEQ]]\n+;\n+  %sext = sext <3 x i1> %X to <3 x i32>\n+  %cmpeq = icmp eq <3 x i32> %sext, zeroinitializer\n+  ret <3 x i1> %cmpeq\n+}\n+\n define i1 @test20(i1 %B) {\n ; CHECK-LABEL: @test20(\n ; CHECK-NEXT:    ret i1 false"
            },
            {
                "fn": "llvm/test/Transforms/InstCombine/signed-comparison.ll",
                "patch": "@@ -13,12 +13,9 @@ define i1 @scalar_zext_slt(i16 %t4) {\n   ret i1 %t6\n }\n \n-; FIXME: Vector compare should work the same as scalar.\n-\n define <4 x i1> @vector_zext_slt(<4 x i16> %t4) {\n ; CHECK-LABEL: @vector_zext_slt(\n-; CHECK-NEXT:    [[T5:%.*]] = zext <4 x i16> %t4 to <4 x i32>\n-; CHECK-NEXT:    [[T6:%.*]] = icmp ult <4 x i32> [[T5]], <i32 500, i32 0, i32 501, i32 65535>\n+; CHECK-NEXT:    [[T6:%.*]] = icmp ult <4 x i16> %t4, <i16 500, i16 0, i16 501, i16 -1>\n ; CHECK-NEXT:    ret <4 x i1> [[T6]]\n ;\n   %t5 = zext <4 x i16> %t4 to <4 x i32>"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/cast.ll (1 of 1)\nTesting Time: 0.24s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/cast.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Transforms/InstCombine/signed-comparison.ll (1 of 1)\nTesting Time: 0.07s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/signed-comparison.ll\n\n  Unexpected Failures: 1\n"
    },
    "01fd7c8bd4fb3385215bff758b0bf68f179e842b___AsmPrinter.cpp": {
        "prefix": "void AsmPrinter::emitXRayTable() {\n  if (Sleds.empty())\n    return;\n\n  auto PrevSection = OutStreamer->getCurrentSectionOnly();\n  auto Fn = MF->getFunction();\n  MCSection *InstMap = nullptr;\n  MCSection *FnSledIndex = nullptr;\n  if (MF->getSubtarget().getTargetTriple().isOSBinFormatELF()) {\n",
        "suffix": "    assert(Associated != nullptr);\n    auto Flags = ELF::SHF_WRITE | ELF::SHF_ALLOC | ELF::SHF_LINK_ORDER;\n    std::string GroupName;\n    if (Fn->hasComdat()) {\n      Flags |= ELF::SHF_GROUP;\n      GroupName = Fn->getComdat()->getName();\n    }\n\n    auto UniqueID = ++XRayFnUniqueID;\n    InstMap =\n        OutContext.getELFSection(\"xray_instr_map\", ELF::SHT_PROGBITS, Flags, 0,\n                                 GroupName, UniqueID, Associated);\n    FnSledIndex =\n        OutContext.getELFSection(\"xray_fn_idx\", ELF::SHT_PROGBITS, Flags, 0,\n                                 GroupName, UniqueID, Associated);\n  } else if (MF->getSubtarget().getTargetTriple().isOSBinFormatMachO()) {\n    InstMap = OutContext.getMachOSection(\"__DATA\", \"xray_instr_map\", 0,\n                                         SectionKind::getReadOnlyWithRel());\n    FnSledIndex = OutContext.getMachOSection(\"__DATA\", \"xray_fn_idx\", 0,\n                                             SectionKind::getReadOnlyWithRel());\n  } else {\n    llvm_unreachable(\"Unsupported target\");\n  }\n\n  auto WordSizeBytes = MAI->getCodePointerSize();\n\n  // Now we switch to the instrumentation map section. Because this is done\n  // per-function, we are able to create an index entry that will represent the\n  // range of sleds associated with a function.\n  MCSymbol *SledsStart = OutContext.createTempSymbol(\"xray_sleds_start\", true);\n  OutStreamer->SwitchSection(InstMap);\n  OutStreamer->EmitLabel(SledsStart);\n  for (const auto &Sled : Sleds)\n    Sled.emit(WordSizeBytes, OutStreamer.get(), CurrentFnSym);\n  MCSymbol *SledsEnd = OutContext.createTempSymbol(\"xray_sleds_end\", true);\n  OutStreamer->EmitLabel(SledsEnd);\n\n  // We then emit a single entry in the index per function. We use the symbols\n  // that bound the instrumentation map as the range for a specific function.\n  // Each entry here will be 2 * word size aligned, as we're writing down two\n  // pointers. This should work for both 32-bit and 64-bit platforms.\n  OutStreamer->SwitchSection(FnSledIndex);\n  OutStreamer->EmitCodeAlignment(2 * WordSizeBytes);\n  OutStreamer->EmitSymbolValue(SledsStart, WordSizeBytes, false);\n  OutStreamer->EmitSymbolValue(SledsEnd, WordSizeBytes, false);\n  OutStreamer->SwitchSection(PrevSection);\n  Sleds.clear();\n}\n",
        "start": 2779,
        "end": 2836,
        "buggy": "void AsmPrinter::emitXRayTable() {\n  if (Sleds.empty())\n    return;\n\n  auto PrevSection = OutStreamer->getCurrentSectionOnly();\n  auto Fn = MF->getFunction();\n  MCSection *InstMap = nullptr;\n  MCSection *FnSledIndex = nullptr;\n  if (MF->getSubtarget().getTargetTriple().isOSBinFormatELF()) {\n    auto Associated = dyn_cast<MCSymbolELF>(PrevSection->getBeginSymbol());\n    assert(Associated != nullptr);\n    auto Flags = ELF::SHF_WRITE | ELF::SHF_ALLOC | ELF::SHF_LINK_ORDER;\n    std::string GroupName;\n    if (Fn->hasComdat()) {\n      Flags |= ELF::SHF_GROUP;\n      GroupName = Fn->getComdat()->getName();\n    }\n\n    auto UniqueID = ++XRayFnUniqueID;\n    InstMap =\n        OutContext.getELFSection(\"xray_instr_map\", ELF::SHT_PROGBITS, Flags, 0,\n                                 GroupName, UniqueID, Associated);\n    FnSledIndex =\n        OutContext.getELFSection(\"xray_fn_idx\", ELF::SHT_PROGBITS, Flags, 0,\n                                 GroupName, UniqueID, Associated);\n  } else if (MF->getSubtarget().getTargetTriple().isOSBinFormatMachO()) {\n    InstMap = OutContext.getMachOSection(\"__DATA\", \"xray_instr_map\", 0,\n                                         SectionKind::getReadOnlyWithRel());\n    FnSledIndex = OutContext.getMachOSection(\"__DATA\", \"xray_fn_idx\", 0,\n                                             SectionKind::getReadOnlyWithRel());\n  } else {\n    llvm_unreachable(\"Unsupported target\");\n  }\n\n  auto WordSizeBytes = MAI->getCodePointerSize();\n\n  // Now we switch to the instrumentation map section. Because this is done\n  // per-function, we are able to create an index entry that will represent the\n  // range of sleds associated with a function.\n  MCSymbol *SledsStart = OutContext.createTempSymbol(\"xray_sleds_start\", true);\n  OutStreamer->SwitchSection(InstMap);\n  OutStreamer->EmitLabel(SledsStart);\n  for (const auto &Sled : Sleds)\n    Sled.emit(WordSizeBytes, OutStreamer.get(), CurrentFnSym);\n  MCSymbol *SledsEnd = OutContext.createTempSymbol(\"xray_sleds_end\", true);\n  OutStreamer->EmitLabel(SledsEnd);\n\n  // We then emit a single entry in the index per function. We use the symbols\n  // that bound the instrumentation map as the range for a specific function.\n  // Each entry here will be 2 * word size aligned, as we're writing down two\n  // pointers. This should work for both 32-bit and 64-bit platforms.\n  OutStreamer->SwitchSection(FnSledIndex);\n  OutStreamer->EmitCodeAlignment(2 * WordSizeBytes);\n  OutStreamer->EmitSymbolValue(SledsStart, WordSizeBytes, false);\n  OutStreamer->EmitSymbolValue(SledsEnd, WordSizeBytes, false);\n  OutStreamer->SwitchSection(PrevSection);\n  Sleds.clear();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    auto Associated = dyn_cast<MCSymbolELF>(PrevSection->getBeginSymbol());\n",
        "src_path": "01fd7c8bd4fb3385215bff758b0bf68f179e842b___AsmPrinter.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/01fd7c8bd4fb3385215bff758b0bf68f179e842b",
        "commit_msg": "[XRay][CodeGen] Use the current function symbol as the associated symbol for the instrumentation map\n\nSummary:\nXRay had been assuming that the previous section is the \"text\" section\nof the function when lowering the instrumentation map. Unfortunately\nthis is not a safe assumption, because we may be coming from lowering\ndebug type information for the function being lowered.\n\nThis fixes an issue with combining -gsplit-dwarf, -generate-type-units,\n-debug-compile and -fxray-instrument for sole member functions. When the\nsplit dwarf section is stripped, we're left with references from the\nxray_instr_map to the debug section. The change now uses the function's\nsymbol instead of the previous section's start symbol.\n\nWe found the bug while attempting to strip the split debug sections off\nan XRay-instrumented object file, which had a peculiar edge-case for\nsingle-function classes where the single function is being lowered.\nBecause XRay had assocaited the instrumentation map for a function to\nthe debug types section instead of the function's section, the objcopy\ncall will fail due to the misplaced reference from the xray_instr_map\nsection.\n\nReviewers: pcc, dblaikie, echristo\n\nSubscribers: llvm-commits, aprantl\n\nDifferential Revision: https://reviews.llvm.org/D37791\n\nllvm-svn: 313233",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/Mips/xray-section-group.ll",
                "patch": "@@ -14,7 +14,7 @@\n define i32 @foo() nounwind noinline uwtable \"function-instrument\"=\"xray-always\" {\n ; CHECK: .section .text.foo,\"ax\",@progbits\n   ret i32 0\n-; CHECK: .section xray_instr_map,\"awo\",@progbits,.text.foo,unique,1\n+; CHECK: .section xray_instr_map,\"awo\",@progbits,foo,unique,1\n }\n \n ; CHECK-OBJ: Section {\n@@ -24,7 +24,7 @@ $bar = comdat any\n define i32 @bar() nounwind noinline uwtable \"function-instrument\"=\"xray-always\" comdat($bar) {\n ; CHECK: .section .text.bar,\"axG\",@progbits,bar,comdat\n   ret i32 1\n-; CHECK: .section xray_instr_map,\"aGwo\",@progbits,bar,comdat,.text.bar,unique,2\n+; CHECK: .section xray_instr_map,\"aGwo\",@progbits,bar,comdat,bar,unique,2\n }\n \n ; CHECK-OBJ: Section {"
            },
            {
                "fn": "llvm/test/CodeGen/PowerPC/xray-attribute-instrumentation.ll",
                "patch": "@@ -22,7 +22,7 @@ define i32 @foo() nounwind noinline uwtable \"function-instrument\"=\"xray-always\"\n ; CHECK-NEXT:         nop\n ; CHECK-NEXT:         mtlr 0\n }\n-; CHECK-LABEL: xray_instr_map,\"awo\",@progbits,.text,unique,1\n+; CHECK-LABEL: xray_instr_map,\"awo\",@progbits,foo,unique,1\n ; CHECK:      .Lxray_sleds_start0:\n ; CHECK-NEXT:         .quad   .Ltmp0\n ; CHECK-NEXT:         .quad   foo\n@@ -37,7 +37,7 @@ define i32 @foo() nounwind noinline uwtable \"function-instrument\"=\"xray-always\"\n ; CHECK-NEXT:         .byte   0x00\n ; CHECK-NEXT:         .space  13\n ; CHECK-NEXT: .Lxray_sleds_end0:\n-; CHECK-LABEL: xray_fn_idx,\"awo\",@progbits,.text,unique,1\n+; CHECK-LABEL: xray_fn_idx,\"awo\",@progbits,foo,unique,1\n ; CHECK:              .p2align        4\n ; CHECK-NEXT:         .quad   .Lxray_sleds_start0\n ; CHECK-NEXT:         .quad   .Lxray_sleds_end0"
            },
            {
                "fn": "llvm/test/CodeGen/X86/xray-section-group.ll",
                "patch": "@@ -5,14 +5,14 @@\n define i32 @foo() nounwind noinline uwtable \"function-instrument\"=\"xray-always\" {\n ; CHECK: .section .text.foo,\"ax\",@progbits\n   ret i32 0\n-; CHECK: .section xray_instr_map,\"awo\",@progbits,.text.foo,unique,1\n+; CHECK: .section xray_instr_map,\"awo\",@progbits,foo,unique,1\n }\n \n $bar = comdat any\n define i32 @bar() nounwind noinline uwtable \"function-instrument\"=\"xray-always\" comdat($bar) {\n ; CHECK: .section .text.bar,\"axG\",@progbits,bar,comdat\n   ret i32 1\n-; CHECK: .section xray_instr_map,\"aGwo\",@progbits,bar,comdat,.text.bar,unique,2\n+; CHECK: .section xray_instr_map,\"aGwo\",@progbits,bar,comdat,bar,unique,2\n }\n \n ; CHECK-OBJ:      section xray_instr_map:"
            },
            {
                "fn": "llvm/test/DebugInfo/X86/xray-split-dwarf-interaction.ll",
                "patch": "@@ -0,0 +1,84 @@\n+; RUN: %llc_dwarf -split-dwarf-file=input.dwo -O3 \\\n+; RUN:     -function-sections -data-sections \\\n+; RUN:     -relocation-model=pic -filetype=asm \\\n+; RUN:     -generate-type-units -debug-compile -o - %s | \\\n+; RUN:     FileCheck %s --check-prefix=CHECK-ASM\n+; RUN: %llc_dwarf -split-dwarf-file=input.dwo -O3 \\\n+; RUN:     -function-sections -data-sections \\\n+; RUN:     -relocation-model=pic -filetype=obj \\\n+; RUN:     -generate-type-units -debug-compile -o - %s | \\\n+; RUN:     llvm-readelf -sections | \\\n+; RUN:     FileCheck %s --check-prefix=CHECK-ELF\n+; Created from `clang++ -fxray-instrument -gsplit-dwarf -fdebug-types-section\n+; -ffunction-sections -fdata-sections -emit-llvm -S input.cc`:\n+; input.cc:\n+;\n+; class a {\n+;   int b();\n+; };\n+; int a::b() {\n+;   for (;;)\n+;     ;\n+; }\n+;\n+; In this test we want to make sure that the xray_instr_map section for\n+; `a::b()` is actually associated with the function's symbol instead of the\n+; .debug_types.dwo section.\n+;\n+; CHECK-ASM: xray_fn_idx,\"awo\",@progbits,_ZN1a1bEv,unique,1\n+;\n+; CHECK-ELF-DAG: [[FSECT:[0-9]+]]] .text._ZN1a1bEv PROGBITS\n+; CHECK-ELF-DAG: [{{.*}}] .debug_types.dwo PROGBITS\n+; CHECK-ELF-DAG: [{{.*}}] xray_instr_map PROGBITS {{.*}} {{.*}} {{.*}} {{.*}} WAL [[FSECT]]\n+target triple = \"x86_64-pc-linux\"\n+\n+%class.a = type { i8 }\n+\n+; Function Attrs: nounwind readnone uwtable\n+define i32 @_ZN1a1bEv(%class.a* nocapture readnone) local_unnamed_addr #0 align 2 !dbg !8 {\n+  tail call void @llvm.dbg.value(metadata %class.a* %0, metadata !17, metadata !DIExpression()), !dbg !19\n+  br label %2, !dbg !20\n+\n+; <label>:2:                                      ; preds = %2, %1\n+  br label %2, !dbg !21, !llvm.loop !25\n+}\n+\n+\n+; Function Attrs: nounwind readnone speculatable\n+declare void @llvm.dbg.value(metadata, metadata, metadata) #1\n+\n+attributes #0 = { nounwind readnone uwtable \"xray-instruction-threshold\"=\"200\" }\n+attributes #1 = { nounwind readnone speculatable }\n+\n+!llvm.dbg.cu = !{!0}\n+!llvm.module.flags = !{!3, !4, !5, !6}\n+!llvm.ident = !{!7}\n+\n+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !1, producer: \"clang version trunk (trunk r312634)\", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, splitDebugInlining: false, debugInfoForProfiling: true)\n+!1 = !DIFile(filename: \"input.cc\", directory: \"/usr/local/google/home/dberris/tmp\")\n+!2 = !{}\n+!3 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!4 = !{i32 1, !\"wchar_size\", i32 4}\n+!5 = !{i32 7, !\"PIC Level\", i32 2}\n+!6 = !{i32 7, !\"PIE Level\", i32 2}\n+!7 = !{!\"clang version trunk (trunk r312634)\"}\n+!8 = distinct !DISubprogram(name: \"b\", linkageName: \"_ZN1a1bEv\", scope: !9, file: !1, line: 4, type: !12, isLocal: false, isDefinition: true, scopeLine: 4, flags: DIFlagPrototyped, isOptimized: true, unit: !0, declaration: !11, variables: !16)\n+!9 = distinct !DICompositeType(tag: DW_TAG_class_type, name: \"a\", file: !1, line: 1, size: 8, elements: !10, identifier: \"_ZTS1a\")\n+!10 = !{!11}\n+!11 = !DISubprogram(name: \"b\", linkageName: \"_ZN1a1bEv\", scope: !9, file: !1, line: 2, type: !12, isLocal: false, isDefinition: false, scopeLine: 2, flags: DIFlagPrototyped, isOptimized: true)\n+!12 = !DISubroutineType(types: !13)\n+!13 = !{!14, !15}\n+!14 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n+!15 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !9, size: 64, flags: DIFlagArtificial | DIFlagObjectPointer)\n+!16 = !{!17}\n+!17 = !DILocalVariable(name: \"this\", arg: 1, scope: !8, type: !18, flags: DIFlagArtificial | DIFlagObjectPointer)\n+!18 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !9, size: 64)\n+!19 = !DILocation(line: 0, scope: !8)\n+!20 = !DILocation(line: 5, column: 3, scope: !8)\n+!21 = !DILocation(line: 5, column: 3, scope: !22)\n+!22 = !DILexicalBlockFile(scope: !23, file: !1, discriminator: 2)\n+!23 = distinct !DILexicalBlock(scope: !24, file: !1, line: 5, column: 3)\n+!24 = distinct !DILexicalBlock(scope: !8, file: !1, line: 5, column: 3)\n+!25 = distinct !{!25, !26, !27}\n+!26 = !DILocation(line: 5, column: 3, scope: !24)\n+!27 = !DILocation(line: 6, column: 5, scope: !24)"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/xray-section-group.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/xray-section-group.ll\n\n  Unexpected Failures: 1\n"
    },
    "ccfa5257a659cf1f54dd3f8518c8c42218369c41___X86ISelLowering.cpp": {
        "prefix": "static SDValue combineFneg(SDNode *N, SelectionDAG &DAG,\n                           const X86Subtarget &Subtarget) {\n  EVT OrigVT = N->getValueType(0);\n  SDValue Arg = isFNEG(N);\n  assert(Arg.getNode() && \"N is expected to be an FNEG node\");\n\n  EVT VT = Arg.getValueType();\n  EVT SVT = VT.getScalarType();\n  SDLoc DL(N);\n\n  // Let legalize expand this if it isn't a legal type yet.\n  if (!DAG.getTargetLoweringInfo().isTypeLegal(VT))\n    return SDValue();\n\n  // If we're negating a FMUL node on a target with FMA, then we can avoid the\n  // use of a constant by performing (-0 - A*B) instead.\n  // FIXME: Check rounding control flags as well once it becomes available.\n  if (Arg.getOpcode() == ISD::FMUL && (SVT == MVT::f32 || SVT == MVT::f64) &&\n      Arg->getFlags().hasNoSignedZeros() && Subtarget.hasAnyFMA()) {\n    SDValue Zero = DAG.getConstantFP(0.0, DL, VT);\n    SDValue NewNode = DAG.getNode(X86ISD::FNMSUB, DL, VT, Arg.getOperand(0),\n                                  Arg.getOperand(1), Zero);\n    return DAG.getBitcast(OrigVT, NewNode);\n  }\n\n  // If we're negating an FMA node, then we can adjust the\n  // instruction to include the extra negation.\n  unsigned NewOpcode = 0;\n",
        "suffix": "    switch (Arg.getOpcode()) {\n    case ISD::FMA:             NewOpcode = X86ISD::FNMSUB;       break;\n    case X86ISD::FMSUB:        NewOpcode = X86ISD::FNMADD;       break;\n    case X86ISD::FNMADD:       NewOpcode = X86ISD::FMSUB;        break;\n    case X86ISD::FNMSUB:       NewOpcode = ISD::FMA;             break;\n    case X86ISD::FMADD_RND:    NewOpcode = X86ISD::FNMSUB_RND;   break;\n    case X86ISD::FMSUB_RND:    NewOpcode = X86ISD::FNMADD_RND;   break;\n    case X86ISD::FNMADD_RND:   NewOpcode = X86ISD::FMSUB_RND;    break;\n    case X86ISD::FNMSUB_RND:   NewOpcode = X86ISD::FMADD_RND;    break;\n    // We can't handle scalar intrinsic node here because it would only\n    // invert one element and not the whole vector. But we could try to handle\n    // a negation of the lower element only.\n    }\n  }\n  if (NewOpcode)\n    return DAG.getBitcast(OrigVT, DAG.getNode(NewOpcode, DL, VT,\n                                              Arg.getNode()->ops()));\n\n  return SDValue();\n}\n",
        "start": 35712,
        "end": 35760,
        "buggy": "static SDValue combineFneg(SDNode *N, SelectionDAG &DAG,\n                           const X86Subtarget &Subtarget) {\n  EVT OrigVT = N->getValueType(0);\n  SDValue Arg = isFNEG(N);\n  assert(Arg.getNode() && \"N is expected to be an FNEG node\");\n\n  EVT VT = Arg.getValueType();\n  EVT SVT = VT.getScalarType();\n  SDLoc DL(N);\n\n  // Let legalize expand this if it isn't a legal type yet.\n  if (!DAG.getTargetLoweringInfo().isTypeLegal(VT))\n    return SDValue();\n\n  // If we're negating a FMUL node on a target with FMA, then we can avoid the\n  // use of a constant by performing (-0 - A*B) instead.\n  // FIXME: Check rounding control flags as well once it becomes available.\n  if (Arg.getOpcode() == ISD::FMUL && (SVT == MVT::f32 || SVT == MVT::f64) &&\n      Arg->getFlags().hasNoSignedZeros() && Subtarget.hasAnyFMA()) {\n    SDValue Zero = DAG.getConstantFP(0.0, DL, VT);\n    SDValue NewNode = DAG.getNode(X86ISD::FNMSUB, DL, VT, Arg.getOperand(0),\n                                  Arg.getOperand(1), Zero);\n    return DAG.getBitcast(OrigVT, NewNode);\n  }\n\n  // If we're negating an FMA node, then we can adjust the\n  // instruction to include the extra negation.\n  unsigned NewOpcode = 0;\n  if (Arg.hasOneUse()) {\n    switch (Arg.getOpcode()) {\n    case ISD::FMA:             NewOpcode = X86ISD::FNMSUB;       break;\n    case X86ISD::FMSUB:        NewOpcode = X86ISD::FNMADD;       break;\n    case X86ISD::FNMADD:       NewOpcode = X86ISD::FMSUB;        break;\n    case X86ISD::FNMSUB:       NewOpcode = ISD::FMA;             break;\n    case X86ISD::FMADD_RND:    NewOpcode = X86ISD::FNMSUB_RND;   break;\n    case X86ISD::FMSUB_RND:    NewOpcode = X86ISD::FNMADD_RND;   break;\n    case X86ISD::FNMADD_RND:   NewOpcode = X86ISD::FMSUB_RND;    break;\n    case X86ISD::FNMSUB_RND:   NewOpcode = X86ISD::FMADD_RND;    break;\n    // We can't handle scalar intrinsic node here because it would only\n    // invert one element and not the whole vector. But we could try to handle\n    // a negation of the lower element only.\n    }\n  }\n  if (NewOpcode)\n    return DAG.getBitcast(OrigVT, DAG.getNode(NewOpcode, DL, VT,\n                                              Arg.getNode()->ops()));\n\n  return SDValue();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  if (Arg.hasOneUse()) {\n",
        "src_path": "ccfa5257a659cf1f54dd3f8518c8c42218369c41___X86ISelLowering.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/ccfa5257a659cf1f54dd3f8518c8c42218369c41",
        "commit_msg": "[X86] Make sure we don't combine (fneg (fma X, Y, Z)) to a target specific node when there are no FMA instructions.\n\nThis would cause a 'cannot select' error at isel when we should have emitted a lib call and an xor.\n\nFixes PR36553.\n\nllvm-svn: 326393",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/pr36553.ll",
                "patch": "@@ -0,0 +1,20 @@\n+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py\n+; RUN: llc < %s -mtriple=x86_64-apple-darwin10 | FileCheck %s\n+\n+; Make sure we don't crash because we negated an fma when we didn't have any fma instructions.\n+\n+define float @pr36553(float %a, float %b, float %c) nounwind {\n+; CHECK-LABEL: pr36553:\n+; CHECK:       ## %bb.0: ## %entry\n+; CHECK-NEXT:    pushq %rax\n+; CHECK-NEXT:    callq _fmaf\n+; CHECK-NEXT:    xorps {{.*}}(%rip), %xmm0\n+; CHECK-NEXT:    popq %rax\n+; CHECK-NEXT:    retq\n+entry:\n+  %0 = tail call float @llvm.fma.f32(float %a, float %b, float %c)\n+  %sub = fsub float -0.000000e+00, %0\n+  ret float %sub\n+}\n+\n+declare float @llvm.fma.f32(float, float, float)"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/pr36553.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/pr36553.ll\n\n  Unexpected Failures: 1\n"
    },
    "4f799c027e09dafa0d1188509b256f75da3609a5___X86ISelLowering.cpp": {
        "prefix": "SDValue\nX86TargetLowering::LowerMemArgument(SDValue Chain, CallingConv::ID CallConv,\n                                    const SmallVectorImpl<ISD::InputArg> &Ins,\n                                    const SDLoc &dl, SelectionDAG &DAG,\n                                    const CCValAssign &VA,\n                                    MachineFrameInfo &MFI, unsigned i) const {\n  // Create the nodes corresponding to a load from this parameter slot.\n  ISD::ArgFlagsTy Flags = Ins[i].Flags;\n  bool AlwaysUseMutable = shouldGuaranteeTCO(\n      CallConv, DAG.getTarget().Options.GuaranteedTailCallOpt);\n  bool isImmutable = !AlwaysUseMutable && !Flags.isByVal();\n  EVT ValVT;\n  MVT PtrVT = getPointerTy(DAG.getDataLayout());\n\n  // If value is passed by pointer we have address passed instead of the value\n  // itself. No need to extend if the mask value and location share the same\n  // absolute size.\n  bool ExtendedInMem =\n      VA.isExtInLoc() && VA.getValVT().getScalarType() == MVT::i1 &&\n      VA.getValVT().getSizeInBits() != VA.getLocVT().getSizeInBits();\n\n  if (VA.getLocInfo() == CCValAssign::Indirect || ExtendedInMem)\n    ValVT = VA.getLocVT();\n  else\n    ValVT = VA.getValVT();\n\n  // Calculate SP offset of interrupt parameter, re-arrange the slot normally\n  // taken by a return address.\n  int Offset = 0;\n  if (CallConv == CallingConv::X86_INTR) {\n    // X86 interrupts may take one or two arguments.\n    // On the stack there will be no return address as in regular call.\n    // Offset of last argument need to be set to -4/-8 bytes.\n    // Where offset of the first argument out of two, should be set to 0 bytes.\n    Offset = (Subtarget.is64Bit() ? 8 : 4) * ((i + 1) % Ins.size() - 1);\n    if (Subtarget.is64Bit() && Ins.size() == 2) {\n      // The stack pointer needs to be realigned for 64 bit handlers with error\n      // code, so the argument offset changes by 8 bytes.\n      Offset += 8;\n    }\n  }\n\n  // FIXME: For now, all byval parameter objects are marked mutable. This can be\n  // changed with more analysis.\n  // In case of tail call optimization mark all arguments mutable. Since they\n  // could be overwritten by lowering of arguments in case of a tail call.\n  if (Flags.isByVal()) {\n    unsigned Bytes = Flags.getByValSize();\n    if (Bytes == 0) Bytes = 1; // Don't create zero-sized stack objects.\n",
        "suffix": "    // Adjust SP offset of interrupt parameter.\n    if (CallConv == CallingConv::X86_INTR) {\n      MFI.setObjectOffset(FI, Offset);\n    }\n    return DAG.getFrameIndex(FI, PtrVT);\n  }\n\n  // This is an argument in memory. We might be able to perform copy elision.\n  if (Flags.isCopyElisionCandidate()) {\n    EVT ArgVT = Ins[i].ArgVT;\n    SDValue PartAddr;\n    if (Ins[i].PartOffset == 0) {\n      // If this is a one-part value or the first part of a multi-part value,\n      // create a stack object for the entire argument value type and return a\n      // load from our portion of it. This assumes that if the first part of an\n      // argument is in memory, the rest will also be in memory.\n      int FI = MFI.CreateFixedObject(ArgVT.getStoreSize(), VA.getLocMemOffset(),\n                                     /*Immutable=*/false);\n      PartAddr = DAG.getFrameIndex(FI, PtrVT);\n      return DAG.getLoad(\n          ValVT, dl, Chain, PartAddr,\n          MachinePointerInfo::getFixedStack(DAG.getMachineFunction(), FI));\n    } else {\n      // This is not the first piece of an argument in memory. See if there is\n      // already a fixed stack object including this offset. If so, assume it\n      // was created by the PartOffset == 0 branch above and create a load from\n      // the appropriate offset into it.\n      int64_t PartBegin = VA.getLocMemOffset();\n      int64_t PartEnd = PartBegin + ValVT.getSizeInBits() / 8;\n      int FI = MFI.getObjectIndexBegin();\n      for (; MFI.isFixedObjectIndex(FI); ++FI) {\n        int64_t ObjBegin = MFI.getObjectOffset(FI);\n        int64_t ObjEnd = ObjBegin + MFI.getObjectSize(FI);\n        if (ObjBegin <= PartBegin && PartEnd <= ObjEnd)\n          break;\n      }\n      if (MFI.isFixedObjectIndex(FI)) {\n        SDValue Addr =\n            DAG.getNode(ISD::ADD, dl, PtrVT, DAG.getFrameIndex(FI, PtrVT),\n                        DAG.getIntPtrConstant(Ins[i].PartOffset, dl));\n        return DAG.getLoad(\n            ValVT, dl, Chain, Addr,\n            MachinePointerInfo::getFixedStack(DAG.getMachineFunction(), FI,\n                                              Ins[i].PartOffset));\n      }\n    }\n  }\n\n  int FI = MFI.CreateFixedObject(ValVT.getSizeInBits() / 8,\n                                 VA.getLocMemOffset(), isImmutable);\n\n  // Set SExt or ZExt flag.\n  if (VA.getLocInfo() == CCValAssign::ZExt) {\n    MFI.setObjectZExt(FI, true);\n  } else if (VA.getLocInfo() == CCValAssign::SExt) {\n    MFI.setObjectSExt(FI, true);\n  }\n\n  // Adjust SP offset of interrupt parameter.\n  if (CallConv == CallingConv::X86_INTR) {\n    MFI.setObjectOffset(FI, Offset);\n  }\n\n  SDValue FIN = DAG.getFrameIndex(FI, PtrVT);\n  SDValue Val = DAG.getLoad(\n      ValVT, dl, Chain, FIN,\n      MachinePointerInfo::getFixedStack(DAG.getMachineFunction(), FI));\n  return ExtendedInMem\n             ? (VA.getValVT().isVector()\n                    ? DAG.getNode(ISD::SCALAR_TO_VECTOR, dl, VA.getValVT(), Val)\n                    : DAG.getNode(ISD::TRUNCATE, dl, VA.getValVT(), Val))\n             : Val;\n}\n",
        "start": 2793,
        "end": 2915,
        "buggy": "SDValue\nX86TargetLowering::LowerMemArgument(SDValue Chain, CallingConv::ID CallConv,\n                                    const SmallVectorImpl<ISD::InputArg> &Ins,\n                                    const SDLoc &dl, SelectionDAG &DAG,\n                                    const CCValAssign &VA,\n                                    MachineFrameInfo &MFI, unsigned i) const {\n  // Create the nodes corresponding to a load from this parameter slot.\n  ISD::ArgFlagsTy Flags = Ins[i].Flags;\n  bool AlwaysUseMutable = shouldGuaranteeTCO(\n      CallConv, DAG.getTarget().Options.GuaranteedTailCallOpt);\n  bool isImmutable = !AlwaysUseMutable && !Flags.isByVal();\n  EVT ValVT;\n  MVT PtrVT = getPointerTy(DAG.getDataLayout());\n\n  // If value is passed by pointer we have address passed instead of the value\n  // itself. No need to extend if the mask value and location share the same\n  // absolute size.\n  bool ExtendedInMem =\n      VA.isExtInLoc() && VA.getValVT().getScalarType() == MVT::i1 &&\n      VA.getValVT().getSizeInBits() != VA.getLocVT().getSizeInBits();\n\n  if (VA.getLocInfo() == CCValAssign::Indirect || ExtendedInMem)\n    ValVT = VA.getLocVT();\n  else\n    ValVT = VA.getValVT();\n\n  // Calculate SP offset of interrupt parameter, re-arrange the slot normally\n  // taken by a return address.\n  int Offset = 0;\n  if (CallConv == CallingConv::X86_INTR) {\n    // X86 interrupts may take one or two arguments.\n    // On the stack there will be no return address as in regular call.\n    // Offset of last argument need to be set to -4/-8 bytes.\n    // Where offset of the first argument out of two, should be set to 0 bytes.\n    Offset = (Subtarget.is64Bit() ? 8 : 4) * ((i + 1) % Ins.size() - 1);\n    if (Subtarget.is64Bit() && Ins.size() == 2) {\n      // The stack pointer needs to be realigned for 64 bit handlers with error\n      // code, so the argument offset changes by 8 bytes.\n      Offset += 8;\n    }\n  }\n\n  // FIXME: For now, all byval parameter objects are marked mutable. This can be\n  // changed with more analysis.\n  // In case of tail call optimization mark all arguments mutable. Since they\n  // could be overwritten by lowering of arguments in case of a tail call.\n  if (Flags.isByVal()) {\n    unsigned Bytes = Flags.getByValSize();\n    if (Bytes == 0) Bytes = 1; // Don't create zero-sized stack objects.\n    int FI = MFI.CreateFixedObject(Bytes, VA.getLocMemOffset(), isImmutable);\n    // Adjust SP offset of interrupt parameter.\n    if (CallConv == CallingConv::X86_INTR) {\n      MFI.setObjectOffset(FI, Offset);\n    }\n    return DAG.getFrameIndex(FI, PtrVT);\n  }\n\n  // This is an argument in memory. We might be able to perform copy elision.\n  if (Flags.isCopyElisionCandidate()) {\n    EVT ArgVT = Ins[i].ArgVT;\n    SDValue PartAddr;\n    if (Ins[i].PartOffset == 0) {\n      // If this is a one-part value or the first part of a multi-part value,\n      // create a stack object for the entire argument value type and return a\n      // load from our portion of it. This assumes that if the first part of an\n      // argument is in memory, the rest will also be in memory.\n      int FI = MFI.CreateFixedObject(ArgVT.getStoreSize(), VA.getLocMemOffset(),\n                                     /*Immutable=*/false);\n      PartAddr = DAG.getFrameIndex(FI, PtrVT);\n      return DAG.getLoad(\n          ValVT, dl, Chain, PartAddr,\n          MachinePointerInfo::getFixedStack(DAG.getMachineFunction(), FI));\n    } else {\n      // This is not the first piece of an argument in memory. See if there is\n      // already a fixed stack object including this offset. If so, assume it\n      // was created by the PartOffset == 0 branch above and create a load from\n      // the appropriate offset into it.\n      int64_t PartBegin = VA.getLocMemOffset();\n      int64_t PartEnd = PartBegin + ValVT.getSizeInBits() / 8;\n      int FI = MFI.getObjectIndexBegin();\n      for (; MFI.isFixedObjectIndex(FI); ++FI) {\n        int64_t ObjBegin = MFI.getObjectOffset(FI);\n        int64_t ObjEnd = ObjBegin + MFI.getObjectSize(FI);\n        if (ObjBegin <= PartBegin && PartEnd <= ObjEnd)\n          break;\n      }\n      if (MFI.isFixedObjectIndex(FI)) {\n        SDValue Addr =\n            DAG.getNode(ISD::ADD, dl, PtrVT, DAG.getFrameIndex(FI, PtrVT),\n                        DAG.getIntPtrConstant(Ins[i].PartOffset, dl));\n        return DAG.getLoad(\n            ValVT, dl, Chain, Addr,\n            MachinePointerInfo::getFixedStack(DAG.getMachineFunction(), FI,\n                                              Ins[i].PartOffset));\n      }\n    }\n  }\n\n  int FI = MFI.CreateFixedObject(ValVT.getSizeInBits() / 8,\n                                 VA.getLocMemOffset(), isImmutable);\n\n  // Set SExt or ZExt flag.\n  if (VA.getLocInfo() == CCValAssign::ZExt) {\n    MFI.setObjectZExt(FI, true);\n  } else if (VA.getLocInfo() == CCValAssign::SExt) {\n    MFI.setObjectSExt(FI, true);\n  }\n\n  // Adjust SP offset of interrupt parameter.\n  if (CallConv == CallingConv::X86_INTR) {\n    MFI.setObjectOffset(FI, Offset);\n  }\n\n  SDValue FIN = DAG.getFrameIndex(FI, PtrVT);\n  SDValue Val = DAG.getLoad(\n      ValVT, dl, Chain, FIN,\n      MachinePointerInfo::getFixedStack(DAG.getMachineFunction(), FI));\n  return ExtendedInMem\n             ? (VA.getValVT().isVector()\n                    ? DAG.getNode(ISD::SCALAR_TO_VECTOR, dl, VA.getValVT(), Val)\n                    : DAG.getNode(ISD::TRUNCATE, dl, VA.getValVT(), Val))\n             : Val;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    int FI = MFI.CreateFixedObject(Bytes, VA.getLocMemOffset(), isImmutable);\n",
        "src_path": "4f799c027e09dafa0d1188509b256f75da3609a5___X86ISelLowering.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/4f799c027e09dafa0d1188509b256f75da3609a5",
        "commit_msg": "[X86] Mark all byval parameters as aliased\n\nThis is a fix for PR30290: by marking all byval stack slots as being aliased,\nthe instruction scheduler is more conservative about rescheduling memory\naccesses to such stack slots as an LLVM Value* might alias it. This fixes\nerrors such as in the patched test case, where reads and writes to a data\nstructure are illegally mixed.\n\nThis could be fixed better in the future with better analysis for the\ninstruction scheduler to know what Values alias what stack slots.\n\nDifferential Revision: https://reviews.llvm.org/D45022\n\nllvm-svn: 331749",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/pr30290.ll",
                "patch": "@@ -5,10 +5,6 @@\n ; When broken, five \"1\" constants are written into the byval %struct.face,\n ; but the subsequent byval read of that struct (call to bar) gets re-ordered\n ; before those writes, illegally.\n-;\n-; FIXME: the output shown below is the broken output of llc, \"movl $1\" is\n-; scheduled after the copy between byval arguments starts. This will be fixed\n-; with the patch in review D45022.\n source_filename = \"test.c\"\n target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"\n target triple = \"x86_64-pc-linux-gnu\"\n@@ -26,8 +22,8 @@ define void @foo(%struct.face* byval nocapture align 8) local_unnamed_addr {\n ; CHECK-NEXT:    .cfi_def_cfa_offset 48\n ; CHECK-NEXT:    vmovaps {{.*#+}} xmm0 = [1,1,1,1]\n ; CHECK-NEXT:    vmovaps %xmm0, {{[0-9]+}}(%rsp)\n-; CHECK-NEXT:    vmovups {{[0-9]+}}(%rsp), %xmm0\n ; CHECK-NEXT:    movl $1, {{[0-9]+}}(%rsp)\n+; CHECK-NEXT:    vmovups {{[0-9]+}}(%rsp), %xmm0\n ; CHECK-NEXT:    vmovups %xmm0, {{[0-9]+}}(%rsp)\n ; CHECK-NEXT:    vmovaps {{[0-9]+}}(%rsp), %xmm0\n ; CHECK-NEXT:    vmovups %xmm0, (%rsp)"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/pr30290.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/pr30290.ll\n\n  Unexpected Failures: 1\n"
    },
    "16f58d18506bf3c0bf89cf24e3fea88d5a8154dc___SelectionDAG.cpp": {
        "prefix": "void SelectionDAG::ReplaceAllUsesWith(SDNode *From, const SDValue *To) {\n  if (From->getNumValues() == 1)  // Handle the simple case efficiently.\n    return ReplaceAllUsesWith(SDValue(From, 0), To[0]);\n\n  // Preserve Debug Info.\n  for (unsigned i = 0, e = From->getNumValues(); i != e; ++i)\n",
        "suffix": "\n  // Iterate over just the existing users of From. See the comments in\n  // the ReplaceAllUsesWith above.\n  SDNode::use_iterator UI = From->use_begin(), UE = From->use_end();\n  RAUWUpdateListener Listener(*this, UI, UE);\n  while (UI != UE) {\n    SDNode *User = *UI;\n\n    // This node is about to morph, remove its old self from the CSE maps.\n    RemoveNodeFromCSEMaps(User);\n\n    // A user can appear in a use list multiple times, and when this happens the\n    // uses are usually next to each other in the list.  To help reduce the\n    // number of CSE and divergence recomputations, process all the uses of this\n    // user that we can find this way.\n    bool To_IsDivergent = false;\n    do {\n      SDUse &Use = UI.getUse();\n      const SDValue &ToOp = To[Use.getResNo()];\n      ++UI;\n      Use.set(ToOp);\n      To_IsDivergent |= ToOp->isDivergent();\n    } while (UI != UE && *UI == User);\n\n    if (To_IsDivergent != From->isDivergent())\n      updateDivergence(User);\n\n    // Now that we have modified User, add it back to the CSE maps.  If it\n    // already exists there, recursively merge the results together.\n    AddModifiedNodeToCSEMaps(User);\n  }\n\n  // If we just RAUW'd the root, take note.\n  if (From == getRoot().getNode())\n    setRoot(SDValue(To[getRoot().getResNo()]));\n}\n",
        "start": 7794,
        "end": 7836,
        "buggy": "void SelectionDAG::ReplaceAllUsesWith(SDNode *From, const SDValue *To) {\n  if (From->getNumValues() == 1)  // Handle the simple case efficiently.\n    return ReplaceAllUsesWith(SDValue(From, 0), To[0]);\n\n  // Preserve Debug Info.\n  for (unsigned i = 0, e = From->getNumValues(); i != e; ++i)\n    transferDbgValues(SDValue(From, i), *To);\n\n  // Iterate over just the existing users of From. See the comments in\n  // the ReplaceAllUsesWith above.\n  SDNode::use_iterator UI = From->use_begin(), UE = From->use_end();\n  RAUWUpdateListener Listener(*this, UI, UE);\n  while (UI != UE) {\n    SDNode *User = *UI;\n\n    // This node is about to morph, remove its old self from the CSE maps.\n    RemoveNodeFromCSEMaps(User);\n\n    // A user can appear in a use list multiple times, and when this happens the\n    // uses are usually next to each other in the list.  To help reduce the\n    // number of CSE and divergence recomputations, process all the uses of this\n    // user that we can find this way.\n    bool To_IsDivergent = false;\n    do {\n      SDUse &Use = UI.getUse();\n      const SDValue &ToOp = To[Use.getResNo()];\n      ++UI;\n      Use.set(ToOp);\n      To_IsDivergent |= ToOp->isDivergent();\n    } while (UI != UE && *UI == User);\n\n    if (To_IsDivergent != From->isDivergent())\n      updateDivergence(User);\n\n    // Now that we have modified User, add it back to the CSE maps.  If it\n    // already exists there, recursively merge the results together.\n    AddModifiedNodeToCSEMaps(User);\n  }\n\n  // If we just RAUW'd the root, take note.\n  if (From == getRoot().getNode())\n    setRoot(SDValue(To[getRoot().getResNo()]));\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    transferDbgValues(SDValue(From, i), *To);\n",
        "src_path": "16f58d18506bf3c0bf89cf24e3fea88d5a8154dc___SelectionDAG.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/16f58d18506bf3c0bf89cf24e3fea88d5a8154dc",
        "commit_msg": "Fix debug info for SelectionDAG legalization of DAG nodes with two results.\n\nThis patch fixes the debug info handling for SelectionDAG legalization\nof DAG nodes with two results. When an replaced SDNode has more than\none result, transferDbgValues was always copying the SDDbgValue from\nthe first result and attaching them to all members. In reality\nSelectionDAG::ReplaceAllUsesWith() is given an array of SDNodes\n(though the type signature doesn't make this obvious (cf. the call\nsite code in ReplaceNode()).\n\nrdar://problem/44162227\n\nDifferential Revision: https://reviews.llvm.org/D52112\n\nllvm-svn: 342264",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/X86/sdag-legalize-multires.ll",
                "patch": "@@ -0,0 +1,47 @@\n+; RUN: llc -O0 %s -stop-after=livedebugvars -o - | FileCheck %s\n+; This is a hand-crafted example modified after some Swift compiler output.\n+; Test that SelectionDAG legalization of DAG nodes with two results\n+; transfers debug info correctly.\n+\n+source_filename = \"/tmp/sincos.ll\"\n+target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"\n+target triple = \"x86_64-apple-macosx10.13.0\"\n+\n+declare float @llvm.cos.f32(float)\n+declare float @llvm.sin.f32(float)\n+declare void @llvm.dbg.value(metadata, metadata, metadata)\n+declare swiftcc void @g(float, float)\n+\n+; CHECK: ![[RCOS:.*]] = !DILocalVariable(name: \"rcos\"\n+; CHECK: ![[RSIN:.*]] = !DILocalVariable(name: \"rsin\"\n+\n+define hidden swiftcc void @f() #0 !dbg !8 {\n+entry:\n+  ; CHECK: CALL64pcrel32 &__sincosf_stret\n+  %0 = call float @llvm.cos.f32(float 1.500000e+00), !dbg !13\n+  ; CHECK: $xmm1 = MOVAPSrr $xmm0\n+  call void @llvm.dbg.value(metadata float %0, metadata !15, metadata !DIExpression()), !dbg !13\n+  ; CHECK: DBG_VALUE debug-use {{.*}}$xmm1, {{.*}}, ![[RSIN]], !DIExpression(),\n+  %1 = call float @llvm.sin.f32(float 1.500000e+00), !dbg !13\n+  call void @llvm.dbg.value(metadata float %1, metadata !11, metadata !DIExpression()), !dbg !13\n+  ; CHECK: DBG_VALUE debug-use {{.*}}$xmm0, {{.*}}, ![[RCOS]], !DIExpression(),\n+  call void @g(float %0, float %1), !dbg !13\n+  ret void, !dbg !13\n+}\n+\n+attributes #0 = { noinline nounwind optnone ssp uwtable \"target-features\"=\"+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87\" }\n+\n+!llvm.dbg.cu = !{!0}\n+!llvm.module.flags = !{!3, !4}\n+\n+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, emissionKind: FullDebug)\n+!1 = !DIFile(filename: \"sincos.ll\", directory: \"/\")\n+!3 = !{i32 2, !\"Dwarf Version\", i32 4}\n+!4 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!8 = distinct !DISubprogram(name: \"f\", scope: !1, file: !1, line: 2, type: !9, isLocal: false, isDefinition: true, scopeLine: 2, isOptimized: false, unit: !0)\n+!9 = !DISubroutineType(types: !10)\n+!10 = !{null}\n+!11 = !DILocalVariable(name: \"rsin\", scope: !8, file: !1, line: 3, type: !12)\n+!12 = !DIBasicType(name: \"float\", size: 32, encoding: DW_ATE_float)\n+!13 = !DILocation(line: 3, scope: !8)\n+!15 = !DILocalVariable(name: \"rcos\", scope: !8, file: !1, line: 4, type: !12)"
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/X86/sdag-legalize-multires.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/sdag-legalize-multires.ll\n\n  Unexpected Failures: 1\n"
    },
    "e62fc3d0b6ce923dcbc29eeb6ebc5808e6724f90___SimplifyLibCalls.cpp": {
        "prefix": "static bool canTransformToMemCmp(CallInst *CI, Value *Str, uint64_t Len,\n                                 const DataLayout &DL) {\n  if (!isOnlyUsedInComparisonWithZero(CI))\n    return false;\n\n  if (!isDereferenceableAndAlignedPointer(Str, 1, APInt(64, Len), DL))\n    return false;\n",
        "suffix": "  return true;\n}\n",
        "start": 167,
        "end": 176,
        "buggy": "static bool canTransformToMemCmp(CallInst *CI, Value *Str, uint64_t Len,\n                                 const DataLayout &DL) {\n  if (!isOnlyUsedInComparisonWithZero(CI))\n    return false;\n\n  if (!isDereferenceableAndAlignedPointer(Str, 1, APInt(64, Len), DL))\n    return false;\n    \n  return true;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    \n",
        "src_path": "e62fc3d0b6ce923dcbc29eeb6ebc5808e6724f90___SimplifyLibCalls.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/e62fc3d0b6ce923dcbc29eeb6ebc5808e6724f90",
        "commit_msg": "[InstCombine] Disable strcmp->memcmp transform for MSan.\n\nSummary:\nThe strcmp->memcmp transform can make the resulting memcmp read\nuninitialized data, which MSan doesn't like.\n\nResolves https://github.com/google/sanitizers/issues/993.\n\nReviewers: eugenis, xbolva00\n\nReviewed By: eugenis\n\nSubscribers: hiraditya, llvm-commits\n\nDifferential Revision: https://reviews.llvm.org/D52272\n\nllvm-svn: 342582",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/strcmp-memcmp.ll",
                "patch": "@@ -542,4 +542,19 @@ define i32 @strncmp_memcmp_bad4([4 x i8]* dereferenceable (4) %buf) {\n   ret i32 0\n }\n \n+define i32 @strcmp_memcmp_msan([12 x i8]* dereferenceable (12) %buf) sanitize_memory {\n+; CHECK-LABEL: @strcmp_memcmp_msan(\n+; CHECK-NEXT:    [[STRING:%.*]] = getelementptr inbounds [12 x i8], [12 x i8]* [[BUF:%.*]], i64 0, i64 0\n+; CHECK-NEXT:    [[CALL:%.*]] = call i32 @strcmp(i8* nonnull [[STRING]], i8* getelementptr inbounds ([4 x i8], [4 x i8]* @key, i64 0, i64 0))\n+; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[CALL]], 0\n+; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32\n+; CHECK-NEXT:    ret i32 [[CONV]]\n+;\n+  %string = getelementptr inbounds [12 x i8], [12 x i8]* %buf, i64 0, i64 0\n+  %call = call i32 @strcmp(i8* nonnull %string, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @key, i64 0, i64 0))\n+  %cmp = icmp eq i32 %call, 0\n+  %conv = zext i1 %cmp to i32\n+  ret i32 %conv\n+}\n+\n declare i32 @memcmp(i8* nocapture, i8* nocapture, i64)"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/strcmp-memcmp.ll (1 of 1)\nTesting Time: 1.25s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/strcmp-memcmp.ll\n\n  Unexpected Failures: 1\n"
    },
    "69bfa402006fa7fabe6eaf1660c9ecacb763a966___MachineBasicBlock.cpp": {
        "prefix": "void MachineBasicBlock::print(raw_ostream &OS, ModuleSlotTracker &MST,\n                              const SlotIndexes *Indexes,\n                              bool IsStandalone) const {\n  const MachineFunction *MF = getParent();\n  if (!MF) {\n    OS << \"Can't print out MachineBasicBlock because parent MachineFunction\"\n       << \" is null\\n\";\n    return;\n  }\n\n  if (Indexes)\n    OS << Indexes->getMBBStartIdx(this) << '\\t';\n\n  OS << \"bb.\" << getNumber();\n  bool HasAttributes = false;\n  if (const auto *BB = getBasicBlock()) {\n    if (BB->hasName()) {\n      OS << \".\" << BB->getName();\n    } else {\n      HasAttributes = true;\n      OS << \" (\";\n      int Slot = MST.getLocalSlot(BB);\n      if (Slot == -1)\n        OS << \"<ir-block badref>\";\n      else\n        OS << (Twine(\"%ir-block.\") + Twine(Slot)).str();\n    }\n  }\n\n  if (hasAddressTaken()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"address-taken\";\n    HasAttributes = true;\n  }\n  if (isEHPad()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"landing-pad\";\n    HasAttributes = true;\n  }\n  if (getAlignment()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"align \" << getAlignment();\n    HasAttributes = true;\n  }\n  if (HasAttributes)\n    OS << \")\";\n  OS << \":\\n\";\n\n  const TargetRegisterInfo *TRI = MF->getSubtarget().getRegisterInfo();\n  const MachineRegisterInfo &MRI = MF->getRegInfo();\n  const TargetInstrInfo &TII = *getParent()->getSubtarget().getInstrInfo();\n  bool HasLineAttributes = false;\n\n  // Print the preds of this block according to the CFG.\n  if (!pred_empty() && IsStandalone) {\n    if (Indexes) OS << '\\t';\n    // Don't indent(2), align with previous line attributes.\n    OS << \"; predecessors: \";\n    for (auto I = pred_begin(), E = pred_end(); I != E; ++I) {\n      if (I != pred_begin())\n        OS << \", \";\n      OS << printMBBReference(**I);\n    }\n    OS << '\\n';\n    HasLineAttributes = true;\n  }\n\n  if (!succ_empty()) {\n    if (Indexes) OS << '\\t';\n    // Print the successors\n    OS.indent(2) << \"successors: \";\n    for (auto I = succ_begin(), E = succ_end(); I != E; ++I) {\n      if (I != succ_begin())\n        OS << \", \";\n      OS << printMBBReference(**I);\n      if (!Probs.empty())\n        OS << '('\n           << format(\"0x%08\" PRIx32, getSuccProbability(I).getNumerator())\n           << ')';\n    }\n    if (!Probs.empty() && IsStandalone) {\n      // Print human readable probabilities as comments.\n      OS << \"; \";\n      for (auto I = succ_begin(), E = succ_end(); I != E; ++I) {\n",
        "suffix": "        if (I != succ_begin())\n          OS << \", \";\n        OS << printMBBReference(**I) << '('\n           << format(\"%.2f%%\",\n                     rint(((double)BP.getNumerator() / BP.getDenominator()) *\n                          100.0 * 100.0) /\n                         100.0)\n           << ')';\n      }\n    }\n\n    OS << '\\n';\n    HasLineAttributes = true;\n  }\n\n  if (!livein_empty() && MRI.tracksLiveness()) {\n    if (Indexes) OS << '\\t';\n    OS.indent(2) << \"liveins: \";\n\n    bool First = true;\n    for (const auto &LI : liveins()) {\n      if (!First)\n        OS << \", \";\n      First = false;\n      OS << printReg(LI.PhysReg, TRI);\n      if (!LI.LaneMask.all())\n        OS << \":0x\" << PrintLaneMask(LI.LaneMask);\n    }\n    HasLineAttributes = true;\n  }\n\n  if (HasLineAttributes)\n    OS << '\\n';\n\n  bool IsInBundle = false;\n  for (const MachineInstr &MI : instrs()) {\n    if (Indexes) {\n      if (Indexes->hasIndex(MI))\n        OS << Indexes->getInstructionIndex(MI);\n      OS << '\\t';\n    }\n\n    if (IsInBundle && !MI.isInsideBundle()) {\n      OS.indent(2) << \"}\\n\";\n      IsInBundle = false;\n    }\n\n    OS.indent(IsInBundle ? 4 : 2);\n    MI.print(OS, MST, IsStandalone, /*SkipOpers=*/false, /*SkipDebugLoc=*/false,\n             /*AddNewLine=*/false, &TII);\n\n    if (!IsInBundle && MI.getFlag(MachineInstr::BundledSucc)) {\n      OS << \" {\";\n      IsInBundle = true;\n    }\n    OS << '\\n';\n  }\n\n  if (IsInBundle)\n    OS.indent(2) << \"}\\n\";\n\n  if (IrrLoopHeaderWeight && IsStandalone) {\n    if (Indexes) OS << '\\t';\n    OS.indent(2) << \"; Irreducible loop header weight: \"\n                 << IrrLoopHeaderWeight.getValue() << '\\n';\n  }\n}\n",
        "start": 281,
        "end": 432,
        "buggy": "void MachineBasicBlock::print(raw_ostream &OS, ModuleSlotTracker &MST,\n                              const SlotIndexes *Indexes,\n                              bool IsStandalone) const {\n  const MachineFunction *MF = getParent();\n  if (!MF) {\n    OS << \"Can't print out MachineBasicBlock because parent MachineFunction\"\n       << \" is null\\n\";\n    return;\n  }\n\n  if (Indexes)\n    OS << Indexes->getMBBStartIdx(this) << '\\t';\n\n  OS << \"bb.\" << getNumber();\n  bool HasAttributes = false;\n  if (const auto *BB = getBasicBlock()) {\n    if (BB->hasName()) {\n      OS << \".\" << BB->getName();\n    } else {\n      HasAttributes = true;\n      OS << \" (\";\n      int Slot = MST.getLocalSlot(BB);\n      if (Slot == -1)\n        OS << \"<ir-block badref>\";\n      else\n        OS << (Twine(\"%ir-block.\") + Twine(Slot)).str();\n    }\n  }\n\n  if (hasAddressTaken()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"address-taken\";\n    HasAttributes = true;\n  }\n  if (isEHPad()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"landing-pad\";\n    HasAttributes = true;\n  }\n  if (getAlignment()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"align \" << getAlignment();\n    HasAttributes = true;\n  }\n  if (HasAttributes)\n    OS << \")\";\n  OS << \":\\n\";\n\n  const TargetRegisterInfo *TRI = MF->getSubtarget().getRegisterInfo();\n  const MachineRegisterInfo &MRI = MF->getRegInfo();\n  const TargetInstrInfo &TII = *getParent()->getSubtarget().getInstrInfo();\n  bool HasLineAttributes = false;\n\n  // Print the preds of this block according to the CFG.\n  if (!pred_empty() && IsStandalone) {\n    if (Indexes) OS << '\\t';\n    // Don't indent(2), align with previous line attributes.\n    OS << \"; predecessors: \";\n    for (auto I = pred_begin(), E = pred_end(); I != E; ++I) {\n      if (I != pred_begin())\n        OS << \", \";\n      OS << printMBBReference(**I);\n    }\n    OS << '\\n';\n    HasLineAttributes = true;\n  }\n\n  if (!succ_empty()) {\n    if (Indexes) OS << '\\t';\n    // Print the successors\n    OS.indent(2) << \"successors: \";\n    for (auto I = succ_begin(), E = succ_end(); I != E; ++I) {\n      if (I != succ_begin())\n        OS << \", \";\n      OS << printMBBReference(**I);\n      if (!Probs.empty())\n        OS << '('\n           << format(\"0x%08\" PRIx32, getSuccProbability(I).getNumerator())\n           << ')';\n    }\n    if (!Probs.empty() && IsStandalone) {\n      // Print human readable probabilities as comments.\n      OS << \"; \";\n      for (auto I = succ_begin(), E = succ_end(); I != E; ++I) {\n        const BranchProbability &BP = *getProbabilityIterator(I);\n        if (I != succ_begin())\n          OS << \", \";\n        OS << printMBBReference(**I) << '('\n           << format(\"%.2f%%\",\n                     rint(((double)BP.getNumerator() / BP.getDenominator()) *\n                          100.0 * 100.0) /\n                         100.0)\n           << ')';\n      }\n    }\n\n    OS << '\\n';\n    HasLineAttributes = true;\n  }\n\n  if (!livein_empty() && MRI.tracksLiveness()) {\n    if (Indexes) OS << '\\t';\n    OS.indent(2) << \"liveins: \";\n\n    bool First = true;\n    for (const auto &LI : liveins()) {\n      if (!First)\n        OS << \", \";\n      First = false;\n      OS << printReg(LI.PhysReg, TRI);\n      if (!LI.LaneMask.all())\n        OS << \":0x\" << PrintLaneMask(LI.LaneMask);\n    }\n    HasLineAttributes = true;\n  }\n\n  if (HasLineAttributes)\n    OS << '\\n';\n\n  bool IsInBundle = false;\n  for (const MachineInstr &MI : instrs()) {\n    if (Indexes) {\n      if (Indexes->hasIndex(MI))\n        OS << Indexes->getInstructionIndex(MI);\n      OS << '\\t';\n    }\n\n    if (IsInBundle && !MI.isInsideBundle()) {\n      OS.indent(2) << \"}\\n\";\n      IsInBundle = false;\n    }\n\n    OS.indent(IsInBundle ? 4 : 2);\n    MI.print(OS, MST, IsStandalone, /*SkipOpers=*/false, /*SkipDebugLoc=*/false,\n             /*AddNewLine=*/false, &TII);\n\n    if (!IsInBundle && MI.getFlag(MachineInstr::BundledSucc)) {\n      OS << \" {\";\n      IsInBundle = true;\n    }\n    OS << '\\n';\n  }\n\n  if (IsInBundle)\n    OS.indent(2) << \"}\\n\";\n\n  if (IrrLoopHeaderWeight && IsStandalone) {\n    if (Indexes) OS << '\\t';\n    OS.indent(2) << \"; Irreducible loop header weight: \"\n                 << IrrLoopHeaderWeight.getValue() << '\\n';\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        const BranchProbability &BP = *getProbabilityIterator(I);\n",
        "src_path": "69bfa402006fa7fabe6eaf1660c9ecacb763a966___MachineBasicBlock.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/69bfa402006fa7fabe6eaf1660c9ecacb763a966",
        "commit_msg": "[CodeGen] fix broken successor probability in MBB dump\n\nWhen printing successor probabilities for a MBB, a human readable value is sometimes shown as 200.0%.\nThe human readable output is based on getProbabilityIterator, which returns 0xFFFFFFFF for getNumerator() and 0x80000000 for getDenominator() for unknown BranchProbability.\nBy using getSuccProbability as we do for the non-human readable part, we can avoid this problem.\n\nDifferential Revision: https://reviews.llvm.org/D52605\n\nllvm-svn: 343297",
        "test_func_diff": [
            {
                "fn": "llvm/test/Other/X86/mbb-dump.ll",
                "patch": "@@ -0,0 +1,25 @@\n+; RUN: llc < %s 2>&1 -print-after=machine-scheduler -mtriple=x86_64-unknown-unknown | FileCheck %s\n+\n+; expected MBB dump output\n+; # *** IR Dump After Machine Instruction Scheduler ***:\n+; # Machine code for function foo: NoPHIs, TracksLiveness\n+; \n+; 0B\tbb.0 (%ir-block.0):\n+; \t  successors: %bb.1(0x80000000); %bb.1(100.00%)\n+; \n+; 16B\tbb.1.next:\n+; \t; predecessors: %bb.0\n+\n+; previously, it was broken as\n+; \t  successors: %bb.1(0x80000000); %bb.1(200.00%)\n+\n+define void @foo(){\n+; CHECK: IR Dump After Machine Instruction Scheduler\n+; CHECK: bb.0\n+; CHECK: 100.0\n+; CHECK: bb.1\n+  br label %next\n+\n+next:\n+  ret void\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Other/X86/mbb-dump.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: Other/X86/mbb-dump.ll\n\n  Unexpected Failures: 1\n"
    },
    "6934202dc04ffa5ff336a1cca9ace8dae44c29d4___MachineLICM.cpp": {
        "prefix": "void MachineLICMBase::ProcessMI(MachineInstr *MI,\n                                BitVector &PhysRegDefs,\n                                BitVector &PhysRegClobbers,\n                                SmallSet<int, 32> &StoredFIs,\n                                SmallVectorImpl<CandidateInfo> &Candidates) {\n  bool RuledOut = false;\n  bool HasNonInvariantUse = false;\n  unsigned Def = 0;\n  for (const MachineOperand &MO : MI->operands()) {\n    if (MO.isFI()) {\n      // Remember if the instruction stores to the frame index.\n      int FI = MO.getIndex();\n      if (!StoredFIs.count(FI) &&\n          MFI->isSpillSlotObjectIndex(FI) &&\n          InstructionStoresToFI(MI, FI))\n        StoredFIs.insert(FI);\n      HasNonInvariantUse = true;\n      continue;\n    }\n\n    // We can't hoist an instruction defining a physreg that is clobbered in\n    // the loop.\n    if (MO.isRegMask()) {\n      PhysRegClobbers.setBitsNotInMask(MO.getRegMask());\n      continue;\n    }\n\n    if (!MO.isReg())\n      continue;\n    unsigned Reg = MO.getReg();\n    if (!Reg)\n      continue;\n    assert(TargetRegisterInfo::isPhysicalRegister(Reg) &&\n           \"Not expecting virtual register!\");\n\n    if (!MO.isDef()) {\n      if (Reg && (PhysRegDefs.test(Reg) || PhysRegClobbers.test(Reg)))\n        // If it's using a non-loop-invariant register, then it's obviously not\n        // safe to hoist.\n        HasNonInvariantUse = true;\n      continue;\n    }\n\n    if (MO.isImplicit()) {\n      for (MCRegAliasIterator AI(Reg, TRI, true); AI.isValid(); ++AI)\n        PhysRegClobbers.set(*AI);\n      if (!MO.isDead())\n        // Non-dead implicit def? This cannot be hoisted.\n        RuledOut = true;\n      // No need to check if a dead implicit def is also defined by\n      // another instruction.\n      continue;\n    }\n\n    // FIXME: For now, avoid instructions with multiple defs, unless\n    // it's a dead implicit def.\n    if (Def)\n      RuledOut = true;\n    else\n      Def = Reg;\n\n    // If we have already seen another instruction that defines the same\n    // register, then this is not safe.  Two defs is indicated by setting a\n    // PhysRegClobbers bit.\n    for (MCRegAliasIterator AS(Reg, TRI, true); AS.isValid(); ++AS) {\n      if (PhysRegDefs.test(*AS))\n        PhysRegClobbers.set(*AS);\n",
        "suffix": "    }\n    if (PhysRegClobbers.test(Reg))\n      // MI defined register is seen defined by another instruction in\n      // the loop, it cannot be a LICM candidate.\n      RuledOut = true;\n  }\n\n  // Only consider reloads for now and remats which do not have register\n  // operands. FIXME: Consider unfold load folding instructions.\n  if (Def && !RuledOut) {\n    int FI = std::numeric_limits<int>::min();\n    if ((!HasNonInvariantUse && IsLICMCandidate(*MI)) ||\n        (TII->isLoadFromStackSlot(*MI, FI) && MFI->isSpillSlotObjectIndex(FI)))\n      Candidates.push_back(CandidateInfo(MI, Def, FI));\n  }\n}\n",
        "start": 399,
        "end": 482,
        "buggy": "void MachineLICMBase::ProcessMI(MachineInstr *MI,\n                                BitVector &PhysRegDefs,\n                                BitVector &PhysRegClobbers,\n                                SmallSet<int, 32> &StoredFIs,\n                                SmallVectorImpl<CandidateInfo> &Candidates) {\n  bool RuledOut = false;\n  bool HasNonInvariantUse = false;\n  unsigned Def = 0;\n  for (const MachineOperand &MO : MI->operands()) {\n    if (MO.isFI()) {\n      // Remember if the instruction stores to the frame index.\n      int FI = MO.getIndex();\n      if (!StoredFIs.count(FI) &&\n          MFI->isSpillSlotObjectIndex(FI) &&\n          InstructionStoresToFI(MI, FI))\n        StoredFIs.insert(FI);\n      HasNonInvariantUse = true;\n      continue;\n    }\n\n    // We can't hoist an instruction defining a physreg that is clobbered in\n    // the loop.\n    if (MO.isRegMask()) {\n      PhysRegClobbers.setBitsNotInMask(MO.getRegMask());\n      continue;\n    }\n\n    if (!MO.isReg())\n      continue;\n    unsigned Reg = MO.getReg();\n    if (!Reg)\n      continue;\n    assert(TargetRegisterInfo::isPhysicalRegister(Reg) &&\n           \"Not expecting virtual register!\");\n\n    if (!MO.isDef()) {\n      if (Reg && (PhysRegDefs.test(Reg) || PhysRegClobbers.test(Reg)))\n        // If it's using a non-loop-invariant register, then it's obviously not\n        // safe to hoist.\n        HasNonInvariantUse = true;\n      continue;\n    }\n\n    if (MO.isImplicit()) {\n      for (MCRegAliasIterator AI(Reg, TRI, true); AI.isValid(); ++AI)\n        PhysRegClobbers.set(*AI);\n      if (!MO.isDead())\n        // Non-dead implicit def? This cannot be hoisted.\n        RuledOut = true;\n      // No need to check if a dead implicit def is also defined by\n      // another instruction.\n      continue;\n    }\n\n    // FIXME: For now, avoid instructions with multiple defs, unless\n    // it's a dead implicit def.\n    if (Def)\n      RuledOut = true;\n    else\n      Def = Reg;\n\n    // If we have already seen another instruction that defines the same\n    // register, then this is not safe.  Two defs is indicated by setting a\n    // PhysRegClobbers bit.\n    for (MCRegAliasIterator AS(Reg, TRI, true); AS.isValid(); ++AS) {\n      if (PhysRegDefs.test(*AS))\n        PhysRegClobbers.set(*AS);\n      PhysRegDefs.set(*AS);\n    }\n    if (PhysRegClobbers.test(Reg))\n      // MI defined register is seen defined by another instruction in\n      // the loop, it cannot be a LICM candidate.\n      RuledOut = true;\n  }\n\n  // Only consider reloads for now and remats which do not have register\n  // operands. FIXME: Consider unfold load folding instructions.\n  if (Def && !RuledOut) {\n    int FI = std::numeric_limits<int>::min();\n    if ((!HasNonInvariantUse && IsLICMCandidate(*MI)) ||\n        (TII->isLoadFromStackSlot(*MI, FI) && MFI->isSpillSlotObjectIndex(FI)))\n      Candidates.push_back(CandidateInfo(MI, Def, FI));\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      PhysRegDefs.set(*AS);\n",
        "src_path": "6934202dc04ffa5ff336a1cca9ace8dae44c29d4___MachineLICM.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/6934202dc04ffa5ff336a1cca9ace8dae44c29d4",
        "commit_msg": "[MachineLICM][X86][AMDGPU] Fix subtle bug in the updating of PhysRegClobbers in post-RA LICM\n\nIt looks like MCRegAliasIterator can visit the same physical register twice. When this happens in this code in LICM we end up setting the PhysRegDef and then later in the same loop visit the register again. Now we see that PhysRegDef is set from the earlier iteration so now set PhysRegClobber.\n\nThis patch splits the loop so we have one that uses the previous value of PhysRegDef to update PhysRegClobber and second loop that updates PhysRegDef.\n\nThe X86 atomic test is an improvement. I had to add sideeffect to the two shrink wrapping tests to prevent hoisting from occurring. I'm not sure about the AMDGPU tests. It looks like the branch instruction changed at end the of the loops. And in the branch-relaxation test I think there is now \"and vcc, exec, -1\" instruction that wasn't there before.\n\nDifferential Revision: https://reviews.llvm.org/D55102\n\nllvm-svn: 348330",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/AMDGPU/branch-relaxation.ll",
                "patch": "@@ -444,7 +444,7 @@ endif:\n ; GCN-NEXT: s_xor_b64 exec, exec, [[TEMP_MASK1]]\n ; GCN-NEXT: ; mask branch [[RET:BB[0-9]+_[0-9]+]]\n \n-; GCN: [[LOOP_BODY:BB[0-9]+_[0-9]+]]: ; %loop\n+; GCN: [[LOOP_BODY:BB[0-9]+_[0-9]+]]: ; %loop{{$}}\n ; GCN: ;;#ASMSTART\n ; GCN: v_nop_e64\n ; GCN: v_nop_e64\n@@ -453,7 +453,7 @@ endif:\n ; GCN: v_nop_e64\n ; GCN: v_nop_e64\n ; GCN: ;;#ASMEND\n-; GCN: s_cbranch_execz [[RET]]\n+; GCN: s_cbranch_vccz [[RET]]\n \n ; GCN-NEXT: [[LONGBB:BB[0-9]+_[0-9]+]]: ; %loop\n ; GCN-NEXT: ; in Loop: Header=[[LOOP_BODY]] Depth=1"
            },
            {
                "fn": "llvm/test/CodeGen/AMDGPU/infinite-loop.ll",
                "patch": "@@ -32,11 +32,11 @@ loop:\n ; SI: s_cbranch_execz [[RET:BB[0-9]+_[0-9]+]]\n \n ; SI: v_mov_b32_e32 [[REG:v[0-9]+]], 0x3e7\n-; SI: [[LOOP:BB[0-9]+_[0-9]+]]:  ; %loop\n ; SI: s_and_b64 vcc, exec, -1\n+; SI: [[LOOP:BB[0-9]+_[0-9]+]]:  ; %loop\n ; SI: s_waitcnt lgkmcnt(0)\n ; SI: buffer_store_dword [[REG]]\n-; SI: s_cbranch_execnz [[LOOP]]\n+; SI: s_cbranch_vccnz [[LOOP]]\n \n ; SI: [[RET]]:  ; %UnifiedReturnBlock\n ; SI: s_endpgm"
            },
            {
                "fn": "llvm/test/CodeGen/X86/atomic_mi.ll",
                "patch": "@@ -93,11 +93,11 @@ define void @store_atomic_imm_64(i64* %p) {\n ; X32-NEXT:    movl {{[0-9]+}}(%esp), %esi\n ; X32-NEXT:    movl (%esi), %eax\n ; X32-NEXT:    movl 4(%esi), %edx\n+; X32-NEXT:    xorl %ecx, %ecx\n+; X32-NEXT:    movl $42, %ebx\n ; X32-NEXT:    .p2align 4, 0x90\n ; X32-NEXT:  .LBB3_1: # %atomicrmw.start\n ; X32-NEXT:    # =>This Inner Loop Header: Depth=1\n-; X32-NEXT:    xorl %ecx, %ecx\n-; X32-NEXT:    movl $42, %ebx\n ; X32-NEXT:    lock cmpxchg8b (%esi)\n ; X32-NEXT:    jne .LBB3_1\n ; X32-NEXT:  # %bb.2: # %atomicrmw.end\n@@ -132,11 +132,11 @@ define void @store_atomic_imm_64_big(i64* %p) {\n ; X32-NEXT:    movl {{[0-9]+}}(%esp), %esi\n ; X32-NEXT:    movl (%esi), %eax\n ; X32-NEXT:    movl 4(%esi), %edx\n+; X32-NEXT:    movl $23, %ecx\n+; X32-NEXT:    movl $1215752192, %ebx # imm = 0x4876E800\n ; X32-NEXT:    .p2align 4, 0x90\n ; X32-NEXT:  .LBB4_1: # %atomicrmw.start\n ; X32-NEXT:    # =>This Inner Loop Header: Depth=1\n-; X32-NEXT:    movl $23, %ecx\n-; X32-NEXT:    movl $1215752192, %ebx # imm = 0x4876E800\n ; X32-NEXT:    lock cmpxchg8b (%esi)\n ; X32-NEXT:    jne .LBB4_1\n ; X32-NEXT:  # %bb.2: # %atomicrmw.end\n@@ -753,10 +753,10 @@ define void @and_64i(i64* %p) {\n ; X32-NEXT:    andl $2, %ebx\n ; X32-NEXT:    movl (%esi), %eax\n ; X32-NEXT:    movl 4(%esi), %edx\n+; X32-NEXT:    xorl %ecx, %ecx\n ; X32-NEXT:    .p2align 4, 0x90\n ; X32-NEXT:  .LBB31_1: # %atomicrmw.start\n ; X32-NEXT:    # =>This Inner Loop Header: Depth=1\n-; X32-NEXT:    xorl %ecx, %ecx\n ; X32-NEXT:    lock cmpxchg8b (%esi)\n ; X32-NEXT:    jne .LBB31_1\n ; X32-NEXT:  # %bb.2: # %atomicrmw.end"
            },
            {
                "fn": "llvm/test/CodeGen/X86/x86-shrink-wrapping.ll",
                "patch": "@@ -126,7 +126,7 @@ for.preheader:\n for.body:                                         ; preds = %entry, %for.body\n   %i.05 = phi i32 [ %inc, %for.body ], [ 0, %for.preheader ]\n   %sum.04 = phi i32 [ %add, %for.body ], [ 0, %for.preheader ]\n-  %call = tail call i32 asm \"movl $$1, $0\", \"=r,~{ebx}\"()\n+  %call = tail call i32 asm sideeffect \"movl $$1, $0\", \"=r,~{ebx}\"()\n   %add = add nsw i32 %call, %sum.04\n   %inc = add nuw nsw i32 %i.05, 1\n   %exitcond = icmp eq i32 %inc, 10\n@@ -178,7 +178,7 @@ for.preheader:\n for.body:                                         ; preds = %for.body, %entry\n   %i.04 = phi i32 [ 0, %for.preheader ], [ %inc, %for.body ]\n   %sum.03 = phi i32 [ 0, %for.preheader ], [ %add, %for.body ]\n-  %call = tail call i32 asm \"movl $$1, $0\", \"=r,~{ebx}\"()\n+  %call = tail call i32 asm sideeffect \"movl $$1, $0\", \"=r,~{ebx}\"()\n   %add = add nsw i32 %call, %sum.03\n   %inc = add nuw nsw i32 %i.04, 1\n   %exitcond = icmp eq i32 %inc, 10\n@@ -248,7 +248,7 @@ for.preheader:\n for.body:                                         ; preds = %entry, %for.body\n   %i.05 = phi i32 [ %inc, %for.body ], [ 0, %for.preheader ]\n   %sum.04 = phi i32 [ %add, %for.body ], [ 0, %for.preheader ]\n-  %call = tail call i32 asm \"movl $$1, $0\", \"=r,~{ebx}\"()\n+  %call = tail call i32 asm sideeffect \"movl $$1, $0\", \"=r,~{ebx}\"()\n   %add = add nsw i32 %call, %sum.04\n   %inc = add nuw nsw i32 %i.05, 1\n   %exitcond = icmp eq i32 %inc, 10\n@@ -324,7 +324,7 @@ if.then:                                          ; preds = %entry\n for.body:                                         ; preds = %for.body, %if.then\n   %i.05 = phi i32 [ 0, %if.then ], [ %inc, %for.body ]\n   %sum.04 = phi i32 [ 0, %if.then ], [ %add, %for.body ]\n-  %call = tail call i32 asm \"movl $$1, $0\", \"=r,~{ebx}\"()\n+  %call = tail call i32 asm sideeffect \"movl $$1, $0\", \"=r,~{ebx}\"()\n   %add = add nsw i32 %call, %sum.04\n   %inc = add nuw nsw i32 %i.05, 1\n   %exitcond = icmp eq i32 %inc, 10"
            },
            {
                "fn": "llvm/test/CodeGen/X86/x86-win64-shrink-wrapping.ll",
                "patch": "@@ -100,7 +100,7 @@ for.preheader:                                    ; preds = %entry\n for.body:                                         ; preds = %for.body, %for.preheader\n   %i.05 = phi i32 [ %inc, %for.body ], [ 0, %for.preheader ]\n   %sum.04 = phi i32 [ %add, %for.body ], [ 0, %for.preheader ]\n-  %call = tail call i32 asm \"movl $$1, $0\", \"=r,~{ebx}\"()\n+  %call = tail call i32 asm sideeffect \"movl $$1, $0\", \"=r,~{ebx}\"()\n   %add = add nsw i32 %call, %sum.04\n   %inc = add nuw nsw i32 %i.05, 1\n   %exitcond = icmp eq i32 %inc, 10"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/atomic_mi.ll (1 of 1)\nTesting Time: 4.19s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/atomic_mi.ll\n\n  Unexpected Failures: 1\n"
    },
    "e79477895e1af4425aecaded2881e3b3c878faf5___X86AvoidStoreForwardingBlocks.cpp": {
        "prefix": "void X86AvoidSFBPass::breakBlockedCopies(\n    MachineInstr *LoadInst, MachineInstr *StoreInst,\n    const DisplacementSizeMap &BlockingStoresDispSizeMap) {\n  int64_t LdDispImm = getDispOperand(LoadInst).getImm();\n  int64_t StDispImm = getDispOperand(StoreInst).getImm();\n  int64_t LMMOffset = 0;\n  int64_t SMMOffset = 0;\n\n  int64_t LdDisp1 = LdDispImm;\n  int64_t LdDisp2 = 0;\n  int64_t StDisp1 = StDispImm;\n  int64_t StDisp2 = 0;\n  unsigned Size1 = 0;\n  unsigned Size2 = 0;\n  int64_t LdStDelta = StDispImm - LdDispImm;\n\n  for (auto DispSizePair : BlockingStoresDispSizeMap) {\n    LdDisp2 = DispSizePair.first;\n    StDisp2 = DispSizePair.first + LdStDelta;\n    Size2 = DispSizePair.second;\n    // Avoid copying overlapping areas.\n    if (LdDisp2 < LdDisp1) {\n      int OverlapDelta = LdDisp1 - LdDisp2;\n      LdDisp2 += OverlapDelta;\n      StDisp2 += OverlapDelta;\n      Size2 -= OverlapDelta;\n    }\n",
        "suffix": "\n    // Build a copy for the point until the current blocking store's\n    // displacement.\n    buildCopies(Size1, LoadInst, LdDisp1, StoreInst, StDisp1, LMMOffset,\n                SMMOffset);\n    // Build a copy for the current blocking store.\n    buildCopies(Size2, LoadInst, LdDisp2, StoreInst, StDisp2, LMMOffset + Size1,\n                SMMOffset + Size1);\n    LdDisp1 = LdDisp2 + Size2;\n    StDisp1 = StDisp2 + Size2;\n    LMMOffset += Size1 + Size2;\n    SMMOffset += Size1 + Size2;\n  }\n  unsigned Size3 = (LdDispImm + getRegSizeInBytes(LoadInst)) - LdDisp1;\n  buildCopies(Size3, LoadInst, LdDisp1, StoreInst, StDisp1, LMMOffset,\n              LMMOffset);\n}\n",
        "start": 562,
        "end": 606,
        "buggy": "void X86AvoidSFBPass::breakBlockedCopies(\n    MachineInstr *LoadInst, MachineInstr *StoreInst,\n    const DisplacementSizeMap &BlockingStoresDispSizeMap) {\n  int64_t LdDispImm = getDispOperand(LoadInst).getImm();\n  int64_t StDispImm = getDispOperand(StoreInst).getImm();\n  int64_t LMMOffset = 0;\n  int64_t SMMOffset = 0;\n\n  int64_t LdDisp1 = LdDispImm;\n  int64_t LdDisp2 = 0;\n  int64_t StDisp1 = StDispImm;\n  int64_t StDisp2 = 0;\n  unsigned Size1 = 0;\n  unsigned Size2 = 0;\n  int64_t LdStDelta = StDispImm - LdDispImm;\n\n  for (auto DispSizePair : BlockingStoresDispSizeMap) {\n    LdDisp2 = DispSizePair.first;\n    StDisp2 = DispSizePair.first + LdStDelta;\n    Size2 = DispSizePair.second;\n    // Avoid copying overlapping areas.\n    if (LdDisp2 < LdDisp1) {\n      int OverlapDelta = LdDisp1 - LdDisp2;\n      LdDisp2 += OverlapDelta;\n      StDisp2 += OverlapDelta;\n      Size2 -= OverlapDelta;\n    }\n    Size1 = std::abs(std::abs(LdDisp2) - std::abs(LdDisp1));\n\n    // Build a copy for the point until the current blocking store's\n    // displacement.\n    buildCopies(Size1, LoadInst, LdDisp1, StoreInst, StDisp1, LMMOffset,\n                SMMOffset);\n    // Build a copy for the current blocking store.\n    buildCopies(Size2, LoadInst, LdDisp2, StoreInst, StDisp2, LMMOffset + Size1,\n                SMMOffset + Size1);\n    LdDisp1 = LdDisp2 + Size2;\n    StDisp1 = StDisp2 + Size2;\n    LMMOffset += Size1 + Size2;\n    SMMOffset += Size1 + Size2;\n  }\n  unsigned Size3 = (LdDispImm + getRegSizeInBytes(LoadInst)) - LdDisp1;\n  buildCopies(Size3, LoadInst, LdDisp1, StoreInst, StDisp1, LMMOffset,\n              LMMOffset);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    Size1 = std::abs(std::abs(LdDisp2) - std::abs(LdDisp1));\n",
        "src_path": "e79477895e1af4425aecaded2881e3b3c878faf5___X86AvoidStoreForwardingBlocks.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/e79477895e1af4425aecaded2881e3b3c878faf5",
        "commit_msg": "[X86] Fix AvoidStoreForwardingBlocks pass for negative displacements\n\nFixes https://bugs.llvm.org/show_bug.cgi?id=39926.\n\nThe size of the first copy was computed as\nstd::abs(std::abs(LdDisp2) - std::abs(LdDisp1)), which results in\nskipped bytes if the signs of LdDisp2 and LdDisp1 differ. As far as\nI can see, this should just be LdDisp2 - LdDisp1. The case where\nLdDisp1 > LdDisp2 is already handled in the code above, in which case\nLdDisp2 is set to LdDisp1 and this subtraction will evaluate to\nSize1 = 0, which is the correct value to skip an overlapping copy.\n\nDifferential Revision: https://reviews.llvm.org/D55485\n\nllvm-svn: 348750",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/pr39926.ll",
                "patch": "@@ -8,9 +8,9 @@ define i8 @test_offset(i8* %base) {\n ; CHECK-NEXT:    movb $0, 7(%rdi)\n ; CHECK-NEXT:    movw $0, 5(%rdi)\n ; CHECK-NEXT:    movl $0, 1(%rdi)\n-; CHECK-NEXT:    movzwl -4(%rdi), %eax\n-; CHECK-NEXT:    movw %ax, -{{[0-9]+}}(%rsp)\n-; CHECK-NEXT:    movb -2(%rdi), %al\n+; CHECK-NEXT:    movl -4(%rdi), %eax\n+; CHECK-NEXT:    movl %eax, -{{[0-9]+}}(%rsp)\n+; CHECK-NEXT:    movb (%rdi), %al\n ; CHECK-NEXT:    movb %al, -{{[0-9]+}}(%rsp)\n ; CHECK-NEXT:    movl 1(%rdi), %eax\n ; CHECK-NEXT:    movl %eax, -{{[0-9]+}}(%rsp)"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/pr39926.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/pr39926.ll\n\n  Unexpected Failures: 1\n"
    },
    "8d5804802498efe95bb3b81d2fdab607e7d1e02b___ObjCARC.h": {
        "prefix": "static inline void EraseInstruction(Instruction *CI) {\n  Value *OldArg = cast<CallInst>(CI)->getArgOperand(0);\n\n  bool Unused = CI->use_empty();\n\n  if (!Unused) {\n    // Replace the return value with the argument.\n    assert((IsForwarding(GetBasicARCInstKind(CI)) ||\n            (IsNoopOnNull(GetBasicARCInstKind(CI)) &&\n",
        "suffix": "           \"Can't delete non-forwarding instruction with users!\");\n    CI->replaceAllUsesWith(OldArg);\n  }\n\n  CI->eraseFromParent();\n\n  if (Unused)\n    RecursivelyDeleteTriviallyDeadInstructions(OldArg);\n}\n",
        "start": 52,
        "end": 70,
        "buggy": "static inline void EraseInstruction(Instruction *CI) {\n  Value *OldArg = cast<CallInst>(CI)->getArgOperand(0);\n\n  bool Unused = CI->use_empty();\n\n  if (!Unused) {\n    // Replace the return value with the argument.\n    assert((IsForwarding(GetBasicARCInstKind(CI)) ||\n            (IsNoopOnNull(GetBasicARCInstKind(CI)) &&\n             isa<ConstantPointerNull>(OldArg))) &&\n           \"Can't delete non-forwarding instruction with users!\");\n    CI->replaceAllUsesWith(OldArg);\n  }\n\n  CI->eraseFromParent();\n\n  if (Unused)\n    RecursivelyDeleteTriviallyDeadInstructions(OldArg);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "             isa<ConstantPointerNull>(OldArg))) &&\n",
        "src_path": "8d5804802498efe95bb3b81d2fdab607e7d1e02b___ObjCARC.h",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/8d5804802498efe95bb3b81d2fdab607e7d1e02b",
        "commit_msg": "Fix assert in ObjCARC optimizer when deleting retainBlock of null or undef.\n\nThe caller to EraseInstruction had this conditional:\n\n    // ARC calls with null are no-ops. Delete them.\n    if (IsNullOrUndef(Arg))\n\nbut the assert inside EraseInstruction only allowed ConstantPointerNull and not\nundef or bitcasts.\n\nThis adds support for both of these cases.\n\nrdar://problem/47003805\n\nllvm-svn: 350261",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/ObjCARC/rv.ll",
                "patch": "@@ -61,6 +61,11 @@ define void @test2() {\n   call i8* @llvm.objc.retainAutoreleasedReturnValue(i8* null)\n   call i8* @llvm.objc.autoreleaseReturnValue(i8* null)\n   ; call i8* @llvm.objc.retainAutoreleaseReturnValue(i8* null) ; TODO\n+  %bitcast = bitcast i32* null to i8*\n+  %rb = call i8* @llvm.objc.retainBlock(i8* %bitcast)\n+  call void @use_pointer(i8* %rb)\n+  %rb2 = call i8* @llvm.objc.retainBlock(i8* undef)\n+  call void @use_pointer(i8* %rb2)\n   ret void\n }\n "
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/ObjCARC/rv.ll (1 of 1)\nTesting Time: 0.91s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/ObjCARC/rv.ll\n\n  Unexpected Failures: 1\n"
    },
    "d4e7a0d83ca785925a4f8c82d114377f5b156bbf___SimplifyLibCalls.cpp": {
        "prefix": "Value *LibCallSimplifier::optimizeMemChr(CallInst *CI, IRBuilder<> &B) {\n  Value *SrcStr = CI->getArgOperand(0);\n  ConstantInt *CharC = dyn_cast<ConstantInt>(CI->getArgOperand(1));\n  ConstantInt *LenC = dyn_cast<ConstantInt>(CI->getArgOperand(2));\n\n  // memchr(x, y, 0) -> null\n  if (LenC && LenC->isZero())\n    return Constant::getNullValue(CI->getType());\n\n  // From now on we need at least constant length and string.\n  StringRef Str;\n  if (!LenC || !getConstantStringInfo(SrcStr, Str, 0, /*TrimAtNul=*/false))\n    return nullptr;\n\n  // Truncate the string to LenC. If Str is smaller than LenC we will still only\n  // scan the string, as reading past the end of it is undefined and we can just\n  // return null if we don't find the char.\n  Str = Str.substr(0, LenC->getZExtValue());\n\n  // If the char is variable but the input str and length are not we can turn\n  // this memchr call into a simple bit field test. Of course this only works\n  // when the return value is only checked against null.\n  //\n  // It would be really nice to reuse switch lowering here but we can't change\n  // the CFG at this point.\n  //\n  // memchr(\"\\r\\n\", C, 2) != nullptr -> (C & ((1 << '\\r') | (1 << '\\n'))) != 0\n  //   after bounds check.\n  if (!CharC && !Str.empty() && isOnlyUsedInZeroEqualityComparison(CI)) {\n    unsigned char Max =\n        *std::max_element(reinterpret_cast<const unsigned char *>(Str.begin()),\n                          reinterpret_cast<const unsigned char *>(Str.end()));\n\n    // Make sure the bit field we're about to create fits in a register on the\n    // target.\n    // FIXME: On a 64 bit architecture this prevents us from using the\n    // interesting range of alpha ascii chars. We could do better by emitting\n    // two bitfields or shifting the range by 64 if no lower chars are used.\n    if (!DL.fitsInLegalInteger(Max + 1))\n      return nullptr;\n\n    // For the bit field use a power-of-2 type with at least 8 bits to avoid\n    // creating unnecessary illegal types.\n    unsigned char Width = NextPowerOf2(std::max((unsigned char)7, Max));\n\n    // Now build the bit field.\n    APInt Bitfield(Width, 0);\n    for (char C : Str)\n      Bitfield.setBit((unsigned char)C);\n    Value *BitfieldC = B.getInt(Bitfield);\n\n",
        "suffix": "    Value *C = B.CreateZExtOrTrunc(CI->getArgOperand(1), BitfieldC->getType());\n    Value *Bounds = B.CreateICmp(ICmpInst::ICMP_ULT, C, B.getIntN(Width, Width),\n                                 \"memchr.bounds\");\n\n    // Create code that checks if the given bit is set in the field.\n    Value *Shl = B.CreateShl(B.getIntN(Width, 1ULL), C);\n    Value *Bits = B.CreateIsNotNull(B.CreateAnd(Shl, BitfieldC), \"memchr.bits\");\n\n    // Finally merge both checks and cast to pointer type. The inttoptr\n    // implicitly zexts the i1 to intptr type.\n    return B.CreateIntToPtr(B.CreateAnd(Bounds, Bits, \"memchr\"), CI->getType());\n  }\n\n  // Check if all arguments are constants.  If so, we can constant fold.\n  if (!CharC)\n    return nullptr;\n\n  // Compute the offset.\n  size_t I = Str.find(CharC->getSExtValue() & 0xFF);\n  if (I == StringRef::npos) // Didn't find the char.  memchr returns null.\n    return Constant::getNullValue(CI->getType());\n\n  // memchr(s+n,c,l) -> gep(s+n+i,c)\n  return B.CreateGEP(B.getInt8Ty(), SrcStr, B.getInt64(I), \"memchr\");\n}\n",
        "start": 750,
        "end": 826,
        "buggy": "Value *LibCallSimplifier::optimizeMemChr(CallInst *CI, IRBuilder<> &B) {\n  Value *SrcStr = CI->getArgOperand(0);\n  ConstantInt *CharC = dyn_cast<ConstantInt>(CI->getArgOperand(1));\n  ConstantInt *LenC = dyn_cast<ConstantInt>(CI->getArgOperand(2));\n\n  // memchr(x, y, 0) -> null\n  if (LenC && LenC->isZero())\n    return Constant::getNullValue(CI->getType());\n\n  // From now on we need at least constant length and string.\n  StringRef Str;\n  if (!LenC || !getConstantStringInfo(SrcStr, Str, 0, /*TrimAtNul=*/false))\n    return nullptr;\n\n  // Truncate the string to LenC. If Str is smaller than LenC we will still only\n  // scan the string, as reading past the end of it is undefined and we can just\n  // return null if we don't find the char.\n  Str = Str.substr(0, LenC->getZExtValue());\n\n  // If the char is variable but the input str and length are not we can turn\n  // this memchr call into a simple bit field test. Of course this only works\n  // when the return value is only checked against null.\n  //\n  // It would be really nice to reuse switch lowering here but we can't change\n  // the CFG at this point.\n  //\n  // memchr(\"\\r\\n\", C, 2) != nullptr -> (C & ((1 << '\\r') | (1 << '\\n'))) != 0\n  //   after bounds check.\n  if (!CharC && !Str.empty() && isOnlyUsedInZeroEqualityComparison(CI)) {\n    unsigned char Max =\n        *std::max_element(reinterpret_cast<const unsigned char *>(Str.begin()),\n                          reinterpret_cast<const unsigned char *>(Str.end()));\n\n    // Make sure the bit field we're about to create fits in a register on the\n    // target.\n    // FIXME: On a 64 bit architecture this prevents us from using the\n    // interesting range of alpha ascii chars. We could do better by emitting\n    // two bitfields or shifting the range by 64 if no lower chars are used.\n    if (!DL.fitsInLegalInteger(Max + 1))\n      return nullptr;\n\n    // For the bit field use a power-of-2 type with at least 8 bits to avoid\n    // creating unnecessary illegal types.\n    unsigned char Width = NextPowerOf2(std::max((unsigned char)7, Max));\n\n    // Now build the bit field.\n    APInt Bitfield(Width, 0);\n    for (char C : Str)\n      Bitfield.setBit((unsigned char)C);\n    Value *BitfieldC = B.getInt(Bitfield);\n\n    // First check that the bit field access is within bounds.\n    Value *C = B.CreateZExtOrTrunc(CI->getArgOperand(1), BitfieldC->getType());\n    Value *Bounds = B.CreateICmp(ICmpInst::ICMP_ULT, C, B.getIntN(Width, Width),\n                                 \"memchr.bounds\");\n\n    // Create code that checks if the given bit is set in the field.\n    Value *Shl = B.CreateShl(B.getIntN(Width, 1ULL), C);\n    Value *Bits = B.CreateIsNotNull(B.CreateAnd(Shl, BitfieldC), \"memchr.bits\");\n\n    // Finally merge both checks and cast to pointer type. The inttoptr\n    // implicitly zexts the i1 to intptr type.\n    return B.CreateIntToPtr(B.CreateAnd(Bounds, Bits, \"memchr\"), CI->getType());\n  }\n\n  // Check if all arguments are constants.  If so, we can constant fold.\n  if (!CharC)\n    return nullptr;\n\n  // Compute the offset.\n  size_t I = Str.find(CharC->getSExtValue() & 0xFF);\n  if (I == StringRef::npos) // Didn't find the char.  memchr returns null.\n    return Constant::getNullValue(CI->getType());\n\n  // memchr(s+n,c,l) -> gep(s+n+i,c)\n  return B.CreateGEP(B.getInt8Ty(), SrcStr, B.getInt64(I), \"memchr\");\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    // First check that the bit field access is within bounds.\n",
        "src_path": "d4e7a0d83ca785925a4f8c82d114377f5b156bbf___SimplifyLibCalls.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/d4e7a0d83ca785925a4f8c82d114377f5b156bbf",
        "commit_msg": "[SimplifyLibCalls] Fix memchr expansion for constant strings.\n\nThe C standard says \"The memchr function locates the first\noccurrence of c (converted to an unsigned char)[...]\".  The expansion\nwas missing the conversion to unsigned char.\n\nFixes https://bugs.llvm.org/show_bug.cgi?id=39041 .\n\nDifferential Revision: https://reviews.llvm.org/D55947\n\nllvm-svn: 350775",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/memchr.ll",
                "patch": "@@ -50,7 +50,7 @@ define void @test3() {\n \n define void @test4(i32 %chr) {\n ; CHECK-LABEL: @test4(\n-; CHECK-NEXT:    [[DST:%.*]] = call i8* @memchr(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @hello, i32 0, i32 0), i32 %chr, i32 14)\n+; CHECK-NEXT:    [[DST:%.*]] = call i8* @memchr(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @hello, i32 0, i32 0), i32 [[CHR:%.*]], i32 14)\n ; CHECK-NEXT:    store i8* [[DST]], i8** @chp, align 4\n ; CHECK-NEXT:    ret void\n ;\n@@ -131,12 +131,13 @@ define void @test10() {\n ; Check transformation memchr(\"\\r\\n\", C, 2) != nullptr -> (C & 9216) != 0\n define i1 @test11(i32 %C) {\n ; CHECK-LABEL: @test11(\n-; CHECK-NEXT:    [[TMP1:%.*]] = trunc i32 %C to i16\n-; CHECK-NEXT:    [[MEMCHR_BOUNDS:%.*]] = icmp ult i16 [[TMP1]], 16\n-; CHECK-NEXT:    [[TMP2:%.*]] = shl i16 1, [[TMP1]]\n-; CHECK-NEXT:    [[TMP3:%.*]] = and i16 [[TMP2]], 9216\n-; CHECK-NEXT:    [[MEMCHR_BITS:%.*]] = icmp ne i16 [[TMP3]], 0\n-; CHECK-NEXT:    [[MEMCHR:%.*]] = and i1 [[MEMCHR:%.*]].bounds, [[MEMCHR:%.*]].bits\n+; CHECK-NEXT:    [[TMP1:%.*]] = trunc i32 [[C:%.*]] to i16\n+; CHECK-NEXT:    [[TMP2:%.*]] = and i16 [[TMP1]], 255\n+; CHECK-NEXT:    [[MEMCHR_BOUNDS:%.*]] = icmp ult i16 [[TMP2]], 16\n+; CHECK-NEXT:    [[TMP3:%.*]] = shl i16 1, [[TMP2]]\n+; CHECK-NEXT:    [[TMP4:%.*]] = and i16 [[TMP3]], 9216\n+; CHECK-NEXT:    [[MEMCHR_BITS:%.*]] = icmp ne i16 [[TMP4]], 0\n+; CHECK-NEXT:    [[MEMCHR:%.*]] = and i1 [[MEMCHR_BOUNDS]], [[MEMCHR_BITS]]\n ; CHECK-NEXT:    ret i1 [[MEMCHR]]\n ;\n   %dst = call i8* @memchr(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @newlines, i64 0, i64 0), i32 %C, i32 2)\n@@ -147,7 +148,7 @@ define i1 @test11(i32 %C) {\n ; No 64 bits here\n define i1 @test12(i32 %C) {\n ; CHECK-LABEL: @test12(\n-; CHECK-NEXT:    [[DST:%.*]] = call i8* @memchr(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @spaces, i32 0, i32 0), i32 %C, i32 3)\n+; CHECK-NEXT:    [[DST:%.*]] = call i8* @memchr(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @spaces, i32 0, i32 0), i32 [[C:%.*]], i32 3)\n ; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i8* [[DST]], null\n ; CHECK-NEXT:    ret i1 [[CMP]]\n ;\n@@ -158,11 +159,12 @@ define i1 @test12(i32 %C) {\n \n define i1 @test13(i32 %C) {\n ; CHECK-LABEL: @test13(\n-; CHECK-NEXT:    [[MEMCHR_BOUNDS:%.*]] = icmp ult i32 %C, 32\n-; CHECK-NEXT:    [[TMP1:%.*]] = shl i32 1, %C\n-; CHECK-NEXT:    [[TMP2:%.*]] = and i32 [[TMP1]], -2147483647\n-; CHECK-NEXT:    [[MEMCHR_BITS:%.*]] = icmp ne i32 [[TMP2]], 0\n-; CHECK-NEXT:    [[MEMCHR:%.*]] = and i1 [[MEMCHR:%.*]].bounds, [[MEMCHR:%.*]].bits\n+; CHECK-NEXT:    [[TMP1:%.*]] = and i32 [[C:%.*]], 255\n+; CHECK-NEXT:    [[MEMCHR_BOUNDS:%.*]] = icmp ult i32 [[TMP1]], 32\n+; CHECK-NEXT:    [[TMP2:%.*]] = shl i32 1, [[TMP1]]\n+; CHECK-NEXT:    [[TMP3:%.*]] = and i32 [[TMP2]], -2147483647\n+; CHECK-NEXT:    [[MEMCHR_BITS:%.*]] = icmp ne i32 [[TMP3]], 0\n+; CHECK-NEXT:    [[MEMCHR:%.*]] = and i1 [[MEMCHR_BOUNDS]], [[MEMCHR_BITS]]\n ; CHECK-NEXT:    ret i1 [[MEMCHR]]\n ;\n   %dst = call i8* @memchr(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @single, i64 0, i64 0), i32 %C, i32 2)\n@@ -172,8 +174,9 @@ define i1 @test13(i32 %C) {\n \n define i1 @test14(i32 %C) {\n ; CHECK-LABEL: @test14(\n-; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i32 %C, 31\n-; CHECK-NEXT:    ret i1 [[TMP1]]\n+; CHECK-NEXT:    [[TMP1:%.*]] = and i32 [[C:%.*]], 255\n+; CHECK-NEXT:    [[MEMCHR_BITS:%.*]] = icmp eq i32 [[TMP1]], 31\n+; CHECK-NEXT:    ret i1 [[MEMCHR_BITS]]\n ;\n   %dst = call i8* @memchr(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @single, i64 0, i64 0), i32 %C, i32 1)\n   %cmp = icmp ne i8* %dst, null\n@@ -182,7 +185,7 @@ define i1 @test14(i32 %C) {\n \n define i1 @test15(i32 %C) {\n ; CHECK-LABEL: @test15(\n-; CHECK-NEXT:    [[DST:%.*]] = call i8* @memchr(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @negative, i32 0, i32 0), i32 %C, i32 3)\n+; CHECK-NEXT:    [[DST:%.*]] = call i8* @memchr(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @negative, i32 0, i32 0), i32 [[C:%.*]], i32 3)\n ; CHECK-NEXT:    [[CMP:%.*]] = icmp ne i8* [[DST]], null\n ; CHECK-NEXT:    ret i1 [[CMP]]\n ;"
            },
            {
                "fn": "llvm/test/Transforms/InstCombine/strchr-1.ll",
                "patch": "@@ -82,8 +82,9 @@ define void @test_simplify6(i8* %str) {\n define i1 @test_simplify7(i32 %C) {\n ; CHECK-LABEL: @test_simplify7\n ; CHECK-NEXT: [[TRUNC:%.*]] = trunc i32 %C to i16\n-; CHECK-NEXT: %memchr.bounds = icmp ult i16 [[TRUNC]], 16\n-; CHECK-NEXT: [[SHL:%.*]] = shl i16 1, [[TRUNC]]\n+; CHECK-NEXT: [[TRUNC_AND:%.*]] = and i16 [[TRUNC]], 255\n+; CHECK-NEXT: %memchr.bounds = icmp ult i16 [[TRUNC_AND]], 16\n+; CHECK-NEXT: [[SHL:%.*]] = shl i16 1, [[TRUNC_AND]]\n ; CHECK-NEXT: [[AND:%.*]] = and i16 [[SHL]], 9217\n ; CHECK-NEXT: %memchr.bits = icmp ne i16 [[AND]], 0\n ; CHECK-NEXT: %memchr1 = and i1 %memchr.bounds, %memchr.bits"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/memchr.ll (1 of 1)\nTesting Time: 0.31s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/memchr.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Transforms/InstCombine/strchr-1.ll (1 of 1)\nTesting Time: 0.12s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/strchr-1.ll\n\n  Unexpected Failures: 1\n"
    },
    "90ede5f4bfe66a0c1b3f4616bb0cc50a6629c4ac___SimplifyCFG.cpp": {
        "prefix": "static bool FoldCondBranchOnPHI(BranchInst *BI, const DataLayout &DL,\n                                AssumptionCache *AC) {\n  BasicBlock *BB = BI->getParent();\n  PHINode *PN = dyn_cast<PHINode>(BI->getCondition());\n  // NOTE: we currently cannot transform this case if the PHI node is used\n  // outside of the block.\n  if (!PN || PN->getParent() != BB || !PN->hasOneUse())\n    return false;\n\n  // Degenerate case of a single entry PHI.\n  if (PN->getNumIncomingValues() == 1) {\n    FoldSingleEntryPHINodes(PN->getParent());\n    return true;\n  }\n\n  // Now we know that this block has multiple preds and two succs.\n  if (!BlockIsSimpleEnoughToThreadThrough(BB))\n    return false;\n\n  // Can't fold blocks that contain noduplicate or convergent calls.\n  if (any_of(*BB, [](const Instruction &I) {\n        const CallInst *CI = dyn_cast<CallInst>(&I);\n        return CI && (CI->cannotDuplicate() || CI->isConvergent());\n      }))\n    return false;\n\n  // Okay, this is a simple enough basic block.  See if any phi values are\n  // constants.\n  for (unsigned i = 0, e = PN->getNumIncomingValues(); i != e; ++i) {\n    ConstantInt *CB = dyn_cast<ConstantInt>(PN->getIncomingValue(i));\n    if (!CB || !CB->getType()->isIntegerTy(1))\n      continue;\n\n    // Okay, we now know that all edges from PredBB should be revectored to\n    // branch to RealDest.\n    BasicBlock *PredBB = PN->getIncomingBlock(i);\n    BasicBlock *RealDest = BI->getSuccessor(!CB->getZExtValue());\n\n    if (RealDest == BB)\n      continue; // Skip self loops.\n    // Skip if the predecessor's terminator is an indirect branch.\n    if (isa<IndirectBrInst>(PredBB->getTerminator()))\n      continue;\n\n    // The dest block might have PHI nodes, other predecessors and other\n    // difficult cases.  Instead of being smart about this, just insert a new\n    // block that jumps to the destination block, effectively splitting\n    // the edge we are about to create.\n    BasicBlock *EdgeBB =\n        BasicBlock::Create(BB->getContext(), RealDest->getName() + \".critedge\",\n                           RealDest->getParent(), RealDest);\n",
        "suffix": "\n    // Update PHI nodes.\n    AddPredecessorToBlock(RealDest, EdgeBB, BB);\n\n    // BB may have instructions that are being threaded over.  Clone these\n    // instructions into EdgeBB.  We know that there will be no uses of the\n    // cloned instructions outside of EdgeBB.\n    BasicBlock::iterator InsertPt = EdgeBB->begin();\n    DenseMap<Value *, Value *> TranslateMap; // Track translated values.\n    for (BasicBlock::iterator BBI = BB->begin(); &*BBI != BI; ++BBI) {\n      if (PHINode *PN = dyn_cast<PHINode>(BBI)) {\n        TranslateMap[PN] = PN->getIncomingValueForBlock(PredBB);\n        continue;\n      }\n      // Clone the instruction.\n      Instruction *N = BBI->clone();\n      if (BBI->hasName())\n        N->setName(BBI->getName() + \".c\");\n\n      // Update operands due to translation.\n      for (User::op_iterator i = N->op_begin(), e = N->op_end(); i != e; ++i) {\n        DenseMap<Value *, Value *>::iterator PI = TranslateMap.find(*i);\n        if (PI != TranslateMap.end())\n          *i = PI->second;\n      }\n\n      // Check for trivial simplification.\n      if (Value *V = SimplifyInstruction(N, {DL, nullptr, nullptr, AC})) {\n        if (!BBI->use_empty())\n          TranslateMap[&*BBI] = V;\n        if (!N->mayHaveSideEffects()) {\n          N->deleteValue(); // Instruction folded away, don't need actual inst\n          N = nullptr;\n        }\n      } else {\n        if (!BBI->use_empty())\n          TranslateMap[&*BBI] = N;\n      }\n      // Insert the new instruction into its new home.\n      if (N)\n        EdgeBB->getInstList().insert(InsertPt, N);\n\n      // Register the new instruction with the assumption cache if necessary.\n      if (auto *II = dyn_cast_or_null<IntrinsicInst>(N))\n        if (II->getIntrinsicID() == Intrinsic::assume)\n          AC->registerAssumption(II);\n    }\n\n    // Loop over all of the edges from PredBB to BB, changing them to branch\n    // to EdgeBB instead.\n    Instruction *PredBBTI = PredBB->getTerminator();\n    for (unsigned i = 0, e = PredBBTI->getNumSuccessors(); i != e; ++i)\n      if (PredBBTI->getSuccessor(i) == BB) {\n        BB->removePredecessor(PredBB);\n        PredBBTI->setSuccessor(i, EdgeBB);\n      }\n\n    // Recurse, simplifying any other constants.\n    return FoldCondBranchOnPHI(BI, DL, AC) || true;\n  }\n\n  return false;\n}\n",
        "start": 2161,
        "end": 2275,
        "buggy": "static bool FoldCondBranchOnPHI(BranchInst *BI, const DataLayout &DL,\n                                AssumptionCache *AC) {\n  BasicBlock *BB = BI->getParent();\n  PHINode *PN = dyn_cast<PHINode>(BI->getCondition());\n  // NOTE: we currently cannot transform this case if the PHI node is used\n  // outside of the block.\n  if (!PN || PN->getParent() != BB || !PN->hasOneUse())\n    return false;\n\n  // Degenerate case of a single entry PHI.\n  if (PN->getNumIncomingValues() == 1) {\n    FoldSingleEntryPHINodes(PN->getParent());\n    return true;\n  }\n\n  // Now we know that this block has multiple preds and two succs.\n  if (!BlockIsSimpleEnoughToThreadThrough(BB))\n    return false;\n\n  // Can't fold blocks that contain noduplicate or convergent calls.\n  if (any_of(*BB, [](const Instruction &I) {\n        const CallInst *CI = dyn_cast<CallInst>(&I);\n        return CI && (CI->cannotDuplicate() || CI->isConvergent());\n      }))\n    return false;\n\n  // Okay, this is a simple enough basic block.  See if any phi values are\n  // constants.\n  for (unsigned i = 0, e = PN->getNumIncomingValues(); i != e; ++i) {\n    ConstantInt *CB = dyn_cast<ConstantInt>(PN->getIncomingValue(i));\n    if (!CB || !CB->getType()->isIntegerTy(1))\n      continue;\n\n    // Okay, we now know that all edges from PredBB should be revectored to\n    // branch to RealDest.\n    BasicBlock *PredBB = PN->getIncomingBlock(i);\n    BasicBlock *RealDest = BI->getSuccessor(!CB->getZExtValue());\n\n    if (RealDest == BB)\n      continue; // Skip self loops.\n    // Skip if the predecessor's terminator is an indirect branch.\n    if (isa<IndirectBrInst>(PredBB->getTerminator()))\n      continue;\n\n    // The dest block might have PHI nodes, other predecessors and other\n    // difficult cases.  Instead of being smart about this, just insert a new\n    // block that jumps to the destination block, effectively splitting\n    // the edge we are about to create.\n    BasicBlock *EdgeBB =\n        BasicBlock::Create(BB->getContext(), RealDest->getName() + \".critedge\",\n                           RealDest->getParent(), RealDest);\n    BranchInst::Create(RealDest, EdgeBB);\n\n    // Update PHI nodes.\n    AddPredecessorToBlock(RealDest, EdgeBB, BB);\n\n    // BB may have instructions that are being threaded over.  Clone these\n    // instructions into EdgeBB.  We know that there will be no uses of the\n    // cloned instructions outside of EdgeBB.\n    BasicBlock::iterator InsertPt = EdgeBB->begin();\n    DenseMap<Value *, Value *> TranslateMap; // Track translated values.\n    for (BasicBlock::iterator BBI = BB->begin(); &*BBI != BI; ++BBI) {\n      if (PHINode *PN = dyn_cast<PHINode>(BBI)) {\n        TranslateMap[PN] = PN->getIncomingValueForBlock(PredBB);\n        continue;\n      }\n      // Clone the instruction.\n      Instruction *N = BBI->clone();\n      if (BBI->hasName())\n        N->setName(BBI->getName() + \".c\");\n\n      // Update operands due to translation.\n      for (User::op_iterator i = N->op_begin(), e = N->op_end(); i != e; ++i) {\n        DenseMap<Value *, Value *>::iterator PI = TranslateMap.find(*i);\n        if (PI != TranslateMap.end())\n          *i = PI->second;\n      }\n\n      // Check for trivial simplification.\n      if (Value *V = SimplifyInstruction(N, {DL, nullptr, nullptr, AC})) {\n        if (!BBI->use_empty())\n          TranslateMap[&*BBI] = V;\n        if (!N->mayHaveSideEffects()) {\n          N->deleteValue(); // Instruction folded away, don't need actual inst\n          N = nullptr;\n        }\n      } else {\n        if (!BBI->use_empty())\n          TranslateMap[&*BBI] = N;\n      }\n      // Insert the new instruction into its new home.\n      if (N)\n        EdgeBB->getInstList().insert(InsertPt, N);\n\n      // Register the new instruction with the assumption cache if necessary.\n      if (auto *II = dyn_cast_or_null<IntrinsicInst>(N))\n        if (II->getIntrinsicID() == Intrinsic::assume)\n          AC->registerAssumption(II);\n    }\n\n    // Loop over all of the edges from PredBB to BB, changing them to branch\n    // to EdgeBB instead.\n    Instruction *PredBBTI = PredBB->getTerminator();\n    for (unsigned i = 0, e = PredBBTI->getNumSuccessors(); i != e; ++i)\n      if (PredBBTI->getSuccessor(i) == BB) {\n        BB->removePredecessor(PredBB);\n        PredBBTI->setSuccessor(i, EdgeBB);\n      }\n\n    // Recurse, simplifying any other constants.\n    return FoldCondBranchOnPHI(BI, DL, AC) || true;\n  }\n\n  return false;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    BranchInst::Create(RealDest, EdgeBB);\n",
        "src_path": "90ede5f4bfe66a0c1b3f4616bb0cc50a6629c4ac___SimplifyCFG.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/90ede5f4bfe66a0c1b3f4616bb0cc50a6629c4ac",
        "commit_msg": "[SimplifyCFG] Retain debug info when threading jumps with critical edges\n\nFixes bug 38023: https://bugs.llvm.org/show_bug.cgi?id=38023\n\nThe SimplifyCFG pass will perform jump threading in some cases where\ndoing so is trivial and would simplify the CFG. When folding a series\nof blocks with redundant conditional branches into an unconditional \"critical\nedge\" block, it does not keep the debug location associated with the previous\nconditional branch.\n\nThis patch fixes the bug described by copying the debug info from the\nold conditional branch to the new unconditional branch instruction, and\nadds a regression test for the SimplifyCFG pass that covers this case.\n\nPatch by Stephen Tozer!\n\nDifferential Revision: https://reviews.llvm.org/D59206\n\nllvm-svn: 355833",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/SimplifyCFG/debug-info-thread-phi.ll",
                "patch": "@@ -0,0 +1,38 @@\n+; RUN: opt %s -debugify -simplifycfg -S | FileCheck %s\n+; Tests Bug 37966\n+\n+define void @bar(i32 %aa) {\n+; CHECK-LABEL: @bar(\n+; CHECK: if.end.1.critedge:\n+; CHECK: br label %if.end.1, !dbg ![[DBG:[0-9]+]]\n+entry:\n+  %aa.addr = alloca i32, align 4\n+  %bb = alloca i32, align 4\n+  store i32 %aa, i32* %aa.addr, align 4\n+  store i32 0, i32* %bb, align 4\n+  %tobool = icmp ne i32 %aa, 0\n+  br i1 %tobool, label %if.then, label %if.end\n+\n+if.then:                                          ; preds = %entry\n+  call void @foo()\n+  br label %if.end\n+\n+if.end:                                           ; preds = %if.then, %entry\n+  store i32 1, i32* %bb, align 4\n+  br i1 %tobool, label %if.then.1, label %if.end.1\n+\n+if.then.1:                                        ; preds = %if.end\n+  call void @foo()\n+  br label %if.end.1\n+\n+if.end.1:                                         ; preds = %if.then.1, %if.end\n+  store i32 2, i32* %bb, align 4\n+  br label %for.end\n+\n+for.end:                                          ; preds = %if.end.1\n+  ret void\n+}\n+\n+declare void @foo()\n+\n+; CHECK: ![[DBG]] = !DILocation("
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/SimplifyCFG/debug-info-thread-phi.ll (1 of 1)\nTesting Time: 0.19s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/SimplifyCFG/debug-info-thread-phi.ll\n\n  Unexpected Failures: 1\n"
    },
    "adf288c5d93e60a91fe226ae2dcebad0f760a259___LoopPredication.cpp": {
        "prefix": "bool LoopPredication::isLoopInvariantValue(const SCEV* S) { \n  // Handling expressions which produce invariant results, but *haven't* yet\n  // been removed from the loop serves two important purposes.\n  // 1) Most importantly, it resolves a pass ordering cycle which would\n  // otherwise need us to iteration licm, loop-predication, and either\n  // loop-unswitch or loop-peeling to make progress on examples with lots of\n  // predicable range checks in a row.  (Since, in the general case,  we can't\n  // hoist the length checks until the dominating checks have been discharged\n  // as we can't prove doing so is safe.)\n  // 2) As a nice side effect, this exposes the value of peeling or unswitching\n  // much more obviously in the IR.  Otherwise, the cost modeling for other\n  // transforms would end up needing to duplicate all of this logic to model a\n  // check which becomes predictable based on a modeled peel or unswitch.\n  // \n  // The cost of doing so in the worst case is an extra fill from the stack  in\n  // the loop to materialize the loop invariant test value instead of checking\n  // against the original IV which is presumable in a register inside the loop.\n  // Such cases are presumably rare, and hint at missing oppurtunities for\n  // other passes. \n\n  if (SE->isLoopInvariant(S, L))\n    // Note: This the SCEV variant, so the original Value* may be within the\n    // loop even though SCEV has proven it is loop invariant.\n    return true;\n\n  // Handle a particular important case which SCEV doesn't yet know about which\n  // shows up in range checks on arrays with immutable lengths.  \n  // TODO: This should be sunk inside SCEV.\n  if (const SCEVUnknown *U = dyn_cast<SCEVUnknown>(S))\n    if (const auto *LI = dyn_cast<LoadInst>(U->getValue()))\n",
        "suffix": "        if (AA->pointsToConstantMemory(LI->getOperand(0)) ||\n            LI->getMetadata(LLVMContext::MD_invariant_load) != nullptr)\n          return true;\n  return false;\n}\n",
        "start": 483,
        "end": 518,
        "buggy": "bool LoopPredication::isLoopInvariantValue(const SCEV* S) { \n  // Handling expressions which produce invariant results, but *haven't* yet\n  // been removed from the loop serves two important purposes.\n  // 1) Most importantly, it resolves a pass ordering cycle which would\n  // otherwise need us to iteration licm, loop-predication, and either\n  // loop-unswitch or loop-peeling to make progress on examples with lots of\n  // predicable range checks in a row.  (Since, in the general case,  we can't\n  // hoist the length checks until the dominating checks have been discharged\n  // as we can't prove doing so is safe.)\n  // 2) As a nice side effect, this exposes the value of peeling or unswitching\n  // much more obviously in the IR.  Otherwise, the cost modeling for other\n  // transforms would end up needing to duplicate all of this logic to model a\n  // check which becomes predictable based on a modeled peel or unswitch.\n  // \n  // The cost of doing so in the worst case is an extra fill from the stack  in\n  // the loop to materialize the loop invariant test value instead of checking\n  // against the original IV which is presumable in a register inside the loop.\n  // Such cases are presumably rare, and hint at missing oppurtunities for\n  // other passes. \n\n  if (SE->isLoopInvariant(S, L))\n    // Note: This the SCEV variant, so the original Value* may be within the\n    // loop even though SCEV has proven it is loop invariant.\n    return true;\n\n  // Handle a particular important case which SCEV doesn't yet know about which\n  // shows up in range checks on arrays with immutable lengths.  \n  // TODO: This should be sunk inside SCEV.\n  if (const SCEVUnknown *U = dyn_cast<SCEVUnknown>(S))\n    if (const auto *LI = dyn_cast<LoadInst>(U->getValue()))\n      if (LI->isUnordered())\n        if (AA->pointsToConstantMemory(LI->getOperand(0)) ||\n            LI->getMetadata(LLVMContext::MD_invariant_load) != nullptr)\n          return true;\n  return false;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      if (LI->isUnordered())\n",
        "src_path": "adf288c5d93e60a91fe226ae2dcebad0f760a259___LoopPredication.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/adf288c5d93e60a91fe226ae2dcebad0f760a259",
        "commit_msg": "[LoopPred] Fix a blatantly obvious bug in r358684\n\nThe bug is that I didn't check whether the operand of the invariant_loads were themselves invariant.  I don't know how this got missed in the patch and review.  I even had an unreduced test case locally, and I remember handling this case, but I must have lost it in one of the rebases.  Oops.\n\nllvm-svn: 358688",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/LoopPredication/invariant_load.ll",
                "patch": "@@ -126,6 +126,70 @@ exit:\n   ret i32 %result\n }\n \n+; Case where we have an invariant load, but it's not loading from a loop\n+; invariant location.\n+define i32 @neg_varying_invariant_load_op(i32* %array, i32* %lengths, i32 %n) {\n+; CHECK-LABEL: @neg_varying_invariant_load_op(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    [[TMP5:%.*]] = icmp eq i32 [[N:%.*]], 0\n+; CHECK-NEXT:    br i1 [[TMP5]], label [[EXIT:%.*]], label [[LOOP_PREHEADER:%.*]]\n+; CHECK:       loop.preheader:\n+; CHECK-NEXT:    br label [[LOOP:%.*]]\n+; CHECK:       loop:\n+; CHECK-NEXT:    [[LOOP_ACC:%.*]] = phi i32 [ [[LOOP_ACC_NEXT:%.*]], [[LOOP]] ], [ 0, [[LOOP_PREHEADER]] ]\n+; CHECK-NEXT:    [[I:%.*]] = phi i32 [ [[I_NEXT:%.*]], [[LOOP]] ], [ 0, [[LOOP_PREHEADER]] ]\n+; CHECK-NEXT:    [[UNKNOWN:%.*]] = load volatile i1, i1* @UNKNOWN\n+; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 [[UNKNOWN]]) [ \"deopt\"() ]\n+; CHECK-NEXT:    [[LENGTH_ADDR:%.*]] = getelementptr i32, i32* [[LENGTHS:%.*]], i32 [[I]]\n+; CHECK-NEXT:    [[LEN:%.*]] = load i32, i32* [[LENGTH_ADDR]], align 4, !invariant.load !0\n+; CHECK-NEXT:    [[WITHIN_BOUNDS:%.*]] = icmp ult i32 [[I]], [[LEN]]\n+; CHECK-NEXT:    call void (i1, ...) @llvm.experimental.guard(i1 [[WITHIN_BOUNDS]], i32 9) [ \"deopt\"() ]\n+; CHECK-NEXT:    [[I_I64:%.*]] = zext i32 [[I]] to i64\n+; CHECK-NEXT:    [[ARRAY_I_PTR:%.*]] = getelementptr inbounds i32, i32* [[ARRAY:%.*]], i64 [[I_I64]]\n+; CHECK-NEXT:    [[ARRAY_I:%.*]] = load i32, i32* [[ARRAY_I_PTR]], align 4\n+; CHECK-NEXT:    [[LOOP_ACC_NEXT]] = add i32 [[LOOP_ACC]], [[ARRAY_I]]\n+; CHECK-NEXT:    [[I_NEXT]] = add nuw i32 [[I]], 1\n+; CHECK-NEXT:    [[CONTINUE:%.*]] = icmp ult i32 [[I_NEXT]], [[N]]\n+; CHECK-NEXT:    br i1 [[CONTINUE]], label [[LOOP]], label [[EXIT_LOOPEXIT:%.*]]\n+; CHECK:       exit.loopexit:\n+; CHECK-NEXT:    [[LOOP_ACC_NEXT_LCSSA:%.*]] = phi i32 [ [[LOOP_ACC_NEXT]], [[LOOP]] ]\n+; CHECK-NEXT:    br label [[EXIT]]\n+; CHECK:       exit:\n+; CHECK-NEXT:    [[RESULT:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[LOOP_ACC_NEXT_LCSSA]], [[EXIT_LOOPEXIT]] ]\n+; CHECK-NEXT:    ret i32 [[RESULT]]\n+;\n+entry:\n+  %tmp5 = icmp eq i32 %n, 0\n+  br i1 %tmp5, label %exit, label %loop.preheader\n+\n+loop.preheader:\n+  br label %loop\n+\n+loop:\n+  %loop.acc = phi i32 [ %loop.acc.next, %loop ], [ 0, %loop.preheader ]\n+  %i = phi i32 [ %i.next, %loop ], [ 0, %loop.preheader ]\n+  %unknown = load volatile i1, i1* @UNKNOWN\n+  call void (i1, ...) @llvm.experimental.guard(i1 %unknown) [ \"deopt\"() ]\n+\n+  %length.addr = getelementptr i32, i32* %lengths, i32 %i\n+  %len = load i32, i32* %length.addr, align 4, !invariant.load !{}\n+  %within.bounds = icmp ult i32 %i, %len\n+  call void (i1, ...) @llvm.experimental.guard(i1 %within.bounds, i32 9) [ \"deopt\"() ]\n+\n+  %i.i64 = zext i32 %i to i64\n+  %array.i.ptr = getelementptr inbounds i32, i32* %array, i64 %i.i64\n+  %array.i = load i32, i32* %array.i.ptr, align 4\n+  %loop.acc.next = add i32 %loop.acc, %array.i\n+\n+  %i.next = add nuw i32 %i, 1\n+  %continue = icmp ult i32 %i.next, %n\n+  br i1 %continue, label %loop, label %exit\n+\n+exit:\n+  %result = phi i32 [ 0, %entry ], [ %loop.acc.next, %loop ]\n+  ret i32 %result\n+}\n+\n ; This is a case where moving the load which provides the limit for the latch\n ; would be invalid, so we can't preform the tempting transform.  Loading the\n ; latch limit may fault since we could always fail the guard."
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/LoopPredication/invariant_load.ll (1 of 1)\nTesting Time: 0.26s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LoopPredication/invariant_load.ll\n\n  Unexpected Failures: 1\n"
    },
    "8535bed79504ffe3ed7f2de8c158a17e79e54736___DwarfDebug.cpp": {
        "prefix": "static void collectCallSiteParameters(const MachineInstr *CallMI,\n                                      ParamSet &Params) {\n  auto *MF = CallMI->getMF();\n  auto CalleesMap = MF->getCallSitesInfo();\n  auto CallFwdRegsInfo = CalleesMap.find(CallMI);\n\n  // There is no information for the call instruction.\n  if (CallFwdRegsInfo == CalleesMap.end())\n    return;\n\n  auto *MBB = CallMI->getParent();\n  const auto &TRI = MF->getSubtarget().getRegisterInfo();\n  const auto &TII = MF->getSubtarget().getInstrInfo();\n  const auto &TLI = MF->getSubtarget().getTargetLowering();\n\n  // Skip the call instruction.\n  auto I = std::next(CallMI->getReverseIterator());\n\n  DenseSet<unsigned> ForwardedRegWorklist;\n  // Add all the forwarding registers into the ForwardedRegWorklist.\n  for (auto ArgReg : CallFwdRegsInfo->second) {\n    bool InsertedReg = ForwardedRegWorklist.insert(ArgReg.Reg).second;\n    assert(InsertedReg && \"Single register used to forward two arguments?\");\n    (void)InsertedReg;\n  }\n\n  // We erase, from the ForwardedRegWorklist, those forwarding registers for\n  // which we successfully describe a loaded value (by using\n  // the describeLoadedValue()). For those remaining arguments in the working\n  // list, for which we do not describe a loaded value by\n  // the describeLoadedValue(), we try to generate an entry value expression\n  // for their call site value desctipion, if the call is within the entry MBB.\n  // The RegsForEntryValues maps a forwarding register into the register holding\n  // the entry value.\n  // TODO: Handle situations when call site parameter value can be described\n  // as the entry value within basic blocks other then the first one.\n  bool ShouldTryEmitEntryVals = MBB->getIterator() == MF->begin();\n  DenseMap<unsigned, unsigned> RegsForEntryValues;\n\n  // If the MI is an instruction defining one or more parameters' forwarding\n  // registers, add those defines. We can currently only describe forwarded\n  // registers that are explicitly defined, but keep track of implicit defines\n  // also to remove those registers from the work list.\n  auto getForwardingRegsDefinedByMI = [&](const MachineInstr &MI,\n                                          SmallVectorImpl<unsigned> &Explicit,\n                                          SmallVectorImpl<unsigned> &Implicit) {\n    if (MI.isDebugInstr())\n      return;\n\n    for (const MachineOperand &MO : MI.operands()) {\n      if (MO.isReg() && MO.isDef() &&\n          Register::isPhysicalRegister(MO.getReg())) {\n        for (auto FwdReg : ForwardedRegWorklist) {\n          if (TRI->regsOverlap(FwdReg, MO.getReg())) {\n            if (MO.isImplicit())\n              Implicit.push_back(FwdReg);\n            else\n              Explicit.push_back(FwdReg);\n            break;\n          }\n        }\n      }\n    }\n  };\n\n  auto finishCallSiteParam = [&](DbgValueLoc DbgLocVal, unsigned Reg) {\n    unsigned FwdReg = Reg;\n    if (ShouldTryEmitEntryVals) {\n      auto EntryValReg = RegsForEntryValues.find(Reg);\n      if (EntryValReg != RegsForEntryValues.end())\n        FwdReg = EntryValReg->second;\n    }\n\n    DbgCallSiteParam CSParm(FwdReg, DbgLocVal);\n    Params.push_back(CSParm);\n    ++NumCSParams;\n  };\n\n  // Search for a loading value in forwaring registers.\n  for (; I != MBB->rend(); ++I) {\n    // If the next instruction is a call we can not interpret parameter's\n    // forwarding registers or we finished the interpretation of all parameters.\n    if (I->isCall())\n      return;\n\n    if (ForwardedRegWorklist.empty())\n      return;\n\n    SmallVector<unsigned, 4> ExplicitFwdRegDefs;\n    SmallVector<unsigned, 4> ImplicitFwdRegDefs;\n    getForwardingRegsDefinedByMI(*I, ExplicitFwdRegDefs, ImplicitFwdRegDefs);\n    if (ExplicitFwdRegDefs.empty() && ImplicitFwdRegDefs.empty())\n      continue;\n\n    // If the MI clobbers more then one forwarding register we must remove\n    // all of them from the working list.\n    for (auto Reg : concat<unsigned>(ExplicitFwdRegDefs, ImplicitFwdRegDefs))\n      ForwardedRegWorklist.erase(Reg);\n\n    // The describeLoadedValue() hook currently does not have any information\n    // about which register it should describe in case of multiple defines, so\n    // for now we only handle instructions where a forwarded register is (at\n    // least partially) defined by the instruction's single explicit define.\n    if (I->getNumExplicitDefs() != 1 || ExplicitFwdRegDefs.empty())\n      continue;\n    unsigned Reg = ExplicitFwdRegDefs[0];\n\n    if (auto ParamValue = TII->describeLoadedValue(*I)) {\n      if (ParamValue->first.isImm()) {\n",
        "suffix": "        DbgValueLoc DbgLocVal(ParamValue->second, Val);\n        finishCallSiteParam(DbgLocVal, Reg);\n      } else if (ParamValue->first.isReg()) {\n        Register RegLoc = ParamValue->first.getReg();\n        unsigned SP = TLI->getStackPointerRegisterToSaveRestore();\n        Register FP = TRI->getFrameRegister(*MF);\n        bool IsSPorFP = (RegLoc == SP) || (RegLoc == FP);\n        if (TRI->isCalleeSavedPhysReg(RegLoc, *MF) || IsSPorFP) {\n          DbgValueLoc DbgLocVal(ParamValue->second,\n                                MachineLocation(RegLoc,\n                                                /*IsIndirect=*/IsSPorFP));\n          finishCallSiteParam(DbgLocVal, Reg);\n        } else if (ShouldTryEmitEntryVals) {\n          ForwardedRegWorklist.insert(RegLoc);\n          RegsForEntryValues[RegLoc] = Reg;\n        }\n      }\n    }\n  }\n\n  // Emit the call site parameter's value as an entry value.\n  if (ShouldTryEmitEntryVals) {\n    // Create an entry value expression where the expression following\n    // the 'DW_OP_entry_value' will be the size of 1 (a register operation).\n    DIExpression *EntryExpr = DIExpression::get(MF->getFunction().getContext(),\n                                                {dwarf::DW_OP_entry_value, 1});\n    for (auto RegEntry : ForwardedRegWorklist) {\n      unsigned FwdReg = RegEntry;\n      auto EntryValReg = RegsForEntryValues.find(RegEntry);\n        if (EntryValReg != RegsForEntryValues.end())\n          FwdReg = EntryValReg->second;\n\n      DbgValueLoc DbgLocVal(EntryExpr, MachineLocation(RegEntry));\n      DbgCallSiteParam CSParm(FwdReg, DbgLocVal);\n      Params.push_back(CSParm);\n      ++NumCSParams;\n    }\n  }\n}\n",
        "start": 514,
        "end": 662,
        "buggy": "static void collectCallSiteParameters(const MachineInstr *CallMI,\n                                      ParamSet &Params) {\n  auto *MF = CallMI->getMF();\n  auto CalleesMap = MF->getCallSitesInfo();\n  auto CallFwdRegsInfo = CalleesMap.find(CallMI);\n\n  // There is no information for the call instruction.\n  if (CallFwdRegsInfo == CalleesMap.end())\n    return;\n\n  auto *MBB = CallMI->getParent();\n  const auto &TRI = MF->getSubtarget().getRegisterInfo();\n  const auto &TII = MF->getSubtarget().getInstrInfo();\n  const auto &TLI = MF->getSubtarget().getTargetLowering();\n\n  // Skip the call instruction.\n  auto I = std::next(CallMI->getReverseIterator());\n\n  DenseSet<unsigned> ForwardedRegWorklist;\n  // Add all the forwarding registers into the ForwardedRegWorklist.\n  for (auto ArgReg : CallFwdRegsInfo->second) {\n    bool InsertedReg = ForwardedRegWorklist.insert(ArgReg.Reg).second;\n    assert(InsertedReg && \"Single register used to forward two arguments?\");\n    (void)InsertedReg;\n  }\n\n  // We erase, from the ForwardedRegWorklist, those forwarding registers for\n  // which we successfully describe a loaded value (by using\n  // the describeLoadedValue()). For those remaining arguments in the working\n  // list, for which we do not describe a loaded value by\n  // the describeLoadedValue(), we try to generate an entry value expression\n  // for their call site value desctipion, if the call is within the entry MBB.\n  // The RegsForEntryValues maps a forwarding register into the register holding\n  // the entry value.\n  // TODO: Handle situations when call site parameter value can be described\n  // as the entry value within basic blocks other then the first one.\n  bool ShouldTryEmitEntryVals = MBB->getIterator() == MF->begin();\n  DenseMap<unsigned, unsigned> RegsForEntryValues;\n\n  // If the MI is an instruction defining one or more parameters' forwarding\n  // registers, add those defines. We can currently only describe forwarded\n  // registers that are explicitly defined, but keep track of implicit defines\n  // also to remove those registers from the work list.\n  auto getForwardingRegsDefinedByMI = [&](const MachineInstr &MI,\n                                          SmallVectorImpl<unsigned> &Explicit,\n                                          SmallVectorImpl<unsigned> &Implicit) {\n    if (MI.isDebugInstr())\n      return;\n\n    for (const MachineOperand &MO : MI.operands()) {\n      if (MO.isReg() && MO.isDef() &&\n          Register::isPhysicalRegister(MO.getReg())) {\n        for (auto FwdReg : ForwardedRegWorklist) {\n          if (TRI->regsOverlap(FwdReg, MO.getReg())) {\n            if (MO.isImplicit())\n              Implicit.push_back(FwdReg);\n            else\n              Explicit.push_back(FwdReg);\n            break;\n          }\n        }\n      }\n    }\n  };\n\n  auto finishCallSiteParam = [&](DbgValueLoc DbgLocVal, unsigned Reg) {\n    unsigned FwdReg = Reg;\n    if (ShouldTryEmitEntryVals) {\n      auto EntryValReg = RegsForEntryValues.find(Reg);\n      if (EntryValReg != RegsForEntryValues.end())\n        FwdReg = EntryValReg->second;\n    }\n\n    DbgCallSiteParam CSParm(FwdReg, DbgLocVal);\n    Params.push_back(CSParm);\n    ++NumCSParams;\n  };\n\n  // Search for a loading value in forwaring registers.\n  for (; I != MBB->rend(); ++I) {\n    // If the next instruction is a call we can not interpret parameter's\n    // forwarding registers or we finished the interpretation of all parameters.\n    if (I->isCall())\n      return;\n\n    if (ForwardedRegWorklist.empty())\n      return;\n\n    SmallVector<unsigned, 4> ExplicitFwdRegDefs;\n    SmallVector<unsigned, 4> ImplicitFwdRegDefs;\n    getForwardingRegsDefinedByMI(*I, ExplicitFwdRegDefs, ImplicitFwdRegDefs);\n    if (ExplicitFwdRegDefs.empty() && ImplicitFwdRegDefs.empty())\n      continue;\n\n    // If the MI clobbers more then one forwarding register we must remove\n    // all of them from the working list.\n    for (auto Reg : concat<unsigned>(ExplicitFwdRegDefs, ImplicitFwdRegDefs))\n      ForwardedRegWorklist.erase(Reg);\n\n    // The describeLoadedValue() hook currently does not have any information\n    // about which register it should describe in case of multiple defines, so\n    // for now we only handle instructions where a forwarded register is (at\n    // least partially) defined by the instruction's single explicit define.\n    if (I->getNumExplicitDefs() != 1 || ExplicitFwdRegDefs.empty())\n      continue;\n    unsigned Reg = ExplicitFwdRegDefs[0];\n\n    if (auto ParamValue = TII->describeLoadedValue(*I)) {\n      if (ParamValue->first.isImm()) {\n        unsigned Val = ParamValue->first.getImm();\n        DbgValueLoc DbgLocVal(ParamValue->second, Val);\n        finishCallSiteParam(DbgLocVal, Reg);\n      } else if (ParamValue->first.isReg()) {\n        Register RegLoc = ParamValue->first.getReg();\n        unsigned SP = TLI->getStackPointerRegisterToSaveRestore();\n        Register FP = TRI->getFrameRegister(*MF);\n        bool IsSPorFP = (RegLoc == SP) || (RegLoc == FP);\n        if (TRI->isCalleeSavedPhysReg(RegLoc, *MF) || IsSPorFP) {\n          DbgValueLoc DbgLocVal(ParamValue->second,\n                                MachineLocation(RegLoc,\n                                                /*IsIndirect=*/IsSPorFP));\n          finishCallSiteParam(DbgLocVal, Reg);\n        } else if (ShouldTryEmitEntryVals) {\n          ForwardedRegWorklist.insert(RegLoc);\n          RegsForEntryValues[RegLoc] = Reg;\n        }\n      }\n    }\n  }\n\n  // Emit the call site parameter's value as an entry value.\n  if (ShouldTryEmitEntryVals) {\n    // Create an entry value expression where the expression following\n    // the 'DW_OP_entry_value' will be the size of 1 (a register operation).\n    DIExpression *EntryExpr = DIExpression::get(MF->getFunction().getContext(),\n                                                {dwarf::DW_OP_entry_value, 1});\n    for (auto RegEntry : ForwardedRegWorklist) {\n      unsigned FwdReg = RegEntry;\n      auto EntryValReg = RegsForEntryValues.find(RegEntry);\n        if (EntryValReg != RegsForEntryValues.end())\n          FwdReg = EntryValReg->second;\n\n      DbgValueLoc DbgLocVal(EntryExpr, MachineLocation(RegEntry));\n      DbgCallSiteParam CSParm(FwdReg, DbgLocVal);\n      Params.push_back(CSParm);\n      ++NumCSParams;\n    }\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        unsigned Val = ParamValue->first.getImm();\n",
        "src_path": "8535bed79504ffe3ed7f2de8c158a17e79e54736___DwarfDebug.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/8535bed79504ffe3ed7f2de8c158a17e79e54736",
        "commit_msg": "[DebugInfo] Fix truncation of call site immediates\n\nSummary:\nThis addresses a bug in collectCallSiteParameters() where call site\nimmediates would be truncated from int64_t to unsigned.\n\nThis fixes PR43525.\n\nReviewers: djtodoro, NikolaPrica, aprantl, vsk\n\nReviewed By: aprantl\n\nSubscribers: hiraditya, llvm-commits\n\nTags: #debug-info, #llvm\n\nDifferential Revision: https://reviews.llvm.org/D68869\n\nllvm-svn: 374770",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/X86/dbgcall-site-64-bit-imms.ll",
                "patch": "@@ -0,0 +1,56 @@\n+; RUN: llc -O1 -debug-entry-values -filetype=obj -o - %s | llvm-dwarfdump - | FileCheck %s\n+\n+; Verify that the 64-bit call site immediates are not truncated.\n+;\n+; Reproducer for PR43525.\n+\n+; Based on the following C program:\n+;\n+; #include <stdint.h>\n+;\n+; extern void foo(int64_t);\n+;\n+; int main() {\n+;   foo(INT64_C(0x1122334455667788));\n+;   foo(INT32_C(-100));\n+; }\n+\n+; CHECK: DW_AT_GNU_call_site_value (DW_OP_constu 0x1122334455667788)\n+; CHECK: DW_AT_GNU_call_site_value (DW_OP_constu 0xffffffffffffff9c)\n+\n+target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n+target triple = \"x86_64-unknown-linux-gnu\"\n+\n+; Function Attrs: nounwind uwtable\n+define i32 @main() !dbg !12 {\n+entry:\n+  tail call void @foo(i64 1234605616436508552), !dbg !16\n+  tail call void @foo(i64 -100), !dbg !17\n+  ret i32 0, !dbg !18\n+}\n+\n+declare !dbg !4 void @foo(i64)\n+\n+!llvm.dbg.cu = !{!0}\n+!llvm.module.flags = !{!8, !9, !10}\n+!llvm.ident = !{!11}\n+\n+!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: \"clang version 10.0.0\", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, retainedTypes: !3, nameTableKind: None)\n+!1 = !DIFile(filename: \"dbgcall-site-long-imms.c\", directory: \"/\")\n+!2 = !{}\n+!3 = !{!4}\n+!4 = !DISubprogram(name: \"foo\", scope: !1, file: !1, line: 3, type: !5, flags: DIFlagPrototyped, spFlags: DISPFlagOptimized, retainedNodes: !2)\n+!5 = !DISubroutineType(types: !6)\n+!6 = !{null, !7}\n+!7 = !DIBasicType(name: \"long int\", size: 64, encoding: DW_ATE_signed)\n+!8 = !{i32 2, !\"Dwarf Version\", i32 4}\n+!9 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!10 = !{i32 1, !\"wchar_size\", i32 4}\n+!11 = !{!\"clang version 10.0.0\"}\n+!12 = distinct !DISubprogram(name: \"main\", scope: !1, file: !1, line: 5, type: !13, scopeLine: 5, flags: DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !2)\n+!13 = !DISubroutineType(types: !14)\n+!14 = !{!15}\n+!15 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n+!16 = !DILocation(line: 6, scope: !12)\n+!17 = !DILocation(line: 7, scope: !12)\n+!18 = !DILocation(line: 8, scope: !12)"
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/X86/dbgcall-site-64-bit-imms.ll (1 of 1)\nTesting Time: 0.76s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/dbgcall-site-64-bit-imms.ll\n\n  Unexpected Failures: 1\n"
    },
    "8723b95cefa4f2a891c2b496dca79f1734cf1d1c___X86FrameLowering.cpp": {
        "prefix": "int X86FrameLowering::getWin64EHFrameIndexRef(const MachineFunction &MF,\n                                              int FI, unsigned &FrameReg) const {\n  const MachineFrameInfo &MFI = MF.getFrameInfo();\n  const X86MachineFunctionInfo *X86FI = MF.getInfo<X86MachineFunctionInfo>();\n  const auto& WinEHXMMSlotInfo = X86FI->getWinEHXMMSlotInfo();\n  const auto it = WinEHXMMSlotInfo.find(FI);\n\n  if (it == WinEHXMMSlotInfo.end())\n    return getFrameIndexReference(MF, FI, FrameReg);\n\n  FrameReg = TRI->getStackRegister();\n",
        "suffix": "}\n",
        "start": 1852,
        "end": 1864,
        "buggy": "int X86FrameLowering::getWin64EHFrameIndexRef(const MachineFunction &MF,\n                                              int FI, unsigned &FrameReg) const {\n  const MachineFrameInfo &MFI = MF.getFrameInfo();\n  const X86MachineFunctionInfo *X86FI = MF.getInfo<X86MachineFunctionInfo>();\n  const auto& WinEHXMMSlotInfo = X86FI->getWinEHXMMSlotInfo();\n  const auto it = WinEHXMMSlotInfo.find(FI);\n\n  if (it == WinEHXMMSlotInfo.end())\n    return getFrameIndexReference(MF, FI, FrameReg);\n\n  FrameReg = TRI->getStackRegister();\n  return alignTo(MFI.getMaxCallFrameSize(), getStackAlignment()) + it->second;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  return alignTo(MFI.getMaxCallFrameSize(), getStackAlignment()) + it->second;\n",
        "src_path": "8723b95cefa4f2a891c2b496dca79f1734cf1d1c___X86FrameLowering.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/8723b95cefa4f2a891c2b496dca79f1734cf1d1c",
        "commit_msg": "[WinEH] Fix the wrong alignment orientation during calculating EH frame.\n\nSummary: This is a bug fix for further issues in PR43585.\n\nReviewers: rnk, RKSimon, craig.topper, andrew.w.kaylor\n\nSubscribers: hiraditya, llvm-commits, annita.zhang\n\nTags: #llvm\n\nDifferential Revision: https://reviews.llvm.org/D70224",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/win64-funclet-savexmm.ll",
                "patch": "@@ -85,17 +85,17 @@ try.cont:                                         ; preds = %catchret.dest, %inv\n ; CHECK: subq    $88, %rsp\n ; CHECK: .seh_stackalloc 88\n ; CHECK: leaq    112(%rdx), %rbp\n-; CHECK: vmovaps %xmm8, 48(%rsp)\n-; CHECK: .seh_savexmm %xmm8, 48\n-; CHECK: vmovaps %xmm7, 64(%rsp)\n-; CHECK: .seh_savexmm %xmm7, 64\n-; CHECK: vmovaps %xmm6, 80(%rsp)\n-; CHECK: .seh_savexmm %xmm6, 80\n+; CHECK: vmovaps %xmm8, 32(%rsp)\n+; CHECK: .seh_savexmm %xmm8, 32\n+; CHECK: vmovaps %xmm7, 48(%rsp)\n+; CHECK: .seh_savexmm %xmm7, 48\n+; CHECK: vmovaps %xmm6, 64(%rsp)\n+; CHECK: .seh_savexmm %xmm6, 64\n ; CHECK: .seh_endprologue\n ; CHECK: movl   -{{[0-9]+}}(%rbp), %ecx\n-; CHECK: vmovaps 80(%rsp), %xmm6\n-; CHECK: vmovaps 64(%rsp), %xmm7\n-; CHECK: vmovaps 48(%rsp), %xmm8\n+; CHECK: vmovaps 64(%rsp), %xmm6\n+; CHECK: vmovaps 48(%rsp), %xmm7\n+; CHECK: vmovaps 32(%rsp), %xmm8\n ; CHECK: leaq    .LBB0_1(%rip), %rax\n ; CHECK: addq    $88, %rsp\n ; CHECK: popq    %rbx"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/win64-funclet-savexmm.ll (1 of 1)\n\nTesting Time: 0.50s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/win64-funclet-savexmm.ll\n\n  Unexpected Failures: 1\n"
    },
    "1a58be2ac58ca078c91c9d1700220d88091b256f___JumpThreading.cpp": {
        "prefix": "PreservedAnalyses JumpThreadingPass::run(Function &F,\n                                         FunctionAnalysisManager &AM) {\n  auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);\n  // Get DT analysis before LVI. When LVI is initialized it conditionally adds\n  // DT if it's available.\n  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);\n  auto &LVI = AM.getResult<LazyValueAnalysis>(F);\n  auto &AA = AM.getResult<AAManager>(F);\n  DomTreeUpdater DTU(DT, DomTreeUpdater::UpdateStrategy::Lazy);\n\n  std::unique_ptr<BlockFrequencyInfo> BFI;\n  std::unique_ptr<BranchProbabilityInfo> BPI;\n  if (F.hasProfileData()) {\n    LoopInfo LI{DominatorTree(F)};\n    BPI.reset(new BranchProbabilityInfo(F, LI, &TLI));\n    BFI.reset(new BlockFrequencyInfo(F, *BPI, LI));\n  }\n\n",
        "suffix": "                         std::move(BFI), std::move(BPI));\n\n  if (!Changed)\n    return PreservedAnalyses::all();\n  PreservedAnalyses PA;\n  PA.preserve<GlobalsAA>();\n  PA.preserve<DominatorTreeAnalysis>();\n  PA.preserve<LazyValueAnalysis>();\n  return PA;\n}\n",
        "start": 325,
        "end": 353,
        "buggy": "PreservedAnalyses JumpThreadingPass::run(Function &F,\n                                         FunctionAnalysisManager &AM) {\n  auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);\n  // Get DT analysis before LVI. When LVI is initialized it conditionally adds\n  // DT if it's available.\n  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);\n  auto &LVI = AM.getResult<LazyValueAnalysis>(F);\n  auto &AA = AM.getResult<AAManager>(F);\n  DomTreeUpdater DTU(DT, DomTreeUpdater::UpdateStrategy::Lazy);\n\n  std::unique_ptr<BlockFrequencyInfo> BFI;\n  std::unique_ptr<BranchProbabilityInfo> BPI;\n  if (F.hasProfileData()) {\n    LoopInfo LI{DominatorTree(F)};\n    BPI.reset(new BranchProbabilityInfo(F, LI, &TLI));\n    BFI.reset(new BlockFrequencyInfo(F, *BPI, LI));\n  }\n\n  bool Changed = runImpl(F, &TLI, &LVI, &AA, &DTU, HasProfileData,\n                         std::move(BFI), std::move(BPI));\n\n  if (!Changed)\n    return PreservedAnalyses::all();\n  PreservedAnalyses PA;\n  PA.preserve<GlobalsAA>();\n  PA.preserve<DominatorTreeAnalysis>();\n  PA.preserve<LazyValueAnalysis>();\n  return PA;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  bool Changed = runImpl(F, &TLI, &LVI, &AA, &DTU, HasProfileData,\n",
        "src_path": "1a58be2ac58ca078c91c9d1700220d88091b256f___JumpThreading.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/1a58be2ac58ca078c91c9d1700220d88091b256f",
        "commit_msg": "[JumpThreading] Use profile data even with the new pass manager\n\nSummary:\nWithout this patch, the jump threading pass ignores profiling data\nwhenever we invoke the pass with the new pass manager.\n\nSpecifically, JumpThreadingPass::run calls runImpl with class variable\nHasProfileData always set to false.  In turn, runImpl sets\nHasProfileData to false again:\n\n  HasProfileData = HasProfileData_;\n\nIn the end, we don't use profiling data at all with the new pass\nmanager.\n\nThis patch fixes the problem by passing F.hasProfileData() to runImpl.\n\nThe bug appears to have been introduced at:\n\n  https://reviews.llvm.org/D41461\n\nwhich removed local variable HasProfileData in JumpThreadingPass::run\neven though there was one more use left in the same function.  As a\nresult, the remaining use ended referring to the class variable\ninstead.\n\nNote that F.hasProfileData is an extremely lightweight function, so I\ndon't see the need to cache its result.  Once this patch is approved,\nI'm planning to stop caching the result of F.hasProfileData in\nrunOnFunction.\n\nReviewers: wmi, eli.friedman\n\nSubscribers: hiraditya, jfb, llvm-commits\n\nTags: #llvm\n\nDifferential Revision: https://reviews.llvm.org/D70509",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/JumpThreading/update-edge-weight.ll",
                "patch": "@@ -1,4 +1,5 @@\n ; RUN: opt -S -jump-threading %s | FileCheck %s\n+; RUN: opt -S -passes=jump-threading %s | FileCheck %s\n \n ; Test if edge weights are properly updated after jump threading.\n "
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/JumpThreading/update-edge-weight.ll (1 of 1)\n\nTesting Time: 0.37s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/JumpThreading/update-edge-weight.ll\n\n  Unexpected Failures: 1\n"
    },
    "e420c0c78eb0700989c8ba80e845b6306d66bb5f___FunctionImportUtils.cpp": {
        "prefix": "void FunctionImportGlobalProcessing::processGlobalForThinLTO(GlobalValue &GV) {\n\n  ValueInfo VI;\n  if (GV.hasName()) {\n    VI = ImportIndex.getValueInfo(GV.getGUID());\n    // Set synthetic function entry counts.\n    if (VI && ImportIndex.hasSyntheticEntryCounts()) {\n      if (Function *F = dyn_cast<Function>(&GV)) {\n        if (!F->isDeclaration()) {\n          for (auto &S : VI.getSummaryList()) {\n            auto *FS = cast<FunctionSummary>(S->getBaseObject());\n            if (FS->modulePath() == M.getModuleIdentifier()) {\n              F->setEntryCount(Function::ProfileCount(FS->entryCount(),\n                                                      Function::PCT_Synthetic));\n              break;\n            }\n          }\n        }\n      }\n    }\n    // Check the summaries to see if the symbol gets resolved to a known local\n    // definition.\n    if (VI && VI.isDSOLocal()) {\n      GV.setDSOLocal(true);\n      if (GV.hasDLLImportStorageClass())\n        GV.setDLLStorageClass(GlobalValue::DefaultStorageClass);\n    }\n  }\n\n  // We should always have a ValueInfo (i.e. GV in index) for definitions when\n  // we are exporting, and also when importing that value.\n  assert(VI || GV.isDeclaration() ||\n         (isPerformingImport() && !doImportAsDefinition(&GV)));\n\n  // Mark read/write-only variables which can be imported with specific\n  // attribute. We can't internalize them now because IRMover will fail\n  // to link variable definitions to their external declarations during\n  // ThinLTO import. We'll internalize read-only variables later, after\n  // import is finished. See internalizeGVsAfterImport.\n  //\n  // If global value dead stripping is not enabled in summary then\n  // propagateConstants hasn't been run. We can't internalize GV\n  // in such case.\n  if (!GV.isDeclaration() && VI && ImportIndex.withAttributePropagation()) {\n    if (GlobalVariable *V = dyn_cast<GlobalVariable>(&GV)) {\n      // We can have more than one local with the same GUID, in the case of\n      // same-named locals in different but same-named source files that were\n      // compiled in their respective directories (so the source file name\n      // and resulting GUID is the same). Find the one in this module.\n      // Handle the case where there is no summary found in this module. That\n      // can happen in the distributed ThinLTO backend, because the index only\n      // contains summaries from the source modules if they are being imported.\n      // We might have a non-null VI and get here even in that case if the name\n      // matches one in this module (e.g. weak or appending linkage).\n      auto *GVS = dyn_cast_or_null<GlobalVarSummary>(\n          ImportIndex.findSummaryInModule(VI, M.getModuleIdentifier()));\n      if (GVS &&\n          (ImportIndex.isReadOnly(GVS) || ImportIndex.isWriteOnly(GVS))) {\n        V->addAttribute(\"thinlto-internalize\");\n        // Objects referenced by writeonly GV initializer should not be\n        // promoted, because there is no any kind of read access to them\n        // on behalf of this writeonly GV. To avoid promotion we convert\n        // GV initializer to 'zeroinitializer'. This effectively drops\n        // references in IR module (not in combined index), so we can\n        // ignore them when computing import. We do not export references\n        // of writeonly object. See computeImportForReferencedGlobals\n",
        "suffix": "          V->setInitializer(Constant::getNullValue(V->getValueType()));\n      }\n    }\n  }\n\n  if (GV.hasLocalLinkage() && shouldPromoteLocalToGlobal(&GV, VI)) {\n    // Save the original name string before we rename GV below.\n    auto Name = GV.getName().str();\n    GV.setName(getPromotedName(&GV));\n    GV.setLinkage(getLinkage(&GV, /* DoPromote */ true));\n    assert(!GV.hasLocalLinkage());\n    GV.setVisibility(GlobalValue::HiddenVisibility);\n\n    // If we are renaming a COMDAT leader, ensure that we record the COMDAT\n    // for later renaming as well. This is required for COFF.\n    if (const auto *C = GV.getComdat())\n      if (C->getName() == Name)\n        RenamedComdats.try_emplace(C, M.getOrInsertComdat(GV.getName()));\n  } else\n    GV.setLinkage(getLinkage(&GV, /* DoPromote */ false));\n\n  // Remove functions imported as available externally defs from comdats,\n  // as this is a declaration for the linker, and will be dropped eventually.\n  // It is illegal for comdats to contain declarations.\n  auto *GO = dyn_cast<GlobalObject>(&GV);\n  if (GO && GO->isDeclarationForLinker() && GO->hasComdat()) {\n    // The IRMover should not have placed any imported declarations in\n    // a comdat, so the only declaration that should be in a comdat\n    // at this point would be a definition imported as available_externally.\n    assert(GO->hasAvailableExternallyLinkage() &&\n           \"Expected comdat on definition (possibly available external)\");\n    GO->setComdat(nullptr);\n  }\n}\n",
        "start": 195,
        "end": 295,
        "buggy": "void FunctionImportGlobalProcessing::processGlobalForThinLTO(GlobalValue &GV) {\n\n  ValueInfo VI;\n  if (GV.hasName()) {\n    VI = ImportIndex.getValueInfo(GV.getGUID());\n    // Set synthetic function entry counts.\n    if (VI && ImportIndex.hasSyntheticEntryCounts()) {\n      if (Function *F = dyn_cast<Function>(&GV)) {\n        if (!F->isDeclaration()) {\n          for (auto &S : VI.getSummaryList()) {\n            auto *FS = cast<FunctionSummary>(S->getBaseObject());\n            if (FS->modulePath() == M.getModuleIdentifier()) {\n              F->setEntryCount(Function::ProfileCount(FS->entryCount(),\n                                                      Function::PCT_Synthetic));\n              break;\n            }\n          }\n        }\n      }\n    }\n    // Check the summaries to see if the symbol gets resolved to a known local\n    // definition.\n    if (VI && VI.isDSOLocal()) {\n      GV.setDSOLocal(true);\n      if (GV.hasDLLImportStorageClass())\n        GV.setDLLStorageClass(GlobalValue::DefaultStorageClass);\n    }\n  }\n\n  // We should always have a ValueInfo (i.e. GV in index) for definitions when\n  // we are exporting, and also when importing that value.\n  assert(VI || GV.isDeclaration() ||\n         (isPerformingImport() && !doImportAsDefinition(&GV)));\n\n  // Mark read/write-only variables which can be imported with specific\n  // attribute. We can't internalize them now because IRMover will fail\n  // to link variable definitions to their external declarations during\n  // ThinLTO import. We'll internalize read-only variables later, after\n  // import is finished. See internalizeGVsAfterImport.\n  //\n  // If global value dead stripping is not enabled in summary then\n  // propagateConstants hasn't been run. We can't internalize GV\n  // in such case.\n  if (!GV.isDeclaration() && VI && ImportIndex.withAttributePropagation()) {\n    if (GlobalVariable *V = dyn_cast<GlobalVariable>(&GV)) {\n      // We can have more than one local with the same GUID, in the case of\n      // same-named locals in different but same-named source files that were\n      // compiled in their respective directories (so the source file name\n      // and resulting GUID is the same). Find the one in this module.\n      // Handle the case where there is no summary found in this module. That\n      // can happen in the distributed ThinLTO backend, because the index only\n      // contains summaries from the source modules if they are being imported.\n      // We might have a non-null VI and get here even in that case if the name\n      // matches one in this module (e.g. weak or appending linkage).\n      auto *GVS = dyn_cast_or_null<GlobalVarSummary>(\n          ImportIndex.findSummaryInModule(VI, M.getModuleIdentifier()));\n      if (GVS &&\n          (ImportIndex.isReadOnly(GVS) || ImportIndex.isWriteOnly(GVS))) {\n        V->addAttribute(\"thinlto-internalize\");\n        // Objects referenced by writeonly GV initializer should not be\n        // promoted, because there is no any kind of read access to them\n        // on behalf of this writeonly GV. To avoid promotion we convert\n        // GV initializer to 'zeroinitializer'. This effectively drops\n        // references in IR module (not in combined index), so we can\n        // ignore them when computing import. We do not export references\n        // of writeonly object. See computeImportForReferencedGlobals\n        if (ImportIndex.isWriteOnly(GVS) && GVS->refs().size())\n          V->setInitializer(Constant::getNullValue(V->getValueType()));\n      }\n    }\n  }\n\n  if (GV.hasLocalLinkage() && shouldPromoteLocalToGlobal(&GV, VI)) {\n    // Save the original name string before we rename GV below.\n    auto Name = GV.getName().str();\n    GV.setName(getPromotedName(&GV));\n    GV.setLinkage(getLinkage(&GV, /* DoPromote */ true));\n    assert(!GV.hasLocalLinkage());\n    GV.setVisibility(GlobalValue::HiddenVisibility);\n\n    // If we are renaming a COMDAT leader, ensure that we record the COMDAT\n    // for later renaming as well. This is required for COFF.\n    if (const auto *C = GV.getComdat())\n      if (C->getName() == Name)\n        RenamedComdats.try_emplace(C, M.getOrInsertComdat(GV.getName()));\n  } else\n    GV.setLinkage(getLinkage(&GV, /* DoPromote */ false));\n\n  // Remove functions imported as available externally defs from comdats,\n  // as this is a declaration for the linker, and will be dropped eventually.\n  // It is illegal for comdats to contain declarations.\n  auto *GO = dyn_cast<GlobalObject>(&GV);\n  if (GO && GO->isDeclarationForLinker() && GO->hasComdat()) {\n    // The IRMover should not have placed any imported declarations in\n    // a comdat, so the only declaration that should be in a comdat\n    // at this point would be a definition imported as available_externally.\n    assert(GO->hasAvailableExternallyLinkage() &&\n           \"Expected comdat on definition (possibly available external)\");\n    GO->setComdat(nullptr);\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        if (ImportIndex.isWriteOnly(GVS) && GVS->refs().size())\n",
        "src_path": "e420c0c78eb0700989c8ba80e845b6306d66bb5f___FunctionImportUtils.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/e420c0c78eb0700989c8ba80e845b6306d66bb5f",
        "commit_msg": "[ThinLTO] Fix importing of writeonly variables in distributed ThinLTO\n\nSummary:\nD69561/dde5893 enabled importing of readonly variables with references,\nhowever, it introduced a bug relating to importing/internalization of\nwriteonly variables with references.\n\nA fix for this was added in D70006/7f92d66. But this didn't work in\ndistributed ThinLTO mode. The reason is that the fix (importing the\nwriteonly var with a zeroinitializer) was only applied when there were\nreferences on the writeonly var summary. In distributed ThinLTO mode,\nwhere we only have a small slice of the index, we will not have the\nreferences on the importing side if we are not importing those\nreferenced values. Rather than changing this handshaking (which will\nrequire a lot of other changes, since that's how we know what to import\nin the distributed backend clang invocation), we can simply always give\nthe writeonly variable a zero initializer.\n\nReviewers: evgeny777, steven_wu\n\nSubscribers: mehdi_amini, inglorion, hiraditya, dexonsmith, arphaman, llvm-commits\n\nTags: #llvm\n\nDifferential Revision: https://reviews.llvm.org/D70977",
        "test_func_diff": [
            {
                "fn": "llvm/test/ThinLTO/X86/index-const-prop2.ll",
                "patch": "@@ -36,6 +36,8 @@\n ; RUN:  -o %t4\n ; RUN: llvm-dis %t4.1.3.import.bc -o - | FileCheck %s --check-prefix=IMPORT2\n \n+; Run again but with main2 exported instead of main to check that write only\n+; variables are optimized out.\n ; RUN: llvm-lto2 run %t1.bc %t2.bc -save-temps \\\n ; RUN:  -r=%t2.bc,foo,pl \\\n ; RUN:  -r=%t2.bc,bar,pl \\\n@@ -49,7 +51,7 @@\n ; RUN:  -r=%t1.bc,baz, \\\n ; RUN:  -r=%t1.bc,gBar, \\\n ; RUN:  -o %t5\n-; RUN: llvm-dis %t5.1.3.import.bc -o - | FileCheck %s --check-prefix=IMPORT\n+; RUN: llvm-dis %t5.1.3.import.bc -o - | FileCheck %s --check-prefix=IMPORT-WRITEONLY\n ; RUN: llvm-dis %t5.1.5.precodegen.bc -o - | FileCheck %s --check-prefix=CODEGEN2\n ; Check that gFoo and gBar were eliminated from source module together\n ; with corresponsing stores\n@@ -59,6 +61,10 @@\n ; IMPORT-NEXT:  @gBar = internal local_unnamed_addr global i32 2, align 4\n ; IMPORT:       !DICompileUnit({{.*}})\n \n+; Write only variables are imported with a zero initializer.\n+; IMPORT-WRITEONLY:  @gFoo.llvm.0 = internal unnamed_addr global i32 0\n+; IMPORT-WRITEONLY:  @gBar = internal local_unnamed_addr global i32 0\n+\n ; CODEGEN:        i32 @main()\n ; CODEGEN-NEXT:     ret i32 3\n "
            },
            {
                "fn": "llvm/test/ThinLTO/X86/writeonly-with-refs.ll",
                "patch": "@@ -7,10 +7,22 @@\n ; RUN:    -r=%t2,outer,pl\n \n ; @outer should have been internalized and converted to zeroinitilizer.\n-; RUN: llvm-dis %t-out.1.5.precodegen.bc -o - | FileCheck %s\n-; RUN: llvm-dis %t-out.2.5.precodegen.bc -o - | FileCheck %s\n+; RUN: llvm-dis %t-out.1.3.import.bc -o - | FileCheck %s\n+; RUN: llvm-dis %t-out.2.3.import.bc -o - | FileCheck %s\n \n-; CHECK: @outer = internal unnamed_addr global %struct.Q zeroinitializer\n+; CHECK: @outer = internal local_unnamed_addr global %struct.Q zeroinitializer\n+\n+; Test again in distributed ThinLTO mode.\n+; RUN: llvm-lto2 run -save-temps %t1 %t2 -o %t-out \\\n+; RUN:    -thinlto-distributed-indexes \\\n+; RUN:    -r=%t1,main,plx \\\n+; RUN:    -r=%t1,_Z3foov,l \\\n+; RUN:    -r=%t2,_Z3foov,pl \\\n+; RUN:    -r=%t2,outer,pl\n+; RUN: opt -function-import -import-all-index -enable-import-metadata -summary-file %t1.thinlto.bc %t1 -o %t1.out\n+; RUN: opt -function-import -import-all-index -summary-file %t2.thinlto.bc %t2 -o %t2.out\n+; RUN: llvm-dis %t1.out -o - | FileCheck %s\n+; RUN: llvm-dis %t2.out -o - | FileCheck %s\n \n source_filename = \"main.cpp\"\n target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\""
            },
            {
                "fn": "llvm/test/ThinLTO/X86/writeonly.ll",
                "patch": "@@ -11,8 +11,8 @@\n ; RUN: llvm-dis %t1.imported.bc -o - | FileCheck %s --check-prefix=IMPORT\n ; RUN: llvm-lto -thinlto-action=optimize %t1.imported.bc -o - | llvm-dis - -o - | FileCheck %s --check-prefix=OPTIMIZE\n \n-; IMPORT: @gFoo.llvm.0 = internal unnamed_addr global i32 1, align 4, !dbg !0\n-; IMPORT-NEXT: @gBar = internal local_unnamed_addr global i32 2, align 4, !dbg !5\n+; IMPORT: @gFoo.llvm.0 = internal unnamed_addr global i32 0, align 4, !dbg !0\n+; IMPORT-NEXT: @gBar = internal local_unnamed_addr global i32 0, align 4, !dbg !5\n ; IMPORT: !DICompileUnit({{.*}})\n \n ; STATS:  2 module-summary-index - Number of live global variables marked write only "
            },
            {
                "fn": "llvm/test/ThinLTO/X86/writeonly2.ll",
                "patch": "@@ -19,8 +19,8 @@\n ; with corresponsing stores\n ; RUN: llvm-dis %t3.2.5.precodegen.bc -o - | FileCheck %s --check-prefix=CODEGEN-SRC\n \n-; IMPORT:       @gFoo.llvm.0 = internal unnamed_addr global i32 1, align 4\n-; IMPORT-NEXT:  @gBar = internal local_unnamed_addr global i32 2, align 4\n+; IMPORT:       @gFoo.llvm.0 = internal unnamed_addr global i32 0, align 4\n+; IMPORT-NEXT:  @gBar = internal local_unnamed_addr global i32 0, align 4\n ; IMPORT:       !DICompileUnit({{.*}})\n \n ; CODEGEN-NOT:  gFoo"
            }
        ],
        "error_msg": "FAIL: LLVM :: ThinLTO/X86/index-const-prop2.ll (1 of 1)\n\nTesting Time: 1.09s\n********************\nFailing Tests (1):\n    LLVM :: ThinLTO/X86/index-const-prop2.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: ThinLTO/X86/writeonly-with-refs.ll (1 of 1)\n\nTesting Time: 0.58s\n********************\nFailing Tests (1):\n    LLVM :: ThinLTO/X86/writeonly-with-refs.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: ThinLTO/X86/writeonly.ll (1 of 1)\n\nTesting Time: 0.40s\n********************\nFailing Tests (1):\n    LLVM :: ThinLTO/X86/writeonly.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: ThinLTO/X86/writeonly2.ll (1 of 1)\n\nTesting Time: 0.44s\n********************\nFailing Tests (1):\n    LLVM :: ThinLTO/X86/writeonly2.ll\n\n  Unexpected Failures: 1\n"
    },
    "453dc4d7ec5a3c3d8f54fc358bc5673834516d48___DbgEntityHistoryCalculator.cpp": {
        "prefix": "void llvm::calculateDbgEntityHistory(const MachineFunction *MF,\n                                     const TargetRegisterInfo *TRI,\n                                     DbgValueHistoryMap &DbgValues,\n                                     DbgLabelInstrMap &DbgLabels) {\n  const TargetLowering *TLI = MF->getSubtarget().getTargetLowering();\n  unsigned SP = TLI->getStackPointerRegisterToSaveRestore();\n  Register FrameReg = TRI->getFrameRegister(*MF);\n  RegDescribedVarsMap RegVars;\n  DbgValueEntriesMap LiveEntries;\n  for (const auto &MBB : *MF) {\n    for (const auto &MI : MBB) {\n      if (MI.isDebugValue()) {\n        assert(MI.getNumOperands() > 1 && \"Invalid DBG_VALUE instruction!\");\n        // Use the base variable (without any DW_OP_piece expressions)\n        // as index into History. The full variables including the\n        // piece expressions are attached to the MI.\n        const DILocalVariable *RawVar = MI.getDebugVariable();\n        assert(RawVar->isValidLocationForIntrinsic(MI.getDebugLoc()) &&\n               \"Expected inlined-at fields to agree\");\n        InlinedEntity Var(RawVar, MI.getDebugLoc()->getInlinedAt());\n\n        handleNewDebugValue(Var, MI, RegVars, LiveEntries, DbgValues);\n      } else if (MI.isDebugLabel()) {\n        assert(MI.getNumOperands() == 1 && \"Invalid DBG_LABEL instruction!\");\n        const DILabel *RawLabel = MI.getDebugLabel();\n        assert(RawLabel->isValidLocationForIntrinsic(MI.getDebugLoc()) &&\n            \"Expected inlined-at fields to agree\");\n        // When collecting debug information for labels, there is no MCSymbol\n        // generated for it. So, we keep MachineInstr in DbgLabels in order\n        // to query MCSymbol afterward.\n        InlinedEntity L(RawLabel, MI.getDebugLoc()->getInlinedAt());\n        DbgLabels.addInstr(L, MI);\n      }\n\n",
        "suffix": "        continue;\n\n      // Not a DBG_VALUE instruction. It may clobber registers which describe\n      // some variables.\n      for (const MachineOperand &MO : MI.operands()) {\n        if (MO.isReg() && MO.isDef() && MO.getReg()) {\n          // Ignore call instructions that claim to clobber SP. The AArch64\n          // backend does this for aggregate function arguments.\n          if (MI.isCall() && MO.getReg() == SP)\n            continue;\n          // If this is a virtual register, only clobber it since it doesn't\n          // have aliases.\n          if (Register::isVirtualRegister(MO.getReg()))\n            clobberRegisterUses(RegVars, MO.getReg(), DbgValues, LiveEntries,\n                                MI);\n          // If this is a register def operand, it may end a debug value\n          // range. Ignore frame-register defs in the epilogue and prologue,\n          // we expect debuggers to understand that stack-locations are\n          // invalid outside of the function body.\n          else if (MO.getReg() != FrameReg ||\n                   (!MI.getFlag(MachineInstr::FrameDestroy) &&\n                   !MI.getFlag(MachineInstr::FrameSetup))) {\n            for (MCRegAliasIterator AI(MO.getReg(), TRI, true); AI.isValid();\n                 ++AI)\n              clobberRegisterUses(RegVars, *AI, DbgValues, LiveEntries, MI);\n          }\n        } else if (MO.isRegMask()) {\n          // If this is a register mask operand, clobber all debug values in\n          // non-CSRs.\n          SmallVector<unsigned, 32> RegsToClobber;\n          // Don't consider SP to be clobbered by register masks.\n          for (auto It : RegVars) {\n            unsigned int Reg = It.first;\n            if (Reg != SP && Register::isPhysicalRegister(Reg) &&\n                MO.clobbersPhysReg(Reg))\n              RegsToClobber.push_back(Reg);\n          }\n\n          for (unsigned Reg : RegsToClobber) {\n            clobberRegisterUses(RegVars, Reg, DbgValues, LiveEntries, MI);\n          }\n        }\n      } // End MO loop.\n    }   // End instr loop.\n\n    // Make sure locations for all variables are valid only until the end of\n    // the basic block (unless it's the last basic block, in which case let\n    // their liveness run off to the end of the function).\n    if (!MBB.empty() && &MBB != &MF->back()) {\n      // Iterate over all variables that have open debug values.\n      for (auto &Pair : LiveEntries) {\n        if (Pair.second.empty())\n          continue;\n\n        // Create a clobbering entry.\n        EntryIndex ClobIdx = DbgValues.startClobber(Pair.first, MBB.back());\n\n        // End all entries.\n        for (EntryIndex Idx : Pair.second) {\n          DbgValueHistoryMap::Entry &Ent = DbgValues.getEntry(Pair.first, Idx);\n          assert(Ent.isDbgValue() && !Ent.isClosed());\n          Ent.endEntry(ClobIdx);\n        }\n      }\n\n      LiveEntries.clear();\n      RegVars.clear();\n    }\n  }\n}\n",
        "start": 231,
        "end": 335,
        "buggy": "void llvm::calculateDbgEntityHistory(const MachineFunction *MF,\n                                     const TargetRegisterInfo *TRI,\n                                     DbgValueHistoryMap &DbgValues,\n                                     DbgLabelInstrMap &DbgLabels) {\n  const TargetLowering *TLI = MF->getSubtarget().getTargetLowering();\n  unsigned SP = TLI->getStackPointerRegisterToSaveRestore();\n  Register FrameReg = TRI->getFrameRegister(*MF);\n  RegDescribedVarsMap RegVars;\n  DbgValueEntriesMap LiveEntries;\n  for (const auto &MBB : *MF) {\n    for (const auto &MI : MBB) {\n      if (MI.isDebugValue()) {\n        assert(MI.getNumOperands() > 1 && \"Invalid DBG_VALUE instruction!\");\n        // Use the base variable (without any DW_OP_piece expressions)\n        // as index into History. The full variables including the\n        // piece expressions are attached to the MI.\n        const DILocalVariable *RawVar = MI.getDebugVariable();\n        assert(RawVar->isValidLocationForIntrinsic(MI.getDebugLoc()) &&\n               \"Expected inlined-at fields to agree\");\n        InlinedEntity Var(RawVar, MI.getDebugLoc()->getInlinedAt());\n\n        handleNewDebugValue(Var, MI, RegVars, LiveEntries, DbgValues);\n      } else if (MI.isDebugLabel()) {\n        assert(MI.getNumOperands() == 1 && \"Invalid DBG_LABEL instruction!\");\n        const DILabel *RawLabel = MI.getDebugLabel();\n        assert(RawLabel->isValidLocationForIntrinsic(MI.getDebugLoc()) &&\n            \"Expected inlined-at fields to agree\");\n        // When collecting debug information for labels, there is no MCSymbol\n        // generated for it. So, we keep MachineInstr in DbgLabels in order\n        // to query MCSymbol afterward.\n        InlinedEntity L(RawLabel, MI.getDebugLoc()->getInlinedAt());\n        DbgLabels.addInstr(L, MI);\n      }\n\n      if (MI.isDebugInstr())\n        continue;\n\n      // Not a DBG_VALUE instruction. It may clobber registers which describe\n      // some variables.\n      for (const MachineOperand &MO : MI.operands()) {\n        if (MO.isReg() && MO.isDef() && MO.getReg()) {\n          // Ignore call instructions that claim to clobber SP. The AArch64\n          // backend does this for aggregate function arguments.\n          if (MI.isCall() && MO.getReg() == SP)\n            continue;\n          // If this is a virtual register, only clobber it since it doesn't\n          // have aliases.\n          if (Register::isVirtualRegister(MO.getReg()))\n            clobberRegisterUses(RegVars, MO.getReg(), DbgValues, LiveEntries,\n                                MI);\n          // If this is a register def operand, it may end a debug value\n          // range. Ignore frame-register defs in the epilogue and prologue,\n          // we expect debuggers to understand that stack-locations are\n          // invalid outside of the function body.\n          else if (MO.getReg() != FrameReg ||\n                   (!MI.getFlag(MachineInstr::FrameDestroy) &&\n                   !MI.getFlag(MachineInstr::FrameSetup))) {\n            for (MCRegAliasIterator AI(MO.getReg(), TRI, true); AI.isValid();\n                 ++AI)\n              clobberRegisterUses(RegVars, *AI, DbgValues, LiveEntries, MI);\n          }\n        } else if (MO.isRegMask()) {\n          // If this is a register mask operand, clobber all debug values in\n          // non-CSRs.\n          SmallVector<unsigned, 32> RegsToClobber;\n          // Don't consider SP to be clobbered by register masks.\n          for (auto It : RegVars) {\n            unsigned int Reg = It.first;\n            if (Reg != SP && Register::isPhysicalRegister(Reg) &&\n                MO.clobbersPhysReg(Reg))\n              RegsToClobber.push_back(Reg);\n          }\n\n          for (unsigned Reg : RegsToClobber) {\n            clobberRegisterUses(RegVars, Reg, DbgValues, LiveEntries, MI);\n          }\n        }\n      } // End MO loop.\n    }   // End instr loop.\n\n    // Make sure locations for all variables are valid only until the end of\n    // the basic block (unless it's the last basic block, in which case let\n    // their liveness run off to the end of the function).\n    if (!MBB.empty() && &MBB != &MF->back()) {\n      // Iterate over all variables that have open debug values.\n      for (auto &Pair : LiveEntries) {\n        if (Pair.second.empty())\n          continue;\n\n        // Create a clobbering entry.\n        EntryIndex ClobIdx = DbgValues.startClobber(Pair.first, MBB.back());\n\n        // End all entries.\n        for (EntryIndex Idx : Pair.second) {\n          DbgValueHistoryMap::Entry &Ent = DbgValues.getEntry(Pair.first, Idx);\n          assert(Ent.isDbgValue() && !Ent.isClosed());\n          Ent.endEntry(ClobIdx);\n        }\n      }\n\n      LiveEntries.clear();\n      RegVars.clear();\n    }\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      if (MI.isDebugInstr())\n",
        "src_path": "453dc4d7ec5a3c3d8f54fc358bc5673834516d48___DbgEntityHistoryCalculator.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/453dc4d7ec5a3c3d8f54fc358bc5673834516d48",
        "commit_msg": "[OPT-DBG] Teach DbgEntityHistoryCalculator about meta-instructions.\n\nThe calculator was considering instructions such as KILLs as clobbers\nof a physical address. This is wrong as meta instructions such as KILLs\nproduce no output in the final program and thus don't clobber or change\nany physical location's value. As a result they're safe to ignore whilst\ncalculating location list ranges.\n\nreviewers: aprantl, vsk\n\ndiff revision: https://reviews.llvm.org/D70497\n\nfixes: https://bugs.llvm.org/show_bug.cgi?id=38753",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/COFF/pieces.ll",
                "patch": "@@ -76,6 +76,7 @@\n ; ASM: [[pad_right_tmp:\\.Ltmp[0-9]+]]:\n ; ASM:         #DEBUG_VALUE: pad_right:o <- [DW_OP_LLVM_fragment 32 32] $eax\n ; ASM:         retq\n+; ASM: [[pad_right_end:\\.Lfunc_end1]]:\n \n \n ; ASM-LABEL: pad_left: # @pad_left\n@@ -84,6 +85,7 @@\n ; ASM: [[pad_left_tmp:\\.Ltmp[0-9]+]]:\n ; ASM:         #DEBUG_VALUE: pad_left:o <- [DW_OP_LLVM_fragment 0 32] $eax\n ; ASM:         retq\n+; ASM: [[pad_left_end:\\.Lfunc_end2]]:\n \n \n ; ASM-LABEL: nested: # @nested\n@@ -146,7 +148,7 @@\n ; ASM:        .asciz  \"pad_right\"             # Function name\n ; ASM:        .short  4414                    # Record kind: S_LOCAL\n ; ASM:        .asciz  \"o\"\n-; ASM:        .cv_def_range    [[pad_right_tmp]] [[pad_right_tmp]], subfield_reg, 17, 4\n+; ASM:        .cv_def_range    [[pad_right_tmp]] [[pad_right_end]], subfield_reg, 17, 4\n \n ; OBJ-LABEL: GlobalProcIdSym {\n ; OBJ:         Kind: S_GPROC32_ID (0x1147)\n@@ -169,7 +171,7 @@\n ; ASM:        .asciz  \"pad_left\"              # Function name\n ; ASM:        .short  4414                    # Record kind: S_LOCAL\n ; ASM:        .asciz  \"o\"\n-; ASM:        .cv_def_range    [[pad_left_tmp]] [[pad_left_tmp]], subfield_reg, 17, 0\n+; ASM:        .cv_def_range    [[pad_left_tmp]] [[pad_left_end]], subfield_reg, 17, 0\n \n ; OBJ-LABEL: GlobalProcIdSym {\n ; OBJ:         Kind: S_GPROC32_ID (0x1147)"
            },
            {
                "fn": "llvm/test/DebugInfo/X86/dbg_entity_calc_ignores_KILL_instruction_at_return.mir",
                "patch": "@@ -0,0 +1,76 @@\n+--- |\n+  ; RUN: llc %s -start-before=cfi-instr-inserter -filetype=obj -o - | llvm-dwarfdump - | FileCheck %s\n+\n+  ; Test that KILL instructions no longer terminate the instruction range of a\n+  ; Debug Intrinsic calculated by DbgEntityHistoryCalculator.\n+\n+  source_filename = \".\\\\test.cpp\"\n+  target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n+  target triple = \"x86_64-scei-ps4\"\n+  \n+  define hidden i32 @main(i32 %arg, i8** nocapture readnone %argv) local_unnamed_addr !dbg !8 {\n+  entry:\n+    call void @llvm.dbg.value(metadata i32 %arg, metadata !19, metadata !DIExpression()), !dbg !22\n+    call void @llvm.dbg.value(metadata i8** %argv, metadata !20, metadata !DIExpression()), !dbg !22\n+    %add = shl nsw i32 %arg, 1, !dbg !23\n+    call void @llvm.dbg.value(metadata i32 %add, metadata !21, metadata !DIExpression()), !dbg !22\n+    ret i32 %add, !dbg !24\n+  }\n+\n+  declare void @llvm.dbg.value(metadata, metadata, metadata)\n+\n+\n+  !llvm.dbg.cu = !{!0}\n+  !llvm.module.flags = !{!3, !4, !5, !6}\n+  !llvm.ident = !{!7}\n+\n+  !0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus_14, file: !1, producer: \"clang version 10.0.0\", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, debugInfoForProfiling: true, nameTableKind: None)\n+  !1 = !DIFile(filename: \"test.cpp\", directory: \"F:\\\\test\")\n+  !2 = !{}\n+  !3 = !{i32 2, !\"Dwarf Version\", i32 4}\n+  !4 = !{i32 2, !\"Debug Info Version\", i32 3}\n+  !5 = !{i32 1, !\"wchar_size\", i32 2}\n+  !6 = !{i32 7, !\"PIC Level\", i32 2}\n+  !7 = !{!\"clang version 10.0.0\"}\n+  !8 = distinct !DISubprogram(name: \"main\", scope: !9, file: !9, line: 1, type: !10, scopeLine: 1, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !18)\n+  !9 = !DIFile(filename: \".\\\\test.cpp\", directory: \"F:\\\\test\")\n+  !10 = !DISubroutineType(types: !11)\n+  !11 = !{!12, !13, !14}\n+  !12 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n+  !13 = !DIDerivedType(tag: DW_TAG_const_type, baseType: !12)\n+  !14 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !15, size: 64)\n+  !15 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !16, size: 64)\n+  !16 = !DIDerivedType(tag: DW_TAG_const_type, baseType: !17)\n+  !17 = !DIBasicType(name: \"char\", size: 8, encoding: DW_ATE_signed_char)\n+  !18 = !{!19, !20, !21}\n+  !19 = !DILocalVariable(name: \"arg\", arg: 1, scope: !8, file: !9, line: 1, type: !13)\n+  !20 = !DILocalVariable(name: \"argv\", arg: 2, scope: !8, file: !9, line: 1, type: !14)\n+  !21 = !DILocalVariable(name: \"result\", scope: !8, file: !9, line: 2, type: !12)\n+  !22 = !DILocation(line: 0, scope: !8)\n+  !23 = !DILocation(line: 2, scope: !8)\n+  !24 = !DILocation(line: 3, scope: !8)\n+\n+...\n+---\n+name:            main\n+alignment:       16\n+tracksRegLiveness: true\n+liveins:\n+  - { reg: '$edi', virtual-reg: '' }\n+frameInfo:\n+  maxAlignment:    1\n+body:             |\n+  bb.0.entry:\n+    liveins: $edi\n+\n+    renamable $edi = KILL killed $edi, implicit-def $rdi\n+    renamable $eax = LEA64_32r killed renamable $rdi, 1, renamable $rdi, 0, $noreg, debug-location !23\n+    DBG_VALUE $eax, $noreg, !21, !DIExpression(), debug-location !22\n+    ; CHECK-LABEL: DW_TAG_variable\n+    ; CHECK: DW_AT_location        (0x00000000:\n+    ; CHECK:  [0x0000000000000003,  0x0000000000000004): DW_OP_reg0 RAX)\n+    ; CHECK-NEXT: DW_AT_name    (\"result\")\n+    renamable $eax = KILL killed $eax, implicit-def $rax\n+    RETQ killed $eax, debug-location !24\n+\n+..."
            },
            {
                "fn": "llvm/test/DebugInfo/X86/dbg_entity_calc_ignores_KILL_instruction_still_clobbers.mir",
                "patch": "@@ -0,0 +1,79 @@\n+--- |\n+  ; RUN: llc %s -start-before=cfi-instr-inserter -filetype=obj -o - | llvm-dwarfdump - | FileCheck %s\n+\n+  ; Test that KILL instructions do not interfere with debug entity history\n+  ; liveness ranges. Check that a physical address clobber after KILL still\n+  ; closes a debug entites range.\n+\n+  source_filename = \".\\\\test.cpp\"\n+  target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n+  target triple = \"x86_64-scei-ps4\"\n+  \n+  define hidden i32 @main(i32 %arg, i8** nocapture readnone %argv) local_unnamed_addr !dbg !8 {\n+  entry:\n+    call void @llvm.dbg.value(metadata i32 %arg, metadata !19, metadata !DIExpression()), !dbg !22\n+    call void @llvm.dbg.value(metadata i8** %argv, metadata !20, metadata !DIExpression()), !dbg !22\n+    %add = shl nsw i32 %arg, 1, !dbg !23\n+    call void @llvm.dbg.value(metadata i32 %add, metadata !21, metadata !DIExpression()), !dbg !22\n+    ret i32 %add, !dbg !24\n+  }\n+  \n+  declare void @llvm.dbg.value(metadata, metadata, metadata)\n+\n+  !llvm.dbg.cu = !{!0}\n+  !llvm.module.flags = !{!3, !4, !5, !6}\n+  !llvm.ident = !{!7}\n+\n+  !0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus_14, file: !1, producer: \"clang version 10.0.0\", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !2, debugInfoForProfiling: true, nameTableKind: None)\n+  !1 = !DIFile(filename: \"test.cpp\", directory: \"F:\\\\test\")\n+  !2 = !{}\n+  !3 = !{i32 2, !\"Dwarf Version\", i32 4}\n+  !4 = !{i32 2, !\"Debug Info Version\", i32 3}\n+  !5 = !{i32 1, !\"wchar_size\", i32 2}\n+  !6 = !{i32 7, !\"PIC Level\", i32 2}\n+  !7 = !{!\"clang version 10.0.0\"}\n+  !8 = distinct !DISubprogram(name: \"main\", scope: !9, file: !9, line: 1, type: !10, scopeLine: 1, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !18)\n+  !9 = !DIFile(filename: \".\\\\test.cpp\", directory: \"F:\\\\test\")\n+  !10 = !DISubroutineType(types: !11)\n+  !11 = !{!12, !13, !14}\n+  !12 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n+  !13 = !DIDerivedType(tag: DW_TAG_const_type, baseType: !12)\n+  !14 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !15, size: 64)\n+  !15 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !16, size: 64)\n+  !16 = !DIDerivedType(tag: DW_TAG_const_type, baseType: !17)\n+  !17 = !DIBasicType(name: \"char\", size: 8, encoding: DW_ATE_signed_char)\n+  !18 = !{!19, !20, !21}\n+  !19 = !DILocalVariable(name: \"arg\", arg: 1, scope: !8, file: !9, line: 1, type: !13)\n+  !20 = !DILocalVariable(name: \"argv\", arg: 2, scope: !8, file: !9, line: 1, type: !14)\n+  !21 = !DILocalVariable(name: \"result\", scope: !8, file: !9, line: 2, type: !12)\n+  !22 = !DILocation(line: 0, scope: !8)\n+  !23 = !DILocation(line: 2, scope: !8)\n+  !24 = !DILocation(line: 3, scope: !8)\n+\n+...\n+---\n+name:            main\n+alignment:       16\n+tracksRegLiveness: true\n+liveins:\n+  - { reg: '$edi', virtual-reg: '' }\n+frameInfo:\n+  maxAlignment:    1\n+body:             |\n+  bb.0.entry:\n+    liveins: $edi\n+\n+    renamable $edi = KILL killed $edi, implicit-def $rdi\n+    renamable $eax = LEA64_32r killed renamable $rdi, 1, renamable $rdi, 0, $noreg, debug-location !23\n+    DBG_VALUE $eax, $noreg, !21, !DIExpression(), debug-location !22\n+    ; CHECK-LABEL: DW_TAG_variable\n+    ; CHECK: DW_AT_location        (0x00000000:\n+    ; CHECK:  [0x0000000000000003,  0x0000000000000007): DW_OP_reg0 RAX)\n+    ; CHECK-NEXT: DW_AT_name    (\"result\")\n+    renamable $eax = KILL killed $eax, implicit-def $rax\n+    $edi = MOV32rr $eax, debug-location !24\n+    $eax = MOV32rr $eax, debug-location !24\n+    $edi = MOV32rr $eax, debug-location !24\n+    RETQ killed $eax, debug-location !24\n+\n+..."
            },
            {
                "fn": "llvm/test/DebugInfo/X86/pieces-3.ll",
                "patch": "@@ -21,8 +21,9 @@\n ; CHECK-NEXT:     [0x0000000000000007, 0x0000000000000009): DW_OP_reg5 RDI, DW_OP_piece 0x8\n ; CHECK-NEXT:   DW_AT_name {{.*}}\"outer\"\n ; CHECK: DW_TAG_variable\n-; CHECK-NEXT:   DW_AT_name {{.*}}\"i1\"\n-; CHECK-NOT:    DW_AT_location\n+; CHECK-NEXT:   DW_AT_location [DW_FORM_data4]        (0x00000044\n+; CHECK-NEXT:     [0x0000000000000007, 0x0000000000000009): DW_OP_reg0 RAX, DW_OP_piece 0x4)\n+; CHECK-NEXT:   \"i1\"\n \n ; ModuleID = '/Volumes/Data/llvm/test/DebugInfo/X86/sroasplit-2.ll'\n target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\""
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/COFF/pieces.ll (1 of 1)\n\nTesting Time: 0.80s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/COFF/pieces.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: DebugInfo/X86/pieces-3.ll (1 of 1)\n\nTesting Time: 0.53s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/pieces-3.ll\n\n  Unexpected Failures: 1\n"
    },
    "0cf0be993c382f15c277de6d0db8be6a236c7c50___InstCombineCasts.cpp": {
        "prefix": "Instruction *InstCombiner::commonCastTransforms(CastInst &CI) {\n  Value *Src = CI.getOperand(0);\n\n  // Try to eliminate a cast of a cast.\n  if (auto *CSrc = dyn_cast<CastInst>(Src)) {   // A->B->C cast\n    if (Instruction::CastOps NewOpc = isEliminableCastPair(CSrc, &CI)) {\n      // The first cast (CSrc) is eliminable so we need to fix up or replace\n      // the second cast (CI). CSrc will then have a good chance of being dead.\n      auto *Ty = CI.getType();\n      auto *Res = CastInst::Create(NewOpc, CSrc->getOperand(0), Ty);\n      // Point debug users of the dying cast to the new one.\n      if (CSrc->hasOneUse())\n        replaceAllDbgUsesWith(*CSrc, *Res, CI, DT);\n      return Res;\n    }\n  }\n\n  if (auto *Sel = dyn_cast<SelectInst>(Src)) {\n    // We are casting a select. Try to fold the cast into the select if the\n    // select does not have a compare instruction with matching operand types\n    // or the select is likely better done in a narrow type.\n    // Creating a select with operands that are different sizes than its\n    // condition may inhibit other folds and lead to worse codegen.\n    auto *Cmp = dyn_cast<CmpInst>(Sel->getCondition());\n    if (!Cmp || Cmp->getOperand(0)->getType() != Sel->getType() ||\n        (CI.getOpcode() == Instruction::Trunc &&\n         shouldChangeType(CI.getSrcTy(), CI.getType()))) {\n      if (Instruction *NV = FoldOpIntoSelect(CI, Sel)) {\n        replaceAllDbgUsesWith(*Sel, *NV, CI, DT);\n        return NV;\n      }\n    }\n  }\n\n  // If we are casting a PHI, then fold the cast into the PHI.\n  if (auto *PN = dyn_cast<PHINode>(Src)) {\n    // Don't do this if it would create a PHI node with an illegal type from a\n    // legal type.\n    if (!Src->getType()->isIntegerTy() || !CI.getType()->isIntegerTy() ||\n",
        "suffix": "      if (Instruction *NV = foldOpIntoPhi(CI, PN))\n        return NV;\n  }\n\n  return nullptr;\n}\n",
        "start": 261,
        "end": 306,
        "buggy": "Instruction *InstCombiner::commonCastTransforms(CastInst &CI) {\n  Value *Src = CI.getOperand(0);\n\n  // Try to eliminate a cast of a cast.\n  if (auto *CSrc = dyn_cast<CastInst>(Src)) {   // A->B->C cast\n    if (Instruction::CastOps NewOpc = isEliminableCastPair(CSrc, &CI)) {\n      // The first cast (CSrc) is eliminable so we need to fix up or replace\n      // the second cast (CI). CSrc will then have a good chance of being dead.\n      auto *Ty = CI.getType();\n      auto *Res = CastInst::Create(NewOpc, CSrc->getOperand(0), Ty);\n      // Point debug users of the dying cast to the new one.\n      if (CSrc->hasOneUse())\n        replaceAllDbgUsesWith(*CSrc, *Res, CI, DT);\n      return Res;\n    }\n  }\n\n  if (auto *Sel = dyn_cast<SelectInst>(Src)) {\n    // We are casting a select. Try to fold the cast into the select if the\n    // select does not have a compare instruction with matching operand types\n    // or the select is likely better done in a narrow type.\n    // Creating a select with operands that are different sizes than its\n    // condition may inhibit other folds and lead to worse codegen.\n    auto *Cmp = dyn_cast<CmpInst>(Sel->getCondition());\n    if (!Cmp || Cmp->getOperand(0)->getType() != Sel->getType() ||\n        (CI.getOpcode() == Instruction::Trunc &&\n         shouldChangeType(CI.getSrcTy(), CI.getType()))) {\n      if (Instruction *NV = FoldOpIntoSelect(CI, Sel)) {\n        replaceAllDbgUsesWith(*Sel, *NV, CI, DT);\n        return NV;\n      }\n    }\n  }\n\n  // If we are casting a PHI, then fold the cast into the PHI.\n  if (auto *PN = dyn_cast<PHINode>(Src)) {\n    // Don't do this if it would create a PHI node with an illegal type from a\n    // legal type.\n    if (!Src->getType()->isIntegerTy() || !CI.getType()->isIntegerTy() ||\n        shouldChangeType(CI.getType(), Src->getType()))\n      if (Instruction *NV = foldOpIntoPhi(CI, PN))\n        return NV;\n  }\n\n  return nullptr;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        shouldChangeType(CI.getType(), Src->getType()))\n",
        "src_path": "0cf0be993c382f15c277de6d0db8be6a236c7c50___InstCombineCasts.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/0cf0be993c382f15c277de6d0db8be6a236c7c50",
        "commit_msg": "[InstCombine] fix operands of shouldChangeType() for casted phi transform\n\nThis is a bug noted in the recent D72733 and seen\nin the similar transform just above the changed source code.\n\nI added tests with illegal types and zexts to show the bug -\nwe could transform legal phi ops to illegal, etc. I did not add\ntests with trunc because we won't see any diffs on those patterns.\nThat is because InstCombiner::SliceUpIllegalIntegerPHI() appears to\ndo those transforms independently of datalayout. It can also create\nmore casts than are present in existing code.\n\nThere are some existing regression tests that do not include a\ndatalayout that would be altered by this fix. I assumed that the\nlack of a datalayout in those regression files is an oversight, so\nI added the minimal layout (make i32 legal) necessary to preserve\nbehavior on those tests.\n\nDifferential Revision: https://reviews.llvm.org/D73907",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/AMDGPU/diverge-switch-default.ll",
                "patch": "@@ -1,5 +1,7 @@\n ; RUN: llc -march=amdgcn -mcpu=gfx900 -print-after=si-annotate-control-flow %s -o /dev/null 2>&1 | FileCheck %s\n \n+target datalayout = \"n32\"\n+\n ; CHECK-LABEL: @switch_unreachable_default\n \n define amdgpu_kernel void @switch_unreachable_default(i32 addrspace(1)* %out, i8 addrspace(1)* %in0, i8 addrspace(1)* %in1) #0 {"
            },
            {
                "fn": "llvm/test/CodeGen/AMDGPU/reqd-work-group-size.ll",
                "patch": "@@ -1,5 +1,7 @@\n ; RUN: opt -mtriple=amdgcn-amd-amdhsa -S -amdgpu-lower-kernel-attributes -instcombine %s | FileCheck -enable-var-scope %s\n \n+target datalayout = \"n32\"\n+\n ; CHECK-LABEL: @invalid_reqd_work_group_size(\n ; CHECK: load i16,\n define amdgpu_kernel void @invalid_reqd_work_group_size(i16 addrspace(1)* %out) #0 !reqd_work_group_size !1 {"
            },
            {
                "fn": "llvm/test/Transforms/InstCombine/cast_phi.ll",
                "patch": "@@ -185,14 +185,14 @@ define i37 @zext_from_legal_to_illegal_type(i32 %x) {\n ; CHECK-NEXT:    br i1 [[CMP]], label [[T:%.*]], label [[F:%.*]]\n ; CHECK:       t:\n ; CHECK-NEXT:    [[Y:%.*]] = call i32 @get_i32()\n-; CHECK-NEXT:    [[PHITMP:%.*]] = zext i32 [[Y]] to i37\n ; CHECK-NEXT:    br label [[EXIT:%.*]]\n ; CHECK:       f:\n ; CHECK-NEXT:    call void @bar()\n ; CHECK-NEXT:    br label [[EXIT]]\n ; CHECK:       exit:\n-; CHECK-NEXT:    [[P:%.*]] = phi i37 [ [[PHITMP]], [[T]] ], [ 3, [[F]] ]\n-; CHECK-NEXT:    ret i37 [[P]]\n+; CHECK-NEXT:    [[P:%.*]] = phi i32 [ [[Y]], [[T]] ], [ 3, [[F]] ]\n+; CHECK-NEXT:    [[R:%.*]] = zext i32 [[P]] to i37\n+; CHECK-NEXT:    ret i37 [[R]]\n ;\n entry:\n   %cmp = icmp eq i32 %x, 42\n@@ -219,14 +219,14 @@ define i37 @zext_from_illegal_to_illegal_type(i32 %x) {\n ; CHECK-NEXT:    br i1 [[CMP]], label [[T:%.*]], label [[F:%.*]]\n ; CHECK:       t:\n ; CHECK-NEXT:    [[Y:%.*]] = call i3 @get_i3()\n-; CHECK-NEXT:    [[PHITMP:%.*]] = zext i3 [[Y]] to i37\n ; CHECK-NEXT:    br label [[EXIT:%.*]]\n ; CHECK:       f:\n ; CHECK-NEXT:    call void @bar()\n ; CHECK-NEXT:    br label [[EXIT]]\n ; CHECK:       exit:\n-; CHECK-NEXT:    [[P:%.*]] = phi i37 [ [[PHITMP]], [[T]] ], [ 3, [[F]] ]\n-; CHECK-NEXT:    ret i37 [[P]]\n+; CHECK-NEXT:    [[P:%.*]] = phi i3 [ [[Y]], [[T]] ], [ 3, [[F]] ]\n+; CHECK-NEXT:    [[R:%.*]] = zext i3 [[P]] to i37\n+; CHECK-NEXT:    ret i37 [[R]]\n ;\n entry:\n   %cmp = icmp eq i32 %x, 42\n@@ -287,14 +287,14 @@ define i64 @zext_from_illegal_to_legal_type(i32 %x) {\n ; CHECK-NEXT:    br i1 [[CMP]], label [[T:%.*]], label [[F:%.*]]\n ; CHECK:       t:\n ; CHECK-NEXT:    [[Y:%.*]] = call i3 @get_i3()\n+; CHECK-NEXT:    [[PHITMP:%.*]] = zext i3 [[Y]] to i64\n ; CHECK-NEXT:    br label [[EXIT:%.*]]\n ; CHECK:       f:\n ; CHECK-NEXT:    call void @bar()\n ; CHECK-NEXT:    br label [[EXIT]]\n ; CHECK:       exit:\n-; CHECK-NEXT:    [[P:%.*]] = phi i3 [ [[Y]], [[T]] ], [ 3, [[F]] ]\n-; CHECK-NEXT:    [[R:%.*]] = zext i3 [[P]] to i64\n-; CHECK-NEXT:    ret i64 [[R]]\n+; CHECK-NEXT:    [[P:%.*]] = phi i64 [ [[PHITMP]], [[T]] ], [ 3, [[F]] ]\n+; CHECK-NEXT:    ret i64 [[P]]\n ;\n entry:\n   %cmp = icmp eq i32 %x, 42"
            },
            {
                "fn": "llvm/test/Transforms/InstCombine/icmp-div-constant.ll",
                "patch": "@@ -1,6 +1,8 @@\n ; NOTE: Assertions have been autogenerated by utils/update_test_checks.py\n ; RUN: opt < %s -instcombine -S | FileCheck %s\n \n+target datalayout = \"n32\"\n+\n define i1 @is_rem2_neg_i8(i8 %x) {\n ; CHECK-LABEL: @is_rem2_neg_i8(\n ; CHECK-NEXT:    [[TMP1:%.*]] = and i8 [[X:%.*]], -127"
            },
            {
                "fn": "llvm/test/Transforms/InstCombine/icmp-mul-zext.ll",
                "patch": "@@ -1,6 +1,8 @@\n ; NOTE: Assertions have been autogenerated by utils/update_test_checks.py\n ; RUN: opt < %s -instcombine -S | FileCheck %s\n \n+target datalayout = \"n32\"\n+\n define i32 @sterix(i32, i8, i64) {\n ; CHECK-LABEL: @sterix(\n ; CHECK-NEXT:  entry:"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/cast_phi.ll (1 of 1)\n\nTesting Time: 1.03s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/cast_phi.ll\n\n  Unexpected Failures: 1\n"
    },
    "a9fe69c359de653015c39e413e48630d069abe27___InstructionSimplify.cpp": {
        "prefix": "static Value *SimplifyOrInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,\n                             unsigned MaxRecurse) {\n  if (Constant *C = foldOrCommuteConstant(Instruction::Or, Op0, Op1, Q))\n    return C;\n\n  // X | undef -> -1\n  // X | -1 = -1\n  // Do not return Op1 because it may contain undef elements if it's a vector.\n  if (match(Op1, m_Undef()) || match(Op1, m_AllOnes()))\n    return Constant::getAllOnesValue(Op0->getType());\n\n  // X | X = X\n  // X | 0 = X\n  if (Op0 == Op1 || match(Op1, m_Zero()))\n    return Op0;\n\n  // A | ~A  =  ~A | A  =  -1\n  if (match(Op0, m_Not(m_Specific(Op1))) ||\n      match(Op1, m_Not(m_Specific(Op0))))\n    return Constant::getAllOnesValue(Op0->getType());\n\n  // (A & ?) | A = A\n  if (match(Op0, m_c_And(m_Specific(Op1), m_Value())))\n    return Op1;\n\n  // A | (A & ?) = A\n  if (match(Op1, m_c_And(m_Specific(Op0), m_Value())))\n    return Op0;\n\n  // ~(A & ?) | A = -1\n  if (match(Op0, m_Not(m_c_And(m_Specific(Op1), m_Value()))))\n    return Constant::getAllOnesValue(Op1->getType());\n\n  // A | ~(A & ?) = -1\n",
        "suffix": "    return Constant::getAllOnesValue(Op0->getType());\n\n  Value *A, *B;\n  // (A & ~B) | (A ^ B) -> (A ^ B)\n  // (~B & A) | (A ^ B) -> (A ^ B)\n  // (A & ~B) | (B ^ A) -> (B ^ A)\n  // (~B & A) | (B ^ A) -> (B ^ A)\n  if (match(Op1, m_Xor(m_Value(A), m_Value(B))) &&\n      (match(Op0, m_c_And(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op0, m_c_And(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op1;\n\n  // Commute the 'or' operands.\n  // (A ^ B) | (A & ~B) -> (A ^ B)\n  // (A ^ B) | (~B & A) -> (A ^ B)\n  // (B ^ A) | (A & ~B) -> (B ^ A)\n  // (B ^ A) | (~B & A) -> (B ^ A)\n  if (match(Op0, m_Xor(m_Value(A), m_Value(B))) &&\n      (match(Op1, m_c_And(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op1, m_c_And(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op0;\n\n  // (A & B) | (~A ^ B) -> (~A ^ B)\n  // (B & A) | (~A ^ B) -> (~A ^ B)\n  // (A & B) | (B ^ ~A) -> (B ^ ~A)\n  // (B & A) | (B ^ ~A) -> (B ^ ~A)\n  if (match(Op0, m_And(m_Value(A), m_Value(B))) &&\n      (match(Op1, m_c_Xor(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op1, m_c_Xor(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op1;\n\n  // (~A ^ B) | (A & B) -> (~A ^ B)\n  // (~A ^ B) | (B & A) -> (~A ^ B)\n  // (B ^ ~A) | (A & B) -> (B ^ ~A)\n  // (B ^ ~A) | (B & A) -> (B ^ ~A)\n  if (match(Op1, m_And(m_Value(A), m_Value(B))) &&\n      (match(Op0, m_c_Xor(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op0, m_c_Xor(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op0;\n\n  if (Value *V = simplifyAndOrOfCmps(Q, Op0, Op1, false))\n    return V;\n\n  // If we have a multiplication overflow check that is being 'and'ed with a\n  // check that one of the multipliers is not zero, we can omit the 'and', and\n  // only keep the overflow check.\n  if (Value *V = omitCheckForZeroBeforeInvertedMulWithOverflow(Op0, Op1))\n    return V;\n  if (Value *V = omitCheckForZeroBeforeInvertedMulWithOverflow(Op1, Op0))\n    return V;\n\n  // Try some generic simplifications for associative operations.\n  if (Value *V = SimplifyAssociativeBinOp(Instruction::Or, Op0, Op1, Q,\n                                          MaxRecurse))\n    return V;\n\n  // Or distributes over And.  Try some generic simplifications based on this.\n  if (Value *V = ExpandBinOp(Instruction::Or, Op0, Op1, Instruction::And, Q,\n                             MaxRecurse))\n    return V;\n\n  // If the operation is with the result of a select instruction, check whether\n  // operating on either branch of the select always yields the same value.\n  if (isa<SelectInst>(Op0) || isa<SelectInst>(Op1))\n    if (Value *V = ThreadBinOpOverSelect(Instruction::Or, Op0, Op1, Q,\n                                         MaxRecurse))\n      return V;\n\n  // (A & C1)|(B & C2)\n  const APInt *C1, *C2;\n  if (match(Op0, m_And(m_Value(A), m_APInt(C1))) &&\n      match(Op1, m_And(m_Value(B), m_APInt(C2)))) {\n    if (*C1 == ~*C2) {\n      // (A & C1)|(B & C2)\n      // If we have: ((V + N) & C1) | (V & C2)\n      // .. and C2 = ~C1 and C2 is 0+1+ and (N & C2) == 0\n      // replace with V+N.\n      Value *N;\n      if (C2->isMask() && // C2 == 0+1+\n          match(A, m_c_Add(m_Specific(B), m_Value(N)))) {\n        // Add commutes, try both ways.\n        if (MaskedValueIsZero(N, *C2, Q.DL, 0, Q.AC, Q.CxtI, Q.DT))\n          return A;\n      }\n      // Or commutes, try both ways.\n      if (C1->isMask() &&\n          match(B, m_c_Add(m_Specific(A), m_Value(N)))) {\n        // Add commutes, try both ways.\n        if (MaskedValueIsZero(N, *C1, Q.DL, 0, Q.AC, Q.CxtI, Q.DT))\n          return B;\n      }\n    }\n  }\n\n  // If the operation is with the result of a phi instruction, check whether\n  // operating on all incoming values of the phi always yields the same value.\n  if (isa<PHINode>(Op0) || isa<PHINode>(Op1))\n    if (Value *V = ThreadBinOpOverPHI(Instruction::Or, Op0, Op1, Q, MaxRecurse))\n      return V;\n\n  return nullptr;\n}\n",
        "start": 2164,
        "end": 2300,
        "buggy": "static Value *SimplifyOrInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,\n                             unsigned MaxRecurse) {\n  if (Constant *C = foldOrCommuteConstant(Instruction::Or, Op0, Op1, Q))\n    return C;\n\n  // X | undef -> -1\n  // X | -1 = -1\n  // Do not return Op1 because it may contain undef elements if it's a vector.\n  if (match(Op1, m_Undef()) || match(Op1, m_AllOnes()))\n    return Constant::getAllOnesValue(Op0->getType());\n\n  // X | X = X\n  // X | 0 = X\n  if (Op0 == Op1 || match(Op1, m_Zero()))\n    return Op0;\n\n  // A | ~A  =  ~A | A  =  -1\n  if (match(Op0, m_Not(m_Specific(Op1))) ||\n      match(Op1, m_Not(m_Specific(Op0))))\n    return Constant::getAllOnesValue(Op0->getType());\n\n  // (A & ?) | A = A\n  if (match(Op0, m_c_And(m_Specific(Op1), m_Value())))\n    return Op1;\n\n  // A | (A & ?) = A\n  if (match(Op1, m_c_And(m_Specific(Op0), m_Value())))\n    return Op0;\n\n  // ~(A & ?) | A = -1\n  if (match(Op0, m_Not(m_c_And(m_Specific(Op1), m_Value()))))\n    return Constant::getAllOnesValue(Op1->getType());\n\n  // A | ~(A & ?) = -1\n  if (match(Op1, m_Not(m_c_And(m_Specific(Op1), m_Value()))))\n    return Constant::getAllOnesValue(Op0->getType());\n\n  Value *A, *B;\n  // (A & ~B) | (A ^ B) -> (A ^ B)\n  // (~B & A) | (A ^ B) -> (A ^ B)\n  // (A & ~B) | (B ^ A) -> (B ^ A)\n  // (~B & A) | (B ^ A) -> (B ^ A)\n  if (match(Op1, m_Xor(m_Value(A), m_Value(B))) &&\n      (match(Op0, m_c_And(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op0, m_c_And(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op1;\n\n  // Commute the 'or' operands.\n  // (A ^ B) | (A & ~B) -> (A ^ B)\n  // (A ^ B) | (~B & A) -> (A ^ B)\n  // (B ^ A) | (A & ~B) -> (B ^ A)\n  // (B ^ A) | (~B & A) -> (B ^ A)\n  if (match(Op0, m_Xor(m_Value(A), m_Value(B))) &&\n      (match(Op1, m_c_And(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op1, m_c_And(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op0;\n\n  // (A & B) | (~A ^ B) -> (~A ^ B)\n  // (B & A) | (~A ^ B) -> (~A ^ B)\n  // (A & B) | (B ^ ~A) -> (B ^ ~A)\n  // (B & A) | (B ^ ~A) -> (B ^ ~A)\n  if (match(Op0, m_And(m_Value(A), m_Value(B))) &&\n      (match(Op1, m_c_Xor(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op1, m_c_Xor(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op1;\n\n  // (~A ^ B) | (A & B) -> (~A ^ B)\n  // (~A ^ B) | (B & A) -> (~A ^ B)\n  // (B ^ ~A) | (A & B) -> (B ^ ~A)\n  // (B ^ ~A) | (B & A) -> (B ^ ~A)\n  if (match(Op1, m_And(m_Value(A), m_Value(B))) &&\n      (match(Op0, m_c_Xor(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op0, m_c_Xor(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op0;\n\n  if (Value *V = simplifyAndOrOfCmps(Q, Op0, Op1, false))\n    return V;\n\n  // If we have a multiplication overflow check that is being 'and'ed with a\n  // check that one of the multipliers is not zero, we can omit the 'and', and\n  // only keep the overflow check.\n  if (Value *V = omitCheckForZeroBeforeInvertedMulWithOverflow(Op0, Op1))\n    return V;\n  if (Value *V = omitCheckForZeroBeforeInvertedMulWithOverflow(Op1, Op0))\n    return V;\n\n  // Try some generic simplifications for associative operations.\n  if (Value *V = SimplifyAssociativeBinOp(Instruction::Or, Op0, Op1, Q,\n                                          MaxRecurse))\n    return V;\n\n  // Or distributes over And.  Try some generic simplifications based on this.\n  if (Value *V = ExpandBinOp(Instruction::Or, Op0, Op1, Instruction::And, Q,\n                             MaxRecurse))\n    return V;\n\n  // If the operation is with the result of a select instruction, check whether\n  // operating on either branch of the select always yields the same value.\n  if (isa<SelectInst>(Op0) || isa<SelectInst>(Op1))\n    if (Value *V = ThreadBinOpOverSelect(Instruction::Or, Op0, Op1, Q,\n                                         MaxRecurse))\n      return V;\n\n  // (A & C1)|(B & C2)\n  const APInt *C1, *C2;\n  if (match(Op0, m_And(m_Value(A), m_APInt(C1))) &&\n      match(Op1, m_And(m_Value(B), m_APInt(C2)))) {\n    if (*C1 == ~*C2) {\n      // (A & C1)|(B & C2)\n      // If we have: ((V + N) & C1) | (V & C2)\n      // .. and C2 = ~C1 and C2 is 0+1+ and (N & C2) == 0\n      // replace with V+N.\n      Value *N;\n      if (C2->isMask() && // C2 == 0+1+\n          match(A, m_c_Add(m_Specific(B), m_Value(N)))) {\n        // Add commutes, try both ways.\n        if (MaskedValueIsZero(N, *C2, Q.DL, 0, Q.AC, Q.CxtI, Q.DT))\n          return A;\n      }\n      // Or commutes, try both ways.\n      if (C1->isMask() &&\n          match(B, m_c_Add(m_Specific(A), m_Value(N)))) {\n        // Add commutes, try both ways.\n        if (MaskedValueIsZero(N, *C1, Q.DL, 0, Q.AC, Q.CxtI, Q.DT))\n          return B;\n      }\n    }\n  }\n\n  // If the operation is with the result of a phi instruction, check whether\n  // operating on all incoming values of the phi always yields the same value.\n  if (isa<PHINode>(Op0) || isa<PHINode>(Op1))\n    if (Value *V = ThreadBinOpOverPHI(Instruction::Or, Op0, Op1, Q, MaxRecurse))\n      return V;\n\n  return nullptr;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  if (match(Op1, m_Not(m_c_And(m_Specific(Op1), m_Value()))))\n",
        "src_path": "a9fe69c359de653015c39e413e48630d069abe27___InstructionSimplify.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/a9fe69c359de653015c39e413e48630d069abe27",
        "commit_msg": "[InstSimplify] fix bug in matching or-with-not op (PR46083)",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstSimplify/or.ll",
                "patch": "@@ -248,10 +248,7 @@ define <2 x i399> @test8_apint(<2 x i399> %V, <2 x i399> %M) {\n \n define i1 @or_with_not_op_commute1(i1 %a, i1 %b) {\n ; CHECK-LABEL: @or_with_not_op_commute1(\n-; CHECK-NEXT:    [[AB:%.*]] = and i1 [[A:%.*]], [[B:%.*]]\n-; CHECK-NEXT:    [[NOT:%.*]] = xor i1 [[AB]], true\n-; CHECK-NEXT:    [[R:%.*]] = or i1 [[A]], [[NOT]]\n-; CHECK-NEXT:    ret i1 [[R]]\n+; CHECK-NEXT:    ret i1 true\n ;\n   %ab = and i1 %a, %b\n   %not = xor i1 %ab, -1\n@@ -263,10 +260,7 @@ define i1 @or_with_not_op_commute1(i1 %a, i1 %b) {\n \n define i8 @or_with_not_op_commute2(i8 %a, i8 %b) {\n ; CHECK-LABEL: @or_with_not_op_commute2(\n-; CHECK-NEXT:    [[AB:%.*]] = and i8 [[B:%.*]], [[A:%.*]]\n-; CHECK-NEXT:    [[NOT:%.*]] = xor i8 [[AB]], -1\n-; CHECK-NEXT:    [[R:%.*]] = or i8 [[A]], [[NOT]]\n-; CHECK-NEXT:    ret i8 [[R]]\n+; CHECK-NEXT:    ret i8 -1\n ;\n   %ab = and i8 %b, %a\n   %not = xor i8 %ab, -1"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstSimplify/or.ll (1 of 1)\n********************\nFailing Tests (1):\n  LLVM :: Transforms/InstSimplify/or.ll\n\n\nTesting Time: 1.43s\n  Unexpected Failures: 1\n"
    },
    "a79e604462ea26c73b6869d71b41667819f90281___AssumeBundleQueries.cpp": {
        "prefix": "RetainedKnowledge\nllvm::getKnowledgeForValue(const Value *V,\n                           ArrayRef<Attribute::AttrKind> AttrKinds,\n                           AssumptionCache *AC,\n                           function_ref<bool(RetainedKnowledge, Instruction *,\n                                             const CallBase::BundleOpInfo *)>\n                               Filter) {\n  NumAssumeQueries++;\n  if (!DebugCounter::shouldExecute(AssumeQueryCounter))\n    return RetainedKnowledge::none();\n  if (AC) {\n    for (AssumptionCache::ResultElem &Elem : AC->assumptionsFor(V)) {\n      IntrinsicInst *II = cast_or_null<IntrinsicInst>(Elem.Assume);\n      if (!II || Elem.Index == AssumptionCache::ExprResultIdx)\n        continue;\n      if (RetainedKnowledge RK = getKnowledgeFromBundle(\n",
        "suffix": "        if (is_contained(AttrKinds, RK.AttrKind) &&\n            Filter(RK, II, &II->bundle_op_info_begin()[Elem.Index])) {\n          NumUsefullAssumeQueries++;\n          return RK;\n        }\n    }\n    return RetainedKnowledge::none();\n  }\n  for (const auto &U : V->uses()) {\n    CallInst::BundleOpInfo* Bundle = getBundleFromUse(&U);\n    if (!Bundle)\n      continue;\n    if (RetainedKnowledge RK =\n            getKnowledgeFromBundle(*cast<CallInst>(U.getUser()), *Bundle))\n      if (is_contained(AttrKinds, RK.AttrKind) &&\n          Filter(RK, cast<Instruction>(U.getUser()), Bundle)) {\n        NumUsefullAssumeQueries++;\n        return RK;\n      }\n  }\n  return RetainedKnowledge::none();\n}\n",
        "start": 159,
        "end": 197,
        "buggy": "RetainedKnowledge\nllvm::getKnowledgeForValue(const Value *V,\n                           ArrayRef<Attribute::AttrKind> AttrKinds,\n                           AssumptionCache *AC,\n                           function_ref<bool(RetainedKnowledge, Instruction *,\n                                             const CallBase::BundleOpInfo *)>\n                               Filter) {\n  NumAssumeQueries++;\n  if (!DebugCounter::shouldExecute(AssumeQueryCounter))\n    return RetainedKnowledge::none();\n  if (AC) {\n    for (AssumptionCache::ResultElem &Elem : AC->assumptionsFor(V)) {\n      IntrinsicInst *II = cast_or_null<IntrinsicInst>(Elem.Assume);\n      if (!II || Elem.Index == AssumptionCache::ExprResultIdx)\n        continue;\n      if (RetainedKnowledge RK = getKnowledgeFromBundle(\n              *II, II->bundle_op_info_begin()[Elem.Index]))\n        if (is_contained(AttrKinds, RK.AttrKind) &&\n            Filter(RK, II, &II->bundle_op_info_begin()[Elem.Index])) {\n          NumUsefullAssumeQueries++;\n          return RK;\n        }\n    }\n    return RetainedKnowledge::none();\n  }\n  for (const auto &U : V->uses()) {\n    CallInst::BundleOpInfo* Bundle = getBundleFromUse(&U);\n    if (!Bundle)\n      continue;\n    if (RetainedKnowledge RK =\n            getKnowledgeFromBundle(*cast<CallInst>(U.getUser()), *Bundle))\n      if (is_contained(AttrKinds, RK.AttrKind) &&\n          Filter(RK, cast<Instruction>(U.getUser()), Bundle)) {\n        NumUsefullAssumeQueries++;\n        return RK;\n      }\n  }\n  return RetainedKnowledge::none();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "              *II, II->bundle_op_info_begin()[Elem.Index]))\n",
        "src_path": "a79e604462ea26c73b6869d71b41667819f90281___AssumeBundleQueries.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/a79e604462ea26c73b6869d71b41667819f90281",
        "commit_msg": "[AssumeBundles] Fix Bug in Assume Queries\n\nthis bug was causing miscompile.\nnow clang cant properly selfhost with -mllvm --enable-knowledge-retention\n\nReviewed By: jdoerfert, lebedev.ri\n\nDifferential Revision: https://reviews.llvm.org/D83507",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/PhaseOrdering/d83507-knowledge-retention-bug.ll",
                "patch": "@@ -13,7 +13,10 @@ define %0* @f1() local_unnamed_addr {\n ; ANY-NEXT:    call void @llvm.assume(i1 true) [ \"nonnull\"(%0* [[I1]]) ]\n ; ANY-NEXT:    [[I4:%.*]] = getelementptr inbounds [[TMP0:%.*]], %0* [[I1]], i64 0, i32 0\n ; ANY-NEXT:    [[I5]] = load %0*, %0** [[I4]], align 8\n-; ANY-NEXT:    br label [[BB3]]\n+; ANY-NEXT:    [[I2:%.*]] = icmp eq %0* [[I5]], null\n+; ANY-NEXT:    br i1 [[I2]], label [[BB6:%.*]], label [[BB3]]\n+; ANY:       bb6:\n+; ANY-NEXT:    ret %0* undef\n ;\n bb:\n   br label %bb1"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/PhaseOrdering/d83507-knowledge-retention-bug.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/PhaseOrdering/d83507-knowledge-retention-bug.ll\n\n\nTesting Time: 0.42s\n  Failed: 1\n"
    },
    "96f372c1e7402595edd2ae9f86b9bdfa22dc1045___AsmWriter.cpp": {
        "prefix": "void BasicBlock::print(raw_ostream &ROS, AssemblyAnnotationWriter *AAW,\n                     bool ShouldPreserveUseListOrder,\n                     bool IsForDebug) const {\n",
        "suffix": "  formatted_raw_ostream OS(ROS);\n  AssemblyWriter W(OS, SlotTable, this->getModule(), AAW,\n                   IsForDebug,\n                   ShouldPreserveUseListOrder);\n  W.printBasicBlock(this);\n}\n",
        "start": 4417,
        "end": 4426,
        "buggy": "void BasicBlock::print(raw_ostream &ROS, AssemblyAnnotationWriter *AAW,\n                     bool ShouldPreserveUseListOrder,\n                     bool IsForDebug) const {\n  SlotTracker SlotTable(this->getModule());\n  formatted_raw_ostream OS(ROS);\n  AssemblyWriter W(OS, SlotTable, this->getModule(), AAW,\n                   IsForDebug,\n                   ShouldPreserveUseListOrder);\n  W.printBasicBlock(this);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  SlotTracker SlotTable(this->getModule());\n",
        "src_path": "96f372c1e7402595edd2ae9f86b9bdfa22dc1045___AsmWriter.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/96f372c1e7402595edd2ae9f86b9bdfa22dc1045",
        "commit_msg": "[AsmWriter] Construct SlotTracker with the function\n\nThis patch teaches BasicBlock::print to construct an instance of\nSlotTracker with the containing function.\n\nWithout this patch, we dump:\n\n*** IR Dump After LoopInstSimplifyPass ***\n; Preheader:\n  br label %1\n\n; Loop:\n<badref>:                                         ; preds = %1, %0\n  br label %1\n\nNote \"<badref>\" above.  This happens because BasicBlock::print calls:\n\n  SlotTracker SlotTable(this->getModule());\n\nNote that this constructor does not add the contents of functions to\nthe slot table.  That is, basic blocks are left unnumbered.\n\nThis patch fixes the problem by switching to:\n\n  SlotTracker SlotTable(this->getParent());\n\nwhich does add the contents of the Module and the function,\nthis->getParent(), to the slot table.\n\nDifferential Revision: https://reviews.llvm.org/D89567",
        "test_func_diff": [
            {
                "fn": "llvm/test/Other/bb-badref.ll",
                "patch": "@@ -0,0 +1,14 @@\n+; RUN: opt -passes=loop-instsimplify -print-after-all -disable-output -S < %s 2>&1 | FileCheck %s\n+\n+; loop-instsimplify dumps individual basic blocks as part of a loop,\n+; not a function.  Verify that the non-entry basic block is labeled as\n+; \"1\", not \"<badref>\".\n+\n+; CHECK-NOT: <badref>\n+\n+define void @foo() {\n+  br label %1\n+\n+1:\n+  br label %1\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Other/bb-badref.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Other/bb-badref.ll\n\n\nTesting Time: 0.41s\n  Failed: 1\n"
    },
    "09266e4af04ec2dc3a3afc19a3f9d5658d482a44___ObjCARCOpts.cpp": {
        "prefix": "void ObjCARCOpt::OptimizeReturns(Function &F) {\n  if (!F.getReturnType()->isPointerTy())\n    return;\n\n  LLVM_DEBUG(dbgs() << \"\\n== ObjCARCOpt::OptimizeReturns ==\\n\");\n\n  SmallPtrSet<Instruction *, 4> DependingInstructions;\n  SmallPtrSet<const BasicBlock *, 4> Visited;\n  for (BasicBlock &BB: F) {\n    ReturnInst *Ret = dyn_cast<ReturnInst>(&BB.back());\n    if (!Ret)\n      continue;\n\n    LLVM_DEBUG(dbgs() << \"Visiting: \" << *Ret << \"\\n\");\n\n    const Value *Arg = GetRCIdentityRoot(Ret->getOperand(0));\n\n    // Look for an ``autorelease'' instruction that is a predecessor of Ret and\n    // dependent on Arg such that there are no instructions dependent on Arg\n    // that need a positive ref count in between the autorelease and Ret.\n    CallInst *Autorelease =\n        FindPredecessorAutoreleaseWithSafePath(Arg, &BB, Ret, Visited, PA);\n    Visited.clear();\n\n    if (!Autorelease)\n      continue;\n\n    CallInst *Retain = FindPredecessorRetainWithSafePath(\n        Arg, Autorelease->getParent(), Autorelease, Visited, PA);\n    Visited.clear();\n\n    if (!Retain)\n      continue;\n\n    // Check that there is nothing that can affect the reference count\n    // between the retain and the call.  Note that Retain need not be in BB.\n    bool HasSafePathToCall = HasSafePathToPredecessorCall(Arg, Retain,\n                                                          DependingInstructions,\n                                                          Visited, PA);\n\n    // Don't remove retainRV/autoreleaseRV pairs if the call isn't a tail call.\n    if (HasSafePathToCall &&\n        GetBasicARCInstKind(Retain) == ARCInstKind::RetainRV &&\n        GetBasicARCInstKind(Autorelease) == ARCInstKind::AutoreleaseRV &&\n",
        "suffix": "      continue;\n\n    DependingInstructions.clear();\n    Visited.clear();\n\n    if (!HasSafePathToCall)\n      continue;\n\n    // If so, we can zap the retain and autorelease.\n    Changed = true;\n    ++NumRets;\n    LLVM_DEBUG(dbgs() << \"Erasing: \" << *Retain << \"\\nErasing: \" << *Autorelease\n                      << \"\\n\");\n    EraseInstruction(Retain);\n    EraseInstruction(Autorelease);\n  }\n}\n",
        "start": 2317,
        "end": 2378,
        "buggy": "void ObjCARCOpt::OptimizeReturns(Function &F) {\n  if (!F.getReturnType()->isPointerTy())\n    return;\n\n  LLVM_DEBUG(dbgs() << \"\\n== ObjCARCOpt::OptimizeReturns ==\\n\");\n\n  SmallPtrSet<Instruction *, 4> DependingInstructions;\n  SmallPtrSet<const BasicBlock *, 4> Visited;\n  for (BasicBlock &BB: F) {\n    ReturnInst *Ret = dyn_cast<ReturnInst>(&BB.back());\n    if (!Ret)\n      continue;\n\n    LLVM_DEBUG(dbgs() << \"Visiting: \" << *Ret << \"\\n\");\n\n    const Value *Arg = GetRCIdentityRoot(Ret->getOperand(0));\n\n    // Look for an ``autorelease'' instruction that is a predecessor of Ret and\n    // dependent on Arg such that there are no instructions dependent on Arg\n    // that need a positive ref count in between the autorelease and Ret.\n    CallInst *Autorelease =\n        FindPredecessorAutoreleaseWithSafePath(Arg, &BB, Ret, Visited, PA);\n    Visited.clear();\n\n    if (!Autorelease)\n      continue;\n\n    CallInst *Retain = FindPredecessorRetainWithSafePath(\n        Arg, Autorelease->getParent(), Autorelease, Visited, PA);\n    Visited.clear();\n\n    if (!Retain)\n      continue;\n\n    // Check that there is nothing that can affect the reference count\n    // between the retain and the call.  Note that Retain need not be in BB.\n    bool HasSafePathToCall = HasSafePathToPredecessorCall(Arg, Retain,\n                                                          DependingInstructions,\n                                                          Visited, PA);\n\n    // Don't remove retainRV/autoreleaseRV pairs if the call isn't a tail call.\n    if (HasSafePathToCall &&\n        GetBasicARCInstKind(Retain) == ARCInstKind::RetainRV &&\n        GetBasicARCInstKind(Autorelease) == ARCInstKind::AutoreleaseRV &&\n        !cast<CallInst>(*DependingInstructions.begin())->isTailCall())\n      continue;\n\n    DependingInstructions.clear();\n    Visited.clear();\n\n    if (!HasSafePathToCall)\n      continue;\n\n    // If so, we can zap the retain and autorelease.\n    Changed = true;\n    ++NumRets;\n    LLVM_DEBUG(dbgs() << \"Erasing: \" << *Retain << \"\\nErasing: \" << *Autorelease\n                      << \"\\n\");\n    EraseInstruction(Retain);\n    EraseInstruction(Autorelease);\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        !cast<CallInst>(*DependingInstructions.begin())->isTailCall())\n",
        "src_path": "09266e4af04ec2dc3a3afc19a3f9d5658d482a44___ObjCARCOpts.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/09266e4af04ec2dc3a3afc19a3f9d5658d482a44",
        "commit_msg": "[ObjC][ARC] Clear the lists of basic blocks and instructions before\ncontinuing the loop\n\nThis fixes a bug introduced in c6f1713c46e61bbb8ece9ac5ac329d02e7f93228.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/ObjCARC/rv.ll",
                "patch": "@@ -427,6 +427,31 @@ lpad:\n   resume { i8*, i32 } %4\n }\n \n+; The second retainRV/autoreleaseRV pair can be removed since the call to\n+; @returner is a tail call.\n+\n+; CHECK-LABEL: define i8* @test30(\n+; CHECK: %[[V0:.*]] = call i8* @returner()\n+; CHECK-NEXT: call i8* @llvm.objc.retainAutoreleasedReturnValue(i8* %[[V0]])\n+; CHECK-NEXT: call i8* @llvm.objc.autoreleaseReturnValue(i8* %[[V0]])\n+; CHECK-NEXT: ret i8* %[[V0]]\n+; CHECK: %[[V3:.*]] = tail call i8* @returner()\n+; CHECK-NEXT: ret i8* %[[V3]]\n+\n+define i8* @test30(i1 %cond) {\n+  br i1 %cond, label %bb0, label %bb1\n+bb0:\n+  %v0 = call i8* @returner()\n+  %v1 = call i8* @llvm.objc.retainAutoreleasedReturnValue(i8* %v0)\n+  %v2 = call i8* @llvm.objc.autoreleaseReturnValue(i8* %v0)\n+  ret i8* %v0\n+bb1:\n+  %v3 = tail call i8* @returner()\n+  %v4 = call i8* @llvm.objc.retainAutoreleasedReturnValue(i8* %v3)\n+  %v5 = call i8* @llvm.objc.autoreleaseReturnValue(i8* %v3)\n+  ret i8* %v3\n+}\n+\n !0 = !{}\n \n ; CHECK: attributes [[NUW]] = { nounwind }"
            }
        ],
        "error_msg": ""
    },
    "f748e92295515ea7b39cd687a718915b559de6ec___PassBuilder.cpp": {
        "prefix": "FunctionPassManager\nPassBuilder::buildFunctionSimplificationPipeline(OptimizationLevel Level,\n                                                 ThinLTOPhase Phase) {\n  assert(Level != OptimizationLevel::O0 && \"Must request optimizations!\");\n\n  // The O1 pipeline has a separate pipeline creation function to simplify\n  // construction readability.\n  if (Level.getSpeedupLevel() == 1)\n    return buildO1FunctionSimplificationPipeline(Level, Phase);\n\n  FunctionPassManager FPM(DebugLogging);\n\n  // Form SSA out of local memory accesses after breaking apart aggregates into\n  // scalars.\n  FPM.addPass(SROA());\n\n  // Catch trivial redundancies\n  FPM.addPass(EarlyCSEPass(true /* Enable mem-ssa. */));\n  if (EnableKnowledgeRetention)\n    FPM.addPass(AssumeSimplifyPass());\n\n  // Hoisting of scalars and load expressions.\n  if (EnableGVNHoist)\n    FPM.addPass(GVNHoistPass());\n\n  // Global value numbering based sinking.\n  if (EnableGVNSink) {\n    FPM.addPass(GVNSinkPass());\n    FPM.addPass(SimplifyCFGPass());\n  }\n\n  if (EnableConstraintElimination)\n    FPM.addPass(ConstraintEliminationPass());\n\n  // Speculative execution if the target has divergent branches; otherwise nop.\n  FPM.addPass(SpeculativeExecutionPass(/* OnlyIfDivergentTarget =*/true));\n\n  // Optimize based on known information about branches, and cleanup afterward.\n  FPM.addPass(JumpThreadingPass());\n  FPM.addPass(CorrelatedValuePropagationPass());\n\n  FPM.addPass(SimplifyCFGPass());\n  if (Level == OptimizationLevel::O3)\n    FPM.addPass(AggressiveInstCombinePass());\n  FPM.addPass(InstCombinePass());\n\n  if (!Level.isOptimizingForSize())\n    FPM.addPass(LibCallsShrinkWrapPass());\n\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  // For PGO use pipeline, try to optimize memory intrinsics such as memcpy\n  // using the size value profile. Don't perform this when optimizing for size.\n  if (PGOOpt && PGOOpt->Action == PGOOptions::IRUse &&\n      !Level.isOptimizingForSize())\n    FPM.addPass(PGOMemOPSizeOpt());\n\n  FPM.addPass(TailCallElimPass());\n  FPM.addPass(SimplifyCFGPass());\n\n  // Form canonically associated expression trees, and simplify the trees using\n  // basic mathematical properties. For example, this will form (nearly)\n  // minimal multiplication trees.\n  FPM.addPass(ReassociatePass());\n\n  // Add the primary loop simplification pipeline.\n  // FIXME: Currently this is split into two loop pass pipelines because we run\n  // some function passes in between them. These can and should be removed\n  // and/or replaced by scheduling the loop pass equivalents in the correct\n  // positions. But those equivalent passes aren't powerful enough yet.\n  // Specifically, `SimplifyCFGPass` and `InstCombinePass` are currently still\n  // used. We have `LoopSimplifyCFGPass` which isn't yet powerful enough yet to\n  // fully replace `SimplifyCFGPass`, and the closest to the other we have is\n  // `LoopInstSimplify`.\n  LoopPassManager LPM1(DebugLogging), LPM2(DebugLogging);\n\n  // Simplify the loop body. We do this initially to clean up after other loop\n  // passes run, either when iterating on a loop or on inner loops with\n  // implications on the outer loop.\n  LPM1.addPass(LoopInstSimplifyPass());\n  LPM1.addPass(LoopSimplifyCFGPass());\n\n  // Disable header duplication in loop rotation at -Oz.\n  LPM1.addPass(LoopRotatePass(Level != OptimizationLevel::Oz));\n  // TODO: Investigate promotion cap for O1.\n  LPM1.addPass(LICMPass(PTO.LicmMssaOptCap, PTO.LicmMssaNoAccForPromotionCap));\n",
        "suffix": "  LPM2.addPass(LoopIdiomRecognizePass());\n  LPM2.addPass(IndVarSimplifyPass());\n\n  for (auto &C : LateLoopOptimizationsEPCallbacks)\n    C(LPM2, Level);\n\n  LPM2.addPass(LoopDeletionPass());\n  // Do not enable unrolling in PreLinkThinLTO phase during sample PGO\n  // because it changes IR to makes profile annotation in back compile\n  // inaccurate. The normal unroller doesn't pay attention to forced full unroll\n  // attributes so we need to make sure and allow the full unroll pass to pay\n  // attention to it.\n  if (Phase != ThinLTOPhase::PreLink || !PGOOpt ||\n      PGOOpt->Action != PGOOptions::SampleUse)\n    LPM2.addPass(LoopFullUnrollPass(Level.getSpeedupLevel(),\n                                    /* OnlyWhenForced= */ !PTO.LoopUnrolling,\n                                    PTO.ForgetAllSCEVInLoopUnroll));\n\n  for (auto &C : LoopOptimizerEndEPCallbacks)\n    C(LPM2, Level);\n\n  // We provide the opt remark emitter pass for LICM to use. We only need to do\n  // this once as it is immutable.\n  FPM.addPass(\n      RequireAnalysisPass<OptimizationRemarkEmitterAnalysis, Function>());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      std::move(LPM1), EnableMSSALoopDependency, /*UseBlockFrequencyInfo=*/true,\n      DebugLogging));\n  FPM.addPass(SimplifyCFGPass());\n  FPM.addPass(InstCombinePass());\n  // The loop passes in LPM2 (LoopIdiomRecognizePass, IndVarSimplifyPass,\n  // LoopDeletionPass and LoopFullUnrollPass) do not preserve MemorySSA.\n  // *All* loop passes must preserve it, in order to be able to use it.\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      std::move(LPM2), /*UseMemorySSA=*/false, /*UseBlockFrequencyInfo=*/false,\n      DebugLogging));\n\n  // Delete small array after loop unroll.\n  FPM.addPass(SROA());\n\n  // Eliminate redundancies.\n  FPM.addPass(MergedLoadStoreMotionPass());\n  if (RunNewGVN)\n    FPM.addPass(NewGVNPass());\n  else\n    FPM.addPass(GVN());\n\n  // Specially optimize memory movement as it doesn't look like dataflow in SSA.\n  FPM.addPass(MemCpyOptPass());\n\n  // Sparse conditional constant propagation.\n  // FIXME: It isn't clear why we do this *after* loop passes rather than\n  // before...\n  FPM.addPass(SCCPPass());\n\n  // Delete dead bit computations (instcombine runs after to fold away the dead\n  // computations, and then ADCE will run later to exploit any new DCE\n  // opportunities that creates).\n  FPM.addPass(BDCEPass());\n\n  // Run instcombine after redundancy and dead bit elimination to exploit\n  // opportunities opened up by them.\n  FPM.addPass(InstCombinePass());\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  // Re-consider control flow based optimizations after redundancy elimination,\n  // redo DCE, etc.\n  FPM.addPass(JumpThreadingPass());\n  FPM.addPass(CorrelatedValuePropagationPass());\n\n  // Finally, do an expensive DCE pass to catch all the dead code exposed by\n  // the simplifications and basic cleanup after all the simplifications.\n  // TODO: Investigate if this is too expensive.\n  FPM.addPass(ADCEPass());\n\n  FPM.addPass(DSEPass());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      LICMPass(PTO.LicmMssaOptCap, PTO.LicmMssaNoAccForPromotionCap),\n      EnableMSSALoopDependency, /*UseBlockFrequencyInfo=*/true, DebugLogging));\n\n  if (PTO.Coroutines)\n    FPM.addPass(CoroElidePass());\n\n  for (auto &C : ScalarOptimizerLateEPCallbacks)\n    C(FPM, Level);\n\n  FPM.addPass(SimplifyCFGPass());\n  FPM.addPass(InstCombinePass());\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  if (EnableCHR && Level == OptimizationLevel::O3 && PGOOpt &&\n      (PGOOpt->Action == PGOOptions::IRUse ||\n       PGOOpt->Action == PGOOptions::SampleUse))\n    FPM.addPass(ControlHeightReductionPass());\n\n  return FPM;\n}\n",
        "start": 641,
        "end": 824,
        "buggy": "FunctionPassManager\nPassBuilder::buildFunctionSimplificationPipeline(OptimizationLevel Level,\n                                                 ThinLTOPhase Phase) {\n  assert(Level != OptimizationLevel::O0 && \"Must request optimizations!\");\n\n  // The O1 pipeline has a separate pipeline creation function to simplify\n  // construction readability.\n  if (Level.getSpeedupLevel() == 1)\n    return buildO1FunctionSimplificationPipeline(Level, Phase);\n\n  FunctionPassManager FPM(DebugLogging);\n\n  // Form SSA out of local memory accesses after breaking apart aggregates into\n  // scalars.\n  FPM.addPass(SROA());\n\n  // Catch trivial redundancies\n  FPM.addPass(EarlyCSEPass(true /* Enable mem-ssa. */));\n  if (EnableKnowledgeRetention)\n    FPM.addPass(AssumeSimplifyPass());\n\n  // Hoisting of scalars and load expressions.\n  if (EnableGVNHoist)\n    FPM.addPass(GVNHoistPass());\n\n  // Global value numbering based sinking.\n  if (EnableGVNSink) {\n    FPM.addPass(GVNSinkPass());\n    FPM.addPass(SimplifyCFGPass());\n  }\n\n  if (EnableConstraintElimination)\n    FPM.addPass(ConstraintEliminationPass());\n\n  // Speculative execution if the target has divergent branches; otherwise nop.\n  FPM.addPass(SpeculativeExecutionPass(/* OnlyIfDivergentTarget =*/true));\n\n  // Optimize based on known information about branches, and cleanup afterward.\n  FPM.addPass(JumpThreadingPass());\n  FPM.addPass(CorrelatedValuePropagationPass());\n\n  FPM.addPass(SimplifyCFGPass());\n  if (Level == OptimizationLevel::O3)\n    FPM.addPass(AggressiveInstCombinePass());\n  FPM.addPass(InstCombinePass());\n\n  if (!Level.isOptimizingForSize())\n    FPM.addPass(LibCallsShrinkWrapPass());\n\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  // For PGO use pipeline, try to optimize memory intrinsics such as memcpy\n  // using the size value profile. Don't perform this when optimizing for size.\n  if (PGOOpt && PGOOpt->Action == PGOOptions::IRUse &&\n      !Level.isOptimizingForSize())\n    FPM.addPass(PGOMemOPSizeOpt());\n\n  FPM.addPass(TailCallElimPass());\n  FPM.addPass(SimplifyCFGPass());\n\n  // Form canonically associated expression trees, and simplify the trees using\n  // basic mathematical properties. For example, this will form (nearly)\n  // minimal multiplication trees.\n  FPM.addPass(ReassociatePass());\n\n  // Add the primary loop simplification pipeline.\n  // FIXME: Currently this is split into two loop pass pipelines because we run\n  // some function passes in between them. These can and should be removed\n  // and/or replaced by scheduling the loop pass equivalents in the correct\n  // positions. But those equivalent passes aren't powerful enough yet.\n  // Specifically, `SimplifyCFGPass` and `InstCombinePass` are currently still\n  // used. We have `LoopSimplifyCFGPass` which isn't yet powerful enough yet to\n  // fully replace `SimplifyCFGPass`, and the closest to the other we have is\n  // `LoopInstSimplify`.\n  LoopPassManager LPM1(DebugLogging), LPM2(DebugLogging);\n\n  // Simplify the loop body. We do this initially to clean up after other loop\n  // passes run, either when iterating on a loop or on inner loops with\n  // implications on the outer loop.\n  LPM1.addPass(LoopInstSimplifyPass());\n  LPM1.addPass(LoopSimplifyCFGPass());\n\n  // Disable header duplication in loop rotation at -Oz.\n  LPM1.addPass(LoopRotatePass(Level != OptimizationLevel::Oz));\n  // TODO: Investigate promotion cap for O1.\n  LPM1.addPass(LICMPass(PTO.LicmMssaOptCap, PTO.LicmMssaNoAccForPromotionCap));\n  LPM1.addPass(SimpleLoopUnswitchPass());\n  LPM2.addPass(LoopIdiomRecognizePass());\n  LPM2.addPass(IndVarSimplifyPass());\n\n  for (auto &C : LateLoopOptimizationsEPCallbacks)\n    C(LPM2, Level);\n\n  LPM2.addPass(LoopDeletionPass());\n  // Do not enable unrolling in PreLinkThinLTO phase during sample PGO\n  // because it changes IR to makes profile annotation in back compile\n  // inaccurate. The normal unroller doesn't pay attention to forced full unroll\n  // attributes so we need to make sure and allow the full unroll pass to pay\n  // attention to it.\n  if (Phase != ThinLTOPhase::PreLink || !PGOOpt ||\n      PGOOpt->Action != PGOOptions::SampleUse)\n    LPM2.addPass(LoopFullUnrollPass(Level.getSpeedupLevel(),\n                                    /* OnlyWhenForced= */ !PTO.LoopUnrolling,\n                                    PTO.ForgetAllSCEVInLoopUnroll));\n\n  for (auto &C : LoopOptimizerEndEPCallbacks)\n    C(LPM2, Level);\n\n  // We provide the opt remark emitter pass for LICM to use. We only need to do\n  // this once as it is immutable.\n  FPM.addPass(\n      RequireAnalysisPass<OptimizationRemarkEmitterAnalysis, Function>());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      std::move(LPM1), EnableMSSALoopDependency, /*UseBlockFrequencyInfo=*/true,\n      DebugLogging));\n  FPM.addPass(SimplifyCFGPass());\n  FPM.addPass(InstCombinePass());\n  // The loop passes in LPM2 (LoopIdiomRecognizePass, IndVarSimplifyPass,\n  // LoopDeletionPass and LoopFullUnrollPass) do not preserve MemorySSA.\n  // *All* loop passes must preserve it, in order to be able to use it.\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      std::move(LPM2), /*UseMemorySSA=*/false, /*UseBlockFrequencyInfo=*/false,\n      DebugLogging));\n\n  // Delete small array after loop unroll.\n  FPM.addPass(SROA());\n\n  // Eliminate redundancies.\n  FPM.addPass(MergedLoadStoreMotionPass());\n  if (RunNewGVN)\n    FPM.addPass(NewGVNPass());\n  else\n    FPM.addPass(GVN());\n\n  // Specially optimize memory movement as it doesn't look like dataflow in SSA.\n  FPM.addPass(MemCpyOptPass());\n\n  // Sparse conditional constant propagation.\n  // FIXME: It isn't clear why we do this *after* loop passes rather than\n  // before...\n  FPM.addPass(SCCPPass());\n\n  // Delete dead bit computations (instcombine runs after to fold away the dead\n  // computations, and then ADCE will run later to exploit any new DCE\n  // opportunities that creates).\n  FPM.addPass(BDCEPass());\n\n  // Run instcombine after redundancy and dead bit elimination to exploit\n  // opportunities opened up by them.\n  FPM.addPass(InstCombinePass());\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  // Re-consider control flow based optimizations after redundancy elimination,\n  // redo DCE, etc.\n  FPM.addPass(JumpThreadingPass());\n  FPM.addPass(CorrelatedValuePropagationPass());\n\n  // Finally, do an expensive DCE pass to catch all the dead code exposed by\n  // the simplifications and basic cleanup after all the simplifications.\n  // TODO: Investigate if this is too expensive.\n  FPM.addPass(ADCEPass());\n\n  FPM.addPass(DSEPass());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      LICMPass(PTO.LicmMssaOptCap, PTO.LicmMssaNoAccForPromotionCap),\n      EnableMSSALoopDependency, /*UseBlockFrequencyInfo=*/true, DebugLogging));\n\n  if (PTO.Coroutines)\n    FPM.addPass(CoroElidePass());\n\n  for (auto &C : ScalarOptimizerLateEPCallbacks)\n    C(FPM, Level);\n\n  FPM.addPass(SimplifyCFGPass());\n  FPM.addPass(InstCombinePass());\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  if (EnableCHR && Level == OptimizationLevel::O3 && PGOOpt &&\n      (PGOOpt->Action == PGOOptions::IRUse ||\n       PGOOpt->Action == PGOOptions::SampleUse))\n    FPM.addPass(ControlHeightReductionPass());\n\n  return FPM;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  LPM1.addPass(SimpleLoopUnswitchPass());\n",
        "src_path": "f748e92295515ea7b39cd687a718915b559de6ec___PassBuilder.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/f748e92295515ea7b39cd687a718915b559de6ec",
        "commit_msg": "[NewPM] Run non-trivial loop unswitching under -O2/3/s/z\n\nFixes https://bugs.llvm.org/show_bug.cgi?id=48715.\n\nReviewed By: asbirlea\n\nDifferential Revision: https://reviews.llvm.org/D94448",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/LoopUnroll/opt-levels.ll",
                "patch": "@@ -7,10 +7,10 @@\n ; the behavior, we artificially disable unrolling for anything but O3 by setting\n ; the default threshold to 0.\n \n-; O3:     loop2.preheader\n-; O2-NOT: loop2.preheader\n-; Os-NOT: loop2.preheader\n-; Oz-NOT: loop2.preheader\n+; O3:     loop1.preheader\n+; O2-NOT: loop1.preheader\n+; Os-NOT: loop1.preheader\n+; Oz-NOT: loop1.preheader\n \n define void @unroll(i32 %iter, i32* %addr1, i32* %addr2) nounwind {\n entry:"
            },
            {
                "fn": "llvm/test/Transforms/SimpleLoopUnswitch/pipeline.ll",
                "patch": "@@ -0,0 +1,39 @@\n+; RUN: opt < %s -S -passes=\"default<O1>\" | FileCheck %s -check-prefix=O1\n+; RUN: opt < %s -S -passes=\"default<O2>\" | FileCheck %s -check-prefix=O2\n+\n+declare i32 @a()\n+declare i32 @b()\n+declare i32 @c()\n+\n+; O1-NOT: loop_begin.us:\n+; O2: loop_begin.us:\n+\n+define i32 @test1(i1* %ptr, i1 %cond1, i1 %cond2) {\n+entry:\n+  br label %loop_begin\n+\n+loop_begin:\n+  br i1 %cond1, label %loop_a, label %loop_b\n+\n+loop_a:\n+  call i32 @a()\n+  br label %latch\n+\n+loop_b:\n+  br i1 %cond2, label %loop_b_a, label %loop_b_b\n+\n+loop_b_a:\n+  call i32 @b()\n+  br label %latch\n+\n+loop_b_b:\n+  call i32 @c()\n+  br label %latch\n+\n+latch:\n+  %v = load i1, i1* %ptr\n+  br i1 %v, label %loop_begin, label %loop_exit\n+\n+loop_exit:\n+  ret i32 0\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/LoopUnroll/opt-levels.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopUnroll/opt-levels.ll\n\n\nTesting Time: 0.27s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/SimpleLoopUnswitch/pipeline.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SimpleLoopUnswitch/pipeline.ll\n\n\nTesting Time: 0.18s\n  Failed: 1\n"
    },
    "875891a10d50a791d3f076c9259e60af6c9af18c___MemoryDependenceAnalysis.cpp": {
        "prefix": "MemDepResult\nMemoryDependenceResults::getInvariantGroupPointerDependency(LoadInst *LI,\n                                                            BasicBlock *BB) {\n\n  if (!LI->hasMetadata(LLVMContext::MD_invariant_group))\n    return MemDepResult::getUnknown();\n\n  // Take the ptr operand after all casts and geps 0. This way we can search\n  // cast graph down only.\n  Value *LoadOperand = LI->getPointerOperand()->stripPointerCasts();\n\n  // It's is not safe to walk the use list of global value, because function\n  // passes aren't allowed to look outside their functions.\n  // FIXME: this could be fixed by filtering instructions from outside\n  // of current function.\n  if (isa<GlobalValue>(LoadOperand))\n    return MemDepResult::getUnknown();\n\n  // Queue to process all pointers that are equivalent to load operand.\n  SmallVector<const Value *, 8> LoadOperandsQueue;\n  LoadOperandsQueue.push_back(LoadOperand);\n\n  Instruction *ClosestDependency = nullptr;\n  // Order of instructions in uses list is unpredictible. In order to always\n  // get the same result, we will look for the closest dominance.\n  auto GetClosestDependency = [this](Instruction *Best, Instruction *Other) {\n    assert(Other && \"Must call it with not null instruction\");\n    if (Best == nullptr || DT.dominates(Best, Other))\n      return Other;\n    return Best;\n  };\n\n  // FIXME: This loop is O(N^2) because dominates can be O(n) and in worst case\n  // we will see all the instructions. This should be fixed in MSSA.\n  while (!LoadOperandsQueue.empty()) {\n    const Value *Ptr = LoadOperandsQueue.pop_back_val();\n    assert(Ptr && !isa<GlobalValue>(Ptr) &&\n           \"Null or GlobalValue should not be inserted\");\n\n    for (const Use &Us : Ptr->uses()) {\n      auto *U = dyn_cast<Instruction>(Us.getUser());\n      if (!U || U == LI || !DT.dominates(U, LI))\n        continue;\n\n      // Bitcast or gep with zeros are using Ptr. Add to queue to check it's\n      // users.      U = bitcast Ptr\n      if (isa<BitCastInst>(U)) {\n        LoadOperandsQueue.push_back(U);\n        continue;\n      }\n      // Gep with zeros is equivalent to bitcast.\n      // FIXME: we are not sure if some bitcast should be canonicalized to gep 0\n      // or gep 0 to bitcast because of SROA, so there are 2 forms. When\n      // typeless pointers will be ready then both cases will be gone\n      // (and this BFS also won't be needed).\n      if (auto *GEP = dyn_cast<GetElementPtrInst>(U))\n        if (GEP->hasAllZeroIndices()) {\n          LoadOperandsQueue.push_back(U);\n          continue;\n        }\n\n      // If we hit load/store with the same invariant.group metadata (and the\n      // same pointer operand) we can assume that value pointed by pointer\n      // operand didn't change.\n",
        "suffix": "          U->hasMetadata(LLVMContext::MD_invariant_group))\n        ClosestDependency = GetClosestDependency(ClosestDependency, U);\n    }\n  }\n\n  if (!ClosestDependency)\n    return MemDepResult::getUnknown();\n  if (ClosestDependency->getParent() == BB)\n    return MemDepResult::getDef(ClosestDependency);\n  // Def(U) can't be returned here because it is non-local. If local\n  // dependency won't be found then return nonLocal counting that the\n  // user will call getNonLocalPointerDependency, which will return cached\n  // result.\n  NonLocalDefsCache.try_emplace(\n      LI, NonLocalDepResult(ClosestDependency->getParent(),\n                            MemDepResult::getDef(ClosestDependency), nullptr));\n  ReverseNonLocalDefsCache[ClosestDependency].insert(LI);\n  return MemDepResult::getNonLocal();\n}\n",
        "start": 283,
        "end": 366,
        "buggy": "MemDepResult\nMemoryDependenceResults::getInvariantGroupPointerDependency(LoadInst *LI,\n                                                            BasicBlock *BB) {\n\n  if (!LI->hasMetadata(LLVMContext::MD_invariant_group))\n    return MemDepResult::getUnknown();\n\n  // Take the ptr operand after all casts and geps 0. This way we can search\n  // cast graph down only.\n  Value *LoadOperand = LI->getPointerOperand()->stripPointerCasts();\n\n  // It's is not safe to walk the use list of global value, because function\n  // passes aren't allowed to look outside their functions.\n  // FIXME: this could be fixed by filtering instructions from outside\n  // of current function.\n  if (isa<GlobalValue>(LoadOperand))\n    return MemDepResult::getUnknown();\n\n  // Queue to process all pointers that are equivalent to load operand.\n  SmallVector<const Value *, 8> LoadOperandsQueue;\n  LoadOperandsQueue.push_back(LoadOperand);\n\n  Instruction *ClosestDependency = nullptr;\n  // Order of instructions in uses list is unpredictible. In order to always\n  // get the same result, we will look for the closest dominance.\n  auto GetClosestDependency = [this](Instruction *Best, Instruction *Other) {\n    assert(Other && \"Must call it with not null instruction\");\n    if (Best == nullptr || DT.dominates(Best, Other))\n      return Other;\n    return Best;\n  };\n\n  // FIXME: This loop is O(N^2) because dominates can be O(n) and in worst case\n  // we will see all the instructions. This should be fixed in MSSA.\n  while (!LoadOperandsQueue.empty()) {\n    const Value *Ptr = LoadOperandsQueue.pop_back_val();\n    assert(Ptr && !isa<GlobalValue>(Ptr) &&\n           \"Null or GlobalValue should not be inserted\");\n\n    for (const Use &Us : Ptr->uses()) {\n      auto *U = dyn_cast<Instruction>(Us.getUser());\n      if (!U || U == LI || !DT.dominates(U, LI))\n        continue;\n\n      // Bitcast or gep with zeros are using Ptr. Add to queue to check it's\n      // users.      U = bitcast Ptr\n      if (isa<BitCastInst>(U)) {\n        LoadOperandsQueue.push_back(U);\n        continue;\n      }\n      // Gep with zeros is equivalent to bitcast.\n      // FIXME: we are not sure if some bitcast should be canonicalized to gep 0\n      // or gep 0 to bitcast because of SROA, so there are 2 forms. When\n      // typeless pointers will be ready then both cases will be gone\n      // (and this BFS also won't be needed).\n      if (auto *GEP = dyn_cast<GetElementPtrInst>(U))\n        if (GEP->hasAllZeroIndices()) {\n          LoadOperandsQueue.push_back(U);\n          continue;\n        }\n\n      // If we hit load/store with the same invariant.group metadata (and the\n      // same pointer operand) we can assume that value pointed by pointer\n      // operand didn't change.\n      if ((isa<LoadInst>(U) || isa<StoreInst>(U)) &&\n          U->hasMetadata(LLVMContext::MD_invariant_group))\n        ClosestDependency = GetClosestDependency(ClosestDependency, U);\n    }\n  }\n\n  if (!ClosestDependency)\n    return MemDepResult::getUnknown();\n  if (ClosestDependency->getParent() == BB)\n    return MemDepResult::getDef(ClosestDependency);\n  // Def(U) can't be returned here because it is non-local. If local\n  // dependency won't be found then return nonLocal counting that the\n  // user will call getNonLocalPointerDependency, which will return cached\n  // result.\n  NonLocalDefsCache.try_emplace(\n      LI, NonLocalDepResult(ClosestDependency->getParent(),\n                            MemDepResult::getDef(ClosestDependency), nullptr));\n  ReverseNonLocalDefsCache[ClosestDependency].insert(LI);\n  return MemDepResult::getNonLocal();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      if ((isa<LoadInst>(U) || isa<StoreInst>(U)) &&\n",
        "src_path": "875891a10d50a791d3f076c9259e60af6c9af18c___MemoryDependenceAnalysis.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/875891a10d50a791d3f076c9259e60af6c9af18c",
        "commit_msg": "[MemoryDependence] Fix invariant group store\n\nFix bug in MemoryDependence [and thus GVN] for invariant group.\n\nPreviously MemDep didn't verify that the store was storing into a\npointer rather than a store simply using a pointer.\n\nDifferential Revision: https://reviews.llvm.org/D98267",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/GVN/storeinvgroup.ll",
                "patch": "@@ -0,0 +1,21 @@\n+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py\n+; RUN: opt -gvn -S -o - < %s | FileCheck %s\n+\n+define double @code(double* %a1) {\n+; CHECK-LABEL: @code(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    [[META:%.*]] = alloca double*, align 8\n+; CHECK-NEXT:    store double 1.234500e+00, double* [[A1:%.*]], align 8\n+; CHECK-NEXT:    store double* [[A1]], double** [[META]], align 8, !invariant.group !0\n+; CHECK-NEXT:    ret double 1.234500e+00\n+;\n+entry:\n+  %meta = alloca double*\n+  store double 1.23450000e+00, double* %a1, align 8\n+  store double* %a1, double** %meta, align 8, !invariant.group !0\n+  %iload = load double, double* %a1, align 8, !invariant.group !1\n+  ret double %iload\n+}\n+\n+!0 = distinct !{}\n+!1 = distinct !{}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/GVN/storeinvgroup.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/GVN/storeinvgroup.ll\n\n\nTesting Time: 0.42s\n  Failed: 1\n"
    },
    "ce066da81c3e6175a02fa7ae831931b5e4126a2b___BasicAliasAnalysis.cpp": {
        "prefix": "bool BasicAAResult::constantOffsetHeuristic(\n    const SmallVectorImpl<VariableGEPIndex> &VarIndices,\n    LocationSize MaybeV1Size, LocationSize MaybeV2Size, const APInt &BaseOffset,\n    AssumptionCache *AC, DominatorTree *DT) {\n  if (VarIndices.size() != 2 || !MaybeV1Size.hasValue() ||\n      !MaybeV2Size.hasValue())\n    return false;\n\n  const uint64_t V1Size = MaybeV1Size.getValue();\n  const uint64_t V2Size = MaybeV2Size.getValue();\n\n  const VariableGEPIndex &Var0 = VarIndices[0], &Var1 = VarIndices[1];\n\n  if (Var0.ZExtBits != Var1.ZExtBits || Var0.SExtBits != Var1.SExtBits ||\n",
        "suffix": "    return false;\n\n  // We'll strip off the Extensions of Var0 and Var1 and do another round\n  // of GetLinearExpression decomposition. In the example above, if Var0\n  // is zext(%x + 1) we should get V1 == %x and V1Offset == 1.\n\n  LinearExpression E0 =\n      GetLinearExpression(ExtendedValue(Var0.V), DL, 0, AC, DT);\n  LinearExpression E1 =\n      GetLinearExpression(ExtendedValue(Var1.V), DL, 0, AC, DT);\n  if (E0.Scale != E1.Scale || E0.Val.ZExtBits != E1.Val.ZExtBits ||\n      E0.Val.SExtBits != E1.Val.SExtBits ||\n      !isValueEqualInPotentialCycles(E0.Val.V, E1.Val.V))\n    return false;\n\n  // We have a hit - Var0 and Var1 only differ by a constant offset!\n\n  // If we've been sext'ed then zext'd the maximum difference between Var0 and\n  // Var1 is possible to calculate, but we're just interested in the absolute\n  // minimum difference between the two. The minimum distance may occur due to\n  // wrapping; consider \"add i3 %i, 5\": if %i == 7 then 7 + 5 mod 8 == 4, and so\n  // the minimum distance between %i and %i + 5 is 3.\n  APInt MinDiff = E0.Offset - E1.Offset, Wrapped = -MinDiff;\n  MinDiff = APIntOps::umin(MinDiff, Wrapped);\n  APInt MinDiffBytes =\n    MinDiff.zextOrTrunc(Var0.Scale.getBitWidth()) * Var0.Scale.abs();\n\n  // We can't definitely say whether GEP1 is before or after V2 due to wrapping\n  // arithmetic (i.e. for some values of GEP1 and V2 GEP1 < V2, and for other\n  // values GEP1 > V2). We'll therefore only declare NoAlias if both V1Size and\n  // V2Size can fit in the MinDiffBytes gap.\n  return MinDiffBytes.uge(V1Size + BaseOffset.abs()) &&\n         MinDiffBytes.uge(V2Size + BaseOffset.abs());\n}\n",
        "start": 1714,
        "end": 1762,
        "buggy": "bool BasicAAResult::constantOffsetHeuristic(\n    const SmallVectorImpl<VariableGEPIndex> &VarIndices,\n    LocationSize MaybeV1Size, LocationSize MaybeV2Size, const APInt &BaseOffset,\n    AssumptionCache *AC, DominatorTree *DT) {\n  if (VarIndices.size() != 2 || !MaybeV1Size.hasValue() ||\n      !MaybeV2Size.hasValue())\n    return false;\n\n  const uint64_t V1Size = MaybeV1Size.getValue();\n  const uint64_t V2Size = MaybeV2Size.getValue();\n\n  const VariableGEPIndex &Var0 = VarIndices[0], &Var1 = VarIndices[1];\n\n  if (Var0.ZExtBits != Var1.ZExtBits || Var0.SExtBits != Var1.SExtBits ||\n      Var0.Scale != -Var1.Scale)\n    return false;\n\n  // We'll strip off the Extensions of Var0 and Var1 and do another round\n  // of GetLinearExpression decomposition. In the example above, if Var0\n  // is zext(%x + 1) we should get V1 == %x and V1Offset == 1.\n\n  LinearExpression E0 =\n      GetLinearExpression(ExtendedValue(Var0.V), DL, 0, AC, DT);\n  LinearExpression E1 =\n      GetLinearExpression(ExtendedValue(Var1.V), DL, 0, AC, DT);\n  if (E0.Scale != E1.Scale || E0.Val.ZExtBits != E1.Val.ZExtBits ||\n      E0.Val.SExtBits != E1.Val.SExtBits ||\n      !isValueEqualInPotentialCycles(E0.Val.V, E1.Val.V))\n    return false;\n\n  // We have a hit - Var0 and Var1 only differ by a constant offset!\n\n  // If we've been sext'ed then zext'd the maximum difference between Var0 and\n  // Var1 is possible to calculate, but we're just interested in the absolute\n  // minimum difference between the two. The minimum distance may occur due to\n  // wrapping; consider \"add i3 %i, 5\": if %i == 7 then 7 + 5 mod 8 == 4, and so\n  // the minimum distance between %i and %i + 5 is 3.\n  APInt MinDiff = E0.Offset - E1.Offset, Wrapped = -MinDiff;\n  MinDiff = APIntOps::umin(MinDiff, Wrapped);\n  APInt MinDiffBytes =\n    MinDiff.zextOrTrunc(Var0.Scale.getBitWidth()) * Var0.Scale.abs();\n\n  // We can't definitely say whether GEP1 is before or after V2 due to wrapping\n  // arithmetic (i.e. for some values of GEP1 and V2 GEP1 < V2, and for other\n  // values GEP1 > V2). We'll therefore only declare NoAlias if both V1Size and\n  // V2Size can fit in the MinDiffBytes gap.\n  return MinDiffBytes.uge(V1Size + BaseOffset.abs()) &&\n         MinDiffBytes.uge(V2Size + BaseOffset.abs());\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      Var0.Scale != -Var1.Scale)\n",
        "src_path": "ce066da81c3e6175a02fa7ae831931b5e4126a2b___BasicAliasAnalysis.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/ce066da81c3e6175a02fa7ae831931b5e4126a2b",
        "commit_msg": "[BasicAA] Make sure types match in constant offset heuristic\n\nThis can only happen if offset types that are larger than the\npointer size are involved. The previous implementation did not\nassert in this case because it initialized the APInts to the\nwidth of one of the variables -- though I strongly suspect it\ndid not compute correct results in this case.\n\nFixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=32621\nreported by fhahn.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Analysis/BasicAA/q.bad.ll",
                "patch": "@@ -178,3 +178,11 @@ define void @constantOffsetHeuristic_i8_i8(i8* %mem, i8 %val) {\n   %c = bitcast i8* %c.8 to i32*\n   ret void\n }\n+\n+; CHECK-LABEL: different_large_bitwidths\n+; MayAlias: i64* %p1, i64* %p2\n+define void @different_large_bitwidths(i8* %a, i64 %i, i128 %j) {\n+  %p1 = getelementptr i8, i8* %a, i64 %i\n+  %p2 = getelementptr i8, i8* %a, i128 %j\n+  ret void\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Analysis/BasicAA/q.bad.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Analysis/BasicAA/q.bad.ll\n\n\nTesting Time: 3.12s\n  Failed: 1\n"
    },
    "74f98391a7a42eccd7aa96546892cb9b65a39edb___X86ISelLowering.cpp": {
        "prefix": "static SDValue combineSetCCMOVMSK(SDValue EFLAGS, X86::CondCode &CC,\n                                  SelectionDAG &DAG,\n                                  const X86Subtarget &Subtarget) {\n  // Handle eq/ne against zero (any_of).\n  // Handle eq/ne against -1 (all_of).\n  if (!(CC == X86::COND_E || CC == X86::COND_NE))\n    return SDValue();\n  if (EFLAGS.getValueType() != MVT::i32)\n    return SDValue();\n  unsigned CmpOpcode = EFLAGS.getOpcode();\n  if (CmpOpcode != X86ISD::CMP && CmpOpcode != X86ISD::SUB)\n    return SDValue();\n  auto *CmpConstant = dyn_cast<ConstantSDNode>(EFLAGS.getOperand(1));\n  if (!CmpConstant)\n    return SDValue();\n  const APInt &CmpVal = CmpConstant->getAPIntValue();\n\n  SDValue CmpOp = EFLAGS.getOperand(0);\n  unsigned CmpBits = CmpOp.getValueSizeInBits();\n  assert(CmpBits == CmpVal.getBitWidth() && \"Value size mismatch\");\n\n  // Peek through any truncate.\n  if (CmpOp.getOpcode() == ISD::TRUNCATE)\n    CmpOp = CmpOp.getOperand(0);\n\n  // Bail if we don't find a MOVMSK.\n  if (CmpOp.getOpcode() != X86ISD::MOVMSK)\n    return SDValue();\n\n  SDValue Vec = CmpOp.getOperand(0);\n  MVT VecVT = Vec.getSimpleValueType();\n  assert((VecVT.is128BitVector() || VecVT.is256BitVector()) &&\n         \"Unexpected MOVMSK operand\");\n  unsigned NumElts = VecVT.getVectorNumElements();\n  unsigned NumEltBits = VecVT.getScalarSizeInBits();\n\n  bool IsAnyOf = CmpOpcode == X86ISD::CMP && CmpVal.isNullValue();\n  bool IsAllOf = CmpOpcode == X86ISD::SUB && NumElts <= CmpBits &&\n                 CmpVal.isMask(NumElts);\n  if (!IsAnyOf && !IsAllOf)\n    return SDValue();\n\n  // See if we can peek through to a vector with a wider element type, if the\n  // signbits extend down to all the sub-elements as well.\n  // Calling MOVMSK with the wider type, avoiding the bitcast, helps expose\n  // potential SimplifyDemandedBits/Elts cases.\n  if (Vec.getOpcode() == ISD::BITCAST) {\n    SDValue BC = peekThroughBitcasts(Vec);\n    MVT BCVT = BC.getSimpleValueType();\n    unsigned BCNumElts = BCVT.getVectorNumElements();\n    unsigned BCNumEltBits = BCVT.getScalarSizeInBits();\n    if ((BCNumEltBits == 32 || BCNumEltBits == 64) &&\n        BCNumEltBits > NumEltBits &&\n        DAG.ComputeNumSignBits(BC) > (BCNumEltBits - NumEltBits)) {\n      SDLoc DL(EFLAGS);\n      unsigned CmpMask = IsAnyOf ? 0 : ((1 << BCNumElts) - 1);\n      return DAG.getNode(X86ISD::CMP, DL, MVT::i32,\n                         DAG.getNode(X86ISD::MOVMSK, DL, MVT::i32, BC),\n                         DAG.getConstant(CmpMask, DL, MVT::i32));\n    }\n  }\n\n  // MOVMSK(PCMPEQ(X,0)) == -1 -> PTESTZ(X,X).\n  // MOVMSK(PCMPEQ(X,0)) != -1 -> !PTESTZ(X,X).\n  if (IsAllOf && Subtarget.hasSSE41()) {\n    SDValue BC = peekThroughBitcasts(Vec);\n    if (BC.getOpcode() == X86ISD::PCMPEQ &&\n        ISD::isBuildVectorAllZeros(BC.getOperand(1).getNode())) {\n      MVT TestVT = VecVT.is128BitVector() ? MVT::v2i64 : MVT::v4i64;\n      SDValue V = DAG.getBitcast(TestVT, BC.getOperand(0));\n      return DAG.getNode(X86ISD::PTEST, SDLoc(EFLAGS), MVT::i32, V, V);\n    }\n  }\n\n  // See if we can avoid a PACKSS by calling MOVMSK on the sources.\n  // For vXi16 cases we can use a v2Xi8 PMOVMSKB. We must mask out\n  // sign bits prior to the comparison with zero unless we know that\n  // the vXi16 splats the sign bit down to the lower i8 half.\n  // TODO: Handle all_of patterns.\n  if (Vec.getOpcode() == X86ISD::PACKSS && VecVT == MVT::v16i8) {\n    SDValue VecOp0 = Vec.getOperand(0);\n    SDValue VecOp1 = Vec.getOperand(1);\n    bool SignExt0 = DAG.ComputeNumSignBits(VecOp0) > 8;\n    bool SignExt1 = DAG.ComputeNumSignBits(VecOp1) > 8;\n    // PMOVMSKB(PACKSSBW(X, undef)) -> PMOVMSKB(BITCAST_v16i8(X)) & 0xAAAA.\n    if (IsAnyOf && CmpBits == 8 && VecOp1.isUndef()) {\n      SDLoc DL(EFLAGS);\n      SDValue Result = DAG.getBitcast(MVT::v16i8, VecOp0);\n      Result = DAG.getNode(X86ISD::MOVMSK, DL, MVT::i32, Result);\n      Result = DAG.getZExtOrTrunc(Result, DL, MVT::i16);\n      if (!SignExt0) {\n        Result = DAG.getNode(ISD::AND, DL, MVT::i16, Result,\n                             DAG.getConstant(0xAAAA, DL, MVT::i16));\n      }\n      return DAG.getNode(X86ISD::CMP, DL, MVT::i32, Result,\n                         DAG.getConstant(0, DL, MVT::i16));\n    }\n    // PMOVMSKB(PACKSSBW(LO(X), HI(X)))\n    // -> PMOVMSKB(BITCAST_v32i8(X)) & 0xAAAAAAAA.\n",
        "suffix": "        VecOp0.getOpcode() == ISD::EXTRACT_SUBVECTOR &&\n        VecOp1.getOpcode() == ISD::EXTRACT_SUBVECTOR &&\n        VecOp0.getOperand(0) == VecOp1.getOperand(0) &&\n        VecOp0.getConstantOperandAPInt(1) == 0 &&\n        VecOp1.getConstantOperandAPInt(1) == 8 &&\n        (IsAnyOf || (SignExt0 && SignExt1))) {\n      SDLoc DL(EFLAGS);\n      SDValue Result = DAG.getBitcast(MVT::v32i8, VecOp0.getOperand(0));\n      Result = DAG.getNode(X86ISD::MOVMSK, DL, MVT::i32, Result);\n      unsigned CmpMask = IsAnyOf ? 0 : 0xFFFFFFFF;\n      if (!SignExt0 || !SignExt1) {\n        assert(IsAnyOf && \"Only perform v16i16 signmasks for any_of patterns\");\n        Result = DAG.getNode(ISD::AND, DL, MVT::i32, Result,\n                             DAG.getConstant(0xAAAAAAAA, DL, MVT::i32));\n      }\n      return DAG.getNode(X86ISD::CMP, DL, MVT::i32, Result,\n                         DAG.getConstant(CmpMask, DL, MVT::i32));\n    }\n  }\n\n  // MOVMSK(SHUFFLE(X,u)) -> MOVMSK(X) iff every element is referenced.\n  SmallVector<int, 32> ShuffleMask;\n  SmallVector<SDValue, 2> ShuffleInputs;\n  if (NumElts == CmpBits &&\n      getTargetShuffleInputs(peekThroughBitcasts(Vec), ShuffleInputs,\n                             ShuffleMask, DAG) &&\n      ShuffleInputs.size() == 1 && !isAnyZeroOrUndef(ShuffleMask) &&\n      ShuffleInputs[0].getValueSizeInBits() == VecVT.getSizeInBits()) {\n    unsigned NumShuffleElts = ShuffleMask.size();\n    APInt DemandedElts = APInt::getNullValue(NumShuffleElts);\n    for (int M : ShuffleMask) {\n      assert(0 <= M && M < (int)NumShuffleElts && \"Bad unary shuffle index\");\n      DemandedElts.setBit(M);\n    }\n    if (DemandedElts.isAllOnesValue()) {\n      SDLoc DL(EFLAGS);\n      SDValue Result = DAG.getBitcast(VecVT, ShuffleInputs[0]);\n      Result = DAG.getNode(X86ISD::MOVMSK, DL, MVT::i32, Result);\n      Result =\n          DAG.getZExtOrTrunc(Result, DL, EFLAGS.getOperand(0).getValueType());\n      return DAG.getNode(X86ISD::CMP, DL, MVT::i32, Result,\n                         EFLAGS.getOperand(1));\n    }\n  }\n\n  return SDValue();\n}\n",
        "start": 42251,
        "end": 42397,
        "buggy": "static SDValue combineSetCCMOVMSK(SDValue EFLAGS, X86::CondCode &CC,\n                                  SelectionDAG &DAG,\n                                  const X86Subtarget &Subtarget) {\n  // Handle eq/ne against zero (any_of).\n  // Handle eq/ne against -1 (all_of).\n  if (!(CC == X86::COND_E || CC == X86::COND_NE))\n    return SDValue();\n  if (EFLAGS.getValueType() != MVT::i32)\n    return SDValue();\n  unsigned CmpOpcode = EFLAGS.getOpcode();\n  if (CmpOpcode != X86ISD::CMP && CmpOpcode != X86ISD::SUB)\n    return SDValue();\n  auto *CmpConstant = dyn_cast<ConstantSDNode>(EFLAGS.getOperand(1));\n  if (!CmpConstant)\n    return SDValue();\n  const APInt &CmpVal = CmpConstant->getAPIntValue();\n\n  SDValue CmpOp = EFLAGS.getOperand(0);\n  unsigned CmpBits = CmpOp.getValueSizeInBits();\n  assert(CmpBits == CmpVal.getBitWidth() && \"Value size mismatch\");\n\n  // Peek through any truncate.\n  if (CmpOp.getOpcode() == ISD::TRUNCATE)\n    CmpOp = CmpOp.getOperand(0);\n\n  // Bail if we don't find a MOVMSK.\n  if (CmpOp.getOpcode() != X86ISD::MOVMSK)\n    return SDValue();\n\n  SDValue Vec = CmpOp.getOperand(0);\n  MVT VecVT = Vec.getSimpleValueType();\n  assert((VecVT.is128BitVector() || VecVT.is256BitVector()) &&\n         \"Unexpected MOVMSK operand\");\n  unsigned NumElts = VecVT.getVectorNumElements();\n  unsigned NumEltBits = VecVT.getScalarSizeInBits();\n\n  bool IsAnyOf = CmpOpcode == X86ISD::CMP && CmpVal.isNullValue();\n  bool IsAllOf = CmpOpcode == X86ISD::SUB && NumElts <= CmpBits &&\n                 CmpVal.isMask(NumElts);\n  if (!IsAnyOf && !IsAllOf)\n    return SDValue();\n\n  // See if we can peek through to a vector with a wider element type, if the\n  // signbits extend down to all the sub-elements as well.\n  // Calling MOVMSK with the wider type, avoiding the bitcast, helps expose\n  // potential SimplifyDemandedBits/Elts cases.\n  if (Vec.getOpcode() == ISD::BITCAST) {\n    SDValue BC = peekThroughBitcasts(Vec);\n    MVT BCVT = BC.getSimpleValueType();\n    unsigned BCNumElts = BCVT.getVectorNumElements();\n    unsigned BCNumEltBits = BCVT.getScalarSizeInBits();\n    if ((BCNumEltBits == 32 || BCNumEltBits == 64) &&\n        BCNumEltBits > NumEltBits &&\n        DAG.ComputeNumSignBits(BC) > (BCNumEltBits - NumEltBits)) {\n      SDLoc DL(EFLAGS);\n      unsigned CmpMask = IsAnyOf ? 0 : ((1 << BCNumElts) - 1);\n      return DAG.getNode(X86ISD::CMP, DL, MVT::i32,\n                         DAG.getNode(X86ISD::MOVMSK, DL, MVT::i32, BC),\n                         DAG.getConstant(CmpMask, DL, MVT::i32));\n    }\n  }\n\n  // MOVMSK(PCMPEQ(X,0)) == -1 -> PTESTZ(X,X).\n  // MOVMSK(PCMPEQ(X,0)) != -1 -> !PTESTZ(X,X).\n  if (IsAllOf && Subtarget.hasSSE41()) {\n    SDValue BC = peekThroughBitcasts(Vec);\n    if (BC.getOpcode() == X86ISD::PCMPEQ &&\n        ISD::isBuildVectorAllZeros(BC.getOperand(1).getNode())) {\n      MVT TestVT = VecVT.is128BitVector() ? MVT::v2i64 : MVT::v4i64;\n      SDValue V = DAG.getBitcast(TestVT, BC.getOperand(0));\n      return DAG.getNode(X86ISD::PTEST, SDLoc(EFLAGS), MVT::i32, V, V);\n    }\n  }\n\n  // See if we can avoid a PACKSS by calling MOVMSK on the sources.\n  // For vXi16 cases we can use a v2Xi8 PMOVMSKB. We must mask out\n  // sign bits prior to the comparison with zero unless we know that\n  // the vXi16 splats the sign bit down to the lower i8 half.\n  // TODO: Handle all_of patterns.\n  if (Vec.getOpcode() == X86ISD::PACKSS && VecVT == MVT::v16i8) {\n    SDValue VecOp0 = Vec.getOperand(0);\n    SDValue VecOp1 = Vec.getOperand(1);\n    bool SignExt0 = DAG.ComputeNumSignBits(VecOp0) > 8;\n    bool SignExt1 = DAG.ComputeNumSignBits(VecOp1) > 8;\n    // PMOVMSKB(PACKSSBW(X, undef)) -> PMOVMSKB(BITCAST_v16i8(X)) & 0xAAAA.\n    if (IsAnyOf && CmpBits == 8 && VecOp1.isUndef()) {\n      SDLoc DL(EFLAGS);\n      SDValue Result = DAG.getBitcast(MVT::v16i8, VecOp0);\n      Result = DAG.getNode(X86ISD::MOVMSK, DL, MVT::i32, Result);\n      Result = DAG.getZExtOrTrunc(Result, DL, MVT::i16);\n      if (!SignExt0) {\n        Result = DAG.getNode(ISD::AND, DL, MVT::i16, Result,\n                             DAG.getConstant(0xAAAA, DL, MVT::i16));\n      }\n      return DAG.getNode(X86ISD::CMP, DL, MVT::i32, Result,\n                         DAG.getConstant(0, DL, MVT::i16));\n    }\n    // PMOVMSKB(PACKSSBW(LO(X), HI(X)))\n    // -> PMOVMSKB(BITCAST_v32i8(X)) & 0xAAAAAAAA.\n    if (CmpBits == 16 && Subtarget.hasInt256() &&\n        VecOp0.getOpcode() == ISD::EXTRACT_SUBVECTOR &&\n        VecOp1.getOpcode() == ISD::EXTRACT_SUBVECTOR &&\n        VecOp0.getOperand(0) == VecOp1.getOperand(0) &&\n        VecOp0.getConstantOperandAPInt(1) == 0 &&\n        VecOp1.getConstantOperandAPInt(1) == 8 &&\n        (IsAnyOf || (SignExt0 && SignExt1))) {\n      SDLoc DL(EFLAGS);\n      SDValue Result = DAG.getBitcast(MVT::v32i8, VecOp0.getOperand(0));\n      Result = DAG.getNode(X86ISD::MOVMSK, DL, MVT::i32, Result);\n      unsigned CmpMask = IsAnyOf ? 0 : 0xFFFFFFFF;\n      if (!SignExt0 || !SignExt1) {\n        assert(IsAnyOf && \"Only perform v16i16 signmasks for any_of patterns\");\n        Result = DAG.getNode(ISD::AND, DL, MVT::i32, Result,\n                             DAG.getConstant(0xAAAAAAAA, DL, MVT::i32));\n      }\n      return DAG.getNode(X86ISD::CMP, DL, MVT::i32, Result,\n                         DAG.getConstant(CmpMask, DL, MVT::i32));\n    }\n  }\n\n  // MOVMSK(SHUFFLE(X,u)) -> MOVMSK(X) iff every element is referenced.\n  SmallVector<int, 32> ShuffleMask;\n  SmallVector<SDValue, 2> ShuffleInputs;\n  if (NumElts == CmpBits &&\n      getTargetShuffleInputs(peekThroughBitcasts(Vec), ShuffleInputs,\n                             ShuffleMask, DAG) &&\n      ShuffleInputs.size() == 1 && !isAnyZeroOrUndef(ShuffleMask) &&\n      ShuffleInputs[0].getValueSizeInBits() == VecVT.getSizeInBits()) {\n    unsigned NumShuffleElts = ShuffleMask.size();\n    APInt DemandedElts = APInt::getNullValue(NumShuffleElts);\n    for (int M : ShuffleMask) {\n      assert(0 <= M && M < (int)NumShuffleElts && \"Bad unary shuffle index\");\n      DemandedElts.setBit(M);\n    }\n    if (DemandedElts.isAllOnesValue()) {\n      SDLoc DL(EFLAGS);\n      SDValue Result = DAG.getBitcast(VecVT, ShuffleInputs[0]);\n      Result = DAG.getNode(X86ISD::MOVMSK, DL, MVT::i32, Result);\n      Result =\n          DAG.getZExtOrTrunc(Result, DL, EFLAGS.getOperand(0).getValueType());\n      return DAG.getNode(X86ISD::CMP, DL, MVT::i32, Result,\n                         EFLAGS.getOperand(1));\n    }\n  }\n\n  return SDValue();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (CmpBits == 16 && Subtarget.hasInt256() &&\n",
        "src_path": "74f98391a7a42eccd7aa96546892cb9b65a39edb___X86ISelLowering.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/74f98391a7a42eccd7aa96546892cb9b65a39edb",
        "commit_msg": "[X86][SSE] combineSetCCMOVMSK - allow comparison with upper (known zero) bits in CMP(MOVMSK(PACKSS())) -> CMP(MOVMSK()) fold\n\nWe already allow the comparison of the upper bits of 'IsAllOf' (allbits) patterns, but we can safely compare the known zero bits for 'IsAnyOf' (zerobits) patterns as well.\n\nThis fixes an issues where we are comparing a type wide than the number of vector elements, which avoids a regression mentioned in rGbaadbe04bf75.",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/vector-compare-all_of.ll",
                "patch": "@@ -743,10 +743,8 @@ define i16 @test_v16i16_legal_sext(<16 x i16> %a0, <16 x i16> %a1) {\n ; AVX2-LABEL: test_v16i16_legal_sext:\n ; AVX2:       # %bb.0:\n ; AVX2-NEXT:    vpcmpgtw %ymm1, %ymm0, %ymm0\n-; AVX2-NEXT:    vextracti128 $1, %ymm0, %xmm1\n-; AVX2-NEXT:    vpacksswb %xmm1, %xmm0, %xmm0\n-; AVX2-NEXT:    vpmovmskb %xmm0, %eax\n-; AVX2-NEXT:    cmpl $65535, %eax # imm = 0xFFFF\n+; AVX2-NEXT:    vpmovmskb %ymm0, %eax\n+; AVX2-NEXT:    cmpl $-1, %eax\n ; AVX2-NEXT:    sete %al\n ; AVX2-NEXT:    negb %al\n ; AVX2-NEXT:    movsbl %al, %eax"
            },
            {
                "fn": "llvm/test/CodeGen/X86/vector-compare-any_of.ll",
                "patch": "@@ -645,9 +645,7 @@ define i16 @test_v16i16_legal_sext(<16 x i16> %a0, <16 x i16> %a1) {\n ; AVX2-LABEL: test_v16i16_legal_sext:\n ; AVX2:       # %bb.0:\n ; AVX2-NEXT:    vpcmpgtw %ymm1, %ymm0, %ymm0\n-; AVX2-NEXT:    vextracti128 $1, %ymm0, %xmm1\n-; AVX2-NEXT:    vpacksswb %xmm1, %xmm0, %xmm0\n-; AVX2-NEXT:    vpmovmskb %xmm0, %eax\n+; AVX2-NEXT:    vpmovmskb %ymm0, %eax\n ; AVX2-NEXT:    negl %eax\n ; AVX2-NEXT:    sbbl %eax, %eax\n ; AVX2-NEXT:    # kill: def $ax killed $ax killed $eax"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/vector-compare-all_of.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-compare-all_of.ll\n\n\nTesting Time: 1.01s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-compare-any_of.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-compare-any_of.ll\n\n\nTesting Time: 1.57s\n  Failed: 1\n"
    },
    "11707435ccb44a9377bfed407453e0646a159636___InferFunctionAttrs.cpp": {
        "prefix": "static bool inferAllPrototypeAttributes(\n    Module &M, function_ref<TargetLibraryInfo &(Function &)> GetTLI) {\n  bool Changed = false;\n\n  for (Function &F : M.functions())\n    // We only infer things using the prototype and the name; we don't need\n    // definitions.  This ensures libfuncs are annotated and also allows our\n    // CGSCC inference to avoid needing to duplicate the inference from other\n    // attribute logic on all calls to declarations (as declarations aren't\n    // explicitly visited by CGSCC passes in the new pass manager.)\n    if (F.isDeclaration() && !F.hasOptNone()) {\n",
        "suffix": "      Changed |= inferAttributesFromOthers(F);\n    }\n\n  return Changed;\n}\n",
        "start": 23,
        "end": 39,
        "buggy": "static bool inferAllPrototypeAttributes(\n    Module &M, function_ref<TargetLibraryInfo &(Function &)> GetTLI) {\n  bool Changed = false;\n\n  for (Function &F : M.functions())\n    // We only infer things using the prototype and the name; we don't need\n    // definitions.  This ensures libfuncs are annotated and also allows our\n    // CGSCC inference to avoid needing to duplicate the inference from other\n    // attribute logic on all calls to declarations (as declarations aren't\n    // explicitly visited by CGSCC passes in the new pass manager.)\n    if (F.isDeclaration() && !F.hasOptNone()) {\n      Changed |= inferLibFuncAttributes(F, GetTLI(F));\n      Changed |= inferAttributesFromOthers(F);\n    }\n\n  return Changed;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      Changed |= inferLibFuncAttributes(F, GetTLI(F));\n",
        "src_path": "11707435ccb44a9377bfed407453e0646a159636___InferFunctionAttrs.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/11707435ccb44a9377bfed407453e0646a159636",
        "commit_msg": "[inferattrs] Don't infer lib func attributes for nobuiltin functions\n\nIf we have a nobuiltin function, we can't assume we know anything about the implementation.\n\nI noticed this when tracing through a log from an in the wild miscompile (https://github.com/emscripten-core/emscripten/issues/9443) triggered after 8666463.  We were incorrectly assuming that a custom allocator could not free.  (It's not clear yet this is the only problem in said issue.)\n\nI also noticed something similiar mentioned in the commit message of ab243e when scrolling back through history.  Through, from what I can tell, that commit fixed symptom not root cause.\n\nThe interface we have for library function detection is extremely error prone, but given the interaction between ``nobuiltin`` decls and ``builtin`` callsites, it's really hard to imagine something much cleaner.  I may iterate on that, but it'll be invasive enough I didn't want to hold an obvious functional fix on it.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InferFunctionAttrs/nobuiltin.ll",
                "patch": "@@ -0,0 +1,5 @@\n+; RUN: opt -S -inferattrs < %s | FileCheck %s\n+\n+; CHECK: Function Attrs: nobuiltin allocsize(0)\n+; CHECK: declare i8* @_Znwm(i32)\n+declare i8* @_Znwm(i32) nobuiltin allocsize(0)"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InferFunctionAttrs/nobuiltin.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InferFunctionAttrs/nobuiltin.ll\n\n\nTesting Time: 0.15s\n  Failed: 1\n"
    },
    "160559344026824ee0b510741c7906c0e165f9a7___SimplifyLibCalls.cpp": {
        "prefix": "Value *LibCallSimplifier::optimizeMemChr(CallInst *CI, IRBuilderBase &B) {\n  Value *SrcStr = CI->getArgOperand(0);\n  Value *Size = CI->getArgOperand(2);\n  annotateNonNullAndDereferenceable(CI, 0, Size, DL);\n  ConstantInt *CharC = dyn_cast<ConstantInt>(CI->getArgOperand(1));\n  ConstantInt *LenC = dyn_cast<ConstantInt>(Size);\n\n  // memchr(x, y, 0) -> null\n  if (LenC) {\n    if (LenC->isZero())\n      return Constant::getNullValue(CI->getType());\n  } else {\n    // From now on we need at least constant length and string.\n    return nullptr;\n  }\n\n  StringRef Str;\n  if (!getConstantStringInfo(SrcStr, Str, 0, /*TrimAtNul=*/false))\n    return nullptr;\n\n  // Truncate the string to LenC. If Str is smaller than LenC we will still only\n  // scan the string, as reading past the end of it is undefined and we can just\n  // return null if we don't find the char.\n  Str = Str.substr(0, LenC->getZExtValue());\n\n  // If the char is variable but the input str and length are not we can turn\n  // this memchr call into a simple bit field test. Of course this only works\n  // when the return value is only checked against null.\n  //\n  // It would be really nice to reuse switch lowering here but we can't change\n  // the CFG at this point.\n  //\n  // memchr(\"\\r\\n\", C, 2) != nullptr -> (1 << C & ((1 << '\\r') | (1 << '\\n')))\n  // != 0\n  //   after bounds check.\n  if (!CharC && !Str.empty() && isOnlyUsedInZeroEqualityComparison(CI)) {\n    unsigned char Max =\n        *std::max_element(reinterpret_cast<const unsigned char *>(Str.begin()),\n                          reinterpret_cast<const unsigned char *>(Str.end()));\n\n    // Make sure the bit field we're about to create fits in a register on the\n    // target.\n    // FIXME: On a 64 bit architecture this prevents us from using the\n    // interesting range of alpha ascii chars. We could do better by emitting\n    // two bitfields or shifting the range by 64 if no lower chars are used.\n    if (!DL.fitsInLegalInteger(Max + 1))\n      return nullptr;\n\n    // For the bit field use a power-of-2 type with at least 8 bits to avoid\n    // creating unnecessary illegal types.\n    unsigned char Width = NextPowerOf2(std::max((unsigned char)7, Max));\n\n    // Now build the bit field.\n    APInt Bitfield(Width, 0);\n    for (char C : Str)\n      Bitfield.setBit((unsigned char)C);\n    Value *BitfieldC = B.getInt(Bitfield);\n\n    // Adjust width of \"C\" to the bitfield width, then mask off the high bits.\n    Value *C = B.CreateZExtOrTrunc(CI->getArgOperand(1), BitfieldC->getType());\n    C = B.CreateAnd(C, B.getIntN(Width, 0xFF));\n\n    // First check that the bit field access is within bounds.\n    Value *Bounds = B.CreateICmp(ICmpInst::ICMP_ULT, C, B.getIntN(Width, Width),\n                                 \"memchr.bounds\");\n\n    // Create code that checks if the given bit is set in the field.\n    Value *Shl = B.CreateShl(B.getIntN(Width, 1ULL), C);\n    Value *Bits = B.CreateIsNotNull(B.CreateAnd(Shl, BitfieldC), \"memchr.bits\");\n\n    // Finally merge both checks and cast to pointer type. The inttoptr\n    // implicitly zexts the i1 to intptr type.\n",
        "suffix": "  }\n\n  // Check if all arguments are constants.  If so, we can constant fold.\n  if (!CharC)\n    return nullptr;\n\n  // Compute the offset.\n  size_t I = Str.find(CharC->getSExtValue() & 0xFF);\n  if (I == StringRef::npos) // Didn't find the char.  memchr returns null.\n    return Constant::getNullValue(CI->getType());\n\n  // memchr(s+n,c,l) -> gep(s+n+i,c)\n  return B.CreateGEP(B.getInt8Ty(), SrcStr, B.getInt64(I), \"memchr\");\n}\n",
        "start": 864,
        "end": 950,
        "buggy": "Value *LibCallSimplifier::optimizeMemChr(CallInst *CI, IRBuilderBase &B) {\n  Value *SrcStr = CI->getArgOperand(0);\n  Value *Size = CI->getArgOperand(2);\n  annotateNonNullAndDereferenceable(CI, 0, Size, DL);\n  ConstantInt *CharC = dyn_cast<ConstantInt>(CI->getArgOperand(1));\n  ConstantInt *LenC = dyn_cast<ConstantInt>(Size);\n\n  // memchr(x, y, 0) -> null\n  if (LenC) {\n    if (LenC->isZero())\n      return Constant::getNullValue(CI->getType());\n  } else {\n    // From now on we need at least constant length and string.\n    return nullptr;\n  }\n\n  StringRef Str;\n  if (!getConstantStringInfo(SrcStr, Str, 0, /*TrimAtNul=*/false))\n    return nullptr;\n\n  // Truncate the string to LenC. If Str is smaller than LenC we will still only\n  // scan the string, as reading past the end of it is undefined and we can just\n  // return null if we don't find the char.\n  Str = Str.substr(0, LenC->getZExtValue());\n\n  // If the char is variable but the input str and length are not we can turn\n  // this memchr call into a simple bit field test. Of course this only works\n  // when the return value is only checked against null.\n  //\n  // It would be really nice to reuse switch lowering here but we can't change\n  // the CFG at this point.\n  //\n  // memchr(\"\\r\\n\", C, 2) != nullptr -> (1 << C & ((1 << '\\r') | (1 << '\\n')))\n  // != 0\n  //   after bounds check.\n  if (!CharC && !Str.empty() && isOnlyUsedInZeroEqualityComparison(CI)) {\n    unsigned char Max =\n        *std::max_element(reinterpret_cast<const unsigned char *>(Str.begin()),\n                          reinterpret_cast<const unsigned char *>(Str.end()));\n\n    // Make sure the bit field we're about to create fits in a register on the\n    // target.\n    // FIXME: On a 64 bit architecture this prevents us from using the\n    // interesting range of alpha ascii chars. We could do better by emitting\n    // two bitfields or shifting the range by 64 if no lower chars are used.\n    if (!DL.fitsInLegalInteger(Max + 1))\n      return nullptr;\n\n    // For the bit field use a power-of-2 type with at least 8 bits to avoid\n    // creating unnecessary illegal types.\n    unsigned char Width = NextPowerOf2(std::max((unsigned char)7, Max));\n\n    // Now build the bit field.\n    APInt Bitfield(Width, 0);\n    for (char C : Str)\n      Bitfield.setBit((unsigned char)C);\n    Value *BitfieldC = B.getInt(Bitfield);\n\n    // Adjust width of \"C\" to the bitfield width, then mask off the high bits.\n    Value *C = B.CreateZExtOrTrunc(CI->getArgOperand(1), BitfieldC->getType());\n    C = B.CreateAnd(C, B.getIntN(Width, 0xFF));\n\n    // First check that the bit field access is within bounds.\n    Value *Bounds = B.CreateICmp(ICmpInst::ICMP_ULT, C, B.getIntN(Width, Width),\n                                 \"memchr.bounds\");\n\n    // Create code that checks if the given bit is set in the field.\n    Value *Shl = B.CreateShl(B.getIntN(Width, 1ULL), C);\n    Value *Bits = B.CreateIsNotNull(B.CreateAnd(Shl, BitfieldC), \"memchr.bits\");\n\n    // Finally merge both checks and cast to pointer type. The inttoptr\n    // implicitly zexts the i1 to intptr type.\n    return B.CreateIntToPtr(B.CreateAnd(Bounds, Bits, \"memchr\"), CI->getType());\n  }\n\n  // Check if all arguments are constants.  If so, we can constant fold.\n  if (!CharC)\n    return nullptr;\n\n  // Compute the offset.\n  size_t I = Str.find(CharC->getSExtValue() & 0xFF);\n  if (I == StringRef::npos) // Didn't find the char.  memchr returns null.\n    return Constant::getNullValue(CI->getType());\n\n  // memchr(s+n,c,l) -> gep(s+n+i,c)\n  return B.CreateGEP(B.getInt8Ty(), SrcStr, B.getInt64(I), \"memchr\");\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    return B.CreateIntToPtr(B.CreateAnd(Bounds, Bits, \"memchr\"), CI->getType());\n",
        "src_path": "160559344026824ee0b510741c7906c0e165f9a7___SimplifyLibCalls.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/160559344026824ee0b510741c7906c0e165f9a7",
        "commit_msg": "[SimplifyLibCalls] Fix memchr opt to use CreateLogicalAnd\n\nThis fixes a bug at LibCallSimplifier::optimizeMemChr which does the following transformation:\n\n```\n// memchr(\"\\r\\n\", C, 2) != nullptr -> (1 << C & ((1 << '\\r') | (1 << '\\n')))\n// != 0\n//   after bounds check.\n```\n\nAs written above, a bounds check on C (whether it is less than integer bitwidth) is done before doing `1 << C` otherwise 1 << C will overflow.\nIf the bounds check is false, the result of (1 << C & ...) must not be used at all, otherwise the result of shift (which is poison) will contaminate the whole results.\nA correct way to encode this is `select i1 (bounds check), (1 << C & ...), false`  because select does not allow the unused operand to contaminate the result.\nHowever, this optimization was introducing `and (bounds check), (1 << C & ...)` which cannot do that.\n\nThe bug was found from compilation of this C++ code: https://reviews.llvm.org/rG2fd3037ac615#1007197\n\nReviewed By: nikic\n\nDifferential Revision: https://reviews.llvm.org/D104901",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/memchr.ll",
                "patch": "@@ -137,7 +137,7 @@ define i1 @test11(i32 %C) {\n ; CHECK-NEXT:    [[TMP3:%.*]] = shl i16 1, [[TMP2]]\n ; CHECK-NEXT:    [[TMP4:%.*]] = and i16 [[TMP3]], 9216\n ; CHECK-NEXT:    [[MEMCHR_BITS:%.*]] = icmp ne i16 [[TMP4]], 0\n-; CHECK-NEXT:    [[MEMCHR:%.*]] = and i1 [[MEMCHR_BOUNDS]], [[MEMCHR_BITS]]\n+; CHECK-NEXT:    [[MEMCHR:%.*]] = select i1 [[MEMCHR_BOUNDS]], i1 [[MEMCHR_BITS]], i1 false\n ; CHECK-NEXT:    ret i1 [[MEMCHR]]\n ;\n   %dst = call i8* @memchr(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @newlines, i64 0, i64 0), i32 %C, i32 2)\n@@ -164,7 +164,7 @@ define i1 @test13(i32 %C) {\n ; CHECK-NEXT:    [[TMP2:%.*]] = shl i32 1, [[TMP1]]\n ; CHECK-NEXT:    [[TMP3:%.*]] = and i32 [[TMP2]], -2147483647\n ; CHECK-NEXT:    [[MEMCHR_BITS:%.*]] = icmp ne i32 [[TMP3]], 0\n-; CHECK-NEXT:    [[MEMCHR:%.*]] = and i1 [[MEMCHR_BOUNDS]], [[MEMCHR_BITS]]\n+; CHECK-NEXT:    [[MEMCHR:%.*]] = select i1 [[MEMCHR_BOUNDS]], i1 [[MEMCHR_BITS]], i1 false\n ; CHECK-NEXT:    ret i1 [[MEMCHR]]\n ;\n   %dst = call i8* @memchr(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @single, i64 0, i64 0), i32 %C, i32 2)"
            },
            {
                "fn": "llvm/test/Transforms/InstCombine/strchr-1.ll",
                "patch": "@@ -95,7 +95,7 @@ define i1 @test_simplify7(i32 %C) {\n ; CHECK-NEXT:    [[TMP3:%.*]] = shl i16 1, [[TMP2]]\n ; CHECK-NEXT:    [[TMP4:%.*]] = and i16 [[TMP3]], 9217\n ; CHECK-NEXT:    [[MEMCHR_BITS:%.*]] = icmp ne i16 [[TMP4]], 0\n-; CHECK-NEXT:    [[MEMCHR1:%.*]] = and i1 [[MEMCHR_BOUNDS]], [[MEMCHR_BITS]]\n+; CHECK-NEXT:    [[MEMCHR1:%.*]] = select i1 [[MEMCHR_BOUNDS]], i1 [[MEMCHR_BITS]], i1 false\n ; CHECK-NEXT:    ret i1 [[MEMCHR1]]\n ;\n "
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/memchr.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/memchr.ll\n\n\nTesting Time: 1.22s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/InstCombine/strchr-1.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/strchr-1.ll\n\n\nTesting Time: 0.14s\n  Failed: 1\n"
    },
    "252a1eecc04080d852ba58c6727970c688eb1619___FunctionImportUtils.cpp": {
        "prefix": "void FunctionImportGlobalProcessing::processGlobalForThinLTO(GlobalValue &GV) {\n\n  ValueInfo VI;\n  if (GV.hasName()) {\n    VI = ImportIndex.getValueInfo(GV.getGUID());\n    // Set synthetic function entry counts.\n    if (VI && ImportIndex.hasSyntheticEntryCounts()) {\n      if (Function *F = dyn_cast<Function>(&GV)) {\n        if (!F->isDeclaration()) {\n          for (auto &S : VI.getSummaryList()) {\n            auto *FS = cast<FunctionSummary>(S->getBaseObject());\n            if (FS->modulePath() == M.getModuleIdentifier()) {\n              F->setEntryCount(Function::ProfileCount(FS->entryCount(),\n                                                      Function::PCT_Synthetic));\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // We should always have a ValueInfo (i.e. GV in index) for definitions when\n  // we are exporting, and also when importing that value.\n  assert(VI || GV.isDeclaration() ||\n         (isPerformingImport() && !doImportAsDefinition(&GV)));\n\n  // Mark read/write-only variables which can be imported with specific\n  // attribute. We can't internalize them now because IRMover will fail\n  // to link variable definitions to their external declarations during\n  // ThinLTO import. We'll internalize read-only variables later, after\n  // import is finished. See internalizeGVsAfterImport.\n  //\n  // If global value dead stripping is not enabled in summary then\n  // propagateConstants hasn't been run. We can't internalize GV\n  // in such case.\n  if (!GV.isDeclaration() && VI && ImportIndex.withAttributePropagation()) {\n    if (GlobalVariable *V = dyn_cast<GlobalVariable>(&GV)) {\n      // We can have more than one local with the same GUID, in the case of\n      // same-named locals in different but same-named source files that were\n      // compiled in their respective directories (so the source file name\n      // and resulting GUID is the same). Find the one in this module.\n      // Handle the case where there is no summary found in this module. That\n      // can happen in the distributed ThinLTO backend, because the index only\n      // contains summaries from the source modules if they are being imported.\n      // We might have a non-null VI and get here even in that case if the name\n      // matches one in this module (e.g. weak or appending linkage).\n      auto *GVS = dyn_cast_or_null<GlobalVarSummary>(\n          ImportIndex.findSummaryInModule(VI, M.getModuleIdentifier()));\n      if (GVS &&\n          (ImportIndex.isReadOnly(GVS) || ImportIndex.isWriteOnly(GVS))) {\n        V->addAttribute(\"thinlto-internalize\");\n        // Objects referenced by writeonly GV initializer should not be\n        // promoted, because there is no any kind of read access to them\n        // on behalf of this writeonly GV. To avoid promotion we convert\n        // GV initializer to 'zeroinitializer'. This effectively drops\n        // references in IR module (not in combined index), so we can\n        // ignore them when computing import. We do not export references\n        // of writeonly object. See computeImportForReferencedGlobals\n        if (ImportIndex.isWriteOnly(GVS))\n          V->setInitializer(Constant::getNullValue(V->getValueType()));\n      }\n    }\n  }\n\n  if (GV.hasLocalLinkage() && shouldPromoteLocalToGlobal(&GV, VI)) {\n    // Save the original name string before we rename GV below.\n    auto Name = GV.getName().str();\n    GV.setName(getPromotedName(&GV));\n    GV.setLinkage(getLinkage(&GV, /* DoPromote */ true));\n    assert(!GV.hasLocalLinkage());\n    GV.setVisibility(GlobalValue::HiddenVisibility);\n\n    // If we are renaming a COMDAT leader, ensure that we record the COMDAT\n    // for later renaming as well. This is required for COFF.\n    if (const auto *C = GV.getComdat())\n      if (C->getName() == Name)\n        RenamedComdats.try_emplace(C, M.getOrInsertComdat(GV.getName()));\n  } else\n    GV.setLinkage(getLinkage(&GV, /* DoPromote */ false));\n\n  // When ClearDSOLocalOnDeclarations is true, clear dso_local if GV is\n  // converted to a declaration, to disable direct access. Don't do this if GV\n  // is implicitly dso_local due to a non-default visibility.\n",
        "suffix": "      !GV.isImplicitDSOLocal()) {\n    GV.setDSOLocal(false);\n  } else if (VI && VI.isDSOLocal(ImportIndex.withDSOLocalPropagation())) {\n    // If all summaries are dso_local, symbol gets resolved to a known local\n    // definition.\n    GV.setDSOLocal(true);\n    if (GV.hasDLLImportStorageClass())\n      GV.setDLLStorageClass(GlobalValue::DefaultStorageClass);\n  }\n\n  // Remove functions imported as available externally defs from comdats,\n  // as this is a declaration for the linker, and will be dropped eventually.\n  // It is illegal for comdats to contain declarations.\n  auto *GO = dyn_cast<GlobalObject>(&GV);\n  if (GO && GO->isDeclarationForLinker() && GO->hasComdat()) {\n    // The IRMover should not have placed any imported declarations in\n    // a comdat, so the only declaration that should be in a comdat\n    // at this point would be a definition imported as available_externally.\n    assert(GO->hasAvailableExternallyLinkage() &&\n           \"Expected comdat on definition (possibly available external)\");\n    GO->setComdat(nullptr);\n  }\n}\n",
        "start": 195,
        "end": 302,
        "buggy": "void FunctionImportGlobalProcessing::processGlobalForThinLTO(GlobalValue &GV) {\n\n  ValueInfo VI;\n  if (GV.hasName()) {\n    VI = ImportIndex.getValueInfo(GV.getGUID());\n    // Set synthetic function entry counts.\n    if (VI && ImportIndex.hasSyntheticEntryCounts()) {\n      if (Function *F = dyn_cast<Function>(&GV)) {\n        if (!F->isDeclaration()) {\n          for (auto &S : VI.getSummaryList()) {\n            auto *FS = cast<FunctionSummary>(S->getBaseObject());\n            if (FS->modulePath() == M.getModuleIdentifier()) {\n              F->setEntryCount(Function::ProfileCount(FS->entryCount(),\n                                                      Function::PCT_Synthetic));\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // We should always have a ValueInfo (i.e. GV in index) for definitions when\n  // we are exporting, and also when importing that value.\n  assert(VI || GV.isDeclaration() ||\n         (isPerformingImport() && !doImportAsDefinition(&GV)));\n\n  // Mark read/write-only variables which can be imported with specific\n  // attribute. We can't internalize them now because IRMover will fail\n  // to link variable definitions to their external declarations during\n  // ThinLTO import. We'll internalize read-only variables later, after\n  // import is finished. See internalizeGVsAfterImport.\n  //\n  // If global value dead stripping is not enabled in summary then\n  // propagateConstants hasn't been run. We can't internalize GV\n  // in such case.\n  if (!GV.isDeclaration() && VI && ImportIndex.withAttributePropagation()) {\n    if (GlobalVariable *V = dyn_cast<GlobalVariable>(&GV)) {\n      // We can have more than one local with the same GUID, in the case of\n      // same-named locals in different but same-named source files that were\n      // compiled in their respective directories (so the source file name\n      // and resulting GUID is the same). Find the one in this module.\n      // Handle the case where there is no summary found in this module. That\n      // can happen in the distributed ThinLTO backend, because the index only\n      // contains summaries from the source modules if they are being imported.\n      // We might have a non-null VI and get here even in that case if the name\n      // matches one in this module (e.g. weak or appending linkage).\n      auto *GVS = dyn_cast_or_null<GlobalVarSummary>(\n          ImportIndex.findSummaryInModule(VI, M.getModuleIdentifier()));\n      if (GVS &&\n          (ImportIndex.isReadOnly(GVS) || ImportIndex.isWriteOnly(GVS))) {\n        V->addAttribute(\"thinlto-internalize\");\n        // Objects referenced by writeonly GV initializer should not be\n        // promoted, because there is no any kind of read access to them\n        // on behalf of this writeonly GV. To avoid promotion we convert\n        // GV initializer to 'zeroinitializer'. This effectively drops\n        // references in IR module (not in combined index), so we can\n        // ignore them when computing import. We do not export references\n        // of writeonly object. See computeImportForReferencedGlobals\n        if (ImportIndex.isWriteOnly(GVS))\n          V->setInitializer(Constant::getNullValue(V->getValueType()));\n      }\n    }\n  }\n\n  if (GV.hasLocalLinkage() && shouldPromoteLocalToGlobal(&GV, VI)) {\n    // Save the original name string before we rename GV below.\n    auto Name = GV.getName().str();\n    GV.setName(getPromotedName(&GV));\n    GV.setLinkage(getLinkage(&GV, /* DoPromote */ true));\n    assert(!GV.hasLocalLinkage());\n    GV.setVisibility(GlobalValue::HiddenVisibility);\n\n    // If we are renaming a COMDAT leader, ensure that we record the COMDAT\n    // for later renaming as well. This is required for COFF.\n    if (const auto *C = GV.getComdat())\n      if (C->getName() == Name)\n        RenamedComdats.try_emplace(C, M.getOrInsertComdat(GV.getName()));\n  } else\n    GV.setLinkage(getLinkage(&GV, /* DoPromote */ false));\n\n  // When ClearDSOLocalOnDeclarations is true, clear dso_local if GV is\n  // converted to a declaration, to disable direct access. Don't do this if GV\n  // is implicitly dso_local due to a non-default visibility.\n  if (ClearDSOLocalOnDeclarations && GV.isDeclarationForLinker() &&\n      !GV.isImplicitDSOLocal()) {\n    GV.setDSOLocal(false);\n  } else if (VI && VI.isDSOLocal(ImportIndex.withDSOLocalPropagation())) {\n    // If all summaries are dso_local, symbol gets resolved to a known local\n    // definition.\n    GV.setDSOLocal(true);\n    if (GV.hasDLLImportStorageClass())\n      GV.setDLLStorageClass(GlobalValue::DefaultStorageClass);\n  }\n\n  // Remove functions imported as available externally defs from comdats,\n  // as this is a declaration for the linker, and will be dropped eventually.\n  // It is illegal for comdats to contain declarations.\n  auto *GO = dyn_cast<GlobalObject>(&GV);\n  if (GO && GO->isDeclarationForLinker() && GO->hasComdat()) {\n    // The IRMover should not have placed any imported declarations in\n    // a comdat, so the only declaration that should be in a comdat\n    // at this point would be a definition imported as available_externally.\n    assert(GO->hasAvailableExternallyLinkage() &&\n           \"Expected comdat on definition (possibly available external)\");\n    GO->setComdat(nullptr);\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  if (ClearDSOLocalOnDeclarations && GV.isDeclarationForLinker() &&\n",
        "src_path": "252a1eecc04080d852ba58c6727970c688eb1619___FunctionImportUtils.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/252a1eecc04080d852ba58c6727970c688eb1619",
        "commit_msg": "[ThinLTO] Respect ClearDSOLocalOnDeclarations for unimported functions\n\nD74751 added `ClearDSOLocalOnDeclarations` and dropped dso_local for\nisDeclarationForLinker `GlobalValue`s. It missed a case for imported\ndeclarations (`doImportAsDefinition` is false while `isPerformingImport` is\ntrue). This can lead to a linker error for a default visibility symbol in\n`ld.lld -shared`.\n\nWhen `ClearDSOLocalOnDeclarations` is true, we check\n`isPerformingImport() && !doImportAsDefinition(&GV)` along with\n`GV.isDeclarationForLinker()`. The new condition checks an imported declaration.\n\nThis patch fixes a `LLVMPolly.so` link error using a trunk clang -DLLVM_ENABLE_LTO=Thin.\n\nReviewed By: tejohnson\n\nDifferential Revision: https://reviews.llvm.org/D104986",
        "test_func_diff": [
            {
                "fn": "llvm/test/ThinLTO/X86/import-dsolocal.ll",
                "patch": "@@ -0,0 +1,124 @@\n+; RUN: split-file %s %t\n+; RUN: opt -module-summary %t/a.ll -o %t/a.bc\n+; RUN: opt -module-summary %t/b.ll -o %t/b.bc\n+\n+;; With a small limit, *_aux are either imported declarations (external/linkonce_odr/weak_odr)\n+;; or unimported (linkonce/weak). Check we discard dso_local.\n+; RUN: llvm-lto2 run %t/a.bc %t/b.bc -o %t1 -save-temps -import-instr-limit=3 \\\n+; RUN:   -r=%t/a.bc,main,plx -r=%t/a.bc,extern, -r=%t/a.bc,linkonce, -r=%t/a.bc,linkonceodr, -r=%t/a.bc,weak, -r=%t/a.bc,weakodr, \\\n+; RUN:   -r=%t/b.bc,a,pl -r=%t/b.bc,b,pl -r=%t/b.bc,extern,pl -r=%t/b.bc,extern_aux,pl \\\n+; RUN:   -r=%t/b.bc,linkonce,pl -r=%t/b.bc,linkonce_aux,pl -r=%t/b.bc,linkonceodr,pl -r=%t/b.bc,linkonceodr_aux,pl \\\n+; RUN:   -r=%t/b.bc,weak,pl -r=%t/b.bc,weak_aux,pl -r=%t/b.bc,weakodr,pl -r=%t/b.bc,weakodr_aux,pl\n+; RUN: llvm-dis %t1.1.3.import.bc -o - | FileCheck %s --check-prefixes=DEST,DEST1\n+\n+;; With a large limit, *_aux are either imported definitions (external/linkonce_odr/weak_odr)\n+;; or unimported (linkonce/weak). Check we discard dso_local as well.\n+; RUN: llvm-lto2 run %t/a.bc %t/b.bc -o %t2 -save-temps -import-instr-limit=10 \\\n+; RUN:   -r=%t/a.bc,main,plx -r=%t/a.bc,extern, -r=%t/a.bc,linkonce, -r=%t/a.bc,linkonceodr, -r=%t/a.bc,weak, -r=%t/a.bc,weakodr, \\\n+; RUN:   -r=%t/b.bc,a,pl -r=%t/b.bc,b,pl -r=%t/b.bc,extern,pl -r=%t/b.bc,extern_aux,pl \\\n+; RUN:   -r=%t/b.bc,linkonce,pl -r=%t/b.bc,linkonce_aux,pl -r=%t/b.bc,linkonceodr,pl -r=%t/b.bc,linkonceodr_aux,pl \\\n+; RUN:   -r=%t/b.bc,weak,pl -r=%t/b.bc,weak_aux,pl -r=%t/b.bc,weakodr,pl -r=%t/b.bc,weakodr_aux,pl\n+; RUN: llvm-dis %t2.1.3.import.bc -o - | FileCheck %s --check-prefixes=DEST,DEST2\n+\n+; DEST:      @a = available_externally global i32 42, align 4\n+; DEST-NEXT: @b = external global i32*, align 8\n+; DEST:      declare void @linkonce()\n+; DEST:      declare void @weak()\n+; DEST:      define dso_local i32 @main()\n+; DEST:      define available_externally void @extern()\n+\n+; DEST1:     declare i32 @extern_aux(i32*, i32**)\n+; DEST1:     declare i32 @linkonceodr_aux(i32*, i32**)\n+; DEST2:     define available_externally i32 @extern_aux(i32* %a, i32** %b)\n+; DEST2:     define available_externally i32 @linkonceodr_aux(i32* %a, i32** %b)\n+\n+; DEST:      define available_externally void @weakodr()\n+\n+; DEST1:     declare i32 @weakodr_aux(i32*, i32**)\n+; DEST2:     define available_externally i32 @weakodr_aux(i32* %a, i32** %b)\n+\n+;--- a.ll\n+target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n+target triple = \"x86_64-unknown-linux-gnu\"\n+\n+declare void @extern()\n+declare void @linkonce()\n+declare void @linkonceodr()\n+declare void @weak()\n+declare void @weakodr()\n+\n+define i32 @main() {\n+  call void @extern()\n+  call void @linkonce()\n+  call void @linkonceodr()\n+  call void @weak()\n+  call void @weakodr()\n+  ret i32 0\n+}\n+\n+;--- b.ll\n+target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n+target triple = \"x86_64-unknown-linux-gnu\"\n+\n+@a = dso_local global i32 42, align 4\n+@b = dso_local global i32* @a, align 8\n+\n+define dso_local void @extern() {\n+  call i32 @extern_aux(i32* @a, i32** @b)\n+  ret void\n+}\n+\n+define dso_local i32 @extern_aux(i32* %a, i32** %b) {\n+  %p = load i32*, i32** %b, align 8\n+  store i32 33, i32* %p, align 4\n+  %v = load i32, i32* %a, align 4\n+  ret i32 %v\n+}\n+\n+define linkonce dso_local void @linkonce() {\n+  call i32 @linkonce_aux(i32* @a, i32** @b)\n+  ret void\n+}\n+\n+define linkonce i32 @linkonce_aux(i32* %a, i32** %b) {\n+  %p = load i32*, i32** %b, align 8\n+  store i32 33, i32* %p, align 4\n+  %v = load i32, i32* %a, align 4\n+  ret i32 %v\n+}\n+\n+define linkonce_odr dso_local void @linkonceodr() {\n+  call i32 @linkonceodr_aux(i32* @a, i32** @b)\n+  ret void\n+}\n+\n+define linkonce_odr i32 @linkonceodr_aux(i32* %a, i32** %b) {\n+  %p = load i32*, i32** %b, align 8\n+  store i32 33, i32* %p, align 4\n+  %v = load i32, i32* %a, align 4\n+  ret i32 %v\n+}\n+\n+define weak dso_local void @weak() {\n+  call i32 @weak_aux(i32* @a, i32** @b)\n+  ret void\n+}\n+\n+define weak i32 @weak_aux(i32* %a, i32** %b) {\n+  %p = load i32*, i32** %b, align 8\n+  store i32 33, i32* %p, align 4\n+  %v = load i32, i32* %a, align 4\n+  ret i32 %v\n+}\n+\n+define weak_odr dso_local void @weakodr() {\n+  call i32 @weakodr_aux(i32* @a, i32** @b)\n+  ret void\n+}\n+\n+define weak_odr i32 @weakodr_aux(i32* %a, i32** %b) {\n+  %p = load i32*, i32** %b, align 8\n+  store i32 33, i32* %p, align 4\n+  %v = load i32, i32* %a, align 4\n+  ret i32 %v\n+}"
            },
            {
                "fn": "llvm/test/ThinLTO/X86/index-const-prop-linkage.ll",
                "patch": "@@ -10,7 +10,7 @@\n ; - available_externally linkage\n ; - reference from @llvm.used\n ; CHECK:      @llvm.used = appending global [1 x i32*] [i32* @g2]\n-; CHECK-NEXT: @g1 = external dso_local global i32, align 4\n+; CHECK-NEXT: @g1 = external global i32, align 4\n ; CHECK-NEXT: @g2 = available_externally global i32 42, align 4\n ; CHECK-NEXT: @g3 = available_externally global i32 42, align 4\n "
            }
        ],
        "error_msg": "FAIL: LLVM :: ThinLTO/X86/import-dsolocal.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: ThinLTO/X86/import-dsolocal.ll\n\n\nTesting Time: 0.65s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: ThinLTO/X86/index-const-prop-linkage.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: ThinLTO/X86/index-const-prop-linkage.ll\n\n\nTesting Time: 0.29s\n  Failed: 1\n"
    },
    "2702fb11484a6f5d99c712a0e92c221288955c56___SimplifyCFG.cpp": {
        "prefix": "bool SimplifyCFGOpt::simplifyOnceImpl(BasicBlock *BB) {\n  bool Changed = false;\n\n  assert(BB && BB->getParent() && \"Block not embedded in function!\");\n  assert(BB->getTerminator() && \"Degenerate basic block encountered!\");\n\n  // Remove basic blocks that have no predecessors (except the entry block)...\n  // or that just have themself as a predecessor.  These are unreachable.\n  if ((pred_empty(BB) && BB != &BB->getParent()->getEntryBlock()) ||\n      BB->getSinglePredecessor() == BB) {\n    LLVM_DEBUG(dbgs() << \"Removing BB: \\n\" << *BB);\n    DeleteDeadBlock(BB, DTU);\n    return true;\n  }\n\n  // Check to see if we can constant propagate this terminator instruction\n  // away...\n  Changed |= ConstantFoldTerminator(BB, /*DeleteDeadConditions=*/true,\n                                    /*TLI=*/nullptr, DTU);\n\n  // Check for and eliminate duplicate PHI nodes in this block.\n  Changed |= EliminateDuplicatePHINodes(BB);\n\n  // Check for and remove branches that will always cause undefined behavior.\n",
        "suffix": "\n  // Merge basic blocks into their predecessor if there is only one distinct\n  // pred, and if there is only one distinct successor of the predecessor, and\n  // if there are no PHI nodes.\n  if (MergeBlockIntoPredecessor(BB, DTU))\n    return true;\n\n  if (SinkCommon && Options.SinkCommonInsts)\n    if (SinkCommonCodeFromPredecessors(BB, DTU)) {\n      // SinkCommonCodeFromPredecessors() does not automatically CSE PHI's,\n      // so we may now how duplicate PHI's.\n      // Let's rerun EliminateDuplicatePHINodes() first,\n      // before FoldTwoEntryPHINode() potentially converts them into select's,\n      // after which we'd need a whole EarlyCSE pass run to cleanup them.\n      return true;\n    }\n\n  IRBuilder<> Builder(BB);\n\n  if (Options.FoldTwoEntryPHINode) {\n    // If there is a trivial two-entry PHI node in this basic block, and we can\n    // eliminate it, do so now.\n    if (auto *PN = dyn_cast<PHINode>(BB->begin()))\n      if (PN->getNumIncomingValues() == 2)\n        if (FoldTwoEntryPHINode(PN, TTI, DTU, DL))\n          return true;\n  }\n\n  Instruction *Terminator = BB->getTerminator();\n  Builder.SetInsertPoint(Terminator);\n  switch (Terminator->getOpcode()) {\n  case Instruction::Br:\n    Changed |= simplifyBranch(cast<BranchInst>(Terminator), Builder);\n    break;\n  case Instruction::Resume:\n    Changed |= simplifyResume(cast<ResumeInst>(Terminator), Builder);\n    break;\n  case Instruction::CleanupRet:\n    Changed |= simplifyCleanupReturn(cast<CleanupReturnInst>(Terminator));\n    break;\n  case Instruction::Switch:\n    Changed |= simplifySwitch(cast<SwitchInst>(Terminator), Builder);\n    break;\n  case Instruction::Unreachable:\n    Changed |= simplifyUnreachable(cast<UnreachableInst>(Terminator));\n    break;\n  case Instruction::IndirectBr:\n    Changed |= simplifyIndirectBr(cast<IndirectBrInst>(Terminator));\n    break;\n  }\n\n  return Changed;\n}\n",
        "start": 6613,
        "end": 6690,
        "buggy": "bool SimplifyCFGOpt::simplifyOnceImpl(BasicBlock *BB) {\n  bool Changed = false;\n\n  assert(BB && BB->getParent() && \"Block not embedded in function!\");\n  assert(BB->getTerminator() && \"Degenerate basic block encountered!\");\n\n  // Remove basic blocks that have no predecessors (except the entry block)...\n  // or that just have themself as a predecessor.  These are unreachable.\n  if ((pred_empty(BB) && BB != &BB->getParent()->getEntryBlock()) ||\n      BB->getSinglePredecessor() == BB) {\n    LLVM_DEBUG(dbgs() << \"Removing BB: \\n\" << *BB);\n    DeleteDeadBlock(BB, DTU);\n    return true;\n  }\n\n  // Check to see if we can constant propagate this terminator instruction\n  // away...\n  Changed |= ConstantFoldTerminator(BB, /*DeleteDeadConditions=*/true,\n                                    /*TLI=*/nullptr, DTU);\n\n  // Check for and eliminate duplicate PHI nodes in this block.\n  Changed |= EliminateDuplicatePHINodes(BB);\n\n  // Check for and remove branches that will always cause undefined behavior.\n  Changed |= removeUndefIntroducingPredecessor(BB, DTU);\n\n  // Merge basic blocks into their predecessor if there is only one distinct\n  // pred, and if there is only one distinct successor of the predecessor, and\n  // if there are no PHI nodes.\n  if (MergeBlockIntoPredecessor(BB, DTU))\n    return true;\n\n  if (SinkCommon && Options.SinkCommonInsts)\n    if (SinkCommonCodeFromPredecessors(BB, DTU)) {\n      // SinkCommonCodeFromPredecessors() does not automatically CSE PHI's,\n      // so we may now how duplicate PHI's.\n      // Let's rerun EliminateDuplicatePHINodes() first,\n      // before FoldTwoEntryPHINode() potentially converts them into select's,\n      // after which we'd need a whole EarlyCSE pass run to cleanup them.\n      return true;\n    }\n\n  IRBuilder<> Builder(BB);\n\n  if (Options.FoldTwoEntryPHINode) {\n    // If there is a trivial two-entry PHI node in this basic block, and we can\n    // eliminate it, do so now.\n    if (auto *PN = dyn_cast<PHINode>(BB->begin()))\n      if (PN->getNumIncomingValues() == 2)\n        if (FoldTwoEntryPHINode(PN, TTI, DTU, DL))\n          return true;\n  }\n\n  Instruction *Terminator = BB->getTerminator();\n  Builder.SetInsertPoint(Terminator);\n  switch (Terminator->getOpcode()) {\n  case Instruction::Br:\n    Changed |= simplifyBranch(cast<BranchInst>(Terminator), Builder);\n    break;\n  case Instruction::Resume:\n    Changed |= simplifyResume(cast<ResumeInst>(Terminator), Builder);\n    break;\n  case Instruction::CleanupRet:\n    Changed |= simplifyCleanupReturn(cast<CleanupReturnInst>(Terminator));\n    break;\n  case Instruction::Switch:\n    Changed |= simplifySwitch(cast<SwitchInst>(Terminator), Builder);\n    break;\n  case Instruction::Unreachable:\n    Changed |= simplifyUnreachable(cast<UnreachableInst>(Terminator));\n    break;\n  case Instruction::IndirectBr:\n    Changed |= simplifyIndirectBr(cast<IndirectBrInst>(Terminator));\n    break;\n  }\n\n  return Changed;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  Changed |= removeUndefIntroducingPredecessor(BB, DTU);\n",
        "src_path": "2702fb11484a6f5d99c712a0e92c221288955c56___SimplifyCFG.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/2702fb11484a6f5d99c712a0e92c221288955c56",
        "commit_msg": "[SimplifyCFG] Restart if `removeUndefIntroducingPredecessor()` made changes\n\nIt might changed the condition of a branch into a constant,\nso we should restart and constant-fold terminator,\ninstead of continuing with the tautological \"conditional\" branch.\nThis fixes the issue reported at https://reviews.llvm.org/rGf30a7dff8a5b32919951dcbf92e4a9d56c4679ff",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/SimplifyCFG/tautological-conditional-branch.ll",
                "patch": "@@ -15,8 +15,7 @@ define void @eggs(i1 %arg, i1 %arg16, %0* %arg17, %0* %arg18, %0* %arg19) {\n ; CHECK:       bb21:\n ; CHECK-NEXT:    [[I:%.*]] = icmp eq %0* [[ARG17:%.*]], null\n ; CHECK-NEXT:    call void @hoge()\n-; CHECK-NEXT:    [[I26:%.*]] = select i1 [[ARG16:%.*]], %0* null, %0* [[ARG19:%.*]]\n-; CHECK-NEXT:    [[I27:%.*]] = getelementptr inbounds [[TMP0:%.*]], %0* [[I26]], i64 0, i32 0\n+; CHECK-NEXT:    [[I27:%.*]] = getelementptr inbounds [[TMP0:%.*]], %0* [[ARG19:%.*]], i64 0, i32 0\n ; CHECK-NEXT:    [[I28:%.*]] = load %1*, %1** [[I27]], align 8\n ; CHECK-NEXT:    call void @pluto.1(%1* [[I28]])\n ; CHECK-NEXT:    call void @pluto()"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/SimplifyCFG/tautological-conditional-branch.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SimplifyCFG/tautological-conditional-branch.ll\n\n\nTesting Time: 0.31s\n  Failed: 1\n"
    },
    "ea8539111d444ffb93ab09c5865d9a1a0927cb2c___Mangler.cpp": {
        "prefix": "static bool canBeUnquotedInDirective(char C) {\n",
        "suffix": "}\n",
        "start": 188,
        "end": 190,
        "buggy": "static bool canBeUnquotedInDirective(char C) {\n  return isAlnum(C) || C == '_' || C == '$' || C == '.' || C == '@';\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  return isAlnum(C) || C == '_' || C == '$' || C == '.' || C == '@';\n",
        "src_path": "ea8539111d444ffb93ab09c5865d9a1a0927cb2c___Mangler.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/ea8539111d444ffb93ab09c5865d9a1a0927cb2c",
        "commit_msg": "[COFF] Force Symbols containing '.' to be quoted\n\nIn D87099, the mangler learned to quote export directives that contain\nspecial characters. Only alhpanumerical characters as well as\n'_', '$', '.' and '@' were exmpt from this quoting. However, at least\nbinutils considers an unquoted '.' to be syntax and object files\ncontaining such symbols will cause errors during linking. Fix that\nby removing '.' from the list of allowed exemptions.\n\nDifferential Revision: https://reviews.llvm.org/D100359",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/dllexport.ll",
                "patch": "@@ -84,6 +84,9 @@ define weak_odr dllexport void @weak1() {\n ; CHECK: .globl \"_complex-name\"\n @\"complex-name\" = dllexport global i32 1, align 4\n \n+; CHECK: .globl _complex.name\n+@\"complex.name\" = dllexport global i32 1, align 4\n+\n \n ; Verify items that should not be exported do not appear in the export table.\n ; We use a separate check prefix to avoid confusion between -NOT and -SAME.\n@@ -106,6 +109,7 @@ define weak_odr dllexport void @weak1() {\n ; CHECK-CL: .ascii \" /EXPORT:_WeakVar1,DATA\"\n ; CHECK-CL: .ascii \" /EXPORT:_WeakVar2,DATA\"\n ; CHECK-CL: .ascii \" /EXPORT:\\\"_complex-name\\\",DATA\"\n+; CHECK-CL: .ascii \" /EXPORT:\\\"_complex.name\\\",DATA\"\n ; CHECK-CL: .ascii \" /EXPORT:_alias\"\n ; CHECK-CL: .ascii \" /EXPORT:_alias2\"\n ; CHECK-CL: .ascii \" /EXPORT:_alias3\"\n@@ -124,6 +128,7 @@ define weak_odr dllexport void @weak1() {\n ; CHECK-GCC: .ascii \" -export:WeakVar1,data\"\n ; CHECK-GCC: .ascii \" -export:WeakVar2,data\"\n ; CHECK-GCC: .ascii \" -export:\\\"complex-name\\\",data\"\n+; CHECK-GCC: .ascii \" -export:\\\"complex.name\\\",data\"\n ; CHECK-GCC: .ascii \" -export:alias\"\n ; CHECK-GCC: .ascii \" -export:alias2\"\n ; CHECK-GCC: .ascii \" -export:alias3\""
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/dllexport.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/dllexport.ll\n\n\nTesting Time: 0.44s\n  Failed: 1\n"
    },
    "307890f85b33bc190b563bcb3daeb232b8ecaa73___X86ISelLowering.cpp": {
        "prefix": "static SDValue LowerScalarImmediateShift(SDValue Op, SelectionDAG &DAG,\n                                         const X86Subtarget &Subtarget) {\n  MVT VT = Op.getSimpleValueType();\n  SDLoc dl(Op);\n  SDValue R = Op.getOperand(0);\n  SDValue Amt = Op.getOperand(1);\n  unsigned X86Opc = getTargetVShiftUniformOpcode(Op.getOpcode(), false);\n\n  auto ArithmeticShiftRight64 = [&](uint64_t ShiftAmt) {\n    assert((VT == MVT::v2i64 || VT == MVT::v4i64) && \"Unexpected SRA type\");\n    MVT ExVT = MVT::getVectorVT(MVT::i32, VT.getVectorNumElements() * 2);\n    SDValue Ex = DAG.getBitcast(ExVT, R);\n\n    // ashr(R, 63) === cmp_slt(R, 0)\n    if (ShiftAmt == 63 && Subtarget.hasSSE42()) {\n      assert((VT != MVT::v4i64 || Subtarget.hasInt256()) &&\n             \"Unsupported PCMPGT op\");\n      return DAG.getNode(X86ISD::PCMPGT, dl, VT, DAG.getConstant(0, dl, VT), R);\n    }\n\n    if (ShiftAmt >= 32) {\n      // Splat sign to upper i32 dst, and SRA upper i32 src to lower i32.\n      SDValue Upper =\n          getTargetVShiftByConstNode(X86ISD::VSRAI, dl, ExVT, Ex, 31, DAG);\n      SDValue Lower = getTargetVShiftByConstNode(X86ISD::VSRAI, dl, ExVT, Ex,\n                                                 ShiftAmt - 32, DAG);\n      if (VT == MVT::v2i64)\n        Ex = DAG.getVectorShuffle(ExVT, dl, Upper, Lower, {5, 1, 7, 3});\n      if (VT == MVT::v4i64)\n        Ex = DAG.getVectorShuffle(ExVT, dl, Upper, Lower,\n                                  {9, 1, 11, 3, 13, 5, 15, 7});\n    } else {\n      // SRA upper i32, SRL whole i64 and select lower i32.\n      SDValue Upper = getTargetVShiftByConstNode(X86ISD::VSRAI, dl, ExVT, Ex,\n                                                 ShiftAmt, DAG);\n      SDValue Lower =\n          getTargetVShiftByConstNode(X86ISD::VSRLI, dl, VT, R, ShiftAmt, DAG);\n      Lower = DAG.getBitcast(ExVT, Lower);\n      if (VT == MVT::v2i64)\n        Ex = DAG.getVectorShuffle(ExVT, dl, Upper, Lower, {4, 1, 6, 3});\n      if (VT == MVT::v4i64)\n        Ex = DAG.getVectorShuffle(ExVT, dl, Upper, Lower,\n                                  {8, 1, 10, 3, 12, 5, 14, 7});\n    }\n    return DAG.getBitcast(VT, Ex);\n  };\n\n  // Optimize shl/srl/sra with constant shift amount.\n  APInt APIntShiftAmt;\n  if (!X86::isConstantSplat(Amt, APIntShiftAmt))\n    return SDValue();\n\n  // If the shift amount is out of range, return undef.\n  if (APIntShiftAmt.uge(VT.getScalarSizeInBits()))\n    return DAG.getUNDEF(VT);\n\n  uint64_t ShiftAmt = APIntShiftAmt.getZExtValue();\n\n  if (SupportedVectorShiftWithImm(VT, Subtarget, Op.getOpcode()))\n    return getTargetVShiftByConstNode(X86Opc, dl, VT, R, ShiftAmt, DAG);\n\n  // i64 SRA needs to be performed as partial shifts.\n  if (((!Subtarget.hasXOP() && VT == MVT::v2i64) ||\n       (Subtarget.hasInt256() && VT == MVT::v4i64)) &&\n      Op.getOpcode() == ISD::SRA)\n    return ArithmeticShiftRight64(ShiftAmt);\n\n  if (VT == MVT::v16i8 || (Subtarget.hasInt256() && VT == MVT::v32i8) ||\n      (Subtarget.hasBWI() && VT == MVT::v64i8)) {\n    unsigned NumElts = VT.getVectorNumElements();\n    MVT ShiftVT = MVT::getVectorVT(MVT::i16, NumElts / 2);\n\n    // Simple i8 add case\n",
        "suffix": "      return DAG.getNode(ISD::ADD, dl, VT, R, R);\n\n    // ashr(R, 7)  === cmp_slt(R, 0)\n    if (Op.getOpcode() == ISD::SRA && ShiftAmt == 7) {\n      SDValue Zeros = DAG.getConstant(0, dl, VT);\n      if (VT.is512BitVector()) {\n        assert(VT == MVT::v64i8 && \"Unexpected element type!\");\n        SDValue CMP = DAG.getSetCC(dl, MVT::v64i1, Zeros, R, ISD::SETGT);\n        return DAG.getNode(ISD::SIGN_EXTEND, dl, VT, CMP);\n      }\n      return DAG.getNode(X86ISD::PCMPGT, dl, VT, Zeros, R);\n    }\n\n    // XOP can shift v16i8 directly instead of as shift v8i16 + mask.\n    if (VT == MVT::v16i8 && Subtarget.hasXOP())\n      return SDValue();\n\n    if (Op.getOpcode() == ISD::SHL) {\n      // Make a large shift.\n      SDValue SHL = getTargetVShiftByConstNode(X86ISD::VSHLI, dl, ShiftVT, R,\n                                               ShiftAmt, DAG);\n      SHL = DAG.getBitcast(VT, SHL);\n      // Zero out the rightmost bits.\n      APInt Mask = APInt::getHighBitsSet(8, 8 - ShiftAmt);\n      return DAG.getNode(ISD::AND, dl, VT, SHL, DAG.getConstant(Mask, dl, VT));\n    }\n    if (Op.getOpcode() == ISD::SRL) {\n      // Make a large shift.\n      SDValue SRL = getTargetVShiftByConstNode(X86ISD::VSRLI, dl, ShiftVT, R,\n                                               ShiftAmt, DAG);\n      SRL = DAG.getBitcast(VT, SRL);\n      // Zero out the leftmost bits.\n      APInt Mask = APInt::getLowBitsSet(8, 8 - ShiftAmt);\n      return DAG.getNode(ISD::AND, dl, VT, SRL, DAG.getConstant(Mask, dl, VT));\n    }\n    if (Op.getOpcode() == ISD::SRA) {\n      // ashr(R, Amt) === sub(xor(lshr(R, Amt), Mask), Mask)\n      SDValue Res = DAG.getNode(ISD::SRL, dl, VT, R, Amt);\n\n      SDValue Mask = DAG.getConstant(128 >> ShiftAmt, dl, VT);\n      Res = DAG.getNode(ISD::XOR, dl, VT, Res, Mask);\n      Res = DAG.getNode(ISD::SUB, dl, VT, Res, Mask);\n      return Res;\n    }\n    llvm_unreachable(\"Unknown shift opcode.\");\n  }\n\n  return SDValue();\n}\n",
        "start": 28661,
        "end": 28783,
        "buggy": "static SDValue LowerScalarImmediateShift(SDValue Op, SelectionDAG &DAG,\n                                         const X86Subtarget &Subtarget) {\n  MVT VT = Op.getSimpleValueType();\n  SDLoc dl(Op);\n  SDValue R = Op.getOperand(0);\n  SDValue Amt = Op.getOperand(1);\n  unsigned X86Opc = getTargetVShiftUniformOpcode(Op.getOpcode(), false);\n\n  auto ArithmeticShiftRight64 = [&](uint64_t ShiftAmt) {\n    assert((VT == MVT::v2i64 || VT == MVT::v4i64) && \"Unexpected SRA type\");\n    MVT ExVT = MVT::getVectorVT(MVT::i32, VT.getVectorNumElements() * 2);\n    SDValue Ex = DAG.getBitcast(ExVT, R);\n\n    // ashr(R, 63) === cmp_slt(R, 0)\n    if (ShiftAmt == 63 && Subtarget.hasSSE42()) {\n      assert((VT != MVT::v4i64 || Subtarget.hasInt256()) &&\n             \"Unsupported PCMPGT op\");\n      return DAG.getNode(X86ISD::PCMPGT, dl, VT, DAG.getConstant(0, dl, VT), R);\n    }\n\n    if (ShiftAmt >= 32) {\n      // Splat sign to upper i32 dst, and SRA upper i32 src to lower i32.\n      SDValue Upper =\n          getTargetVShiftByConstNode(X86ISD::VSRAI, dl, ExVT, Ex, 31, DAG);\n      SDValue Lower = getTargetVShiftByConstNode(X86ISD::VSRAI, dl, ExVT, Ex,\n                                                 ShiftAmt - 32, DAG);\n      if (VT == MVT::v2i64)\n        Ex = DAG.getVectorShuffle(ExVT, dl, Upper, Lower, {5, 1, 7, 3});\n      if (VT == MVT::v4i64)\n        Ex = DAG.getVectorShuffle(ExVT, dl, Upper, Lower,\n                                  {9, 1, 11, 3, 13, 5, 15, 7});\n    } else {\n      // SRA upper i32, SRL whole i64 and select lower i32.\n      SDValue Upper = getTargetVShiftByConstNode(X86ISD::VSRAI, dl, ExVT, Ex,\n                                                 ShiftAmt, DAG);\n      SDValue Lower =\n          getTargetVShiftByConstNode(X86ISD::VSRLI, dl, VT, R, ShiftAmt, DAG);\n      Lower = DAG.getBitcast(ExVT, Lower);\n      if (VT == MVT::v2i64)\n        Ex = DAG.getVectorShuffle(ExVT, dl, Upper, Lower, {4, 1, 6, 3});\n      if (VT == MVT::v4i64)\n        Ex = DAG.getVectorShuffle(ExVT, dl, Upper, Lower,\n                                  {8, 1, 10, 3, 12, 5, 14, 7});\n    }\n    return DAG.getBitcast(VT, Ex);\n  };\n\n  // Optimize shl/srl/sra with constant shift amount.\n  APInt APIntShiftAmt;\n  if (!X86::isConstantSplat(Amt, APIntShiftAmt))\n    return SDValue();\n\n  // If the shift amount is out of range, return undef.\n  if (APIntShiftAmt.uge(VT.getScalarSizeInBits()))\n    return DAG.getUNDEF(VT);\n\n  uint64_t ShiftAmt = APIntShiftAmt.getZExtValue();\n\n  if (SupportedVectorShiftWithImm(VT, Subtarget, Op.getOpcode()))\n    return getTargetVShiftByConstNode(X86Opc, dl, VT, R, ShiftAmt, DAG);\n\n  // i64 SRA needs to be performed as partial shifts.\n  if (((!Subtarget.hasXOP() && VT == MVT::v2i64) ||\n       (Subtarget.hasInt256() && VT == MVT::v4i64)) &&\n      Op.getOpcode() == ISD::SRA)\n    return ArithmeticShiftRight64(ShiftAmt);\n\n  if (VT == MVT::v16i8 || (Subtarget.hasInt256() && VT == MVT::v32i8) ||\n      (Subtarget.hasBWI() && VT == MVT::v64i8)) {\n    unsigned NumElts = VT.getVectorNumElements();\n    MVT ShiftVT = MVT::getVectorVT(MVT::i16, NumElts / 2);\n\n    // Simple i8 add case\n    if (Op.getOpcode() == ISD::SHL && ShiftAmt == 1)\n      return DAG.getNode(ISD::ADD, dl, VT, R, R);\n\n    // ashr(R, 7)  === cmp_slt(R, 0)\n    if (Op.getOpcode() == ISD::SRA && ShiftAmt == 7) {\n      SDValue Zeros = DAG.getConstant(0, dl, VT);\n      if (VT.is512BitVector()) {\n        assert(VT == MVT::v64i8 && \"Unexpected element type!\");\n        SDValue CMP = DAG.getSetCC(dl, MVT::v64i1, Zeros, R, ISD::SETGT);\n        return DAG.getNode(ISD::SIGN_EXTEND, dl, VT, CMP);\n      }\n      return DAG.getNode(X86ISD::PCMPGT, dl, VT, Zeros, R);\n    }\n\n    // XOP can shift v16i8 directly instead of as shift v8i16 + mask.\n    if (VT == MVT::v16i8 && Subtarget.hasXOP())\n      return SDValue();\n\n    if (Op.getOpcode() == ISD::SHL) {\n      // Make a large shift.\n      SDValue SHL = getTargetVShiftByConstNode(X86ISD::VSHLI, dl, ShiftVT, R,\n                                               ShiftAmt, DAG);\n      SHL = DAG.getBitcast(VT, SHL);\n      // Zero out the rightmost bits.\n      APInt Mask = APInt::getHighBitsSet(8, 8 - ShiftAmt);\n      return DAG.getNode(ISD::AND, dl, VT, SHL, DAG.getConstant(Mask, dl, VT));\n    }\n    if (Op.getOpcode() == ISD::SRL) {\n      // Make a large shift.\n      SDValue SRL = getTargetVShiftByConstNode(X86ISD::VSRLI, dl, ShiftVT, R,\n                                               ShiftAmt, DAG);\n      SRL = DAG.getBitcast(VT, SRL);\n      // Zero out the leftmost bits.\n      APInt Mask = APInt::getLowBitsSet(8, 8 - ShiftAmt);\n      return DAG.getNode(ISD::AND, dl, VT, SRL, DAG.getConstant(Mask, dl, VT));\n    }\n    if (Op.getOpcode() == ISD::SRA) {\n      // ashr(R, Amt) === sub(xor(lshr(R, Amt), Mask), Mask)\n      SDValue Res = DAG.getNode(ISD::SRL, dl, VT, R, Amt);\n\n      SDValue Mask = DAG.getConstant(128 >> ShiftAmt, dl, VT);\n      Res = DAG.getNode(ISD::XOR, dl, VT, Res, Mask);\n      Res = DAG.getNode(ISD::SUB, dl, VT, Res, Mask);\n      return Res;\n    }\n    llvm_unreachable(\"Unknown shift opcode.\");\n  }\n\n  return SDValue();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (Op.getOpcode() == ISD::SHL && ShiftAmt == 1)\n",
        "src_path": "307890f85b33bc190b563bcb3daeb232b8ecaa73___X86ISelLowering.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/307890f85b33bc190b563bcb3daeb232b8ecaa73",
        "commit_msg": "[X86] Freeze vXi8 shl(x,1) -> add(x,x) vector fold (PR50468)\n\nWe don't have any vXi8 shift instructions (other than on XOP which is handled separately), so replace the shl(x,1) -> add(x,x) fold with shl(x,1) -> add(freeze(x),freeze(x)) to avoid the undef issues identified in PR50468.\n\nSplit off from D106675 as I'm still looking at whether we can fix the vXi16/i32/i64 issues with the D106679 alternative.\n\nDifferential Revision: https://reviews.llvm.org/D108139",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/bitreverse.ll",
                "patch": "@@ -69,11 +69,11 @@ define <2 x i16> @test_bitreverse_v2i16(<2 x i16> %a) nounwind {\n ; X64-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n ; X64-NEXT:    psrlw $2, %xmm0\n ; X64-NEXT:    por %xmm1, %xmm0\n-; X64-NEXT:    movdqa {{.*#+}} xmm1 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n+; X64-NEXT:    movdqa {{.*#+}} xmm1 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n ; X64-NEXT:    pand %xmm0, %xmm1\n-; X64-NEXT:    paddb %xmm1, %xmm1\n+; X64-NEXT:    psrlw $1, %xmm1\n ; X64-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n-; X64-NEXT:    psrlw $1, %xmm0\n+; X64-NEXT:    paddb %xmm0, %xmm0\n ; X64-NEXT:    por %xmm1, %xmm0\n ; X64-NEXT:    retq\n ;"
            },
            {
                "fn": "llvm/test/CodeGen/X86/combine-bitreverse.ll",
                "patch": "@@ -61,11 +61,11 @@ define <4 x i32> @test_demandedbits_bitreverse(<4 x i32> %a0) nounwind {\n ; X86-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm0\n ; X86-NEXT:    psrlw $2, %xmm0\n ; X86-NEXT:    por %xmm1, %xmm0\n-; X86-NEXT:    movdqa {{.*#+}} xmm1 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n+; X86-NEXT:    movdqa {{.*#+}} xmm1 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n ; X86-NEXT:    pand %xmm0, %xmm1\n-; X86-NEXT:    paddb %xmm1, %xmm1\n+; X86-NEXT:    psrlw $1, %xmm1\n ; X86-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm0\n-; X86-NEXT:    psrlw $1, %xmm0\n+; X86-NEXT:    paddb %xmm0, %xmm0\n ; X86-NEXT:    por %xmm1, %xmm0\n ; X86-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm0\n ; X86-NEXT:    retl"
            },
            {
                "fn": "llvm/test/CodeGen/X86/vector-bitreverse.ll",
                "patch": "@@ -693,11 +693,11 @@ define <16 x i8> @test_bitreverse_v16i8(<16 x i8> %a) nounwind {\n ; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n ; SSE2-NEXT:    psrlw $2, %xmm0\n ; SSE2-NEXT:    por %xmm1, %xmm0\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm1 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm1 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n ; SSE2-NEXT:    pand %xmm0, %xmm1\n-; SSE2-NEXT:    paddb %xmm1, %xmm1\n+; SSE2-NEXT:    psrlw $1, %xmm1\n ; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n-; SSE2-NEXT:    psrlw $1, %xmm0\n+; SSE2-NEXT:    paddb %xmm0, %xmm0\n ; SSE2-NEXT:    por %xmm1, %xmm0\n ; SSE2-NEXT:    retq\n ;\n@@ -781,11 +781,11 @@ define <8 x i16> @test_bitreverse_v8i16(<8 x i16> %a) nounwind {\n ; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n ; SSE2-NEXT:    psrlw $2, %xmm0\n ; SSE2-NEXT:    por %xmm1, %xmm0\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm1 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm1 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n ; SSE2-NEXT:    pand %xmm0, %xmm1\n-; SSE2-NEXT:    paddb %xmm1, %xmm1\n+; SSE2-NEXT:    psrlw $1, %xmm1\n ; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n-; SSE2-NEXT:    psrlw $1, %xmm0\n+; SSE2-NEXT:    paddb %xmm0, %xmm0\n ; SSE2-NEXT:    por %xmm1, %xmm0\n ; SSE2-NEXT:    retq\n ;\n@@ -881,11 +881,11 @@ define <4 x i32> @test_bitreverse_v4i32(<4 x i32> %a) nounwind {\n ; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n ; SSE2-NEXT:    psrlw $2, %xmm0\n ; SSE2-NEXT:    por %xmm1, %xmm0\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm1 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm1 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n ; SSE2-NEXT:    pand %xmm0, %xmm1\n-; SSE2-NEXT:    paddb %xmm1, %xmm1\n+; SSE2-NEXT:    psrlw $1, %xmm1\n ; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n-; SSE2-NEXT:    psrlw $1, %xmm0\n+; SSE2-NEXT:    paddb %xmm0, %xmm0\n ; SSE2-NEXT:    por %xmm1, %xmm0\n ; SSE2-NEXT:    retq\n ;\n@@ -983,11 +983,11 @@ define <2 x i64> @test_bitreverse_v2i64(<2 x i64> %a) nounwind {\n ; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n ; SSE2-NEXT:    psrlw $2, %xmm0\n ; SSE2-NEXT:    por %xmm1, %xmm0\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm1 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm1 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n ; SSE2-NEXT:    pand %xmm0, %xmm1\n-; SSE2-NEXT:    paddb %xmm1, %xmm1\n+; SSE2-NEXT:    psrlw $1, %xmm1\n ; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n-; SSE2-NEXT:    psrlw $1, %xmm0\n+; SSE2-NEXT:    paddb %xmm0, %xmm0\n ; SSE2-NEXT:    por %xmm1, %xmm0\n ; SSE2-NEXT:    retq\n ;\n@@ -1079,13 +1079,13 @@ define <32 x i8> @test_bitreverse_v32i8(<32 x i8> %a) nounwind {\n ; SSE2-NEXT:    pand %xmm5, %xmm0\n ; SSE2-NEXT:    psrlw $2, %xmm0\n ; SSE2-NEXT:    por %xmm4, %xmm0\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm4 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm4 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n ; SSE2-NEXT:    movdqa %xmm0, %xmm6\n ; SSE2-NEXT:    pand %xmm4, %xmm6\n-; SSE2-NEXT:    paddb %xmm6, %xmm6\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm7 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n+; SSE2-NEXT:    psrlw $1, %xmm6\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm7 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n ; SSE2-NEXT:    pand %xmm7, %xmm0\n-; SSE2-NEXT:    psrlw $1, %xmm0\n+; SSE2-NEXT:    paddb %xmm0, %xmm0\n ; SSE2-NEXT:    por %xmm6, %xmm0\n ; SSE2-NEXT:    movdqa %xmm2, %xmm6\n ; SSE2-NEXT:    psllw $4, %xmm6\n@@ -1099,9 +1099,9 @@ define <32 x i8> @test_bitreverse_v32i8(<32 x i8> %a) nounwind {\n ; SSE2-NEXT:    psrlw $2, %xmm1\n ; SSE2-NEXT:    por %xmm3, %xmm1\n ; SSE2-NEXT:    pand %xmm1, %xmm4\n-; SSE2-NEXT:    paddb %xmm4, %xmm4\n+; SSE2-NEXT:    psrlw $1, %xmm4\n ; SSE2-NEXT:    pand %xmm7, %xmm1\n-; SSE2-NEXT:    psrlw $1, %xmm1\n+; SSE2-NEXT:    paddb %xmm1, %xmm1\n ; SSE2-NEXT:    por %xmm4, %xmm1\n ; SSE2-NEXT:    retq\n ;\n@@ -1256,13 +1256,13 @@ define <16 x i16> @test_bitreverse_v16i16(<16 x i16> %a) nounwind {\n ; SSE2-NEXT:    pand %xmm5, %xmm0\n ; SSE2-NEXT:    psrlw $2, %xmm0\n ; SSE2-NEXT:    por %xmm4, %xmm0\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm4 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm4 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n ; SSE2-NEXT:    movdqa %xmm0, %xmm7\n ; SSE2-NEXT:    pand %xmm4, %xmm7\n-; SSE2-NEXT:    paddb %xmm7, %xmm7\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm6 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n+; SSE2-NEXT:    psrlw $1, %xmm7\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm6 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n ; SSE2-NEXT:    pand %xmm6, %xmm0\n-; SSE2-NEXT:    psrlw $1, %xmm0\n+; SSE2-NEXT:    paddb %xmm0, %xmm0\n ; SSE2-NEXT:    por %xmm7, %xmm0\n ; SSE2-NEXT:    movdqa %xmm2, %xmm7\n ; SSE2-NEXT:    psrlw $8, %xmm7\n@@ -1280,9 +1280,9 @@ define <16 x i16> @test_bitreverse_v16i16(<16 x i16> %a) nounwind {\n ; SSE2-NEXT:    psrlw $2, %xmm1\n ; SSE2-NEXT:    por %xmm3, %xmm1\n ; SSE2-NEXT:    pand %xmm1, %xmm4\n-; SSE2-NEXT:    paddb %xmm4, %xmm4\n+; SSE2-NEXT:    psrlw $1, %xmm4\n ; SSE2-NEXT:    pand %xmm6, %xmm1\n-; SSE2-NEXT:    psrlw $1, %xmm1\n+; SSE2-NEXT:    paddb %xmm1, %xmm1\n ; SSE2-NEXT:    por %xmm4, %xmm1\n ; SSE2-NEXT:    retq\n ;\n@@ -1459,13 +1459,13 @@ define <8 x i32> @test_bitreverse_v8i32(<8 x i32> %a) nounwind {\n ; SSE2-NEXT:    pand %xmm8, %xmm0\n ; SSE2-NEXT:    psrlw $2, %xmm0\n ; SSE2-NEXT:    por %xmm5, %xmm0\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm5 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm5 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n ; SSE2-NEXT:    movdqa %xmm0, %xmm6\n ; SSE2-NEXT:    pand %xmm5, %xmm6\n-; SSE2-NEXT:    paddb %xmm6, %xmm6\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm7 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n+; SSE2-NEXT:    psrlw $1, %xmm6\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm7 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n ; SSE2-NEXT:    pand %xmm7, %xmm0\n-; SSE2-NEXT:    psrlw $1, %xmm0\n+; SSE2-NEXT:    paddb %xmm0, %xmm0\n ; SSE2-NEXT:    por %xmm6, %xmm0\n ; SSE2-NEXT:    movdqa %xmm2, %xmm6\n ; SSE2-NEXT:    punpckhbw {{.*#+}} xmm6 = xmm6[8],xmm4[8],xmm6[9],xmm4[9],xmm6[10],xmm4[10],xmm6[11],xmm4[11],xmm6[12],xmm4[12],xmm6[13],xmm4[13],xmm6[14],xmm4[14],xmm6[15],xmm4[15]\n@@ -1487,9 +1487,9 @@ define <8 x i32> @test_bitreverse_v8i32(<8 x i32> %a) nounwind {\n ; SSE2-NEXT:    psrlw $2, %xmm1\n ; SSE2-NEXT:    por %xmm3, %xmm1\n ; SSE2-NEXT:    pand %xmm1, %xmm5\n-; SSE2-NEXT:    paddb %xmm5, %xmm5\n+; SSE2-NEXT:    psrlw $1, %xmm5\n ; SSE2-NEXT:    pand %xmm7, %xmm1\n-; SSE2-NEXT:    psrlw $1, %xmm1\n+; SSE2-NEXT:    paddb %xmm1, %xmm1\n ; SSE2-NEXT:    por %xmm5, %xmm1\n ; SSE2-NEXT:    retq\n ;\n@@ -1668,13 +1668,13 @@ define <4 x i64> @test_bitreverse_v4i64(<4 x i64> %a) nounwind {\n ; SSE2-NEXT:    pand %xmm8, %xmm0\n ; SSE2-NEXT:    psrlw $2, %xmm0\n ; SSE2-NEXT:    por %xmm5, %xmm0\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm5 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm5 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n ; SSE2-NEXT:    movdqa %xmm0, %xmm6\n ; SSE2-NEXT:    pand %xmm5, %xmm6\n-; SSE2-NEXT:    paddb %xmm6, %xmm6\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm7 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n+; SSE2-NEXT:    psrlw $1, %xmm6\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm7 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n ; SSE2-NEXT:    pand %xmm7, %xmm0\n-; SSE2-NEXT:    psrlw $1, %xmm0\n+; SSE2-NEXT:    paddb %xmm0, %xmm0\n ; SSE2-NEXT:    por %xmm6, %xmm0\n ; SSE2-NEXT:    movdqa %xmm2, %xmm6\n ; SSE2-NEXT:    punpckhbw {{.*#+}} xmm6 = xmm6[8],xmm4[8],xmm6[9],xmm4[9],xmm6[10],xmm4[10],xmm6[11],xmm4[11],xmm6[12],xmm4[12],xmm6[13],xmm4[13],xmm6[14],xmm4[14],xmm6[15],xmm4[15]\n@@ -1698,9 +1698,9 @@ define <4 x i64> @test_bitreverse_v4i64(<4 x i64> %a) nounwind {\n ; SSE2-NEXT:    psrlw $2, %xmm1\n ; SSE2-NEXT:    por %xmm3, %xmm1\n ; SSE2-NEXT:    pand %xmm1, %xmm5\n-; SSE2-NEXT:    paddb %xmm5, %xmm5\n+; SSE2-NEXT:    psrlw $1, %xmm5\n ; SSE2-NEXT:    pand %xmm7, %xmm1\n-; SSE2-NEXT:    psrlw $1, %xmm1\n+; SSE2-NEXT:    paddb %xmm1, %xmm1\n ; SSE2-NEXT:    por %xmm5, %xmm1\n ; SSE2-NEXT:    retq\n ;\n@@ -1868,13 +1868,13 @@ define <64 x i8> @test_bitreverse_v64i8(<64 x i8> %a) nounwind {\n ; SSE2-NEXT:    pand %xmm8, %xmm0\n ; SSE2-NEXT:    psrlw $2, %xmm0\n ; SSE2-NEXT:    por %xmm6, %xmm0\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm6 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm6 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n ; SSE2-NEXT:    movdqa %xmm0, %xmm7\n ; SSE2-NEXT:    pand %xmm6, %xmm7\n-; SSE2-NEXT:    paddb %xmm7, %xmm7\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm9 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n+; SSE2-NEXT:    psrlw $1, %xmm7\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm9 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n ; SSE2-NEXT:    pand %xmm9, %xmm0\n-; SSE2-NEXT:    psrlw $1, %xmm0\n+; SSE2-NEXT:    paddb %xmm0, %xmm0\n ; SSE2-NEXT:    por %xmm7, %xmm0\n ; SSE2-NEXT:    movdqa %xmm1, %xmm7\n ; SSE2-NEXT:    psllw $4, %xmm7\n@@ -1891,9 +1891,9 @@ define <64 x i8> @test_bitreverse_v64i8(<64 x i8> %a) nounwind {\n ; SSE2-NEXT:    por %xmm4, %xmm1\n ; SSE2-NEXT:    movdqa %xmm1, %xmm4\n ; SSE2-NEXT:    pand %xmm6, %xmm4\n-; SSE2-NEXT:    paddb %xmm4, %xmm4\n+; SSE2-NEXT:    psrlw $1, %xmm4\n ; SSE2-NEXT:    pand %xmm9, %xmm1\n-; SSE2-NEXT:    psrlw $1, %xmm1\n+; SSE2-NEXT:    paddb %xmm1, %xmm1\n ; SSE2-NEXT:    por %xmm4, %xmm1\n ; SSE2-NEXT:    movdqa %xmm2, %xmm4\n ; SSE2-NEXT:    psllw $4, %xmm4\n@@ -1910,9 +1910,9 @@ define <64 x i8> @test_bitreverse_v64i8(<64 x i8> %a) nounwind {\n ; SSE2-NEXT:    por %xmm4, %xmm2\n ; SSE2-NEXT:    movdqa %xmm2, %xmm4\n ; SSE2-NEXT:    pand %xmm6, %xmm4\n-; SSE2-NEXT:    paddb %xmm4, %xmm4\n+; SSE2-NEXT:    psrlw $1, %xmm4\n ; SSE2-NEXT:    pand %xmm9, %xmm2\n-; SSE2-NEXT:    psrlw $1, %xmm2\n+; SSE2-NEXT:    paddb %xmm2, %xmm2\n ; SSE2-NEXT:    por %xmm4, %xmm2\n ; SSE2-NEXT:    movdqa %xmm10, %xmm4\n ; SSE2-NEXT:    psllw $4, %xmm4\n@@ -1926,9 +1926,9 @@ define <64 x i8> @test_bitreverse_v64i8(<64 x i8> %a) nounwind {\n ; SSE2-NEXT:    psrlw $2, %xmm3\n ; SSE2-NEXT:    por %xmm5, %xmm3\n ; SSE2-NEXT:    pand %xmm3, %xmm6\n-; SSE2-NEXT:    paddb %xmm6, %xmm6\n+; SSE2-NEXT:    psrlw $1, %xmm6\n ; SSE2-NEXT:    pand %xmm9, %xmm3\n-; SSE2-NEXT:    psrlw $1, %xmm3\n+; SSE2-NEXT:    paddb %xmm3, %xmm3\n ; SSE2-NEXT:    por %xmm6, %xmm3\n ; SSE2-NEXT:    retq\n ;\n@@ -2160,13 +2160,13 @@ define <32 x i16> @test_bitreverse_v32i16(<32 x i16> %a) nounwind {\n ; SSE2-NEXT:    pand %xmm8, %xmm0\n ; SSE2-NEXT:    psrlw $2, %xmm0\n ; SSE2-NEXT:    por %xmm6, %xmm0\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm6 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm6 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n ; SSE2-NEXT:    movdqa %xmm0, %xmm7\n ; SSE2-NEXT:    pand %xmm6, %xmm7\n-; SSE2-NEXT:    paddb %xmm7, %xmm7\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm9 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n+; SSE2-NEXT:    psrlw $1, %xmm7\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm9 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n ; SSE2-NEXT:    pand %xmm9, %xmm0\n-; SSE2-NEXT:    psrlw $1, %xmm0\n+; SSE2-NEXT:    paddb %xmm0, %xmm0\n ; SSE2-NEXT:    por %xmm7, %xmm0\n ; SSE2-NEXT:    movdqa %xmm1, %xmm7\n ; SSE2-NEXT:    psrlw $8, %xmm7\n@@ -2187,9 +2187,9 @@ define <32 x i16> @test_bitreverse_v32i16(<32 x i16> %a) nounwind {\n ; SSE2-NEXT:    por %xmm5, %xmm1\n ; SSE2-NEXT:    movdqa %xmm1, %xmm5\n ; SSE2-NEXT:    pand %xmm6, %xmm5\n-; SSE2-NEXT:    paddb %xmm5, %xmm5\n+; SSE2-NEXT:    psrlw $1, %xmm5\n ; SSE2-NEXT:    pand %xmm9, %xmm1\n-; SSE2-NEXT:    psrlw $1, %xmm1\n+; SSE2-NEXT:    paddb %xmm1, %xmm1\n ; SSE2-NEXT:    por %xmm5, %xmm1\n ; SSE2-NEXT:    movdqa %xmm2, %xmm5\n ; SSE2-NEXT:    psrlw $8, %xmm5\n@@ -2210,9 +2210,9 @@ define <32 x i16> @test_bitreverse_v32i16(<32 x i16> %a) nounwind {\n ; SSE2-NEXT:    por %xmm5, %xmm2\n ; SSE2-NEXT:    movdqa %xmm2, %xmm5\n ; SSE2-NEXT:    pand %xmm6, %xmm5\n-; SSE2-NEXT:    paddb %xmm5, %xmm5\n+; SSE2-NEXT:    psrlw $1, %xmm5\n ; SSE2-NEXT:    pand %xmm9, %xmm2\n-; SSE2-NEXT:    psrlw $1, %xmm2\n+; SSE2-NEXT:    paddb %xmm2, %xmm2\n ; SSE2-NEXT:    por %xmm5, %xmm2\n ; SSE2-NEXT:    movdqa %xmm4, %xmm5\n ; SSE2-NEXT:    psrlw $8, %xmm5\n@@ -2230,9 +2230,9 @@ define <32 x i16> @test_bitreverse_v32i16(<32 x i16> %a) nounwind {\n ; SSE2-NEXT:    psrlw $2, %xmm3\n ; SSE2-NEXT:    por %xmm10, %xmm3\n ; SSE2-NEXT:    pand %xmm3, %xmm6\n-; SSE2-NEXT:    paddb %xmm6, %xmm6\n+; SSE2-NEXT:    psrlw $1, %xmm6\n ; SSE2-NEXT:    pand %xmm9, %xmm3\n-; SSE2-NEXT:    psrlw $1, %xmm3\n+; SSE2-NEXT:    paddb %xmm3, %xmm3\n ; SSE2-NEXT:    por %xmm6, %xmm3\n ; SSE2-NEXT:    retq\n ;\n@@ -2504,13 +2504,13 @@ define <16 x i32> @test_bitreverse_v16i32(<16 x i32> %a) nounwind {\n ; SSE2-NEXT:    pand %xmm8, %xmm0\n ; SSE2-NEXT:    psrlw $2, %xmm0\n ; SSE2-NEXT:    por %xmm7, %xmm0\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm7 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm7 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n ; SSE2-NEXT:    movdqa %xmm0, %xmm6\n ; SSE2-NEXT:    pand %xmm7, %xmm6\n-; SSE2-NEXT:    paddb %xmm6, %xmm6\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm9 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n+; SSE2-NEXT:    psrlw $1, %xmm6\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm9 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n ; SSE2-NEXT:    pand %xmm9, %xmm0\n-; SSE2-NEXT:    psrlw $1, %xmm0\n+; SSE2-NEXT:    paddb %xmm0, %xmm0\n ; SSE2-NEXT:    por %xmm6, %xmm0\n ; SSE2-NEXT:    movdqa %xmm1, %xmm6\n ; SSE2-NEXT:    punpckhbw {{.*#+}} xmm6 = xmm6[8],xmm10[8],xmm6[9],xmm10[9],xmm6[10],xmm10[10],xmm6[11],xmm10[11],xmm6[12],xmm10[12],xmm6[13],xmm10[13],xmm6[14],xmm10[14],xmm6[15],xmm10[15]\n@@ -2535,9 +2535,9 @@ define <16 x i32> @test_bitreverse_v16i32(<16 x i32> %a) nounwind {\n ; SSE2-NEXT:    por %xmm4, %xmm1\n ; SSE2-NEXT:    movdqa %xmm1, %xmm4\n ; SSE2-NEXT:    pand %xmm7, %xmm4\n-; SSE2-NEXT:    paddb %xmm4, %xmm4\n+; SSE2-NEXT:    psrlw $1, %xmm4\n ; SSE2-NEXT:    pand %xmm9, %xmm1\n-; SSE2-NEXT:    psrlw $1, %xmm1\n+; SSE2-NEXT:    paddb %xmm1, %xmm1\n ; SSE2-NEXT:    por %xmm4, %xmm1\n ; SSE2-NEXT:    movdqa %xmm2, %xmm4\n ; SSE2-NEXT:    punpckhbw {{.*#+}} xmm4 = xmm4[8],xmm10[8],xmm4[9],xmm10[9],xmm4[10],xmm10[10],xmm4[11],xmm10[11],xmm4[12],xmm10[12],xmm4[13],xmm10[13],xmm4[14],xmm10[14],xmm4[15],xmm10[15]\n@@ -2562,9 +2562,9 @@ define <16 x i32> @test_bitreverse_v16i32(<16 x i32> %a) nounwind {\n ; SSE2-NEXT:    por %xmm4, %xmm2\n ; SSE2-NEXT:    movdqa %xmm2, %xmm4\n ; SSE2-NEXT:    pand %xmm7, %xmm4\n-; SSE2-NEXT:    paddb %xmm4, %xmm4\n+; SSE2-NEXT:    psrlw $1, %xmm4\n ; SSE2-NEXT:    pand %xmm9, %xmm2\n-; SSE2-NEXT:    psrlw $1, %xmm2\n+; SSE2-NEXT:    paddb %xmm2, %xmm2\n ; SSE2-NEXT:    por %xmm4, %xmm2\n ; SSE2-NEXT:    movdqa %xmm11, %xmm4\n ; SSE2-NEXT:    punpckhbw {{.*#+}} xmm4 = xmm4[8],xmm10[8],xmm4[9],xmm10[9],xmm4[10],xmm10[10],xmm4[11],xmm10[11],xmm4[12],xmm10[12],xmm4[13],xmm10[13],xmm4[14],xmm10[14],xmm4[15],xmm10[15]\n@@ -2586,9 +2586,9 @@ define <16 x i32> @test_bitreverse_v16i32(<16 x i32> %a) nounwind {\n ; SSE2-NEXT:    psrlw $2, %xmm3\n ; SSE2-NEXT:    por %xmm5, %xmm3\n ; SSE2-NEXT:    pand %xmm3, %xmm7\n-; SSE2-NEXT:    paddb %xmm7, %xmm7\n+; SSE2-NEXT:    psrlw $1, %xmm7\n ; SSE2-NEXT:    pand %xmm9, %xmm3\n-; SSE2-NEXT:    psrlw $1, %xmm3\n+; SSE2-NEXT:    paddb %xmm3, %xmm3\n ; SSE2-NEXT:    por %xmm7, %xmm3\n ; SSE2-NEXT:    retq\n ;\n@@ -2862,13 +2862,13 @@ define <8 x i64> @test_bitreverse_v8i64(<8 x i64> %a) nounwind {\n ; SSE2-NEXT:    pand %xmm8, %xmm0\n ; SSE2-NEXT:    psrlw $2, %xmm0\n ; SSE2-NEXT:    por %xmm7, %xmm0\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm7 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm7 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n ; SSE2-NEXT:    movdqa %xmm0, %xmm6\n ; SSE2-NEXT:    pand %xmm7, %xmm6\n-; SSE2-NEXT:    paddb %xmm6, %xmm6\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm9 = [170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170]\n+; SSE2-NEXT:    psrlw $1, %xmm6\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm9 = [85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85]\n ; SSE2-NEXT:    pand %xmm9, %xmm0\n-; SSE2-NEXT:    psrlw $1, %xmm0\n+; SSE2-NEXT:    paddb %xmm0, %xmm0\n ; SSE2-NEXT:    por %xmm6, %xmm0\n ; SSE2-NEXT:    movdqa %xmm1, %xmm6\n ; SSE2-NEXT:    punpckhbw {{.*#+}} xmm6 = xmm6[8],xmm10[8],xmm6[9],xmm10[9],xmm6[10],xmm10[10],xmm6[11],xmm10[11],xmm6[12],xmm10[12],xmm6[13],xmm10[13],xmm6[14],xmm10[14],xmm6[15],xmm10[15]\n@@ -2895,9 +2895,9 @@ define <8 x i64> @test_bitreverse_v8i64(<8 x i64> %a) nounwind {\n ; SSE2-NEXT:    por %xmm4, %xmm1\n ; SSE2-NEXT:    movdqa %xmm1, %xmm4\n ; SSE2-NEXT:    pand %xmm7, %xmm4\n-; SSE2-NEXT:    paddb %xmm4, %xmm4\n+; SSE2-NEXT:    psrlw $1, %xmm4\n ; SSE2-NEXT:    pand %xmm9, %xmm1\n-; SSE2-NEXT:    psrlw $1, %xmm1\n+; SSE2-NEXT:    paddb %xmm1, %xmm1\n ; SSE2-NEXT:    por %xmm4, %xmm1\n ; SSE2-NEXT:    movdqa %xmm2, %xmm4\n ; SSE2-NEXT:    punpckhbw {{.*#+}} xmm4 = xmm4[8],xmm10[8],xmm4[9],xmm10[9],xmm4[10],xmm10[10],xmm4[11],xmm10[11],xmm4[12],xmm10[12],xmm4[13],xmm10[13],xmm4[14],xmm10[14],xmm4[15],xmm10[15]\n@@ -2924,9 +2924,9 @@ define <8 x i64> @test_bitreverse_v8i64(<8 x i64> %a) nounwind {\n ; SSE2-NEXT:    por %xmm4, %xmm2\n ; SSE2-NEXT:    movdqa %xmm2, %xmm4\n ; SSE2-NEXT:    pand %xmm7, %xmm4\n-; SSE2-NEXT:    paddb %xmm4, %xmm4\n+; SSE2-NEXT:    psrlw $1, %xmm4\n ; SSE2-NEXT:    pand %xmm9, %xmm2\n-; SSE2-NEXT:    psrlw $1, %xmm2\n+; SSE2-NEXT:    paddb %xmm2, %xmm2\n ; SSE2-NEXT:    por %xmm4, %xmm2\n ; SSE2-NEXT:    movdqa %xmm11, %xmm4\n ; SSE2-NEXT:    punpckhbw {{.*#+}} xmm4 = xmm4[8],xmm10[8],xmm4[9],xmm10[9],xmm4[10],xmm10[10],xmm4[11],xmm10[11],xmm4[12],xmm10[12],xmm4[13],xmm10[13],xmm4[14],xmm10[14],xmm4[15],xmm10[15]\n@@ -2950,9 +2950,9 @@ define <8 x i64> @test_bitreverse_v8i64(<8 x i64> %a) nounwind {\n ; SSE2-NEXT:    psrlw $2, %xmm3\n ; SSE2-NEXT:    por %xmm5, %xmm3\n ; SSE2-NEXT:    pand %xmm3, %xmm7\n-; SSE2-NEXT:    paddb %xmm7, %xmm7\n+; SSE2-NEXT:    psrlw $1, %xmm7\n ; SSE2-NEXT:    pand %xmm9, %xmm3\n-; SSE2-NEXT:    psrlw $1, %xmm3\n+; SSE2-NEXT:    paddb %xmm3, %xmm3\n ; SSE2-NEXT:    por %xmm7, %xmm3\n ; SSE2-NEXT:    retq\n ;"
            },
            {
                "fn": "llvm/test/CodeGen/X86/vector-fshl-rot-128.ll",
                "patch": "@@ -517,10 +517,10 @@ define <16 x i8> @var_funnnel_v16i8(<16 x i8> %x, <16 x i8> %amt) nounwind {\n ; SSE2-NEXT:    pandn %xmm3, %xmm2\n ; SSE2-NEXT:    por %xmm4, %xmm2\n ; SSE2-NEXT:    movdqa %xmm2, %xmm3\n-; SSE2-NEXT:    paddb %xmm2, %xmm3\n+; SSE2-NEXT:    psrlw $7, %xmm3\n+; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm3\n ; SSE2-NEXT:    movdqa %xmm2, %xmm4\n-; SSE2-NEXT:    psrlw $7, %xmm4\n-; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm4\n+; SSE2-NEXT:    paddb %xmm2, %xmm4\n ; SSE2-NEXT:    por %xmm3, %xmm4\n ; SSE2-NEXT:    paddb %xmm1, %xmm1\n ; SSE2-NEXT:    pcmpgtb %xmm1, %xmm0\n@@ -553,10 +553,10 @@ define <16 x i8> @var_funnnel_v16i8(<16 x i8> %x, <16 x i8> %amt) nounwind {\n ; SSE41-NEXT:    movdqa %xmm2, %xmm0\n ; SSE41-NEXT:    pblendvb %xmm0, %xmm3, %xmm1\n ; SSE41-NEXT:    movdqa %xmm1, %xmm0\n-; SSE41-NEXT:    paddb %xmm1, %xmm0\n+; SSE41-NEXT:    psrlw $7, %xmm0\n+; SSE41-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n ; SSE41-NEXT:    movdqa %xmm1, %xmm3\n-; SSE41-NEXT:    psrlw $7, %xmm3\n-; SSE41-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm3\n+; SSE41-NEXT:    paddb %xmm1, %xmm3\n ; SSE41-NEXT:    por %xmm0, %xmm3\n ; SSE41-NEXT:    paddb %xmm2, %xmm2\n ; SSE41-NEXT:    movdqa %xmm2, %xmm0\n@@ -580,10 +580,10 @@ define <16 x i8> @var_funnnel_v16i8(<16 x i8> %x, <16 x i8> %amt) nounwind {\n ; AVX-NEXT:    vpor %xmm2, %xmm3, %xmm2\n ; AVX-NEXT:    vpaddb %xmm1, %xmm1, %xmm1\n ; AVX-NEXT:    vpblendvb %xmm1, %xmm2, %xmm0, %xmm0\n-; AVX-NEXT:    vpaddb %xmm0, %xmm0, %xmm2\n-; AVX-NEXT:    vpsrlw $7, %xmm0, %xmm3\n-; AVX-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm3, %xmm3\n-; AVX-NEXT:    vpor %xmm3, %xmm2, %xmm2\n+; AVX-NEXT:    vpsrlw $7, %xmm0, %xmm2\n+; AVX-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm2, %xmm2\n+; AVX-NEXT:    vpaddb %xmm0, %xmm0, %xmm3\n+; AVX-NEXT:    vpor %xmm2, %xmm3, %xmm2\n ; AVX-NEXT:    vpaddb %xmm1, %xmm1, %xmm1\n ; AVX-NEXT:    vpblendvb %xmm1, %xmm2, %xmm0, %xmm0\n ; AVX-NEXT:    retq\n@@ -728,10 +728,10 @@ define <16 x i8> @var_funnnel_v16i8(<16 x i8> %x, <16 x i8> %amt) nounwind {\n ; X86-SSE2-NEXT:    pandn %xmm3, %xmm2\n ; X86-SSE2-NEXT:    por %xmm4, %xmm2\n ; X86-SSE2-NEXT:    movdqa %xmm2, %xmm3\n-; X86-SSE2-NEXT:    paddb %xmm2, %xmm3\n+; X86-SSE2-NEXT:    psrlw $7, %xmm3\n+; X86-SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm3\n ; X86-SSE2-NEXT:    movdqa %xmm2, %xmm4\n-; X86-SSE2-NEXT:    psrlw $7, %xmm4\n-; X86-SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm4\n+; X86-SSE2-NEXT:    paddb %xmm2, %xmm4\n ; X86-SSE2-NEXT:    por %xmm3, %xmm4\n ; X86-SSE2-NEXT:    paddb %xmm1, %xmm1\n ; X86-SSE2-NEXT:    pcmpgtb %xmm1, %xmm0"
            },
            {
                "fn": "llvm/test/CodeGen/X86/vector-fshl-rot-256.ll",
                "patch": "@@ -443,10 +443,10 @@ define <32 x i8> @var_funnnel_v32i8(<32 x i8> %x, <32 x i8> %amt) nounwind {\n ; AVX2-NEXT:    vpor %ymm2, %ymm3, %ymm2\n ; AVX2-NEXT:    vpaddb %ymm1, %ymm1, %ymm1\n ; AVX2-NEXT:    vpblendvb %ymm1, %ymm2, %ymm0, %ymm0\n-; AVX2-NEXT:    vpaddb %ymm0, %ymm0, %ymm2\n-; AVX2-NEXT:    vpsrlw $7, %ymm0, %ymm3\n-; AVX2-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm3, %ymm3\n-; AVX2-NEXT:    vpor %ymm3, %ymm2, %ymm2\n+; AVX2-NEXT:    vpsrlw $7, %ymm0, %ymm2\n+; AVX2-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm2, %ymm2\n+; AVX2-NEXT:    vpaddb %ymm0, %ymm0, %ymm3\n+; AVX2-NEXT:    vpor %ymm2, %ymm3, %ymm2\n ; AVX2-NEXT:    vpaddb %ymm1, %ymm1, %ymm1\n ; AVX2-NEXT:    vpblendvb %ymm1, %ymm2, %ymm0, %ymm0\n ; AVX2-NEXT:    retq\n@@ -467,10 +467,10 @@ define <32 x i8> @var_funnnel_v32i8(<32 x i8> %x, <32 x i8> %amt) nounwind {\n ; AVX512F-NEXT:    vpor %ymm2, %ymm3, %ymm2\n ; AVX512F-NEXT:    vpaddb %ymm1, %ymm1, %ymm1\n ; AVX512F-NEXT:    vpblendvb %ymm1, %ymm2, %ymm0, %ymm0\n-; AVX512F-NEXT:    vpaddb %ymm0, %ymm0, %ymm2\n-; AVX512F-NEXT:    vpsrlw $7, %ymm0, %ymm3\n-; AVX512F-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm3, %ymm3\n-; AVX512F-NEXT:    vpor %ymm3, %ymm2, %ymm2\n+; AVX512F-NEXT:    vpsrlw $7, %ymm0, %ymm2\n+; AVX512F-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm2, %ymm2\n+; AVX512F-NEXT:    vpaddb %ymm0, %ymm0, %ymm3\n+; AVX512F-NEXT:    vpor %ymm2, %ymm3, %ymm2\n ; AVX512F-NEXT:    vpaddb %ymm1, %ymm1, %ymm1\n ; AVX512F-NEXT:    vpblendvb %ymm1, %ymm2, %ymm0, %ymm0\n ; AVX512F-NEXT:    retq"
            },
            {
                "fn": "llvm/test/CodeGen/X86/vector-fshl-rot-512.ll",
                "patch": "@@ -272,154 +272,154 @@ define <64 x i8> @var_funnnel_v64i8(<64 x i8> %x, <64 x i8> %amt) nounwind {\n ;\n ; AVX512BW-LABEL: var_funnnel_v64i8:\n ; AVX512BW:       # %bb.0:\n-; AVX512BW-NEXT:    vpxor %xmm2, %xmm2, %xmm2\n-; AVX512BW-NEXT:    vpsubb %zmm1, %zmm2, %zmm2\n-; AVX512BW-NEXT:    vmovdqa64 {{.*#+}} zmm3 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n-; AVX512BW-NEXT:    vpandq %zmm3, %zmm2, %zmm2\n-; AVX512BW-NEXT:    vpsllw $5, %zmm2, %zmm2\n-; AVX512BW-NEXT:    vpaddb %zmm2, %zmm2, %zmm4\n+; AVX512BW-NEXT:    vmovdqa64 {{.*#+}} zmm2 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n+; AVX512BW-NEXT:    vpandq %zmm2, %zmm1, %zmm3\n+; AVX512BW-NEXT:    vpsllw $5, %zmm3, %zmm3\n+; AVX512BW-NEXT:    vpaddb %zmm3, %zmm3, %zmm4\n ; AVX512BW-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512BW-NEXT:    vpmovb2m %zmm2, %k2\n-; AVX512BW-NEXT:    vpsrlw $4, %zmm0, %zmm2\n-; AVX512BW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm2, %zmm2\n-; AVX512BW-NEXT:    vpblendmb %zmm2, %zmm0, %zmm2 {%k2}\n-; AVX512BW-NEXT:    vpsrlw $2, %zmm2, %zmm5\n-; AVX512BW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n-; AVX512BW-NEXT:    vmovdqu8 %zmm5, %zmm2 {%k1}\n-; AVX512BW-NEXT:    vpsrlw $1, %zmm2, %zmm5\n+; AVX512BW-NEXT:    vpmovb2m %zmm3, %k2\n+; AVX512BW-NEXT:    vpsllw $4, %zmm0, %zmm3\n+; AVX512BW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm3, %zmm3\n+; AVX512BW-NEXT:    vpblendmb %zmm3, %zmm0, %zmm3 {%k2}\n+; AVX512BW-NEXT:    vpsllw $2, %zmm3, %zmm5\n ; AVX512BW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n+; AVX512BW-NEXT:    vmovdqu8 %zmm5, %zmm3 {%k1}\n ; AVX512BW-NEXT:    vpaddb %zmm4, %zmm4, %zmm4\n ; AVX512BW-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512BW-NEXT:    vmovdqu8 %zmm5, %zmm2 {%k1}\n-; AVX512BW-NEXT:    vpandq %zmm3, %zmm1, %zmm1\n+; AVX512BW-NEXT:    vpaddb %zmm3, %zmm3, %zmm3 {%k1}\n+; AVX512BW-NEXT:    vpxor %xmm4, %xmm4, %xmm4\n+; AVX512BW-NEXT:    vpsubb %zmm1, %zmm4, %zmm1\n+; AVX512BW-NEXT:    vpandq %zmm2, %zmm1, %zmm1\n ; AVX512BW-NEXT:    vpsllw $5, %zmm1, %zmm1\n-; AVX512BW-NEXT:    vpaddb %zmm1, %zmm1, %zmm3\n-; AVX512BW-NEXT:    vpmovb2m %zmm3, %k1\n+; AVX512BW-NEXT:    vpaddb %zmm1, %zmm1, %zmm2\n+; AVX512BW-NEXT:    vpmovb2m %zmm2, %k1\n ; AVX512BW-NEXT:    vpmovb2m %zmm1, %k2\n-; AVX512BW-NEXT:    vpsllw $4, %zmm0, %zmm1\n+; AVX512BW-NEXT:    vpsrlw $4, %zmm0, %zmm1\n ; AVX512BW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512BW-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k2}\n-; AVX512BW-NEXT:    vpsllw $2, %zmm0, %zmm1\n+; AVX512BW-NEXT:    vpsrlw $2, %zmm0, %zmm1\n ; AVX512BW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512BW-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n-; AVX512BW-NEXT:    vpaddb %zmm3, %zmm3, %zmm1\n-; AVX512BW-NEXT:    vpmovb2m %zmm1, %k1\n-; AVX512BW-NEXT:    vpaddb %zmm0, %zmm0, %zmm0 {%k1}\n-; AVX512BW-NEXT:    vporq %zmm2, %zmm0, %zmm0\n+; AVX512BW-NEXT:    vpsrlw $1, %zmm0, %zmm1\n+; AVX512BW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n+; AVX512BW-NEXT:    vpaddb %zmm2, %zmm2, %zmm2\n+; AVX512BW-NEXT:    vpmovb2m %zmm2, %k1\n+; AVX512BW-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n+; AVX512BW-NEXT:    vporq %zmm0, %zmm3, %zmm0\n ; AVX512BW-NEXT:    retq\n ;\n ; AVX512VLBW-LABEL: var_funnnel_v64i8:\n ; AVX512VLBW:       # %bb.0:\n-; AVX512VLBW-NEXT:    vpxor %xmm2, %xmm2, %xmm2\n-; AVX512VLBW-NEXT:    vpsubb %zmm1, %zmm2, %zmm2\n-; AVX512VLBW-NEXT:    vmovdqa64 {{.*#+}} zmm3 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n-; AVX512VLBW-NEXT:    vpandq %zmm3, %zmm2, %zmm2\n-; AVX512VLBW-NEXT:    vpsllw $5, %zmm2, %zmm2\n-; AVX512VLBW-NEXT:    vpaddb %zmm2, %zmm2, %zmm4\n+; AVX512VLBW-NEXT:    vmovdqa64 {{.*#+}} zmm2 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n+; AVX512VLBW-NEXT:    vpandq %zmm2, %zmm1, %zmm3\n+; AVX512VLBW-NEXT:    vpsllw $5, %zmm3, %zmm3\n+; AVX512VLBW-NEXT:    vpaddb %zmm3, %zmm3, %zmm4\n ; AVX512VLBW-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512VLBW-NEXT:    vpmovb2m %zmm2, %k2\n-; AVX512VLBW-NEXT:    vpsrlw $4, %zmm0, %zmm2\n-; AVX512VLBW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm2, %zmm2\n-; AVX512VLBW-NEXT:    vpblendmb %zmm2, %zmm0, %zmm2 {%k2}\n-; AVX512VLBW-NEXT:    vpsrlw $2, %zmm2, %zmm5\n-; AVX512VLBW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n-; AVX512VLBW-NEXT:    vmovdqu8 %zmm5, %zmm2 {%k1}\n-; AVX512VLBW-NEXT:    vpsrlw $1, %zmm2, %zmm5\n+; AVX512VLBW-NEXT:    vpmovb2m %zmm3, %k2\n+; AVX512VLBW-NEXT:    vpsllw $4, %zmm0, %zmm3\n+; AVX512VLBW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm3, %zmm3\n+; AVX512VLBW-NEXT:    vpblendmb %zmm3, %zmm0, %zmm3 {%k2}\n+; AVX512VLBW-NEXT:    vpsllw $2, %zmm3, %zmm5\n ; AVX512VLBW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n+; AVX512VLBW-NEXT:    vmovdqu8 %zmm5, %zmm3 {%k1}\n ; AVX512VLBW-NEXT:    vpaddb %zmm4, %zmm4, %zmm4\n ; AVX512VLBW-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512VLBW-NEXT:    vmovdqu8 %zmm5, %zmm2 {%k1}\n-; AVX512VLBW-NEXT:    vpandq %zmm3, %zmm1, %zmm1\n+; AVX512VLBW-NEXT:    vpaddb %zmm3, %zmm3, %zmm3 {%k1}\n+; AVX512VLBW-NEXT:    vpxor %xmm4, %xmm4, %xmm4\n+; AVX512VLBW-NEXT:    vpsubb %zmm1, %zmm4, %zmm1\n+; AVX512VLBW-NEXT:    vpandq %zmm2, %zmm1, %zmm1\n ; AVX512VLBW-NEXT:    vpsllw $5, %zmm1, %zmm1\n-; AVX512VLBW-NEXT:    vpaddb %zmm1, %zmm1, %zmm3\n-; AVX512VLBW-NEXT:    vpmovb2m %zmm3, %k1\n+; AVX512VLBW-NEXT:    vpaddb %zmm1, %zmm1, %zmm2\n+; AVX512VLBW-NEXT:    vpmovb2m %zmm2, %k1\n ; AVX512VLBW-NEXT:    vpmovb2m %zmm1, %k2\n-; AVX512VLBW-NEXT:    vpsllw $4, %zmm0, %zmm1\n+; AVX512VLBW-NEXT:    vpsrlw $4, %zmm0, %zmm1\n ; AVX512VLBW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512VLBW-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k2}\n-; AVX512VLBW-NEXT:    vpsllw $2, %zmm0, %zmm1\n+; AVX512VLBW-NEXT:    vpsrlw $2, %zmm0, %zmm1\n ; AVX512VLBW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512VLBW-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n-; AVX512VLBW-NEXT:    vpaddb %zmm3, %zmm3, %zmm1\n-; AVX512VLBW-NEXT:    vpmovb2m %zmm1, %k1\n-; AVX512VLBW-NEXT:    vpaddb %zmm0, %zmm0, %zmm0 {%k1}\n-; AVX512VLBW-NEXT:    vporq %zmm2, %zmm0, %zmm0\n+; AVX512VLBW-NEXT:    vpsrlw $1, %zmm0, %zmm1\n+; AVX512VLBW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n+; AVX512VLBW-NEXT:    vpaddb %zmm2, %zmm2, %zmm2\n+; AVX512VLBW-NEXT:    vpmovb2m %zmm2, %k1\n+; AVX512VLBW-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n+; AVX512VLBW-NEXT:    vporq %zmm0, %zmm3, %zmm0\n ; AVX512VLBW-NEXT:    retq\n ;\n ; AVX512VBMI2-LABEL: var_funnnel_v64i8:\n ; AVX512VBMI2:       # %bb.0:\n-; AVX512VBMI2-NEXT:    vpxor %xmm2, %xmm2, %xmm2\n-; AVX512VBMI2-NEXT:    vpsubb %zmm1, %zmm2, %zmm2\n-; AVX512VBMI2-NEXT:    vmovdqa64 {{.*#+}} zmm3 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n-; AVX512VBMI2-NEXT:    vpandq %zmm3, %zmm2, %zmm2\n-; AVX512VBMI2-NEXT:    vpsllw $5, %zmm2, %zmm2\n-; AVX512VBMI2-NEXT:    vpaddb %zmm2, %zmm2, %zmm4\n+; AVX512VBMI2-NEXT:    vmovdqa64 {{.*#+}} zmm2 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n+; AVX512VBMI2-NEXT:    vpandq %zmm2, %zmm1, %zmm3\n+; AVX512VBMI2-NEXT:    vpsllw $5, %zmm3, %zmm3\n+; AVX512VBMI2-NEXT:    vpaddb %zmm3, %zmm3, %zmm4\n ; AVX512VBMI2-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512VBMI2-NEXT:    vpmovb2m %zmm2, %k2\n-; AVX512VBMI2-NEXT:    vpsrlw $4, %zmm0, %zmm2\n-; AVX512VBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm2, %zmm2\n-; AVX512VBMI2-NEXT:    vpblendmb %zmm2, %zmm0, %zmm2 {%k2}\n-; AVX512VBMI2-NEXT:    vpsrlw $2, %zmm2, %zmm5\n-; AVX512VBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n-; AVX512VBMI2-NEXT:    vmovdqu8 %zmm5, %zmm2 {%k1}\n-; AVX512VBMI2-NEXT:    vpsrlw $1, %zmm2, %zmm5\n+; AVX512VBMI2-NEXT:    vpmovb2m %zmm3, %k2\n+; AVX512VBMI2-NEXT:    vpsllw $4, %zmm0, %zmm3\n+; AVX512VBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm3, %zmm3\n+; AVX512VBMI2-NEXT:    vpblendmb %zmm3, %zmm0, %zmm3 {%k2}\n+; AVX512VBMI2-NEXT:    vpsllw $2, %zmm3, %zmm5\n ; AVX512VBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n+; AVX512VBMI2-NEXT:    vmovdqu8 %zmm5, %zmm3 {%k1}\n ; AVX512VBMI2-NEXT:    vpaddb %zmm4, %zmm4, %zmm4\n ; AVX512VBMI2-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512VBMI2-NEXT:    vmovdqu8 %zmm5, %zmm2 {%k1}\n-; AVX512VBMI2-NEXT:    vpandq %zmm3, %zmm1, %zmm1\n+; AVX512VBMI2-NEXT:    vpaddb %zmm3, %zmm3, %zmm3 {%k1}\n+; AVX512VBMI2-NEXT:    vpxor %xmm4, %xmm4, %xmm4\n+; AVX512VBMI2-NEXT:    vpsubb %zmm1, %zmm4, %zmm1\n+; AVX512VBMI2-NEXT:    vpandq %zmm2, %zmm1, %zmm1\n ; AVX512VBMI2-NEXT:    vpsllw $5, %zmm1, %zmm1\n-; AVX512VBMI2-NEXT:    vpaddb %zmm1, %zmm1, %zmm3\n-; AVX512VBMI2-NEXT:    vpmovb2m %zmm3, %k1\n+; AVX512VBMI2-NEXT:    vpaddb %zmm1, %zmm1, %zmm2\n+; AVX512VBMI2-NEXT:    vpmovb2m %zmm2, %k1\n ; AVX512VBMI2-NEXT:    vpmovb2m %zmm1, %k2\n-; AVX512VBMI2-NEXT:    vpsllw $4, %zmm0, %zmm1\n+; AVX512VBMI2-NEXT:    vpsrlw $4, %zmm0, %zmm1\n ; AVX512VBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512VBMI2-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k2}\n-; AVX512VBMI2-NEXT:    vpsllw $2, %zmm0, %zmm1\n+; AVX512VBMI2-NEXT:    vpsrlw $2, %zmm0, %zmm1\n ; AVX512VBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512VBMI2-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n-; AVX512VBMI2-NEXT:    vpaddb %zmm3, %zmm3, %zmm1\n-; AVX512VBMI2-NEXT:    vpmovb2m %zmm1, %k1\n-; AVX512VBMI2-NEXT:    vpaddb %zmm0, %zmm0, %zmm0 {%k1}\n-; AVX512VBMI2-NEXT:    vporq %zmm2, %zmm0, %zmm0\n+; AVX512VBMI2-NEXT:    vpsrlw $1, %zmm0, %zmm1\n+; AVX512VBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n+; AVX512VBMI2-NEXT:    vpaddb %zmm2, %zmm2, %zmm2\n+; AVX512VBMI2-NEXT:    vpmovb2m %zmm2, %k1\n+; AVX512VBMI2-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n+; AVX512VBMI2-NEXT:    vporq %zmm0, %zmm3, %zmm0\n ; AVX512VBMI2-NEXT:    retq\n ;\n ; AVX512VLVBMI2-LABEL: var_funnnel_v64i8:\n ; AVX512VLVBMI2:       # %bb.0:\n-; AVX512VLVBMI2-NEXT:    vpxor %xmm2, %xmm2, %xmm2\n-; AVX512VLVBMI2-NEXT:    vpsubb %zmm1, %zmm2, %zmm2\n-; AVX512VLVBMI2-NEXT:    vmovdqa64 {{.*#+}} zmm3 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n-; AVX512VLVBMI2-NEXT:    vpandq %zmm3, %zmm2, %zmm2\n-; AVX512VLVBMI2-NEXT:    vpsllw $5, %zmm2, %zmm2\n-; AVX512VLVBMI2-NEXT:    vpaddb %zmm2, %zmm2, %zmm4\n+; AVX512VLVBMI2-NEXT:    vmovdqa64 {{.*#+}} zmm2 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n+; AVX512VLVBMI2-NEXT:    vpandq %zmm2, %zmm1, %zmm3\n+; AVX512VLVBMI2-NEXT:    vpsllw $5, %zmm3, %zmm3\n+; AVX512VLVBMI2-NEXT:    vpaddb %zmm3, %zmm3, %zmm4\n ; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm2, %k2\n-; AVX512VLVBMI2-NEXT:    vpsrlw $4, %zmm0, %zmm2\n-; AVX512VLVBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm2, %zmm2\n-; AVX512VLVBMI2-NEXT:    vpblendmb %zmm2, %zmm0, %zmm2 {%k2}\n-; AVX512VLVBMI2-NEXT:    vpsrlw $2, %zmm2, %zmm5\n-; AVX512VLVBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n-; AVX512VLVBMI2-NEXT:    vmovdqu8 %zmm5, %zmm2 {%k1}\n-; AVX512VLVBMI2-NEXT:    vpsrlw $1, %zmm2, %zmm5\n+; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm3, %k2\n+; AVX512VLVBMI2-NEXT:    vpsllw $4, %zmm0, %zmm3\n+; AVX512VLVBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm3, %zmm3\n+; AVX512VLVBMI2-NEXT:    vpblendmb %zmm3, %zmm0, %zmm3 {%k2}\n+; AVX512VLVBMI2-NEXT:    vpsllw $2, %zmm3, %zmm5\n ; AVX512VLVBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n+; AVX512VLVBMI2-NEXT:    vmovdqu8 %zmm5, %zmm3 {%k1}\n ; AVX512VLVBMI2-NEXT:    vpaddb %zmm4, %zmm4, %zmm4\n ; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512VLVBMI2-NEXT:    vmovdqu8 %zmm5, %zmm2 {%k1}\n-; AVX512VLVBMI2-NEXT:    vpandq %zmm3, %zmm1, %zmm1\n+; AVX512VLVBMI2-NEXT:    vpaddb %zmm3, %zmm3, %zmm3 {%k1}\n+; AVX512VLVBMI2-NEXT:    vpxor %xmm4, %xmm4, %xmm4\n+; AVX512VLVBMI2-NEXT:    vpsubb %zmm1, %zmm4, %zmm1\n+; AVX512VLVBMI2-NEXT:    vpandq %zmm2, %zmm1, %zmm1\n ; AVX512VLVBMI2-NEXT:    vpsllw $5, %zmm1, %zmm1\n-; AVX512VLVBMI2-NEXT:    vpaddb %zmm1, %zmm1, %zmm3\n-; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm3, %k1\n+; AVX512VLVBMI2-NEXT:    vpaddb %zmm1, %zmm1, %zmm2\n+; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm2, %k1\n ; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm1, %k2\n-; AVX512VLVBMI2-NEXT:    vpsllw $4, %zmm0, %zmm1\n+; AVX512VLVBMI2-NEXT:    vpsrlw $4, %zmm0, %zmm1\n ; AVX512VLVBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512VLVBMI2-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k2}\n-; AVX512VLVBMI2-NEXT:    vpsllw $2, %zmm0, %zmm1\n+; AVX512VLVBMI2-NEXT:    vpsrlw $2, %zmm0, %zmm1\n ; AVX512VLVBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512VLVBMI2-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n-; AVX512VLVBMI2-NEXT:    vpaddb %zmm3, %zmm3, %zmm1\n-; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm1, %k1\n-; AVX512VLVBMI2-NEXT:    vpaddb %zmm0, %zmm0, %zmm0 {%k1}\n-; AVX512VLVBMI2-NEXT:    vporq %zmm2, %zmm0, %zmm0\n+; AVX512VLVBMI2-NEXT:    vpsrlw $1, %zmm0, %zmm1\n+; AVX512VLVBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n+; AVX512VLVBMI2-NEXT:    vpaddb %zmm2, %zmm2, %zmm2\n+; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm2, %k1\n+; AVX512VLVBMI2-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n+; AVX512VLVBMI2-NEXT:    vporq %zmm0, %zmm3, %zmm0\n ; AVX512VLVBMI2-NEXT:    retq\n   %res = call <64 x i8> @llvm.fshl.v64i8(<64 x i8> %x, <64 x i8> %x, <64 x i8> %amt)\n   ret <64 x i8> %res"
            },
            {
                "fn": "llvm/test/CodeGen/X86/vector-fshr-128.ll",
                "patch": "@@ -732,65 +732,65 @@ define <8 x i16> @var_funnnel_v8i16(<8 x i16> %x, <8 x i16> %y, <8 x i16> %amt)\n define <16 x i8> @var_funnnel_v16i8(<16 x i8> %x, <16 x i8> %y, <16 x i8> %amt) nounwind {\n ; SSE2-LABEL: var_funnnel_v16i8:\n ; SSE2:       # %bb.0:\n-; SSE2-NEXT:    movdqa {{.*#+}} xmm5 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n-; SSE2-NEXT:    movdqa %xmm2, %xmm4\n-; SSE2-NEXT:    pandn %xmm5, %xmm4\n-; SSE2-NEXT:    psllw $5, %xmm4\n+; SSE2-NEXT:    movdqa {{.*#+}} xmm4 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n+; SSE2-NEXT:    movdqa %xmm2, %xmm5\n+; SSE2-NEXT:    pand %xmm4, %xmm5\n+; SSE2-NEXT:    psllw $5, %xmm5\n ; SSE2-NEXT:    pxor %xmm3, %xmm3\n ; SSE2-NEXT:    pxor %xmm6, %xmm6\n-; SSE2-NEXT:    pcmpgtb %xmm4, %xmm6\n-; SSE2-NEXT:    paddb %xmm0, %xmm0\n+; SSE2-NEXT:    pcmpgtb %xmm5, %xmm6\n ; SSE2-NEXT:    movdqa %xmm6, %xmm7\n-; SSE2-NEXT:    pandn %xmm0, %xmm7\n-; SSE2-NEXT:    psllw $4, %xmm0\n-; SSE2-NEXT:    pand %xmm6, %xmm0\n-; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n-; SSE2-NEXT:    por %xmm7, %xmm0\n-; SSE2-NEXT:    paddb %xmm4, %xmm4\n+; SSE2-NEXT:    pandn %xmm1, %xmm7\n+; SSE2-NEXT:    psrlw $4, %xmm1\n+; SSE2-NEXT:    pand %xmm6, %xmm1\n+; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm1\n+; SSE2-NEXT:    por %xmm7, %xmm1\n+; SSE2-NEXT:    paddb %xmm5, %xmm5\n ; SSE2-NEXT:    pxor %xmm6, %xmm6\n-; SSE2-NEXT:    pcmpgtb %xmm4, %xmm6\n+; SSE2-NEXT:    pcmpgtb %xmm5, %xmm6\n ; SSE2-NEXT:    movdqa %xmm6, %xmm7\n-; SSE2-NEXT:    pandn %xmm0, %xmm7\n-; SSE2-NEXT:    psllw $2, %xmm0\n-; SSE2-NEXT:    pand %xmm6, %xmm0\n-; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n-; SSE2-NEXT:    por %xmm7, %xmm0\n-; SSE2-NEXT:    paddb %xmm4, %xmm4\n+; SSE2-NEXT:    pandn %xmm1, %xmm7\n+; SSE2-NEXT:    psrlw $2, %xmm1\n+; SSE2-NEXT:    pand %xmm6, %xmm1\n+; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm1\n+; SSE2-NEXT:    por %xmm7, %xmm1\n+; SSE2-NEXT:    paddb %xmm5, %xmm5\n ; SSE2-NEXT:    pxor %xmm6, %xmm6\n-; SSE2-NEXT:    pcmpgtb %xmm4, %xmm6\n-; SSE2-NEXT:    movdqa %xmm6, %xmm4\n-; SSE2-NEXT:    pandn %xmm0, %xmm4\n-; SSE2-NEXT:    paddb %xmm0, %xmm0\n-; SSE2-NEXT:    pand %xmm6, %xmm0\n-; SSE2-NEXT:    pand %xmm5, %xmm2\n-; SSE2-NEXT:    psllw $5, %xmm2\n-; SSE2-NEXT:    pxor %xmm5, %xmm5\n-; SSE2-NEXT:    pcmpgtb %xmm2, %xmm5\n-; SSE2-NEXT:    movdqa %xmm5, %xmm6\n-; SSE2-NEXT:    pandn %xmm1, %xmm6\n-; SSE2-NEXT:    psrlw $4, %xmm1\n-; SSE2-NEXT:    pand %xmm5, %xmm1\n+; SSE2-NEXT:    pcmpgtb %xmm5, %xmm6\n+; SSE2-NEXT:    movdqa %xmm6, %xmm5\n+; SSE2-NEXT:    pandn %xmm1, %xmm5\n+; SSE2-NEXT:    psrlw $1, %xmm1\n+; SSE2-NEXT:    pand %xmm6, %xmm1\n ; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm1\n-; SSE2-NEXT:    por %xmm6, %xmm1\n+; SSE2-NEXT:    por %xmm5, %xmm1\n+; SSE2-NEXT:    pandn %xmm4, %xmm2\n+; SSE2-NEXT:    psllw $5, %xmm2\n+; SSE2-NEXT:    pxor %xmm4, %xmm4\n+; SSE2-NEXT:    pcmpgtb %xmm2, %xmm4\n+; SSE2-NEXT:    paddb %xmm0, %xmm0\n+; SSE2-NEXT:    movdqa %xmm4, %xmm5\n+; SSE2-NEXT:    pandn %xmm0, %xmm5\n+; SSE2-NEXT:    psllw $4, %xmm0\n+; SSE2-NEXT:    pand %xmm4, %xmm0\n+; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n+; SSE2-NEXT:    por %xmm5, %xmm0\n ; SSE2-NEXT:    paddb %xmm2, %xmm2\n-; SSE2-NEXT:    pxor %xmm5, %xmm5\n-; SSE2-NEXT:    pcmpgtb %xmm2, %xmm5\n-; SSE2-NEXT:    movdqa %xmm5, %xmm6\n-; SSE2-NEXT:    pandn %xmm1, %xmm6\n-; SSE2-NEXT:    psrlw $2, %xmm1\n-; SSE2-NEXT:    pand %xmm5, %xmm1\n-; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm1\n-; SSE2-NEXT:    por %xmm6, %xmm1\n+; SSE2-NEXT:    pxor %xmm4, %xmm4\n+; SSE2-NEXT:    pcmpgtb %xmm2, %xmm4\n+; SSE2-NEXT:    movdqa %xmm4, %xmm5\n+; SSE2-NEXT:    pandn %xmm0, %xmm5\n+; SSE2-NEXT:    psllw $2, %xmm0\n+; SSE2-NEXT:    pand %xmm4, %xmm0\n+; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n+; SSE2-NEXT:    por %xmm5, %xmm0\n ; SSE2-NEXT:    paddb %xmm2, %xmm2\n ; SSE2-NEXT:    pcmpgtb %xmm2, %xmm3\n ; SSE2-NEXT:    movdqa %xmm3, %xmm2\n-; SSE2-NEXT:    pandn %xmm1, %xmm2\n-; SSE2-NEXT:    psrlw $1, %xmm1\n-; SSE2-NEXT:    pand %xmm3, %xmm1\n-; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm1\n-; SSE2-NEXT:    por %xmm2, %xmm1\n-; SSE2-NEXT:    por %xmm4, %xmm1\n-; SSE2-NEXT:    por %xmm1, %xmm0\n+; SSE2-NEXT:    pandn %xmm0, %xmm2\n+; SSE2-NEXT:    por %xmm1, %xmm2\n+; SSE2-NEXT:    paddb %xmm0, %xmm0\n+; SSE2-NEXT:    pand %xmm3, %xmm0\n+; SSE2-NEXT:    por %xmm2, %xmm0\n ; SSE2-NEXT:    retq\n ;\n ; SSE41-LABEL: var_funnnel_v16i8:\n@@ -981,77 +981,77 @@ define <16 x i8> @var_funnnel_v16i8(<16 x i8> %x, <16 x i8> %y, <16 x i8> %amt)\n ; XOP-LABEL: var_funnnel_v16i8:\n ; XOP:       # %bb.0:\n ; XOP-NEXT:    vmovdqa {{.*#+}} xmm3 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n-; XOP-NEXT:    vpandn %xmm3, %xmm2, %xmm4\n+; XOP-NEXT:    vpand %xmm3, %xmm2, %xmm4\n+; XOP-NEXT:    vpxor %xmm5, %xmm5, %xmm5\n+; XOP-NEXT:    vpsubb %xmm4, %xmm5, %xmm4\n+; XOP-NEXT:    vpshlb %xmm4, %xmm1, %xmm1\n+; XOP-NEXT:    vpandn %xmm3, %xmm2, %xmm2\n ; XOP-NEXT:    vpaddb %xmm0, %xmm0, %xmm0\n-; XOP-NEXT:    vpshlb %xmm4, %xmm0, %xmm0\n-; XOP-NEXT:    vpand %xmm3, %xmm2, %xmm2\n-; XOP-NEXT:    vpxor %xmm3, %xmm3, %xmm3\n-; XOP-NEXT:    vpsubb %xmm2, %xmm3, %xmm2\n-; XOP-NEXT:    vpshlb %xmm2, %xmm1, %xmm1\n+; XOP-NEXT:    vpshlb %xmm2, %xmm0, %xmm0\n ; XOP-NEXT:    vpor %xmm1, %xmm0, %xmm0\n ; XOP-NEXT:    retq\n ;\n ; X86-SSE2-LABEL: var_funnnel_v16i8:\n ; X86-SSE2:       # %bb.0:\n-; X86-SSE2-NEXT:    movdqa {{.*#+}} xmm5 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n-; X86-SSE2-NEXT:    movdqa %xmm2, %xmm4\n-; X86-SSE2-NEXT:    pandn %xmm5, %xmm4\n-; X86-SSE2-NEXT:    psllw $5, %xmm4\n+; X86-SSE2-NEXT:    movdqa {{.*#+}} xmm4 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n+; X86-SSE2-NEXT:    movdqa %xmm2, %xmm5\n+; X86-SSE2-NEXT:    pand %xmm4, %xmm5\n+; X86-SSE2-NEXT:    psllw $5, %xmm5\n ; X86-SSE2-NEXT:    pxor %xmm3, %xmm3\n ; X86-SSE2-NEXT:    pxor %xmm6, %xmm6\n-; X86-SSE2-NEXT:    pcmpgtb %xmm4, %xmm6\n-; X86-SSE2-NEXT:    paddb %xmm0, %xmm0\n+; X86-SSE2-NEXT:    pcmpgtb %xmm5, %xmm6\n ; X86-SSE2-NEXT:    movdqa %xmm6, %xmm7\n-; X86-SSE2-NEXT:    pandn %xmm0, %xmm7\n-; X86-SSE2-NEXT:    psllw $4, %xmm0\n-; X86-SSE2-NEXT:    pand %xmm6, %xmm0\n-; X86-SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm0\n-; X86-SSE2-NEXT:    por %xmm7, %xmm0\n-; X86-SSE2-NEXT:    paddb %xmm4, %xmm4\n+; X86-SSE2-NEXT:    pandn %xmm1, %xmm7\n+; X86-SSE2-NEXT:    psrlw $4, %xmm1\n+; X86-SSE2-NEXT:    pand %xmm6, %xmm1\n+; X86-SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm1\n+; X86-SSE2-NEXT:    por %xmm7, %xmm1\n+; X86-SSE2-NEXT:    paddb %xmm5, %xmm5\n ; X86-SSE2-NEXT:    pxor %xmm6, %xmm6\n-; X86-SSE2-NEXT:    pcmpgtb %xmm4, %xmm6\n+; X86-SSE2-NEXT:    pcmpgtb %xmm5, %xmm6\n ; X86-SSE2-NEXT:    movdqa %xmm6, %xmm7\n-; X86-SSE2-NEXT:    pandn %xmm0, %xmm7\n-; X86-SSE2-NEXT:    psllw $2, %xmm0\n-; X86-SSE2-NEXT:    pand %xmm6, %xmm0\n-; X86-SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm0\n-; X86-SSE2-NEXT:    por %xmm7, %xmm0\n-; X86-SSE2-NEXT:    paddb %xmm4, %xmm4\n+; X86-SSE2-NEXT:    pandn %xmm1, %xmm7\n+; X86-SSE2-NEXT:    psrlw $2, %xmm1\n+; X86-SSE2-NEXT:    pand %xmm6, %xmm1\n+; X86-SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm1\n+; X86-SSE2-NEXT:    por %xmm7, %xmm1\n+; X86-SSE2-NEXT:    paddb %xmm5, %xmm5\n ; X86-SSE2-NEXT:    pxor %xmm6, %xmm6\n-; X86-SSE2-NEXT:    pcmpgtb %xmm4, %xmm6\n-; X86-SSE2-NEXT:    movdqa %xmm6, %xmm4\n-; X86-SSE2-NEXT:    pandn %xmm0, %xmm4\n-; X86-SSE2-NEXT:    paddb %xmm0, %xmm0\n-; X86-SSE2-NEXT:    pand %xmm6, %xmm0\n-; X86-SSE2-NEXT:    pand %xmm5, %xmm2\n-; X86-SSE2-NEXT:    psllw $5, %xmm2\n-; X86-SSE2-NEXT:    pxor %xmm5, %xmm5\n-; X86-SSE2-NEXT:    pcmpgtb %xmm2, %xmm5\n-; X86-SSE2-NEXT:    movdqa %xmm5, %xmm6\n-; X86-SSE2-NEXT:    pandn %xmm1, %xmm6\n-; X86-SSE2-NEXT:    psrlw $4, %xmm1\n-; X86-SSE2-NEXT:    pand %xmm5, %xmm1\n+; X86-SSE2-NEXT:    pcmpgtb %xmm5, %xmm6\n+; X86-SSE2-NEXT:    movdqa %xmm6, %xmm5\n+; X86-SSE2-NEXT:    pandn %xmm1, %xmm5\n+; X86-SSE2-NEXT:    psrlw $1, %xmm1\n+; X86-SSE2-NEXT:    pand %xmm6, %xmm1\n ; X86-SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm1\n-; X86-SSE2-NEXT:    por %xmm6, %xmm1\n+; X86-SSE2-NEXT:    por %xmm5, %xmm1\n+; X86-SSE2-NEXT:    pandn %xmm4, %xmm2\n+; X86-SSE2-NEXT:    psllw $5, %xmm2\n+; X86-SSE2-NEXT:    pxor %xmm4, %xmm4\n+; X86-SSE2-NEXT:    pcmpgtb %xmm2, %xmm4\n+; X86-SSE2-NEXT:    paddb %xmm0, %xmm0\n+; X86-SSE2-NEXT:    movdqa %xmm4, %xmm5\n+; X86-SSE2-NEXT:    pandn %xmm0, %xmm5\n+; X86-SSE2-NEXT:    psllw $4, %xmm0\n+; X86-SSE2-NEXT:    pand %xmm4, %xmm0\n+; X86-SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm0\n+; X86-SSE2-NEXT:    por %xmm5, %xmm0\n ; X86-SSE2-NEXT:    paddb %xmm2, %xmm2\n-; X86-SSE2-NEXT:    pxor %xmm5, %xmm5\n-; X86-SSE2-NEXT:    pcmpgtb %xmm2, %xmm5\n-; X86-SSE2-NEXT:    movdqa %xmm5, %xmm6\n-; X86-SSE2-NEXT:    pandn %xmm1, %xmm6\n-; X86-SSE2-NEXT:    psrlw $2, %xmm1\n-; X86-SSE2-NEXT:    pand %xmm5, %xmm1\n-; X86-SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm1\n-; X86-SSE2-NEXT:    por %xmm6, %xmm1\n+; X86-SSE2-NEXT:    pxor %xmm4, %xmm4\n+; X86-SSE2-NEXT:    pcmpgtb %xmm2, %xmm4\n+; X86-SSE2-NEXT:    movdqa %xmm4, %xmm5\n+; X86-SSE2-NEXT:    pandn %xmm0, %xmm5\n+; X86-SSE2-NEXT:    psllw $2, %xmm0\n+; X86-SSE2-NEXT:    pand %xmm4, %xmm0\n+; X86-SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm0\n+; X86-SSE2-NEXT:    por %xmm5, %xmm0\n ; X86-SSE2-NEXT:    paddb %xmm2, %xmm2\n ; X86-SSE2-NEXT:    pcmpgtb %xmm2, %xmm3\n ; X86-SSE2-NEXT:    movdqa %xmm3, %xmm2\n-; X86-SSE2-NEXT:    pandn %xmm1, %xmm2\n-; X86-SSE2-NEXT:    psrlw $1, %xmm1\n-; X86-SSE2-NEXT:    pand %xmm3, %xmm1\n-; X86-SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm1\n-; X86-SSE2-NEXT:    por %xmm2, %xmm1\n-; X86-SSE2-NEXT:    por %xmm4, %xmm1\n-; X86-SSE2-NEXT:    por %xmm1, %xmm0\n+; X86-SSE2-NEXT:    pandn %xmm0, %xmm2\n+; X86-SSE2-NEXT:    por %xmm1, %xmm2\n+; X86-SSE2-NEXT:    paddb %xmm0, %xmm0\n+; X86-SSE2-NEXT:    pand %xmm3, %xmm0\n+; X86-SSE2-NEXT:    por %xmm2, %xmm0\n ; X86-SSE2-NEXT:    retl\n   %res = call <16 x i8> @llvm.fshr.v16i8(<16 x i8> %x, <16 x i8> %y, <16 x i8> %amt)\n   ret <16 x i8> %res"
            },
            {
                "fn": "llvm/test/CodeGen/X86/vector-fshr-256.ll",
                "patch": "@@ -758,45 +758,45 @@ define <32 x i8> @var_funnnel_v32i8(<32 x i8> %x, <32 x i8> %y, <32 x i8> %amt)\n ; XOPAVX1-LABEL: var_funnnel_v32i8:\n ; XOPAVX1:       # %bb.0:\n ; XOPAVX1-NEXT:    vmovaps {{.*#+}} ymm3 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n-; XOPAVX1-NEXT:    vandnps %ymm3, %ymm2, %ymm4\n+; XOPAVX1-NEXT:    vandps %ymm3, %ymm2, %ymm4\n ; XOPAVX1-NEXT:    vextractf128 $1, %ymm4, %xmm5\n-; XOPAVX1-NEXT:    vextractf128 $1, %ymm0, %xmm6\n-; XOPAVX1-NEXT:    vpaddb %xmm6, %xmm6, %xmm6\n-; XOPAVX1-NEXT:    vpshlb %xmm5, %xmm6, %xmm5\n-; XOPAVX1-NEXT:    vpaddb %xmm0, %xmm0, %xmm0\n-; XOPAVX1-NEXT:    vpshlb %xmm4, %xmm0, %xmm0\n-; XOPAVX1-NEXT:    vinsertf128 $1, %xmm5, %ymm0, %ymm0\n-; XOPAVX1-NEXT:    vandps %ymm3, %ymm2, %ymm2\n+; XOPAVX1-NEXT:    vpxor %xmm6, %xmm6, %xmm6\n+; XOPAVX1-NEXT:    vpsubb %xmm5, %xmm6, %xmm5\n+; XOPAVX1-NEXT:    vextractf128 $1, %ymm1, %xmm7\n+; XOPAVX1-NEXT:    vpshlb %xmm5, %xmm7, %xmm5\n+; XOPAVX1-NEXT:    vpsubb %xmm4, %xmm6, %xmm4\n+; XOPAVX1-NEXT:    vpshlb %xmm4, %xmm1, %xmm1\n+; XOPAVX1-NEXT:    vinsertf128 $1, %xmm5, %ymm1, %ymm1\n+; XOPAVX1-NEXT:    vandnps %ymm3, %ymm2, %ymm2\n ; XOPAVX1-NEXT:    vextractf128 $1, %ymm2, %xmm3\n-; XOPAVX1-NEXT:    vpxor %xmm4, %xmm4, %xmm4\n-; XOPAVX1-NEXT:    vpsubb %xmm3, %xmm4, %xmm3\n-; XOPAVX1-NEXT:    vextractf128 $1, %ymm1, %xmm5\n-; XOPAVX1-NEXT:    vpshlb %xmm3, %xmm5, %xmm3\n-; XOPAVX1-NEXT:    vpsubb %xmm2, %xmm4, %xmm2\n-; XOPAVX1-NEXT:    vpshlb %xmm2, %xmm1, %xmm1\n-; XOPAVX1-NEXT:    vinsertf128 $1, %xmm3, %ymm1, %ymm1\n+; XOPAVX1-NEXT:    vextractf128 $1, %ymm0, %xmm4\n+; XOPAVX1-NEXT:    vpaddb %xmm4, %xmm4, %xmm4\n+; XOPAVX1-NEXT:    vpshlb %xmm3, %xmm4, %xmm3\n+; XOPAVX1-NEXT:    vpaddb %xmm0, %xmm0, %xmm0\n+; XOPAVX1-NEXT:    vpshlb %xmm2, %xmm0, %xmm0\n+; XOPAVX1-NEXT:    vinsertf128 $1, %xmm3, %ymm0, %ymm0\n ; XOPAVX1-NEXT:    vorps %ymm1, %ymm0, %ymm0\n ; XOPAVX1-NEXT:    retq\n ;\n ; XOPAVX2-LABEL: var_funnnel_v32i8:\n ; XOPAVX2:       # %bb.0:\n ; XOPAVX2-NEXT:    vmovdqa {{.*#+}} ymm3 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n-; XOPAVX2-NEXT:    vpandn %ymm3, %ymm2, %ymm4\n+; XOPAVX2-NEXT:    vpand %ymm3, %ymm2, %ymm4\n ; XOPAVX2-NEXT:    vextracti128 $1, %ymm4, %xmm5\n-; XOPAVX2-NEXT:    vpaddb %ymm0, %ymm0, %ymm0\n-; XOPAVX2-NEXT:    vextracti128 $1, %ymm0, %xmm6\n-; XOPAVX2-NEXT:    vpshlb %xmm5, %xmm6, %xmm5\n-; XOPAVX2-NEXT:    vpshlb %xmm4, %xmm0, %xmm0\n-; XOPAVX2-NEXT:    vinserti128 $1, %xmm5, %ymm0, %ymm0\n-; XOPAVX2-NEXT:    vpand %ymm3, %ymm2, %ymm2\n+; XOPAVX2-NEXT:    vpxor %xmm6, %xmm6, %xmm6\n+; XOPAVX2-NEXT:    vpsubb %xmm5, %xmm6, %xmm5\n+; XOPAVX2-NEXT:    vextracti128 $1, %ymm1, %xmm7\n+; XOPAVX2-NEXT:    vpshlb %xmm5, %xmm7, %xmm5\n+; XOPAVX2-NEXT:    vpsubb %xmm4, %xmm6, %xmm4\n+; XOPAVX2-NEXT:    vpshlb %xmm4, %xmm1, %xmm1\n+; XOPAVX2-NEXT:    vinserti128 $1, %xmm5, %ymm1, %ymm1\n+; XOPAVX2-NEXT:    vpandn %ymm3, %ymm2, %ymm2\n ; XOPAVX2-NEXT:    vextracti128 $1, %ymm2, %xmm3\n-; XOPAVX2-NEXT:    vpxor %xmm4, %xmm4, %xmm4\n-; XOPAVX2-NEXT:    vpsubb %xmm3, %xmm4, %xmm3\n-; XOPAVX2-NEXT:    vextracti128 $1, %ymm1, %xmm5\n-; XOPAVX2-NEXT:    vpshlb %xmm3, %xmm5, %xmm3\n-; XOPAVX2-NEXT:    vpsubb %xmm2, %xmm4, %xmm2\n-; XOPAVX2-NEXT:    vpshlb %xmm2, %xmm1, %xmm1\n-; XOPAVX2-NEXT:    vinserti128 $1, %xmm3, %ymm1, %ymm1\n+; XOPAVX2-NEXT:    vpaddb %ymm0, %ymm0, %ymm0\n+; XOPAVX2-NEXT:    vextracti128 $1, %ymm0, %xmm4\n+; XOPAVX2-NEXT:    vpshlb %xmm3, %xmm4, %xmm3\n+; XOPAVX2-NEXT:    vpshlb %xmm2, %xmm0, %xmm0\n+; XOPAVX2-NEXT:    vinserti128 $1, %xmm3, %ymm0, %ymm0\n ; XOPAVX2-NEXT:    vpor %ymm1, %ymm0, %ymm0\n ; XOPAVX2-NEXT:    retq\n   %res = call <32 x i8> @llvm.fshr.v32i8(<32 x i8> %x, <32 x i8> %y, <32 x i8> %amt)"
            },
            {
                "fn": "llvm/test/CodeGen/X86/vector-fshr-rot-128.ll",
                "patch": "@@ -553,10 +553,10 @@ define <16 x i8> @var_funnnel_v16i8(<16 x i8> %x, <16 x i8> %amt) nounwind {\n ; SSE2-NEXT:    pandn %xmm1, %xmm2\n ; SSE2-NEXT:    por %xmm4, %xmm2\n ; SSE2-NEXT:    movdqa %xmm2, %xmm1\n-; SSE2-NEXT:    paddb %xmm2, %xmm1\n+; SSE2-NEXT:    psrlw $7, %xmm1\n+; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm1\n ; SSE2-NEXT:    movdqa %xmm2, %xmm4\n-; SSE2-NEXT:    psrlw $7, %xmm4\n-; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm4\n+; SSE2-NEXT:    paddb %xmm2, %xmm4\n ; SSE2-NEXT:    por %xmm1, %xmm4\n ; SSE2-NEXT:    paddb %xmm3, %xmm3\n ; SSE2-NEXT:    pcmpgtb %xmm3, %xmm0\n@@ -588,10 +588,10 @@ define <16 x i8> @var_funnnel_v16i8(<16 x i8> %x, <16 x i8> %amt) nounwind {\n ; SSE41-NEXT:    paddb %xmm0, %xmm0\n ; SSE41-NEXT:    pblendvb %xmm0, %xmm3, %xmm2\n ; SSE41-NEXT:    movdqa %xmm2, %xmm1\n-; SSE41-NEXT:    paddb %xmm2, %xmm1\n+; SSE41-NEXT:    psrlw $7, %xmm1\n+; SSE41-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm1\n ; SSE41-NEXT:    movdqa %xmm2, %xmm3\n-; SSE41-NEXT:    psrlw $7, %xmm3\n-; SSE41-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm3\n+; SSE41-NEXT:    paddb %xmm2, %xmm3\n ; SSE41-NEXT:    por %xmm1, %xmm3\n ; SSE41-NEXT:    paddb %xmm0, %xmm0\n ; SSE41-NEXT:    pblendvb %xmm0, %xmm3, %xmm2\n@@ -616,10 +616,10 @@ define <16 x i8> @var_funnnel_v16i8(<16 x i8> %x, <16 x i8> %amt) nounwind {\n ; AVX-NEXT:    vpor %xmm2, %xmm3, %xmm2\n ; AVX-NEXT:    vpaddb %xmm1, %xmm1, %xmm1\n ; AVX-NEXT:    vpblendvb %xmm1, %xmm2, %xmm0, %xmm0\n-; AVX-NEXT:    vpaddb %xmm0, %xmm0, %xmm2\n-; AVX-NEXT:    vpsrlw $7, %xmm0, %xmm3\n-; AVX-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm3, %xmm3\n-; AVX-NEXT:    vpor %xmm3, %xmm2, %xmm2\n+; AVX-NEXT:    vpsrlw $7, %xmm0, %xmm2\n+; AVX-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm2, %xmm2\n+; AVX-NEXT:    vpaddb %xmm0, %xmm0, %xmm3\n+; AVX-NEXT:    vpor %xmm2, %xmm3, %xmm2\n ; AVX-NEXT:    vpaddb %xmm1, %xmm1, %xmm1\n ; AVX-NEXT:    vpblendvb %xmm1, %xmm2, %xmm0, %xmm0\n ; AVX-NEXT:    retq\n@@ -768,10 +768,10 @@ define <16 x i8> @var_funnnel_v16i8(<16 x i8> %x, <16 x i8> %amt) nounwind {\n ; X86-SSE2-NEXT:    pandn %xmm1, %xmm2\n ; X86-SSE2-NEXT:    por %xmm4, %xmm2\n ; X86-SSE2-NEXT:    movdqa %xmm2, %xmm1\n-; X86-SSE2-NEXT:    paddb %xmm2, %xmm1\n+; X86-SSE2-NEXT:    psrlw $7, %xmm1\n+; X86-SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm1\n ; X86-SSE2-NEXT:    movdqa %xmm2, %xmm4\n-; X86-SSE2-NEXT:    psrlw $7, %xmm4\n-; X86-SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm4\n+; X86-SSE2-NEXT:    paddb %xmm2, %xmm4\n ; X86-SSE2-NEXT:    por %xmm1, %xmm4\n ; X86-SSE2-NEXT:    paddb %xmm3, %xmm3\n ; X86-SSE2-NEXT:    pcmpgtb %xmm3, %xmm0"
            },
            {
                "fn": "llvm/test/CodeGen/X86/vector-fshr-rot-256.ll",
                "patch": "@@ -480,10 +480,10 @@ define <32 x i8> @var_funnnel_v32i8(<32 x i8> %x, <32 x i8> %amt) nounwind {\n ; AVX2-NEXT:    vpor %ymm2, %ymm3, %ymm2\n ; AVX2-NEXT:    vpaddb %ymm1, %ymm1, %ymm1\n ; AVX2-NEXT:    vpblendvb %ymm1, %ymm2, %ymm0, %ymm0\n-; AVX2-NEXT:    vpaddb %ymm0, %ymm0, %ymm2\n-; AVX2-NEXT:    vpsrlw $7, %ymm0, %ymm3\n-; AVX2-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm3, %ymm3\n-; AVX2-NEXT:    vpor %ymm3, %ymm2, %ymm2\n+; AVX2-NEXT:    vpsrlw $7, %ymm0, %ymm2\n+; AVX2-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm2, %ymm2\n+; AVX2-NEXT:    vpaddb %ymm0, %ymm0, %ymm3\n+; AVX2-NEXT:    vpor %ymm2, %ymm3, %ymm2\n ; AVX2-NEXT:    vpaddb %ymm1, %ymm1, %ymm1\n ; AVX2-NEXT:    vpblendvb %ymm1, %ymm2, %ymm0, %ymm0\n ; AVX2-NEXT:    retq\n@@ -506,10 +506,10 @@ define <32 x i8> @var_funnnel_v32i8(<32 x i8> %x, <32 x i8> %amt) nounwind {\n ; AVX512F-NEXT:    vpor %ymm2, %ymm3, %ymm2\n ; AVX512F-NEXT:    vpaddb %ymm1, %ymm1, %ymm1\n ; AVX512F-NEXT:    vpblendvb %ymm1, %ymm2, %ymm0, %ymm0\n-; AVX512F-NEXT:    vpaddb %ymm0, %ymm0, %ymm2\n-; AVX512F-NEXT:    vpsrlw $7, %ymm0, %ymm3\n-; AVX512F-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm3, %ymm3\n-; AVX512F-NEXT:    vpor %ymm3, %ymm2, %ymm2\n+; AVX512F-NEXT:    vpsrlw $7, %ymm0, %ymm2\n+; AVX512F-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm2, %ymm2\n+; AVX512F-NEXT:    vpaddb %ymm0, %ymm0, %ymm3\n+; AVX512F-NEXT:    vpor %ymm2, %ymm3, %ymm2\n ; AVX512F-NEXT:    vpaddb %ymm1, %ymm1, %ymm1\n ; AVX512F-NEXT:    vpblendvb %ymm1, %ymm2, %ymm0, %ymm0\n ; AVX512F-NEXT:    retq"
            },
            {
                "fn": "llvm/test/CodeGen/X86/vector-fshr-rot-512.ll",
                "patch": "@@ -272,154 +272,154 @@ define <64 x i8> @var_funnnel_v64i8(<64 x i8> %x, <64 x i8> %amt) nounwind {\n ;\n ; AVX512BW-LABEL: var_funnnel_v64i8:\n ; AVX512BW:       # %bb.0:\n-; AVX512BW-NEXT:    vmovdqa64 {{.*#+}} zmm2 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n-; AVX512BW-NEXT:    vpandq %zmm2, %zmm1, %zmm3\n-; AVX512BW-NEXT:    vpsllw $5, %zmm3, %zmm3\n-; AVX512BW-NEXT:    vpaddb %zmm3, %zmm3, %zmm4\n+; AVX512BW-NEXT:    vpxor %xmm2, %xmm2, %xmm2\n+; AVX512BW-NEXT:    vpsubb %zmm1, %zmm2, %zmm2\n+; AVX512BW-NEXT:    vmovdqa64 {{.*#+}} zmm3 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n+; AVX512BW-NEXT:    vpandq %zmm3, %zmm2, %zmm2\n+; AVX512BW-NEXT:    vpsllw $5, %zmm2, %zmm2\n+; AVX512BW-NEXT:    vpaddb %zmm2, %zmm2, %zmm4\n ; AVX512BW-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512BW-NEXT:    vpmovb2m %zmm3, %k2\n-; AVX512BW-NEXT:    vpsrlw $4, %zmm0, %zmm3\n-; AVX512BW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm3, %zmm3\n-; AVX512BW-NEXT:    vpblendmb %zmm3, %zmm0, %zmm3 {%k2}\n-; AVX512BW-NEXT:    vpsrlw $2, %zmm3, %zmm5\n-; AVX512BW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n-; AVX512BW-NEXT:    vmovdqu8 %zmm5, %zmm3 {%k1}\n-; AVX512BW-NEXT:    vpsrlw $1, %zmm3, %zmm5\n+; AVX512BW-NEXT:    vpmovb2m %zmm2, %k2\n+; AVX512BW-NEXT:    vpsllw $4, %zmm0, %zmm2\n+; AVX512BW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm2, %zmm2\n+; AVX512BW-NEXT:    vpblendmb %zmm2, %zmm0, %zmm2 {%k2}\n+; AVX512BW-NEXT:    vpsllw $2, %zmm2, %zmm5\n ; AVX512BW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n+; AVX512BW-NEXT:    vmovdqu8 %zmm5, %zmm2 {%k1}\n ; AVX512BW-NEXT:    vpaddb %zmm4, %zmm4, %zmm4\n ; AVX512BW-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512BW-NEXT:    vmovdqu8 %zmm5, %zmm3 {%k1}\n-; AVX512BW-NEXT:    vpxor %xmm4, %xmm4, %xmm4\n-; AVX512BW-NEXT:    vpsubb %zmm1, %zmm4, %zmm1\n-; AVX512BW-NEXT:    vpandq %zmm2, %zmm1, %zmm1\n+; AVX512BW-NEXT:    vpaddb %zmm2, %zmm2, %zmm2 {%k1}\n+; AVX512BW-NEXT:    vpandq %zmm3, %zmm1, %zmm1\n ; AVX512BW-NEXT:    vpsllw $5, %zmm1, %zmm1\n-; AVX512BW-NEXT:    vpaddb %zmm1, %zmm1, %zmm2\n-; AVX512BW-NEXT:    vpmovb2m %zmm2, %k1\n+; AVX512BW-NEXT:    vpaddb %zmm1, %zmm1, %zmm3\n+; AVX512BW-NEXT:    vpmovb2m %zmm3, %k1\n ; AVX512BW-NEXT:    vpmovb2m %zmm1, %k2\n-; AVX512BW-NEXT:    vpsllw $4, %zmm0, %zmm1\n+; AVX512BW-NEXT:    vpsrlw $4, %zmm0, %zmm1\n ; AVX512BW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512BW-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k2}\n-; AVX512BW-NEXT:    vpsllw $2, %zmm0, %zmm1\n+; AVX512BW-NEXT:    vpsrlw $2, %zmm0, %zmm1\n ; AVX512BW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512BW-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n-; AVX512BW-NEXT:    vpaddb %zmm2, %zmm2, %zmm1\n-; AVX512BW-NEXT:    vpmovb2m %zmm1, %k1\n-; AVX512BW-NEXT:    vpaddb %zmm0, %zmm0, %zmm0 {%k1}\n-; AVX512BW-NEXT:    vporq %zmm0, %zmm3, %zmm0\n+; AVX512BW-NEXT:    vpsrlw $1, %zmm0, %zmm1\n+; AVX512BW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n+; AVX512BW-NEXT:    vpaddb %zmm3, %zmm3, %zmm3\n+; AVX512BW-NEXT:    vpmovb2m %zmm3, %k1\n+; AVX512BW-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n+; AVX512BW-NEXT:    vporq %zmm2, %zmm0, %zmm0\n ; AVX512BW-NEXT:    retq\n ;\n ; AVX512VLBW-LABEL: var_funnnel_v64i8:\n ; AVX512VLBW:       # %bb.0:\n-; AVX512VLBW-NEXT:    vmovdqa64 {{.*#+}} zmm2 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n-; AVX512VLBW-NEXT:    vpandq %zmm2, %zmm1, %zmm3\n-; AVX512VLBW-NEXT:    vpsllw $5, %zmm3, %zmm3\n-; AVX512VLBW-NEXT:    vpaddb %zmm3, %zmm3, %zmm4\n+; AVX512VLBW-NEXT:    vpxor %xmm2, %xmm2, %xmm2\n+; AVX512VLBW-NEXT:    vpsubb %zmm1, %zmm2, %zmm2\n+; AVX512VLBW-NEXT:    vmovdqa64 {{.*#+}} zmm3 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n+; AVX512VLBW-NEXT:    vpandq %zmm3, %zmm2, %zmm2\n+; AVX512VLBW-NEXT:    vpsllw $5, %zmm2, %zmm2\n+; AVX512VLBW-NEXT:    vpaddb %zmm2, %zmm2, %zmm4\n ; AVX512VLBW-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512VLBW-NEXT:    vpmovb2m %zmm3, %k2\n-; AVX512VLBW-NEXT:    vpsrlw $4, %zmm0, %zmm3\n-; AVX512VLBW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm3, %zmm3\n-; AVX512VLBW-NEXT:    vpblendmb %zmm3, %zmm0, %zmm3 {%k2}\n-; AVX512VLBW-NEXT:    vpsrlw $2, %zmm3, %zmm5\n-; AVX512VLBW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n-; AVX512VLBW-NEXT:    vmovdqu8 %zmm5, %zmm3 {%k1}\n-; AVX512VLBW-NEXT:    vpsrlw $1, %zmm3, %zmm5\n+; AVX512VLBW-NEXT:    vpmovb2m %zmm2, %k2\n+; AVX512VLBW-NEXT:    vpsllw $4, %zmm0, %zmm2\n+; AVX512VLBW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm2, %zmm2\n+; AVX512VLBW-NEXT:    vpblendmb %zmm2, %zmm0, %zmm2 {%k2}\n+; AVX512VLBW-NEXT:    vpsllw $2, %zmm2, %zmm5\n ; AVX512VLBW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n+; AVX512VLBW-NEXT:    vmovdqu8 %zmm5, %zmm2 {%k1}\n ; AVX512VLBW-NEXT:    vpaddb %zmm4, %zmm4, %zmm4\n ; AVX512VLBW-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512VLBW-NEXT:    vmovdqu8 %zmm5, %zmm3 {%k1}\n-; AVX512VLBW-NEXT:    vpxor %xmm4, %xmm4, %xmm4\n-; AVX512VLBW-NEXT:    vpsubb %zmm1, %zmm4, %zmm1\n-; AVX512VLBW-NEXT:    vpandq %zmm2, %zmm1, %zmm1\n+; AVX512VLBW-NEXT:    vpaddb %zmm2, %zmm2, %zmm2 {%k1}\n+; AVX512VLBW-NEXT:    vpandq %zmm3, %zmm1, %zmm1\n ; AVX512VLBW-NEXT:    vpsllw $5, %zmm1, %zmm1\n-; AVX512VLBW-NEXT:    vpaddb %zmm1, %zmm1, %zmm2\n-; AVX512VLBW-NEXT:    vpmovb2m %zmm2, %k1\n+; AVX512VLBW-NEXT:    vpaddb %zmm1, %zmm1, %zmm3\n+; AVX512VLBW-NEXT:    vpmovb2m %zmm3, %k1\n ; AVX512VLBW-NEXT:    vpmovb2m %zmm1, %k2\n-; AVX512VLBW-NEXT:    vpsllw $4, %zmm0, %zmm1\n+; AVX512VLBW-NEXT:    vpsrlw $4, %zmm0, %zmm1\n ; AVX512VLBW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512VLBW-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k2}\n-; AVX512VLBW-NEXT:    vpsllw $2, %zmm0, %zmm1\n+; AVX512VLBW-NEXT:    vpsrlw $2, %zmm0, %zmm1\n ; AVX512VLBW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512VLBW-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n-; AVX512VLBW-NEXT:    vpaddb %zmm2, %zmm2, %zmm1\n-; AVX512VLBW-NEXT:    vpmovb2m %zmm1, %k1\n-; AVX512VLBW-NEXT:    vpaddb %zmm0, %zmm0, %zmm0 {%k1}\n-; AVX512VLBW-NEXT:    vporq %zmm0, %zmm3, %zmm0\n+; AVX512VLBW-NEXT:    vpsrlw $1, %zmm0, %zmm1\n+; AVX512VLBW-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n+; AVX512VLBW-NEXT:    vpaddb %zmm3, %zmm3, %zmm3\n+; AVX512VLBW-NEXT:    vpmovb2m %zmm3, %k1\n+; AVX512VLBW-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n+; AVX512VLBW-NEXT:    vporq %zmm2, %zmm0, %zmm0\n ; AVX512VLBW-NEXT:    retq\n ;\n ; AVX512VBMI2-LABEL: var_funnnel_v64i8:\n ; AVX512VBMI2:       # %bb.0:\n-; AVX512VBMI2-NEXT:    vmovdqa64 {{.*#+}} zmm2 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n-; AVX512VBMI2-NEXT:    vpandq %zmm2, %zmm1, %zmm3\n-; AVX512VBMI2-NEXT:    vpsllw $5, %zmm3, %zmm3\n-; AVX512VBMI2-NEXT:    vpaddb %zmm3, %zmm3, %zmm4\n+; AVX512VBMI2-NEXT:    vpxor %xmm2, %xmm2, %xmm2\n+; AVX512VBMI2-NEXT:    vpsubb %zmm1, %zmm2, %zmm2\n+; AVX512VBMI2-NEXT:    vmovdqa64 {{.*#+}} zmm3 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n+; AVX512VBMI2-NEXT:    vpandq %zmm3, %zmm2, %zmm2\n+; AVX512VBMI2-NEXT:    vpsllw $5, %zmm2, %zmm2\n+; AVX512VBMI2-NEXT:    vpaddb %zmm2, %zmm2, %zmm4\n ; AVX512VBMI2-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512VBMI2-NEXT:    vpmovb2m %zmm3, %k2\n-; AVX512VBMI2-NEXT:    vpsrlw $4, %zmm0, %zmm3\n-; AVX512VBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm3, %zmm3\n-; AVX512VBMI2-NEXT:    vpblendmb %zmm3, %zmm0, %zmm3 {%k2}\n-; AVX512VBMI2-NEXT:    vpsrlw $2, %zmm3, %zmm5\n-; AVX512VBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n-; AVX512VBMI2-NEXT:    vmovdqu8 %zmm5, %zmm3 {%k1}\n-; AVX512VBMI2-NEXT:    vpsrlw $1, %zmm3, %zmm5\n+; AVX512VBMI2-NEXT:    vpmovb2m %zmm2, %k2\n+; AVX512VBMI2-NEXT:    vpsllw $4, %zmm0, %zmm2\n+; AVX512VBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm2, %zmm2\n+; AVX512VBMI2-NEXT:    vpblendmb %zmm2, %zmm0, %zmm2 {%k2}\n+; AVX512VBMI2-NEXT:    vpsllw $2, %zmm2, %zmm5\n ; AVX512VBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n+; AVX512VBMI2-NEXT:    vmovdqu8 %zmm5, %zmm2 {%k1}\n ; AVX512VBMI2-NEXT:    vpaddb %zmm4, %zmm4, %zmm4\n ; AVX512VBMI2-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512VBMI2-NEXT:    vmovdqu8 %zmm5, %zmm3 {%k1}\n-; AVX512VBMI2-NEXT:    vpxor %xmm4, %xmm4, %xmm4\n-; AVX512VBMI2-NEXT:    vpsubb %zmm1, %zmm4, %zmm1\n-; AVX512VBMI2-NEXT:    vpandq %zmm2, %zmm1, %zmm1\n+; AVX512VBMI2-NEXT:    vpaddb %zmm2, %zmm2, %zmm2 {%k1}\n+; AVX512VBMI2-NEXT:    vpandq %zmm3, %zmm1, %zmm1\n ; AVX512VBMI2-NEXT:    vpsllw $5, %zmm1, %zmm1\n-; AVX512VBMI2-NEXT:    vpaddb %zmm1, %zmm1, %zmm2\n-; AVX512VBMI2-NEXT:    vpmovb2m %zmm2, %k1\n+; AVX512VBMI2-NEXT:    vpaddb %zmm1, %zmm1, %zmm3\n+; AVX512VBMI2-NEXT:    vpmovb2m %zmm3, %k1\n ; AVX512VBMI2-NEXT:    vpmovb2m %zmm1, %k2\n-; AVX512VBMI2-NEXT:    vpsllw $4, %zmm0, %zmm1\n+; AVX512VBMI2-NEXT:    vpsrlw $4, %zmm0, %zmm1\n ; AVX512VBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512VBMI2-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k2}\n-; AVX512VBMI2-NEXT:    vpsllw $2, %zmm0, %zmm1\n+; AVX512VBMI2-NEXT:    vpsrlw $2, %zmm0, %zmm1\n ; AVX512VBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512VBMI2-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n-; AVX512VBMI2-NEXT:    vpaddb %zmm2, %zmm2, %zmm1\n-; AVX512VBMI2-NEXT:    vpmovb2m %zmm1, %k1\n-; AVX512VBMI2-NEXT:    vpaddb %zmm0, %zmm0, %zmm0 {%k1}\n-; AVX512VBMI2-NEXT:    vporq %zmm0, %zmm3, %zmm0\n+; AVX512VBMI2-NEXT:    vpsrlw $1, %zmm0, %zmm1\n+; AVX512VBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n+; AVX512VBMI2-NEXT:    vpaddb %zmm3, %zmm3, %zmm3\n+; AVX512VBMI2-NEXT:    vpmovb2m %zmm3, %k1\n+; AVX512VBMI2-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n+; AVX512VBMI2-NEXT:    vporq %zmm2, %zmm0, %zmm0\n ; AVX512VBMI2-NEXT:    retq\n ;\n ; AVX512VLVBMI2-LABEL: var_funnnel_v64i8:\n ; AVX512VLVBMI2:       # %bb.0:\n-; AVX512VLVBMI2-NEXT:    vmovdqa64 {{.*#+}} zmm2 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n-; AVX512VLVBMI2-NEXT:    vpandq %zmm2, %zmm1, %zmm3\n-; AVX512VLVBMI2-NEXT:    vpsllw $5, %zmm3, %zmm3\n-; AVX512VLVBMI2-NEXT:    vpaddb %zmm3, %zmm3, %zmm4\n+; AVX512VLVBMI2-NEXT:    vpxor %xmm2, %xmm2, %xmm2\n+; AVX512VLVBMI2-NEXT:    vpsubb %zmm1, %zmm2, %zmm2\n+; AVX512VLVBMI2-NEXT:    vmovdqa64 {{.*#+}} zmm3 = [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7]\n+; AVX512VLVBMI2-NEXT:    vpandq %zmm3, %zmm2, %zmm2\n+; AVX512VLVBMI2-NEXT:    vpsllw $5, %zmm2, %zmm2\n+; AVX512VLVBMI2-NEXT:    vpaddb %zmm2, %zmm2, %zmm4\n ; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm3, %k2\n-; AVX512VLVBMI2-NEXT:    vpsrlw $4, %zmm0, %zmm3\n-; AVX512VLVBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm3, %zmm3\n-; AVX512VLVBMI2-NEXT:    vpblendmb %zmm3, %zmm0, %zmm3 {%k2}\n-; AVX512VLVBMI2-NEXT:    vpsrlw $2, %zmm3, %zmm5\n-; AVX512VLVBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n-; AVX512VLVBMI2-NEXT:    vmovdqu8 %zmm5, %zmm3 {%k1}\n-; AVX512VLVBMI2-NEXT:    vpsrlw $1, %zmm3, %zmm5\n+; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm2, %k2\n+; AVX512VLVBMI2-NEXT:    vpsllw $4, %zmm0, %zmm2\n+; AVX512VLVBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm2, %zmm2\n+; AVX512VLVBMI2-NEXT:    vpblendmb %zmm2, %zmm0, %zmm2 {%k2}\n+; AVX512VLVBMI2-NEXT:    vpsllw $2, %zmm2, %zmm5\n ; AVX512VLVBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm5, %zmm5\n+; AVX512VLVBMI2-NEXT:    vmovdqu8 %zmm5, %zmm2 {%k1}\n ; AVX512VLVBMI2-NEXT:    vpaddb %zmm4, %zmm4, %zmm4\n ; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm4, %k1\n-; AVX512VLVBMI2-NEXT:    vmovdqu8 %zmm5, %zmm3 {%k1}\n-; AVX512VLVBMI2-NEXT:    vpxor %xmm4, %xmm4, %xmm4\n-; AVX512VLVBMI2-NEXT:    vpsubb %zmm1, %zmm4, %zmm1\n-; AVX512VLVBMI2-NEXT:    vpandq %zmm2, %zmm1, %zmm1\n+; AVX512VLVBMI2-NEXT:    vpaddb %zmm2, %zmm2, %zmm2 {%k1}\n+; AVX512VLVBMI2-NEXT:    vpandq %zmm3, %zmm1, %zmm1\n ; AVX512VLVBMI2-NEXT:    vpsllw $5, %zmm1, %zmm1\n-; AVX512VLVBMI2-NEXT:    vpaddb %zmm1, %zmm1, %zmm2\n-; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm2, %k1\n+; AVX512VLVBMI2-NEXT:    vpaddb %zmm1, %zmm1, %zmm3\n+; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm3, %k1\n ; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm1, %k2\n-; AVX512VLVBMI2-NEXT:    vpsllw $4, %zmm0, %zmm1\n+; AVX512VLVBMI2-NEXT:    vpsrlw $4, %zmm0, %zmm1\n ; AVX512VLVBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512VLVBMI2-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k2}\n-; AVX512VLVBMI2-NEXT:    vpsllw $2, %zmm0, %zmm1\n+; AVX512VLVBMI2-NEXT:    vpsrlw $2, %zmm0, %zmm1\n ; AVX512VLVBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n ; AVX512VLVBMI2-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n-; AVX512VLVBMI2-NEXT:    vpaddb %zmm2, %zmm2, %zmm1\n-; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm1, %k1\n-; AVX512VLVBMI2-NEXT:    vpaddb %zmm0, %zmm0, %zmm0 {%k1}\n-; AVX512VLVBMI2-NEXT:    vporq %zmm0, %zmm3, %zmm0\n+; AVX512VLVBMI2-NEXT:    vpsrlw $1, %zmm0, %zmm1\n+; AVX512VLVBMI2-NEXT:    vpandq {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %zmm1, %zmm1\n+; AVX512VLVBMI2-NEXT:    vpaddb %zmm3, %zmm3, %zmm3\n+; AVX512VLVBMI2-NEXT:    vpmovb2m %zmm3, %k1\n+; AVX512VLVBMI2-NEXT:    vmovdqu8 %zmm1, %zmm0 {%k1}\n+; AVX512VLVBMI2-NEXT:    vporq %zmm2, %zmm0, %zmm0\n ; AVX512VLVBMI2-NEXT:    retq\n   %res = call <64 x i8> @llvm.fshr.v64i8(<64 x i8> %x, <64 x i8> %x, <64 x i8> %amt)\n   ret <64 x i8> %res"
            },
            {
                "fn": "llvm/test/CodeGen/X86/vector-rotate-128.ll",
                "patch": "@@ -506,10 +506,10 @@ define <16 x i8> @var_rotate_v16i8(<16 x i8> %a, <16 x i8> %b) nounwind {\n ; SSE2-NEXT:    pandn %xmm3, %xmm2\n ; SSE2-NEXT:    por %xmm4, %xmm2\n ; SSE2-NEXT:    movdqa %xmm2, %xmm3\n-; SSE2-NEXT:    paddb %xmm2, %xmm3\n+; SSE2-NEXT:    psrlw $7, %xmm3\n+; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm3\n ; SSE2-NEXT:    movdqa %xmm2, %xmm4\n-; SSE2-NEXT:    psrlw $7, %xmm4\n-; SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm4\n+; SSE2-NEXT:    paddb %xmm2, %xmm4\n ; SSE2-NEXT:    por %xmm3, %xmm4\n ; SSE2-NEXT:    paddb %xmm1, %xmm1\n ; SSE2-NEXT:    pcmpgtb %xmm1, %xmm0\n@@ -542,10 +542,10 @@ define <16 x i8> @var_rotate_v16i8(<16 x i8> %a, <16 x i8> %b) nounwind {\n ; SSE41-NEXT:    movdqa %xmm2, %xmm0\n ; SSE41-NEXT:    pblendvb %xmm0, %xmm3, %xmm1\n ; SSE41-NEXT:    movdqa %xmm1, %xmm0\n-; SSE41-NEXT:    paddb %xmm1, %xmm0\n+; SSE41-NEXT:    psrlw $7, %xmm0\n+; SSE41-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0\n ; SSE41-NEXT:    movdqa %xmm1, %xmm3\n-; SSE41-NEXT:    psrlw $7, %xmm3\n-; SSE41-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm3\n+; SSE41-NEXT:    paddb %xmm1, %xmm3\n ; SSE41-NEXT:    por %xmm0, %xmm3\n ; SSE41-NEXT:    paddb %xmm2, %xmm2\n ; SSE41-NEXT:    movdqa %xmm2, %xmm0\n@@ -569,10 +569,10 @@ define <16 x i8> @var_rotate_v16i8(<16 x i8> %a, <16 x i8> %b) nounwind {\n ; AVX-NEXT:    vpor %xmm2, %xmm3, %xmm2\n ; AVX-NEXT:    vpaddb %xmm1, %xmm1, %xmm1\n ; AVX-NEXT:    vpblendvb %xmm1, %xmm2, %xmm0, %xmm0\n-; AVX-NEXT:    vpaddb %xmm0, %xmm0, %xmm2\n-; AVX-NEXT:    vpsrlw $7, %xmm0, %xmm3\n-; AVX-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm3, %xmm3\n-; AVX-NEXT:    vpor %xmm3, %xmm2, %xmm2\n+; AVX-NEXT:    vpsrlw $7, %xmm0, %xmm2\n+; AVX-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm2, %xmm2\n+; AVX-NEXT:    vpaddb %xmm0, %xmm0, %xmm3\n+; AVX-NEXT:    vpor %xmm2, %xmm3, %xmm2\n ; AVX-NEXT:    vpaddb %xmm1, %xmm1, %xmm1\n ; AVX-NEXT:    vpblendvb %xmm1, %xmm2, %xmm0, %xmm0\n ; AVX-NEXT:    retq\n@@ -699,10 +699,10 @@ define <16 x i8> @var_rotate_v16i8(<16 x i8> %a, <16 x i8> %b) nounwind {\n ; X86-SSE2-NEXT:    pandn %xmm3, %xmm2\n ; X86-SSE2-NEXT:    por %xmm4, %xmm2\n ; X86-SSE2-NEXT:    movdqa %xmm2, %xmm3\n-; X86-SSE2-NEXT:    paddb %xmm2, %xmm3\n+; X86-SSE2-NEXT:    psrlw $7, %xmm3\n+; X86-SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm3\n ; X86-SSE2-NEXT:    movdqa %xmm2, %xmm4\n-; X86-SSE2-NEXT:    psrlw $7, %xmm4\n-; X86-SSE2-NEXT:    pand {{\\.?LCPI[0-9]+_[0-9]+}}, %xmm4\n+; X86-SSE2-NEXT:    paddb %xmm2, %xmm4\n ; X86-SSE2-NEXT:    por %xmm3, %xmm4\n ; X86-SSE2-NEXT:    paddb %xmm1, %xmm1\n ; X86-SSE2-NEXT:    pcmpgtb %xmm1, %xmm0"
            },
            {
                "fn": "llvm/test/CodeGen/X86/vector-rotate-256.ll",
                "patch": "@@ -439,10 +439,10 @@ define <32 x i8> @var_rotate_v32i8(<32 x i8> %a, <32 x i8> %b) nounwind {\n ; AVX2-NEXT:    vpor %ymm2, %ymm3, %ymm2\n ; AVX2-NEXT:    vpaddb %ymm1, %ymm1, %ymm1\n ; AVX2-NEXT:    vpblendvb %ymm1, %ymm2, %ymm0, %ymm0\n-; AVX2-NEXT:    vpaddb %ymm0, %ymm0, %ymm2\n-; AVX2-NEXT:    vpsrlw $7, %ymm0, %ymm3\n-; AVX2-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm3, %ymm3\n-; AVX2-NEXT:    vpor %ymm3, %ymm2, %ymm2\n+; AVX2-NEXT:    vpsrlw $7, %ymm0, %ymm2\n+; AVX2-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm2, %ymm2\n+; AVX2-NEXT:    vpaddb %ymm0, %ymm0, %ymm3\n+; AVX2-NEXT:    vpor %ymm2, %ymm3, %ymm2\n ; AVX2-NEXT:    vpaddb %ymm1, %ymm1, %ymm1\n ; AVX2-NEXT:    vpblendvb %ymm1, %ymm2, %ymm0, %ymm0\n ; AVX2-NEXT:    retq\n@@ -463,10 +463,10 @@ define <32 x i8> @var_rotate_v32i8(<32 x i8> %a, <32 x i8> %b) nounwind {\n ; AVX512F-NEXT:    vpor %ymm2, %ymm3, %ymm2\n ; AVX512F-NEXT:    vpaddb %ymm1, %ymm1, %ymm1\n ; AVX512F-NEXT:    vpblendvb %ymm1, %ymm2, %ymm0, %ymm0\n-; AVX512F-NEXT:    vpaddb %ymm0, %ymm0, %ymm2\n-; AVX512F-NEXT:    vpsrlw $7, %ymm0, %ymm3\n-; AVX512F-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm3, %ymm3\n-; AVX512F-NEXT:    vpor %ymm3, %ymm2, %ymm2\n+; AVX512F-NEXT:    vpsrlw $7, %ymm0, %ymm2\n+; AVX512F-NEXT:    vpand {{\\.?LCPI[0-9]+_[0-9]+}}(%rip), %ymm2, %ymm2\n+; AVX512F-NEXT:    vpaddb %ymm0, %ymm0, %ymm3\n+; AVX512F-NEXT:    vpor %ymm2, %ymm3, %ymm2\n ; AVX512F-NEXT:    vpaddb %ymm1, %ymm1, %ymm1\n ; AVX512F-NEXT:    vpblendvb %ymm1, %ymm2, %ymm0, %ymm0\n ; AVX512F-NEXT:    retq"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/bitreverse.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/bitreverse.ll\n\n\nTesting Time: 1.35s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/combine-bitreverse.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/combine-bitreverse.ll\n\n\nTesting Time: 0.24s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-bitreverse.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-bitreverse.ll\n\n\nTesting Time: 1.37s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-fshl-rot-128.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-fshl-rot-128.ll\n\n\nTesting Time: 0.30s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-fshl-rot-256.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-fshl-rot-256.ll\n\n\nTesting Time: 0.59s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-fshl-rot-512.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-fshl-rot-512.ll\n\n\nTesting Time: 1.14s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-fshr-128.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-fshr-128.ll\n\n\nTesting Time: 0.36s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-fshr-256.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-fshr-256.ll\n\n\nTesting Time: 2.80s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-fshr-rot-128.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-fshr-rot-128.ll\n\n\nTesting Time: 0.30s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-fshr-rot-256.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-fshr-rot-256.ll\n\n\nTesting Time: 0.60s\n  Failed: 1\n-- Testing: 1 tests, "
    },
    "cf53c6c9710617ea465863e117dda695af2c3ebb___X86MCInstLower.cpp": {
        "prefix": "void X86AsmPrinter::emitAsanReportError(Module &M, unsigned Reg,\n                                        const ASanAccessInfo &AccessInfo,\n                                        MCSubtargetInfo &STI) {\n  std::string Name = AccessInfo.IsWrite ? \"store\" : \"load\";\n  MCSymbol *ReportError = OutContext.getOrCreateSymbol(\n      \"__asan_report_\" + Name + utostr(1ULL << AccessInfo.AccessSizeIndex));\n  OutStreamer->emitInstruction(MCInstBuilder(X86::MOV64rr)\n                                   .addReg(X86::RDI)\n                                   .addReg(X86::NoRegister + Reg),\n                               STI);\n  OutStreamer->emitInstruction(\n      MCInstBuilder(X86::JMP_1)\n",
        "suffix": "      STI);\n}\n",
        "start": 1517,
        "end": 1531,
        "buggy": "void X86AsmPrinter::emitAsanReportError(Module &M, unsigned Reg,\n                                        const ASanAccessInfo &AccessInfo,\n                                        MCSubtargetInfo &STI) {\n  std::string Name = AccessInfo.IsWrite ? \"store\" : \"load\";\n  MCSymbol *ReportError = OutContext.getOrCreateSymbol(\n      \"__asan_report_\" + Name + utostr(1ULL << AccessInfo.AccessSizeIndex));\n  OutStreamer->emitInstruction(MCInstBuilder(X86::MOV64rr)\n                                   .addReg(X86::RDI)\n                                   .addReg(X86::NoRegister + Reg),\n                               STI);\n  OutStreamer->emitInstruction(\n      MCInstBuilder(X86::JMP_1)\n          .addExpr(MCSymbolRefExpr::create(ReportError, OutContext)),\n      STI);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "          .addExpr(MCSymbolRefExpr::create(ReportError, OutContext)),\n",
        "src_path": "cf53c6c9710617ea465863e117dda695af2c3ebb___X86MCInstLower.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/cf53c6c9710617ea465863e117dda695af2c3ebb",
        "commit_msg": "[asan] Fixed link error by setting jump symbol to R_X86_64_PLT32.\n\nFixing this link error:\nld: error: relocation R_X86_64_PC32 cannot be used against symbol __asan_report_load...; recompile with -fPIC\n\nReviewed By: vitalybuka\n\nDifferential Revision: https://reviews.llvm.org/D109183",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/asan-check-memaccess-add.ll",
                "patch": "@@ -166,7 +166,7 @@ define void @load16(i128* nocapture readonly %x) {\n ; CHECK-NEXT:         popq    %rcx\n ; CHECK-NEXT:         jl      [[RET]]\n ; CHECK-NEXT:         movq    [[REG:.*]], %rdi\n-; CHECK-NEXT:         jmp     __asan_report_store1\n+; CHECK-NEXT:         jmp     __asan_report_store1@PLT\n \n ; CHECK:              .type   __asan_check_store2_rn[[RN2]],@function\n ; CHECK-NEXT:         .weak   __asan_check_store2_rn[[RN2]]\n@@ -188,7 +188,7 @@ define void @load16(i128* nocapture readonly %x) {\n ; CHECK-NEXT:         popq    %rcx\n ; CHECK-NEXT:         jl      [[RET]]\n ; CHECK-NEXT:         movq    [[REG:.*]], %rdi\n-; CHECK-NEXT:         jmp     __asan_report_store2\n+; CHECK-NEXT:         jmp     __asan_report_store2@PLT\n \n ; CHECK:              .type   __asan_check_store4_rn[[RN4]],@function\n ; CHECK-NEXT:         .weak   __asan_check_store4_rn[[RN4]]\n@@ -210,7 +210,7 @@ define void @load16(i128* nocapture readonly %x) {\n ; CHECK-NEXT:         popq    %rcx\n ; CHECK-NEXT:         jl      [[RET]]\n ; CHECK-NEXT:         movq    [[REG:.*]], %rdi\n-; CHECK-NEXT:         jmp     __asan_report_store4\n+; CHECK-NEXT:         jmp     __asan_report_store4@PLT\n \n ; CHECK:              .type   __asan_check_store8_rn[[RN8]],@function\n ; CHECK-NEXT:         .weak   __asan_check_store8_rn[[RN8]]\n@@ -224,7 +224,7 @@ define void @load16(i128* nocapture readonly %x) {\n ; CHECK-NEXT:         retq\n ; CHECK-NEXT: [[FAIL]]:\n ; CHECK-NEXT:         movq    [[REG:.*]], %rdi\n-; CHECK-NEXT:         jmp     __asan_report_store8\n+; CHECK-NEXT:         jmp     __asan_report_store8@PLT\n \n ; CHECK:              .type   __asan_check_store16_rn[[RN16]],@function\n ; CHECK-NEXT:         .weak   __asan_check_store16_rn[[RN16]]\n@@ -238,6 +238,6 @@ define void @load16(i128* nocapture readonly %x) {\n ; CHECK-NEXT:         retq\n ; CHECK-NEXT: [[FAIL]]:\n ; CHECK-NEXT:         movq    [[REG:.*]], %rdi\n-; CHECK-NEXT:         jmp     __asan_report_store16\n+; CHECK-NEXT:         jmp     __asan_report_store16@PLT\n \n declare void @llvm.asan.check.memaccess(i8*, i32 immarg)"
            },
            {
                "fn": "llvm/test/CodeGen/X86/asan-check-memaccess-or.ll",
                "patch": "@@ -172,7 +172,7 @@ define void @load16(i128* nocapture readonly %x) {\n ; CHECK-NEXT:         popq    %rcx\n ; CHECK-NEXT:         jl      [[RET]]\n ; CHECK-NEXT:         movq    [[REG:.*]], %rdi\n-; CHECK-NEXT:         jmp     __asan_report_store1\n+; CHECK-NEXT:         jmp     __asan_report_store1@PLT\n \n ; CHECK:              .type   __asan_check_store2_rn[[RN2]],@function\n ; CHECK-NEXT:         .weak   __asan_check_store2_rn[[RN2]]\n@@ -195,7 +195,7 @@ define void @load16(i128* nocapture readonly %x) {\n ; CHECK-NEXT:         popq    %rcx\n ; CHECK-NEXT:         jl      [[RET]]\n ; CHECK-NEXT:         movq    [[REG:.*]], %rdi\n-; CHECK-NEXT:         jmp     __asan_report_store2\n+; CHECK-NEXT:         jmp     __asan_report_store2@PLT\n \n ; CHECK:              .type   __asan_check_store4_rn[[RN4]],@function\n ; CHECK-NEXT:         .weak   __asan_check_store4_rn[[RN4]]\n@@ -218,7 +218,7 @@ define void @load16(i128* nocapture readonly %x) {\n ; CHECK-NEXT:         popq    %rcx\n ; CHECK-NEXT:         jl      [[RET]]\n ; CHECK-NEXT:         movq    [[REG:.*]], %rdi\n-; CHECK-NEXT:         jmp     __asan_report_store4\n+; CHECK-NEXT:         jmp     __asan_report_store4@PLT\n \n ; CHECK:              .type   __asan_check_store8_rn[[RN8]],@function\n ; CHECK-NEXT:         .weak   __asan_check_store8_rn[[RN8]]\n@@ -233,7 +233,7 @@ define void @load16(i128* nocapture readonly %x) {\n ; CHECK-NEXT:         retq\n ; CHECK-NEXT: [[FAIL]]:\n ; CHECK-NEXT:         movq    [[REG:.*]], %rdi\n-; CHECK-NEXT:         jmp     __asan_report_store8\n+; CHECK-NEXT:         jmp     __asan_report_store8@PLT\n \n ; CHECK:              .type   __asan_check_store16_rn[[RN16]],@function\n ; CHECK-NEXT:         .weak   __asan_check_store16_rn[[RN16]]\n@@ -248,6 +248,6 @@ define void @load16(i128* nocapture readonly %x) {\n ; CHECK-NEXT:         retq\n ; CHECK-NEXT: [[FAIL]]:\n ; CHECK-NEXT:         movq    [[REG:.*]], %rdi\n-; CHECK-NEXT:         jmp     __asan_report_store16\n+; CHECK-NEXT:         jmp     __asan_report_store16@PLT\n \n declare void @llvm.asan.check.memaccess(i8*, i32 immarg)"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/asan-check-memaccess-add.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/asan-check-memaccess-add.ll\n\n\nTesting Time: 0.19s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/asan-check-memaccess-or.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/asan-check-memaccess-or.ll\n\n\nTesting Time: 0.13s\n  Failed: 1\n"
    },
    "5ec23863320ca12bfabb6dcff1d0425cb614b7a5___IndVarSimplify.cpp": {
        "prefix": "bool IndVarSimplify::run(Loop *L) {\n  // We need (and expect!) the incoming loop to be in LCSSA.\n  assert(L->isRecursivelyLCSSAForm(*DT, *LI) &&\n         \"LCSSA required to run indvars!\");\n\n  // If LoopSimplify form is not available, stay out of trouble. Some notes:\n  //  - LSR currently only supports LoopSimplify-form loops. Indvars'\n  //    canonicalization can be a pessimization without LSR to \"clean up\"\n  //    afterwards.\n  //  - We depend on having a preheader; in particular,\n  //    Loop::getCanonicalInductionVariable only supports loops with preheaders,\n  //    and we're in trouble if we can't find the induction variable even when\n  //    we've manually inserted one.\n  //  - LFTR relies on having a single backedge.\n  if (!L->isLoopSimplifyForm())\n    return false;\n\n#ifndef NDEBUG\n  // Used below for a consistency check only\n  // Note: Since the result returned by ScalarEvolution may depend on the order\n  // in which previous results are added to its cache, the call to\n  // getBackedgeTakenCount() may change following SCEV queries.\n  const SCEV *BackedgeTakenCount;\n  if (VerifyIndvars)\n    BackedgeTakenCount = SE->getBackedgeTakenCount(L);\n#endif\n\n  bool Changed = false;\n  // If there are any floating-point recurrences, attempt to\n  // transform them to use integer recurrences.\n  Changed |= rewriteNonIntegerIVs(L);\n\n  // Create a rewriter object which we'll use to transform the code with.\n  SCEVExpander Rewriter(*SE, DL, \"indvars\");\n#ifndef NDEBUG\n  Rewriter.setDebugType(DEBUG_TYPE);\n#endif\n\n  // Eliminate redundant IV users.\n  //\n  // Simplification works best when run before other consumers of SCEV. We\n  // attempt to avoid evaluating SCEVs for sign/zero extend operations until\n  // other expressions involving loop IVs have been evaluated. This helps SCEV\n  // set no-wrap flags before normalizing sign/zero extension.\n  Rewriter.disableCanonicalMode();\n  Changed |= simplifyAndExtend(L, Rewriter, LI);\n\n  // Check to see if we can compute the final value of any expressions\n  // that are recurrent in the loop, and substitute the exit values from the\n  // loop into any instructions outside of the loop that use the final values\n  // of the current expressions.\n  if (ReplaceExitValue != NeverRepl) {\n    if (int Rewrites = rewriteLoopExitValues(L, LI, TLI, SE, TTI, Rewriter, DT,\n                                             ReplaceExitValue, DeadInsts)) {\n      NumReplaced += Rewrites;\n      Changed = true;\n    }\n  }\n\n  // Eliminate redundant IV cycles.\n",
        "suffix": "\n  // Try to convert exit conditions to unsigned and rotate computation\n  // out of the loop.  Note: Handles invalidation internally if needed.\n  Changed |= canonicalizeExitCondition(L);\n\n  // Try to eliminate loop exits based on analyzeable exit counts\n  if (optimizeLoopExits(L, Rewriter))  {\n    Changed = true;\n    // Given we've changed exit counts, notify SCEV\n    // Some nested loops may share same folded exit basic block,\n    // thus we need to notify top most loop.\n    SE->forgetTopmostLoop(L);\n  }\n\n  // Try to form loop invariant tests for loop exits by changing how many\n  // iterations of the loop run when that is unobservable.\n  if (predicateLoopExits(L, Rewriter)) {\n    Changed = true;\n    // Given we've changed exit counts, notify SCEV\n    SE->forgetLoop(L);\n  }\n\n  // If we have a trip count expression, rewrite the loop's exit condition\n  // using it.\n  if (!DisableLFTR) {\n    BasicBlock *PreHeader = L->getLoopPreheader();\n    BranchInst *PreHeaderBR = cast<BranchInst>(PreHeader->getTerminator());\n\n    SmallVector<BasicBlock*, 16> ExitingBlocks;\n    L->getExitingBlocks(ExitingBlocks);\n    for (BasicBlock *ExitingBB : ExitingBlocks) {\n      // Can't rewrite non-branch yet.\n      if (!isa<BranchInst>(ExitingBB->getTerminator()))\n        continue;\n\n      // If our exitting block exits multiple loops, we can only rewrite the\n      // innermost one.  Otherwise, we're changing how many times the innermost\n      // loop runs before it exits.\n      if (LI->getLoopFor(ExitingBB) != L)\n        continue;\n\n      if (!needsLFTR(L, ExitingBB))\n        continue;\n\n      const SCEV *ExitCount = SE->getExitCount(L, ExitingBB);\n      if (isa<SCEVCouldNotCompute>(ExitCount))\n        continue;\n\n      // This was handled above, but as we form SCEVs, we can sometimes refine\n      // existing ones; this allows exit counts to be folded to zero which\n      // weren't when optimizeLoopExits saw them.  Arguably, we should iterate\n      // until stable to handle cases like this better.\n      if (ExitCount->isZero())\n        continue;\n\n      PHINode *IndVar = FindLoopCounter(L, ExitingBB, ExitCount, SE, DT);\n      if (!IndVar)\n        continue;\n\n      // Avoid high cost expansions.  Note: This heuristic is questionable in\n      // that our definition of \"high cost\" is not exactly principled.\n      if (Rewriter.isHighCostExpansion(ExitCount, L, SCEVCheapExpansionBudget,\n                                       TTI, PreHeaderBR))\n        continue;\n\n      // Check preconditions for proper SCEVExpander operation. SCEV does not\n      // express SCEVExpander's dependencies, such as LoopSimplify. Instead\n      // any pass that uses the SCEVExpander must do it. This does not work\n      // well for loop passes because SCEVExpander makes assumptions about\n      // all loops, while LoopPassManager only forces the current loop to be\n      // simplified.\n      //\n      // FIXME: SCEV expansion has no way to bail out, so the caller must\n      // explicitly check any assumptions made by SCEV. Brittle.\n      const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(ExitCount);\n      if (!AR || AR->getLoop()->getLoopPreheader())\n        Changed |= linearFunctionTestReplace(L, ExitingBB,\n                                             ExitCount, IndVar,\n                                             Rewriter);\n    }\n  }\n  // Clear the rewriter cache, because values that are in the rewriter's cache\n  // can be deleted in the loop below, causing the AssertingVH in the cache to\n  // trigger.\n  Rewriter.clear();\n\n  // Now that we're done iterating through lists, clean up any instructions\n  // which are now dead.\n  while (!DeadInsts.empty()) {\n    Value *V = DeadInsts.pop_back_val();\n\n    if (PHINode *PHI = dyn_cast_or_null<PHINode>(V))\n      Changed |= RecursivelyDeleteDeadPHINode(PHI, TLI, MSSAU.get());\n    else if (Instruction *Inst = dyn_cast_or_null<Instruction>(V))\n      Changed |=\n          RecursivelyDeleteTriviallyDeadInstructions(Inst, TLI, MSSAU.get());\n  }\n\n  // The Rewriter may not be used from this point on.\n\n  // Loop-invariant instructions in the preheader that aren't used in the\n  // loop may be sunk below the loop to reduce register pressure.\n  Changed |= sinkUnusedInvariants(L);\n\n  // rewriteFirstIterationLoopExitValues does not rely on the computation of\n  // trip count and therefore can further simplify exit values in addition to\n  // rewriteLoopExitValues.\n  Changed |= rewriteFirstIterationLoopExitValues(L);\n\n  // Clean up dead instructions.\n  Changed |= DeleteDeadPHIs(L->getHeader(), TLI, MSSAU.get());\n\n  // Check a post-condition.\n  assert(L->isRecursivelyLCSSAForm(*DT, *LI) &&\n         \"Indvars did not preserve LCSSA!\");\n\n  // Verify that LFTR, and any other change have not interfered with SCEV's\n  // ability to compute trip count.  We may have *changed* the exit count, but\n  // only by reducing it.\n#ifndef NDEBUG\n  if (VerifyIndvars && !isa<SCEVCouldNotCompute>(BackedgeTakenCount)) {\n    SE->forgetLoop(L);\n    const SCEV *NewBECount = SE->getBackedgeTakenCount(L);\n    if (SE->getTypeSizeInBits(BackedgeTakenCount->getType()) <\n        SE->getTypeSizeInBits(NewBECount->getType()))\n      NewBECount = SE->getTruncateOrNoop(NewBECount,\n                                         BackedgeTakenCount->getType());\n    else\n      BackedgeTakenCount = SE->getTruncateOrNoop(BackedgeTakenCount,\n                                                 NewBECount->getType());\n    assert(!SE->isKnownPredicate(ICmpInst::ICMP_ULT, BackedgeTakenCount,\n                                 NewBECount) && \"indvars must preserve SCEV\");\n  }\n  if (VerifyMemorySSA && MSSAU)\n    MSSAU->getMemorySSA()->verifyMemorySSA();\n#endif\n\n  return Changed;\n}\n",
        "start": 1867,
        "end": 2066,
        "buggy": "bool IndVarSimplify::run(Loop *L) {\n  // We need (and expect!) the incoming loop to be in LCSSA.\n  assert(L->isRecursivelyLCSSAForm(*DT, *LI) &&\n         \"LCSSA required to run indvars!\");\n\n  // If LoopSimplify form is not available, stay out of trouble. Some notes:\n  //  - LSR currently only supports LoopSimplify-form loops. Indvars'\n  //    canonicalization can be a pessimization without LSR to \"clean up\"\n  //    afterwards.\n  //  - We depend on having a preheader; in particular,\n  //    Loop::getCanonicalInductionVariable only supports loops with preheaders,\n  //    and we're in trouble if we can't find the induction variable even when\n  //    we've manually inserted one.\n  //  - LFTR relies on having a single backedge.\n  if (!L->isLoopSimplifyForm())\n    return false;\n\n#ifndef NDEBUG\n  // Used below for a consistency check only\n  // Note: Since the result returned by ScalarEvolution may depend on the order\n  // in which previous results are added to its cache, the call to\n  // getBackedgeTakenCount() may change following SCEV queries.\n  const SCEV *BackedgeTakenCount;\n  if (VerifyIndvars)\n    BackedgeTakenCount = SE->getBackedgeTakenCount(L);\n#endif\n\n  bool Changed = false;\n  // If there are any floating-point recurrences, attempt to\n  // transform them to use integer recurrences.\n  Changed |= rewriteNonIntegerIVs(L);\n\n  // Create a rewriter object which we'll use to transform the code with.\n  SCEVExpander Rewriter(*SE, DL, \"indvars\");\n#ifndef NDEBUG\n  Rewriter.setDebugType(DEBUG_TYPE);\n#endif\n\n  // Eliminate redundant IV users.\n  //\n  // Simplification works best when run before other consumers of SCEV. We\n  // attempt to avoid evaluating SCEVs for sign/zero extend operations until\n  // other expressions involving loop IVs have been evaluated. This helps SCEV\n  // set no-wrap flags before normalizing sign/zero extension.\n  Rewriter.disableCanonicalMode();\n  Changed |= simplifyAndExtend(L, Rewriter, LI);\n\n  // Check to see if we can compute the final value of any expressions\n  // that are recurrent in the loop, and substitute the exit values from the\n  // loop into any instructions outside of the loop that use the final values\n  // of the current expressions.\n  if (ReplaceExitValue != NeverRepl) {\n    if (int Rewrites = rewriteLoopExitValues(L, LI, TLI, SE, TTI, Rewriter, DT,\n                                             ReplaceExitValue, DeadInsts)) {\n      NumReplaced += Rewrites;\n      Changed = true;\n    }\n  }\n\n  // Eliminate redundant IV cycles.\n  NumElimIV += Rewriter.replaceCongruentIVs(L, DT, DeadInsts);\n\n  // Try to convert exit conditions to unsigned and rotate computation\n  // out of the loop.  Note: Handles invalidation internally if needed.\n  Changed |= canonicalizeExitCondition(L);\n\n  // Try to eliminate loop exits based on analyzeable exit counts\n  if (optimizeLoopExits(L, Rewriter))  {\n    Changed = true;\n    // Given we've changed exit counts, notify SCEV\n    // Some nested loops may share same folded exit basic block,\n    // thus we need to notify top most loop.\n    SE->forgetTopmostLoop(L);\n  }\n\n  // Try to form loop invariant tests for loop exits by changing how many\n  // iterations of the loop run when that is unobservable.\n  if (predicateLoopExits(L, Rewriter)) {\n    Changed = true;\n    // Given we've changed exit counts, notify SCEV\n    SE->forgetLoop(L);\n  }\n\n  // If we have a trip count expression, rewrite the loop's exit condition\n  // using it.\n  if (!DisableLFTR) {\n    BasicBlock *PreHeader = L->getLoopPreheader();\n    BranchInst *PreHeaderBR = cast<BranchInst>(PreHeader->getTerminator());\n\n    SmallVector<BasicBlock*, 16> ExitingBlocks;\n    L->getExitingBlocks(ExitingBlocks);\n    for (BasicBlock *ExitingBB : ExitingBlocks) {\n      // Can't rewrite non-branch yet.\n      if (!isa<BranchInst>(ExitingBB->getTerminator()))\n        continue;\n\n      // If our exitting block exits multiple loops, we can only rewrite the\n      // innermost one.  Otherwise, we're changing how many times the innermost\n      // loop runs before it exits.\n      if (LI->getLoopFor(ExitingBB) != L)\n        continue;\n\n      if (!needsLFTR(L, ExitingBB))\n        continue;\n\n      const SCEV *ExitCount = SE->getExitCount(L, ExitingBB);\n      if (isa<SCEVCouldNotCompute>(ExitCount))\n        continue;\n\n      // This was handled above, but as we form SCEVs, we can sometimes refine\n      // existing ones; this allows exit counts to be folded to zero which\n      // weren't when optimizeLoopExits saw them.  Arguably, we should iterate\n      // until stable to handle cases like this better.\n      if (ExitCount->isZero())\n        continue;\n\n      PHINode *IndVar = FindLoopCounter(L, ExitingBB, ExitCount, SE, DT);\n      if (!IndVar)\n        continue;\n\n      // Avoid high cost expansions.  Note: This heuristic is questionable in\n      // that our definition of \"high cost\" is not exactly principled.\n      if (Rewriter.isHighCostExpansion(ExitCount, L, SCEVCheapExpansionBudget,\n                                       TTI, PreHeaderBR))\n        continue;\n\n      // Check preconditions for proper SCEVExpander operation. SCEV does not\n      // express SCEVExpander's dependencies, such as LoopSimplify. Instead\n      // any pass that uses the SCEVExpander must do it. This does not work\n      // well for loop passes because SCEVExpander makes assumptions about\n      // all loops, while LoopPassManager only forces the current loop to be\n      // simplified.\n      //\n      // FIXME: SCEV expansion has no way to bail out, so the caller must\n      // explicitly check any assumptions made by SCEV. Brittle.\n      const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(ExitCount);\n      if (!AR || AR->getLoop()->getLoopPreheader())\n        Changed |= linearFunctionTestReplace(L, ExitingBB,\n                                             ExitCount, IndVar,\n                                             Rewriter);\n    }\n  }\n  // Clear the rewriter cache, because values that are in the rewriter's cache\n  // can be deleted in the loop below, causing the AssertingVH in the cache to\n  // trigger.\n  Rewriter.clear();\n\n  // Now that we're done iterating through lists, clean up any instructions\n  // which are now dead.\n  while (!DeadInsts.empty()) {\n    Value *V = DeadInsts.pop_back_val();\n\n    if (PHINode *PHI = dyn_cast_or_null<PHINode>(V))\n      Changed |= RecursivelyDeleteDeadPHINode(PHI, TLI, MSSAU.get());\n    else if (Instruction *Inst = dyn_cast_or_null<Instruction>(V))\n      Changed |=\n          RecursivelyDeleteTriviallyDeadInstructions(Inst, TLI, MSSAU.get());\n  }\n\n  // The Rewriter may not be used from this point on.\n\n  // Loop-invariant instructions in the preheader that aren't used in the\n  // loop may be sunk below the loop to reduce register pressure.\n  Changed |= sinkUnusedInvariants(L);\n\n  // rewriteFirstIterationLoopExitValues does not rely on the computation of\n  // trip count and therefore can further simplify exit values in addition to\n  // rewriteLoopExitValues.\n  Changed |= rewriteFirstIterationLoopExitValues(L);\n\n  // Clean up dead instructions.\n  Changed |= DeleteDeadPHIs(L->getHeader(), TLI, MSSAU.get());\n\n  // Check a post-condition.\n  assert(L->isRecursivelyLCSSAForm(*DT, *LI) &&\n         \"Indvars did not preserve LCSSA!\");\n\n  // Verify that LFTR, and any other change have not interfered with SCEV's\n  // ability to compute trip count.  We may have *changed* the exit count, but\n  // only by reducing it.\n#ifndef NDEBUG\n  if (VerifyIndvars && !isa<SCEVCouldNotCompute>(BackedgeTakenCount)) {\n    SE->forgetLoop(L);\n    const SCEV *NewBECount = SE->getBackedgeTakenCount(L);\n    if (SE->getTypeSizeInBits(BackedgeTakenCount->getType()) <\n        SE->getTypeSizeInBits(NewBECount->getType()))\n      NewBECount = SE->getTruncateOrNoop(NewBECount,\n                                         BackedgeTakenCount->getType());\n    else\n      BackedgeTakenCount = SE->getTruncateOrNoop(BackedgeTakenCount,\n                                                 NewBECount->getType());\n    assert(!SE->isKnownPredicate(ICmpInst::ICMP_ULT, BackedgeTakenCount,\n                                 NewBECount) && \"indvars must preserve SCEV\");\n  }\n  if (VerifyMemorySSA && MSSAU)\n    MSSAU->getMemorySSA()->verifyMemorySSA();\n#endif\n\n  return Changed;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  NumElimIV += Rewriter.replaceCongruentIVs(L, DT, DeadInsts);\n",
        "src_path": "5ec23863320ca12bfabb6dcff1d0425cb614b7a5___IndVarSimplify.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/5ec23863320ca12bfabb6dcff1d0425cb614b7a5",
        "commit_msg": "Reapply db28934 \"[IndVars] Pass TTI to replaceCongruentIVs\"\n\nThis reapplies patch db289340c841990055a164e8eb2a3b5ff25677bf.\n\nThe test failures on build with expensive checks caused by the patch happened due\nto the fact that we sorted loop Phis in replaceCongruentIVs using llvm::sort,\nwhich shuffles the given container if the expensive checks are enabled,\nso equivalent Phis in the sorted vector had different mutual order from run\nto run. replaceCongruentIVs tries to replace narrow Phis with truncations\nof wide ones. In some test cases there were several Phis with the same\nwidth, so if their order differs from run to run, the narrow Phis would\nbe replaced with a different Phi, depending on the shuffling result.\n\nThe patch ae14fae0ff4304022beda5ab484f84ac0fdda807 fixed this issue by\nreplacing llvm::sort with llvm::stable_sort.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/GVN/gvn-eliminate-duplicating-phis.ll",
                "patch": "@@ -47,11 +47,10 @@ define void @non_local_load_with_iv_zext(i32* %ptr) {\n ; CHECK-NEXT:    br label [[LOOP:%.*]]\n ; CHECK:       loop:\n ; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[LOOP]] ], [ 0, [[ENTRY:%.*]] ]\n-; CHECK-NEXT:    [[VAL:%.*]] = phi i32 [ [[VAL_INC:%.*]], [[LOOP]] ], [ 0, [[ENTRY]] ]\n-; CHECK-NEXT:    [[VAL_INC]] = add nuw nsw i32 [[VAL]], 1\n-; CHECK-NEXT:    store i32 [[VAL_INC]], i32* [[PTR]], align 4\n-; CHECK-NEXT:    call void @foo(i64 [[INDVARS_IV]])\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n+; CHECK-NEXT:    [[INDVARS:%.*]] = trunc i64 [[INDVARS_IV_NEXT]] to i32\n+; CHECK-NEXT:    store i32 [[INDVARS]], i32* [[PTR]], align 4\n+; CHECK-NEXT:    call void @foo(i64 [[INDVARS_IV]])\n ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp eq i64 [[INDVARS_IV]], 1000\n ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[EXIT:%.*]], label [[LOOP]]\n ; CHECK:       exit:\n@@ -85,12 +84,12 @@ define void @two_non_local_loads(i32* %ptr1) {\n ; CHECK-NEXT:    br label [[LOOP:%.*]]\n ; CHECK:       loop:\n ; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[LOOP]] ], [ 0, [[ENTRY:%.*]] ]\n-; CHECK-NEXT:    [[VAL2:%.*]] = phi i32 [ [[VAL2_INC:%.*]], [[LOOP]] ], [ 0, [[ENTRY]] ]\n-; CHECK-NEXT:    [[VAL2_INC]] = add nuw nsw i32 [[VAL2]], 1\n-; CHECK-NEXT:    store i32 [[VAL2_INC]], i32* [[PTR1]], align 4\n-; CHECK-NEXT:    store i32 [[VAL2_INC]], i32* [[PTR2]], align 4\n-; CHECK-NEXT:    call void @foo(i64 [[INDVARS_IV]])\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n+; CHECK-NEXT:    [[INDVARS4:%.*]] = trunc i64 [[INDVARS_IV_NEXT]] to i32\n+; CHECK-NEXT:    store i32 [[INDVARS4]], i32* [[PTR1]], align 4\n+; CHECK-NEXT:    [[INDVARS:%.*]] = trunc i64 [[INDVARS_IV_NEXT]] to i32\n+; CHECK-NEXT:    store i32 [[INDVARS]], i32* [[PTR2]], align 4\n+; CHECK-NEXT:    call void @foo(i64 [[INDVARS_IV]])\n ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp eq i64 [[INDVARS_IV]], 1000\n ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[EXIT:%.*]], label [[LOOP]]\n ; CHECK:       exit:"
            },
            {
                "fn": "llvm/test/Transforms/IndVarSimplify/X86/pr27133.ll",
                "patch": "@@ -9,11 +9,11 @@ define i32 @fn2() personality i32 (...)* @__CxxFrameHandler3 {\n ; CHECK-NEXT:    br label [[FOR_COND:%.*]]\n ; CHECK:       for.cond:\n ; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[FOR_INC:%.*]] ], [ 0, [[ENTRY:%.*]] ]\n-; CHECK-NEXT:    [[C_0:%.*]] = phi i32 [ [[INC:%.*]], [[FOR_INC]] ], [ 0, [[ENTRY]] ]\n+; CHECK-NEXT:    [[INDVARS1:%.*]] = trunc i64 [[INDVARS_IV]] to i32\n ; CHECK-NEXT:    invoke void @fn1(i64 [[INDVARS_IV]])\n ; CHECK-NEXT:    to label [[FOR_INC]] unwind label [[CATCH_DISPATCH:%.*]]\n ; CHECK:       catch.dispatch:\n-; CHECK-NEXT:    [[C_0_LCSSA:%.*]] = phi i32 [ [[C_0]], [[FOR_COND]] ]\n+; CHECK-NEXT:    [[C_0_LCSSA:%.*]] = phi i32 [ [[INDVARS1]], [[FOR_COND]] ]\n ; CHECK-NEXT:    [[TMP0:%.*]] = catchswitch within none [label %catch] unwind to caller\n ; CHECK:       catch:\n ; CHECK-NEXT:    [[TMP1:%.*]] = catchpad within [[TMP0]] [i8* null, i32 64, i8* null]\n@@ -22,7 +22,6 @@ define i32 @fn2() personality i32 (...)* @__CxxFrameHandler3 {\n ; CHECK-NEXT:    ret i32 [[C_0_LCSSA]]\n ; CHECK:       for.inc:\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw i64 [[INDVARS_IV]], 1\n-; CHECK-NEXT:    [[INC]] = add nuw nsw i32 [[C_0]], 1\n ; CHECK-NEXT:    br label [[FOR_COND]]\n ;\n entry:"
            },
            {
                "fn": "llvm/test/Transforms/IndVarSimplify/widen-loop-comp.ll",
                "patch": "@@ -103,17 +103,17 @@ define void @test2([8 x i8]* %a, i8* %b, i8 %limit) {\n ; CHECK:       for.cond1.preheader.preheader:\n ; CHECK-NEXT:    br label [[FOR_COND1_PREHEADER:%.*]]\n ; CHECK:       for.cond1.preheader.us:\n-; CHECK-NEXT:    [[INDVARS_IV2:%.*]] = phi i64 [ 0, [[FOR_COND1_PREHEADER_US_PREHEADER]] ], [ [[INDVARS_IV_NEXT3:%.*]], [[FOR_INC13_US:%.*]] ]\n+; CHECK-NEXT:    [[INDVARS_IV3:%.*]] = phi i64 [ 0, [[FOR_COND1_PREHEADER_US_PREHEADER]] ], [ [[INDVARS_IV_NEXT4:%.*]], [[FOR_INC13_US:%.*]] ]\n ; CHECK-NEXT:    br i1 true, label [[FOR_BODY4_LR_PH_US:%.*]], label [[FOR_INC13_US]]\n ; CHECK:       for.inc13.us.loopexit:\n ; CHECK-NEXT:    br label [[FOR_INC13_US]]\n ; CHECK:       for.inc13.us:\n-; CHECK-NEXT:    [[INDVARS_IV_NEXT3]] = add nuw nsw i64 [[INDVARS_IV2]], 1\n-; CHECK-NEXT:    [[EXITCOND4:%.*]] = icmp ne i64 [[INDVARS_IV_NEXT3]], 4\n-; CHECK-NEXT:    br i1 [[EXITCOND4]], label [[FOR_COND1_PREHEADER_US]], label [[FOR_END_LOOPEXIT1:%.*]]\n+; CHECK-NEXT:    [[INDVARS_IV_NEXT4]] = add nuw nsw i64 [[INDVARS_IV3]], 1\n+; CHECK-NEXT:    [[EXITCOND6:%.*]] = icmp ne i64 [[INDVARS_IV_NEXT4]], 4\n+; CHECK-NEXT:    br i1 [[EXITCOND6]], label [[FOR_COND1_PREHEADER_US]], label [[FOR_END_LOOPEXIT1:%.*]]\n ; CHECK:       for.body4.us:\n ; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_BODY4_LR_PH_US]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY4_US:%.*]] ]\n-; CHECK-NEXT:    [[ARRAYIDX6_US:%.*]] = getelementptr inbounds [8 x i8], [8 x i8]* [[A:%.*]], i64 [[INDVARS_IV2]], i64 [[INDVARS_IV]]\n+; CHECK-NEXT:    [[ARRAYIDX6_US:%.*]] = getelementptr inbounds [8 x i8], [8 x i8]* [[A:%.*]], i64 [[INDVARS_IV3]], i64 [[INDVARS_IV]]\n ; CHECK-NEXT:    [[TMP0:%.*]] = load i8, i8* [[ARRAYIDX6_US]], align 1\n ; CHECK-NEXT:    [[IDXPROM7_US:%.*]] = zext i8 [[TMP0]] to i64\n ; CHECK-NEXT:    [[ARRAYIDX8_US:%.*]] = getelementptr inbounds i8, i8* [[B:%.*]], i64 [[IDXPROM7_US]]\n@@ -549,14 +549,14 @@ define i32 @test11(i32 %start, i32* %p, i32* %q) {\n ; CHECK:       loop:\n ; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[BACKEDGE:%.*]] ], [ [[TMP0]], [[ENTRY:%.*]] ]\n ; CHECK-NEXT:    [[TMP1:%.*]] = add nsw i64 [[INDVARS_IV]], -1\n+; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nsw i64 [[INDVARS_IV]], -1\n ; CHECK-NEXT:    [[COND:%.*]] = icmp eq i64 [[INDVARS_IV]], 0\n ; CHECK-NEXT:    br i1 [[COND]], label [[EXIT:%.*]], label [[BACKEDGE]]\n ; CHECK:       backedge:\n ; CHECK-NEXT:    [[STORE_ADDR:%.*]] = getelementptr i32, i32* [[P:%.*]], i64 [[TMP1]]\n ; CHECK-NEXT:    store i32 1, i32* [[STORE_ADDR]], align 4\n ; CHECK-NEXT:    [[STOP:%.*]] = load i32, i32* [[Q:%.*]], align 4\n ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp eq i32 [[STOP]], 0\n-; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nsw i64 [[INDVARS_IV]], -1\n ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[FAILURE:%.*]]\n ; CHECK:       exit:\n ; CHECK-NEXT:    ret i32 0\n@@ -599,11 +599,11 @@ define i32 @test12(i32 %start, i32* %p, i32* %q) {\n ; CHECK-NEXT:    br i1 [[COND]], label [[EXIT:%.*]], label [[BACKEDGE]]\n ; CHECK:       backedge:\n ; CHECK-NEXT:    [[TMP1:%.*]] = add nsw i64 [[INDVARS_IV]], -1\n+; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nsw i64 [[INDVARS_IV]], -1\n ; CHECK-NEXT:    [[STORE_ADDR:%.*]] = getelementptr i32, i32* [[P:%.*]], i64 [[TMP1]]\n ; CHECK-NEXT:    store i32 1, i32* [[STORE_ADDR]], align 4\n ; CHECK-NEXT:    [[STOP:%.*]] = load i32, i32* [[Q:%.*]], align 4\n ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp eq i32 [[STOP]], 0\n-; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nsw i64 [[INDVARS_IV]], -1\n ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[LOOP]], label [[FAILURE:%.*]]\n ; CHECK:       exit:\n ; CHECK-NEXT:    ret i32 0\n@@ -862,8 +862,8 @@ define i32 @test16_unsigned_pos1(i32 %start, i32* %p, i32* %q, i32 %x) {\n ; CHECK-NEXT:    [[TMP3:%.*]] = add nsw i64 [[INDVARS_IV]], -1\n ; CHECK-NEXT:    br i1 [[COND]], label [[EXIT:%.*]], label [[GUARDED:%.*]]\n ; CHECK:       guarded:\n-; CHECK-NEXT:    [[ICMP_USER_WIDE4:%.*]] = icmp ult i64 [[TMP1]], [[TMP2]]\n-; CHECK-NEXT:    br i1 [[ICMP_USER_WIDE4]], label [[BACKEDGE]], label [[SIDE_EXIT:%.*]]\n+; CHECK-NEXT:    [[ICMP_USER_WIDE5:%.*]] = icmp ult i64 [[TMP1]], [[TMP2]]\n+; CHECK-NEXT:    br i1 [[ICMP_USER_WIDE5]], label [[BACKEDGE]], label [[SIDE_EXIT:%.*]]\n ; CHECK:       backedge:\n ; CHECK-NEXT:    [[STORE_ADDR:%.*]] = getelementptr i32, i32* [[P:%.*]], i64 [[TMP3]]\n ; CHECK-NEXT:    store i32 1, i32* [[STORE_ADDR]], align 4\n@@ -1266,13 +1266,13 @@ define i32 @test17(i32* %p, i32 %len) {\n ; CHECK:       loop:\n ; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[BACKEDGE:%.*]] ], [ [[TMP0]], [[ENTRY:%.*]] ]\n ; CHECK-NEXT:    [[TMP1:%.*]] = add nsw i64 [[INDVARS_IV]], -1\n+; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nsw i64 [[INDVARS_IV]], -1\n ; CHECK-NEXT:    [[COND_1:%.*]] = icmp eq i64 [[INDVARS_IV]], 0\n ; CHECK-NEXT:    br i1 [[COND_1]], label [[EXIT:%.*]], label [[BACKEDGE]]\n ; CHECK:       backedge:\n ; CHECK-NEXT:    [[ADDR:%.*]] = getelementptr inbounds i32, i32* [[P:%.*]], i64 [[TMP1]]\n ; CHECK-NEXT:    [[LOADED:%.*]] = load atomic i32, i32* [[ADDR]] unordered, align 4\n ; CHECK-NEXT:    [[COND_2:%.*]] = icmp eq i32 [[LOADED]], 0\n-; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nsw i64 [[INDVARS_IV]], -1\n ; CHECK-NEXT:    br i1 [[COND_2]], label [[FAILURE:%.*]], label [[LOOP]]\n ; CHECK:       exit:\n ; CHECK-NEXT:    [[TMP2:%.*]] = trunc i64 -1 to i32\n@@ -1312,10 +1312,9 @@ define void @test18() {\n ; CHECK-NEXT:    br label [[LOOP:%.*]]\n ; CHECK:       loop:\n ; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[LOOP]] ], [ 0, [[ENTRY:%.*]] ]\n-; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[IV_NEXT:%.*]], [[LOOP]] ], [ 0, [[ENTRY]] ]\n-; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n-; CHECK-NEXT:    call void @bar(i32 [[IV_NEXT]])\n+; CHECK-NEXT:    [[INDVARS2:%.*]] = trunc i64 [[INDVARS_IV_NEXT]] to i32\n+; CHECK-NEXT:    call void @bar(i32 [[INDVARS2]])\n ; CHECK-NEXT:    call void @foo(i64 [[INDVARS_IV]])\n ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp eq i64 [[INDVARS_IV]], 1000\n ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[EXIT:%.*]], label [[LOOP]]\n@@ -1412,11 +1411,10 @@ define void @test21(i32* %ptr) {\n ; CHECK-NEXT:    br label [[LOOP:%.*]]\n ; CHECK:       loop:\n ; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[LOOP]] ], [ 0, [[ENTRY:%.*]] ]\n-; CHECK-NEXT:    [[VAL:%.*]] = phi i32 [ [[VAL_INC:%.*]], [[LOOP]] ], [ 0, [[ENTRY]] ]\n-; CHECK-NEXT:    [[VAL_INC]] = add nuw nsw i32 [[VAL]], 1\n-; CHECK-NEXT:    store i32 [[VAL_INC]], i32* [[PTR]], align 4\n-; CHECK-NEXT:    call void @foo(i64 [[INDVARS_IV]])\n ; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1\n+; CHECK-NEXT:    [[INDVARS:%.*]] = trunc i64 [[INDVARS_IV_NEXT]] to i32\n+; CHECK-NEXT:    store i32 [[INDVARS]], i32* [[PTR]], align 4\n+; CHECK-NEXT:    call void @foo(i64 [[INDVARS_IV]])\n ; CHECK-NEXT:    [[LOOP_COND:%.*]] = icmp eq i64 [[INDVARS_IV]], 1000\n ; CHECK-NEXT:    br i1 [[LOOP_COND]], label [[EXIT:%.*]], label [[LOOP]]\n ; CHECK:       exit:"
            },
            {
                "fn": "llvm/test/Transforms/PhaseOrdering/X86/pixel-splat.ll",
                "patch": "@@ -26,7 +26,7 @@ define void @loop_or(i8* noalias %pIn, i32* noalias %pOut, i32 %s) {\n ; CHECK:       for.body.preheader:\n ; CHECK-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[S]] to i64\n ; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i32 [[S]], 8\n-; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[FOR_BODY_PREHEADER4:%.*]], label [[VECTOR_PH:%.*]]\n+; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[FOR_BODY_PREHEADER5:%.*]], label [[VECTOR_PH:%.*]]\n ; CHECK:       vector.ph:\n ; CHECK-NEXT:    [[N_VEC:%.*]] = and i64 [[WIDE_TRIP_COUNT]], 4294967288\n ; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]\n@@ -37,9 +37,9 @@ define void @loop_or(i8* noalias %pIn, i32* noalias %pOut, i32 %s) {\n ; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x i8>, <4 x i8>* [[TMP1]], align 1\n ; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, i8* [[TMP0]], i64 4\n ; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i8* [[TMP2]] to <4 x i8>*\n-; CHECK-NEXT:    [[WIDE_LOAD3:%.*]] = load <4 x i8>, <4 x i8>* [[TMP3]], align 1\n+; CHECK-NEXT:    [[WIDE_LOAD4:%.*]] = load <4 x i8>, <4 x i8>* [[TMP3]], align 1\n ; CHECK-NEXT:    [[TMP4:%.*]] = zext <4 x i8> [[WIDE_LOAD]] to <4 x i32>\n-; CHECK-NEXT:    [[TMP5:%.*]] = zext <4 x i8> [[WIDE_LOAD3]] to <4 x i32>\n+; CHECK-NEXT:    [[TMP5:%.*]] = zext <4 x i8> [[WIDE_LOAD4]] to <4 x i32>\n ; CHECK-NEXT:    [[TMP6:%.*]] = mul nuw nsw <4 x i32> [[TMP4]], <i32 65792, i32 65792, i32 65792, i32 65792>\n ; CHECK-NEXT:    [[TMP7:%.*]] = mul nuw nsw <4 x i32> [[TMP5]], <i32 65792, i32 65792, i32 65792, i32 65792>\n ; CHECK-NEXT:    [[TMP8:%.*]] = or <4 x i32> [[TMP4]], <i32 -16777216, i32 -16777216, i32 -16777216, i32 -16777216>\n@@ -57,12 +57,12 @@ define void @loop_or(i8* noalias %pIn, i32* noalias %pOut, i32 %s) {\n ; CHECK-NEXT:    br i1 [[TMP16]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP0:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N_VEC]], [[WIDE_TRIP_COUNT]]\n-; CHECK-NEXT:    br i1 [[CMP_N]], label [[FOR_END]], label [[FOR_BODY_PREHEADER4]]\n-; CHECK:       for.body.preheader4:\n+; CHECK-NEXT:    br i1 [[CMP_N]], label [[FOR_END]], label [[FOR_BODY_PREHEADER5]]\n+; CHECK:       for.body.preheader5:\n ; CHECK-NEXT:    [[INDVARS_IV_PH:%.*]] = phi i64 [ 0, [[FOR_BODY_PREHEADER]] ], [ [[N_VEC]], [[MIDDLE_BLOCK]] ]\n ; CHECK-NEXT:    br label [[FOR_BODY:%.*]]\n ; CHECK:       for.body:\n-; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ], [ [[INDVARS_IV_PH]], [[FOR_BODY_PREHEADER4]] ]\n+; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ], [ [[INDVARS_IV_PH]], [[FOR_BODY_PREHEADER5]] ]\n ; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, i8* [[PIN]], i64 [[INDVARS_IV]]\n ; CHECK-NEXT:    [[TMP17:%.*]] = load i8, i8* [[ARRAYIDX]], align 1\n ; CHECK-NEXT:    [[CONV:%.*]] = zext i8 [[TMP17]] to i32"
            },
            {
                "fn": "llvm/test/Transforms/PhaseOrdering/X86/vdiv.ll",
                "patch": "@@ -19,28 +19,28 @@ define void @vdiv(double* %x, double* %y, double %a, i32 %N) #0 {\n ; CHECK:       for.body.preheader:\n ; CHECK-NEXT:    [[WIDE_TRIP_COUNT:%.*]] = zext i32 [[N]] to i64\n ; CHECK-NEXT:    [[MIN_ITERS_CHECK:%.*]] = icmp ult i32 [[N]], 16\n-; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[FOR_BODY_PREHEADER17:%.*]], label [[VECTOR_MEMCHECK:%.*]]\n+; CHECK-NEXT:    br i1 [[MIN_ITERS_CHECK]], label [[FOR_BODY_PREHEADER18:%.*]], label [[VECTOR_MEMCHECK:%.*]]\n ; CHECK:       vector.memcheck:\n ; CHECK-NEXT:    [[SCEVGEP:%.*]] = getelementptr double, double* [[X:%.*]], i64 [[WIDE_TRIP_COUNT]]\n-; CHECK-NEXT:    [[SCEVGEP6:%.*]] = getelementptr double, double* [[Y:%.*]], i64 [[WIDE_TRIP_COUNT]]\n-; CHECK-NEXT:    [[BOUND0:%.*]] = icmp ugt double* [[SCEVGEP6]], [[X]]\n+; CHECK-NEXT:    [[SCEVGEP7:%.*]] = getelementptr double, double* [[Y:%.*]], i64 [[WIDE_TRIP_COUNT]]\n+; CHECK-NEXT:    [[BOUND0:%.*]] = icmp ugt double* [[SCEVGEP7]], [[X]]\n ; CHECK-NEXT:    [[BOUND1:%.*]] = icmp ugt double* [[SCEVGEP]], [[Y]]\n ; CHECK-NEXT:    [[FOUND_CONFLICT:%.*]] = and i1 [[BOUND0]], [[BOUND1]]\n-; CHECK-NEXT:    br i1 [[FOUND_CONFLICT]], label [[FOR_BODY_PREHEADER17]], label [[VECTOR_PH:%.*]]\n+; CHECK-NEXT:    br i1 [[FOUND_CONFLICT]], label [[FOR_BODY_PREHEADER18]], label [[VECTOR_PH:%.*]]\n ; CHECK:       vector.ph:\n ; CHECK-NEXT:    [[N_VEC:%.*]] = and i64 [[WIDE_TRIP_COUNT]], 4294967280\n ; CHECK-NEXT:    [[BROADCAST_SPLATINSERT:%.*]] = insertelement <4 x double> poison, double [[A:%.*]], i32 0\n ; CHECK-NEXT:    [[BROADCAST_SPLAT:%.*]] = shufflevector <4 x double> [[BROADCAST_SPLATINSERT]], <4 x double> poison, <4 x i32> zeroinitializer\n-; CHECK-NEXT:    [[BROADCAST_SPLATINSERT11:%.*]] = insertelement <4 x double> poison, double [[A]], i32 0\n-; CHECK-NEXT:    [[BROADCAST_SPLAT12:%.*]] = shufflevector <4 x double> [[BROADCAST_SPLATINSERT11]], <4 x double> poison, <4 x i32> zeroinitializer\n-; CHECK-NEXT:    [[BROADCAST_SPLATINSERT13:%.*]] = insertelement <4 x double> poison, double [[A]], i32 0\n-; CHECK-NEXT:    [[BROADCAST_SPLAT14:%.*]] = shufflevector <4 x double> [[BROADCAST_SPLATINSERT13]], <4 x double> poison, <4 x i32> zeroinitializer\n-; CHECK-NEXT:    [[BROADCAST_SPLATINSERT15:%.*]] = insertelement <4 x double> poison, double [[A]], i32 0\n-; CHECK-NEXT:    [[BROADCAST_SPLAT16:%.*]] = shufflevector <4 x double> [[BROADCAST_SPLATINSERT15]], <4 x double> poison, <4 x i32> zeroinitializer\n+; CHECK-NEXT:    [[BROADCAST_SPLATINSERT12:%.*]] = insertelement <4 x double> poison, double [[A]], i32 0\n+; CHECK-NEXT:    [[BROADCAST_SPLAT13:%.*]] = shufflevector <4 x double> [[BROADCAST_SPLATINSERT12]], <4 x double> poison, <4 x i32> zeroinitializer\n+; CHECK-NEXT:    [[BROADCAST_SPLATINSERT14:%.*]] = insertelement <4 x double> poison, double [[A]], i32 0\n+; CHECK-NEXT:    [[BROADCAST_SPLAT15:%.*]] = shufflevector <4 x double> [[BROADCAST_SPLATINSERT14]], <4 x double> poison, <4 x i32> zeroinitializer\n+; CHECK-NEXT:    [[BROADCAST_SPLATINSERT16:%.*]] = insertelement <4 x double> poison, double [[A]], i32 0\n+; CHECK-NEXT:    [[BROADCAST_SPLAT17:%.*]] = shufflevector <4 x double> [[BROADCAST_SPLATINSERT16]], <4 x double> poison, <4 x i32> zeroinitializer\n ; CHECK-NEXT:    [[TMP0:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT]]\n-; CHECK-NEXT:    [[TMP1:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT12]]\n-; CHECK-NEXT:    [[TMP2:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT14]]\n-; CHECK-NEXT:    [[TMP3:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT16]]\n+; CHECK-NEXT:    [[TMP1:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT13]]\n+; CHECK-NEXT:    [[TMP2:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT15]]\n+; CHECK-NEXT:    [[TMP3:%.*]] = fdiv fast <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>, [[BROADCAST_SPLAT17]]\n ; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]\n ; CHECK:       vector.body:\n ; CHECK-NEXT:    [[INDEX:%.*]] = phi i64 [ 0, [[VECTOR_PH]] ], [ [[INDEX_NEXT:%.*]], [[VECTOR_BODY]] ]\n@@ -49,17 +49,17 @@ define void @vdiv(double* %x, double* %y, double %a, i32 %N) #0 {\n ; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <4 x double>, <4 x double>* [[TMP5]], align 8, !tbaa [[TBAA3:![0-9]+]], !alias.scope !7\n ; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds double, double* [[TMP4]], i64 4\n ; CHECK-NEXT:    [[TMP7:%.*]] = bitcast double* [[TMP6]] to <4 x double>*\n-; CHECK-NEXT:    [[WIDE_LOAD8:%.*]] = load <4 x double>, <4 x double>* [[TMP7]], align 8, !tbaa [[TBAA3]], !alias.scope !7\n+; CHECK-NEXT:    [[WIDE_LOAD9:%.*]] = load <4 x double>, <4 x double>* [[TMP7]], align 8, !tbaa [[TBAA3]], !alias.scope !7\n ; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds double, double* [[TMP4]], i64 8\n ; CHECK-NEXT:    [[TMP9:%.*]] = bitcast double* [[TMP8]] to <4 x double>*\n-; CHECK-NEXT:    [[WIDE_LOAD9:%.*]] = load <4 x double>, <4 x double>* [[TMP9]], align 8, !tbaa [[TBAA3]], !alias.scope !7\n+; CHECK-NEXT:    [[WIDE_LOAD10:%.*]] = load <4 x double>, <4 x double>* [[TMP9]], align 8, !tbaa [[TBAA3]], !alias.scope !7\n ; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds double, double* [[TMP4]], i64 12\n ; CHECK-NEXT:    [[TMP11:%.*]] = bitcast double* [[TMP10]] to <4 x double>*\n-; CHECK-NEXT:    [[WIDE_LOAD10:%.*]] = load <4 x double>, <4 x double>* [[TMP11]], align 8, !tbaa [[TBAA3]], !alias.scope !7\n+; CHECK-NEXT:    [[WIDE_LOAD11:%.*]] = load <4 x double>, <4 x double>* [[TMP11]], align 8, !tbaa [[TBAA3]], !alias.scope !7\n ; CHECK-NEXT:    [[TMP12:%.*]] = fmul fast <4 x double> [[WIDE_LOAD]], [[TMP0]]\n-; CHECK-NEXT:    [[TMP13:%.*]] = fmul fast <4 x double> [[WIDE_LOAD8]], [[TMP1]]\n-; CHECK-NEXT:    [[TMP14:%.*]] = fmul fast <4 x double> [[WIDE_LOAD9]], [[TMP2]]\n-; CHECK-NEXT:    [[TMP15:%.*]] = fmul fast <4 x double> [[WIDE_LOAD10]], [[TMP3]]\n+; CHECK-NEXT:    [[TMP13:%.*]] = fmul fast <4 x double> [[WIDE_LOAD9]], [[TMP1]]\n+; CHECK-NEXT:    [[TMP14:%.*]] = fmul fast <4 x double> [[WIDE_LOAD10]], [[TMP2]]\n+; CHECK-NEXT:    [[TMP15:%.*]] = fmul fast <4 x double> [[WIDE_LOAD11]], [[TMP3]]\n ; CHECK-NEXT:    [[TMP16:%.*]] = getelementptr inbounds double, double* [[X]], i64 [[INDEX]]\n ; CHECK-NEXT:    [[TMP17:%.*]] = bitcast double* [[TMP16]] to <4 x double>*\n ; CHECK-NEXT:    store <4 x double> [[TMP12]], <4 x double>* [[TMP17]], align 8, !tbaa [[TBAA3]], !alias.scope !10, !noalias !7\n@@ -77,8 +77,8 @@ define void @vdiv(double* %x, double* %y, double %a, i32 %N) #0 {\n ; CHECK-NEXT:    br i1 [[TMP24]], label [[MIDDLE_BLOCK:%.*]], label [[VECTOR_BODY]], !llvm.loop [[LOOP12:![0-9]+]]\n ; CHECK:       middle.block:\n ; CHECK-NEXT:    [[CMP_N:%.*]] = icmp eq i64 [[N_VEC]], [[WIDE_TRIP_COUNT]]\n-; CHECK-NEXT:    br i1 [[CMP_N]], label [[FOR_END]], label [[FOR_BODY_PREHEADER17]]\n-; CHECK:       for.body.preheader17:\n+; CHECK-NEXT:    br i1 [[CMP_N]], label [[FOR_END]], label [[FOR_BODY_PREHEADER18]]\n+; CHECK:       for.body.preheader18:\n ; CHECK-NEXT:    [[INDVARS_IV_PH:%.*]] = phi i64 [ 0, [[VECTOR_MEMCHECK]] ], [ 0, [[FOR_BODY_PREHEADER]] ], [ [[N_VEC]], [[MIDDLE_BLOCK]] ]\n ; CHECK-NEXT:    [[TMP25:%.*]] = xor i64 [[INDVARS_IV_PH]], -1\n ; CHECK-NEXT:    [[TMP26:%.*]] = add nsw i64 [[TMP25]], [[WIDE_TRIP_COUNT]]\n@@ -101,17 +101,17 @@ define void @vdiv(double* %x, double* %y, double %a, i32 %N) #0 {\n ; CHECK-NEXT:    [[PROL_ITER_CMP_NOT:%.*]] = icmp eq i64 [[PROL_ITER_SUB]], 0\n ; CHECK-NEXT:    br i1 [[PROL_ITER_CMP_NOT]], label [[FOR_BODY_PROL_LOOPEXIT]], label [[FOR_BODY_PROL]], !llvm.loop [[LOOP14:![0-9]+]]\n ; CHECK:       for.body.prol.loopexit:\n-; CHECK-NEXT:    [[INDVARS_IV_UNR:%.*]] = phi i64 [ [[INDVARS_IV_PH]], [[FOR_BODY_PREHEADER17]] ], [ [[INDVARS_IV_NEXT_PROL]], [[FOR_BODY_PROL]] ]\n+; CHECK-NEXT:    [[INDVARS_IV_UNR:%.*]] = phi i64 [ [[INDVARS_IV_PH]], [[FOR_BODY_PREHEADER18]] ], [ [[INDVARS_IV_NEXT_PROL]], [[FOR_BODY_PROL]] ]\n ; CHECK-NEXT:    [[TMP29:%.*]] = icmp ult i64 [[TMP26]], 3\n-; CHECK-NEXT:    br i1 [[TMP29]], label [[FOR_END]], label [[FOR_BODY_PREHEADER17_NEW:%.*]]\n-; CHECK:       for.body.preheader17.new:\n+; CHECK-NEXT:    br i1 [[TMP29]], label [[FOR_END]], label [[FOR_BODY_PREHEADER18_NEW:%.*]]\n+; CHECK:       for.body.preheader18.new:\n ; CHECK-NEXT:    [[TMP30:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n ; CHECK-NEXT:    [[TMP31:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n ; CHECK-NEXT:    [[TMP32:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n ; CHECK-NEXT:    [[TMP33:%.*]] = fdiv fast double 1.000000e+00, [[A]]\n ; CHECK-NEXT:    br label [[FOR_BODY:%.*]]\n ; CHECK:       for.body:\n-; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_UNR]], [[FOR_BODY_PREHEADER17_NEW]] ], [ [[INDVARS_IV_NEXT_3:%.*]], [[FOR_BODY]] ]\n+; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ [[INDVARS_IV_UNR]], [[FOR_BODY_PREHEADER18_NEW]] ], [ [[INDVARS_IV_NEXT_3:%.*]], [[FOR_BODY]] ]\n ; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds double, double* [[Y]], i64 [[INDVARS_IV]]\n ; CHECK-NEXT:    [[T0:%.*]] = load double, double* [[ARRAYIDX]], align 8, !tbaa [[TBAA3]]\n ; CHECK-NEXT:    [[TMP34:%.*]] = fmul fast double [[T0]], [[TMP30]]"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/LoopVectorize/X86/gather_scatter.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/X86/gather_scatter.ll\n\n\nTesting Time: 3.98s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/IndVarSimplify/X86/pr27133.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/IndVarSimplify/X86/pr27133.ll\n\n\nTesting Time: 0.12s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/PhaseOrdering/X86/pixel-splat.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/PhaseOrdering/X86/pixel-splat.ll\n\n\nTesting Time: 0.16s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/PhaseOrdering/X86/vdiv.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/PhaseOrdering/X86/vdiv.ll\n\n\nTesting Time: 0.23s\n  Failed: 1\n"
    },
    "b6a41fddcfd375ce30487ef87ca2cd65a6be0bcc___DwarfCompileUnit.cpp": {
        "prefix": "void DwarfCompileUnit::createBaseTypeDIEs() {\n  // Insert the base_type DIEs directly after the CU so that their offsets will\n  // fit in the fixed size ULEB128 used inside the location expressions.\n  // Maintain order by iterating backwards and inserting to the front of CU\n  // child list.\n  for (auto &Btr : reverse(ExprRefedBaseTypes)) {\n    DIE &Die = getUnitDie().addChildFront(\n      DIE::get(DIEValueAllocator, dwarf::DW_TAG_base_type));\n    SmallString<32> Str;\n    addString(Die, dwarf::DW_AT_name,\n              Twine(dwarf::AttributeEncodingString(Btr.Encoding) +\n                    \"_\" + Twine(Btr.BitSize)).toStringRef(Str));\n    addUInt(Die, dwarf::DW_AT_encoding, dwarf::DW_FORM_data1, Btr.Encoding);\n",
        "suffix": "\n    Btr.Die = &Die;\n  }\n}\n",
        "start": 1571,
        "end": 1588,
        "buggy": "void DwarfCompileUnit::createBaseTypeDIEs() {\n  // Insert the base_type DIEs directly after the CU so that their offsets will\n  // fit in the fixed size ULEB128 used inside the location expressions.\n  // Maintain order by iterating backwards and inserting to the front of CU\n  // child list.\n  for (auto &Btr : reverse(ExprRefedBaseTypes)) {\n    DIE &Die = getUnitDie().addChildFront(\n      DIE::get(DIEValueAllocator, dwarf::DW_TAG_base_type));\n    SmallString<32> Str;\n    addString(Die, dwarf::DW_AT_name,\n              Twine(dwarf::AttributeEncodingString(Btr.Encoding) +\n                    \"_\" + Twine(Btr.BitSize)).toStringRef(Str));\n    addUInt(Die, dwarf::DW_AT_encoding, dwarf::DW_FORM_data1, Btr.Encoding);\n    addUInt(Die, dwarf::DW_AT_byte_size, None, Btr.BitSize / 8);\n\n    Btr.Die = &Die;\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    addUInt(Die, dwarf::DW_AT_byte_size, None, Btr.BitSize / 8);\n",
        "src_path": "b6a41fddcfd375ce30487ef87ca2cd65a6be0bcc___DwarfCompileUnit.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/b6a41fddcfd375ce30487ef87ca2cd65a6be0bcc",
        "commit_msg": "[DWARF][DebugInfo] Fix off-by-one error in size of DW_TAG_base_type types\n\nFix PR53163 by rounding the byte size of DW_TAG_base_type types up. Without\nthis fix we risk emitting types with a truncated size (including rounding\nless-than-byte-sized types' sizes down to zero).\n\nReviewed By: probinson\n\nDifferential Revision: https://reviews.llvm.org/D117124",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/X86/base-type-size.ll",
                "patch": "@@ -0,0 +1,50 @@\n+; RUN: llc %s --filetype=obj -o - | llvm-dwarfdump - -o - | FileCheck %s\n+\n+;; cat test.cpp\n+;; void ext(bool);\n+;; void fun(bool b) { ext(b); }\n+;; $ clang++ test.cpp -o - -emit-llvm -S -O2 -gdwarf-5\n+;;\n+;; Check that the DW_TAG_base_type DIE for the 1u conversion in the DIExpression\n+;; has a non-zero DW_AT_byte_size attribute.\n+\n+; CHECK: DW_TAG_base_type\n+; CHECK-NEXT: DW_AT_name      (\"DW_ATE_unsigned_1\")\n+; CHECK-NEXT: DW_AT_encoding  (DW_ATE_unsigned)\n+; CHECK-NEXT: DW_AT_byte_size (0x01)\n+\n+target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n+target triple = \"x86_64-unknown-linux-gnu\"\n+\n+define dso_local void @_Z3funb(i1 zeroext %b) local_unnamed_addr #0 !dbg !7 {\n+entry:\n+  call void @llvm.dbg.value(metadata i1 %b, metadata !12, metadata !DIExpression(DW_OP_LLVM_convert, 1, DW_ATE_unsigned, DW_OP_LLVM_convert, 8, DW_ATE_unsigned, DW_OP_stack_value)), !dbg !13\n+  tail call void @_Z3extb(i1 zeroext %b), !dbg !14\n+  ret void, !dbg !15\n+}\n+\n+declare !dbg !16 dso_local void @_Z3extb(i1 zeroext) local_unnamed_addr\n+declare void @llvm.dbg.value(metadata, metadata, metadata)\n+\n+!llvm.dbg.cu = !{!0}\n+!llvm.module.flags = !{!2, !3, !4, !5}\n+!llvm.ident = !{!6}\n+\n+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus_14, file: !1, producer: \"clang version 14.0.0\", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, splitDebugInlining: false, nameTableKind: None)\n+!1 = !DIFile(filename: \"test.cpp\", directory: \"/\")\n+!2 = !{i32 7, !\"Dwarf Version\", i32 5}\n+!3 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!4 = !{i32 1, !\"wchar_size\", i32 4}\n+!5 = !{i32 7, !\"uwtable\", i32 1}\n+!6 = !{!\"clang version 14.0.0\"}\n+!7 = distinct !DISubprogram(name: \"fun\", linkageName: \"_Z3funb\", scope: !1, file: !1, line: 2, type: !8, scopeLine: 2, flags: DIFlagPrototyped | DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !11)\n+!8 = !DISubroutineType(types: !9)\n+!9 = !{null, !10}\n+!10 = !DIBasicType(name: \"bool\", size: 8, encoding: DW_ATE_boolean)\n+!11 = !{!12}\n+!12 = !DILocalVariable(name: \"b\", arg: 1, scope: !7, file: !1, line: 2, type: !10)\n+!13 = !DILocation(line: 0, scope: !7)\n+!14 = !DILocation(line: 2, column: 20, scope: !7)\n+!15 = !DILocation(line: 2, column: 28, scope: !7)\n+!16 = !DISubprogram(name: \"ext\", linkageName: \"_Z3extb\", scope: !1, file: !1, line: 1, type: !8, flags: DIFlagPrototyped, spFlags: DISPFlagOptimized, retainedNodes: !17)\n+!17 = !{}"
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/X86/base-type-size.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: DebugInfo/X86/base-type-size.ll\n\n\nTesting Time: 0.35s\n  Failed: 1\n"
    },
    "0e74d75a295729bc145724ffa0495fee4d1b598c___StructurizeCFG.cpp": {
        "prefix": "bool StructurizeCFG::run(Region *R, DominatorTree *DT) {\n  if (R->isTopLevelRegion())\n    return false;\n\n  this->DT = DT;\n\n  Func = R->getEntry()->getParent();\n  ParentRegion = R;\n\n  orderNodes();\n  collectInfos();\n  createFlow();\n  insertConditions(false);\n  insertConditions(true);\n",
        "suffix": "  setPhiValues();\n  simplifyAffectedPhis();\n  rebuildSSA();\n\n  // Cleanup\n  Order.clear();\n  Visited.clear();\n  DeletedPhis.clear();\n  AddedPhis.clear();\n  Predicates.clear();\n  Conditions.clear();\n  Loops.clear();\n  LoopPreds.clear();\n  LoopConds.clear();\n\n  return true;\n}\n",
        "start": 1078,
        "end": 1109,
        "buggy": "bool StructurizeCFG::run(Region *R, DominatorTree *DT) {\n  if (R->isTopLevelRegion())\n    return false;\n\n  this->DT = DT;\n\n  Func = R->getEntry()->getParent();\n  ParentRegion = R;\n\n  orderNodes();\n  collectInfos();\n  createFlow();\n  insertConditions(false);\n  insertConditions(true);\n  simplifyConditions();\n  setPhiValues();\n  simplifyAffectedPhis();\n  rebuildSSA();\n\n  // Cleanup\n  Order.clear();\n  Visited.clear();\n  DeletedPhis.clear();\n  AddedPhis.clear();\n  Predicates.clear();\n  Conditions.clear();\n  Loops.clear();\n  LoopPreds.clear();\n  LoopConds.clear();\n\n  return true;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  simplifyConditions();\n",
        "src_path": "0e74d75a295729bc145724ffa0495fee4d1b598c___StructurizeCFG.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/0e74d75a295729bc145724ffa0495fee4d1b598c",
        "commit_msg": "[StructurizeCFG] Fix boolean not bug\n\nD118623 added code to fold not-of-compare into a compare\nwith the inverted predicate, if the compare had no other\nuses. This relies on accurate use lists in the IR but it\nwas run before setPhiValues, when some phi inputs are still\nstored in a data structure on the side, instead of being\nreal uses in the IR. The effect was that a phi that should\nbe using the original compare result would now get an\ninverted result instead.\n\nFix this by moving simplifyConditions after setPhiValues.\n\nDifferential Revision: https://reviews.llvm.org/D120312",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/StructurizeCFG/invert-condition.ll",
                "patch": "@@ -29,13 +29,12 @@ bb5:                                              ; preds = %bb2\n   ret void\n }\n \n-; FIXME: StructurizeCFG modifies I5 in-place without updating the use of I5 in\n-; the phi instruction.\n define void @invert_condition_phi(i32 %arg) {\n ; CHECK-LABEL: @invert_condition_phi(\n ; CHECK-NEXT:  main_body:\n-; CHECK-NEXT:    [[I5:%.*]] = icmp ne i32 [[ARG:%.*]], 0\n-; CHECK-NEXT:    br i1 [[I5]], label [[IF1:%.*]], label [[ENDIF1:%.*]]\n+; CHECK-NEXT:    [[I5:%.*]] = icmp eq i32 [[ARG:%.*]], 0\n+; CHECK-NEXT:    [[I5_INV:%.*]] = xor i1 [[I5]], true\n+; CHECK-NEXT:    br i1 [[I5_INV]], label [[IF1:%.*]], label [[ENDIF1:%.*]]\n ; CHECK:       if1:\n ; CHECK-NEXT:    br label [[ENDIF1]]\n ; CHECK:       endif1:"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/StructurizeCFG/invert-condition.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/StructurizeCFG/invert-condition.ll\n\n\nTesting Time: 0.30s\n  Failed: 1\n"
    },
    "a5c3b5748c1176c11bdc041271ead5392295742d___MemCpyOptimizer.cpp": {
        "prefix": "bool MemCpyOptPass::processMemCpy(MemCpyInst *M, BasicBlock::iterator &BBI) {\n  // We can only optimize non-volatile memcpy's.\n  if (M->isVolatile()) return false;\n\n  // If the source and destination of the memcpy are the same, then zap it.\n  if (M->getSource() == M->getDest()) {\n    ++BBI;\n    eraseInstruction(M);\n    return true;\n  }\n\n  // If copying from a constant, try to turn the memcpy into a memset.\n  if (auto *GV = dyn_cast<GlobalVariable>(M->getSource()))\n    if (GV->isConstant() && GV->hasDefinitiveInitializer())\n      if (Value *ByteVal = isBytewiseValue(GV->getInitializer(),\n                                           M->getModule()->getDataLayout())) {\n        IRBuilder<> Builder(M);\n        Instruction *NewM =\n            Builder.CreateMemSet(M->getRawDest(), ByteVal, M->getLength(),\n                                 MaybeAlign(M->getDestAlignment()), false);\n        auto *LastDef =\n            cast<MemoryDef>(MSSAU->getMemorySSA()->getMemoryAccess(M));\n        auto *NewAccess =\n            MSSAU->createMemoryAccessAfter(NewM, LastDef, LastDef);\n        MSSAU->insertDef(cast<MemoryDef>(NewAccess), /*RenameUses=*/true);\n\n        eraseInstruction(M);\n        ++NumCpyToSet;\n        return true;\n      }\n\n  MemoryUseOrDef *MA = MSSA->getMemoryAccess(M);\n",
        "suffix": "  MemoryLocation DestLoc = MemoryLocation::getForDest(M);\n  const MemoryAccess *DestClobber =\n      MSSA->getWalker()->getClobberingMemoryAccess(AnyClobber, DestLoc);\n\n  // Try to turn a partially redundant memset + memcpy into\n  // memcpy + smaller memset.  We don't need the memcpy size for this.\n  // The memcpy most post-dom the memset, so limit this to the same basic\n  // block. A non-local generalization is likely not worthwhile.\n  if (auto *MD = dyn_cast<MemoryDef>(DestClobber))\n    if (auto *MDep = dyn_cast_or_null<MemSetInst>(MD->getMemoryInst()))\n      if (DestClobber->getBlock() == M->getParent())\n        if (processMemSetMemCpyDependence(M, MDep))\n          return true;\n\n  MemoryAccess *SrcClobber = MSSA->getWalker()->getClobberingMemoryAccess(\n      AnyClobber, MemoryLocation::getForSource(M));\n\n  // There are four possible optimizations we can do for memcpy:\n  //   a) memcpy-memcpy xform which exposes redundance for DSE.\n  //   b) call-memcpy xform for return slot optimization.\n  //   c) memcpy from freshly alloca'd space or space that has just started\n  //      its lifetime copies undefined data, and we can therefore eliminate\n  //      the memcpy in favor of the data that was already at the destination.\n  //   d) memcpy from a just-memset'd source can be turned into memset.\n  if (auto *MD = dyn_cast<MemoryDef>(SrcClobber)) {\n    if (Instruction *MI = MD->getMemoryInst()) {\n      if (auto *CopySize = dyn_cast<ConstantInt>(M->getLength())) {\n        if (auto *C = dyn_cast<CallInst>(MI)) {\n          // FIXME: Can we pass in either of dest/src alignment here instead\n          // of conservatively taking the minimum?\n          Align Alignment = std::min(M->getDestAlign().valueOrOne(),\n                                     M->getSourceAlign().valueOrOne());\n          if (performCallSlotOptzn(\n                  M, M, M->getDest(), M->getSource(),\n                  TypeSize::getFixed(CopySize->getZExtValue()), Alignment,\n                  [C]() -> CallInst * { return C; })) {\n            LLVM_DEBUG(dbgs() << \"Performed call slot optimization:\\n\"\n                              << \"    call: \" << *C << \"\\n\"\n                              << \"    memcpy: \" << *M << \"\\n\");\n            eraseInstruction(M);\n            ++NumMemCpyInstr;\n            return true;\n          }\n        }\n      }\n      if (auto *MDep = dyn_cast<MemCpyInst>(MI))\n        return processMemCpyMemCpyDependence(M, MDep);\n      if (auto *MDep = dyn_cast<MemSetInst>(MI)) {\n        if (performMemCpyToMemSetOptzn(M, MDep)) {\n          LLVM_DEBUG(dbgs() << \"Converted memcpy to memset\\n\");\n          eraseInstruction(M);\n          ++NumCpyToSet;\n          return true;\n        }\n      }\n    }\n\n    if (hasUndefContents(MSSA, AA, M->getSource(), MD, M->getLength())) {\n      LLVM_DEBUG(dbgs() << \"Removed memcpy from undef\\n\");\n      eraseInstruction(M);\n      ++NumMemCpyInstr;\n      return true;\n    }\n  }\n\n  return false;\n}\n",
        "start": 1398,
        "end": 1497,
        "buggy": "bool MemCpyOptPass::processMemCpy(MemCpyInst *M, BasicBlock::iterator &BBI) {\n  // We can only optimize non-volatile memcpy's.\n  if (M->isVolatile()) return false;\n\n  // If the source and destination of the memcpy are the same, then zap it.\n  if (M->getSource() == M->getDest()) {\n    ++BBI;\n    eraseInstruction(M);\n    return true;\n  }\n\n  // If copying from a constant, try to turn the memcpy into a memset.\n  if (auto *GV = dyn_cast<GlobalVariable>(M->getSource()))\n    if (GV->isConstant() && GV->hasDefinitiveInitializer())\n      if (Value *ByteVal = isBytewiseValue(GV->getInitializer(),\n                                           M->getModule()->getDataLayout())) {\n        IRBuilder<> Builder(M);\n        Instruction *NewM =\n            Builder.CreateMemSet(M->getRawDest(), ByteVal, M->getLength(),\n                                 MaybeAlign(M->getDestAlignment()), false);\n        auto *LastDef =\n            cast<MemoryDef>(MSSAU->getMemorySSA()->getMemoryAccess(M));\n        auto *NewAccess =\n            MSSAU->createMemoryAccessAfter(NewM, LastDef, LastDef);\n        MSSAU->insertDef(cast<MemoryDef>(NewAccess), /*RenameUses=*/true);\n\n        eraseInstruction(M);\n        ++NumCpyToSet;\n        return true;\n      }\n\n  MemoryUseOrDef *MA = MSSA->getMemoryAccess(M);\n  MemoryAccess *AnyClobber = MSSA->getWalker()->getClobberingMemoryAccess(MA);\n  MemoryLocation DestLoc = MemoryLocation::getForDest(M);\n  const MemoryAccess *DestClobber =\n      MSSA->getWalker()->getClobberingMemoryAccess(AnyClobber, DestLoc);\n\n  // Try to turn a partially redundant memset + memcpy into\n  // memcpy + smaller memset.  We don't need the memcpy size for this.\n  // The memcpy most post-dom the memset, so limit this to the same basic\n  // block. A non-local generalization is likely not worthwhile.\n  if (auto *MD = dyn_cast<MemoryDef>(DestClobber))\n    if (auto *MDep = dyn_cast_or_null<MemSetInst>(MD->getMemoryInst()))\n      if (DestClobber->getBlock() == M->getParent())\n        if (processMemSetMemCpyDependence(M, MDep))\n          return true;\n\n  MemoryAccess *SrcClobber = MSSA->getWalker()->getClobberingMemoryAccess(\n      AnyClobber, MemoryLocation::getForSource(M));\n\n  // There are four possible optimizations we can do for memcpy:\n  //   a) memcpy-memcpy xform which exposes redundance for DSE.\n  //   b) call-memcpy xform for return slot optimization.\n  //   c) memcpy from freshly alloca'd space or space that has just started\n  //      its lifetime copies undefined data, and we can therefore eliminate\n  //      the memcpy in favor of the data that was already at the destination.\n  //   d) memcpy from a just-memset'd source can be turned into memset.\n  if (auto *MD = dyn_cast<MemoryDef>(SrcClobber)) {\n    if (Instruction *MI = MD->getMemoryInst()) {\n      if (auto *CopySize = dyn_cast<ConstantInt>(M->getLength())) {\n        if (auto *C = dyn_cast<CallInst>(MI)) {\n          // FIXME: Can we pass in either of dest/src alignment here instead\n          // of conservatively taking the minimum?\n          Align Alignment = std::min(M->getDestAlign().valueOrOne(),\n                                     M->getSourceAlign().valueOrOne());\n          if (performCallSlotOptzn(\n                  M, M, M->getDest(), M->getSource(),\n                  TypeSize::getFixed(CopySize->getZExtValue()), Alignment,\n                  [C]() -> CallInst * { return C; })) {\n            LLVM_DEBUG(dbgs() << \"Performed call slot optimization:\\n\"\n                              << \"    call: \" << *C << \"\\n\"\n                              << \"    memcpy: \" << *M << \"\\n\");\n            eraseInstruction(M);\n            ++NumMemCpyInstr;\n            return true;\n          }\n        }\n      }\n      if (auto *MDep = dyn_cast<MemCpyInst>(MI))\n        return processMemCpyMemCpyDependence(M, MDep);\n      if (auto *MDep = dyn_cast<MemSetInst>(MI)) {\n        if (performMemCpyToMemSetOptzn(M, MDep)) {\n          LLVM_DEBUG(dbgs() << \"Converted memcpy to memset\\n\");\n          eraseInstruction(M);\n          ++NumCpyToSet;\n          return true;\n        }\n      }\n    }\n\n    if (hasUndefContents(MSSA, AA, M->getSource(), MD, M->getLength())) {\n      LLVM_DEBUG(dbgs() << \"Removed memcpy from undef\\n\");\n      eraseInstruction(M);\n      ++NumMemCpyInstr;\n      return true;\n    }\n  }\n\n  return false;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  MemoryAccess *AnyClobber = MSSA->getWalker()->getClobberingMemoryAccess(MA);\n",
        "src_path": "a5c3b5748c1176c11bdc041271ead5392295742d___MemCpyOptimizer.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/a5c3b5748c1176c11bdc041271ead5392295742d",
        "commit_msg": "[MemCpyOpt] Work around PR54682\n\nAs discussed on https://github.com/llvm/llvm-project/issues/54682,\nMemorySSA currently has a bug when computing the clobber of calls\nthat access loop-varying locations. I think a \"proper\" fix for this\non the MemorySSA side might be non-trivial, but we can easily work\naround this in MemCpyOpt:\n\nCurrently, MemCpyOpt uses a location-less getClobberingMemoryAccess()\ncall to find a clobber on either the src or dest location, and then\nrefines it for the src and dest clobber. This was intended as an\noptimization, as the location-less API is cached, while the\nlocation-affected APIs are not.\n\nHowever, I don't think this really makes a difference in practice,\nbecause I don't think anything will use the cached clobbers on\nthose calls later anyway. On CTMark, this patch seems to be very\nmildly positive actually.\n\nSo I think this is a reasonable way to avoid the problem for now,\nthough MemorySSA should also get a fix.\n\nDifferential Revision: https://reviews.llvm.org/D122911",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/MemCpyOpt/pr54682.ll",
                "patch": "@@ -1,7 +1,8 @@\n ; NOTE: Assertions have been autogenerated by utils/update_test_checks.py\n ; RUN: opt -S -memcpyopt < %s | FileCheck %s\n \n-; FIXME: This currently gets miscompiled.\n+; The memcpy here is *not* dead, because it reads memory written in a previous\n+; loop iteration.\n \n define void @test(i1 %c, i8* nocapture noundef readonly %path, i8* noundef writeonly %name) {\n ; CHECK-LABEL: @test(\n@@ -17,6 +18,7 @@ define void @test(i1 %c, i8* nocapture noundef readonly %path, i8* noundef write\n ; CHECK:       exit:\n ; CHECK-NEXT:    [[TMP_IV_1:%.*]] = getelementptr inbounds i8, i8* [[TMP_IV]], i64 1\n ; CHECK-NEXT:    [[LEN:%.*]] = sub nsw i64 259, [[IV]]\n+; CHECK-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 [[NAME:%.*]], i8* nonnull align 1 [[TMP_IV_1]], i64 [[LEN]], i1 false)\n ; CHECK-NEXT:    ret void\n ;\n entry:"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/MemCpyOpt/pr54682.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/MemCpyOpt/pr54682.ll\n\n\nTesting Time: 0.32s\n  Failed: 1\n"
    },
    "059d1f84d2d59093300a81c246de81b1c1da767b___DwarfUnit.cpp": {
        "prefix": "DIE &DwarfUnit::constructMemberDIE(DIE &Buffer, const DIDerivedType *DT) {\n  DIE &MemberDie = createAndAddDIE(DT->getTag(), Buffer);\n  StringRef Name = DT->getName();\n  if (!Name.empty())\n    addString(MemberDie, dwarf::DW_AT_name, Name);\n\n  addAnnotation(MemberDie, DT->getAnnotations());\n\n  if (DIType *Resolved = DT->getBaseType())\n    addType(MemberDie, Resolved);\n\n  addSourceLine(MemberDie, DT);\n\n  if (DT->getTag() == dwarf::DW_TAG_inheritance && DT->isVirtual()) {\n\n    // For C++, virtual base classes are not at fixed offset. Use following\n    // expression to extract appropriate offset from vtable.\n    // BaseAddr = ObAddr + *((*ObAddr) - Offset)\n\n    DIELoc *VBaseLocationDie = new (DIEValueAllocator) DIELoc;\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_dup);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_constu);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_udata, DT->getOffsetInBits());\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_minus);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus);\n\n    addBlock(MemberDie, dwarf::DW_AT_data_member_location, VBaseLocationDie);\n  } else {\n    uint64_t Size = DT->getSizeInBits();\n    uint64_t FieldSize = DD->getBaseTypeSize(DT);\n    uint32_t AlignInBytes = DT->getAlignInBytes();\n    uint64_t OffsetInBytes;\n\n",
        "suffix": "    if (IsBitfield) {\n      // Handle bitfield, assume bytes are 8 bits.\n      if (DD->useDWARF2Bitfields())\n        addUInt(MemberDie, dwarf::DW_AT_byte_size, None, FieldSize/8);\n      addUInt(MemberDie, dwarf::DW_AT_bit_size, None, Size);\n\n      uint64_t Offset = DT->getOffsetInBits();\n      // We can't use DT->getAlignInBits() here: AlignInBits for member type\n      // is non-zero if and only if alignment was forced (e.g. _Alignas()),\n      // which can't be done with bitfields. Thus we use FieldSize here.\n      uint32_t AlignInBits = FieldSize;\n      uint32_t AlignMask = ~(AlignInBits - 1);\n      // The bits from the start of the storage unit to the start of the field.\n      uint64_t StartBitOffset = Offset - (Offset & AlignMask);\n      // The byte offset of the field's aligned storage unit inside the struct.\n      OffsetInBytes = (Offset - StartBitOffset) / 8;\n\n      if (DD->useDWARF2Bitfields()) {\n        uint64_t HiMark = (Offset + FieldSize) & AlignMask;\n        uint64_t FieldOffset = (HiMark - FieldSize);\n        Offset -= FieldOffset;\n\n        // Maybe we need to work from the other end.\n        if (Asm->getDataLayout().isLittleEndian())\n          Offset = FieldSize - (Offset + Size);\n\n        addUInt(MemberDie, dwarf::DW_AT_bit_offset, None, Offset);\n        OffsetInBytes = FieldOffset >> 3;\n      } else {\n        addUInt(MemberDie, dwarf::DW_AT_data_bit_offset, None, Offset);\n      }\n    } else {\n      // This is not a bitfield.\n      OffsetInBytes = DT->getOffsetInBits() / 8;\n      if (AlignInBytes)\n        addUInt(MemberDie, dwarf::DW_AT_alignment, dwarf::DW_FORM_udata,\n                AlignInBytes);\n    }\n\n    if (DD->getDwarfVersion() <= 2) {\n      DIELoc *MemLocationDie = new (DIEValueAllocator) DIELoc;\n      addUInt(*MemLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus_uconst);\n      addUInt(*MemLocationDie, dwarf::DW_FORM_udata, OffsetInBytes);\n      addBlock(MemberDie, dwarf::DW_AT_data_member_location, MemLocationDie);\n    } else if (!IsBitfield || DD->useDWARF2Bitfields()) {\n      // In DWARF v3, DW_FORM_data4/8 in DW_AT_data_member_location are\n      // interpreted as location-list pointers. Interpreting constants as\n      // pointers is not expected, so we use DW_FORM_udata to encode the\n      // constants here.\n      if (DD->getDwarfVersion() == 3)\n        addUInt(MemberDie, dwarf::DW_AT_data_member_location,\n                dwarf::DW_FORM_udata, OffsetInBytes);\n      else\n        addUInt(MemberDie, dwarf::DW_AT_data_member_location, None,\n                OffsetInBytes);\n    }\n  }\n\n  addAccess(MemberDie, DT->getFlags());\n\n  if (DT->isVirtual())\n    addUInt(MemberDie, dwarf::DW_AT_virtuality, dwarf::DW_FORM_data1,\n            dwarf::DW_VIRTUALITY_virtual);\n\n  // Objective-C properties.\n  if (DINode *PNode = DT->getObjCProperty())\n    if (DIE *PDie = getDIE(PNode))\n      addAttribute(MemberDie, dwarf::DW_AT_APPLE_property,\n                   dwarf::DW_FORM_ref4, DIEEntry(*PDie));\n\n  if (DT->isArtificial())\n    addFlag(MemberDie, dwarf::DW_AT_artificial);\n\n  return MemberDie;\n}\n",
        "start": 1589,
        "end": 1699,
        "buggy": "DIE &DwarfUnit::constructMemberDIE(DIE &Buffer, const DIDerivedType *DT) {\n  DIE &MemberDie = createAndAddDIE(DT->getTag(), Buffer);\n  StringRef Name = DT->getName();\n  if (!Name.empty())\n    addString(MemberDie, dwarf::DW_AT_name, Name);\n\n  addAnnotation(MemberDie, DT->getAnnotations());\n\n  if (DIType *Resolved = DT->getBaseType())\n    addType(MemberDie, Resolved);\n\n  addSourceLine(MemberDie, DT);\n\n  if (DT->getTag() == dwarf::DW_TAG_inheritance && DT->isVirtual()) {\n\n    // For C++, virtual base classes are not at fixed offset. Use following\n    // expression to extract appropriate offset from vtable.\n    // BaseAddr = ObAddr + *((*ObAddr) - Offset)\n\n    DIELoc *VBaseLocationDie = new (DIEValueAllocator) DIELoc;\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_dup);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_constu);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_udata, DT->getOffsetInBits());\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_minus);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus);\n\n    addBlock(MemberDie, dwarf::DW_AT_data_member_location, VBaseLocationDie);\n  } else {\n    uint64_t Size = DT->getSizeInBits();\n    uint64_t FieldSize = DD->getBaseTypeSize(DT);\n    uint32_t AlignInBytes = DT->getAlignInBytes();\n    uint64_t OffsetInBytes;\n\n    bool IsBitfield = FieldSize && Size != FieldSize;\n    if (IsBitfield) {\n      // Handle bitfield, assume bytes are 8 bits.\n      if (DD->useDWARF2Bitfields())\n        addUInt(MemberDie, dwarf::DW_AT_byte_size, None, FieldSize/8);\n      addUInt(MemberDie, dwarf::DW_AT_bit_size, None, Size);\n\n      uint64_t Offset = DT->getOffsetInBits();\n      // We can't use DT->getAlignInBits() here: AlignInBits for member type\n      // is non-zero if and only if alignment was forced (e.g. _Alignas()),\n      // which can't be done with bitfields. Thus we use FieldSize here.\n      uint32_t AlignInBits = FieldSize;\n      uint32_t AlignMask = ~(AlignInBits - 1);\n      // The bits from the start of the storage unit to the start of the field.\n      uint64_t StartBitOffset = Offset - (Offset & AlignMask);\n      // The byte offset of the field's aligned storage unit inside the struct.\n      OffsetInBytes = (Offset - StartBitOffset) / 8;\n\n      if (DD->useDWARF2Bitfields()) {\n        uint64_t HiMark = (Offset + FieldSize) & AlignMask;\n        uint64_t FieldOffset = (HiMark - FieldSize);\n        Offset -= FieldOffset;\n\n        // Maybe we need to work from the other end.\n        if (Asm->getDataLayout().isLittleEndian())\n          Offset = FieldSize - (Offset + Size);\n\n        addUInt(MemberDie, dwarf::DW_AT_bit_offset, None, Offset);\n        OffsetInBytes = FieldOffset >> 3;\n      } else {\n        addUInt(MemberDie, dwarf::DW_AT_data_bit_offset, None, Offset);\n      }\n    } else {\n      // This is not a bitfield.\n      OffsetInBytes = DT->getOffsetInBits() / 8;\n      if (AlignInBytes)\n        addUInt(MemberDie, dwarf::DW_AT_alignment, dwarf::DW_FORM_udata,\n                AlignInBytes);\n    }\n\n    if (DD->getDwarfVersion() <= 2) {\n      DIELoc *MemLocationDie = new (DIEValueAllocator) DIELoc;\n      addUInt(*MemLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus_uconst);\n      addUInt(*MemLocationDie, dwarf::DW_FORM_udata, OffsetInBytes);\n      addBlock(MemberDie, dwarf::DW_AT_data_member_location, MemLocationDie);\n    } else if (!IsBitfield || DD->useDWARF2Bitfields()) {\n      // In DWARF v3, DW_FORM_data4/8 in DW_AT_data_member_location are\n      // interpreted as location-list pointers. Interpreting constants as\n      // pointers is not expected, so we use DW_FORM_udata to encode the\n      // constants here.\n      if (DD->getDwarfVersion() == 3)\n        addUInt(MemberDie, dwarf::DW_AT_data_member_location,\n                dwarf::DW_FORM_udata, OffsetInBytes);\n      else\n        addUInt(MemberDie, dwarf::DW_AT_data_member_location, None,\n                OffsetInBytes);\n    }\n  }\n\n  addAccess(MemberDie, DT->getFlags());\n\n  if (DT->isVirtual())\n    addUInt(MemberDie, dwarf::DW_AT_virtuality, dwarf::DW_FORM_data1,\n            dwarf::DW_VIRTUALITY_virtual);\n\n  // Objective-C properties.\n  if (DINode *PNode = DT->getObjCProperty())\n    if (DIE *PDie = getDIE(PNode))\n      addAttribute(MemberDie, dwarf::DW_AT_APPLE_property,\n                   dwarf::DW_FORM_ref4, DIEEntry(*PDie));\n\n  if (DT->isArtificial())\n    addFlag(MemberDie, dwarf::DW_AT_artificial);\n\n  return MemberDie;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    bool IsBitfield = FieldSize && Size != FieldSize;\n",
        "src_path": "059d1f84d2d59093300a81c246de81b1c1da767b___DwarfUnit.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/059d1f84d2d59093300a81c246de81b1c1da767b",
        "commit_msg": "[DebugInfo] Correctly recognize bitfields when emitting dwarf\n\nUse the \"isBitfield\" flag for debug types to determine whether something is\na bitfield, rather than trying to guess from it's layout. Fixes\nhttps://bugs.llvm.org/show_bug.cgi?id=44601\n\nPatch by: mahkoh\n\nDifferential Revision: https://reviews.llvm.org/D96334",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/AArch64/bitfields.ll",
                "patch": "@@ -24,6 +24,9 @@\n ; CHECK: DW_TAG_member\n ; CHECK-NEXT: DW_AT_name{{.*}}\"b\"\n ; CHECK-NOT: DW_TAG_member\n+; CHECK:      DW_AT_byte_size  {{.*}} (0x04)\n+; CHECK-NEXT: DW_AT_bit_size   {{.*}} (0x20)\n+; CHECK-NEXT: DW_AT_bit_offset {{.*}} (0x00)\n ; CHECK:      DW_AT_data_member_location {{.*}} (DW_OP_plus_uconst 0x4)\n \n ; CHECK: DW_TAG_member\n@@ -63,11 +66,11 @@ target triple = \"aarch64_be--linux-gnu\"\n !5 = !{!0}\n !6 = !DICompositeType(tag: DW_TAG_structure_type, name: \"bitfield\", file: !3, line: 1, size: 96, elements: !7)\n !7 = !{!8, !10, !11, !12}\n-!8 = !DIDerivedType(tag: DW_TAG_member, name: \"a\", scope: !6, file: !3, line: 2, baseType: !9, size: 2)\n+!8 = !DIDerivedType(tag: DW_TAG_member, name: \"a\", scope: !6, file: !3, line: 2, baseType: !9, size: 2, flags: DIFlagBitField)\n !9 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n-!10 = !DIDerivedType(tag: DW_TAG_member, name: \"b\", scope: !6, file: !3, line: 3, baseType: !9, size: 32, offset: 32)\n-!11 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !6, file: !3, line: 4, baseType: !9, size: 1, offset: 64)\n-!12 = !DIDerivedType(tag: DW_TAG_member, name: \"d\", scope: !6, file: !3, line: 5, baseType: !9, size: 28, offset: 65)\n+!10 = !DIDerivedType(tag: DW_TAG_member, name: \"b\", scope: !6, file: !3, line: 3, baseType: !9, size: 32, offset: 32, flags: DIFlagBitField)\n+!11 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !6, file: !3, line: 4, baseType: !9, size: 1, offset: 64, flags: DIFlagBitField)\n+!12 = !DIDerivedType(tag: DW_TAG_member, name: \"d\", scope: !6, file: !3, line: 5, baseType: !9, size: 28, offset: 65, flags: DIFlagBitField)\n !13 = !{i32 2, !\"Dwarf Version\", i32 2}\n !14 = !{i32 2, !\"Debug Info Version\", i32 3}\n !15 = !{i32 1, !\"PIC Level\", i32 2}"
            },
            {
                "fn": "llvm/test/DebugInfo/ARM/big-endian-bitfield.ll",
                "patch": "@@ -27,15 +27,15 @@ target datalayout = \"E-m:e-p:32:32-i64:64-v128:64:128-n32-S64\"\n !5 = !{!0}\n !6 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: \"S\", file: !3, line: 1, size: 32, elements: !7)\n !7 = !{!8, !10, !11, !12}\n-!8 = !DIDerivedType(tag: DW_TAG_member, name: \"j\", scope: !6, file: !3, line: 2, baseType: !9, size: 5)\n+!8 = !DIDerivedType(tag: DW_TAG_member, name: \"j\", scope: !6, file: !3, line: 2, baseType: !9, size: 5, flags: DIFlagBitField)\n ; CHECK: DW_TAG_member\n ; CHECK-NEXT: DW_AT_name{{.*}}\"j\"\n ; CHECK-NOT:  DW_TAG\n ; CHECK:      DW_AT_data_bit_offset      [DW_FORM_data1]\t(0x00)\n !9 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n-!10 = !DIDerivedType(tag: DW_TAG_member, name: \"k\", scope: !6, file: !3, line: 3, baseType: !9, size: 6, offset: 5)\n-!11 = !DIDerivedType(tag: DW_TAG_member, name: \"m\", scope: !6, file: !3, line: 4, baseType: !9, size: 5, offset: 11)\n-!12 = !DIDerivedType(tag: DW_TAG_member, name: \"n\", scope: !6, file: !3, line: 5, baseType: !9, size: 8, offset: 16)\n+!10 = !DIDerivedType(tag: DW_TAG_member, name: \"k\", scope: !6, file: !3, line: 3, baseType: !9, size: 6, offset: 5, flags: DIFlagBitField)\n+!11 = !DIDerivedType(tag: DW_TAG_member, name: \"m\", scope: !6, file: !3, line: 4, baseType: !9, size: 5, offset: 11, flags: DIFlagBitField)\n+!12 = !DIDerivedType(tag: DW_TAG_member, name: \"n\", scope: !6, file: !3, line: 5, baseType: !9, size: 8, offset: 16, flags: DIFlagBitField)\n !13 = !{i32 2, !\"Dwarf Version\", i32 4}\n ; CHECK: DW_TAG_member\n ; CHECK-NEXT: DW_AT_name{{.*}}\"k\""
            },
            {
                "fn": "llvm/test/DebugInfo/ARM/bitfield.ll",
                "patch": "@@ -36,7 +36,7 @@ target triple = \"thumbv7-apple-ios\"\n !7 = !{!8, !10}\n !8 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !6, file: !3, line: 2, baseType: !9, size: 8, align: 8)\n !9 = !DIBasicType(name: \"char\", size: 8, align: 8, encoding: DW_ATE_signed_char)\n-!10 = !DIDerivedType(tag: DW_TAG_member, name: \"reserved\", scope: !6, file: !3, line: 4, baseType: !11, size: 28, align: 32, offset: 12)\n+!10 = !DIDerivedType(tag: DW_TAG_member, name: \"reserved\", scope: !6, file: !3, line: 4, baseType: !11, size: 28, align: 32, offset: 12, flags: DIFlagBitField)\n !11 = !DIBasicType(name: \"int\", size: 32, align: 32, encoding: DW_ATE_signed)\n !12 = !{i32 2, !\"Dwarf Version\", i32 2}\n !13 = !{i32 2, !\"Debug Info Version\", i32 3}"
            },
            {
                "fn": "llvm/test/DebugInfo/X86/bitfields-dwarf4.ll",
                "patch": "@@ -43,7 +43,7 @@ target triple = \"x86_64-apple-macosx\"\n ; CHECK-NOT:  DW_AT_data_bit_offset\n ; CHECK:      DW_AT_data_member_location [DW_FORM_data1]\t(0x00)\n !9 = !DIBasicType(name: \"char\", size: 8, encoding: DW_ATE_signed_char)\n-!10 = !DIDerivedType(tag: DW_TAG_member, name: \"b\", scope: !6, file: !3, line: 6, baseType: !11, size: 5, offset: 8)\n+!10 = !DIDerivedType(tag: DW_TAG_member, name: \"b\", scope: !6, file: !3, line: 6, baseType: !11, size: 5, offset: 8, flags: DIFlagBitField)\n !11 = !DIDerivedType(tag: DW_TAG_typedef, name: \"uint32_t\", file: !12, line: 183, baseType: !13)\n !12 = !DIFile(filename: \"/Volumes/Data/llvm/_build.ninja.release/bin/../lib/clang/3.9.0/include/stdint.h\", directory: \"/Volumes/Data/llvm\")\n !13 = !DIBasicType(name: \"unsigned int\", size: 32, encoding: DW_ATE_unsigned)\n@@ -56,7 +56,7 @@ target triple = \"x86_64-apple-macosx\"\n ; CHECK-NOT:  DW_AT_byte_size\n ; CHECK-NEXT: DW_AT_data_bit_offset      [DW_FORM_data1]\t(0x08)\n ; CHECK-NOT:  DW_AT_data_member_location\n-!14 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !6, file: !3, line: 7, baseType: !11, size: 27, offset: 13)\n+!14 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !6, file: !3, line: 7, baseType: !11, size: 27, offset: 13, flags: DIFlagBitField)\n !15 = !{i32 2, !\"Dwarf Version\", i32 4}\n !16 = !{i32 2, !\"Debug Info Version\", i32 3}\n !17 = !{i32 1, !\"PIC Level\", i32 2}"
            },
            {
                "fn": "llvm/test/DebugInfo/X86/bitfields.ll",
                "patch": "@@ -63,11 +63,11 @@ target triple = \"x86_64-apple-macosx\"\n !5 = !{!0}\n !6 = !DICompositeType(tag: DW_TAG_structure_type, name: \"bitfield\", file: !3, line: 1, size: 96, elements: !7)\n !7 = !{!8, !10, !11, !12}\n-!8 = !DIDerivedType(tag: DW_TAG_member, name: \"a\", scope: !6, file: !3, line: 2, baseType: !9, size: 2)\n+!8 = !DIDerivedType(tag: DW_TAG_member, name: \"a\", scope: !6, file: !3, line: 2, baseType: !9, size: 2, flags: DIFlagBitField)\n !9 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n-!10 = !DIDerivedType(tag: DW_TAG_member, name: \"b\", scope: !6, file: !3, line: 3, baseType: !9, size: 32, offset: 32)\n-!11 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !6, file: !3, line: 4, baseType: !9, size: 1, offset: 64)\n-!12 = !DIDerivedType(tag: DW_TAG_member, name: \"d\", scope: !6, file: !3, line: 5, baseType: !9, size: 28, offset: 65)\n+!10 = !DIDerivedType(tag: DW_TAG_member, name: \"b\", scope: !6, file: !3, line: 3, baseType: !9, size: 32, offset: 32, flags: DIFlagBitField)\n+!11 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !6, file: !3, line: 4, baseType: !9, size: 1, offset: 64, flags: DIFlagBitField)\n+!12 = !DIDerivedType(tag: DW_TAG_member, name: \"d\", scope: !6, file: !3, line: 5, baseType: !9, size: 28, offset: 65, flags: DIFlagBitField)\n !13 = !{i32 2, !\"Dwarf Version\", i32 2}\n !14 = !{i32 2, !\"Debug Info Version\", i32 3}\n !15 = !{i32 1, !\"PIC Level\", i32 2}"
            },
            {
                "fn": "llvm/test/DebugInfo/X86/debug-info-packed-struct.ll",
                "patch": "@@ -157,7 +157,7 @@ target triple = \"x86_64-apple-darwin\"\n !12 = !DIBasicType(name: \"char\", size: 8, encoding: DW_ATE_signed_char)\n !13 = !DIDerivedType(tag: DW_TAG_member, name: \"l1_ofs1\", scope: !9, file: !8, line: 36, baseType: !14, size: 64, offset: 8)\n !14 = !DICompositeType(tag: DW_TAG_structure_type, name: \"size8_anon\", file: !8, line: 30, size: 64, elements: !4)\n-!15 = !DIDerivedType(tag: DW_TAG_member, name: \"l1_ofs9\", scope: !9, file: !8, line: 37, baseType: !16, size: 1, offset: 72)\n+!15 = !DIDerivedType(tag: DW_TAG_member, name: \"l1_ofs9\", scope: !9, file: !8, line: 37, baseType: !16, size: 1, offset: 72, flags: DIFlagBitField)\n !16 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n !17 = !DIGlobalVariableExpression(var: !18, expr: !DIExpression())\n !18 = !DIGlobalVariable(name: \"l2\", scope: !2, file: !8, line: 90, type: !19, isLocal: false, isDefinition: true)\n@@ -167,10 +167,10 @@ target triple = \"x86_64-apple-darwin\"\n !22 = !DIDerivedType(tag: DW_TAG_member, name: \"l2_ofs1\", scope: !19, file: !8, line: 56, baseType: !23, size: 64, offset: 8)\n !23 = !DICompositeType(tag: DW_TAG_structure_type, name: \"size8_pack1\", file: !8, line: 50, size: 64, elements: !24)\n !24 = !{!25, !26}\n-!25 = !DIDerivedType(tag: DW_TAG_member, name: \"i\", scope: !23, file: !8, line: 51, baseType: !16, size: 4)\n-!26 = !DIDerivedType(tag: DW_TAG_member, name: \"l\", scope: !23, file: !8, line: 52, baseType: !27, size: 60, offset: 4)\n+!25 = !DIDerivedType(tag: DW_TAG_member, name: \"i\", scope: !23, file: !8, line: 51, baseType: !16, size: 4, flags: DIFlagBitField)\n+!26 = !DIDerivedType(tag: DW_TAG_member, name: \"l\", scope: !23, file: !8, line: 52, baseType: !27, size: 60, offset: 4, flags: DIFlagBitField)\n !27 = !DIBasicType(name: \"long long int\", size: 64, encoding: DW_ATE_signed)\n-!28 = !DIDerivedType(tag: DW_TAG_member, name: \"l2_ofs9\", scope: !19, file: !8, line: 57, baseType: !16, size: 1, offset: 72)\n+!28 = !DIDerivedType(tag: DW_TAG_member, name: \"l2_ofs9\", scope: !19, file: !8, line: 57, baseType: !16, size: 1, offset: 72, flags: DIFlagBitField)\n !29 = !DIGlobalVariableExpression(var: !30, expr: !DIExpression())\n !30 = !DIGlobalVariable(name: \"l3\", scope: !2, file: !8, line: 91, type: !31, isLocal: false, isDefinition: true)\n !31 = !DICompositeType(tag: DW_TAG_structure_type, name: \"layout3\", file: !8, line: 76, size: 128, elements: !32)\n@@ -179,18 +179,18 @@ target triple = \"x86_64-apple-darwin\"\n !34 = !DIDerivedType(tag: DW_TAG_member, name: \"l3_ofs4\", scope: !31, file: !8, line: 78, baseType: !35, size: 64, offset: 32)\n !35 = !DICompositeType(tag: DW_TAG_structure_type, name: \"size8_pack4\", file: !8, line: 72, size: 64, elements: !36)\n !36 = !{!37, !38}\n-!37 = !DIDerivedType(tag: DW_TAG_member, name: \"i\", scope: !35, file: !8, line: 73, baseType: !16, size: 4)\n-!38 = !DIDerivedType(tag: DW_TAG_member, name: \"l\", scope: !35, file: !8, line: 74, baseType: !27, size: 60, offset: 4)\n-!39 = !DIDerivedType(tag: DW_TAG_member, name: \"l3_ofs12\", scope: !31, file: !8, line: 79, baseType: !16, size: 1, offset: 96)\n+!37 = !DIDerivedType(tag: DW_TAG_member, name: \"i\", scope: !35, file: !8, line: 73, baseType: !16, size: 4, flags: DIFlagBitField)\n+!38 = !DIDerivedType(tag: DW_TAG_member, name: \"l\", scope: !35, file: !8, line: 74, baseType: !27, size: 60, offset: 4, flags: DIFlagBitField)\n+!39 = !DIDerivedType(tag: DW_TAG_member, name: \"l3_ofs12\", scope: !31, file: !8, line: 79, baseType: !16, size: 1, offset: 96, flags: DIFlagBitField)\n !40 = !DICompositeType(tag: DW_TAG_structure_type, name: \"layout0\", file: !8, line: 15, size: 192, elements: !41)\n !41 = !{!42, !43, !48}\n !42 = !DIDerivedType(tag: DW_TAG_member, name: \"l0_ofs0\", scope: !40, file: !8, line: 16, baseType: !12, size: 8)\n !43 = !DIDerivedType(tag: DW_TAG_member, name: \"l0_ofs8\", scope: !40, file: !8, line: 17, baseType: !44, size: 64, offset: 64)\n !44 = !DICompositeType(tag: DW_TAG_structure_type, name: \"size8\", file: !8, line: 11, size: 64, elements: !45)\n !45 = !{!46, !47}\n-!46 = !DIDerivedType(tag: DW_TAG_member, name: \"i\", scope: !44, file: !8, line: 12, baseType: !16, size: 4)\n-!47 = !DIDerivedType(tag: DW_TAG_member, name: \"l\", scope: !44, file: !8, line: 13, baseType: !27, size: 60, offset: 4)\n-!48 = !DIDerivedType(tag: DW_TAG_member, name: \"l0_ofs16\", scope: !40, file: !8, line: 18, baseType: !16, size: 1, offset: 128)\n+!46 = !DIDerivedType(tag: DW_TAG_member, name: \"i\", scope: !44, file: !8, line: 12, baseType: !16, size: 4, flags: DIFlagBitField)\n+!47 = !DIDerivedType(tag: DW_TAG_member, name: \"l\", scope: !44, file: !8, line: 13, baseType: !27, size: 60, offset: 4, flags: DIFlagBitField)\n+!48 = !DIDerivedType(tag: DW_TAG_member, name: \"l0_ofs16\", scope: !40, file: !8, line: 18, baseType: !16, size: 1, offset: 128, flags: DIFlagBitField)\n !49 = !{i32 2, !\"Dwarf Version\", i32 2}\n !50 = !{i32 2, !\"Debug Info Version\", i32 3}\n !51 = !{!\"clang version 3.7.0 (trunk 240791) (llvm/trunk 240790)\"}"
            },
            {
                "fn": "llvm/test/DebugInfo/X86/packed_bitfields2.ll",
                "patch": "@@ -0,0 +1,51 @@\n+; RUN: llc -dwarf-version=5 -debugger-tune=lldb -mtriple x86_64-unknown-linux-gnu -O0 -filetype=obj -o %t_2_le.o %s\n+; RUN: llvm-dwarfdump -v -debug-info %t_2_le.o | FileCheck %s\n+\n+; Produced at -O0 from:\n+; struct __attribute__((packed)) bitfield {\n+; \tint i:1;\n+; \tint j:32;\n+; } bitfield;\n+\n+; CHECK: DW_TAG_member\n+; CHECK-NEXT: DW_AT_name{{.*}}\"i\"\n+; CHECK-NOT: DW_TAG_member\n+; CHECK: DW_AT_bit_size   {{.*}} (0x01)\n+; CHECK-NEXT: DW_AT_data_bit_offset {{.*}} (0x00)\n+\n+; CHECK: DW_TAG_member\n+; CHECK-NEXT: DW_AT_name{{.*}}\"j\"\n+; CHECK-NOT: DW_TAG_member\n+; CHECK: DW_AT_bit_size   {{.*}} (0x20)\n+; CHECK-NEXT: DW_AT_data_bit_offset {{.*}} (0x01)\n+\n+; ModuleID = 'packed_bitfields2.c'\n+source_filename = \"packed_bitfields2.c\"\n+target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n+target triple = \"x86_64-pc-linux-gnu\"\n+\n+%struct.bitfield = type { [5 x i8] }\n+\n+@bitfield = dso_local global %struct.bitfield zeroinitializer, align 1, !dbg !0\n+\n+!llvm.dbg.cu = !{!2}\n+!llvm.module.flags = !{!11, !12, !13, !14, !15}\n+!llvm.ident = !{!16}\n+\n+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())\n+!1 = distinct !DIGlobalVariable(name: \"bitfield\", scope: !2, file: !3, line: 4, type: !6, isLocal: false, isDefinition: true)\n+!2 = distinct !DICompileUnit(language: DW_LANG_C99, file: !3, producer: \"clang version 11.0.1\", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !4, globals: !5, splitDebugInlining: false, nameTableKind: None, sysroot: \"/\")\n+!3 = !DIFile(filename: \"packed_bitfields2.c\", directory: \"/\")\n+!4 = !{}\n+!5 = !{!0}\n+!6 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: \"bitfield\", file: !3, line: 1, size: 40, elements: !7)\n+!7 = !{!8, !10}\n+!8 = !DIDerivedType(tag: DW_TAG_member, name: \"i\", scope: !6, file: !3, line: 2, baseType: !9, size: 1, flags: DIFlagBitField, extraData: i64 0)\n+!9 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n+!10 = !DIDerivedType(tag: DW_TAG_member, name: \"j\", scope: !6, file: !3, line: 3, baseType: !9, size: 32, offset: 1, flags: DIFlagBitField, extraData: i64 0)\n+!11 = !{i32 7, !\"Dwarf Version\", i32 5}\n+!12 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!13 = !{i32 1, !\"wchar_size\", i32 4}\n+!14 = !{i32 7, !\"PIC Level\", i32 2}\n+!15 = !{i32 7, !\"PIE Level\", i32 2}\n+!16 = !{!\"clang version 11.0.1\"}"
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/X86/packed_bitfields2.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: DebugInfo/X86/packed_bitfields2.ll\n\n\nTesting Time: 0.11s\n  Failed: 1\n"
    },
    "e22af03a794d633915d0b51c15e05bb9cb9b4ec9___Sink.cpp": {
        "prefix": "static bool isSafeToMove(Instruction *Inst, AliasAnalysis &AA,\n                         SmallPtrSetImpl<Instruction *> &Stores) {\n\n  if (Inst->mayWriteToMemory()) {\n    Stores.insert(Inst);\n    return false;\n  }\n\n  if (LoadInst *L = dyn_cast<LoadInst>(Inst)) {\n    MemoryLocation Loc = MemoryLocation::get(L);\n    for (Instruction *S : Stores)\n      if (isModSet(AA.getModRefInfo(S, Loc)))\n        return false;\n  }\n\n  if (Inst->isTerminator() || isa<PHINode>(Inst) || Inst->isEHPad() ||\n",
        "suffix": "    return false;\n\n  if (auto *Call = dyn_cast<CallBase>(Inst)) {\n    // Convergent operations cannot be made control-dependent on additional\n    // values.\n    if (Call->isConvergent())\n      return false;\n\n    for (Instruction *S : Stores)\n      if (isModSet(AA.getModRefInfo(S, Call)))\n        return false;\n  }\n\n  return true;\n}\n",
        "start": 30,
        "end": 61,
        "buggy": "static bool isSafeToMove(Instruction *Inst, AliasAnalysis &AA,\n                         SmallPtrSetImpl<Instruction *> &Stores) {\n\n  if (Inst->mayWriteToMemory()) {\n    Stores.insert(Inst);\n    return false;\n  }\n\n  if (LoadInst *L = dyn_cast<LoadInst>(Inst)) {\n    MemoryLocation Loc = MemoryLocation::get(L);\n    for (Instruction *S : Stores)\n      if (isModSet(AA.getModRefInfo(S, Loc)))\n        return false;\n  }\n\n  if (Inst->isTerminator() || isa<PHINode>(Inst) || Inst->isEHPad() ||\n      Inst->mayThrow())\n    return false;\n\n  if (auto *Call = dyn_cast<CallBase>(Inst)) {\n    // Convergent operations cannot be made control-dependent on additional\n    // values.\n    if (Call->isConvergent())\n      return false;\n\n    for (Instruction *S : Stores)\n      if (isModSet(AA.getModRefInfo(S, Call)))\n        return false;\n  }\n\n  return true;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      Inst->mayThrow())\n",
        "src_path": "e22af03a794d633915d0b51c15e05bb9cb9b4ec9___Sink.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/e22af03a794d633915d0b51c15e05bb9cb9b4ec9",
        "commit_msg": "[Sink] Don't sink non-willreturn calls (PR51188)\n\nFixes https://github.com/llvm/llvm-project/issues/51188.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/Sink/call.ll",
                "patch": "@@ -4,11 +4,11 @@\n declare i32 @f_load_global() nounwind willreturn readonly\n declare i32 @f_load_global_throwable() willreturn readonly\n declare i32 @f_load_global_may_not_return() nounwind readonly\n-declare i32 @f_load_arg(i32*) nounwind readonly argmemonly\n-declare void @f_store_global(i32) nounwind\n-declare void @f_store_arg(i32*) nounwind argmemonly\n-declare void @f_readonly_arg(i32* readonly, i32*) nounwind argmemonly\n-declare i32 @f_readnone(i32) nounwind readnone\n+declare i32 @f_load_arg(i32*) nounwind willreturn readonly argmemonly\n+declare void @f_store_global(i32) nounwind willreturn\n+declare void @f_store_arg(i32*) nounwind willreturn argmemonly\n+declare void @f_readonly_arg(i32* readonly, i32*) nounwind willreturn argmemonly\n+declare i32 @f_readnone(i32) nounwind willreturn readnone\n \n @A = external global i32\n @B = external global i32\n@@ -51,9 +51,9 @@ false:\n \n define i32 @test_may_not_return_no_stores(i1 %z) {\n ; CHECK-LABEL: @test_may_not_return_no_stores(\n+; CHECK-NEXT:    [[L:%.*]] = call i32 @f_load_global_may_not_return()\n ; CHECK-NEXT:    br i1 [[Z:%.*]], label [[TRUE:%.*]], label [[FALSE:%.*]]\n ; CHECK:       true:\n-; CHECK-NEXT:    [[L:%.*]] = call i32 @f_load_global_may_not_return()\n ; CHECK-NEXT:    ret i32 [[L]]\n ; CHECK:       false:\n ; CHECK-NEXT:    ret i32 0"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/Sink/call.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/Sink/call.ll\n\n\nTesting Time: 0.22s\n  Failed: 1\n"
    },
    "0513b0305acde91a0a5f7f5ea4061476011f0d1d___X86ISelLowering.cpp": {
        "prefix": "static SDValue combineOr(SDNode *N, SelectionDAG &DAG,\n                         TargetLowering::DAGCombinerInfo &DCI,\n                         const X86Subtarget &Subtarget) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  SDLoc dl(N);\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n\n  // If this is SSE1 only convert to FOR to avoid scalarization.\n  if (Subtarget.hasSSE1() && !Subtarget.hasSSE2() && VT == MVT::v4i32) {\n    return DAG.getBitcast(MVT::v4i32,\n                          DAG.getNode(X86ISD::FOR, dl, MVT::v4f32,\n                                      DAG.getBitcast(MVT::v4f32, N0),\n                                      DAG.getBitcast(MVT::v4f32, N1)));\n  }\n\n  // Match any-of bool scalar reductions into a bitcast/movmsk + cmp.\n  // TODO: Support multiple SrcOps.\n  if (VT == MVT::i1) {\n    SmallVector<SDValue, 2> SrcOps;\n    SmallVector<APInt, 2> SrcPartials;\n    if (matchScalarReduction(SDValue(N, 0), ISD::OR, SrcOps, &SrcPartials) &&\n        SrcOps.size() == 1) {\n      unsigned NumElts = SrcOps[0].getValueType().getVectorNumElements();\n      EVT MaskVT = EVT::getIntegerVT(*DAG.getContext(), NumElts);\n      SDValue Mask = combineBitcastvxi1(DAG, MaskVT, SrcOps[0], dl, Subtarget);\n      if (!Mask && TLI.isTypeLegal(SrcOps[0].getValueType()))\n        Mask = DAG.getBitcast(MaskVT, SrcOps[0]);\n      if (Mask) {\n        assert(SrcPartials[0].getBitWidth() == NumElts &&\n               \"Unexpected partial reduction mask\");\n        SDValue ZeroBits = DAG.getConstant(0, dl, MaskVT);\n        SDValue PartialBits = DAG.getConstant(SrcPartials[0], dl, MaskVT);\n        Mask = DAG.getNode(ISD::AND, dl, MaskVT, Mask, PartialBits);\n        return DAG.getSetCC(dl, MVT::i1, Mask, ZeroBits, ISD::SETNE);\n      }\n    }\n  }\n\n  if (SDValue R = combineBitOpWithMOVMSK(N, DAG))\n    return R;\n\n  if (SDValue R = combineBitOpWithShift(N, DAG))\n    return R;\n\n  if (SDValue FPLogic = convertIntLogicToFPLogic(N, DAG, DCI, Subtarget))\n    return FPLogic;\n\n  if (DCI.isBeforeLegalizeOps())\n    return SDValue();\n\n  if (SDValue R = combineCompareEqual(N, DAG, DCI, Subtarget))\n    return R;\n\n  if (SDValue R = canonicalizeBitSelect(N, DAG, Subtarget))\n    return R;\n\n  if (SDValue R = combineLogicBlendIntoPBLENDV(N, DAG, Subtarget))\n    return R;\n\n  // (0 - SetCC) | C -> (zext (not SetCC)) * (C + 1) - 1 if we can get a LEA out of it.\n  if ((VT == MVT::i32 || VT == MVT::i64) &&\n      N0.getOpcode() == ISD::SUB && N0.hasOneUse() &&\n      isNullConstant(N0.getOperand(0))) {\n    SDValue Cond = N0.getOperand(1);\n    if (Cond.getOpcode() == ISD::ZERO_EXTEND && Cond.hasOneUse())\n      Cond = Cond.getOperand(0);\n\n    if (Cond.getOpcode() == X86ISD::SETCC && Cond.hasOneUse()) {\n      if (auto *CN = dyn_cast<ConstantSDNode>(N1)) {\n",
        "suffix": "        if (Val == 1 || Val == 2 || Val == 3 || Val == 4 || Val == 7 || Val == 8) {\n          X86::CondCode CCode = (X86::CondCode)Cond.getConstantOperandVal(0);\n          CCode = X86::GetOppositeBranchCondition(CCode);\n          SDValue NotCond = getSETCC(CCode, Cond.getOperand(1), SDLoc(Cond), DAG);\n\n          SDValue R = DAG.getZExtOrTrunc(NotCond, dl, VT);\n          R = DAG.getNode(ISD::MUL, dl, VT, R, DAG.getConstant(Val + 1, dl, VT));\n          R = DAG.getNode(ISD::SUB, dl, VT, R, DAG.getConstant(1, dl, VT));\n          return R;\n        }\n      }\n    }\n  }\n\n  // Combine OR(X,KSHIFTL(Y,Elts/2)) -> CONCAT_VECTORS(X,Y) == KUNPCK(X,Y).\n  // Combine OR(KSHIFTL(X,Elts/2),Y) -> CONCAT_VECTORS(Y,X) == KUNPCK(Y,X).\n  // iff the upper elements of the non-shifted arg are zero.\n  // KUNPCK require 16+ bool vector elements.\n  if (N0.getOpcode() == X86ISD::KSHIFTL || N1.getOpcode() == X86ISD::KSHIFTL) {\n    unsigned NumElts = VT.getVectorNumElements();\n    unsigned HalfElts = NumElts / 2;\n    APInt UpperElts = APInt::getHighBitsSet(NumElts, HalfElts);\n    if (NumElts >= 16 && N1.getOpcode() == X86ISD::KSHIFTL &&\n        N1.getConstantOperandAPInt(1) == HalfElts &&\n        DAG.MaskedVectorIsZero(N0, UpperElts)) {\n      return DAG.getNode(\n          ISD::CONCAT_VECTORS, dl, VT,\n          extractSubVector(N0, 0, DAG, dl, HalfElts),\n          extractSubVector(N1.getOperand(0), 0, DAG, dl, HalfElts));\n    }\n    if (NumElts >= 16 && N0.getOpcode() == X86ISD::KSHIFTL &&\n        N0.getConstantOperandAPInt(1) == HalfElts &&\n        DAG.MaskedVectorIsZero(N1, UpperElts)) {\n      return DAG.getNode(\n          ISD::CONCAT_VECTORS, dl, VT,\n          extractSubVector(N1, 0, DAG, dl, HalfElts),\n          extractSubVector(N0.getOperand(0), 0, DAG, dl, HalfElts));\n    }\n  }\n\n  if (VT.isVector() && (VT.getScalarSizeInBits() % 8) == 0) {\n    // Attempt to recursively combine an OR of shuffles.\n    SDValue Op(N, 0);\n    if (SDValue Res = combineX86ShufflesRecursively(Op, DAG, Subtarget))\n      return Res;\n\n    // If either operand is a constant mask, then only the elements that aren't\n    // allones are actually demanded by the other operand.\n    auto SimplifyUndemandedElts = [&](SDValue Op, SDValue OtherOp) {\n      APInt UndefElts;\n      SmallVector<APInt> EltBits;\n      int NumElts = VT.getVectorNumElements();\n      int EltSizeInBits = VT.getScalarSizeInBits();\n      if (!getTargetConstantBitsFromNode(Op, EltSizeInBits, UndefElts, EltBits))\n        return false;\n\n      APInt DemandedElts = APInt::getZero(NumElts);\n      for (int I = 0; I != NumElts; ++I)\n        if (!EltBits[I].isAllOnes())\n          DemandedElts.setBit(I);\n\n      return TLI.SimplifyDemandedVectorElts(OtherOp, DemandedElts, DCI);\n    };\n    if (SimplifyUndemandedElts(N0, N1) || SimplifyUndemandedElts(N1, N0)) {\n      if (N->getOpcode() != ISD::DELETED_NODE)\n        DCI.AddToWorklist(N);\n      return SDValue(N, 0);\n    }\n  }\n\n  // We should fold \"masked merge\" patterns when `andn` is not available.\n  if (!Subtarget.hasBMI() && VT.isScalarInteger() && VT != MVT::i1)\n    if (SDValue R = foldMaskedMerge(N, DAG))\n      return R;\n\n  return SDValue();\n}\n",
        "start": 48524,
        "end": 48672,
        "buggy": "static SDValue combineOr(SDNode *N, SelectionDAG &DAG,\n                         TargetLowering::DAGCombinerInfo &DCI,\n                         const X86Subtarget &Subtarget) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  SDLoc dl(N);\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n\n  // If this is SSE1 only convert to FOR to avoid scalarization.\n  if (Subtarget.hasSSE1() && !Subtarget.hasSSE2() && VT == MVT::v4i32) {\n    return DAG.getBitcast(MVT::v4i32,\n                          DAG.getNode(X86ISD::FOR, dl, MVT::v4f32,\n                                      DAG.getBitcast(MVT::v4f32, N0),\n                                      DAG.getBitcast(MVT::v4f32, N1)));\n  }\n\n  // Match any-of bool scalar reductions into a bitcast/movmsk + cmp.\n  // TODO: Support multiple SrcOps.\n  if (VT == MVT::i1) {\n    SmallVector<SDValue, 2> SrcOps;\n    SmallVector<APInt, 2> SrcPartials;\n    if (matchScalarReduction(SDValue(N, 0), ISD::OR, SrcOps, &SrcPartials) &&\n        SrcOps.size() == 1) {\n      unsigned NumElts = SrcOps[0].getValueType().getVectorNumElements();\n      EVT MaskVT = EVT::getIntegerVT(*DAG.getContext(), NumElts);\n      SDValue Mask = combineBitcastvxi1(DAG, MaskVT, SrcOps[0], dl, Subtarget);\n      if (!Mask && TLI.isTypeLegal(SrcOps[0].getValueType()))\n        Mask = DAG.getBitcast(MaskVT, SrcOps[0]);\n      if (Mask) {\n        assert(SrcPartials[0].getBitWidth() == NumElts &&\n               \"Unexpected partial reduction mask\");\n        SDValue ZeroBits = DAG.getConstant(0, dl, MaskVT);\n        SDValue PartialBits = DAG.getConstant(SrcPartials[0], dl, MaskVT);\n        Mask = DAG.getNode(ISD::AND, dl, MaskVT, Mask, PartialBits);\n        return DAG.getSetCC(dl, MVT::i1, Mask, ZeroBits, ISD::SETNE);\n      }\n    }\n  }\n\n  if (SDValue R = combineBitOpWithMOVMSK(N, DAG))\n    return R;\n\n  if (SDValue R = combineBitOpWithShift(N, DAG))\n    return R;\n\n  if (SDValue FPLogic = convertIntLogicToFPLogic(N, DAG, DCI, Subtarget))\n    return FPLogic;\n\n  if (DCI.isBeforeLegalizeOps())\n    return SDValue();\n\n  if (SDValue R = combineCompareEqual(N, DAG, DCI, Subtarget))\n    return R;\n\n  if (SDValue R = canonicalizeBitSelect(N, DAG, Subtarget))\n    return R;\n\n  if (SDValue R = combineLogicBlendIntoPBLENDV(N, DAG, Subtarget))\n    return R;\n\n  // (0 - SetCC) | C -> (zext (not SetCC)) * (C + 1) - 1 if we can get a LEA out of it.\n  if ((VT == MVT::i32 || VT == MVT::i64) &&\n      N0.getOpcode() == ISD::SUB && N0.hasOneUse() &&\n      isNullConstant(N0.getOperand(0))) {\n    SDValue Cond = N0.getOperand(1);\n    if (Cond.getOpcode() == ISD::ZERO_EXTEND && Cond.hasOneUse())\n      Cond = Cond.getOperand(0);\n\n    if (Cond.getOpcode() == X86ISD::SETCC && Cond.hasOneUse()) {\n      if (auto *CN = dyn_cast<ConstantSDNode>(N1)) {\n        unsigned Val = CN->getZExtValue();\n        if (Val == 1 || Val == 2 || Val == 3 || Val == 4 || Val == 7 || Val == 8) {\n          X86::CondCode CCode = (X86::CondCode)Cond.getConstantOperandVal(0);\n          CCode = X86::GetOppositeBranchCondition(CCode);\n          SDValue NotCond = getSETCC(CCode, Cond.getOperand(1), SDLoc(Cond), DAG);\n\n          SDValue R = DAG.getZExtOrTrunc(NotCond, dl, VT);\n          R = DAG.getNode(ISD::MUL, dl, VT, R, DAG.getConstant(Val + 1, dl, VT));\n          R = DAG.getNode(ISD::SUB, dl, VT, R, DAG.getConstant(1, dl, VT));\n          return R;\n        }\n      }\n    }\n  }\n\n  // Combine OR(X,KSHIFTL(Y,Elts/2)) -> CONCAT_VECTORS(X,Y) == KUNPCK(X,Y).\n  // Combine OR(KSHIFTL(X,Elts/2),Y) -> CONCAT_VECTORS(Y,X) == KUNPCK(Y,X).\n  // iff the upper elements of the non-shifted arg are zero.\n  // KUNPCK require 16+ bool vector elements.\n  if (N0.getOpcode() == X86ISD::KSHIFTL || N1.getOpcode() == X86ISD::KSHIFTL) {\n    unsigned NumElts = VT.getVectorNumElements();\n    unsigned HalfElts = NumElts / 2;\n    APInt UpperElts = APInt::getHighBitsSet(NumElts, HalfElts);\n    if (NumElts >= 16 && N1.getOpcode() == X86ISD::KSHIFTL &&\n        N1.getConstantOperandAPInt(1) == HalfElts &&\n        DAG.MaskedVectorIsZero(N0, UpperElts)) {\n      return DAG.getNode(\n          ISD::CONCAT_VECTORS, dl, VT,\n          extractSubVector(N0, 0, DAG, dl, HalfElts),\n          extractSubVector(N1.getOperand(0), 0, DAG, dl, HalfElts));\n    }\n    if (NumElts >= 16 && N0.getOpcode() == X86ISD::KSHIFTL &&\n        N0.getConstantOperandAPInt(1) == HalfElts &&\n        DAG.MaskedVectorIsZero(N1, UpperElts)) {\n      return DAG.getNode(\n          ISD::CONCAT_VECTORS, dl, VT,\n          extractSubVector(N1, 0, DAG, dl, HalfElts),\n          extractSubVector(N0.getOperand(0), 0, DAG, dl, HalfElts));\n    }\n  }\n\n  if (VT.isVector() && (VT.getScalarSizeInBits() % 8) == 0) {\n    // Attempt to recursively combine an OR of shuffles.\n    SDValue Op(N, 0);\n    if (SDValue Res = combineX86ShufflesRecursively(Op, DAG, Subtarget))\n      return Res;\n\n    // If either operand is a constant mask, then only the elements that aren't\n    // allones are actually demanded by the other operand.\n    auto SimplifyUndemandedElts = [&](SDValue Op, SDValue OtherOp) {\n      APInt UndefElts;\n      SmallVector<APInt> EltBits;\n      int NumElts = VT.getVectorNumElements();\n      int EltSizeInBits = VT.getScalarSizeInBits();\n      if (!getTargetConstantBitsFromNode(Op, EltSizeInBits, UndefElts, EltBits))\n        return false;\n\n      APInt DemandedElts = APInt::getZero(NumElts);\n      for (int I = 0; I != NumElts; ++I)\n        if (!EltBits[I].isAllOnes())\n          DemandedElts.setBit(I);\n\n      return TLI.SimplifyDemandedVectorElts(OtherOp, DemandedElts, DCI);\n    };\n    if (SimplifyUndemandedElts(N0, N1) || SimplifyUndemandedElts(N1, N0)) {\n      if (N->getOpcode() != ISD::DELETED_NODE)\n        DCI.AddToWorklist(N);\n      return SDValue(N, 0);\n    }\n  }\n\n  // We should fold \"masked merge\" patterns when `andn` is not available.\n  if (!Subtarget.hasBMI() && VT.isScalarInteger() && VT != MVT::i1)\n    if (SDValue R = foldMaskedMerge(N, DAG))\n      return R;\n\n  return SDValue();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        unsigned Val = CN->getZExtValue();\n",
        "src_path": "0513b0305acde91a0a5f7f5ea4061476011f0d1d___X86ISelLowering.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/0513b0305acde91a0a5f7f5ea4061476011f0d1d",
        "commit_msg": "[X86] Avoid miscompile in combineOr (X86ISelLowering.cpp)\n\nIn combineOr (X86ISelLowering.cpp) there is a DAG combine that rewrite\na \"(0 - SetCC) | C\" pattern into something simpler given that a LEA\ncan be used. Another requirement is that C has some specific value,\nfor example 1 or 7. When checking those requirements the code used a\n32-bit unsigned variable to store the value of C. So for a 64-bit OR\nthis could miscompile in case any of the 32 most significant bits in\nC were non zero.\n\nThis patch adds fixes the bug by using a large enough type for the\nC value.\n\nThe faulty code seem to have been introduced by commit 9bceb8981d32fe\n(D131358).\n\nReviewed By: RKSimon\n\nDifferential Revision: https://reviews.llvm.org/D134892",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/X86/or-lea.ll",
                "patch": "@@ -811,10 +811,12 @@ define i64 @or_large_constant(i64 %x) {\n ;\n ; X64-LABEL: or_large_constant:\n ; X64:       # %bb.0: # %entry\n-; X64-NEXT:    xorl %eax, %eax\n+; X64-NEXT:    xorl %ecx, %ecx\n ; X64-NEXT:    cmpq $2, %rdi\n-; X64-NEXT:    setl %al\n-; X64-NEXT:    leaq -1(%rax,%rax), %rax\n+; X64-NEXT:    setge %cl\n+; X64-NEXT:    negq %rcx\n+; X64-NEXT:    movabsq $549755813889, %rax # imm = 0x8000000001\n+; X64-NEXT:    orq %rcx, %rax\n ; X64-NEXT:    retq\n entry:\n   %cmp = icmp sgt i64 %x, 1"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/or-lea.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/or-lea.ll\n\n\nTesting Time: 0.63s\n  Failed: 1\n"
    },
    "dd881c9dbf5d940eedff7d23395141454c5a26b9___DwarfUnit.cpp": {
        "prefix": "DIE &DwarfUnit::constructMemberDIE(DIE &Buffer, const DIDerivedType *DT) {\n  DIE &MemberDie = createAndAddDIE(DT->getTag(), Buffer);\n  StringRef Name = DT->getName();\n  if (!Name.empty())\n    addString(MemberDie, dwarf::DW_AT_name, Name);\n\n  addAnnotation(MemberDie, DT->getAnnotations());\n\n  if (DIType *Resolved = DT->getBaseType())\n    addType(MemberDie, Resolved);\n\n  addSourceLine(MemberDie, DT);\n\n  if (DT->getTag() == dwarf::DW_TAG_inheritance && DT->isVirtual()) {\n\n    // For C++, virtual base classes are not at fixed offset. Use following\n    // expression to extract appropriate offset from vtable.\n    // BaseAddr = ObAddr + *((*ObAddr) - Offset)\n\n    DIELoc *VBaseLocationDie = new (DIEValueAllocator) DIELoc;\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_dup);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_constu);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_udata, DT->getOffsetInBits());\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_minus);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus);\n\n    addBlock(MemberDie, dwarf::DW_AT_data_member_location, VBaseLocationDie);\n  } else {\n    uint64_t Size = DT->getSizeInBits();\n    uint64_t FieldSize = DD->getBaseTypeSize(DT);\n    uint32_t AlignInBytes = DT->getAlignInBytes();\n    uint64_t OffsetInBytes;\n\n",
        "suffix": "    if (IsBitfield) {\n      // Handle bitfield, assume bytes are 8 bits.\n      if (DD->useDWARF2Bitfields())\n        addUInt(MemberDie, dwarf::DW_AT_byte_size, std::nullopt, FieldSize / 8);\n      addUInt(MemberDie, dwarf::DW_AT_bit_size, std::nullopt, Size);\n\n      uint64_t Offset = DT->getOffsetInBits();\n      // We can't use DT->getAlignInBits() here: AlignInBits for member type\n      // is non-zero if and only if alignment was forced (e.g. _Alignas()),\n      // which can't be done with bitfields. Thus we use FieldSize here.\n      uint32_t AlignInBits = FieldSize;\n      uint32_t AlignMask = ~(AlignInBits - 1);\n      // The bits from the start of the storage unit to the start of the field.\n      uint64_t StartBitOffset = Offset - (Offset & AlignMask);\n      // The byte offset of the field's aligned storage unit inside the struct.\n      OffsetInBytes = (Offset - StartBitOffset) / 8;\n\n      if (DD->useDWARF2Bitfields()) {\n        uint64_t HiMark = (Offset + FieldSize) & AlignMask;\n        uint64_t FieldOffset = (HiMark - FieldSize);\n        Offset -= FieldOffset;\n\n        // Maybe we need to work from the other end.\n        if (Asm->getDataLayout().isLittleEndian())\n          Offset = FieldSize - (Offset + Size);\n\n        addUInt(MemberDie, dwarf::DW_AT_bit_offset, std::nullopt, Offset);\n        OffsetInBytes = FieldOffset >> 3;\n      } else {\n        addUInt(MemberDie, dwarf::DW_AT_data_bit_offset, std::nullopt, Offset);\n      }\n    } else {\n      // This is not a bitfield.\n      OffsetInBytes = DT->getOffsetInBits() / 8;\n      if (AlignInBytes)\n        addUInt(MemberDie, dwarf::DW_AT_alignment, dwarf::DW_FORM_udata,\n                AlignInBytes);\n    }\n\n    if (DD->getDwarfVersion() <= 2) {\n      DIELoc *MemLocationDie = new (DIEValueAllocator) DIELoc;\n      addUInt(*MemLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus_uconst);\n      addUInt(*MemLocationDie, dwarf::DW_FORM_udata, OffsetInBytes);\n      addBlock(MemberDie, dwarf::DW_AT_data_member_location, MemLocationDie);\n    } else if (!IsBitfield || DD->useDWARF2Bitfields()) {\n      // In DWARF v3, DW_FORM_data4/8 in DW_AT_data_member_location are\n      // interpreted as location-list pointers. Interpreting constants as\n      // pointers is not expected, so we use DW_FORM_udata to encode the\n      // constants here.\n      if (DD->getDwarfVersion() == 3)\n        addUInt(MemberDie, dwarf::DW_AT_data_member_location,\n                dwarf::DW_FORM_udata, OffsetInBytes);\n      else\n        addUInt(MemberDie, dwarf::DW_AT_data_member_location, std::nullopt,\n                OffsetInBytes);\n    }\n  }\n\n  addAccess(MemberDie, DT->getFlags());\n\n  if (DT->isVirtual())\n    addUInt(MemberDie, dwarf::DW_AT_virtuality, dwarf::DW_FORM_data1,\n            dwarf::DW_VIRTUALITY_virtual);\n\n  // Objective-C properties.\n  if (DINode *PNode = DT->getObjCProperty())\n    if (DIE *PDie = getDIE(PNode))\n      addAttribute(MemberDie, dwarf::DW_AT_APPLE_property,\n                   dwarf::DW_FORM_ref4, DIEEntry(*PDie));\n\n  if (DT->isArtificial())\n    addFlag(MemberDie, dwarf::DW_AT_artificial);\n\n  return MemberDie;\n}\n",
        "start": 1591,
        "end": 1701,
        "buggy": "DIE &DwarfUnit::constructMemberDIE(DIE &Buffer, const DIDerivedType *DT) {\n  DIE &MemberDie = createAndAddDIE(DT->getTag(), Buffer);\n  StringRef Name = DT->getName();\n  if (!Name.empty())\n    addString(MemberDie, dwarf::DW_AT_name, Name);\n\n  addAnnotation(MemberDie, DT->getAnnotations());\n\n  if (DIType *Resolved = DT->getBaseType())\n    addType(MemberDie, Resolved);\n\n  addSourceLine(MemberDie, DT);\n\n  if (DT->getTag() == dwarf::DW_TAG_inheritance && DT->isVirtual()) {\n\n    // For C++, virtual base classes are not at fixed offset. Use following\n    // expression to extract appropriate offset from vtable.\n    // BaseAddr = ObAddr + *((*ObAddr) - Offset)\n\n    DIELoc *VBaseLocationDie = new (DIEValueAllocator) DIELoc;\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_dup);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_constu);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_udata, DT->getOffsetInBits());\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_minus);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus);\n\n    addBlock(MemberDie, dwarf::DW_AT_data_member_location, VBaseLocationDie);\n  } else {\n    uint64_t Size = DT->getSizeInBits();\n    uint64_t FieldSize = DD->getBaseTypeSize(DT);\n    uint32_t AlignInBytes = DT->getAlignInBytes();\n    uint64_t OffsetInBytes;\n\n    bool IsBitfield = FieldSize && Size != FieldSize;\n    if (IsBitfield) {\n      // Handle bitfield, assume bytes are 8 bits.\n      if (DD->useDWARF2Bitfields())\n        addUInt(MemberDie, dwarf::DW_AT_byte_size, std::nullopt, FieldSize / 8);\n      addUInt(MemberDie, dwarf::DW_AT_bit_size, std::nullopt, Size);\n\n      uint64_t Offset = DT->getOffsetInBits();\n      // We can't use DT->getAlignInBits() here: AlignInBits for member type\n      // is non-zero if and only if alignment was forced (e.g. _Alignas()),\n      // which can't be done with bitfields. Thus we use FieldSize here.\n      uint32_t AlignInBits = FieldSize;\n      uint32_t AlignMask = ~(AlignInBits - 1);\n      // The bits from the start of the storage unit to the start of the field.\n      uint64_t StartBitOffset = Offset - (Offset & AlignMask);\n      // The byte offset of the field's aligned storage unit inside the struct.\n      OffsetInBytes = (Offset - StartBitOffset) / 8;\n\n      if (DD->useDWARF2Bitfields()) {\n        uint64_t HiMark = (Offset + FieldSize) & AlignMask;\n        uint64_t FieldOffset = (HiMark - FieldSize);\n        Offset -= FieldOffset;\n\n        // Maybe we need to work from the other end.\n        if (Asm->getDataLayout().isLittleEndian())\n          Offset = FieldSize - (Offset + Size);\n\n        addUInt(MemberDie, dwarf::DW_AT_bit_offset, std::nullopt, Offset);\n        OffsetInBytes = FieldOffset >> 3;\n      } else {\n        addUInt(MemberDie, dwarf::DW_AT_data_bit_offset, std::nullopt, Offset);\n      }\n    } else {\n      // This is not a bitfield.\n      OffsetInBytes = DT->getOffsetInBits() / 8;\n      if (AlignInBytes)\n        addUInt(MemberDie, dwarf::DW_AT_alignment, dwarf::DW_FORM_udata,\n                AlignInBytes);\n    }\n\n    if (DD->getDwarfVersion() <= 2) {\n      DIELoc *MemLocationDie = new (DIEValueAllocator) DIELoc;\n      addUInt(*MemLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus_uconst);\n      addUInt(*MemLocationDie, dwarf::DW_FORM_udata, OffsetInBytes);\n      addBlock(MemberDie, dwarf::DW_AT_data_member_location, MemLocationDie);\n    } else if (!IsBitfield || DD->useDWARF2Bitfields()) {\n      // In DWARF v3, DW_FORM_data4/8 in DW_AT_data_member_location are\n      // interpreted as location-list pointers. Interpreting constants as\n      // pointers is not expected, so we use DW_FORM_udata to encode the\n      // constants here.\n      if (DD->getDwarfVersion() == 3)\n        addUInt(MemberDie, dwarf::DW_AT_data_member_location,\n                dwarf::DW_FORM_udata, OffsetInBytes);\n      else\n        addUInt(MemberDie, dwarf::DW_AT_data_member_location, std::nullopt,\n                OffsetInBytes);\n    }\n  }\n\n  addAccess(MemberDie, DT->getFlags());\n\n  if (DT->isVirtual())\n    addUInt(MemberDie, dwarf::DW_AT_virtuality, dwarf::DW_FORM_data1,\n            dwarf::DW_VIRTUALITY_virtual);\n\n  // Objective-C properties.\n  if (DINode *PNode = DT->getObjCProperty())\n    if (DIE *PDie = getDIE(PNode))\n      addAttribute(MemberDie, dwarf::DW_AT_APPLE_property,\n                   dwarf::DW_FORM_ref4, DIEEntry(*PDie));\n\n  if (DT->isArtificial())\n    addFlag(MemberDie, dwarf::DW_AT_artificial);\n\n  return MemberDie;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    bool IsBitfield = FieldSize && Size != FieldSize;\n",
        "src_path": "dd881c9dbf5d940eedff7d23395141454c5a26b9___DwarfUnit.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/dd881c9dbf5d940eedff7d23395141454c5a26b9",
        "commit_msg": "Revert \"Revert \"[DebugInfo] Correctly recognize bitfields when emitting dwarf\"\"\n\nhttps://reviews.llvm.org/D140195 should have fixed the fail in\ngreen-dragon that was reported in https://reviews.llvm.org/D96334 and\nresulted in the revert.\n\nThis reverts commit 920de9c94caff0b3ac21bf637487b07cb9aea98a.",
        "test_func_diff": [
            {
                "fn": "llvm/test/DebugInfo/AArch64/bitfields.ll",
                "patch": "@@ -24,6 +24,9 @@\n ; CHECK: DW_TAG_member\n ; CHECK-NEXT: DW_AT_name{{.*}}\"b\"\n ; CHECK-NOT: DW_TAG_member\n+; CHECK:      DW_AT_byte_size  {{.*}} (0x04)\n+; CHECK-NEXT: DW_AT_bit_size   {{.*}} (0x20)\n+; CHECK-NEXT: DW_AT_bit_offset {{.*}} (0x00)\n ; CHECK:      DW_AT_data_member_location {{.*}} (DW_OP_plus_uconst 0x4)\n \n ; CHECK: DW_TAG_member\n@@ -63,11 +66,11 @@ target triple = \"aarch64_be--linux-gnu\"\n !5 = !{!0}\n !6 = !DICompositeType(tag: DW_TAG_structure_type, name: \"bitfield\", file: !3, line: 1, size: 96, elements: !7)\n !7 = !{!8, !10, !11, !12}\n-!8 = !DIDerivedType(tag: DW_TAG_member, name: \"a\", scope: !6, file: !3, line: 2, baseType: !9, size: 2)\n+!8 = !DIDerivedType(tag: DW_TAG_member, name: \"a\", scope: !6, file: !3, line: 2, baseType: !9, size: 2, flags: DIFlagBitField)\n !9 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n-!10 = !DIDerivedType(tag: DW_TAG_member, name: \"b\", scope: !6, file: !3, line: 3, baseType: !9, size: 32, offset: 32)\n-!11 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !6, file: !3, line: 4, baseType: !9, size: 1, offset: 64)\n-!12 = !DIDerivedType(tag: DW_TAG_member, name: \"d\", scope: !6, file: !3, line: 5, baseType: !9, size: 28, offset: 65)\n+!10 = !DIDerivedType(tag: DW_TAG_member, name: \"b\", scope: !6, file: !3, line: 3, baseType: !9, size: 32, offset: 32, flags: DIFlagBitField)\n+!11 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !6, file: !3, line: 4, baseType: !9, size: 1, offset: 64, flags: DIFlagBitField)\n+!12 = !DIDerivedType(tag: DW_TAG_member, name: \"d\", scope: !6, file: !3, line: 5, baseType: !9, size: 28, offset: 65, flags: DIFlagBitField)\n !13 = !{i32 2, !\"Dwarf Version\", i32 2}\n !14 = !{i32 2, !\"Debug Info Version\", i32 3}\n !15 = !{i32 1, !\"PIC Level\", i32 2}"
            },
            {
                "fn": "llvm/test/DebugInfo/ARM/big-endian-bitfield.ll",
                "patch": "@@ -27,15 +27,15 @@ target datalayout = \"E-m:e-p:32:32-i64:64-v128:64:128-n32-S64\"\n !5 = !{!0}\n !6 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: \"S\", file: !3, line: 1, size: 32, elements: !7)\n !7 = !{!8, !10, !11, !12}\n-!8 = !DIDerivedType(tag: DW_TAG_member, name: \"j\", scope: !6, file: !3, line: 2, baseType: !9, size: 5)\n+!8 = !DIDerivedType(tag: DW_TAG_member, name: \"j\", scope: !6, file: !3, line: 2, baseType: !9, size: 5, flags: DIFlagBitField)\n ; CHECK: DW_TAG_member\n ; CHECK-NEXT: DW_AT_name{{.*}}\"j\"\n ; CHECK-NOT:  DW_TAG\n ; CHECK:      DW_AT_data_bit_offset      [DW_FORM_data1]\t(0x00)\n !9 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n-!10 = !DIDerivedType(tag: DW_TAG_member, name: \"k\", scope: !6, file: !3, line: 3, baseType: !9, size: 6, offset: 5)\n-!11 = !DIDerivedType(tag: DW_TAG_member, name: \"m\", scope: !6, file: !3, line: 4, baseType: !9, size: 5, offset: 11)\n-!12 = !DIDerivedType(tag: DW_TAG_member, name: \"n\", scope: !6, file: !3, line: 5, baseType: !9, size: 8, offset: 16)\n+!10 = !DIDerivedType(tag: DW_TAG_member, name: \"k\", scope: !6, file: !3, line: 3, baseType: !9, size: 6, offset: 5, flags: DIFlagBitField)\n+!11 = !DIDerivedType(tag: DW_TAG_member, name: \"m\", scope: !6, file: !3, line: 4, baseType: !9, size: 5, offset: 11, flags: DIFlagBitField)\n+!12 = !DIDerivedType(tag: DW_TAG_member, name: \"n\", scope: !6, file: !3, line: 5, baseType: !9, size: 8, offset: 16, flags: DIFlagBitField)\n !13 = !{i32 2, !\"Dwarf Version\", i32 4}\n ; CHECK: DW_TAG_member\n ; CHECK-NEXT: DW_AT_name{{.*}}\"k\""
            },
            {
                "fn": "llvm/test/DebugInfo/ARM/bitfield.ll",
                "patch": "@@ -33,7 +33,7 @@\n !7 = !{!8, !10}\n !8 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !6, file: !3, line: 2, baseType: !9, size: 8, align: 8)\n !9 = !DIBasicType(name: \"char\", size: 8, align: 8, encoding: DW_ATE_signed_char)\n-!10 = !DIDerivedType(tag: DW_TAG_member, name: \"reserved\", scope: !6, file: !3, line: 4, baseType: !11, size: 28, align: 32, offset: 12)\n+!10 = !DIDerivedType(tag: DW_TAG_member, name: \"reserved\", scope: !6, file: !3, line: 4, baseType: !11, size: 28, align: 32, offset: 12, flags: DIFlagBitField)\n !11 = !DIBasicType(name: \"int\", size: 32, align: 32, encoding: DW_ATE_signed)\n !12 = !{i32 2, !\"Dwarf Version\", i32 2}\n !13 = !{i32 2, !\"Debug Info Version\", i32 3}"
            },
            {
                "fn": "llvm/test/DebugInfo/X86/bitfields-dwarf4.ll",
                "patch": "@@ -44,7 +44,7 @@ target triple = \"x86_64-apple-macosx\"\n ; CHECK-NOT:  DW_AT_data_bit_offset\n ; CHECK:      DW_AT_data_member_location [DW_FORM_data1]\t(0x00)\n !9 = !DIBasicType(name: \"char\", size: 8, encoding: DW_ATE_signed_char)\n-!10 = !DIDerivedType(tag: DW_TAG_member, name: \"b\", scope: !6, file: !3, line: 6, baseType: !11, size: 5, offset: 8)\n+!10 = !DIDerivedType(tag: DW_TAG_member, name: \"b\", scope: !6, file: !3, line: 6, baseType: !11, size: 5, offset: 8, flags: DIFlagBitField)\n !11 = !DIDerivedType(tag: DW_TAG_typedef, name: \"uint32_t\", file: !12, line: 183, baseType: !13)\n !12 = !DIFile(filename: \"/Volumes/Data/llvm/_build.ninja.release/bin/../lib/clang/3.9.0/include/stdint.h\", directory: \"/Volumes/Data/llvm\")\n !13 = !DIBasicType(name: \"unsigned int\", size: 32, encoding: DW_ATE_unsigned)\n@@ -57,7 +57,7 @@ target triple = \"x86_64-apple-macosx\"\n ; CHECK-NOT:  DW_AT_byte_size\n ; CHECK-NEXT: DW_AT_data_bit_offset      [DW_FORM_data1]\t(0x08)\n ; CHECK-NOT:  DW_AT_data_member_location\n-!14 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !6, file: !3, line: 7, baseType: !11, size: 27, offset: 13)\n+!14 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !6, file: !3, line: 7, baseType: !11, size: 27, offset: 13, flags: DIFlagBitField)\n !15 = !{i32 2, !\"Dwarf Version\", i32 4}\n !16 = !{i32 2, !\"Debug Info Version\", i32 3}\n !17 = !{i32 1, !\"PIC Level\", i32 2}"
            },
            {
                "fn": "llvm/test/DebugInfo/X86/bitfields.ll",
                "patch": "@@ -63,11 +63,11 @@ target triple = \"x86_64-apple-macosx\"\n !5 = !{!0}\n !6 = !DICompositeType(tag: DW_TAG_structure_type, name: \"bitfield\", file: !3, line: 1, size: 96, elements: !7)\n !7 = !{!8, !10, !11, !12}\n-!8 = !DIDerivedType(tag: DW_TAG_member, name: \"a\", scope: !6, file: !3, line: 2, baseType: !9, size: 2)\n+!8 = !DIDerivedType(tag: DW_TAG_member, name: \"a\", scope: !6, file: !3, line: 2, baseType: !9, size: 2, flags: DIFlagBitField)\n !9 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n-!10 = !DIDerivedType(tag: DW_TAG_member, name: \"b\", scope: !6, file: !3, line: 3, baseType: !9, size: 32, offset: 32)\n-!11 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !6, file: !3, line: 4, baseType: !9, size: 1, offset: 64)\n-!12 = !DIDerivedType(tag: DW_TAG_member, name: \"d\", scope: !6, file: !3, line: 5, baseType: !9, size: 28, offset: 65)\n+!10 = !DIDerivedType(tag: DW_TAG_member, name: \"b\", scope: !6, file: !3, line: 3, baseType: !9, size: 32, offset: 32, flags: DIFlagBitField)\n+!11 = !DIDerivedType(tag: DW_TAG_member, name: \"c\", scope: !6, file: !3, line: 4, baseType: !9, size: 1, offset: 64, flags: DIFlagBitField)\n+!12 = !DIDerivedType(tag: DW_TAG_member, name: \"d\", scope: !6, file: !3, line: 5, baseType: !9, size: 28, offset: 65, flags: DIFlagBitField)\n !13 = !{i32 2, !\"Dwarf Version\", i32 2}\n !14 = !{i32 2, !\"Debug Info Version\", i32 3}\n !15 = !{i32 1, !\"PIC Level\", i32 2}"
            },
            {
                "fn": "llvm/test/DebugInfo/X86/debug-info-packed-struct.ll",
                "patch": "@@ -157,7 +157,7 @@ target triple = \"x86_64-apple-darwin\"\n !12 = !DIBasicType(name: \"char\", size: 8, encoding: DW_ATE_signed_char)\n !13 = !DIDerivedType(tag: DW_TAG_member, name: \"l1_ofs1\", scope: !9, file: !8, line: 36, baseType: !14, size: 64, offset: 8)\n !14 = !DICompositeType(tag: DW_TAG_structure_type, name: \"size8_anon\", file: !8, line: 30, size: 64, elements: !4)\n-!15 = !DIDerivedType(tag: DW_TAG_member, name: \"l1_ofs9\", scope: !9, file: !8, line: 37, baseType: !16, size: 1, offset: 72)\n+!15 = !DIDerivedType(tag: DW_TAG_member, name: \"l1_ofs9\", scope: !9, file: !8, line: 37, baseType: !16, size: 1, offset: 72, flags: DIFlagBitField)\n !16 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n !17 = !DIGlobalVariableExpression(var: !18, expr: !DIExpression())\n !18 = !DIGlobalVariable(name: \"l2\", scope: !2, file: !8, line: 90, type: !19, isLocal: false, isDefinition: true)\n@@ -167,10 +167,10 @@ target triple = \"x86_64-apple-darwin\"\n !22 = !DIDerivedType(tag: DW_TAG_member, name: \"l2_ofs1\", scope: !19, file: !8, line: 56, baseType: !23, size: 64, offset: 8)\n !23 = !DICompositeType(tag: DW_TAG_structure_type, name: \"size8_pack1\", file: !8, line: 50, size: 64, elements: !24)\n !24 = !{!25, !26}\n-!25 = !DIDerivedType(tag: DW_TAG_member, name: \"i\", scope: !23, file: !8, line: 51, baseType: !16, size: 4)\n-!26 = !DIDerivedType(tag: DW_TAG_member, name: \"l\", scope: !23, file: !8, line: 52, baseType: !27, size: 60, offset: 4)\n+!25 = !DIDerivedType(tag: DW_TAG_member, name: \"i\", scope: !23, file: !8, line: 51, baseType: !16, size: 4, flags: DIFlagBitField)\n+!26 = !DIDerivedType(tag: DW_TAG_member, name: \"l\", scope: !23, file: !8, line: 52, baseType: !27, size: 60, offset: 4, flags: DIFlagBitField)\n !27 = !DIBasicType(name: \"long long int\", size: 64, encoding: DW_ATE_signed)\n-!28 = !DIDerivedType(tag: DW_TAG_member, name: \"l2_ofs9\", scope: !19, file: !8, line: 57, baseType: !16, size: 1, offset: 72)\n+!28 = !DIDerivedType(tag: DW_TAG_member, name: \"l2_ofs9\", scope: !19, file: !8, line: 57, baseType: !16, size: 1, offset: 72, flags: DIFlagBitField)\n !29 = !DIGlobalVariableExpression(var: !30, expr: !DIExpression())\n !30 = !DIGlobalVariable(name: \"l3\", scope: !2, file: !8, line: 91, type: !31, isLocal: false, isDefinition: true)\n !31 = !DICompositeType(tag: DW_TAG_structure_type, name: \"layout3\", file: !8, line: 76, size: 128, elements: !32)\n@@ -179,18 +179,18 @@ target triple = \"x86_64-apple-darwin\"\n !34 = !DIDerivedType(tag: DW_TAG_member, name: \"l3_ofs4\", scope: !31, file: !8, line: 78, baseType: !35, size: 64, offset: 32)\n !35 = !DICompositeType(tag: DW_TAG_structure_type, name: \"size8_pack4\", file: !8, line: 72, size: 64, elements: !36)\n !36 = !{!37, !38}\n-!37 = !DIDerivedType(tag: DW_TAG_member, name: \"i\", scope: !35, file: !8, line: 73, baseType: !16, size: 4)\n-!38 = !DIDerivedType(tag: DW_TAG_member, name: \"l\", scope: !35, file: !8, line: 74, baseType: !27, size: 60, offset: 4)\n-!39 = !DIDerivedType(tag: DW_TAG_member, name: \"l3_ofs12\", scope: !31, file: !8, line: 79, baseType: !16, size: 1, offset: 96)\n+!37 = !DIDerivedType(tag: DW_TAG_member, name: \"i\", scope: !35, file: !8, line: 73, baseType: !16, size: 4, flags: DIFlagBitField)\n+!38 = !DIDerivedType(tag: DW_TAG_member, name: \"l\", scope: !35, file: !8, line: 74, baseType: !27, size: 60, offset: 4, flags: DIFlagBitField)\n+!39 = !DIDerivedType(tag: DW_TAG_member, name: \"l3_ofs12\", scope: !31, file: !8, line: 79, baseType: !16, size: 1, offset: 96, flags: DIFlagBitField)\n !40 = !DICompositeType(tag: DW_TAG_structure_type, name: \"layout0\", file: !8, line: 15, size: 192, elements: !41)\n !41 = !{!42, !43, !48}\n !42 = !DIDerivedType(tag: DW_TAG_member, name: \"l0_ofs0\", scope: !40, file: !8, line: 16, baseType: !12, size: 8)\n !43 = !DIDerivedType(tag: DW_TAG_member, name: \"l0_ofs8\", scope: !40, file: !8, line: 17, baseType: !44, size: 64, offset: 64)\n !44 = !DICompositeType(tag: DW_TAG_structure_type, name: \"size8\", file: !8, line: 11, size: 64, elements: !45)\n !45 = !{!46, !47}\n-!46 = !DIDerivedType(tag: DW_TAG_member, name: \"i\", scope: !44, file: !8, line: 12, baseType: !16, size: 4)\n-!47 = !DIDerivedType(tag: DW_TAG_member, name: \"l\", scope: !44, file: !8, line: 13, baseType: !27, size: 60, offset: 4)\n-!48 = !DIDerivedType(tag: DW_TAG_member, name: \"l0_ofs16\", scope: !40, file: !8, line: 18, baseType: !16, size: 1, offset: 128)\n+!46 = !DIDerivedType(tag: DW_TAG_member, name: \"i\", scope: !44, file: !8, line: 12, baseType: !16, size: 4, flags: DIFlagBitField)\n+!47 = !DIDerivedType(tag: DW_TAG_member, name: \"l\", scope: !44, file: !8, line: 13, baseType: !27, size: 60, offset: 4, flags: DIFlagBitField)\n+!48 = !DIDerivedType(tag: DW_TAG_member, name: \"l0_ofs16\", scope: !40, file: !8, line: 18, baseType: !16, size: 1, offset: 128, flags: DIFlagBitField)\n !49 = !{i32 2, !\"Dwarf Version\", i32 2}\n !50 = !{i32 2, !\"Debug Info Version\", i32 3}\n !51 = !{!\"clang version 3.7.0 (trunk 240791) (llvm/trunk 240790)\"}"
            },
            {
                "fn": "llvm/test/DebugInfo/X86/packed_bitfields2.ll",
                "patch": "@@ -0,0 +1,51 @@\n+; RUN: llc -dwarf-version=5 -debugger-tune=lldb -mtriple x86_64-unknown-linux-gnu -O0 -filetype=obj -o %t_2_le.o %s\n+; RUN: llvm-dwarfdump -v -debug-info %t_2_le.o | FileCheck %s\n+\n+; Produced at -O0 from:\n+; struct __attribute__((packed)) bitfield {\n+; \tint i:1;\n+; \tint j:32;\n+; } bitfield;\n+\n+; CHECK: DW_TAG_member\n+; CHECK-NEXT: DW_AT_name{{.*}}\"i\"\n+; CHECK-NOT: DW_TAG_member\n+; CHECK: DW_AT_bit_size   {{.*}} (0x01)\n+; CHECK-NEXT: DW_AT_data_bit_offset {{.*}} (0x00)\n+\n+; CHECK: DW_TAG_member\n+; CHECK-NEXT: DW_AT_name{{.*}}\"j\"\n+; CHECK-NOT: DW_TAG_member\n+; CHECK: DW_AT_bit_size   {{.*}} (0x20)\n+; CHECK-NEXT: DW_AT_data_bit_offset {{.*}} (0x01)\n+\n+; ModuleID = 'packed_bitfields2.c'\n+source_filename = \"packed_bitfields2.c\"\n+target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n+target triple = \"x86_64-pc-linux-gnu\"\n+\n+%struct.bitfield = type { [5 x i8] }\n+\n+@bitfield = dso_local global %struct.bitfield zeroinitializer, align 1, !dbg !0\n+\n+!llvm.dbg.cu = !{!2}\n+!llvm.module.flags = !{!11, !12, !13, !14, !15}\n+!llvm.ident = !{!16}\n+\n+!0 = !DIGlobalVariableExpression(var: !1, expr: !DIExpression())\n+!1 = distinct !DIGlobalVariable(name: \"bitfield\", scope: !2, file: !3, line: 4, type: !6, isLocal: false, isDefinition: true)\n+!2 = distinct !DICompileUnit(language: DW_LANG_C99, file: !3, producer: \"clang version 11.0.1\", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug, enums: !4, globals: !5, splitDebugInlining: false, nameTableKind: None, sysroot: \"/\")\n+!3 = !DIFile(filename: \"packed_bitfields2.c\", directory: \"/\")\n+!4 = !{}\n+!5 = !{!0}\n+!6 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: \"bitfield\", file: !3, line: 1, size: 40, elements: !7)\n+!7 = !{!8, !10}\n+!8 = !DIDerivedType(tag: DW_TAG_member, name: \"i\", scope: !6, file: !3, line: 2, baseType: !9, size: 1, flags: DIFlagBitField, extraData: i64 0)\n+!9 = !DIBasicType(name: \"int\", size: 32, encoding: DW_ATE_signed)\n+!10 = !DIDerivedType(tag: DW_TAG_member, name: \"j\", scope: !6, file: !3, line: 3, baseType: !9, size: 32, offset: 1, flags: DIFlagBitField, extraData: i64 0)\n+!11 = !{i32 7, !\"Dwarf Version\", i32 5}\n+!12 = !{i32 2, !\"Debug Info Version\", i32 3}\n+!13 = !{i32 1, !\"wchar_size\", i32 4}\n+!14 = !{i32 7, !\"PIC Level\", i32 2}\n+!15 = !{i32 7, !\"PIE Level\", i32 2}\n+!16 = !{!\"clang version 11.0.1\"}"
            }
        ],
        "error_msg": "FAIL: LLVM :: DebugInfo/X86/packed_bitfields2.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: DebugInfo/X86/packed_bitfields2.ll\n\n\nTesting Time: 0.12s\n  Failed: 1\n"
    },
    "9497680067cc5a2e7d4e0bf657b23d57c06e5e97___ConstraintSystem.h": {
        "prefix": "",
        "suffix": "",
        "start": 94,
        "end": 94,
        "buggy": "  ArrayRef<int64_t> getLastConstraint() { return Constraints[0]; }\n",
        "fix": null,
        "buggy_hunk_masked": "  ArrayRef<int64_t> getLastConstraint() { return Constraints[0]; }\n",
        "src_path": "9497680067cc5a2e7d4e0bf657b23d57c06e5e97___ConstraintSystem.h",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/9497680067cc5a2e7d4e0bf657b23d57c06e5e97",
        "commit_msg": "[ConstraintElim] Update getLastConstraint to return to last row. (NFC)\n\nThe current code incorrectly returned the first instead of the last row.\nThis fixes the debug output.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/ConstraintElimination/debug.ll",
                "patch": "@@ -16,7 +16,7 @@ define i1 @test_and_ule(i4 %x, i4 %y, i4 %z) {\n ; CHECK: Checking   %t.1 = icmp ule i4 %x, %z\n ; CHECK: Condition   %t.1 = icmp ule i4 %x, %z implied by dominating constraints\n \n-; CHECK: Removing %x + -1 * %y <= 0\n+; CHECK: Removing %y + -1 * %z <= 0\n ; CHECK: Removing %x + -1 * %y <= 0\n \n entry:"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/ConstraintElimination/debug.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/ConstraintElimination/debug.ll\n\n\nTesting Time: 0.37s\n  Failed: 1\n"
    },
    "831e99fee90e9406c7260ca66d688ec353110183___GVNHoist.cpp": {
        "prefix": "void GVNHoist::checkSafety(CHIArgs C, BasicBlock *BB, GVNHoist::InsKind K,\n                           SmallVectorImpl<CHIArg> &Safe) {\n  int NumBBsOnAllPaths = MaxNumberOfBBSInPath;\n  for (auto CHI : C) {\n    Instruction *Insn = CHI.I;\n    if (!Insn) // No instruction was inserted in this CHI.\n      continue;\n    if (K == InsKind::Scalar) {\n      if (safeToHoistScalar(BB, Insn->getParent(), NumBBsOnAllPaths))\n        Safe.push_back(CHI);\n    } else {\n",
        "suffix": "      if (MemoryUseOrDef *UD = MSSA->getMemoryAccess(Insn))\n        if (safeToHoistLdSt(T, Insn, UD, K, NumBBsOnAllPaths))\n          Safe.push_back(CHI);\n    }\n  }\n}\n",
        "start": 808,
        "end": 825,
        "buggy": "void GVNHoist::checkSafety(CHIArgs C, BasicBlock *BB, GVNHoist::InsKind K,\n                           SmallVectorImpl<CHIArg> &Safe) {\n  int NumBBsOnAllPaths = MaxNumberOfBBSInPath;\n  for (auto CHI : C) {\n    Instruction *Insn = CHI.I;\n    if (!Insn) // No instruction was inserted in this CHI.\n      continue;\n    if (K == InsKind::Scalar) {\n      if (safeToHoistScalar(BB, Insn->getParent(), NumBBsOnAllPaths))\n        Safe.push_back(CHI);\n    } else {\n      auto *T = BB->getTerminator();\n      if (MemoryUseOrDef *UD = MSSA->getMemoryAccess(Insn))\n        if (safeToHoistLdSt(T, Insn, UD, K, NumBBsOnAllPaths))\n          Safe.push_back(CHI);\n    }\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      auto *T = BB->getTerminator();\n",
        "src_path": "831e99fee90e9406c7260ca66d688ec353110183___GVNHoist.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/831e99fee90e9406c7260ca66d688ec353110183",
        "commit_msg": "[GVNHoist] don't hoist callbr users into the callbr's block\n\nThis isn't safe to do.\n\nLink: https://github.com/llvm/llvm-project/issues/53562\nFixes: https://github.com/llvm/llvm-project/issues/61023\n\nReviewed By: efriedma, nikic\n\nDifferential Revision: https://reviews.llvm.org/D144927",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/GVNHoist/hoist-call.ll",
                "patch": "@@ -1,13 +1,20 @@\n+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py\n ; RUN: opt -S -passes=gvn-hoist < %s | FileCheck %s\n \n ; Check that the call and fcmp are hoisted.\n-; CHECK-LABEL: define void @fun(\n-; CHECK: call float\n-; CHECK: fcmp oeq\n-; CHECK-NOT: call float\n-; CHECK-NOT: fcmp oeq\n-\n define void @fun(float %__b) minsize {\n+; CHECK-LABEL: @fun(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    br label [[IF_THEN:%.*]]\n+; CHECK:       if.then:\n+; CHECK-NEXT:    [[TMP0:%.*]] = call float @llvm.fabs.f32(float [[__B:%.*]])\n+; CHECK-NEXT:    [[CMPINF7:%.*]] = fcmp oeq float [[TMP0]], 0x7FF0000000000000\n+; CHECK-NEXT:    br i1 undef, label [[IF_THEN8:%.*]], label [[LOR_LHS_FALSE:%.*]]\n+; CHECK:       lor.lhs.false:\n+; CHECK-NEXT:    unreachable\n+; CHECK:       if.then8:\n+; CHECK-NEXT:    ret void\n+;\n entry:\n   br label %if.then\n \n@@ -26,3 +33,171 @@ if.then8:                                         ; preds = %if.then\n }\n \n declare float @llvm.fabs.f32(float)\n+\n+; Check that extractvalues are not hoisted into entry, but that non-dependent\n+; adds are.\n+define i32 @foo(i32 %x) {\n+; CHECK-LABEL: @foo(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[X:%.*]], 1\n+; CHECK-NEXT:    [[TMP0:%.*]] = callbr { i32, i32 } asm sideeffect \"somestuff\", \"=r,=r,!i\"()\n+; CHECK-NEXT:    to label [[ASM_FALLTHROUGH:%.*]] [label %err.split]\n+; CHECK:       asm.fallthrough:\n+; CHECK-NEXT:    [[ASMRESULT:%.*]] = extractvalue { i32, i32 } [[TMP0]], 0\n+; CHECK-NEXT:    ret i32 [[ADD]]\n+; CHECK:       err.split:\n+; CHECK-NEXT:    [[ASMRESULT2:%.*]] = extractvalue { i32, i32 } [[TMP0]], 0\n+; CHECK-NEXT:    ret i32 [[ADD]]\n+;\n+entry:\n+  %0 = callbr { i32, i32 } asm sideeffect \"somestuff\", \"=r,=r,!i\"()\n+  to label %asm.fallthrough [label %err.split]\n+\n+asm.fallthrough:                                  ; preds = %entry\n+  %asmresult = extractvalue { i32, i32 } %0, 0\n+  %add = add nsw i32 %x, 1\n+  ret i32 %add\n+\n+err.split:                                        ; preds = %entry\n+  %asmresult2 = extractvalue { i32, i32 } %0, 0\n+  %add2 = add nsw i32 %x, 1\n+  ret i32 %add2\n+}\n+\n+; Check that extractvalues and dependent adds are not hoisted into entry.\n+define i32 @foo2() {\n+; CHECK-LABEL: @foo2(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    [[TMP0:%.*]] = callbr { i32, i32 } asm sideeffect \"somestuff\", \"=r,=r,!i\"()\n+; CHECK-NEXT:    to label [[ASM_FALLTHROUGH:%.*]] [label %err.split]\n+; CHECK:       asm.fallthrough:\n+; CHECK-NEXT:    [[ASMRESULT:%.*]] = extractvalue { i32, i32 } [[TMP0]], 0\n+; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[ASMRESULT]], 1\n+; CHECK-NEXT:    ret i32 [[ADD]]\n+; CHECK:       err.split:\n+; CHECK-NEXT:    [[ASMRESULT2:%.*]] = extractvalue { i32, i32 } [[TMP0]], 0\n+; CHECK-NEXT:    [[ADD2:%.*]] = add nsw i32 [[ASMRESULT2]], 1\n+; CHECK-NEXT:    ret i32 [[ADD2]]\n+;\n+entry:\n+  %0 = callbr { i32, i32 } asm sideeffect \"somestuff\", \"=r,=r,!i\"()\n+  to label %asm.fallthrough [label %err.split]\n+\n+asm.fallthrough:                                  ; preds = %entry\n+  %asmresult = extractvalue { i32, i32 } %0, 0\n+  %add = add nsw i32 %asmresult, 1\n+  ret i32 %add\n+\n+err.split:                                        ; preds = %entry\n+  %asmresult2 = extractvalue { i32, i32 } %0, 0\n+  %add2 = add nsw i32 %asmresult2, 1\n+  ret i32 %add2\n+}\n+\n+; Ensure we don't hoist loads that are modified by callbr.\n+@x = global i32 0\n+define i32 @foo3() {\n+; CHECK-LABEL: @foo3(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    callbr void asm \"\", \"=*m,!i\"(ptr elementtype(i32) @x)\n+; CHECK-NEXT:    to label [[ASM_FALLTHROUGH:%.*]] [label %err.split]\n+; CHECK:       asm.fallthrough:\n+; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr @x, align 4\n+; CHECK-NEXT:    ret i32 [[TMP0]]\n+; CHECK:       err.split:\n+; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @x, align 4\n+; CHECK-NEXT:    ret i32 [[TMP1]]\n+;\n+entry:\n+  callbr void asm \"\", \"=*m,!i\"(ptr elementtype(i32) @x)\n+  to label %asm.fallthrough [label %err.split]\n+\n+asm.fallthrough:                                  ; preds = %entry\n+  %0 = load i32, ptr @x\n+  ret i32 %0\n+\n+err.split:                                        ; preds = %entry\n+  %1 = load i32, ptr @x\n+  ret i32 %1\n+}\n+\n+; Ensure we do hoist loads that aren't modified by callbr, if the callbr has\n+; the attribute memory(argmem:readwrite).\n+@y = global i32 0\n+define i32 @foo4() {\n+; CHECK-LABEL: @foo4(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr @y, align 4\n+; CHECK-NEXT:    callbr void asm \"\", \"=*m,!i\"(ptr elementtype(i32) @x) #[[ATTR2:[0-9]+]]\n+; CHECK-NEXT:    to label [[A:%.*]] [label %b]\n+; CHECK:       a:\n+; CHECK-NEXT:    ret i32 [[TMP0]]\n+; CHECK:       b:\n+; CHECK-NEXT:    ret i32 [[TMP0]]\n+;\n+entry:\n+  callbr void asm \"\", \"=*m,!i\"(ptr elementtype(i32) @x) memory(argmem: readwrite)\n+  to label %a [label %b]\n+\n+a:                                  ; preds = %entry\n+  %0 = load i32, ptr @y\n+  ret i32 %0\n+\n+b:                                        ; preds = %entry\n+  %1 = load i32, ptr @y\n+  ret i32 %1\n+}\n+\n+; Ensure we don't hoist loads that are modified by callbr, if the callbr has\n+; the attribute memory(argmem:readwrite).\n+define i32 @foo5() {\n+; CHECK-LABEL: @foo5(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    callbr void asm \"\", \"=*m,!i\"(ptr elementtype(i32) @x) #[[ATTR2]]\n+; CHECK-NEXT:    to label [[A:%.*]] [label %b]\n+; CHECK:       a:\n+; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr @x, align 4\n+; CHECK-NEXT:    ret i32 [[TMP0]]\n+; CHECK:       b:\n+; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @x, align 4\n+; CHECK-NEXT:    ret i32 [[TMP1]]\n+;\n+entry:\n+  callbr void asm \"\", \"=*m,!i\"(ptr elementtype(i32) @x) memory(argmem: readwrite)\n+  to label %a [label %b]\n+\n+a:                                  ; preds = %entry\n+  %0 = load i32, ptr @x\n+  ret i32 %0\n+\n+b:                                        ; preds = %entry\n+  %1 = load i32, ptr @x\n+  ret i32 %1\n+}\n+\n+; Ensure we hoist loads that are modified by callbr, if the callbr has the\n+; attribute memory(argmem:none).\n+define i32 @foo6() {\n+; CHECK-LABEL: @foo6(\n+; CHECK-NEXT:  entry:\n+; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr @x, align 4\n+; CHECK-NEXT:    callbr void asm \"\", \"=*m,!i\"(ptr elementtype(i32) @x) #[[ATTR3:[0-9]+]]\n+; CHECK-NEXT:    to label [[A:%.*]] [label %b]\n+; CHECK:       a:\n+; CHECK-NEXT:    ret i32 [[TMP0]]\n+; CHECK:       b:\n+; CHECK-NEXT:    ret i32 [[TMP0]]\n+;\n+entry:\n+  callbr void asm \"\", \"=*m,!i\"(ptr elementtype(i32) @x) memory(argmem: none)\n+  to label %a [label %b]\n+\n+a:                                  ; preds = %entry\n+  %0 = load i32, ptr @x\n+  ret i32 %0\n+\n+b:                                        ; preds = %entry\n+  %1 = load i32, ptr @x\n+  ret i32 %1\n+}\n+"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/GVNHoist/hoist-call.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/GVNHoist/hoist-call.ll\n\n\nTesting Time: 1.96s\n  Failed: 1\n"
    },
    "bef8294650f0119238830d73a7527023c7c8a97f___AsmPrinter.cpp": {
        "prefix": "void AsmPrinter::emitXRayTable() {\n  if (Sleds.empty())\n    return;\n\n  auto PrevSection = OutStreamer->getCurrentSectionOnly();\n  const Function &F = MF->getFunction();\n  MCSection *InstMap = nullptr;\n  MCSection *FnSledIndex = nullptr;\n  const Triple &TT = TM.getTargetTriple();\n  // Use PC-relative addresses on all targets.\n  if (TT.isOSBinFormatELF()) {\n    auto LinkedToSym = cast<MCSymbolELF>(CurrentFnSym);\n    auto Flags = ELF::SHF_ALLOC | ELF::SHF_LINK_ORDER;\n    StringRef GroupName;\n    if (F.hasComdat()) {\n      Flags |= ELF::SHF_GROUP;\n      GroupName = F.getComdat()->getName();\n    }\n    InstMap = OutContext.getELFSection(\"xray_instr_map\", ELF::SHT_PROGBITS,\n                                       Flags, 0, GroupName, F.hasComdat(),\n                                       MCSection::NonUniqueID, LinkedToSym);\n\n    if (TM.Options.XRayFunctionIndex)\n      FnSledIndex = OutContext.getELFSection(\n          \"xray_fn_idx\", ELF::SHT_PROGBITS, Flags, 0, GroupName, F.hasComdat(),\n          MCSection::NonUniqueID, LinkedToSym);\n  } else if (MF->getSubtarget().getTargetTriple().isOSBinFormatMachO()) {\n    InstMap = OutContext.getMachOSection(\"__DATA\", \"xray_instr_map\",\n                                         MachO::S_ATTR_LIVE_SUPPORT,\n                                         SectionKind::getReadOnlyWithRel());\n    if (TM.Options.XRayFunctionIndex)\n      FnSledIndex = OutContext.getMachOSection(\"__DATA\", \"xray_fn_idx\",\n                                               MachO::S_ATTR_LIVE_SUPPORT,\n                                               SectionKind::getReadOnly());\n  } else {\n    llvm_unreachable(\"Unsupported target\");\n  }\n\n  auto WordSizeBytes = MAI->getCodePointerSize();\n\n  // Now we switch to the instrumentation map section. Because this is done\n  // per-function, we are able to create an index entry that will represent the\n  // range of sleds associated with a function.\n  auto &Ctx = OutContext;\n",
        "suffix": "  OutStreamer->switchSection(InstMap);\n  OutStreamer->emitLabel(SledsStart);\n  for (const auto &Sled : Sleds) {\n    MCSymbol *Dot = Ctx.createTempSymbol();\n    OutStreamer->emitLabel(Dot);\n    OutStreamer->emitValueImpl(\n        MCBinaryExpr::createSub(MCSymbolRefExpr::create(Sled.Sled, Ctx),\n                                MCSymbolRefExpr::create(Dot, Ctx), Ctx),\n        WordSizeBytes);\n    OutStreamer->emitValueImpl(\n        MCBinaryExpr::createSub(\n            MCSymbolRefExpr::create(CurrentFnBegin, Ctx),\n            MCBinaryExpr::createAdd(MCSymbolRefExpr::create(Dot, Ctx),\n                                    MCConstantExpr::create(WordSizeBytes, Ctx),\n                                    Ctx),\n            Ctx),\n        WordSizeBytes);\n    Sled.emit(WordSizeBytes, OutStreamer.get());\n  }\n  MCSymbol *SledsEnd = OutContext.createTempSymbol(\"xray_sleds_end\", true);\n  OutStreamer->emitLabel(SledsEnd);\n\n  // We then emit a single entry in the index per function. We use the symbols\n  // that bound the instrumentation map as the range for a specific function.\n  // Each entry here will be 2 * word size aligned, as we're writing down two\n  // pointers. This should work for both 32-bit and 64-bit platforms.\n  if (FnSledIndex) {\n    OutStreamer->switchSection(FnSledIndex);\n    OutStreamer->emitCodeAlignment(Align(2 * WordSizeBytes),\n                                   &getSubtargetInfo());\n    // For Mach-O, use an \"l\" symbol as the atom of this subsection. The label\n    // difference uses a SUBTRACTOR external relocation which references the\n    // symbol.\n    MCSymbol *Dot = Ctx.createLinkerPrivateSymbol(\"xray_fn_idx\");\n    OutStreamer->emitLabel(Dot);\n    OutStreamer->emitValueImpl(\n        MCBinaryExpr::createSub(MCSymbolRefExpr::create(SledsStart, Ctx),\n                                MCSymbolRefExpr::create(Dot, Ctx), Ctx),\n        WordSizeBytes);\n    OutStreamer->emitValueImpl(MCConstantExpr::create(Sleds.size(), Ctx),\n                               WordSizeBytes);\n    OutStreamer->switchSection(PrevSection);\n  }\n  Sleds.clear();\n}\n",
        "start": 3992,
        "end": 4081,
        "buggy": "void AsmPrinter::emitXRayTable() {\n  if (Sleds.empty())\n    return;\n\n  auto PrevSection = OutStreamer->getCurrentSectionOnly();\n  const Function &F = MF->getFunction();\n  MCSection *InstMap = nullptr;\n  MCSection *FnSledIndex = nullptr;\n  const Triple &TT = TM.getTargetTriple();\n  // Use PC-relative addresses on all targets.\n  if (TT.isOSBinFormatELF()) {\n    auto LinkedToSym = cast<MCSymbolELF>(CurrentFnSym);\n    auto Flags = ELF::SHF_ALLOC | ELF::SHF_LINK_ORDER;\n    StringRef GroupName;\n    if (F.hasComdat()) {\n      Flags |= ELF::SHF_GROUP;\n      GroupName = F.getComdat()->getName();\n    }\n    InstMap = OutContext.getELFSection(\"xray_instr_map\", ELF::SHT_PROGBITS,\n                                       Flags, 0, GroupName, F.hasComdat(),\n                                       MCSection::NonUniqueID, LinkedToSym);\n\n    if (TM.Options.XRayFunctionIndex)\n      FnSledIndex = OutContext.getELFSection(\n          \"xray_fn_idx\", ELF::SHT_PROGBITS, Flags, 0, GroupName, F.hasComdat(),\n          MCSection::NonUniqueID, LinkedToSym);\n  } else if (MF->getSubtarget().getTargetTriple().isOSBinFormatMachO()) {\n    InstMap = OutContext.getMachOSection(\"__DATA\", \"xray_instr_map\",\n                                         MachO::S_ATTR_LIVE_SUPPORT,\n                                         SectionKind::getReadOnlyWithRel());\n    if (TM.Options.XRayFunctionIndex)\n      FnSledIndex = OutContext.getMachOSection(\"__DATA\", \"xray_fn_idx\",\n                                               MachO::S_ATTR_LIVE_SUPPORT,\n                                               SectionKind::getReadOnly());\n  } else {\n    llvm_unreachable(\"Unsupported target\");\n  }\n\n  auto WordSizeBytes = MAI->getCodePointerSize();\n\n  // Now we switch to the instrumentation map section. Because this is done\n  // per-function, we are able to create an index entry that will represent the\n  // range of sleds associated with a function.\n  auto &Ctx = OutContext;\n  MCSymbol *SledsStart = OutContext.createTempSymbol(\"xray_sleds_start\", true);\n  OutStreamer->switchSection(InstMap);\n  OutStreamer->emitLabel(SledsStart);\n  for (const auto &Sled : Sleds) {\n    MCSymbol *Dot = Ctx.createTempSymbol();\n    OutStreamer->emitLabel(Dot);\n    OutStreamer->emitValueImpl(\n        MCBinaryExpr::createSub(MCSymbolRefExpr::create(Sled.Sled, Ctx),\n                                MCSymbolRefExpr::create(Dot, Ctx), Ctx),\n        WordSizeBytes);\n    OutStreamer->emitValueImpl(\n        MCBinaryExpr::createSub(\n            MCSymbolRefExpr::create(CurrentFnBegin, Ctx),\n            MCBinaryExpr::createAdd(MCSymbolRefExpr::create(Dot, Ctx),\n                                    MCConstantExpr::create(WordSizeBytes, Ctx),\n                                    Ctx),\n            Ctx),\n        WordSizeBytes);\n    Sled.emit(WordSizeBytes, OutStreamer.get());\n  }\n  MCSymbol *SledsEnd = OutContext.createTempSymbol(\"xray_sleds_end\", true);\n  OutStreamer->emitLabel(SledsEnd);\n\n  // We then emit a single entry in the index per function. We use the symbols\n  // that bound the instrumentation map as the range for a specific function.\n  // Each entry here will be 2 * word size aligned, as we're writing down two\n  // pointers. This should work for both 32-bit and 64-bit platforms.\n  if (FnSledIndex) {\n    OutStreamer->switchSection(FnSledIndex);\n    OutStreamer->emitCodeAlignment(Align(2 * WordSizeBytes),\n                                   &getSubtargetInfo());\n    // For Mach-O, use an \"l\" symbol as the atom of this subsection. The label\n    // difference uses a SUBTRACTOR external relocation which references the\n    // symbol.\n    MCSymbol *Dot = Ctx.createLinkerPrivateSymbol(\"xray_fn_idx\");\n    OutStreamer->emitLabel(Dot);\n    OutStreamer->emitValueImpl(\n        MCBinaryExpr::createSub(MCSymbolRefExpr::create(SledsStart, Ctx),\n                                MCSymbolRefExpr::create(Dot, Ctx), Ctx),\n        WordSizeBytes);\n    OutStreamer->emitValueImpl(MCConstantExpr::create(Sleds.size(), Ctx),\n                               WordSizeBytes);\n    OutStreamer->switchSection(PrevSection);\n  }\n  Sleds.clear();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  MCSymbol *SledsStart = OutContext.createTempSymbol(\"xray_sleds_start\", true);\n",
        "src_path": "bef8294650f0119238830d73a7527023c7c8a97f___AsmPrinter.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/bef8294650f0119238830d73a7527023c7c8a97f",
        "commit_msg": "[XRay] Make xray_instr_map compatible with Mach-O\n\nThe `__DATA,xray_instr_map` section has label differences like\n`.quad Lxray_sled_0-Ltmp0` that is represented as a pair of UNSIGNED and SUBTRACTOR relocations.\n\nLLVM integrated assembler attempts to rewrite A-B into A-B'+offset where B' can\nbe included in the symbol table. B' is called an atom and should be a\nnon-temporary symbol in the same section. However, since `xray_instr_map` does\nnot define a non-temporary symbol, the SUBTRACTOR relocation will have no\nassociated symbol, and its `r_extern` value will be 0. Therefore, we will see\nlinker errors like:\n\n    error: SUBTRACTOR relocation must be extern at offset 0 of __DATA,xray_instr_map in a.o\n\nTo fix this issue, we need to define a non-temporary symbol in the section. We\ncan accomplish this by renaming `Lxray_sleds_start0` to `lxray_sleds_start0`\n(\"L\" to \"l\").\n\n`lxray_sleds_start0` serves as the atom for this dead-strippable subsection.\nWith the `S_ATTR_LIVE_SUPPORT` attribute, `ld -dead_strip` will retain\nsubsections that reference live functions.\n\nSpecial thanks to Oleksii Lozovskyi for reporting the issue and providing\ninitial analysis.\n\nDifferential Revision: https://reviews.llvm.org/D153239",
        "test_func_diff": [
            {
                "fn": "llvm/test/CodeGen/AArch64/xray-attribute-instrumentation.ll",
                "patch": "@@ -22,7 +22,7 @@ define i32 @foo() nounwind noinline uwtable \"function-instrument\"=\"xray-always\"\n ; CHECK-LINUX-LABEL: Lxray_sleds_end0:\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start0:\n+; CHECK-MACOS-LABEL: lxray_sleds_start0:\n ; CHECK-MACOS:         .quad Lxray_sled_0\n ; CHECK-MACOS:         .quad Lxray_sled_1\n ; CHECK-MACOS-LABEL: Lxray_sleds_end0:\n@@ -48,7 +48,7 @@ define i32 @bar() nounwind noinline uwtable \"function-instrument\"=\"xray-never\" \"\n ; CHECK-LINUX-LABEL: Lxray_sleds_end1:\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start1:\n+; CHECK-MACOS-LABEL: lxray_sleds_start1:\n ; CHECK-MACOS:         .quad Lxray_sled_2\n ; CHECK-MACOS:         .quad Lxray_sled_3\n ; CHECK-MACOS-LABEL: Lxray_sleds_end1:\n@@ -74,7 +74,7 @@ define i32 @instrumented() nounwind noinline uwtable \"xray-instruction-threshold\n ; CHECK-LINUX-LABEL: Lxray_sleds_end2:\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start2:\n+; CHECK-MACOS-LABEL: lxray_sleds_start2:\n ; CHECK-MACOS:         .quad Lxray_sled_4\n ; CHECK-MACOS:         .quad Lxray_sled_5\n ; CHECK-MACOS-LABEL: Lxray_sleds_end2:"
            },
            {
                "fn": "llvm/test/CodeGen/AArch64/xray-omit-function-index.ll",
                "patch": "@@ -32,7 +32,7 @@ define i32 @foo() nounwind noinline uwtable \"function-instrument\"=\"xray-always\"\n ; CHECK-LINUX-LABEL: Lxray_sleds_end0:\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start0:\n+; CHECK-MACOS-LABEL: lxray_sleds_start0:\n ; CHECK-MACOS:         .quad Lxray_sled_0\n ; CHECK-MACOS:         .quad Lxray_sled_1\n ; CHECK-MACOS-LABEL: Lxray_sleds_end0:"
            },
            {
                "fn": "llvm/test/CodeGen/AArch64/xray-partial-instrumentation-skip-entry.ll",
                "patch": "@@ -23,6 +23,6 @@ define i32 @foo() nounwind noinline uwtable \"function-instrument\"=\"xray-always\"\n ; CHECK-LINUX-LABEL: Lxray_sleds_end0:\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start0:\n+; CHECK-MACOS-LABEL: lxray_sleds_start0:\n ; CHECK-MACOS:         .quad Lxray_sled_0\n ; CHECK-MACOS-LABEL: Lxray_sleds_end0:"
            },
            {
                "fn": "llvm/test/CodeGen/AArch64/xray-partial-instrumentation-skip-exit.ll",
                "patch": "@@ -23,6 +23,6 @@ define i32 @foo() nounwind noinline uwtable \"function-instrument\"=\"xray-always\"\n ; CHECK-LINUX-LABEL: Lxray_sleds_end0:\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start0:\n+; CHECK-MACOS-LABEL: lxray_sleds_start0:\n ; CHECK-MACOS:         .quad Lxray_sled_0\n ; CHECK-MACOS-LABEL: Lxray_sleds_end0:"
            },
            {
                "fn": "llvm/test/CodeGen/AArch64/xray-tail-call-sled.ll",
                "patch": "@@ -29,15 +29,15 @@ define i32 @callee() nounwind noinline uwtable \"function-instrument\"=\"xray-alway\n ; CHECK-LINUX-NEXT:    .xword 2\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start0:\n+; CHECK-MACOS-LABEL: lxray_sleds_start0:\n ; CHECK-MACOS-NEXT:  [[TMP:Ltmp[0-9]+]]:\n ; CHECK-MACOS:         .quad Lxray_sled_0-[[TMP]]\n ; CHECK-MACOS:       [[TMP:Ltmp[0-9]+]]:\n ; CHECK-MACOS-NEXT:    .quad Lxray_sled_1-[[TMP]]\n ; CHECK-MACOS-LABEL: Lxray_sleds_end0:\n ; CHECK-MACOS-LABEL: .section __DATA,xray_fn_idx,regular,live_support{{$}}\n ; CHECK-MACOS:       [[IDX:lxray_fn_idx[0-9]+]]:\n-; CHECK-MACOS-NEXT:    .quad Lxray_sleds_start0-[[IDX]]\n+; CHECK-MACOS-NEXT:    .quad lxray_sleds_start0-[[IDX]]\n ; CHECK-MACOS-NEXT:    .quad 2\n \n define i32 @caller() nounwind noinline uwtable \"function-instrument\"=\"xray-always\" {\n@@ -68,11 +68,11 @@ define i32 @caller() nounwind noinline uwtable \"function-instrument\"=\"xray-alway\n ; CHECK-LINUX-NEXT:    .xword 2\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start1:\n+; CHECK-MACOS-LABEL: lxray_sleds_start1:\n ; CHECK-MACOS:         .quad Lxray_sled_2\n ; CHECK-MACOS:         .quad Lxray_sled_3\n ; CHECK-MACOS-LABEL: Lxray_sleds_end1:\n ; CHECK-MACOS-LABEL: .section __DATA,xray_fn_idx,regular,live_support{{$}}\n ; CHECK-MACOS:       [[IDX:lxray_fn_idx[0-9]+]]:\n-; CHECK-MACOS-NEXT:    .quad Lxray_sleds_start1-[[IDX]]\n+; CHECK-MACOS-NEXT:    .quad lxray_sleds_start1-[[IDX]]\n ; CHECK-MACOS-NEXT:    .quad 2"
            },
            {
                "fn": "llvm/test/CodeGen/ARM/xray-armv6-attribute-instrumentation.ll",
                "patch": "@@ -34,10 +34,10 @@ define i32 @foo() nounwind noinline uwtable \"function-instrument\"=\"xray-always\"\n ; CHECK-LINUX-NEXT:    .long 2\n \n ; CHECK-IOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-IOS-LABEL: Lxray_sleds_start0:\n+; CHECK-IOS-LABEL: lxray_sleds_start0:\n ; CHECK-IOS:         .long Lxray_sled_0\n ; CHECK-IOS:         .long Lxray_sled_1\n ; CHECK-IOS-LABEL: Lxray_sleds_end0:\n ; CHECK-IOS-LABEL: .section __DATA,xray_fn_idx,regular,live_support{{$}}\n-; CHECK-IOS:         .long Lxray_sleds_start0-lxray_fn_idx0\n+; CHECK-IOS:         .long lxray_sleds_start0-lxray_fn_idx0\n ; CHECK-IOS-NEXT:    .long 2"
            },
            {
                "fn": "llvm/test/CodeGen/ARM/xray-armv7-attribute-instrumentation.ll",
                "patch": "@@ -25,11 +25,11 @@ define i32 @foo() nounwind noinline uwtable \"function-instrument\"=\"xray-always\"\n ; CHECK-LINUX-NEXT:    .long 2\n \n ; CHECK-IOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-IOS-LABEL: Lxray_sleds_start0:\n+; CHECK-IOS-LABEL: lxray_sleds_start0:\n ; CHECK-IOS:         .long Lxray_sled_0\n ; CHECK-IOS:         .long Lxray_sled_1\n ; CHECK-IOS-LABEL: Lxray_sleds_end0:\n ; CHECK-IOS-LABEL: .section __DATA,xray_fn_idx,regular,live_support{{$}}\n ; CHECK-IOS:       lxray_fn_idx0:\n-; CHECK-IOS:         .long Lxray_sleds_start0-lxray_fn_idx0\n+; CHECK-IOS:         .long lxray_sleds_start0-lxray_fn_idx0\n ; CHECK-IOS-NEXT:    .long 2"
            },
            {
                "fn": "llvm/test/CodeGen/X86/xray-attribute-instrumentation.ll",
                "patch": "@@ -25,13 +25,13 @@ define i32 @foo() nounwind noinline uwtable \"function-instrument\"=\"xray-always\"\n ; CHECK-LINUX-NEXT:    .quad 2\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start0:\n+; CHECK-MACOS-LABEL: lxray_sleds_start0:\n ; CHECK-MACOS:         .quad Lxray_sled_0\n ; CHECK-MACOS:         .quad Lxray_sled_1\n ; CHECK-MACOS-LABEL: Lxray_sleds_end0:\n ; CHECK-MACOS-LABEL: .section __DATA,xray_fn_idx,regular,live_support{{$}}\n ; CHECK-MACOS:       [[IDX:lxray_fn_idx[0-9]+]]:\n-; CHECK-MACOS-NEXT:    .quad Lxray_sleds_start0-[[IDX]]\n+; CHECK-MACOS-NEXT:    .quad lxray_sleds_start0-[[IDX]]\n ; CHECK-MACOS-NEXT:    .quad 2\n \n \n@@ -74,7 +74,7 @@ NotEqual:\n ; CHECK-LINUX-NEXT:    .quad 3\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start1:\n+; CHECK-MACOS-LABEL: lxray_sleds_start1:\n ; CHECK-MACOS:       [[TMP:Ltmp[0-9]+]]:\n ; CHECK-MACOS-NEXT:    .quad Lxray_sled_2-[[TMP]]\n ; CHECK-MACOS:       [[TMP:Ltmp[0-9]+]]:\n@@ -84,5 +84,5 @@ NotEqual:\n ; CHECK-MACOS-LABEL: Lxray_sleds_end1:\n ; CHECK-MACOS-LABEL: .section __DATA,xray_fn_idx,regular,live_support{{$}}\n ; CHECK-MACOS:       [[IDX:lxray_fn_idx[0-9]+]]:\n-; CHECK-MACOS-NEXT:    .quad Lxray_sleds_start1-[[IDX]]\n+; CHECK-MACOS-NEXT:    .quad lxray_sleds_start1-[[IDX]]\n ; CHECK-MACOS-NEXT:    .quad 3"
            },
            {
                "fn": "llvm/test/CodeGen/X86/xray-log-args.ll",
                "patch": "@@ -25,7 +25,7 @@ define i32 @callee(i32 %arg) nounwind noinline uwtable \"function-instrument\"=\"xr\n ; CHECK-LINUX-NEXT:    .byte 0x02\n ; CHECK-LINUX:         .zero 13\n \n-; CHECK-MACOS-LABEL: Lxray_sleds_start0:\n+; CHECK-MACOS-LABEL: lxray_sleds_start0:\n ; CHECK-MACOS-NEXT:  [[TMP:Ltmp[0-9]+]]:\n ; CHECK-MACOS-NEXT:    .quad Lxray_sled_0-[[TMP]]\n ; CHECK-MACOS-NEXT:    .quad Lfunc_begin0-([[TMP]]+8)\n@@ -62,7 +62,7 @@ define i32 @caller(i32 %arg) nounwind noinline uwtable \"function-instrument\"=\"xr\n ; CHECK-LINUX-NEXT:    .byte 0x02\n ; CHECK-LINUX:         .zero 13\n \n-; CHECK-MACOS-LABEL: Lxray_sleds_start1:\n+; CHECK-MACOS-LABEL: lxray_sleds_start1:\n ; CHECK-MACOS-NEXT:  [[TMP:Ltmp[0-9]+]]:\n ; CHECK-MACOS-NEXT:    .quad Lxray_sled_2-[[TMP]]\n ; CHECK-MACOS-NEXT:    .quad Lfunc_begin1-([[TMP]]+8)"
            },
            {
                "fn": "llvm/test/CodeGen/X86/xray-partial-instrumentation-skip-entry.ll",
                "patch": "@@ -21,12 +21,12 @@ define i32 @foo() nounwind noinline uwtable \"function-instrument\"=\"xray-always\"\n ; CHECK-LINUX-NEXT:    .quad 1\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start0:\n+; CHECK-MACOS-LABEL: lxray_sleds_start0:\n ; CHECK-MACOS:         .quad Lxray_sled_0\n ; CHECK-MACOS-LABEL: Lxray_sleds_end0:\n ; CHECK-MACOS-LABEL: .section __DATA,xray_fn_idx,regular,live_support{{$}}\n ; CHECK-MACOS:       [[IDX:lxray_fn_idx[0-9]+]]:\n-; CHECK-MACOS-NEXT:    .quad Lxray_sleds_start0-[[IDX]]\n+; CHECK-MACOS-NEXT:    .quad lxray_sleds_start0-[[IDX]]\n ; CHECK-MACOS-NEXT:    .quad 1\n \n \n@@ -62,11 +62,11 @@ NotEqual:\n ; CHECK-LINUX-NEXT:    .quad 2\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start1:\n+; CHECK-MACOS-LABEL: lxray_sleds_start1:\n ; CHECK-MACOS:         .quad Lxray_sled_1\n ; CHECK-MACOS:         .quad Lxray_sled_2\n ; CHECK-MACOS-LABEL: Lxray_sleds_end1:\n ; CHECK-MACOS-LABEL: .section __DATA,xray_fn_idx,regular,live_support{{$}}\n ; CHECK-MACOS:       [[IDX:lxray_fn_idx[0-9]+]]:\n-; CHECK-MACOS-NEXT:    .quad Lxray_sleds_start1-[[IDX]]\n+; CHECK-MACOS-NEXT:    .quad lxray_sleds_start1-[[IDX]]\n ; CHECK-MACOS-NEXT:    .quad 2"
            },
            {
                "fn": "llvm/test/CodeGen/X86/xray-partial-instrumentation-skip-exit.ll",
                "patch": "@@ -18,15 +18,17 @@ define i32 @foo() nounwind noinline uwtable \"function-instrument\"=\"xray-always\"\n ; CHECK-LINUX:         .quad .Lxray_sled_0\n ; CHECK-LINUX-LABEL: .Lxray_sleds_end0:\n ; CHECK-LINUX-LABEL: .section xray_fn_idx,\"awo\",@progbits,foo{{$}}\n-; CHECK-LINUX:         .quad .Lxray_sleds_start0\n+; CHECK-LINUX:       [[IDX:.lxray_fn_idx[0-9]+]]:\n+; CHECK-LINUX:         .quad .Lxray_sleds_start0-[[IDX]]\n ; CHECK-LINUX-NEXT:    .quad .Lxray_sleds_end0\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start0:\n+; CHECK-MACOS-LABEL: lxray_sleds_start0:\n ; CHECK-MACOS:         .quad Lxray_sled_0\n ; CHECK-MACOS-LABEL: Lxray_sleds_end0:\n ; CHECK-MACOS-LABEL: .section __DATA,xray_fn_idx,regular,live_support{{$}}\n-; CHECK-MACOS:         .quad Lxray_sleds_start0\n+; CHECK-MACOS:       [[IDX:lxray_fn_idx[0-9]+]]:\n+; CHECK-MACOS:         .quad lxray_sleds_start0-[[IDX]]\n ; CHECK-MACOS-NEXT:    .quad Lxray_sleds_end0\n \n \n@@ -57,13 +59,13 @@ NotEqual:\n ; CHECK-LINUX-LABEL: .section xray_fn_idx,\"awo\",@progbits,bar{[$}}\n ; CHECK-LINUX:       .Lxray_fn_idx0:\n ; CHECK-LINUX-NEXT:    .quad .Lxray_sleds_start1-.Lxray_fn_idx0\n-; CHECK-LINUX-NEXT:    .quad .Lxray_sleds_end1\n+; CHECK-LINUX-NEXT:    .quad 2\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start1:\n+; CHECK-MACOS-LABEL: lxray_sleds_start1:\n ; CHECK-MACOS:         .quad Lxray_sled_1\n ; CHECK-MACOS-LABEL: Lxray_sleds_end1:\n ; CHECK-MACOS-LABEL: .section __DATA,xray_fn_idx,regular,live_support{{$}}\n ; CHECK-MACOS:       Lxray_fn_idx0:\n ; CHECK-MACOS-NEXT:    .quad Lxray_sleds_start1-Lxray_fn_idx0\n-; CHECK-MACOS-NEXT:    .quad Lxray_sleds_end1\n+; CHECK-MACOS-NEXT:    .quad 2"
            },
            {
                "fn": "llvm/test/CodeGen/X86/xray-tail-call-sled.ll",
                "patch": "@@ -24,13 +24,13 @@ define dso_local i32 @callee() nounwind noinline uwtable \"function-instrument\"=\"\n ; CHECK-LINUX-NEXT:    .quad 2\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start0:\n+; CHECK-MACOS-LABEL: lxray_sleds_start0:\n ; CHECK-MACOS:         .quad Lxray_sled_0\n ; CHECK-MACOS:         .quad Lxray_sled_1\n ; CHECK-MACOS-LABEL: Lxray_sleds_end0:\n ; CHECK-MACOS-LABEL: .section __DATA,xray_fn_idx,regular,live_support{{$}}\n ; CHECK-MACOS:       [[IDX:lxray_fn_idx[0-9]+]]:\n-; CHECK-MACOS-NEXT:    .quad Lxray_sleds_start0-[[IDX]]\n+; CHECK-MACOS-NEXT:    .quad lxray_sleds_start0-[[IDX]]\n ; CHECK-MACOS-NEXT:    .quad 2\n \n define dso_local i32 @caller() nounwind noinline uwtable \"function-instrument\"=\"xray-always\" {\n@@ -58,11 +58,11 @@ define dso_local i32 @caller() nounwind noinline uwtable \"function-instrument\"=\"\n ; CHECK-LINUX-NEXT:    .quad 2\n \n ; CHECK-MACOS-LABEL: .section __DATA,xray_instr_map,regular,live_support{{$}}\n-; CHECK-MACOS-LABEL: Lxray_sleds_start1:\n+; CHECK-MACOS-LABEL: lxray_sleds_start1:\n ; CHECK-MACOS:         .quad Lxray_sled_2\n ; CHECK-MACOS:         .quad Lxray_sled_3\n ; CHECK-MACOS-LABEL: Lxray_sleds_end1:\n ; CHECK-MACOS-LABEL: .section __DATA,xray_fn_idx,regular,live_support{{$}}\n ; CHECK-MACOS:       [[IDX:lxray_fn_idx[0-9]+]]:\n-; CHECK-MACOS-NEXT:    .quad Lxray_sleds_start1-[[IDX]]\n+; CHECK-MACOS-NEXT:    .quad lxray_sleds_start1-[[IDX]]\n ; CHECK-MACOS-NEXT:    .quad 2"
            }
        ],
        "error_msg": "FAIL: LLVM :: CodeGen/X86/xray-attribute-instrumentation.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/xray-attribute-instrumentation.ll\n\n\nTesting Time: 0.38s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/xray-log-args.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/xray-log-args.ll\n\n\nTesting Time: 0.21s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/xray-partial-instrumentation-skip-entry.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/xray-partial-instrumentation-skip-entry.ll\n\n\nTesting Time: 0.30s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nPASS: LLVM :: CodeGen/X86/xray-partial-instrumentation-skip-exit.ll (1 of 1)\n\nTesting Time: 0.27s\n  Passed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/xray-tail-call-sled.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/xray-tail-call-sled.ll\n\n\nTesting Time: 0.21s\n  Failed: 1\n"
    },
    "c15ccfb24afa67d3c3f54e52cc1d1afa564715ed___InstructionCombining.cpp": {
        "prefix": "Instruction *\nInstCombinerImpl::foldBinOpOfSelectAndCastOfSelectCondition(BinaryOperator &I) {\n  // TODO: this simplification may be extended to any speculatable instruction,\n  // not just binops, and would possibly be handled better in FoldOpIntoSelect.\n  Instruction::BinaryOps Opc = I.getOpcode();\n  Value *LHS = I.getOperand(0), *RHS = I.getOperand(1);\n  Value *A, *CondVal, *TrueVal, *FalseVal;\n  Value *CastOp;\n\n  auto MatchSelectAndCast = [&](Value *CastOp, Value *SelectOp) {\n    return match(CastOp, m_ZExtOrSExt(m_Value(A))) &&\n           A->getType()->getScalarSizeInBits() == 1 &&\n           match(SelectOp, m_Select(m_Value(CondVal), m_Value(TrueVal),\n                                    m_Value(FalseVal)));\n  };\n\n  // Make sure one side of the binop is a select instruction, and the other is a\n  // zero/sign extension operating on a i1.\n  if (MatchSelectAndCast(LHS, RHS))\n    CastOp = LHS;\n  else if (MatchSelectAndCast(RHS, LHS))\n    CastOp = RHS;\n  else\n    return nullptr;\n\n  auto NewFoldedConst = [&](bool IsTrueArm, Value *V) {\n    bool IsCastOpRHS = (CastOp == RHS);\n",
        "suffix": "    Constant *C;\n\n    if (IsTrueArm) {\n      C = Constant::getNullValue(V->getType());\n    } else if (IsZExt) {\n      unsigned BitWidth = V->getType()->getScalarSizeInBits();\n      C = Constant::getIntegerValue(V->getType(), APInt(BitWidth, 1));\n    } else {\n      C = Constant::getAllOnesValue(V->getType());\n    }\n\n    return IsCastOpRHS ? Builder.CreateBinOp(Opc, V, C)\n                       : Builder.CreateBinOp(Opc, C, V);\n  };\n\n  // If the value used in the zext/sext is the select condition, or the negated\n  // of the select condition, the binop can be simplified.\n  if (CondVal == A) {\n    Value *NewTrueVal = NewFoldedConst(false, TrueVal);\n    return SelectInst::Create(CondVal, NewTrueVal,\n                              NewFoldedConst(true, FalseVal));\n  }\n\n  if (match(A, m_Not(m_Specific(CondVal)))) {\n    Value *NewTrueVal = NewFoldedConst(true, TrueVal);\n    return SelectInst::Create(CondVal, NewTrueVal,\n                              NewFoldedConst(false, FalseVal));\n  }\n\n  return nullptr;\n}\n",
        "start": 884,
        "end": 942,
        "buggy": "Instruction *\nInstCombinerImpl::foldBinOpOfSelectAndCastOfSelectCondition(BinaryOperator &I) {\n  // TODO: this simplification may be extended to any speculatable instruction,\n  // not just binops, and would possibly be handled better in FoldOpIntoSelect.\n  Instruction::BinaryOps Opc = I.getOpcode();\n  Value *LHS = I.getOperand(0), *RHS = I.getOperand(1);\n  Value *A, *CondVal, *TrueVal, *FalseVal;\n  Value *CastOp;\n\n  auto MatchSelectAndCast = [&](Value *CastOp, Value *SelectOp) {\n    return match(CastOp, m_ZExtOrSExt(m_Value(A))) &&\n           A->getType()->getScalarSizeInBits() == 1 &&\n           match(SelectOp, m_Select(m_Value(CondVal), m_Value(TrueVal),\n                                    m_Value(FalseVal)));\n  };\n\n  // Make sure one side of the binop is a select instruction, and the other is a\n  // zero/sign extension operating on a i1.\n  if (MatchSelectAndCast(LHS, RHS))\n    CastOp = LHS;\n  else if (MatchSelectAndCast(RHS, LHS))\n    CastOp = RHS;\n  else\n    return nullptr;\n\n  auto NewFoldedConst = [&](bool IsTrueArm, Value *V) {\n    bool IsCastOpRHS = (CastOp == RHS);\n    bool IsZExt = isa<ZExtInst>(CastOp);\n    Constant *C;\n\n    if (IsTrueArm) {\n      C = Constant::getNullValue(V->getType());\n    } else if (IsZExt) {\n      unsigned BitWidth = V->getType()->getScalarSizeInBits();\n      C = Constant::getIntegerValue(V->getType(), APInt(BitWidth, 1));\n    } else {\n      C = Constant::getAllOnesValue(V->getType());\n    }\n\n    return IsCastOpRHS ? Builder.CreateBinOp(Opc, V, C)\n                       : Builder.CreateBinOp(Opc, C, V);\n  };\n\n  // If the value used in the zext/sext is the select condition, or the negated\n  // of the select condition, the binop can be simplified.\n  if (CondVal == A) {\n    Value *NewTrueVal = NewFoldedConst(false, TrueVal);\n    return SelectInst::Create(CondVal, NewTrueVal,\n                              NewFoldedConst(true, FalseVal));\n  }\n\n  if (match(A, m_Not(m_Specific(CondVal)))) {\n    Value *NewTrueVal = NewFoldedConst(true, TrueVal);\n    return SelectInst::Create(CondVal, NewTrueVal,\n                              NewFoldedConst(false, FalseVal));\n  }\n\n  return nullptr;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    bool IsZExt = isa<ZExtInst>(CastOp);\n",
        "src_path": "c15ccfb24afa67d3c3f54e52cc1d1afa564715ed___InstructionCombining.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/c15ccfb24afa67d3c3f54e52cc1d1afa564715ed",
        "commit_msg": "[InstCombine] Fix select + cast fold with constant expression (PR64669)\n\nThe zext constant expression was detected by the fold, but then\nhandled as a sext. Use ZExtOperator instead of ZExtInst to handle\nconstant expressions.\n\nFixes https://github.com/llvm/llvm-project/issues/64669.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/InstCombine/binop-select-cast-of-select-cond.ll",
                "patch": "@@ -224,3 +224,19 @@ define <2 x i8> @vectorized_add(<2 x i1> %c, <2 x i8> %arg) {\n   %add = add <2 x i8> %sel, %zext\n   ret <2 x i8> %add\n }\n+\n+@b = external global [72 x i32]\n+@c = external global i32\n+\n+define i64 @pr64669(i64 %a) {\n+; CHECK-LABEL: define i64 @pr64669\n+; CHECK-SAME: (i64 [[A:%.*]]) {\n+; CHECK-NEXT:    [[TMP1:%.*]] = add i64 [[A]], 1\n+; CHECK-NEXT:    [[ADD:%.*]] = select i1 icmp ne (ptr getelementptr inbounds ([72 x i32], ptr @b, i64 0, i64 25), ptr @c), i64 [[TMP1]], i64 0\n+; CHECK-NEXT:    ret i64 [[ADD]]\n+;\n+  %mul = select i1 icmp ne (ptr getelementptr inbounds ([72 x i32], ptr @b, i64 0, i64 25), ptr @c), i64 %a, i64 0\n+  %conv3 = zext i1 icmp ne (ptr getelementptr inbounds ([72 x i32], ptr @b, i64 0, i64 25), ptr @c) to i64\n+  %add = add nsw i64 %mul, %conv3\n+  ret i64 %add\n+}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/binop-select-cast-of-select-cond.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/binop-select-cast-of-select-cond.ll\n\n\nTesting Time: 0.34s\n  Failed: 1\n"
    },
    "57a554800b804a0d849858972822142e1f75d37f___SROA.cpp": {
        "prefix": "  bool visitLoadInst(LoadInst &LI) {\n    LLVM_DEBUG(dbgs() << \"    original: \" << LI << \"\\n\");\n    Value *OldOp = LI.getOperand(0);\n    assert(OldOp == OldPtr);\n\n    AAMDNodes AATags = LI.getAAMetadata();\n\n    unsigned AS = LI.getPointerAddressSpace();\n\n    Type *TargetTy = IsSplit ? Type::getIntNTy(LI.getContext(), SliceSize * 8)\n                             : LI.getType();\n    const bool IsLoadPastEnd =\n        DL.getTypeStoreSize(TargetTy).getFixedValue() > SliceSize;\n    bool IsPtrAdjusted = false;\n    Value *V;\n    if (VecTy) {\n      V = rewriteVectorizedLoadInst(LI);\n    } else if (IntTy && LI.getType()->isIntegerTy()) {\n      V = rewriteIntegerLoad(LI);\n    } else if (NewBeginOffset == NewAllocaBeginOffset &&\n               NewEndOffset == NewAllocaEndOffset &&\n               (canConvertValue(DL, NewAllocaTy, TargetTy) ||\n                (IsLoadPastEnd && NewAllocaTy->isIntegerTy() &&\n",
        "suffix": "      Value *NewPtr =\n          getPtrToNewAI(LI.getPointerAddressSpace(), LI.isVolatile());\n      LoadInst *NewLI = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), NewPtr,\n                                              NewAI.getAlign(), LI.isVolatile(),\n                                              LI.getName());\n      if (LI.isVolatile())\n        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());\n      if (NewLI->isAtomic())\n        NewLI->setAlignment(LI.getAlign());\n\n      // Copy any metadata that is valid for the new load. This may require\n      // conversion to a different kind of metadata, e.g. !nonnull might change\n      // to !range or vice versa.\n      copyMetadataForLoad(*NewLI, LI);\n\n      // Do this after copyMetadataForLoad() to preserve the TBAA shift.\n      if (AATags)\n        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));\n\n      // Try to preserve nonnull metadata\n      V = NewLI;\n\n      // If this is an integer load past the end of the slice (which means the\n      // bytes outside the slice are undef or this load is dead) just forcibly\n      // fix the integer size with correct handling of endianness.\n      if (auto *AITy = dyn_cast<IntegerType>(NewAllocaTy))\n        if (auto *TITy = dyn_cast<IntegerType>(TargetTy))\n          if (AITy->getBitWidth() < TITy->getBitWidth()) {\n            V = IRB.CreateZExt(V, TITy, \"load.ext\");\n            if (DL.isBigEndian())\n              V = IRB.CreateShl(V, TITy->getBitWidth() - AITy->getBitWidth(),\n                                \"endian_shift\");\n          }\n    } else {\n      Type *LTy = TargetTy->getPointerTo(AS);\n      LoadInst *NewLI =\n          IRB.CreateAlignedLoad(TargetTy, getNewAllocaSlicePtr(IRB, LTy),\n                                getSliceAlign(), LI.isVolatile(), LI.getName());\n      if (AATags)\n        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));\n      if (LI.isVolatile())\n        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());\n      NewLI->copyMetadata(LI, {LLVMContext::MD_mem_parallel_loop_access,\n                               LLVMContext::MD_access_group});\n\n      V = NewLI;\n      IsPtrAdjusted = true;\n    }\n    V = convertValue(DL, IRB, V, TargetTy);\n\n    if (IsSplit) {\n      assert(!LI.isVolatile());\n      assert(LI.getType()->isIntegerTy() &&\n             \"Only integer type loads and stores are split\");\n      assert(SliceSize < DL.getTypeStoreSize(LI.getType()).getFixedValue() &&\n             \"Split load isn't smaller than original load\");\n      assert(DL.typeSizeEqualsStoreSize(LI.getType()) &&\n             \"Non-byte-multiple bit width\");\n      // Move the insertion point just past the load so that we can refer to it.\n      IRB.SetInsertPoint(&*std::next(BasicBlock::iterator(&LI)));\n      // Create a placeholder value with the same type as LI to use as the\n      // basis for the new value. This allows us to replace the uses of LI with\n      // the computed value, and then replace the placeholder with LI, leaving\n      // LI only used for this computation.\n      Value *Placeholder = new LoadInst(\n          LI.getType(), PoisonValue::get(LI.getType()->getPointerTo(AS)), \"\",\n          false, Align(1));\n      V = insertInteger(DL, IRB, Placeholder, V, NewBeginOffset - BeginOffset,\n                        \"insert\");\n      LI.replaceAllUsesWith(V);\n      Placeholder->replaceAllUsesWith(&LI);\n      Placeholder->deleteValue();\n    } else {\n      LI.replaceAllUsesWith(V);\n    }\n\n    Pass.DeadInsts.push_back(&LI);\n    deleteIfTriviallyDead(OldOp);\n    LLVM_DEBUG(dbgs() << \"          to: \" << *V << \"\\n\");\n    return !LI.isVolatile() && !IsPtrAdjusted;\n  }\n",
        "start": 2693,
        "end": 2797,
        "buggy": "  bool visitLoadInst(LoadInst &LI) {\n    LLVM_DEBUG(dbgs() << \"    original: \" << LI << \"\\n\");\n    Value *OldOp = LI.getOperand(0);\n    assert(OldOp == OldPtr);\n\n    AAMDNodes AATags = LI.getAAMetadata();\n\n    unsigned AS = LI.getPointerAddressSpace();\n\n    Type *TargetTy = IsSplit ? Type::getIntNTy(LI.getContext(), SliceSize * 8)\n                             : LI.getType();\n    const bool IsLoadPastEnd =\n        DL.getTypeStoreSize(TargetTy).getFixedValue() > SliceSize;\n    bool IsPtrAdjusted = false;\n    Value *V;\n    if (VecTy) {\n      V = rewriteVectorizedLoadInst(LI);\n    } else if (IntTy && LI.getType()->isIntegerTy()) {\n      V = rewriteIntegerLoad(LI);\n    } else if (NewBeginOffset == NewAllocaBeginOffset &&\n               NewEndOffset == NewAllocaEndOffset &&\n               (canConvertValue(DL, NewAllocaTy, TargetTy) ||\n                (IsLoadPastEnd && NewAllocaTy->isIntegerTy() &&\n                 TargetTy->isIntegerTy()))) {\n      Value *NewPtr =\n          getPtrToNewAI(LI.getPointerAddressSpace(), LI.isVolatile());\n      LoadInst *NewLI = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), NewPtr,\n                                              NewAI.getAlign(), LI.isVolatile(),\n                                              LI.getName());\n      if (LI.isVolatile())\n        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());\n      if (NewLI->isAtomic())\n        NewLI->setAlignment(LI.getAlign());\n\n      // Copy any metadata that is valid for the new load. This may require\n      // conversion to a different kind of metadata, e.g. !nonnull might change\n      // to !range or vice versa.\n      copyMetadataForLoad(*NewLI, LI);\n\n      // Do this after copyMetadataForLoad() to preserve the TBAA shift.\n      if (AATags)\n        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));\n\n      // Try to preserve nonnull metadata\n      V = NewLI;\n\n      // If this is an integer load past the end of the slice (which means the\n      // bytes outside the slice are undef or this load is dead) just forcibly\n      // fix the integer size with correct handling of endianness.\n      if (auto *AITy = dyn_cast<IntegerType>(NewAllocaTy))\n        if (auto *TITy = dyn_cast<IntegerType>(TargetTy))\n          if (AITy->getBitWidth() < TITy->getBitWidth()) {\n            V = IRB.CreateZExt(V, TITy, \"load.ext\");\n            if (DL.isBigEndian())\n              V = IRB.CreateShl(V, TITy->getBitWidth() - AITy->getBitWidth(),\n                                \"endian_shift\");\n          }\n    } else {\n      Type *LTy = TargetTy->getPointerTo(AS);\n      LoadInst *NewLI =\n          IRB.CreateAlignedLoad(TargetTy, getNewAllocaSlicePtr(IRB, LTy),\n                                getSliceAlign(), LI.isVolatile(), LI.getName());\n      if (AATags)\n        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));\n      if (LI.isVolatile())\n        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());\n      NewLI->copyMetadata(LI, {LLVMContext::MD_mem_parallel_loop_access,\n                               LLVMContext::MD_access_group});\n\n      V = NewLI;\n      IsPtrAdjusted = true;\n    }\n    V = convertValue(DL, IRB, V, TargetTy);\n\n    if (IsSplit) {\n      assert(!LI.isVolatile());\n      assert(LI.getType()->isIntegerTy() &&\n             \"Only integer type loads and stores are split\");\n      assert(SliceSize < DL.getTypeStoreSize(LI.getType()).getFixedValue() &&\n             \"Split load isn't smaller than original load\");\n      assert(DL.typeSizeEqualsStoreSize(LI.getType()) &&\n             \"Non-byte-multiple bit width\");\n      // Move the insertion point just past the load so that we can refer to it.\n      IRB.SetInsertPoint(&*std::next(BasicBlock::iterator(&LI)));\n      // Create a placeholder value with the same type as LI to use as the\n      // basis for the new value. This allows us to replace the uses of LI with\n      // the computed value, and then replace the placeholder with LI, leaving\n      // LI only used for this computation.\n      Value *Placeholder = new LoadInst(\n          LI.getType(), PoisonValue::get(LI.getType()->getPointerTo(AS)), \"\",\n          false, Align(1));\n      V = insertInteger(DL, IRB, Placeholder, V, NewBeginOffset - BeginOffset,\n                        \"insert\");\n      LI.replaceAllUsesWith(V);\n      Placeholder->replaceAllUsesWith(&LI);\n      Placeholder->deleteValue();\n    } else {\n      LI.replaceAllUsesWith(V);\n    }\n\n    Pass.DeadInsts.push_back(&LI);\n    deleteIfTriviallyDead(OldOp);\n    LLVM_DEBUG(dbgs() << \"          to: \" << *V << \"\\n\");\n    return !LI.isVolatile() && !IsPtrAdjusted;\n  }\n",
        "fix": null,
        "buggy_hunk_masked": "                 TargetTy->isIntegerTy()))) {\n",
        "src_path": "57a554800b804a0d849858972822142e1f75d37f___SROA.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/57a554800b804a0d849858972822142e1f75d37f",
        "commit_msg": "[SROA] Don't shrink volatile load past end\n\nFor volatile atomic, this may result in a verifier errors, if the\nnew alloca type is not legal for atomic accesses.\n\nI've opted to disable this special case for volatile accesses in\ngeneral, as changing the size of the volatile access seems\ndubious in any case.\n\nFixes https://github.com/llvm/llvm-project/issues/64721.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Transforms/SROA/basictest.ll",
                "patch": "@@ -1968,6 +1968,38 @@ bb7:\n   ret void\n }\n \n+define i32 @load_atomic_volatile_past_end() {\n+; CHECK-LABEL: @load_atomic_volatile_past_end(\n+; CHECK-NEXT:    [[A:%.*]] = alloca i1, align 1\n+; CHECK-NEXT:    [[A_0_V:%.*]] = load atomic volatile i32, ptr [[A]] seq_cst, align 1\n+; CHECK-NEXT:    ret i32 [[A_0_V]]\n+;\n+  %a = alloca i1, align 1\n+  %v = load atomic volatile i32, ptr %a seq_cst, align 4\n+  ret i32 %v\n+}\n+\n+define i32 @load_volatile_past_end() {\n+; CHECK-LABEL: @load_volatile_past_end(\n+; CHECK-NEXT:    [[A:%.*]] = alloca i1, align 1\n+; CHECK-NEXT:    [[A_0_V:%.*]] = load volatile i32, ptr [[A]], align 1\n+; CHECK-NEXT:    ret i32 [[A_0_V]]\n+;\n+  %a = alloca i1, align 1\n+  %v = load volatile i32, ptr %a, align 4\n+  ret i32 %v\n+}\n+\n+define i32 @load_atomic_past_end() {\n+; CHECK-LABEL: @load_atomic_past_end(\n+; CHECK-NEXT:    [[A_0_LOAD_EXT:%.*]] = zext i1 undef to i32\n+; CHECK-NEXT:    ret i32 [[A_0_LOAD_EXT]]\n+;\n+  %a = alloca i1, align 1\n+  %v = load atomic i32, ptr %a seq_cst, align 4\n+  ret i32 %v\n+}\n+\n !0 = !{!1, !1, i64 0, i64 200}\n !1 = !{!2, i64 1, !\"type_0\"}\n !2 = !{!\"root\"}"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/SROA/basictest.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SROA/basictest.ll\n\n\nTesting Time: 2.89s\n  Failed: 1\n"
    },
    "6d2dfd37bd50b21ed90427052198bd1f06c761f8___LoopPassManager.cpp": {
        "prefix": "PreservedAnalyses FunctionToLoopPassAdaptor::run(Function &F,\n                                                 FunctionAnalysisManager &AM) {\n  // Before we even compute any loop analyses, first run a miniature function\n  // pass pipeline to put loops into their canonical form. Note that we can\n  // directly build up function analyses after this as the function pass\n  // manager handles all the invalidation at that layer.\n  PassInstrumentation PI = AM.getResult<PassInstrumentationAnalysis>(F);\n\n  PreservedAnalyses PA = PreservedAnalyses::all();\n  // Check the PassInstrumentation's BeforePass callbacks before running the\n  // canonicalization pipeline.\n  if (PI.runBeforePass<Function>(LoopCanonicalizationFPM, F)) {\n    PA = LoopCanonicalizationFPM.run(F, AM);\n    PI.runAfterPass<Function>(LoopCanonicalizationFPM, F, PA);\n  }\n\n  // Get the loop structure for this function\n  LoopInfo &LI = AM.getResult<LoopAnalysis>(F);\n\n  // If there are no loops, there is nothing to do here.\n  if (LI.empty())\n    return PA;\n\n  // Get the analysis results needed by loop passes.\n  MemorySSA *MSSA =\n      UseMemorySSA ? (&AM.getResult<MemorySSAAnalysis>(F).getMSSA()) : nullptr;\n  BlockFrequencyInfo *BFI = UseBlockFrequencyInfo && F.hasProfileData()\n                                ? (&AM.getResult<BlockFrequencyAnalysis>(F))\n                                : nullptr;\n  BranchProbabilityInfo *BPI =\n      UseBranchProbabilityInfo && F.hasProfileData()\n          ? (&AM.getResult<BranchProbabilityAnalysis>(F))\n          : nullptr;\n  LoopStandardAnalysisResults LAR = {AM.getResult<AAManager>(F),\n                                     AM.getResult<AssumptionAnalysis>(F),\n                                     AM.getResult<DominatorTreeAnalysis>(F),\n                                     AM.getResult<LoopAnalysis>(F),\n                                     AM.getResult<ScalarEvolutionAnalysis>(F),\n                                     AM.getResult<TargetLibraryAnalysis>(F),\n                                     AM.getResult<TargetIRAnalysis>(F),\n                                     BFI,\n                                     BPI,\n                                     MSSA};\n\n  // Setup the loop analysis manager from its proxy. It is important that\n  // this is only done when there are loops to process and we have built the\n  // LoopStandardAnalysisResults object. The loop analyses cached in this\n  // manager have access to those analysis results and so it must invalidate\n  // itself when they go away.\n  auto &LAMFP = AM.getResult<LoopAnalysisManagerFunctionProxy>(F);\n  if (UseMemorySSA)\n    LAMFP.markMSSAUsed();\n  LoopAnalysisManager &LAM = LAMFP.getManager();\n\n  // A postorder worklist of loops to process.\n  SmallPriorityWorklist<Loop *, 4> Worklist;\n\n  // Register the worklist and loop analysis manager so that loop passes can\n  // update them when they mutate the loop nest structure.\n  LPMUpdater Updater(Worklist, LAM, LoopNestMode);\n\n  // Add the loop nests in the reverse order of LoopInfo. See method\n  // declaration.\n  if (!LoopNestMode) {\n    appendLoopsToWorklist(LI, Worklist);\n  } else {\n    for (Loop *L : LI)\n      Worklist.insert(L);\n  }\n\n#ifndef NDEBUG\n  PI.pushBeforeNonSkippedPassCallback([&LAR, &LI](StringRef PassID, Any IR) {\n    if (isSpecialPass(PassID, {\"PassManager\"}))\n      return;\n    assert(llvm::any_cast<const Loop *>(&IR) ||\n           llvm::any_cast<const LoopNest *>(&IR));\n    const Loop **LPtr = llvm::any_cast<const Loop *>(&IR);\n    const Loop *L = LPtr ? *LPtr : nullptr;\n    if (!L)\n      L = &llvm::any_cast<const LoopNest *>(IR)->getOutermostLoop();\n    assert(L && \"Loop should be valid for printing\");\n\n    // Verify the loop structure and LCSSA form before visiting the loop.\n    L->verifyLoop();\n    assert(L->isRecursivelyLCSSAForm(LAR.DT, LI) &&\n           \"Loops must remain in LCSSA form!\");\n  });\n#endif\n\n  do {\n    Loop *L = Worklist.pop_back_val();\n    assert(!(LoopNestMode && L->getParentLoop()) &&\n           \"L should be a top-level loop in loop-nest mode.\");\n\n    // Reset the update structure for this loop.\n    Updater.CurrentL = L;\n    Updater.SkipCurrentLoop = false;\n\n#ifndef NDEBUG\n    // Save a parent loop pointer for asserts.\n    Updater.ParentL = L->getParentLoop();\n#endif\n    // Check the PassInstrumentation's BeforePass callbacks before running the\n    // pass, skip its execution completely if asked to (callback returns\n    // false).\n    if (!PI.runBeforePass<Loop>(*Pass, *L))\n      continue;\n\n    PreservedAnalyses PassPA = Pass->run(*L, LAM, LAR, Updater);\n\n    // Do not pass deleted Loop into the instrumentation.\n    if (Updater.skipCurrentLoop())\n      PI.runAfterPassInvalidated<Loop>(*Pass, PassPA);\n    else\n      PI.runAfterPass<Loop>(*Pass, *L, PassPA);\n\n    if (LAR.MSSA && !PassPA.getChecker<MemorySSAAnalysis>().preserved())\n      report_fatal_error(\"Loop pass manager using MemorySSA contains a pass \"\n",
        "suffix": "\n#ifndef NDEBUG\n    // LoopAnalysisResults should always be valid.\n    if (VerifyDomInfo)\n      LAR.DT.verify();\n    if (VerifyLoopInfo)\n      LAR.LI.verify(LAR.DT);\n    if (VerifySCEV)\n      LAR.SE.verify();\n    if (LAR.MSSA && VerifyMemorySSA)\n      LAR.MSSA->verifyMemorySSA();\n#endif\n\n    // If the loop hasn't been deleted, we need to handle invalidation here.\n    if (!Updater.skipCurrentLoop())\n      // We know that the loop pass couldn't have invalidated any other\n      // loop's analyses (that's the contract of a loop pass), so directly\n      // handle the loop analysis manager's invalidation here.\n      LAM.invalidate(*L, PassPA);\n\n    // Then intersect the preserved set so that invalidation of module\n    // analyses will eventually occur when the module pass completes.\n    PA.intersect(std::move(PassPA));\n  } while (!Worklist.empty());\n\n#ifndef NDEBUG\n  PI.popBeforeNonSkippedPassCallback();\n#endif\n\n  // By definition we preserve the proxy. We also preserve all analyses on\n  // Loops. This precludes *any* invalidation of loop analyses by the proxy,\n  // but that's OK because we've taken care to invalidate analyses in the\n  // loop analysis manager incrementally above.\n  PA.preserveSet<AllAnalysesOn<Loop>>();\n  PA.preserve<LoopAnalysisManagerFunctionProxy>();\n  // We also preserve the set of standard analyses.\n  PA.preserve<DominatorTreeAnalysis>();\n  PA.preserve<LoopAnalysis>();\n  PA.preserve<ScalarEvolutionAnalysis>();\n  if (UseBlockFrequencyInfo && F.hasProfileData())\n    PA.preserve<BlockFrequencyAnalysis>();\n  if (UseBranchProbabilityInfo && F.hasProfileData())\n    PA.preserve<BranchProbabilityAnalysis>();\n  if (UseMemorySSA)\n    PA.preserve<MemorySSAAnalysis>();\n  return PA;\n}\n",
        "start": 198,
        "end": 363,
        "buggy": "PreservedAnalyses FunctionToLoopPassAdaptor::run(Function &F,\n                                                 FunctionAnalysisManager &AM) {\n  // Before we even compute any loop analyses, first run a miniature function\n  // pass pipeline to put loops into their canonical form. Note that we can\n  // directly build up function analyses after this as the function pass\n  // manager handles all the invalidation at that layer.\n  PassInstrumentation PI = AM.getResult<PassInstrumentationAnalysis>(F);\n\n  PreservedAnalyses PA = PreservedAnalyses::all();\n  // Check the PassInstrumentation's BeforePass callbacks before running the\n  // canonicalization pipeline.\n  if (PI.runBeforePass<Function>(LoopCanonicalizationFPM, F)) {\n    PA = LoopCanonicalizationFPM.run(F, AM);\n    PI.runAfterPass<Function>(LoopCanonicalizationFPM, F, PA);\n  }\n\n  // Get the loop structure for this function\n  LoopInfo &LI = AM.getResult<LoopAnalysis>(F);\n\n  // If there are no loops, there is nothing to do here.\n  if (LI.empty())\n    return PA;\n\n  // Get the analysis results needed by loop passes.\n  MemorySSA *MSSA =\n      UseMemorySSA ? (&AM.getResult<MemorySSAAnalysis>(F).getMSSA()) : nullptr;\n  BlockFrequencyInfo *BFI = UseBlockFrequencyInfo && F.hasProfileData()\n                                ? (&AM.getResult<BlockFrequencyAnalysis>(F))\n                                : nullptr;\n  BranchProbabilityInfo *BPI =\n      UseBranchProbabilityInfo && F.hasProfileData()\n          ? (&AM.getResult<BranchProbabilityAnalysis>(F))\n          : nullptr;\n  LoopStandardAnalysisResults LAR = {AM.getResult<AAManager>(F),\n                                     AM.getResult<AssumptionAnalysis>(F),\n                                     AM.getResult<DominatorTreeAnalysis>(F),\n                                     AM.getResult<LoopAnalysis>(F),\n                                     AM.getResult<ScalarEvolutionAnalysis>(F),\n                                     AM.getResult<TargetLibraryAnalysis>(F),\n                                     AM.getResult<TargetIRAnalysis>(F),\n                                     BFI,\n                                     BPI,\n                                     MSSA};\n\n  // Setup the loop analysis manager from its proxy. It is important that\n  // this is only done when there are loops to process and we have built the\n  // LoopStandardAnalysisResults object. The loop analyses cached in this\n  // manager have access to those analysis results and so it must invalidate\n  // itself when they go away.\n  auto &LAMFP = AM.getResult<LoopAnalysisManagerFunctionProxy>(F);\n  if (UseMemorySSA)\n    LAMFP.markMSSAUsed();\n  LoopAnalysisManager &LAM = LAMFP.getManager();\n\n  // A postorder worklist of loops to process.\n  SmallPriorityWorklist<Loop *, 4> Worklist;\n\n  // Register the worklist and loop analysis manager so that loop passes can\n  // update them when they mutate the loop nest structure.\n  LPMUpdater Updater(Worklist, LAM, LoopNestMode);\n\n  // Add the loop nests in the reverse order of LoopInfo. See method\n  // declaration.\n  if (!LoopNestMode) {\n    appendLoopsToWorklist(LI, Worklist);\n  } else {\n    for (Loop *L : LI)\n      Worklist.insert(L);\n  }\n\n#ifndef NDEBUG\n  PI.pushBeforeNonSkippedPassCallback([&LAR, &LI](StringRef PassID, Any IR) {\n    if (isSpecialPass(PassID, {\"PassManager\"}))\n      return;\n    assert(llvm::any_cast<const Loop *>(&IR) ||\n           llvm::any_cast<const LoopNest *>(&IR));\n    const Loop **LPtr = llvm::any_cast<const Loop *>(&IR);\n    const Loop *L = LPtr ? *LPtr : nullptr;\n    if (!L)\n      L = &llvm::any_cast<const LoopNest *>(IR)->getOutermostLoop();\n    assert(L && \"Loop should be valid for printing\");\n\n    // Verify the loop structure and LCSSA form before visiting the loop.\n    L->verifyLoop();\n    assert(L->isRecursivelyLCSSAForm(LAR.DT, LI) &&\n           \"Loops must remain in LCSSA form!\");\n  });\n#endif\n\n  do {\n    Loop *L = Worklist.pop_back_val();\n    assert(!(LoopNestMode && L->getParentLoop()) &&\n           \"L should be a top-level loop in loop-nest mode.\");\n\n    // Reset the update structure for this loop.\n    Updater.CurrentL = L;\n    Updater.SkipCurrentLoop = false;\n\n#ifndef NDEBUG\n    // Save a parent loop pointer for asserts.\n    Updater.ParentL = L->getParentLoop();\n#endif\n    // Check the PassInstrumentation's BeforePass callbacks before running the\n    // pass, skip its execution completely if asked to (callback returns\n    // false).\n    if (!PI.runBeforePass<Loop>(*Pass, *L))\n      continue;\n\n    PreservedAnalyses PassPA = Pass->run(*L, LAM, LAR, Updater);\n\n    // Do not pass deleted Loop into the instrumentation.\n    if (Updater.skipCurrentLoop())\n      PI.runAfterPassInvalidated<Loop>(*Pass, PassPA);\n    else\n      PI.runAfterPass<Loop>(*Pass, *L, PassPA);\n\n    if (LAR.MSSA && !PassPA.getChecker<MemorySSAAnalysis>().preserved())\n      report_fatal_error(\"Loop pass manager using MemorySSA contains a pass \"\n                         \"that does not preserve MemorySSA\");\n\n#ifndef NDEBUG\n    // LoopAnalysisResults should always be valid.\n    if (VerifyDomInfo)\n      LAR.DT.verify();\n    if (VerifyLoopInfo)\n      LAR.LI.verify(LAR.DT);\n    if (VerifySCEV)\n      LAR.SE.verify();\n    if (LAR.MSSA && VerifyMemorySSA)\n      LAR.MSSA->verifyMemorySSA();\n#endif\n\n    // If the loop hasn't been deleted, we need to handle invalidation here.\n    if (!Updater.skipCurrentLoop())\n      // We know that the loop pass couldn't have invalidated any other\n      // loop's analyses (that's the contract of a loop pass), so directly\n      // handle the loop analysis manager's invalidation here.\n      LAM.invalidate(*L, PassPA);\n\n    // Then intersect the preserved set so that invalidation of module\n    // analyses will eventually occur when the module pass completes.\n    PA.intersect(std::move(PassPA));\n  } while (!Worklist.empty());\n\n#ifndef NDEBUG\n  PI.popBeforeNonSkippedPassCallback();\n#endif\n\n  // By definition we preserve the proxy. We also preserve all analyses on\n  // Loops. This precludes *any* invalidation of loop analyses by the proxy,\n  // but that's OK because we've taken care to invalidate analyses in the\n  // loop analysis manager incrementally above.\n  PA.preserveSet<AllAnalysesOn<Loop>>();\n  PA.preserve<LoopAnalysisManagerFunctionProxy>();\n  // We also preserve the set of standard analyses.\n  PA.preserve<DominatorTreeAnalysis>();\n  PA.preserve<LoopAnalysis>();\n  PA.preserve<ScalarEvolutionAnalysis>();\n  if (UseBlockFrequencyInfo && F.hasProfileData())\n    PA.preserve<BlockFrequencyAnalysis>();\n  if (UseBranchProbabilityInfo && F.hasProfileData())\n    PA.preserve<BranchProbabilityAnalysis>();\n  if (UseMemorySSA)\n    PA.preserve<MemorySSAAnalysis>();\n  return PA;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                         \"that does not preserve MemorySSA\");\n",
        "src_path": "6d2dfd37bd50b21ed90427052198bd1f06c761f8___LoopPassManager.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/6d2dfd37bd50b21ed90427052198bd1f06c761f8",
        "commit_msg": "[LPM] Set gen_crash_diag=false for non-MSSA pass in MSSA pipeline\n\nWhen a loop pass that does not preserve MSSA is run as part of a\nloop-mssa pipeline, this is user error and we should not ask for\na bug report.\n\nFixes https://github.com/llvm/llvm-project/issues/73554.",
        "test_func_diff": [
            {
                "fn": "llvm/test/Other/loop-mssa-not-preserved.ll",
                "patch": "@@ -1,4 +1,4 @@\n-; RUN: not --crash opt -passes='loop-mssa(loop-unroll-full)' 2>&1 < %s | FileCheck %s\n+; RUN: not opt -passes='loop-mssa(loop-unroll-full)' 2>&1 < %s | FileCheck %s\n \n ; CHECK: LLVM ERROR: Loop pass manager using MemorySSA contains a pass that does not preserve MemorySSA\n "
            }
        ],
        "error_msg": "FAIL: LLVM :: Other/loop-mssa-not-preserved.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Other/loop-mssa-not-preserved.ll\n\n\nTesting Time: 6.82s\n\nTotal Discovered Tests: 1\n  Failed: 1 (100.00%)\n"
    },
    "ab3fdbdfbe7edc62049c602d87be91c3ad3f5e3b___ValueTracking.cpp": {
        "prefix": "static bool isKnownNonNullFromDominatingCondition(const Value *V,\n                                                  const Instruction *CtxI,\n                                                  const DominatorTree *DT) {\n  assert(!isa<Constant>(V) && \"Called for constant?\");\n\n  if (!CtxI || !DT)\n    return false;\n\n  unsigned NumUsesExplored = 0;\n  for (const auto *U : V->users()) {\n    // Avoid massive lists\n    if (NumUsesExplored >= DomConditionsMaxUses)\n      break;\n    NumUsesExplored++;\n\n    // If the value is used as an argument to a call or invoke, then argument\n    // attributes may provide an answer about null-ness.\n    if (const auto *CB = dyn_cast<CallBase>(U))\n      if (auto *CalledFunc = CB->getCalledFunction())\n        for (const Argument &Arg : CalledFunc->args())\n          if (CB->getArgOperand(Arg.getArgNo()) == V &&\n              Arg.hasNonNullAttr(/* AllowUndefOrPoison */ false) &&\n              DT->dominates(CB, CtxI))\n            return true;\n\n    // If the value is used as a load/store, then the pointer must be non null.\n    if (V == getLoadStorePointerOperand(U)) {\n      const Instruction *I = cast<Instruction>(U);\n      if (!NullPointerIsDefined(I->getFunction(),\n                                V->getType()->getPointerAddressSpace()) &&\n          DT->dominates(I, CtxI))\n        return true;\n    }\n\n",
        "suffix": "        isValidAssumeForContext(cast<Instruction>(U), CtxI, DT))\n      return true;\n\n    // Consider only compare instructions uniquely controlling a branch\n    Value *RHS;\n    CmpInst::Predicate Pred;\n    if (!match(U, m_c_ICmp(Pred, m_Specific(V), m_Value(RHS))))\n      continue;\n\n    bool NonNullIfTrue;\n    if (cmpExcludesZero(Pred, RHS))\n      NonNullIfTrue = true;\n    else if (cmpExcludesZero(CmpInst::getInversePredicate(Pred), RHS))\n      NonNullIfTrue = false;\n    else\n      continue;\n\n    SmallVector<const User *, 4> WorkList;\n    SmallPtrSet<const User *, 4> Visited;\n    for (const auto *CmpU : U->users()) {\n      assert(WorkList.empty() && \"Should be!\");\n      if (Visited.insert(CmpU).second)\n        WorkList.push_back(CmpU);\n\n      while (!WorkList.empty()) {\n        auto *Curr = WorkList.pop_back_val();\n\n        // If a user is an AND, add all its users to the work list. We only\n        // propagate \"pred != null\" condition through AND because it is only\n        // correct to assume that all conditions of AND are met in true branch.\n        // TODO: Support similar logic of OR and EQ predicate?\n        if (NonNullIfTrue)\n          if (match(Curr, m_LogicalAnd(m_Value(), m_Value()))) {\n            for (const auto *CurrU : Curr->users())\n              if (Visited.insert(CurrU).second)\n                WorkList.push_back(CurrU);\n            continue;\n          }\n\n        if (const BranchInst *BI = dyn_cast<BranchInst>(Curr)) {\n          assert(BI->isConditional() && \"uses a comparison!\");\n\n          BasicBlock *NonNullSuccessor =\n              BI->getSuccessor(NonNullIfTrue ? 0 : 1);\n          BasicBlockEdge Edge(BI->getParent(), NonNullSuccessor);\n          if (Edge.isSingleEdge() && DT->dominates(Edge, CtxI->getParent()))\n            return true;\n        } else if (NonNullIfTrue && isGuard(Curr) &&\n                   DT->dominates(cast<Instruction>(Curr), CtxI)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n",
        "start": 2155,
        "end": 2246,
        "buggy": "static bool isKnownNonNullFromDominatingCondition(const Value *V,\n                                                  const Instruction *CtxI,\n                                                  const DominatorTree *DT) {\n  assert(!isa<Constant>(V) && \"Called for constant?\");\n\n  if (!CtxI || !DT)\n    return false;\n\n  unsigned NumUsesExplored = 0;\n  for (const auto *U : V->users()) {\n    // Avoid massive lists\n    if (NumUsesExplored >= DomConditionsMaxUses)\n      break;\n    NumUsesExplored++;\n\n    // If the value is used as an argument to a call or invoke, then argument\n    // attributes may provide an answer about null-ness.\n    if (const auto *CB = dyn_cast<CallBase>(U))\n      if (auto *CalledFunc = CB->getCalledFunction())\n        for (const Argument &Arg : CalledFunc->args())\n          if (CB->getArgOperand(Arg.getArgNo()) == V &&\n              Arg.hasNonNullAttr(/* AllowUndefOrPoison */ false) &&\n              DT->dominates(CB, CtxI))\n            return true;\n\n    // If the value is used as a load/store, then the pointer must be non null.\n    if (V == getLoadStorePointerOperand(U)) {\n      const Instruction *I = cast<Instruction>(U);\n      if (!NullPointerIsDefined(I->getFunction(),\n                                V->getType()->getPointerAddressSpace()) &&\n          DT->dominates(I, CtxI))\n        return true;\n    }\n\n    if (match(U, m_IDiv(m_Value(), m_Specific(V))) &&\n        isValidAssumeForContext(cast<Instruction>(U), CtxI, DT))\n      return true;\n\n    // Consider only compare instructions uniquely controlling a branch\n    Value *RHS;\n    CmpInst::Predicate Pred;\n    if (!match(U, m_c_ICmp(Pred, m_Specific(V), m_Value(RHS))))\n      continue;\n\n    bool NonNullIfTrue;\n    if (cmpExcludesZero(Pred, RHS))\n      NonNullIfTrue = true;\n    else if (cmpExcludesZero(CmpInst::getInversePredicate(Pred), RHS))\n      NonNullIfTrue = false;\n    else\n      continue;\n\n    SmallVector<const User *, 4> WorkList;\n    SmallPtrSet<const User *, 4> Visited;\n    for (const auto *CmpU : U->users()) {\n      assert(WorkList.empty() && \"Should be!\");\n      if (Visited.insert(CmpU).second)\n        WorkList.push_back(CmpU);\n\n      while (!WorkList.empty()) {\n        auto *Curr = WorkList.pop_back_val();\n\n        // If a user is an AND, add all its users to the work list. We only\n        // propagate \"pred != null\" condition through AND because it is only\n        // correct to assume that all conditions of AND are met in true branch.\n        // TODO: Support similar logic of OR and EQ predicate?\n        if (NonNullIfTrue)\n          if (match(Curr, m_LogicalAnd(m_Value(), m_Value()))) {\n            for (const auto *CurrU : Curr->users())\n              if (Visited.insert(CurrU).second)\n                WorkList.push_back(CurrU);\n            continue;\n          }\n\n        if (const BranchInst *BI = dyn_cast<BranchInst>(Curr)) {\n          assert(BI->isConditional() && \"uses a comparison!\");\n\n          BasicBlock *NonNullSuccessor =\n              BI->getSuccessor(NonNullIfTrue ? 0 : 1);\n          BasicBlockEdge Edge(BI->getParent(), NonNullSuccessor);\n          if (Edge.isSingleEdge() && DT->dominates(Edge, CtxI->getParent()))\n            return true;\n        } else if (NonNullIfTrue && isGuard(Curr) &&\n                   DT->dominates(cast<Instruction>(Curr), CtxI)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (match(U, m_IDiv(m_Value(), m_Specific(V))) &&\n",
        "src_path": "ab3fdbdfbe7edc62049c602d87be91c3ad3f5e3b___ValueTracking.cpp",
        "uri": "https://api.github.com/repos/llvm/llvm-project/commits/ab3fdbdfbe7edc62049c602d87be91c3ad3f5e3b",
        "commit_msg": "[ValueTracking] Support srem/urem for isKnownNonNullFromDominatingCondition (#74021)\n\nSimilar to div, the rem should also proof its second operand is\r\nnon-zero, otherwise it is a UB.\r\n\r\nFix https://github.com/llvm/llvm-project/issues/71782",
        "test_func_diff": [
            {
                "fn": "llvm/test/Analysis/ValueTracking/select-known-non-zero.ll",
                "patch": "@@ -2,6 +2,8 @@\n ; RUN: opt < %s -passes=instsimplify -S | FileCheck %s\n \n declare void @llvm.assume(i1)\n+declare void @use(i64)\n+declare void @use4(i4)\n \n define i1 @select_v_ne_fail(i8 %v, i8 %C, i8 %y) {\n ; CHECK-LABEL: @select_v_ne_fail(\n@@ -446,4 +448,56 @@ define i64 @incorrect_safe_div_call_2(i64 %n, i64 %d) {\n   ret i64 %3\n }\n \n-declare void @use(i64)\n+; https://alive2.llvm.org/ce/z/Si_B7b\n+define i4 @icmp_urem(i4 %n, i4 %d) {\n+; CHECK-LABEL: @icmp_urem(\n+; CHECK-NEXT:    [[TMP1:%.*]] = urem i4 [[N:%.*]], [[D:%.*]]\n+; CHECK-NEXT:    ret i4 [[TMP1]]\n+;\n+  %1 = icmp eq i4 %d, 0\n+  %2 = urem i4 %n, %d\n+  %3 = select i1 %1, i4 -1, i4 %2\n+  ret i4 %3\n+}\n+\n+define i4 @icmp_urem_clobber_by_call(i4 %n, i4 %d) {\n+; CHECK-LABEL: @icmp_urem_clobber_by_call(\n+; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i4 [[D:%.*]], 0\n+; CHECK-NEXT:    tail call void @use4(i4 [[D]])\n+; CHECK-NEXT:    [[TMP2:%.*]] = urem i4 [[N:%.*]], [[D]]\n+; CHECK-NEXT:    [[TMP3:%.*]] = select i1 [[TMP1]], i4 -1, i4 [[TMP2]]\n+; CHECK-NEXT:    ret i4 [[TMP3]]\n+;\n+  %1 = icmp eq i4 %d, 0\n+  tail call void @use4(i4 %d)\n+  %2 = urem i4 %n, %d\n+  %3 = select i1 %1, i4 -1, i4 %2\n+  ret i4 %3\n+}\n+\n+; https://alive2.llvm.org/ce/z/Fn3Wac\n+define i4 @icmp_srem(i4 %n, i4 %d) {\n+; CHECK-LABEL: @icmp_srem(\n+; CHECK-NEXT:    [[TMP1:%.*]] = srem i4 [[N:%.*]], [[D:%.*]]\n+; CHECK-NEXT:    ret i4 [[TMP1]]\n+;\n+  %1 = icmp eq i4 %d, 0\n+  %2 = srem i4 %n, %d\n+  %3 = select i1 %1, i4 -1, i4 %2\n+  ret i4 %3\n+}\n+\n+define i4 @icmp_srem_clobber_by_call(i4 %n, i4 %d) {\n+; CHECK-LABEL: @icmp_srem_clobber_by_call(\n+; CHECK-NEXT:    [[TMP1:%.*]] = icmp eq i4 [[D:%.*]], 0\n+; CHECK-NEXT:    tail call void @use4(i4 [[D]])\n+; CHECK-NEXT:    [[TMP2:%.*]] = srem i4 [[N:%.*]], [[D]]\n+; CHECK-NEXT:    [[TMP3:%.*]] = select i1 [[TMP1]], i4 -1, i4 [[TMP2]]\n+; CHECK-NEXT:    ret i4 [[TMP3]]\n+;\n+  %1 = icmp eq i4 %d, 0\n+  tail call void @use4(i4 %d)\n+  %2 = srem i4 %n, %d\n+  %3 = select i1 %1, i4 -1, i4 %2\n+  ret i4 %3\n+}"
            },
            {
                "fn": "llvm/test/Transforms/InstCombine/zext-or-icmp.ll",
                "patch": "@@ -231,9 +231,7 @@ define i1 @PR51762(ptr %i, i32 %t0, i16 %t1, ptr %p, ptr %d, ptr %f, i32 %p2, i1\n ; CHECK-NEXT:    [[INSERT_INSERT41:%.*]] = or i64 [[INSERT_SHIFT52]], [[INSERT_EXT39]]\n ; CHECK-NEXT:    [[REM:%.*]] = urem i64 [[S1]], [[INSERT_INSERT41]]\n ; CHECK-NEXT:    [[NE:%.*]] = icmp ne i64 [[REM]], 0\n-; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i64 [[INSERT_INSERT41]], 0\n-; CHECK-NEXT:    [[SPEC_SELECT57:%.*]] = or i1 [[NE]], [[CMP]]\n-; CHECK-NEXT:    [[LOR_EXT:%.*]] = zext i1 [[SPEC_SELECT57]] to i32\n+; CHECK-NEXT:    [[LOR_EXT:%.*]] = zext i1 [[NE]] to i32\n ; CHECK-NEXT:    [[T2:%.*]] = load i32, ptr [[D:%.*]], align 4\n ; CHECK-NEXT:    [[CONV15:%.*]] = sext i16 [[T1]] to i32\n ; CHECK-NEXT:    [[CMP16:%.*]] = icmp sge i32 [[T2]], [[CONV15]]"
            }
        ],
        "error_msg": "FAIL: LLVM :: Transforms/InstCombine/zext-or-icmp.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/zext-or-icmp.ll\n\n\nTesting Time: 0.36s\n\nTotal Discovered Tests: 1\n  Failed: 1 (100.00%)\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Analysis/ValueTracking/select-known-non-zero.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Analysis/ValueTracking/select-known-non-zero.ll\n\n\nTesting Time: 0.15s\n\nTotal Discovered Tests: 1\n  Failed: 1 (100.00%)\n"
    },
    "caa6ff7c2a6ef64df53e04701944aaa4712a1915___analyzerinfo.cpp": {
        "prefix": "std::string AnalyzerInformation::getAnalyzerInfoFile(const std::string &buildDir, const std::string &sourcefile, const std::string &cfg)\n{\n    std::ifstream fin(Path::join(buildDir, \"files.txt\"));\n    if (fin.is_open()) {\n        const std::string& ret = getAnalyzerInfoFileFromFilesTxt(fin, sourcefile, cfg);\n        if (!ret.empty())\n            return Path::join(buildDir, ret);\n    }\n\n    const std::string::size_type pos = sourcefile.rfind('/');\n    std::string filename;\n",
        "suffix": "        filename = sourcefile;\n    else\n        filename = sourcefile.substr(pos + 1);\n    return Path::join(buildDir, filename) + \".analyzerinfo\";\n}\n",
        "start": 112,
        "end": 128,
        "buggy": "std::string AnalyzerInformation::getAnalyzerInfoFile(const std::string &buildDir, const std::string &sourcefile, const std::string &cfg)\n{\n    std::ifstream fin(Path::join(buildDir, \"files.txt\"));\n    if (fin.is_open()) {\n        const std::string& ret = getAnalyzerInfoFileFromFilesTxt(fin, sourcefile, cfg);\n        if (!ret.empty())\n            return Path::join(buildDir, ret);\n    }\n\n    const std::string::size_type pos = sourcefile.rfind('/');\n    std::string filename;\n    if (pos != std::string::npos)\n        filename = sourcefile;\n    else\n        filename = sourcefile.substr(pos + 1);\n    return Path::join(buildDir, filename) + \".analyzerinfo\";\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (pos != std::string::npos)\n",
        "src_path": "caa6ff7c2a6ef64df53e04701944aaa4712a1915___analyzerinfo.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/caa6ff7c2a6ef64df53e04701944aaa4712a1915",
        "commit_msg": "Fix sense of test (.analyzerinfo files get placed in wrong directory) (#4486)\n\n* Fix sense of test (.analyzerinfo files get placed in wrong directory)\r\n\r\n* Update testanalyzerinformation.cpp\r\n\r\nstyle (tabs -> spaces)",
        "test_func_diff": [
            {
                "fn": "test/testanalyzerinformation.cpp",
                "patch": "@@ -38,6 +38,8 @@ class TestAnalyzerInformation : public TestFixture, private AnalyzerInformation\n         ASSERT_EQUALS(\"file1.a4\", getAnalyzerInfoFileFromFilesTxt(f1, \"file1.c\", \"\"));\n         std::istringstream f2(filesTxt);\n         ASSERT_EQUALS(\"file1.a4\", getAnalyzerInfoFileFromFilesTxt(f2, \"./file1.c\", \"\"));\n+        ASSERT_EQUALS(\"builddir/file1.c.analyzerinfo\", AnalyzerInformation::getAnalyzerInfoFile(\"builddir\", \"file1.c\", \"\"));\n+        ASSERT_EQUALS(\"builddir/file1.c.analyzerinfo\", AnalyzerInformation::getAnalyzerInfoFile(\"builddir\", \"some/path/file1.c\", \"\"));\n     }\n };\n "
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_caa6ff7c2a6ef64df53e04701944aaa4712a1915/build_caa6ff7c2a6ef64df53e04701944aaa4712a1915\nTest project /out/danmar___cppcheck/git_repo_dir_caa6ff7c2a6ef64df53e04701944aaa4712a1915/build_caa6ff7c2a6ef64df53e04701944aaa4712a1915\n    Start 2: TestAnalyzerInformation\n1/1 Test #2: TestAnalyzerInformation ..........***Failed    0.00 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.01 sec\n\nThe following tests FAILED:\n\t  2 - TestAnalyzerInformation (Failed)\n"
    },
    "4996ec190ecf27a4bf018eb0dcd12e2a51fd550e___checkleakautovar.cpp": {
        "prefix": "void CheckLeakAutoVar::functionCall(const Token *tokName, const Token *tokOpeningPar, VarInfo *varInfo, const VarInfo::AllocInfo& allocation, const Library::AllocFunc* af)\n{\n    // Ignore function call?\n    if (mSettings->library.isLeakIgnore(tokName->str()))\n        return;\n    if (mSettings->library.getReallocFuncInfo(tokName))\n        return;\n\n    const Token * const tokFirstArg = tokOpeningPar->next();\n    if (!tokFirstArg || tokFirstArg->str() == \")\") {\n        // no arguments\n        return;\n    }\n\n    int argNr = 1;\n",
        "suffix": "        if (mTokenizer->isCPP() && arg->str() == \"new\") {\n            arg = arg->next();\n            if (Token::simpleMatch(arg, \"( std :: nothrow )\"))\n                arg = arg->tokAt(5);\n        }\n\n        // Skip casts\n        while (arg && arg->isCast())\n            arg = arg->astOperand2() ? arg->astOperand2() : arg->astOperand1();\n        const Token * const argTypeStartTok = arg;\n\n        while (Token::Match(arg, \"%name% .|:: %name%\"))\n            arg = arg->tokAt(2);\n\n        if (Token::Match(arg, \"%var% [-,)] !!.\") || Token::Match(arg, \"& %var%\")) {\n            // goto variable\n            if (arg->str() == \"&\")\n                arg = arg->next();\n\n            const bool isnull = arg->hasKnownIntValue() && arg->values().front().intvalue == 0;\n\n            // Is variable allocated?\n            if (!isnull && (!af || af->arg == argNr))\n                changeAllocStatus(varInfo, allocation, tokName, arg);\n        }\n        // Check smart pointer\n        else if (Token::Match(arg, \"%name% < %type%\") && mSettings->library.isSmartPointer(argTypeStartTok)) {\n            const Token * typeEndTok = arg->linkAt(1);\n            const Token * allocTok = nullptr;\n            if (!Token::Match(typeEndTok, \"> {|( %var% ,|)|}\"))\n                continue;\n\n            bool arrayDelete = false;\n            if (Token::findsimplematch(arg->next(), \"[ ]\", typeEndTok))\n                arrayDelete = true;\n\n            // Check deleter\n            const Token * deleterToken = nullptr;\n            const Token * endDeleterToken = nullptr;\n            const Library::AllocFunc* sp_af = nullptr;\n            if (Token::Match(arg, \"unique_ptr < %type% ,\")) {\n                deleterToken = arg->tokAt(4);\n                endDeleterToken = typeEndTok;\n            } else if (Token::Match(typeEndTok, \"> {|( %var% ,\")) {\n                deleterToken = typeEndTok->tokAt(4);\n                endDeleterToken = typeEndTok->linkAt(1);\n            }\n            if (deleterToken) {\n                // Check if its a pointer to a function\n                const Token * dtok = Token::findmatch(deleterToken, \"& %name%\", endDeleterToken);\n                if (dtok) {\n                    sp_af = mSettings->library.getDeallocFuncInfo(dtok->tokAt(1));\n                } else {\n                    // If the deleter is a class, check if class calls the dealloc function\n                    dtok = Token::findmatch(deleterToken, \"%type%\", endDeleterToken);\n                    if (dtok && dtok->type()) {\n                        const Scope * tscope = dtok->type()->classScope;\n                        for (const Token *tok2 = tscope->bodyStart; tok2 != tscope->bodyEnd; tok2 = tok2->next()) {\n                            sp_af = mSettings->library.getDeallocFuncInfo(tok2);\n                            if (sp_af) {\n                                allocTok = tok2;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            const Token * vtok = typeEndTok->tokAt(2);\n            const VarInfo::AllocInfo sp_allocation(sp_af ? sp_af->groupId : (arrayDelete ? NEW_ARRAY : NEW), VarInfo::OWNED, allocTok);\n            changeAllocStatus(varInfo, sp_allocation, vtok, vtok);\n        } else {\n            checkTokenInsideExpression(arg, varInfo);\n        }\n        // TODO: check each token in argument expression (could contain multiple variables)\n        argNr++;\n    }\n}\n",
        "start": 844,
        "end": 937,
        "buggy": "void CheckLeakAutoVar::functionCall(const Token *tokName, const Token *tokOpeningPar, VarInfo *varInfo, const VarInfo::AllocInfo& allocation, const Library::AllocFunc* af)\n{\n    // Ignore function call?\n    if (mSettings->library.isLeakIgnore(tokName->str()))\n        return;\n    if (mSettings->library.getReallocFuncInfo(tokName))\n        return;\n\n    const Token * const tokFirstArg = tokOpeningPar->next();\n    if (!tokFirstArg || tokFirstArg->str() == \")\") {\n        // no arguments\n        return;\n    }\n\n    int argNr = 1;\n    for (const Token *arg = tokFirstArg; arg; arg = arg->nextArgument()) {\n        if (mTokenizer->isCPP() && arg->str() == \"new\") {\n            arg = arg->next();\n            if (Token::simpleMatch(arg, \"( std :: nothrow )\"))\n                arg = arg->tokAt(5);\n        }\n\n        // Skip casts\n        while (arg && arg->isCast())\n            arg = arg->astOperand2() ? arg->astOperand2() : arg->astOperand1();\n        const Token * const argTypeStartTok = arg;\n\n        while (Token::Match(arg, \"%name% .|:: %name%\"))\n            arg = arg->tokAt(2);\n\n        if (Token::Match(arg, \"%var% [-,)] !!.\") || Token::Match(arg, \"& %var%\")) {\n            // goto variable\n            if (arg->str() == \"&\")\n                arg = arg->next();\n\n            const bool isnull = arg->hasKnownIntValue() && arg->values().front().intvalue == 0;\n\n            // Is variable allocated?\n            if (!isnull && (!af || af->arg == argNr))\n                changeAllocStatus(varInfo, allocation, tokName, arg);\n        }\n        // Check smart pointer\n        else if (Token::Match(arg, \"%name% < %type%\") && mSettings->library.isSmartPointer(argTypeStartTok)) {\n            const Token * typeEndTok = arg->linkAt(1);\n            const Token * allocTok = nullptr;\n            if (!Token::Match(typeEndTok, \"> {|( %var% ,|)|}\"))\n                continue;\n\n            bool arrayDelete = false;\n            if (Token::findsimplematch(arg->next(), \"[ ]\", typeEndTok))\n                arrayDelete = true;\n\n            // Check deleter\n            const Token * deleterToken = nullptr;\n            const Token * endDeleterToken = nullptr;\n            const Library::AllocFunc* sp_af = nullptr;\n            if (Token::Match(arg, \"unique_ptr < %type% ,\")) {\n                deleterToken = arg->tokAt(4);\n                endDeleterToken = typeEndTok;\n            } else if (Token::Match(typeEndTok, \"> {|( %var% ,\")) {\n                deleterToken = typeEndTok->tokAt(4);\n                endDeleterToken = typeEndTok->linkAt(1);\n            }\n            if (deleterToken) {\n                // Check if its a pointer to a function\n                const Token * dtok = Token::findmatch(deleterToken, \"& %name%\", endDeleterToken);\n                if (dtok) {\n                    sp_af = mSettings->library.getDeallocFuncInfo(dtok->tokAt(1));\n                } else {\n                    // If the deleter is a class, check if class calls the dealloc function\n                    dtok = Token::findmatch(deleterToken, \"%type%\", endDeleterToken);\n                    if (dtok && dtok->type()) {\n                        const Scope * tscope = dtok->type()->classScope;\n                        for (const Token *tok2 = tscope->bodyStart; tok2 != tscope->bodyEnd; tok2 = tok2->next()) {\n                            sp_af = mSettings->library.getDeallocFuncInfo(tok2);\n                            if (sp_af) {\n                                allocTok = tok2;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            const Token * vtok = typeEndTok->tokAt(2);\n            const VarInfo::AllocInfo sp_allocation(sp_af ? sp_af->groupId : (arrayDelete ? NEW_ARRAY : NEW), VarInfo::OWNED, allocTok);\n            changeAllocStatus(varInfo, sp_allocation, vtok, vtok);\n        } else {\n            checkTokenInsideExpression(arg, varInfo);\n        }\n        // TODO: check each token in argument expression (could contain multiple variables)\n        argNr++;\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    for (const Token *arg = tokFirstArg; arg; arg = arg->nextArgument()) {\n",
        "src_path": "4996ec190ecf27a4bf018eb0dcd12e2a51fd550e___checkleakautovar.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/4996ec190ecf27a4bf018eb0dcd12e2a51fd550e",
        "commit_msg": "Fix #9652 (fp memleak with function call with cast)\n\nWhen the first argument was (void *)(1), at the start of the second\niteration, arg was pointing to the \"1\", which caused problems for\nnextArgument(), which saw the \")\" as the next token and returned\nnullptr, signalling that there are no more arguments.\n\nInstead, save the first token in the argument, which makes\nnextArgument() do the right thing.",
        "test_func_diff": [
            {
                "fn": "test/testleakautovar.cpp",
                "patch": "@@ -184,6 +184,8 @@ class TestLeakAutoVar : public TestFixture {\n         TEST_CASE(smartPtrInContainer); // #8262\n \n         TEST_CASE(recursiveCountLimit); // #5872 #6157 #9097\n+\n+        TEST_CASE(functionCallCastConfig); // #9652\n     }\n \n     void check(const char code[], bool cpp = false) {\n@@ -202,6 +204,22 @@ class TestLeakAutoVar : public TestFixture {\n         c.runChecks(&tokenizer, &settings, this);\n     }\n \n+    void check(const char code[], Settings & settings) {\n+        // Clear the error buffer..\n+        errout.str(\"\");\n+\n+        // Tokenize..\n+        Tokenizer tokenizer(&settings, this);\n+        std::istringstream istr(code);\n+        tokenizer.tokenize(istr, \"test.cpp\");\n+\n+        // Check for leaks..\n+        CheckLeakAutoVar c;\n+        settings.checkLibrary = true;\n+        settings.addEnabled(\"information\");\n+        c.runChecks(&tokenizer, &settings, this);\n+    }\n+\n     void checkP(const char code[], bool cpp = false) {\n         // Clear the error buffer..\n         errout.str(\"\");\n@@ -2023,6 +2041,31 @@ class TestLeakAutoVar : public TestFixture {\n                                \"}\"));\n     }\n \n+    void functionCallCastConfig() { // #9652\n+        Settings settingsFunctionCall = settings;\n+\n+        const char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n+                               \"<def format=\\\"2\\\">\\n\"\n+                               \"  <function name=\\\"free_func\\\">\\n\"\n+                               \"    <noreturn>false</noreturn>\\n\"\n+                               \"    <arg nr=\\\"1\\\">\\n\"\n+                               \"      <not-uninit/>\\n\"\n+                               \"    </arg>\\n\"\n+                               \"    <arg nr=\\\"2\\\">\\n\"\n+                               \"      <not-uninit/>\\n\"\n+                               \"    </arg>\\n\"\n+                               \"  </function>\\n\"\n+                               \"</def>\";\n+        tinyxml2::XMLDocument doc;\n+        doc.Parse(xmldata, sizeof(xmldata));\n+        settingsFunctionCall.library.load(doc);\n+        check(\"void test_func()\\n\"\n+              \"{\\n\"\n+              \"    char * buf = malloc(4);\\n\"\n+              \"    free_func((void *)(1), buf);\\n\"\n+              \"}\", settingsFunctionCall);\n+        ASSERT_EQUALS(\"[test.cpp:5]: (information) --check-library: Function free_func() should have <use>/<leak-ignore> configuration\\n\", errout.str());\n+    }\n };\n \n REGISTER_TEST(TestLeakAutoVar)"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_4996ec190ecf27a4bf018eb0dcd12e2a51fd550e/build_4996ec190ecf27a4bf018eb0dcd12e2a51fd550e\nTest project /out/danmar___cppcheck/git_repo_dir_4996ec190ecf27a4bf018eb0dcd12e2a51fd550e/build_4996ec190ecf27a4bf018eb0dcd12e2a51fd550e\n    Start 27: TestLeakAutoVar\n1/3 Test #27: TestLeakAutoVar ..................***Failed    4.53 sec\n    Start 62: TestLeakAutoVarStrcpy\n2/3 Test #62: TestLeakAutoVarStrcpy ............   Passed    0.05 sec\n    Start 63: TestLeakAutoVarWindows\n3/3 Test #63: TestLeakAutoVarWindows ...........   Passed    0.08 sec\n\n67% tests passed, 1 tests failed out of 3\n\nTotal Test time (real) =   4.67 sec\n\nThe following tests FAILED:\n\t 27 - TestLeakAutoVar (Failed)\n"
    },
    "d0b6079a832d5c156af1e51274e09f28ee8677a7___checkcondition.cpp": {
        "prefix": "void CheckCondition::checkCompareValueOutOfTypeRange()\n{\n    if (!mSettings->severity.isEnabled(Severity::style))\n        return;\n\n    if (mSettings->platformType == cppcheck::Platform::PlatformType::Native ||\n        mSettings->platformType == cppcheck::Platform::PlatformType::Unspecified)\n        return;\n\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n    for (const Scope * scope : symbolDatabase->functionScopes) {\n        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {\n            if (!tok->isComparisonOp() || !tok->isBinaryOp())\n                continue;\n\n            for (int i = 0; i < 2; ++i) {\n                const Token * const valueTok = (i == 0) ? tok->astOperand1() : tok->astOperand2();\n                const Token * const typeTok = valueTok->astSibling();\n                if (!valueTok->hasKnownIntValue() || !typeTok->valueType() || typeTok->valueType()->pointer)\n                    continue;\n                if (valueTok->getKnownIntValue() < 0 && valueTok->valueType() && valueTok->valueType()->sign != ValueType::Sign::SIGNED)\n                    continue;\n                int bits = 0;\n                switch (typeTok->valueType()->type) {\n                case ValueType::Type::BOOL:\n                    bits = 1;\n                    break;\n                case ValueType::Type::CHAR:\n                    bits = mSettings->char_bit;\n                    break;\n                case ValueType::Type::SHORT:\n                    bits = mSettings->short_bit;\n                    break;\n                case ValueType::Type::INT:\n                    bits = mSettings->int_bit;\n                    break;\n                case ValueType::Type::LONG:\n                    bits = mSettings->long_bit;\n                    break;\n                case ValueType::Type::LONGLONG:\n                    bits = mSettings->long_long_bit;\n                    break;\n                default:\n                    break;\n                };\n                if (bits == 0 || bits >= 64)\n                    continue;\n\n                const auto typeMinValue = (typeTok->valueType()->sign == ValueType::Sign::SIGNED) ? (-(1LL << (bits-1))) : 0;\n                const auto unsignedTypeMaxValue = (1LL << bits) - 1LL;\n",
        "suffix": "\n                if (valueTok->getKnownIntValue() < typeMinValue)\n                    compareValueOutOfTypeRangeError(valueTok, typeTok->valueType()->str(), valueTok->getKnownIntValue());\n                else if (valueTok->getKnownIntValue() > typeMaxValue)\n                    compareValueOutOfTypeRangeError(valueTok, typeTok->valueType()->str(), valueTok->getKnownIntValue());\n            }\n        }\n    }\n}\n",
        "start": 1760,
        "end": 1819,
        "buggy": "void CheckCondition::checkCompareValueOutOfTypeRange()\n{\n    if (!mSettings->severity.isEnabled(Severity::style))\n        return;\n\n    if (mSettings->platformType == cppcheck::Platform::PlatformType::Native ||\n        mSettings->platformType == cppcheck::Platform::PlatformType::Unspecified)\n        return;\n\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n    for (const Scope * scope : symbolDatabase->functionScopes) {\n        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {\n            if (!tok->isComparisonOp() || !tok->isBinaryOp())\n                continue;\n\n            for (int i = 0; i < 2; ++i) {\n                const Token * const valueTok = (i == 0) ? tok->astOperand1() : tok->astOperand2();\n                const Token * const typeTok = valueTok->astSibling();\n                if (!valueTok->hasKnownIntValue() || !typeTok->valueType() || typeTok->valueType()->pointer)\n                    continue;\n                if (valueTok->getKnownIntValue() < 0 && valueTok->valueType() && valueTok->valueType()->sign != ValueType::Sign::SIGNED)\n                    continue;\n                int bits = 0;\n                switch (typeTok->valueType()->type) {\n                case ValueType::Type::BOOL:\n                    bits = 1;\n                    break;\n                case ValueType::Type::CHAR:\n                    bits = mSettings->char_bit;\n                    break;\n                case ValueType::Type::SHORT:\n                    bits = mSettings->short_bit;\n                    break;\n                case ValueType::Type::INT:\n                    bits = mSettings->int_bit;\n                    break;\n                case ValueType::Type::LONG:\n                    bits = mSettings->long_bit;\n                    break;\n                case ValueType::Type::LONGLONG:\n                    bits = mSettings->long_long_bit;\n                    break;\n                default:\n                    break;\n                };\n                if (bits == 0 || bits >= 64)\n                    continue;\n\n                const auto typeMinValue = (typeTok->valueType()->sign == ValueType::Sign::SIGNED) ? (-(1LL << (bits-1))) : 0;\n                const auto unsignedTypeMaxValue = (1LL << bits) - 1LL;\n                const auto typeMaxValue = (typeTok->valueType()->sign == ValueType::Sign::SIGNED) ? (unsignedTypeMaxValue / 2) : unsignedTypeMaxValue;\n\n                if (valueTok->getKnownIntValue() < typeMinValue)\n                    compareValueOutOfTypeRangeError(valueTok, typeTok->valueType()->str(), valueTok->getKnownIntValue());\n                else if (valueTok->getKnownIntValue() > typeMaxValue)\n                    compareValueOutOfTypeRangeError(valueTok, typeTok->valueType()->str(), valueTok->getKnownIntValue());\n            }\n        }\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                const auto typeMaxValue = (typeTok->valueType()->sign == ValueType::Sign::SIGNED) ? (unsignedTypeMaxValue / 2) : unsignedTypeMaxValue;\n",
        "src_path": "d0b6079a832d5c156af1e51274e09f28ee8677a7___checkcondition.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/d0b6079a832d5c156af1e51274e09f28ee8677a7",
        "commit_msg": "Fixed #10372 (Confusing message for compareValueOutOfTypeRangeError)",
        "test_func_diff": [
            {
                "fn": "test/testcondition.cpp",
                "patch": "@@ -4439,6 +4439,32 @@ class TestCondition : public TestFixture {\n               \"  if (b == true) {}\\n\"\n               \"}\", &settingsUnix64);\n         ASSERT_EQUALS(\"\", errout.str());\n+\n+        // #10372\n+        check(\"void f(signed char x) {\\n\"\n+              \"  if (x == 0xff) {}\\n\"\n+              \"}\", &settingsUnix64);\n+        ASSERT_EQUALS(\"[test.cpp:2]: (style) Comparing expression of type 'signed char' against value 255. Condition is always true/false.\\n\", errout.str());\n+\n+        check(\"void f(short x) {\\n\"\n+              \"  if (x == 0xffff) {}\\n\"\n+              \"}\", &settingsUnix64);\n+        ASSERT_EQUALS(\"[test.cpp:2]: (style) Comparing expression of type 'signed short' against value 65535. Condition is always true/false.\\n\", errout.str());\n+\n+        check(\"void f(int x) {\\n\"\n+              \"  if (x == 0xffffffff) {}\\n\"\n+              \"}\", &settingsUnix64);\n+        ASSERT_EQUALS(\"\", errout.str());\n+\n+        check(\"void f(long x) {\\n\"\n+              \"  if (x == ~0L) {}\\n\"\n+              \"}\", &settingsUnix64);\n+        ASSERT_EQUALS(\"\", errout.str());\n+\n+        check(\"void f(long long x) {\\n\"\n+              \"  if (x == ~0LL) {}\\n\"\n+              \"}\", &settingsUnix64);\n+        ASSERT_EQUALS(\"\", errout.str());\n     }\n \n     void knownConditionCast() { // #9976"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_d0b6079a832d5c156af1e51274e09f28ee8677a7/build_d0b6079a832d5c156af1e51274e09f28ee8677a7\nTest project /out/danmar___cppcheck/git_repo_dir_d0b6079a832d5c156af1e51274e09f28ee8677a7/build_d0b6079a832d5c156af1e51274e09f28ee8677a7\n    Start 14: TestCondition\n1/1 Test #14: TestCondition ....................***Failed    2.95 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   2.96 sec\n\nThe following tests FAILED:\n\t 14 - TestCondition (Failed)\n"
    },
    "2daf7f5430f11def5fd1d67598487369f97c42f4___preprocessor.cpp": {
        "prefix": "std::string Preprocessor::getcode(const simplecpp::TokenList &tokens1, const std::string &cfg, std::vector<std::string> &files, const bool writeLocations)\n{\n    const simplecpp::DUI dui = createDUI(_settings, cfg, files[0]);\n\n    simplecpp::OutputList outputList;\n    std::list<simplecpp::MacroUsage> macroUsage;\n    simplecpp::TokenList tokens2(files);\n    simplecpp::preprocess(tokens2, tokens1, files, tokenlists, dui, &outputList, &macroUsage);\n\n    bool showerror = (!_settings.userDefines.empty() && !_settings.force);\n    reportOutput(outputList, showerror);\n    if (hasErrors(outputList))\n        return \"\";\n\n    // ensure that guessed define macros without value are not used in the code\n    if (!validateCfg(cfg, macroUsage))\n        return \"\";\n\n    // assembler code locations..\n    std::set<simplecpp::Location> assemblerLocations;\n    for (std::list<Directive>::const_iterator dirIt = directives.begin(); dirIt != directives.end(); ++dirIt) {\n        const Directive &d1 = *dirIt;\n        if (d1.str.compare(0, 11, \"#pragma asm\") != 0)\n            continue;\n        std::list<Directive>::const_iterator dirIt2 = dirIt;\n        ++dirIt2;\n        if (dirIt2 == directives.end())\n            continue;\n\n        const Directive &d2 = *dirIt2;\n        if (d2.str.compare(0,14,\"#pragma endasm\") != 0 || d1.file != d2.file)\n            continue;\n\n        simplecpp::Location loc(files);\n        loc.fileIndex = ~0U;\n        loc.col = 0U;\n        for (unsigned int i = 0; i < files.size(); ++i) {\n            if (files[i] == d1.file) {\n                loc.fileIndex = i;\n                break;\n            }\n        }\n\n        for (unsigned int linenr = d1.linenr + 1U; linenr < d2.linenr; linenr++) {\n            loc.line = linenr;\n            assemblerLocations.insert(loc);\n        }\n    }\n\n    unsigned int prevfile = 0;\n    unsigned int line = 1;\n    std::ostringstream ret;\n    for (const simplecpp::Token *tok = tokens2.cfront(); tok; tok = tok->next) {\n        if (writeLocations && tok->location.fileIndex != prevfile) {\n            ret << \"\\n#line \" << tok->location.line << \" \\\"\" << tok->location.file() << \"\\\"\\n\";\n            prevfile = tok->location.fileIndex;\n            line = tok->location.line;\n        }\n\n",
        "suffix": "            ret << ' ';\n        bool newline = false;\n        while (tok->location.line > line) {\n            ret << '\\n';\n            line++;\n            newline = true;\n        }\n        if (newline) {\n            simplecpp::Location loc = tok->location;\n            loc.col = 0U;\n            if (assemblerLocations.find(loc) != assemblerLocations.end()) {\n                ret << \"asm();\";\n                while (assemblerLocations.find(loc) != assemblerLocations.end()) {\n                    loc.line++;\n                }\n                while (tok && tok->location.line < loc.line)\n                    tok = tok->next;\n                if (!tok)\n                    break;\n                while (line < tok->location.line) {\n                    ret << '\\n';\n                    ++line;\n                }\n            }\n        }\n        if (!tok->macro.empty())\n            ret << Preprocessor::macroChar;\n        ret << tok->str;\n    }\n\n    return ret.str();\n}\n",
        "start": 559,
        "end": 650,
        "buggy": "std::string Preprocessor::getcode(const simplecpp::TokenList &tokens1, const std::string &cfg, std::vector<std::string> &files, const bool writeLocations)\n{\n    const simplecpp::DUI dui = createDUI(_settings, cfg, files[0]);\n\n    simplecpp::OutputList outputList;\n    std::list<simplecpp::MacroUsage> macroUsage;\n    simplecpp::TokenList tokens2(files);\n    simplecpp::preprocess(tokens2, tokens1, files, tokenlists, dui, &outputList, &macroUsage);\n\n    bool showerror = (!_settings.userDefines.empty() && !_settings.force);\n    reportOutput(outputList, showerror);\n    if (hasErrors(outputList))\n        return \"\";\n\n    // ensure that guessed define macros without value are not used in the code\n    if (!validateCfg(cfg, macroUsage))\n        return \"\";\n\n    // assembler code locations..\n    std::set<simplecpp::Location> assemblerLocations;\n    for (std::list<Directive>::const_iterator dirIt = directives.begin(); dirIt != directives.end(); ++dirIt) {\n        const Directive &d1 = *dirIt;\n        if (d1.str.compare(0, 11, \"#pragma asm\") != 0)\n            continue;\n        std::list<Directive>::const_iterator dirIt2 = dirIt;\n        ++dirIt2;\n        if (dirIt2 == directives.end())\n            continue;\n\n        const Directive &d2 = *dirIt2;\n        if (d2.str.compare(0,14,\"#pragma endasm\") != 0 || d1.file != d2.file)\n            continue;\n\n        simplecpp::Location loc(files);\n        loc.fileIndex = ~0U;\n        loc.col = 0U;\n        for (unsigned int i = 0; i < files.size(); ++i) {\n            if (files[i] == d1.file) {\n                loc.fileIndex = i;\n                break;\n            }\n        }\n\n        for (unsigned int linenr = d1.linenr + 1U; linenr < d2.linenr; linenr++) {\n            loc.line = linenr;\n            assemblerLocations.insert(loc);\n        }\n    }\n\n    unsigned int prevfile = 0;\n    unsigned int line = 1;\n    std::ostringstream ret;\n    for (const simplecpp::Token *tok = tokens2.cfront(); tok; tok = tok->next) {\n        if (writeLocations && tok->location.fileIndex != prevfile) {\n            ret << \"\\n#line \" << tok->location.line << \" \\\"\" << tok->location.file() << \"\\\"\\n\";\n            prevfile = tok->location.fileIndex;\n            line = tok->location.line;\n        }\n\n        if (tok->previous && line == tok->location.line)\n            ret << ' ';\n        bool newline = false;\n        while (tok->location.line > line) {\n            ret << '\\n';\n            line++;\n            newline = true;\n        }\n        if (newline) {\n            simplecpp::Location loc = tok->location;\n            loc.col = 0U;\n            if (assemblerLocations.find(loc) != assemblerLocations.end()) {\n                ret << \"asm();\";\n                while (assemblerLocations.find(loc) != assemblerLocations.end()) {\n                    loc.line++;\n                }\n                while (tok && tok->location.line < loc.line)\n                    tok = tok->next;\n                if (!tok)\n                    break;\n                while (line < tok->location.line) {\n                    ret << '\\n';\n                    ++line;\n                }\n            }\n        }\n        if (!tok->macro.empty())\n            ret << Preprocessor::macroChar;\n        ret << tok->str;\n    }\n\n    return ret.str();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        if (tok->previous && line == tok->location.line)\n",
        "src_path": "2daf7f5430f11def5fd1d67598487369f97c42f4___preprocessor.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/2daf7f5430f11def5fd1d67598487369f97c42f4",
        "commit_msg": "Merge pull request #874 from simartin/ticket_7912\n\nTicket #7912: Properly preprocess files with decreasing line numbers, due to #line directives",
        "test_func_diff": [
            {
                "fn": "test/testpreprocessor.cpp",
                "patch": "@@ -240,6 +240,8 @@ class TestPreprocessor : public TestFixture {\n         TEST_CASE(testDirectiveIncludeTypes);\n         TEST_CASE(testDirectiveIncludeLocations);\n         TEST_CASE(testDirectiveIncludeComments);\n+\n+        TEST_CASE(testSameLine);  // #7912\n     }\n \n     void preprocess(const char* code, std::map<std::string, std::string>& actual, const char filename[] = \"file.c\") {\n@@ -2294,6 +2296,19 @@ class TestPreprocessor : public TestFixture {\n         ASSERT_EQUALS(dumpdata, ostr.str());\n     }\n \n+    void testSameLine() { // Ticket #7912\n+        const char code[] = \"#line 1 \\\"bench/btl/libs/BLAS/blas_interface_impl.hh\\\" \\n\"\n+                            \"template < > class blas_interface < float > : public c_interface_base < float > \\n\"\n+                            \"{ } ;\\n\"\n+                            \"#line 1 \\\"bench/btl/libs/BLAS/blas_interface_impl.hh\\\" \\n\"\n+                            \"template < > class blas_interface < double > : public c_interface_base < double > \\n\"\n+                            \"{ } ;\";\n+        const char exp[]  = \"template < > class blas_interface < float > : public c_interface_base < float >\\n\"\n+                            \"{ } ; template < > class blas_interface < double > : public c_interface_base < double > { } ;\";\n+        Preprocessor preprocessor(settings0, this);\n+        ASSERT_EQUALS(exp, preprocessor.getcode(code, \"\", \"test.cpp\"));\n+    }\n+\n };\n \n REGISTER_TEST(TestPreprocessor)"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_2daf7f5430f11def5fd1d67598487369f97c42f4/build_2daf7f5430f11def5fd1d67598487369f97c42f4\nTest project /out/danmar___cppcheck/git_repo_dir_2daf7f5430f11def5fd1d67598487369f97c42f4/build_2daf7f5430f11def5fd1d67598487369f97c42f4\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   17.97 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  17.98 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n"
    },
    "46ac0d79c1036afb0c565e2bc330d9eb5ffa9eb1___checkleakautovar.cpp": {
        "prefix": "void CheckLeakAutoVar::ret(const Token *tok, const VarInfo &varInfo)\n{\n    const std::map<int, VarInfo::AllocInfo> &alloctype = varInfo.alloctype;\n    const std::map<int, std::string> &possibleUsage = varInfo.possibleUsage;\n\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n    for (std::map<int, VarInfo::AllocInfo>::const_iterator it = alloctype.begin(); it != alloctype.end(); ++it) {\n        // don't warn if variable is conditionally allocated\n        if (!it->second.managed() && varInfo.conditionalAlloc.find(it->first) != varInfo.conditionalAlloc.end())\n            continue;\n\n        // don't warn if there is a reference of the variable\n        if (varInfo.referenced.find(it->first) != varInfo.referenced.end())\n            continue;\n\n        const int varid = it->first;\n        const Variable *var = symbolDatabase->getVariableFromVarId(varid);\n        if (var) {\n            bool used = false;\n            for (const Token *tok2 = tok; tok2; tok2 = tok2->next()) {\n                if (tok2->str() == \";\" || Token::simpleMatch(tok2, \"return ;\"))\n                    break;\n                if (!Token::Match(tok2, \"return|(|{|,\"))\n                    continue;\n\n                tok2 = tok2->next();\n",
        "suffix": "                    tok2 = tok2->astOperand2() ? tok2->astOperand2() : tok2->astOperand1();\n                if (Token::Match(tok2, \"%varid%\", varid))\n                    tok2 = tok2->next();\n                else if (Token::Match(tok2, \"& %varid% . %name%\", varid))\n                    tok2 = tok2->tokAt(4);\n                else\n                    continue;\n                if (Token::Match(tok2, \"[});,]\")) {\n                    used = true;\n                    break;\n                }\n            }\n\n            // return deallocated pointer\n            if (used && it->second.status == VarInfo::DEALLOC)\n                deallocReturnError(tok, var->name());\n\n            else if (!used && !it->second.managed()) {\n                const std::map<int, std::string>::const_iterator use = possibleUsage.find(varid);\n                if (use == possibleUsage.end()) {\n                    leakError(tok, var->name(), it->second.type);\n                } else {\n                    configurationInfo(tok, use->second);\n                }\n            }\n        }\n    }\n}\n",
        "start": 913,
        "end": 967,
        "buggy": "void CheckLeakAutoVar::ret(const Token *tok, const VarInfo &varInfo)\n{\n    const std::map<int, VarInfo::AllocInfo> &alloctype = varInfo.alloctype;\n    const std::map<int, std::string> &possibleUsage = varInfo.possibleUsage;\n\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n    for (std::map<int, VarInfo::AllocInfo>::const_iterator it = alloctype.begin(); it != alloctype.end(); ++it) {\n        // don't warn if variable is conditionally allocated\n        if (!it->second.managed() && varInfo.conditionalAlloc.find(it->first) != varInfo.conditionalAlloc.end())\n            continue;\n\n        // don't warn if there is a reference of the variable\n        if (varInfo.referenced.find(it->first) != varInfo.referenced.end())\n            continue;\n\n        const int varid = it->first;\n        const Variable *var = symbolDatabase->getVariableFromVarId(varid);\n        if (var) {\n            bool used = false;\n            for (const Token *tok2 = tok; tok2; tok2 = tok2->next()) {\n                if (tok2->str() == \";\" || Token::simpleMatch(tok2, \"return ;\"))\n                    break;\n                if (!Token::Match(tok2, \"return|(|{|,\"))\n                    continue;\n\n                tok2 = tok2->next();\n                while (tok2 && tok2->isCast() && (tok2->valueType() && (tok2->valueType()->pointer || (tok2->valueType()->typeSize(*mSettings) >= mSettings->sizeof_pointer))))\n                    tok2 = tok2->astOperand2() ? tok2->astOperand2() : tok2->astOperand1();\n                if (Token::Match(tok2, \"%varid%\", varid))\n                    tok2 = tok2->next();\n                else if (Token::Match(tok2, \"& %varid% . %name%\", varid))\n                    tok2 = tok2->tokAt(4);\n                else\n                    continue;\n                if (Token::Match(tok2, \"[});,]\")) {\n                    used = true;\n                    break;\n                }\n            }\n\n            // return deallocated pointer\n            if (used && it->second.status == VarInfo::DEALLOC)\n                deallocReturnError(tok, var->name());\n\n            else if (!used && !it->second.managed()) {\n                const std::map<int, std::string>::const_iterator use = possibleUsage.find(varid);\n                if (use == possibleUsage.end()) {\n                    leakError(tok, var->name(), it->second.type);\n                } else {\n                    configurationInfo(tok, use->second);\n                }\n            }\n        }\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                while (tok2 && tok2->isCast() && (tok2->valueType() && (tok2->valueType()->pointer || (tok2->valueType()->typeSize(*mSettings) >= mSettings->sizeof_pointer))))\n",
        "src_path": "46ac0d79c1036afb0c565e2bc330d9eb5ffa9eb1___checkleakautovar.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/46ac0d79c1036afb0c565e2bc330d9eb5ffa9eb1",
        "commit_msg": "Checkmemleakautovar: fix crash and FP (#2196)\n\nThis fixes crashes found by daca where valueType() is NULL. Also,\r\nsomewhat related, it removes warnings when casting to a type that is\r\nunknown to cppcheck, for example, there is no longer a warning for the\r\nfollowing code:\r\n\r\n\tvoid* f() {\r\n\t\tvoid *x = malloc(1);\r\n\t\treturn (mytype)x;\r\n\t}",
        "test_func_diff": [
            {
                "fn": "test/testleakautovar.cpp",
                "patch": "@@ -24,6 +24,7 @@\n #include \"tokenize.h\"\n \n #include <simplecpp.h>\n+#include <tinyxml2.h>\n #include <vector>\n \n class TestLeakAutoVar : public TestFixture {\n@@ -47,6 +48,14 @@ class TestLeakAutoVar : public TestFixture {\n         settings.library.smartPointers.insert(\"std::shared_ptr\");\n         settings.library.smartPointers.insert(\"std::unique_ptr\");\n \n+        const char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n+        \"<def>\\n\"\n+        \"  <podtype name=\\\"uint8_t\\\" sign=\\\"u\\\" size=\\\"1\\\"/>\\n\"\n+        \"</def>\";\n+        tinyxml2::XMLDocument doc;\n+        doc.Parse(xmldata, sizeof(xmldata));\n+        settings.library.load(doc);\n+\n         // Assign\n         TEST_CASE(assign1);\n         TEST_CASE(assign2);\n@@ -1735,6 +1744,18 @@ class TestLeakAutoVar : public TestFixture {\n               \"    return (void*)(short)x;\\n\"\n               \"}\", true);\n         ASSERT_EQUALS(\"[test.cpp:3]: (error) Memory leak: x\\n\", errout.str());\n+\n+        check(\"void* f() {\\n\"\n+              \"    void *x = malloc(1);\\n\"\n+              \"    return (mytype)x;\\n\"\n+              \"}\", true);\n+        ASSERT_EQUALS(\"\", errout.str());\n+\n+        check(\"void* f() {\\n\" // Do not crash\n+              \"    void *x = malloc(1);\\n\"\n+              \"    return (mytype)y;\\n\"\n+              \"}\", true);\n+        ASSERT_EQUALS(\"[test.cpp:3]: (error) Memory leak: x\\n\", errout.str());\n     }\n \n     void test1() { // 3809"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_46ac0d79c1036afb0c565e2bc330d9eb5ffa9eb1/build_46ac0d79c1036afb0c565e2bc330d9eb5ffa9eb1\nTest project /out/danmar___cppcheck/git_repo_dir_46ac0d79c1036afb0c565e2bc330d9eb5ffa9eb1/build_46ac0d79c1036afb0c565e2bc330d9eb5ffa9eb1\n    Start 24: TestLeakAutoVar\n1/1 Test #24: TestLeakAutoVar ..................***Failed    4.36 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   4.36 sec\n\nThe following tests FAILED:\n\t 24 - TestLeakAutoVar (Failed)\n"
    },
    "290563b9640505d140684587e5c21e887d510495___templatesimplifier.cpp": {
        "prefix": "bool TemplateSimplifier::simplifyTemplateInstantiations(\n    const TokenAndName &templateDeclaration,\n    const std::list<const Token *> &specializations,\n    const std::time_t maxtime,\n    std::set<std::string> &expandedtemplates)\n{\n    // this variable is not used at the moment. The intention was to\n    // allow continuous instantiations until all templates has been expanded\n    //bool done = false;\n\n    // Contains tokens such as \"T\"\n    std::vector<const Token *> typeParametersInDeclaration;\n    const Token * const tok = getTemplateParametersInDeclaration(templateDeclaration.token->tokAt(2), typeParametersInDeclaration);\n\n    // bail out if the end of the file was reached\n    if (!tok)\n        return false;\n\n    const bool printDebug = mSettings->debugwarnings;\n\n    // get the position of the template name\n    const int namepos = getTemplateNamePosition(tok);\n    if (namepos == -1) {\n        // debug message that we bail out..\n        if (printDebug && mErrorLogger) {\n            const std::list<const Token *> callstack(1, tok);\n            mErrorLogger->reportErr(ErrorLogger::ErrorMessage(callstack, &mTokenList, Severity::debug, \"debug\", \"simplifyTemplates: bailing out\", false));\n        }\n        return false;\n    }\n\n    const bool specialized = Token::simpleMatch(templateDeclaration.token, \"template < >\");\n    bool isfunc = false;\n\n    if (tok->strAt(namepos + 1) == \"(\")\n        isfunc = true;\n    else if (tok->strAt(namepos + 1) == \"<\") {\n        const Token *tok1 = tok->tokAt(namepos + 1)->findClosingBracket();\n        if (tok1 && tok1->strAt(1) == \"(\")\n            isfunc = true;\n    }\n\n    // locate template usage..\n    std::string::size_type numberOfTemplateInstantiations = mTemplateInstantiations.size();\n    unsigned int recursiveCount = 0;\n\n    bool instantiated = false;\n\n    for (const TokenAndName &instantiation : mTemplateInstantiations) {\n        if (numberOfTemplateInstantiations != mTemplateInstantiations.size()) {\n            numberOfTemplateInstantiations = mTemplateInstantiations.size();\n            simplifyCalculations();\n            ++recursiveCount;\n            if (recursiveCount > 100) {\n                // bail out..\n                break;\n            }\n        }\n\n        // already simplified\n        if (!Token::Match(instantiation.token, \"%name% <\"))\n            continue;\n\n        if (instantiation.name != templateDeclaration.name)\n            continue;\n\n        if (!matchSpecialization(tok->tokAt(namepos), instantiation.token, specializations))\n            continue;\n\n        Token * const tok2 = instantiation.token;\n        if (mErrorLogger && !mTokenList.getFiles().empty())\n            mErrorLogger->reportProgress(mTokenList.getFiles()[0], \"TemplateSimplifier::simplifyTemplateInstantiations()\", tok2->progressValue());\n#ifdef MAXTIME\n        if (std::time(0) > maxtime)\n            return false;\n#else\n        (void)maxtime;\n#endif\n        assert(mTokenList.validateToken(tok2)); // that assertion fails on examples from #6021\n\n        const Token *startToken = tok2;\n        while (Token::Match(startToken->tokAt(-2), \"%name% :: %name%\") ||\n               Token::Match(startToken->tokAt(-2), \"> :: %name%\")) {\n            if (startToken->strAt(-2) == \">\") {\n                const Token * tok3 = startToken->tokAt(-2)->findOpeningBracket();\n                if (tok3)\n                    startToken = tok3->previous();\n                else\n                    break;\n            } else\n                startToken = startToken->tokAt(-2);\n        }\n\n        if (Token::Match(startToken->previous(), \"[;{}=]\") &&\n            (!specialized && !instantiateMatch(tok2, typeParametersInDeclaration.size(), isfunc ? \"(\" : \"*| %name%\")))\n            continue;\n\n        // New type..\n        mTypesUsedInTemplateInstantiation.clear();\n        std::list<std::string> typeStringsUsedInTemplateInstantiation;\n        std::string typeForNewName = getNewName(tok2, typeStringsUsedInTemplateInstantiation);\n\n        if (typeForNewName.empty() || (!typeParametersInDeclaration.empty() && typeParametersInDeclaration.size() != mTypesUsedInTemplateInstantiation.size())) {\n            if (printDebug && mErrorLogger) {\n                std::list<const Token *> callstack(1, tok2);\n                mErrorLogger->reportErr(ErrorLogger::ErrorMessage(callstack, &mTokenList, Severity::debug, \"debug\",\n                                        \"Failed to instantiate template \\\"\" + instantiation.name + \"\\\". The checking continues anyway.\", false));\n            }\n            if (typeForNewName.empty())\n                continue;\n            break;\n        }\n\n        // New classname/funcname..\n        const std::string newName(templateDeclaration.name + \" < \" + typeForNewName + \" >\");\n\n        if (expandedtemplates.find(newName) == expandedtemplates.end()) {\n            expandedtemplates.insert(newName);\n            expandTemplate(tok, instantiation.name, typeParametersInDeclaration, newName, !specialized);\n            instantiated = true;\n        }\n\n        // Replace all these template usages..\n        replaceTemplateUsage(tok2, instantiation.name, typeStringsUsedInTemplateInstantiation, newName);\n    }\n\n    // process uninstantiated templates\n    // TODO: remove the specialized check and handle all uninstantiated templates someday.\n",
        "suffix": "        simplifyCalculations();\n\n        Token * tok2 = const_cast<Token *>(tok->tokAt(namepos));\n        if (mErrorLogger && !mTokenList.getFiles().empty())\n            mErrorLogger->reportProgress(mTokenList.getFiles()[0], \"TemplateSimplifier::simplifyTemplateInstantiations()\", tok2->progressValue());\n#ifdef MAXTIME\n        if (std::time(0) > maxtime)\n            return false;\n#else\n        (void)maxtime;\n#endif\n        assert(mTokenList.validateToken(tok2)); // that assertion fails on examples from #6021\n\n        Token *startToken = tok2;\n        while (Token::Match(startToken->tokAt(-2), \"%name% :: %name%\") ||\n               Token::Match(startToken->tokAt(-2), \"> :: %name%\")) {\n            if (startToken->strAt(-2) == \">\") {\n                const Token * tok3 = startToken->tokAt(-2)->findOpeningBracket();\n                if (tok3)\n                    startToken = tok3->previous();\n                else\n                    break;\n            } else\n                startToken = startToken->tokAt(-2);\n        }\n\n        if (Token::Match(startToken->previous(), \"[;{}=]\") &&\n            (!specialized && !instantiateMatch(tok2, typeParametersInDeclaration.size(), isfunc ? \"(\" : \"*| %name%\")))\n            return false;\n\n        // already simplified\n        if (!Token::Match(startToken, \"%name% <\"))\n            return false;\n\n        if (templateDeclaration.scope.empty()) {\n            if (startToken->str() != templateDeclaration.name)\n                return false;\n        } else {\n            std::string name = templateDeclaration.scope + \" :: \" + startToken->str();\n            if (name != templateDeclaration.name)\n                return false;\n        }\n\n        if (!matchSpecialization(tok->tokAt(namepos), startToken, specializations))\n            return false;\n\n        tok2 = startToken;\n\n        // New type..\n        mTypesUsedInTemplateInstantiation.clear();\n        std::list<std::string> typeStringsUsedInTemplateInstantiation;\n        std::string typeForNewName = getNewName(tok2, typeStringsUsedInTemplateInstantiation);\n\n        if (typeForNewName.empty()) {\n            if (printDebug && mErrorLogger) {\n                std::list<const Token *> callstack(1, tok2);\n                mErrorLogger->reportErr(ErrorLogger::ErrorMessage(callstack, &mTokenList, Severity::debug, \"debug\",\n                                        \"Failed to instantiate template \\\"\" + templateDeclaration.name + \"\\\". The checking continues anyway.\", false));\n            }\n            return false;\n        }\n\n        // New classname/funcname..\n        const std::string newName(templateDeclaration.name + \" < \" + typeForNewName + \" >\");\n        if (expandedtemplates.find(newName) == expandedtemplates.end()) {\n            expandedtemplates.insert(newName);\n            expandTemplate(tok, templateDeclaration.name, typeParametersInDeclaration, newName, !specialized);\n            instantiated = true;\n        }\n\n        // Replace all these template usages..\n        replaceTemplateUsage(startToken, templateDeclaration.name, typeStringsUsedInTemplateInstantiation, newName);\n    }\n\n    // Template has been instantiated .. then remove the template declaration\n    return instantiated;\n}\n",
        "start": 1580,
        "end": 1785,
        "buggy": "bool TemplateSimplifier::simplifyTemplateInstantiations(\n    const TokenAndName &templateDeclaration,\n    const std::list<const Token *> &specializations,\n    const std::time_t maxtime,\n    std::set<std::string> &expandedtemplates)\n{\n    // this variable is not used at the moment. The intention was to\n    // allow continuous instantiations until all templates has been expanded\n    //bool done = false;\n\n    // Contains tokens such as \"T\"\n    std::vector<const Token *> typeParametersInDeclaration;\n    const Token * const tok = getTemplateParametersInDeclaration(templateDeclaration.token->tokAt(2), typeParametersInDeclaration);\n\n    // bail out if the end of the file was reached\n    if (!tok)\n        return false;\n\n    const bool printDebug = mSettings->debugwarnings;\n\n    // get the position of the template name\n    const int namepos = getTemplateNamePosition(tok);\n    if (namepos == -1) {\n        // debug message that we bail out..\n        if (printDebug && mErrorLogger) {\n            const std::list<const Token *> callstack(1, tok);\n            mErrorLogger->reportErr(ErrorLogger::ErrorMessage(callstack, &mTokenList, Severity::debug, \"debug\", \"simplifyTemplates: bailing out\", false));\n        }\n        return false;\n    }\n\n    const bool specialized = Token::simpleMatch(templateDeclaration.token, \"template < >\");\n    bool isfunc = false;\n\n    if (tok->strAt(namepos + 1) == \"(\")\n        isfunc = true;\n    else if (tok->strAt(namepos + 1) == \"<\") {\n        const Token *tok1 = tok->tokAt(namepos + 1)->findClosingBracket();\n        if (tok1 && tok1->strAt(1) == \"(\")\n            isfunc = true;\n    }\n\n    // locate template usage..\n    std::string::size_type numberOfTemplateInstantiations = mTemplateInstantiations.size();\n    unsigned int recursiveCount = 0;\n\n    bool instantiated = false;\n\n    for (const TokenAndName &instantiation : mTemplateInstantiations) {\n        if (numberOfTemplateInstantiations != mTemplateInstantiations.size()) {\n            numberOfTemplateInstantiations = mTemplateInstantiations.size();\n            simplifyCalculations();\n            ++recursiveCount;\n            if (recursiveCount > 100) {\n                // bail out..\n                break;\n            }\n        }\n\n        // already simplified\n        if (!Token::Match(instantiation.token, \"%name% <\"))\n            continue;\n\n        if (instantiation.name != templateDeclaration.name)\n            continue;\n\n        if (!matchSpecialization(tok->tokAt(namepos), instantiation.token, specializations))\n            continue;\n\n        Token * const tok2 = instantiation.token;\n        if (mErrorLogger && !mTokenList.getFiles().empty())\n            mErrorLogger->reportProgress(mTokenList.getFiles()[0], \"TemplateSimplifier::simplifyTemplateInstantiations()\", tok2->progressValue());\n#ifdef MAXTIME\n        if (std::time(0) > maxtime)\n            return false;\n#else\n        (void)maxtime;\n#endif\n        assert(mTokenList.validateToken(tok2)); // that assertion fails on examples from #6021\n\n        const Token *startToken = tok2;\n        while (Token::Match(startToken->tokAt(-2), \"%name% :: %name%\") ||\n               Token::Match(startToken->tokAt(-2), \"> :: %name%\")) {\n            if (startToken->strAt(-2) == \">\") {\n                const Token * tok3 = startToken->tokAt(-2)->findOpeningBracket();\n                if (tok3)\n                    startToken = tok3->previous();\n                else\n                    break;\n            } else\n                startToken = startToken->tokAt(-2);\n        }\n\n        if (Token::Match(startToken->previous(), \"[;{}=]\") &&\n            (!specialized && !instantiateMatch(tok2, typeParametersInDeclaration.size(), isfunc ? \"(\" : \"*| %name%\")))\n            continue;\n\n        // New type..\n        mTypesUsedInTemplateInstantiation.clear();\n        std::list<std::string> typeStringsUsedInTemplateInstantiation;\n        std::string typeForNewName = getNewName(tok2, typeStringsUsedInTemplateInstantiation);\n\n        if (typeForNewName.empty() || (!typeParametersInDeclaration.empty() && typeParametersInDeclaration.size() != mTypesUsedInTemplateInstantiation.size())) {\n            if (printDebug && mErrorLogger) {\n                std::list<const Token *> callstack(1, tok2);\n                mErrorLogger->reportErr(ErrorLogger::ErrorMessage(callstack, &mTokenList, Severity::debug, \"debug\",\n                                        \"Failed to instantiate template \\\"\" + instantiation.name + \"\\\". The checking continues anyway.\", false));\n            }\n            if (typeForNewName.empty())\n                continue;\n            break;\n        }\n\n        // New classname/funcname..\n        const std::string newName(templateDeclaration.name + \" < \" + typeForNewName + \" >\");\n\n        if (expandedtemplates.find(newName) == expandedtemplates.end()) {\n            expandedtemplates.insert(newName);\n            expandTemplate(tok, instantiation.name, typeParametersInDeclaration, newName, !specialized);\n            instantiated = true;\n        }\n\n        // Replace all these template usages..\n        replaceTemplateUsage(tok2, instantiation.name, typeStringsUsedInTemplateInstantiation, newName);\n    }\n\n    // process uninstantiated templates\n    // TODO: remove the specialized check and handle all uninstantiated templates someday.\n    if (mTemplateInstantiations.empty() && specialized) {\n        simplifyCalculations();\n\n        Token * tok2 = const_cast<Token *>(tok->tokAt(namepos));\n        if (mErrorLogger && !mTokenList.getFiles().empty())\n            mErrorLogger->reportProgress(mTokenList.getFiles()[0], \"TemplateSimplifier::simplifyTemplateInstantiations()\", tok2->progressValue());\n#ifdef MAXTIME\n        if (std::time(0) > maxtime)\n            return false;\n#else\n        (void)maxtime;\n#endif\n        assert(mTokenList.validateToken(tok2)); // that assertion fails on examples from #6021\n\n        Token *startToken = tok2;\n        while (Token::Match(startToken->tokAt(-2), \"%name% :: %name%\") ||\n               Token::Match(startToken->tokAt(-2), \"> :: %name%\")) {\n            if (startToken->strAt(-2) == \">\") {\n                const Token * tok3 = startToken->tokAt(-2)->findOpeningBracket();\n                if (tok3)\n                    startToken = tok3->previous();\n                else\n                    break;\n            } else\n                startToken = startToken->tokAt(-2);\n        }\n\n        if (Token::Match(startToken->previous(), \"[;{}=]\") &&\n            (!specialized && !instantiateMatch(tok2, typeParametersInDeclaration.size(), isfunc ? \"(\" : \"*| %name%\")))\n            return false;\n\n        // already simplified\n        if (!Token::Match(startToken, \"%name% <\"))\n            return false;\n\n        if (templateDeclaration.scope.empty()) {\n            if (startToken->str() != templateDeclaration.name)\n                return false;\n        } else {\n            std::string name = templateDeclaration.scope + \" :: \" + startToken->str();\n            if (name != templateDeclaration.name)\n                return false;\n        }\n\n        if (!matchSpecialization(tok->tokAt(namepos), startToken, specializations))\n            return false;\n\n        tok2 = startToken;\n\n        // New type..\n        mTypesUsedInTemplateInstantiation.clear();\n        std::list<std::string> typeStringsUsedInTemplateInstantiation;\n        std::string typeForNewName = getNewName(tok2, typeStringsUsedInTemplateInstantiation);\n\n        if (typeForNewName.empty()) {\n            if (printDebug && mErrorLogger) {\n                std::list<const Token *> callstack(1, tok2);\n                mErrorLogger->reportErr(ErrorLogger::ErrorMessage(callstack, &mTokenList, Severity::debug, \"debug\",\n                                        \"Failed to instantiate template \\\"\" + templateDeclaration.name + \"\\\". The checking continues anyway.\", false));\n            }\n            return false;\n        }\n\n        // New classname/funcname..\n        const std::string newName(templateDeclaration.name + \" < \" + typeForNewName + \" >\");\n        if (expandedtemplates.find(newName) == expandedtemplates.end()) {\n            expandedtemplates.insert(newName);\n            expandTemplate(tok, templateDeclaration.name, typeParametersInDeclaration, newName, !specialized);\n            instantiated = true;\n        }\n\n        // Replace all these template usages..\n        replaceTemplateUsage(startToken, templateDeclaration.name, typeStringsUsedInTemplateInstantiation, newName);\n    }\n\n    // Template has been instantiated .. then remove the template declaration\n    return instantiated;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (mTemplateInstantiations.empty() && specialized) {\n",
        "src_path": "290563b9640505d140684587e5c21e887d510495___templatesimplifier.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/290563b9640505d140684587e5c21e887d510495",
        "commit_msg": "Fix specialized template regression. (#1425)\n\n* Fix specialized template regression.\r\n\r\nOnly check for instantiation of template being processed rather than\r\ncount of all instantiations.\r\n\r\n* Add 2 more tests.",
        "test_func_diff": [
            {
                "fn": "test/testsimplifytemplate.cpp",
                "patch": "@@ -130,6 +130,7 @@ class TestSimplifyTemplate : public TestFixture {\n         TEST_CASE(expandSpecialized1);\n         TEST_CASE(expandSpecialized2);\n         TEST_CASE(expandSpecialized3); // #8671\n+        TEST_CASE(expandSpecialized4);\n \n         TEST_CASE(templateAlias1);\n         TEST_CASE(templateAlias2);\n@@ -1818,6 +1819,58 @@ class TestSimplifyTemplate : public TestFixture {\n         ASSERT_EQUALS(expected, tok(code));\n     }\n \n+    void expandSpecialized4() {\n+        {\n+            const char code[] = \"template<> class C<char> { };\\n\"\n+                                \"map<int> m;\";\n+            const char expected[] = \"class C<char> { } ; \"\n+                                    \"map < int > m ;\";\n+            ASSERT_EQUALS(expected, tok(code));\n+        }\n+        {\n+            const char code[] = \"template<> class C<char> { };\\n\"\n+                                \"map<int> m;\\n\"\n+                                \"C<char> c;\";\n+            const char expected[] = \"class C<char> { } ; \"\n+                                    \"map < int > m ; \"\n+                                    \"C<char> c ;\";\n+            ASSERT_EQUALS(expected, tok(code));\n+        }\n+        {\n+            const char code[] = \"template<typename T> class C { };\\n\"\n+                                \"template<> class C<char> { };\\n\"\n+                                \"map<int> m;\\n\";\n+            const char expected[] = \"template < typename T > class C { } ; \"\n+                                    \"class C<char> { } ; \"\n+                                    \"map < int > m ;\";\n+            ASSERT_EQUALS(expected, tok(code));\n+        }\n+        {\n+            const char code[] = \"template<typename T> class C { };\\n\"\n+                                \"template<> class C<char> { };\\n\"\n+                                \"map<int> m;\\n\"\n+                                \"C<int> i;\";\n+            const char expected[] = \"class C<char> { } ; \"\n+                                    \"map < int > m ; \"\n+                                    \"C<int> i ; \"\n+                                    \"class C<int> { } ;\";\n+            ASSERT_EQUALS(expected, tok(code));\n+        }\n+        {\n+            const char code[] = \"template<typename T> class C { };\\n\"\n+                                \"template<> class C<char> { };\\n\"\n+                                \"map<int> m;\\n\"\n+                                \"C<int> i;\\n\"\n+                                \"C<char> c;\";\n+            const char expected[] = \"class C<char> { } ; \"\n+                                    \"map < int > m ; \"\n+                                    \"C<int> i ; \"\n+                                    \"C<char> c ; \"\n+                                    \"class C<int> { } ;\";\n+            ASSERT_EQUALS(expected, tok(code));\n+        }\n+    }\n+\n     void templateAlias1() {\n         const char code[] = \"template<class T, int N> struct Foo {};\\n\"\n                             \"template<class T> using Bar = Foo<T,3>;\\n\""
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_290563b9640505d140684587e5c21e887d510495/build_290563b9640505d140684587e5c21e887d510495\nTest project /out/danmar___cppcheck/git_repo_dir_290563b9640505d140684587e5c21e887d510495/build_290563b9640505d140684587e5c21e887d510495\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   24.03 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  24.04 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n"
    },
    "0c6aabe4445f097539a5d1f2a73815e69ce3d52f___checkleakautovar.cpp": {
        "prefix": "void CheckLeakAutoVar::functionCall(const Token *tokName, const Token *tokOpeningPar, VarInfo *varInfo, const VarInfo::AllocInfo& allocation, const Library::AllocFunc* af)\n{\n    // Ignore function call?\n    if (mSettings->library.isLeakIgnore(tokName->str()))\n        return;\n    if (mSettings->library.getReallocFuncInfo(tokName))\n        return;\n\n    const Token * const tokFirstArg = tokOpeningPar->next();\n    if (!tokFirstArg || tokFirstArg->str() == \")\") {\n        // no arguments\n        return;\n    }\n\n    int argNr = 1;\n",
        "suffix": "        if (mTokenizer->isCPP() && arg->str() == \"new\") {\n            arg = arg->next();\n            if (Token::simpleMatch(arg, \"( std :: nothrow )\"))\n                arg = arg->tokAt(5);\n        }\n\n        // Skip casts\n        while (arg && arg->isCast())\n            arg = arg->astOperand2() ? arg->astOperand2() : arg->astOperand1();\n        const Token * const argTypeStartTok = arg;\n\n        while (Token::Match(arg, \"%name% .|:: %name%\"))\n            arg = arg->tokAt(2);\n\n        if (Token::Match(arg, \"%var% [-,)] !!.\") || Token::Match(arg, \"& %var%\")) {\n            // goto variable\n            if (arg->str() == \"&\")\n                arg = arg->next();\n\n            const bool isnull = arg->hasKnownIntValue() && arg->values().front().intvalue == 0;\n\n            // Is variable allocated?\n            if (!isnull && (!af || af->arg == argNr))\n                changeAllocStatus(varInfo, allocation, tokName, arg);\n        }\n        // Check smart pointer\n        else if (Token::Match(arg, \"%name% < %type%\") && mSettings->library.isSmartPointer(argTypeStartTok)) {\n            const Token * typeEndTok = arg->linkAt(1);\n            const Token * allocTok = nullptr;\n            if (!Token::Match(typeEndTok, \"> {|( %var% ,|)|}\"))\n                continue;\n\n            bool arrayDelete = false;\n            if (Token::findsimplematch(arg->next(), \"[ ]\", typeEndTok))\n                arrayDelete = true;\n\n            // Check deleter\n            const Token * deleterToken = nullptr;\n            const Token * endDeleterToken = nullptr;\n            const Library::AllocFunc* sp_af = nullptr;\n            if (Token::Match(arg, \"unique_ptr < %type% ,\")) {\n                deleterToken = arg->tokAt(4);\n                endDeleterToken = typeEndTok;\n            } else if (Token::Match(typeEndTok, \"> {|( %var% ,\")) {\n                deleterToken = typeEndTok->tokAt(4);\n                endDeleterToken = typeEndTok->linkAt(1);\n            }\n            if (deleterToken) {\n                // Check if its a pointer to a function\n                const Token * dtok = Token::findmatch(deleterToken, \"& %name%\", endDeleterToken);\n                if (dtok) {\n                    sp_af = mSettings->library.getDeallocFuncInfo(dtok->tokAt(1));\n                } else {\n                    // If the deleter is a class, check if class calls the dealloc function\n                    dtok = Token::findmatch(deleterToken, \"%type%\", endDeleterToken);\n                    if (dtok && dtok->type()) {\n                        const Scope * tscope = dtok->type()->classScope;\n                        for (const Token *tok2 = tscope->bodyStart; tok2 != tscope->bodyEnd; tok2 = tok2->next()) {\n                            sp_af = mSettings->library.getDeallocFuncInfo(tok2);\n                            if (sp_af) {\n                                allocTok = tok2;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            const Token * vtok = typeEndTok->tokAt(2);\n            const VarInfo::AllocInfo sp_allocation(sp_af ? sp_af->groupId : (arrayDelete ? NEW_ARRAY : NEW), VarInfo::OWNED, allocTok);\n            changeAllocStatus(varInfo, sp_allocation, vtok, vtok);\n        } else {\n            checkTokenInsideExpression(arg, varInfo);\n        }\n        // TODO: check each token in argument expression (could contain multiple variables)\n        argNr++;\n    }\n}\n",
        "start": 844,
        "end": 937,
        "buggy": "void CheckLeakAutoVar::functionCall(const Token *tokName, const Token *tokOpeningPar, VarInfo *varInfo, const VarInfo::AllocInfo& allocation, const Library::AllocFunc* af)\n{\n    // Ignore function call?\n    if (mSettings->library.isLeakIgnore(tokName->str()))\n        return;\n    if (mSettings->library.getReallocFuncInfo(tokName))\n        return;\n\n    const Token * const tokFirstArg = tokOpeningPar->next();\n    if (!tokFirstArg || tokFirstArg->str() == \")\") {\n        // no arguments\n        return;\n    }\n\n    int argNr = 1;\n    for (const Token *arg = tokFirstArg; arg; arg = arg->nextArgument()) {\n        if (mTokenizer->isCPP() && arg->str() == \"new\") {\n            arg = arg->next();\n            if (Token::simpleMatch(arg, \"( std :: nothrow )\"))\n                arg = arg->tokAt(5);\n        }\n\n        // Skip casts\n        while (arg && arg->isCast())\n            arg = arg->astOperand2() ? arg->astOperand2() : arg->astOperand1();\n        const Token * const argTypeStartTok = arg;\n\n        while (Token::Match(arg, \"%name% .|:: %name%\"))\n            arg = arg->tokAt(2);\n\n        if (Token::Match(arg, \"%var% [-,)] !!.\") || Token::Match(arg, \"& %var%\")) {\n            // goto variable\n            if (arg->str() == \"&\")\n                arg = arg->next();\n\n            const bool isnull = arg->hasKnownIntValue() && arg->values().front().intvalue == 0;\n\n            // Is variable allocated?\n            if (!isnull && (!af || af->arg == argNr))\n                changeAllocStatus(varInfo, allocation, tokName, arg);\n        }\n        // Check smart pointer\n        else if (Token::Match(arg, \"%name% < %type%\") && mSettings->library.isSmartPointer(argTypeStartTok)) {\n            const Token * typeEndTok = arg->linkAt(1);\n            const Token * allocTok = nullptr;\n            if (!Token::Match(typeEndTok, \"> {|( %var% ,|)|}\"))\n                continue;\n\n            bool arrayDelete = false;\n            if (Token::findsimplematch(arg->next(), \"[ ]\", typeEndTok))\n                arrayDelete = true;\n\n            // Check deleter\n            const Token * deleterToken = nullptr;\n            const Token * endDeleterToken = nullptr;\n            const Library::AllocFunc* sp_af = nullptr;\n            if (Token::Match(arg, \"unique_ptr < %type% ,\")) {\n                deleterToken = arg->tokAt(4);\n                endDeleterToken = typeEndTok;\n            } else if (Token::Match(typeEndTok, \"> {|( %var% ,\")) {\n                deleterToken = typeEndTok->tokAt(4);\n                endDeleterToken = typeEndTok->linkAt(1);\n            }\n            if (deleterToken) {\n                // Check if its a pointer to a function\n                const Token * dtok = Token::findmatch(deleterToken, \"& %name%\", endDeleterToken);\n                if (dtok) {\n                    sp_af = mSettings->library.getDeallocFuncInfo(dtok->tokAt(1));\n                } else {\n                    // If the deleter is a class, check if class calls the dealloc function\n                    dtok = Token::findmatch(deleterToken, \"%type%\", endDeleterToken);\n                    if (dtok && dtok->type()) {\n                        const Scope * tscope = dtok->type()->classScope;\n                        for (const Token *tok2 = tscope->bodyStart; tok2 != tscope->bodyEnd; tok2 = tok2->next()) {\n                            sp_af = mSettings->library.getDeallocFuncInfo(tok2);\n                            if (sp_af) {\n                                allocTok = tok2;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            const Token * vtok = typeEndTok->tokAt(2);\n            const VarInfo::AllocInfo sp_allocation(sp_af ? sp_af->groupId : (arrayDelete ? NEW_ARRAY : NEW), VarInfo::OWNED, allocTok);\n            changeAllocStatus(varInfo, sp_allocation, vtok, vtok);\n        } else {\n            checkTokenInsideExpression(arg, varInfo);\n        }\n        // TODO: check each token in argument expression (could contain multiple variables)\n        argNr++;\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    for (const Token *arg = tokFirstArg; arg; arg = arg->nextArgument()) {\n",
        "src_path": "0c6aabe4445f097539a5d1f2a73815e69ce3d52f___checkleakautovar.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/0c6aabe4445f097539a5d1f2a73815e69ce3d52f",
        "commit_msg": "Merge pull request #2703 from rikardfalkeborn/9652-fp-function-call-cast-config\n\nFix #9652 (fp memleak with function call with cast)",
        "test_func_diff": [
            {
                "fn": "test/testleakautovar.cpp",
                "patch": "@@ -184,6 +184,8 @@ class TestLeakAutoVar : public TestFixture {\n         TEST_CASE(smartPtrInContainer); // #8262\n \n         TEST_CASE(recursiveCountLimit); // #5872 #6157 #9097\n+\n+        TEST_CASE(functionCallCastConfig); // #9652\n     }\n \n     void check(const char code[], bool cpp = false) {\n@@ -202,6 +204,22 @@ class TestLeakAutoVar : public TestFixture {\n         c.runChecks(&tokenizer, &settings, this);\n     }\n \n+    void check(const char code[], Settings & settings) {\n+        // Clear the error buffer..\n+        errout.str(\"\");\n+\n+        // Tokenize..\n+        Tokenizer tokenizer(&settings, this);\n+        std::istringstream istr(code);\n+        tokenizer.tokenize(istr, \"test.cpp\");\n+\n+        // Check for leaks..\n+        CheckLeakAutoVar c;\n+        settings.checkLibrary = true;\n+        settings.addEnabled(\"information\");\n+        c.runChecks(&tokenizer, &settings, this);\n+    }\n+\n     void checkP(const char code[], bool cpp = false) {\n         // Clear the error buffer..\n         errout.str(\"\");\n@@ -2023,6 +2041,31 @@ class TestLeakAutoVar : public TestFixture {\n                                \"}\"));\n     }\n \n+    void functionCallCastConfig() { // #9652\n+        Settings settingsFunctionCall = settings;\n+\n+        const char xmldata[] = \"<?xml version=\\\"1.0\\\"?>\\n\"\n+                               \"<def format=\\\"2\\\">\\n\"\n+                               \"  <function name=\\\"free_func\\\">\\n\"\n+                               \"    <noreturn>false</noreturn>\\n\"\n+                               \"    <arg nr=\\\"1\\\">\\n\"\n+                               \"      <not-uninit/>\\n\"\n+                               \"    </arg>\\n\"\n+                               \"    <arg nr=\\\"2\\\">\\n\"\n+                               \"      <not-uninit/>\\n\"\n+                               \"    </arg>\\n\"\n+                               \"  </function>\\n\"\n+                               \"</def>\";\n+        tinyxml2::XMLDocument doc;\n+        doc.Parse(xmldata, sizeof(xmldata));\n+        settingsFunctionCall.library.load(doc);\n+        check(\"void test_func()\\n\"\n+              \"{\\n\"\n+              \"    char * buf = malloc(4);\\n\"\n+              \"    free_func((void *)(1), buf);\\n\"\n+              \"}\", settingsFunctionCall);\n+        ASSERT_EQUALS(\"[test.cpp:5]: (information) --check-library: Function free_func() should have <use>/<leak-ignore> configuration\\n\", errout.str());\n+    }\n };\n \n REGISTER_TEST(TestLeakAutoVar)"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_0c6aabe4445f097539a5d1f2a73815e69ce3d52f/build_0c6aabe4445f097539a5d1f2a73815e69ce3d52f\nTest project /out/danmar___cppcheck/git_repo_dir_0c6aabe4445f097539a5d1f2a73815e69ce3d52f/build_0c6aabe4445f097539a5d1f2a73815e69ce3d52f\n    Start 27: TestLeakAutoVar\n1/3 Test #27: TestLeakAutoVar ..................***Failed    4.25 sec\n    Start 62: TestLeakAutoVarStrcpy\n2/3 Test #62: TestLeakAutoVarStrcpy ............   Passed    0.05 sec\n    Start 63: TestLeakAutoVarWindows\n3/3 Test #63: TestLeakAutoVarWindows ...........   Passed    0.06 sec\n\n67% tests passed, 1 tests failed out of 3\n\nTotal Test time (real) =   4.37 sec\n\nThe following tests FAILED:\n\t 27 - TestLeakAutoVar (Failed)\n"
    },
    "53734a3da1dd394aee9398127692b0e38e9ffa9f___valueflow.cpp": {
        "prefix": "std::vector<LifetimeToken> getLifetimeTokens(const Token* tok, bool escape, ValueFlow::Value::ErrorPath errorPath, int depth)\n{\n    if (!tok)\n        return std::vector<LifetimeToken> {};\n    const Variable *var = tok->variable();\n    if (depth < 0)\n        return {{tok, std::move(errorPath)}};\n    if (var && var->declarationId() == tok->varId()) {\n        if (var->isReference() || var->isRValueReference()) {\n            if (!var->declEndToken())\n                return {{tok, true, std::move(errorPath)}};\n            if (var->isArgument()) {\n                errorPath.emplace_back(var->declEndToken(), \"Passed to reference.\");\n                return {{tok, true, std::move(errorPath)}};\n            } else if (Token::simpleMatch(var->declEndToken(), \"=\")) {\n                errorPath.emplace_back(var->declEndToken(), \"Assigned to reference.\");\n                const Token *vartok = var->declEndToken()->astOperand2();\n",
        "suffix": "                const bool nonlocal = var->isStatic() || var->isGlobal();\n                if (vartok == tok || (nonlocal && temporary) || (!escape && (var->isConst() || var->isRValueReference()) && temporary))\n                    return {{tok, true, std::move(errorPath)}};\n                if (vartok)\n                    return getLifetimeTokens(vartok, escape, std::move(errorPath), depth - 1);\n            } else if (Token::simpleMatch(var->nameToken()->astParent(), \":\") &&\n                       var->nameToken()->astParent()->astParent() &&\n                       Token::simpleMatch(var->nameToken()->astParent()->astParent()->previous(), \"for (\")) {\n                errorPath.emplace_back(var->nameToken(), \"Assigned to reference.\");\n                const Token* vartok = var->nameToken();\n                if (vartok == tok)\n                    return {{tok, true, std::move(errorPath)}};\n                const Token* contok = var->nameToken()->astParent()->astOperand2();\n                if (contok)\n                    return getLifetimeTokens(contok, escape, std::move(errorPath), depth - 1);\n            } else {\n                return std::vector<LifetimeToken> {};\n            }\n        }\n    } else if (Token::Match(tok->previous(), \"%name% (\")) {\n        const Function *f = tok->previous()->function();\n        if (f) {\n            if (!Function::returnsReference(f))\n                return {{tok, std::move(errorPath)}};\n            std::vector<LifetimeToken> result;\n            std::vector<const Token*> returns = Function::findReturns(f);\n            for (const Token* returnTok : returns) {\n                if (returnTok == tok)\n                    continue;\n                for (LifetimeToken& lt : getLifetimeTokens(returnTok, escape, std::move(errorPath), depth - 1)) {\n                    const Token* argvarTok = lt.token;\n                    const Variable* argvar = argvarTok->variable();\n                    if (!argvar)\n                        continue;\n                    if (argvar->isArgument() && (argvar->isReference() || argvar->isRValueReference())) {\n                        int n = getArgumentPos(argvar, f);\n                        if (n < 0)\n                            return std::vector<LifetimeToken> {};\n                        std::vector<const Token*> args = getArguments(tok->previous());\n                        // TODO: Track lifetimes of default parameters\n                        if (n >= args.size())\n                            return std::vector<LifetimeToken> {};\n                        const Token* argTok = args[n];\n                        lt.errorPath.emplace_back(returnTok, \"Return reference.\");\n                        lt.errorPath.emplace_back(tok->previous(), \"Called function passing '\" + argTok->expressionString() + \"'.\");\n                        std::vector<LifetimeToken> arglts = LifetimeToken::setInconclusive(\n                                                                getLifetimeTokens(argTok, escape, std::move(lt.errorPath), depth - 1), returns.size() > 1);\n                        result.insert(result.end(), arglts.begin(), arglts.end());\n                    }\n                }\n            }\n            return result;\n        } else if (Token::Match(tok->tokAt(-2), \". %name% (\") && tok->tokAt(-2)->originalName() != \"->\" && astIsContainer(tok->tokAt(-2)->astOperand1())) {\n            const Library::Container* library = getLibraryContainer(tok->tokAt(-2)->astOperand1());\n            Library::Container::Yield y = library->getYield(tok->previous()->str());\n            if (y == Library::Container::Yield::AT_INDEX || y == Library::Container::Yield::ITEM) {\n                errorPath.emplace_back(tok->previous(), \"Accessing container.\");\n                return LifetimeToken::setAddressOf(\n                           getLifetimeTokens(tok->tokAt(-2)->astOperand1(), escape, std::move(errorPath), depth - 1), false);\n            }\n        }\n    } else if (Token::Match(tok, \".|::|[\")) {\n        const Token *vartok = tok;\n        while (vartok) {\n            if (vartok->str() == \"[\" || vartok->originalName() == \"->\")\n                vartok = vartok->astOperand1();\n            else if (vartok->str() == \".\" || vartok->str() == \"::\")\n                vartok = vartok->astOperand2();\n            else\n                break;\n        }\n\n        if (!vartok)\n            return {{tok, std::move(errorPath)}};\n        const Variable *tokvar = vartok->variable();\n        if (!astIsContainer(vartok) && !(tokvar && tokvar->isArray() && !tokvar->isArgument()) &&\n            (Token::Match(vartok->astParent(), \"[|*\") || vartok->astParent()->originalName() == \"->\")) {\n            for (const ValueFlow::Value &v : vartok->values()) {\n                if (!v.isLocalLifetimeValue())\n                    continue;\n                if (v.tokvalue == tok)\n                    continue;\n                errorPath.insert(errorPath.end(), v.errorPath.begin(), v.errorPath.end());\n                return getLifetimeTokens(v.tokvalue, escape, std::move(errorPath), depth - 1);\n            }\n        } else {\n            return LifetimeToken::setAddressOf(getLifetimeTokens(vartok, escape, std::move(errorPath), depth - 1),\n                                               !(astIsContainer(vartok) && Token::simpleMatch(vartok->astParent(), \"[\")));\n        }\n    }\n    return {{tok, std::move(errorPath)}};\n}\n",
        "start": 2728,
        "end": 2837,
        "buggy": "std::vector<LifetimeToken> getLifetimeTokens(const Token* tok, bool escape, ValueFlow::Value::ErrorPath errorPath, int depth)\n{\n    if (!tok)\n        return std::vector<LifetimeToken> {};\n    const Variable *var = tok->variable();\n    if (depth < 0)\n        return {{tok, std::move(errorPath)}};\n    if (var && var->declarationId() == tok->varId()) {\n        if (var->isReference() || var->isRValueReference()) {\n            if (!var->declEndToken())\n                return {{tok, true, std::move(errorPath)}};\n            if (var->isArgument()) {\n                errorPath.emplace_back(var->declEndToken(), \"Passed to reference.\");\n                return {{tok, true, std::move(errorPath)}};\n            } else if (Token::simpleMatch(var->declEndToken(), \"=\")) {\n                errorPath.emplace_back(var->declEndToken(), \"Assigned to reference.\");\n                const Token *vartok = var->declEndToken()->astOperand2();\n                const bool temporary = isTemporary(true, vartok, nullptr, true);\n                const bool nonlocal = var->isStatic() || var->isGlobal();\n                if (vartok == tok || (nonlocal && temporary) || (!escape && (var->isConst() || var->isRValueReference()) && temporary))\n                    return {{tok, true, std::move(errorPath)}};\n                if (vartok)\n                    return getLifetimeTokens(vartok, escape, std::move(errorPath), depth - 1);\n            } else if (Token::simpleMatch(var->nameToken()->astParent(), \":\") &&\n                       var->nameToken()->astParent()->astParent() &&\n                       Token::simpleMatch(var->nameToken()->astParent()->astParent()->previous(), \"for (\")) {\n                errorPath.emplace_back(var->nameToken(), \"Assigned to reference.\");\n                const Token* vartok = var->nameToken();\n                if (vartok == tok)\n                    return {{tok, true, std::move(errorPath)}};\n                const Token* contok = var->nameToken()->astParent()->astOperand2();\n                if (contok)\n                    return getLifetimeTokens(contok, escape, std::move(errorPath), depth - 1);\n            } else {\n                return std::vector<LifetimeToken> {};\n            }\n        }\n    } else if (Token::Match(tok->previous(), \"%name% (\")) {\n        const Function *f = tok->previous()->function();\n        if (f) {\n            if (!Function::returnsReference(f))\n                return {{tok, std::move(errorPath)}};\n            std::vector<LifetimeToken> result;\n            std::vector<const Token*> returns = Function::findReturns(f);\n            for (const Token* returnTok : returns) {\n                if (returnTok == tok)\n                    continue;\n                for (LifetimeToken& lt : getLifetimeTokens(returnTok, escape, std::move(errorPath), depth - 1)) {\n                    const Token* argvarTok = lt.token;\n                    const Variable* argvar = argvarTok->variable();\n                    if (!argvar)\n                        continue;\n                    if (argvar->isArgument() && (argvar->isReference() || argvar->isRValueReference())) {\n                        int n = getArgumentPos(argvar, f);\n                        if (n < 0)\n                            return std::vector<LifetimeToken> {};\n                        std::vector<const Token*> args = getArguments(tok->previous());\n                        // TODO: Track lifetimes of default parameters\n                        if (n >= args.size())\n                            return std::vector<LifetimeToken> {};\n                        const Token* argTok = args[n];\n                        lt.errorPath.emplace_back(returnTok, \"Return reference.\");\n                        lt.errorPath.emplace_back(tok->previous(), \"Called function passing '\" + argTok->expressionString() + \"'.\");\n                        std::vector<LifetimeToken> arglts = LifetimeToken::setInconclusive(\n                                                                getLifetimeTokens(argTok, escape, std::move(lt.errorPath), depth - 1), returns.size() > 1);\n                        result.insert(result.end(), arglts.begin(), arglts.end());\n                    }\n                }\n            }\n            return result;\n        } else if (Token::Match(tok->tokAt(-2), \". %name% (\") && tok->tokAt(-2)->originalName() != \"->\" && astIsContainer(tok->tokAt(-2)->astOperand1())) {\n            const Library::Container* library = getLibraryContainer(tok->tokAt(-2)->astOperand1());\n            Library::Container::Yield y = library->getYield(tok->previous()->str());\n            if (y == Library::Container::Yield::AT_INDEX || y == Library::Container::Yield::ITEM) {\n                errorPath.emplace_back(tok->previous(), \"Accessing container.\");\n                return LifetimeToken::setAddressOf(\n                           getLifetimeTokens(tok->tokAt(-2)->astOperand1(), escape, std::move(errorPath), depth - 1), false);\n            }\n        }\n    } else if (Token::Match(tok, \".|::|[\")) {\n        const Token *vartok = tok;\n        while (vartok) {\n            if (vartok->str() == \"[\" || vartok->originalName() == \"->\")\n                vartok = vartok->astOperand1();\n            else if (vartok->str() == \".\" || vartok->str() == \"::\")\n                vartok = vartok->astOperand2();\n            else\n                break;\n        }\n\n        if (!vartok)\n            return {{tok, std::move(errorPath)}};\n        const Variable *tokvar = vartok->variable();\n        if (!astIsContainer(vartok) && !(tokvar && tokvar->isArray() && !tokvar->isArgument()) &&\n            (Token::Match(vartok->astParent(), \"[|*\") || vartok->astParent()->originalName() == \"->\")) {\n            for (const ValueFlow::Value &v : vartok->values()) {\n                if (!v.isLocalLifetimeValue())\n                    continue;\n                if (v.tokvalue == tok)\n                    continue;\n                errorPath.insert(errorPath.end(), v.errorPath.begin(), v.errorPath.end());\n                return getLifetimeTokens(v.tokvalue, escape, std::move(errorPath), depth - 1);\n            }\n        } else {\n            return LifetimeToken::setAddressOf(getLifetimeTokens(vartok, escape, std::move(errorPath), depth - 1),\n                                               !(astIsContainer(vartok) && Token::simpleMatch(vartok->astParent(), \"[\")));\n        }\n    }\n    return {{tok, std::move(errorPath)}};\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                const bool temporary = isTemporary(true, vartok, nullptr, true);\n",
        "src_path": "53734a3da1dd394aee9398127692b0e38e9ffa9f___valueflow.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/53734a3da1dd394aee9398127692b0e38e9ffa9f",
        "commit_msg": "Test for return address of reference (#2991)",
        "test_func_diff": [
            {
                "fn": "test/testautovariables.cpp",
                "patch": "@@ -2564,6 +2564,21 @@ class TestAutoVariables : public TestFixture {\n               \"    }\\n\"\n               \"};\\n\");\n         ASSERT_EQUALS(\"\", errout.str());\n+\n+        //Make sure we can still take the address of a reference without warning\n+        check(\"int* foo() {\\n\"\n+              \"  int& x = getX();\\n\"\n+              \"  return &x;\\n\"\n+              \"}\\n\");\n+        ASSERT_EQUALS(\"\", errout.str());\n+        check(\"struct C {\\n\"\n+              \"  int* m_x;\\n\"\n+              \"  void foo() {\\n\"\n+              \"    const int& x = getX();\\n\"\n+              \"    m_x = &x;\\n\"\n+              \"  }\\n\"\n+              \"}\\n\");\n+        ASSERT_EQUALS(\"\", errout.str());\n     }\n \n     void danglingLifetimeFunction() {"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_53734a3da1dd394aee9398127692b0e38e9ffa9f/build_53734a3da1dd394aee9398127692b0e38e9ffa9f\nTest project /out/danmar___cppcheck/git_repo_dir_53734a3da1dd394aee9398127692b0e38e9ffa9f/build_53734a3da1dd394aee9398127692b0e38e9ffa9f\n    Start 5: TestAutoVariables\n1/1 Test #5: TestAutoVariables ................***Failed    0.92 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.92 sec\n\nThe following tests FAILED:\n\t  5 - TestAutoVariables (Failed)\n"
    },
    "0c659a149953b9a67901a5b30259b7ef534bbaad___forwardanalyzer.cpp": {
        "prefix": "    Progress updateRange(Token* start, const Token* end) {\n        for (Token* tok = start; tok && tok != end; tok = tok->next()) {\n            Token* next = nullptr;\n\n            if (tok->link()) {\n                // Skip casts..\n                if (tok->str() == \"(\" && !tok->astOperand2() && tok->isCast()) {\n                    tok = tok->link();\n                    continue;\n                }\n                // Skip template arguments..\n                if (tok->str() == \"<\") {\n                    tok = tok->link();\n                    continue;\n                }\n            }\n\n            // Evaluate RHS of assignment before LHS\n            if (Token* assignTok = assignExpr(tok)) {\n                if (updateRecursive(assignTok->astOperand2()) == Progress::Break)\n                    return Progress::Break;\n                if (updateRecursive(assignTok->astOperand1()) == Progress::Break)\n                    return Progress::Break;\n                if (update(assignTok) == Progress::Break)\n                    return Progress::Break;\n                tok = nextAfterAstRightmostLeaf(assignTok);\n                if (!tok)\n                    return Progress::Break;\n            } else if (tok->str() ==  \"break\") {\n                const Scope* scope = findBreakScope(tok->scope());\n                if (!scope)\n                    return Progress::Break;\n                tok = skipTo(tok, scope->bodyEnd, end);\n                if (!analyzer->lowerToPossible())\n                    return Progress::Break;\n                // TODO: Don't break, instead move to the outer scope\n                if (!tok)\n                    return Progress::Break;\n            } else if (Token::Match(tok, \"%name% :\") || tok->str() == \"case\") {\n                if (!analyzer->lowerToPossible())\n                    return Progress::Break;\n            } else if (tok->link() && tok->str() == \"}\") {\n                if (Token::Match(tok->link()->previous(), \")|else {\")) {\n                    const bool inElse = Token::simpleMatch(tok->link()->previous(), \"else {\");\n                    const Token* condTok = getCondTokFromEnd(tok);\n                    if (!condTok)\n                        return Progress::Break;\n                    if (!condTok->hasKnownIntValue()) {\n                        if (!analyzer->lowerToPossible())\n                            return Progress::Break;\n",
        "suffix": "                        return Progress::Break;\n                    }\n                    analyzer->assume(condTok, !inElse, tok);\n                    if (Token::simpleMatch(tok, \"} else {\"))\n                        tok = tok->linkAt(2);\n                } else if (Token::simpleMatch(tok->link()->previous(), \"try {\")) {\n                    if (!analyzer->lowerToPossible())\n                        return Progress::Break;\n                } else if (Token::simpleMatch(tok->next(), \"else {\")) {\n                    tok = tok->linkAt(2);\n                }\n            } else if (tok->isControlFlowKeyword() && Token::Match(tok, \"if|while|for (\") && Token::simpleMatch(tok->next()->link(), \") {\")) {\n                Token* endCond = tok->next()->link();\n                Token* endBlock = endCond->next()->link();\n                Token* condTok = getCondTok(tok);\n                Token* initTok = getInitTok(tok);\n                if (!condTok)\n                    return Progress::Break;\n                if (initTok && updateRecursive(initTok) == Progress::Break)\n                    return Progress::Break;\n                if (Token::Match(tok, \"for|while (\")) {\n                    Token* stepTok = getStepTok(tok);\n                    if (updateLoop(endBlock, condTok, initTok, stepTok) == Progress::Break)\n                        return Progress::Break;\n                    tok = endBlock;\n                } else {\n                    // Traverse condition\n                    if (updateRecursive(condTok) == Progress::Break)\n                        return Progress::Break;\n                    // Check if condition is true or false\n                    bool checkThen, checkElse;\n                    std::tie(checkThen, checkElse) = evalCond(condTok);\n                    ForwardAnalyzer::Action thenAction = ForwardAnalyzer::Action::None;\n                    ForwardAnalyzer::Action elseAction = ForwardAnalyzer::Action::None;\n                    bool hasElse = Token::simpleMatch(endBlock, \"} else {\");\n                    bool bail = false;\n\n                    // Traverse then block\n                    bool returnThen = isEscapeScope(endBlock, true);\n                    bool returnElse = false;\n                    if (checkThen) {\n                        if (updateRange(endCond->next(), endBlock) == Progress::Break)\n                            return Progress::Break;\n                    } else if (!checkElse) {\n                        thenAction = checkScope(endBlock);\n                        if (hasGoto(endBlock))\n                            bail = true;\n                    }\n                    // Traverse else block\n                    if (hasElse) {\n                        returnElse = isEscapeScope(endBlock->linkAt(2), true);\n                        if (checkElse) {\n                            Progress result = updateRange(endBlock->tokAt(2), endBlock->linkAt(2));\n                            if (result == Progress::Break)\n                                return Progress::Break;\n                        } else if (!checkThen) {\n                            elseAction = checkScope(endBlock->linkAt(2));\n                            if (hasGoto(endBlock))\n                                bail = true;\n                        }\n                        tok = endBlock->linkAt(2);\n                    } else {\n                        tok = endBlock;\n                    }\n                    if (bail)\n                        return Progress::Break;\n                    if (returnThen && returnElse)\n                        return Progress::Break;\n                    else if (thenAction.isModified() && elseAction.isModified())\n                        return Progress::Break;\n                    else if ((returnThen || returnElse) && (thenAction.isModified() || elseAction.isModified()))\n                        return Progress::Break;\n                    // Conditional return\n                    if (returnThen && !hasElse) {\n                        if (checkThen) {\n                            return Progress::Break;\n                        } else {\n                            if (analyzer->isConditional())\n                                return Progress::Break;\n                            analyzer->assume(condTok, false);\n                        }\n                    }\n                    if (thenAction.isInconclusive() || elseAction.isInconclusive()) {\n                        if (!analyzer->lowerToInconclusive())\n                            return Progress::Break;\n                    } else if (thenAction.isModified() || elseAction.isModified()) {\n                        if (!hasElse && analyzer->isConditional())\n                            return Progress::Break;\n                        if (!analyzer->lowerToPossible())\n                            return Progress::Break;\n                        analyzer->assume(condTok, elseAction.isModified());\n                    }\n                }\n            } else if (Token::simpleMatch(tok, \"try {\")) {\n                Token* endBlock = tok->next()->link();\n                ForwardAnalyzer::Action a = analyzeScope(endBlock);\n                if (updateRange(tok->next(), endBlock) == Progress::Break)\n                    return Progress::Break;\n                if (a.isModified())\n                    analyzer->lowerToPossible();\n                tok = endBlock;\n            } else if (Token::simpleMatch(tok, \"do {\")) {\n                Token* endBlock = tok->next()->link();\n                if (updateLoop(endBlock, nullptr) == Progress::Break)\n                    return Progress::Break;\n                tok = endBlock;\n            } else if (Token::Match(tok, \"assert|ASSERT (\")) {\n                const Token* condTok = tok->next()->astOperand2();\n                bool checkThen, checkElse;\n                std::tie(checkThen, checkElse) = evalCond(condTok);\n                if (checkElse)\n                    return Progress::Break;\n                if (!checkThen)\n                    analyzer->assume(condTok, true, tok);\n            } else if (Token::simpleMatch(tok, \"switch (\")) {\n                if (updateRecursive(tok->next()->astOperand2()) == Progress::Break)\n                    return Progress::Break;\n                return Progress::Break;\n            } else {\n                if (updateTok(tok, &next) == Progress::Break)\n                    return Progress::Break;\n                if (next) {\n                    if (precedes(next, end))\n                        tok = next->previous();\n                    else\n                        return Progress::Break;\n                }\n            }\n            // Prevent infinite recursion\n            if (tok->next() == start)\n                break;\n        }\n        return Progress::Continue;\n    }\n",
        "start": 252,
        "end": 436,
        "buggy": "    Progress updateRange(Token* start, const Token* end) {\n        for (Token* tok = start; tok && tok != end; tok = tok->next()) {\n            Token* next = nullptr;\n\n            if (tok->link()) {\n                // Skip casts..\n                if (tok->str() == \"(\" && !tok->astOperand2() && tok->isCast()) {\n                    tok = tok->link();\n                    continue;\n                }\n                // Skip template arguments..\n                if (tok->str() == \"<\") {\n                    tok = tok->link();\n                    continue;\n                }\n            }\n\n            // Evaluate RHS of assignment before LHS\n            if (Token* assignTok = assignExpr(tok)) {\n                if (updateRecursive(assignTok->astOperand2()) == Progress::Break)\n                    return Progress::Break;\n                if (updateRecursive(assignTok->astOperand1()) == Progress::Break)\n                    return Progress::Break;\n                if (update(assignTok) == Progress::Break)\n                    return Progress::Break;\n                tok = nextAfterAstRightmostLeaf(assignTok);\n                if (!tok)\n                    return Progress::Break;\n            } else if (tok->str() ==  \"break\") {\n                const Scope* scope = findBreakScope(tok->scope());\n                if (!scope)\n                    return Progress::Break;\n                tok = skipTo(tok, scope->bodyEnd, end);\n                if (!analyzer->lowerToPossible())\n                    return Progress::Break;\n                // TODO: Don't break, instead move to the outer scope\n                if (!tok)\n                    return Progress::Break;\n            } else if (Token::Match(tok, \"%name% :\") || tok->str() == \"case\") {\n                if (!analyzer->lowerToPossible())\n                    return Progress::Break;\n            } else if (tok->link() && tok->str() == \"}\") {\n                if (Token::Match(tok->link()->previous(), \")|else {\")) {\n                    const bool inElse = Token::simpleMatch(tok->link()->previous(), \"else {\");\n                    const Token* condTok = getCondTokFromEnd(tok);\n                    if (!condTok)\n                        return Progress::Break;\n                    if (!condTok->hasKnownIntValue()) {\n                        if (!analyzer->lowerToPossible())\n                            return Progress::Break;\n                    } else if (condTok->values().front().intvalue == !inElse) {\n                        return Progress::Break;\n                    }\n                    analyzer->assume(condTok, !inElse, tok);\n                    if (Token::simpleMatch(tok, \"} else {\"))\n                        tok = tok->linkAt(2);\n                } else if (Token::simpleMatch(tok->link()->previous(), \"try {\")) {\n                    if (!analyzer->lowerToPossible())\n                        return Progress::Break;\n                } else if (Token::simpleMatch(tok->next(), \"else {\")) {\n                    tok = tok->linkAt(2);\n                }\n            } else if (tok->isControlFlowKeyword() && Token::Match(tok, \"if|while|for (\") && Token::simpleMatch(tok->next()->link(), \") {\")) {\n                Token* endCond = tok->next()->link();\n                Token* endBlock = endCond->next()->link();\n                Token* condTok = getCondTok(tok);\n                Token* initTok = getInitTok(tok);\n                if (!condTok)\n                    return Progress::Break;\n                if (initTok && updateRecursive(initTok) == Progress::Break)\n                    return Progress::Break;\n                if (Token::Match(tok, \"for|while (\")) {\n                    Token* stepTok = getStepTok(tok);\n                    if (updateLoop(endBlock, condTok, initTok, stepTok) == Progress::Break)\n                        return Progress::Break;\n                    tok = endBlock;\n                } else {\n                    // Traverse condition\n                    if (updateRecursive(condTok) == Progress::Break)\n                        return Progress::Break;\n                    // Check if condition is true or false\n                    bool checkThen, checkElse;\n                    std::tie(checkThen, checkElse) = evalCond(condTok);\n                    ForwardAnalyzer::Action thenAction = ForwardAnalyzer::Action::None;\n                    ForwardAnalyzer::Action elseAction = ForwardAnalyzer::Action::None;\n                    bool hasElse = Token::simpleMatch(endBlock, \"} else {\");\n                    bool bail = false;\n\n                    // Traverse then block\n                    bool returnThen = isEscapeScope(endBlock, true);\n                    bool returnElse = false;\n                    if (checkThen) {\n                        if (updateRange(endCond->next(), endBlock) == Progress::Break)\n                            return Progress::Break;\n                    } else if (!checkElse) {\n                        thenAction = checkScope(endBlock);\n                        if (hasGoto(endBlock))\n                            bail = true;\n                    }\n                    // Traverse else block\n                    if (hasElse) {\n                        returnElse = isEscapeScope(endBlock->linkAt(2), true);\n                        if (checkElse) {\n                            Progress result = updateRange(endBlock->tokAt(2), endBlock->linkAt(2));\n                            if (result == Progress::Break)\n                                return Progress::Break;\n                        } else if (!checkThen) {\n                            elseAction = checkScope(endBlock->linkAt(2));\n                            if (hasGoto(endBlock))\n                                bail = true;\n                        }\n                        tok = endBlock->linkAt(2);\n                    } else {\n                        tok = endBlock;\n                    }\n                    if (bail)\n                        return Progress::Break;\n                    if (returnThen && returnElse)\n                        return Progress::Break;\n                    else if (thenAction.isModified() && elseAction.isModified())\n                        return Progress::Break;\n                    else if ((returnThen || returnElse) && (thenAction.isModified() || elseAction.isModified()))\n                        return Progress::Break;\n                    // Conditional return\n                    if (returnThen && !hasElse) {\n                        if (checkThen) {\n                            return Progress::Break;\n                        } else {\n                            if (analyzer->isConditional())\n                                return Progress::Break;\n                            analyzer->assume(condTok, false);\n                        }\n                    }\n                    if (thenAction.isInconclusive() || elseAction.isInconclusive()) {\n                        if (!analyzer->lowerToInconclusive())\n                            return Progress::Break;\n                    } else if (thenAction.isModified() || elseAction.isModified()) {\n                        if (!hasElse && analyzer->isConditional())\n                            return Progress::Break;\n                        if (!analyzer->lowerToPossible())\n                            return Progress::Break;\n                        analyzer->assume(condTok, elseAction.isModified());\n                    }\n                }\n            } else if (Token::simpleMatch(tok, \"try {\")) {\n                Token* endBlock = tok->next()->link();\n                ForwardAnalyzer::Action a = analyzeScope(endBlock);\n                if (updateRange(tok->next(), endBlock) == Progress::Break)\n                    return Progress::Break;\n                if (a.isModified())\n                    analyzer->lowerToPossible();\n                tok = endBlock;\n            } else if (Token::simpleMatch(tok, \"do {\")) {\n                Token* endBlock = tok->next()->link();\n                if (updateLoop(endBlock, nullptr) == Progress::Break)\n                    return Progress::Break;\n                tok = endBlock;\n            } else if (Token::Match(tok, \"assert|ASSERT (\")) {\n                const Token* condTok = tok->next()->astOperand2();\n                bool checkThen, checkElse;\n                std::tie(checkThen, checkElse) = evalCond(condTok);\n                if (checkElse)\n                    return Progress::Break;\n                if (!checkThen)\n                    analyzer->assume(condTok, true, tok);\n            } else if (Token::simpleMatch(tok, \"switch (\")) {\n                if (updateRecursive(tok->next()->astOperand2()) == Progress::Break)\n                    return Progress::Break;\n                return Progress::Break;\n            } else {\n                if (updateTok(tok, &next) == Progress::Break)\n                    return Progress::Break;\n                if (next) {\n                    if (precedes(next, end))\n                        tok = next->previous();\n                    else\n                        return Progress::Break;\n                }\n            }\n            // Prevent infinite recursion\n            if (tok->next() == start)\n                break;\n        }\n        return Progress::Continue;\n    }\n",
        "fix": null,
        "buggy_hunk_masked": "                    } else if (condTok->values().front().intvalue == !inElse) {\n",
        "src_path": "0c659a149953b9a67901a5b30259b7ef534bbaad___forwardanalyzer.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/0c659a149953b9a67901a5b30259b7ef534bbaad",
        "commit_msg": "Fix incorrect logic for condition (#2675)",
        "test_func_diff": [
            {
                "fn": "test/testvalueflow.cpp",
                "patch": "@@ -1819,7 +1819,7 @@ class TestValueFlow : public TestFixture {\n                \"    y = 42 / x;\\n\" // <- x is 2\n                \"}\";\n         ASSERT_EQUALS(false, testValueOfX(code, 5U, 0));\n-        TODO_ASSERT_EQUALS(true, false, testValueOfX(code, 5U, 2));\n+        ASSERT_EQUALS(true, testValueOfX(code, 5U, 2));\n \n         code = \"void f() {\\n\" // #6118 - FN\n                \"    int x = 0;\\n\""
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_0c659a149953b9a67901a5b30259b7ef534bbaad/build_0c659a149953b9a67901a5b30259b7ef534bbaad\nTest project /out/danmar___cppcheck/git_repo_dir_0c659a149953b9a67901a5b30259b7ef534bbaad/build_0c659a149953b9a67901a5b30259b7ef534bbaad\n    Start 59: TestValueFlow\n1/1 Test #59: TestValueFlow ....................***Failed    1.27 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.28 sec\n\nThe following tests FAILED:\n\t 59 - TestValueFlow (Failed)\n"
    },
    "68d77b73da0d86b8d18bf6fcbbf45e77a29a6b26___symboldatabase.cpp": {
        "prefix": "void Variable::evaluate(const Library* lib)\n{\n    if (_name)\n        setFlag(fIsArray, arrayDimensions(lib));\n\n    const Token* tok = _start;\n    while (tok && tok->previous() && tok->previous()->isName())\n        tok = tok->previous();\n",
        "suffix": "        if (tok->str() == \"static\")\n            setFlag(fIsStatic, true);\n        else if (tok->str() == \"extern\")\n            setFlag(fIsExtern, true);\n        else if (tok->str() == \"volatile\")\n            setFlag(fIsVolatile, true);\n        else if (tok->str() == \"mutable\")\n            setFlag(fIsMutable, true);\n        else if (tok->str() == \"const\")\n            setFlag(fIsConst, true);\n        else if (tok->str() == \"*\") {\n            setFlag(fIsPointer, !isArray() || Token::Match(tok->previous(), \"( * %name% )\"));\n            setFlag(fIsConst, false); // Points to const, isn't necessarily const itself\n        } else if (tok->str() == \"&\") {\n            if (isReference())\n                setFlag(fIsRValueRef, true);\n            setFlag(fIsReference, true);\n        } else if (tok->str() == \"&&\") { // Before simplification, && isn't split up\n            setFlag(fIsRValueRef, true);\n            setFlag(fIsReference, true); // Set also fIsReference\n        }\n\n        if (tok->str() == \"<\" && tok->link())\n            tok = tok->link();\n        else\n            tok = tok->next();\n    }\n\n    while (Token::Match(_start, \"static|const %any%\"))\n        _start = _start->next();\n    while (_end && _end->previous() && _end->str() == \"const\")\n        _end = _end->previous();\n\n    if (_start) {\n        std::string strtype = _start->str();\n        for (const Token *typeToken = _start; Token::Match(typeToken, \"%type% :: %type%\"); typeToken = typeToken->tokAt(2))\n            strtype += \"::\" + typeToken->strAt(2);\n        setFlag(fIsClass, !lib->podtype(strtype) && !_start->isStandardType() && !isPointer() && !isReference());\n        setFlag(fIsStlType, Token::simpleMatch(_start, \"std ::\"));\n        setFlag(fIsStlString, isStlType() && (Token::Match(_start->tokAt(2), \"string|wstring|u16string|u32string !!::\") || (Token::simpleMatch(_start->tokAt(2), \"basic_string <\") && !Token::simpleMatch(_start->linkAt(3), \"> ::\"))));\n    }\n    if (_access == Argument) {\n        tok = _name;\n        if (!tok) {\n            // Argument without name\n            tok = _end;\n            // back up to start of array dimensions\n            while (tok && tok->str() == \"]\")\n                tok = tok->link()->previous();\n            // add array dimensions if present\n            if (tok && tok->next()->str() == \"[\")\n                setFlag(fIsArray, arrayDimensions(lib));\n        }\n        if (!tok)\n            return;\n        tok = tok->next();\n        while (tok->str() == \"[\")\n            tok = tok->link();\n        setFlag(fHasDefault, tok->str() == \"=\");\n    }\n    // check for C++11 member initialization\n    if (_scope && _scope->isClassOrStruct()) {\n        // type var = x or\n        // type var = {x}\n        // type var = x; gets simplified to: type var ; var = x ;\n        Token const * declEnd = declEndToken();\n        if ((Token::Match(declEnd, \"; %name% =\") && declEnd->strAt(1) == _name->str()) ||\n            Token::Match(declEnd, \"=|{\"))\n            setFlag(fHasDefault, true);\n    }\n\n    if (_start) {\n        if (Token::Match(_start, \"float|double\"))\n            setFlag(fIsFloatType, true);\n    }\n}\n",
        "start": 1720,
        "end": 1804,
        "buggy": "void Variable::evaluate(const Library* lib)\n{\n    if (_name)\n        setFlag(fIsArray, arrayDimensions(lib));\n\n    const Token* tok = _start;\n    while (tok && tok->previous() && tok->previous()->isName())\n        tok = tok->previous();\n    for (const Token* const end = _name?_name:_end; tok != end;) {\n        if (tok->str() == \"static\")\n            setFlag(fIsStatic, true);\n        else if (tok->str() == \"extern\")\n            setFlag(fIsExtern, true);\n        else if (tok->str() == \"volatile\")\n            setFlag(fIsVolatile, true);\n        else if (tok->str() == \"mutable\")\n            setFlag(fIsMutable, true);\n        else if (tok->str() == \"const\")\n            setFlag(fIsConst, true);\n        else if (tok->str() == \"*\") {\n            setFlag(fIsPointer, !isArray() || Token::Match(tok->previous(), \"( * %name% )\"));\n            setFlag(fIsConst, false); // Points to const, isn't necessarily const itself\n        } else if (tok->str() == \"&\") {\n            if (isReference())\n                setFlag(fIsRValueRef, true);\n            setFlag(fIsReference, true);\n        } else if (tok->str() == \"&&\") { // Before simplification, && isn't split up\n            setFlag(fIsRValueRef, true);\n            setFlag(fIsReference, true); // Set also fIsReference\n        }\n\n        if (tok->str() == \"<\" && tok->link())\n            tok = tok->link();\n        else\n            tok = tok->next();\n    }\n\n    while (Token::Match(_start, \"static|const %any%\"))\n        _start = _start->next();\n    while (_end && _end->previous() && _end->str() == \"const\")\n        _end = _end->previous();\n\n    if (_start) {\n        std::string strtype = _start->str();\n        for (const Token *typeToken = _start; Token::Match(typeToken, \"%type% :: %type%\"); typeToken = typeToken->tokAt(2))\n            strtype += \"::\" + typeToken->strAt(2);\n        setFlag(fIsClass, !lib->podtype(strtype) && !_start->isStandardType() && !isPointer() && !isReference());\n        setFlag(fIsStlType, Token::simpleMatch(_start, \"std ::\"));\n        setFlag(fIsStlString, isStlType() && (Token::Match(_start->tokAt(2), \"string|wstring|u16string|u32string !!::\") || (Token::simpleMatch(_start->tokAt(2), \"basic_string <\") && !Token::simpleMatch(_start->linkAt(3), \"> ::\"))));\n    }\n    if (_access == Argument) {\n        tok = _name;\n        if (!tok) {\n            // Argument without name\n            tok = _end;\n            // back up to start of array dimensions\n            while (tok && tok->str() == \"]\")\n                tok = tok->link()->previous();\n            // add array dimensions if present\n            if (tok && tok->next()->str() == \"[\")\n                setFlag(fIsArray, arrayDimensions(lib));\n        }\n        if (!tok)\n            return;\n        tok = tok->next();\n        while (tok->str() == \"[\")\n            tok = tok->link();\n        setFlag(fHasDefault, tok->str() == \"=\");\n    }\n    // check for C++11 member initialization\n    if (_scope && _scope->isClassOrStruct()) {\n        // type var = x or\n        // type var = {x}\n        // type var = x; gets simplified to: type var ; var = x ;\n        Token const * declEnd = declEndToken();\n        if ((Token::Match(declEnd, \"; %name% =\") && declEnd->strAt(1) == _name->str()) ||\n            Token::Match(declEnd, \"=|{\"))\n            setFlag(fHasDefault, true);\n    }\n\n    if (_start) {\n        if (Token::Match(_start, \"float|double\"))\n            setFlag(fIsFloatType, true);\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    for (const Token* const end = _name?_name:_end; tok != end;) {\n",
        "src_path": "68d77b73da0d86b8d18bf6fcbbf45e77a29a6b26___symboldatabase.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/68d77b73da0d86b8d18bf6fcbbf45e77a29a6b26",
        "commit_msg": "SymbolDatabase: Fixed parsing of unnamed arguments, properly detect pointers (#8052)",
        "test_func_diff": [
            {
                "fn": "test/testsymboldatabase.cpp",
                "patch": "@@ -1615,6 +1615,12 @@ class TestSymbolDatabase: public TestFixture {\n             ASSERT(g && g->type == Scope::eFunction && g->function && g->function->argumentList.size() == 1 && g->function->argumentList.front().hasDefault());\n             ASSERT_EQUALS(\"\", errout.str());\n         }\n+        {\n+            GET_SYMBOL_DB(\"void g(int*) { }\"); // unnamed pointer argument (#8052)\n+            const Scope* g = db->findScopeByName(\"g\");\n+            ASSERT(g && g->type == Scope::eFunction && g->function && g->function->argumentList.size() == 1 && g->function->argumentList.front().nameToken() == nullptr && g->function->argumentList.front().isPointer());\n+            ASSERT_EQUALS(\"\", errout.str());\n+        }\n         {\n             GET_SYMBOL_DB(\"void g(int* const) { }\"); // 'const' is not the name of the variable - #5882\n             const Scope* g = db->findScopeByName(\"g\");"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_68d77b73da0d86b8d18bf6fcbbf45e77a29a6b26/build_68d77b73da0d86b8d18bf6fcbbf45e77a29a6b26\nTest project /out/danmar___cppcheck/git_repo_dir_68d77b73da0d86b8d18bf6fcbbf45e77a29a6b26/build_68d77b73da0d86b8d18bf6fcbbf45e77a29a6b26\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   24.73 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  24.73 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n"
    },
    "797de4ef920dda5c569e5fd74e27731bc32053dd___checkcondition.cpp": {
        "prefix": "void CheckCondition::checkCompareValueOutOfTypeRange()\n{\n    if (!mSettings->severity.isEnabled(Severity::style))\n        return;\n\n    if (mSettings->platformType == cppcheck::Platform::PlatformType::Native ||\n        mSettings->platformType == cppcheck::Platform::PlatformType::Unspecified)\n        return;\n\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n    for (const Scope * scope : symbolDatabase->functionScopes) {\n        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {\n            if (!tok->isComparisonOp() || !tok->isBinaryOp())\n                continue;\n\n            for (int i = 0; i < 2; ++i) {\n                const Token * const valueTok = (i == 0) ? tok->astOperand1() : tok->astOperand2();\n                const Token * const typeTok = valueTok->astSibling();\n                if (!valueTok->hasKnownIntValue() || !typeTok->valueType() || typeTok->valueType()->pointer)\n                    continue;\n                if (valueTok->getKnownIntValue() < 0 && valueTok->valueType() && valueTok->valueType()->sign != ValueType::Sign::SIGNED)\n                    continue;\n                int bits = 0;\n                switch (typeTok->valueType()->type) {\n                case ValueType::Type::BOOL:\n                    bits = 1;\n                    break;\n                case ValueType::Type::CHAR:\n                    bits = mSettings->char_bit;\n                    break;\n                case ValueType::Type::SHORT:\n                    bits = mSettings->short_bit;\n                    break;\n                case ValueType::Type::INT:\n                    bits = mSettings->int_bit;\n                    break;\n                case ValueType::Type::LONG:\n                    bits = mSettings->long_bit;\n                    break;\n                case ValueType::Type::LONGLONG:\n                    bits = mSettings->long_long_bit;\n                    break;\n                default:\n                    break;\n                };\n                if (bits == 0 || bits >= 64)\n                    continue;\n\n                const auto typeMinValue = (typeTok->valueType()->sign == ValueType::Sign::SIGNED) ? (-(1LL << (bits-1))) : 0;\n",
        "suffix": "                const auto typeMaxValue = (typeTok->valueType()->sign == ValueType::Sign::SIGNED) ? (unsignedTypeMaxValue / 2) : unsignedTypeMaxValue;\n\n                if (valueTok->getKnownIntValue() < typeMinValue)\n                    compareValueOutOfTypeRangeError(valueTok, typeTok->valueType()->str(), valueTok->getKnownIntValue());\n                else if (valueTok->getKnownIntValue() > typeMaxValue)\n                    compareValueOutOfTypeRangeError(valueTok, typeTok->valueType()->str(), valueTok->getKnownIntValue());\n            }\n        }\n    }\n}\n",
        "start": 1760,
        "end": 1819,
        "buggy": "void CheckCondition::checkCompareValueOutOfTypeRange()\n{\n    if (!mSettings->severity.isEnabled(Severity::style))\n        return;\n\n    if (mSettings->platformType == cppcheck::Platform::PlatformType::Native ||\n        mSettings->platformType == cppcheck::Platform::PlatformType::Unspecified)\n        return;\n\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n    for (const Scope * scope : symbolDatabase->functionScopes) {\n        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {\n            if (!tok->isComparisonOp() || !tok->isBinaryOp())\n                continue;\n\n            for (int i = 0; i < 2; ++i) {\n                const Token * const valueTok = (i == 0) ? tok->astOperand1() : tok->astOperand2();\n                const Token * const typeTok = valueTok->astSibling();\n                if (!valueTok->hasKnownIntValue() || !typeTok->valueType() || typeTok->valueType()->pointer)\n                    continue;\n                if (valueTok->getKnownIntValue() < 0 && valueTok->valueType() && valueTok->valueType()->sign != ValueType::Sign::SIGNED)\n                    continue;\n                int bits = 0;\n                switch (typeTok->valueType()->type) {\n                case ValueType::Type::BOOL:\n                    bits = 1;\n                    break;\n                case ValueType::Type::CHAR:\n                    bits = mSettings->char_bit;\n                    break;\n                case ValueType::Type::SHORT:\n                    bits = mSettings->short_bit;\n                    break;\n                case ValueType::Type::INT:\n                    bits = mSettings->int_bit;\n                    break;\n                case ValueType::Type::LONG:\n                    bits = mSettings->long_bit;\n                    break;\n                case ValueType::Type::LONGLONG:\n                    bits = mSettings->long_long_bit;\n                    break;\n                default:\n                    break;\n                };\n                if (bits == 0 || bits >= 64)\n                    continue;\n\n                const auto typeMinValue = (typeTok->valueType()->sign == ValueType::Sign::SIGNED) ? (-(1LL << (bits-1))) : 0;\n                const auto unsignedTypeMaxValue = (1LL << (bits-1)) - 1LL;\n                const auto typeMaxValue = (typeTok->valueType()->sign == ValueType::Sign::SIGNED) ? (unsignedTypeMaxValue / 2) : unsignedTypeMaxValue;\n\n                if (valueTok->getKnownIntValue() < typeMinValue)\n                    compareValueOutOfTypeRangeError(valueTok, typeTok->valueType()->str(), valueTok->getKnownIntValue());\n                else if (valueTok->getKnownIntValue() > typeMaxValue)\n                    compareValueOutOfTypeRangeError(valueTok, typeTok->valueType()->str(), valueTok->getKnownIntValue());\n            }\n        }\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                const auto unsignedTypeMaxValue = (1LL << (bits-1)) - 1LL;\n",
        "src_path": "797de4ef920dda5c569e5fd74e27731bc32053dd___checkcondition.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/797de4ef920dda5c569e5fd74e27731bc32053dd",
        "commit_msg": "Fixed #10363 (FP: compareValueOutOfTypeRangeError)",
        "test_func_diff": [
            {
                "fn": "test/testcondition.cpp",
                "patch": "@@ -4304,9 +4304,19 @@ class TestCondition : public TestFixture {\n         settingsUnix64.platform(cppcheck::Platform::PlatformType::Unix64);\n \n         check(\"void f(unsigned char c) {\\n\"\n-              \"  if (c == 1234) {}\\n\"\n+              \"  if (c == 256) {}\\n\"\n               \"}\", &settingsUnix64);\n-        ASSERT_EQUALS(\"[test.cpp:2]: (style) Comparing expression of type 'unsigned char' against value 1234. Condition is always true/false.\\n\", errout.str());\n+        ASSERT_EQUALS(\"[test.cpp:2]: (style) Comparing expression of type 'unsigned char' against value 256. Condition is always true/false.\\n\", errout.str());\n+\n+        check(\"void f(unsigned char c) {\\n\"\n+              \"  if (c == 255) {}\\n\"\n+              \"}\", &settingsUnix64);\n+        ASSERT_EQUALS(\"\", errout.str());\n+\n+        check(\"void f(bool b) {\\n\"\n+              \"  if (b == true) {}\\n\"\n+              \"}\", &settingsUnix64);\n+        ASSERT_EQUALS(\"\", errout.str());\n     }\n };\n "
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_797de4ef920dda5c569e5fd74e27731bc32053dd/build_797de4ef920dda5c569e5fd74e27731bc32053dd\nTest project /out/danmar___cppcheck/git_repo_dir_797de4ef920dda5c569e5fd74e27731bc32053dd/build_797de4ef920dda5c569e5fd74e27731bc32053dd\n    Start 14: TestCondition\n1/1 Test #14: TestCondition ....................***Failed    1.91 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.92 sec\n\nThe following tests FAILED:\n\t 14 - TestCondition (Failed)\n"
    },
    "0ee3f678b52d0203d4b84abf65e5cac92f26a553___checkcondition.cpp": {
        "prefix": "void CheckCondition::alwaysTrueFalse()\n{\n    if (!mSettings->isEnabled(Settings::STYLE))\n        return;\n\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n    for (const Scope * scope : symbolDatabase->functionScopes) {\n        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {\n\n            if (tok->link()) // don't write false positives when templates are used\n                continue;\n            if (!tok->hasKnownIntValue())\n                continue;\n            // Skip already diagnosed values\n            if (diag(tok, false))\n                continue;\n            if (Token::Match(tok, \"%num%|%bool%|%char%\"))\n                continue;\n            if (Token::Match(tok, \"! %num%|%bool%|%char%\"))\n                continue;\n            if (Token::Match(tok, \"%oror%|&&|:\"))\n                continue;\n            if (Token::Match(tok, \"%comp%\") && isSameExpression(mTokenizer->isCPP(), true, tok->astOperand1(), tok->astOperand2(), mSettings->library, true, true))\n                continue;\n\n            const bool constIfWhileExpression =\n                tok->astParent() && Token::Match(tok->astTop()->astOperand1(), \"if|while\") &&\n                (Token::Match(tok->astParent(), \"%oror%|&&\") || Token::Match(tok->astParent()->astOperand1(), \"if|while\"));\n            const bool constValExpr = tok->isNumber() && Token::Match(tok->astParent(),\"%oror%|&&|?\"); // just one number in boolean expression\n            const bool compExpr = Token::Match(tok, \"%comp%|!\"); // a compare expression\n            const bool returnStatement = Token::simpleMatch(tok->astTop(), \"return\") &&\n                                         Token::Match(tok->astParent(), \"%oror%|&&|return\");\n\n            if (!(constIfWhileExpression || constValExpr || compExpr || returnStatement))\n                continue;\n\n",
        "suffix": "                continue;\n\n            if (returnStatement && isConstVarExpression(tok))\n                continue;\n\n            if (returnStatement && Token::simpleMatch(tok->astParent(), \"return\") && tok->variable() && (\n                    !tok->variable()->isLocal() ||\n                    tok->variable()->isReference() ||\n                    tok->variable()->isConst() ||\n                    !isVariableChanged(tok->variable(), mSettings, mTokenizer->isCPP())))\n                continue;\n\n            // Don't warn in assertions. Condition is often 'always true' by intention.\n            // If platform,defines,etc cause 'always false' then that is not dangerous neither.\n            bool assertFound = false;\n            for (const Token * tok2 = tok->astParent(); tok2 ; tok2 = tok2->astParent()) { // move backwards and try to find \"assert\"\n                if (tok2->str() == \"(\" && tok2->astOperand2()) {\n                    const std::string& str = tok2->previous()->str();\n                    if ((str.find(\"assert\")!=std::string::npos || str.find(\"ASSERT\")!=std::string::npos))\n                        assertFound = true;\n                    break;\n                }\n            }\n            if (assertFound)\n                continue;\n\n            // Don't warn when there are expanded macros..\n            bool isExpandedMacro = false;\n            std::stack<const Token*> tokens;\n            tokens.push(tok);\n            while (!tokens.empty()) {\n                const Token *tok2 = tokens.top();\n                tokens.pop();\n                if (!tok2)\n                    continue;\n                tokens.push(tok2->astOperand1());\n                tokens.push(tok2->astOperand2());\n                if (tok2->isExpandedMacro()) {\n                    isExpandedMacro = true;\n                    break;\n                }\n            }\n            if (isExpandedMacro)\n                continue;\n            for (const Token *parent = tok; parent; parent = parent->astParent()) {\n                if (parent->isExpandedMacro()) {\n                    isExpandedMacro = true;\n                    break;\n                }\n            }\n            if (isExpandedMacro)\n                continue;\n\n            // don't warn when condition checks sizeof result\n            bool hasSizeof = false;\n            tokens.push(tok);\n            while (!tokens.empty()) {\n                const Token *tok2 = tokens.top();\n                tokens.pop();\n                if (!tok2)\n                    continue;\n                if (tok2->isNumber())\n                    continue;\n                if (Token::simpleMatch(tok2->previous(), \"sizeof (\")) {\n                    hasSizeof = true;\n                    continue;\n                }\n                if (tok2->isComparisonOp() || tok2->isArithmeticalOp()) {\n                    tokens.push(tok2->astOperand1());\n                    tokens.push(tok2->astOperand2());\n                } else\n                    break;\n            }\n            if (tokens.empty() && hasSizeof)\n                continue;\n\n            alwaysTrueFalseError(tok, &tok->values().front());\n        }\n    }\n}\n",
        "start": 1298,
        "end": 1414,
        "buggy": "void CheckCondition::alwaysTrueFalse()\n{\n    if (!mSettings->isEnabled(Settings::STYLE))\n        return;\n\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n    for (const Scope * scope : symbolDatabase->functionScopes) {\n        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {\n\n            if (tok->link()) // don't write false positives when templates are used\n                continue;\n            if (!tok->hasKnownIntValue())\n                continue;\n            // Skip already diagnosed values\n            if (diag(tok, false))\n                continue;\n            if (Token::Match(tok, \"%num%|%bool%|%char%\"))\n                continue;\n            if (Token::Match(tok, \"! %num%|%bool%|%char%\"))\n                continue;\n            if (Token::Match(tok, \"%oror%|&&|:\"))\n                continue;\n            if (Token::Match(tok, \"%comp%\") && isSameExpression(mTokenizer->isCPP(), true, tok->astOperand1(), tok->astOperand2(), mSettings->library, true, true))\n                continue;\n\n            const bool constIfWhileExpression =\n                tok->astParent() && Token::Match(tok->astTop()->astOperand1(), \"if|while\") &&\n                (Token::Match(tok->astParent(), \"%oror%|&&\") || Token::Match(tok->astParent()->astOperand1(), \"if|while\"));\n            const bool constValExpr = tok->isNumber() && Token::Match(tok->astParent(),\"%oror%|&&|?\"); // just one number in boolean expression\n            const bool compExpr = Token::Match(tok, \"%comp%|!\"); // a compare expression\n            const bool returnStatement = Token::simpleMatch(tok->astTop(), \"return\") &&\n                                         Token::Match(tok->astParent(), \"%oror%|&&|return\");\n\n            if (!(constIfWhileExpression || constValExpr || compExpr || returnStatement))\n                continue;\n\n            if (returnStatement && scope->function && !Token::simpleMatch(scope->function->retDef, \"bool\"))\n                continue;\n\n            if (returnStatement && isConstVarExpression(tok))\n                continue;\n\n            if (returnStatement && Token::simpleMatch(tok->astParent(), \"return\") && tok->variable() && (\n                    !tok->variable()->isLocal() ||\n                    tok->variable()->isReference() ||\n                    tok->variable()->isConst() ||\n                    !isVariableChanged(tok->variable(), mSettings, mTokenizer->isCPP())))\n                continue;\n\n            // Don't warn in assertions. Condition is often 'always true' by intention.\n            // If platform,defines,etc cause 'always false' then that is not dangerous neither.\n            bool assertFound = false;\n            for (const Token * tok2 = tok->astParent(); tok2 ; tok2 = tok2->astParent()) { // move backwards and try to find \"assert\"\n                if (tok2->str() == \"(\" && tok2->astOperand2()) {\n                    const std::string& str = tok2->previous()->str();\n                    if ((str.find(\"assert\")!=std::string::npos || str.find(\"ASSERT\")!=std::string::npos))\n                        assertFound = true;\n                    break;\n                }\n            }\n            if (assertFound)\n                continue;\n\n            // Don't warn when there are expanded macros..\n            bool isExpandedMacro = false;\n            std::stack<const Token*> tokens;\n            tokens.push(tok);\n            while (!tokens.empty()) {\n                const Token *tok2 = tokens.top();\n                tokens.pop();\n                if (!tok2)\n                    continue;\n                tokens.push(tok2->astOperand1());\n                tokens.push(tok2->astOperand2());\n                if (tok2->isExpandedMacro()) {\n                    isExpandedMacro = true;\n                    break;\n                }\n            }\n            if (isExpandedMacro)\n                continue;\n            for (const Token *parent = tok; parent; parent = parent->astParent()) {\n                if (parent->isExpandedMacro()) {\n                    isExpandedMacro = true;\n                    break;\n                }\n            }\n            if (isExpandedMacro)\n                continue;\n\n            // don't warn when condition checks sizeof result\n            bool hasSizeof = false;\n            tokens.push(tok);\n            while (!tokens.empty()) {\n                const Token *tok2 = tokens.top();\n                tokens.pop();\n                if (!tok2)\n                    continue;\n                if (tok2->isNumber())\n                    continue;\n                if (Token::simpleMatch(tok2->previous(), \"sizeof (\")) {\n                    hasSizeof = true;\n                    continue;\n                }\n                if (tok2->isComparisonOp() || tok2->isArithmeticalOp()) {\n                    tokens.push(tok2->astOperand1());\n                    tokens.push(tok2->astOperand2());\n                } else\n                    break;\n            }\n            if (tokens.empty() && hasSizeof)\n                continue;\n\n            alwaysTrueFalseError(tok, &tok->values().front());\n        }\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            if (returnStatement && scope->function && !Token::simpleMatch(scope->function->retDef, \"bool\"))\n",
        "src_path": "0ee3f678b52d0203d4b84abf65e5cac92f26a553___checkcondition.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/0ee3f678b52d0203d4b84abf65e5cac92f26a553",
        "commit_msg": "Fix issue 8987: False positive knownConditionTrueFalse (#1678)",
        "test_func_diff": [
            {
                "fn": "test/testcondition.cpp",
                "patch": "@@ -2872,6 +2872,15 @@ class TestCondition : public TestFixture {\n               \"  else return 42;\\n\"\n               \"}\\n\");\n         ASSERT_EQUALS(\"\", errout.str());\n+\n+        check(\"long X::g(bool unknown, int& result) {\\n\"\n+              \"    long ret = 0;\\n\"\n+              \"    bool f = false;\\n\"\n+              \"    f = f || unknown;\\n\"\n+              \"    f ? result = 42 : ret = -1;\\n\"\n+              \"    return ret;\\n\"\n+              \"}\\n\");\n+        ASSERT_EQUALS(\"\", errout.str());\n     }\n \n     void multiConditionAlwaysTrue() {"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_0ee3f678b52d0203d4b84abf65e5cac92f26a553/build_0ee3f678b52d0203d4b84abf65e5cac92f26a553\nTest project /out/danmar___cppcheck/git_repo_dir_0ee3f678b52d0203d4b84abf65e5cac92f26a553/build_0ee3f678b52d0203d4b84abf65e5cac92f26a553\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   27.67 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  27.68 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n"
    },
    "f5dbfce8ffb3132bb49a155527a620c98e61b4a1___astutils.cpp": {
        "prefix": "bool isOppositeExpression(bool cpp, const Token * const tok1, const Token * const tok2, const Library& library, bool pure)\n{\n    if (!tok1 || !tok2)\n        return false;\n    if (isOppositeCond(true, cpp, tok1, tok2, library, pure))\n        return true;\n    if (tok1->str() == \"-\" && !tok1->astOperand2())\n        return isSameExpression(cpp, true, tok1->astOperand1(), tok2, library, pure);\n",
        "suffix": "        return isSameExpression(cpp, true, tok2->astOperand1(), tok1, library, pure);\n    return false;\n}\n",
        "start": 362,
        "end": 373,
        "buggy": "bool isOppositeExpression(bool cpp, const Token * const tok1, const Token * const tok2, const Library& library, bool pure)\n{\n    if (!tok1 || !tok2)\n        return false;\n    if (isOppositeCond(true, cpp, tok1, tok2, library, pure))\n        return true;\n    if (tok1->str() == \"-\" && !tok1->astOperand2())\n        return isSameExpression(cpp, true, tok1->astOperand1(), tok2, library, pure);\n    if (tok2->str() == \"-\" && !tok1->astOperand2())\n        return isSameExpression(cpp, true, tok2->astOperand1(), tok1, library, pure);\n    return false;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (tok2->str() == \"-\" && !tok1->astOperand2())\n",
        "src_path": "f5dbfce8ffb3132bb49a155527a620c98e61b4a1___astutils.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/f5dbfce8ffb3132bb49a155527a620c98e61b4a1",
        "commit_msg": "Fix false positive with oppositeExpression when using binary op (#1211)\n\n* Fix false positive with oppositeExpression when using binary op\r\n\r\n* Simplify conditional",
        "test_func_diff": [
            {
                "fn": "test/testother.cpp",
                "patch": "@@ -3958,6 +3958,9 @@ class TestOther : public TestFixture {\n \n         check(\"bool f(int i){ return !((i - 1) & i); }\");\n         ASSERT_EQUALS(\"\", errout.str());\n+\n+        check(\"bool f(unsigned i){ return (x > 0) && (x & (x-1)) == 0; }\");\n+        ASSERT_EQUALS(\"\", errout.str());\n     }\n \n     void duplicateVarExpression() {"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_f5dbfce8ffb3132bb49a155527a620c98e61b4a1/build_f5dbfce8ffb3132bb49a155527a620c98e61b4a1\nTest project /out/danmar___cppcheck/git_repo_dir_f5dbfce8ffb3132bb49a155527a620c98e61b4a1/build_f5dbfce8ffb3132bb49a155527a620c98e61b4a1\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   19.67 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  19.67 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n"
    },
    "43e4364675d4d47125b0d919039ba73dd4f6376e___preprocessor.cpp": {
        "prefix": "std::string Preprocessor::getcode(const simplecpp::TokenList &tokens1, const std::string &cfg, std::vector<std::string> &files, const bool writeLocations)\n{\n    const simplecpp::DUI dui = createDUI(_settings, cfg, files[0]);\n\n    simplecpp::OutputList outputList;\n    std::list<simplecpp::MacroUsage> macroUsage;\n    simplecpp::TokenList tokens2(files);\n    simplecpp::preprocess(tokens2, tokens1, files, tokenlists, dui, &outputList, &macroUsage);\n\n    bool showerror = (!_settings.userDefines.empty() && !_settings.force);\n    reportOutput(outputList, showerror);\n    if (hasErrors(outputList))\n        return \"\";\n\n    // ensure that guessed define macros without value are not used in the code\n    if (!validateCfg(cfg, macroUsage))\n        return \"\";\n\n    // assembler code locations..\n    std::set<simplecpp::Location> assemblerLocations;\n    for (std::list<Directive>::const_iterator dirIt = directives.begin(); dirIt != directives.end(); ++dirIt) {\n        const Directive &d1 = *dirIt;\n        if (d1.str.compare(0, 11, \"#pragma asm\") != 0)\n            continue;\n        std::list<Directive>::const_iterator dirIt2 = dirIt;\n        ++dirIt2;\n        if (dirIt2 == directives.end())\n            continue;\n\n        const Directive &d2 = *dirIt2;\n        if (d2.str.compare(0,14,\"#pragma endasm\") != 0 || d1.file != d2.file)\n            continue;\n\n        simplecpp::Location loc(files);\n        loc.fileIndex = ~0U;\n        loc.col = 0U;\n        for (unsigned int i = 0; i < files.size(); ++i) {\n            if (files[i] == d1.file) {\n                loc.fileIndex = i;\n                break;\n            }\n        }\n\n        for (unsigned int linenr = d1.linenr + 1U; linenr < d2.linenr; linenr++) {\n            loc.line = linenr;\n            assemblerLocations.insert(loc);\n        }\n    }\n\n    unsigned int prevfile = 0;\n    unsigned int line = 1;\n    std::ostringstream ret;\n    for (const simplecpp::Token *tok = tokens2.cfront(); tok; tok = tok->next) {\n        if (writeLocations && tok->location.fileIndex != prevfile) {\n            ret << \"\\n#line \" << tok->location.line << \" \\\"\" << tok->location.file() << \"\\\"\\n\";\n            prevfile = tok->location.fileIndex;\n            line = tok->location.line;\n        }\n\n",
        "suffix": "            ret << ' ';\n        bool newline = false;\n        while (tok->location.line > line) {\n            ret << '\\n';\n            line++;\n            newline = true;\n        }\n        if (newline) {\n            simplecpp::Location loc = tok->location;\n            loc.col = 0U;\n            if (assemblerLocations.find(loc) != assemblerLocations.end()) {\n                ret << \"asm();\";\n                while (assemblerLocations.find(loc) != assemblerLocations.end()) {\n                    loc.line++;\n                }\n                while (tok && tok->location.line < loc.line)\n                    tok = tok->next;\n                if (!tok)\n                    break;\n                while (line < tok->location.line) {\n                    ret << '\\n';\n                    ++line;\n                }\n            }\n        }\n        if (!tok->macro.empty())\n            ret << Preprocessor::macroChar;\n        ret << tok->str;\n    }\n\n    return ret.str();\n}\n",
        "start": 559,
        "end": 650,
        "buggy": "std::string Preprocessor::getcode(const simplecpp::TokenList &tokens1, const std::string &cfg, std::vector<std::string> &files, const bool writeLocations)\n{\n    const simplecpp::DUI dui = createDUI(_settings, cfg, files[0]);\n\n    simplecpp::OutputList outputList;\n    std::list<simplecpp::MacroUsage> macroUsage;\n    simplecpp::TokenList tokens2(files);\n    simplecpp::preprocess(tokens2, tokens1, files, tokenlists, dui, &outputList, &macroUsage);\n\n    bool showerror = (!_settings.userDefines.empty() && !_settings.force);\n    reportOutput(outputList, showerror);\n    if (hasErrors(outputList))\n        return \"\";\n\n    // ensure that guessed define macros without value are not used in the code\n    if (!validateCfg(cfg, macroUsage))\n        return \"\";\n\n    // assembler code locations..\n    std::set<simplecpp::Location> assemblerLocations;\n    for (std::list<Directive>::const_iterator dirIt = directives.begin(); dirIt != directives.end(); ++dirIt) {\n        const Directive &d1 = *dirIt;\n        if (d1.str.compare(0, 11, \"#pragma asm\") != 0)\n            continue;\n        std::list<Directive>::const_iterator dirIt2 = dirIt;\n        ++dirIt2;\n        if (dirIt2 == directives.end())\n            continue;\n\n        const Directive &d2 = *dirIt2;\n        if (d2.str.compare(0,14,\"#pragma endasm\") != 0 || d1.file != d2.file)\n            continue;\n\n        simplecpp::Location loc(files);\n        loc.fileIndex = ~0U;\n        loc.col = 0U;\n        for (unsigned int i = 0; i < files.size(); ++i) {\n            if (files[i] == d1.file) {\n                loc.fileIndex = i;\n                break;\n            }\n        }\n\n        for (unsigned int linenr = d1.linenr + 1U; linenr < d2.linenr; linenr++) {\n            loc.line = linenr;\n            assemblerLocations.insert(loc);\n        }\n    }\n\n    unsigned int prevfile = 0;\n    unsigned int line = 1;\n    std::ostringstream ret;\n    for (const simplecpp::Token *tok = tokens2.cfront(); tok; tok = tok->next) {\n        if (writeLocations && tok->location.fileIndex != prevfile) {\n            ret << \"\\n#line \" << tok->location.line << \" \\\"\" << tok->location.file() << \"\\\"\\n\";\n            prevfile = tok->location.fileIndex;\n            line = tok->location.line;\n        }\n\n        if (tok->previous && line == tok->location.line)\n            ret << ' ';\n        bool newline = false;\n        while (tok->location.line > line) {\n            ret << '\\n';\n            line++;\n            newline = true;\n        }\n        if (newline) {\n            simplecpp::Location loc = tok->location;\n            loc.col = 0U;\n            if (assemblerLocations.find(loc) != assemblerLocations.end()) {\n                ret << \"asm();\";\n                while (assemblerLocations.find(loc) != assemblerLocations.end()) {\n                    loc.line++;\n                }\n                while (tok && tok->location.line < loc.line)\n                    tok = tok->next;\n                if (!tok)\n                    break;\n                while (line < tok->location.line) {\n                    ret << '\\n';\n                    ++line;\n                }\n            }\n        }\n        if (!tok->macro.empty())\n            ret << Preprocessor::macroChar;\n        ret << tok->str;\n    }\n\n    return ret.str();\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        if (tok->previous && line == tok->location.line)\n",
        "src_path": "43e4364675d4d47125b0d919039ba73dd4f6376e___preprocessor.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/43e4364675d4d47125b0d919039ba73dd4f6376e",
        "commit_msg": "Ticket #7912: Properly preprocess files with decreasing line numbers, due to #line directives.",
        "test_func_diff": [
            {
                "fn": "test/testpreprocessor.cpp",
                "patch": "@@ -240,6 +240,8 @@ class TestPreprocessor : public TestFixture {\n         TEST_CASE(testDirectiveIncludeTypes);\n         TEST_CASE(testDirectiveIncludeLocations);\n         TEST_CASE(testDirectiveIncludeComments);\n+\n+        TEST_CASE(testSameLine);  // #7912\n     }\n \n     void preprocess(const char* code, std::map<std::string, std::string>& actual, const char filename[] = \"file.c\") {\n@@ -2294,6 +2296,19 @@ class TestPreprocessor : public TestFixture {\n         ASSERT_EQUALS(dumpdata, ostr.str());\n     }\n \n+    void testSameLine() { // Ticket #7912\n+        const char code[] = \"#line 1 \\\"bench/btl/libs/BLAS/blas_interface_impl.hh\\\" \\n\"\n+                            \"template < > class blas_interface < float > : public c_interface_base < float > \\n\"\n+                            \"{ } ;\\n\"\n+                            \"#line 1 \\\"bench/btl/libs/BLAS/blas_interface_impl.hh\\\" \\n\"\n+                            \"template < > class blas_interface < double > : public c_interface_base < double > \\n\"\n+                            \"{ } ;\";\n+        const char exp[]  = \"template < > class blas_interface < float > : public c_interface_base < float >\\n\"\n+                            \"{ } ; template < > class blas_interface < double > : public c_interface_base < double > { } ;\";\n+        Preprocessor preprocessor(settings0, this);\n+        ASSERT_EQUALS(exp, preprocessor.getcode(code, \"\", \"test.cpp\"));\n+    }\n+\n };\n \n REGISTER_TEST(TestPreprocessor)"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_43e4364675d4d47125b0d919039ba73dd4f6376e/build_43e4364675d4d47125b0d919039ba73dd4f6376e\nTest project /out/danmar___cppcheck/git_repo_dir_43e4364675d4d47125b0d919039ba73dd4f6376e/build_43e4364675d4d47125b0d919039ba73dd4f6376e\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   11.49 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  11.49 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n"
    },
    "6f2879a59b2c71b1fdb472471412c4b73184fea0___errorlogger.cpp": {
        "prefix": "bool ErrorLogger::reportUnmatchedSuppressions(const std::list<Suppressions::Suppression> &unmatched)\n{\n    bool err = false;\n    // Report unmatched suppressions\n    for (const Suppressions::Suppression &s : unmatched) {\n        // don't report \"unmatchedSuppression\" as unmatched\n        if (s.errorId == \"unmatchedSuppression\")\n            continue;\n\n        // check if this unmatched suppression is suppressed\n        bool suppressed = false;\n        for (const Suppressions::Suppression &s2 : unmatched) {\n            if (s2.errorId == \"unmatchedSuppression\") {\n",
        "suffix": "                    (s2.lineNumber == Suppressions::Suppression::NO_LINE || s2.lineNumber == s.lineNumber)) {\n                    suppressed = true;\n                    break;\n                }\n            }\n        }\n\n        if (suppressed)\n            continue;\n\n        std::list<ErrorLogger::ErrorMessage::FileLocation> callStack;\n        if (!s.fileName.empty())\n            callStack.emplace_back(s.fileName, s.lineNumber, 0);\n        reportErr(ErrorLogger::ErrorMessage(callStack, emptyString, Severity::information, \"Unmatched suppression: \" + s.errorId, \"unmatchedSuppression\", false));\n        err = true;\n    }\n    return err;\n}\n",
        "start": 554,
        "end": 585,
        "buggy": "bool ErrorLogger::reportUnmatchedSuppressions(const std::list<Suppressions::Suppression> &unmatched)\n{\n    bool err = false;\n    // Report unmatched suppressions\n    for (const Suppressions::Suppression &s : unmatched) {\n        // don't report \"unmatchedSuppression\" as unmatched\n        if (s.errorId == \"unmatchedSuppression\")\n            continue;\n\n        // check if this unmatched suppression is suppressed\n        bool suppressed = false;\n        for (const Suppressions::Suppression &s2 : unmatched) {\n            if (s2.errorId == \"unmatchedSuppression\") {\n                if ((s2.fileName == \"*\" || s2.fileName == s.fileName) &&\n                    (s2.lineNumber == Suppressions::Suppression::NO_LINE || s2.lineNumber == s.lineNumber)) {\n                    suppressed = true;\n                    break;\n                }\n            }\n        }\n\n        if (suppressed)\n            continue;\n\n        std::list<ErrorLogger::ErrorMessage::FileLocation> callStack;\n        if (!s.fileName.empty())\n            callStack.emplace_back(s.fileName, s.lineNumber, 0);\n        reportErr(ErrorLogger::ErrorMessage(callStack, emptyString, Severity::information, \"Unmatched suppression: \" + s.errorId, \"unmatchedSuppression\", false));\n        err = true;\n    }\n    return err;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                if ((s2.fileName == \"*\" || s2.fileName == s.fileName) &&\n",
        "src_path": "6f2879a59b2c71b1fdb472471412c4b73184fea0___errorlogger.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/6f2879a59b2c71b1fdb472471412c4b73184fea0",
        "commit_msg": "errorlogger.cpp: Handle empty file-name like \"*\" (unmatchedSuppression) (#2440)\n\nUsing \"--suppress=unmatchedSuppression\" did not suppress the error-id in\r\nall files, one needed to specify \"*\" as file-name. This commit also\r\nallows empty file-names to suppress \"unmatchedSuppression\", not only \"*\"\r\nor the exact file-name.\r\nThe manual uses the following example for suppressions specified in a\r\nfile:\r\n// suppress all uninitvar errors in all files\r\nuninitvar\r\n\r\nThis example suggests that no \"*\" has to be used to get suppression in\r\nall files. I think that the command line parameter should work in the\r\nsame way.",
        "test_func_diff": [
            {
                "fn": "test/testerrorlogger.cpp",
                "patch": "@@ -325,6 +325,14 @@ class TestErrorLogger : public TestFixture {\n         reportUnmatchedSuppressions(suppressions);\n         ASSERT_EQUALS(\"\", errout.str());\n \n+        // suppress all unmatchedSuppression (corresponds to \"--suppress=unmatchedSuppression\")\n+        errout.str(\"\");\n+        suppressions.clear();\n+        suppressions.emplace_back(\"abc\", \"a.c\", 10U);\n+        suppressions.emplace_back(\"unmatchedSuppression\", \"\", Suppressions::Suppression::NO_LINE);\n+        reportUnmatchedSuppressions(suppressions);\n+        ASSERT_EQUALS(\"\", errout.str());\n+\n         // suppress all unmatchedSuppression in a.c\n         errout.str(\"\");\n         suppressions.clear();"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_6f2879a59b2c71b1fdb472471412c4b73184fea0/build_6f2879a59b2c71b1fdb472471412c4b73184fea0\nTest project /out/danmar___cppcheck/git_repo_dir_6f2879a59b2c71b1fdb472471412c4b73184fea0/build_6f2879a59b2c71b1fdb472471412c4b73184fea0\n    Start 14: TestErrorLogger\n1/1 Test #14: TestErrorLogger ..................***Failed    0.00 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.01 sec\n\nThe following tests FAILED:\n\t 14 - TestErrorLogger (Failed)\n"
    },
    "c4dcfef38564e97442fb6c122f5e67c908e0c665___tokenize.cpp": {
        "prefix": "    bool usingMatch(\n        const Token *nameToken,\n        const std::string &scope,\n        Token **tok,\n        const std::string &scope1,\n        const ScopeInfo3 *currentScope,\n        const ScopeInfo3 *memberClassScope)\n    {\n        Token *tok1 = *tok;\n\n        if (tok1 && tok1->str() != nameToken->str())\n            return false;\n\n        // skip this using\n        if (tok1 == nameToken) {\n            *tok = findSemicolon(tok1);\n            return false;\n        }\n\n        // skip other using with this name\n        if (tok1->strAt(-1) == \"using\") {\n            // fixme: this is wrong\n            // skip to end of scope\n            if (currentScope->bodyEnd)\n                *tok = currentScope->bodyEnd->previous();\n            return false;\n        }\n\n        if (Token::Match(tok1->tokAt(-1), \"class|struct|union|enum|namespace\")) {\n            // fixme\n            return false;\n        }\n\n        // get qualification\n        std::string qualification;\n        const Token* tok2 = tok1;\n        std::string::size_type index = scope.size();\n        std::string::size_type new_index = std::string::npos;\n        bool match = true;\n        while (Token::Match(tok2->tokAt(-2), \"%name% ::\") && !tok2->tokAt(-2)->isKeyword()) {\n            std::string last;\n            if (match && !scope1.empty()) {\n                new_index = scope1.rfind(' ', index - 1);\n                if (new_index != std::string::npos)\n                    last = scope1.substr(new_index, index - new_index);\n                else if (!qualification.empty())\n                    last.clear();\n                else\n                    last = scope1;\n            } else\n                match = false;\n            if (match && tok2->strAt(-2) == last)\n                index = new_index;\n            else {\n                if (!qualification.empty())\n                    qualification = \" :: \" + qualification;\n                qualification = tok2->strAt(-2) + qualification;\n            }\n            tok2 = tok2->tokAt(-2);\n        }\n\n        std::string fullScope1 = scope1;\n        if (!scope1.empty() && !qualification.empty())\n            fullScope1 += \" :: \";\n        fullScope1 += qualification;\n\n        if (scope == fullScope1)\n            return true;\n\n        const ScopeInfo3 *scopeInfo = memberClassScope ? memberClassScope : currentScope;\n\n        // check in base types\n",
        "suffix": "            return true;\n\n        // check using namespace\n        const ScopeInfo3 * tempScope = scopeInfo;\n        while (tempScope) {\n            //if (!tempScope->parent->usingNamespaces.empty()) {\n            if (!tempScope->usingNamespaces.empty()) {\n                if (qualification.empty()) {\n                    if (tempScope->usingNamespaces.find(scope) != tempScope->usingNamespaces.end())\n                        return true;\n                } else {\n                    for (const auto &ns : tempScope->usingNamespaces) {\n                        if (scope == ns + \" :: \" + qualification)\n                            return true;\n                    }\n                }\n            }\n            tempScope = tempScope->parent;\n        }\n\n        std::string newScope1 = scope1;\n\n        // scopes didn't match so try higher scopes\n        index = newScope1.size();\n        while (!newScope1.empty()) {\n            std::string::size_type separator = newScope1.rfind(\" :: \", index - 1);\n            if (separator != std::string::npos)\n                newScope1 = newScope1.substr(0, separator);\n            else\n                newScope1.clear();\n\n            std::string newFullScope1 = newScope1;\n            if (!newScope1.empty() && !qualification.empty())\n                newFullScope1 += \" :: \";\n            newFullScope1 += qualification;\n\n            if (scope == newFullScope1)\n                return true;\n        }\n\n        return false;\n    }\n",
        "start": 2061,
        "end": 2175,
        "buggy": "    bool usingMatch(\n        const Token *nameToken,\n        const std::string &scope,\n        Token **tok,\n        const std::string &scope1,\n        const ScopeInfo3 *currentScope,\n        const ScopeInfo3 *memberClassScope)\n    {\n        Token *tok1 = *tok;\n\n        if (tok1 && tok1->str() != nameToken->str())\n            return false;\n\n        // skip this using\n        if (tok1 == nameToken) {\n            *tok = findSemicolon(tok1);\n            return false;\n        }\n\n        // skip other using with this name\n        if (tok1->strAt(-1) == \"using\") {\n            // fixme: this is wrong\n            // skip to end of scope\n            if (currentScope->bodyEnd)\n                *tok = currentScope->bodyEnd->previous();\n            return false;\n        }\n\n        if (Token::Match(tok1->tokAt(-1), \"class|struct|union|enum|namespace\")) {\n            // fixme\n            return false;\n        }\n\n        // get qualification\n        std::string qualification;\n        const Token* tok2 = tok1;\n        std::string::size_type index = scope.size();\n        std::string::size_type new_index = std::string::npos;\n        bool match = true;\n        while (Token::Match(tok2->tokAt(-2), \"%name% ::\") && !tok2->tokAt(-2)->isKeyword()) {\n            std::string last;\n            if (match && !scope1.empty()) {\n                new_index = scope1.rfind(' ', index - 1);\n                if (new_index != std::string::npos)\n                    last = scope1.substr(new_index, index - new_index);\n                else if (!qualification.empty())\n                    last.clear();\n                else\n                    last = scope1;\n            } else\n                match = false;\n            if (match && tok2->strAt(-2) == last)\n                index = new_index;\n            else {\n                if (!qualification.empty())\n                    qualification = \" :: \" + qualification;\n                qualification = tok2->strAt(-2) + qualification;\n            }\n            tok2 = tok2->tokAt(-2);\n        }\n\n        std::string fullScope1 = scope1;\n        if (!scope1.empty() && !qualification.empty())\n            fullScope1 += \" :: \";\n        fullScope1 += qualification;\n\n        if (scope == fullScope1)\n            return true;\n\n        const ScopeInfo3 *scopeInfo = memberClassScope ? memberClassScope : currentScope;\n\n        // check in base types\n        if (scopeInfo->findTypeInBase(scope))\n            return true;\n\n        // check using namespace\n        const ScopeInfo3 * tempScope = scopeInfo;\n        while (tempScope) {\n            //if (!tempScope->parent->usingNamespaces.empty()) {\n            if (!tempScope->usingNamespaces.empty()) {\n                if (qualification.empty()) {\n                    if (tempScope->usingNamespaces.find(scope) != tempScope->usingNamespaces.end())\n                        return true;\n                } else {\n                    for (const auto &ns : tempScope->usingNamespaces) {\n                        if (scope == ns + \" :: \" + qualification)\n                            return true;\n                    }\n                }\n            }\n            tempScope = tempScope->parent;\n        }\n\n        std::string newScope1 = scope1;\n\n        // scopes didn't match so try higher scopes\n        index = newScope1.size();\n        while (!newScope1.empty()) {\n            std::string::size_type separator = newScope1.rfind(\" :: \", index - 1);\n            if (separator != std::string::npos)\n                newScope1 = newScope1.substr(0, separator);\n            else\n                newScope1.clear();\n\n            std::string newFullScope1 = newScope1;\n            if (!newScope1.empty() && !qualification.empty())\n                newFullScope1 += \" :: \";\n            newFullScope1 += qualification;\n\n            if (scope == newFullScope1)\n                return true;\n        }\n\n        return false;\n    }\n",
        "fix": null,
        "buggy_hunk_masked": "        if (scopeInfo->findTypeInBase(scope))\n",
        "src_path": "c4dcfef38564e97442fb6c122f5e67c908e0c665___tokenize.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/c4dcfef38564e97442fb6c122f5e67c908e0c665",
        "commit_msg": "Fix #10260 debug: Executable scope 'x' with unknown function. (#3974)\n\n* Fix #10174 debug: Executable scope 'x' with unknown function\r\n\r\n* Format\r\n\r\n* Add test for #10198\r\n\r\n* Fix #10260 debug: Executable scope 'x' with unknown function.",
        "test_func_diff": [
            {
                "fn": "test/testsymboldatabase.cpp",
                "patch": "@@ -4919,6 +4919,29 @@ class TestSymbolDatabase : public TestFixture {\n             ASSERT(function && function->token->str() == \"A\");\n             ASSERT(function->hasBody());\n         }\n+        {\n+            GET_SYMBOL_DB(\"namespace N {\\n\" // #10260\n+                          \"    namespace O {\\n\"\n+                          \"        struct B;\\n\"\n+                          \"    }\\n\"\n+                          \"}\\n\"\n+                          \"struct I {\\n\"\n+                          \"    using B = N::O::B;\\n\"\n+                          \"};\\n\"\n+                          \"struct A : I {\\n\"\n+                          \"    void f(B*);\\n\"\n+                          \"};\\n\"\n+                          \"void A::f(N::O::B*) {}\\n\");\n+            ASSERT(db);\n+            ASSERT_EQUALS(1, db->functionScopes.size());\n+            auto it = std::find_if(db->scopeList.begin(), db->scopeList.end(), [](const Scope& s) {\n+                return s.className == \"A\";\n+            });\n+            ASSERT(it != db->scopeList.end());\n+            const Function* function = findFunctionByName(\"f\", &*it);\n+            ASSERT(function && function->token->str() == \"f\");\n+            ASSERT(function->hasBody());\n+        }\n     }\n \n     void createSymbolDatabaseFindAllScopes1() {"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_c4dcfef38564e97442fb6c122f5e67c908e0c665/build_c4dcfef38564e97442fb6c122f5e67c908e0c665\nTest project /out/danmar___cppcheck/git_repo_dir_c4dcfef38564e97442fb6c122f5e67c908e0c665/build_c4dcfef38564e97442fb6c122f5e67c908e0c665\n    Start 48: TestSymbolDatabase\n1/1 Test #48: TestSymbolDatabase ...............***Failed    1.50 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.53 sec\n\nThe following tests FAILED:\n\t 48 - TestSymbolDatabase (Failed)\n"
    },
    "81a1d744c6e9d13f2fac894c380caafb270741df___checkbufferoverrun.cpp": {
        "prefix": "void CheckBufferOverrun::arrayIndex()\n{\n    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {\n        if (tok->str() != \"[\")\n            continue;\n        const Token *array = tok->astOperand1();\n        while (Token::Match(array, \".|::\"))\n            array = array->astOperand2();\n        if (!array|| !array->variable() || array->variable()->nameToken() == array)\n            continue;\n        if (!array->scope()->isExecutable()) {\n            // LHS in non-executable scope => This is just a definition\n            const Token *parent = tok;\n            while (parent && !Token::simpleMatch(parent->astParent(), \"=\"))\n                parent = parent->astParent();\n",
        "suffix": "                continue;\n        }\n\n        const Token *indexToken = tok->astOperand2();\n        if (!indexToken)\n            continue;\n\n        const Token *stringLiteral = nullptr;\n\n        if (!array->variable()->isArray() && array->variable()->dimensions().empty()) {\n            stringLiteral = array->getValueTokenMinStrSize();\n            if (!stringLiteral)\n                continue;\n        }\n\n        const MathLib::bigint dim = stringLiteral ? Token::getStrSize(stringLiteral) : array->variable()->dimensions()[0].num;\n\n        // Positive index\n        if (stringLiteral || dim > 1) { // TODO check arrays with dim 1 also\n            for (int cond = 0; cond < 2; cond++) {\n                const ValueFlow::Value *value = indexToken->getMaxValue(cond == 1);\n                if (!value)\n                    continue;\n                const MathLib::bigint index = value->intvalue;\n                if (index < dim)\n                    continue;\n                if (index == dim) {\n                    const Token *parent = tok;\n                    while (Token::simpleMatch(parent, \"[\"))\n                        parent = parent->astParent();\n                    if (parent->isUnaryOp(\"&\"))\n                        continue;\n                }\n                arrayIndexError(tok, array->variable(), value);\n            }\n        }\n\n        // Negative index\n        const ValueFlow::Value *negativeValue = indexToken->getValueLE(-1, mSettings);\n        if (negativeValue) {\n            negativeIndexError(tok, array->variable(), negativeValue);\n        }\n    }\n}\n",
        "start": 176,
        "end": 235,
        "buggy": "void CheckBufferOverrun::arrayIndex()\n{\n    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {\n        if (tok->str() != \"[\")\n            continue;\n        const Token *array = tok->astOperand1();\n        while (Token::Match(array, \".|::\"))\n            array = array->astOperand2();\n        if (!array|| !array->variable() || array->variable()->nameToken() == array)\n            continue;\n        if (!array->scope()->isExecutable()) {\n            // LHS in non-executable scope => This is just a definition\n            const Token *parent = tok;\n            while (parent && !Token::simpleMatch(parent->astParent(), \"=\"))\n                parent = parent->astParent();\n            if (parent && parent == parent->astParent()->astOperand1())\n                continue;\n        }\n\n        const Token *indexToken = tok->astOperand2();\n        if (!indexToken)\n            continue;\n\n        const Token *stringLiteral = nullptr;\n\n        if (!array->variable()->isArray() && array->variable()->dimensions().empty()) {\n            stringLiteral = array->getValueTokenMinStrSize();\n            if (!stringLiteral)\n                continue;\n        }\n\n        const MathLib::bigint dim = stringLiteral ? Token::getStrSize(stringLiteral) : array->variable()->dimensions()[0].num;\n\n        // Positive index\n        if (stringLiteral || dim > 1) { // TODO check arrays with dim 1 also\n            for (int cond = 0; cond < 2; cond++) {\n                const ValueFlow::Value *value = indexToken->getMaxValue(cond == 1);\n                if (!value)\n                    continue;\n                const MathLib::bigint index = value->intvalue;\n                if (index < dim)\n                    continue;\n                if (index == dim) {\n                    const Token *parent = tok;\n                    while (Token::simpleMatch(parent, \"[\"))\n                        parent = parent->astParent();\n                    if (parent->isUnaryOp(\"&\"))\n                        continue;\n                }\n                arrayIndexError(tok, array->variable(), value);\n            }\n        }\n\n        // Negative index\n        const ValueFlow::Value *negativeValue = indexToken->getValueLE(-1, mSettings);\n        if (negativeValue) {\n            negativeIndexError(tok, array->variable(), negativeValue);\n        }\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            if (parent && parent == parent->astParent()->astOperand1())\n",
        "src_path": "81a1d744c6e9d13f2fac894c380caafb270741df___checkbufferoverrun.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/81a1d744c6e9d13f2fac894c380caafb270741df",
        "commit_msg": "CheckBufferOverrun: fix FP for array definition of static class member",
        "test_func_diff": [
            {
                "fn": "test/testbufferoverrun.cpp",
                "patch": "@@ -2138,11 +2138,15 @@ class TestBufferOverrun : public TestFixture {\n         ASSERT_EQUALS(\"\", errout.str());\n \n         check(\"class X { static const int x[100]; };\\n\" // #6070\n-              \"const int X::x[100] = {0};\", false, \"test.cpp\");\n+              \"const int X::x[100] = {0};\");\n         ASSERT_EQUALS(\"\", errout.str());\n \n         check(\"namespace { class X { static const int x[100]; };\\n\" // #6232\n-              \"const int X::x[100] = {0}; }\", false, \"test.cpp\");\n+              \"const int X::x[100] = {0}; }\");\n+        ASSERT_EQUALS(\"\", errout.str());\n+\n+        check(\"class ActorSprite { static ImageSet * targetCursorImages[2][10]; };\\n\"\n+              \"ImageSet *ActorSprite::targetCursorImages[2][10];\\n\");\n         ASSERT_EQUALS(\"\", errout.str());\n \n     }"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_81a1d744c6e9d13f2fac894c380caafb270741df/build_81a1d744c6e9d13f2fac894c380caafb270741df\nTest project /out/danmar___cppcheck/git_repo_dir_81a1d744c6e9d13f2fac894c380caafb270741df/build_81a1d744c6e9d13f2fac894c380caafb270741df\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   23.14 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  23.14 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n"
    },
    "4779f0e1725c5807b329798e12dbeaddbf568b65___templatesimplifier.cpp": {
        "prefix": "std::string TemplateSimplifier::getNewName(\n    Token *tok2,\n    std::list<std::string> &typeStringsUsedInTemplateInstantiation)\n{\n    std::string typeForNewName;\n    unsigned int indentlevel = 0;\n    const Token * endToken = tok2->next()->findClosingBracket();\n    for (Token *tok3 = tok2->tokAt(2); tok3 != endToken && (indentlevel > 0 || tok3->str() != \">\"); tok3 = tok3->next()) {\n        // #2721 - unhandled [ => bail out\n        if (tok3->str() == \"[\" && !Token::Match(tok3->next(), \"%num%| ]\")) {\n            typeForNewName.clear();\n            break;\n        }\n        if (!tok3->next()) {\n            typeForNewName.clear();\n            break;\n        }\n        if (Token::Match(tok3->tokAt(-2), \"<|,|:: %name% <\") && (tok3->strAt(1) == \">\" || templateParameters(tok3)))\n            ++indentlevel;\n        else if (indentlevel > 0 && Token::Match(tok3, \"> ,|>|::\"))\n            --indentlevel;\n",
        "suffix": "            mTypesUsedInTemplateInstantiation.emplace_back(tok3, \"\");\n        }\n        if (Token::Match(tok3, \"(|[\"))\n            ++indentlevel;\n        else if (Token::Match(tok3, \")|]\"))\n            --indentlevel;\n        const bool constconst = tok3->str() == \"const\" && tok3->strAt(1) == \"const\";\n        if (!constconst) {\n            if (tok3->isUnsigned())\n                typeStringsUsedInTemplateInstantiation.emplace_back(\"unsigned\");\n            else if (tok3->isSigned())\n                typeStringsUsedInTemplateInstantiation.emplace_back(\"signed\");\n            if (tok3->isLong())\n                typeStringsUsedInTemplateInstantiation.emplace_back(\"long\");\n            typeStringsUsedInTemplateInstantiation.push_back(tok3->str());\n        }\n        // add additional type information\n        if (!constconst && !Token::Match(tok3, \"class|struct|enum\")) {\n            if (!typeForNewName.empty())\n                typeForNewName += ' ';\n            if (tok3->isUnsigned())\n                typeForNewName += \"unsigned \";\n            else if (tok3->isSigned())\n                typeForNewName += \"signed \";\n            if (tok3->isLong()) {\n                typeForNewName += \"long \";\n            }\n            typeForNewName += tok3->str();\n        }\n    }\n\n    return typeForNewName;\n}\n",
        "start": 2948,
        "end": 3002,
        "buggy": "std::string TemplateSimplifier::getNewName(\n    Token *tok2,\n    std::list<std::string> &typeStringsUsedInTemplateInstantiation)\n{\n    std::string typeForNewName;\n    unsigned int indentlevel = 0;\n    const Token * endToken = tok2->next()->findClosingBracket();\n    for (Token *tok3 = tok2->tokAt(2); tok3 != endToken && (indentlevel > 0 || tok3->str() != \">\"); tok3 = tok3->next()) {\n        // #2721 - unhandled [ => bail out\n        if (tok3->str() == \"[\" && !Token::Match(tok3->next(), \"%num%| ]\")) {\n            typeForNewName.clear();\n            break;\n        }\n        if (!tok3->next()) {\n            typeForNewName.clear();\n            break;\n        }\n        if (Token::Match(tok3->tokAt(-2), \"<|,|:: %name% <\") && (tok3->strAt(1) == \">\" || templateParameters(tok3)))\n            ++indentlevel;\n        else if (indentlevel > 0 && Token::Match(tok3, \"> ,|>|::\"))\n            --indentlevel;\n        if (indentlevel == 0 && Token::Match(tok3->previous(), \"[<,]\")) {\n            mTypesUsedInTemplateInstantiation.emplace_back(tok3, \"\");\n        }\n        if (Token::Match(tok3, \"(|[\"))\n            ++indentlevel;\n        else if (Token::Match(tok3, \")|]\"))\n            --indentlevel;\n        const bool constconst = tok3->str() == \"const\" && tok3->strAt(1) == \"const\";\n        if (!constconst) {\n            if (tok3->isUnsigned())\n                typeStringsUsedInTemplateInstantiation.emplace_back(\"unsigned\");\n            else if (tok3->isSigned())\n                typeStringsUsedInTemplateInstantiation.emplace_back(\"signed\");\n            if (tok3->isLong())\n                typeStringsUsedInTemplateInstantiation.emplace_back(\"long\");\n            typeStringsUsedInTemplateInstantiation.push_back(tok3->str());\n        }\n        // add additional type information\n        if (!constconst && !Token::Match(tok3, \"class|struct|enum\")) {\n            if (!typeForNewName.empty())\n                typeForNewName += ' ';\n            if (tok3->isUnsigned())\n                typeForNewName += \"unsigned \";\n            else if (tok3->isSigned())\n                typeForNewName += \"signed \";\n            if (tok3->isLong()) {\n                typeForNewName += \"long \";\n            }\n            typeForNewName += tok3->str();\n        }\n    }\n\n    return typeForNewName;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        if (indentlevel == 0 && Token::Match(tok3->previous(), \"[<,]\")) {\n",
        "src_path": "4779f0e1725c5807b329798e12dbeaddbf568b65___templatesimplifier.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/4779f0e1725c5807b329798e12dbeaddbf568b65",
        "commit_msg": "TemplateSimplifier: Fixed instantiation when template parameters are A<..>, B<..>",
        "test_func_diff": [
            {
                "fn": "test/testsimplifytemplate.cpp",
                "patch": "@@ -220,6 +220,7 @@ class TestSimplifyTemplate : public TestFixture {\n         TEST_CASE(template174); // #10506 hang\n         TEST_CASE(template175); // #10908\n         TEST_CASE(template176); // #11146\n+        TEST_CASE(template177);\n         TEST_CASE(template_specialization_1);  // #7868 - template specialization template <typename T> struct S<C<T>> {..};\n         TEST_CASE(template_specialization_2);  // #7868 - template specialization template <typename T> struct S<C<T>> {..};\n         TEST_CASE(template_enum);  // #6299 Syntax error in complex enum declaration (including template)\n@@ -4491,6 +4492,16 @@ class TestSimplifyTemplate : public TestFixture {\n         ASSERT_EQUALS(exp, tok(code));\n     }\n \n+    void template177() {\n+        const char code[] = \"template <typename Encoding, typename Allocator>\\n\"\n+                            \"class C { xyz<Encoding, Allocator> x; };\\n\"\n+                            \"C<UTF8<>, MemoryPoolAllocator<>> c;\";\n+        const char exp[] = \"class C<UTF8<>,MemoryPoolAllocator<>> ; \"\n+                           \"C<UTF8<>,MemoryPoolAllocator<>> c ; \"\n+                           \"class C<UTF8<>,MemoryPoolAllocator<>> { xyz < UTF8 < > , MemoryPoolAllocator < > > x ; } ;\";\n+        ASSERT_EQUALS(exp, tok(code));\n+    }\n+\n     void template_specialization_1() {  // #7868 - template specialization template <typename T> struct S<C<T>> {..};\n         const char code[] = \"template <typename T> struct C {};\\n\"\n                             \"template <typename T> struct S {a};\\n\""
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_4779f0e1725c5807b329798e12dbeaddbf568b65/build_4779f0e1725c5807b329798e12dbeaddbf568b65\nTest project /out/danmar___cppcheck/git_repo_dir_4779f0e1725c5807b329798e12dbeaddbf568b65/build_4779f0e1725c5807b329798e12dbeaddbf568b65\n    Start 55: TestThreadExecutor\n1/3 Test #55: TestThreadExecutor ...............   Passed    7.45 sec\n    Start 44: TestProcessExecutor\n2/3 Test #44: TestProcessExecutor ..............   Passed    6.89 sec\n    Start 45: TestSimplifyTemplate\n3/3 Test #45: TestSimplifyTemplate .............***Failed    0.93 sec\n\n67% tests passed, 1 tests failed out of 3\n\nTotal Test time (real) =  15.28 sec\n\nThe following tests FAILED:\n\t 45 - TestSimplifyTemplate (Failed)\n"
    },
    "f1169bf2b43fc1beab0da21e430adaa0a7a9eb49___reverseanalyzer.cpp": {
        "prefix": "    void traverse(Token* start) {\n        for (Token* tok = start->previous(); tok; tok = tok->previous()) {\n            if (tok == start || (tok->str() == \"{\" && (tok->scope()->type == Scope::ScopeType::eFunction ||\n                                 tok->scope()->type == Scope::ScopeType::eLambda))) {\n                break;\n            }\n            if (Token::Match(tok, \"return|break|continue\"))\n                break;\n            if (Token::Match(tok, \"%name% :\"))\n                break;\n            // Evaluate LHS of assignment before RHS\n            if (Token* assignTok = assignExpr(tok)) {\n                // If assignTok has broken ast then stop\n                if (!assignTok->astOperand1() || !assignTok->astOperand2())\n                    break;\n                Token* assignTop = assignTok;\n                bool continueB = true;\n                while (assignTop->isAssignmentOp()) {\n                    if (!Token::Match(assignTop->astOperand1(), \"%assign%\")) {\n                        continueB &= updateRecursive(assignTop->astOperand1());\n                    }\n                    if (!assignTop->astParent())\n                        break;\n                    assignTop = assignTop->astParent();\n                }\n                // Is assignment in dead code\n                if (Token* parent = isDeadCode(assignTok)) {\n                    tok = parent;\n                    continue;\n                }\n                // Simple assign\n                if (assignTok->astParent() == assignTop || assignTok == assignTop) {\n                    Analyzer::Action rhsAction =\n                        analyzer->analyze(assignTok->astOperand2(), Analyzer::Direction::Reverse);\n                    Analyzer::Action lhsAction =\n                        analyzer->analyze(assignTok->astOperand1(), Analyzer::Direction::Reverse);\n                    // Assignment from\n                    if (rhsAction.isRead()) {\n                        const std::string info = \"Assignment from '\" + assignTok->expressionString() + \"'\";\n                        ValuePtr<Analyzer> a = analyzer->reanalyze(assignTok->astOperand1(), info);\n                        if (a) {\n                            valueFlowGenericForward(nextAfterAstRightmostLeaf(assignTok->astOperand2()),\n                                                    assignTok->astOperand2()->scope()->bodyEnd,\n                                                    a,\n                                                    settings);\n                        }\n                        // Assignment to\n                    } else if (lhsAction.matches() && !assignTok->astOperand2()->hasKnownValue()) {\n                        const std::string info = \"Assignment to '\" + assignTok->expressionString() + \"'\";\n                        ValuePtr<Analyzer> a = analyzer->reanalyze(assignTok->astOperand2(), info);\n                        if (a) {\n                            valueFlowGenericForward(nextAfterAstRightmostLeaf(assignTok->astOperand2()),\n                                                    assignTok->astOperand2()->scope()->bodyEnd,\n                                                    a,\n                                                    settings);\n                            valueFlowGenericReverse(assignTok->astOperand1()->previous(), a, settings);\n                        }\n                    }\n                }\n                if (!continueB)\n                    break;\n",
        "suffix": "                tok = previousBeforeAstLeftmostLeaf(assignTop)->next();\n                continue;\n            }\n            if (tok->str() == \"}\") {\n                Token* condTok = getCondTokFromEnd(tok);\n                if (!condTok)\n                    break;\n                Analyzer::Action condAction = analyzeRecursive(condTok);\n                const bool inLoop = condTok->astTop() && Token::Match(condTok->astTop()->previous(), \"for|while (\");\n                // Evaluate condition of for and while loops first\n                if (inLoop) {\n                    if (condAction.isModified())\n                        break;\n                    valueFlowGenericForward(condTok, analyzer, settings);\n                }\n                Token* thenEnd;\n                const bool hasElse = Token::simpleMatch(tok->link()->tokAt(-2), \"} else {\");\n                if (hasElse) {\n                    thenEnd = tok->link()->tokAt(-2);\n                } else {\n                    thenEnd = tok;\n                }\n\n                Analyzer::Action thenAction = analyzeRange(thenEnd->link(), thenEnd);\n                Analyzer::Action elseAction = Analyzer::Action::None;\n                if (hasElse) {\n                    elseAction = analyzeRange(tok->link(), tok);\n                }\n                if (thenAction.isModified() && inLoop)\n                    break;\n                else if (thenAction.isModified() && !elseAction.isModified())\n                    analyzer->assume(condTok, hasElse, condTok);\n                else if (elseAction.isModified() && !thenAction.isModified())\n                    analyzer->assume(condTok, !hasElse, condTok);\n                // Bail if one of the branches are read to avoid FPs due to over constraints\n                else if (thenAction.isIdempotent() || elseAction.isIdempotent() || thenAction.isRead() ||\n                         elseAction.isRead())\n                    break;\n                if (thenAction.isInvalid() || elseAction.isInvalid())\n                    break;\n\n                if (!thenAction.isModified() && !elseAction.isModified())\n                    valueFlowGenericForward(condTok, analyzer, settings);\n                else if (condAction.isRead())\n                    break;\n                // If the condition modifies the variable then bail\n                if (condAction.isModified())\n                    break;\n                tok = condTok->astTop()->previous();\n                continue;\n            }\n            if (tok->str() == \"{\") {\n                if (tok->previous() &&\n                    (Token::simpleMatch(tok->previous(), \"do\") ||\n                     (tok->strAt(-1) == \")\" && Token::Match(tok->linkAt(-1)->previous(), \"for|while (\")))) {\n                    Analyzer::Action action = analyzeRange(tok, tok->link());\n                    if (action.isModified())\n                        break;\n                }\n                if (Token::simpleMatch(tok->tokAt(-2), \"} else {\"))\n                    tok = tok->linkAt(-2);\n                if (Token::simpleMatch(tok->previous(), \") {\"))\n                    tok = tok->previous()->link();\n                continue;\n            }\n            if (Token* next = isUnevaluated(tok)) {\n                tok = next;\n                continue;\n            }\n            if (Token* parent = isDeadCode(tok)) {\n                tok = parent;\n                continue;\n            }\n            if (!update(tok))\n                break;\n        }\n    }\n",
        "start": 119,
        "end": 257,
        "buggy": "    void traverse(Token* start) {\n        for (Token* tok = start->previous(); tok; tok = tok->previous()) {\n            if (tok == start || (tok->str() == \"{\" && (tok->scope()->type == Scope::ScopeType::eFunction ||\n                                 tok->scope()->type == Scope::ScopeType::eLambda))) {\n                break;\n            }\n            if (Token::Match(tok, \"return|break|continue\"))\n                break;\n            if (Token::Match(tok, \"%name% :\"))\n                break;\n            // Evaluate LHS of assignment before RHS\n            if (Token* assignTok = assignExpr(tok)) {\n                // If assignTok has broken ast then stop\n                if (!assignTok->astOperand1() || !assignTok->astOperand2())\n                    break;\n                Token* assignTop = assignTok;\n                bool continueB = true;\n                while (assignTop->isAssignmentOp()) {\n                    if (!Token::Match(assignTop->astOperand1(), \"%assign%\")) {\n                        continueB &= updateRecursive(assignTop->astOperand1());\n                    }\n                    if (!assignTop->astParent())\n                        break;\n                    assignTop = assignTop->astParent();\n                }\n                // Is assignment in dead code\n                if (Token* parent = isDeadCode(assignTok)) {\n                    tok = parent;\n                    continue;\n                }\n                // Simple assign\n                if (assignTok->astParent() == assignTop || assignTok == assignTop) {\n                    Analyzer::Action rhsAction =\n                        analyzer->analyze(assignTok->astOperand2(), Analyzer::Direction::Reverse);\n                    Analyzer::Action lhsAction =\n                        analyzer->analyze(assignTok->astOperand1(), Analyzer::Direction::Reverse);\n                    // Assignment from\n                    if (rhsAction.isRead()) {\n                        const std::string info = \"Assignment from '\" + assignTok->expressionString() + \"'\";\n                        ValuePtr<Analyzer> a = analyzer->reanalyze(assignTok->astOperand1(), info);\n                        if (a) {\n                            valueFlowGenericForward(nextAfterAstRightmostLeaf(assignTok->astOperand2()),\n                                                    assignTok->astOperand2()->scope()->bodyEnd,\n                                                    a,\n                                                    settings);\n                        }\n                        // Assignment to\n                    } else if (lhsAction.matches() && !assignTok->astOperand2()->hasKnownValue()) {\n                        const std::string info = \"Assignment to '\" + assignTok->expressionString() + \"'\";\n                        ValuePtr<Analyzer> a = analyzer->reanalyze(assignTok->astOperand2(), info);\n                        if (a) {\n                            valueFlowGenericForward(nextAfterAstRightmostLeaf(assignTok->astOperand2()),\n                                                    assignTok->astOperand2()->scope()->bodyEnd,\n                                                    a,\n                                                    settings);\n                            valueFlowGenericReverse(assignTok->astOperand1()->previous(), a, settings);\n                        }\n                    }\n                }\n                if (!continueB)\n                    break;\n                valueFlowGenericForward(assignTop->astOperand2(), analyzer, settings);\n                tok = previousBeforeAstLeftmostLeaf(assignTop)->next();\n                continue;\n            }\n            if (tok->str() == \"}\") {\n                Token* condTok = getCondTokFromEnd(tok);\n                if (!condTok)\n                    break;\n                Analyzer::Action condAction = analyzeRecursive(condTok);\n                const bool inLoop = condTok->astTop() && Token::Match(condTok->astTop()->previous(), \"for|while (\");\n                // Evaluate condition of for and while loops first\n                if (inLoop) {\n                    if (condAction.isModified())\n                        break;\n                    valueFlowGenericForward(condTok, analyzer, settings);\n                }\n                Token* thenEnd;\n                const bool hasElse = Token::simpleMatch(tok->link()->tokAt(-2), \"} else {\");\n                if (hasElse) {\n                    thenEnd = tok->link()->tokAt(-2);\n                } else {\n                    thenEnd = tok;\n                }\n\n                Analyzer::Action thenAction = analyzeRange(thenEnd->link(), thenEnd);\n                Analyzer::Action elseAction = Analyzer::Action::None;\n                if (hasElse) {\n                    elseAction = analyzeRange(tok->link(), tok);\n                }\n                if (thenAction.isModified() && inLoop)\n                    break;\n                else if (thenAction.isModified() && !elseAction.isModified())\n                    analyzer->assume(condTok, hasElse, condTok);\n                else if (elseAction.isModified() && !thenAction.isModified())\n                    analyzer->assume(condTok, !hasElse, condTok);\n                // Bail if one of the branches are read to avoid FPs due to over constraints\n                else if (thenAction.isIdempotent() || elseAction.isIdempotent() || thenAction.isRead() ||\n                         elseAction.isRead())\n                    break;\n                if (thenAction.isInvalid() || elseAction.isInvalid())\n                    break;\n\n                if (!thenAction.isModified() && !elseAction.isModified())\n                    valueFlowGenericForward(condTok, analyzer, settings);\n                else if (condAction.isRead())\n                    break;\n                // If the condition modifies the variable then bail\n                if (condAction.isModified())\n                    break;\n                tok = condTok->astTop()->previous();\n                continue;\n            }\n            if (tok->str() == \"{\") {\n                if (tok->previous() &&\n                    (Token::simpleMatch(tok->previous(), \"do\") ||\n                     (tok->strAt(-1) == \")\" && Token::Match(tok->linkAt(-1)->previous(), \"for|while (\")))) {\n                    Analyzer::Action action = analyzeRange(tok, tok->link());\n                    if (action.isModified())\n                        break;\n                }\n                if (Token::simpleMatch(tok->tokAt(-2), \"} else {\"))\n                    tok = tok->linkAt(-2);\n                if (Token::simpleMatch(tok->previous(), \") {\"))\n                    tok = tok->previous()->link();\n                continue;\n            }\n            if (Token* next = isUnevaluated(tok)) {\n                tok = next;\n                continue;\n            }\n            if (Token* parent = isDeadCode(tok)) {\n                tok = parent;\n                continue;\n            }\n            if (!update(tok))\n                break;\n        }\n    }\n",
        "fix": null,
        "buggy_hunk_masked": "                valueFlowGenericForward(assignTop->astOperand2(), analyzer, settings);\n",
        "src_path": "f1169bf2b43fc1beab0da21e430adaa0a7a9eb49___reverseanalyzer.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/f1169bf2b43fc1beab0da21e430adaa0a7a9eb49",
        "commit_msg": "10062: Fix FP due to assignment in reverseanalyzer (#2983)\n\nreverseanalyzer has a special process for assignments, and would not see\r\na stop condition on a rhs of an assignment.",
        "test_func_diff": [
            {
                "fn": "test/testnullpointer.cpp",
                "patch": "@@ -107,6 +107,7 @@ class TestNullPointer : public TestFixture {\n         TEST_CASE(nullpointer64);\n         TEST_CASE(nullpointer65); // #9980\n         TEST_CASE(nullpointer66); // #10024\n+        TEST_CASE(nullpointer67); // #10062\n         TEST_CASE(nullpointer_addressOf); // address of\n         TEST_CASE(nullpointerSwitch); // #2626\n         TEST_CASE(nullpointer_cast); // #4692\n@@ -2050,6 +2051,33 @@ class TestNullPointer : public TestFixture {\n         ASSERT_EQUALS(\"\", errout.str());\n     }\n \n+    void nullpointer67() {\n+        check(\"int result;\\n\"\n+              \"\\n\"\n+              \"int test_b(void) {\\n\"\n+              \"    char **string = NULL;\\n\"\n+              \"\\n\"\n+              \"    /* The bug disappears if \\\"result =\\\" is omitted. */\\n\"\n+              \"    result = some_other_call(&string);\\n\"\n+              \"    if (string && string[0])\\n\"\n+              \"        return 0;\\n\"\n+              \"    return -1;\\n\"\n+              \"}\\n\");\n+        ASSERT_EQUALS(\"\", errout.str());\n+\n+        check(\"int result;\\n\"\n+              \"\\n\"\n+              \"int test_b(void) {\\n\"\n+              \"    char **string = NULL;\\n\"\n+              \"\\n\"\n+              \"    some_other_call(&string);\\n\"\n+              \"    if (string && string[0])\\n\"\n+              \"        return 0;\\n\"\n+              \"    return -1;\\n\"\n+              \"}\\n\");\n+        ASSERT_EQUALS(\"\", errout.str());\n+    }\n+\n     void nullpointer_addressOf() { // address of\n         check(\"void f() {\\n\"\n               \"  struct X *x = 0;\\n\""
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_f1169bf2b43fc1beab0da21e430adaa0a7a9eb49/build_f1169bf2b43fc1beab0da21e430adaa0a7a9eb49\nTest project /out/danmar___cppcheck/git_repo_dir_f1169bf2b43fc1beab0da21e430adaa0a7a9eb49/build_f1169bf2b43fc1beab0da21e430adaa0a7a9eb49\n    Start 31: TestNullPointer\n1/1 Test #31: TestNullPointer ..................***Failed    0.73 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.74 sec\n\nThe following tests FAILED:\n\t 31 - TestNullPointer (Failed)\n"
    },
    "d909ac856569e39cb2f53b158c6246ac82d461b7___valueflow.cpp": {
        "prefix": "static void valueFlowDynamicBufferSize(TokenList *tokenlist, SymbolDatabase *symboldatabase, ErrorLogger *errorLogger, const Settings *settings)\n{\n    for (const Scope *functionScope : symboldatabase->functionScopes) {\n        for (const Token *tok = functionScope->bodyStart; tok != functionScope->bodyEnd; tok = tok->next()) {\n            if (!Token::Match(tok, \"[;{}] %var% =\"))\n                continue;\n\n            if (!tok->next()->variable())\n                continue;\n\n            const Token *rhs = tok->tokAt(2)->astOperand2();\n            while (rhs && rhs->isCast())\n                rhs = rhs->astOperand2() ? rhs->astOperand2() : rhs->astOperand1();\n            if (!rhs)\n                continue;\n\n            if (!Token::Match(rhs->previous(), \"%name% (\"))\n                continue;\n\n            const Library::AllocFunc *allocFunc = settings->library.alloc(rhs->previous());\n            if (!allocFunc || allocFunc->bufferSize == Library::AllocFunc::BufferSize::none)\n                continue;\n\n            const std::vector<const Token *> args = getArguments(rhs->previous());\n\n            const Token * const arg1 = (args.size() >= allocFunc->bufferSizeArg1) ? args[allocFunc->bufferSizeArg1 - 1] : nullptr;\n            const Token * const arg2 = (args.size() >= allocFunc->bufferSizeArg2) ? args[allocFunc->bufferSizeArg2 - 1] : nullptr;\n\n            MathLib::bigint sizeValue = -1;\n            switch (allocFunc->bufferSize) {\n            case Library::AllocFunc::BufferSize::none:\n                break;\n            case Library::AllocFunc::BufferSize::malloc:\n                if (arg1 && arg1->hasKnownIntValue())\n                    sizeValue = arg1->getKnownIntValue();\n                break;\n            case Library::AllocFunc::BufferSize::calloc:\n                if (arg1 && arg2 && arg1->hasKnownIntValue() && arg2->hasKnownIntValue())\n                    sizeValue = arg1->getKnownIntValue() * arg2->getKnownIntValue();\n                break;\n            case Library::AllocFunc::BufferSize::strdup:\n                if (arg1 && arg1->hasKnownValue()) {\n                    const ValueFlow::Value &value = arg1->values().back();\n                    if (value.isTokValue() && value.tokvalue->tokType() == Token::eString)\n",
        "suffix": "                }\n                break;\n            };\n            if (sizeValue < 0)\n                continue;\n\n            ValueFlow::Value value(sizeValue);\n            value.errorPath.emplace_back(tok->tokAt(2), \"Assign \" + tok->strAt(1) + \", buffer with size \" + MathLib::toString(sizeValue));\n            value.valueType = ValueFlow::Value::ValueType::BUFFER_SIZE;\n            value.setKnown();\n            const std::list<ValueFlow::Value> values{value};\n            valueFlowForward(const_cast<Token *>(rhs),\n                             functionScope->bodyEnd,\n                             tok->next()->variable(),\n                             tok->next()->varId(),\n                             values,\n                             true,\n                             false,\n                             tokenlist,\n                             errorLogger,\n                             settings);\n        }\n    }\n}\n",
        "start": 5288,
        "end": 5356,
        "buggy": "static void valueFlowDynamicBufferSize(TokenList *tokenlist, SymbolDatabase *symboldatabase, ErrorLogger *errorLogger, const Settings *settings)\n{\n    for (const Scope *functionScope : symboldatabase->functionScopes) {\n        for (const Token *tok = functionScope->bodyStart; tok != functionScope->bodyEnd; tok = tok->next()) {\n            if (!Token::Match(tok, \"[;{}] %var% =\"))\n                continue;\n\n            if (!tok->next()->variable())\n                continue;\n\n            const Token *rhs = tok->tokAt(2)->astOperand2();\n            while (rhs && rhs->isCast())\n                rhs = rhs->astOperand2() ? rhs->astOperand2() : rhs->astOperand1();\n            if (!rhs)\n                continue;\n\n            if (!Token::Match(rhs->previous(), \"%name% (\"))\n                continue;\n\n            const Library::AllocFunc *allocFunc = settings->library.alloc(rhs->previous());\n            if (!allocFunc || allocFunc->bufferSize == Library::AllocFunc::BufferSize::none)\n                continue;\n\n            const std::vector<const Token *> args = getArguments(rhs->previous());\n\n            const Token * const arg1 = (args.size() >= allocFunc->bufferSizeArg1) ? args[allocFunc->bufferSizeArg1 - 1] : nullptr;\n            const Token * const arg2 = (args.size() >= allocFunc->bufferSizeArg2) ? args[allocFunc->bufferSizeArg2 - 1] : nullptr;\n\n            MathLib::bigint sizeValue = -1;\n            switch (allocFunc->bufferSize) {\n            case Library::AllocFunc::BufferSize::none:\n                break;\n            case Library::AllocFunc::BufferSize::malloc:\n                if (arg1 && arg1->hasKnownIntValue())\n                    sizeValue = arg1->getKnownIntValue();\n                break;\n            case Library::AllocFunc::BufferSize::calloc:\n                if (arg1 && arg2 && arg1->hasKnownIntValue() && arg2->hasKnownIntValue())\n                    sizeValue = arg1->getKnownIntValue() * arg2->getKnownIntValue();\n                break;\n            case Library::AllocFunc::BufferSize::strdup:\n                if (arg1 && arg1->hasKnownValue()) {\n                    const ValueFlow::Value &value = arg1->values().back();\n                    if (value.isTokValue() && value.tokvalue->tokType() == Token::eString)\n                        sizeValue = Token::getStrLength(value.tokvalue);\n                }\n                break;\n            };\n            if (sizeValue < 0)\n                continue;\n\n            ValueFlow::Value value(sizeValue);\n            value.errorPath.emplace_back(tok->tokAt(2), \"Assign \" + tok->strAt(1) + \", buffer with size \" + MathLib::toString(sizeValue));\n            value.valueType = ValueFlow::Value::ValueType::BUFFER_SIZE;\n            value.setKnown();\n            const std::list<ValueFlow::Value> values{value};\n            valueFlowForward(const_cast<Token *>(rhs),\n                             functionScope->bodyEnd,\n                             tok->next()->variable(),\n                             tok->next()->varId(),\n                             values,\n                             true,\n                             false,\n                             tokenlist,\n                             errorLogger,\n                             settings);\n        }\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                        sizeValue = Token::getStrLength(value.tokvalue);\n",
        "src_path": "d909ac856569e39cb2f53b158c6246ac82d461b7___valueflow.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/d909ac856569e39cb2f53b158c6246ac82d461b7",
        "commit_msg": "Bugfix buffer size for strdup like functions (#1893)\n\nstrdup() allocates the string length plus one for a terminating null\r\ncharacter. Add one to compensate for this.\r\n\r\nFixes false positive buffer out of bounds on code like this:\r\n\r\n\tvoid f() {\r\n\t\tconst char *a = \"abcd\";\r\n\t\tchar * b = strdup(a);\r\n\t\tprintf(\"%c\", b[4]); // prints the terminating null character\r\n\t\tfree(b);\r\n\t}\r\n\r\nAlso, add a testcase for valueFlowDynamicBufferSize() and add tests for\r\nstrdup(), malloc() and calloc().",
        "test_func_diff": [
            {
                "fn": "test/testvalueflow.cpp",
                "patch": "@@ -117,6 +117,8 @@ class TestValueFlow : public TestFixture {\n         TEST_CASE(valueFlowTerminatingCond);\n \n         TEST_CASE(valueFlowContainerSize);\n+\n+        TEST_CASE(valueFlowDynamicBufferSize);\n     }\n \n     static bool isNotTokValue(const ValueFlow::Value &val) {\n@@ -223,6 +225,24 @@ class TestValueFlow : public TestFixture {\n         return false;\n     }\n \n+    bool testValueOfX(const char code[], unsigned int linenr, int value, ValueFlow::Value::ValueType type) {\n+        // Tokenize..\n+        Tokenizer tokenizer(&settings, this);\n+        std::istringstream istr(code);\n+        tokenizer.tokenize(istr, \"test.cpp\");\n+\n+        for (const Token *tok = tokenizer.tokens(); tok; tok = tok->next()) {\n+            if (tok->str() == \"x\" && tok->linenr() == linenr) {\n+                for (const ValueFlow::Value &v : tok->values()) {\n+                    if (v.valueType == type && v.intvalue == value)\n+                        return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n     bool testValueOfX(const char code[], unsigned int linenr, ValueFlow::Value::MoveKind moveKind) {\n         // Tokenize..\n         Tokenizer tokenizer(&settings, this);\n@@ -3819,6 +3839,32 @@ class TestValueFlow : public TestFixture {\n                \"}\";\n         ASSERT_EQUALS(\"\", isKnownContainerSizeValue(tokenValues(code, \"+\"), 8));\n     }\n+\n+    void valueFlowDynamicBufferSize() {\n+        const char *code;\n+\n+        LOAD_LIB_2(settings.library, \"std.cfg\");\n+        LOAD_LIB_2(settings.library, \"posix.cfg\");\n+\n+        code = \"void* f() {\\n\"\n+               \"  void* x = malloc(10);\\n\"\n+               \"  return x;\\n\"\n+               \"}\";\n+        ASSERT_EQUALS(true, testValueOfX(code, 3U, 10,  ValueFlow::Value::BUFFER_SIZE));\n+\n+        code = \"void* f() {\\n\"\n+               \"  void* x = calloc(4, 5);\\n\"\n+               \"  return x;\\n\"\n+               \"}\";\n+        ASSERT_EQUALS(true, testValueOfX(code, 3U, 20,  ValueFlow::Value::BUFFER_SIZE));\n+\n+        code = \"void* f() {\\n\"\n+               \"  const char* y = \\\"abcd\\\";\\n\"\n+               \"  const char* x = strdup(y);\\n\"\n+               \"  return x;\\n\"\n+               \"}\";\n+        ASSERT_EQUALS(true, testValueOfX(code, 4U, 5,  ValueFlow::Value::BUFFER_SIZE));\n+    }\n };\n \n REGISTER_TEST(TestValueFlow)"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_d909ac856569e39cb2f53b158c6246ac82d461b7/build_d909ac856569e39cb2f53b158c6246ac82d461b7\nTest project /out/danmar___cppcheck/git_repo_dir_d909ac856569e39cb2f53b158c6246ac82d461b7/build_d909ac856569e39cb2f53b158c6246ac82d461b7\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   27.64 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  27.65 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n"
    },
    "272760f9cac187bd16ab4a596a0cab870ceb42be___checkclass.cpp": {
        "prefix": "void CheckClass::checkExplicitConstructors()\n{\n    if (!mSettings->isEnabled(Settings::STYLE))\n        return;\n\n    for (const Scope * scope : mSymbolDatabase->classAndStructScopes) {\n        // Do not perform check, if the class/struct has not any constructors\n        if (scope->numConstructors == 0)\n            continue;\n\n        // Is class abstract? Maybe this test is over-simplification, but it will suffice for simple cases,\n        // and it will avoid false positives.\n        bool isAbstractClass = false;\n        for (const Function &func : scope->functionList) {\n            if (func.isPure()) {\n                isAbstractClass = true;\n                break;\n            }\n        }\n\n        // Abstract classes can't be instantiated. But if there is C++11\n        // \"misuse\" by derived classes then these constructors must be explicit.\n        if (isAbstractClass && mSettings->standards.cpp != Standards::CPP11)\n            continue;\n\n        for (const Function &func : scope->functionList) {\n\n            // We are looking for constructors, which are meeting following criteria:\n            //  1) Constructor is declared with a single parameter\n            //  2) Constructor is not declared as explicit\n            //  3) It is not a copy/move constructor of non-abstract class\n            //  4) Constructor is not marked as delete (programmer can mark the default constructor as deleted, which is ok)\n            if (!func.isConstructor() || func.isDelete() || (!func.hasBody() && func.access == Private))\n                continue;\n\n            if (!func.isExplicit() &&\n",
        "suffix": "                func.type != Function::eCopyConstructor &&\n                func.type != Function::eMoveConstructor) {\n                noExplicitConstructorError(func.tokenDef, scope->className, scope->type == Scope::eStruct);\n            }\n        }\n    }\n}\n",
        "start": 240,
        "end": 283,
        "buggy": "void CheckClass::checkExplicitConstructors()\n{\n    if (!mSettings->isEnabled(Settings::STYLE))\n        return;\n\n    for (const Scope * scope : mSymbolDatabase->classAndStructScopes) {\n        // Do not perform check, if the class/struct has not any constructors\n        if (scope->numConstructors == 0)\n            continue;\n\n        // Is class abstract? Maybe this test is over-simplification, but it will suffice for simple cases,\n        // and it will avoid false positives.\n        bool isAbstractClass = false;\n        for (const Function &func : scope->functionList) {\n            if (func.isPure()) {\n                isAbstractClass = true;\n                break;\n            }\n        }\n\n        // Abstract classes can't be instantiated. But if there is C++11\n        // \"misuse\" by derived classes then these constructors must be explicit.\n        if (isAbstractClass && mSettings->standards.cpp != Standards::CPP11)\n            continue;\n\n        for (const Function &func : scope->functionList) {\n\n            // We are looking for constructors, which are meeting following criteria:\n            //  1) Constructor is declared with a single parameter\n            //  2) Constructor is not declared as explicit\n            //  3) It is not a copy/move constructor of non-abstract class\n            //  4) Constructor is not marked as delete (programmer can mark the default constructor as deleted, which is ok)\n            if (!func.isConstructor() || func.isDelete() || (!func.hasBody() && func.access == Private))\n                continue;\n\n            if (!func.isExplicit() &&\n                func.argCount() == 1 &&\n                func.type != Function::eCopyConstructor &&\n                func.type != Function::eMoveConstructor) {\n                noExplicitConstructorError(func.tokenDef, scope->className, scope->type == Scope::eStruct);\n            }\n        }\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                func.argCount() == 1 &&\n",
        "src_path": "272760f9cac187bd16ab4a596a0cab870ceb42be___checkclass.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/272760f9cac187bd16ab4a596a0cab870ceb42be",
        "commit_msg": "Fix explicit constructor with default arguments check bug\n\nBefore this fix, the code:\n```\nclass A {\n    A(int, int x=3){\n        x;\n    }\n};\n```\nWas considered OK.\nBut explicit keyword is still needed\n\nI'm still new to open-source contributions, so I will gladly take advice.",
        "test_func_diff": [
            {
                "fn": "test/testclass.cpp",
                "patch": "@@ -430,6 +430,11 @@ class TestClass : public TestFixture {\n                                   \"    B(const B&) {}\\n\"\n                                   \"};\");\n         ASSERT_EQUALS(\"\", errout.str());\n+\n+        checkExplicitConstructors(\"struct A{\"\n+                                  \"    A(int, int y=2) {}\"\n+                                  \"};\");\n+        ASSERT_EQUALS(\"[test.cpp:1]: (style) Struct 'A' has a constructor with 1 argument that is not explicit.\\n\", errout.str());\n     }\n \n     void checkDuplInheritedMembers(const char code[]) {"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_272760f9cac187bd16ab4a596a0cab870ceb42be/build_272760f9cac187bd16ab4a596a0cab870ceb42be\nTest project /out/danmar___cppcheck/git_repo_dir_272760f9cac187bd16ab4a596a0cab870ceb42be/build_272760f9cac187bd16ab4a596a0cab870ceb42be\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   34.37 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  34.38 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n"
    },
    "398fa280213771a0fa7a649a54dd6e6625d48e20___valueflow.cpp": {
        "prefix": "    virtual std::vector<Condition> parse(const Token* tok, const Settings*) const OVERRIDE {\n        Condition cond;\n\n        ValueFlow::Value true_value;\n        ValueFlow::Value false_value;\n\n        if (Token::Match(tok, \"==|!=\")) {\n            if (!tok->astOperand1() || !tok->astOperand2())\n                return {};\n\n            ValueFlow::Value::ValueKind kind = ValueFlow::Value::ValueKind::Known;\n            std::list<ValueFlow::Value> values = getIteratorValues(tok->astOperand1()->values(), &kind);\n            if (!values.empty()) {\n                cond.vartok = tok->astOperand2();\n            } else {\n",
        "suffix": "                if (!values.empty())\n                    cond.vartok = tok->astOperand1();\n            }\n            for (ValueFlow::Value& v:values) {\n                v.setPossible();\n                v.assumeCondition(tok);\n            }\n            cond.true_values = values;\n            cond.false_values = values;\n        }\n\n        return {cond};\n    }\n",
        "start": 7176,
        "end": 7204,
        "buggy": "    virtual std::vector<Condition> parse(const Token* tok, const Settings*) const OVERRIDE {\n        Condition cond;\n\n        ValueFlow::Value true_value;\n        ValueFlow::Value false_value;\n\n        if (Token::Match(tok, \"==|!=\")) {\n            if (!tok->astOperand1() || !tok->astOperand2())\n                return {};\n\n            ValueFlow::Value::ValueKind kind = ValueFlow::Value::ValueKind::Known;\n            std::list<ValueFlow::Value> values = getIteratorValues(tok->astOperand1()->values(), &kind);\n            if (!values.empty()) {\n                cond.vartok = tok->astOperand2();\n            } else {\n                values = getIteratorValues(tok->astOperand2()->values());\n                if (!values.empty())\n                    cond.vartok = tok->astOperand1();\n            }\n            for (ValueFlow::Value& v:values) {\n                v.setPossible();\n                v.assumeCondition(tok);\n            }\n            cond.true_values = values;\n            cond.false_values = values;\n        }\n\n        return {cond};\n    }\n",
        "fix": null,
        "buggy_hunk_masked": "                values = getIteratorValues(tok->astOperand2()->values());\n",
        "src_path": "398fa280213771a0fa7a649a54dd6e6625d48e20___valueflow.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/398fa280213771a0fa7a649a54dd6e6625d48e20",
        "commit_msg": "Fix 10657: False positive; ValueFlow - invalid iterator (#3636)",
        "test_func_diff": [
            {
                "fn": "test/teststl.cpp",
                "patch": "@@ -4201,6 +4201,20 @@ class TestStl : public TestFixture {\n             \"[test.cpp:4] -> [test.cpp:4]: (warning) Either the condition 'i==v.end()' is redundant or there is possible dereference of an invalid iterator: i+1.\\n\",\n             errout.str());\n \n+        // #10657\n+        check(\"std::list<int> mValues;\\n\"\n+              \"typedef std::list<int>::iterator ValueIterator;\\n\"\n+              \"void foo(ValueIterator beginValue, ValueIterator endValue) {\\n\"\n+              \"    ValueIterator prevValue = beginValue;\\n\"\n+              \"    ValueIterator curValue = beginValue;\\n\"\n+              \"    for (++curValue; prevValue != endValue && curValue != mValues.end(); ++curValue) {\\n\"\n+              \"        a = bar(*curValue);\\n\"\n+              \"        prevValue = curValue;\\n\"\n+              \"    }\\n\"\n+              \"    if (endValue == mValues.end()) {}\\n\"\n+              \"}\\n\");\n+        ASSERT_EQUALS(\"\", errout.str());\n+\n         // #10642\n         check(\"int f(std::vector<int> v) {\\n\"\n               \"    return *(v.begin() + v.size() - 1);\\n\""
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_398fa280213771a0fa7a649a54dd6e6625d48e20/build_398fa280213771a0fa7a649a54dd6e6625d48e20\nTest project /out/danmar___cppcheck/git_repo_dir_398fa280213771a0fa7a649a54dd6e6625d48e20/build_398fa280213771a0fa7a649a54dd6e6625d48e20\n    Start 44: TestStl\n1/1 Test #44: TestStl ..........................***Failed    4.16 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   4.17 sec\n\nThe following tests FAILED:\n\t 44 - TestStl (Failed)\n"
    },
    "d2284ddbcd2a70b4a39047ae32b1c5662060407f___checkunusedvar.cpp": {
        "prefix": "void CheckUnusedVar::checkFunctionVariableUsage()\n{\n    if (!mSettings->isEnabled(Settings::STYLE))\n        return;\n\n    // Parse all executing scopes..\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n\n    // only check functions\n    for (const Scope * scope : symbolDatabase->functionScopes) {\n        // Bailout when there are lambdas or inline functions\n        // TODO: Handle lambdas and inline functions properly\n        if (scope->hasInlineOrLambdaFunction())\n            continue;\n\n        for (const Token *tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {\n            if (findLambdaEndToken(tok))\n                // todo: handle lambdas\n                break;\n            if (Token::simpleMatch(tok, \"try {\"))\n                // todo: check try blocks\n                tok = tok->linkAt(1);\n            const Token *varDecl = nullptr;\n            if (tok->variable() && tok->variable()->nameToken() == tok) {\n                const Token * eq = tok->next();\n                while (Token::simpleMatch(eq, \"[\"))\n                    eq = eq->link()->next();\n                if (Token::simpleMatch(eq, \"=\")) {\n                    varDecl = tok;\n                    tok = eq;\n                }\n            }\n            // not assignment/initialization => continue\n            if ((!tok->isAssignmentOp() || !tok->astOperand1()) && !(Token::Match(tok, \"%var% (\") && tok->variable() && tok->variable()->nameToken() == tok))\n                continue;\n            if (tok->isName()) {\n                if (mTokenizer->isCPP()) {\n                    // do not check RAII/scope_lock objects\n                    if (!tok->valueType())\n                        continue;\n                    bool check = false;\n                    switch (tok->valueType()->type) {\n                    case ValueType::Type::UNKNOWN_TYPE:\n                    case ValueType::Type::NONSTD:\n                    case ValueType::Type::RECORD:\n",
        "suffix": "                        break;\n                    case ValueType::Type::CONTAINER:\n                    case ValueType::Type::ITERATOR:\n                    case ValueType::Type::VOID:\n                    case ValueType::Type::BOOL:\n                    case ValueType::Type::CHAR:\n                    case ValueType::Type::SHORT:\n                    case ValueType::Type::WCHAR_T:\n                    case ValueType::Type::INT:\n                    case ValueType::Type::LONG:\n                    case ValueType::Type::LONGLONG:\n                    case ValueType::Type::UNKNOWN_INT:\n                    case ValueType::Type::FLOAT:\n                    case ValueType::Type::DOUBLE:\n                    case ValueType::Type::LONGDOUBLE:\n                        check = true;\n                        break;\n                    };\n                    if (!check)\n                        continue;\n                }\n                tok = tok->next();\n            }\n            if (tok->astParent() && tok->str() != \"(\") {\n                const Token *parent = tok->astParent();\n                while (Token::Match(parent, \"%oror%|%comp%|!|&&\"))\n                    parent = parent->astParent();\n                if (!parent)\n                    continue;\n                if (!Token::simpleMatch(parent->previous(), \"if (\"))\n                    continue;\n            }\n            // Do not warn about assignment with NULL\n            if (FwdAnalysis::isNullOperand(tok->astOperand2()))\n                continue;\n\n            if (tok->astOperand1()->variable() && tok->astOperand1()->variable()->isReference() && tok->astOperand1()->variable()->nameToken() != tok->astOperand1())\n                // todo: check references\n                continue;\n\n            if (tok->astOperand1()->variable() && tok->astOperand1()->variable()->isStatic())\n                // todo: check static variables\n                continue;\n\n            if (tok->astOperand1()->variable() && tok->astOperand1()->variable()->nameToken()->isAttributeUnused())\n                continue;\n\n            // Is there a redundant assignment?\n            const Token *start = tok->findExpressionStartEndTokens().second->next();\n\n            const Token *expr = varDecl ? varDecl : tok->astOperand1();\n\n            FwdAnalysis fwdAnalysis(mTokenizer->isCPP(), mSettings->library);\n            if (fwdAnalysis.unusedValue(expr, start, scope->bodyEnd))\n                // warn\n                unreadVariableError(tok, expr->expressionString(), false);\n        }\n\n        // varId, usage {read, write, modified}\n        Variables variables;\n\n        checkFunctionVariableUsage_iterateScopes(scope, variables);\n\n\n        // Check usage of all variables in the current scope..\n        for (std::map<unsigned int, Variables::VariableUsage>::const_iterator it = variables.varUsage().begin();\n             it != variables.varUsage().end();\n             ++it) {\n            const Variables::VariableUsage &usage = it->second;\n\n            // variable has been marked as unused so ignore it\n            if (usage._var->nameToken()->isAttributeUnused() || usage._var->nameToken()->isAttributeUsed())\n                continue;\n\n            // skip things that are only partially implemented to prevent false positives\n            if (usage.mType == Variables::pointerPointer ||\n                usage.mType == Variables::pointerArray ||\n                usage.mType == Variables::referenceArray)\n                continue;\n\n            const std::string &varname = usage._var->name();\n            const Variable* var = symbolDatabase->getVariableFromVarId(it->first);\n\n            // variable has had memory allocated for it, but hasn't done\n            // anything with that memory other than, perhaps, freeing it\n            if (usage.unused() && !usage._modified && usage._allocateMemory)\n                allocatedButUnusedVariableError(usage._lastAccess, varname);\n\n            // variable has not been written, read, or modified\n            else if (usage.unused() && !usage._modified)\n                unusedVariableError(usage._var->nameToken(), varname);\n\n            // variable has not been written but has been modified\n            else if (usage._modified && !usage._write && !usage._allocateMemory && var && !var->isStlType())\n                unassignedVariableError(usage._var->nameToken(), varname);\n\n            // variable has been read but not written\n            else if (!usage._write && !usage._allocateMemory && var && !var->isStlType() && !isEmptyType(var->type()))\n                unassignedVariableError(usage._var->nameToken(), varname);\n        }\n    }\n}\n",
        "start": 1089,
        "end": 1236,
        "buggy": "void CheckUnusedVar::checkFunctionVariableUsage()\n{\n    if (!mSettings->isEnabled(Settings::STYLE))\n        return;\n\n    // Parse all executing scopes..\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n\n    // only check functions\n    for (const Scope * scope : symbolDatabase->functionScopes) {\n        // Bailout when there are lambdas or inline functions\n        // TODO: Handle lambdas and inline functions properly\n        if (scope->hasInlineOrLambdaFunction())\n            continue;\n\n        for (const Token *tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {\n            if (findLambdaEndToken(tok))\n                // todo: handle lambdas\n                break;\n            if (Token::simpleMatch(tok, \"try {\"))\n                // todo: check try blocks\n                tok = tok->linkAt(1);\n            const Token *varDecl = nullptr;\n            if (tok->variable() && tok->variable()->nameToken() == tok) {\n                const Token * eq = tok->next();\n                while (Token::simpleMatch(eq, \"[\"))\n                    eq = eq->link()->next();\n                if (Token::simpleMatch(eq, \"=\")) {\n                    varDecl = tok;\n                    tok = eq;\n                }\n            }\n            // not assignment/initialization => continue\n            if ((!tok->isAssignmentOp() || !tok->astOperand1()) && !(Token::Match(tok, \"%var% (\") && tok->variable() && tok->variable()->nameToken() == tok))\n                continue;\n            if (tok->isName()) {\n                if (mTokenizer->isCPP()) {\n                    // do not check RAII/scope_lock objects\n                    if (!tok->valueType())\n                        continue;\n                    bool check = false;\n                    switch (tok->valueType()->type) {\n                    case ValueType::Type::UNKNOWN_TYPE:\n                    case ValueType::Type::NONSTD:\n                    case ValueType::Type::RECORD:\n                        check = tok->valueType()->typeScope && tok->valueType()->typeScope->getDestructor();\n                        break;\n                    case ValueType::Type::CONTAINER:\n                    case ValueType::Type::ITERATOR:\n                    case ValueType::Type::VOID:\n                    case ValueType::Type::BOOL:\n                    case ValueType::Type::CHAR:\n                    case ValueType::Type::SHORT:\n                    case ValueType::Type::WCHAR_T:\n                    case ValueType::Type::INT:\n                    case ValueType::Type::LONG:\n                    case ValueType::Type::LONGLONG:\n                    case ValueType::Type::UNKNOWN_INT:\n                    case ValueType::Type::FLOAT:\n                    case ValueType::Type::DOUBLE:\n                    case ValueType::Type::LONGDOUBLE:\n                        check = true;\n                        break;\n                    };\n                    if (!check)\n                        continue;\n                }\n                tok = tok->next();\n            }\n            if (tok->astParent() && tok->str() != \"(\") {\n                const Token *parent = tok->astParent();\n                while (Token::Match(parent, \"%oror%|%comp%|!|&&\"))\n                    parent = parent->astParent();\n                if (!parent)\n                    continue;\n                if (!Token::simpleMatch(parent->previous(), \"if (\"))\n                    continue;\n            }\n            // Do not warn about assignment with NULL\n            if (FwdAnalysis::isNullOperand(tok->astOperand2()))\n                continue;\n\n            if (tok->astOperand1()->variable() && tok->astOperand1()->variable()->isReference() && tok->astOperand1()->variable()->nameToken() != tok->astOperand1())\n                // todo: check references\n                continue;\n\n            if (tok->astOperand1()->variable() && tok->astOperand1()->variable()->isStatic())\n                // todo: check static variables\n                continue;\n\n            if (tok->astOperand1()->variable() && tok->astOperand1()->variable()->nameToken()->isAttributeUnused())\n                continue;\n\n            // Is there a redundant assignment?\n            const Token *start = tok->findExpressionStartEndTokens().second->next();\n\n            const Token *expr = varDecl ? varDecl : tok->astOperand1();\n\n            FwdAnalysis fwdAnalysis(mTokenizer->isCPP(), mSettings->library);\n            if (fwdAnalysis.unusedValue(expr, start, scope->bodyEnd))\n                // warn\n                unreadVariableError(tok, expr->expressionString(), false);\n        }\n\n        // varId, usage {read, write, modified}\n        Variables variables;\n\n        checkFunctionVariableUsage_iterateScopes(scope, variables);\n\n\n        // Check usage of all variables in the current scope..\n        for (std::map<unsigned int, Variables::VariableUsage>::const_iterator it = variables.varUsage().begin();\n             it != variables.varUsage().end();\n             ++it) {\n            const Variables::VariableUsage &usage = it->second;\n\n            // variable has been marked as unused so ignore it\n            if (usage._var->nameToken()->isAttributeUnused() || usage._var->nameToken()->isAttributeUsed())\n                continue;\n\n            // skip things that are only partially implemented to prevent false positives\n            if (usage.mType == Variables::pointerPointer ||\n                usage.mType == Variables::pointerArray ||\n                usage.mType == Variables::referenceArray)\n                continue;\n\n            const std::string &varname = usage._var->name();\n            const Variable* var = symbolDatabase->getVariableFromVarId(it->first);\n\n            // variable has had memory allocated for it, but hasn't done\n            // anything with that memory other than, perhaps, freeing it\n            if (usage.unused() && !usage._modified && usage._allocateMemory)\n                allocatedButUnusedVariableError(usage._lastAccess, varname);\n\n            // variable has not been written, read, or modified\n            else if (usage.unused() && !usage._modified)\n                unusedVariableError(usage._var->nameToken(), varname);\n\n            // variable has not been written but has been modified\n            else if (usage._modified && !usage._write && !usage._allocateMemory && var && !var->isStlType())\n                unassignedVariableError(usage._var->nameToken(), varname);\n\n            // variable has been read but not written\n            else if (!usage._write && !usage._allocateMemory && var && !var->isStlType() && !isEmptyType(var->type()))\n                unassignedVariableError(usage._var->nameToken(), varname);\n        }\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                        check = tok->valueType()->typeScope && tok->valueType()->typeScope->getDestructor();\n",
        "src_path": "d2284ddbcd2a70b4a39047ae32b1c5662060407f___checkunusedvar.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/d2284ddbcd2a70b4a39047ae32b1c5662060407f",
        "commit_msg": "Fix false positives in self check: Variable t is assigned a value that is never used. Classes with destructors was not handled properly.",
        "test_func_diff": [
            {
                "fn": "test/testunusedvar.cpp",
                "patch": "@@ -149,6 +149,7 @@ class TestUnusedVar : public TestFixture {\n         TEST_CASE(localvarthrow); // ticket #3687\n \n         TEST_CASE(localVarStd);\n+        TEST_CASE(localVarClass);\n \n         // Don't give false positives for variables in structs/unions\n         TEST_CASE(localvarStruct1);\n@@ -4148,6 +4149,25 @@ class TestUnusedVar : public TestFixture {\n         ASSERT_EQUALS(\"\", errout.str());\n     }\n \n+    void localVarClass() {\n+        functionVariableUsage(\"void f() {\\n\"\n+                              \"    Fred f;\\n\"\n+                              \"}\");\n+        ASSERT_EQUALS(\"\", errout.str());\n+\n+        functionVariableUsage(\"class C { int x; };\\n\"\n+                              \"void f() {\\n\"\n+                              \"    C c;\\n\"\n+                              \"}\");\n+        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: c\\n\", errout.str());\n+\n+        functionVariableUsage(\"class C { public: C(int); ~C(); };\\n\"\n+                              \"void f() {\\n\"\n+                              \"    C c(12);\\n\"\n+                              \"}\");\n+        ASSERT_EQUALS(\"\", errout.str());\n+    }\n+\n     // ticket #3104 - false positive when variable is read with \"if (NOT var)\"\n     void localvarIfNOT() {\n         functionVariableUsage(\"void f() {\\n\""
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_d2284ddbcd2a70b4a39047ae32b1c5662060407f/build_d2284ddbcd2a70b4a39047ae32b1c5662060407f\nTest project /out/danmar___cppcheck/git_repo_dir_d2284ddbcd2a70b4a39047ae32b1c5662060407f/build_d2284ddbcd2a70b4a39047ae32b1c5662060407f\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   24.84 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  24.84 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n"
    },
    "192c30ab1d3ec97ae7c6955d8953fac133b8e4ff___tokenize.cpp": {
        "prefix": "void Tokenizer::arraySize()\n{\n    auto getStrTok = [](Token* tok, bool addLength, Token** endStmt) -> Token* {\n        if (addLength) {\n",
        "suffix": "            return tok->tokAt(4);\n        }\n        if (Token::Match(tok, \"%var% [ ] =\")) {\n            tok = tok->tokAt(4);\n            int parCount = 0;\n            while (Token::simpleMatch(tok, \"(\")) {\n                ++parCount;\n                tok = tok->next();\n            }\n            if (Token::Match(tok, \"%str%\")) {\n                *endStmt = tok->tokAt(parCount + 1);\n                return tok;\n            }\n        }\n        return nullptr;\n    };\n\n    for (Token *tok = list.front(); tok; tok = tok->next()) {\n        if (!tok->isName() || !Token::Match(tok, \"%var% [ ] =\"))\n            continue;\n        bool addlength = false;\n        if (Token::Match(tok->previous(), \"!!* %var% [ ] = { %str% } ;\")) {\n            Token *t = tok->tokAt(3);\n            t->deleteNext();\n            t->next()->deleteNext();\n            addlength = true;\n        }\n\n        Token* endStmt{};\n        if (const Token* strTok = getStrTok(tok, addlength, &endStmt)) {\n            const int sz = Token::getStrArraySize(strTok);\n            tok->next()->insertToken(MathLib::toString(sz));\n            tok = endStmt;\n        }\n\n        else if (Token::Match(tok, \"%var% [ ] = {\")) {\n            MathLib::biguint sz = 1;\n            tok = tok->next();\n            Token *end = tok->linkAt(3);\n            for (Token *tok2 = tok->tokAt(4); tok2 && tok2 != end; tok2 = tok2->next()) {\n                if (tok2->link() && Token::Match(tok2, \"{|(|[|<\")) {\n                    if (tok2->str() == \"[\" && tok2->link()->strAt(1) == \"=\") { // designated initializer\n                        if (Token::Match(tok2, \"[ %num% ]\"))\n                            sz = std::max(sz, MathLib::toULongNumber(tok2->strAt(1)) + 1U);\n                        else {\n                            sz = 0;\n                            break;\n                        }\n                    }\n                    tok2 = tok2->link();\n                } else if (tok2->str() == \",\") {\n                    if (!Token::Match(tok2->next(), \"[},]\"))\n                        ++sz;\n                    else {\n                        tok2 = tok2->previous();\n                        tok2->deleteNext();\n                    }\n                }\n            }\n\n            if (sz != 0)\n                tok->insertToken(MathLib::toString(sz));\n\n            tok = end->next() ? end->next() : end;\n        }\n    }\n}\n",
        "start": 3160,
        "end": 3231,
        "buggy": "void Tokenizer::arraySize()\n{\n    auto getStrTok = [](Token* tok, bool addLength, Token** endStmt) -> Token* {\n        if (addLength) {\n            *endStmt = tok->tokAt(6);\n            return tok->tokAt(4);\n        }\n        if (Token::Match(tok, \"%var% [ ] =\")) {\n            tok = tok->tokAt(4);\n            int parCount = 0;\n            while (Token::simpleMatch(tok, \"(\")) {\n                ++parCount;\n                tok = tok->next();\n            }\n            if (Token::Match(tok, \"%str%\")) {\n                *endStmt = tok->tokAt(parCount + 1);\n                return tok;\n            }\n        }\n        return nullptr;\n    };\n\n    for (Token *tok = list.front(); tok; tok = tok->next()) {\n        if (!tok->isName() || !Token::Match(tok, \"%var% [ ] =\"))\n            continue;\n        bool addlength = false;\n        if (Token::Match(tok->previous(), \"!!* %var% [ ] = { %str% } ;\")) {\n            Token *t = tok->tokAt(3);\n            t->deleteNext();\n            t->next()->deleteNext();\n            addlength = true;\n        }\n\n        Token* endStmt{};\n        if (const Token* strTok = getStrTok(tok, addlength, &endStmt)) {\n            const int sz = Token::getStrArraySize(strTok);\n            tok->next()->insertToken(MathLib::toString(sz));\n            tok = endStmt;\n        }\n\n        else if (Token::Match(tok, \"%var% [ ] = {\")) {\n            MathLib::biguint sz = 1;\n            tok = tok->next();\n            Token *end = tok->linkAt(3);\n            for (Token *tok2 = tok->tokAt(4); tok2 && tok2 != end; tok2 = tok2->next()) {\n                if (tok2->link() && Token::Match(tok2, \"{|(|[|<\")) {\n                    if (tok2->str() == \"[\" && tok2->link()->strAt(1) == \"=\") { // designated initializer\n                        if (Token::Match(tok2, \"[ %num% ]\"))\n                            sz = std::max(sz, MathLib::toULongNumber(tok2->strAt(1)) + 1U);\n                        else {\n                            sz = 0;\n                            break;\n                        }\n                    }\n                    tok2 = tok2->link();\n                } else if (tok2->str() == \",\") {\n                    if (!Token::Match(tok2->next(), \"[},]\"))\n                        ++sz;\n                    else {\n                        tok2 = tok2->previous();\n                        tok2->deleteNext();\n                    }\n                }\n            }\n\n            if (sz != 0)\n                tok->insertToken(MathLib::toString(sz));\n\n            tok = end->next() ? end->next() : end;\n        }\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            *endStmt = tok->tokAt(6);\n",
        "src_path": "192c30ab1d3ec97ae7c6955d8953fac133b8e4ff___tokenize.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/192c30ab1d3ec97ae7c6955d8953fac133b8e4ff",
        "commit_msg": "Fix crash in arraySize() (#4556)\n\n* Fix  #11355 FN: arrayIndexOutOfBounds\r\n\r\n* Fix\r\n\r\n* Fix crash in arraySize()",
        "test_func_diff": [
            {
                "fn": "test/testtokenize.cpp",
                "patch": "@@ -4013,6 +4013,7 @@ class TestTokenizer : public TestFixture {\n         ASSERT_EQUALS(\"; int a [ 3 ] = { [ 2 ] = 5 } ;\", tokenizeAndStringify(\";int a[]={ [2] = 5 };\"));\n         ASSERT_EQUALS(\"; int a [ 5 ] = { 1 , 2 , [ 2 ] = 5 , 3 , 4 } ;\", tokenizeAndStringify(\";int a[]={ 1, 2, [2] = 5, 3, 4 };\"));\n         ASSERT_EQUALS(\"; int a [ ] = { 1 , 2 , [ x ] = 5 , 3 , 4 } ;\", tokenizeAndStringify(\";int a[]={ 1, 2, [x] = 5, 3, 4 };\"));\n+        ASSERT_EQUALS(\"; const char c [ 4 ] = \\\"abc\\\" ;\", tokenizeAndStringify(\";const char c[] = { \\\"abc\\\" };\"));\n     }\n \n     void labels() {"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_192c30ab1d3ec97ae7c6955d8953fac133b8e4ff/build_192c30ab1d3ec97ae7c6955d8953fac133b8e4ff\nTest project /out/danmar___cppcheck/git_repo_dir_192c30ab1d3ec97ae7c6955d8953fac133b8e4ff/build_192c30ab1d3ec97ae7c6955d8953fac133b8e4ff\n    Start 55: TestThreadExecutor\n1/2 Test #55: TestThreadExecutor ...............   Passed    8.50 sec\n    Start 58: TestTokenizer\n2/2 Test #58: TestTokenizer ....................***Exception: SegFault  1.12 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =   9.63 sec\n\nThe following tests FAILED:\n\t 58 - TestTokenizer (SEGFAULT)\n"
    },
    "ea2916a3e49934d482cd9b30b520c7873db4de82___tokenlist.cpp": {
        "prefix": "static void compilePrecedence2(Token *&tok, AST_state& state)\n{\n    compileScope(tok, state);\n    while (tok) {\n        if (tok->tokType() == Token::eIncDecOp && !isPrefixUnary(tok, state.cpp)) {\n            compileUnaryOp(tok, state, compileScope);\n        } else if (tok->str() == \"...\") {\n            state.op.push(tok);\n            tok = tok->next();\n            break;\n        } else if (tok->str() == \".\" && tok->strAt(1) != \"*\") {\n            if (tok->strAt(1) == \".\") {\n                state.op.push(tok);\n                tok = tok->tokAt(3);\n                break;\n            } else\n                compileBinOp(tok, state, compileScope);\n        } else if (tok->str() == \"[\") {\n            if (state.cpp && isPrefixUnary(tok, state.cpp) && Token::Match(tok->link(), \"] (|{\")) { // Lambda\n                // What we do here:\n                // - Nest the round bracket under the square bracket.\n                // - Nest what follows the lambda (if anything) with the lambda opening [\n                // - Compile the content of the lambda function as separate tree (this is done later)\n                // this must be consistent with isLambdaCaptureList\n                Token* const squareBracket = tok;\n                if (Token::simpleMatch(squareBracket->link(), \"] (\")) {\n                    Token* const roundBracket = squareBracket->link()->next();\n                    Token* curlyBracket = roundBracket->link()->next();\n                    if (Token::Match(curlyBracket, \"mutable|const\"))\n                        curlyBracket = curlyBracket->next();\n                    if (curlyBracket && curlyBracket->originalName() == \"->\") {\n                        while (Token::Match(curlyBracket, \"%name%|.|::|&|*\"))\n                            curlyBracket = curlyBracket->next();\n                        if (curlyBracket && curlyBracket->str() == \"<\" && curlyBracket->link())\n                            curlyBracket = curlyBracket->link()->next();\n                    }\n                    if (curlyBracket && curlyBracket->str() == \"{\") {\n                        squareBracket->astOperand1(roundBracket);\n                        roundBracket->astOperand1(curlyBracket);\n                        state.op.push(squareBracket);\n                        tok = curlyBracket->link()->next();\n                        continue;\n                    }\n                } else {\n                    Token* const curlyBracket = squareBracket->link()->next();\n                    squareBracket->astOperand1(curlyBracket);\n                    state.op.push(squareBracket);\n                    tok = curlyBracket->link()->next();\n                    continue;\n                }\n            }\n\n            const Token* const tok2 = tok;\n            if (tok->strAt(1) != \"]\")\n                compileBinOp(tok, state, compileExpression);\n            else\n                compileUnaryOp(tok, state, compileExpression);\n            tok = tok2->link()->next();\n        } else if (tok->str() == \"(\" && (!iscast(tok) || Token::Match(tok->previous(), \"if|while|for|switch|catch\"))) {\n            Token* tok2 = tok;\n            tok = tok->next();\n            const bool opPrevTopSquare = !state.op.empty() && state.op.top() && state.op.top()->str() == \"[\";\n            const std::size_t oldOpSize = state.op.size();\n            compileExpression(tok, state);\n            tok = tok2;\n            if ((tok->previous() && tok->previous()->isName() && (!Token::Match(tok->previous(), \"return|case\") && (!state.cpp || !Token::Match(tok->previous(), \"throw|delete\"))))\n                || (tok->strAt(-1) == \"]\" && (!state.cpp || !Token::Match(tok->linkAt(-1)->previous(), \"new|delete\")))\n                || (tok->strAt(-1) == \">\" && tok->linkAt(-1))\n                || (tok->strAt(-1) == \")\" && !iscast(tok->linkAt(-1))) // Don't treat brackets to clarify precedence as function calls\n                || (tok->strAt(-1) == \"}\" && opPrevTopSquare)) {\n                const bool operandInside = oldOpSize < state.op.size();\n                if (operandInside)\n                    compileBinOp(tok, state, nullptr);\n                else\n                    compileUnaryOp(tok, state, nullptr);\n            }\n            tok = tok->link()->next();\n        } else if (iscast(tok) && Token::simpleMatch(tok->link(), \") {\") && Token::simpleMatch(tok->link()->linkAt(1), \"} [\")) {\n            Token *cast = tok;\n            tok = tok->link()->next();\n            Token *tok1 = tok;\n            compileUnaryOp(tok, state, compileExpression);\n            cast->astOperand1(tok1);\n            tok = tok1->link()->next();\n        } else if (state.cpp && tok->str() == \"{\" && iscpp11init(tok)) {\n            if (Token::simpleMatch(tok, \"{ }\"))\n                compileUnaryOp(tok, state, compileExpression);\n            else\n                compileBinOp(tok, state, compileExpression);\n",
        "suffix": "                tok = tok->next();\n        } else break;\n    }\n}\n",
        "start": 797,
        "end": 890,
        "buggy": "static void compilePrecedence2(Token *&tok, AST_state& state)\n{\n    compileScope(tok, state);\n    while (tok) {\n        if (tok->tokType() == Token::eIncDecOp && !isPrefixUnary(tok, state.cpp)) {\n            compileUnaryOp(tok, state, compileScope);\n        } else if (tok->str() == \"...\") {\n            state.op.push(tok);\n            tok = tok->next();\n            break;\n        } else if (tok->str() == \".\" && tok->strAt(1) != \"*\") {\n            if (tok->strAt(1) == \".\") {\n                state.op.push(tok);\n                tok = tok->tokAt(3);\n                break;\n            } else\n                compileBinOp(tok, state, compileScope);\n        } else if (tok->str() == \"[\") {\n            if (state.cpp && isPrefixUnary(tok, state.cpp) && Token::Match(tok->link(), \"] (|{\")) { // Lambda\n                // What we do here:\n                // - Nest the round bracket under the square bracket.\n                // - Nest what follows the lambda (if anything) with the lambda opening [\n                // - Compile the content of the lambda function as separate tree (this is done later)\n                // this must be consistent with isLambdaCaptureList\n                Token* const squareBracket = tok;\n                if (Token::simpleMatch(squareBracket->link(), \"] (\")) {\n                    Token* const roundBracket = squareBracket->link()->next();\n                    Token* curlyBracket = roundBracket->link()->next();\n                    if (Token::Match(curlyBracket, \"mutable|const\"))\n                        curlyBracket = curlyBracket->next();\n                    if (curlyBracket && curlyBracket->originalName() == \"->\") {\n                        while (Token::Match(curlyBracket, \"%name%|.|::|&|*\"))\n                            curlyBracket = curlyBracket->next();\n                        if (curlyBracket && curlyBracket->str() == \"<\" && curlyBracket->link())\n                            curlyBracket = curlyBracket->link()->next();\n                    }\n                    if (curlyBracket && curlyBracket->str() == \"{\") {\n                        squareBracket->astOperand1(roundBracket);\n                        roundBracket->astOperand1(curlyBracket);\n                        state.op.push(squareBracket);\n                        tok = curlyBracket->link()->next();\n                        continue;\n                    }\n                } else {\n                    Token* const curlyBracket = squareBracket->link()->next();\n                    squareBracket->astOperand1(curlyBracket);\n                    state.op.push(squareBracket);\n                    tok = curlyBracket->link()->next();\n                    continue;\n                }\n            }\n\n            const Token* const tok2 = tok;\n            if (tok->strAt(1) != \"]\")\n                compileBinOp(tok, state, compileExpression);\n            else\n                compileUnaryOp(tok, state, compileExpression);\n            tok = tok2->link()->next();\n        } else if (tok->str() == \"(\" && (!iscast(tok) || Token::Match(tok->previous(), \"if|while|for|switch|catch\"))) {\n            Token* tok2 = tok;\n            tok = tok->next();\n            const bool opPrevTopSquare = !state.op.empty() && state.op.top() && state.op.top()->str() == \"[\";\n            const std::size_t oldOpSize = state.op.size();\n            compileExpression(tok, state);\n            tok = tok2;\n            if ((tok->previous() && tok->previous()->isName() && (!Token::Match(tok->previous(), \"return|case\") && (!state.cpp || !Token::Match(tok->previous(), \"throw|delete\"))))\n                || (tok->strAt(-1) == \"]\" && (!state.cpp || !Token::Match(tok->linkAt(-1)->previous(), \"new|delete\")))\n                || (tok->strAt(-1) == \">\" && tok->linkAt(-1))\n                || (tok->strAt(-1) == \")\" && !iscast(tok->linkAt(-1))) // Don't treat brackets to clarify precedence as function calls\n                || (tok->strAt(-1) == \"}\" && opPrevTopSquare)) {\n                const bool operandInside = oldOpSize < state.op.size();\n                if (operandInside)\n                    compileBinOp(tok, state, nullptr);\n                else\n                    compileUnaryOp(tok, state, nullptr);\n            }\n            tok = tok->link()->next();\n        } else if (iscast(tok) && Token::simpleMatch(tok->link(), \") {\") && Token::simpleMatch(tok->link()->linkAt(1), \"} [\")) {\n            Token *cast = tok;\n            tok = tok->link()->next();\n            Token *tok1 = tok;\n            compileUnaryOp(tok, state, compileExpression);\n            cast->astOperand1(tok1);\n            tok = tok1->link()->next();\n        } else if (state.cpp && tok->str() == \"{\" && iscpp11init(tok)) {\n            if (Token::simpleMatch(tok, \"{ }\"))\n                compileUnaryOp(tok, state, compileExpression);\n            else\n                compileBinOp(tok, state, compileExpression);\n            if (Token::simpleMatch(tok, \"}\"))\n                tok = tok->next();\n        } else break;\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            if (Token::simpleMatch(tok, \"}\"))\n",
        "src_path": "ea2916a3e49934d482cd9b30b520c7873db4de82___tokenlist.cpp",
        "uri": "https://api.github.com/repos/danmar/cppcheck/commits/ea2916a3e49934d482cd9b30b520c7873db4de82",
        "commit_msg": "Fix issue 9514: Syntax Error: AST broken, 'for' doesn't have two operands. (#2429)\n\n* Fix issue 9514: Syntax Error: AST broken, 'for' doesn't have two operands.\r\n\r\n* Fix typo",
        "test_func_diff": [
            {
                "fn": "test/testtokenize.cpp",
                "patch": "@@ -474,6 +474,7 @@ class TestTokenizer : public TestFixture {\n         TEST_CASE(checkLambdas);\n         TEST_CASE(checkIfCppCast);\n         TEST_CASE(checkRefQualifiers);\n+        TEST_CASE(checkConditionBlock);\n \n         // #9052\n         TEST_CASE(noCrash1);\n@@ -7692,6 +7693,7 @@ class TestTokenizer : public TestFixture {\n         ASSERT_EQUALS(\"Abc({newreturn\", testAst(\"return new A {b(c)};\"));\n         ASSERT_EQUALS(\"a{{return\", testAst(\"return{{a}};\"));\n         ASSERT_EQUALS(\"a{b{,{return\", testAst(\"return{{a},{b}};\"));\n+        ASSERT_EQUALS(\"stdvector::\", testAst(\"std::vector<std::vector<int>>{{},{}}\"));\n     }\n \n     void astbrackets() { // []\n@@ -8178,6 +8180,12 @@ class TestTokenizer : public TestFixture {\n \n     }\n \n+    void checkConditionBlock() {\n+        ASSERT_NO_THROW(tokenizeAndStringify(\"void a() {\\n\"\n+                                             \"  for (auto b : std::vector<std::vector<int>>{{}, {}}) {}\\n\"\n+                                             \"}\\n\"))\n+    }\n+\n     void noCrash1() {\n         ASSERT_NO_THROW(tokenizeAndStringify(\n                             \"struct A {\\n\""
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_ea2916a3e49934d482cd9b30b520c7873db4de82/build_ea2916a3e49934d482cd9b30b520c7873db4de82\nTest project /out/danmar___cppcheck/git_repo_dir_ea2916a3e49934d482cd9b30b520c7873db4de82/build_ea2916a3e49934d482cd9b30b520c7873db4de82\n    Start 49: TestTokenizer\n1/1 Test #49: TestTokenizer ....................***Failed    3.57 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   3.57 sec\n\nThe following tests FAILED:\n\t 49 - TestTokenizer (Failed)\n"
    },
    "de215ef978104a0e9efdc7b78a9d58cd529cf17a___App.hpp": {
        "prefix": "    bool _parse_single_config(const ConfigItem &item, std::size_t level = 0) {\n        if(level < item.parents.size()) {\n            try {\n                auto subcom = get_subcommand(item.parents.at(level));\n                auto result = subcom->_parse_single_config(item, level + 1);\n\n                return result;\n            } catch(const OptionNotFound &) {\n                return false;\n            }\n        }\n        // check for section open\n        if(item.name == \"++\") {\n            if(configurable_) {\n                increment_parsed();\n                _trigger_pre_parse(2);\n                if(parent_ != nullptr) {\n                    parent_->parsed_subcommands_.push_back(this);\n                }\n            }\n            return true;\n        }\n        // check for section close\n        if(item.name == \"--\") {\n",
        "suffix": "                _process_callbacks();\n                _process_requirements();\n                run_callback();\n            }\n            return true;\n        }\n        Option *op = get_option_no_throw(\"--\" + item.name);\n        if(op == nullptr) {\n            if(item.name.size() == 1) {\n                op = get_option_no_throw(\"-\" + item.name);\n            }\n        }\n        if(op == nullptr) {\n            op = get_option_no_throw(item.name);\n        }\n        if(op == nullptr) {\n            // If the option was not present\n            if(get_allow_config_extras() == config_extras_mode::capture)\n                // Should we worry about classifying the extras properly?\n                missing_.emplace_back(detail::Classifier::NONE, item.fullname());\n            return false;\n        }\n\n        if(!op->get_configurable()) {\n            if(get_allow_config_extras() == config_extras_mode::ignore_all) {\n                return false;\n            }\n            throw ConfigError::NotConfigurable(item.fullname());\n        }\n\n        if(op->empty()) {\n\n            if(op->get_expected_min() == 0) {\n                // Flag parsing\n                auto res = config_formatter_->to_flag(item);\n                res = op->get_flag_value(item.name, res);\n\n                op->add_result(res);\n\n            } else {\n                op->add_result(item.inputs);\n                op->run_callback();\n            }\n        }\n\n        return true;\n    }\n",
        "start": 2392,
        "end": 2463,
        "buggy": "    bool _parse_single_config(const ConfigItem &item, std::size_t level = 0) {\n        if(level < item.parents.size()) {\n            try {\n                auto subcom = get_subcommand(item.parents.at(level));\n                auto result = subcom->_parse_single_config(item, level + 1);\n\n                return result;\n            } catch(const OptionNotFound &) {\n                return false;\n            }\n        }\n        // check for section open\n        if(item.name == \"++\") {\n            if(configurable_) {\n                increment_parsed();\n                _trigger_pre_parse(2);\n                if(parent_ != nullptr) {\n                    parent_->parsed_subcommands_.push_back(this);\n                }\n            }\n            return true;\n        }\n        // check for section close\n        if(item.name == \"--\") {\n            if(configurable_) {\n                _process_callbacks();\n                _process_requirements();\n                run_callback();\n            }\n            return true;\n        }\n        Option *op = get_option_no_throw(\"--\" + item.name);\n        if(op == nullptr) {\n            if(item.name.size() == 1) {\n                op = get_option_no_throw(\"-\" + item.name);\n            }\n        }\n        if(op == nullptr) {\n            op = get_option_no_throw(item.name);\n        }\n        if(op == nullptr) {\n            // If the option was not present\n            if(get_allow_config_extras() == config_extras_mode::capture)\n                // Should we worry about classifying the extras properly?\n                missing_.emplace_back(detail::Classifier::NONE, item.fullname());\n            return false;\n        }\n\n        if(!op->get_configurable()) {\n            if(get_allow_config_extras() == config_extras_mode::ignore_all) {\n                return false;\n            }\n            throw ConfigError::NotConfigurable(item.fullname());\n        }\n\n        if(op->empty()) {\n\n            if(op->get_expected_min() == 0) {\n                // Flag parsing\n                auto res = config_formatter_->to_flag(item);\n                res = op->get_flag_value(item.name, res);\n\n                op->add_result(res);\n\n            } else {\n                op->add_result(item.inputs);\n                op->run_callback();\n            }\n        }\n\n        return true;\n    }\n",
        "fix": null,
        "buggy_hunk_masked": "            if(configurable_) {\n",
        "src_path": "de215ef978104a0e9efdc7b78a9d58cd529cf17a___App.hpp",
        "uri": "https://api.github.com/repos/CLIUtils/CLI11/commits/de215ef978104a0e9efdc7b78a9d58cd529cf17a",
        "commit_msg": "Incorrect subcommand callback trigger (#733)\n\n* fix the issue where subcommand callbacks would be triggered multiple times if specified as configurable.\r\n\r\n* style: pre-commit.ci fixes\r\n\r\nCo-authored-by: pre-commit-ci[bot] <66853113+pre-commit-ci[bot]@users.noreply.github.com>",
        "test_func_diff": [
            {
                "fn": "tests/ConfigFileTest.cpp",
                "patch": "@@ -1581,6 +1581,25 @@ TEST_CASE_METHOD(TApp, \"DuplicateSubcommandCallbacks\", \"[config]\") {\n     CHECK(3 == count);\n }\n \n+TEST_CASE_METHOD(TApp, \"SubcommandCallbackSingle\", \"[config]\") {\n+\n+    TempFile tmptoml{\"Testtomlcallback.toml\"};\n+\n+    app.set_config(\"--config\", tmptoml);\n+\n+    {\n+        std::ofstream out{tmptoml};\n+        out << \"[foo]\" << std::endl;\n+    }\n+    int count{0};\n+    auto *foo = app.add_subcommand(\"foo\");\n+    foo->configurable();\n+    foo->callback([&count]() { ++count; });\n+\n+    run();\n+    CHECK(1 == count);\n+}\n+\n TEST_CASE_METHOD(TApp, \"IniFailure\", \"[config]\") {\n \n     TempFile tmpini{\"TestIniTmp.ini\"};"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CLIUtils___CLI11/git_repo_dir_de215ef978104a0e9efdc7b78a9d58cd529cf17a/build_de215ef978104a0e9efdc7b78a9d58cd529cf17a\nTest project /out/CLIUtils___CLI11/git_repo_dir_de215ef978104a0e9efdc7b78a9d58cd529cf17a/build_de215ef978104a0e9efdc7b78a9d58cd529cf17a\n\nCLI11 information:\n  C++ standard: 11\n  __has_include: yes\n  No optional library found\n\n    Start 2: ConfigFileTest\n1/1 Test #2: ConfigFileTest ...................***Failed    0.03 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.03 sec\n\nThe following tests FAILED:\n\t  2 - ConfigFileTest (Failed)\n"
    },
    "020a21afc65fe843efca5b2f74e3d5b502425f76___Validators.hpp": {
        "prefix": "inline std::pair<std::string, std::string> split_program_name(std::string commandline) {\n    // try to determine the programName\n    std::pair<std::string, std::string> vals;\n    trim(commandline);\n    auto esp = commandline.find_first_of(' ', 1);\n    while(detail::check_path(commandline.substr(0, esp).c_str()) != path_type::file) {\n        esp = commandline.find_first_of(' ', esp + 1);\n        if(esp == std::string::npos) {\n            // if we have reached the end and haven't found a valid file just assume the first argument is the\n            // program name\n            if(commandline[0] == '\"' || commandline[0] == '\\'' || commandline[0] == '`') {\n                bool embeddedQuote = false;\n                auto keyChar = commandline[0];\n                auto end = commandline.find_first_of(keyChar, 1);\n                while((end != std::string::npos) && (commandline[end - 1] == '\\\\')) {  // deal with escaped quotes\n                    end = commandline.find_first_of(keyChar, end + 1);\n                    embeddedQuote = true;\n                }\n                if(end != std::string::npos) {\n                    vals.first = commandline.substr(1, end - 1);\n                    esp = end + 1;\n                    if(embeddedQuote) {\n                        vals.first = find_and_replace(vals.first, std::string(\"\\\\\") + keyChar, std::string(1, keyChar));\n                    }\n                } else {\n                    esp = commandline.find_first_of(' ', 1);\n                }\n            } else {\n                esp = commandline.find_first_of(' ', 1);\n            }\n\n            break;\n        }\n    }\n    if(vals.first.empty()) {\n        vals.first = commandline.substr(0, esp);\n        rtrim(vals.first);\n    }\n\n    // strip the program name\n",
        "suffix": "    ltrim(vals.second);\n    return vals;\n}\n",
        "start": 1126,
        "end": 1169,
        "buggy": "inline std::pair<std::string, std::string> split_program_name(std::string commandline) {\n    // try to determine the programName\n    std::pair<std::string, std::string> vals;\n    trim(commandline);\n    auto esp = commandline.find_first_of(' ', 1);\n    while(detail::check_path(commandline.substr(0, esp).c_str()) != path_type::file) {\n        esp = commandline.find_first_of(' ', esp + 1);\n        if(esp == std::string::npos) {\n            // if we have reached the end and haven't found a valid file just assume the first argument is the\n            // program name\n            if(commandline[0] == '\"' || commandline[0] == '\\'' || commandline[0] == '`') {\n                bool embeddedQuote = false;\n                auto keyChar = commandline[0];\n                auto end = commandline.find_first_of(keyChar, 1);\n                while((end != std::string::npos) && (commandline[end - 1] == '\\\\')) {  // deal with escaped quotes\n                    end = commandline.find_first_of(keyChar, end + 1);\n                    embeddedQuote = true;\n                }\n                if(end != std::string::npos) {\n                    vals.first = commandline.substr(1, end - 1);\n                    esp = end + 1;\n                    if(embeddedQuote) {\n                        vals.first = find_and_replace(vals.first, std::string(\"\\\\\") + keyChar, std::string(1, keyChar));\n                    }\n                } else {\n                    esp = commandline.find_first_of(' ', 1);\n                }\n            } else {\n                esp = commandline.find_first_of(' ', 1);\n            }\n\n            break;\n        }\n    }\n    if(vals.first.empty()) {\n        vals.first = commandline.substr(0, esp);\n        rtrim(vals.first);\n    }\n\n    // strip the program name\n    vals.second = (esp != std::string::npos) ? commandline.substr(esp + 1) : std::string{};\n    ltrim(vals.second);\n    return vals;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    vals.second = (esp != std::string::npos) ? commandline.substr(esp + 1) : std::string{};\n",
        "src_path": "020a21afc65fe843efca5b2f74e3d5b502425f76___Validators.hpp",
        "uri": "https://api.github.com/repos/CLIUtils/CLI11/commits/020a21afc65fe843efca5b2f74e3d5b502425f76",
        "commit_msg": "Fix an issue where an error was generated if just a file name was supplied to the split_program_name parsing (#740)",
        "test_func_diff": [
            {
                "fn": "tests/StringParseTest.cpp",
                "patch": "@@ -89,6 +89,15 @@ TEST_CASE_METHOD(TApp, \"ProgNameWithSpace\", \"[stringparse]\") {\n     CHECK(app.get_name() == \"Foo Bar\");\n }\n \n+// From GitHub issue #739 https://github.com/CLIUtils/CLI11/issues/739\n+TEST_CASE_METHOD(TApp, \"ProgNameOnly\", \"[stringparse]\") {\n+\n+    app.add_flag(\"--foo\");\n+    CHECK_NOTHROW(app.parse(\"\\\"C:\\\\example.exe\\\"\", true));\n+\n+    CHECK(app.get_name() == \"C:\\\\example.exe\");\n+}\n+\n TEST_CASE_METHOD(TApp, \"ProgNameWithSpaceEmbeddedQuote\", \"[stringparse]\") {\n \n     app.add_flag(\"--foo\");"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/CLIUtils___CLI11/git_repo_dir_020a21afc65fe843efca5b2f74e3d5b502425f76/build_020a21afc65fe843efca5b2f74e3d5b502425f76\nTest project /out/CLIUtils___CLI11/git_repo_dir_020a21afc65fe843efca5b2f74e3d5b502425f76/build_020a21afc65fe843efca5b2f74e3d5b502425f76\n\nCLI11 information:\n  C++ standard: 11\n  __has_include: yes\n  No optional library found\n\n    Start 15: StringParseTest\n1/1 Test #15: StringParseTest ..................***Failed    0.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.02 sec\n\nThe following tests FAILED:\n\t 15 - StringParseTest (Failed)\n"
    },
    "059898e80d55dbe8d5c5eca6e6c1b10668553f92___align.cpp": {
        "prefix": "chunk_t *align_assign(chunk_t *first, size_t span, size_t thresh, size_t *p_nl_count)\n{\n   LOG_FUNC_ENTRY();\n\n   if (first == nullptr)\n   {\n      return(nullptr);\n   }\n   size_t my_level = first->level;\n\n   LOG_FMT(LALASS, \"%s(%d): [my_level is %zu]: start checking with '%s', on orig_line %zu, span is %zu, thresh is %zu\\n\",\n           __func__, __LINE__, my_level, first->text(), first->orig_line, span, thresh);\n\n   // If we are aligning on a tabstop, we shouldn't right-align\n   AlignStack as;    // regular assigns\n   as.Start(span, thresh);\n   as.m_right_align = !cpd.settings[UO_align_on_tabstop].b;\n\n   AlignStack vdas;  // variable def assigns\n   vdas.Start(span, thresh);\n   vdas.m_right_align = as.m_right_align;\n\n   size_t  var_def_cnt = 0;\n   size_t  equ_count   = 0;\n   size_t  tmp;\n   chunk_t *pc = first;\n   while (pc != nullptr)\n   {\n      LOG_FMT(LALASS, \"%s(%d): orig_line is %zu, check pc->text() '%s'\\n\",\n              __func__, __LINE__, pc->orig_line, pc->text());\n      // Don't check inside PAREN or SQUARE groups\n      if (  pc->type == CT_SPAREN_OPEN\n",
        "suffix": "         || pc->type == CT_SQUARE_OPEN\n         || pc->type == CT_PAREN_OPEN)\n      {\n         LOG_FMT(LALASS, \"%s(%d): Don't check inside PAREN or SQUARE groups, type is %s\\n\",\n                 __func__, __LINE__, get_token_name(pc->type));\n         tmp = pc->orig_line;\n         pc  = chunk_skip_to_match(pc);\n         if (pc != nullptr)\n         {\n            as.NewLines(pc->orig_line - tmp);\n            vdas.NewLines(pc->orig_line - tmp);\n         }\n         continue;\n      }\n\n      // Recurse if a brace set is found\n      if (pc->type == CT_BRACE_OPEN || pc->type == CT_VBRACE_OPEN)\n      {\n         size_t myspan;\n         size_t mythresh;\n\n         size_t sub_nl_count = 0;\n\n         if (pc->parent_type == CT_ENUM)\n         {\n            myspan   = cpd.settings[UO_align_enum_equ_span].u;\n            mythresh = cpd.settings[UO_align_enum_equ_thresh].u;\n         }\n         else\n         {\n            myspan   = cpd.settings[UO_align_assign_span].u;\n            mythresh = cpd.settings[UO_align_assign_thresh].u;\n         }\n\n         pc = align_assign(chunk_get_next_ncnl(pc), myspan, mythresh, &sub_nl_count);\n         if (sub_nl_count > 0)\n         {\n            as.NewLines(sub_nl_count);\n            vdas.NewLines(sub_nl_count);\n            if (p_nl_count != nullptr)\n            {\n               *p_nl_count += sub_nl_count;\n            }\n         }\n         continue;\n      }\n\n      // Done with this brace set?\n      if (pc->type == CT_BRACE_CLOSE || pc->type == CT_VBRACE_CLOSE)\n      {\n         pc = chunk_get_next(pc);\n         break;\n      }\n\n      if (chunk_is_newline(pc))\n      {\n         as.NewLines(pc->nl_count);\n         vdas.NewLines(pc->nl_count);\n         if (p_nl_count != nullptr)\n         {\n            *p_nl_count += pc->nl_count;\n         }\n\n         var_def_cnt = 0;\n         equ_count   = 0;\n      }\n      else if (pc->flags & PCF_VAR_DEF)\n      {\n         var_def_cnt++;\n      }\n      else if (var_def_cnt > 1)\n      {\n         // we hit the second variable def - don't look for assigns, don't align\n         vdas.Reset();\n      }\n      else if (  equ_count == 0\n              && pc->type == CT_ASSIGN\n              && ((pc->flags & PCF_IN_TEMPLATE) == 0))  // Issue #999\n      {\n         equ_count++;\n         if (var_def_cnt != 0)\n         {\n            vdas.Add(pc);\n         }\n         else\n         {\n            as.Add(pc);\n         }\n      }\n\n      pc = chunk_get_next(pc);\n   }\n\n   as.End();\n   vdas.End();\n\n   if (pc != nullptr)\n   {\n      LOG_FMT(LALASS, \"%s(%d): done on '%s' on orig_line %zu\\n\",\n              __func__, __LINE__, pc->text(), pc->orig_line);\n   }\n   else\n   {\n      LOG_FMT(LALASS, \"%s(%d): done on NULL\\n\", __func__, __LINE__);\n   }\n\n   return(pc);\n} // align_assign\n",
        "start": 701,
        "end": 841,
        "buggy": "chunk_t *align_assign(chunk_t *first, size_t span, size_t thresh, size_t *p_nl_count)\n{\n   LOG_FUNC_ENTRY();\n\n   if (first == nullptr)\n   {\n      return(nullptr);\n   }\n   size_t my_level = first->level;\n\n   LOG_FMT(LALASS, \"%s(%d): [my_level is %zu]: start checking with '%s', on orig_line %zu, span is %zu, thresh is %zu\\n\",\n           __func__, __LINE__, my_level, first->text(), first->orig_line, span, thresh);\n\n   // If we are aligning on a tabstop, we shouldn't right-align\n   AlignStack as;    // regular assigns\n   as.Start(span, thresh);\n   as.m_right_align = !cpd.settings[UO_align_on_tabstop].b;\n\n   AlignStack vdas;  // variable def assigns\n   vdas.Start(span, thresh);\n   vdas.m_right_align = as.m_right_align;\n\n   size_t  var_def_cnt = 0;\n   size_t  equ_count   = 0;\n   size_t  tmp;\n   chunk_t *pc = first;\n   while (pc != nullptr)\n   {\n      LOG_FMT(LALASS, \"%s(%d): orig_line is %zu, check pc->text() '%s'\\n\",\n              __func__, __LINE__, pc->orig_line, pc->text());\n      // Don't check inside PAREN or SQUARE groups\n      if (  pc->type == CT_SPAREN_OPEN\n         || pc->type == CT_FPAREN_OPEN\n         || pc->type == CT_SQUARE_OPEN\n         || pc->type == CT_PAREN_OPEN)\n      {\n         LOG_FMT(LALASS, \"%s(%d): Don't check inside PAREN or SQUARE groups, type is %s\\n\",\n                 __func__, __LINE__, get_token_name(pc->type));\n         tmp = pc->orig_line;\n         pc  = chunk_skip_to_match(pc);\n         if (pc != nullptr)\n         {\n            as.NewLines(pc->orig_line - tmp);\n            vdas.NewLines(pc->orig_line - tmp);\n         }\n         continue;\n      }\n\n      // Recurse if a brace set is found\n      if (pc->type == CT_BRACE_OPEN || pc->type == CT_VBRACE_OPEN)\n      {\n         size_t myspan;\n         size_t mythresh;\n\n         size_t sub_nl_count = 0;\n\n         if (pc->parent_type == CT_ENUM)\n         {\n            myspan   = cpd.settings[UO_align_enum_equ_span].u;\n            mythresh = cpd.settings[UO_align_enum_equ_thresh].u;\n         }\n         else\n         {\n            myspan   = cpd.settings[UO_align_assign_span].u;\n            mythresh = cpd.settings[UO_align_assign_thresh].u;\n         }\n\n         pc = align_assign(chunk_get_next_ncnl(pc), myspan, mythresh, &sub_nl_count);\n         if (sub_nl_count > 0)\n         {\n            as.NewLines(sub_nl_count);\n            vdas.NewLines(sub_nl_count);\n            if (p_nl_count != nullptr)\n            {\n               *p_nl_count += sub_nl_count;\n            }\n         }\n         continue;\n      }\n\n      // Done with this brace set?\n      if (pc->type == CT_BRACE_CLOSE || pc->type == CT_VBRACE_CLOSE)\n      {\n         pc = chunk_get_next(pc);\n         break;\n      }\n\n      if (chunk_is_newline(pc))\n      {\n         as.NewLines(pc->nl_count);\n         vdas.NewLines(pc->nl_count);\n         if (p_nl_count != nullptr)\n         {\n            *p_nl_count += pc->nl_count;\n         }\n\n         var_def_cnt = 0;\n         equ_count   = 0;\n      }\n      else if (pc->flags & PCF_VAR_DEF)\n      {\n         var_def_cnt++;\n      }\n      else if (var_def_cnt > 1)\n      {\n         // we hit the second variable def - don't look for assigns, don't align\n         vdas.Reset();\n      }\n      else if (  equ_count == 0\n              && pc->type == CT_ASSIGN\n              && ((pc->flags & PCF_IN_TEMPLATE) == 0))  // Issue #999\n      {\n         equ_count++;\n         if (var_def_cnt != 0)\n         {\n            vdas.Add(pc);\n         }\n         else\n         {\n            as.Add(pc);\n         }\n      }\n\n      pc = chunk_get_next(pc);\n   }\n\n   as.End();\n   vdas.End();\n\n   if (pc != nullptr)\n   {\n      LOG_FMT(LALASS, \"%s(%d): done on '%s' on orig_line %zu\\n\",\n              __func__, __LINE__, pc->text(), pc->orig_line);\n   }\n   else\n   {\n      LOG_FMT(LALASS, \"%s(%d): done on NULL\\n\", __func__, __LINE__);\n   }\n\n   return(pc);\n} // align_assign\n",
        "fix": null,
        "buggy_hunk_masked": "         || pc->type == CT_FPAREN_OPEN\n",
        "src_path": "059898e80d55dbe8d5c5eca6e6c1b10668553f92___align.cpp",
        "uri": "https://api.github.com/repos/uncrustify/uncrustify/commits/059898e80d55dbe8d5c5eca6e6c1b10668553f92",
        "commit_msg": "A bugfix proposal for #1340",
        "test_func_diff": [
            {
                "fn": "tests/config/bug_1340.cfg",
                "patch": "@@ -0,0 +1,6 @@\n+output_tab_size                 = 4\n+indent_columns                  = 4\n+indent_with_tabs                = 0\n+indent_align_string             = true\n+indent_cpp_lambda_body          = true\n+align_assign_span               = 1"
            },
            {
                "fn": "tests/cpp.test",
                "patch": "@@ -111,6 +111,8 @@\n 30209 empty.cfg                        cpp/bug_1134.cpp\n 30210 bug_1338.cfg                     cpp/bug_1338.cpp\n \n+30220 bug_1340.cfg                     cpp/bug_1340.cpp\n+\n 30240 align_func_params.cfg            cpp/align_func_params.cpp\n 30241 align_func_params_span.cfg       cpp/align_func_params.cpp\n 30242 align_func_params_gap.cfg        cpp/align_func_params.cpp"
            },
            {
                "fn": "tests/input/cpp/bug_1340.cpp",
                "patch": "@@ -0,0 +1,20 @@\n+double t               = 111; \n+double t1                         = 222; \n+double t123 = 333;\n+\n+\n+auto f = [](double x) -> double\n+         {\n+             double t                          = 1111;\n+             double t1              = 1222;\n+             double t123 = 1333;\n+         };\n+\n+\n+std::transform(v1.begin(), v1.end(), v2.begin(),\n+               [](double x) -> double\n+               {\n+                   double t = 2111;\n+                   double t1                       = 2222;\n+                   double t123            = 2333;\n+               }; );"
            },
            {
                "fn": "tests/output/cpp/30023-templates.cpp",
                "patch": "@@ -163,8 +163,8 @@ void g(X<>& x);\n typedef std::vector<std::vector<int> >    Table; // OK\n typedef std::vector<std::vector<bool> >   Flags; // Error\n \n-void func(List<B> =default_val1);\n-void func(List<List<B> > =default_val2);\n+void func(List<B>       =default_val1);\n+void func(List<List<B> >=default_val2);\n \n BLAH<(3.14 >= 42)> blah;\n bool               X = j<3> > 1;"
            },
            {
                "fn": "tests/output/cpp/30220-bug_1340.cpp",
                "patch": "@@ -0,0 +1,20 @@\n+double t    = 111;\n+double t1   = 222;\n+double t123 = 333;\n+\n+\n+auto f = [](double x) -> double\n+         {\n+             double t    = 1111;\n+             double t1   = 1222;\n+             double t123 = 1333;\n+         };\n+\n+\n+std::transform(v1.begin(), v1.end(), v2.begin(),\n+               [](double x) -> double\n+               {\n+                   double t    = 2111;\n+                   double t1   = 2222;\n+                   double t123 = 2333;\n+               }; );"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/uncrustify___uncrustify/git_repo_dir_059898e80d55dbe8d5c5eca6e6c1b10668553f92/build_059898e80d55dbe8d5c5eca6e6c1b10668553f92\nTest project /out/uncrustify___uncrustify/git_repo_dir_059898e80d55dbe8d5c5eca6e6c1b10668553f92/build_059898e80d55dbe8d5c5eca6e6c1b10668553f92\n    Start 283: cpp_30023\n1/2 Test #283: cpp_30023 ........................***Failed    0.06 sec\n    Start 350: cpp_30220\n2/2 Test #350: cpp_30220 ........................***Failed    0.02 sec\n\n0% tests passed, 2 tests failed out of 2\n\nLabel Time Summary:\ncpp    =   0.08 sec*proc (2 tests)\n\nTotal Test time (real) =   0.13 sec\n\nThe following tests FAILED:\n\t283 - cpp_30023 (Failed)\n\t350 - cpp_30220 (Failed)\n"
    },
    "ad5bb5198bae3e41beafc96a0a509725df0d3f79___meta.hpp": {
        "prefix": "    [[nodiscard]] static bool erase(void *container, meta_any key) {\n        bool ret = false;\n\n        if(const auto *k_ptr = key.try_cast<typename meta_associative_container_traits<Type>::key_type>(); k_ptr) {\n            ret = meta_associative_container_traits<Type>::erase(*static_cast<Type *>(container), *k_ptr);\n        }\n\n        return ret;\n    }\n\n    [[nodiscard]] static iterator find(void *container, meta_any key) {\n        iterator ret{};\n\n        if(const auto *k_ptr = key.try_cast<typename meta_associative_container_traits<Type>::key_type>(); k_ptr) {\n            ret = iterator{std::in_place_type<Type>, meta_associative_container_traits<Type>::find(*static_cast<Type *>(container), *k_ptr)};\n        }\n\n        return ret;\n    }\n};\n\n\n/**\n * @brief Construct a proxy object for associative containers.\n * @tparam Type Type of container to wrap.\n * @param container The container to wrap.\n */\ntemplate<typename Type>\nmeta_associative_container::meta_associative_container(Type &container)\n",
        "suffix": "      key_type_fn{&meta_associative_container_proxy<Type>::key_type},\n      mapped_type_fn{&meta_associative_container_proxy<Type>::mapped_type},\n      value_type_fn{&meta_associative_container_proxy<Type>::value_type},\n      size_fn{&meta_associative_container_proxy<Type>::size},\n      clear_fn{&meta_associative_container_proxy<Type>::clear},\n      begin_fn{&meta_associative_container_proxy<Type>::begin},\n      end_fn{&meta_associative_container_proxy<Type>::end},\n      insert_fn{&meta_associative_container_proxy<Type>::insert},\n      erase_fn{&meta_associative_container_proxy<Type>::erase},\n      find_fn{&meta_associative_container_proxy<Type>::find},\n      instance{&container}\n{}\n\n\n/*! @brief Default constructor. */\ninline meta_associative_container::meta_associative_container()\n    : key_only_container{false},\n      key_type_fn{nullptr},\n      mapped_type_fn{nullptr},\n      value_type_fn{nullptr},\n      size_fn{nullptr},\n      clear_fn{nullptr},\n      begin_fn{nullptr},\n      end_fn{nullptr},\n      insert_fn{nullptr},\n      erase_fn{nullptr},\n      find_fn{nullptr},\n      instance{nullptr}\n{}\n\n\n/**\n * @brief Returns true if the associative container is also key-only, false\n * otherwise.\n * @return True if the associative container is also key-only, false otherwise.\n */\n[[nodiscard]] inline bool meta_associative_container::key_only() const ENTT_NOEXCEPT {\n    return key_only_container;\n}\n\n\n/**\n * @brief Returns the key meta type of the wrapped container type.\n * @return The key meta type of the wrapped container type.\n */\n[[nodiscard]] inline meta_type meta_associative_container::key_type() const ENTT_NOEXCEPT {\n    return key_type_fn();\n}\n\n\n/**\n * @brief Returns the mapped meta type of the wrapped container type.\n * @return The mapped meta type of the wrapped container type.\n */\n[[nodiscard]] inline meta_type meta_associative_container::mapped_type() const ENTT_NOEXCEPT {\n    return mapped_type_fn();\n}\n\n\n/*! @copydoc meta_sequence_container::value_type */\n[[nodiscard]] inline meta_type meta_associative_container::value_type() const ENTT_NOEXCEPT {\n    return value_type_fn();\n}\n\n\n/*! @copydoc meta_sequence_container::size */\n[[nodiscard]] inline meta_associative_container::size_type meta_associative_container::size() const ENTT_NOEXCEPT {\n    return size_fn(instance);\n}\n\n\n/*! @copydoc meta_sequence_container::clear */\ninline bool meta_associative_container::clear() {\n    return clear_fn(instance);\n}\n\n\n/*! @copydoc meta_sequence_container::begin */\n[[nodiscard]] inline meta_associative_container::iterator meta_associative_container::begin() {\n    return begin_fn(instance);\n}\n\n\n/*! @copydoc meta_sequence_container::end */\n[[nodiscard]] inline meta_associative_container::iterator meta_associative_container::end() {\n    return end_fn(instance);\n}\n\n\n/**\n * @brief Inserts an element (a key/value pair) into the wrapped container.\n * @param key The key of the element to insert.\n * @param value The value of the element to insert.\n * @return A bool denoting whether the insertion took place.\n */\ninline bool meta_associative_container::insert(meta_any key, meta_any value = {}) {\n    return insert_fn(instance, key.ref(), value.ref());\n}\n\n\n/**\n * @brief Removes the specified element from the wrapped container.\n * @param key The key of the element to remove.\n * @return A bool denoting whether the removal took place.\n */\ninline bool meta_associative_container::erase(meta_any key) {\n    return erase_fn(instance, key.ref());\n}\n\n\n/**\n * @brief Returns an iterator to the element with key equivalent to a given\n * one, if any.\n * @param key The key of the element to search.\n * @return An iterator to the element with the given key, if any.\n */\n[[nodiscard]] inline meta_associative_container::iterator meta_associative_container::find(meta_any key) {\n    return find_fn(instance, key.ref());\n}\n\n\n/**\n * @brief Returns false if a proxy is invalid, true otherwise.\n * @return False if the proxy is invalid, true otherwise.\n */\n[[nodiscard]] inline meta_associative_container::operator bool() const ENTT_NOEXCEPT {\n    return (instance != nullptr);\n}\n\n\n}\n",
        "start": 1946,
        "end": 2106,
        "buggy": "    [[nodiscard]] static bool erase(void *container, meta_any key) {\n        bool ret = false;\n\n        if(const auto *k_ptr = key.try_cast<typename meta_associative_container_traits<Type>::key_type>(); k_ptr) {\n            ret = meta_associative_container_traits<Type>::erase(*static_cast<Type *>(container), *k_ptr);\n        }\n\n        return ret;\n    }\n\n    [[nodiscard]] static iterator find(void *container, meta_any key) {\n        iterator ret{};\n\n        if(const auto *k_ptr = key.try_cast<typename meta_associative_container_traits<Type>::key_type>(); k_ptr) {\n            ret = iterator{std::in_place_type<Type>, meta_associative_container_traits<Type>::find(*static_cast<Type *>(container), *k_ptr)};\n        }\n\n        return ret;\n    }\n};\n\n\n/**\n * @brief Construct a proxy object for associative containers.\n * @tparam Type Type of container to wrap.\n * @param container The container to wrap.\n */\ntemplate<typename Type>\nmeta_associative_container::meta_associative_container(Type &container)\n    : key_only_container{!is_key_only_meta_associative_container_v<Type>},\n      key_type_fn{&meta_associative_container_proxy<Type>::key_type},\n      mapped_type_fn{&meta_associative_container_proxy<Type>::mapped_type},\n      value_type_fn{&meta_associative_container_proxy<Type>::value_type},\n      size_fn{&meta_associative_container_proxy<Type>::size},\n      clear_fn{&meta_associative_container_proxy<Type>::clear},\n      begin_fn{&meta_associative_container_proxy<Type>::begin},\n      end_fn{&meta_associative_container_proxy<Type>::end},\n      insert_fn{&meta_associative_container_proxy<Type>::insert},\n      erase_fn{&meta_associative_container_proxy<Type>::erase},\n      find_fn{&meta_associative_container_proxy<Type>::find},\n      instance{&container}\n{}\n\n\n/*! @brief Default constructor. */\ninline meta_associative_container::meta_associative_container()\n    : key_only_container{false},\n      key_type_fn{nullptr},\n      mapped_type_fn{nullptr},\n      value_type_fn{nullptr},\n      size_fn{nullptr},\n      clear_fn{nullptr},\n      begin_fn{nullptr},\n      end_fn{nullptr},\n      insert_fn{nullptr},\n      erase_fn{nullptr},\n      find_fn{nullptr},\n      instance{nullptr}\n{}\n\n\n/**\n * @brief Returns true if the associative container is also key-only, false\n * otherwise.\n * @return True if the associative container is also key-only, false otherwise.\n */\n[[nodiscard]] inline bool meta_associative_container::key_only() const ENTT_NOEXCEPT {\n    return key_only_container;\n}\n\n\n/**\n * @brief Returns the key meta type of the wrapped container type.\n * @return The key meta type of the wrapped container type.\n */\n[[nodiscard]] inline meta_type meta_associative_container::key_type() const ENTT_NOEXCEPT {\n    return key_type_fn();\n}\n\n\n/**\n * @brief Returns the mapped meta type of the wrapped container type.\n * @return The mapped meta type of the wrapped container type.\n */\n[[nodiscard]] inline meta_type meta_associative_container::mapped_type() const ENTT_NOEXCEPT {\n    return mapped_type_fn();\n}\n\n\n/*! @copydoc meta_sequence_container::value_type */\n[[nodiscard]] inline meta_type meta_associative_container::value_type() const ENTT_NOEXCEPT {\n    return value_type_fn();\n}\n\n\n/*! @copydoc meta_sequence_container::size */\n[[nodiscard]] inline meta_associative_container::size_type meta_associative_container::size() const ENTT_NOEXCEPT {\n    return size_fn(instance);\n}\n\n\n/*! @copydoc meta_sequence_container::clear */\ninline bool meta_associative_container::clear() {\n    return clear_fn(instance);\n}\n\n\n/*! @copydoc meta_sequence_container::begin */\n[[nodiscard]] inline meta_associative_container::iterator meta_associative_container::begin() {\n    return begin_fn(instance);\n}\n\n\n/*! @copydoc meta_sequence_container::end */\n[[nodiscard]] inline meta_associative_container::iterator meta_associative_container::end() {\n    return end_fn(instance);\n}\n\n\n/**\n * @brief Inserts an element (a key/value pair) into the wrapped container.\n * @param key The key of the element to insert.\n * @param value The value of the element to insert.\n * @return A bool denoting whether the insertion took place.\n */\ninline bool meta_associative_container::insert(meta_any key, meta_any value = {}) {\n    return insert_fn(instance, key.ref(), value.ref());\n}\n\n\n/**\n * @brief Removes the specified element from the wrapped container.\n * @param key The key of the element to remove.\n * @return A bool denoting whether the removal took place.\n */\ninline bool meta_associative_container::erase(meta_any key) {\n    return erase_fn(instance, key.ref());\n}\n\n\n/**\n * @brief Returns an iterator to the element with key equivalent to a given\n * one, if any.\n * @param key The key of the element to search.\n * @return An iterator to the element with the given key, if any.\n */\n[[nodiscard]] inline meta_associative_container::iterator meta_associative_container::find(meta_any key) {\n    return find_fn(instance, key.ref());\n}\n\n\n/**\n * @brief Returns false if a proxy is invalid, true otherwise.\n * @return False if the proxy is invalid, true otherwise.\n */\n[[nodiscard]] inline meta_associative_container::operator bool() const ENTT_NOEXCEPT {\n    return (instance != nullptr);\n}\n\n\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    : key_only_container{!is_key_only_meta_associative_container_v<Type>},\n",
        "src_path": "ad5bb5198bae3e41beafc96a0a509725df0d3f79___meta.hpp",
        "uri": "https://api.github.com/repos/skypjack/entt/commits/ad5bb5198bae3e41beafc96a0a509725df0d3f79",
        "commit_msg": "meta: fixed key_only member function for meta associative containers",
        "test_func_diff": [
            {
                "fn": "test/entt/meta/meta_container.cpp",
                "patch": "@@ -145,6 +145,7 @@ TEST(MetaAssociativeContainer, StdMap) {\n     auto view = any.as_associative_container();\n \n     ASSERT_TRUE(view);\n+    ASSERT_FALSE(view.key_only());\n     ASSERT_EQ(view.key_type(), entt::resolve<int>());\n     ASSERT_EQ(view.mapped_type(), entt::resolve<char>());\n     ASSERT_EQ(view.value_type(), (entt::resolve<std::pair<const int, char>>()));\n@@ -196,6 +197,7 @@ TEST(MetaAssociativeContainer, StdSet) {\n     auto view = any.as_associative_container();\n \n     ASSERT_TRUE(view);\n+    ASSERT_TRUE(view.key_only());\n     ASSERT_EQ(view.key_type(), entt::resolve<int>());\n     ASSERT_EQ(view.mapped_type(), entt::meta_type{});\n     ASSERT_EQ(view.value_type(), entt::resolve<int>());"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/skypjack___entt/git_repo_dir_ad5bb5198bae3e41beafc96a0a509725df0d3f79/build_ad5bb5198bae3e41beafc96a0a509725df0d3f79\nTest project /out/skypjack___entt/git_repo_dir_ad5bb5198bae3e41beafc96a0a509725df0d3f79/build_ad5bb5198bae3e41beafc96a0a509725df0d3f79\n    Start 23: meta_container\n1/1 Test #23: meta_container ...................***Failed    0.05 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.06 sec\n\nThe following tests FAILED:\n\t 23 - meta_container (Failed)\n"
    },
    "e3b8f31b044e4fe7d47439467fc1622266b5335c___nn.c": {
        "prefix": "int\nnn_setsockopt(int s, int nnlevel, int nnopt, const void *valp, size_t sz)\n{\n\tconst char *name                             = NULL;\n\tint (*set)(nng_socket, const void *, size_t) = NULL;\n\tint rv;\n\n\tfor (unsigned i = 0; i < sizeof(options) / sizeof(options[0]); i++) {\n\t\tif ((options[i].nnlevel == nnlevel) &&\n\t\t    (options[i].nnopt == nnopt)) {\n\n\t\t\tset  = options[i].set;\n\t\t\tname = options[i].opt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set != NULL) {\n\t\treturn (set((nng_socket) s, valp, sz));\n\t}\n\n\tif (name == NULL) {\n",
        "suffix": "\t}\n\n\tif ((rv = nng_setopt((nng_socket) s, name, valp, sz)) != 0) {\n\t\tnn_seterror(rv);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n",
        "start": 816,
        "end": 846,
        "buggy": "int\nnn_setsockopt(int s, int nnlevel, int nnopt, const void *valp, size_t sz)\n{\n\tconst char *name                             = NULL;\n\tint (*set)(nng_socket, const void *, size_t) = NULL;\n\tint rv;\n\n\tfor (unsigned i = 0; i < sizeof(options) / sizeof(options[0]); i++) {\n\t\tif ((options[i].nnlevel == nnlevel) &&\n\t\t    (options[i].nnopt == nnopt)) {\n\n\t\t\tset  = options[i].set;\n\t\t\tname = options[i].opt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set != NULL) {\n\t\treturn (set((nng_socket) s, valp, sz));\n\t}\n\n\tif (name == NULL) {\n\t\treturn (ENOPROTOOPT);\n\t}\n\n\tif ((rv = nng_setopt((nng_socket) s, name, valp, sz)) != 0) {\n\t\tnn_seterror(rv);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\treturn (ENOPROTOOPT);\n",
        "src_path": "e3b8f31b044e4fe7d47439467fc1622266b5335c___nn.c",
        "uri": "https://api.github.com/repos/nanomsg/nng/commits/e3b8f31b044e4fe7d47439467fc1622266b5335c",
        "commit_msg": "fixes #350 Incorrect compat error code from nn_setsockopt",
        "test_func_diff": [
            {
                "fn": "tests/CMakeLists.txt",
                "patch": "@@ -187,5 +187,9 @@ add_nng_compat_test(compat_survey 5)\n add_nng_compat_test(compat_reqttl 5)\n add_nng_compat_test(compat_shutdown 5)\n \n+# These are special tests for compat mode, not inherited from the\n+# legacy libnanomsg suite.\n+add_nng_test(compat_options 5 NNG_PROTO_REP0)\n+\n # c++ tests\n add_nng_cpp_test(cplusplus_pair 5)"
            },
            {
                "fn": "tests/compat_options.c",
                "patch": "@@ -0,0 +1,57 @@\n+//\n+// Copyright 2018 Staysail Systems, Inc. <info@staysail.tech>\n+// Copyright 2018 Capitar IT Group BV <info@capitar.com>\n+//\n+// This software is supplied under the terms of the MIT License, a\n+// copy of which should be located in the distribution where this\n+// file was obtained (LICENSE.txt).  A copy of the license may also be\n+// found online at https://opensource.org/licenses/MIT.\n+//\n+\n+#include \"convey.h\"\n+\n+#include \"compat/nanomsg/nn.h\"\n+\n+#include \"compat_testutil.h\"\n+\n+#include <string.h>\n+\n+#define SECONDS(x) ((x) *1000)\n+\n+TestMain(\"Compatible Options\", {\n+\n+\tatexit(nn_term);\n+\n+\tConvey(\"Given a compat NN_REP socket\", {\n+\t\tint repsock;\n+\n+\t\tSo((repsock = nn_socket(AF_SP, NN_REP)) != -1);\n+\t\tReset({ nn_close(repsock); });\n+\n+\t\tConvey(\"NN_DOMAIN works\", {\n+\t\t\tint    dom = 4321;\n+\t\t\tsize_t sz;\n+\t\t\tsz = sizeof(dom);\n+\t\t\tSo(nn_getsockopt(repsock, NN_SOL_SOCKET, NN_DOMAIN,\n+\t\t\t       &dom, &sz) == 0);\n+\t\t\tSo(sz == sizeof(dom));\n+\t\t\tSo(dom == AF_SP);\n+\n+\t\t\tSo(nn_setsockopt(repsock, NN_SOL_SOCKET, NN_DOMAIN,\n+\t\t\t       &dom, sz) == -1);\n+\t\t\tSo(nn_errno() == ENOPROTOOPT);\n+\t\t});\n+\t\tConvey(\"NN_LINGER has no effect\", {\n+\t\t\tint    l = 4321;\n+\t\t\tsize_t sz;\n+\t\t\tsz = sizeof(l);\n+\t\t\tSo(nn_setsockopt(repsock, NN_SOL_SOCKET, NN_LINGER, &l,\n+\t\t\t       sz) == 0);\n+\n+\t\t\tSo(nn_getsockopt(repsock, NN_SOL_SOCKET, NN_LINGER, &l,\n+\t\t\t       &sz) == 0);\n+\t\t\tSo(sz == sizeof(l));\n+\t\t\tSo(l == 0);\n+\t\t});\n+\t});\n+})"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/nanomsg___nng/git_repo_dir_e3b8f31b044e4fe7d47439467fc1622266b5335c/build_e3b8f31b044e4fe7d47439467fc1622266b5335c\nUpdateCTestConfiguration  from :/out/nanomsg___nng/git_repo_dir_e3b8f31b044e4fe7d47439467fc1622266b5335c/build_e3b8f31b044e4fe7d47439467fc1622266b5335c/DartConfiguration.tcl\nUpdateCTestConfiguration  from :/out/nanomsg___nng/git_repo_dir_e3b8f31b044e4fe7d47439467fc1622266b5335c/build_e3b8f31b044e4fe7d47439467fc1622266b5335c/DartConfiguration.tcl\nTest project /out/nanomsg___nng/git_repo_dir_e3b8f31b044e4fe7d47439467fc1622266b5335c/build_e3b8f31b044e4fe7d47439467fc1622266b5335c\nConstructing a list of tests\nDone constructing a list of tests\nUpdating test list for fixtures\nAdded 0 tests to meet fixture requirements\nChecking test dependency graph...\nChecking test dependency graph end\ntest 8\n    Start  8: httpserver\n\n8: Test command: /out/nanomsg___nng/git_repo_dir_e3b8f31b044e4fe7d47439467fc1622266b5335c/build_e3b8f31b044e4fe7d47439467fc1622266b5335c/tests/httpserver \"-v\" \"-p\" \"TEST_PORT=12220\"\n8: Working Directory: /out/nanomsg___nng/git_repo_dir_e3b8f31b044e4fe7d47439467fc1622266b5335c/build_e3b8f31b044e4fe7d47439467fc1622266b5335c/tests\n8: Test timeout computed to be: 30\n8: === RUN: HTTP Server\n8: \n8:   We can start an HTTP server \u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\n8:     We can connect a client to it \u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\n8:       404 works \u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\n8:       Valid data works \u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\n8:   Directory serving works \u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m"
    },
    "111b241473ceeecee1f1c232d3c9879fb850361d___message.c": {
        "prefix": "static int\nnni_chunk_insert(nni_chunk *ch, const void *data, size_t len)\n{\n\tint rv;\n\n\tif (ch->ch_ptr == NULL) {\n\t\tch->ch_ptr = ch->ch_buf;\n\t}\n\n\tif ((ch->ch_ptr >= ch->ch_buf) &&\n\t    (ch->ch_ptr < (ch->ch_buf + ch->ch_cap)) &&\n\t    (len <= (size_t)(ch->ch_ptr - ch->ch_buf))) {\n\t\t// There is already enough room at the beginning.\n\t\tch->ch_ptr -= len;\n\t} else if ((ch->ch_len + len) <= ch->ch_cap) {\n\t\t// We had enough capacity, just shuffle data down.\n",
        "suffix": "\t} else if ((rv = nni_chunk_grow(ch, 0, len)) == 0) {\n\t\t// We grew the chunk, so adjust.\n\t\tch->ch_ptr -= len;\n\t} else {\n\t\t// Couldn't grow the chunk either.  Error.\n\t\treturn (rv);\n\t}\n\n\tch->ch_len += len;\n\tif (data != NULL) {\n\t\tmemcpy(ch->ch_ptr, data, len);\n\t}\n\n\treturn (0);\n}\n",
        "start": 260,
        "end": 291,
        "buggy": "static int\nnni_chunk_insert(nni_chunk *ch, const void *data, size_t len)\n{\n\tint rv;\n\n\tif (ch->ch_ptr == NULL) {\n\t\tch->ch_ptr = ch->ch_buf;\n\t}\n\n\tif ((ch->ch_ptr >= ch->ch_buf) &&\n\t    (ch->ch_ptr < (ch->ch_buf + ch->ch_cap)) &&\n\t    (len <= (size_t)(ch->ch_ptr - ch->ch_buf))) {\n\t\t// There is already enough room at the beginning.\n\t\tch->ch_ptr -= len;\n\t} else if ((ch->ch_len + len) <= ch->ch_cap) {\n\t\t// We had enough capacity, just shuffle data down.\n\t\tmemmove(ch->ch_ptr + len, ch->ch_ptr, ch->ch_len);\n\t} else if ((rv = nni_chunk_grow(ch, 0, len)) == 0) {\n\t\t// We grew the chunk, so adjust.\n\t\tch->ch_ptr -= len;\n\t} else {\n\t\t// Couldn't grow the chunk either.  Error.\n\t\treturn (rv);\n\t}\n\n\tch->ch_len += len;\n\tif (data != NULL) {\n\t\tmemcpy(ch->ch_ptr, data, len);\n\t}\n\n\treturn (0);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\tmemmove(ch->ch_ptr + len, ch->ch_ptr, ch->ch_len);\n",
        "src_path": "111b241473ceeecee1f1c232d3c9879fb850361d___message.c",
        "uri": "https://api.github.com/repos/nanomsg/nng/commits/111b241473ceeecee1f1c232d3c9879fb850361d",
        "commit_msg": "fixes #1541 bug in nni_chunk_insert",
        "test_func_diff": [
            {
                "fn": "src/core/message_test.c",
                "patch": "@@ -62,8 +62,9 @@ test_msg_insert_body(void)\n \tNUTS_PASS(nng_msg_alloc(&msg, 0));\n \tNUTS_PASS(nng_msg_append(msg, \"xyz\", 4));\n \tNUTS_PASS(nng_msg_insert(msg, \"uvw\", 3));\n-\tNUTS_ASSERT(nng_msg_len(msg) == 7);\n-\tNUTS_ASSERT(strcmp(nng_msg_body(msg), \"uvwxyz\") == 0);\n+\tNUTS_PASS(nng_msg_insert(msg, \"st\", 2));\n+\tNUTS_ASSERT(nng_msg_len(msg) == 9);\n+\tNUTS_ASSERT(strcmp(nng_msg_body(msg), \"stuvwxyz\") == 0);\n \tnng_msg_free(msg);\n }\n "
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/nanomsg___nng/git_repo_dir_111b241473ceeecee1f1c232d3c9879fb850361d/build_111b241473ceeecee1f1c232d3c9879fb850361d\nTest project /out/nanomsg___nng/git_repo_dir_111b241473ceeecee1f1c232d3c9879fb850361d/build_111b241473ceeecee1f1c232d3c9879fb850361d\n    Start 60: nng.pipe\n1/1 Test #60: nng.pipe .........................   Passed    0.33 sec\n\n100% tests passed, 0 tests failed out of 1\n\nTotal Test time (real) =   0.34 sec\n"
    },
    "6a1346405949ca1cf5befc5e83c6c66c86e4f9d1___core.h": {
        "prefix": "  FMT_CONSTEXPR void on_sign(sign_t s) {\n    require_numeric_argument();\n    if (is_integral_type(arg_type_) && arg_type_ != type::int_type &&\n",
        "suffix": "      this->on_error(\"format specifier requires signed argument\");\n    }\n    Handler::on_sign(s);\n  }\n",
        "start": 2819,
        "end": 2826,
        "buggy": "  FMT_CONSTEXPR void on_sign(sign_t s) {\n    require_numeric_argument();\n    if (is_integral_type(arg_type_) && arg_type_ != type::int_type &&\n        arg_type_ != type::long_long_type && arg_type_ != type::char_type) {\n      this->on_error(\"format specifier requires signed argument\");\n    }\n    Handler::on_sign(s);\n  }\n",
        "fix": null,
        "buggy_hunk_masked": "        arg_type_ != type::long_long_type && arg_type_ != type::char_type) {\n",
        "src_path": "6a1346405949ca1cf5befc5e83c6c66c86e4f9d1___core.h",
        "uri": "https://api.github.com/repos/fmtlib/fmt/commits/6a1346405949ca1cf5befc5e83c6c66c86e4f9d1",
        "commit_msg": "Include 128-bit with other signed integers in specifier check",
        "test_func_diff": [
            {
                "fn": "test/format-test.cc",
                "patch": "@@ -570,6 +570,9 @@ TEST(format_test, plus_sign) {\n   EXPECT_THROW_MSG((void)fmt::format(runtime(\"{0:+}\"), 42ul), format_error,\n                    \"format specifier requires signed argument\");\n   EXPECT_EQ(\"+42\", fmt::format(\"{0:+}\", 42ll));\n+#if FMT_USE_INT128\n+  EXPECT_EQ(\"+42\", fmt::format(\"{0:+}\", __int128_t(42)));\n+#endif\n   EXPECT_THROW_MSG((void)fmt::format(runtime(\"{0:+}\"), 42ull), format_error,\n                    \"format specifier requires signed argument\");\n   EXPECT_EQ(\"+42\", fmt::format(\"{0:+}\", 42.0));"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_6a1346405949ca1cf5befc5e83c6c66c86e4f9d1/build_6a1346405949ca1cf5befc5e83c6c66c86e4f9d1\nTest project /out/fmtlib___fmt/git_repo_dir_6a1346405949ca1cf5befc5e83c6c66c86e4f9d1/build_6a1346405949ca1cf5befc5e83c6c66c86e4f9d1\n    Start 7: format-test\n1/1 Test #7: format-test ......................***Failed    0.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.02 sec\n\nThe following tests FAILED:\n\t  7 - format-test (Failed)\n"
    },
    "611cf0b3c644d33b9d347b824bf06bd594bfa564___format.h": {
        "prefix": "    void on_oct() {\n      int num_digits = internal::count_digits<3>(abs_value);\n",
        "suffix": "        // Octal prefix '0' is counted as a digit, so only add it if precision\n        // is not greater than the number of digits.\n        prefix[prefix_size++] = '0';\n      }\n      writer.write_int(num_digits, get_prefix(), specs,\n                       bin_writer<3>{abs_value, num_digits});\n    }\n",
        "start": 1442,
        "end": 1451,
        "buggy": "    void on_oct() {\n      int num_digits = internal::count_digits<3>(abs_value);\n      if (specs.alt && specs.precision <= num_digits) {\n        // Octal prefix '0' is counted as a digit, so only add it if precision\n        // is not greater than the number of digits.\n        prefix[prefix_size++] = '0';\n      }\n      writer.write_int(num_digits, get_prefix(), specs,\n                       bin_writer<3>{abs_value, num_digits});\n    }\n",
        "fix": null,
        "buggy_hunk_masked": "      if (specs.alt && specs.precision <= num_digits) {\n",
        "src_path": "611cf0b3c644d33b9d347b824bf06bd594bfa564___format.h",
        "uri": "https://api.github.com/repos/fmtlib/fmt/commits/611cf0b3c644d33b9d347b824bf06bd594bfa564",
        "commit_msg": "Format octal 0 as 0",
        "test_func_diff": [
            {
                "fn": "test/format-test.cc",
                "patch": "@@ -1001,6 +1001,7 @@ TEST(FormatterTest, HashFlag) {\n   EXPECT_EQ(\"0x42\", format(\"{0:#x}\", 0x42));\n   EXPECT_EQ(\"0X42\", format(\"{0:#X}\", 0x42));\n   EXPECT_EQ(\"-0x42\", format(\"{0:#x}\", -0x42));\n+  EXPECT_EQ(\"0\", format(\"{0:#o}\", 0));\n   EXPECT_EQ(\"042\", format(\"{0:#o}\", 042));\n   EXPECT_EQ(\"-042\", format(\"{0:#o}\", -042));\n   EXPECT_EQ(\"42\", format(\"{0:#}\", 42u));"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_611cf0b3c644d33b9d347b824bf06bd594bfa564/build_611cf0b3c644d33b9d347b824bf06bd594bfa564\nTest project /out/fmtlib___fmt/git_repo_dir_611cf0b3c644d33b9d347b824bf06bd594bfa564/build_611cf0b3c644d33b9d347b824bf06bd594bfa564\n    Start 7: format-test\n1/1 Test #7: format-test ......................***Failed    0.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.02 sec\n\nThe following tests FAILED:\n\t  7 - format-test (Failed)\n"
    },
    "0cc73ebf79ec39ba74f3d31a76c0acb2df824908___core.h": {
        "prefix": "template <typename Context> class basic_format_args {\n public:\n  using size_type = int;\n  using format_arg = basic_format_arg<Context>;\n\n private:\n  // A descriptor that contains information about formatting arguments.\n  // If the number of arguments is less or equal to max_packed_args then\n  // argument types are passed in the descriptor. This reduces binary code size\n  // per formatting function call.\n  unsigned long long desc_;\n  union {\n    // If is_packed() returns true then argument values are stored in values_;\n    // otherwise they are stored in args_. This is done to improve cache\n    // locality and reduce compiled code size since storing larger objects\n    // may require more code (at least on x86-64) even if the same amount of\n    // data is actually copied to stack. It saves ~10% on the bloat test.\n    const detail::value<Context>* values_;\n    const format_arg* args_;\n  };\n\n  bool is_packed() const { return (desc_ & detail::is_unpacked_bit) == 0; }\n  bool has_named_args() const {\n    return (desc_ & detail::has_named_args_bit) != 0;\n  }\n\n  detail::type type(int index) const {\n    int shift = index * detail::packed_arg_bits;\n    unsigned int mask = (1 << detail::packed_arg_bits) - 1;\n    return static_cast<detail::type>((desc_ >> shift) & mask);\n  }\n\n  basic_format_args(unsigned long long desc,\n                    const detail::value<Context>* values)\n      : desc_(desc), values_(values) {}\n  basic_format_args(unsigned long long desc, const format_arg* args)\n      : desc_(desc), args_(args) {}\n\n public:\n  basic_format_args() : desc_(0) {}\n\n  /**\n   \\rst\n   Constructs a `basic_format_args` object from `~fmt::format_arg_store`.\n   \\endrst\n   */\n  template <typename... Args>\n  FMT_INLINE basic_format_args(const format_arg_store<Context, Args...>& store)\n      : basic_format_args(store.desc, store.data_.args()) {}\n\n  /**\n   \\rst\n   Constructs a `basic_format_args` object from\n   `~fmt::dynamic_format_arg_store`.\n   \\endrst\n   */\n  FMT_INLINE basic_format_args(const dynamic_format_arg_store<Context>& store)\n      : basic_format_args(store.get_types(), store.data()) {}\n\n  /**\n   \\rst\n   Constructs a `basic_format_args` object from a dynamic set of arguments.\n   \\endrst\n   */\n  basic_format_args(const format_arg* args, int count)\n      : basic_format_args(detail::is_unpacked_bit | detail::to_unsigned(count),\n                          args) {}\n\n  /** Returns the argument with the specified id. */\n  format_arg get(int id) const {\n    format_arg arg;\n    if (!is_packed()) {\n      if (id < max_size()) arg = args_[id];\n      return arg;\n    }\n    if (id >= detail::max_packed_args) return arg;\n    arg.type_ = type(id);\n    if (arg.type_ == detail::type::none_type) return arg;\n    arg.value_ = values_[id];\n    return arg;\n  }\n\n  template <typename Char> format_arg get(basic_string_view<Char> name) const {\n    int id = get_id(name);\n    return id >= 0 ? get(id) : format_arg();\n  }\n\n  template <typename Char> int get_id(basic_string_view<Char> name) const {\n",
        "suffix": "    const auto& named_args =\n        (is_packed() ? values_[-1] : args_[-1].value_).named_args;\n    for (size_t i = 0; i < named_args.size; ++i) {\n      if (named_args.data[i].name == name) return named_args.data[i].id;\n    }\n    return -1;\n  }\n\n  int max_size() const {\n    unsigned long long max_packed = detail::max_packed_args;\n    return static_cast<int>(is_packed() ? max_packed\n                                        : desc_ & ~detail::is_unpacked_bit);\n  }\n};\n\n/** An alias to ``basic_format_args<context>``. */\n// It is a separate type rather than an alias to make symbols readable.\nstruct format_args : basic_format_args<format_context> {\n  template <typename... Args>\n  FMT_INLINE format_args(const Args&... args) : basic_format_args(args...) {}\n};\n",
        "start": 1628,
        "end": 1737,
        "buggy": "template <typename Context> class basic_format_args {\n public:\n  using size_type = int;\n  using format_arg = basic_format_arg<Context>;\n\n private:\n  // A descriptor that contains information about formatting arguments.\n  // If the number of arguments is less or equal to max_packed_args then\n  // argument types are passed in the descriptor. This reduces binary code size\n  // per formatting function call.\n  unsigned long long desc_;\n  union {\n    // If is_packed() returns true then argument values are stored in values_;\n    // otherwise they are stored in args_. This is done to improve cache\n    // locality and reduce compiled code size since storing larger objects\n    // may require more code (at least on x86-64) even if the same amount of\n    // data is actually copied to stack. It saves ~10% on the bloat test.\n    const detail::value<Context>* values_;\n    const format_arg* args_;\n  };\n\n  bool is_packed() const { return (desc_ & detail::is_unpacked_bit) == 0; }\n  bool has_named_args() const {\n    return (desc_ & detail::has_named_args_bit) != 0;\n  }\n\n  detail::type type(int index) const {\n    int shift = index * detail::packed_arg_bits;\n    unsigned int mask = (1 << detail::packed_arg_bits) - 1;\n    return static_cast<detail::type>((desc_ >> shift) & mask);\n  }\n\n  basic_format_args(unsigned long long desc,\n                    const detail::value<Context>* values)\n      : desc_(desc), values_(values) {}\n  basic_format_args(unsigned long long desc, const format_arg* args)\n      : desc_(desc), args_(args) {}\n\n public:\n  basic_format_args() : desc_(0) {}\n\n  /**\n   \\rst\n   Constructs a `basic_format_args` object from `~fmt::format_arg_store`.\n   \\endrst\n   */\n  template <typename... Args>\n  FMT_INLINE basic_format_args(const format_arg_store<Context, Args...>& store)\n      : basic_format_args(store.desc, store.data_.args()) {}\n\n  /**\n   \\rst\n   Constructs a `basic_format_args` object from\n   `~fmt::dynamic_format_arg_store`.\n   \\endrst\n   */\n  FMT_INLINE basic_format_args(const dynamic_format_arg_store<Context>& store)\n      : basic_format_args(store.get_types(), store.data()) {}\n\n  /**\n   \\rst\n   Constructs a `basic_format_args` object from a dynamic set of arguments.\n   \\endrst\n   */\n  basic_format_args(const format_arg* args, int count)\n      : basic_format_args(detail::is_unpacked_bit | detail::to_unsigned(count),\n                          args) {}\n\n  /** Returns the argument with the specified id. */\n  format_arg get(int id) const {\n    format_arg arg;\n    if (!is_packed()) {\n      if (id < max_size()) arg = args_[id];\n      return arg;\n    }\n    if (id >= detail::max_packed_args) return arg;\n    arg.type_ = type(id);\n    if (arg.type_ == detail::type::none_type) return arg;\n    arg.value_ = values_[id];\n    return arg;\n  }\n\n  template <typename Char> format_arg get(basic_string_view<Char> name) const {\n    int id = get_id(name);\n    return id >= 0 ? get(id) : format_arg();\n  }\n\n  template <typename Char> int get_id(basic_string_view<Char> name) const {\n    if (!has_named_args()) return {};\n    const auto& named_args =\n        (is_packed() ? values_[-1] : args_[-1].value_).named_args;\n    for (size_t i = 0; i < named_args.size; ++i) {\n      if (named_args.data[i].name == name) return named_args.data[i].id;\n    }\n    return -1;\n  }\n\n  int max_size() const {\n    unsigned long long max_packed = detail::max_packed_args;\n    return static_cast<int>(is_packed() ? max_packed\n                                        : desc_ & ~detail::is_unpacked_bit);\n  }\n};\n\n/** An alias to ``basic_format_args<context>``. */\n// It is a separate type rather than an alias to make symbols readable.\nstruct format_args : basic_format_args<format_context> {\n  template <typename... Args>\n  FMT_INLINE format_args(const Args&... args) : basic_format_args(args...) {}\n};\n",
        "fix": null,
        "buggy_hunk_masked": "    if (!has_named_args()) return {};\n",
        "src_path": "0cc73ebf79ec39ba74f3d31a76c0acb2df824908___core.h",
        "uri": "https://api.github.com/repos/fmtlib/fmt/commits/0cc73ebf79ec39ba74f3d31a76c0acb2df824908",
        "commit_msg": "Report error on missing named argument (#1796)",
        "test_func_diff": [
            {
                "fn": "test/format-test.cc",
                "patch": "@@ -543,7 +543,6 @@ TEST(FormatterTest, ManyArgs) {\n TEST(FormatterTest, NamedArg) {\n   EXPECT_EQ(\"1/a/A\", format(\"{_1}/{a_}/{A_}\", fmt::arg(\"a_\", 'a'),\n                             fmt::arg(\"A_\", \"A\"), fmt::arg(\"_1\", 1)));\n-  EXPECT_THROW_MSG(format(\"{a}\"), format_error, \"argument not found\");\n   EXPECT_EQ(\" -42\", format(\"{0:{width}}\", -42, fmt::arg(\"width\", 4)));\n   EXPECT_EQ(\"st\", format(\"{0:.{precision}}\", \"str\", fmt::arg(\"precision\", 2)));\n   EXPECT_EQ(\"1 2\", format(\"{} {two}\", 1, fmt::arg(\"two\", 2)));\n@@ -553,6 +552,8 @@ TEST(FormatterTest, NamedArg) {\n                          fmt::arg(\"i\", 0), fmt::arg(\"j\", 0), fmt::arg(\"k\", 0),\n                          fmt::arg(\"l\", 0), fmt::arg(\"m\", 0), fmt::arg(\"n\", 0),\n                          fmt::arg(\"o\", 0), fmt::arg(\"p\", 0)));\n+  EXPECT_THROW_MSG(format(\"{a}\"), format_error, \"argument not found\");\n+  EXPECT_THROW_MSG(format(\"{a}\", 42), format_error, \"argument not found\");\n }\n \n TEST(FormatterTest, AutoArgIndex) {"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_0cc73ebf79ec39ba74f3d31a76c0acb2df824908/build_0cc73ebf79ec39ba74f3d31a76c0acb2df824908\nTest project /out/fmtlib___fmt/git_repo_dir_0cc73ebf79ec39ba74f3d31a76c0acb2df824908/build_0cc73ebf79ec39ba74f3d31a76c0acb2df824908\n    Start 7: format-test\n1/1 Test #7: format-test ......................***Failed    0.03 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.03 sec\n\nThe following tests FAILED:\n\t  7 - format-test (Failed)\n"
    },
    "fc6e0fe992156935bfb66bb2121c62ee8446758e___format.h": {
        "prefix": "void basic_writer<Range>::write_double(T value, const format_specs &spec) {\n  // Check type.\n  float_spec_handler<char_type> handler(spec.type());\n  internal::handle_float_type_spec(spec.type(), handler);\n\n  char sign = 0;\n  // Use isnegative instead of value < 0 because the latter is always\n  // false for NaN.\n  if (internal::fputil::isnegative(static_cast<double>(value))) {\n    sign = '-';\n    value = -value;\n  } else if (spec.flag(SIGN_FLAG)) {\n    sign = spec.flag(PLUS_FLAG) ? '+' : ' ';\n  }\n\n  struct write_inf_or_nan_t {\n    basic_writer &writer;\n    format_specs spec;\n    char sign;\n    void operator()(const char *str) const {\n      writer.write_padded(INF_SIZE + (sign ? 1 : 0), spec,\n                          inf_or_nan_writer{sign, str});\n    }\n  } write_inf_or_nan = {*this, spec, sign};\n\n  // Format NaN and ininity ourselves because sprintf's output is not consistent\n  // across platforms.\n  if (internal::fputil::isnotanumber(value))\n    return write_inf_or_nan(handler.upper ? \"NAN\" : \"nan\");\n  if (internal::fputil::isinfinity(value))\n    return write_inf_or_nan(handler.upper ? \"INF\" : \"inf\");\n\n  basic_memory_buffer<char_type> buffer;\n  if (FMT_USE_GRISU && sizeof(T) <= sizeof(double) &&\n      std::numeric_limits<double>::is_iec559) {\n    internal::fp fp_value(static_cast<double>(value));\n    fp_value.normalize();\n    // Find a cached power of 10 close to 1 / fp_value.\n    int dec_exp = 0;\n    const int min_exp = -60;\n    auto dec_pow = internal::get_cached_power(\n        min_exp - (fp_value.e + internal::fp::significand_size), dec_exp);\n    internal::fp product = fp_value * dec_pow;\n    // Generate output.\n    internal::fp one(1ull << -product.e, product.e);\n    uint64_t hi = product.f >> -one.e;\n    uint64_t f = product.f & (one.f - 1);\n    typedef back_insert_range<internal::basic_buffer<char_type>> range;\n    basic_writer<range> w{range(buffer)};\n    w.write(hi);\n    size_t digits = buffer.size();\n    w.write('.');\n    const unsigned max_digits = 18;\n    while (digits++ < max_digits) {\n      f *= 10;\n      w.write(static_cast<char>('0' + (f >> -one.e)));\n      f &= one.f - 1;\n    }\n    w.write('e');\n    w.write(-dec_exp);\n  } else {\n    format_specs normalized_spec(spec);\n    normalized_spec.type_ = handler.type;\n    write_double_sprintf(value, normalized_spec, buffer);\n  }\n  size_t n = buffer.size();\n  align_spec as = spec;\n  if (spec.align() == ALIGN_NUMERIC) {\n    if (sign) {\n",
        "suffix": "      sign = 0;\n      if (as.width_)\n        --as.width_;\n    }\n    as.align_ = ALIGN_RIGHT;\n  } else {\n    if (spec.align() == ALIGN_DEFAULT)\n      as.align_ = ALIGN_RIGHT;\n    if (sign)\n      ++n;\n  }\n  write_padded(n, as, double_writer{n, sign, buffer});\n}\n",
        "start": 2861,
        "end": 2943,
        "buggy": "void basic_writer<Range>::write_double(T value, const format_specs &spec) {\n  // Check type.\n  float_spec_handler<char_type> handler(spec.type());\n  internal::handle_float_type_spec(spec.type(), handler);\n\n  char sign = 0;\n  // Use isnegative instead of value < 0 because the latter is always\n  // false for NaN.\n  if (internal::fputil::isnegative(static_cast<double>(value))) {\n    sign = '-';\n    value = -value;\n  } else if (spec.flag(SIGN_FLAG)) {\n    sign = spec.flag(PLUS_FLAG) ? '+' : ' ';\n  }\n\n  struct write_inf_or_nan_t {\n    basic_writer &writer;\n    format_specs spec;\n    char sign;\n    void operator()(const char *str) const {\n      writer.write_padded(INF_SIZE + (sign ? 1 : 0), spec,\n                          inf_or_nan_writer{sign, str});\n    }\n  } write_inf_or_nan = {*this, spec, sign};\n\n  // Format NaN and ininity ourselves because sprintf's output is not consistent\n  // across platforms.\n  if (internal::fputil::isnotanumber(value))\n    return write_inf_or_nan(handler.upper ? \"NAN\" : \"nan\");\n  if (internal::fputil::isinfinity(value))\n    return write_inf_or_nan(handler.upper ? \"INF\" : \"inf\");\n\n  basic_memory_buffer<char_type> buffer;\n  if (FMT_USE_GRISU && sizeof(T) <= sizeof(double) &&\n      std::numeric_limits<double>::is_iec559) {\n    internal::fp fp_value(static_cast<double>(value));\n    fp_value.normalize();\n    // Find a cached power of 10 close to 1 / fp_value.\n    int dec_exp = 0;\n    const int min_exp = -60;\n    auto dec_pow = internal::get_cached_power(\n        min_exp - (fp_value.e + internal::fp::significand_size), dec_exp);\n    internal::fp product = fp_value * dec_pow;\n    // Generate output.\n    internal::fp one(1ull << -product.e, product.e);\n    uint64_t hi = product.f >> -one.e;\n    uint64_t f = product.f & (one.f - 1);\n    typedef back_insert_range<internal::basic_buffer<char_type>> range;\n    basic_writer<range> w{range(buffer)};\n    w.write(hi);\n    size_t digits = buffer.size();\n    w.write('.');\n    const unsigned max_digits = 18;\n    while (digits++ < max_digits) {\n      f *= 10;\n      w.write(static_cast<char>('0' + (f >> -one.e)));\n      f &= one.f - 1;\n    }\n    w.write('e');\n    w.write(-dec_exp);\n  } else {\n    format_specs normalized_spec(spec);\n    normalized_spec.type_ = handler.type;\n    write_double_sprintf(value, normalized_spec, buffer);\n  }\n  size_t n = buffer.size();\n  align_spec as = spec;\n  if (spec.align() == ALIGN_NUMERIC) {\n    if (sign) {\n      *reserve(1) = sign;\n      sign = 0;\n      if (as.width_)\n        --as.width_;\n    }\n    as.align_ = ALIGN_RIGHT;\n  } else {\n    if (spec.align() == ALIGN_DEFAULT)\n      as.align_ = ALIGN_RIGHT;\n    if (sign)\n      ++n;\n  }\n  write_padded(n, as, double_writer{n, sign, buffer});\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      *reserve(1) = sign;\n",
        "src_path": "fc6e0fe992156935bfb66bb2121c62ee8446758e___format.h",
        "uri": "https://api.github.com/repos/fmtlib/fmt/commits/fc6e0fe992156935bfb66bb2121c62ee8446758e",
        "commit_msg": "Fix FP formatting to a non-back_insert_iterator with sign & numeric alignment (#756)",
        "test_func_diff": [
            {
                "fn": "test/format-test.cc",
                "patch": "@@ -232,6 +232,12 @@ TEST(FormatToTest, Format) {\n   EXPECT_EQ(\"part1part2\", s);\n }\n \n+TEST(FormatToTest, FormatToNonbackInsertIteratorWithSignAndNumericAlignment) {\n+  char buffer[16] = {};\n+  fmt::format_to(buffer, \"{: =+}\", 42.0);\n+  EXPECT_STREQ(\"+42\", buffer);\n+}\n+\n TEST(FormatterTest, Escape) {\n   EXPECT_EQ(\"{\", format(\"{{\"));\n   EXPECT_EQ(\"before {\", format(\"before {{\"));"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_fc6e0fe992156935bfb66bb2121c62ee8446758e/build_fc6e0fe992156935bfb66bb2121c62ee8446758e\nTest project /out/fmtlib___fmt/git_repo_dir_fc6e0fe992156935bfb66bb2121c62ee8446758e/build_fc6e0fe992156935bfb66bb2121c62ee8446758e\n    Start 3: format-test\n1/1 Test #3: format-test ......................***Failed    0.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.02 sec\n\nThe following tests FAILED:\n\t  3 - format-test (Failed)\n"
    },
    "96c18b26c28bbdb8305b79be4eacfb28ee4aa872___printf.h": {
        "prefix": "class printf_arg_formatter : public detail::arg_formatter_base<Range> {\n public:\n  using iterator = typename Range::iterator;\n\n private:\n  using char_type = typename Range::value_type;\n  using base = detail::arg_formatter_base<Range>;\n  using context_type = basic_printf_context<iterator, char_type>;\n\n  context_type& context_;\n\n  void write_null_pointer(char) {\n    this->specs()->type = 0;\n    this->write(\"(nil)\");\n  }\n\n  void write_null_pointer(wchar_t) {\n    this->specs()->type = 0;\n    this->write(L\"(nil)\");\n  }\n\n public:\n  using format_specs = typename base::format_specs;\n\n  /**\n    \\rst\n    Constructs an argument formatter object.\n    *buffer* is a reference to the output buffer and *specs* contains format\n    specifier information for standard argument types.\n    \\endrst\n   */\n  printf_arg_formatter(iterator iter, format_specs& specs, context_type& ctx)\n      : base(Range(iter), &specs, detail::locale_ref()), context_(ctx) {}\n\n  template <typename T, FMT_ENABLE_IF(fmt::detail::is_integral<T>::value)>\n  iterator operator()(T value) {\n    // MSVC2013 fails to compile separate overloads for bool and char_type so\n    // use std::is_same instead.\n    if (std::is_same<T, bool>::value) {\n      format_specs& fmt_specs = *this->specs();\n      if (fmt_specs.type != 's') return base::operator()(value ? 1 : 0);\n      fmt_specs.type = 0;\n      this->write(value != 0);\n    } else if (std::is_same<T, char_type>::value) {\n      format_specs& fmt_specs = *this->specs();\n      if (fmt_specs.type && fmt_specs.type != 'c')\n        return (*this)(static_cast<int>(value));\n      fmt_specs.sign = sign::none;\n      fmt_specs.alt = false;\n",
        "suffix": "      return base::operator()(value);\n    } else {\n      return base::operator()(value);\n    }\n    return this->out();\n  }\n\n  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>\n  iterator operator()(T value) {\n    return base::operator()(value);\n  }\n\n  /** Formats a null-terminated C string. */\n  iterator operator()(const char* value) {\n    if (value)\n      base::operator()(value);\n    else if (this->specs()->type == 'p')\n      write_null_pointer(char_type());\n    else\n      this->write(\"(null)\");\n    return this->out();\n  }\n\n  /** Formats a null-terminated wide C string. */\n  iterator operator()(const wchar_t* value) {\n    if (value)\n      base::operator()(value);\n    else if (this->specs()->type == 'p')\n      write_null_pointer(char_type());\n    else\n      this->write(L\"(null)\");\n    return this->out();\n  }\n\n  iterator operator()(basic_string_view<char_type> value) {\n    return base::operator()(value);\n  }\n\n  iterator operator()(monostate value) { return base::operator()(value); }\n\n  /** Formats a pointer. */\n  iterator operator()(const void* value) {\n    if (value) return base::operator()(value);\n    this->specs()->type = 0;\n    write_null_pointer(char_type());\n    return this->out();\n  }\n\n  /** Formats an argument of a custom (user-defined) type. */\n  iterator operator()(typename basic_format_arg<context_type>::handle handle) {\n    handle.format(context_.parse_context(), context_);\n    return this->out();\n  }\n};\n",
        "start": 211,
        "end": 314,
        "buggy": "class printf_arg_formatter : public detail::arg_formatter_base<Range> {\n public:\n  using iterator = typename Range::iterator;\n\n private:\n  using char_type = typename Range::value_type;\n  using base = detail::arg_formatter_base<Range>;\n  using context_type = basic_printf_context<iterator, char_type>;\n\n  context_type& context_;\n\n  void write_null_pointer(char) {\n    this->specs()->type = 0;\n    this->write(\"(nil)\");\n  }\n\n  void write_null_pointer(wchar_t) {\n    this->specs()->type = 0;\n    this->write(L\"(nil)\");\n  }\n\n public:\n  using format_specs = typename base::format_specs;\n\n  /**\n    \\rst\n    Constructs an argument formatter object.\n    *buffer* is a reference to the output buffer and *specs* contains format\n    specifier information for standard argument types.\n    \\endrst\n   */\n  printf_arg_formatter(iterator iter, format_specs& specs, context_type& ctx)\n      : base(Range(iter), &specs, detail::locale_ref()), context_(ctx) {}\n\n  template <typename T, FMT_ENABLE_IF(fmt::detail::is_integral<T>::value)>\n  iterator operator()(T value) {\n    // MSVC2013 fails to compile separate overloads for bool and char_type so\n    // use std::is_same instead.\n    if (std::is_same<T, bool>::value) {\n      format_specs& fmt_specs = *this->specs();\n      if (fmt_specs.type != 's') return base::operator()(value ? 1 : 0);\n      fmt_specs.type = 0;\n      this->write(value != 0);\n    } else if (std::is_same<T, char_type>::value) {\n      format_specs& fmt_specs = *this->specs();\n      if (fmt_specs.type && fmt_specs.type != 'c')\n        return (*this)(static_cast<int>(value));\n      fmt_specs.sign = sign::none;\n      fmt_specs.alt = false;\n      fmt_specs.align = align::right;\n      return base::operator()(value);\n    } else {\n      return base::operator()(value);\n    }\n    return this->out();\n  }\n\n  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>\n  iterator operator()(T value) {\n    return base::operator()(value);\n  }\n\n  /** Formats a null-terminated C string. */\n  iterator operator()(const char* value) {\n    if (value)\n      base::operator()(value);\n    else if (this->specs()->type == 'p')\n      write_null_pointer(char_type());\n    else\n      this->write(\"(null)\");\n    return this->out();\n  }\n\n  /** Formats a null-terminated wide C string. */\n  iterator operator()(const wchar_t* value) {\n    if (value)\n      base::operator()(value);\n    else if (this->specs()->type == 'p')\n      write_null_pointer(char_type());\n    else\n      this->write(L\"(null)\");\n    return this->out();\n  }\n\n  iterator operator()(basic_string_view<char_type> value) {\n    return base::operator()(value);\n  }\n\n  iterator operator()(monostate value) { return base::operator()(value); }\n\n  /** Formats a pointer. */\n  iterator operator()(const void* value) {\n    if (value) return base::operator()(value);\n    this->specs()->type = 0;\n    write_null_pointer(char_type());\n    return this->out();\n  }\n\n  /** Formats an argument of a custom (user-defined) type. */\n  iterator operator()(typename basic_format_arg<context_type>::handle handle) {\n    handle.format(context_.parse_context(), context_);\n    return this->out();\n  }\n};\n",
        "fix": null,
        "buggy_hunk_masked": "      fmt_specs.align = align::right;\n",
        "src_path": "96c18b26c28bbdb8305b79be4eacfb28ee4aa872___printf.h",
        "uri": "https://api.github.com/repos/fmtlib/fmt/commits/96c18b26c28bbdb8305b79be4eacfb28ee4aa872",
        "commit_msg": "make plus flag for printf not be ignored for char argument (#1683)\n\n* make plus flag for printf not be ignored for char argument\r\n\r\n* clarify overwriting of alignment specifiers for printf with char argument",
        "test_func_diff": [
            {
                "fn": "test/printf-test.cc",
                "patch": "@@ -156,6 +156,10 @@ TEST(PrintfTest, PlusFlag) {\n TEST(PrintfTest, MinusFlag) {\n   EXPECT_PRINTF(\"abc  \", \"%-5s\", \"abc\");\n   EXPECT_PRINTF(\"abc  \", \"%0--5s\", \"abc\");\n+\n+  EXPECT_PRINTF(\"7    \", \"%-5d\", 7);\n+  EXPECT_PRINTF(\"97   \", \"%-5hhi\", 'a');\n+  EXPECT_PRINTF(\"a    \", \"%-5c\", 'a');\n }\n \n TEST(PrintfTest, SpaceFlag) {"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_96c18b26c28bbdb8305b79be4eacfb28ee4aa872/build_96c18b26c28bbdb8305b79be4eacfb28ee4aa872\nTest project /out/fmtlib___fmt/git_repo_dir_96c18b26c28bbdb8305b79be4eacfb28ee4aa872/build_96c18b26c28bbdb8305b79be4eacfb28ee4aa872\n    Start 12: printf-test\n1/1 Test #12: printf-test ......................***Failed    0.01 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.01 sec\n\nThe following tests FAILED:\n\t 12 - printf-test (Failed)\n"
    },
    "cd7202e0399677942a5428a7db9dec1d3c8b5c45___chrono.h": {
        "prefix": "  void on_second(numeric_system ns) {\n    if (handle_nan_inf()) return;\n\n    if (ns == numeric_system::standard) {\n      if (std::is_floating_point<rep>::value) {\n        auto buf = memory_buffer();\n        write_floating_seconds(buf, std::chrono::duration<rep, Period>(val));\n        if (negative) *out++ = '-';\n        if (buf.size() < 2 || buf[1] == '.') *out++ = '0';\n        out = std::copy(buf.begin(), buf.end(), out);\n      } else {\n        write(second(), 2);\n        write_fractional_seconds<char_type>(\n",
        "suffix": "      }\n      return;\n    }\n    auto time = tm();\n    time.tm_sec = to_nonnegative_int(second(), 60);\n    format_tm(time, &tm_writer_type::on_second, ns);\n  }\n",
        "start": 1828,
        "end": 1848,
        "buggy": "  void on_second(numeric_system ns) {\n    if (handle_nan_inf()) return;\n\n    if (ns == numeric_system::standard) {\n      if (std::is_floating_point<rep>::value) {\n        auto buf = memory_buffer();\n        write_floating_seconds(buf, std::chrono::duration<rep, Period>(val));\n        if (negative) *out++ = '-';\n        if (buf.size() < 2 || buf[1] == '.') *out++ = '0';\n        out = std::copy(buf.begin(), buf.end(), out);\n      } else {\n        write(second(), 2);\n        write_fractional_seconds<char_type>(\n            out, std::chrono::duration<Rep, Period>(val));\n      }\n      return;\n    }\n    auto time = tm();\n    time.tm_sec = to_nonnegative_int(second(), 60);\n    format_tm(time, &tm_writer_type::on_second, ns);\n  }\n",
        "fix": null,
        "buggy_hunk_masked": "            out, std::chrono::duration<Rep, Period>(val));\n",
        "src_path": "cd7202e0399677942a5428a7db9dec1d3c8b5c45___chrono.h",
        "uri": "https://api.github.com/repos/fmtlib/fmt/commits/cd7202e0399677942a5428a7db9dec1d3c8b5c45",
        "commit_msg": "Fix overflow error (#3143)\n\nSigned-off-by: Vladislav Shchapov <vladislav@shchapov.ru>\r\n\r\nSigned-off-by: Vladislav Shchapov <vladislav@shchapov.ru>",
        "test_func_diff": [
            {
                "fn": "test/chrono-test.cc",
                "patch": "@@ -642,6 +642,15 @@ TEST(chrono_test, cpp20_duration_subsecond_support) {\n                         std::chrono::duration<long long, std::ratio<1, 7>>(1)),\n             \"00.142857\");\n \n+  EXPECT_EQ(fmt::format(\"{:%S}\",\n+                        std::chrono::duration<char, std::ratio<1, 100>>(0x80)),\n+            \"-01.28\");\n+\n+  EXPECT_EQ(\n+      fmt::format(\"{:%M:%S}\",\n+                  std::chrono::duration<short, std::ratio<1, 100>>(0x8000)),\n+      \"-05:27.68\");\n+\n   // Check that floating point seconds with ratio<1,1> are printed.\n   EXPECT_EQ(fmt::format(\"{:%S}\", std::chrono::duration<double>{1.5}),\n             \"01.500000\");"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_cd7202e0399677942a5428a7db9dec1d3c8b5c45/build_cd7202e0399677942a5428a7db9dec1d3c8b5c45\nTest project /out/fmtlib___fmt/git_repo_dir_cd7202e0399677942a5428a7db9dec1d3c8b5c45/build_cd7202e0399677942a5428a7db9dec1d3c8b5c45\n    Start 3: chrono-test\n1/1 Test #3: chrono-test ......................***Failed    0.11 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.11 sec\n\nThe following tests FAILED:\n\t  3 - chrono-test (Failed)\n"
    },
    "6b7bfed40c559c06d2a4e074427dbc24819bd447___format-inl.h": {
        "prefix": "                     int& exp10) {\n  bigint numerator;    // 2 * R in (FPP)^2.\n  bigint denominator;  // 2 * S in (FPP)^2.\n  // lower and upper are differences between value and corresponding boundaries.\n  bigint lower;             // (M^- in (FPP)^2).\n  bigint upper_store;       // upper's value if different from lower.\n  bigint* upper = nullptr;  // (M^+ in (FPP)^2).\n  fp value;\n  // Shift numerator and denominator by an extra bit or two (if lower boundary\n  // is closer) to make lower and upper integers. This eliminates multiplication\n  // by 2 during later computations.\n  const bool is_predecessor_closer =\n      binary32 ? value.assign(static_cast<float>(d)) : value.assign(d);\n  int shift = is_predecessor_closer ? 2 : 1;\n  uint64_t significand = value.f << shift;\n  if (value.e >= 0) {\n    numerator.assign(significand);\n    numerator <<= value.e;\n    lower.assign(1);\n    lower <<= value.e;\n    if (shift != 1) {\n      upper_store.assign(1);\n      upper_store <<= value.e + 1;\n      upper = &upper_store;\n    }\n    denominator.assign_pow10(exp10);\n",
        "suffix": "  } else if (exp10 < 0) {\n    numerator.assign_pow10(-exp10);\n    lower.assign(numerator);\n    if (shift != 1) {\n      upper_store.assign(numerator);\n      upper_store <<= 1;\n      upper = &upper_store;\n    }\n    numerator *= significand;\n    denominator.assign(1);\n    denominator <<= shift - value.e;\n  } else {\n    numerator.assign(significand);\n    denominator.assign_pow10(exp10);\n    denominator <<= shift - value.e;\n    lower.assign(1);\n    if (shift != 1) {\n      upper_store.assign(1ULL << 1);\n      upper = &upper_store;\n    }\n  }\n  // Invariant: value == (numerator / denominator) * pow(10, exp10).\n  if (num_digits < 0) {\n    // Generate the shortest representation.\n    if (!upper) upper = &lower;\n    bool even = (value.f & 1) == 0;\n    num_digits = 0;\n    char* data = buf.data();\n    for (;;) {\n      int digit = numerator.divmod_assign(denominator);\n      bool low = compare(numerator, lower) - even < 0;  // numerator <[=] lower.\n      // numerator + upper >[=] pow10:\n      bool high = add_compare(numerator, *upper, denominator) + even > 0;\n      data[num_digits++] = static_cast<char>('0' + digit);\n      if (low || high) {\n        if (!low) {\n          ++data[num_digits - 1];\n        } else if (high) {\n          int result = add_compare(numerator, numerator, denominator);\n          // Round half to even.\n          if (result > 0 || (result == 0 && (digit % 2) != 0))\n            ++data[num_digits - 1];\n        }\n        buf.try_resize(to_unsigned(num_digits));\n        exp10 -= num_digits - 1;\n        return;\n      }\n      numerator *= 10;\n      lower *= 10;\n      if (upper != &lower) *upper *= 10;\n    }\n  }\n  // Generate the given number of digits.\n  exp10 -= num_digits - 1;\n  if (num_digits == 0) {\n    buf.try_resize(1);\n    denominator *= 10;\n    buf[0] = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';\n    return;\n  }\n  buf.try_resize(to_unsigned(num_digits));\n  for (int i = 0; i < num_digits - 1; ++i) {\n    int digit = numerator.divmod_assign(denominator);\n    buf[i] = static_cast<char>('0' + digit);\n    numerator *= 10;\n  }\n  int digit = numerator.divmod_assign(denominator);\n  auto result = add_compare(numerator, numerator, denominator);\n  if (result > 0 || (result == 0 && (digit % 2) != 0)) {\n    if (digit == 9) {\n      const auto overflow = '0' + 10;\n      buf[num_digits - 1] = overflow;\n      // Propagate the carry.\n      for (int i = num_digits - 1; i > 0 && buf[i] == overflow; --i) {\n        buf[i] = '0';\n        ++buf[i - 1];\n      }\n      if (buf[0] == overflow) {\n        buf[0] = '1';\n        ++exp10;\n      }\n      return;\n    }\n    ++digit;\n  }\n  buf[num_digits - 1] = static_cast<char>('0' + digit);\n}\n",
        "start": 2309,
        "end": 2422,
        "buggy": "                     int& exp10) {\n  bigint numerator;    // 2 * R in (FPP)^2.\n  bigint denominator;  // 2 * S in (FPP)^2.\n  // lower and upper are differences between value and corresponding boundaries.\n  bigint lower;             // (M^- in (FPP)^2).\n  bigint upper_store;       // upper's value if different from lower.\n  bigint* upper = nullptr;  // (M^+ in (FPP)^2).\n  fp value;\n  // Shift numerator and denominator by an extra bit or two (if lower boundary\n  // is closer) to make lower and upper integers. This eliminates multiplication\n  // by 2 during later computations.\n  const bool is_predecessor_closer =\n      binary32 ? value.assign(static_cast<float>(d)) : value.assign(d);\n  int shift = is_predecessor_closer ? 2 : 1;\n  uint64_t significand = value.f << shift;\n  if (value.e >= 0) {\n    numerator.assign(significand);\n    numerator <<= value.e;\n    lower.assign(1);\n    lower <<= value.e;\n    if (shift != 1) {\n      upper_store.assign(1);\n      upper_store <<= value.e + 1;\n      upper = &upper_store;\n    }\n    denominator.assign_pow10(exp10);\n    denominator <<= 1;\n  } else if (exp10 < 0) {\n    numerator.assign_pow10(-exp10);\n    lower.assign(numerator);\n    if (shift != 1) {\n      upper_store.assign(numerator);\n      upper_store <<= 1;\n      upper = &upper_store;\n    }\n    numerator *= significand;\n    denominator.assign(1);\n    denominator <<= shift - value.e;\n  } else {\n    numerator.assign(significand);\n    denominator.assign_pow10(exp10);\n    denominator <<= shift - value.e;\n    lower.assign(1);\n    if (shift != 1) {\n      upper_store.assign(1ULL << 1);\n      upper = &upper_store;\n    }\n  }\n  // Invariant: value == (numerator / denominator) * pow(10, exp10).\n  if (num_digits < 0) {\n    // Generate the shortest representation.\n    if (!upper) upper = &lower;\n    bool even = (value.f & 1) == 0;\n    num_digits = 0;\n    char* data = buf.data();\n    for (;;) {\n      int digit = numerator.divmod_assign(denominator);\n      bool low = compare(numerator, lower) - even < 0;  // numerator <[=] lower.\n      // numerator + upper >[=] pow10:\n      bool high = add_compare(numerator, *upper, denominator) + even > 0;\n      data[num_digits++] = static_cast<char>('0' + digit);\n      if (low || high) {\n        if (!low) {\n          ++data[num_digits - 1];\n        } else if (high) {\n          int result = add_compare(numerator, numerator, denominator);\n          // Round half to even.\n          if (result > 0 || (result == 0 && (digit % 2) != 0))\n            ++data[num_digits - 1];\n        }\n        buf.try_resize(to_unsigned(num_digits));\n        exp10 -= num_digits - 1;\n        return;\n      }\n      numerator *= 10;\n      lower *= 10;\n      if (upper != &lower) *upper *= 10;\n    }\n  }\n  // Generate the given number of digits.\n  exp10 -= num_digits - 1;\n  if (num_digits == 0) {\n    buf.try_resize(1);\n    denominator *= 10;\n    buf[0] = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';\n    return;\n  }\n  buf.try_resize(to_unsigned(num_digits));\n  for (int i = 0; i < num_digits - 1; ++i) {\n    int digit = numerator.divmod_assign(denominator);\n    buf[i] = static_cast<char>('0' + digit);\n    numerator *= 10;\n  }\n  int digit = numerator.divmod_assign(denominator);\n  auto result = add_compare(numerator, numerator, denominator);\n  if (result > 0 || (result == 0 && (digit % 2) != 0)) {\n    if (digit == 9) {\n      const auto overflow = '0' + 10;\n      buf[num_digits - 1] = overflow;\n      // Propagate the carry.\n      for (int i = num_digits - 1; i > 0 && buf[i] == overflow; --i) {\n        buf[i] = '0';\n        ++buf[i - 1];\n      }\n      if (buf[0] == overflow) {\n        buf[0] = '1';\n        ++exp10;\n      }\n      return;\n    }\n    ++digit;\n  }\n  buf[num_digits - 1] = static_cast<char>('0' + digit);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    denominator <<= 1;\n",
        "src_path": "6b7bfed40c559c06d2a4e074427dbc24819bd447___format-inl.h",
        "uri": "https://api.github.com/repos/fmtlib/fmt/commits/6b7bfed40c559c06d2a4e074427dbc24819bd447",
        "commit_msg": "Fix fallback float formatter at assymetric bounds (#1976)",
        "test_func_diff": [
            {
                "fn": "test/format-test.cc",
                "patch": "@@ -1317,6 +1317,8 @@ TEST(FormatterTest, FormatDouble) {\n   EXPECT_EQ(buffer, format(\"{:a}\", -42.0));\n   safe_sprintf(buffer, \"%A\", -42.0);\n   EXPECT_EQ(buffer, format(\"{:A}\", -42.0));\n+  EXPECT_EQ(\"9223372036854775808.000000\",\n+            format(\"{:f}\", 9223372036854775807.0));\n }\n \n TEST(FormatterTest, PrecisionRounding) {"
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_6b7bfed40c559c06d2a4e074427dbc24819bd447/build_6b7bfed40c559c06d2a4e074427dbc24819bd447\nTest project /out/fmtlib___fmt/git_repo_dir_6b7bfed40c559c06d2a4e074427dbc24819bd447/build_6b7bfed40c559c06d2a4e074427dbc24819bd447\n    Start 6: format-test\n1/1 Test #6: format-test ......................***Failed    0.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.02 sec\n\nThe following tests FAILED:\n\t  6 - format-test (Failed)\n"
    },
    "2b7a146fa1f91ee3d7ebc6a782663185543bc373___format.h": {
        "prefix": "template <typename OutputIt, typename Char, typename UInt> struct int_writer {\n  OutputIt out;\n  locale_ref locale;\n  const basic_format_specs<Char>& specs;\n  UInt abs_value;\n  char prefix[4];\n  unsigned prefix_size;\n\n  using iterator =\n      remove_reference_t<decltype(reserve(std::declval<OutputIt&>(), 0))>;\n\n  string_view get_prefix() const { return string_view(prefix, prefix_size); }\n\n  template <typename Int>\n  int_writer(OutputIt output, locale_ref loc, Int value,\n             const basic_format_specs<Char>& s)\n      : out(output),\n        locale(loc),\n        specs(s),\n        abs_value(static_cast<UInt>(value)),\n        prefix_size(0) {\n    static_assert(std::is_same<uint32_or_64_or_128_t<Int>, UInt>::value, \"\");\n    if (is_negative(value)) {\n      prefix[0] = '-';\n      ++prefix_size;\n      abs_value = 0 - abs_value;\n    } else if (specs.sign != sign::none && specs.sign != sign::minus) {\n      prefix[0] = specs.sign == sign::plus ? '+' : ' ';\n      ++prefix_size;\n    }\n  }\n\n  void on_dec() {\n    auto num_digits = count_digits(abs_value);\n    out = write_int(\n        out, num_digits, get_prefix(), specs, [this, num_digits](iterator it) {\n          return format_decimal<Char>(it, abs_value, num_digits).end;\n        });\n  }\n\n  void on_hex() {\n    if (specs.alt) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = specs.type;\n    }\n    int num_digits = count_digits<4>(abs_value);\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<4, Char>(it, abs_value, num_digits,\n                                                  specs.type != 'x');\n                    });\n  }\n\n  void on_bin() {\n    if (specs.alt) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = static_cast<char>(specs.type);\n    }\n    int num_digits = count_digits<1>(abs_value);\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<1, Char>(it, abs_value, num_digits);\n                    });\n  }\n\n  void on_oct() {\n    int num_digits = count_digits<3>(abs_value);\n    if (specs.alt && specs.precision <= num_digits && abs_value != 0) {\n      // Octal prefix '0' is counted as a digit, so only add it if precision\n      // is not greater than the number of digits.\n      prefix[prefix_size++] = '0';\n    }\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<3, Char>(it, abs_value, num_digits);\n                    });\n  }\n\n  enum { sep_size = 1 };\n\n  void on_num() {\n    std::string groups = grouping<Char>(locale);\n    if (groups.empty()) return on_dec();\n    auto sep = thousands_sep<Char>(locale);\n    if (!sep) return on_dec();\n    int num_digits = count_digits(abs_value);\n    int size = num_digits, n = num_digits;\n    std::string::const_iterator group = groups.cbegin();\n",
        "suffix": "           *group != max_value<char>()) {\n      size += sep_size;\n      n -= *group;\n      ++group;\n    }\n    if (group == groups.cend()) size += sep_size * ((n - 1) / groups.back());\n    char digits[40];\n    format_decimal(digits, abs_value, num_digits);\n    basic_memory_buffer<Char> buffer;\n    size += prefix_size;\n    buffer.resize(size);\n    basic_string_view<Char> s(&sep, sep_size);\n    // Index of a decimal digit with the least significant digit having index 0.\n    int digit_index = 0;\n    group = groups.cbegin();\n    auto p = buffer.data() + size;\n    for (int i = num_digits - 1; i >= 0; --i) {\n      *--p = static_cast<Char>(digits[i]);\n      if (*group <= 0 || ++digit_index % *group != 0 ||\n          *group == max_value<char>())\n        continue;\n      if (group + 1 != groups.cend()) {\n        digit_index = 0;\n        ++group;\n      }\n      p -= s.size();\n      std::uninitialized_copy(s.data(), s.data() + s.size(),\n                              make_checked(p, s.size()));\n    }\n    if (prefix_size != 0) p[-1] = static_cast<Char>('-');\n    write(out, basic_string_view<Char>(buffer.data(), buffer.size()), specs);\n  }\n\n  void on_chr() { *out++ = static_cast<Char>(abs_value); }\n\n  FMT_NORETURN void on_error() {\n    FMT_THROW(format_error(\"invalid type specifier\"));\n  }\n};\n",
        "start": 1474,
        "end": 1601,
        "buggy": "template <typename OutputIt, typename Char, typename UInt> struct int_writer {\n  OutputIt out;\n  locale_ref locale;\n  const basic_format_specs<Char>& specs;\n  UInt abs_value;\n  char prefix[4];\n  unsigned prefix_size;\n\n  using iterator =\n      remove_reference_t<decltype(reserve(std::declval<OutputIt&>(), 0))>;\n\n  string_view get_prefix() const { return string_view(prefix, prefix_size); }\n\n  template <typename Int>\n  int_writer(OutputIt output, locale_ref loc, Int value,\n             const basic_format_specs<Char>& s)\n      : out(output),\n        locale(loc),\n        specs(s),\n        abs_value(static_cast<UInt>(value)),\n        prefix_size(0) {\n    static_assert(std::is_same<uint32_or_64_or_128_t<Int>, UInt>::value, \"\");\n    if (is_negative(value)) {\n      prefix[0] = '-';\n      ++prefix_size;\n      abs_value = 0 - abs_value;\n    } else if (specs.sign != sign::none && specs.sign != sign::minus) {\n      prefix[0] = specs.sign == sign::plus ? '+' : ' ';\n      ++prefix_size;\n    }\n  }\n\n  void on_dec() {\n    auto num_digits = count_digits(abs_value);\n    out = write_int(\n        out, num_digits, get_prefix(), specs, [this, num_digits](iterator it) {\n          return format_decimal<Char>(it, abs_value, num_digits).end;\n        });\n  }\n\n  void on_hex() {\n    if (specs.alt) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = specs.type;\n    }\n    int num_digits = count_digits<4>(abs_value);\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<4, Char>(it, abs_value, num_digits,\n                                                  specs.type != 'x');\n                    });\n  }\n\n  void on_bin() {\n    if (specs.alt) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = static_cast<char>(specs.type);\n    }\n    int num_digits = count_digits<1>(abs_value);\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<1, Char>(it, abs_value, num_digits);\n                    });\n  }\n\n  void on_oct() {\n    int num_digits = count_digits<3>(abs_value);\n    if (specs.alt && specs.precision <= num_digits && abs_value != 0) {\n      // Octal prefix '0' is counted as a digit, so only add it if precision\n      // is not greater than the number of digits.\n      prefix[prefix_size++] = '0';\n    }\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<3, Char>(it, abs_value, num_digits);\n                    });\n  }\n\n  enum { sep_size = 1 };\n\n  void on_num() {\n    std::string groups = grouping<Char>(locale);\n    if (groups.empty()) return on_dec();\n    auto sep = thousands_sep<Char>(locale);\n    if (!sep) return on_dec();\n    int num_digits = count_digits(abs_value);\n    int size = num_digits, n = num_digits;\n    std::string::const_iterator group = groups.cbegin();\n    while (group != groups.cend() && num_digits > *group && *group > 0 &&\n           *group != max_value<char>()) {\n      size += sep_size;\n      n -= *group;\n      ++group;\n    }\n    if (group == groups.cend()) size += sep_size * ((n - 1) / groups.back());\n    char digits[40];\n    format_decimal(digits, abs_value, num_digits);\n    basic_memory_buffer<Char> buffer;\n    size += prefix_size;\n    buffer.resize(size);\n    basic_string_view<Char> s(&sep, sep_size);\n    // Index of a decimal digit with the least significant digit having index 0.\n    int digit_index = 0;\n    group = groups.cbegin();\n    auto p = buffer.data() + size;\n    for (int i = num_digits - 1; i >= 0; --i) {\n      *--p = static_cast<Char>(digits[i]);\n      if (*group <= 0 || ++digit_index % *group != 0 ||\n          *group == max_value<char>())\n        continue;\n      if (group + 1 != groups.cend()) {\n        digit_index = 0;\n        ++group;\n      }\n      p -= s.size();\n      std::uninitialized_copy(s.data(), s.data() + s.size(),\n                              make_checked(p, s.size()));\n    }\n    if (prefix_size != 0) p[-1] = static_cast<Char>('-');\n    write(out, basic_string_view<Char>(buffer.data(), buffer.size()), specs);\n  }\n\n  void on_chr() { *out++ = static_cast<Char>(abs_value); }\n\n  FMT_NORETURN void on_error() {\n    FMT_THROW(format_error(\"invalid type specifier\"));\n  }\n};\n",
        "fix": null,
        "buggy_hunk_masked": "    while (group != groups.cend() && num_digits > *group && *group > 0 &&\n",
        "src_path": "2b7a146fa1f91ee3d7ebc6a782663185543bc373___format.h",
        "uri": "https://api.github.com/repos/fmtlib/fmt/commits/2b7a146fa1f91ee3d7ebc6a782663185543bc373",
        "commit_msg": "Fix a regression in handling digit separators (#1782)",
        "test_func_diff": [
            {
                "fn": "test/locale-test.cc",
                "patch": "@@ -61,6 +61,7 @@ TEST(LocaleTest, Format) {\n \n   std::locale special_grouping_loc(std::locale(), new special_grouping<char>());\n   EXPECT_EQ(\"1,23,45,678\", fmt::format(special_grouping_loc, \"{:L}\", 12345678));\n+  EXPECT_EQ(\"12,345\", fmt::format(special_grouping_loc, \"{:L}\", 12345));\n \n   std::locale small_grouping_loc(std::locale(), new small_grouping<char>());\n   EXPECT_EQ(\"4,2,9,4,9,6,7,2,9,5\","
            }
        ],
        "error_msg": "Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_2b7a146fa1f91ee3d7ebc6a782663185543bc373/build_2b7a146fa1f91ee3d7ebc6a782663185543bc373\nTest project /out/fmtlib___fmt/git_repo_dir_2b7a146fa1f91ee3d7ebc6a782663185543bc373/build_2b7a146fa1f91ee3d7ebc6a782663185543bc373\n    Start 9: locale-test\n1/1 Test #9: locale-test ......................***Failed    0.00 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.00 sec\n\nThe following tests FAILED:\n\t  9 - locale-test (Failed)\n"
    }
}