{
    "e942fb84fbe3a73a98a00d2a279425872b5fb9d2___print-ripng.c": {
        "start": 108,
        "end": 174,
        "buggy": "void\nripng_print(netdissect_options *ndo, const u_char *dat, unsigned int length)\n{\n\tregister const struct rip6 *rp = (const struct rip6 *)dat;\n\tregister const struct netinfo6 *ni;\n\tregister u_int amt;\n\tregister u_int i;\n\tint j;\n\tint trunc;\n\n\tif (ndo->ndo_snapend < dat)\n\t\treturn;\n\tamt = ndo->ndo_snapend - dat;\n\ti = min(length, amt);\n\tif (i < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n\t\treturn;\n\ti -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n\n\tswitch (rp->rip6_cmd) {\n\n\tcase RIP6_REQUEST:\n\t\tj = length / sizeof(*ni);\n\t\tif (j == 1\n\t\t    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6\n\t\t    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {\n\t\t\tND_PRINT((ndo, \" ripng-req dump\"));\n\t\t\tbreak;\n\t\t}\n\t\tif (j * sizeof(*ni) != length - 4)\n\t\t\tND_PRINT((ndo, \" ripng-req %d[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-req %d:\", j));\n\t\ttrunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);\n\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n\t\t    i -= sizeof(*ni), ++ni) {\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, 0);\n\t\t}\n\t\tbreak;\n\tcase RIP6_RESPONSE:\n\t\tj = length / sizeof(*ni);\n\t\tif (j * sizeof(*ni) != length - 4)\n\t\t\tND_PRINT((ndo, \" ripng-resp %d[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-resp %d:\", j));\n\t\ttrunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);\n\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n\t\t    i -= sizeof(*ni), ++ni) {\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, ni->rip6_metric);\n\t\t}\n\t\tif (trunc)\n\t\t\tND_PRINT((ndo, \"[|ripng]\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \" ripng-%d ?? %u\", rp->rip6_cmd, length));\n\t\tbreak;\n\t}\n\tif (rp->rip6_vers != RIP6_VERSION)\n\t\tND_PRINT((ndo, \" [vers %d]\", rp->rip6_vers));\n}\n",
        "fix": null,
        "src_path": "e942fb84fbe3a73a98a00d2a279425872b5fb9d2___print-ripng.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/e942fb84fbe3a73a98a00d2a279425872b5fb9d2",
        "commit_msg": "CVE-2017-12992/RIPng: Clean up bounds checking.\n\nDo bounds checking as we access items.\n\nScan the list of netinfo6 entries based on the supplied packet length,\nwithout taking the captured length into account; let the aforementioned\nbounds checking handle that.\n\nThis fixes a buffer over-read discovered by Kamil Frankowicz.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -450,6 +450,7 @@ isoclns-oobr\t\tisoclns-oobr.pcap\t\tisoclns-oobr.out\n nfs-attr-oobr\t\tnfs-attr-oobr.pcap\t\tnfs-attr-oobr.out\n decnet-oobr\t\tdecnet-oobr.pcap\t\tdecnet-oobr.out\n oobr_parse_elements\toobr_parse_elements.pcap\toobr_parse_elements.out\n+hoobr_ripng_print\thoobr_ripng_print.pcap\t\thoobr_ripng_print.out\n \n # bad packets from Wilfried Kirsch\n slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve"
            },
            {
                "fn": "tests/hoobr_ripng_print.out",
                "patch": "@@ -0,0 +1 @@\n+IP 48.48.48.48.521 > 48.48.48.48.12336: [|ripng]"
            }
        ],
        "error_msg": "    hoobr_ripng_print                  : TEST FAILED(exit 256)\n"
    },
    "3a76fd7c95fced2c2f8c8148a9055c3a542eff29___print-domain.c": {
        "start": 147,
        "end": 229,
        "buggy": "const u_char *\nns_nprint(netdissect_options *ndo,\n          register const u_char *cp, register const u_char *bp)\n{\n\tregister u_int i, l;\n\tregister const u_char *rp = NULL;\n\tregister int compress = 0;\n\tint chars_processed;\n\tint elt;\n\tint data_size = ndo->ndo_snapend - bp;\n\n\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\treturn(NULL);\n\tif (!ND_TTEST2(*cp, 1))\n\t\treturn(NULL);\n\tchars_processed = 1;\n\tif (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {\n\t\tcompress = 0;\n\t\trp = cp + l;\n\t}\n\n\tif (i != 0)\n\t\twhile (i && cp < ndo->ndo_snapend) {\n\t\t\tif ((i & INDIR_MASK) == INDIR_MASK) {\n\t\t\t\tif (!compress) {\n\t\t\t\t\trp = cp + 1;\n\t\t\t\t\tcompress = 1;\n\t\t\t\t}\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\tcp = bp + (((i << 8) | *cp) & 0x3fff);\n\t\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\t\treturn(NULL);\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\ti = *cp++;\n\t\t\t\tchars_processed++;\n\n\t\t\t\t/*\n\t\t\t\t * If we've looked at every character in\n\t\t\t\t * the message, this pointer will make\n\t\t\t\t * us look at some character again,\n\t\t\t\t * which means we're looping.\n\t\t\t\t */\n\t\t\t\tif (chars_processed >= data_size) {\n\t\t\t\t\tND_PRINT((ndo, \"<LOOP>\"));\n\t\t\t\t\treturn (NULL);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((i & INDIR_MASK) == EDNS0_MASK) {\n\t\t\t\telt = (i & ~INDIR_MASK);\n\t\t\t\tswitch(elt) {\n\t\t\t\tcase EDNS0_ELT_BITLABEL:\n\t\t\t\t\tif (blabel_print(ndo, cp) == NULL)\n\t\t\t\t\t\treturn (NULL);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* unknown ELT */\n\t\t\t\t\tND_PRINT((ndo, \"<ELT %d>\", elt));\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (fn_printn(ndo, cp, l, ndo->ndo_snapend))\n\t\t\t\t\treturn(NULL);\n\t\t\t}\n\n\t\t\tcp += l;\n\t\t\tchars_processed += l;\n\t\t\tND_PRINT((ndo, \".\"));\n\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\treturn(NULL);\n\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\treturn(NULL);\n\t\t\ti = *cp++;\n\t\t\tchars_processed++;\n\t\t\tif (!compress)\n\t\t\t\trp += l + 1;\n\t\t}\n\telse\n\t\tND_PRINT((ndo, \".\"));\n\treturn (rp);\n}\n",
        "fix": null,
        "src_path": "3a76fd7c95fced2c2f8c8148a9055c3a542eff29___print-domain.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/3a76fd7c95fced2c2f8c8148a9055c3a542eff29",
        "commit_msg": "CVE-2017-12995/Check for DNS compression pointers that don't point backwards.\n\nThis is what BIND 9.11.0-P2 does; it not only detects pointers that\nloop, as \"point backwards\" means \"point before anything we've processed\nso far, including what we're processing right now\", so the pointer can't\npoint to itself (as that's what we're processing right now).\n\nThis fixes an infinite loop discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).\n\nAlso, add some infinite-pointer-loop captures.\n\nMore checks should be done.  We might, for example, want to make sure\nthe upper 2 bits of the label length/pointer byte are 00 or 11, and that\nif we encounter a pointer and jump backwards to what we think is a label\nthe label ends before the beginning of the last label we processed, to\nmake sure the pointer doesn't point backwards into the *middle* of a\nlabel, and also make sure the entire name is <= 255 bytes long.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -474,6 +474,7 @@ zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n telnet-iac-check-oobr\ttelnet-iac-check-oobr.pcap\ttelnet-iac-check-oobr.out\t-vvv -e\n resp_4_infiniteloop\tresp_4_infiniteloop.pcap\tresp_4_infiniteloop.out\t-vvv -e\n+dns_fwdptr\t\tdns_fwdptr.pcap\t\t\tdns_fwdptr.out\t\t-vvv -e\n \n # RTP tests\n # fuzzed pcap\n@@ -483,3 +484,11 @@ rtp-seg-fault-2  rtp-seg-fault-2.pcap  rtp-seg-fault-2.out  -v -T rtp\n # NFS tests\n # fuzzed pcap\n nfs-seg-fault-1  nfs-seg-fault-1.pcap  nfs-seg-fault-1.out\n+\n+# DNS infinite loop tests\n+#\n+# See http://marc.info/?l=tcpdump-workers&m=95552439022555\n+#\n+dns-zlip-1\t\tdns-zlip-1.pcap\t\tdns-zlip-1.out\n+dns-zlip-2\t\tdns-zlip-2.pcap\t\tdns-zlip-2.out\n+dns-zlip-3\t\tdns-zlip-3.pcap\t\tdns-zlip-3.out"
            },
            {
                "fn": "tests/dns-zlip-1.out",
                "patch": "@@ -0,0 +1 @@\n+IP 10.0.0.1.1024 > 146.84.28.88.53: 60777 Type49159 (Class 49168)? <BAD PTR>[|domain]"
            },
            {
                "fn": "tests/dns-zlip-2.out",
                "patch": "@@ -0,0 +1 @@\n+IP 10.0.0.1.1024 > 146.84.28.88.53: 18992 Type49164 (Class 49168)? <BAD PTR>[|domain]"
            },
            {
                "fn": "tests/dns-zlip-3.out",
                "patch": "@@ -0,0 +1 @@\n+IP 10.0.0.1.1024 > 146.84.28.88.53: 65483 Type49164 (Class 49164)? thisleetostringwillcrashyourlittlenameserverforsurehahahahahah.<BAD PTR>[|domain]"
            },
            {
                "fn": "tests/dns_fwdptr.out",
                "patch": "@@ -0,0 +1,2 @@\n+be:af:ca:ce:ff:ff > de:ad:be:ef:00:01, ethertype IPv4 (0x0800), length 63207: (tos 0x0, ttl 128, id 36039, offset 0, flags [none], proto UDP (17), length 63193)\n+    156.118.17.235.53 > 156.118.27.229.500: [udp sum ok] 51584 zoneRef NoChange*|$ [64259q] q: Type507 (Class 769)? M-{.^AM-{^C.M-{.^AM-{^C.M-{.^AM-{^C.M-{.^AM-{^C.M-{.^AM-{ .M-{^C^A.<BAD PTR>[|domain]"
            }
        ],
        "error_msg": "    dns-zlip-1                         : TEST FAILED(exit 256)\n    dns-zlip-2                         : TEST FAILED(exit 256)\n    dns-zlip-3                         : TEST FAILED(exit 256)\n    dns_fwdptr                         : TEST FAILED(exit 256)\n"
    },
    "7a923447fd49a069a0fd3b6c3547438ab5ee2123___print-nfs.c": {
        "start": 784,
        "end": 831,
        "buggy": "static void\nnfs_printfh(netdissect_options *ndo,\n            register const uint32_t *dp, const u_int len)\n{\n\tmy_fsid fsid;\n\tuint32_t ino;\n\tconst char *sfsname = NULL;\n\tchar *spacep;\n\n\tif (ndo->ndo_uflag) {\n\t\tu_int i;\n\t\tchar const *sep = \"\";\n\n\t\tND_PRINT((ndo, \" fh[\"));\n\t\tfor (i=0; i<len; i++) {\n\t\t\tND_PRINT((ndo, \"%s%x\", sep, dp[i]));\n\t\t\tsep = \":\";\n\t\t}\n\t\tND_PRINT((ndo, \"]\"));\n\t\treturn;\n\t}\n\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n\n\tif (sfsname) {\n\t\t/* file system ID is ASCII, not numeric, for this server OS */\n\t\tstatic char temp[NFSX_V3FHMAX+1];\n\n\t\t/* Make sure string is null-terminated */\n\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n\t\ttemp[sizeof(temp) - 1] = '\\0';\n\t\t/* Remove trailing spaces */\n\t\tspacep = strchr(temp, ' ');\n\t\tif (spacep)\n\t\t\t*spacep = '\\0';\n\n\t\tND_PRINT((ndo, \" fh %s/\", temp));\n\t} else {\n\t\tND_PRINT((ndo, \" fh %d,%d/\",\n\t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n\t}\n\n\tif(fsid.Fsid_dev.Minor == 257)\n\t\t/* Print the undecoded handle */\n\t\tND_PRINT((ndo, \"%s\", fsid.Opaque_Handle));\n\telse\n\t\tND_PRINT((ndo, \"%ld\", (long) ino));\n}\n",
        "fix": null,
        "src_path": "7a923447fd49a069a0fd3b6c3547438ab5ee2123___print-nfs.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/7a923447fd49a069a0fd3b6c3547438ab5ee2123",
        "commit_msg": "CVE-2017-13001/NFS: Don't copy more data than is in the file handle.\n\nAlso, put the buffer on the stack; no reason to make it static.  (65\nbytes isn't a lot.)\n\nThis fixes a buffer over-read discovered by Kamil Frankowicz.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -458,6 +458,7 @@ hoobr_parse_field\thoobr_parse_field.pcap\t\thoobr_parse_field.out\n hoobr_chdlc_print\thoobr_chdlc_print.pcap\t\thoobr_chdlc_print.out\n hoobr_lookup_nsap\thoobr_lookup_nsap.pcap\t\thoobr_lookup_nsap.out\n hoobr_rt6_print\t\thoobr_rt6_print.pcap\t\thoobr_rt6_print.out\n+hoobr_nfs_printfh\thoobr_nfs_printfh.pcap\t\thoobr_nfs_printfh.out\n \n # bad packets from Wilfried Kirsch\n slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve"
            },
            {
                "fn": "tests/hoobr_nfs_printfh.out",
                "patch": "@@ -0,0 +1,104 @@\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00d0:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030                      00000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00d0:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030                                0000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030                                0000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0040:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0050:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0060:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0070:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0080:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0090:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00a0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00b0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00c0:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x00d0:  3030 3030 3030 3030 3030 3030            000000000000\n+IP 48.48.48.48.12336 > 48.48.48.48.2049: Flags [.U], seq 808464432:808476728, ack 808464432, win 12336, urg 12336, length 12296: NFS request xid 808464432 12292 readlink fh 00000000/808464432"
            }
        ],
        "error_msg": "    hoobr_nfs_printfh                  : TEST FAILED(exit 256)\n"
    },
    "b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd___print-nfs.c": {
        "start": 865,
        "end": 905,
        "buggy": "static int\nxid_map_enter(netdissect_options *ndo,\n              const struct sunrpc_msg *rp, const u_char *bp)\n{\n\tconst struct ip *ip = NULL;\n\tconst struct ip6_hdr *ip6 = NULL;\n\tstruct xid_map_entry *xmep;\n\n\tif (!ND_TTEST(rp->rm_call.cb_vers))\n\t\treturn (0);\n\tswitch (IP_V((const struct ip *)bp)) {\n\tcase 4:\n\t\tip = (const struct ip *)bp;\n\t\tbreak;\n\tcase 6:\n\t\tip6 = (const struct ip6_hdr *)bp;\n\t\tbreak;\n\tdefault:\n\t\treturn (1);\n\t}\n\n\txmep = &xid_map[xid_map_next];\n\n\tif (++xid_map_next >= XIDMAPSIZE)\n\t\txid_map_next = 0;\n\n\tUNALIGNED_MEMCPY(&xmep->xid, &rp->rm_xid, sizeof(xmep->xid));\n\tif (ip) {\n\t\txmep->ipver = 4;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));\n\t}\n\telse if (ip6) {\n\t\txmep->ipver = 6;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));\n\t}\n\txmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);\n\txmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);\n\treturn (1);\n}\n",
        "fix": null,
        "src_path": "b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd___print-nfs.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd",
        "commit_msg": "CVE-2017-13005/NFS: Add two bounds checks before fetching data\n\nThis fixes a buffer over-read discovered by Kamil Frankowicz.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -461,6 +461,7 @@ hoobr_lookup_nsap\thoobr_lookup_nsap.pcap\t\thoobr_lookup_nsap.out\n hoobr_rt6_print\t\thoobr_rt6_print.pcap\t\thoobr_rt6_print.out\n hoobr_nfs_printfh\thoobr_nfs_printfh.pcap\t\thoobr_nfs_printfh.out\n hoobr_aodv_extension\thoobr_aodv_extension.pcap\thoobr_aodv_extension.out\n+hoobr_nfs_xid_map_enter hoobr_nfs_xid_map_enter.pcap    hoobr_nfs_xid_map_enter.out\n \n # bad packets from Wilfried Kirsch\n slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve"
            },
            {
                "fn": "tests/hoobr_nfs_xid_map_enter.out",
                "patch": "@@ -0,0 +1,41 @@\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0020:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0030:  30                                       0\n+IP 48.48.48.48.12336 > 48.48.48.48.2049: NFS request xid 808464432 12308 [|nfs]"
            }
        ],
        "error_msg": "    hoobr_nfs_xid_map_enter            : TEST FAILED(exit 256)\n"
    },
    "5edf405d7ed9fc92f4f43e8a3d44baa4c6387562___print-802_11.c": {
        "start": 997,
        "end": 1220,
        "buggy": "static int\nparse_elements(netdissect_options *ndo,\n               struct mgmt_body_t *pbody, const u_char *p, int offset,\n               u_int length)\n{\n\tu_int elementlen;\n\tstruct ssid_t ssid;\n\tstruct challenge_t challenge;\n\tstruct rates_t rates;\n\tstruct ds_t ds;\n\tstruct cf_t cf;\n\tstruct tim_t tim;\n\n\t/*\n\t * We haven't seen any elements yet.\n\t */\n\tpbody->challenge_present = 0;\n\tpbody->ssid_present = 0;\n\tpbody->rates_present = 0;\n\tpbody->ds_present = 0;\n\tpbody->cf_present = 0;\n\tpbody->tim_present = 0;\n\n\twhile (length != 0) {\n\t\t/* Make sure we at least have the element ID and length. */\n\t\tif (!ND_TTEST2(*(p + offset), 2))\n\t\t\treturn 0;\n\t\tif (length < 2)\n\t\t\treturn 0;\n\t\telementlen = *(p + offset + 1);\n\n\t\t/* Make sure we have the entire element. */\n\t\tif (!ND_TTEST2(*(p + offset + 2), elementlen))\n\t\t\treturn 0;\n\t\tif (length < elementlen + 2)\n\t\t\treturn 0;\n\n\t\tswitch (*(p + offset)) {\n\t\tcase E_SSID:\n\t\t\tmemcpy(&ssid, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (ssid.length != 0) {\n\t\t\t\tif (ssid.length > sizeof(ssid.ssid) - 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), ssid.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < ssid.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&ssid.ssid, p + offset, ssid.length);\n\t\t\t\toffset += ssid.length;\n\t\t\t\tlength -= ssid.length;\n\t\t\t}\n\t\t\tssid.ssid[ssid.length] = '\\0';\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen an SSID IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->ssid_present) {\n\t\t\t\tpbody->ssid = ssid;\n\t\t\t\tpbody->ssid_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_CHALLENGE:\n\t\t\tmemcpy(&challenge, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (challenge.length != 0) {\n\t\t\t\tif (challenge.length >\n\t\t\t\t    sizeof(challenge.text) - 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), challenge.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < challenge.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&challenge.text, p + offset,\n\t\t\t\t    challenge.length);\n\t\t\t\toffset += challenge.length;\n\t\t\t\tlength -= challenge.length;\n\t\t\t}\n\t\t\tchallenge.text[challenge.length] = '\\0';\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a challenge IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->challenge_present) {\n\t\t\t\tpbody->challenge = challenge;\n\t\t\t\tpbody->challenge_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_RATES:\n\t\t\tmemcpy(&rates, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (rates.length != 0) {\n\t\t\t\tif (rates.length > sizeof rates.rate)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), rates.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < rates.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&rates.rate, p + offset, rates.length);\n\t\t\t\toffset += rates.length;\n\t\t\t\tlength -= rates.length;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a rates IE,\n\t\t\t * copy this one if it's not zero-length,\n\t\t\t * otherwise ignore this one, so we later\n\t\t\t * report the first one we saw.\n\t\t\t *\n\t\t\t * We ignore zero-length rates IEs as some\n\t\t\t * devices seem to put a zero-length rates\n\t\t\t * IE, followed by an SSID IE, followed by\n\t\t\t * a non-zero-length rates IE into frames,\n\t\t\t * even though IEEE Std 802.11-2007 doesn't\n\t\t\t * seem to indicate that a zero-length rates\n\t\t\t * IE is valid.\n\t\t\t */\n\t\t\tif (!pbody->rates_present && rates.length != 0) {\n\t\t\t\tpbody->rates = rates;\n\t\t\t\tpbody->rates_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_DS:\n\t\t\tmemcpy(&ds, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (ds.length != 1) {\n\t\t\t\toffset += ds.length;\n\t\t\t\tlength -= ds.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tds.channel = *(p + offset);\n\t\t\toffset += 1;\n\t\t\tlength -= 1;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a DS IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->ds_present) {\n\t\t\t\tpbody->ds = ds;\n\t\t\t\tpbody->ds_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_CF:\n\t\t\tmemcpy(&cf, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (cf.length != 6) {\n\t\t\t\toffset += cf.length;\n\t\t\t\tlength -= cf.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(&cf.count, p + offset, 6);\n\t\t\toffset += 6;\n\t\t\tlength -= 6;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a CF IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->cf_present) {\n\t\t\t\tpbody->cf = cf;\n\t\t\t\tpbody->cf_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_TIM:\n\t\t\tmemcpy(&tim, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (tim.length <= 3) {\n\t\t\t\toffset += tim.length;\n\t\t\t\tlength -= tim.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tim.length - 3 > (int)sizeof tim.bitmap)\n\t\t\t\treturn 0;\n\t\t\tmemcpy(&tim.count, p + offset, 3);\n\t\t\toffset += 3;\n\t\t\tlength -= 3;\n\n\t\t\tmemcpy(tim.bitmap, p + offset + 3, tim.length - 3);\n\t\t\toffset += tim.length - 3;\n\t\t\tlength -= tim.length - 3;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a TIM IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->tim_present) {\n\t\t\t\tpbody->tim = tim;\n\t\t\t\tpbody->tim_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n#if 0\n\t\t\tND_PRINT((ndo, \"(1) unhandled element_id (%d)  \",\n\t\t\t    *(p + offset)));\n#endif\n\t\t\toffset += 2 + elementlen;\n\t\t\tlength -= 2 + elementlen;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* No problems found. */\n\treturn 1;\n}\n",
        "fix": null,
        "src_path": "5edf405d7ed9fc92f4f43e8a3d44baa4c6387562___print-802_11.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/5edf405d7ed9fc92f4f43e8a3d44baa4c6387562",
        "commit_msg": "CVE-2017-13008/IEEE 802.11: Fix TIM bitmap copy to copy from p + offset.\n\noffset has already been advanced to point to the bitmap; we shouldn't\nadd the amount to advance again.\n\nThis fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.\n\nAdd a test using the capture file supplied by the reporter(s).\n\nWhile we're at it, remove some redundant tests - we've already checked,\nbefore the case statement, whether we have captured the entire\ninformation element and whether the entire information element is\npresent in the on-the-wire packet; in the cases for particular IEs, we\nonly need to make sure we don't go past the end of the IE.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -438,6 +438,7 @@ ipv6-rthdr-oobr\t\tipv6-rthdr-oobr.pcap\t\tipv6-rthdr-oobr.out\n ieee802.11_tim_ie_oobr\tieee802.11_tim_ie_oobr.pcap\tieee802.11_tim_ie_oobr.out\n decnet-shorthdr-oobr\tdecnet-shorthdr-oobr.pcap\tdecnet-shorthdr-oobr.out\n isakmp-3948-oobr-2\tisakmp-3948-oobr-2.pcap\t\tisakmp-3948-oobr-2.out\n+ieee802.11_rates_oobr\tieee802.11_rates_oobr.pcap\tieee802.11_rates_oobr.out\n \n # bad packets from Kamil Frankowicz\n snmp-heapoverflow-1\tsnmp-heapoverflow-1.pcap\tsnmp-heapoverflow-1.out"
            },
            {
                "fn": "tests/ieee802.11_rates_oobr.out",
                "patch": "@@ -0,0 +1 @@\n+fhset 48 fhpat 48 48dBm signal 48dB signal 48dB noise [|802.11]Beacon IBSS, PRIVACY[|802.11]"
            }
        ],
        "error_msg": "    ieee802.11_rates_oobr              : passed\n"
    },
    "985122081165753c7442bd7824c473eb9ff56308___print-eap.c": {
        "start": 149,
        "end": 288,
        "buggy": "void\neap_print(netdissect_options *ndo,\n          register const u_char *cp,\n          u_int length)\n{\n    const struct eap_frame_t *eap;\n    const u_char *tptr;\n    u_int tlen, type, subtype;\n    int count=0, len;\n\n    tptr = cp;\n    tlen = length;\n    eap = (const struct eap_frame_t *)cp;\n    ND_TCHECK(*eap);\n\n    /* in non-verbose mode just lets print the basic info */\n    if (ndo->ndo_vflag < 1) {\n\tND_PRINT((ndo, \"%s (%u) v%u, len %u\",\n               tok2str(eap_frame_type_values, \"unknown\", eap->type),\n               eap->type,\n               eap->version,\n               EXTRACT_16BITS(eap->length)));\n\treturn;\n    }\n\n    ND_PRINT((ndo, \"%s (%u) v%u, len %u\",\n           tok2str(eap_frame_type_values, \"unknown\", eap->type),\n           eap->type,\n           eap->version,\n           EXTRACT_16BITS(eap->length)));\n\n    tptr += sizeof(const struct eap_frame_t);\n    tlen -= sizeof(const struct eap_frame_t);\n\n    switch (eap->type) {\n    case EAP_FRAME_TYPE_PACKET:\n        type = *(tptr);\n        len = EXTRACT_16BITS(tptr+2);\n        ND_PRINT((ndo, \", %s (%u), id %u, len %u\",\n               tok2str(eap_code_values, \"unknown\", type),\n               type,\n               *(tptr+1),\n               len));\n\n        ND_TCHECK2(*tptr, len);\n\n        if (type <= 2) { /* For EAP_REQUEST and EAP_RESPONSE only */\n            subtype = *(tptr+4);\n            ND_PRINT((ndo, \"\\n\\t\\t Type %s (%u)\",\n                   tok2str(eap_type_values, \"unknown\", *(tptr+4)),\n                   *(tptr + 4)));\n\n            switch (subtype) {\n            case EAP_TYPE_IDENTITY:\n                if (len - 5 > 0) {\n                    ND_PRINT((ndo, \", Identity: \"));\n                    safeputs(ndo, tptr + 5, len - 5);\n                }\n                break;\n\n            case EAP_TYPE_NOTIFICATION:\n                if (len - 5 > 0) {\n                    ND_PRINT((ndo, \", Notification: \"));\n                    safeputs(ndo, tptr + 5, len - 5);\n                }\n                break;\n\n            case EAP_TYPE_NAK:\n                count = 5;\n\n                /*\n                 * one or more octets indicating\n                 * the desired authentication\n                 * type one octet per type\n                 */\n                while (count < len) {\n                    ND_PRINT((ndo, \" %s (%u),\",\n                           tok2str(eap_type_values, \"unknown\", *(tptr+count)),\n                           *(tptr + count)));\n                    count++;\n                }\n                break;\n\n            case EAP_TYPE_TTLS:\n                ND_PRINT((ndo, \" TTLSv%u\",\n                       EAP_TTLS_VERSION(*(tptr + 5)))); /* fall through */\n            case EAP_TYPE_TLS:\n                ND_PRINT((ndo, \" flags [%s] 0x%02x,\",\n                       bittok2str(eap_tls_flags_values, \"none\", *(tptr+5)),\n                       *(tptr + 5)));\n\n                if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {\n\t\t    ND_PRINT((ndo, \" len %u\", EXTRACT_32BITS(tptr + 6)));\n                }\n                break;\n\n            case EAP_TYPE_FAST:\n                ND_PRINT((ndo, \" FASTv%u\",\n                       EAP_TTLS_VERSION(*(tptr + 5))));\n                ND_PRINT((ndo, \" flags [%s] 0x%02x,\",\n                       bittok2str(eap_tls_flags_values, \"none\", *(tptr+5)),\n                       *(tptr + 5)));\n\n                if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {\n                    ND_PRINT((ndo, \" len %u\", EXTRACT_32BITS(tptr + 6)));\n                }\n\n                /* FIXME - TLV attributes follow */\n                break;\n\n            case EAP_TYPE_AKA:\n            case EAP_TYPE_SIM:\n                ND_PRINT((ndo, \" subtype [%s] 0x%02x,\",\n                       tok2str(eap_aka_subtype_values, \"unknown\", *(tptr+5)),\n                       *(tptr + 5)));\n\n                /* FIXME - TLV attributes follow */\n                break;\n\n            case EAP_TYPE_MD5_CHALLENGE:\n            case EAP_TYPE_OTP:\n            case EAP_TYPE_GTC:\n            case EAP_TYPE_EXPANDED_TYPES:\n            case EAP_TYPE_EXPERIMENTAL:\n            default:\n                break;\n            }\n        }\n        break;\n\n    case EAP_FRAME_TYPE_LOGOFF:\n    case EAP_FRAME_TYPE_ENCAP_ASF_ALERT:\n    default:\n        break;\n    }\n    return;\n\n trunc:\n    ND_PRINT((ndo, \"\\n\\t[|EAP]\"));\n}\n",
        "fix": null,
        "src_path": "985122081165753c7442bd7824c473eb9ff56308___print-eap.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/985122081165753c7442bd7824c473eb9ff56308",
        "commit_msg": "CVE-2017-13015/EAP: Add more bounds checks.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -512,6 +512,7 @@ wb-oobr\t\t\twb-oobr.pcap\t\t\twb-oobr.out\t-v\n lldp_asan\t\tlldp_asan.pcap\t\t\tlldp_asan.out\t-v\n extract_read2_asan\textract_read2_asan.pcap\t\textract_read2_asan.out\t-v\n getname_2_read4_asan\tgetname_2_read4_asan.pcap\tgetname_2_read4_asan.out\t-v\n+eap_extract_read2_asan\teap_extract_read2_asan.pcap\teap_extract_read2_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/eap_extract_read2_asan.out",
                "patch": "@@ -0,0 +1,2 @@\n+EAP packet (0) v155, len 0\n+\t[|EAP]"
            }
        ],
        "error_msg": "    eap_extract_read2_asan             : TEST FAILED(exit 256)\n"
    },
    "1bc78d795cd5cad5525498658f414a11ea0a7e9c___print-radius.c": {
        "start": 494,
        "end": 557,
        "buggy": "static void\nprint_attr_string(netdissect_options *ndo,\n                  register const u_char *data, u_int length, u_short attr_code)\n{\n   register u_int i;\n\n   ND_TCHECK2(data[0],length);\n\n   switch(attr_code)\n   {\n      case TUNNEL_PASS:\n           if (length < 3)\n           {\n              ND_PRINT((ndo, \"%s\", tstr));\n              return;\n           }\n           if (*data && (*data <=0x1F) )\n              ND_PRINT((ndo, \"Tag[%u] \", *data));\n           else\n              ND_PRINT((ndo, \"Tag[Unused] \"));\n           data++;\n           length--;\n           ND_PRINT((ndo, \"Salt %u \", EXTRACT_16BITS(data)));\n           data+=2;\n           length-=2;\n        break;\n      case TUNNEL_CLIENT_END:\n      case TUNNEL_SERVER_END:\n      case TUNNEL_PRIV_GROUP:\n      case TUNNEL_ASSIGN_ID:\n      case TUNNEL_CLIENT_AUTH:\n      case TUNNEL_SERVER_AUTH:\n           if (*data <= 0x1F)\n           {\n              if (length < 1)\n              {\n                 ND_PRINT((ndo, \"%s\", tstr));\n                 return;\n              }\n              if (*data)\n                ND_PRINT((ndo, \"Tag[%u] \", *data));\n              else\n                ND_PRINT((ndo, \"Tag[Unused] \"));\n              data++;\n              length--;\n           }\n        break;\n      case EGRESS_VLAN_NAME:\n           ND_PRINT((ndo, \"%s (0x%02x) \",\n                  tok2str(rfc4675_tagged,\"Unknown tag\",*data),\n                  *data));\n           data++;\n           length--;\n        break;\n   }\n\n   for (i=0; *data && i < length ; i++, data++)\n       ND_PRINT((ndo, \"%c\", (*data < 32 || *data > 126) ? '.' : *data));\n\n   return;\n\n   trunc:\n      ND_PRINT((ndo, \"%s\", tstr));\n}\n",
        "fix": null,
        "src_path": "1bc78d795cd5cad5525498658f414a11ea0a7e9c___print-radius.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/1bc78d795cd5cad5525498658f414a11ea0a7e9c",
        "commit_msg": "CVE-2017-13032/RADIUS: Check whether a byte exists before testing its value.\n\nReverse the test in a for loop to test the length before testing whether\nwe have a null byte.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.\n\nClean up other length tests while we're at it.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -541,6 +541,7 @@ pim_header_asan\t\tpim_header_asan.pcap\t\tpim_header_asan.out\t-v\n pim_header_asan-2\tpim_header_asan-2.pcap\t\tpim_header_asan-2.out\t-v\n pim_header_asan-3\tpim_header_asan-3.pcap\t\tpim_header_asan-3.out\t-v\n ip6_frag_asan\t\tip6_frag_asan.pcap\t\tip6_frag_asan.out\t-v\n+radius_attr_asan\tradius_attr_asan.pcap\t\tradius_attr_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/radius_attr_asan.out",
                "patch": "@@ -0,0 +1,9 @@\n+IP (tos 0x64, ttl 249, id 40192, offset 0, flags [+, DF, rsvd], proto UDP (17), length 299, options (unknown 235 [bad length 252]), bad cksum 8000 (->1faa)!)\n+    0.0.86.32.258 > 0.2.250.99.3799: RADIUS, length: 263\n+\tUnknown Command (58), id: 0x6a, Authenticator: 0901020ed7ff03edb63a0f00cb0f00cb\n+\t  NAS-Port Attribute (5), length: 5, Value: ERROR: length 3 != 4\n+\t  Unknown Attribute (127), length: 4, Value: \n+\t  NAS-IP-Address Attribute (4), length: 4, Value: ERROR: length 2 != 4\n+\t  NAS-IP-Address Attribute (4), length: 4, Value: ERROR: length 2 != 4\n+\t  NAS-IP-Address Attribute (4), length: 4, Value: ERROR: length 2 != 4\n+\t  Callback-Id Attribute (20), length: 4, Value: .. [|radius]"
            }
        ],
        "error_msg": "    radius_attr_asan                   : passed\n"
    },
    "39582c04cc5e34054b2936b423072fb9df2ff6ef___print-hncp.c": {
        "start": 311,
        "end": 358,
        "buggy": "static int\ndhcpv6_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint16_t type, optlen;\n\n    i = 0;\n    while (i < length) {\n        tlv = cp + i;\n        type = EXTRACT_16BITS(tlv);\n        optlen = EXTRACT_16BITS(tlv + 2);\n        value = tlv + 4;\n\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n\n        ND_PRINT((ndo, \"%s\", tok2str(dh6opt_str, \"Unknown\", type)));\n        ND_PRINT((ndo,\" (%u)\", optlen + 4 ));\n\n        switch (type) {\n            case DH6OPT_DNS_SERVERS:\n            case DH6OPT_SNTP_SERVERS: {\n                if (optlen % 16 != 0) {\n                    ND_PRINT((ndo, \" %s\", istr));\n                    return -1;\n                }\n                for (t = 0; t < optlen; t += 16)\n                    ND_PRINT((ndo, \" %s\", ip6addr_string(ndo, value + t)));\n            }\n                break;\n            case DH6OPT_DOMAIN_LIST: {\n                const u_char *tp = value;\n                while (tp < value + optlen) {\n                    ND_PRINT((ndo, \" \"));\n                    if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                        return -1;\n                }\n            }\n                break;\n        }\n\n        i += 4 + optlen;\n    }\n    return 0;\n}\n",
        "fix": null,
        "src_path": "39582c04cc5e34054b2936b423072fb9df2ff6ef___print-hncp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/39582c04cc5e34054b2936b423072fb9df2ff6ef",
        "commit_msg": "CVE-2017-13042/HNCP: add DHCPv6-Data bounds checks\n\nhncp_print_rec() validates each HNCP TLV to be within the declared as\nwell as the on-the-wire packet space. However, dhcpv6_print() in the same\nfile didn't do the same for the DHCPv6 options within the HNCP\nDHCPv6-Data TLV value, which could cause an out-of-bounds read when\ndecoding an invalid packet. Add missing checks to dhcpv6_print().\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -554,6 +554,12 @@ radius_attr_asan\tradius_attr_asan.pcap\t\tradius_attr_asan.out\t-v\n ospf6_decode_v3_asan\tospf6_decode_v3_asan.pcap\tospf6_decode_v3_asan.out -v\n ip_ts_opts_asan\t\tip_ts_opts_asan.pcap\t\tip_ts_opts_asan.out\t-v\n isakmpv1-attr-oobr\tisakmpv1-attr-oobr.pcap\t\tisakmpv1-attr-oobr.out\t-v\n+# The case below depends on the bug in print-hncp.c, which at the time of\n+# discovery had codepoints for DHCPv6-Data and DHCPv4-Data swapped around.\n+# After the bugfix the output will be different because of the different\n+# code path and will not test the vulnerability unless modified respectively.\n+# The .pcap file is truncated after the 1st packet.\n+hncp_dhcpv6data-oobr\thncp_dhcpv6data-oobr.pcap\thncp_dhcpv6data-oobr.out -v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/hncp_dhcpv6data-oobr.out",
                "patch": "@@ -0,0 +1,7 @@\n+IP6 (flowlabel 0x01cc3, hlim 234, next-header UDP (17) payload length: 11025) 400::e4ff:ffff:adf9:8900:0.1646 > 62:9de3:ff47:ebec:8206:ff00:ad:ff00.8231: hncp (11017)\n+\tFuture use: type=16384 (5)\n+\tDHCPv6-Data (25)\n+\t\tUnknown (4)\n+\t\tUnknown (4)\n+\t\tSNTP-servers (61956)  (invalid)\n+\t[|hncp]"
            }
        ],
        "error_msg": "    hncp_dhcpv6data-oobr               : TEST FAILED(exit 256)\n"
    },
    "c2f6833dddecf2d5fb89c9c898eee9981da342ed___print-hncp.c": {
        "start": 263,
        "end": 309,
        "buggy": "static int\ndhcpv4_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint8_t type, optlen;\n\n    i = 0;\n    while (i < length) {\n        tlv = cp + i;\n        type = (uint8_t)tlv[0];\n        optlen = (uint8_t)tlv[1];\n        value = tlv + 2;\n\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n\n        ND_PRINT((ndo, \"%s\", tok2str(dh4opt_str, \"Unknown\", type)));\n        ND_PRINT((ndo,\" (%u)\", optlen + 2 ));\n\n        switch (type) {\n        case DH4OPT_DNS_SERVERS:\n        case DH4OPT_NTP_SERVERS: {\n            if (optlen < 4 || optlen % 4 != 0) {\n                return -1;\n            }\n            for (t = 0; t < optlen; t += 4)\n                ND_PRINT((ndo, \" %s\", ipaddr_string(ndo, value + t)));\n        }\n            break;\n        case DH4OPT_DOMAIN_SEARCH: {\n            const u_char *tp = value;\n            while (tp < value + optlen) {\n                ND_PRINT((ndo, \" \"));\n                if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                    return -1;\n            }\n        }\n            break;\n        }\n\n        i += 2 + optlen;\n    }\n    return 0;\n}\n",
        "fix": null,
        "src_path": "c2f6833dddecf2d5fb89c9c898eee9981da342ed___print-hncp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/c2f6833dddecf2d5fb89c9c898eee9981da342ed",
        "commit_msg": "CVE-2017-13044/HNCP: add DHCPv4-Data bounds checks\n\ndhcpv4_print() in print-hncp.c had the same bug as dhcpv6_print(), apply\na fix along the same lines.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -560,6 +560,8 @@ isakmpv1-attr-oobr\tisakmpv1-attr-oobr.pcap\t\tisakmpv1-attr-oobr.out\t-v\n # code path and will not test the vulnerability unless modified respectively.\n # The .pcap file is truncated after the 1st packet.\n hncp_dhcpv6data-oobr\thncp_dhcpv6data-oobr.pcap\thncp_dhcpv6data-oobr.out -v -c1\n+# Same comments apply to the case below.\n+hncp_dhcpv4data-oobr\thncp_dhcpv4data-oobr.pcap\thncp_dhcpv4data-oobr.out -v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/hncp_dhcpv4data-oobr.out",
                "patch": "@@ -0,0 +1,4 @@\n+IP truncated-ip - 260 bytes missing! (tos 0x12,ECT(0), ttl 48, id 21323, offset 0, flags [+, DF, rsvd], proto UDP (17), length 296, bad cksum 8e0f (->cd08)!)\n+    1.2.7.0.1812 > 128.253.0.96.8231: hncp (268)\n+\tDHCPv4-Data (6)\n+\t\tDNS-server (98) (invalid)"
            }
        ],
        "error_msg": "    hncp_dhcpv4data-oobr               : TEST FAILED(exit 256)\n"
    },
    "d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514___print-bgp.c": {
        "start": 906,
        "end": 991,
        "buggy": "static int\ndecode_multicast_vpn(netdissect_options *ndo,\n                     const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t route_type, route_length, addr_length, sg_length;\n        u_int offset;\n\n\tND_TCHECK2(pptr[0], 2);\n        route_type = *pptr++;\n        route_length = *pptr++;\n\n        snprintf(buf, buflen, \"Route-Type: %s (%u), length: %u\",\n                 tok2str(bgp_multicast_vpn_route_type_values,\n                         \"Unknown\", route_type),\n                 route_type, route_length);\n\n        switch(route_type) {\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s, Originator %s\",\n                     bgp_vpn_rd_print(ndo, pptr),\n                     bgp_vpn_ip_print(ndo, pptr + BGP_VPN_RD_LEN,\n                                      (route_length - BGP_VPN_RD_LEN) << 3));\n            break;\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            sg_length = bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            addr_length =  route_length - sg_length;\n\n            ND_TCHECK2(pptr[0], addr_length);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", Originator %s\",\n                     bgp_vpn_ip_print(ndo, pptr, addr_length << 3));\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN: /* fall through */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            pptr += BGP_VPN_RD_LEN;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n            /*\n             * no per route-type printing yet.\n             */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF:\n        default:\n            break;\n        }\n\n        return route_length + 2;\n\ntrunc:\n\treturn -2;\n}\n",
        "fix": null,
        "src_path": "d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514___print-bgp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514",
        "commit_msg": "CVE-2017-13043/BGP: fix decoding of MVPN route types 6 and 7\n\nRFC 6514 Section 4.6 defines the structure for Shared Tree Join (6) and\nSource Tree Join (7) multicast VPN route types. decode_multicast_vpn()\ndidn't implement the Source AS field of that structure properly, adjust\nthe offsets to put it right.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -564,6 +564,7 @@ hncp_dhcpv6data-oobr\thncp_dhcpv6data-oobr.pcap\thncp_dhcpv6data-oobr.out -v -c1\n hncp_dhcpv4data-oobr\thncp_dhcpv4data-oobr.pcap\thncp_dhcpv4data-oobr.out -v -c1\n vqp-oobr\t\tvqp-oobr.pcap\t\t\tvqp-oobr.out\t\t-v -c1\n bgp_pmsi_tunnel-oobr\tbgp_pmsi_tunnel-oobr.pcap\tbgp_pmsi_tunnel-oobr.out -v -c1\n+bgp_mvpn_6_and_7\tbgp_mvpn_6_and_7.pcap\t\tbgp_mvpn_6_and_7.out\t-v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/bgp_mvpn_6_and_7.out",
                "patch": "@@ -0,0 +1,13 @@\n+IP (tos 0xc, ttl 254, id 21263, offset 0, flags [rsvd], proto TCP (6), length 517, bad cksum 8e15 (->99c9)!)\n+    241.0.93.20.179 > 255.247.0.1.200: Flags [none], seq 2146691977:2146692450, win 56026, options [unknown-161,eol], length 473: BGP\n+\tUpdate Message (2), length: 45\n+\t  Withdrawn routes: 3 bytes\n+\t  Attribute Set (128), length: 7, Flags [OTPE+f]: \n+\t    Origin AS: 148\n+\t      Multi-Protocol Reach NLRI (14), length: 71, Flags [T+6]: \n+\t    AFI: IPv4 (1), SAFI: Multicast VPN (5), nh-length: 0, no SNPA\n+\t      Route-Type: Intra-AS I-PMSI (1), length: 0, RD: 62209:33686018 (= 2.2.2.2), Originator bogus address length 4294967232\n+\t      Route-Type: Unknown (0), length: 0\n+\t      Route-Type: Unknown (243), length: 1\n+\t      Route-Type: Inter-AS I-PMSI (2), length: 2, RD: unknown RD format, Source-AS 368115805\n+\t      Route-Type: Inter-AS I-PMSI (2), length: 2, RD: unknown RD format, Source-AS 335544320[|BGP]"
            }
        ],
        "error_msg": "    bgp_mvpn_6_and_7                   : TEST FAILED(exit 256)\n"
    },
    "bd4e697ebd6c8457efa8f28f6831fc929b88a014___print-bgp.c": {
        "start": 758,
        "end": 796,
        "buggy": "static int\ndecode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n{\n\tuint8_t route_target[8];\n\tu_int plen;\n\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   /* get prefix length */\n\n\tif (0 == plen) {\n\t\tsnprintf(buf, buflen, \"default route target\");\n\t\treturn 1;\n\t}\n\n\tif (32 > plen)\n\t\treturn -1;\n\n        plen-=32; /* adjust prefix length */\n\n\tif (64 < plen)\n\t\treturn -1;\n\n\tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[1], (plen + 7) / 8);\n\tmemcpy(&route_target, &pptr[1], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),\n\t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n\n\treturn 5 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}\n",
        "fix": null,
        "src_path": "bd4e697ebd6c8457efa8f28f6831fc929b88a014___print-bgp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/bd4e697ebd6c8457efa8f28f6831fc929b88a014",
        "commit_msg": "CVE-2017-13053/BGP: fix VPN route target bounds checks\n\ndecode_rt_routing_info() didn't check bounds before fetching 4 octets of\nthe origin AS field and could over-read the input buffer, put it right.\n\nIt also fetched the varying number of octets of the route target field\nfrom 4 octets lower than the correct offset, put it right.\n\nIt also used the same temporary buffer explicitly through as_printf()\nand implicitly through bgp_vpn_rd_print() so the end result of snprintf()\nwas not what was originally intended.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -572,6 +572,7 @@ rsvp_uni-oobr-2\trsvp_uni-oobr-2.pcap\trsvp_uni-oobr-2.out\t-v -c1\n rsvp_uni-oobr-3\trsvp_uni-oobr-3.pcap\trsvp_uni-oobr-3.out\t-v -c3\n rpki-rtr-oob\t\trpki-rtr-oob.pcap\trpki-rtr-oob.out\t-v -c1\n lldp_8023_mtu-oobr\tlldp_8023_mtu-oobr.pcap\tlldp_8023_mtu-oobr.out\t-v -c1\n+bgp_vpn_rt-oobr\tbgp_vpn_rt-oobr.pcap\tbgp_vpn_rt-oobr.out\t-v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/bgp_vpn_rt-oobr.out",
                "patch": "@@ -0,0 +1,43 @@\n+IP (tos 0xc, ttl 254, id 21263, offset 0, flags [rsvd], proto TCP (6), length 60165, bad cksum 8e15 (->9eb8)!)\n+    241.0.128.19.179 > 239.8.0.1.0: Flags [none], seq 2146695561:2146755682, win 56026, options [unknown-161,eol], length 60121: BGP\n+\tUpdate Message (2), length: 45\n+\t  Withdrawn routes: 3 bytes\n+\t  Attribute Set (128), length: 7, Flags [OTPE+f]: \n+\t    Origin AS: 0\n+\t      Multi-Protocol Unreach NLRI (15), length: 227, Flags [T+6]: \n+\t    AFI: IPv6 (2), SAFI: Multicast VPN (5)\n+\t      Route-Type: Source-Active (5), length: 5, RD: unknown RD format, Group bogus address length 127\n+\t      Route-Type: Unknown (142), length: 142\n+\t      Route-Type: Unknown (0), length: 0\n+\t      Route-Type: Unknown (33), length: 0\n+\t      Route-Type: Unknown (0), length: 0[|BGP] [|BGP]\n+\tUpdate Message (2), length: 45[|BGP] [|BGP]\n+\tUpdate Message (2), length: 45\n+\t  Withdrawn routes: 3 bytes\n+\t  Attribute Set (128), length: 7, Flags [OTPE+f]: \n+\t    Origin AS: 0\n+\t      Multi-Protocol Reach NLRI (14), length: 227, Flags [T+6]: \n+\t    AFI: IPv4 (1), vendor specific SAFI: Route Target Routing Information (132)\n+\t    nexthop: invalid len, nh-length: 1, no SNPA\n+\t      origin AS: 0, route target 0:0 (= 0.0.0.0)\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target\n+\t      default route target[|BGP]"
            }
        ],
        "error_msg": "    bgp_vpn_rt-oobr                    : TEST FAILED(exit 256)\n"
    },
    "926f796e8feec15f3836aa0a060ed906f8ae04d3___resolve.c": {
        "start": 623,
        "end": 639,
        "buggy": "Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){\n  Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);\n  if( p ){\n    struct SrcList_item *pItem = &pSrc->a[iSrc];\n    p->y.pTab = pItem->pTab;\n    p->iTable = pItem->iCursor;\n    if( p->y.pTab->iPKey==iCol ){\n      p->iColumn = -1;\n    }else{\n      p->iColumn = (ynVar)iCol;\n      testcase( iCol==BMS );\n      testcase( iCol==BMS-1 );\n      pItem->colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);\n    }\n  }\n  return p;\n}\n",
        "fix": null,
        "src_path": "926f796e8feec15f3836aa0a060ed906f8ae04d3___resolve.c",
        "uri": "https://api.github.com/repos/sqlite/sqlite/commits/926f796e8feec15f3836aa0a060ed906f8ae04d3",
        "commit_msg": "Ensure that the SrcList_item.colUsed field is set correctly (set to have a\n1 for all columns of the table) when a generated column appears in the USING\nclause of a join.\n\nFossilOrigin-Name: 1923efb283e8840fa7436eb20b9d2174ef7cace1690d3b97b572a0db2048b8e3",
        "test_func_diff": [
            {
                "fn": "test/gencol1.test",
                "patch": "@@ -342,4 +342,19 @@ do_execsql_test gencol1-12.10 {\n   PRAGMA integrity_check;\n } {ok}\n \n+# 2019-12-09 but report from Yongheng Chen\n+# Ensure that the SrcList_item.colUsed field is set correctly when a\n+# generated column appears in the USING clause of a join.\n+#\n+do_execsql_test gencol1-13.10 {\n+  CREATE TABLE t1(x, y AS(x+1));\n+  INSERT INTO t1 VALUES(10);\n+  SELECT y FROM t1 JOIN t1 USING (y,y);\n+} {11}\n+do_execsql_test gencol1-13.11 {\n+  CREATE INDEX t1y ON t1(y);\n+  SELECT y FROM t1 JOIN t1 USING (y,y);\n+} {11}\n+\n+\n finish_test"
            }
        ],
        "error_msg": "warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/usr/lib/x86_64-linux-gnu/libthread_db.so.1\".\ngencol1-13.10...\n! gencol1-13.10 expected: [11]\n! gencol1-13.10 got:      []\n[Detaching after fork from child process 175649]\nSQLite 2019-12-09 17:14:48 1923efb283e8840fa7436eb20b9d2174ef7cace1690d3b97b572a0db2048b8e3\n1 errors out of 103 tests on wangjian Linux 64-bit little-endian\n!Failures on these tests: gencol1-13.10\nAll memory allocations freed - no leaks\nMemory used:          now          0  max     342280  max-size     120000\nAllocation count:     now          0  max        382\nPage-cache used:      now          0  max          0  max-size       1288\nPage-cache overflow:  now          0  max      14688\nMaximum memory usage: 342280 bytes\nCurrent memory usage: 0 bytes\nNumber of malloc()  : -1 calls\n[Inferior 1 (process 171831) exited with code 01]\n"
    },
    "f25486c3d4aa472fec79150f2c41ed4333395d3d___jpc_t2cod.c": {
        "start": 223,
        "end": 323,
        "buggy": "static int jpc_pi_nextrpcl(register jpc_pi_t *pi)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_pchg_t *pchg;\n\tint prchind;\n\tint prcvind;\n\tint *prclyrno;\n\tint compno;\n\tjpc_picomp_t *picomp;\n\tint xstep;\n\tint ystep;\n\tuint_fast32_t r;\n\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\tuint_fast32_t trx0;\n\tuint_fast32_t try0;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->xstep = 0;\n\t\tpi->ystep = 0;\n\t\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t\t  ++compno, ++picomp) {\n\t\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\t\t// Check for the potential for overflow problems.\n\t\t\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >\n\t\t\t\t  JAS_UINTFAST32_NUMBITS - 2 ||\n\t\t\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >\n\t\t\t\t  JAS_UINTFAST32_NUMBITS - 2) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\txstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t\t\t  (pirlvl->prcwidthexpn + picomp->numrlvls - rlvlno - 1));\n\t\t\t\tystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t\t\t  (pirlvl->prcheightexpn + picomp->numrlvls - rlvlno - 1));\n\t\t\t\tpi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);\n\t\t\t\tpi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);\n\t\t\t}\n\t\t}\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pchg->rlvlnoend &&\n\t  pi->rlvlno < pi->maxrlvls; ++pi->rlvlno) {\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend; pi->y +=\n\t\t  pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend; pi->x +=\n\t\t\t  pi->xstep - (pi->x % pi->xstep)) {\n\t\t\t\tfor (pi->compno = pchg->compnostart,\n\t\t\t\t  pi->picomp = &pi->picomps[pi->compno];\n\t\t\t\t  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno <\n\t\t\t\t  pi->numcomps; ++pi->compno, ++pi->picomp) {\n\t\t\t\t\tif (pi->rlvlno >= pi->picomp->numrlvls) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\tif (((pi->x == pi->xstart &&\n\t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx)))\n\t\t\t\t\t  || !(pi->x % (JAS_CAST(uint_fast32_t, 1) << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart &&\n\t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy)))\n\t\t\t\t\t  || !(pi->y % (JAS_CAST(uint_fast32_t, 1) << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,\n\t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,\n\t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;\n\n\t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <\n\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int,\n\t\t\t\t\t\t  pchg->lyrnoend); ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n",
        "fix": null,
        "src_path": "f25486c3d4aa472fec79150f2c41ed4333395d3d___jpc_t2cod.c",
        "uri": "https://api.github.com/repos/mdadams/jasper/commits/f25486c3d4aa472fec79150f2c41ed4333395d3d",
        "commit_msg": "Fixed a bug in the packet iterator code.\nAdded a new regression test case.",
        "test_func_diff": [],
        "error_msg": "AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==112994==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7fe016021f64 bp 0x7fffc670c0b0 sp 0x7fffc670b900 T0)\n==112994==The signal is caused by a READ memory access.\n==112994==Hint: address points to the zero page.\n    #0 0x7fe016021f64 in jpc_pi_nextrpcl jpc_t2cod.c\n    #1 0x7fe01601f790 in jpc_pi_next (/out/mdadams___jasper/git_repo_dir/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/libjasper/libjasper.so.4+0x116790)\n    #2 0x7fe01602b681 in jpc_dec_decodepkts (/out/mdadams___jasper/git_repo_dir/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/libjasper/libjasper.so.4+0x122681)\n    #3 0x7fe015f92d16 in jpc_dec_process_sod jpc_dec.c\n    #4 0x7fe015f9931f in jpc_dec_decode jpc_dec.c\n    #5 0x7fe015f97ddb in jpc_decode (/out/mdadams___jasper/git_repo_dir/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/libjasper/libjasper.so.4+0x8eddb)\n    #6 0x7fe015f48581 in jas_image_decode (/out/mdadams___jasper/git_repo_dir/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/libjasper/libjasper.so.4+0x3f581)\n    #7 0x555c007ce9e5 in main (/mnt/local/home_dir/wj_code/dl_code/out/mdadams___jasper/git_repo_dir/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/appl/imginfo+0xf29e5)\n    #8 0x7fe015afb082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #9 0x555c006fb3dd in _start (/mnt/local/home_dir/wj_code/dl_code/out/mdadams___jasper/git_repo_dir/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/appl/imginfo+0x1f3dd)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV jpc_t2cod.c in jpc_pi_nextrpcl\n==112994==ABORTING\n"
    },
    "fb0e0cce0b9f25389ab56604c3547351617e1415___gd_tga.c": {
        "start": 206,
        "end": 336,
        "buggy": "int read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tint* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint encoded_pixels;\n\tint rle_size;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\trle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);\n\t\tif (rle_size <= 0) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < rle_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n\t\t\t\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));\n\t\t\t\t\tbitmap_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));\n\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n",
        "fix": null,
        "src_path": "fb0e0cce0b9f25389ab56604c3547351617e1415___gd_tga.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/fb0e0cce0b9f25389ab56604c3547351617e1415",
        "commit_msg": "Fix OOB reads of the TGA decompression buffer\n\nIt is possible to craft TGA files which will overflow the decompression\nbuffer, but not the image's bitmap. Therefore we augment the check for the\nbitmap's overflow with a check for the buffer's overflow.\n\nThis issue had been reported by Ibrahim El-Sayed to security@libgd.org.\n\nCVE-2016-6906",
        "test_func_diff": [
            {
                "fn": "tests/tga/.gitignore",
                "patch": "@@ -3,5 +3,6 @@\n /bug00247a\n /bug00248\n /bug00248a\n+/heap_overflow\n /tga_null\n /tga_read"
            },
            {
                "fn": "tests/tga/CMakeLists.txt",
                "patch": "@@ -5,6 +5,7 @@ LIST(APPEND TESTS_FILES\n \tbug00247a\n \tbug00248\n \tbug00248a\n+\theap_overflow\n \ttga_read\n )\n "
            },
            {
                "fn": "tests/tga/Makemodule.am",
                "patch": "@@ -4,6 +4,7 @@ libgd_test_programs += \\\n \ttga/bug00247a \\\n \ttga/bug00248 \\\n \ttga/bug00248a \\\n+\ttga/heap_overflow \\\n \ttga/tga_null \\\n \ttga/tga_read\n \n@@ -14,6 +15,7 @@ EXTRA_DIST += \\\n \ttga/bug00247a.tga \\\n \ttga/bug00248.tga \\\n \ttga/bug00248a.tga \\\n+\ttga/heap_overflow.tga \\\n \ttga/tga_read_rgb.png \\\n \ttga/tga_read_rgb.tga \\\n \ttga/tga_read_rgb_rle.tga"
            },
            {
                "fn": "tests/tga/heap_overflow.c",
                "patch": "@@ -0,0 +1,51 @@\n+/**\n+ * Test that the crafted TGA file doesn't trigger OOB reads.\n+ */\n+\n+\n+#include \"gd.h\"\n+#include \"gdtest.h\"\n+\n+\n+static size_t read_test_file(char **buffer, char *basename);\n+\n+\n+int main()\n+{\n+    gdImagePtr im;\n+    char *buffer;\n+    size_t size;\n+\n+    size = read_test_file(&buffer, \"heap_overflow.tga\");\n+    im = gdImageCreateFromTgaPtr(size, (void *) buffer);\n+    gdTestAssert(im == NULL);\n+    free(buffer);\n+\n+    return gdNumFailures();\n+}\n+\n+\n+static size_t read_test_file(char **buffer, char *basename)\n+{\n+    char *filename;\n+    FILE *fp;\n+    size_t exp_size, act_size;\n+\n+    filename = gdTestFilePath2(\"tga\", basename);\n+    fp = fopen(filename, \"rb\");\n+    gdTestAssert(fp != NULL);\n+\n+\tfseek(fp, 0, SEEK_END);\n+\texp_size = ftell(fp);\n+\tfseek(fp, 0, SEEK_SET);\n+\n+    *buffer = malloc(exp_size);\n+    gdTestAssert(*buffer != NULL);\n+    act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);\n+    gdTestAssert(act_size == exp_size);\n+\n+    fclose(fp);\n+    free(filename);\n+\n+    return act_size;\n+}"
            }
        ],
        "error_msg": "========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 152\n# PASS:  149\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  3\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:31: Total pixels changed: 9 with a maximum channel difference of 255.\nfreetype/bug00132.c:33: Reference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\ngdimagestringft/gdimagestringft_bbox.c:56: (491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\nFAIL: tga/heap_overflow\n=======================\n\nFAIL tga/heap_overflow (exit status: 139)\n\n"
    },
    "fe9ed49dafa993e3af96b6a5a589efeea9bfb36f___gd_gd2.c": {
        "start": 405,
        "end": 566,
        "buggy": "BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)\n{\n\tint sx, sy;\n\tint i;\n\tint ncx, ncy, nc, cs, cx, cy;\n\tint x, y, ylo, yhi, xlo, xhi;\n\tint vers, fmt;\n\tt_chunk_info *chunkIdx = NULL;\t/* So we can gdFree it with impunity. */\n\tunsigned char *chunkBuf = NULL;\t/* So we can gdFree it with impunity. */\n\tint chunkNum = 0;\n\tint chunkMax = 0;\n\tuLongf chunkLen;\n\tint chunkPos = 0;\n\tint compMax = 0;\n\tint bytesPerPixel;\n\tchar *compBuf = NULL;\t\t/* So we can gdFree it with impunity. */\n\n\tgdImagePtr im;\n\n\t/* Get the header */\n\tim =\n\t    _gd2CreateFromFile (in, &sx, &sy, &cs, &vers, &fmt, &ncx, &ncy,\n\t                        &chunkIdx);\n\tif (im == NULL) {\n\t\t/* No need to free chunkIdx as _gd2CreateFromFile does it for us. */\n\t\treturn 0;\n\t}\n\n\tbytesPerPixel = im->trueColor ? 4 : 1;\n\tnc = ncx * ncy;\n\n\tif (gd2_compressed (fmt)) {\n\t\t/* Find the maximum compressed chunk size. */\n\t\tcompMax = 0;\n\t\tfor (i = 0; (i < nc); i++) {\n\t\t\tif (chunkIdx[i].size > compMax) {\n\t\t\t\tcompMax = chunkIdx[i].size;\n\t\t\t};\n\t\t};\n\t\tcompMax++;\n\n\t\t/* Allocate buffers */\n\t\tchunkMax = cs * bytesPerPixel * cs;\n\t\tchunkBuf = gdCalloc (chunkMax, 1);\n\t\tif (!chunkBuf) {\n\t\t\tgoto fail;\n\t\t}\n\t\tcompBuf = gdCalloc (compMax, 1);\n\t\tif (!compBuf) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tGD2_DBG (printf (\"Largest compressed chunk is %d bytes\\n\", compMax));\n\t};\n\n\t/*      if ( (ncx != sx / cs) || (ncy != sy / cs)) { */\n\t/*              goto fail2; */\n\t/*      }; */\n\n\t/* Read the data... */\n\tfor (cy = 0; (cy < ncy); cy++) {\n\t\tfor (cx = 0; (cx < ncx); cx++) {\n\n\t\t\tylo = cy * cs;\n\t\t\tyhi = ylo + cs;\n\t\t\tif (yhi > im->sy) {\n\t\t\t\tyhi = im->sy;\n\t\t\t};\n\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"Processing Chunk %d (%d, %d), y from %d to %d\\n\",\n\t\t\t          chunkNum, cx, cy, ylo, yhi));\n\n\t\t\tif (gd2_compressed (fmt)) {\n\n\t\t\t\tchunkLen = chunkMax;\n\n\t\t\t\tif (!_gd2ReadChunk (chunkIdx[chunkNum].offset,\n\t\t\t\t                    compBuf,\n\t\t\t\t                    chunkIdx[chunkNum].size,\n\t\t\t\t                    (char *) chunkBuf, &chunkLen, in)) {\n\t\t\t\t\tGD2_DBG (printf (\"Error reading comproessed chunk\\n\"));\n\t\t\t\t\tgoto fail;\n\t\t\t\t};\n\n\t\t\t\tchunkPos = 0;\n\t\t\t};\n\n\t\t\tfor (y = ylo; (y < yhi); y++) {\n\n\t\t\t\txlo = cx * cs;\n\t\t\t\txhi = xlo + cs;\n\t\t\t\tif (xhi > im->sx) {\n\t\t\t\t\txhi = im->sx;\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"y=%d: \",y)); */\n\t\t\t\tif (!gd2_compressed (fmt)) {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tif (!gdGetInt (&im->tpixels[y][x], in)) {\n\t\t\t\t\t\t\t\t/*printf(\"EOF while reading\\n\"); */\n\t\t\t\t\t\t\t\t/*gdImageDestroy(im); */\n\t\t\t\t\t\t\t\t/*return 0; */\n\t\t\t\t\t\t\t\tim->tpixels[y][x] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint ch;\n\t\t\t\t\t\t\tif (!gdGetByte (&ch, in)) {\n\t\t\t\t\t\t\t\t/*printf(\"EOF while reading\\n\"); */\n\t\t\t\t\t\t\t\t/*gdImageDestroy(im); */\n\t\t\t\t\t\t\t\t/*return 0; */\n\t\t\t\t\t\t\t\tch = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tim->pixels[y][x] = ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\t/* 2.0.1: work around a gcc bug by being verbose.\n\t\t\t\t\t\t\t   TBB */\n\t\t\t\t\t\t\tint a = chunkBuf[chunkPos++] << 24;\n\t\t\t\t\t\t\tint r = chunkBuf[chunkPos++] << 16;\n\t\t\t\t\t\t\tint g = chunkBuf[chunkPos++] << 8;\n\t\t\t\t\t\t\tint b = chunkBuf[chunkPos++];\n\t\t\t\t\t\t\t/* 2.0.11: tpixels */\n\t\t\t\t\t\t\tim->tpixels[y][x] = a + r + g + b;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tim->pixels[y][x] = chunkBuf[chunkPos++];\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"\\n\")); */\n\t\t\t};\n\t\t\tchunkNum++;\n\t\t};\n\t};\n\n\tGD2_DBG (printf (\"Freeing memory\\n\"));\n\n\tgdFree (chunkBuf);\n\tgdFree (compBuf);\n\tgdFree (chunkIdx);\n\n\tGD2_DBG (printf (\"Done\\n\"));\n\n\treturn im;\n\nfail:\n\tgdImageDestroy (im);\n\tif (chunkBuf) {\n\t\tgdFree (chunkBuf);\n\t}\n\tif (compBuf) {\n\t\tgdFree (compBuf);\n\t}\n\tif (chunkIdx) {\n\t\tgdFree (chunkIdx);\n\t}\n\treturn 0;\n}\n",
        "fix": null,
        "src_path": "fe9ed49dafa993e3af96b6a5a589efeea9bfb36f___gd_gd2.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/fe9ed49dafa993e3af96b6a5a589efeea9bfb36f",
        "commit_msg": "Fix DOS vulnerability in gdImageCreateFromGd2Ctx()\n\nWe must not pretend that there are image data if there are none. Instead\nwe fail reading the image file gracefully.",
        "test_func_diff": [
            {
                "fn": "tests/gd2/.gitignore",
                "patch": "@@ -6,3 +6,4 @@\n /gd2_read\n /gd2_read_corrupt\n /php_bug_72339\n+/too_few_image_data"
            },
            {
                "fn": "tests/gd2/CMakeLists.txt",
                "patch": "@@ -7,6 +7,7 @@ LIST(APPEND TESTS_FILES\n \tphp_bug_72339\n \tgd2_read\n \tgd2_read_corrupt\n+\ttoo_few_image_data\n )\n \n ADD_GD_TESTS()"
            },
            {
                "fn": "tests/gd2/Makemodule.am",
                "patch": "@@ -3,7 +3,8 @@ libgd_test_programs += \\\n \tgd2/bug00309 \\\n \tgd2/gd2_empty_file \\\n \tgd2/php_bug_72339 \\\n-\tgd2/gd2_read_corrupt\n+\tgd2/gd2_read_corrupt \\\n+\tgd2/too_few_image_data\n \n if HAVE_LIBZ\n libgd_test_programs += \\\n@@ -23,4 +24,6 @@ EXTRA_DIST += \\\n \tgd2/conv_test_exp.png \\\n \tgd2/empty.gd2 \\\n \tgd2/invalid_header.gd2 \\\n-\tgd2/invalid_neg_size.gd2\n+\tgd2/invalid_neg_size.gd2 \\\n+\tgd2/php_bug_72339_exp.gd2 \\\n+\tgd2/too_few_image_data.gd2"
            },
            {
                "fn": "tests/gd2/too_few_image_data.c",
                "patch": "@@ -0,0 +1,22 @@\n+/*\n+too_few_image_data.gd2 claims to have a size of 12336x48 pixels, but doesn't\n+provide as much image data. We test that gdImageCreateFromGd2Ctx() returns NULL\n+in this case.\n+*/\n+\n+#include \"gd.h\"\n+#include \"gdtest.h\"\n+\n+int main()\n+{\n+    gdImagePtr im;\n+    FILE *fp;\n+\n+    fp = gdTestFileOpen2(\"gd2\", \"too_few_image_data.gd2\");\n+    gdTestAssert(fp != NULL);\n+    im = gdImageCreateFromGd2(fp);\n+    gdTestAssert(im == NULL);\n+    fclose(fp);\n+\n+    return gdNumFailures();\n+}"
            }
        ],
        "error_msg": "========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 155\n# PASS:  152\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  3\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:31: Total pixels changed: 9 with a maximum channel difference of 255.\nfreetype/bug00132.c:33: Reference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gd2/too_few_image_data\n============================\n\ngd2/too_few_image_data.c:18: Assert failed in <gd2/too_few_image_data.c:18>\nFAIL gd2/too_few_image_data (exit status: 2)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\ngdimagestringft/gdimagestringft_bbox.c:56: (491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\n"
    },
    "a93eac0e843148dc2d631c3ba80af17e9c8c860f___gd.c": {
        "start": 2832,
        "end": 2925,
        "buggy": "BGD_DECLARE(gdImagePtr) gdImageClone (gdImagePtr src) {\n\tgdImagePtr dst;\n\tregister int i, x;\n\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(src->sx , src->sy);\n\t} else {\n\t\tdst = gdImageCreate(src->sx , src->sy);\n\t}\n\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (src->trueColor == 0) {\n\t\tdst->colorsTotal = src->colorsTotal;\n\t\tfor (i = 0; i < gdMaxColors; i++) {\n\t\t\tdst->red[i]   = src->red[i];\n\t\t\tdst->green[i] = src->green[i];\n\t\t\tdst->blue[i]  = src->blue[i];\n\t\t\tdst->alpha[i] = src->alpha[i];\n\t\t\tdst->open[i]  = src->open[i];\n\t\t}\n\t\tfor (i = 0; i < src->sy; i++) {\n\t\t\tfor (x = 0; x < src->sx; x++) {\n\t\t\t\tdst->pixels[i][x] = src->pixels[i][x];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < src->sy; i++) {\n\t\t\tfor (x = 0; x < src->sx; x++) {\n\t\t\t\tdst->tpixels[i][x] = src->tpixels[i][x];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (src->styleLength > 0) {\n\t\tdst->styleLength = src->styleLength;\n\t\tdst->stylePos    = src->stylePos;\n\t\tfor (i = 0; i < src->styleLength; i++) {\n\t\t\tdst->style[i] = src->style[i];\n\t\t}\n\t}\n\n\tdst->interlace   = src->interlace;\n\n\tdst->alphaBlendingFlag = src->alphaBlendingFlag;\n\tdst->saveAlphaFlag     = src->saveAlphaFlag;\n\tdst->AA                = src->AA;\n\tdst->AA_color          = src->AA_color;\n\tdst->AA_dont_blend     = src->AA_dont_blend;\n\n\tdst->cx1 = src->cx1;\n\tdst->cy1 = src->cy1;\n\tdst->cx2 = src->cx2;\n\tdst->cy2 = src->cy2;\n\n\tdst->res_x = src->res_x;\n\tdst->res_y = src->res_y;\n\n\tdst->paletteQuantizationMethod     = src->paletteQuantizationMethod;\n\tdst->paletteQuantizationSpeed      = src->paletteQuantizationSpeed;\n\tdst->paletteQuantizationMinQuality = src->paletteQuantizationMinQuality;\n\tdst->paletteQuantizationMinQuality = src->paletteQuantizationMinQuality;\n\n\tdst->interpolation_id = src->interpolation_id;\n\tdst->interpolation    = src->interpolation;\n\n\tif (src->brush) {\n\t\tdst->brush = gdImageClone(src->brush);\n\t}\n\n\tif (src->tile) {\n\t\tdst->tile = gdImageClone(src->tile);\n\t}\n\n\tif (src->style) {\n\t\tgdImageSetStyle(dst, src->style, src->styleLength);\n\t}\n\n\tfor (i = 0; i < gdMaxColors; i++) {\n\t\tdst->brushColorMap[i] = src->brushColorMap[i];\n\t\tdst->tileColorMap[i] = src->tileColorMap[i];\n\t}\n\n\tif (src->polyAllocated > 0) {\n\t\tdst->polyAllocated = src->polyAllocated;\n\t\tfor (i = 0; i < src->polyAllocated; i++) {\n\t\t\tdst->polyInts[i] = src->polyInts[i];\n\t\t}\n\t}\n\n\treturn dst;\n}\n",
        "fix": null,
        "src_path": "a93eac0e843148dc2d631c3ba80af17e9c8c860f___gd.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/a93eac0e843148dc2d631c3ba80af17e9c8c860f",
        "commit_msg": "Fix potential NULL pointer dereference in gdImageClone()",
        "test_func_diff": [
            {
                "fn": "tests/gdimageclone/.gitignore",
                "patch": "@@ -1 +1,2 @@\n /bug00300\n+/style"
            },
            {
                "fn": "tests/gdimageclone/CMakeLists.txt",
                "patch": "@@ -1,5 +1,6 @@\n LIST(APPEND TESTS_FILES\n \tbug00300\n+\tstyle\n )\n \n ADD_GD_TESTS()"
            },
            {
                "fn": "tests/gdimageclone/Makemodule.am",
                "patch": "@@ -1,5 +1,6 @@\n libgd_test_programs += \\\n-\tgdimageclone/bug00300\n+\tgdimageclone/bug00300 \\\n+\tgdimageclone/style\n \n EXTRA_DIST += \\\n \tgdimageclone/CMakeLists.txt"
            },
            {
                "fn": "tests/gdimageclone/style.c",
                "patch": "@@ -0,0 +1,30 @@\n+/**\n+ * Cloning an image should exactly reproduce all style related data\n+ */\n+\n+\n+#include <string.h>\n+#include \"gd.h\"\n+#include \"gdtest.h\"\n+\n+\n+int main()\n+{\n+    gdImagePtr im, clone;\n+    int style[] = {0, 0, 0};\n+\n+    im = gdImageCreate(8, 8);\n+    gdImageSetStyle(im, style, sizeof(style)/sizeof(style[0]));\n+\n+    clone = gdImageClone(im);\n+    gdTestAssert(clone != NULL);\n+\n+    gdTestAssert(clone->styleLength == im->styleLength);\n+    gdTestAssert(clone->stylePos == im->stylePos);\n+    gdTestAssert(!memcmp(clone->style, im->style, sizeof(style)/sizeof(style[0])));\n+\n+    gdImageDestroy(clone);\n+    gdImageDestroy(im);\n+\n+    return gdNumFailures();\n+}"
            }
        ],
        "error_msg": "========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 191\n# PASS:  190\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  1\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: gdimageclone/style\n========================\n\nFAIL gdimageclone/style (exit status: 139)\n\n"
    },
    "7722455726bec8c53458a32851d2a87982cf0eac___gd_gd2.c": {
        "start": 54,
        "end": 169,
        "buggy": "static int _gd2GetHeader(gdIOCtxPtr in, int *sx, int *sy, int *cs, int *vers, int *fmt, int *ncx, int *ncy, t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG(php_gd_error(\"Reading gd2 header info\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC(in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tid[i] = ch;\n\t}\n\tid[4] = 0;\n\n\tGD2_DBG(php_gd_error(\"Got file code: %s\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp(id, GD2_ID) != 0) {\n\t\tGD2_DBG(php_gd_error(\"Not a valid gd2 file\"));\n\t\tgoto fail1;\n\t}\n\n\t/* Version */\n\tif (gdGetWord(vers, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Version: %d\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG(php_gd_error(\"Bad version: %d\", *vers));\n\t\tgoto fail1;\n\t}\n\n\t/* Image Size */\n\tif (!gdGetWord(sx, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get x-size\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord(sy, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get y-size\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Image is %dx%d\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord(cs, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"ChunkSize: %d\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG(php_gd_error(\"Bad chunk size: %d\", *cs));\n\t\tgoto fail1;\n\t}\n\n\t/* Data Format */\n\tif (gdGetWord(fmt, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Format: %d\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) && (*fmt != GD2_FMT_TRUECOLOR_RAW) && (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG(php_gd_error(\"Bad data format: %d\", *fmt));\n\t\tgoto fail1;\n\t}\n\n\t/* # of chunks wide */\n\tif (gdGetWord(ncx, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks Wide\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord(ncy, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks vertically\", *ncy));\n\n\tif (gd2_compressed(*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG(php_gd_error(\"Reading %d chunk index entries\", nc));\n\t\tsidx = sizeof(t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tcidx = gdCalloc(sidx, 1);\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt(&cidx[i].offset, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (gdGetInt(&cidx[i].size, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t*chunkIdx = cidx;\n\t}\n\n\tGD2_DBG(php_gd_error(\"gd2 header complete\"));\n\n\treturn 1;\n\nfail1:\n\treturn 0;\n}\n",
        "fix": null,
        "src_path": "7722455726bec8c53458a32851d2a87982cf0eac___gd_gd2.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/7722455726bec8c53458a32851d2a87982cf0eac",
        "commit_msg": "Fixed #72339 Integer Overflow in _gd2GetHeader() resulting in heap overflow",
        "test_func_diff": [
            {
                "fn": "ext/gd/tests/bug72339.phpt",
                "patch": "@@ -0,0 +1,11 @@\n+--TEST--\n+Bug #72339 Integer Overflow in _gd2GetHeader() resulting in heap overflow \n+--SKIPIF--\n+<?php if (!function_exists(\"imagecreatefromgd2\")) print \"skip\"; ?>\n+--FILE--\n+<?php imagecreatefromgd2(dirname(__FILE__) . DIRECTORY_SEPARATOR . \"bug72339.gd\"); ?>\n+--EXPECTF--\t\n+Warning: imagecreatefromgd2(): gd warning: product of memory allocation multiplication would exceed INT_MAX, failing operation gracefully\n+ in %sbug72339.php on line %d\n+\n+Warning: imagecreatefromgd2(): '%sbug72339.gd' is not a valid GD2 file in %sbug72339.php on line %d"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.5.37-dev ZEND_VERSION: 2.5.0 PHP_OS : Linux - Linux wangjian 5.4.0-173-generic #191-Ubuntu SMP Fri Feb 2 13:55:07 UTC 2024 x86_64 INI actual : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_7722455726bec8c53458a32851d2a87982cf0eac More .INIs : CWD : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_7722455726bec8c53458a32851d2a87982cf0eac Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/gd/tests/bug72339.phpt]\nFAIL Bug #72339 Integer Overflow in _gd2GetHeader() resulting in heap overflow [ext/gd/tests/bug72339.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 1 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72339 Integer Overflow in _gd2GetHeader() resulting in heap overflow [ext/gd/tests/bug72339.phpt] =====================================================================\n"
    },
    "28022c9b1fd937436ab67bb3d61f652c108baf96___gd.c": {
        "start": 1525,
        "end": 1547,
        "buggy": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tzend_long ncolors;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tif ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), \"Image\", le_gd)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Number of colors has to be greater than zero\");\n\t\tRETURN_FALSE;\n\t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n\n\tRETURN_TRUE;\n}\n",
        "fix": null,
        "src_path": "28022c9b1fd937436ab67bb3d61f652c108baf96___gd.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/28022c9b1fd937436ab67bb3d61f652c108baf96",
        "commit_msg": "Fix bug#72697 - select_colors write out-of-bounds\n\n(cherry picked from commit b6f13a5ef9d6280cf984826a5de012a32c396cd4)\n\nConflicts:\n\text/gd/gd.c",
        "test_func_diff": [
            {
                "fn": "ext/gd/tests/bug72697.phpt",
                "patch": "@@ -0,0 +1,17 @@\n+--TEST--\n+Bug #72697: select_colors write out-of-bounds\n+--SKIPIF--\n+<?php \n+if (!function_exists(\"imagecreatetruecolor\")) die(\"skip\");\n+if (PHP_INT_MAX !== 9223372036854775807) die(\"skip for 64-bit long systems only\");\n+?>\n+--FILE--\n+<?php\n+\n+$img=imagecreatetruecolor(10, 10);\n+imagetruecolortopalette($img, false, PHP_INT_MAX / 8);\n+?>\n+DONE\n+--EXPECTF--\n+Warning: imagetruecolortopalette(): Number of colors has to be greater than zero and no more than 2147483647 in %sbug72697.php on line %d\n+DONE\n\\ No newline at end of file"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 7.0.11-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux wangjian 5.4.0-173-generic #191-Ubuntu SMP Fri Feb 2 13:55:07 UTC 2024 x86_64 INI actual : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_28022c9b1fd937436ab67bb3d61f652c108baf96 More .INIs : CWD : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_28022c9b1fd937436ab67bb3d61f652c108baf96 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. FAIL Bug #72697: select_colors write out-of-bounds [ext/gd/tests/bug72697.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72697: select_colors write out-of-bounds [ext/gd/tests/bug72697.phpt] =====================================================================\n"
    },
    "b2af4e8868726a040234de113436c6e4f6372d17___var.c": {
        "start": 1032,
        "end": 1092,
        "buggy": "PHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n\tconst unsigned char *p;\n\tphp_unserialize_data_t var_hash;\n\tzval *options = NULL, *classes = NULL;\n\tHashTable *class_hash = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t}\n\t}\n\n\tif (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\tif (class_hash) {\n\t\t\tzend_hash_destroy(class_hash);\n\t\t\tFREE_HASHTABLE(class_hash);\n\t\t}\n\t\tzval_ptr_dtor(return_value);\n\t\tif (!EG(exception)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",\n\t\t\t\t(zend_long)((char*)p - buf), buf_len);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\t/* We should keep an reference to return_value to prevent it from being dtor\n\t   in case nesting calls to unserialize */\n\tvar_push_dtor(&var_hash, return_value);\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}\n",
        "fix": null,
        "src_path": "b2af4e8868726a040234de113436c6e4f6372d17___var.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/b2af4e8868726a040234de113436c6e4f6372d17",
        "commit_msg": "Complete the fix of bug #70172 for PHP 7",
        "test_func_diff": [
            {
                "fn": "ext/standard/tests/serialize/bug70172_2.phpt",
                "patch": "@@ -1,7 +1,5 @@\n --TEST--\n Bug #70172 - Use After Free Vulnerability in unserialize()\n---XFAIL--\n-Unfinished merge, needs fix.\n --FILE--\n <?php\n class obj implements Serializable {\n@@ -61,10 +59,10 @@ array(2) {\n     [0]=>\n     array(1) {\n       [0]=>\n-      &object(obj2)#%d (1) {\n+      object(obj2)#%d (1) {\n         [\"ryat\"]=>\n         int(1)\n       }\n     }\n   }\n-}\n\\ No newline at end of file\n+}"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 7.0.14-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux wangjian 5.4.0-173-generic #191-Ubuntu SMP Fri Feb 2 13:55:07 UTC 2024 x86_64 INI actual : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_b2af4e8868726a040234de113436c6e4f6372d17 More .INIs : CWD : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_b2af4e8868726a040234de113436c6e4f6372d17 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. FAIL Bug #70172 - Use After Free Vulnerability in unserialize() [ext/standard/tests/serialize/bug70172_2.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #70172 - Use After Free Vulnerability in unserialize() [ext/standard/tests/serialize/bug70172_2.phpt] =====================================================================\n"
    },
    "8d2539fa0faf3f63e1d1e7635347c5b9e777d47b___wddx.c": {
        "start": 879,
        "end": 1018,
        "buggy": "static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t*pce;\n\tzval\t\t\t\tobj;\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp((char *)name, EL_STRING) || !strcmp((char *)name, EL_NUMBER) ||\n\t\t!strcmp((char *)name, EL_BOOLEAN) || !strcmp((char *)name, EL_NULL) ||\n\t  \t!strcmp((char *)name, EL_ARRAY) || !strcmp((char *)name, EL_STRUCT) ||\n\t\t!strcmp((char *)name, EL_RECORDSET) || !strcmp((char *)name, EL_BINARY) ||\n\t\t!strcmp((char *)name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (Z_TYPE(ent1->data) == IS_UNDEF) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t\tefree(ent1);\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp((char *)name, EL_BINARY)) {\n\t\t\tzend_string *new_str = NULL;\n\t\t\t\n\t\t\tif (ZSTR_EMPTY_ALLOC() != Z_STR(ent1->data)) {\n\t\t\t\tnew_str = php_base64_decode(\n\t\t\t\t\t(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t}\n\n\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\tif (new_str) {\n\t\t\t\tZVAL_STR(&ent1->data, new_str);\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(&ent1->data);\n\t\t\t}\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE(ent1->data) == IS_OBJECT) {\n\t\t\tzval fname, retval;\n\n\t\t\tZVAL_STRING(&fname, \"__wakeup\");\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, &fname, &retval, 0, 0, 0, NULL);\n\n\t\t\tzval_ptr_dtor(&fname);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (Z_ISUNDEF(ent2->data)) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE(ent2->data) == IS_ARRAY || Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(&ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE(ent1->data) == IS_STRING && Z_STRLEN(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\tzend_string_forget_hash_val(Z_STR(ent1->data));\n\t\t\t\t\t\tif ((pce = zend_hash_find_ptr(EG(class_table), Z_STR(ent1->data))) == NULL) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (pce != PHP_IC_ENTRY && (pce->serialize || pce->unserialize)) {\n\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\t\t\t\t\t\t\tZVAL_UNDEF(&ent2->data);\n\t\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Class %s can not be unserialized\", Z_STRVAL(ent1->data));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\t\tobject_init_ex(&obj, pce);\n\n\t\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP(obj),\n\t\t\t\t\t\t\t\t\t\t\tZ_ARRVAL(ent2->data),\n\t\t\t\t\t\t\t\t\t\t\tzval_add_ref, 0);\n\n\t\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\t\tphp_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\t\tZVAL_COPY_VALUE(&ent2->data, &obj);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE(ent2->data);\n\t\t\t\t\t\tadd_property_zval(&ent2->data, ent1->varname, &ent1->data);\n\t\t\t\t\t\tif Z_REFCOUNTED(ent1->data) Z_DELREF(ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_str_update(target_hash, ent1->varname, strlen(ent1->varname), &ent1->data);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp((char *)name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp((char *)name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}\n}\n",
        "fix": null,
        "src_path": "8d2539fa0faf3f63e1d1e7635347c5b9e777d47b___wddx.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/8d2539fa0faf3f63e1d1e7635347c5b9e777d47b",
        "commit_msg": "Fix bug #73831 - NULL Pointer Dereference while unserialize php object",
        "test_func_diff": [
            {
                "fn": "ext/wddx/tests/bug73831.phpt",
                "patch": "@@ -0,0 +1,23 @@\n+--TEST--\n+Bug #73831 (NULL Pointer Dereference while unserialize php object)\n+--SKIPIF--\n+<?php if (!extension_loaded(\"wddx\")) print \"skip\"; ?>\n+--FILE--\n+<?php\n+$xml = <<<EOF\n+<?xml version=\"1.0\" ?>\n+<wddxPacket version=\"1.0\">\n+\t<struct>\n+\t\t<var name=\"php_class_name\">\n+\t\t\t<string>Throwable</string>\n+                </var>\n+        </struct>\n+</wddxPacket>\n+EOF;\n+try {\n+\t$wddx = wddx_deserialize($xml);\n+} catch(Error $e) { echo $e->getMessage(); }\n+?>\n+--EXPECTF--\n+Warning: wddx_deserialize(): Class throwable can not be instantiated in %sbug73831.php on line %d\n+Cannot instantiate interface Throwable"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 7.0.15-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux wangjian 5.4.0-173-generic #191-Ubuntu SMP Fri Feb 2 13:55:07 UTC 2024 x86_64 INI actual : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_8d2539fa0faf3f63e1d1e7635347c5b9e777d47b More .INIs : --------------------------------------------------------------------- PHP : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_8d2539fa0faf3f63e1d1e7635347c5b9e777d47b/sapi/phpdbg/phpdbg PHP_SAPI : phpdbg PHP_VERSION : 7.0.15-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux wangjian 5.4.0-173-generic #191-Ubuntu SMP Fri Feb 2 13:55:07 UTC 2024 x86_64 INI actual : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_8d2539fa0faf3f63e1d1e7635347c5b9e777d47b More .INIs : --------------------------------------------------------------------- CWD : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_8d2539fa0faf3f63e1d1e7635347c5b9e777d47b Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. FAIL Bug #73831 (NULL Pointer Dereference while unserialize php object) [ext/wddx/tests/bug73831.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #73831 (NULL Pointer Dereference while unserialize php object) [ext/wddx/tests/bug73831.phpt] =================================================================="
    },
    "bab0b99f376dac9170ac81382a5ed526938d595a___xp_socket.c": {
        "start": 568,
        "end": 605,
        "buggy": "static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)\n{\n\tchar *colon;\n\tchar *host = NULL;\n\n#ifdef HAVE_IPV6\n\tchar *p;\n\n\tif (*(str) == '[' && str_len > 1) {\n\t\t/* IPV6 notation to specify raw address with port (i.e. [fe80::1]:80) */\n\t\tp = memchr(str + 1, ']', str_len - 2);\n\t\tif (!p || *(p + 1) != ':') {\n\t\t\tif (get_err) {\n\t\t\t\t*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\t*portno = atoi(p + 2);\n\t\treturn estrndup(str + 1, p - str - 1);\n\t}\n#endif\n\tif (str_len) {\n\t\tcolon = memchr(str, ':', str_len - 1);\n\t} else {\n\t\tcolon = NULL;\n\t}\n\tif (colon) {\n\t\t*portno = atoi(colon + 1);\n\t\thost = estrndup(str, colon - str);\n\t} else {\n\t\tif (get_err) {\n\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\treturn host;\n}\n",
        "fix": null,
        "src_path": "bab0b99f376dac9170ac81382a5ed526938d595a___xp_socket.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/bab0b99f376dac9170ac81382a5ed526938d595a",
        "commit_msg": "Detect invalid port in xp_socket parse ip address\n\nFor historical reasons, fsockopen() accepts the port and hostname\nseparately: fsockopen('127.0.0.1', 80)\n\nHowever, with the introdcution of stream transports in PHP 4.3,\nit became possible to include the port in the hostname specifier:\n\nfsockopen('127.0.0.1:80')\nOr more formally: fsockopen('tcp://127.0.0.1:80')\n\nConfusing results when these two forms are combined, however.\nfsockopen('127.0.0.1:80', 443) results in fsockopen() attempting\nto connect to '127.0.0.1:80:443' which any reasonable stack would\nconsider invalid.\n\nUnfortunately, PHP parses the address looking for the first colon\n(with special handling for IPv6, don't worry) and calls atoi()\nfrom there.  atoi() in turn, simply stops parsing at the first\nnon-numeric character and returns the value so far.\n\nThe end result is that the explicitly supplied port is treated\nas ignored garbage, rather than producing an error.\n\nThis diff replaces atoi() with strtol() and inspects the\nstop character.  If additional \"garbage\" of any kind is found,\nit fails and returns an error.",
        "test_func_diff": [
            {
                "fn": "ext/standard/tests/streams/parseip-001.phpt",
                "patch": "@@ -0,0 +1,37 @@\n+--TEST--\n+Use of double-port in fsockopen()\n+--FILE--\n+<?php\n+\n+$try = [\n+  '127.0.0.1:80',\n+  'tcp://127.0.0.1:80',\n+  '[::1]:80',\n+  'tcp://[::1]:80',\n+  'localhost:80',\n+  'tcp://localhost:80',\n+];\n+\n+foreach ($try as $addr) {\n+  echo \"== $addr ==\\n\";\n+  var_dump(@fsockopen($addr, 81, $errno, $errstr), $errstr);\n+}\n+--EXPECTF--\n+== 127.0.0.1:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"127.0.0.1:80:81\"\"\n+== tcp://127.0.0.1:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"127.0.0.1:80:81\"\"\n+== [::1]:80 ==\n+bool(false)\n+string(37) \"Failed to parse address \"[::1]:80:81\"\"\n+== tcp://[::1]:80 ==\n+bool(false)\n+string(37) \"Failed to parse address \"[::1]:80:81\"\"\n+== localhost:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"localhost:80:81\"\"\n+== tcp://localhost:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"localhost:80:81\"\"\n\\ No newline at end of file"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 7.0.18-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux wangjian 5.4.0-173-generic #191-Ubuntu SMP Fri Feb 2 13:55:07 UTC 2024 x86_64 INI actual : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_bab0b99f376dac9170ac81382a5ed526938d595a More .INIs : --------------------------------------------------------------------- PHP : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_bab0b99f376dac9170ac81382a5ed526938d595a/sapi/phpdbg/phpdbg PHP_SAPI : phpdbg PHP_VERSION : 7.0.18-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux wangjian 5.4.0-173-generic #191-Ubuntu SMP Fri Feb 2 13:55:07 UTC 2024 x86_64 INI actual : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_bab0b99f376dac9170ac81382a5ed526938d595a More .INIs : --------------------------------------------------------------------- CWD : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_bab0b99f376dac9170ac81382a5ed526938d595a Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. FAIL Use of double-port in fsockopen() [ext/standard/tests/streams/parseip-001.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Use of double-port in fsockopen() [ext/standard/tests/streams/parseip-001.phpt] =====================================================================\n"
    },
    "0f2d7e784a256b54b2385043438848047bc2a629___idna.c": {
        "start": 318,
        "end": 363,
        "buggy": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* \u3002 */\n        if (c != 0xFF0E)  /* \uff0e */\n          if (c != 0xFF61)  /* \uff61 */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d < de)\n    *d++ = '\\0';\n\n  return d - ds;  /* Number of bytes written. */\n}\n",
        "fix": null,
        "src_path": "0f2d7e784a256b54b2385043438848047bc2a629___idna.c",
        "uri": "https://api.github.com/repos/libuv/libuv/commits/0f2d7e784a256b54b2385043438848047bc2a629",
        "commit_msg": "fix: always zero-terminate idna output\n\nFixes: https://github.com/libuv/libuv/security/advisories/GHSA-f74f-cvh7-c6q6",
        "test_func_diff": [
            {
                "fn": "test/test-idna.c",
                "patch": "@@ -100,6 +100,7 @@ TEST_IMPL(utf8_decode1) {\n TEST_IMPL(utf8_decode1_overrun) {\n   const char* p;\n   char b[1];\n+  char c[1];\n \n   /* Single byte. */\n   p = b;\n@@ -113,6 +114,9 @@ TEST_IMPL(utf8_decode1_overrun) {\n   ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + 1));\n   ASSERT_PTR_EQ(p, b + 1);\n \n+  b[0] = 0x7F;\n+  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 1, c, c + 1));\n+\n   return 0;\n }\n "
            }
        ],
        "error_msg": "not ok 118 - fs_utime_round\n# exit code 134\n# Output from process `fs_utime_round`:\n# Assertion failed in test/test-fs.c on line 847: `s->st_atim.tv_sec <= (long) atime` (0 <= -14245440)\nok 119 - fs_write_alotof_bufs\nnot ok 429 - utf8_decode1_overrun\n# exit code 134\n# Output from process `utf8_decode1_overrun`:\n# Assertion failed in test/test-idna.c on line 118: `UV_EINVAL == uv__idna_toascii(b, b + 1, c, c + 1)` (-22 == 1)\nok 430 - walk_handles\n"
    },
    "39e8fa1b7db1680654527f8fa0e9ee93b334ecba___njs_function.c": {
        "start": 1366,
        "end": 1441,
        "buggy": "static njs_int_t\nnjs_function_prototype_apply(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t         i, length;\n    njs_int_t       ret;\n    njs_frame_t     *frame;\n    njs_value_t     *this, *arr_like;\n    njs_array_t     *arr;\n    njs_function_t  *func;\n\n    if (!njs_is_function(njs_argument(args, 0))) {\n        njs_type_error(vm, \"\\\"this\\\" argument is not a function\");\n        return NJS_ERROR;\n    }\n\n    func = njs_function(njs_argument(args, 0));\n    this = njs_arg(args, nargs, 1);\n    arr_like = njs_arg(args, nargs, 2);\n\n    if (njs_is_null_or_undefined(arr_like)) {\n        length = 0;\n\n        goto activate;\n\n    } else if (njs_is_array(arr_like)) {\n        arr = arr_like->data.u.array;\n\n        args = arr->start;\n        length = arr->length;\n\n        goto activate;\n\n    } else if (njs_slow_path(!njs_is_object(arr_like))) {\n        njs_type_error(vm, \"second argument is not an array-like object\");\n        return NJS_ERROR;\n    }\n\n    ret = njs_object_length(vm, arr_like, &length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    arr = njs_array_alloc(vm, 1, length, NJS_ARRAY_SPARE);\n    if (njs_slow_path(arr == NULL)) {\n        return NJS_ERROR;\n    }\n\n    args = arr->start;\n\n    for (i = 0; i < length; i++) {\n        ret = njs_value_property_i64(vm, arr_like, i, &args[i]);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return ret;\n        }\n    }\n\nactivate:\n\n    /* Skip the \"apply\" method frame. */\n    vm->top_frame->skip = 1;\n\n    frame = (njs_frame_t *) vm->top_frame;\n\n    ret = njs_function_frame(vm, func, this, args, length, 0);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_function_frame_invoke(vm, frame->native.retval);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    return NJS_DECLINED;\n}\n",
        "fix": null,
        "src_path": "39e8fa1b7db1680654527f8fa0e9ee93b334ecba___njs_function.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/39e8fa1b7db1680654527f8fa0e9ee93b334ecba",
        "commit_msg": "Fixed Function.prototype.apply() with slow arrays.\n\nPreviously, the function had two issues:\n   * array->start was referenced without checking for fast array flag\n   * the created arguments list was not sanity-checked for its length,\n     which can be very large.\n\nThe fix is to remove micro-optimization for arrays and introduce limit\nsize for arguments list.\n\nThis closes #449 issue in Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -10063,6 +10063,10 @@ static njs_unit_test_t  njs_test[] =\n                  \"f.apply(123, {})\"),\n       njs_str(\"123\") },\n \n+    { njs_str(\"(function(index, ...rest){ return rest[index];})\"\n+              \".apply({}, [1022].concat(Array(1023).fill(1).map((v,i)=>i.toString(16))))\"),\n+      njs_str(\"3fe\") },\n+\n     { njs_str(\"String.prototype.concat.apply('a', \"\n                  \"{length:2, 0:{toString:function() {return 'b'}}, 1:'c'})\"),\n       njs_str(\"abc\") },"
            }
        ],
        "error_msg": "\n"
    },
    "ad48705bf1f04b4221a5f5b07715ac48b3160d53___njs_function.c": {
        "start": 805,
        "end": 939,
        "buggy": "njs_int_t\nnjs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n\n    native = &frame->native;\n\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n\n    function = active->function;\n\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n\n\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n\n    /* Move all arguments. */\n\n    p = native->arguments;\n    local = native->local + function->args_offset;\n\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n\n        *local++ = p++;\n    }\n\n    return NJS_OK;\n}\n\n\nnjs_object_type_t\nnjs_function_object_type(njs_vm_t *vm, njs_function_t *function)\n{\n    if (function->object.shared_hash.slot\n        == vm->shared->async_function_instance_hash.slot)\n    {\n        return NJS_OBJ_TYPE_ASYNC_FUNCTION;\n    }\n\n    return NJS_OBJ_TYPE_FUNCTION;\n}\n\n\nnjs_int_t\nnjs_function_capture_closure(njs_vm_t *vm, njs_function_t *function,\n    njs_function_lambda_t *lambda)\n{\n    void                *start, *end;\n    uint32_t            n;\n    njs_value_t         *value, **closure;\n    njs_native_frame_t  *frame;\n\n    if (lambda->nclosures == 0) {\n        return NJS_OK;\n    }\n\n    frame = &vm->active_frame->native;\n\n    while (frame->native) {\n        frame = frame->previous;\n    }\n\n    start = frame;\n    end = frame->free;\n\n    closure = njs_function_closures(function);\n    n = lambda->nclosures;\n\n    do {\n        n--;\n\n        value = njs_scope_value(vm, lambda->closures[n]);\n\n        if (start <= (void *) value && (void *) value < end) {\n            value = njs_scope_value_clone(vm, lambda->closures[n], value);\n            if (njs_slow_path(value == NULL)) {\n                return NJS_ERROR;\n            }\n        }\n\n        closure[n] = value;\n\n    } while (n != 0);\n\n    return NJS_OK;\n}\n\n\nnjs_inline njs_value_t *\nnjs_function_closure_value(njs_vm_t *vm, njs_value_t **scope, njs_index_t index,\n    void *start, void *end)\n{\n    njs_value_t  *value, *newval;\n\n    value = scope[njs_scope_index_value(index)];\n\n    if (start <= (void *) value && end > (void *) value) {\n        newval = njs_mp_alloc(vm->mem_pool, sizeof(njs_value_t));\n        if (njs_slow_path(newval == NULL)) {\n            njs_memory_error(vm);\n            return NULL;\n        }\n\n        *newval = *value;\n        value = newval;\n    }\n\n    scope[njs_scope_index_value(index)] = value;\n\n    return value;\n}\n",
        "fix": null,
        "src_path": "ad48705bf1f04b4221a5f5b07715ac48b3160d53___njs_function.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/ad48705bf1f04b4221a5f5b07715ac48b3160d53",
        "commit_msg": "Fixed frame allocation from an awaited frame.\n\nnjs_function_frame_save() is used to save the awaited frame when \"await\"\ninstruction is encountered. The saving was done as a memcpy() of\nexisting runtime frame.\n\nnjs_function_frame_alloc() is used to alloc a new function frame, this\nfunction tries to use a spare preallocated memory from the previous\nframe first.  Previously, this function might result in \"use-after-free\"\nwhen invoked from a restored frame saved with njs_function_frame_save().\nBecause njs_function_frame_save() left pointers to the spare memory of\nthe original frame which may be already free when saved frame is\nrestored.\n\nThe fix is to erase fields for the spare memory from the saved frame.\n\nThis closes #469 issue on Github.",
        "test_func_diff": [
            {
                "fn": "test/js/async_recursive_large.t.js",
                "patch": "@@ -0,0 +1,26 @@\n+/*---\n+includes: [compareArray.js]\n+flags: [async]\n+---*/\n+\n+let stages = [];\n+\n+async function f(v) {\n+    if (v == 1000) {\n+        return;\n+    }\n+\n+    stages.push(`f>${v}`);\n+\n+    await \"X\";\n+\n+    await f(v + 1);\n+\n+    stages.push(`f<${v}`);\n+}\n+\n+f(0)\n+.then(v => {\n+    assert.sameValue(stages.length, 2000);\n+})\n+.then($DONE, $DONE);"
            },
            {
                "fn": "test/js/async_recursive_mid.t.js",
                "patch": "@@ -6,7 +6,7 @@ flags: [async]\n let stages = [];\n \n async function f(v) {\n-    if (v == 3) {\n+    if (v == 1000) {\n         return;\n     }\n "
            }
        ],
        "error_msg": "\n"
    },
    "eafe4c7a326b163612f10861392622b5da5b1792___njs_iterator.c": {
        "start": 460,
        "end": 634,
        "buggy": "njs_int_t\nnjs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_iterator_handler_t handler)\n{\n    double              idx;\n    int64_t             i, from, to, length;\n    njs_int_t           ret;\n    njs_array_t         *array, *keys;\n    njs_value_t         *entry, *value, prop, character, string_obj;\n    const u_char        *p, *end, *pos;\n    njs_string_prop_t   string_prop;\n    njs_object_value_t  *object;\n\n    value = args->value;\n    from = args->from;\n    to = args->to;\n\n    if (njs_is_array(value)) {\n        array = njs_array(value);\n\n        from += 1;\n\n        while (from-- > to) {\n            if (njs_slow_path(!array->object.fast_array)) {\n                goto process_object;\n            }\n\n            if (njs_fast_path(from < array->length\n                              && njs_is_valid(&array->start[from])))\n            {\n                ret = handler(vm, args, &array->start[from], from);\n\n            } else {\n                entry = njs_value_arg(&njs_value_invalid);\n                ret = njs_value_property_i64(vm, value, from, &prop);\n                if (njs_slow_path(ret != NJS_DECLINED)) {\n                    if (ret == NJS_ERROR) {\n                        return NJS_ERROR;\n                    }\n\n                    entry = &prop;\n                }\n\n                ret = handler(vm, args, entry, from);\n            }\n\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DONE) {\n                    return NJS_DONE;\n                }\n\n                return NJS_ERROR;\n            }\n        }\n\n        return NJS_OK;\n    }\n\n    if (njs_is_string(value) || njs_is_object_string(value)) {\n\n        if (njs_is_string(value)) {\n            object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value);\n            if (njs_slow_path(object == NULL)) {\n                return NJS_ERROR;\n            }\n\n            njs_set_object_value(&string_obj, object);\n\n            args->value = &string_obj;\n        }\n        else {\n            value = njs_object_value(value);\n        }\n\n        length = njs_string_prop(&string_prop, value);\n        end = string_prop.start + string_prop.size;\n\n        if ((size_t) length == string_prop.size) {\n            /* Byte or ASCII string. */\n\n            p = string_prop.start + from;\n\n            i = from + 1;\n\n            while (i-- > to) {\n                /* This cannot fail. */\n                (void) njs_string_new(vm, &character, p, 1, 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n\n                    return NJS_ERROR;\n                }\n\n                p--;\n            }\n\n        } else {\n            /* UTF-8 string. */\n\n            p = njs_string_offset(string_prop.start, end, from);\n            p = njs_utf8_next(p, end);\n\n            i = from + 1;\n\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n\n                /* This cannot fail. */\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n\n                    return NJS_ERROR;\n                }\n\n                p = pos;\n            }\n        }\n\n        return NJS_OK;\n    }\n\n    if (!njs_is_object(value)) {\n        return NJS_OK;\n    }\n\nprocess_object:\n\n    if (!njs_fast_object(from - to)) {\n        keys = njs_array_indices(vm, value);\n        if (njs_slow_path(keys == NULL)) {\n            return NJS_ERROR;\n        }\n\n        i = keys->length;\n\n        while (i > 0) {\n            idx = njs_string_to_index(&keys->start[--i]);\n\n            if (idx < to || idx > from) {\n                continue;\n            }\n\n            ret = njs_iterator_object_handler(vm, handler, args,\n                                              &keys->start[i], idx);\n            if (njs_slow_path(ret != NJS_OK)) {\n                njs_array_destroy(vm, keys);\n                return ret;\n            }\n        }\n\n        njs_array_destroy(vm, keys);\n\n        return NJS_OK;\n    }\n\n    i = from + 1;\n\n    while (i-- > to) {\n        ret = njs_iterator_object_handler(vm, handler, args, NULL, i);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    return NJS_OK;\n}\n",
        "fix": null,
        "src_path": "eafe4c7a326b163612f10861392622b5da5b1792___njs_iterator.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/eafe4c7a326b163612f10861392622b5da5b1792",
        "commit_msg": "Fixed Array.prototype.lastIndexOf() with unicode string as \"this\".\n\nPreviously, when lastIndexOf() was called with unicode string as \"this\"\nargument and a negative \"fromIndex\" argument null-pointer dererence\nmight occur because njs_string_offset() was called with invalid index\nvalue whereas njs_string_offset() should always be called with valid\nindex argument.\n\nThe fix is to verify that from index is valid.\n\nThis closes #482 issue on Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -5103,6 +5103,9 @@ static njs_unit_test_t  njs_test[] =\n     { njs_str(\"Array.prototype.lastIndexOf.call({0:'undefined', length:0}, 'undefined')\"),\n       njs_str(\"-1\") },\n \n+    { njs_str(\"[1,0,-1,-2].map(v => Array.prototype.lastIndexOf.call('\u0424', '\u0424', v))\"),\n+      njs_str(\"0,0,0,-1\") },\n+\n     { njs_str(\"[''].lastIndexOf.call('00000000000000000000000000000\u043000')\"),\n       njs_str(\"-1\") },\n "
            }
        ],
        "error_msg": "\n"
    },
    "b3b29ce8f3acf3a32733d930105a17d7b0ba347e___peglib.h": {
        "start": 178,
        "end": 192,
        "buggy": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}\n",
        "fix": null,
        "src_path": "b3b29ce8f3acf3a32733d930105a17d7b0ba347e___peglib.h",
        "uri": "https://api.github.com/repos/yhirose/cpp-peglib/commits/b3b29ce8f3acf3a32733d930105a17d7b0ba347e",
        "commit_msg": "Fix #122",
        "test_func_diff": [
            {
                "fn": "test/test1.cc",
                "patch": "@@ -45,6 +45,17 @@ TEST_CASE(\"Start rule with ignore operator test\", \"[general]\")\n     REQUIRE(ret == false);\n }\n \n+TEST_CASE(\"Invalid UTF-8 text test\", \"[general]\")\n+{\n+    std::string s = \"a <- '\";\n+    s += static_cast<char>(0xe8); // Make invalid utf8 text...\n+\n+    parser parser(s.c_str());\n+\n+    bool ret = parser;\n+    REQUIRE(ret == false);\n+}\n+\n TEST_CASE(\"Backslash escape sequence test\", \"[general]\")\n {\n     parser parser(R\"("
            }
        ],
        "error_msg": "==2168940==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7f9449e48440 at pc 0x55bba2b21c6f bp 0x7ffc297e9f10 sp 0x7ffc297e9f08\nREAD of size 1 at 0x7f9449e48440 thread T0\n[Detaching after fork from child process 2168944]\n    #0 0x55bba2b21c6e in peg::decode_codepoint(char const*, unsigned long, unsigned long&, char32_t&) /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:234:35\n    #1 0x55bba2b21b49 in peg::decode_codepoint(char const*, unsigned long, char32_t&) /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:270:7\n    #2 0x55bba2ac10a6 in peg::CharacterClass::parse_core(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:1293:16\n    #3 0x55bba2ab5519 in peg::Ope::parse(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:2438:10\n    #4 0x55bba2ac0a23 in peg::NotPredicate::parse_core(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:1211:22\n    #5 0x55bba2ab5519 in peg::Ope::parse(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:2438:10\n    #6 0x55bba2abe6a8 in peg::Sequence::parse_core(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:1010:23\n    #7 0x55bba2ab5519 in peg::Ope::parse(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:2438:10\n    #8 0x55"
    },
    "d15795acd5074e0b44e71f7ede8bdfe1b48591fc___x509_crt.c": {
        "start": 2189,
        "end": 2313,
        "buggy": "int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const mbedtls_x509_crt_profile *profile,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy )\n{\n    size_t cn_len;\n    int ret;\n    int pathlen = 0, selfsigned = 0;\n    mbedtls_x509_crt *parent;\n    mbedtls_x509_name *name;\n    mbedtls_x509_sequence *cur = NULL;\n    mbedtls_pk_type_t pk_type;\n\n    if( profile == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    *flags = 0;\n\n    if( cn != NULL )\n    {\n        name = &crt->subject;\n        cn_len = strlen( cn );\n\n        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n        {\n            cur = &crt->subject_alt_names;\n\n            while( cur != NULL )\n            {\n                if( cur->buf.len == cn_len &&\n                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )\n                    break;\n\n                if( cur->buf.len > 2 &&\n                    memcmp( cur->buf.p, \"*.\", 2 ) == 0 &&\n                    x509_check_wildcard( cn, &cur->buf ) == 0 )\n                {\n                    break;\n                }\n\n                cur = cur->next;\n            }\n\n            if( cur == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n        else\n        {\n            while( name != NULL )\n            {\n                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )\n                {\n                    if( name->val.len == cn_len &&\n                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )\n                        break;\n\n                    if( name->val.len > 2 &&\n                        memcmp( name->val.p, \"*.\", 2 ) == 0 &&\n                        x509_check_wildcard( cn, &name->val ) == 0 )\n                        break;\n                }\n\n                name = name->next;\n            }\n\n            if( name == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n    }\n\n    /* Check the type and size of the key */\n    pk_type = mbedtls_pk_get_type( &crt->pk );\n\n    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n    /* Look for a parent in trusted CAs */\n    for( parent = trust_ca; parent != NULL; parent = parent->next )\n    {\n        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n            break;\n    }\n\n    if( parent != NULL )\n    {\n        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            return( ret );\n    }\n    else\n    {\n        /* Look for a parent upwards the chain */\n        for( parent = crt->next; parent != NULL; parent = parent->next )\n            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n                break;\n\n        /* Are we part of the chain or at the top? */\n        if( parent != NULL )\n        {\n            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n        {\n            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n\n    return( 0 );\n}\n",
        "fix": null,
        "src_path": "d15795acd5074e0b44e71f7ede8bdfe1b48591fc___x509_crt.c",
        "uri": "https://api.github.com/repos/ARMmbed/mbedtls/commits/d15795acd5074e0b44e71f7ede8bdfe1b48591fc",
        "commit_msg": "Improve behaviour on fatal errors\n\nIf we didn't walk the whole chain, then there may be any kind of errors in the\npart of the chain we didn't check, so setting all flags looks like the safe\nthing to do.",
        "test_func_diff": [
            {
                "fn": "tests/suites/test_suite_x509parse.data",
                "patch": "@@ -1204,7 +1204,7 @@ mbedtls_x509_crt_verify_max:\"data_files/test-ca2.crt\":\"data_files/dir-maxpath\":M\n \n X509 CRT verify long chain (max intermediate CA + 1)\n depends_on:MBEDTLS_SHA256_C:MBEDTLS_ECDSA_C:MBEDTLS_ECP_DP_SECP256R1_ENABLED\n-mbedtls_x509_crt_verify_max:\"data_files/dir-maxpath/00.crt\":\"data_files/dir-maxpath\":MBEDTLS_X509_MAX_INTERMEDIATE_CA+1:MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:0\n+mbedtls_x509_crt_verify_max:\"data_files/dir-maxpath/00.crt\":\"data_files/dir-maxpath\":MBEDTLS_X509_MAX_INTERMEDIATE_CA+1:MBEDTLS_ERR_X509_CERT_VERIFY_FAILED:-1\n \n X509 CRT verify chain #1 (zero pathlen intermediate)\n depends_on:MBEDTLS_SHA256_C:MBEDTLS_RSA_C"
            }
        ],
        "error_msg": "X509 Certificate information #1 ................................... PASS\nX509 Certificate information #2 ................................... PASS\nX509 Certificate information #3 ................................... PASS\nX509 Certificate information MD2 Digest ........................... ----\n   Unmet dependencies: MBEDTLS_MD2_C  \nX509 Certificate information MD4 Digest ........................... ----\n   Unmet dependencies: MBEDTLS_MD4_C  \nX509 Certificate information MD5 Digest ........................... PASS\nX509 Certificate information SHA1 Digest .......................... PASS\nX509 Certificate information SHA224 Digest ........................ PASS\nX509 Certificate information SHA256 Digest ........................ PASS\nX509 Certificate information SHA384 Digest ........................ PASS\nX509 Certificate information SHA512 Digest ........................ PASS\nX509 Certificate information RSA-PSS, SHA1 Digest ................. PASS\nX509 Certificate information RSA-PSS, SHA224 Digest ............... PASS\nX509 Certificate information RSA-PSS, SHA256 Digest ............... PASS\nX509 Certificate information RSA-PSS, SHA384 Digest ............... PASS\nX509 Certificate information RSA-PSS, SHA512 Digest ............... PASS\nX509 Certificate information EC, SHA1 Digest ...................... PASS\nX509 Certificate information EC, SHA224 Digest .................... PASS\nX509 Certificate information EC, SHA256 Digest .................... PASS\nX509 Certificate information EC, SHA384 Digest .................... PASS\nX509 Certificate information EC, SHA512 Digest .................... PASS\nX509 Certificate information, NS Cert Type ........................ PASS\nX509 Certificate information, Key Usage ........................... PASS\nX509 Certificate information, Key Usage with decipherOnly ......... PASS\nX509 Certificate information, Subject Alt Name .................... PASS\nX509 Certificate information, Subject Alt Name + Key Usage ........ PASS\nX509 Certificate information, Key Usage + Extended Key Usage ...... PASS"
    },
    "5e7b9ec688d79e7b16ec7064e1d37e8481a31e72___QuotedString.cpp": {
        "start": 58,
        "end": 58,
        "buggy": "static inline bool isQuote(char c) { return c == '\\\"' || c == '\\''; }\n",
        "fix": null,
        "src_path": "5e7b9ec688d79e7b16ec7064e1d37e8481a31e72___QuotedString.cpp",
        "uri": "https://api.github.com/repos/bblanchon/ArduinoJson/commits/5e7b9ec688d79e7b16ec7064e1d37e8481a31e72",
        "commit_msg": "Fix buffer overflow (pull request #81)",
        "test_func_diff": [
            {
                "fn": "test/QuotedString_ExtractFrom_Tests.cpp",
                "patch": "@@ -16,6 +16,11 @@ class QuotedString_ExtractFrom_Tests : public testing::Test {\n     _result = QuotedString::extractFrom(_jsonString, &_trailing);\n   }\n \n+  void whenInputIs(const char *json, size_t len) {\n+    memcpy(_jsonString, json, len);\n+    _result = QuotedString::extractFrom(_jsonString, &_trailing);\n+  }\n+\n   void resultMustBe(const char *expected) { EXPECT_STREQ(expected, _result); }\n \n   void trailingMustBe(const char *expected) {\n@@ -134,3 +139,8 @@ TEST_F(QuotedString_ExtractFrom_Tests, AllEscapedCharsTogether) {\n   whenInputIs(\"\\\"1\\\\\\\"2\\\\\\\\3\\\\/4\\\\b5\\\\f6\\\\n7\\\\r8\\\\t9\\\"\");\n   resultMustBe(\"1\\\"2\\\\3/4\\b5\\f6\\n7\\r8\\t9\");\n }\n+\n+TEST_F(QuotedString_ExtractFrom_Tests, UnterminatedEscapeSequence) {\n+  whenInputIs(\"\\\"\\\\\\0\\\"\", 4);\n+  resultMustBe(0);\n+}"
            }
        ],
        "error_msg": "Running main() from gtest_main.cc\nNote: Google Test filter = QuotedString_ExtractFrom_Tests.UnterminatedEscapeSequence\n[==========] Running 1 test from 1 test case.\n[----------] Global test environment set-up.\n[----------] 1 test from QuotedString_ExtractFrom_Tests\n[ RUN      ] QuotedString_ExtractFrom_Tests.UnterminatedEscapeSequence\n/out/bblanchon___ArduinoJson/git_repo_dir/test/QuotedString_ExtractFrom_Tests.cpp:24: Failure\nValue of: _result\n  Actual: \"\"\nExpected: expected\nWhich is: NULL\n[  FAILED  ] QuotedString_ExtractFrom_Tests.UnterminatedEscapeSequence (0 ms)\n[----------] 1 test from QuotedString_ExtractFrom_Tests (0 ms total)\n\n[----------] Global test environment tear-down\n[==========] 1 test from 1 test case ran. (0 ms total)\n[  PASSED  ] 0 tests.\n[  FAILED  ] 1 test, listed below:\n[  FAILED  ] QuotedString_ExtractFrom_Tests.UnterminatedEscapeSequence\n\n 1 FAILED TEST\n"
    },
    "1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7___TarFileReader.cpp": {
        "start": 99,
        "end": 109,
        "buggy": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();\n\n  LOG_DEBUG(5, \"Extracting: \" << path);\n\n  return extract(*SystemUtilities::oopen(path));\n}\n",
        "fix": null,
        "src_path": "1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7___TarFileReader.cpp",
        "uri": "https://api.github.com/repos/CauldronDevelopmentLLC/cbang/commits/1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7",
        "commit_msg": "Don't allow extraction of tar files outside of the target directory, added tar tests",
        "test_func_diff": [
            {
                "fn": "tests/tarTests/.gitignore",
                "patch": "@@ -0,0 +1 @@\n+/path"
            },
            {
                "fn": "tests/tarTests/BadExtractTest/data/args",
                "patch": "@@ -0,0 +1 @@\n+--extract test.tar"
            },
            {
                "fn": "tests/tarTests/BadExtractTest/expect/return",
                "patch": "@@ -0,0 +1 @@\n+1"
            },
            {
                "fn": "tests/tarTests/BadExtractTest/expect/stderr",
                "patch": "@@ -0,0 +1 @@\n+Tar path points outside of the extraction directory: ./../hello.txt\n\\ No newline at end of file"
            },
            {
                "fn": "tests/tarTests/CompressedExtractTest/data/args",
                "patch": "@@ -0,0 +1 @@\n+--extract test.tar.bz2"
            },
            {
                "fn": "tests/tarTests/CompressedExtractTest/expect/return",
                "patch": "@@ -0,0 +1 @@\n+0"
            },
            {
                "fn": "tests/tarTests/CompressedExtractTest/expect/stdout",
                "patch": "@@ -0,0 +1 @@\n+hello.txt"
            },
            {
                "fn": "tests/tarTests/ExtractTest/data/args",
                "patch": "@@ -0,0 +1 @@\n+--extract test.tar"
            },
            {
                "fn": "tests/tarTests/ExtractTest/expect/return",
                "patch": "@@ -0,0 +1 @@\n+0"
            },
            {
                "fn": "tests/tarTests/ExtractTest/expect/stdout",
                "patch": "@@ -0,0 +1 @@\n+hello.txt"
            },
            {
                "fn": "tests/tarTests/SConscript",
                "patch": "@@ -0,0 +1,8 @@\n+Import('*')\n+\n+# Local includes\n+env.Append(CPPPATH = ['#'])\n+\n+prog = env.Program('tar', 'tar.cpp')\n+\n+Return('prog')"
            },
            {
                "fn": "tests/tarTests/tar.cpp",
                "patch": "@@ -0,0 +1,61 @@\n+/******************************************************************************\\\n+\n+          This file is part of the C! library.  A.K.A the cbang library.\n+\n+                Copyright (c) 2003-2019, Cauldron Development LLC\n+                   Copyright (c) 2003-2017, Stanford University\n+                               All rights reserved.\n+\n+         The C! library is free software: you can redistribute it and/or\n+        modify it under the terms of the GNU Lesser General Public License\n+       as published by the Free Software Foundation, either version 2.1 of\n+               the License, or (at your option) any later version.\n+\n+        The C! library is distributed in the hope that it will be useful,\n+          but WITHOUT ANY WARRANTY; without even the implied warranty of\n+        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+                 Lesser General Public License for more details.\n+\n+         You should have received a copy of the GNU Lesser General Public\n+                 License along with the C! library.  If not, see\n+                         <http://www.gnu.org/licenses/>.\n+\n+        In addition, BSD licensing may be granted on a case by case basis\n+        by written permission from at least one of the copyright holders.\n+           You may request written permission by emailing the authors.\n+\n+                  For information regarding this software email:\n+                                 Joseph Coffland\n+                          joseph@cauldrondevelopment.com\n+\n+\\******************************************************************************/\n+\n+#include <cbang/tar/TarFileReader.h>\n+#include <cbang/Catch.h>\n+\n+#include <iostream>\n+\n+using namespace cb;\n+using namespace std;\n+\n+\n+int main(int argc, char *argv[]) {\n+  try {\n+    for (int i = 1; i < argc; i++) {\n+      string arg = argv[i];\n+\n+      if (arg == \"--extract\" && i < argc - 1) {\n+        TarFileReader reader(argv[++i]);\n+\n+        while (reader.hasMore())\n+          cout << reader.extract() << endl;\n+\n+      } else THROWS(\"Invalid arg '\" << arg << \"'\");\n+    }\n+\n+    return 0;\n+\n+  } catch (const Exception &e) {cerr << e.getMessage();}\n+\n+  return 1;\n+}"
            },
            {
                "fn": "tests/tarTests/test.json",
                "patch": "@@ -0,0 +1,3 @@\n+{\n+  \"command\": \"%(suite-dir)s/tar\"\n+}"
            }
        ],
        "error_msg": "scons: Reading SConscript files ...\n   Compiler: gcc (gnu)\n   Platform: posix\n       Mode: gnu\n       Arch: x86\nGCC Version: 9\n       Jobs: 255\nChecking for C library pthread... (cached) yes\nChecking for C header file zlib.h... (cached) yes\nChecking for C library z... (cached) yes\nChecking for C header file bzlib.h... (cached) yes\nChecking for C library bz2... (cached) yes\nChecking for C header file expat.h... (cached) yes\nChecking for C library expat... (cached) yes\nChecking for C header file pthread.h... (cached) yes\nChecking for C library pthread... (cached) yes\nChecking for C library dl... (cached) yes\nChecking for C library sqlite3... (cached) yes\nChecking for C header file sqlite3.h... (cached) yes\nChecking for C function sqlite3_backup_init()... (cached) yes\nChecking for C header file yaml.h... (cached) yes\nChecking for C library yaml... (cached) yes\nChecking for C library snappy... (cached) yes\nChecking for C library leveldb... no\nNeed library leveldb(cached) error: no result\nChecking for C header file mysql/mysql.h... no\nChecking for C function clock_gettime()... (cached) yes\nChecking for C header file event.h... (cached) yes\nChecking for C library event... (cached) yes\nChecking for C++ header file re2/re2.h... (cached) yes\nChecking for C library re2... (cached) yes\nChecking for C function epoll_create1()... (cached) yes\nChecking for C library dl... (cached) yes\nChecking for C header file openssl/ssl.h... (cached) yes\nChecking for C library crypto... (cached) yes\nChecking for C library ssl... (cached) yes\nChecking for openssl version >= 1.1.0...(cached) yes\nChecking for C++ header file ChakraCore.h... no\nNeed C++ header ChakraCore.h(cached) error: no result\nChecking for C++ header file v8.h... (cached) yes\nChecking for C++ header file libplatform/libplatform.h... (cached) yes\nChecking for C library v8... (cached) yes\nChecking for C header file pthread.h... (cached) yes\nChecking for C library pthread... (cached) yes\nChecking for C header file valgrind/valgrind.h... (cached) yes\nChecking for C header file "
    }
}