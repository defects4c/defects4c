{
    "1f3c6f4534c6411313361697d98d1145a1f030fa___lparser.c": {
        "prefix": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  /* global name? */\n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */\n    lua_assert(var->k != VVOID);  /* this one must exist */\n",
        "suffix": "    luaK_indexed(fs, var, &key);  /* env[varname] */\n  }\n}\n",
        "start": 463,
        "end": 474,
        "buggy": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  /* global name? */\n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */\n    lua_assert(var->k != VVOID);  /* this one must exist */\n    codestring(&key, varname);  /* key is variable name */\n    luaK_indexed(fs, var, &key);  /* env[varname] */\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    codestring(&key, varname);  /* key is variable name */\n",
        "src_path": "1f3c6f4534c6411313361697d98d1145a1f030fa___lparser.c",
        "uri": "https://api.github.com/repos/lua/lua/commits/1f3c6f4534c6411313361697d98d1145a1f030fa",
        "commit_msg": "Bug: Lua can generate wrong code when _ENV is <const>",
        "test_func_diff": [
            {
                "fn": "testes/attrib.lua",
                "patch": "@@ -434,6 +434,16 @@ a.aVeryLongName012345678901234567890123456789012345678901234567890123456789 ==\n 10)\n \n \n+do\n+  -- _ENV constant\n+  local function foo ()\n+    local _ENV <const> = 11\n+    X = \"hi\"\n+  end\n+  local st, msg = pcall(foo)\n+  assert(not st and string.find(msg, \"number\"))\n+end\n+\n \n -- test of large float/integer indices \n "
            }
        ],
        "error_msg": "testing require\npackage config: /|;|?|!|-|\ntesting 'require' message\n+\n+\ntesting assignments, logical operators, and constructors\n+\n../lua: attrib.lua:444: assertion failed!\nstack traceback:\n\t[C]: in function 'assert'\n\tattrib.lua:444: in main chunk\n\t[C]: in ?\n"
    },
    "f8d9a433fe22ab2fa15c00179048ab02ae23d583___address.c": {
        "prefix": "struct Address *\nnew_address(const char *hostname_or_ip) {\n    union {\n        struct sockaddr a;\n        struct sockaddr_in in;\n        struct sockaddr_in6 in6;\n        struct sockaddr_un un;\n        struct sockaddr_storage s;\n    } s;\n    char ip_buf[ADDRESS_BUFFER_SIZE];\n    char *port;\n    size_t len;\n\n    if (hostname_or_ip == NULL)\n        return NULL;\n\n    /* IPv6 address */\n    /* we need to test for raw IPv6 address for IPv4 port combinations since a\n     * colon would give false positives\n     */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET6, hostname_or_ip,\n                &s.in6.sin6_addr) == 1) {\n        s.in6.sin6_family = AF_INET6;\n\n        return new_address_sa(&s.a, sizeof(s.in6));\n    }\n\n    /* Unix socket */\n    memset(&s, 0, sizeof(s));\n    if (strncmp(\"unix:\", hostname_or_ip, 5) == 0) {\n        if (strlen(hostname_or_ip) >=\n                sizeof(s.un.sun_path))\n            return NULL;\n\n        /* XXX: only supporting pathname unix sockets */\n        s.un.sun_family = AF_UNIX;\n        strncpy(s.un.sun_path,\n                hostname_or_ip + 5,\n                sizeof(s.un.sun_path) - 1);\n\n        return new_address_sa(&s.a, offsetof(struct sockaddr_un, sun_path) +\n                              strlen(s.un.sun_path) + 1);\n    }\n\n    /* Trailing port */\n    if ((port = strrchr(hostname_or_ip, ':')) != NULL &&\n            is_numeric(port + 1)) {\n        len = (size_t)(port - hostname_or_ip);\n        int port_num = atoi(port + 1);\n\n        if (len < sizeof(ip_buf) && port_num >= 0 && port_num <= 65535) {\n            strncpy(ip_buf, hostname_or_ip, len);\n            ip_buf[len] = '\\0';\n\n            struct Address *addr = new_address(ip_buf);\n            if (addr != NULL)\n                address_set_port(addr, (uint16_t) port_num);\n\n            return addr;\n        }\n    }\n\n    /* Wildcard */\n    if (strcmp(\"*\", hostname_or_ip) == 0) {\n        struct Address *addr = malloc(sizeof(struct Address));\n        if (addr != NULL) {\n            addr->type = WILDCARD;\n            addr->len = 0;\n            address_set_port(addr, 0);\n        }\n        return addr;\n    }\n\n    /* IPv4 address */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET, hostname_or_ip,\n                  &s.in.sin_addr) == 1) {\n        s.in.sin_family = AF_INET;\n\n        return new_address_sa(&s.a, sizeof(s.in));\n    }\n\n    /* [IPv6 address] */\n    memset(&s, 0, sizeof(s));\n    if (hostname_or_ip[0] == '[' &&\n            (port = strchr(hostname_or_ip, ']')) != NULL) {\n        len = (size_t)(port - hostname_or_ip - 1);\n",
        "suffix": "        /* inet_pton() will not parse the IP correctly unless it is in a\n         * separate string.\n         */\n        strncpy(ip_buf, hostname_or_ip + 1, len);\n        ip_buf[len] = '\\0';\n\n        if (inet_pton(AF_INET6, ip_buf,\n                      &s.in6.sin6_addr) == 1) {\n            s.in6.sin6_family = AF_INET6;\n\n            return new_address_sa(&s.a, sizeof(s.in6));\n        }\n    }\n\n    /* hostname */\n    if (valid_hostname(hostname_or_ip)) {\n        len = strlen(hostname_or_ip);\n        struct Address *addr = malloc(\n                offsetof(struct Address, data) + len + 1);\n        if (addr != NULL) {\n            addr->type = HOSTNAME;\n            addr->port = 0;\n            addr->len = len;\n            memcpy(addr->data, hostname_or_ip, len);\n            addr->data[addr->len] = '\\0';\n\n            /* Store address in lower case */\n            for (char *c = addr->data; *c != '\\0'; c++)\n                *c = tolower(*c);\n        }\n\n        return addr;\n    }\n\n    return NULL;\n}\n",
        "start": 63,
        "end": 187,
        "buggy": "struct Address *\nnew_address(const char *hostname_or_ip) {\n    union {\n        struct sockaddr a;\n        struct sockaddr_in in;\n        struct sockaddr_in6 in6;\n        struct sockaddr_un un;\n        struct sockaddr_storage s;\n    } s;\n    char ip_buf[ADDRESS_BUFFER_SIZE];\n    char *port;\n    size_t len;\n\n    if (hostname_or_ip == NULL)\n        return NULL;\n\n    /* IPv6 address */\n    /* we need to test for raw IPv6 address for IPv4 port combinations since a\n     * colon would give false positives\n     */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET6, hostname_or_ip,\n                &s.in6.sin6_addr) == 1) {\n        s.in6.sin6_family = AF_INET6;\n\n        return new_address_sa(&s.a, sizeof(s.in6));\n    }\n\n    /* Unix socket */\n    memset(&s, 0, sizeof(s));\n    if (strncmp(\"unix:\", hostname_or_ip, 5) == 0) {\n        if (strlen(hostname_or_ip) >=\n                sizeof(s.un.sun_path))\n            return NULL;\n\n        /* XXX: only supporting pathname unix sockets */\n        s.un.sun_family = AF_UNIX;\n        strncpy(s.un.sun_path,\n                hostname_or_ip + 5,\n                sizeof(s.un.sun_path) - 1);\n\n        return new_address_sa(&s.a, offsetof(struct sockaddr_un, sun_path) +\n                              strlen(s.un.sun_path) + 1);\n    }\n\n    /* Trailing port */\n    if ((port = strrchr(hostname_or_ip, ':')) != NULL &&\n            is_numeric(port + 1)) {\n        len = (size_t)(port - hostname_or_ip);\n        int port_num = atoi(port + 1);\n\n        if (len < sizeof(ip_buf) && port_num >= 0 && port_num <= 65535) {\n            strncpy(ip_buf, hostname_or_ip, len);\n            ip_buf[len] = '\\0';\n\n            struct Address *addr = new_address(ip_buf);\n            if (addr != NULL)\n                address_set_port(addr, (uint16_t) port_num);\n\n            return addr;\n        }\n    }\n\n    /* Wildcard */\n    if (strcmp(\"*\", hostname_or_ip) == 0) {\n        struct Address *addr = malloc(sizeof(struct Address));\n        if (addr != NULL) {\n            addr->type = WILDCARD;\n            addr->len = 0;\n            address_set_port(addr, 0);\n        }\n        return addr;\n    }\n\n    /* IPv4 address */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET, hostname_or_ip,\n                  &s.in.sin_addr) == 1) {\n        s.in.sin_family = AF_INET;\n\n        return new_address_sa(&s.a, sizeof(s.in));\n    }\n\n    /* [IPv6 address] */\n    memset(&s, 0, sizeof(s));\n    if (hostname_or_ip[0] == '[' &&\n            (port = strchr(hostname_or_ip, ']')) != NULL) {\n        len = (size_t)(port - hostname_or_ip - 1);\n\n        /* inet_pton() will not parse the IP correctly unless it is in a\n         * separate string.\n         */\n        strncpy(ip_buf, hostname_or_ip + 1, len);\n        ip_buf[len] = '\\0';\n\n        if (inet_pton(AF_INET6, ip_buf,\n                      &s.in6.sin6_addr) == 1) {\n            s.in6.sin6_family = AF_INET6;\n\n            return new_address_sa(&s.a, sizeof(s.in6));\n        }\n    }\n\n    /* hostname */\n    if (valid_hostname(hostname_or_ip)) {\n        len = strlen(hostname_or_ip);\n        struct Address *addr = malloc(\n                offsetof(struct Address, data) + len + 1);\n        if (addr != NULL) {\n            addr->type = HOSTNAME;\n            addr->port = 0;\n            addr->len = len;\n            memcpy(addr->data, hostname_or_ip, len);\n            addr->data[addr->len] = '\\0';\n\n            /* Store address in lower case */\n            for (char *c = addr->data; *c != '\\0'; c++)\n                *c = tolower(*c);\n        }\n\n        return addr;\n    }\n\n    return NULL;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\n",
        "src_path": "f8d9a433fe22ab2fa15c00179048ab02ae23d583___address.c",
        "uri": "https://api.github.com/repos/dlundquist/sniproxy/commits/f8d9a433fe22ab2fa15c00179048ab02ae23d583",
        "commit_msg": "address: fix buffer overflow\n\nUpdate tests to work on Debian 11.",
        "test_func_diff": [
            {
                "fn": "tests/Makefile.am",
                "patch": "@@ -1,6 +1,8 @@\n AM_CPPFLAGS = -I$(top_srcdir)/src -g $(LIBEV_CFLAGS) $(LIBPCRE_CFLAGS) $(LIBUDNS_CFLAGS)\n AM_CFLAGS = -fno-strict-aliasing -Wall -Wextra -Wpedantic -Wwrite-strings\n \n+.NOTPARALLEL:\n+\n TESTS = address_test \\\n         buffer_test \\\n         cfg_tokenizer_test \\"
            },
            {
                "fn": "tests/bad_dns_request_test",
                "patch": "@@ -35,6 +35,11 @@ my $bad_requests = [\n         request => \"GET / HTTP/1.1\\r\\nHost: \\0example.com\\r\\n\\r\\n\",\n         client => \\&http_client,\n     },\n+    {\n+        # Exceed hostname buffer size\n+        request => \"GET / HTTP/1.1\\r\\nHost: [\" . 'long.' x 60 . \"example.com]\\r\\n\\r\\n\",\n+        client => \\&http_client,\n+    },\n     {\n         # Test client aborting connection before DNS response received\n         request => \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n\","
            },
            {
                "fn": "tests/slow_client_test",
                "patch": "@@ -31,11 +31,16 @@ sub slow_client($$) {\n     my $socket = IO::Socket::INET->new(PeerAddr => '127.0.0.1',\n             PeerPort => $port,\n             Proto => \"tcp\",\n-            Type => SOCK_STREAM)\n+            Type => SOCK_STREAM,\n+            Timeout => 5)\n         or die \"couldn't connect $!\";\n \n     $socket->send($request);\n     foreach (split(\"\\r\\n\", $request)) {\n+        unless ($socket->connected()) {\n+            print \"Disconnected\\n\";\n+            exit(0);\n+        }\n         $socket->send(\"$_\\r\\n\");\n         sleep(1);\n     }"
            }
        ],
        "error_msg": "Test failed.\nworker failed with exit code 111\nworker failed with exit code 111\nserver died with signal 11, with coredump\nworker failed with exit code 111\nnd LibVEX; rerun with -h for copyright info\n==853088== Command: ../src/sniproxy -f -c /tmp/GaG05lCg4d\n==853088== \n--853088-- WARNING: Serious error when reading debug info\n--853088-- When reading debug info from /mnt/local/home_dir/wj_code/dl_code/out/dlundquist___sniproxy/git_repo_dir/src/sniproxy:\n--853088-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--853088-- WARNING: Serious error when reading debug info\n--853088-- When reading debug info from /mnt/local/home_dir/wj_code/dl_code/out/dlundquist___sniproxy/git_repo_dir/src/sniproxy:\n--853088-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--853088-- WARNING: Serious error when reading debug info\n--853088-- When reading debug info from /mnt/local/home_dir/wj_code/dl_code/out/dlundquist___sniproxy/git_repo_dir/src/sniproxy:\n--853088-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--853088-- WARNING: Serious error when reading debug info\n--853088-- When reading debug info from /mnt/local/home_dir/wj_code/dl_code/out/dlundquist___sniproxy/git_repo_dir/src/sniproxy:\n--853088-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--853088-- WARNING: Serious error when reading debug info\n--853088-- When reading debug info from /mnt/local/home_dir/wj_code/dl_code/out/dlundquist___sniproxy/git_repo_dir/src/sniproxy:\n--853088-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--853088-- WARNING: Serious error when reading debug info\n--853088-- When reading debug info from /mnt/local/home_dir/wj_code/dl_code/out/dlundquist___sniproxy/git_repo_dir/src/sniproxy:\n--853088-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--853088-- WARNING: Serious error when reading debug info\n--853088-- When reading debug info from /mnt/local/home_dir/wj_code/dl_code/out/dlundquist___sniproxy/git_repo_dir/src/sniproxy:\n--853088-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--853088-- WARNING: Serious error when reading debug info\n--853088-- When readi"
    },
    "6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45___smbutil.c": {
        "prefix": "static int\nname_len(netdissect_options *ndo,\n         const unsigned char *s, const unsigned char *maxbuf)\n{\n    const unsigned char *s0 = s;\n    unsigned char c;\n\n    if (s >= maxbuf)\n\treturn(-1);\t/* name goes past the end of the buffer */\n    ND_TCHECK2(*s, 1);\n    c = *s;\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (*s) {\n\tif (s >= maxbuf)\n\t    return(-1);\t/* name goes past the end of the buffer */\n\tND_TCHECK2(*s, 1);\n\ts += (*s) + 1;\n",
        "suffix": "    return(PTR_DIFF(s, s0) + 1);\n\ntrunc:\n    return(-1);\t/* name goes past the end of the buffer */\n}\n",
        "start": 222,
        "end": 245,
        "buggy": "static int\nname_len(netdissect_options *ndo,\n         const unsigned char *s, const unsigned char *maxbuf)\n{\n    const unsigned char *s0 = s;\n    unsigned char c;\n\n    if (s >= maxbuf)\n\treturn(-1);\t/* name goes past the end of the buffer */\n    ND_TCHECK2(*s, 1);\n    c = *s;\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (*s) {\n\tif (s >= maxbuf)\n\t    return(-1);\t/* name goes past the end of the buffer */\n\tND_TCHECK2(*s, 1);\n\ts += (*s) + 1;\n    }\n    return(PTR_DIFF(s, s0) + 1);\n\ntrunc:\n    return(-1);\t/* name goes past the end of the buffer */\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    }\n",
        "src_path": "6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45___smbutil.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45",
        "commit_msg": "CVE-2017-12893/SMB/CIFS: Add a bounds check in name_len().\n\nAfter we advance the pointer by the length value in the buffer, make\nsure it points to something in the captured data.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -449,6 +449,9 @@ decnet-oobr\t\tdecnet-oobr.pcap\t\tdecnet-oobr.out\n # bad packets from Wilfried Kirsch\n slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve\n \n+# bad packets from Otto Airamo and Antti Levom\u00e4ki\n+nbns-valgrind\t\tnbns-valgrind.pcap\t\tnbns-valgrind.out\t-vvv -e\n+\n # RTP tests\n # fuzzed pcap\n rtp-seg-fault-1  rtp-seg-fault-1.pcap  rtp-seg-fault-1.out  -v -T rtp"
            },
            {
                "fn": "tests/nbns-valgrind.out",
                "patch": "@@ -0,0 +1,16 @@\n+00:0c:85:0e:a5:ff > 00:00:0c:07:ac:f0, ethertype IPv4 (0x0800), length 92: (tos 0x0, ttl 127, id 38615, offset 0, flags [none], proto UDP (17), length 78)\n+    10.49.248.228.137 > 10.48.161.241.137: \n+>>> NBT UDP PACKET(137): QUERY; REQUEST; UNICAST\n+TrnID=0x8D40\n+OpCode=0\n+NmFlags=0x10\n+Rcode=0\n+QueryCount=1\n+AnswerCount=0\n+AuthorityCount=0\n+AddressRecCount=0\n+QuestionRecords:\n+Name=\n+WARNING: Short packet. Try increasing the snap length\n+\n+"
            }
        ],
        "error_msg": "    nbns-valgrind                      : TEST FAILED(exit 256)\n"
    },
    "99798bd9a41bd3d03fdc1e949810a38967f20ed3___print-802_11.c": {
        "prefix": "static int\nparse_elements(netdissect_options *ndo,\n               struct mgmt_body_t *pbody, const u_char *p, int offset,\n               u_int length)\n{\n\tu_int elementlen;\n\tstruct ssid_t ssid;\n\tstruct challenge_t challenge;\n\tstruct rates_t rates;\n\tstruct ds_t ds;\n\tstruct cf_t cf;\n\tstruct tim_t tim;\n\n\t/*\n\t * We haven't seen any elements yet.\n\t */\n\tpbody->challenge_present = 0;\n\tpbody->ssid_present = 0;\n\tpbody->rates_present = 0;\n\tpbody->ds_present = 0;\n\tpbody->cf_present = 0;\n\tpbody->tim_present = 0;\n\n\twhile (length != 0) {\n\t\t/* Make sure we at least have the element ID and length. */\n\t\tif (!ND_TTEST2(*(p + offset), 2))\n\t\t\treturn 0;\n\t\tif (length < 2)\n\t\t\treturn 0;\n\t\telementlen = *(p + offset + 1);\n\n\t\t/* Make sure we have the entire element. */\n\t\tif (!ND_TTEST2(*(p + offset + 2), elementlen))\n\t\t\treturn 0;\n\t\tif (length < elementlen + 2)\n\t\t\treturn 0;\n\n\t\tswitch (*(p + offset)) {\n\t\tcase E_SSID:\n\t\t\tmemcpy(&ssid, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (ssid.length != 0) {\n\t\t\t\tif (ssid.length > sizeof(ssid.ssid) - 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), ssid.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < ssid.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&ssid.ssid, p + offset, ssid.length);\n\t\t\t\toffset += ssid.length;\n\t\t\t\tlength -= ssid.length;\n\t\t\t}\n\t\t\tssid.ssid[ssid.length] = '\\0';\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen an SSID IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->ssid_present) {\n\t\t\t\tpbody->ssid = ssid;\n\t\t\t\tpbody->ssid_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_CHALLENGE:\n\t\t\tmemcpy(&challenge, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (challenge.length != 0) {\n\t\t\t\tif (challenge.length >\n\t\t\t\t    sizeof(challenge.text) - 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), challenge.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < challenge.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&challenge.text, p + offset,\n\t\t\t\t    challenge.length);\n\t\t\t\toffset += challenge.length;\n\t\t\t\tlength -= challenge.length;\n\t\t\t}\n\t\t\tchallenge.text[challenge.length] = '\\0';\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a challenge IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->challenge_present) {\n\t\t\t\tpbody->challenge = challenge;\n\t\t\t\tpbody->challenge_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_RATES:\n\t\t\tmemcpy(&rates, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (rates.length != 0) {\n\t\t\t\tif (rates.length > sizeof rates.rate)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), rates.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < rates.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&rates.rate, p + offset, rates.length);\n\t\t\t\toffset += rates.length;\n\t\t\t\tlength -= rates.length;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a rates IE,\n\t\t\t * copy this one if it's not zero-length,\n\t\t\t * otherwise ignore this one, so we later\n\t\t\t * report the first one we saw.\n\t\t\t *\n\t\t\t * We ignore zero-length rates IEs as some\n\t\t\t * devices seem to put a zero-length rates\n\t\t\t * IE, followed by an SSID IE, followed by\n\t\t\t * a non-zero-length rates IE into frames,\n\t\t\t * even though IEEE Std 802.11-2007 doesn't\n\t\t\t * seem to indicate that a zero-length rates\n\t\t\t * IE is valid.\n\t\t\t */\n\t\t\tif (!pbody->rates_present && rates.length != 0) {\n\t\t\t\tpbody->rates = rates;\n\t\t\t\tpbody->rates_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_DS:\n\t\t\tmemcpy(&ds, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (ds.length != 1) {\n\t\t\t\toffset += ds.length;\n\t\t\t\tlength -= ds.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tds.channel = *(p + offset);\n\t\t\toffset += 1;\n\t\t\tlength -= 1;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a DS IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->ds_present) {\n\t\t\t\tpbody->ds = ds;\n\t\t\t\tpbody->ds_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_CF:\n\t\t\tmemcpy(&cf, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (cf.length != 6) {\n\t\t\t\toffset += cf.length;\n\t\t\t\tlength -= cf.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(&cf.count, p + offset, 6);\n\t\t\toffset += 6;\n\t\t\tlength -= 6;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a CF IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->cf_present) {\n\t\t\t\tpbody->cf = cf;\n\t\t\t\tpbody->cf_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_TIM:\n\t\t\tmemcpy(&tim, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (tim.length <= 3) {\n\t\t\t\toffset += tim.length;\n\t\t\t\tlength -= tim.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tim.length - 3 > (int)sizeof tim.bitmap)\n\t\t\t\treturn 0;\n\t\t\tmemcpy(&tim.count, p + offset, 3);\n\t\t\toffset += 3;\n\t\t\tlength -= 3;\n\n",
        "suffix": "\t\t\tlength -= tim.length - 3;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a TIM IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->tim_present) {\n\t\t\t\tpbody->tim = tim;\n\t\t\t\tpbody->tim_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n#if 0\n\t\t\tND_PRINT((ndo, \"(1) unhandled element_id (%d)  \",\n\t\t\t    *(p + offset)));\n#endif\n\t\t\toffset += 2 + elementlen;\n\t\t\tlength -= 2 + elementlen;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* No problems found. */\n\treturn 1;\n}\n",
        "start": 997,
        "end": 1221,
        "buggy": "static int\nparse_elements(netdissect_options *ndo,\n               struct mgmt_body_t *pbody, const u_char *p, int offset,\n               u_int length)\n{\n\tu_int elementlen;\n\tstruct ssid_t ssid;\n\tstruct challenge_t challenge;\n\tstruct rates_t rates;\n\tstruct ds_t ds;\n\tstruct cf_t cf;\n\tstruct tim_t tim;\n\n\t/*\n\t * We haven't seen any elements yet.\n\t */\n\tpbody->challenge_present = 0;\n\tpbody->ssid_present = 0;\n\tpbody->rates_present = 0;\n\tpbody->ds_present = 0;\n\tpbody->cf_present = 0;\n\tpbody->tim_present = 0;\n\n\twhile (length != 0) {\n\t\t/* Make sure we at least have the element ID and length. */\n\t\tif (!ND_TTEST2(*(p + offset), 2))\n\t\t\treturn 0;\n\t\tif (length < 2)\n\t\t\treturn 0;\n\t\telementlen = *(p + offset + 1);\n\n\t\t/* Make sure we have the entire element. */\n\t\tif (!ND_TTEST2(*(p + offset + 2), elementlen))\n\t\t\treturn 0;\n\t\tif (length < elementlen + 2)\n\t\t\treturn 0;\n\n\t\tswitch (*(p + offset)) {\n\t\tcase E_SSID:\n\t\t\tmemcpy(&ssid, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (ssid.length != 0) {\n\t\t\t\tif (ssid.length > sizeof(ssid.ssid) - 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), ssid.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < ssid.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&ssid.ssid, p + offset, ssid.length);\n\t\t\t\toffset += ssid.length;\n\t\t\t\tlength -= ssid.length;\n\t\t\t}\n\t\t\tssid.ssid[ssid.length] = '\\0';\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen an SSID IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->ssid_present) {\n\t\t\t\tpbody->ssid = ssid;\n\t\t\t\tpbody->ssid_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_CHALLENGE:\n\t\t\tmemcpy(&challenge, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (challenge.length != 0) {\n\t\t\t\tif (challenge.length >\n\t\t\t\t    sizeof(challenge.text) - 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), challenge.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < challenge.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&challenge.text, p + offset,\n\t\t\t\t    challenge.length);\n\t\t\t\toffset += challenge.length;\n\t\t\t\tlength -= challenge.length;\n\t\t\t}\n\t\t\tchallenge.text[challenge.length] = '\\0';\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a challenge IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->challenge_present) {\n\t\t\t\tpbody->challenge = challenge;\n\t\t\t\tpbody->challenge_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_RATES:\n\t\t\tmemcpy(&rates, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (rates.length != 0) {\n\t\t\t\tif (rates.length > sizeof rates.rate)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), rates.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < rates.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&rates.rate, p + offset, rates.length);\n\t\t\t\toffset += rates.length;\n\t\t\t\tlength -= rates.length;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a rates IE,\n\t\t\t * copy this one if it's not zero-length,\n\t\t\t * otherwise ignore this one, so we later\n\t\t\t * report the first one we saw.\n\t\t\t *\n\t\t\t * We ignore zero-length rates IEs as some\n\t\t\t * devices seem to put a zero-length rates\n\t\t\t * IE, followed by an SSID IE, followed by\n\t\t\t * a non-zero-length rates IE into frames,\n\t\t\t * even though IEEE Std 802.11-2007 doesn't\n\t\t\t * seem to indicate that a zero-length rates\n\t\t\t * IE is valid.\n\t\t\t */\n\t\t\tif (!pbody->rates_present && rates.length != 0) {\n\t\t\t\tpbody->rates = rates;\n\t\t\t\tpbody->rates_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_DS:\n\t\t\tmemcpy(&ds, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (ds.length != 1) {\n\t\t\t\toffset += ds.length;\n\t\t\t\tlength -= ds.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tds.channel = *(p + offset);\n\t\t\toffset += 1;\n\t\t\tlength -= 1;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a DS IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->ds_present) {\n\t\t\t\tpbody->ds = ds;\n\t\t\t\tpbody->ds_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_CF:\n\t\t\tmemcpy(&cf, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (cf.length != 6) {\n\t\t\t\toffset += cf.length;\n\t\t\t\tlength -= cf.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(&cf.count, p + offset, 6);\n\t\t\toffset += 6;\n\t\t\tlength -= 6;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a CF IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->cf_present) {\n\t\t\t\tpbody->cf = cf;\n\t\t\t\tpbody->cf_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_TIM:\n\t\t\tmemcpy(&tim, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (tim.length <= 3) {\n\t\t\t\toffset += tim.length;\n\t\t\t\tlength -= tim.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tim.length - 3 > (int)sizeof tim.bitmap)\n\t\t\t\treturn 0;\n\t\t\tmemcpy(&tim.count, p + offset, 3);\n\t\t\toffset += 3;\n\t\t\tlength -= 3;\n\n\t\t\tmemcpy(tim.bitmap, p + (tim.length - 3),\n\t\t\t    (tim.length - 3));\n\t\t\toffset += tim.length - 3;\n\t\t\tlength -= tim.length - 3;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a TIM IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->tim_present) {\n\t\t\t\tpbody->tim = tim;\n\t\t\t\tpbody->tim_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n#if 0\n\t\t\tND_PRINT((ndo, \"(1) unhandled element_id (%d)  \",\n\t\t\t    *(p + offset)));\n#endif\n\t\t\toffset += 2 + elementlen;\n\t\t\tlength -= 2 + elementlen;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* No problems found. */\n\treturn 1;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tmemcpy(tim.bitmap, p + (tim.length - 3),\n\t\t\t    (tim.length - 3));\n\t\t\toffset += tim.length - 3;\n",
        "src_path": "99798bd9a41bd3d03fdc1e949810a38967f20ed3___print-802_11.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/99798bd9a41bd3d03fdc1e949810a38967f20ed3",
        "commit_msg": "CVE-2017-12987/IEEE 802.11: Fix processing of TIM IE.\n\nThe arguments to memcpy() were completely wrong.\n\nThis fixes a buffer over-read discovered by Kamil Frankowicz.\n\nAdd a test using the capture file supplied by Brian 'geeknik' Carpenter.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -435,6 +435,7 @@ atm-heapoverflow\tatm-heapoverflow.pcap\t\tatm-heapoverflow.out\t\t-c1 -e\n ipv6-next-header-oobr-1\tipv6-next-header-oobr-1.pcap\tipv6-next-header-oobr-1.out\n ipv6-next-header-oobr-2\tipv6-next-header-oobr-2.pcap\tipv6-next-header-oobr-2.out\n ipv6-rthdr-oobr\t\tipv6-rthdr-oobr.pcap\t\tipv6-rthdr-oobr.out\n+ieee802.11_tim_ie_oobr\tieee802.11_tim_ie_oobr.pcap\tieee802.11_tim_ie_oobr.out\n \n # bad packets from Kamil Frankowicz\n snmp-heapoverflow-1\tsnmp-heapoverflow-1.pcap\tsnmp-heapoverflow-1.out"
            },
            {
                "fn": "tests/ieee802.11_tim_ie_oobr.out",
                "patch": "@@ -0,0 +1,4 @@\n+ReAssoc Response AID(3030) : PRIVACY : n/a[|802.11]\n+ReAssoc Response AID(3030) : PRIVACY : n/a[|802.11]\n+[|802.11]\n+ReAssoc Response AID(3030) : PRIVACY : n/a[|802.11]"
            }
        ],
        "error_msg": "    ieee802.11_tim_ie_oobr             : passed\n"
    },
    "8934a7d6307267d301182f19ed162563717e29e3___print-telnet.c": {
        "prefix": "static int\ntelnet_parse(netdissect_options *ndo, const u_char *sp, u_int length, int print)\n{\n\tint i, x;\n\tu_int c;\n\tconst u_char *osp, *p;\n#define FETCH(c, sp, length) \\\n\tdo { \\\n\t\tif (length < 1) \\\n\t\t\tgoto pktend; \\\n\t\tND_TCHECK(*sp); \\\n\t\tc = *sp++; \\\n\t\tlength--; \\\n\t} while (0)\n\n\tosp = sp;\n\n\tFETCH(c, sp, length);\n\tif (c != IAC)\n\t\tgoto pktend;\n\tFETCH(c, sp, length);\n\tif (c == IAC) {\t\t/* <IAC><IAC>! */\n\t\tif (print)\n\t\t\tND_PRINT((ndo, \"IAC IAC\"));\n\t\tgoto done;\n\t}\n\n\ti = c - TELCMD_FIRST;\n\tif (i < 0 || i > IAC - TELCMD_FIRST)\n\t\tgoto pktend;\n\n\tswitch (c) {\n\tcase DONT:\n\tcase DO:\n\tcase WONT:\n\tcase WILL:\n\tcase SB:\n\t\t/* DONT/DO/WONT/WILL x */\n\t\tFETCH(x, sp, length);\n\t\tif (x >= 0 && x < NTELOPTS) {\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \"%s %s\", telcmds[i], telopts[x]));\n\t\t} else {\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \"%s %#x\", telcmds[i], x));\n\t\t}\n\t\tif (c != SB)\n\t\t\tbreak;\n\t\t/* IAC SB .... IAC SE */\n\t\tp = sp;\n\t\twhile (length > (u_int)(p + 1 - sp)) {\n\t\t\tND_TCHECK2(*p, 2);\n\t\t\tif (p[0] == IAC && p[1] == SE)\n\t\t\t\tbreak;\n\t\t\tp++;\n\t\t}\n",
        "suffix": "\t\t\tgoto pktend;\n\n\t\tswitch (x) {\n\t\tcase TELOPT_AUTHENTICATION:\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, authcmd)));\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, authtype)));\n\t\t\tbreak;\n\t\tcase TELOPT_ENCRYPT:\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, enccmd)));\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, enctype)));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, cmds)));\n\t\t\tbreak;\n\t\t}\n\t\twhile (p > sp) {\n\t\t\tFETCH(x, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %#x\", x));\n\t\t}\n\t\t/* terminating IAC SE */\n\t\tif (print)\n\t\t\tND_PRINT((ndo, \" SE\"));\n\t\tsp += 2;\n\t\tbreak;\n\tdefault:\n\t\tif (print)\n\t\t\tND_PRINT((ndo, \"%s\", telcmds[i]));\n\t\tgoto done;\n\t}\n\ndone:\n\treturn sp - osp;\n\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\npktend:\n\treturn -1;\n#undef FETCH\n}\n",
        "start": 389,
        "end": 505,
        "buggy": "static int\ntelnet_parse(netdissect_options *ndo, const u_char *sp, u_int length, int print)\n{\n\tint i, x;\n\tu_int c;\n\tconst u_char *osp, *p;\n#define FETCH(c, sp, length) \\\n\tdo { \\\n\t\tif (length < 1) \\\n\t\t\tgoto pktend; \\\n\t\tND_TCHECK(*sp); \\\n\t\tc = *sp++; \\\n\t\tlength--; \\\n\t} while (0)\n\n\tosp = sp;\n\n\tFETCH(c, sp, length);\n\tif (c != IAC)\n\t\tgoto pktend;\n\tFETCH(c, sp, length);\n\tif (c == IAC) {\t\t/* <IAC><IAC>! */\n\t\tif (print)\n\t\t\tND_PRINT((ndo, \"IAC IAC\"));\n\t\tgoto done;\n\t}\n\n\ti = c - TELCMD_FIRST;\n\tif (i < 0 || i > IAC - TELCMD_FIRST)\n\t\tgoto pktend;\n\n\tswitch (c) {\n\tcase DONT:\n\tcase DO:\n\tcase WONT:\n\tcase WILL:\n\tcase SB:\n\t\t/* DONT/DO/WONT/WILL x */\n\t\tFETCH(x, sp, length);\n\t\tif (x >= 0 && x < NTELOPTS) {\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \"%s %s\", telcmds[i], telopts[x]));\n\t\t} else {\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \"%s %#x\", telcmds[i], x));\n\t\t}\n\t\tif (c != SB)\n\t\t\tbreak;\n\t\t/* IAC SB .... IAC SE */\n\t\tp = sp;\n\t\twhile (length > (u_int)(p + 1 - sp)) {\n\t\t\tND_TCHECK2(*p, 2);\n\t\t\tif (p[0] == IAC && p[1] == SE)\n\t\t\t\tbreak;\n\t\t\tp++;\n\t\t}\n\t\tif (*p != IAC)\n\t\t\tgoto pktend;\n\n\t\tswitch (x) {\n\t\tcase TELOPT_AUTHENTICATION:\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, authcmd)));\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, authtype)));\n\t\t\tbreak;\n\t\tcase TELOPT_ENCRYPT:\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, enccmd)));\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, enctype)));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, cmds)));\n\t\t\tbreak;\n\t\t}\n\t\twhile (p > sp) {\n\t\t\tFETCH(x, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %#x\", x));\n\t\t}\n\t\t/* terminating IAC SE */\n\t\tif (print)\n\t\t\tND_PRINT((ndo, \" SE\"));\n\t\tsp += 2;\n\t\tbreak;\n\tdefault:\n\t\tif (print)\n\t\t\tND_PRINT((ndo, \"%s\", telcmds[i]));\n\t\tgoto done;\n\t}\n\ndone:\n\treturn sp - osp;\n\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\npktend:\n\treturn -1;\n#undef FETCH\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\tif (*p != IAC)\n",
        "src_path": "8934a7d6307267d301182f19ed162563717e29e3___print-telnet.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/8934a7d6307267d301182f19ed162563717e29e3",
        "commit_msg": "CVE-2017-12988/TELNET: Add a missing bounds check.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -466,6 +466,7 @@ eigrp-tlv-oobr\t\teigrp-tlv-oobr.pcap\t\teigrp-tlv-oobr.out\t-vvv -e\n zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n bgp-as-path-oobr\tbgp-as-path-oobr.pcap\t\tbgp-as-path-oobr.out\t-vvv -e\n isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n+telnet-iac-check-oobr\ttelnet-iac-check-oobr.pcap\ttelnet-iac-check-oobr.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap"
            }
        ],
        "error_msg": "    telnet-iac-check-oobr              : TEST FAILED(exit 256)\n"
    },
    "b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00___print-mobility.c": {
        "prefix": "static int\nmobility_opt_print(netdissect_options *ndo,\n                   const u_char *bp, const unsigned len)\n{\n\tunsigned i, optlen;\n\n\tfor (i = 0; i < len; i += optlen) {\n\t\tND_TCHECK(bp[i]);\n\t\tif (bp[i] == IP6MOPT_PAD1)\n\t\t\toptlen = 1;\n\t\telse {\n\t\t\tif (i + 1 < len) {\n\t\t\t\tND_TCHECK(bp[i + 1]);\n\t\t\t\toptlen = bp[i + 1] + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto trunc;\n\t\t}\n\t\tif (i + optlen > len)\n\t\t\tgoto trunc;\n\t\tND_TCHECK(bp[i + optlen]);\n\n\t\tswitch (bp[i]) {\n\t\tcase IP6MOPT_PAD1:\n\t\t\tND_PRINT((ndo, \"(pad1)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_PADN:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(padn: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(padn)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_REFRESH:\n\t\t\tif (len - i < IP6MOPT_REFRESH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(refresh: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\t/* units of 4 secs */\n",
        "suffix": "\t\t\t\tEXTRACT_16BITS(&bp[i+2]) << 2));\n\t\t\tbreak;\n\t\tcase IP6MOPT_ALTCOA:\n\t\t\tif (len - i < IP6MOPT_ALTCOA_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(altcoa: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(alt-CoA: %s)\", ip6addr_string(ndo, &bp[i+2])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_NONCEID:\n\t\t\tif (len - i < IP6MOPT_NONCEID_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(ni: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(ni: ho=0x%04x co=0x%04x)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]),\n\t\t\t\tEXTRACT_16BITS(&bp[i+4])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_AUTH:\n\t\t\tif (len - i < IP6MOPT_AUTH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(auth: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(auth)\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(sopt_type %u: trunc)\", bp[i]));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(type-0x%02x: len=%u)\", bp[i], bp[i + 1]));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n\ntrunc:\n\treturn 1;\n}\n",
        "start": 114,
        "end": 192,
        "buggy": "static int\nmobility_opt_print(netdissect_options *ndo,\n                   const u_char *bp, const unsigned len)\n{\n\tunsigned i, optlen;\n\n\tfor (i = 0; i < len; i += optlen) {\n\t\tND_TCHECK(bp[i]);\n\t\tif (bp[i] == IP6MOPT_PAD1)\n\t\t\toptlen = 1;\n\t\telse {\n\t\t\tif (i + 1 < len) {\n\t\t\t\tND_TCHECK(bp[i + 1]);\n\t\t\t\toptlen = bp[i + 1] + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto trunc;\n\t\t}\n\t\tif (i + optlen > len)\n\t\t\tgoto trunc;\n\t\tND_TCHECK(bp[i + optlen]);\n\n\t\tswitch (bp[i]) {\n\t\tcase IP6MOPT_PAD1:\n\t\t\tND_PRINT((ndo, \"(pad1)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_PADN:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(padn: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(padn)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_REFRESH:\n\t\t\tif (len - i < IP6MOPT_REFRESH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(refresh: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\t/* units of 4 secs */\n\t\t\tND_PRINT((ndo, \"(refresh: %u)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]) << 2));\n\t\t\tbreak;\n\t\tcase IP6MOPT_ALTCOA:\n\t\t\tif (len - i < IP6MOPT_ALTCOA_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(altcoa: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(alt-CoA: %s)\", ip6addr_string(ndo, &bp[i+2])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_NONCEID:\n\t\t\tif (len - i < IP6MOPT_NONCEID_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(ni: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(ni: ho=0x%04x co=0x%04x)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]),\n\t\t\t\tEXTRACT_16BITS(&bp[i+4])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_AUTH:\n\t\t\tif (len - i < IP6MOPT_AUTH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(auth: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(auth)\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(sopt_type %u: trunc)\", bp[i]));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(type-0x%02x: len=%u)\", bp[i], bp[i + 1]));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n\ntrunc:\n\treturn 1;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tND_PRINT((ndo, \"(refresh: %u)\",\n",
        "src_path": "b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00___print-mobility.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00",
        "commit_msg": "CVE-2017-13023/IPv6 mobility: Add a bounds check before fetching data\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't cause 'tcpdump: pcap_loop: truncated dump file'",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -524,6 +524,7 @@ pgm_opts_asan_2\t\tpgm_opts_asan_2.pcap\t\tpgm_opts_asan_2.out\t-v\n vtp_asan\t\tvtp_asan.pcap\t\t\tvtp_asan.out\t-v\n icmp6_mobileprefix_asan\ticmp6_mobileprefix_asan.pcap\ticmp6_mobileprefix_asan.out\t-v\n ip_printroute_asan\tip_printroute_asan.pcap\t\tip_printroute_asan.out\t-v\n+mobility_opt_asan\tmobility_opt_asan.pcap\t\tmobility_opt_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/mobility_opt_asan.out",
                "patch": "@@ -0,0 +1,2 @@\n+IP6 (class 0x50, flowlabel 0x00004, hlim 0, next-header Mobile IP (old) (62) payload length: 7168) d400:7fa1:0:400::6238:2949 > 9675:86dd:7300:2c:1c7f:ffff:ffc3:b2a1: mobility: BU seq#=116 A lifetime=15872(pad1)[|MOBILITY]\n+IP6 (class 0x50, flowlabel 0x00004, hlim 0, next-header Mobile IP (old) (62) payload length: 7168) d4c3:b2a1:200:400::6238:2949 > 9675:86dd:73f0:2c:1c7f:ffff:ebc3:b291: mobility: BU seq#=116 A lifetime=15360[|MOBILITY]"
            }
        ],
        "error_msg": "    mobility_opt_asan                  : TEST FAILED(exit 256)\n"
    },
    "7d3aba9f06899d0128ef46e8a2fa143c6fad8f62___print-mobility.c": {
        "prefix": "static int\nmobility_opt_print(netdissect_options *ndo,\n                   const u_char *bp, const unsigned len)\n{\n\tunsigned i, optlen;\n\n\tfor (i = 0; i < len; i += optlen) {\n\t\tND_TCHECK(bp[i]);\n\t\tif (bp[i] == IP6MOPT_PAD1)\n\t\t\toptlen = 1;\n\t\telse {\n\t\t\tif (i + 1 < len) {\n\t\t\t\tND_TCHECK(bp[i + 1]);\n\t\t\t\toptlen = bp[i + 1] + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto trunc;\n\t\t}\n\t\tif (i + optlen > len)\n\t\t\tgoto trunc;\n\t\tND_TCHECK(bp[i + optlen]);\n\n\t\tswitch (bp[i]) {\n\t\tcase IP6MOPT_PAD1:\n\t\t\tND_PRINT((ndo, \"(pad1)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_PADN:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(padn: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(padn)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_REFRESH:\n\t\t\tif (len - i < IP6MOPT_REFRESH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(refresh: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\t/* units of 4 secs */\n\t\t\tND_TCHECK_16BITS(&bp[i+2]);\n\t\t\tND_PRINT((ndo, \"(refresh: %u)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]) << 2));\n\t\t\tbreak;\n\t\tcase IP6MOPT_ALTCOA:\n\t\t\tif (len - i < IP6MOPT_ALTCOA_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(altcoa: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(alt-CoA: %s)\", ip6addr_string(ndo, &bp[i+2])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_NONCEID:\n\t\t\tif (len - i < IP6MOPT_NONCEID_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(ni: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n",
        "suffix": "\t\t\t\tEXTRACT_16BITS(&bp[i+2]),\n\t\t\t\tEXTRACT_16BITS(&bp[i+4])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_AUTH:\n\t\t\tif (len - i < IP6MOPT_AUTH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(auth: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(auth)\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(sopt_type %u: trunc)\", bp[i]));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(type-0x%02x: len=%u)\", bp[i], bp[i + 1]));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n\ntrunc:\n\treturn 1;\n}\n",
        "start": 114,
        "end": 193,
        "buggy": "static int\nmobility_opt_print(netdissect_options *ndo,\n                   const u_char *bp, const unsigned len)\n{\n\tunsigned i, optlen;\n\n\tfor (i = 0; i < len; i += optlen) {\n\t\tND_TCHECK(bp[i]);\n\t\tif (bp[i] == IP6MOPT_PAD1)\n\t\t\toptlen = 1;\n\t\telse {\n\t\t\tif (i + 1 < len) {\n\t\t\t\tND_TCHECK(bp[i + 1]);\n\t\t\t\toptlen = bp[i + 1] + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto trunc;\n\t\t}\n\t\tif (i + optlen > len)\n\t\t\tgoto trunc;\n\t\tND_TCHECK(bp[i + optlen]);\n\n\t\tswitch (bp[i]) {\n\t\tcase IP6MOPT_PAD1:\n\t\t\tND_PRINT((ndo, \"(pad1)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_PADN:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(padn: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(padn)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_REFRESH:\n\t\t\tif (len - i < IP6MOPT_REFRESH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(refresh: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\t/* units of 4 secs */\n\t\t\tND_TCHECK_16BITS(&bp[i+2]);\n\t\t\tND_PRINT((ndo, \"(refresh: %u)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]) << 2));\n\t\t\tbreak;\n\t\tcase IP6MOPT_ALTCOA:\n\t\t\tif (len - i < IP6MOPT_ALTCOA_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(altcoa: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(alt-CoA: %s)\", ip6addr_string(ndo, &bp[i+2])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_NONCEID:\n\t\t\tif (len - i < IP6MOPT_NONCEID_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(ni: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(ni: ho=0x%04x co=0x%04x)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]),\n\t\t\t\tEXTRACT_16BITS(&bp[i+4])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_AUTH:\n\t\t\tif (len - i < IP6MOPT_AUTH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(auth: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(auth)\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(sopt_type %u: trunc)\", bp[i]));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(type-0x%02x: len=%u)\", bp[i], bp[i + 1]));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n\ntrunc:\n\treturn 1;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tND_PRINT((ndo, \"(ni: ho=0x%04x co=0x%04x)\",\n",
        "src_path": "7d3aba9f06899d0128ef46e8a2fa143c6fad8f62___print-mobility.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/7d3aba9f06899d0128ef46e8a2fa143c6fad8f62",
        "commit_msg": "CVE-2017-13024/IPv6 mobility: Add a bounds check before fetching data\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't cause 'tcpdump: pcap_loop: truncated dump file'",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -525,6 +525,7 @@ vtp_asan\t\tvtp_asan.pcap\t\t\tvtp_asan.out\t-v\n icmp6_mobileprefix_asan\ticmp6_mobileprefix_asan.pcap\ticmp6_mobileprefix_asan.out\t-v\n ip_printroute_asan\tip_printroute_asan.pcap\t\tip_printroute_asan.out\t-v\n mobility_opt_asan\tmobility_opt_asan.pcap\t\tmobility_opt_asan.out\t-v\n+mobility_opt_asan_2\tmobility_opt_asan_2.pcap\tmobility_opt_asan_2.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/mobility_opt_asan_2.out",
                "patch": "@@ -0,0 +1 @@\n+IP6 (class 0x50, flowlabel 0x0002c, hlim 0, next-header Mobile IP (old) (62) payload length: 7168) ff:7f0f:40:0:ee00:0:b658:5203 > 205:20:1:b00:0:2200:af01:e000: mobility: BRR(type-0x06: len=0)[|MOBILITY]"
            }
        ],
        "error_msg": "    mobility_opt_asan_2                : TEST FAILED(exit 256)\n"
    },
    "29e5470e6ab84badbc31f4532bb7554a796d9d52___print-bootp.c": {
        "prefix": "void\nbootp_print(netdissect_options *ndo,\n\t    register const u_char *cp, u_int length)\n{\n\tregister const struct bootp *bp;\n\tstatic const u_char vm_cmu[4] = VM_CMU;\n\tstatic const u_char vm_rfc1048[4] = VM_RFC1048;\n\n\tbp = (const struct bootp *)cp;\n\tND_TCHECK(bp->bp_op);\n\n\tND_PRINT((ndo, \"BOOTP/DHCP, %s\",\n\t\t  tok2str(bootp_op_values, \"unknown (0x%02x)\", bp->bp_op)));\n\n\tND_TCHECK(bp->bp_hlen);\n\tif (bp->bp_htype == 1 && bp->bp_hlen == 6 && bp->bp_op == BOOTPREQUEST) {\n\t\tND_TCHECK2(bp->bp_chaddr[0], 6);\n\t\tND_PRINT((ndo, \" from %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n\t}\n\n\tND_PRINT((ndo, \", length %u\", length));\n\n\tif (!ndo->ndo_vflag)\n\t\treturn;\n\n\tND_TCHECK(bp->bp_secs);\n\n\t/* The usual hardware address type is 1 (10Mb Ethernet) */\n\tif (bp->bp_htype != 1)\n\t\tND_PRINT((ndo, \", htype %d\", bp->bp_htype));\n\n\t/* The usual length for 10Mb Ethernet address is 6 bytes */\n\tif (bp->bp_htype != 1 || bp->bp_hlen != 6)\n\t\tND_PRINT((ndo, \", hlen %d\", bp->bp_hlen));\n\n\t/* Only print interesting fields */\n\tif (bp->bp_hops)\n\t\tND_PRINT((ndo, \", hops %d\", bp->bp_hops));\n\tif (EXTRACT_32BITS(&bp->bp_xid))\n\t\tND_PRINT((ndo, \", xid 0x%x\", EXTRACT_32BITS(&bp->bp_xid)));\n\tif (EXTRACT_16BITS(&bp->bp_secs))\n\t\tND_PRINT((ndo, \", secs %d\", EXTRACT_16BITS(&bp->bp_secs)));\n\n",
        "suffix": "\t\t  bittok2str(bootp_flag_values, \"none\", EXTRACT_16BITS(&bp->bp_flags))));\n\tif (ndo->ndo_vflag > 1)\n\t\tND_PRINT((ndo, \" (0x%04x)\", EXTRACT_16BITS(&bp->bp_flags)));\n\n\t/* Client's ip address */\n\tND_TCHECK(bp->bp_ciaddr);\n\tif (EXTRACT_32BITS(&bp->bp_ciaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Client-IP %s\", ipaddr_string(ndo, &bp->bp_ciaddr)));\n\n\t/* 'your' ip address (bootp client) */\n\tND_TCHECK(bp->bp_yiaddr);\n\tif (EXTRACT_32BITS(&bp->bp_yiaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Your-IP %s\", ipaddr_string(ndo, &bp->bp_yiaddr)));\n\n\t/* Server's ip address */\n\tND_TCHECK(bp->bp_siaddr);\n\tif (EXTRACT_32BITS(&bp->bp_siaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Server-IP %s\", ipaddr_string(ndo, &bp->bp_siaddr)));\n\n\t/* Gateway's ip address */\n\tND_TCHECK(bp->bp_giaddr);\n\tif (EXTRACT_32BITS(&bp->bp_giaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Gateway-IP %s\", ipaddr_string(ndo, &bp->bp_giaddr)));\n\n\t/* Client's Ethernet address */\n\tif (bp->bp_htype == 1 && bp->bp_hlen == 6) {\n\t\tND_TCHECK2(bp->bp_chaddr[0], 6);\n\t\tND_PRINT((ndo, \"\\n\\t  Client-Ethernet-Address %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n\t}\n\n\tND_TCHECK2(bp->bp_sname[0], 1);\t\t/* check first char only */\n\tif (*bp->bp_sname) {\n\t\tND_PRINT((ndo, \"\\n\\t  sname \\\"\"));\n\t\tif (fn_printztn(ndo, bp->bp_sname, (u_int)sizeof bp->bp_sname,\n\t\t    ndo->ndo_snapend)) {\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tND_PRINT((ndo, \"%s\", tstr + 1));\n\t\t\treturn;\n\t\t}\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\tND_TCHECK2(bp->bp_file[0], 1);\t\t/* check first char only */\n\tif (*bp->bp_file) {\n\t\tND_PRINT((ndo, \"\\n\\t  file \\\"\"));\n\t\tif (fn_printztn(ndo, bp->bp_file, (u_int)sizeof bp->bp_file,\n\t\t    ndo->ndo_snapend)) {\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tND_PRINT((ndo, \"%s\", tstr + 1));\n\t\t\treturn;\n\t\t}\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\n\t/* Decode the vendor buffer */\n\tND_TCHECK(bp->bp_vend[0]);\n\tif (memcmp((const char *)bp->bp_vend, vm_rfc1048,\n\t\t    sizeof(uint32_t)) == 0)\n\t\trfc1048_print(ndo, bp->bp_vend);\n\telse if (memcmp((const char *)bp->bp_vend, vm_cmu,\n\t\t\tsizeof(uint32_t)) == 0)\n\t\tcmu_print(ndo, bp->bp_vend);\n\telse {\n\t\tuint32_t ul;\n\n\t\tul = EXTRACT_32BITS(&bp->bp_vend);\n\t\tif (ul != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  Vendor-#0x%x\", ul));\n\t}\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n",
        "start": 282,
        "end": 398,
        "buggy": "void\nbootp_print(netdissect_options *ndo,\n\t    register const u_char *cp, u_int length)\n{\n\tregister const struct bootp *bp;\n\tstatic const u_char vm_cmu[4] = VM_CMU;\n\tstatic const u_char vm_rfc1048[4] = VM_RFC1048;\n\n\tbp = (const struct bootp *)cp;\n\tND_TCHECK(bp->bp_op);\n\n\tND_PRINT((ndo, \"BOOTP/DHCP, %s\",\n\t\t  tok2str(bootp_op_values, \"unknown (0x%02x)\", bp->bp_op)));\n\n\tND_TCHECK(bp->bp_hlen);\n\tif (bp->bp_htype == 1 && bp->bp_hlen == 6 && bp->bp_op == BOOTPREQUEST) {\n\t\tND_TCHECK2(bp->bp_chaddr[0], 6);\n\t\tND_PRINT((ndo, \" from %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n\t}\n\n\tND_PRINT((ndo, \", length %u\", length));\n\n\tif (!ndo->ndo_vflag)\n\t\treturn;\n\n\tND_TCHECK(bp->bp_secs);\n\n\t/* The usual hardware address type is 1 (10Mb Ethernet) */\n\tif (bp->bp_htype != 1)\n\t\tND_PRINT((ndo, \", htype %d\", bp->bp_htype));\n\n\t/* The usual length for 10Mb Ethernet address is 6 bytes */\n\tif (bp->bp_htype != 1 || bp->bp_hlen != 6)\n\t\tND_PRINT((ndo, \", hlen %d\", bp->bp_hlen));\n\n\t/* Only print interesting fields */\n\tif (bp->bp_hops)\n\t\tND_PRINT((ndo, \", hops %d\", bp->bp_hops));\n\tif (EXTRACT_32BITS(&bp->bp_xid))\n\t\tND_PRINT((ndo, \", xid 0x%x\", EXTRACT_32BITS(&bp->bp_xid)));\n\tif (EXTRACT_16BITS(&bp->bp_secs))\n\t\tND_PRINT((ndo, \", secs %d\", EXTRACT_16BITS(&bp->bp_secs)));\n\n\tND_PRINT((ndo, \", Flags [%s]\",\n\t\t  bittok2str(bootp_flag_values, \"none\", EXTRACT_16BITS(&bp->bp_flags))));\n\tif (ndo->ndo_vflag > 1)\n\t\tND_PRINT((ndo, \" (0x%04x)\", EXTRACT_16BITS(&bp->bp_flags)));\n\n\t/* Client's ip address */\n\tND_TCHECK(bp->bp_ciaddr);\n\tif (EXTRACT_32BITS(&bp->bp_ciaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Client-IP %s\", ipaddr_string(ndo, &bp->bp_ciaddr)));\n\n\t/* 'your' ip address (bootp client) */\n\tND_TCHECK(bp->bp_yiaddr);\n\tif (EXTRACT_32BITS(&bp->bp_yiaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Your-IP %s\", ipaddr_string(ndo, &bp->bp_yiaddr)));\n\n\t/* Server's ip address */\n\tND_TCHECK(bp->bp_siaddr);\n\tif (EXTRACT_32BITS(&bp->bp_siaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Server-IP %s\", ipaddr_string(ndo, &bp->bp_siaddr)));\n\n\t/* Gateway's ip address */\n\tND_TCHECK(bp->bp_giaddr);\n\tif (EXTRACT_32BITS(&bp->bp_giaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Gateway-IP %s\", ipaddr_string(ndo, &bp->bp_giaddr)));\n\n\t/* Client's Ethernet address */\n\tif (bp->bp_htype == 1 && bp->bp_hlen == 6) {\n\t\tND_TCHECK2(bp->bp_chaddr[0], 6);\n\t\tND_PRINT((ndo, \"\\n\\t  Client-Ethernet-Address %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n\t}\n\n\tND_TCHECK2(bp->bp_sname[0], 1);\t\t/* check first char only */\n\tif (*bp->bp_sname) {\n\t\tND_PRINT((ndo, \"\\n\\t  sname \\\"\"));\n\t\tif (fn_printztn(ndo, bp->bp_sname, (u_int)sizeof bp->bp_sname,\n\t\t    ndo->ndo_snapend)) {\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tND_PRINT((ndo, \"%s\", tstr + 1));\n\t\t\treturn;\n\t\t}\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\tND_TCHECK2(bp->bp_file[0], 1);\t\t/* check first char only */\n\tif (*bp->bp_file) {\n\t\tND_PRINT((ndo, \"\\n\\t  file \\\"\"));\n\t\tif (fn_printztn(ndo, bp->bp_file, (u_int)sizeof bp->bp_file,\n\t\t    ndo->ndo_snapend)) {\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tND_PRINT((ndo, \"%s\", tstr + 1));\n\t\t\treturn;\n\t\t}\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\n\t/* Decode the vendor buffer */\n\tND_TCHECK(bp->bp_vend[0]);\n\tif (memcmp((const char *)bp->bp_vend, vm_rfc1048,\n\t\t    sizeof(uint32_t)) == 0)\n\t\trfc1048_print(ndo, bp->bp_vend);\n\telse if (memcmp((const char *)bp->bp_vend, vm_cmu,\n\t\t\tsizeof(uint32_t)) == 0)\n\t\tcmu_print(ndo, bp->bp_vend);\n\telse {\n\t\tuint32_t ul;\n\n\t\tul = EXTRACT_32BITS(&bp->bp_vend);\n\t\tif (ul != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  Vendor-#0x%x\", ul));\n\t}\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\tND_PRINT((ndo, \", Flags [%s]\",\n",
        "src_path": "29e5470e6ab84badbc31f4532bb7554a796d9d52___print-bootp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/29e5470e6ab84badbc31f4532bb7554a796d9d52",
        "commit_msg": "CVE-2017-13028/BOOTP: Add a bounds check before fetching data\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't cause 'tcpdump: pcap_loop: truncated dump file'",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -533,6 +533,7 @@ isis_stlv_asan-2\tisis_stlv_asan-2.pcap\t\tisis_stlv_asan-2.out\t-v\n isis_stlv_asan-3\tisis_stlv_asan-3.pcap\t\tisis_stlv_asan-3.out\t-v\n isis_stlv_asan-4\tisis_stlv_asan-4.pcap\t\tisis_stlv_asan-4.out\t-v\n lldp_mgmt_addr_tlv_asan\tlldp_mgmt_addr_tlv_asan.pcap\tlldp_mgmt_addr_tlv_asan.out\t-v\n+bootp_asan\t\tbootp_asan.pcap\t\t\tbootp_asan.out\t\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/bootp_asan.out",
                "patch": "@@ -0,0 +1,2 @@\n+IP (tos 0x0, ttl 252, id 40207, offset 0, flags [+, DF, rsvd], proto UDP (17), length 60951, bad cksum ff (->8336)!)\n+    18.0.0.15.16896 > 107.95.83.32.68: BOOTP/DHCP, unknown (0x00), length 59384, htype 0, hlen 0, hops 13, xid 0x14000000, secs 3328 [|bootp]"
            }
        ],
        "error_msg": "    bootp_asan                         : TEST FAILED(exit 256)\n"
    },
    "88b2dac837e81cf56dce05e6e7b5989332c0092d___print-ospf6.c": {
        "prefix": "static int\nospf6_decode_v3(netdissect_options *ndo,\n                register const struct ospf6hdr *op,\n                register const u_char *dataend)\n{\n\tregister const rtrid_t *ap;\n\tregister const struct lsr6 *lsrp;\n\tregister const struct lsa6_hdr *lshp;\n\tregister const struct lsa6 *lsap;\n\tregister int i;\n\n\tswitch (op->ospf6_type) {\n\n\tcase OSPF_TYPE_HELLO: {\n\t\tregister const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n",
        "suffix": "\t\t          bittok2str(ospf6_option_values, \"none\",\n\t\t          EXTRACT_32BITS(&hellop->hello_options))));\n\n\t\tND_TCHECK(hellop->hello_deadint);\n\t\tND_PRINT((ndo, \"\\n\\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u\",\n\t\t          EXTRACT_16BITS(&hellop->hello_helloint),\n\t\t          EXTRACT_16BITS(&hellop->hello_deadint),\n\t\t          ipaddr_string(ndo, &hellop->hello_ifid),\n\t\t          hellop->hello_priority));\n\n\t\tND_TCHECK(hellop->hello_dr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_dr) != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_dr)));\n\t\tND_TCHECK(hellop->hello_bdr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_bdr) != 0)\n\t\t\tND_PRINT((ndo, \", Backup Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_bdr)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  Neighbor List:\"));\n\t\t\tap = hellop->hello_neighbor;\n\t\t\twhile ((const u_char *)ap < dataend) {\n\t\t\t\tND_TCHECK(*ap);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t    %s\", ipaddr_string(ndo, ap)));\n\t\t\t\t++ap;\n\t\t\t}\n\t\t}\n\t\tbreak;\t/* HELLO */\n\t}\n\n\tcase OSPF_TYPE_DD: {\n\t\tregister const struct dd6 *ddp = (const struct dd6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\tND_TCHECK(ddp->db_options);\n\t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n\t\t          bittok2str(ospf6_option_values, \"none\",\n\t\t          EXTRACT_32BITS(&ddp->db_options))));\n\t\tND_TCHECK(ddp->db_flags);\n\t\tND_PRINT((ndo, \", DD Flags [%s]\",\n\t\t          bittok2str(ospf6_dd_flag_values,\"none\",ddp->db_flags)));\n\n\t\tND_TCHECK(ddp->db_seq);\n\t\tND_PRINT((ndo, \", MTU %u, DD-Sequence 0x%08x\",\n                       EXTRACT_16BITS(&ddp->db_mtu),\n                       EXTRACT_32BITS(&ddp->db_seq)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\t/* Print all the LS adv's */\n\t\t\tlshp = ddp->db_lshdr;\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase OSPF_TYPE_LS_REQ:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlsrp = (const struct lsr6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lsrp < dataend) {\n\t\t\t\tND_TCHECK(*lsrp);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s\",\n\t\t\t\t          ipaddr_string(ndo, &lsrp->ls_router)));\n\t\t\t\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lsrp->ls_type),\n                                                    &lsrp->ls_stateid);\n\t\t\t\t++lsrp;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_UPDATE:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tregister const struct lsu6 *lsup = (const struct lsu6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\t\tND_TCHECK(lsup->lsu_count);\n\t\t\ti = EXTRACT_32BITS(&lsup->lsu_count);\n\t\t\tlsap = lsup->lsu_lsa;\n\t\t\twhile ((const u_char *)lsap < dataend && i--) {\n\t\t\t\tif (ospf6_print_lsa(ndo, lsap, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tlsap = (const struct lsa6 *)((const u_char *)lsap +\n\t\t\t\t    EXTRACT_16BITS(&lsap->ls_hdr.ls_length));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_ACK:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlshp = (const struct lsa6_hdr *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn (0);\ntrunc:\n\treturn (1);\n}\n",
        "start": 722,
        "end": 841,
        "buggy": "static int\nospf6_decode_v3(netdissect_options *ndo,\n                register const struct ospf6hdr *op,\n                register const u_char *dataend)\n{\n\tregister const rtrid_t *ap;\n\tregister const struct lsr6 *lsrp;\n\tregister const struct lsa6_hdr *lshp;\n\tregister const struct lsa6 *lsap;\n\tregister int i;\n\n\tswitch (op->ospf6_type) {\n\n\tcase OSPF_TYPE_HELLO: {\n\t\tregister const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n\t\t          bittok2str(ospf6_option_values, \"none\",\n\t\t          EXTRACT_32BITS(&hellop->hello_options))));\n\n\t\tND_TCHECK(hellop->hello_deadint);\n\t\tND_PRINT((ndo, \"\\n\\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u\",\n\t\t          EXTRACT_16BITS(&hellop->hello_helloint),\n\t\t          EXTRACT_16BITS(&hellop->hello_deadint),\n\t\t          ipaddr_string(ndo, &hellop->hello_ifid),\n\t\t          hellop->hello_priority));\n\n\t\tND_TCHECK(hellop->hello_dr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_dr) != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_dr)));\n\t\tND_TCHECK(hellop->hello_bdr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_bdr) != 0)\n\t\t\tND_PRINT((ndo, \", Backup Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_bdr)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  Neighbor List:\"));\n\t\t\tap = hellop->hello_neighbor;\n\t\t\twhile ((const u_char *)ap < dataend) {\n\t\t\t\tND_TCHECK(*ap);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t    %s\", ipaddr_string(ndo, ap)));\n\t\t\t\t++ap;\n\t\t\t}\n\t\t}\n\t\tbreak;\t/* HELLO */\n\t}\n\n\tcase OSPF_TYPE_DD: {\n\t\tregister const struct dd6 *ddp = (const struct dd6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\tND_TCHECK(ddp->db_options);\n\t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n\t\t          bittok2str(ospf6_option_values, \"none\",\n\t\t          EXTRACT_32BITS(&ddp->db_options))));\n\t\tND_TCHECK(ddp->db_flags);\n\t\tND_PRINT((ndo, \", DD Flags [%s]\",\n\t\t          bittok2str(ospf6_dd_flag_values,\"none\",ddp->db_flags)));\n\n\t\tND_TCHECK(ddp->db_seq);\n\t\tND_PRINT((ndo, \", MTU %u, DD-Sequence 0x%08x\",\n                       EXTRACT_16BITS(&ddp->db_mtu),\n                       EXTRACT_32BITS(&ddp->db_seq)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\t/* Print all the LS adv's */\n\t\t\tlshp = ddp->db_lshdr;\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase OSPF_TYPE_LS_REQ:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlsrp = (const struct lsr6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lsrp < dataend) {\n\t\t\t\tND_TCHECK(*lsrp);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s\",\n\t\t\t\t          ipaddr_string(ndo, &lsrp->ls_router)));\n\t\t\t\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lsrp->ls_type),\n                                                    &lsrp->ls_stateid);\n\t\t\t\t++lsrp;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_UPDATE:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tregister const struct lsu6 *lsup = (const struct lsu6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\t\tND_TCHECK(lsup->lsu_count);\n\t\t\ti = EXTRACT_32BITS(&lsup->lsu_count);\n\t\t\tlsap = lsup->lsu_lsa;\n\t\t\twhile ((const u_char *)lsap < dataend && i--) {\n\t\t\t\tif (ospf6_print_lsa(ndo, lsap, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tlsap = (const struct lsa6 *)((const u_char *)lsap +\n\t\t\t\t    EXTRACT_16BITS(&lsap->ls_hdr.ls_length));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_ACK:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlshp = (const struct lsa6_hdr *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn (0);\ntrunc:\n\treturn (1);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n",
        "src_path": "88b2dac837e81cf56dce05e6e7b5989332c0092d___print-ospf6.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/88b2dac837e81cf56dce05e6e7b5989332c0092d",
        "commit_msg": "CVE-2017-13036/OSPFv3: Add a bounds check before fetching data\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -549,6 +549,7 @@ pim_header_asan-2\tpim_header_asan-2.pcap\t\tpim_header_asan-2.out\t-v\n pim_header_asan-3\tpim_header_asan-3.pcap\t\tpim_header_asan-3.out\t-v\n ip6_frag_asan\t\tip6_frag_asan.pcap\t\tip6_frag_asan.out\t-v\n radius_attr_asan\tradius_attr_asan.pcap\t\tradius_attr_asan.out\t-v\n+ospf6_decode_v3_asan\tospf6_decode_v3_asan.pcap\tospf6_decode_v3_asan.out -v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/ospf6_decode_v3_asan.out",
                "patch": "@@ -0,0 +1,2 @@\n+IP6 (class 0x76, flowlabel 0xf6701, hlim 109, next-header OSPF (89) payload length: 30311) 6767:6780:6767:a102:4:b6:5853:f040 > 1000:a32:8847:1::116: OSPFv3, Hello, length 30311\n+\tRouter-ID 1.1.0.34, Area 0.255.2.2, Instance 82 [|ospf3]"
            }
        ],
        "error_msg": "    ospf6_decode_v3_asan               : TEST FAILED(exit 256)\n"
    },
    "7335163a6ef82d46ff18f3e6099a157747241629___print-ppp.c": {
        "prefix": "static void\nhandle_mlppp(netdissect_options *ndo,\n             const u_char *p, int length)\n{\n    if (!ndo->ndo_eflag)\n        ND_PRINT((ndo, \"MLPPP, \"));\n\n",
        "suffix": "           (EXTRACT_16BITS(p))&0x0fff, /* only support 12-Bit sequence space for now */\n           bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0),\n           length));\n}\n",
        "start": 807,
        "end": 818,
        "buggy": "static void\nhandle_mlppp(netdissect_options *ndo,\n             const u_char *p, int length)\n{\n    if (!ndo->ndo_eflag)\n        ND_PRINT((ndo, \"MLPPP, \"));\n\n    ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\",\n           (EXTRACT_16BITS(p))&0x0fff, /* only support 12-Bit sequence space for now */\n           bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0),\n           length));\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\",\n",
        "src_path": "7335163a6ef82d46ff18f3e6099a157747241629___print-ppp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/7335163a6ef82d46ff18f3e6099a157747241629",
        "commit_msg": "CVE-2017-13038/PPP: Do bounds checking.\n\nThis fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.\n\nAdd a test using the capture file supplied by Katie Holly.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -554,6 +554,9 @@ radius_attr_asan\tradius_attr_asan.pcap\t\tradius_attr_asan.out\t-v\n ospf6_decode_v3_asan\tospf6_decode_v3_asan.pcap\tospf6_decode_v3_asan.out -v\n ip_ts_opts_asan\t\tip_ts_opts_asan.pcap\t\tip_ts_opts_asan.out\t-v\n \n+# bad packets from Katie Holly\n+mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out\n+\n # RTP tests\n # fuzzed pcap\n rtp-seg-fault-1  rtp-seg-fault-1.pcap  rtp-seg-fault-1.out  -v -T rtp"
            },
            {
                "fn": "tests/mlppp-oobr.out",
                "patch": "@@ -0,0 +1 @@\n+MLPPP, [|mlppp]"
            }
        ],
        "error_msg": "    mlppp-oobr                         : TEST FAILED(exit 256)\n"
    },
    "aa0858100096a3490edf93034a80e66a4d61aad5___print-rx.c": {
        "prefix": "static void\nubik_print(netdissect_options *ndo,\n           register const u_char *bp)\n{\n\tint ubik_op;\n\tint32_t temp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from ubik/ubik_int.xg\n\t */\n\n\tubik_op = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n\n\tND_PRINT((ndo, \" ubik call %s\", tok2str(ubik_req, \"op#%d\", ubik_op)));\n\n\t/*\n\t * Decode some of the arguments to the Ubik calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (ubik_op) {\n\t\tcase 10000:\t\t/* Beacon */\n\t\t\tND_TCHECK2(bp[0], 4);\n\t\t\ttemp = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\t\t\tND_PRINT((ndo, \" syncsite %s\", temp ? \"yes\" : \"no\"));\n\t\t\tND_PRINT((ndo, \" votestart\"));\n\t\t\tDATEOUT();\n\t\t\tND_PRINT((ndo, \" dbversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 10003:\t\t/* Get sync site */\n\t\t\tND_PRINT((ndo, \" site\"));\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 20000:\t\t/* Begin */\n\t\tcase 20001:\t\t/* Commit */\n\t\tcase 20007:\t\t/* Abort */\n\t\tcase 20008:\t\t/* Release locks */\n\t\tcase 20010:\t\t/* Writev */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20002:\t\t/* Lock */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" pos\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n",
        "suffix": "\t\t\tbp += sizeof(int32_t);\n\t\t\ttok2str(ubik_lock_types, \"type %d\", temp);\n\t\t\tbreak;\n\t\tcase 20003:\t\t/* Write */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" pos\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20005:\t\t/* Get file */\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20006:\t\t/* Send file */\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" dbversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20009:\t\t/* Truncate */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20012:\t\t/* Set version */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" oldversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" newversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|ubik]\"));\n}\n",
        "start": 2524,
        "end": 2628,
        "buggy": "static void\nubik_print(netdissect_options *ndo,\n           register const u_char *bp)\n{\n\tint ubik_op;\n\tint32_t temp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from ubik/ubik_int.xg\n\t */\n\n\tubik_op = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n\n\tND_PRINT((ndo, \" ubik call %s\", tok2str(ubik_req, \"op#%d\", ubik_op)));\n\n\t/*\n\t * Decode some of the arguments to the Ubik calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (ubik_op) {\n\t\tcase 10000:\t\t/* Beacon */\n\t\t\tND_TCHECK2(bp[0], 4);\n\t\t\ttemp = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\t\t\tND_PRINT((ndo, \" syncsite %s\", temp ? \"yes\" : \"no\"));\n\t\t\tND_PRINT((ndo, \" votestart\"));\n\t\t\tDATEOUT();\n\t\t\tND_PRINT((ndo, \" dbversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 10003:\t\t/* Get sync site */\n\t\t\tND_PRINT((ndo, \" site\"));\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 20000:\t\t/* Begin */\n\t\tcase 20001:\t\t/* Commit */\n\t\tcase 20007:\t\t/* Abort */\n\t\tcase 20008:\t\t/* Release locks */\n\t\tcase 20010:\t\t/* Writev */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20002:\t\t/* Lock */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" pos\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\t\t\ttemp = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\t\t\ttok2str(ubik_lock_types, \"type %d\", temp);\n\t\t\tbreak;\n\t\tcase 20003:\t\t/* Write */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" pos\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20005:\t\t/* Get file */\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20006:\t\t/* Send file */\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" dbversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20009:\t\t/* Truncate */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20012:\t\t/* Set version */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" oldversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" newversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|ubik]\"));\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\ttemp = EXTRACT_32BITS(bp);\n",
        "src_path": "aa0858100096a3490edf93034a80e66a4d61aad5___print-rx.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/aa0858100096a3490edf93034a80e66a4d61aad5",
        "commit_msg": "CVE-2017-13049/Rx: add a missing bounds check for Ubik\n\nOne of the case blocks in ubik_print() didn't check bounds before\nfetching 32 bits of packet data and could overread past the captured\npacket data by that amount.\n\nThis fixes a buffer over-read discovered by Henri Salo from Nixu\nCorporation.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -573,6 +573,9 @@ mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out\n mptcp-dss-oobr\t\tmptcp-dss-oobr.pcap\t\tmptcp-dss-oobr.out\t-v\n icmp6_nodeinfo_oobr\ticmp6_nodeinfo_oobr.pcap\ticmp6_nodeinfo_oobr.out\n \n+# bad packets from Henri Salo\n+rx_ubik-oobr\t\trx_ubik-oobr.pcap\t\trx_ubik-oobr.out -c1\n+\n # RTP tests\n # fuzzed pcap\n rtp-seg-fault-1  rtp-seg-fault-1.pcap  rtp-seg-fault-1.out  -v -T rtp"
            },
            {
                "fn": "tests/rx_ubik-oobr.out",
                "patch": "@@ -0,0 +1 @@\n+IP truncated-ip - 2598 bytes missing! 222.241.104.198.3503 > 131.63.241.146.7002:  rx data pt ubik call disk-lock tid 50266112.32382 file 2122216448 pos 545160708 length 1087685554 [|ubik] (2632)"
            }
        ],
        "error_msg": "    rx_ubik-oobr                       : TEST FAILED(exit 256)\n"
    },
    "e6511cc1a950fe1566b2236329d6b4bd0826cc7a___print-lldp.c": {
        "prefix": "static int\nlldp_private_8023_print(netdissect_options *ndo,\n                        const u_char *tptr, u_int tlv_len)\n{\n    int subtype, hexdump = FALSE;\n\n    if (tlv_len < 4) {\n        return hexdump;\n    }\n    subtype = *(tptr+3);\n\n    ND_PRINT((ndo, \"\\n\\t  %s Subtype (%u)\",\n           tok2str(lldp_8023_subtype_values, \"unknown\", subtype),\n           subtype));\n\n    switch (subtype) {\n    case LLDP_PRIVATE_8023_SUBTYPE_MACPHY:\n        if (tlv_len < 9) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    autonegotiation [%s] (0x%02x)\",\n               bittok2str(lldp_8023_autonegotiation_values, \"none\", *(tptr+4)),\n               *(tptr + 4)));\n        ND_PRINT((ndo, \"\\n\\t    PMD autoneg capability [%s] (0x%04x)\",\n               bittok2str(lldp_pmd_capability_values,\"unknown\", EXTRACT_16BITS(tptr+5)),\n               EXTRACT_16BITS(tptr + 5)));\n        ND_PRINT((ndo, \"\\n\\t    MAU type %s (0x%04x)\",\n               tok2str(lldp_mau_types_values, \"unknown\", EXTRACT_16BITS(tptr+7)),\n               EXTRACT_16BITS(tptr + 7)));\n        break;\n\n    case LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER:\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    MDI power support [%s], power pair %s, power class %s\",\n               bittok2str(lldp_mdi_values, \"none\", *(tptr+4)),\n               tok2str(lldp_mdi_power_pairs_values, \"unknown\", *(tptr+5)),\n               tok2str(lldp_mdi_power_class_values, \"unknown\", *(tptr + 6))));\n        break;\n\n    case LLDP_PRIVATE_8023_SUBTYPE_LINKAGGR:\n        if (tlv_len < 9) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    aggregation status [%s], aggregation port ID %u\",\n               bittok2str(lldp_aggregation_values, \"none\", *(tptr+4)),\n               EXTRACT_32BITS(tptr + 5)));\n        break;\n\n    case LLDP_PRIVATE_8023_SUBTYPE_MTU:\n",
        "suffix": "        break;\n\n    default:\n        hexdump = TRUE;\n        break;\n    }\n\n    return hexdump;\n}\n",
        "start": 850,
        "end": 910,
        "buggy": "static int\nlldp_private_8023_print(netdissect_options *ndo,\n                        const u_char *tptr, u_int tlv_len)\n{\n    int subtype, hexdump = FALSE;\n\n    if (tlv_len < 4) {\n        return hexdump;\n    }\n    subtype = *(tptr+3);\n\n    ND_PRINT((ndo, \"\\n\\t  %s Subtype (%u)\",\n           tok2str(lldp_8023_subtype_values, \"unknown\", subtype),\n           subtype));\n\n    switch (subtype) {\n    case LLDP_PRIVATE_8023_SUBTYPE_MACPHY:\n        if (tlv_len < 9) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    autonegotiation [%s] (0x%02x)\",\n               bittok2str(lldp_8023_autonegotiation_values, \"none\", *(tptr+4)),\n               *(tptr + 4)));\n        ND_PRINT((ndo, \"\\n\\t    PMD autoneg capability [%s] (0x%04x)\",\n               bittok2str(lldp_pmd_capability_values,\"unknown\", EXTRACT_16BITS(tptr+5)),\n               EXTRACT_16BITS(tptr + 5)));\n        ND_PRINT((ndo, \"\\n\\t    MAU type %s (0x%04x)\",\n               tok2str(lldp_mau_types_values, \"unknown\", EXTRACT_16BITS(tptr+7)),\n               EXTRACT_16BITS(tptr + 7)));\n        break;\n\n    case LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER:\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    MDI power support [%s], power pair %s, power class %s\",\n               bittok2str(lldp_mdi_values, \"none\", *(tptr+4)),\n               tok2str(lldp_mdi_power_pairs_values, \"unknown\", *(tptr+5)),\n               tok2str(lldp_mdi_power_class_values, \"unknown\", *(tptr + 6))));\n        break;\n\n    case LLDP_PRIVATE_8023_SUBTYPE_LINKAGGR:\n        if (tlv_len < 9) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    aggregation status [%s], aggregation port ID %u\",\n               bittok2str(lldp_aggregation_values, \"none\", *(tptr+4)),\n               EXTRACT_32BITS(tptr + 5)));\n        break;\n\n    case LLDP_PRIVATE_8023_SUBTYPE_MTU:\n        ND_PRINT((ndo, \"\\n\\t    MTU size %u\", EXTRACT_16BITS(tptr + 4)));\n        break;\n\n    default:\n        hexdump = TRUE;\n        break;\n    }\n\n    return hexdump;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        ND_PRINT((ndo, \"\\n\\t    MTU size %u\", EXTRACT_16BITS(tptr + 4)));\n",
        "src_path": "e6511cc1a950fe1566b2236329d6b4bd0826cc7a___print-lldp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/e6511cc1a950fe1566b2236329d6b4bd0826cc7a",
        "commit_msg": "CVE-2017-13054/LLDP: add a missing length check\n\nIn lldp_private_8023_print() the case block for subtype 4 (Maximum Frame\nSize TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length\ncheck and could over-read the input buffer, put it right.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -571,6 +571,7 @@ rsvp_uni-oobr-1\trsvp_uni-oobr-1.pcap\trsvp_uni-oobr-1.out\t-v -c1\n rsvp_uni-oobr-2\trsvp_uni-oobr-2.pcap\trsvp_uni-oobr-2.out\t-v -c1\n rsvp_uni-oobr-3\trsvp_uni-oobr-3.pcap\trsvp_uni-oobr-3.out\t-v -c3\n rpki-rtr-oob\t\trpki-rtr-oob.pcap\trpki-rtr-oob.out\t-v -c1\n+lldp_8023_mtu-oobr\tlldp_8023_mtu-oobr.pcap\tlldp_8023_mtu-oobr.out\t-v -c1\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/lldp_8023_mtu-oobr.out",
                "patch": "@@ -0,0 +1,4 @@\n+LLDP, length 4293194266\n+\tOrganization specific TLV (127), length 4: OUI IEEE 802.3 Private (0x00120f)\n+\t  Max frame size Subtype (4)\n+\t[|LLDP]"
            }
        ],
        "error_msg": "    lldp_8023_mtu-oobr                 : TEST FAILED(exit 256)\n"
    },
    "061e7371a944588f231cb1b66d6fb070b646e376___print-isakmp.c": {
        "prefix": "static const u_char *\nikev1_id_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len,\n\t       const u_char *ep _U_, uint32_t phase, uint32_t doi _U_,\n\t       uint32_t proto _U_, int depth _U_)\n{\n#define USE_IPSECDOI_IN_PHASE1\t1\n\tconst struct ikev1_pl_id *p;\n\tstruct ikev1_pl_id id;\n\tstatic const char *idtypestr[] = {\n\t\t\"IPv4\", \"IPv4net\", \"IPv6\", \"IPv6net\",\n\t};\n\tstatic const char *ipsecidtypestr[] = {\n\t\tNULL, \"IPv4\", \"FQDN\", \"user FQDN\", \"IPv4net\", \"IPv6\",\n\t\t\"IPv6net\", \"IPv4range\", \"IPv6range\", \"ASN1 DN\", \"ASN1 GN\",\n\t\t\"keyid\",\n\t};\n\tint len;\n\tconst u_char *data;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_ID)));\n\n\tp = (const struct ikev1_pl_id *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&id, ext, sizeof(id));\n\tif (sizeof(*p) < item_len) {\n\t\tdata = (const u_char *)(p + 1);\n\t\tlen = item_len - sizeof(*p);\n\t} else {\n\t\tdata = NULL;\n\t\tlen = 0;\n\t}\n\n#if 0 /*debug*/\n\tND_PRINT((ndo,\" [phase=%d doi=%d proto=%d]\", phase, doi, proto));\n#endif\n\tswitch (phase) {\n#ifndef USE_IPSECDOI_IN_PHASE1\n\tcase 1:\n#endif\n\tdefault:\n\t\tND_PRINT((ndo,\" idtype=%s\", STR_OR_ID(id.d.id_type, idtypestr)));\n\t\tND_PRINT((ndo,\" doi_data=%u\",\n\t\t\t  (uint32_t)(ntohl(id.d.doi_data) & 0xffffff)));\n\t\tbreak;\n\n#ifdef USE_IPSECDOI_IN_PHASE1\n\tcase 1:\n#endif\n\tcase 2:\n\t    {\n\t\tconst struct ipsecdoi_id *doi_p;\n\t\tstruct ipsecdoi_id doi_id;\n\t\tconst char *p_name;\n\n\t\tdoi_p = (const struct ipsecdoi_id *)ext;\n\t\tND_TCHECK(*doi_p);\n\t\tUNALIGNED_MEMCPY(&doi_id, ext, sizeof(doi_id));\n\t\tND_PRINT((ndo,\" idtype=%s\", STR_OR_ID(doi_id.type, ipsecidtypestr)));\n\t\t/* A protocol ID of 0 DOES NOT mean IPPROTO_IP! */\n\t\tif (!ndo->ndo_nflag && doi_id.proto_id && (p_name = netdb_protoname(doi_id.proto_id)) != NULL)\n\t\t\tND_PRINT((ndo,\" protoid=%s\", p_name));\n\t\telse\n\t\t\tND_PRINT((ndo,\" protoid=%u\", doi_id.proto_id));\n\t\tND_PRINT((ndo,\" port=%d\", ntohs(doi_id.port)));\n\t\tif (!len)\n\t\t\tbreak;\n\t\tif (data == NULL)\n\t\t\tgoto trunc;\n\t\tND_TCHECK2(*data, len);\n\t\tswitch (doi_id.type) {\n\t\tcase IPSECDOI_ID_IPV4_ADDR:\n\t\t\tif (len < 4)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 4]\", len));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo,\" len=%d %s\", len, ipaddr_string(ndo, data)));\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_FQDN:\n\t\tcase IPSECDOI_ID_USER_FQDN:\n\t\t    {\n\t\t\tint i;\n\t\t\tND_PRINT((ndo,\" len=%d \", len));\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\tsafeputchar(ndo, data[i]);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_ID_IPV4_ADDR_SUBNET:\n\t\t    {\n\t\t\tconst u_char *mask;\n\t\t\tif (len < 8)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 8]\", len));\n\t\t\telse {\n\t\t\t\tmask = data + sizeof(struct in_addr);\n\t\t\t\tND_PRINT((ndo,\" len=%d %s/%u.%u.%u.%u\", len,\n\t\t\t\t\t  ipaddr_string(ndo, data),\n\t\t\t\t\t  mask[0], mask[1], mask[2], mask[3]));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_ID_IPV6_ADDR:\n\t\t\tif (len < 16)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 16]\", len));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo,\" len=%d %s\", len, ip6addr_string(ndo, data)));\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_IPV6_ADDR_SUBNET:\n\t\t    {\n\t\t\tconst u_char *mask;\n",
        "suffix": "\t\t\t\tmask = (const u_char *)(data + sizeof(struct in6_addr));\n\t\t\t\t/*XXX*/\n\t\t\t\tND_PRINT((ndo,\" len=%d %s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\", len,\n\t\t\t\t\t  ip6addr_string(ndo, data),\n\t\t\t\t\t  mask[0], mask[1], mask[2], mask[3],\n\t\t\t\t\t  mask[4], mask[5], mask[6], mask[7],\n\t\t\t\t\t  mask[8], mask[9], mask[10], mask[11],\n\t\t\t\t\t  mask[12], mask[13], mask[14], mask[15]));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_ID_IPV4_ADDR_RANGE:\n\t\t\tif (len < 8)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 8]\", len));\n\t\t\telse {\n\t\t\t\tND_PRINT((ndo,\" len=%d %s-%s\", len,\n\t\t\t\t\t  ipaddr_string(ndo, data),\n\t\t\t\t\t  ipaddr_string(ndo, data + sizeof(struct in_addr))));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_IPV6_ADDR_RANGE:\n\t\t\tif (len < 32)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 32]\", len));\n\t\t\telse {\n\t\t\t\tND_PRINT((ndo,\" len=%d %s-%s\", len,\n\t\t\t\t\t  ip6addr_string(ndo, data),\n\t\t\t\t\t  ip6addr_string(ndo, data + sizeof(struct in6_addr))));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_DER_ASN1_DN:\n\t\tcase IPSECDOI_ID_DER_ASN1_GN:\n\t\tcase IPSECDOI_ID_KEY_ID:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tif (data && len) {\n\t\tND_PRINT((ndo,\" len=%d\", len));\n\t\tif (2 < ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo,\" \"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)data, len))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_ID)));\n\treturn NULL;\n}\n",
        "start": 1326,
        "end": 1493,
        "buggy": "static const u_char *\nikev1_id_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len,\n\t       const u_char *ep _U_, uint32_t phase, uint32_t doi _U_,\n\t       uint32_t proto _U_, int depth _U_)\n{\n#define USE_IPSECDOI_IN_PHASE1\t1\n\tconst struct ikev1_pl_id *p;\n\tstruct ikev1_pl_id id;\n\tstatic const char *idtypestr[] = {\n\t\t\"IPv4\", \"IPv4net\", \"IPv6\", \"IPv6net\",\n\t};\n\tstatic const char *ipsecidtypestr[] = {\n\t\tNULL, \"IPv4\", \"FQDN\", \"user FQDN\", \"IPv4net\", \"IPv6\",\n\t\t\"IPv6net\", \"IPv4range\", \"IPv6range\", \"ASN1 DN\", \"ASN1 GN\",\n\t\t\"keyid\",\n\t};\n\tint len;\n\tconst u_char *data;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_ID)));\n\n\tp = (const struct ikev1_pl_id *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&id, ext, sizeof(id));\n\tif (sizeof(*p) < item_len) {\n\t\tdata = (const u_char *)(p + 1);\n\t\tlen = item_len - sizeof(*p);\n\t} else {\n\t\tdata = NULL;\n\t\tlen = 0;\n\t}\n\n#if 0 /*debug*/\n\tND_PRINT((ndo,\" [phase=%d doi=%d proto=%d]\", phase, doi, proto));\n#endif\n\tswitch (phase) {\n#ifndef USE_IPSECDOI_IN_PHASE1\n\tcase 1:\n#endif\n\tdefault:\n\t\tND_PRINT((ndo,\" idtype=%s\", STR_OR_ID(id.d.id_type, idtypestr)));\n\t\tND_PRINT((ndo,\" doi_data=%u\",\n\t\t\t  (uint32_t)(ntohl(id.d.doi_data) & 0xffffff)));\n\t\tbreak;\n\n#ifdef USE_IPSECDOI_IN_PHASE1\n\tcase 1:\n#endif\n\tcase 2:\n\t    {\n\t\tconst struct ipsecdoi_id *doi_p;\n\t\tstruct ipsecdoi_id doi_id;\n\t\tconst char *p_name;\n\n\t\tdoi_p = (const struct ipsecdoi_id *)ext;\n\t\tND_TCHECK(*doi_p);\n\t\tUNALIGNED_MEMCPY(&doi_id, ext, sizeof(doi_id));\n\t\tND_PRINT((ndo,\" idtype=%s\", STR_OR_ID(doi_id.type, ipsecidtypestr)));\n\t\t/* A protocol ID of 0 DOES NOT mean IPPROTO_IP! */\n\t\tif (!ndo->ndo_nflag && doi_id.proto_id && (p_name = netdb_protoname(doi_id.proto_id)) != NULL)\n\t\t\tND_PRINT((ndo,\" protoid=%s\", p_name));\n\t\telse\n\t\t\tND_PRINT((ndo,\" protoid=%u\", doi_id.proto_id));\n\t\tND_PRINT((ndo,\" port=%d\", ntohs(doi_id.port)));\n\t\tif (!len)\n\t\t\tbreak;\n\t\tif (data == NULL)\n\t\t\tgoto trunc;\n\t\tND_TCHECK2(*data, len);\n\t\tswitch (doi_id.type) {\n\t\tcase IPSECDOI_ID_IPV4_ADDR:\n\t\t\tif (len < 4)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 4]\", len));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo,\" len=%d %s\", len, ipaddr_string(ndo, data)));\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_FQDN:\n\t\tcase IPSECDOI_ID_USER_FQDN:\n\t\t    {\n\t\t\tint i;\n\t\t\tND_PRINT((ndo,\" len=%d \", len));\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\tsafeputchar(ndo, data[i]);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_ID_IPV4_ADDR_SUBNET:\n\t\t    {\n\t\t\tconst u_char *mask;\n\t\t\tif (len < 8)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 8]\", len));\n\t\t\telse {\n\t\t\t\tmask = data + sizeof(struct in_addr);\n\t\t\t\tND_PRINT((ndo,\" len=%d %s/%u.%u.%u.%u\", len,\n\t\t\t\t\t  ipaddr_string(ndo, data),\n\t\t\t\t\t  mask[0], mask[1], mask[2], mask[3]));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_ID_IPV6_ADDR:\n\t\t\tif (len < 16)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 16]\", len));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo,\" len=%d %s\", len, ip6addr_string(ndo, data)));\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_IPV6_ADDR_SUBNET:\n\t\t    {\n\t\t\tconst u_char *mask;\n\t\t\tif (len < 20)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 20]\", len));\n\t\t\telse {\n\t\t\t\tmask = (const u_char *)(data + sizeof(struct in6_addr));\n\t\t\t\t/*XXX*/\n\t\t\t\tND_PRINT((ndo,\" len=%d %s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\", len,\n\t\t\t\t\t  ip6addr_string(ndo, data),\n\t\t\t\t\t  mask[0], mask[1], mask[2], mask[3],\n\t\t\t\t\t  mask[4], mask[5], mask[6], mask[7],\n\t\t\t\t\t  mask[8], mask[9], mask[10], mask[11],\n\t\t\t\t\t  mask[12], mask[13], mask[14], mask[15]));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_ID_IPV4_ADDR_RANGE:\n\t\t\tif (len < 8)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 8]\", len));\n\t\t\telse {\n\t\t\t\tND_PRINT((ndo,\" len=%d %s-%s\", len,\n\t\t\t\t\t  ipaddr_string(ndo, data),\n\t\t\t\t\t  ipaddr_string(ndo, data + sizeof(struct in_addr))));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_IPV6_ADDR_RANGE:\n\t\t\tif (len < 32)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 32]\", len));\n\t\t\telse {\n\t\t\t\tND_PRINT((ndo,\" len=%d %s-%s\", len,\n\t\t\t\t\t  ip6addr_string(ndo, data),\n\t\t\t\t\t  ip6addr_string(ndo, data + sizeof(struct in6_addr))));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_DER_ASN1_DN:\n\t\tcase IPSECDOI_ID_DER_ASN1_GN:\n\t\tcase IPSECDOI_ID_KEY_ID:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tif (data && len) {\n\t\tND_PRINT((ndo,\" len=%d\", len));\n\t\tif (2 < ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo,\" \"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)data, len))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_ID)));\n\treturn NULL;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tif (len < 20)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 20]\", len));\n\t\t\telse {\n",
        "src_path": "061e7371a944588f231cb1b66d6fb070b646e376___print-isakmp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/061e7371a944588f231cb1b66d6fb070b646e376",
        "commit_msg": "CVE-2017-13689/IKEv1: Fix addr+subnet length check.\n\nAn IPv6 address plus subnet mask is 32 bytes, not 20 bytes.\n16 bytes of IPv6 address, 16 bytes of subnet mask.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -577,6 +577,7 @@ cfm_sender_id-oobr\tcfm_sender_id-oobr.pcap\tcfm_sender_id-oobr.out\t-v -c1\n isis-extd-isreach-oobr\tisis-extd-isreach-oobr.pcap\tisis-extd-isreach-oobr.out -v -c4\n olsr-oobr-1\t\tolsr-oobr-1.pcap\t\tolsr-oobr-1.out\t-v\n olsr-oobr-2\t\tolsr-oobr-2.pcap\t\tolsr-oobr-2.out\t-v\n+ikev1_id_ipv6_addr_subnet-oobr\tikev1_id_ipv6_addr_subnet-oobr.pcap\tikev1_id_ipv6_addr_subnet-oobr.out\t-v\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/ikev1_id_ipv6_addr_subnet-oobr.out",
                "patch": "@@ -0,0 +1,3 @@\n+IP (tos 0x0, ttl 100, id 40207, offset 0, flags [+, DF, rsvd], proto UDP (17), length 32808, bad cksum 8e7f (->bc78)!)\n+    16.0.128.20.500 > 12.251.0.45.0: isakmp 1.0 msgid 0d101010: phase 2/others ? #16[]:\n+    (id: idtype=IPv6net protoid=16 port=4112 len=24 [bad: < 32]) [|#145] (len mismatch: isakmp 4278190080/ip 4856)"
            }
        ],
        "error_msg": "    ikev1_id_ipv6_addr_subnet-oobr     : TEST FAILED(exit 256)\n"
    },
    "d229761821da38d984a9e4098ad96842490dc001___Client.cpp": {
        "prefix": "bool CClient::OnTextMessage(CTextMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n",
        "suffix": "                CString sMsg = Message.GetText();\n                UserCommand(sMsg);\n            } else {\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModCommand(Message.GetText()));\n            }\n            continue;\n        }\n\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n\n        if (!GetIRCSock()) {\n            // Some lagmeters do a PRIVMSG to their own nick, ignore those.\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(\n                    t_f(\"Your message to {1} got lost, you are not connected \"\n                        \"to IRC!\")(Message.GetTarget()));\n            continue;\n        }\n\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}\n",
        "start": 1223,
        "end": 1270,
        "buggy": "bool CClient::OnTextMessage(CTextMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n            if (sTarget.Equals(\"status\")) {\n                CString sMsg = Message.GetText();\n                UserCommand(sMsg);\n            } else {\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModCommand(Message.GetText()));\n            }\n            continue;\n        }\n\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n\n        if (!GetIRCSock()) {\n            // Some lagmeters do a PRIVMSG to their own nick, ignore those.\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(\n                    t_f(\"Your message to {1} got lost, you are not connected \"\n                        \"to IRC!\")(Message.GetTarget()));\n            continue;\n        }\n\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            if (sTarget.Equals(\"status\")) {\n",
        "src_path": "d229761821da38d984a9e4098ad96842490dc001___Client.cpp",
        "uri": "https://api.github.com/repos/znc/znc/commits/d229761821da38d984a9e4098ad96842490dc001",
        "commit_msg": "Fix echo-message for *status\n\nClose #1705",
        "test_func_diff": [
            {
                "fn": "test/integration/tests/core.cpp",
                "patch": "@@ -14,9 +14,10 @@\n  * limitations under the License.\n  */\n \n-#include \"znctest.h\"\n #include <gmock/gmock.h>\n \n+#include \"znctest.h\"\n+\n using testing::HasSubstr;\n \n namespace znc_inttest {\n@@ -244,7 +245,8 @@ TEST_F(ZNCTest, AwayNotify) {\n     client.Write(\"USER user/test x x :x\");\n     QByteArray cap_ls;\n     client.ReadUntilAndGet(\" LS :\", cap_ls);\n-    ASSERT_THAT(cap_ls.toStdString(), AllOf(HasSubstr(\"cap-notify\"), Not(HasSubstr(\"away-notify\"))));\n+    ASSERT_THAT(cap_ls.toStdString(),\n+                AllOf(HasSubstr(\"cap-notify\"), Not(HasSubstr(\"away-notify\"))));\n     client.Write(\"CAP REQ :cap-notify\");\n     client.ReadUntil(\"ACK :cap-notify\");\n     client.Write(\"CAP END\");\n@@ -284,5 +286,15 @@ TEST_F(ZNCTest, JoinKey) {\n     ircd.ReadUntil(\"JOIN #znc secret\");\n }\n \n+TEST_F(ZNCTest, StatusEchoMessage) {\n+    auto znc = Run();\n+    auto ircd = ConnectIRCd();\n+    auto client = LoginClient();\n+    client.Write(\"CAP REQ :echo-message\");\n+    client.Write(\"PRIVMSG *status :blah\");\n+    client.ReadUntil(\":nick!user@irc.znc.in PRIVMSG *status :blah\");\n+    client.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n+}\n+\n }  // namespace\n }  // namespace znc_inttest"
            }
        ],
        "error_msg": "      <failure message=\"test/integration/framework/base.h:116&#x0A;Value of: m_device-&gt;waitForReadyRead(timeout_ms)&#x0A;  Actual: false&#x0A;Expected: true&#x0A;Wanted: :nick!user@irc.znc.in PRIVMSG *status :blah\" type=\"\"><![CDATA[test/integration/framework/base.h:116\nValue of: m_device->waitForReadyRead(timeout_ms)\n  Actual: false\nExpected: true\nWanted: :nick!user@irc.znc.in PRIVMSG *status :blah]]></failure>\n"
    },
    "54d501092d88c0cf89bec4279951f548fb0b8618___zipfile.c": {
        "prefix": "static int zipfileUpdate(\n  sqlite3_vtab *pVtab, \n  int nVal, \n  sqlite3_value **apVal, \n  sqlite_int64 *pRowid\n){\n  ZipfileTab *pTab = (ZipfileTab*)pVtab;\n  int rc = SQLITE_OK;             /* Return Code */\n  ZipfileEntry *pNew = 0;         /* New in-memory CDS entry */\n\n  u32 mode = 0;                   /* Mode for new entry */\n  u32 mTime = 0;                  /* Modification time for new entry */\n  i64 sz = 0;                     /* Uncompressed size */\n  const char *zPath = 0;          /* Path for new entry */\n  int nPath = 0;                  /* strlen(zPath) */\n  const u8 *pData = 0;            /* Pointer to buffer containing content */\n  int nData = 0;                  /* Size of pData buffer in bytes */\n  int iMethod = 0;                /* Compression method for new entry */\n  u8 *pFree = 0;                  /* Free this */\n  char *zFree = 0;                /* Also free this */\n  ZipfileEntry *pOld = 0;\n  ZipfileEntry *pOld2 = 0;\n  int bUpdate = 0;                /* True for an update that modifies \"name\" */\n  int bIsDir = 0;\n  u32 iCrc32 = 0;\n\n  if( pTab->pWriteFd==0 ){\n    rc = zipfileBegin(pVtab);\n    if( rc!=SQLITE_OK ) return rc;\n  }\n\n  /* If this is a DELETE or UPDATE, find the archive entry to delete. */\n  if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){\n    const char *zDelete = (const char*)sqlite3_value_text(apVal[0]);\n    int nDelete = (int)strlen(zDelete);\n    if( nVal>1 ){\n      const char *zUpdate = (const char*)sqlite3_value_text(apVal[1]);\n      if( zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete)!=0 ){\n        bUpdate = 1;\n      }\n    }\n    for(pOld=pTab->pFirstEntry; 1; pOld=pOld->pNext){\n      if( zipfileComparePath(pOld->cds.zFile, zDelete, nDelete)==0 ){\n        break;\n      }\n      assert( pOld->pNext );\n    }\n  }\n\n  if( nVal>1 ){\n    /* Check that \"sz\" and \"rawdata\" are both NULL: */\n    if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){\n      zipfileTableErr(pTab, \"sz must be NULL\");\n      rc = SQLITE_CONSTRAINT;\n    }\n    if( sqlite3_value_type(apVal[6])!=SQLITE_NULL ){\n      zipfileTableErr(pTab, \"rawdata must be NULL\"); \n      rc = SQLITE_CONSTRAINT;\n    }\n\n    if( rc==SQLITE_OK ){\n      if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){\n        /* data=NULL. A directory */\n        bIsDir = 1;\n      }else{\n        /* Value specified for \"data\", and possibly \"method\". This must be\n        ** a regular file or a symlink. */\n        const u8 *aIn = sqlite3_value_blob(apVal[7]);\n        int nIn = sqlite3_value_bytes(apVal[7]);\n        int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;\n\n        iMethod = sqlite3_value_int(apVal[8]);\n        sz = nIn;\n        pData = aIn;\n        nData = nIn;\n        if( iMethod!=0 && iMethod!=8 ){\n          zipfileTableErr(pTab, \"unknown compression method: %d\", iMethod);\n          rc = SQLITE_CONSTRAINT;\n        }else{\n          if( bAuto || iMethod ){\n            int nCmp;\n            rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);\n            if( rc==SQLITE_OK ){\n              if( iMethod || nCmp<nIn ){\n                iMethod = 8;\n                pData = pFree;\n                nData = nCmp;\n              }\n            }\n          }\n          iCrc32 = crc32(0, aIn, nIn);\n        }\n      }\n    }\n\n    if( rc==SQLITE_OK ){\n      rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);\n    }\n\n    if( rc==SQLITE_OK ){\n      zPath = (const char*)sqlite3_value_text(apVal[2]);\n",
        "suffix": "      mTime = zipfileGetTime(apVal[4]);\n    }\n\n    if( rc==SQLITE_OK && bIsDir ){\n      /* For a directory, check that the last character in the path is a\n      ** '/'. This appears to be required for compatibility with info-zip\n      ** (the unzip command on unix). It does not create directories\n      ** otherwise.  */\n      if( zPath[nPath-1]!='/' ){\n        zFree = sqlite3_mprintf(\"%s/\", zPath);\n        if( zFree==0 ){ rc = SQLITE_NOMEM; }\n        zPath = (const char*)zFree;\n        nPath++;\n      }\n    }\n\n    /* Check that we're not inserting a duplicate entry -OR- updating an\n    ** entry with a path, thereby making it into a duplicate. */\n    if( (pOld==0 || bUpdate) && rc==SQLITE_OK ){\n      ZipfileEntry *p;\n      for(p=pTab->pFirstEntry; p; p=p->pNext){\n        if( zipfileComparePath(p->cds.zFile, zPath, nPath)==0 ){\n          switch( sqlite3_vtab_on_conflict(pTab->db) ){\n            case SQLITE_IGNORE: {\n              goto zipfile_update_done;\n            }\n            case SQLITE_REPLACE: {\n              pOld2 = p;\n              break;\n            }\n            default: {\n              zipfileTableErr(pTab, \"duplicate name: \\\"%s\\\"\", zPath);\n              rc = SQLITE_CONSTRAINT;\n              break;\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    if( rc==SQLITE_OK ){\n      /* Create the new CDS record. */\n      pNew = zipfileNewEntry(zPath);\n      if( pNew==0 ){\n        rc = SQLITE_NOMEM;\n      }else{\n        pNew->cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;\n        pNew->cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;\n        pNew->cds.flags = ZIPFILE_NEWENTRY_FLAGS;\n        pNew->cds.iCompression = (u16)iMethod;\n        zipfileMtimeToDos(&pNew->cds, mTime);\n        pNew->cds.crc32 = iCrc32;\n        pNew->cds.szCompressed = nData;\n        pNew->cds.szUncompressed = (u32)sz;\n        pNew->cds.iExternalAttr = (mode<<16);\n        pNew->cds.iOffset = (u32)pTab->szCurrent;\n        pNew->cds.nFile = (u16)nPath;\n        pNew->mUnixTime = (u32)mTime;\n        rc = zipfileAppendEntry(pTab, pNew, pData, nData);\n        zipfileAddEntry(pTab, pOld, pNew);\n      }\n    }\n  }\n\n  if( rc==SQLITE_OK && (pOld || pOld2) ){\n    ZipfileCsr *pCsr;\n    for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){\n      if( pCsr->pCurrent && (pCsr->pCurrent==pOld || pCsr->pCurrent==pOld2) ){\n        pCsr->pCurrent = pCsr->pCurrent->pNext;\n        pCsr->bNoop = 1;\n      }\n    }\n\n    zipfileRemoveEntryFromList(pTab, pOld);\n    zipfileRemoveEntryFromList(pTab, pOld2);\n  }\n\nzipfile_update_done:\n  sqlite3_free(pFree);\n  sqlite3_free(zFree);\n  return rc;\n}\n",
        "start": 1521,
        "end": 1705,
        "buggy": "static int zipfileUpdate(\n  sqlite3_vtab *pVtab, \n  int nVal, \n  sqlite3_value **apVal, \n  sqlite_int64 *pRowid\n){\n  ZipfileTab *pTab = (ZipfileTab*)pVtab;\n  int rc = SQLITE_OK;             /* Return Code */\n  ZipfileEntry *pNew = 0;         /* New in-memory CDS entry */\n\n  u32 mode = 0;                   /* Mode for new entry */\n  u32 mTime = 0;                  /* Modification time for new entry */\n  i64 sz = 0;                     /* Uncompressed size */\n  const char *zPath = 0;          /* Path for new entry */\n  int nPath = 0;                  /* strlen(zPath) */\n  const u8 *pData = 0;            /* Pointer to buffer containing content */\n  int nData = 0;                  /* Size of pData buffer in bytes */\n  int iMethod = 0;                /* Compression method for new entry */\n  u8 *pFree = 0;                  /* Free this */\n  char *zFree = 0;                /* Also free this */\n  ZipfileEntry *pOld = 0;\n  ZipfileEntry *pOld2 = 0;\n  int bUpdate = 0;                /* True for an update that modifies \"name\" */\n  int bIsDir = 0;\n  u32 iCrc32 = 0;\n\n  if( pTab->pWriteFd==0 ){\n    rc = zipfileBegin(pVtab);\n    if( rc!=SQLITE_OK ) return rc;\n  }\n\n  /* If this is a DELETE or UPDATE, find the archive entry to delete. */\n  if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){\n    const char *zDelete = (const char*)sqlite3_value_text(apVal[0]);\n    int nDelete = (int)strlen(zDelete);\n    if( nVal>1 ){\n      const char *zUpdate = (const char*)sqlite3_value_text(apVal[1]);\n      if( zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete)!=0 ){\n        bUpdate = 1;\n      }\n    }\n    for(pOld=pTab->pFirstEntry; 1; pOld=pOld->pNext){\n      if( zipfileComparePath(pOld->cds.zFile, zDelete, nDelete)==0 ){\n        break;\n      }\n      assert( pOld->pNext );\n    }\n  }\n\n  if( nVal>1 ){\n    /* Check that \"sz\" and \"rawdata\" are both NULL: */\n    if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){\n      zipfileTableErr(pTab, \"sz must be NULL\");\n      rc = SQLITE_CONSTRAINT;\n    }\n    if( sqlite3_value_type(apVal[6])!=SQLITE_NULL ){\n      zipfileTableErr(pTab, \"rawdata must be NULL\"); \n      rc = SQLITE_CONSTRAINT;\n    }\n\n    if( rc==SQLITE_OK ){\n      if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){\n        /* data=NULL. A directory */\n        bIsDir = 1;\n      }else{\n        /* Value specified for \"data\", and possibly \"method\". This must be\n        ** a regular file or a symlink. */\n        const u8 *aIn = sqlite3_value_blob(apVal[7]);\n        int nIn = sqlite3_value_bytes(apVal[7]);\n        int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;\n\n        iMethod = sqlite3_value_int(apVal[8]);\n        sz = nIn;\n        pData = aIn;\n        nData = nIn;\n        if( iMethod!=0 && iMethod!=8 ){\n          zipfileTableErr(pTab, \"unknown compression method: %d\", iMethod);\n          rc = SQLITE_CONSTRAINT;\n        }else{\n          if( bAuto || iMethod ){\n            int nCmp;\n            rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);\n            if( rc==SQLITE_OK ){\n              if( iMethod || nCmp<nIn ){\n                iMethod = 8;\n                pData = pFree;\n                nData = nCmp;\n              }\n            }\n          }\n          iCrc32 = crc32(0, aIn, nIn);\n        }\n      }\n    }\n\n    if( rc==SQLITE_OK ){\n      rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);\n    }\n\n    if( rc==SQLITE_OK ){\n      zPath = (const char*)sqlite3_value_text(apVal[2]);\n      nPath = (int)strlen(zPath);\n      mTime = zipfileGetTime(apVal[4]);\n    }\n\n    if( rc==SQLITE_OK && bIsDir ){\n      /* For a directory, check that the last character in the path is a\n      ** '/'. This appears to be required for compatibility with info-zip\n      ** (the unzip command on unix). It does not create directories\n      ** otherwise.  */\n      if( zPath[nPath-1]!='/' ){\n        zFree = sqlite3_mprintf(\"%s/\", zPath);\n        if( zFree==0 ){ rc = SQLITE_NOMEM; }\n        zPath = (const char*)zFree;\n        nPath++;\n      }\n    }\n\n    /* Check that we're not inserting a duplicate entry -OR- updating an\n    ** entry with a path, thereby making it into a duplicate. */\n    if( (pOld==0 || bUpdate) && rc==SQLITE_OK ){\n      ZipfileEntry *p;\n      for(p=pTab->pFirstEntry; p; p=p->pNext){\n        if( zipfileComparePath(p->cds.zFile, zPath, nPath)==0 ){\n          switch( sqlite3_vtab_on_conflict(pTab->db) ){\n            case SQLITE_IGNORE: {\n              goto zipfile_update_done;\n            }\n            case SQLITE_REPLACE: {\n              pOld2 = p;\n              break;\n            }\n            default: {\n              zipfileTableErr(pTab, \"duplicate name: \\\"%s\\\"\", zPath);\n              rc = SQLITE_CONSTRAINT;\n              break;\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    if( rc==SQLITE_OK ){\n      /* Create the new CDS record. */\n      pNew = zipfileNewEntry(zPath);\n      if( pNew==0 ){\n        rc = SQLITE_NOMEM;\n      }else{\n        pNew->cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;\n        pNew->cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;\n        pNew->cds.flags = ZIPFILE_NEWENTRY_FLAGS;\n        pNew->cds.iCompression = (u16)iMethod;\n        zipfileMtimeToDos(&pNew->cds, mTime);\n        pNew->cds.crc32 = iCrc32;\n        pNew->cds.szCompressed = nData;\n        pNew->cds.szUncompressed = (u32)sz;\n        pNew->cds.iExternalAttr = (mode<<16);\n        pNew->cds.iOffset = (u32)pTab->szCurrent;\n        pNew->cds.nFile = (u16)nPath;\n        pNew->mUnixTime = (u32)mTime;\n        rc = zipfileAppendEntry(pTab, pNew, pData, nData);\n        zipfileAddEntry(pTab, pOld, pNew);\n      }\n    }\n  }\n\n  if( rc==SQLITE_OK && (pOld || pOld2) ){\n    ZipfileCsr *pCsr;\n    for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){\n      if( pCsr->pCurrent && (pCsr->pCurrent==pOld || pCsr->pCurrent==pOld2) ){\n        pCsr->pCurrent = pCsr->pCurrent->pNext;\n        pCsr->bNoop = 1;\n      }\n    }\n\n    zipfileRemoveEntryFromList(pTab, pOld);\n    zipfileRemoveEntryFromList(pTab, pOld2);\n  }\n\nzipfile_update_done:\n  sqlite3_free(pFree);\n  sqlite3_free(zFree);\n  return rc;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "      nPath = (int)strlen(zPath);\n",
        "src_path": "54d501092d88c0cf89bec4279951f548fb0b8618___zipfile.c",
        "uri": "https://api.github.com/repos/sqlite/sqlite/commits/54d501092d88c0cf89bec4279951f548fb0b8618",
        "commit_msg": "Fix the zipfile extension so that INSERT works even if the pathname of\nthe file being inserted is a NULL.  Bug discovered by the\nYongheng and Rui fuzzer.\n\nFossilOrigin-Name: a80f84b511231204658304226de3e075a55afc2e3f39ac063716f7a57f585c06",
        "test_func_diff": [
            {
                "fn": "test/zipfile.test",
                "patch": "@@ -795,4 +795,18 @@ if {$tcl_platform(platform)!=\"windows\"} {\n   } {. ./x1.txt ./x2.txt}\n }\n \n+# 2019-12-18 Yongheng and Rui fuzzer\n+#\n+do_execsql_test 13.10 {\n+  DROP TABLE IF EXISTS t0;\n+  DROP TABLE IF EXISTS t1;\n+  CREATE TABLE t0(a,b,c,d,e,f,g);\n+  REPLACE INTO t0(c,b,f) VALUES(10,10,10);\n+  CREATE VIRTUAL TABLE t1 USING zipfile('h.zip');\n+  REPLACE INTO t1 SELECT * FROM t0;\n+  SELECT quote(name),quote(mode),quote(mtime),quote(sz),quote(rawdata),\n+         quote(data),quote(method) FROM t1;\n+} {'' 10 10 2 X'3130' X'3130' 0}\n+\n+\n finish_test"
            }
        ],
        "error_msg": "warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/usr/lib/x86_64-linux-gnu/libthread_db.so.1\".\n[Detaching after fork from child process 181009]\n[Detaching after fork from child process 181721]\n[Detaching after fork from child process 182335]\n[Detaching after fork from child process 183098]\n[Detaching after fork from child process 183768]\n[Detaching after fork from child process 184734]\n[Detaching after fork from child process 185566]\n[Detaching after fork from child process 186924]\n[Detaching after fork from child process 187788]\n[Detaching after fork from child process 188627]\n[Detaching after fork from child process 189128]\n[Detaching after fork from child process 190190]\n[Detaching after fork from child process 190678]\nzipfile-2.5.1...[Detaching after fork from child process 191138]\nzipfile-6.0...[Detaching after fork from child process 191712]\nzipfile-6.2...[Detaching after fork from child process 191904]\nzipfile-13.10...\nProgram received signal SIGSEGV, Segmentation fault.\n__strlen_avx2 () at ../sysdeps/x86_64/multiarch/strlen-avx2.S:65\n65\t../sysdeps/x86_64/multiarch/strlen-avx2.S: No such file or directory.\n"
    },
    "bc7fe41e5857a0854d524e2a63a028e9394d2a5c___t_hash.c": {
        "prefix": "void hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n",
        "suffix": "    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Always replicate HINCRBYFLOAT as an HSET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}\n",
        "start": 660,
        "end": 706,
        "buggy": "void hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Always replicate HINCRBYFLOAT as an HSET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n",
        "src_path": "bc7fe41e5857a0854d524e2a63a028e9394d2a5c___t_hash.c",
        "uri": "https://api.github.com/repos/redis/redis/commits/bc7fe41e5857a0854d524e2a63a028e9394d2a5c",
        "commit_msg": "fix hincrbyfloat not to create a key if the new value is invalid (#11149)\n\nCheck the validity of the value before performing the create operation,\r\nprevents new data from being generated even if the request fails to execute.\r\n\r\nCo-authored-by: Oran Agra <oran@redislabs.com>\r\nCo-authored-by: chendianqiang <chendianqiang@meituan.com>\r\nCo-authored-by: Binbin <binloveplay1314@qq.com>",
        "test_func_diff": [
            {
                "fn": "tests/unit/type/hash.tcl",
                "patch": "@@ -819,4 +819,8 @@ start_server {tags {\"hash\"}} {\n         set _ $k\n     } {ZIP_INT_8B 127 ZIP_INT_16B 32767 ZIP_INT_32B 2147483647 ZIP_INT_64B 9223372036854775808 ZIP_INT_IMM_MIN 0 ZIP_INT_IMM_MAX 12}\n \n+    test {HINCRBYFLOAT does not allow NaN or Infinity} {\n+        assert_error \"*value is NaN or Infinity*\" {r hincrbyfloat hfoo field +inf}\n+        assert_equal 0 [r exists hfoo]\n+    }\n }"
            }
        ],
        "error_msg": "[err]: HINCRBYFLOAT does not allow NaN or Infinity in tests/unit/type/hash.tcl\n*** [err]: HINCRBYFLOAT does not allow NaN or Infinity in tests/unit/type/hash.tcl\n"
    },
    "76a7b10005c70babee357a7d0f2becf28ec7ed1e___hiredis.c": {
        "prefix": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n\n    if (elements > 0) {\n",
        "suffix": "        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n\n    r->elements = elements;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n",
        "start": 169,
        "end": 195,
        "buggy": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n\n    if (elements > 0) {\n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n\n    r->elements = elements;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        r->element = hi_calloc(elements,sizeof(redisReply*));\n",
        "src_path": "76a7b10005c70babee357a7d0f2becf28ec7ed1e___hiredis.c",
        "uri": "https://api.github.com/repos/redis/hiredis/commits/76a7b10005c70babee357a7d0f2becf28ec7ed1e",
        "commit_msg": "Fix for integer/buffer overflow CVE-2021-32765\n\nThis fix prevents hiredis from trying to allocate more than `SIZE_MAX`\nbytes, which would result in a buffer overrun.\n\n[Full Details](https://github.com/redis/hiredis/security/advisories/GHSA-hfm9-39pp-55p2)",
        "test_func_diff": [
            {
                "fn": "test.c",
                "patch": "@@ -493,6 +493,20 @@ static void test_reply_reader(void) {\n     freeReplyObject(reply);\n     redisReaderFree(reader);\n \n+    test(\"Multi-bulk never overflows regardless of maxelements: \");\n+    size_t bad_mbulk_len = (SIZE_MAX / sizeof(void *)) + 3;\n+    char bad_mbulk_reply[100];\n+    snprintf(bad_mbulk_reply, sizeof(bad_mbulk_reply), \"*%llu\\r\\n+asdf\\r\\n\",\n+        (unsigned long long) bad_mbulk_len);\n+\n+    reader = redisReaderCreate();\n+    reader->maxelements = 0;    /* Don't rely on default limit */\n+    redisReaderFeed(reader, bad_mbulk_reply, strlen(bad_mbulk_reply));\n+    ret = redisReaderGetReply(reader,&reply);\n+    test_cond(ret == REDIS_ERR && strcasecmp(reader->errstr, \"Out of memory\") == 0);\n+    freeReplyObject(reply);\n+    redisReaderFree(reader);\n+\n #if LLONG_MAX > SIZE_MAX\n     test(\"Set error when array > SIZE_MAX: \");\n     reader = redisReaderCreate();"
            }
        ],
        "error_msg": ""
    },
    "2bb97f407c1145c850416a3bfbcc8cf124e68a19___gd_gd2.c": {
        "prefix": "static int\n_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (!cidx) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n",
        "suffix": "\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n",
        "start": 63,
        "end": 179,
        "buggy": "static int\n_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (!cidx) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t};\n\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t};\n",
        "src_path": "2bb97f407c1145c850416a3bfbcc8cf124e68a19___gd_gd2.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/2bb97f407c1145c850416a3bfbcc8cf124e68a19",
        "commit_msg": "gd2: handle corrupt images better (CVE-2016-3074)\n\nMake sure we do some range checking on corrupted chunks.\n\nThanks to Hans Jerry Illikainen <hji@dyntopia.com> for indepth report\nand reproducer information.  Made for easy test case writing :).",
        "test_func_diff": [
            {
                "fn": "tests/Makefile.am",
                "patch": "@@ -129,7 +129,8 @@ endif\n \n if HAVE_LIBZ\n check_PROGRAMS += \\\n-\tgd2/gd2_null\n+\tgd2/gd2_null \\\n+\tgd2/gd2_read_corrupt\n endif\n \n if HAVE_LIBPNG"
            },
            {
                "fn": "tests/gd2/gd2_read_corrupt.c",
                "patch": "@@ -0,0 +1,25 @@\n+/* Just try to read the invalid gd2 image & not crash. */\n+#include \"gd.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"gdtest.h\"\n+\n+int main()\n+{\n+\tgdImagePtr im;\n+\tFILE *fp;\n+\tchar path[1024];\n+\n+\t/* Read the corrupt image. */\n+\tsprintf(path, \"%s/gd2/invalid_neg_size.gd2\", GDTEST_TOP_DIR);\n+\tfp = fopen(path, \"rb\");\n+\tif (!fp) {\n+\t\tprintf(\"failed, cannot open file\\n\");\n+\t\treturn 1;\n+\t}\n+\tim = gdImageCreateFromGd2(fp);\n+\tfclose(fp);\n+\n+\t/* Should have failed & rejected it. */\n+\treturn im == NULL ? 0 : 1;\n+}"
            }
        ],
        "error_msg": "========================================\n   GD 2.2.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 102\n# PASS:  99\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  3\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: gd2/gd2_read_corrupt\n==========================\n\ncorrupted size vs. prev_size\nFAIL gd2/gd2_read_corrupt (exit status: 134)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\n(491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:35: Total pixels changed: 9 with a maximum channel difference of 0.\nReference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\n"
    },
    "1846f48e5fcdde996e7c27a4bbac5d0aef183e4b___gd.c": {
        "prefix": "BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n",
        "suffix": "\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char), sx)) {\n\t\treturn NULL;\n\t}\n\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n\n\t/* Row-major ever since gd 1.3 */\n\tim->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; (i < sy); i++) {\n\t\t/* Row-major ever since gd 1.3 */\n\t\tim->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\tif (!im->pixels[i]) {\n\t\t\tfor (--i ; i >= 0; i--) {\n\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t}\n\t\t\tgdFree(im->pixels);\n\t\t\tgdFree(im);\n\t\t\treturn NULL;\n\t\t}\n\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tim->open[i] = 1;\n\t};\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->res_x = GD_RESOLUTION;\n\tim->res_y = GD_RESOLUTION;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}\n",
        "start": 183,
        "end": 249,
        "buggy": "BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char), sx)) {\n\t\treturn NULL;\n\t}\n\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n\n\t/* Row-major ever since gd 1.3 */\n\tim->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; (i < sy); i++) {\n\t\t/* Row-major ever since gd 1.3 */\n\t\tim->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\tif (!im->pixels[i]) {\n\t\t\tfor (--i ; i >= 0; i--) {\n\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t}\n\t\t\tgdFree(im->pixels);\n\t\t\tgdFree(im);\n\t\t\treturn NULL;\n\t\t}\n\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tim->open[i] = 1;\n\t};\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->res_x = GD_RESOLUTION;\n\tim->res_y = GD_RESOLUTION;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\tif (overflow2(sizeof (unsigned char *), sy)) {\n",
        "src_path": "1846f48e5fcdde996e7c27a4bbac5d0aef183e4b___gd.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/1846f48e5fcdde996e7c27a4bbac5d0aef183e4b",
        "commit_msg": "Fix #340: System frozen\n\ngdImageCreate() doesn't check for oversized images and as such is prone\nto DoS vulnerabilities. We fix that by applying the same overflow check\nthat is already in place for gdImageCreateTrueColor().\n\nCVE-2016-9317",
        "test_func_diff": [
            {
                "fn": "tests/CMakeLists.txt",
                "patch": "@@ -38,6 +38,7 @@ if (BUILD_TEST)\n \t\tgdimagecopy\n \t\tgdimagecopyresampled\n \t\tgdimagecopyrotated\n+\t\tgdimagecreate\n \t\tgdimagecrop\n \t\tgdimagefile\n \t\tgdimagefill"
            },
            {
                "fn": "tests/Makefile.am",
                "patch": "@@ -33,6 +33,7 @@ include gdimageconvolution/Makemodule.am\n include gdimagecopy/Makemodule.am\n include gdimagecopyresampled/Makemodule.am\n include gdimagecopyrotated/Makemodule.am\n+include gdimagecreate/Makemodule.am\n include gdimagecrop/Makemodule.am\n include gdimagefile/Makemodule.am\n include gdimagefill/Makemodule.am"
            },
            {
                "fn": "tests/gdimagecreate/.gitignore",
                "patch": "@@ -0,0 +1 @@\n+/bug00340"
            },
            {
                "fn": "tests/gdimagecreate/CMakeLists.txt",
                "patch": "@@ -0,0 +1,5 @@\n+SET(TESTS_FILES\n+\tbug00340\n+)\n+\n+ADD_GD_TESTS()"
            },
            {
                "fn": "tests/gdimagecreate/Makemodule.am",
                "patch": "@@ -0,0 +1,5 @@\n+libgd_test_programs += \\\n+\tgdimagecreate/bug00340\n+\n+EXTRA_DIST += \\\n+\tgdimagecreate/CMakeLists.txt"
            },
            {
                "fn": "tests/gdimagecreate/bug00340.c",
                "patch": "@@ -0,0 +1,33 @@\n+/**\r\n+ * Regression test for <https://github.com/libgd/libgd/issues/340>\r\n+ *\r\n+ * We're testing that trying to create an oversized image fails early,\r\n+ * triggering an appropriate warning.\r\n+ */\r\n+\r\n+\r\n+#include <string.h>\r\n+#include \"gd.h\"\r\n+#include \"gd_errors.h\"\r\n+#include \"gdtest.h\"\r\n+\r\n+\r\n+#define MSG \"product of memory allocation multiplication would exceed INT_MAX, failing operation gracefully\\n\"\r\n+\r\n+\r\n+void error_handler(int priority, const char *format, ...)\r\n+{\r\n+    gdTestAssert(priority == GD_WARNING);\r\n+    gdTestAssert(!strcmp(format, MSG));\r\n+}\r\n+\r\n+\r\n+int main()\r\n+{\r\n+    gdImagePtr im;\r\n+\r\n+    im = gdImageCreate(64970, 65111);\r\n+    gdTestAssert(im == NULL);\r\n+\r\n+    return gdNumFailures();\r\n+}\r"
            }
        ],
        "error_msg": "========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 156\n# PASS:  154\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  2\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:31: Total pixels changed: 9 with a maximum channel difference of 255.\nfreetype/bug00132.c:33: Reference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\ngdimagestringft/gdimagestringft_bbox.c:56: (491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\n"
    },
    "69d2fd2c597ffc0c217de1238b9bf4d4bceba8e6___gd_gd2.c": {
        "prefix": "static int\n_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n",
        "suffix": "\n\t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tif (overflow2(sizeof(t_chunk_info), nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0)\n\t\t\t\tgoto fail2;\n\t\t};\n\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n",
        "start": 121,
        "end": 247,
        "buggy": "static int\n_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\n\t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tif (overflow2(sizeof(t_chunk_info), nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0)\n\t\t\t\tgoto fail2;\n\t\t};\n\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\tnc = (*ncx) * (*ncy);\n",
        "src_path": "69d2fd2c597ffc0c217de1238b9bf4d4bceba8e6___gd_gd2.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/69d2fd2c597ffc0c217de1238b9bf4d4bceba8e6",
        "commit_msg": "Fix #354: Signed Integer Overflow gd_io.c\n\nGD2 stores the number of horizontal and vertical chunks as words (i.e. 2\nbyte unsigned). These values are multiplied and assigned to an int when\nreading the image, what can cause integer overflows. We have to avoid\nthat, and also make sure that either chunk count is actually greater\nthan zero. If illegal chunk counts are detected, we bail out from\nreading the image.",
        "test_func_diff": [
            {
                "fn": "tests/gd2/.gitignore",
                "patch": "@@ -1,5 +1,6 @@\n /bug_289\n /bug00309\n+/bug00354\n /gd2_empty_file\n /gd2_im2im\n /gd2_null"
            },
            {
                "fn": "tests/gd2/CMakeLists.txt",
                "patch": "@@ -1,6 +1,7 @@\n LIST(APPEND TESTS_FILES\n \tbug_289\n \tbug00309\n+\tbug00354\n \tgd2_empty_file\n \tgd2_im2im\n \tgd2_null"
            },
            {
                "fn": "tests/gd2/Makemodule.am",
                "patch": "@@ -1,6 +1,7 @@\n libgd_test_programs += \\\n \tgd2/bug_289 \\\n \tgd2/bug00309 \\\n+\tgd2/bug00354 \\\n \tgd2/gd2_empty_file \\\n \tgd2/php_bug_72339 \\\n \tgd2/gd2_read_corrupt \\\n@@ -19,6 +20,8 @@ endif\n \n EXTRA_DIST += \\\n \tgd2/CMakeLists.txt \\\n+\tgd2/bug00354a.gd2 \\\n+\tgd2/bug00354b.gd2 \\\n \tgd2/conv_gd2_exp.gd2 \\\n \tgd2/conv_test.gd2 \\\n \tgd2/conv_test_exp.png \\"
            },
            {
                "fn": "tests/gd2/bug00354.c",
                "patch": "@@ -0,0 +1,32 @@\n+/**\r\n+ * We're testing GD2 image files which report illegal chunk counts. These should\r\n+ * not cause integer overflows or other issues, but instead simply fail to be\r\n+ * loaded.\r\n+ *\r\n+ * See also <https://github.com/libgd/libgd/issues/354>.\r\n+ */\r\n+\r\n+\r\n+#include \"gd.h\"\r\n+#include \"gdtest.h\"\r\n+\r\n+\r\n+int main()\r\n+{\r\n+    gdImagePtr im;\r\n+    FILE *fp;\r\n+\r\n+    fp = gdTestFileOpen2(\"gd2\", \"bug00354a.gd2\");\r\n+    gdTestAssert(fp != NULL);\r\n+    im = gdImageCreateFromGd2(fp);\r\n+    gdTestAssert(im == NULL);\r\n+    fclose(fp);\r\n+\r\n+    fp = gdTestFileOpen2(\"gd2\", \"bug00354b.gd2\");\r\n+    gdTestAssert(fp != NULL);\r\n+    im = gdImageCreateFromGd2(fp);\r\n+    gdTestAssert(im == NULL);\r\n+    fclose(fp);\r\n+\r\n+    return gdNumFailures();\r\n+}\r"
            }
        ],
        "error_msg": "========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 157\n# PASS:  155\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  2\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:31: Total pixels changed: 9 with a maximum channel difference of 255.\nfreetype/bug00132.c:33: Reference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\ngdimagestringft/gdimagestringft_bbox.c:56: (491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\n"
    },
    "7325e9a5e71e2fc0e350487ecac7d84acdf0ed5e___jwe.c": {
        "prefix": "static bool _cjose_jwe_decrypt_dat_aes_gcm(cjose_jwe_t *jwe, cjose_err *err)\n{\n    EVP_CIPHER_CTX *ctx = NULL;\n\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // get AES GCM cipher\n    const EVP_CIPHER *cipher = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128GCM) == 0)\n        cipher = EVP_aes_128_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A192GCM) == 0)\n        cipher = EVP_aes_192_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A256GCM) == 0)\n        cipher = EVP_aes_256_gcm();\n\n    if (NULL == cipher)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // instantiate and initialize a new openssl cipher context\n    ctx = EVP_CIPHER_CTX_new();\n    if (NULL == ctx)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    EVP_CIPHER_CTX_init(ctx);\n\n    // initialize context for decryption using AES GCM cipher and CEK and IV\n    if (EVP_DecryptInit_ex(ctx, cipher, NULL, jwe->cek, jwe->enc_iv.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n",
        "suffix": "    if (EVP_CIPHER_CTX_ctrl(ctx, CJOSE_EVP_CTRL_GCM_SET_TAG, jwe->enc_auth_tag.raw_len, jwe->enc_auth_tag.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // set GCM mode AAD data (hdr_b64u) by setting \"out\" to NULL\n    int bytes_decrypted = 0;\n    if (EVP_DecryptUpdate(ctx, NULL, &bytes_decrypted, (unsigned char *)jwe->enc_header.b64u, jwe->enc_header.b64u_len) != 1\n        || bytes_decrypted != jwe->enc_header.b64u_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // allocate buffer for the plaintext\n    cjose_get_dealloc()(jwe->dat);\n    jwe->dat_len = jwe->enc_ct.raw_len;\n    if (!_cjose_jwe_malloc(jwe->dat_len, false, &jwe->dat, err))\n    {\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // decrypt ciphertext to plaintext buffer\n    if (EVP_DecryptUpdate(ctx, jwe->dat, &bytes_decrypted, jwe->enc_ct.raw, jwe->enc_ct.raw_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    jwe->dat_len = bytes_decrypted;\n\n    // finalize the decryption\n    if (EVP_DecryptFinal_ex(ctx, NULL, &bytes_decrypted) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    EVP_CIPHER_CTX_free(ctx);\n    return true;\n\n_cjose_jwe_decrypt_dat_aes_gcm_fail:\n    if (NULL != ctx)\n    {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n    return false;\n}\n",
        "start": 1244,
        "end": 1337,
        "buggy": "static bool _cjose_jwe_decrypt_dat_aes_gcm(cjose_jwe_t *jwe, cjose_err *err)\n{\n    EVP_CIPHER_CTX *ctx = NULL;\n\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // get AES GCM cipher\n    const EVP_CIPHER *cipher = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128GCM) == 0)\n        cipher = EVP_aes_128_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A192GCM) == 0)\n        cipher = EVP_aes_192_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A256GCM) == 0)\n        cipher = EVP_aes_256_gcm();\n\n    if (NULL == cipher)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // instantiate and initialize a new openssl cipher context\n    ctx = EVP_CIPHER_CTX_new();\n    if (NULL == ctx)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    EVP_CIPHER_CTX_init(ctx);\n\n    // initialize context for decryption using AES GCM cipher and CEK and IV\n    if (EVP_DecryptInit_ex(ctx, cipher, NULL, jwe->cek, jwe->enc_iv.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // set the expected GCM-mode authentication tag\n    if (EVP_CIPHER_CTX_ctrl(ctx, CJOSE_EVP_CTRL_GCM_SET_TAG, jwe->enc_auth_tag.raw_len, jwe->enc_auth_tag.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // set GCM mode AAD data (hdr_b64u) by setting \"out\" to NULL\n    int bytes_decrypted = 0;\n    if (EVP_DecryptUpdate(ctx, NULL, &bytes_decrypted, (unsigned char *)jwe->enc_header.b64u, jwe->enc_header.b64u_len) != 1\n        || bytes_decrypted != jwe->enc_header.b64u_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // allocate buffer for the plaintext\n    cjose_get_dealloc()(jwe->dat);\n    jwe->dat_len = jwe->enc_ct.raw_len;\n    if (!_cjose_jwe_malloc(jwe->dat_len, false, &jwe->dat, err))\n    {\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // decrypt ciphertext to plaintext buffer\n    if (EVP_DecryptUpdate(ctx, jwe->dat, &bytes_decrypted, jwe->enc_ct.raw, jwe->enc_ct.raw_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    jwe->dat_len = bytes_decrypted;\n\n    // finalize the decryption\n    if (EVP_DecryptFinal_ex(ctx, NULL, &bytes_decrypted) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    EVP_CIPHER_CTX_free(ctx);\n    return true;\n\n_cjose_jwe_decrypt_dat_aes_gcm_fail:\n    if (NULL != ctx)\n    {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n    return false;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    // set the expected GCM-mode authentication tag\n",
        "src_path": "7325e9a5e71e2fc0e350487ecac7d84acdf0ed5e___jwe.c",
        "uri": "https://api.github.com/repos/OpenIDC/cjose/commits/7325e9a5e71e2fc0e350487ecac7d84acdf0ed5e",
        "commit_msg": "use fixed authentication tag length of 16 octets in AES GCM decryption\n\nsee: https://github.com/cisco/cjose/issues/125\n\nSigned-off-by: Hans Zandbelt <hans.zandbelt@openidc.com>",
        "test_func_diff": [
            {
                "fn": "test/check_jwe.c",
                "patch": "@@ -967,6 +967,63 @@ START_TEST(test_cjose_jwe_decrypt_aes)\n }\n END_TEST\n \n+START_TEST(test_cjose_jwe_decrypt_aes_gcm)\n+{\n+    cjose_err err;\n+\n+    const char *key = JWK_OCT_32;\n+    const char *plain1 = \"Live long and prosper.\";\n+    char *compact1 = \"eyJhbGciOiAiZGlyIiwgImVuYyI6ICJBMjU2R0NNIn0..Du_9fxxV-zrReaWC.aS_rpokeuxkaPc2sykcQDCQuJCYoww.GpeKGEqd8KQ0v6JNea5aSA\";\n+    char *compact2 = \"eyJhbGciOiAiZGlyIiwgImVuYyI6ICJBMjU2R0NNIn0..Du_9fxxV-zrReaWC.aS_rpokeuxkaPc2sykcQDCQuJCYoww.Gp\";\n+\n+    cjose_jwk_t *jwk = cjose_jwk_import(key, strlen(key), &err);\n+    ck_assert_msg(NULL != jwk,\n+                  \"cjose_jwk_import failed: \"\n+                  \"%s, file: %s, function: %s, line: %ld\",\n+                  err.message, err.file, err.function, err.line);\n+\n+    cjose_jwe_t *jwe1 = cjose_jwe_import(compact1, strlen(compact1), &err);\n+    ck_assert_msg(NULL != jwe1,\n+                  \"cjose_jwe_import failed: \"\n+                  \"%s, file: %s, function: %s, line: %ld\",\n+                  err.message, err.file, err.function, err.line);\n+\n+    uint8_t *plain2 = NULL;\n+    size_t plain2_len = 0;\n+    plain2 = cjose_jwe_decrypt(jwe1, jwk, &plain2_len, &err);\n+    ck_assert_msg(NULL != plain2,\n+                  \"cjose_jwe_decrypt failed: \"\n+                  \"%s, file: %s, function: %s, line: %ld\",\n+                  err.message, err.file, err.function, err.line);\n+\n+    ck_assert_msg(plain2_len == strlen(plain1),\n+                  \"length of decrypted plaintext does not match length of original, \"\n+                  \"expected: %lu, found: %lu\",\n+                  strlen(plain1), plain2_len);\n+    ck_assert_msg(strncmp(plain1, plain2, plain2_len) == 0, \"decrypted plaintext does not match encrypted plaintext\");\n+\n+    cjose_get_dealloc()(plain2);\n+    cjose_jwe_release(jwe1);\n+\n+    cjose_jwe_t *jwe2 = cjose_jwe_import(compact2, strlen(compact2), &err);\n+    ck_assert_msg(NULL != jwe2,\n+                   \"cjose_jwe_import failed: \"\n+                   \"%s, file: %s, function: %s, line: %ld\",\n+                   err.message, err.file, err.function, err.line);\n+\n+    uint8_t *plain3 = NULL;\n+    size_t plain3_len = 0;\n+    plain3 = cjose_jwe_decrypt(jwe2, jwk, &plain3_len, &err);\n+    ck_assert_msg(NULL == plain3,\n+                   \"cjose_jwe_decrypt succeeded where it should have failed: \"\n+                   \"%s, file: %s, function: %s, line: %ld\",\n+                   err.message, err.file, err.function, err.line);\n+\n+    cjose_jwe_release(jwe2);\n+    cjose_jwk_release(jwk);\n+}\n+END_TEST\n+\n START_TEST(test_cjose_jwe_decrypt_rsa)\n {\n     struct cjose_jwe_decrypt_rsa\n@@ -1373,6 +1430,7 @@ Suite *cjose_jwe_suite()\n     tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_large);\n     tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_many);\n     tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_aes);\n+    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_aes_gcm);\n     tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_rsa);\n     tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_header);\n     tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_key);"
            }
        ],
        "error_msg": "check_jwe.c:1017:F:core:test_cjose_jwe_decrypt_aes_gcm:0: cjose_jwe_decrypt succeeded where it should have failed: core, file: , function: N+\u0001, line: 1\n"
    },
    "3530bcc30350d4a6ccf35d2f7b33e23292b9de70___idna.c": {
        "prefix": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n",
        "suffix": "\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* \u3002 */\n        if (c != 0xFF0E)  /* \uff0e */\n          if (c != 0xFF61)  /* \uff61 */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d >= de)\n    return UV_EINVAL;\n\n  *d++ = '\\0';\n  return d - ds;  /* Number of bytes written. */\n}\n",
        "start": 318,
        "end": 364,
        "buggy": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* \u3002 */\n        if (c != 0xFF0E)  /* \uff0e */\n          if (c != 0xFF61)  /* \uff61 */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d >= de)\n    return UV_EINVAL;\n\n  *d++ = '\\0';\n  return d - ds;  /* Number of bytes written. */\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  ds = d;\n",
        "src_path": "3530bcc30350d4a6ccf35d2f7b33e23292b9de70___idna.c",
        "uri": "https://api.github.com/repos/libuv/libuv/commits/3530bcc30350d4a6ccf35d2f7b33e23292b9de70",
        "commit_msg": "fix: reject zero-length idna inputs\n\nFixes: https://github.com/libuv/libuv/security/advisories/GHSA-f74f-cvh7-c6q6",
        "test_func_diff": [
            {
                "fn": "test/test-idna.c",
                "patch": "@@ -115,6 +115,7 @@ TEST_IMPL(utf8_decode1_overrun) {\n   ASSERT_PTR_EQ(p, b + 1);\n \n   b[0] = 0x7F;\n+  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 0, c, c + 1));\n   ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 1, c, c + 1));\n \n   return 0;"
            }
        ],
        "error_msg": "not ok 118 - fs_utime_round\n# exit code 134\n# Output from process `fs_utime_round`:\n# Assertion failed in test/test-fs.c on line 847: `s->st_atim.tv_sec <= (long) atime` (0 <= -14245440)\nok 119 - fs_write_alotof_bufs\nnot ok 429 - utf8_decode1_overrun\n# exit code 134\n# Output from process `utf8_decode1_overrun`:\n# Assertion failed in test/test-idna.c on line 118: `UV_EINVAL == uv__idna_toascii(b, b + 0, c, c + 1)` (-22 == 1)\nok 430 - walk_handles\n"
    },
    "d457c9545e7e71ebb5c0479eb16b9d33175855e2___njs_vmcode.c": {
        "prefix": "static njs_jump_off_t\nnjs_vmcode_typeof(njs_vm_t *vm, njs_value_t *value, njs_value_t *invld)\n{\n    /* ECMAScript 5.1: null, array and regexp are objects. */\n\n    static const njs_value_t  *types[NJS_VALUE_TYPE_MAX] = {\n        &njs_string_object,\n        &njs_string_undefined,\n        &njs_string_boolean,\n        &njs_string_number,\n        &njs_string_symbol,\n        &njs_string_string,\n        &njs_string_data,\n        &njs_string_external,\n        &njs_string_invalid,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_function,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n",
        "suffix": "\n    vm->retval = *types[value->type];\n\n    return sizeof(njs_vmcode_2addr_t);\n}\n",
        "start": 1487,
        "end": 1524,
        "buggy": "static njs_jump_off_t\nnjs_vmcode_typeof(njs_vm_t *vm, njs_value_t *value, njs_value_t *invld)\n{\n    /* ECMAScript 5.1: null, array and regexp are objects. */\n\n    static const njs_value_t  *types[NJS_VALUE_TYPE_MAX] = {\n        &njs_string_object,\n        &njs_string_undefined,\n        &njs_string_boolean,\n        &njs_string_number,\n        &njs_string_symbol,\n        &njs_string_string,\n        &njs_string_data,\n        &njs_string_external,\n        &njs_string_invalid,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_function,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n    };\n\n    vm->retval = *types[value->type];\n\n    return sizeof(njs_vmcode_2addr_t);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    };\n",
        "src_path": "d457c9545e7e71ebb5c0479eb16b9d33175855e2___njs_vmcode.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/d457c9545e7e71ebb5c0479eb16b9d33175855e2",
        "commit_msg": "Added missing element in typeof table for DataView() type.\n\nPreviously, typeof operation for DataView object resulted\nin out of bounds array accessing.\n\nThis fixes #450 issue on Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -6390,6 +6390,9 @@ static njs_unit_test_t  njs_test[] =\n     { njs_str(\"(new DataView(new ArrayBuffer(3)))\"),\n       njs_str(\"[object DataView]\") },\n \n+    { njs_str(\"var x = new ArrayBuffer(3); [typeof x, typeof new DataView(x)]\"),\n+      njs_str(\"object,object\") },\n+\n     { njs_str(\"(new DataView(new ArrayBuffer(3))).buffer\"),\n       njs_str(\"[object ArrayBuffer]\") },\n "
            }
        ],
        "error_msg": "\n"
    },
    "f65981b0b8fcf02d69a40bc934803c25c9f607ab___njs_vmcode.c": {
        "prefix": "static njs_jump_off_t\nnjs_vmcode_array(njs_vm_t *vm, u_char *pc)\n{\n    uint32_t            length;\n    njs_array_t         *array;\n    njs_value_t         *value;\n    njs_vmcode_array_t  *code;\n\n    code = (njs_vmcode_array_t *) pc;\n\n    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);\n\n    if (njs_fast_path(array != NULL)) {\n\n        if (code->ctor) {\n            /* Array of the form [,,,], [1,,]. */\n",
        "suffix": "        } else {\n            /* Array of the form [], [,,1], [1,2,3]. */\n            array->length = 0;\n        }\n\n        njs_set_array(&vm->retval, array);\n\n        return sizeof(njs_vmcode_array_t);\n    }\n\n    return NJS_ERROR;\n}\n",
        "start": 1042,
        "end": 1078,
        "buggy": "static njs_jump_off_t\nnjs_vmcode_array(njs_vm_t *vm, u_char *pc)\n{\n    uint32_t            length;\n    njs_array_t         *array;\n    njs_value_t         *value;\n    njs_vmcode_array_t  *code;\n\n    code = (njs_vmcode_array_t *) pc;\n\n    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);\n\n    if (njs_fast_path(array != NULL)) {\n\n        if (code->ctor) {\n            /* Array of the form [,,,], [1,,]. */\n            value = array->start;\n            length = array->length;\n\n            do {\n                njs_set_invalid(value);\n                value++;\n                length--;\n            } while (length != 0);\n\n        } else {\n            /* Array of the form [], [,,1], [1,2,3]. */\n            array->length = 0;\n        }\n\n        njs_set_array(&vm->retval, array);\n\n        return sizeof(njs_vmcode_array_t);\n    }\n\n    return NJS_ERROR;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            value = array->start;\n            length = array->length;\n\n            do {\n                njs_set_invalid(value);\n                value++;\n                length--;\n            } while (length != 0);\n\n",
        "src_path": "f65981b0b8fcf02d69a40bc934803c25c9f607ab___njs_vmcode.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/f65981b0b8fcf02d69a40bc934803c25c9f607ab",
        "commit_msg": "Fixed allocation of large array literals.\n\nPreviously, allocation of large array literals may result in\nnull-pointer dereference. The reason is that njs_array_alloc() may\nreturn a slow array when size is large enough, but the instruction\ncode assumes that array is always flat.\n\nThe fix is to check fast_array flag before accessing array->start.\n\nThis closes #473 issue on Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -13154,6 +13154,10 @@ static njs_unit_test_t  njs_test[] =\n     { njs_str(\"(new Function('return 5' + '** 1'.repeat(2**13)))()\"),\n       njs_str(\"5\") },\n \n+    { njs_str(\"var a = (new Function('return [' + ','.repeat(2**16) + ']'))();\"\n+\t\t\t  \"njs.dump(a)\"),\n+      njs_str(\"[<65536 empty items>]\") },\n+\n     { njs_str(\"(new Function('var a = 7; return a' + '= a'.repeat(2**13)))()\"),\n       njs_str(\"7\") },\n "
            }
        ],
        "error_msg": "\n"
    },
    "2e00e95473861846aa8538be87db07699d9f676d___njs_array.c": {
        "prefix": "static njs_int_t\nnjs_array_prototype_splice(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t      i, n, start, length, items, delta, delete;\n    njs_int_t    ret;\n    njs_value_t  *this, value, del_object;\n    njs_array_t  *array, *deleted;\n\n    this = njs_argument(args, 0);\n\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_object_length(vm, this, &length);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    start = (start < 0) ? njs_max(length + start, 0) : njs_min(start, length);\n\n    items = 0;\n    delete = 0;\n\n    if (nargs == 2) {\n        delete = length - start;\n\n    } else if (nargs > 2) {\n        items = nargs - 3;\n\n        ret = njs_value_to_integer(vm, njs_arg(args, nargs, 2), &delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n\n        delete = njs_min(njs_max(delete, 0), length - start);\n    }\n\n    delta = items - delete;\n\n    if (njs_slow_path((length + delta) > NJS_MAX_LENGTH)) {\n        njs_type_error(vm, \"Invalid length\");\n        return NJS_ERROR;\n    }\n\n    /* TODO: ArraySpeciesCreate(). */\n\n    deleted = njs_array_alloc(vm, 0, delete, 0);\n    if (njs_slow_path(deleted == NULL)) {\n        return NJS_ERROR;\n    }\n\n    if (njs_fast_path(njs_is_fast_array(this) && deleted->object.fast_array)) {\n        array = njs_array(this);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            deleted->start[i] = array->start[n];\n        }\n\n    } else {\n        njs_set_array(&del_object, deleted);\n\n        for (i = 0, n = start; i < delete; i++, n++) {\n            ret = njs_value_property_i64(vm, this, n, &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n\n            if (ret == NJS_OK) {\n                /* TODO:  CreateDataPropertyOrThrow(). */\n                ret = njs_value_property_i64_set(vm, &del_object, i, &value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return ret;\n                }\n",
        "suffix": "        }\n\n        ret = njs_object_length_set(vm, &del_object, delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    if (njs_fast_path(njs_is_fast_array(this))) {\n        array = njs_array(this);\n\n        if (delta != 0) {\n            /*\n             * Relocate the rest of items.\n             * Index of the first item is in \"n\".\n             */\n            if (delta > 0) {\n                ret = njs_array_expand(vm, array, 0, delta);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n            }\n\n            ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                        array->length - (start + delete), 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n            array->length += delta;\n        }\n\n        /* Copy new items. */\n\n        if (items > 0) {\n            memcpy(&array->start[start], &args[3],\n                   items * sizeof(njs_value_t));\n        }\n\n    } else {\n\n       if (delta != 0) {\n           ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                       length - (start + delete), delta < 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n            for (i = length - 1; i >= length + delta; i--) {\n                ret = njs_value_property_i64_delete(vm, this, i, NULL);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return NJS_ERROR;\n                }\n            }\n       }\n\n        /* Copy new items. */\n\n        for (i = 3, n = start; items-- > 0; i++, n++) {\n            ret = njs_value_property_i64_set(vm, this, n, &args[i]);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n        }\n\n        ret = njs_object_length_set(vm, this, length + delta);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    njs_set_array(&vm->retval, deleted);\n\n    return NJS_OK;\n}\n",
        "start": 1207,
        "end": 1362,
        "buggy": "static njs_int_t\nnjs_array_prototype_splice(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t      i, n, start, length, items, delta, delete;\n    njs_int_t    ret;\n    njs_value_t  *this, value, del_object;\n    njs_array_t  *array, *deleted;\n\n    this = njs_argument(args, 0);\n\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_object_length(vm, this, &length);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    start = (start < 0) ? njs_max(length + start, 0) : njs_min(start, length);\n\n    items = 0;\n    delete = 0;\n\n    if (nargs == 2) {\n        delete = length - start;\n\n    } else if (nargs > 2) {\n        items = nargs - 3;\n\n        ret = njs_value_to_integer(vm, njs_arg(args, nargs, 2), &delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n\n        delete = njs_min(njs_max(delete, 0), length - start);\n    }\n\n    delta = items - delete;\n\n    if (njs_slow_path((length + delta) > NJS_MAX_LENGTH)) {\n        njs_type_error(vm, \"Invalid length\");\n        return NJS_ERROR;\n    }\n\n    /* TODO: ArraySpeciesCreate(). */\n\n    deleted = njs_array_alloc(vm, 0, delete, 0);\n    if (njs_slow_path(deleted == NULL)) {\n        return NJS_ERROR;\n    }\n\n    if (njs_fast_path(njs_is_fast_array(this) && deleted->object.fast_array)) {\n        array = njs_array(this);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            deleted->start[i] = array->start[n];\n        }\n\n    } else {\n        njs_set_array(&del_object, deleted);\n\n        for (i = 0, n = start; i < delete; i++, n++) {\n            ret = njs_value_property_i64(vm, this, n, &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n\n            if (ret == NJS_OK) {\n                /* TODO:  CreateDataPropertyOrThrow(). */\n                ret = njs_value_property_i64_set(vm, &del_object, i, &value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return ret;\n                }\n            }\n        }\n\n        ret = njs_object_length_set(vm, &del_object, delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    if (njs_fast_path(njs_is_fast_array(this))) {\n        array = njs_array(this);\n\n        if (delta != 0) {\n            /*\n             * Relocate the rest of items.\n             * Index of the first item is in \"n\".\n             */\n            if (delta > 0) {\n                ret = njs_array_expand(vm, array, 0, delta);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n            }\n\n            ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                        array->length - (start + delete), 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n            array->length += delta;\n        }\n\n        /* Copy new items. */\n\n        if (items > 0) {\n            memcpy(&array->start[start], &args[3],\n                   items * sizeof(njs_value_t));\n        }\n\n    } else {\n\n       if (delta != 0) {\n           ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                       length - (start + delete), delta < 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n            for (i = length - 1; i >= length + delta; i--) {\n                ret = njs_value_property_i64_delete(vm, this, i, NULL);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return NJS_ERROR;\n                }\n            }\n       }\n\n        /* Copy new items. */\n\n        for (i = 3, n = start; items-- > 0; i++, n++) {\n            ret = njs_value_property_i64_set(vm, this, n, &args[i]);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n        }\n\n        ret = njs_object_length_set(vm, this, length + delta);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    njs_set_array(&vm->retval, deleted);\n\n    return NJS_OK;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            }\n",
        "src_path": "2e00e95473861846aa8538be87db07699d9f676d___njs_array.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/2e00e95473861846aa8538be87db07699d9f676d",
        "commit_msg": "Fixed Array.prototype.slice() with slow \"this\" argument.\n\nPreviously, when \"this\" argument was not a fast array, but the \"deleted\" array\nwas a fast array, the \"deleted\" array may be left in uninitialized state if\n\"this\" argument had gaps.\n\nThis fix is to ensure that \"deleted\" is properly initialized.\n\nThis fixes #485 issue on Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -4869,6 +4869,15 @@ static njs_unit_test_t  njs_test[] =\n               \"Array.prototype.splice.call(obj, 2**53-2, 0, 'C');\"),\n       njs_str(\"TypeError: Invalid length\") },\n \n+    { njs_str(\"var a = {1: 'B', length: 2};\"\n+              \"Array.prototype.splice.call(a, 0)\"),\n+      njs_str(\",B\") },\n+\n+    { njs_str(\"var a = new Uint8Array();\"\n+              \"a.__proto__ = [1,2,3];\"\n+              \"a.splice(0)\"),\n+      njs_str(\",,\") },\n+\n     { njs_str(\"var a = []; a.reverse()\"),\n       njs_str(\"\") },\n "
            }
        ],
        "error_msg": "\n"
    },
    "81af26364c21c196dd21fb5e14c7fa9ce7debd17___njs_array.c": {
        "prefix": "njs_int_t\nnjs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)\n{\n    uint32_t           i, length;\n    njs_value_t        index, value;\n    njs_object_prop_t  *prop;\n\n",
        "suffix": "    array->object.fast_array = 0;\n\n    length = array->length;\n\n    for (i = 0; i < length; i++) {\n        if (njs_is_valid(&array->start[i])) {\n            njs_uint32_to_string(&index, i);\n            prop = njs_object_property_add(vm, &value, &index, 0);\n            if (njs_slow_path(prop == NULL)) {\n                return NJS_ERROR;\n            }\n\n            prop->value = array->start[i];\n        }\n    }\n\n    /* GC: release value. */\n\n    njs_mp_free(vm->mem_pool, array->start);\n    array->start = NULL;\n\n    return NJS_OK;\n}\n",
        "start": 138,
        "end": 168,
        "buggy": "njs_int_t\nnjs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)\n{\n    uint32_t           i, length;\n    njs_value_t        index, value;\n    njs_object_prop_t  *prop;\n\n    njs_set_array(&value, array);\n    array->object.fast_array = 0;\n\n    length = array->length;\n\n    for (i = 0; i < length; i++) {\n        if (njs_is_valid(&array->start[i])) {\n            njs_uint32_to_string(&index, i);\n            prop = njs_object_property_add(vm, &value, &index, 0);\n            if (njs_slow_path(prop == NULL)) {\n                return NJS_ERROR;\n            }\n\n            prop->value = array->start[i];\n        }\n    }\n\n    /* GC: release value. */\n\n    njs_mp_free(vm->mem_pool, array->start);\n    array->start = NULL;\n\n    return NJS_OK;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    njs_set_array(&value, array);\n",
        "src_path": "81af26364c21c196dd21fb5e14c7fa9ce7debd17___njs_array.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/81af26364c21c196dd21fb5e14c7fa9ce7debd17",
        "commit_msg": "Fixed Object.defineProperty() when a recursive descriptor is provided.\n\nThis closes #481 issue on Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -13837,6 +13837,16 @@ static njs_unit_test_t  njs_test[] =\n               \"d.enumerable && d.writable && d.configurable\"),\n       njs_str(\"true\") },\n \n+    { njs_str(\"const arr = [1,2];\"\n+              \"function f(arg) {\"\n+              \"        const desc = {get: arg};\"\n+              \"        Object.defineProperty(desc, 'set', desc);\"\n+              \"        Object.defineProperty(arr, 1, desc);\"\n+              \"}\"\n+              \"f(f);\"\n+              \"njs.dump(arr)\"),\n+      njs_str(\"[1,'[Getter]']\") },\n+\n     { njs_str(\"Object.defineProperties()\"),\n       njs_str(\"TypeError: Object.defineProperties is called on non-object\") },\n "
            }
        ],
        "error_msg": "\n"
    },
    "5c6130a2a0b4c41ab415f6b8992aa323636338b9___njs_typed_array.c": {
        "prefix": "njs_int_t\nnjs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n\n    njs_typed_array_prop_set(vm, array, index, num);\n\n",
        "suffix": "}\n",
        "start": 685,
        "end": 708,
        "buggy": "njs_int_t\nnjs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n\n    njs_typed_array_prop_set(vm, array, index, num);\n\n    njs_set_number(setval, num);\n\n    return NJS_OK;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    njs_set_number(setval, num);\n\n    return NJS_OK;\n",
        "src_path": "5c6130a2a0b4c41ab415f6b8992aa323636338b9___njs_typed_array.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/5c6130a2a0b4c41ab415f6b8992aa323636338b9",
        "commit_msg": "Fixed Array.prototype.fill() for typed-arrays.\n\nThis closes #478 issue on Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -5409,6 +5409,9 @@ static njs_unit_test_t  njs_test[] =\n                  \"Array.prototype.fill.call(o, 2).a\"),\n       njs_str(\"4\") },\n \n+    { njs_str(\"Array.prototype.fill.call(new Int32Array(1))\"),\n+      njs_str(\"0\") },\n+\n     { njs_str(\"ArrayBuffer()\"),\n       njs_str(\"TypeError: Constructor ArrayBuffer requires 'new'\") },\n "
            }
        ],
        "error_msg": "\n"
    },
    "1bbaa929b77113532785c408dd1b41cd0521ffc8___log_blackbox.c": {
        "prefix": "static void\n_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\n\tfn_size = strlen(cs->function) + 1;\n\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\n\tif (chunk == NULL) {\n\t\t/* something bad has happened. abort blackbox logging */\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* line number */\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* tags */\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* log level/priority */\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\n\t/* function name */\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\n\t/* timestamp */\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\n\t/* log message length */\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\n\t/* log message */\n",
        "suffix": "\n\t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */\n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\n\tactual_size += msg_len;\n\n\t/* now that we know the length, write it\n\t */\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}\n",
        "start": 54,
        "end": 130,
        "buggy": "static void\n_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\n\tfn_size = strlen(cs->function) + 1;\n\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\n\tif (chunk == NULL) {\n\t\t/* something bad has happened. abort blackbox logging */\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* line number */\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* tags */\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* log level/priority */\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\n\t/* function name */\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\n\t/* timestamp */\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\n\t/* log message length */\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\n\t/* log message */\n\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);\n\tif (msg_len >= max_size) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n\n\t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */\n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\n\tactual_size += msg_len;\n\n\t/* now that we know the length, write it\n\t */\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);\n\tif (msg_len >= max_size) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n",
        "src_path": "1bbaa929b77113532785c408dd1b41cd0521ffc8___log_blackbox.c",
        "uri": "https://api.github.com/repos/ClusterLabs/libqb/commits/1bbaa929b77113532785c408dd1b41cd0521ffc8",
        "commit_msg": "log: fix potential overflow with long log messages (#490)\n\nqb_vsnprintf_serialize was called with 'max_size' as the\r\nlimiting number for the length of the formatted log\r\nmessage. But the buffer also needs to contain the\r\nlog header (given by 'actual_size'), so we now pass\r\n't->max_line_length' as the maximum length of the\r\nformatted log message to limit space to the actual \r\nbytes left\r\n\r\nAlso added error checks to the blackbox calls at\r\nthe end of the test, as these now provide a proper\r\ntest that the BB is functioning. Before they were\r\nmasking failures.",
        "test_func_diff": [
            {
                "fn": "tests/check_log.c",
                "patch": "@@ -832,8 +832,10 @@ START_TEST(test_log_long_msg)\n \t\tqb_log(LOG_INFO, \"Message %d %d - %s\", lpc, lpc%600, buffer);\n \t}\n \n-        qb_log_blackbox_write_to_file(\"blackbox.dump\");\n-        qb_log_blackbox_print_from_file(\"blackbox.dump\");\n+        rc = qb_log_blackbox_write_to_file(\"blackbox.dump\");\n+\tck_assert_int_gt(rc, 0);\n+        rc = qb_log_blackbox_print_from_file(\"blackbox.dump\");\n+\tck_assert_int_le(rc, 0);\n \tunlink(\"blackbox.dump\");\n \tqb_log_fini();\n }"
            }
        ],
        "error_msg": "Running suite(s): logging\nthr_send_logs_1\nthr_send_logs_1\nthr_send_logs_2\nthr_send_logs_2\n93%: Checks: 16, Failures: 1, Errors: 0\ncheck_log.c:131:P:va_serialize:test_va_serialize:0: Passed\ncheck_log.c:189:P:log_stupid_inputs:test_log_stupid_inputs:0: Passed\ncheck_log.c:597:P:log_basic:test_log_basic:0: Passed\ncheck_log.c:678:P:log_format:test_log_format:0: Passed\ncheck_log.c:716:P:log_enable:test_log_enable:0: Passed\ncheck_log.c:783:P:log_threads:test_log_threads:0: Passed\ncheck_log.c:836:F:log_long_msg:test_log_long_msg:0: Assertion 'rc > 0' failed: rc == -2, 0 == 0\ncheck_log.c:295:P:log_filter_fn:test_log_filter_fn:0: Passed\ncheck_log.c:880:P:threaded_logging:test_threaded_logging:0: Passed\ncheck_log.c:432:P:line_length:test_line_length:0: Passed\ncheck_log.c:340:P:file_logging:test_file_logging:0: Passed\ncheck_log.c:914:P:threaded_logging_bad_sched_params:test_threaded_logging_bad_sched_params:0: Passed\ncheck_log.c:374:P:timestamps:test_timestamps:0: Passed\ncheck_log.c:971:P:extended_information:test_extended_information:0: Passed\ncheck_log.c:1009:P:zero_tags:test_zero_tags:0: Passed\ncheck_log.c:1083:P:syslog:test_syslog:0: Passed\n"
    },
    "3cb0f914d6427073f262e1b2b5fd973e3043cdf7___ytnef.c": {
        "prefix": "int TNEFParse(TNEFStruct *TNEF) {\n  WORD key;\n  DWORD type;\n  DWORD size;\n  DWORD signature;\n  BYTE *data;\n  WORD checksum, header_checksum;\n  int i;\n\n  if (TNEF->IO.ReadProc == NULL) {\n    printf(\"ERROR: Setup incorrectly: No ReadProc\\n\");\n    return YTNEF_INCORRECT_SETUP;\n  }\n\n  if (TNEF->IO.InitProc != NULL) {\n    DEBUG(TNEF->Debug, 2, \"About to initialize\");\n    if (TNEF->IO.InitProc(&TNEF->IO) != 0) {\n      return YTNEF_CANNOT_INIT_DATA;\n    }\n    DEBUG(TNEF->Debug, 2, \"Initialization finished\");\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Signature\");\n  if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(DWORD), 1, &signature) < 1) {\n    printf(\"ERROR: Error reading signature\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_ERROR_READING_DATA;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Checking Signature\");\n  if (TNEFCheckForSignature(signature) < 0) {\n    printf(\"ERROR: Signature does not match. Not TNEF.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NOT_TNEF_STREAM;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Key.\");\n\n  if (TNEFGetKey(TNEF, &key) < 0) {\n    printf(\"ERROR: Unable to retrieve key.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NO_KEY;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Starting Full Processing.\");\n\n  while (TNEFGetHeader(TNEF, &type, &size) == 0) {\n    DEBUG2(TNEF->Debug, 2, \"Header says type=0x%X, size=%u\", type, size);\n    DEBUG2(TNEF->Debug, 2, \"Header says type=%u, size=%u\", type, size);\n",
        "suffix": "    ALLOCCHECK(data);\n    if (TNEFRawRead(TNEF, data, size, &header_checksum) < 0) {\n      printf(\"ERROR: Unable to read data.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    if (TNEFRawRead(TNEF, (BYTE *)&checksum, 2, NULL) < 0) {\n      printf(\"ERROR: Unable to read checksum.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    checksum = SwapWord((BYTE *)&checksum, sizeof(WORD));\n    if (checksum != header_checksum) {\n      printf(\"ERROR: Checksum mismatch. Data corruption?:\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_BAD_CHECKSUM;\n    }\n    for (i = 0; i < (sizeof(TNEFList) / sizeof(TNEFHandler)); i++) {\n      if (TNEFList[i].id == type) {\n        if (TNEFList[i].handler != NULL) {\n          if (TNEFList[i].handler(TNEF, i, (char*)data, size) < 0) {\n            free(data);\n            if (TNEF->IO.CloseProc != NULL) {\n              TNEF->IO.CloseProc(&TNEF->IO);\n            }\n            return YTNEF_ERROR_IN_HANDLER;\n          } else {\n            //  Found our handler and processed it.  now time to get out\n            break;\n          }\n        } else {\n          DEBUG2(TNEF->Debug, 1, \"No handler for %s: %u bytes\",\n                 TNEFList[i].name, size);\n        }\n      }\n    }\n\n    free(data);\n  }\n\n  if (TNEF->IO.CloseProc != NULL) {\n    TNEF->IO.CloseProc(&TNEF->IO);\n  }\n  return 0;\n\n}\n",
        "start": 1095,
        "end": 1205,
        "buggy": "int TNEFParse(TNEFStruct *TNEF) {\n  WORD key;\n  DWORD type;\n  DWORD size;\n  DWORD signature;\n  BYTE *data;\n  WORD checksum, header_checksum;\n  int i;\n\n  if (TNEF->IO.ReadProc == NULL) {\n    printf(\"ERROR: Setup incorrectly: No ReadProc\\n\");\n    return YTNEF_INCORRECT_SETUP;\n  }\n\n  if (TNEF->IO.InitProc != NULL) {\n    DEBUG(TNEF->Debug, 2, \"About to initialize\");\n    if (TNEF->IO.InitProc(&TNEF->IO) != 0) {\n      return YTNEF_CANNOT_INIT_DATA;\n    }\n    DEBUG(TNEF->Debug, 2, \"Initialization finished\");\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Signature\");\n  if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(DWORD), 1, &signature) < 1) {\n    printf(\"ERROR: Error reading signature\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_ERROR_READING_DATA;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Checking Signature\");\n  if (TNEFCheckForSignature(signature) < 0) {\n    printf(\"ERROR: Signature does not match. Not TNEF.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NOT_TNEF_STREAM;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Key.\");\n\n  if (TNEFGetKey(TNEF, &key) < 0) {\n    printf(\"ERROR: Unable to retrieve key.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NO_KEY;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Starting Full Processing.\");\n\n  while (TNEFGetHeader(TNEF, &type, &size) == 0) {\n    DEBUG2(TNEF->Debug, 2, \"Header says type=0x%X, size=%u\", type, size);\n    DEBUG2(TNEF->Debug, 2, \"Header says type=%u, size=%u\", type, size);\n    data = calloc(size, sizeof(BYTE));\n    ALLOCCHECK(data);\n    if (TNEFRawRead(TNEF, data, size, &header_checksum) < 0) {\n      printf(\"ERROR: Unable to read data.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    if (TNEFRawRead(TNEF, (BYTE *)&checksum, 2, NULL) < 0) {\n      printf(\"ERROR: Unable to read checksum.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    checksum = SwapWord((BYTE *)&checksum, sizeof(WORD));\n    if (checksum != header_checksum) {\n      printf(\"ERROR: Checksum mismatch. Data corruption?:\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_BAD_CHECKSUM;\n    }\n    for (i = 0; i < (sizeof(TNEFList) / sizeof(TNEFHandler)); i++) {\n      if (TNEFList[i].id == type) {\n        if (TNEFList[i].handler != NULL) {\n          if (TNEFList[i].handler(TNEF, i, (char*)data, size) < 0) {\n            free(data);\n            if (TNEF->IO.CloseProc != NULL) {\n              TNEF->IO.CloseProc(&TNEF->IO);\n            }\n            return YTNEF_ERROR_IN_HANDLER;\n          } else {\n            //  Found our handler and processed it.  now time to get out\n            break;\n          }\n        } else {\n          DEBUG2(TNEF->Debug, 1, \"No handler for %s: %u bytes\",\n                 TNEFList[i].name, size);\n        }\n      }\n    }\n\n    free(data);\n  }\n\n  if (TNEF->IO.CloseProc != NULL) {\n    TNEF->IO.CloseProc(&TNEF->IO);\n  }\n  return 0;\n\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    data = calloc(size, sizeof(BYTE));\n",
        "src_path": "3cb0f914d6427073f262e1b2b5fd973e3043cdf7___ytnef.c",
        "uri": "https://api.github.com/repos/Yeraze/ytnef/commits/3cb0f914d6427073f262e1b2b5fd973e3043cdf7",
        "commit_msg": "BugFix - Potential OOB with Fields of Size 0\n\nThanks to @hannob for contributing a malformed TNEF stream with\na Version field of size 0.  Now such files will return an error\nindicating invalid data.",
        "test_func_diff": [
            {
                "fn": "test-data/test.sh",
                "patch": "@@ -21,3 +21,5 @@ diff results data\n ../ytnefprint/ytnefprint ./winmail.dat  | grep -A 1 PR_RTF_SYNC_BODY_CRC     | grep 872404792\n ../ytnefprint/ytnefprint ./winmail.dat  | grep -A 1 PR_RTF_SYNC_BODY_COUNT   | grep 90\n ../ytnefprint/ytnefprint ./winmail.dat  | grep -A 18 PR_RTF_COMPRESSED       | grep '\\pard Casdasdfasdfasd\\\\par'\n+\n+../ytnefprint/ytnefprint ./ytnef-oob-TNEFVersion-SwapWord | grep 'ERROR: Field with size of 0'"
            }
        ],
        "error_msg": "==487455==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000012 at pc 0x7f43397732eb bp 0x7fff4bd62f50 sp 0x7fff4bd62f48\nREAD of size 1 at 0x602000000012 thread T0\n    #0 0x7f43397732ea in SwapWord /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:153:28\n    #1 0x7f4339772c38 in TNEFVersion /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:338:11\n    #2 0x7f433978002d in TNEFParse /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:1180:15\n    #3 0x7f433977ead6 in TNEFParseFile /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:1042:10\n    #4 0x557ab462d4f0 in main /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/ytnefprint/main.c:80:9\n    #5 0x7f43393e2082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #6 0x557ab455a35d in _start (/mnt/local/home_dir/wj_code/dl_code/out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/ytnefprint/.libs/ytnefprint+0x1f35d)\n\n0x602000000012 is located 1 bytes after 1-byte region [0x602000000010,0x602000000011)\nallocated by thread T0 here:\n    #0 0x557ab45f2b08 in __interceptor_calloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:77:3\n    #1 0x7f433977f9f1 in TNEFParse /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:1150:12\n    #2 0x7f433977ead6 in TNEFParseFile /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:1042:10\n    #3 0x557ab462d4f0 in main /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/ytnefprint/main.c:80:9\n    #4 0x7f43393e2082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:153:28 in SwapWord\nShadow bytes around the buggy address:\n  0x601ffffffd80: 00 "
    },
    "864f5d4c127def386dd5cc926ad96934b297f04e___UriQuery.c": {
        "prefix": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\t\t\t\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t} else {\n\t\t\tURI_CHAR * afterKey;\n\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\n\t\t\t/* Copy key */\n\t\t\tif (firstItem == URI_TRUE) {\n",
        "suffix": "\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\tafterKey = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\twrite += (afterKey - write);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tURI_CHAR * afterValue;\n\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\tafterValue = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t\twrite += (afterValue - write);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n",
        "start": 184,
        "end": 262,
        "buggy": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\t\t\t\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t} else {\n\t\t\tURI_CHAR * afterKey;\n\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\n\t\t\t/* Copy key */\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\tafterKey = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\twrite += (afterKey - write);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tURI_CHAR * afterValue;\n\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\tafterValue = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t\twrite += (afterValue - write);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\t\tfirstItem = URI_FALSE;\n",
        "src_path": "864f5d4c127def386dd5cc926ad96934b297f04e___UriQuery.c",
        "uri": "https://api.github.com/repos/uriparser/uriparser/commits/864f5d4c127def386dd5cc926ad96934b297f04e",
        "commit_msg": "UriQuery.c: Fix out-of-bounds-write in ComposeQuery and ...Ex\n\nReported by Google Autofuzz team",
        "test_func_diff": [
            {
                "fn": "test/test.cpp",
                "patch": "@@ -104,6 +104,7 @@ class UriSuite : public Suite {\n \t\tTEST_ADD(UriSuite::testQueryList)\n \t\tTEST_ADD(UriSuite::testQueryListPair)\n \t\tTEST_ADD(UriSuite::testQueryDissection_Bug3590761)\n+\t\tTEST_ADD(UriSuite::testQueryCompositionMathWrite_GoogleAutofuzz113244572)\n \t\tTEST_ADD(UriSuite::testFreeCrash_Bug20080827)\n \t\tTEST_ADD(UriSuite::testParseInvalid_Bug16)\n \t\tTEST_ADD(UriSuite::testRangeComparison)\n@@ -1749,6 +1750,37 @@ Rule                                | Example | hostSet | absPath | emptySeg\n \t\turiFreeQueryListA(queryList);\n \t}\n \n+\tvoid testQueryCompositionMathWrite_GoogleAutofuzz113244572() {\n+\t\tUriQueryListA second = { .key = \"\\x11\", .value = NULL, .next = NULL };\n+\t\tUriQueryListA first = { .key = \"\\x01\", .value = \"\\x02\", .next = &second };\n+\n+\t\tconst UriBool spaceToPlus = URI_TRUE;\n+\t\tconst UriBool normalizeBreaks = URI_FALSE;  /* for factor 3 but 6 */\n+\n+\t\tconst int charsRequired = (3 + 1 + 3) + 1 + (3);\n+\n+\t\t{\n+\t\t\t// Minimum space to hold everything fine\n+\t\t\tconst char * const expected = \"%01=%02\" \"&\" \"%11\";\n+\t\t\tchar dest[charsRequired + 1];\n+\t\t\tint charsWritten;\n+\t\t\tTEST_ASSERT(uriComposeQueryExA(dest, &first, sizeof(dest),\n+\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n+\t\t\t\t== URI_SUCCESS);\n+\t\t\tTEST_ASSERT(! strcmp(dest, expected));\n+\t\t\tTEST_ASSERT(charsWritten == strlen(expected) + 1);\n+\t\t}\n+\n+\t\t{\n+\t\t\t// Previous math failed to take ampersand into account\n+\t\t\tchar dest[charsRequired + 1 - 1];\n+\t\t\tint charsWritten;\n+\t\t\tTEST_ASSERT(uriComposeQueryExA(dest, &first, sizeof(dest),\n+\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n+\t\t\t\t== URI_ERROR_OUTPUT_TOO_LARGE);\n+\t\t}\n+\t}\n+\n \tvoid testFreeCrash_Bug20080827() {\n \t\tchar const * const sourceUri = \"abc\";\n \t\tchar const * const baseUri = \"http://www.example.org/\";"
            }
        ],
        "error_msg": "UriSuite: 0/56\nUriSuite: 1/56\nUriSuite: 2/56\nUriSuite: 3/56\nUriSuite: 4/56\nUriSuite: 5/56\nUriSuite: 6/56\nUriSuite: 7/56\nUriSuite: 8/56\nUriSuite: 9/56\nUriSuite: 10/56\nUriSuite: 11/56\nUriSuite: 12/56\nUriSuite: 13/56\nUriSuite: 14/56\nUriSuite: 15/56\nUriSuite: 16/56\nUriSuite: 17/56\nUriSuite: 18/56\nUriSuite: 19/56\nUriSuite: 20/56\nUriSuite: 21/56\nUriSuite: 22/56\nUriSuite: 23/56\nUriSuite: 24/56\nUriSuite: 25/56\nUriSuite: 26/56\nUriSuite: 27/56\nUriSuite: 28/56\nUriSuite: 29/56\nUriSuite: 30/56\nUriSuite: 31/56\nUriSuite: 32/56\nUriSuite: 33/56\nUriSuite: 34/56\nUriSuite: 35/56\nUriSuite: 36/56\nUriSuite: 37/56\nUriSuite: 38/56\nUriSuite: 39/56\nUriSuite: 40/56\nUriSuite: 41/56\nUriSuite: 42/56\nUriSuite: 43/56\nUriSuite: 44/56\nUriSuite: 45/56\nUriSuite: 46/56\nUriSuite: 47/56\nUriSuite: 48/56\nUriSuite: 49/56\nUriSuite: 50/56\nUriSuite: 51/56\nUriSuite: 52/56\nUriSuite: 53/56\nUriSuite: 54/56\nUriSuite: 55/56\nUriSuite: 56/56\nUriSuite: 56/56, 98% correct in 0.000462 seconds\n\tTest:    testQueryCompositionMathWrite_GoogleAutofuzz113244572\n\tSuite:   UriSuite\n\tFile:    test/test.cpp\n\tLine:    1780\n\tMessage: uriComposeQueryExA(dest, &first, sizeof(dest), &charsWritten, spaceToPlus, normalizeBreaks) == URI_ERROR_OUTPUT_TOO_LARGE\n\nFourSuite: 0/7\nFourSuite: 1/7\nFourSuite: 2/7\nFourSuite: 3/7\nFourSuite: 4/7\nFourSuite: 5/7\nFourSuite: 6/7\nFourSuite: 7/7\nFourSuite: 7/7, 100% correct in 0.000379 seconds\nVersionSuite: 0/1\nbytes_printed: 5\nVersionSuite: 1/1\nVersionSuite: 1/1, 100% correct in 0.000012 seconds\nTotal: 64 tests, 98% correct in 0.000853 seconds\nFAIL test/uriparser_test (exit status: 1)\n"
    }
}