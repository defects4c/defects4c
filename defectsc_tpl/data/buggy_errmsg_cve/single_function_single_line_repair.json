{
    "1890d59905414ab84a35892b2e45833654aa5c13___tool_writeout.c": {
        "prefix": "void ourWriteOut(CURL *curl, struct OutStruct *outs, const char *writeinfo)\n{\n  FILE *stream = stdout;\n  const char *ptr = writeinfo;\n  char *stringp = NULL;\n  long longinfo;\n  double doubleinfo;\n\n  while(ptr && *ptr) {\n",
        "suffix": "      if('%' == ptr[1]) {\n        /* an escaped %-letter */\n        fputc('%', stream);\n        ptr += 2;\n      }\n      else {\n        /* this is meant as a variable to output */\n        char *end;\n        char keepit;\n        int i;\n        if('{' == ptr[1]) {\n          bool match = FALSE;\n          end = strchr(ptr, '}');\n          ptr += 2; /* pass the % and the { */\n          if(!end) {\n            fputs(\"%{\", stream);\n            continue;\n          }\n          keepit = *end;\n          *end = 0; /* zero terminate */\n          for(i = 0; replacements[i].name; i++) {\n            if(curl_strequal(ptr, replacements[i].name)) {\n              match = TRUE;\n              switch(replacements[i].id) {\n              case VAR_EFFECTIVE_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_HTTP_CODE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HTTP_CODE_PROXY:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE,\n                                     &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HEADER_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REQUEST_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_NUM_CONNECTS:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_COUNT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_TOTAL_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_NAMELOOKUP_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_CONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_APPCONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_PRETRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_STARTTRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_SIZE_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SIZE_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SPEED_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_SPEED_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_CONTENT_TYPE:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_FTP_ENTRY_PATH:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_REDIRECT_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_PROXY_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PROXY_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_EFFECTIVE_FILENAME:\n                if(outs->filename)\n                  fprintf(stream, \"%s\", outs->filename);\n                break;\n              case VAR_PRIMARY_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_PRIMARY_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_LOCAL_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_LOCAL_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_HTTP_VERSION:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_VERSION,\n                                     &longinfo)) {\n                  const char *version = \"0\";\n                  switch(longinfo) {\n                  case CURL_HTTP_VERSION_1_0:\n                    version = \"1.0\";\n                    break;\n                  case CURL_HTTP_VERSION_1_1:\n                    version = \"1.1\";\n                    break;\n                  case CURL_HTTP_VERSION_2_0:\n                    version = \"2\";\n                    break;\n                  }\n\n                  fprintf(stream, version);\n                }\n                break;\n              case VAR_SCHEME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SCHEME,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              default:\n                break;\n              }\n              break;\n            }\n          }\n          if(!match) {\n            fprintf(stderr, \"curl: unknown --write-out variable: '%s'\\n\", ptr);\n          }\n          ptr = end + 1; /* pass the end */\n          *end = keepit;\n        }\n        else {\n          /* illegal syntax, then just output the characters that are used */\n          fputc('%', stream);\n          fputc(ptr[1], stream);\n          ptr += 2;\n        }\n      }\n    }\n    else if('\\\\' == *ptr) {\n      switch(ptr[1]) {\n      case 'r':\n        fputc('\\r', stream);\n        break;\n      case 'n':\n        fputc('\\n', stream);\n        break;\n      case 't':\n        fputc('\\t', stream);\n        break;\n      default:\n        /* unknown, just output this */\n        fputc(*ptr, stream);\n        fputc(ptr[1], stream);\n        break;\n      }\n      ptr += 2;\n    }\n    else {\n      fputc(*ptr, stream);\n      ptr++;\n    }\n  }\n\n}\n",
        "start": 107,
        "end": 369,
        "buggy": "void ourWriteOut(CURL *curl, struct OutStruct *outs, const char *writeinfo)\n{\n  FILE *stream = stdout;\n  const char *ptr = writeinfo;\n  char *stringp = NULL;\n  long longinfo;\n  double doubleinfo;\n\n  while(ptr && *ptr) {\n    if('%' == *ptr) {\n      if('%' == ptr[1]) {\n        /* an escaped %-letter */\n        fputc('%', stream);\n        ptr += 2;\n      }\n      else {\n        /* this is meant as a variable to output */\n        char *end;\n        char keepit;\n        int i;\n        if('{' == ptr[1]) {\n          bool match = FALSE;\n          end = strchr(ptr, '}');\n          ptr += 2; /* pass the % and the { */\n          if(!end) {\n            fputs(\"%{\", stream);\n            continue;\n          }\n          keepit = *end;\n          *end = 0; /* zero terminate */\n          for(i = 0; replacements[i].name; i++) {\n            if(curl_strequal(ptr, replacements[i].name)) {\n              match = TRUE;\n              switch(replacements[i].id) {\n              case VAR_EFFECTIVE_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_HTTP_CODE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HTTP_CODE_PROXY:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE,\n                                     &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HEADER_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REQUEST_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_NUM_CONNECTS:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_COUNT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_TOTAL_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_NAMELOOKUP_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_CONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_APPCONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_PRETRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_STARTTRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_SIZE_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SIZE_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SPEED_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_SPEED_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_CONTENT_TYPE:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_FTP_ENTRY_PATH:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_REDIRECT_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_PROXY_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PROXY_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_EFFECTIVE_FILENAME:\n                if(outs->filename)\n                  fprintf(stream, \"%s\", outs->filename);\n                break;\n              case VAR_PRIMARY_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_PRIMARY_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_LOCAL_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_LOCAL_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_HTTP_VERSION:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_VERSION,\n                                     &longinfo)) {\n                  const char *version = \"0\";\n                  switch(longinfo) {\n                  case CURL_HTTP_VERSION_1_0:\n                    version = \"1.0\";\n                    break;\n                  case CURL_HTTP_VERSION_1_1:\n                    version = \"1.1\";\n                    break;\n                  case CURL_HTTP_VERSION_2_0:\n                    version = \"2\";\n                    break;\n                  }\n\n                  fprintf(stream, version);\n                }\n                break;\n              case VAR_SCHEME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SCHEME,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              default:\n                break;\n              }\n              break;\n            }\n          }\n          if(!match) {\n            fprintf(stderr, \"curl: unknown --write-out variable: '%s'\\n\", ptr);\n          }\n          ptr = end + 1; /* pass the end */\n          *end = keepit;\n        }\n        else {\n          /* illegal syntax, then just output the characters that are used */\n          fputc('%', stream);\n          fputc(ptr[1], stream);\n          ptr += 2;\n        }\n      }\n    }\n    else if('\\\\' == *ptr) {\n      switch(ptr[1]) {\n      case 'r':\n        fputc('\\r', stream);\n        break;\n      case 'n':\n        fputc('\\n', stream);\n        break;\n      case 't':\n        fputc('\\t', stream);\n        break;\n      default:\n        /* unknown, just output this */\n        fputc(*ptr, stream);\n        fputc(ptr[1], stream);\n        break;\n      }\n      ptr += 2;\n    }\n    else {\n      fputc(*ptr, stream);\n      ptr++;\n    }\n  }\n\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if('%' == *ptr) {\n",
        "src_path": "1890d59905414ab84a35892b2e45833654aa5c13___tool_writeout.c",
        "uri": "https://api.github.com/repos/curl/curl/commits/1890d59905414ab84a35892b2e45833654aa5c13",
        "commit_msg": "tool_writeout: fixed a buffer read overrun on --write-out\n\nIf a % ended the statement, the string's trailing NUL would be skipped\nand memory past the end of the buffer would be accessed and potentially\ndisplayed as part of the --write-out output. Added tests 1440 and 1441\nto check for this kind of condition.\n\nReported-by: Brian Carpenter",
        "test_func_diff": [
            {
                "fn": "tests/data/Makefile.inc",
                "patch": "@@ -153,7 +153,7 @@ test1408 test1409 test1410 test1411 test1412 test1413 test1414 test1415 \\\n test1416 test1417 test1418 test1419 test1420 test1421 test1422 test1423 \\\n test1424 \\\n test1428 test1429 test1430 test1431 test1432 test1433 test1434 test1435 \\\n-test1436 test1437 test1438 test1439 \\\n+test1436 test1437 test1438 test1439 test1440 test1441 \\\n \\\n test1500 test1501 test1502 test1503 test1504 test1505 test1506 test1507 \\\n test1508 test1509 test1510 test1511 test1512 test1513 test1514 test1515 \\"
            },
            {
                "fn": "tests/data/test1440",
                "patch": "@@ -0,0 +1,31 @@\n+<testcase>\n+<info>\n+<keywords>\n+--write-out\n+</keywords>\n+</info>\n+# Server-side\n+<reply>\n+</reply>\n+\n+# Client-side\n+<client>\n+<server>\n+file\n+</server>\n+\n+<name>\n+Check --write-out with trailing %{\n+</name>\n+<command>\n+file://localhost/%PWD/log/ --write-out '%{'\n+</command>\n+</client>\n+\n+# Verify data\n+<verify>\n+<stdout nonewline=\"yes\">\n+%{\n+</stdout>\n+</verify>\n+</testcase>"
            },
            {
                "fn": "tests/data/test1441",
                "patch": "@@ -0,0 +1,31 @@\n+<testcase>\n+<info>\n+<keywords>\n+--write-out\n+</keywords>\n+</info>\n+# Server-side\n+<reply>\n+</reply>\n+\n+# Client-side\n+<client>\n+<server>\n+file\n+</server>\n+\n+<name>\n+Check --write-out with trailing %\n+</name>\n+<command>\n+file://localhost/%PWD/log/ --write-out '%'\n+</command>\n+</client>\n+\n+# Verify data\n+<verify>\n+<stdout nonewline=\"yes\">\n+%\n+</stdout>\n+</verify>\n+</testcase>"
            }
        ],
        "error_msg": "********* System characteristics ******** \n* curl 7.54.0-DEV (x86_64-pc-linux-gnu) \n* libcurl/7.54.0-DEV OpenSSL/1.1.1f\n* Features: Debug TrackMemory IPv6 Largefile NTLM NTLM_WB SSL TLS-SRP UnixSockets HTTPS-proxy \n* Host: wangjian\n* System: Linux wangjian 5.4.0-173-generic #191-Ubuntu SMP Fri Feb 2 13:55:07 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux\n* Servers: \n* Env: Valgrind \n***************************************** \ntest 1440...[Check --write-out with trailing %{]\ns-----emv- OK (1   out of 2  , remaining: 00:01)\ntest 1441...[Check --write-out with trailing %]\n\n 1441: stdout FAILED:\nBinary files log/check-expected and log/check-generated differ\n\n - abort tests\nTESTDONE: 1 tests out of 2 reported OK: 50%\nTESTFAIL: These test cases failed: 1441 \nTESTDONE: 2 tests were considered during 2 seconds.\n"
    },
    "f76e7feb41a4327d2b0978449bbdafe98d4a3771___print-isakmp.c": {
        "prefix": "void\nisakmp_rfc3948_print(netdissect_options *ndo,\n\t\t     const u_char *bp, u_int length,\n\t\t     const u_char *bp2)\n{\n",
        "suffix": "\tif(length == 1 && bp[0]==0xff) {\n\t\tND_PRINT((ndo, \"isakmp-nat-keep-alive\"));\n\t\treturn;\n\t}\n\n\tif(length < 4) {\n\t\tgoto trunc;\n\t}\n\n\t/*\n\t * see if this is an IKE packet\n\t */\n\tif(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {\n\t\tND_PRINT((ndo, \"NONESP-encap: \"));\n\t\tisakmp_print(ndo, bp+4, length-4, bp2);\n\t\treturn;\n\t}\n\n\t/* must be an ESP packet */\n\t{\n\t\tint nh, enh, padlen;\n\t\tint advance;\n\n\t\tND_PRINT((ndo, \"UDP-encap: \"));\n\n\t\tadvance = esp_print(ndo, bp, length, bp2, &enh, &padlen);\n\t\tif(advance <= 0)\n\t\t\treturn;\n\n\t\tbp += advance;\n\t\tlength -= advance + padlen;\n\t\tnh = enh & 0xff;\n\n\t\tip_print_inner(ndo, bp, length, nh, bp2);\n\t\treturn;\n\t}\n\ntrunc:\n\tND_PRINT((ndo,\"[|isakmp]\"));\n\treturn;\n}\n",
        "start": 3039,
        "end": 3085,
        "buggy": "void\nisakmp_rfc3948_print(netdissect_options *ndo,\n\t\t     const u_char *bp, u_int length,\n\t\t     const u_char *bp2)\n{\n\n\tif(length == 1 && bp[0]==0xff) {\n\t\tND_PRINT((ndo, \"isakmp-nat-keep-alive\"));\n\t\treturn;\n\t}\n\n\tif(length < 4) {\n\t\tgoto trunc;\n\t}\n\n\t/*\n\t * see if this is an IKE packet\n\t */\n\tif(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {\n\t\tND_PRINT((ndo, \"NONESP-encap: \"));\n\t\tisakmp_print(ndo, bp+4, length-4, bp2);\n\t\treturn;\n\t}\n\n\t/* must be an ESP packet */\n\t{\n\t\tint nh, enh, padlen;\n\t\tint advance;\n\n\t\tND_PRINT((ndo, \"UDP-encap: \"));\n\n\t\tadvance = esp_print(ndo, bp, length, bp2, &enh, &padlen);\n\t\tif(advance <= 0)\n\t\t\treturn;\n\n\t\tbp += advance;\n\t\tlength -= advance + padlen;\n\t\tnh = enh & 0xff;\n\n\t\tip_print_inner(ndo, bp, length, nh, bp2);\n\t\treturn;\n\t}\n\ntrunc:\n\tND_PRINT((ndo,\"[|isakmp]\"));\n\treturn;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\n",
        "src_path": "f76e7feb41a4327d2b0978449bbdafe98d4a3771___print-isakmp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/f76e7feb41a4327d2b0978449bbdafe98d4a3771",
        "commit_msg": "CVE-2017-12896/ISAKMP: Do bounds checks in isakmp_rfc3948_print().\n\nThis fixes a buffer over-read discovered by Kamil Frankowicz.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -441,6 +441,7 @@ isoclns-heapoverflow-3\tisoclns-heapoverflow-3.pcap\tisoclns-heapoverflow-3.out\t-e\n stp-v4-length-sigsegv\tstp-v4-length-sigsegv.pcap\tstp-v4-length-sigsegv.out\n hoobr_pimv1\t\thoobr_pimv1.pcap\t\thoobr_pimv1.out\n hoobr_safeputs\t\thoobr_safeputs.pcap\t\thoobr_safeputs.out\n+isakmp-rfc3948-oobr\tisakmp-rfc3948-oobr.pcap\tisakmp-rfc3948-oobr.out\n \n # bad packets from Wilfried Kirsch\n slip-bad-direction\tslip-bad-direction.pcap\t\tslip-bad-direction.out\t-ve"
            },
            {
                "fn": "tests/isakmp-rfc3948-oobr.out",
                "patch": "@@ -0,0 +1,67 @@\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+30:30:30:30:30:30 > 30:30:30:30:30:30, ethertype Unknown (0x3030), length 808464432: \n+\t0x0000:  3030 3030 3030 3030 3030 3030 3030 3030  0000000000000000\n+\t0x0010:  3030 3030 3030 3030 3030 3030            000000000000\n+IP 48.48.48.48.4500 > 48.48.48.48.12336: [|isakmp]"
            }
        ],
        "error_msg": "    isakmp-rfc3948-oobr                : TEST FAILED(exit 256)\n"
    },
    "979dcefd7b259e9e233f77fe1c5312793bfd948f___print-isoclns.c": {
        "prefix": "static int\nisis_print_extd_ip_reach(netdissect_options *ndo,\n                         const uint8_t *tptr, const char *ident, uint16_t afi)\n{\n    char ident_buffer[20];\n    uint8_t prefix[sizeof(struct in6_addr)]; /* shared copy buffer for IPv4 and IPv6 prefixes */\n    u_int metric, status_byte, bit_length, byte_length, sublen, processed, subtlvtype, subtlvlen;\n\n    if (!ND_TTEST2(*tptr, 4))\n        return (0);\n    metric = EXTRACT_32BITS(tptr);\n    processed=4;\n    tptr+=4;\n\n    if (afi == AF_INET) {\n        if (!ND_TTEST2(*tptr, 1)) /* fetch status byte */\n            return (0);\n        status_byte=*(tptr++);\n        bit_length = status_byte&0x3f;\n        if (bit_length > 32) {\n            ND_PRINT((ndo, \"%sIPv4 prefix: bad bit length %u\",\n                   ident,\n                   bit_length));\n            return (0);\n        }\n        processed++;\n    } else if (afi == AF_INET6) {\n",
        "suffix": "            return (0);\n        status_byte=*(tptr++);\n        bit_length=*(tptr++);\n        if (bit_length > 128) {\n            ND_PRINT((ndo, \"%sIPv6 prefix: bad bit length %u\",\n                   ident,\n                   bit_length));\n            return (0);\n        }\n        processed+=2;\n    } else\n        return (0); /* somebody is fooling us */\n\n    byte_length = (bit_length + 7) / 8; /* prefix has variable length encoding */\n\n    if (!ND_TTEST2(*tptr, byte_length))\n        return (0);\n    memset(prefix, 0, sizeof prefix);   /* clear the copy buffer */\n    memcpy(prefix,tptr,byte_length);    /* copy as much as is stored in the TLV */\n    tptr+=byte_length;\n    processed+=byte_length;\n\n    if (afi == AF_INET)\n        ND_PRINT((ndo, \"%sIPv4 prefix: %15s/%u\",\n               ident,\n               ipaddr_string(ndo, prefix),\n               bit_length));\n    else if (afi == AF_INET6)\n        ND_PRINT((ndo, \"%sIPv6 prefix: %s/%u\",\n               ident,\n               ip6addr_string(ndo, prefix),\n               bit_length));\n\n    ND_PRINT((ndo, \", Distribution: %s, Metric: %u\",\n           ISIS_MASK_TLV_EXTD_IP_UPDOWN(status_byte) ? \"down\" : \"up\",\n           metric));\n\n    if (afi == AF_INET && ISIS_MASK_TLV_EXTD_IP_SUBTLV(status_byte))\n        ND_PRINT((ndo, \", sub-TLVs present\"));\n    else if (afi == AF_INET6)\n        ND_PRINT((ndo, \", %s%s\",\n               ISIS_MASK_TLV_EXTD_IP6_IE(status_byte) ? \"External\" : \"Internal\",\n               ISIS_MASK_TLV_EXTD_IP6_SUBTLV(status_byte) ? \", sub-TLVs present\" : \"\"));\n\n    if ((afi == AF_INET  && ISIS_MASK_TLV_EXTD_IP_SUBTLV(status_byte))\n     || (afi == AF_INET6 && ISIS_MASK_TLV_EXTD_IP6_SUBTLV(status_byte))\n\t) {\n        /* assume that one prefix can hold more\n           than one subTLV - therefore the first byte must reflect\n           the aggregate bytecount of the subTLVs for this prefix\n        */\n        if (!ND_TTEST2(*tptr, 1))\n            return (0);\n        sublen=*(tptr++);\n        processed+=sublen+1;\n        ND_PRINT((ndo, \" (%u)\", sublen));   /* print out subTLV length */\n\n        while (sublen>0) {\n            if (!ND_TTEST2(*tptr,2))\n                return (0);\n            subtlvtype=*(tptr++);\n            subtlvlen=*(tptr++);\n            /* prepend the indent string */\n            snprintf(ident_buffer, sizeof(ident_buffer), \"%s  \",ident);\n            if (!isis_print_ip_reach_subtlv(ndo, tptr, subtlvtype, subtlvlen, ident_buffer))\n                return(0);\n            tptr+=subtlvlen;\n            sublen-=(subtlvlen+2);\n        }\n    }\n    return (processed);\n}\n",
        "start": 2014,
        "end": 2113,
        "buggy": "static int\nisis_print_extd_ip_reach(netdissect_options *ndo,\n                         const uint8_t *tptr, const char *ident, uint16_t afi)\n{\n    char ident_buffer[20];\n    uint8_t prefix[sizeof(struct in6_addr)]; /* shared copy buffer for IPv4 and IPv6 prefixes */\n    u_int metric, status_byte, bit_length, byte_length, sublen, processed, subtlvtype, subtlvlen;\n\n    if (!ND_TTEST2(*tptr, 4))\n        return (0);\n    metric = EXTRACT_32BITS(tptr);\n    processed=4;\n    tptr+=4;\n\n    if (afi == AF_INET) {\n        if (!ND_TTEST2(*tptr, 1)) /* fetch status byte */\n            return (0);\n        status_byte=*(tptr++);\n        bit_length = status_byte&0x3f;\n        if (bit_length > 32) {\n            ND_PRINT((ndo, \"%sIPv4 prefix: bad bit length %u\",\n                   ident,\n                   bit_length));\n            return (0);\n        }\n        processed++;\n    } else if (afi == AF_INET6) {\n        if (!ND_TTEST2(*tptr, 1)) /* fetch status & prefix_len byte */\n            return (0);\n        status_byte=*(tptr++);\n        bit_length=*(tptr++);\n        if (bit_length > 128) {\n            ND_PRINT((ndo, \"%sIPv6 prefix: bad bit length %u\",\n                   ident,\n                   bit_length));\n            return (0);\n        }\n        processed+=2;\n    } else\n        return (0); /* somebody is fooling us */\n\n    byte_length = (bit_length + 7) / 8; /* prefix has variable length encoding */\n\n    if (!ND_TTEST2(*tptr, byte_length))\n        return (0);\n    memset(prefix, 0, sizeof prefix);   /* clear the copy buffer */\n    memcpy(prefix,tptr,byte_length);    /* copy as much as is stored in the TLV */\n    tptr+=byte_length;\n    processed+=byte_length;\n\n    if (afi == AF_INET)\n        ND_PRINT((ndo, \"%sIPv4 prefix: %15s/%u\",\n               ident,\n               ipaddr_string(ndo, prefix),\n               bit_length));\n    else if (afi == AF_INET6)\n        ND_PRINT((ndo, \"%sIPv6 prefix: %s/%u\",\n               ident,\n               ip6addr_string(ndo, prefix),\n               bit_length));\n\n    ND_PRINT((ndo, \", Distribution: %s, Metric: %u\",\n           ISIS_MASK_TLV_EXTD_IP_UPDOWN(status_byte) ? \"down\" : \"up\",\n           metric));\n\n    if (afi == AF_INET && ISIS_MASK_TLV_EXTD_IP_SUBTLV(status_byte))\n        ND_PRINT((ndo, \", sub-TLVs present\"));\n    else if (afi == AF_INET6)\n        ND_PRINT((ndo, \", %s%s\",\n               ISIS_MASK_TLV_EXTD_IP6_IE(status_byte) ? \"External\" : \"Internal\",\n               ISIS_MASK_TLV_EXTD_IP6_SUBTLV(status_byte) ? \", sub-TLVs present\" : \"\"));\n\n    if ((afi == AF_INET  && ISIS_MASK_TLV_EXTD_IP_SUBTLV(status_byte))\n     || (afi == AF_INET6 && ISIS_MASK_TLV_EXTD_IP6_SUBTLV(status_byte))\n\t) {\n        /* assume that one prefix can hold more\n           than one subTLV - therefore the first byte must reflect\n           the aggregate bytecount of the subTLVs for this prefix\n        */\n        if (!ND_TTEST2(*tptr, 1))\n            return (0);\n        sublen=*(tptr++);\n        processed+=sublen+1;\n        ND_PRINT((ndo, \" (%u)\", sublen));   /* print out subTLV length */\n\n        while (sublen>0) {\n            if (!ND_TTEST2(*tptr,2))\n                return (0);\n            subtlvtype=*(tptr++);\n            subtlvlen=*(tptr++);\n            /* prepend the indent string */\n            snprintf(ident_buffer, sizeof(ident_buffer), \"%s  \",ident);\n            if (!isis_print_ip_reach_subtlv(ndo, tptr, subtlvtype, subtlvlen, ident_buffer))\n                return(0);\n            tptr+=subtlvlen;\n            sublen-=(subtlvlen+2);\n        }\n    }\n    return (processed);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        if (!ND_TTEST2(*tptr, 1)) /* fetch status & prefix_len byte */\n",
        "src_path": "979dcefd7b259e9e233f77fe1c5312793bfd948f___print-isoclns.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/979dcefd7b259e9e233f77fe1c5312793bfd948f",
        "commit_msg": "CVE-2017-12998/IS-IS: Check for 2 bytes if we're going to fetch 2 bytes.\n\nProbably a copy-and-pasteo.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -478,6 +478,7 @@ resp_4_infiniteloop\tresp_4_infiniteloop.pcap\tresp_4_infiniteloop.out\t-vvv -e\n dns_fwdptr\t\tdns_fwdptr.pcap\t\t\tdns_fwdptr.out\t\t-vvv -e\n isis-areaaddr-oobr-1\tisis-areaaddr-oobr-1.pcap\tisis-areaaddr-oobr-1.out\t\t-vvv -e\n isis-areaaddr-oobr-2\tisis-areaaddr-oobr-2.pcap\tisis-areaaddr-oobr-2.out\t\t-vvv -e\n+isis-extd-ipreach-oobr\tisis-extd-ipreach-oobr.pcap\tisis-extd-ipreach-oobr.out\t\t-vvv -e\n \n # RTP tests\n # fuzzed pcap"
            }
        ],
        "error_msg": "    isis-extd-ipreach-oobr             : passed\n"
    },
    "a7e5f58f402e6919ec444a57946bade7dfd6b184___print-802_15_4.c": {
        "prefix": "u_int\nieee802_15_4_if_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int hdrlen;\n\tuint16_t fc;\n\tuint8_t seq;\n\tuint16_t panid = 0;\n\n\tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\treturn caplen;\n\t}\n\thdrlen = 3;\n\n\tfc = EXTRACT_LE_16BITS(p);\n\tseq = EXTRACT_LE_8BITS(p + 2);\n\n\tp += 3;\n\tcaplen -= 3;\n\n\tND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[FC_FRAME_TYPE(fc)]));\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"seq %02x \", seq));\n\n\t/*\n\t * Destination address and PAN ID, if present.\n\t */\n\tswitch (FC_DEST_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (fc & FC_PAN_ID_COMPRESSION) {\n\t\t\t/*\n\t\t\t * PAN ID compression; this requires that both\n\t\t\t * the source and destination addresses be present,\n\t\t\t * but the destination address is missing.\n\t\t\t */\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved destination addressing mode\"));\n\t\treturn hdrlen;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n",
        "suffix": "\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"< \"));\n\n\t/*\n\t * Source address and PAN ID, if present.\n\t */\n\tswitch (FC_SRC_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved source addressing mode\"));\n\t\treturn 0;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\n\tif (!ndo->ndo_suppress_default_print)\n\t\tND_DEFAULTPRINT(p, caplen);\n\n\treturn hdrlen;\n}\n",
        "start": 64,
        "end": 223,
        "buggy": "u_int\nieee802_15_4_if_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int hdrlen;\n\tuint16_t fc;\n\tuint8_t seq;\n\tuint16_t panid = 0;\n\n\tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\treturn caplen;\n\t}\n\thdrlen = 3;\n\n\tfc = EXTRACT_LE_16BITS(p);\n\tseq = EXTRACT_LE_8BITS(p + 2);\n\n\tp += 3;\n\tcaplen -= 3;\n\n\tND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[FC_FRAME_TYPE(fc)]));\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"seq %02x \", seq));\n\n\t/*\n\t * Destination address and PAN ID, if present.\n\t */\n\tswitch (FC_DEST_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (fc & FC_PAN_ID_COMPRESSION) {\n\t\t\t/*\n\t\t\t * PAN ID compression; this requires that both\n\t\t\t * the source and destination addresses be present,\n\t\t\t * but the destination address is missing.\n\t\t\t */\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved destination addressing mode\"));\n\t\treturn hdrlen;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p + 2)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"< \"));\n\n\t/*\n\t * Source address and PAN ID, if present.\n\t */\n\tswitch (FC_SRC_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved source addressing mode\"));\n\t\treturn 0;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\n\tif (!ndo->ndo_suppress_default_print)\n\t\tND_DEFAULTPRINT(p, caplen);\n\n\treturn hdrlen;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p + 2)));\n",
        "src_path": "a7e5f58f402e6919ec444a57946bade7dfd6b184___print-802_15_4.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/a7e5f58f402e6919ec444a57946bade7dfd6b184",
        "commit_msg": "CVE-2017-13000/IEEE 802.15.4: Fix bug introduced by previous fix.\n\nWe've already advanced the pointer past the PAN ID, if present; it now\npoints to the address, so don't add 2 to it.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/802_15_4-data.out",
                "patch": "@@ -0,0 +1 @@\n+IEEE 802.15.4 Data packet seq 01 ab4d:10:05:00:81:00:01:00:01 < [|802.15.4]"
            },
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -488,6 +488,7 @@ pimv2-oobr-3\t\tpimv2-oobr-3.pcap\t\tpimv2-oobr-3.out\t\t-vvv -e\n pimv2-oobr-4\t\tpimv2-oobr-4.pcap\t\tpimv2-oobr-4.out\t\t-vvv -e\n 802_15_4-oobr-1\t\t802_15_4-oobr-1.pcap\t\t802_15_4-oobr-1.out\t-vvv -e\n 802_15_4-oobr-2\t\t802_15_4-oobr-2.pcap\t\t802_15_4-oobr-2.out\t-vvv -e\n+802_15_4-data\t\t802_15_4-data.pcap\t\t802_15_4-data.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap"
            }
        ],
        "error_msg": "    802_15_4-data                      : TEST FAILED(exit 256)\n"
    },
    "8512734883227c11568bb35da1d48b9f8466f43f___print-802_15_4.c": {
        "prefix": "u_int\nieee802_15_4_if_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int hdrlen;\n\tuint16_t fc;\n\tuint8_t seq;\n\tuint16_t panid = 0;\n\n\tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\treturn caplen;\n\t}\n\thdrlen = 3;\n\n\tfc = EXTRACT_LE_16BITS(p);\n\tseq = EXTRACT_LE_8BITS(p + 2);\n\n\tp += 3;\n\tcaplen -= 3;\n\n\tND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[FC_FRAME_TYPE(fc)]));\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"seq %02x \", seq));\n\n\t/*\n\t * Destination address and PAN ID, if present.\n\t */\n\tswitch (FC_DEST_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (fc & FC_PAN_ID_COMPRESSION) {\n\t\t\t/*\n\t\t\t * PAN ID compression; this requires that both\n\t\t\t * the source and destination addresses be present,\n\t\t\t * but the destination address is missing.\n\t\t\t */\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved destination addressing mode\"));\n\t\treturn hdrlen;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n",
        "suffix": "\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"< \"));\n\n\t/*\n\t * Source address and PAN ID, if present.\n\t */\n\tswitch (FC_SRC_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved source addressing mode\"));\n\t\treturn 0;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\n\tif (!ndo->ndo_suppress_default_print)\n\t\tND_DEFAULTPRINT(p, caplen);\n\n\treturn hdrlen;\n}\n",
        "start": 64,
        "end": 223,
        "buggy": "u_int\nieee802_15_4_if_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int hdrlen;\n\tuint16_t fc;\n\tuint8_t seq;\n\tuint16_t panid = 0;\n\n\tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\treturn caplen;\n\t}\n\thdrlen = 3;\n\n\tfc = EXTRACT_LE_16BITS(p);\n\tseq = EXTRACT_LE_8BITS(p + 2);\n\n\tp += 3;\n\tcaplen -= 3;\n\n\tND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[FC_FRAME_TYPE(fc)]));\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"seq %02x \", seq));\n\n\t/*\n\t * Destination address and PAN ID, if present.\n\t */\n\tswitch (FC_DEST_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (fc & FC_PAN_ID_COMPRESSION) {\n\t\t\t/*\n\t\t\t * PAN ID compression; this requires that both\n\t\t\t * the source and destination addresses be present,\n\t\t\t * but the destination address is missing.\n\t\t\t */\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved destination addressing mode\"));\n\t\treturn hdrlen;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"< \"));\n\n\t/*\n\t * Source address and PAN ID, if present.\n\t */\n\tswitch (FC_SRC_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved source addressing mode\"));\n\t\treturn 0;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\n\tif (!ndo->ndo_suppress_default_print)\n\t\tND_DEFAULTPRINT(p, caplen);\n\n\treturn hdrlen;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));\n",
        "src_path": "8512734883227c11568bb35da1d48b9f8466f43f___print-802_15_4.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/8512734883227c11568bb35da1d48b9f8466f43f",
        "commit_msg": "CVE-2017-13000/IEEE 802.15.4: Fix bug introduced two fixes prior.\n\nWe've already advanced the pointer past the PAN ID, if present; it now\npoints to the address, so don't add 2 to it.\n\nThis fixes a buffer over-read discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/802_15_4_beacon.out",
                "patch": "@@ -0,0 +1 @@\n+IEEE 802.15.4 Beacon packet seq cd ffab:cdff < [|802.15.4]"
            },
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -489,6 +489,7 @@ pimv2-oobr-4\t\tpimv2-oobr-4.pcap\t\tpimv2-oobr-4.out\t\t-vvv -e\n 802_15_4-oobr-1\t\t802_15_4-oobr-1.pcap\t\t802_15_4-oobr-1.out\t-vvv -e\n 802_15_4-oobr-2\t\t802_15_4-oobr-2.pcap\t\t802_15_4-oobr-2.out\t-vvv -e\n 802_15_4-data\t\t802_15_4-data.pcap\t\t802_15_4-data.out\t-vvv -e\n+802_15_4_beacon\t\t802_15_4_beacon.pcap\t\t802_15_4_beacon.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap"
            }
        ],
        "error_msg": "    802_15_4_beacon                    : TEST FAILED(exit 256)\n"
    },
    "ca336198e8bebccc18502de27672fdbd6eb34856___print-pktap.c": {
        "prefix": "u_int\npktap_if_print(netdissect_options *ndo,\n               const struct pcap_pkthdr *h, const u_char *p)\n{\n\tuint32_t dlt, hdrlen, rectype;\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tif_printer printer;\n\tconst pktap_header_t *hdr;\n\n\tif (caplen < sizeof(pktap_header_t) || length < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\thdr = (const pktap_header_t *)p;\n\tdlt = EXTRACT_LE_32BITS(&hdr->pkt_dlt);\n",
        "suffix": "\tif (hdrlen < sizeof(pktap_header_t)) {\n\t\t/*\n\t\t * Claimed header length < structure length.\n\t\t * XXX - does this just mean some fields aren't\n\t\t * being supplied, or is it truly an error (i.e.,\n\t\t * is the length supplied so that the header can\n\t\t * be expanded in the future)?\n\t\t */\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\tif (caplen < hdrlen || length < hdrlen) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (hdrlen);\n\t}\n\n\tif (ndo->ndo_eflag)\n\t\tpktap_header_print(ndo, p, length);\n\n\tlength -= hdrlen;\n\tcaplen -= hdrlen;\n\tp += hdrlen;\n\n\trectype = EXTRACT_LE_32BITS(&hdr->pkt_rectype);\n\tswitch (rectype) {\n\n\tcase PKT_REC_NONE:\n\t\tND_PRINT((ndo, \"no data\"));\n\t\tbreak;\n\n\tcase PKT_REC_PACKET:\n\t\tif ((printer = lookup_printer(dlt)) != NULL) {\n\t\t\thdrlen += printer(ndo, h, p);\n\t\t} else {\n\t\t\tif (!ndo->ndo_eflag)\n\t\t\t\tpktap_header_print(ndo, (const u_char *)hdr,\n\t\t\t\t\t\tlength + hdrlen);\n\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p, caplen);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn (hdrlen);\n}\n",
        "start": 98,
        "end": 160,
        "buggy": "u_int\npktap_if_print(netdissect_options *ndo,\n               const struct pcap_pkthdr *h, const u_char *p)\n{\n\tuint32_t dlt, hdrlen, rectype;\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tif_printer printer;\n\tconst pktap_header_t *hdr;\n\n\tif (caplen < sizeof(pktap_header_t) || length < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\thdr = (const pktap_header_t *)p;\n\tdlt = EXTRACT_LE_32BITS(&hdr->pkt_dlt);\n\thdrlen = EXTRACT_LE_32BITS(&hdr->pkt_len);\n\tif (hdrlen < sizeof(pktap_header_t)) {\n\t\t/*\n\t\t * Claimed header length < structure length.\n\t\t * XXX - does this just mean some fields aren't\n\t\t * being supplied, or is it truly an error (i.e.,\n\t\t * is the length supplied so that the header can\n\t\t * be expanded in the future)?\n\t\t */\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\tif (caplen < hdrlen || length < hdrlen) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (hdrlen);\n\t}\n\n\tif (ndo->ndo_eflag)\n\t\tpktap_header_print(ndo, p, length);\n\n\tlength -= hdrlen;\n\tcaplen -= hdrlen;\n\tp += hdrlen;\n\n\trectype = EXTRACT_LE_32BITS(&hdr->pkt_rectype);\n\tswitch (rectype) {\n\n\tcase PKT_REC_NONE:\n\t\tND_PRINT((ndo, \"no data\"));\n\t\tbreak;\n\n\tcase PKT_REC_PACKET:\n\t\tif ((printer = lookup_printer(dlt)) != NULL) {\n\t\t\thdrlen += printer(ndo, h, p);\n\t\t} else {\n\t\t\tif (!ndo->ndo_eflag)\n\t\t\t\tpktap_header_print(ndo, (const u_char *)hdr,\n\t\t\t\t\t\tlength + hdrlen);\n\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p, caplen);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn (hdrlen);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\thdrlen = EXTRACT_LE_32BITS(&hdr->pkt_len);\n",
        "src_path": "ca336198e8bebccc18502de27672fdbd6eb34856___print-pktap.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/ca336198e8bebccc18502de27672fdbd6eb34856",
        "commit_msg": "CVE-2017-13007/PKTAP: Pass a properly updated struct pcap_pkthdr to the sub-dissector.\n\nThe sub-dissector expects that the length and captured length will\nreflect the actual remaining data in the packet, not the raw amount\nincluding the PKTAP header; pass an updated header, just as we do for\nPPI.\n\nThis fixes a buffer over-read discovered by Yannick Formaggio.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -502,6 +502,7 @@ juniper_es\t\tjuniper_es.pcap\t\t\tjuniper_es.out\t-vvv -e\n \n # bad packets from Yannick Formaggio\n l2tp-avp-overflow\tl2tp-avp-overflow.pcap\t\tl2tp-avp-overflow.out\t-v\n+pktap-heap-overflow\tpktap-heap-overflow.pcap\tpktap-heap-overflow.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/pktap-heap-overflow.out",
                "patch": "@@ -0,0 +1,3 @@\n+[|pktap]\n+[|ppp]\n+EXIT CODE 00000100"
            }
        ],
        "error_msg": "    pktap-heap-overflow                : TEST FAILED(exit 256)\n"
    },
    "a77ff09c46560bc895dea11dc9fe643486b056ac___print-lldp.c": {
        "prefix": "static int\nlldp_mgmt_addr_tlv_print(netdissect_options *ndo,\n                         const u_char *pptr, u_int len)\n{\n    uint8_t mgmt_addr_len, intf_num_subtype, oid_len;\n    const u_char *tptr;\n    u_int tlen;\n    char *mgmt_addr;\n\n    tlen = len;\n    tptr = pptr;\n\n    if (tlen < 1) {\n        return 0;\n    }\n    mgmt_addr_len = *tptr++;\n    tlen--;\n\n    if (tlen < mgmt_addr_len) {\n        return 0;\n    }\n\n    mgmt_addr = lldp_network_addr_print(ndo, tptr, mgmt_addr_len);\n    if (mgmt_addr == NULL) {\n        return 0;\n    }\n    ND_PRINT((ndo, \"\\n\\t  Management Address length %u, %s\",\n           mgmt_addr_len, mgmt_addr));\n    tptr += mgmt_addr_len;\n    tlen -= mgmt_addr_len;\n\n    if (tlen < LLDP_INTF_NUM_LEN) {\n        return 0;\n    }\n\n    intf_num_subtype = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  %s Interface Numbering (%u): %u\",\n           tok2str(lldp_intf_numb_subtype_values, \"Unknown\", intf_num_subtype),\n           intf_num_subtype,\n           EXTRACT_32BITS(tptr + 1)));\n\n    tptr += LLDP_INTF_NUM_LEN;\n    tlen -= LLDP_INTF_NUM_LEN;\n\n    /*\n     * The OID is optional.\n     */\n    if (tlen) {\n        oid_len = *tptr;\n\n",
        "suffix": "            return 0;\n        }\n        if (oid_len) {\n            ND_PRINT((ndo, \"\\n\\t  OID length %u\", oid_len));\n            safeputs(ndo, tptr + 1, oid_len);\n        }\n    }\n\n    return 1;\n}\n",
        "start": 1354,
        "end": 1414,
        "buggy": "static int\nlldp_mgmt_addr_tlv_print(netdissect_options *ndo,\n                         const u_char *pptr, u_int len)\n{\n    uint8_t mgmt_addr_len, intf_num_subtype, oid_len;\n    const u_char *tptr;\n    u_int tlen;\n    char *mgmt_addr;\n\n    tlen = len;\n    tptr = pptr;\n\n    if (tlen < 1) {\n        return 0;\n    }\n    mgmt_addr_len = *tptr++;\n    tlen--;\n\n    if (tlen < mgmt_addr_len) {\n        return 0;\n    }\n\n    mgmt_addr = lldp_network_addr_print(ndo, tptr, mgmt_addr_len);\n    if (mgmt_addr == NULL) {\n        return 0;\n    }\n    ND_PRINT((ndo, \"\\n\\t  Management Address length %u, %s\",\n           mgmt_addr_len, mgmt_addr));\n    tptr += mgmt_addr_len;\n    tlen -= mgmt_addr_len;\n\n    if (tlen < LLDP_INTF_NUM_LEN) {\n        return 0;\n    }\n\n    intf_num_subtype = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  %s Interface Numbering (%u): %u\",\n           tok2str(lldp_intf_numb_subtype_values, \"Unknown\", intf_num_subtype),\n           intf_num_subtype,\n           EXTRACT_32BITS(tptr + 1)));\n\n    tptr += LLDP_INTF_NUM_LEN;\n    tlen -= LLDP_INTF_NUM_LEN;\n\n    /*\n     * The OID is optional.\n     */\n    if (tlen) {\n        oid_len = *tptr;\n\n        if (tlen < oid_len) {\n            return 0;\n        }\n        if (oid_len) {\n            ND_PRINT((ndo, \"\\n\\t  OID length %u\", oid_len));\n            safeputs(ndo, tptr + 1, oid_len);\n        }\n    }\n\n    return 1;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        if (tlen < oid_len) {\n",
        "src_path": "a77ff09c46560bc895dea11dc9fe643486b056ac___print-lldp.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/a77ff09c46560bc895dea11dc9fe643486b056ac",
        "commit_msg": "CVE-2017-13027/LLDP: Fix a bounds check.\n\nThe total length of the OID is the OID length plus the length of the OID\nlength itself.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -532,6 +532,7 @@ isis_stlv_asan\t\tisis_stlv_asan.pcap\t\tisis_stlv_asan.out\t-v\n isis_stlv_asan-2\tisis_stlv_asan-2.pcap\t\tisis_stlv_asan-2.out\t-v\n isis_stlv_asan-3\tisis_stlv_asan-3.pcap\t\tisis_stlv_asan-3.out\t-v\n isis_stlv_asan-4\tisis_stlv_asan-4.pcap\t\tisis_stlv_asan-4.out\t-v\n+lldp_mgmt_addr_tlv_asan\tlldp_mgmt_addr_tlv_asan.pcap\tlldp_mgmt_addr_tlv_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/lldp_mgmt_addr_tlv_asan.out",
                "patch": "@@ -0,0 +1,8 @@\n+LLDP, length 1048572\n+\tManagement Address TLV (8), length 15\n+\t  Management Address length 6, AFI Reserved (0), no AF printer !\n+\t  Unknown Interface Numbering (10): 666137427\n+\t[|LLDP]\n+00:00:00:a0:d4:c3 > 06:04:e8:03:00:02, ethertype Unknown (0xb2a1), length 58785857: \n+\t0x0000:  0200 efff e5ff 804f 006e 0026 0000 0000  .......O.n.&....\n+\t0x0010:  01                                       ."
            }
        ],
        "error_msg": "    lldp_mgmt_addr_tlv_asan            : TEST FAILED(exit 256)\n"
    },
    "2d669862df7cd17f539129049f6fb70d17174125___print-frag6.c": {
        "prefix": "int\nfrag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)\n{\n\tregister const struct ip6_frag *dp;\n\tregister const struct ip6_hdr *ip6;\n\n\tdp = (const struct ip6_frag *)bp;\n\tip6 = (const struct ip6_hdr *)bp2;\n\n",
        "suffix": "\n\tif (ndo->ndo_vflag) {\n\t\tND_PRINT((ndo, \"frag (0x%08x:%d|%ld)\",\n\t\t       EXTRACT_32BITS(&dp->ip6f_ident),\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t} else {\n\t\tND_PRINT((ndo, \"frag (%d|%ld)\",\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t}\n\n\t/* it is meaningless to decode non-first fragment */\n\tif ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)\n\t\treturn -1;\n\telse\n\t{\n\t\tND_PRINT((ndo, \" \"));\n\t\treturn sizeof(struct ip6_frag);\n\t}\ntrunc:\n\tND_PRINT((ndo, \"[|frag]\"));\n\treturn -1;\n}\n",
        "start": 35,
        "end": 70,
        "buggy": "int\nfrag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)\n{\n\tregister const struct ip6_frag *dp;\n\tregister const struct ip6_hdr *ip6;\n\n\tdp = (const struct ip6_frag *)bp;\n\tip6 = (const struct ip6_hdr *)bp2;\n\n\tND_TCHECK(dp->ip6f_offlg);\n\n\tif (ndo->ndo_vflag) {\n\t\tND_PRINT((ndo, \"frag (0x%08x:%d|%ld)\",\n\t\t       EXTRACT_32BITS(&dp->ip6f_ident),\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t} else {\n\t\tND_PRINT((ndo, \"frag (%d|%ld)\",\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t}\n\n\t/* it is meaningless to decode non-first fragment */\n\tif ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)\n\t\treturn -1;\n\telse\n\t{\n\t\tND_PRINT((ndo, \" \"));\n\t\treturn sizeof(struct ip6_frag);\n\t}\ntrunc:\n\tND_PRINT((ndo, \"[|frag]\"));\n\treturn -1;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\tND_TCHECK(dp->ip6f_offlg);\n",
        "src_path": "2d669862df7cd17f539129049f6fb70d17174125___print-frag6.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/2d669862df7cd17f539129049f6fb70d17174125",
        "commit_msg": "CVE-2017-13031/Check for the presence of the entire IPv6 fragment header.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.\n\nClean up some whitespace in tests/TESTLIST while we're at it.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -536,9 +536,10 @@ isis_stlv_asan-4\tisis_stlv_asan-4.pcap\t\tisis_stlv_asan-4.out\t-v\n lldp_mgmt_addr_tlv_asan\tlldp_mgmt_addr_tlv_asan.pcap\tlldp_mgmt_addr_tlv_asan.out\t-v\n bootp_asan\t\tbootp_asan.pcap\t\t\tbootp_asan.out\t\t-v\n ppp_ccp_config_deflate_option_asan\tppp_ccp_config_deflate_option_asan.pcap\tppp_ccp_config_deflate_option_asan.out\t-v\n-pim_header_asan\t\tpim_header_asan.pcap\t\tpim_header_asan.out\t\t-v\n-pim_header_asan-2\tpim_header_asan-2.pcap\t\tpim_header_asan-2.out\t\t-v\n-pim_header_asan-3\tpim_header_asan-3.pcap\t\tpim_header_asan-3.out\t\t-v\n+pim_header_asan\t\tpim_header_asan.pcap\t\tpim_header_asan.out\t-v\n+pim_header_asan-2\tpim_header_asan-2.pcap\t\tpim_header_asan-2.out\t-v\n+pim_header_asan-3\tpim_header_asan-3.pcap\t\tpim_header_asan-3.out\t-v\n+ip6_frag_asan\t\tip6_frag_asan.pcap\t\tip6_frag_asan.out\t-v\n \n # RTP tests\n # fuzzed pcap"
            },
            {
                "fn": "tests/ip6_frag_asan.out",
                "patch": "@@ -0,0 +1 @@\n+IP6 (class 0x51, flowlabel 0xb2100, hlim 16, next-header Fragment (44) payload length: 27136) 452:22:19:0:41a:e4ff:10ff:484d > 2243:80:1400:100:19:ffff:ffff:fffb: [|frag]"
            }
        ],
        "error_msg": "    ip6_frag_asan                      : TEST FAILED(exit 256)\n"
    },
    "571a6f33f47e7a2394fa08f925e534135c29cf1e___print-isoclns.c": {
        "prefix": "static char *\nisis_print_id(const uint8_t *cp, int id_len)\n{\n    int i;\n    static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n    char *pos = id;\n\n",
        "suffix": "        snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n\tpos += strlen(pos);\n\tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}\n",
        "start": 1643,
        "end": 1663,
        "buggy": "static char *\nisis_print_id(const uint8_t *cp, int id_len)\n{\n    int i;\n    static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n    char *pos = id;\n\n    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n        snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n\tpos += strlen(pos);\n\tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n",
        "src_path": "571a6f33f47e7a2394fa08f925e534135c29cf1e___print-isoclns.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/571a6f33f47e7a2394fa08f925e534135c29cf1e",
        "commit_msg": "CVE-2017-13035/Properly handle IS-IS IDs shorter than a system ID (MAC address).\n\nSome of them are variable-length, with a field giving the total length,\nand therefore they can be shorter than 6 octets.  If one is, don't run\npast the end.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s), modified\nso the capture file won't be rejected as an invalid capture.",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -539,6 +539,7 @@ isis_stlv_asan\t\tisis_stlv_asan.pcap\t\tisis_stlv_asan.out\t-v\n isis_stlv_asan-2\tisis_stlv_asan-2.pcap\t\tisis_stlv_asan-2.out\t-v\n isis_stlv_asan-3\tisis_stlv_asan-3.pcap\t\tisis_stlv_asan-3.out\t-v\n isis_stlv_asan-4\tisis_stlv_asan-4.pcap\t\tisis_stlv_asan-4.out\t-v\n+isis_sysid_asan\t\tisis_sysid_asan.pcap\t\tisis_sysid_asan.out\t-v\n lldp_mgmt_addr_tlv_asan\tlldp_mgmt_addr_tlv_asan.pcap\tlldp_mgmt_addr_tlv_asan.out\t-v\n bootp_asan\t\tbootp_asan.pcap\t\t\tbootp_asan.out\t\t-v\n bootp_asan-2\t\tbootp_asan-2.pcap\t\tbootp_asan-2.out\t-v"
            },
            {
                "fn": "tests/isis_sysid_asan.out",
                "patch": "@@ -0,0 +1,71 @@\n+UI 22! IS-IS, length 469869187\n+\tL2 Lan IIH, hlen: 27, v: 1, pdu-v: 1, sys-id-len: 6 (0), max-area: 224 (224)\n+\t  source-id: fed0.f90f.58af,  holding time: 34047s, Flags: [unknown circuit type 0x00]\n+\t  lan-id:    0105.0088.a204.00, Priority: 65, PDU length: 4096\n+\t    unknown TLV #64, length: 128\n+\t\t0x0000:  ff10 8e12 0001 1b01 0000 6b00 fbcf f90f\n+\t\t0x0010:  58af 84ff 1000 4901 0000 88a2 011c 000c\n+\t\t0x0020:  0281 0083 1b01 0010 019d e000 fed0 f90f\n+\t\t0x0030:  58af 84ff 1000 4101 0500 88a2 011c 0272\n+\t\t0x0040:  0c2a 2205 831b 011c 0010 0000 0583 1b01\n+\t\t0x0050:  0010 01ab e000 fe08 0808 0808 08cb 0808\n+\t\t0x0060:  0808 0808 0808 0880 0008 7f08 0808 0808\n+\t\t0x0070:  08fd 0808 080c 0608 0807 0808 0808 0408\n+\t    Padding TLV #8, length: 8\n+\t    Padding TLV #8, length: 8\n+\t    Padding TLV #8, length: 7\n+\t    Padding TLV #8, length: 8\n+\t    Padding TLV #8, length: 0\n+\t    Padding TLV #8, length: 8\n+\t    unknown TLV #100, length: 0\n+\t    unknown TLV #32, length: 16\n+\t\t0x0000:  2020 2020 3c20 2020 2020 2020 205a 1a31\n+\t    IS Neighbor(s) (variable length) TLV #7, length: 238\n+\t      LAN address length 1 bytes \n+\t\tIS Neighbor: 5a\n+\t\tIS Neighbor: 45\n+\t\tIS Neighbor: 50\n+\t\tIS Neighbor: 48\n+\t\tIS Neighbor: 59\n+\t\tIS Neighbor: 52\n+\t\tIS Neighbor: 5f\n+\t\tIS Neighbor: 43\n+\t\tIS Neighbor: 54\n+\t\tIS Neighbor: 4c\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 08\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 64\n+\t\tIS Neighbor: 00\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 10\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20\n+\t\tIS Neighbor: 20 [|isis]"
            }
        ],
        "error_msg": "    isis_sysid_asan                    : TEST FAILED(exit 256)\n"
    },
    "5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e___print-isoclns.c": {
        "prefix": "static int\nisis_print_is_reach_subtlv(netdissect_options *ndo,\n                           const uint8_t *tptr, u_int subt, u_int subl,\n                           const char *ident)\n{\n        u_int te_class,priority_level,gmpls_switch_cap;\n        union { /* int to float conversion buffer for several subTLVs */\n            float f;\n            uint32_t i;\n        } bw;\n\n        /* first lets see if we know the subTLVs name*/\n\tND_PRINT((ndo, \"%s%s subTLV #%u, length: %u\",\n\t          ident, tok2str(isis_ext_is_reach_subtlv_values, \"unknown\", subt),\n\t          subt, subl));\n\n\tND_TCHECK2(*tptr, subl);\n\n        switch(subt) {\n        case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP:\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID:\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID:\n\t    if (subl >= 4) {\n\t      ND_PRINT((ndo, \", 0x%08x\", EXTRACT_32BITS(tptr)));\n\t      if (subl == 8) /* rfc4205 */\n\t        ND_PRINT((ndo, \", 0x%08x\", EXTRACT_32BITS(tptr+4)));\n\t    }\n\t    break;\n        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR:\n        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR:\n            if (subl >= sizeof(struct in_addr))\n              ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr)));\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW :\n\tcase ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW:\n            if (subl >= 4) {\n              bw.i = EXTRACT_32BITS(tptr);\n              ND_PRINT((ndo, \", %.3f Mbps\", bw.f * 8 / 1000000));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW :\n            if (subl >= 32) {\n              for (te_class = 0; te_class < 8; te_class++) {\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  TE-Class %u: %.3f Mbps\",\n                       ident,\n                       te_class,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n\t      }\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS: /* fall through */\n        case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD:\n            ND_PRINT((ndo, \"%sBandwidth Constraints Model ID: %s (%u)\",\n                   ident,\n                   tok2str(diffserv_te_bc_values, \"unknown\", *tptr),\n                   *tptr));\n            tptr++;\n            /* decode BCs until the subTLV ends */\n            for (te_class = 0; te_class < (subl-1)/4; te_class++) {\n",
        "suffix": "                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Bandwidth constraint CT%u: %.3f Mbps\",\n                       ident,\n                       te_class,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC:\n            if (subl >= 3)\n              ND_PRINT((ndo, \", %u\", EXTRACT_24BITS(tptr)));\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE:\n            if (subl == 2) {\n               ND_PRINT((ndo, \", [ %s ] (0x%04x)\",\n                      bittok2str(isis_subtlv_link_attribute_values,\n                                 \"Unknown\",\n                                 EXTRACT_16BITS(tptr)),\n                      EXTRACT_16BITS(tptr)));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE:\n            if (subl >= 2) {\n              ND_PRINT((ndo, \", %s, Priority %u\",\n\t\t   bittok2str(gmpls_link_prot_values, \"none\", *tptr),\n                   *(tptr+1)));\n            }\n            break;\n        case ISIS_SUBTLV_SPB_METRIC:\n            if (subl >= 6) {\n              ND_PRINT((ndo, \", LM: %u\", EXTRACT_24BITS(tptr)));\n              tptr=tptr+3;\n              ND_PRINT((ndo, \", P: %u\", *(tptr)));\n              tptr++;\n              ND_PRINT((ndo, \", P-ID: %u\", EXTRACT_16BITS(tptr)));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR:\n            if (subl >= 36) {\n              gmpls_switch_cap = *tptr;\n              ND_PRINT((ndo, \"%s  Interface Switching Capability:%s\",\n                   ident,\n                   tok2str(gmpls_switch_cap_values, \"Unknown\", gmpls_switch_cap)));\n              ND_PRINT((ndo, \", LSP Encoding: %s\",\n                   tok2str(gmpls_encoding_values, \"Unknown\", *(tptr + 1))));\n\t      tptr+=4;\n              ND_PRINT((ndo, \"%s  Max LSP Bandwidth:\", ident));\n              for (priority_level = 0; priority_level < 8; priority_level++) {\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s    priority level %d: %.3f Mbps\",\n                       ident,\n                       priority_level,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n              }\n              subl-=36;\n              switch (gmpls_switch_cap) {\n              case GMPLS_PSC1:\n              case GMPLS_PSC2:\n              case GMPLS_PSC3:\n              case GMPLS_PSC4:\n                ND_TCHECK2(*tptr, 6);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Min LSP Bandwidth: %.3f Mbps\", ident, bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Interface MTU: %u\", ident, EXTRACT_16BITS(tptr + 4)));\n                break;\n              case GMPLS_TSC:\n                ND_TCHECK2(*tptr, 8);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Min LSP Bandwidth: %.3f Mbps\", ident, bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Indication %s\", ident,\n                       tok2str(gmpls_switch_cap_tsc_indication_values, \"Unknown (%u)\", *(tptr + 4))));\n                break;\n              default:\n                /* there is some optional stuff left to decode but this is as of yet\n                   not specified so just lets hexdump what is left */\n                if(subl>0){\n                  if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t    \", subl))\n                    return(0);\n                }\n              }\n            }\n            break;\n        default:\n            if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t    \", subl))\n                return(0);\n            break;\n        }\n        return(1);\n\ntrunc:\n    return(0);\n}\n",
        "start": 1810,
        "end": 1964,
        "buggy": "static int\nisis_print_is_reach_subtlv(netdissect_options *ndo,\n                           const uint8_t *tptr, u_int subt, u_int subl,\n                           const char *ident)\n{\n        u_int te_class,priority_level,gmpls_switch_cap;\n        union { /* int to float conversion buffer for several subTLVs */\n            float f;\n            uint32_t i;\n        } bw;\n\n        /* first lets see if we know the subTLVs name*/\n\tND_PRINT((ndo, \"%s%s subTLV #%u, length: %u\",\n\t          ident, tok2str(isis_ext_is_reach_subtlv_values, \"unknown\", subt),\n\t          subt, subl));\n\n\tND_TCHECK2(*tptr, subl);\n\n        switch(subt) {\n        case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP:\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID:\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID:\n\t    if (subl >= 4) {\n\t      ND_PRINT((ndo, \", 0x%08x\", EXTRACT_32BITS(tptr)));\n\t      if (subl == 8) /* rfc4205 */\n\t        ND_PRINT((ndo, \", 0x%08x\", EXTRACT_32BITS(tptr+4)));\n\t    }\n\t    break;\n        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR:\n        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR:\n            if (subl >= sizeof(struct in_addr))\n              ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr)));\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW :\n\tcase ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW:\n            if (subl >= 4) {\n              bw.i = EXTRACT_32BITS(tptr);\n              ND_PRINT((ndo, \", %.3f Mbps\", bw.f * 8 / 1000000));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW :\n            if (subl >= 32) {\n              for (te_class = 0; te_class < 8; te_class++) {\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  TE-Class %u: %.3f Mbps\",\n                       ident,\n                       te_class,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n\t      }\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS: /* fall through */\n        case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD:\n            ND_PRINT((ndo, \"%sBandwidth Constraints Model ID: %s (%u)\",\n                   ident,\n                   tok2str(diffserv_te_bc_values, \"unknown\", *tptr),\n                   *tptr));\n            tptr++;\n            /* decode BCs until the subTLV ends */\n            for (te_class = 0; te_class < (subl-1)/4; te_class++) {\n                ND_TCHECK2(*tptr, 4);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Bandwidth constraint CT%u: %.3f Mbps\",\n                       ident,\n                       te_class,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC:\n            if (subl >= 3)\n              ND_PRINT((ndo, \", %u\", EXTRACT_24BITS(tptr)));\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE:\n            if (subl == 2) {\n               ND_PRINT((ndo, \", [ %s ] (0x%04x)\",\n                      bittok2str(isis_subtlv_link_attribute_values,\n                                 \"Unknown\",\n                                 EXTRACT_16BITS(tptr)),\n                      EXTRACT_16BITS(tptr)));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE:\n            if (subl >= 2) {\n              ND_PRINT((ndo, \", %s, Priority %u\",\n\t\t   bittok2str(gmpls_link_prot_values, \"none\", *tptr),\n                   *(tptr+1)));\n            }\n            break;\n        case ISIS_SUBTLV_SPB_METRIC:\n            if (subl >= 6) {\n              ND_PRINT((ndo, \", LM: %u\", EXTRACT_24BITS(tptr)));\n              tptr=tptr+3;\n              ND_PRINT((ndo, \", P: %u\", *(tptr)));\n              tptr++;\n              ND_PRINT((ndo, \", P-ID: %u\", EXTRACT_16BITS(tptr)));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR:\n            if (subl >= 36) {\n              gmpls_switch_cap = *tptr;\n              ND_PRINT((ndo, \"%s  Interface Switching Capability:%s\",\n                   ident,\n                   tok2str(gmpls_switch_cap_values, \"Unknown\", gmpls_switch_cap)));\n              ND_PRINT((ndo, \", LSP Encoding: %s\",\n                   tok2str(gmpls_encoding_values, \"Unknown\", *(tptr + 1))));\n\t      tptr+=4;\n              ND_PRINT((ndo, \"%s  Max LSP Bandwidth:\", ident));\n              for (priority_level = 0; priority_level < 8; priority_level++) {\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s    priority level %d: %.3f Mbps\",\n                       ident,\n                       priority_level,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n              }\n              subl-=36;\n              switch (gmpls_switch_cap) {\n              case GMPLS_PSC1:\n              case GMPLS_PSC2:\n              case GMPLS_PSC3:\n              case GMPLS_PSC4:\n                ND_TCHECK2(*tptr, 6);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Min LSP Bandwidth: %.3f Mbps\", ident, bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Interface MTU: %u\", ident, EXTRACT_16BITS(tptr + 4)));\n                break;\n              case GMPLS_TSC:\n                ND_TCHECK2(*tptr, 8);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Min LSP Bandwidth: %.3f Mbps\", ident, bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Indication %s\", ident,\n                       tok2str(gmpls_switch_cap_tsc_indication_values, \"Unknown (%u)\", *(tptr + 4))));\n                break;\n              default:\n                /* there is some optional stuff left to decode but this is as of yet\n                   not specified so just lets hexdump what is left */\n                if(subl>0){\n                  if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t    \", subl))\n                    return(0);\n                }\n              }\n            }\n            break;\n        default:\n            if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t    \", subl))\n                return(0);\n            break;\n        }\n        return(1);\n\ntrunc:\n    return(0);\n}\n",
        "fix": null,
        "buggy_hunk_masked": "                ND_TCHECK2(*tptr, 4);\n",
        "src_path": "5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e___print-isoclns.c",
        "uri": "https://api.github.com/repos/the-tcpdump-group/tcpdump/commits/5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e",
        "commit_msg": "CVE-2017-13055/IS-IS: fix an Extended IS Reachability sub-TLV\n\nIn isis_print_is_reach_subtlv() one of the case blocks did not check that\nthe sub-TLV \"V\" is actually present and could over-read the input buffer.\nAdd a length check to fix that and remove a useless boundary check from\na loop because the boundary is tested for the full length of \"V\" before\nthe switch block.\n\nUpdate one of the prior test cases as it turns out it depended on this\npreviously incorrect code path to make it to its own malformed structure\nfurther down the buffer, the bugfix has changed its output.\n\nThis fixes a buffer over-read discovered by Bhargava Shastry,\nSecT/TU Berlin.\n\nAdd a test using the capture file supplied by the reporter(s).",
        "test_func_diff": [
            {
                "fn": "tests/TESTLIST",
                "patch": "@@ -574,6 +574,7 @@ rpki-rtr-oob\t\trpki-rtr-oob.pcap\trpki-rtr-oob.out\t-v -c1\n lldp_8023_mtu-oobr\tlldp_8023_mtu-oobr.pcap\tlldp_8023_mtu-oobr.out\t-v -c1\n bgp_vpn_rt-oobr\tbgp_vpn_rt-oobr.pcap\tbgp_vpn_rt-oobr.out\t-v -c1\n cfm_sender_id-oobr\tcfm_sender_id-oobr.pcap\tcfm_sender_id-oobr.out\t-v -c1\n+isis-extd-isreach-oobr\tisis-extd-isreach-oobr.pcap\tisis-extd-isreach-oobr.out -v -c4\n \n # bad packets from Katie Holly\n mlppp-oobr\t\tmlppp-oobr.pcap\t\t\tmlppp-oobr.out"
            },
            {
                "fn": "tests/isis-extd-isreach-oobr.out",
                "patch": "@@ -0,0 +1,39 @@\n+OSI NLPID 0xfe unknown, length: 33554428\n+\t0x0000:  fe7f 4a01 0066 0002 00ff ffff f200 0000\n+\t0x0010:  00c6 0000 007f e6ff 00e6 6800 0000\n+unknown CHDLC protocol (0xfafe)\n+OSI NLPID 0xfe unknown, length: 33554428\n+\t0x0000:  fe7f 4a01 f165 0002 0000 0000 0000 0000\n+\t0x0010:  00c6 0000 007f e6ff 00e6 6800 0000\n+IS-IS, length 33554427\n+\tL2 Lan IIH, hlen: 27, v: 1, pdu-v: 1, sys-id-len: 6 (0), max-area: 3 (0)\n+\t  source-id: 3801.0101.0101,  holding time: 257s, Flags: [unknown circuit type 0x00]\n+\t  lan-id:    0101.0101.0100.00, Priority: 1, PDU length: 257\n+\t    Extended IS Reachability TLV #22, length: 12\n+\t      IS Neighbor: 0d0d.0d0d.0d0d.0d, Metric: 855309, sub-TLVs present (13)\n+\t        unknown subTLV #13, length: 13\n+\t\t    0x0000:  0d0d 0d0d 0d0d 0d0d 0d0d 0d0d 0d\n+\t      IS Neighbor: 0d0d.0d0d.0d0d.0d, Metric: 855309, sub-TLVs present (13)\n+\t        unknown subTLV #13, length: 13\n+\t\t    0x0000:  0d0d 0d0d 0d0d 0d64 0d0d 0d0d 0d\n+\t      IS Neighbor: 0d0d.0d0d.0d0d.0d, Metric: 855309, sub-TLVs present (13)\n+\t        unknown subTLV #13, length: 13\n+\t\t    0x0000:  0d0d 0d0d 0d0d 0d0d 0d0d 0d0d 0d\n+\t      IS Neighbor: 0d0d.0d0d.0d0d.0d, Metric: 855309, sub-TLVs present (13)\n+\t        unknown subTLV #13, length: 13\n+\t\t    0x0000:  1c0d 0d0d 0d0d 670d 0d0d 0d0d 0d\n+\t      IS Neighbor: 0d0d.0d00.0000.40, Metric: 13391955, sub-TLVs present (3)\n+\t        unknown subTLV #41, length: 16\n+\t\t    0x0000:  0022 0000 0000 0000 0000 0000 0000 0000\n+\t      IS Neighbor: 0000.0000.0a16.00, Metric: 2097279, no sub-TLVs present\n+\t      IS Neighbor: 0000.3604.1f01.16, Metric: 70400, no sub-TLVs present\n+\t      IS Neighbor: 0012.3a01.4996.01, Metric: 8838496, no sub-TLVs present\n+\t      IS Neighbor: 00c7.8787.8766.87, Metric: 0, sub-TLVs present (64)\n+\t        unknown subTLV #120, length: 22\n+\t\t    0x0000:  0101 0100 f0ff ffff ff01 0101 434c 4945\n+\t\t    0x0010:  4e54 0101 011f\n+\t        Link Local/Remote Identifier subTLV #4, length: 4, 0x04040404\n+\t        Link Local/Remote Identifier subTLV #4, length: 4, 0x04040404\n+\t        Link Local/Remote Identifier subTLV #4, length: 4, 0x0404000a\n+\t        Bandwidth Constraints subTLV #22, length: 0\n+\t\t [|isis]"
            },
            {
                "fn": "tests/isis-seg-fault-1-v.out",
                "patch": "@@ -28,274 +28,155 @@ IS-IS, length 1497\n \t        unknown subTLV #0, length: 0\n \t        unknown subTLV #0, length: 0\n \t        Bandwidth Constraints subTLV #22, length: 0\n-\t        Bandwidth Constraints Model ID: Russian dolls (0)\n-\t          Bandwidth constraint CT0: 0.000 Mbps\n-\t          Bandwidth constraint CT1: 0.000 Mbps\n-\t          Bandwidth constraint CT2: 0.000 Mbps\n-\t          Bandwidth constraint CT3: 0.000 Mbps\n-\t          Bandwidth constraint CT4: 0.000 Mbps\n-\t          Bandwidth constraint CT5: 0.000 Mbps\n-\t          Bandwidth constraint CT6: -0.000 Mbps\n-\t          Bandwidth constraint CT7: 0.000 Mbps\n-\t          Bandwidth constraint CT8: 0.000 Mbps\n-\t          Bandwidth constraint CT9: 0.000 Mbps\n-\t          Bandwidth constraint CT10: 0.000 Mbps\n-\t          Bandwidth constraint CT11: 0.000 Mbps\n-\t          Bandwidth constraint CT12: 0.000 Mbps\n-\t          Bandwidth constraint CT13: 0.000 Mbps\n-\t          Bandwidth constraint CT14: -1267650597027719304708096.000 Mbps\n-\t          Bandwidth constraint CT15: 0.000 Mbps\n-\t          Bandwidth constraint CT16: 0.000 Mbps\n-\t          Bandwidth constraint CT17: 0.000 Mbps\n-\t          Bandwidth constraint CT18: 0.000 Mbps\n-\t          Bandwidth constraint CT19: 0.000 Mbps\n-\t          Bandwidth constraint CT20: 0.000 Mbps\n-\t          Bandwidth constraint CT21: 0.000 Mbps\n-\t          Bandwidth constraint CT22: 0.000 Mbps\n-\t          Bandwidth constraint CT23: 0.000 Mbps\n-\t          Bandwidth constraint CT24: 0.000 Mbps\n-\t          Bandwidth constraint CT25: 0.000 Mbps\n-\t          Bandwidth constraint CT26: 0.000 Mbps\n-\t          Bandwidth constraint CT27: 0.000 Mbps\n-\t          Bandwidth constraint CT28: 0.000 Mbps\n-\t          Bandwidth constraint CT29: 0.000 Mbps\n-\t          Bandwidth constraint CT30: 0.000 Mbps\n-\t          Bandwidth constraint CT31: 0.000 Mbps\n-\t          Bandwidth constraint CT32: 0.000 Mbps\n-\t          Bandwidth constraint CT33: 0.000 Mbps\n-\t          Bandwidth constraint CT34: 0.000 Mbps\n-\t          Bandwidth constraint CT35: 0.000 Mbps\n-\t          Bandwidth constraint CT36: 0.000 Mbps\n-\t          Bandwidth constraint CT37: 0.000 Mbps\n-\t          Bandwidth constraint CT38: 16.777 Mbps\n-\t          Bandwidth constraint CT39: 0.000 Mbps\n-\t          Bandwidth constraint CT40: 0.000 Mbps\n-\t          Bandwidth constraint CT41: 0.000 Mbps\n-\t          Bandwidth constraint CT42: 0.000 Mbps\n-\t          Bandwidth constraint CT43: 0.000 Mbps\n-\t          Bandwidth constraint CT44: 0.000 Mbps\n-\t          Bandwidth constraint CT45: 0.000 Mbps\n-\t          Bandwidth constraint CT46: 0.000 Mbps\n-\t          Bandwidth constraint CT47: 0.000 Mbps\n-\t          Bandwidth constraint CT48: 0.000 Mbps\n-\t          Bandwidth constraint CT49: 0.000 Mbps\n-\t          Bandwidth constraint CT50: 0.000 Mbps\n-\t          Bandwidth constraint CT51: 0.000 Mbps\n-\t          Bandwidth constraint CT52: 0.000 Mbps\n-\t          Bandwidth constraint CT53: 0.000 Mbps\n-\t          Bandwidth constraint CT54: 0.000 Mbps\n-\t          Bandwidth constraint CT55: 0.000 Mbps\n-\t          Bandwidth constraint CT56: 0.000 Mbps\n-\t          Bandwidth constraint CT57: 0.000 Mbps\n-\t          Bandwidth constraint CT58: 0.000 Mbps\n-\t          Bandwidth constraint CT59: 0.000 Mbps\n-\t          Bandwidth constraint CT60: 0.000 Mbps\n-\t          Bandwidth constraint CT61: 0.000 Mbps\n-\t          Bandwidth constraint CT62: 0.000 Mbps\n-\t          Bandwidth constraint CT63: 0.000 Mbps\n-\t          Bandwidth constraint CT64: 0.000 Mbps\n-\t          Bandwidth constraint CT65: 0.000 Mbps\n-\t          Bandwidth constraint CT66: 0.000 Mbps\n-\t          Bandwidth constraint CT67: 0.000 Mbps\n-\t          Bandwidth constraint CT68: 0.000 Mbps\n-\t          Bandwidth constraint CT69: 0.000 Mbps\n-\t          Bandwidth constraint CT70: 0.000 Mbps\n-\t          Bandwidth constraint CT71: 0.000 Mbps\n-\t          Bandwidth constraint CT72: 0.000 Mbps\n-\t          Bandwidth constraint CT73: 0.000 Mbps\n-\t          Bandwidth constraint CT74: 0.000 Mbps\n-\t          Bandwidth constraint CT75: 0.000 Mbps\n-\t          Bandwidth constraint CT76: 0.000 Mbps\n-\t          Bandwidth constraint CT77: 0.000 Mbps\n-\t          Bandwidth constraint CT78: 0.000 Mbps\n-\t          Bandwidth constraint CT79: 0.000 Mbps\n-\t          Bandwidth constraint CT80: 0.000 Mbps\n-\t          Bandwidth constraint CT81: 0.000 Mbps\n-\t          Bandwidth constraint CT82: 0.000 Mbps\n-\t          Bandwidth constraint CT83: 0.000 Mbps\n-\t          Bandwidth constraint CT84: 0.000 Mbps\n-\t          Bandwidth constraint CT85: 0.000 Mbps\n-\t          Bandwidth constraint CT86: 0.000 Mbps\n-\t          Bandwidth constraint CT87: 0.000 Mbps\n-\t          Bandwidth constraint CT88: 0.000 Mbps\n-\t          Bandwidth constraint CT89: 0.000 Mbps\n-\t          Bandwidth constraint CT90: 0.000 Mbps\n-\t          Bandwidth constraint CT91: 0.000 Mbps\n-\t          Bandwidth constraint CT92: 0.000 Mbps\n-\t          Bandwidth constraint CT93: 0.000 Mbps\n-\t          Bandwidth constraint CT94: 0.000 Mbps\n-\t          Bandwidth constraint CT95: 0.000 Mbps\n-\t          Bandwidth constraint CT96: 0.000 Mbps\n-\t          Bandwidth constraint CT97: 0.000 Mbps\n-\t          Bandwidth constraint CT98: 0.000 Mbps\n-\t          Bandwidth constraint CT99: 0.000 Mbps\n-\t          Bandwidth constraint CT100: 0.000 Mbps\n-\t          Bandwidth constraint CT101: 0.000 Mbps\n-\t          Bandwidth constraint CT102: 0.000 Mbps\n-\t          Bandwidth constraint CT103: 0.000 Mbps\n-\t          Bandwidth constraint CT104: 0.000 Mbps\n-\t          Bandwidth constraint CT105: 0.000 Mbps\n-\t          Bandwidth constraint CT106: 0.000 Mbps\n-\t          Bandwidth constraint CT107: 0.000 Mbps\n-\t          Bandwidth constraint CT108: 0.000 Mbps\n-\t          Bandwidth constraint CT109: 0.000 Mbps\n-\t          Bandwidth constraint CT110: 334903128525925002608918921216.000 Mbps\n-\t          Bandwidth constraint CT111: 0.000 Mbps\n-\t          Bandwidth constraint CT112: 0.000 Mbps\n-\t          Bandwidth constraint CT113: 0.000 Mbps\n-\t          Bandwidth constraint CT114: 0.000 Mbps\n-\t          Bandwidth constraint CT115: 0.000 Mbps\n-\t          Bandwidth constraint CT116: 0.000 Mbps\n-\t          Bandwidth constraint CT117: 0.000 Mbps\n-\t          Bandwidth constraint CT118: 0.000 Mbps\n-\t          Bandwidth constraint CT119: 0.000 Mbps\n-\t          Bandwidth constraint CT120: 0.000 Mbps\n-\t          Bandwidth constraint CT121: 0.000 Mbps\n-\t          Bandwidth constraint CT122: 0.000 Mbps\n-\t          Bandwidth constraint CT123: 0.000 Mbps\n-\t          Bandwidth constraint CT124: 0.000 Mbps\n-\t          Bandwidth constraint CT125: 0.000 Mbps\n-\t          Bandwidth constraint CT126: 0.000 Mbps\n-\t          Bandwidth constraint CT127: 0.000 Mbps\n-\t          Bandwidth constraint CT128: 0.000 Mbps\n-\t          Bandwidth constraint CT129: 0.000 Mbps\n-\t          Bandwidth constraint CT130: 0.000 Mbps\n-\t          Bandwidth constraint CT131: 0.000 Mbps\n-\t          Bandwidth constraint CT132: 0.000 Mbps\n-\t          Bandwidth constraint CT133: 0.000 Mbps\n-\t          Bandwidth constraint CT134: 0.000 Mbps\n-\t          Bandwidth constraint CT135: 0.000 Mbps\n-\t          Bandwidth constraint CT136: 0.000 Mbps\n-\t          Bandwidth constraint CT137: -4.194 Mbps\n-\t          Bandwidth constraint CT138: 0.000 Mbps\n-\t          Bandwidth constraint CT139: 0.000 Mbps\n-\t          Bandwidth constraint CT140: 0.000 Mbps\n-\t          Bandwidth constraint CT141: 0.000 Mbps\n-\t          Bandwidth constraint CT142: 0.000 Mbps\n-\t          Bandwidth constraint CT143: 0.000 Mbps\n-\t          Bandwidth constraint CT144: 0.000 Mbps\n-\t          Bandwidth constraint CT145: 0.000 Mbps\n-\t          Bandwidth constraint CT146: 0.000 Mbps\n-\t          Bandwidth constraint CT147: 0.000 Mbps\n-\t          Bandwidth constraint CT148: 0.000 Mbps\n-\t          Bandwidth constraint CT149: 0.000 Mbps\n-\t          Bandwidth constraint CT150: 0.000 Mbps\n-\t          Bandwidth constraint CT151: 0.000 Mbps\n-\t          Bandwidth constraint CT152: 0.000 Mbps\n-\t          Bandwidth constraint CT153: 0.000 Mbps\n-\t          Bandwidth constraint CT154: 16.777 Mbps\n-\t          Bandwidth constraint CT155: 0.000 Mbps\n-\t          Bandwidth constraint CT156: 0.000 Mbps\n-\t          Bandwidth constraint CT157: 0.000 Mbps\n-\t          Bandwidth constraint CT158: 0.000 Mbps\n-\t          Bandwidth constraint CT159: 0.000 Mbps\n-\t          Bandwidth constraint CT160: 0.000 Mbps\n-\t          Bandwidth constraint CT161: 0.000 Mbps\n-\t          Bandwidth constraint CT162: 0.000 Mbps\n-\t          Bandwidth constraint CT163: 0.000 Mbps\n-\t          Bandwidth constraint CT164: 0.000 Mbps\n-\t          Bandwidth constraint CT165: 0.000 Mbps\n-\t          Bandwidth constraint CT166: 0.000 Mbps\n-\t          Bandwidth constraint CT167: 0.000 Mbps\n-\t          Bandwidth constraint CT168: 0.000 Mbps\n-\t          Bandwidth constraint CT169: 0.000 Mbps\n-\t          Bandwidth constraint CT170: 0.000 Mbps\n-\t          Bandwidth constraint CT171: 0.000 Mbps\n-\t          Bandwidth constraint CT172: 0.000 Mbps\n-\t          Bandwidth constraint CT173: 0.000 Mbps\n-\t          Bandwidth constraint CT174: 0.000 Mbps\n-\t          Bandwidth constraint CT175: 0.000 Mbps\n-\t          Bandwidth constraint CT176: 0.000 Mbps\n-\t          Bandwidth constraint CT177: 0.000 Mbps\n-\t          Bandwidth constraint CT178: 0.000 Mbps\n-\t          Bandwidth constraint CT179: 1099511.625 Mbps\n-\t          Bandwidth constraint CT180: 0.000 Mbps\n-\t          Bandwidth constraint CT181: 0.000 Mbps\n-\t          Bandwidth constraint CT182: 0.000 Mbps\n-\t          Bandwidth constraint CT183: 0.000 Mbps\n-\t          Bandwidth constraint CT184: 0.000 Mbps\n-\t          Bandwidth constraint CT185: 0.000 Mbps\n-\t          Bandwidth constraint CT186: 0.000 Mbps\n-\t          Bandwidth constraint CT187: 0.000 Mbps\n-\t          Bandwidth constraint CT188: 0.000 Mbps\n-\t          Bandwidth constraint CT189: 0.000 Mbps\n-\t          Bandwidth constraint CT190: 0.000 Mbps\n-\t          Bandwidth constraint CT191: 0.000 Mbps\n-\t          Bandwidth constraint CT192: 0.000 Mbps\n-\t          Bandwidth constraint CT193: 0.000 Mbps\n-\t          Bandwidth constraint CT194: 0.000 Mbps\n-\t          Bandwidth constraint CT195: 0.000 Mbps\n-\t          Bandwidth constraint CT196: 0.000 Mbps\n-\t          Bandwidth constraint CT197: 0.000 Mbps\n-\t          Bandwidth constraint CT198: 0.000 Mbps\n-\t          Bandwidth constraint CT199: 0.000 Mbps\n-\t          Bandwidth constraint CT200: 0.000 Mbps\n-\t          Bandwidth constraint CT201: 0.000 Mbps\n-\t          Bandwidth constraint CT202: 0.000 Mbps\n-\t          Bandwidth constraint CT203: 0.000 Mbps\n-\t          Bandwidth constraint CT204: 0.000 Mbps\n-\t          Bandwidth constraint CT205: 0.000 Mbps\n-\t          Bandwidth constraint CT206: 0.000 Mbps\n-\t          Bandwidth constraint CT207: 0.000 Mbps\n-\t          Bandwidth constraint CT208: 0.000 Mbps\n-\t          Bandwidth constraint CT209: 0.000 Mbps\n-\t          Bandwidth constraint CT210: 0.000 Mbps\n-\t          Bandwidth constraint CT211: 0.000 Mbps\n-\t          Bandwidth constraint CT212: 0.000 Mbps\n-\t          Bandwidth constraint CT213: 0.000 Mbps\n-\t          Bandwidth constraint CT214: 0.000 Mbps\n-\t          Bandwidth constraint CT215: 0.000 Mbps\n-\t          Bandwidth constraint CT216: 0.000 Mbps\n-\t          Bandwidth constraint CT217: 0.000 Mbps\n-\t          Bandwidth constraint CT218: 0.000 Mbps\n-\t          Bandwidth constraint CT219: 0.000 Mbps\n-\t          Bandwidth constraint CT220: 0.000 Mbps\n-\t          Bandwidth constraint CT221: 0.000 Mbps\n-\t          Bandwidth constraint CT222: 0.000 Mbps\n-\t          Bandwidth constraint CT223: 0.000 Mbps\n-\t          Bandwidth constraint CT224: 0.000 Mbps\n-\t          Bandwidth constraint CT225: 0.000 Mbps\n-\t          Bandwidth constraint CT226: 0.000 Mbps\n-\t          Bandwidth constraint CT227: 0.000 Mbps\n-\t          Bandwidth constraint CT228: 0.000 Mbps\n-\t          Bandwidth constraint CT229: 0.000 Mbps\n-\t          Bandwidth constraint CT230: -0.000 Mbps\n-\t          Bandwidth constraint CT231: 0.000 Mbps\n-\t          Bandwidth constraint CT232: 0.000 Mbps\n-\t          Bandwidth constraint CT233: 0.000 Mbps\n-\t          Bandwidth constraint CT234: 0.000 Mbps\n-\t          Bandwidth constraint CT235: 0.000 Mbps\n-\t          Bandwidth constraint CT236: 0.000 Mbps\n-\t          Bandwidth constraint CT237: 0.000 Mbps\n-\t          Bandwidth constraint CT238: 0.000 Mbps\n-\t          Bandwidth constraint CT239: 0.000 Mbps\n-\t          Bandwidth constraint CT240: 0.000 Mbps\n-\t          Bandwidth constraint CT241: 0.000 Mbps\n-\t          Bandwidth constraint CT242: 0.000 Mbps\n-\t          Bandwidth constraint CT243: 0.000 Mbps\n-\t          Bandwidth constraint CT244: 0.000 Mbps\n-\t          Bandwidth constraint CT245: 0.000 Mbps\n-\t          Bandwidth constraint CT246: 0.000 Mbps\n-\t          Bandwidth constraint CT247: 0.000 Mbps\n-\t          Bandwidth constraint CT248: 0.000 Mbps\n-\t          Bandwidth constraint CT249: 0.000 Mbps\n-\t          Bandwidth constraint CT250: 0.000 Mbps\n-\t          Bandwidth constraint CT251: 0.000 Mbps\n-\t          Bandwidth constraint CT252: 0.000 Mbps\n-\t          Bandwidth constraint CT253: 0.000 Mbps\n-\t          Bandwidth constraint CT254: 0.000 Mbps\n-\t          Bandwidth constraint CT255: 0.000 Mbps\n-\t          Bandwidth constraint CT256: 0.000 Mbps\n-\t          Bandwidth constraint CT257: 0.000 Mbps\n-\t          Bandwidth constraint CT258: 0.000 Mbps\n-\t          Bandwidth constraint CT259: 0.000 Mbps\n-\t          Bandwidth constraint CT260: 0.000 Mbps\n-\t          Bandwidth constraint CT261: 0.000 Mbps\n-\t          Bandwidth constraint CT262: 0.000 Mbps\n-\t          Bandwidth constraint CT263: 0.000 Mbps\n-\t          Bandwidth constraint CT264: 0.000 Mbps\n-\t          Bandwidth constraint CT265: 0.000 Mbps\n-\t          Bandwidth constraint CT266: 0.000 Mbps\n-\t          Bandwidth constraint CT267: 0.000 Mbps\n-\t          Bandwidth constraint CT268: 0.000 Mbps\n-\t\t [|isis]\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #64, length: 0\n+\t        unknown subTLV #0, length: 189\n+\t\t    0x0000:  0000 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0010:  00c2 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0020:  0000 0000 0000 0000 0000 0000 0020 0000\n+\t\t    0x0030:  00f0 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0040:  0000 0000 0000 0000 0000 0000 5900 0000\n+\t\t    0x0050:  0000 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0060:  0000 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0070:  0000 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x0080:  0000 0000 0000 0000 0000 7d00 0008 ff00\n+\t\t    0x0090:  004a 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x00a0:  8000 0000 0000 0000 0000 0000 0000 0000\n+\t\t    0x00b0:  0000 0000 0000 0000 0000 0000 00\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 3400.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.2302.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0069.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0200.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0067.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, sub-TLVs present (37)\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 7800.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0065.00, sub-TLVs present (128)\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #66, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 8\n+\t\t    0x0000:  0000 0008 ff00 0000\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #121, length: 1\n+\t\t    0x0000:  00\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #50, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #0, length: 0\n+\t        unknown subTLV #132, length: 8\n+\t\t    0x0000:  0000 0000 0000 0000\n+\t        unknown subTLV #0, length: 0\n+\t      IS Neighbor: 8900.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 2500.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.2500.0000.c9, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0008.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: f700.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.004f.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 3d00.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0080.0002.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.007e.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t      IS Neighbor: 0000.0000.0000.00, no sub-TLVs present\n+\t    Padding TLV #8, length: 255\n+\t    Padding TLV #8, length: 255\n+\t    Padding TLV #8, length: 247\n+\t    unknown TLV #0, length: 0\n+\t    unknown TLV #0, length: 0\n+\t    unknown TLV #0, length: 0\n+\t    unknown TLV #0, length: 0\n+\t    Padding TLV #8, length: 155"
            }
        ],
        "error_msg": "    isis-extd-isreach-oobr             : TEST FAILED(exit 256)\n"
    },
    "2390ad111bde16a78c98ac44572090b33c3bd2d8___Client.cpp": {
        "prefix": "void CClient::EchoMessage(const CMessage& Message) {\n    CMessage EchoedMessage = Message;\n    for (CClient* pClient : GetClients()) {\n        if (pClient->HasEchoMessage() ||\n",
        "suffix": "                                 pClient->HasSelfMessage()))) {\n            EchoedMessage.SetNick(GetNickMask());\n            pClient->PutClient(EchoedMessage);\n        }\n    }\n}\n",
        "start": 888,
        "end": 898,
        "buggy": "void CClient::EchoMessage(const CMessage& Message) {\n    CMessage EchoedMessage = Message;\n    for (CClient* pClient : GetClients()) {\n        if (pClient->HasEchoMessage() ||\n            (pClient != this && (m_pNetwork->IsChan(Message.GetParam(0)) ||\n                                 pClient->HasSelfMessage()))) {\n            EchoedMessage.SetNick(GetNickMask());\n            pClient->PutClient(EchoedMessage);\n        }\n    }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "            (pClient != this && (m_pNetwork->IsChan(Message.GetParam(0)) ||\n",
        "src_path": "2390ad111bde16a78c98ac44572090b33c3bd2d8___Client.cpp",
        "uri": "https://api.github.com/repos/znc/znc/commits/2390ad111bde16a78c98ac44572090b33c3bd2d8",
        "commit_msg": "Fix null pointer dereference in echo-message\n\nThe bug was introduced while fixing #1705. If a client did not enable\necho-message, and doesn't have a network, it crashes.\n\nThanks to LunarBNC for reporting this",
        "test_func_diff": [
            {
                "fn": "test/integration/tests/core.cpp",
                "patch": "@@ -297,6 +297,14 @@ TEST_F(ZNCTest, StatusEchoMessage) {\n     client.Write(\"PRIVMSG *status :blah\");\n     client.ReadUntil(\":nick!user@irc.znc.in PRIVMSG *status :blah\");\n     client.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n+    client.Write(\"znc delnetwork test\");\n+    client.ReadUntil(\"Network deleted\");\n+    auto client2 = LoginClient();\n+    client2.Write(\"PRIVMSG *status :blah2\");\n+    client2.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n+    auto client3 = LoginClient();\n+    client3.Write(\"PRIVMSG *status :blah3\");\n+    client3.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n }\n \n }  // namespace"
            }
        ],
        "error_msg": "      <failure message=\"test/integration/framework/base.h:118&#x0A;Value of: m_device-&gt;waitForReadyRead(timeout_ms)&#x0A;  Actual: false&#x0A;Expected: true&#x0A;Wanted: :*status!znc@znc.in PRIVMSG nick :Unknown command\" type=\"\"><![CDATA[test/integration/framework/base.h:118\nValue of: m_device->waitForReadyRead(timeout_ms)\n  Actual: false\nExpected: true\nWanted: :*status!znc@znc.in PRIVMSG nick :Unknown command]]></failure>\n      <failure message=\"test/integration/framework/base.cpp:52&#x0A;Expected equality of these values:&#x0A;  m_proc.exitStatus()&#x0A;    Which is: 1&#x0A;  QProcess::NormalExit&#x0A;    Which is: 0\" type=\"\"><![CDATA[test/integration/framework/base.cpp:52\nExpected equality of these values:\n  m_proc.exitStatus()\n    Which is: 1\n  QProcess::NormalExit\n    Which is: 0]]></failure>\n      <failure message=\"test/integration/framework/base.cpp:56&#x0A;Expected equality of these values:&#x0A;  m_proc.exitCode()&#x0A;    Which is: 11&#x0A;  m_exit&#x0A;    Which is: 0\" type=\"\"><![CDATA[test/integration/framework/base.cpp:56\nExpected equality of these values:\n  m_proc.exitCode()\n    Which is: 11\n  m_exit\n    Which is: 0]]></failure>\n"
    },
    "77f619d48259383628c3ec4654b1ad578e9eb40e___gd.c": {
        "prefix": "BGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit, rightLimit;\n\tint i;\n\tint restoreAlphaBleding;\n\n",
        "suffix": "\t\t/* Refuse to fill to a non-solid border */\n\t\treturn;\n\t}\n\n\tleftLimit = (-1);\n\n\trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\t\n\tfor (i = x; (i >= 0); i--) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == (-1)) {\n\t\tim->alphaBlendingFlag = restoreAlphaBleding;\n\t\treturn;\n\t}\n\t/* Seek right */\n\trightLimit = x;\n\tfor (i = (x + 1); (i < im->sx); i++) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t/* Look at lines above and below and start paints */\n\t/* Above */\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c;\n\t\t\tc = gdImageGetPixel (im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\t/* Below */\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c = gdImageGetPixel (im, i, y + 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBleding;\n}\n",
        "start": 1923,
        "end": 2005,
        "buggy": "BGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit, rightLimit;\n\tint i;\n\tint restoreAlphaBleding;\n\n\tif (border < 0) {\n\t\t/* Refuse to fill to a non-solid border */\n\t\treturn;\n\t}\n\n\tleftLimit = (-1);\n\n\trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\t\n\tfor (i = x; (i >= 0); i--) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == (-1)) {\n\t\tim->alphaBlendingFlag = restoreAlphaBleding;\n\t\treturn;\n\t}\n\t/* Seek right */\n\trightLimit = x;\n\tfor (i = (x + 1); (i < im->sx); i++) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t/* Look at lines above and below and start paints */\n\t/* Above */\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c;\n\t\t\tc = gdImageGetPixel (im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\t/* Below */\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c = gdImageGetPixel (im, i, y + 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBleding;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\tif (border < 0) {\n",
        "src_path": "77f619d48259383628c3ec4654b1ad578e9eb40e___gd.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/77f619d48259383628c3ec4654b1ad578e9eb40e",
        "commit_msg": "fix #215 gdImageFillToBorder stack-overflow when invalid color is used",
        "test_func_diff": [
            {
                "fn": "tests/gdimagefilltoborder/.gitignore",
                "patch": "@@ -1 +1,2 @@\n /bug00037\n+/github_bug_215"
            },
            {
                "fn": "tests/gdimagefilltoborder/CMakeLists.txt",
                "patch": "@@ -1,5 +1,6 @@\n SET(TESTS_FILES\n \tbug00037\n+\tgithub_bug_215\n )\n \n ADD_GD_TESTS()"
            },
            {
                "fn": "tests/gdimagefilltoborder/Makemodule.am",
                "patch": "@@ -1,6 +1,7 @@\n if HAVE_LIBPNG\n libgd_test_programs += \\\n-\tgdimagefilltoborder/bug00037\n+\tgdimagefilltoborder/bug00037 \\\n+\tgdimagefilltoborder/github_bug_215\n endif\n \n EXTRA_DIST += \\"
            }
        ],
        "error_msg": "====================================\n   GD 2.2.1: tests/test-suite.log\n====================================\n\n# TOTAL: 107\n# PASS:  104\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  3\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:35: Total pixels changed: 9 with a maximum channel difference of 255.\nReference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gdimagefilltoborder/github_bug_215\n========================================\n\nFAIL gdimagefilltoborder/github_bug_215 (exit status: 139)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\n(491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\n"
    },
    "58b6dde319c301b0eae27d12e2a659e067d80558___gd_tga.c": {
        "prefix": "int read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tint* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint encoded_pixels;\n\tint rle_size;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\trle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);\n\t\tif (rle_size <= 0) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < rle_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n",
        "suffix": "\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + pixel_block_size > rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));\n\t\t\t\t\tbitmap_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));\n\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n",
        "start": 206,
        "end": 338,
        "buggy": "int read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tint* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint encoded_pixels;\n\tint rle_size;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\trle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);\n\t\tif (rle_size <= 0) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < rle_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n\t\t\t\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + pixel_block_size > rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));\n\t\t\t\t\tbitmap_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));\n\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\t\n",
        "src_path": "58b6dde319c301b0eae27d12e2a659e067d80558___gd_tga.c",
        "uri": "https://api.github.com/repos/libgd/libgd/commits/58b6dde319c301b0eae27d12e2a659e067d80558",
        "commit_msg": "Fix OOB reads of the TGA decompression buffer\n\nIt is possible to craft TGA files which will overflow the decompression\nbuffer, but not the image's bitmap. Therefore we also have to check for\npotential decompression buffer overflows.\n\nThis issue had been reported by Ibrahim El-Sayed to security@libgd.org;\na modified case exposing an off-by-one error of the first patch had been\nprovided by Konrad Beckmann.\n\nThis commit is an amendment to commit fb0e0cce, so we use CVE-2016-6906\nas well.",
        "test_func_diff": [
            {
                "fn": "tests/tga/Makemodule.am",
                "patch": "@@ -15,7 +15,8 @@ EXTRA_DIST += \\\n \ttga/bug00247a.tga \\\n \ttga/bug00248.tga \\\n \ttga/bug00248a.tga \\\n-\ttga/heap_overflow.tga \\\n+\ttga/heap_overflow_1.tga \\\n+\ttga/heap_overflow_2.tga \\\n \ttga/tga_read_rgb.png \\\n \ttga/tga_read_rgb.tga \\\n \ttga/tga_read_rgb_rle.tga"
            },
            {
                "fn": "tests/tga/heap_overflow.c",
                "patch": "@@ -1,27 +1,35 @@\n /**\n- * Test that the crafted TGA file doesn't trigger OOB reads.\n+ * Test that crafted TGA files don't trigger OOB reads.\n  */\n \n \n #include \"gd.h\"\n #include \"gdtest.h\"\n \n \n+static void check_file(char *basename);\n static size_t read_test_file(char **buffer, char *basename);\n \n \n int main()\n+{\n+    check_file(\"heap_overflow_1.tga\");\n+    check_file(\"heap_overflow_2.tga\");\n+\n+    return gdNumFailures();\n+}\n+\n+\n+static void check_file(char *basename)\n {\n     gdImagePtr im;\n     char *buffer;\n     size_t size;\n \n-    size = read_test_file(&buffer, \"heap_overflow.tga\");\n+    size = read_test_file(&buffer, basename);\n     im = gdImageCreateFromTgaPtr(size, (void *) buffer);\n     gdTestAssert(im == NULL);\n     free(buffer);\n-\n-    return gdNumFailures();\n }\n \n "
            }
        ],
        "error_msg": "========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 155\n# PASS:  153\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  2\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:31: Total pixels changed: 9 with a maximum channel difference of 255.\nfreetype/bug00132.c:33: Reference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\ngdimagestringft/gdimagestringft_bbox.c:56: (491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\n"
    },
    "28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5___spl_dllist.c": {
        "prefix": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = Z_SPLDLLIST_P(getThis());\n\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\t/* $obj[] = ... */\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\t/* $obj[$foo] = ... */\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\n\t\tindex = spl_offset_convert_to_long(zindex);\n\n\t\tif (index < 0 || index >= intern->llist->count) {\n",
        "suffix": "\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\n\t\tif (element != NULL) {\n\t\t\t/* call dtor on the old element as in spl_ptr_llist_pop */\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\n\t\t\t/* the element is replaced, delref the old one as in\n\t\t\t * SplDoublyLinkedList::pop() */\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\n\t\t\t/* new element, call ctor as in spl_ptr_llist_push */\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} /* }}} */\n",
        "start": 811,
        "end": 861,
        "buggy": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = Z_SPLDLLIST_P(getThis());\n\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\t/* $obj[] = ... */\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\t/* $obj[$foo] = ... */\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\n\t\tindex = spl_offset_convert_to_long(zindex);\n\n\t\tif (index < 0 || index >= intern->llist->count) {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\n\t\tif (element != NULL) {\n\t\t\t/* call dtor on the old element as in spl_ptr_llist_pop */\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\n\t\t\t/* the element is replaced, delref the old one as in\n\t\t\t * SplDoublyLinkedList::pop() */\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\n\t\t\t/* new element, call ctor as in spl_ptr_llist_push */\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} /* }}} */\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tzval_ptr_dtor(value);\n",
        "src_path": "28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5___spl_dllist.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5",
        "commit_msg": "Fix bug #71735: Double-free in SplDoublyLinkedList::offsetSet",
        "test_func_diff": [
            {
                "fn": "ext/spl/tests/bug71735.phpt",
                "patch": "@@ -0,0 +1,15 @@\n+--TEST--\n+Bug #71735 (Double-free in SplDoublyLinkedList::offsetSet)\n+--FILE--\n+<?php\n+try {\n+$var_1=new SplStack();\n+$var_1->offsetSet(100,new DateTime('2000-01-01'));\n+} catch(OutOfRangeException $e) {\n+\tprint $e->getMessage().\"\\n\";\n+}\n+?>\n+===DONE===\n+--EXPECT--\n+Offset invalid or out of range\n+===DONE===\n\\ No newline at end of file"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 7.0.6-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux wangjian 5.4.0-173-generic #191-Ubuntu SMP Fri Feb 2 13:55:07 UTC 2024 x86_64 INI actual : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5 More .INIs : CWD : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. FAIL Bug #71735 (Double-free in SplDoublyLinkedList::offsetSet) [ext/spl/tests/bug71735.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #71735 (Double-free in SplDoublyLinkedList::offsetSet) [ext/spl/tests/bug71735.phpt] =====================================================================\n"
    },
    "b88393f08a558eec14964a55d3c680fe67407712___wddx.c": {
        "prefix": "static int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n",
        "suffix": "\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;\n}\n",
        "start": 227,
        "end": 244,
        "buggy": "static int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n",
        "src_path": "b88393f08a558eec14964a55d3c680fe67407712___wddx.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/b88393f08a558eec14964a55d3c680fe67407712",
        "commit_msg": "Fix bug #72860: wddx_deserialize use-after-free",
        "test_func_diff": [
            {
                "fn": "ext/wddx/tests/bug72860.phpt",
                "patch": "@@ -0,0 +1,27 @@\n+--TEST--\n+Bug #72860: wddx_deserialize use-after-free\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+\n+$xml=<<<XML\n+<?xml version='1.0'?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+       <recordset fieldNames='F'>\n+               <field name='F'>\n+       </recordset>\n+</wddxPacket>\n+XML;\n+\n+var_dump(wddx_deserialize($xml));\n+?>\n+DONE\n+--EXPECT--\n+NULL\n+DONE\n\\ No newline at end of file"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.27-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux wangjian 5.4.0-173-generic #191-Ubuntu SMP Fri Feb 2 13:55:07 UTC 2024 x86_64 INI actual : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_b88393f08a558eec14964a55d3c680fe67407712 More .INIs : CWD : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_b88393f08a558eec14964a55d3c680fe67407712 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/wddx/tests/bug72860.phpt]\n \n===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 0 ( 0.0%) ( 0.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 1 (100.0%) (100.0%) --------------------------------------------------------------------- Time taken : 0 seconds =====================================================================\n"
    },
    "863d37ea66d5c960db08d6f4a2cbd2518f0f80d1___gd.c": {
        "prefix": "void gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit = -1, rightLimit;\n\tint i, restoreAlphaBlending = 0;\n\n",
        "suffix": "\t\t/* Refuse to fill to a non-solid border */\n\t\treturn;\n\t}\n\n\tif (!im->trueColor) {\n\t\tif ((color > (im->colorsTotal - 1)) || (border > (im->colorsTotal - 1)) || (color < 0)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\trestoreAlphaBlending = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\n\tfor (i = x; i >= 0; i--) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == -1) {\n\t\tim->alphaBlendingFlag = restoreAlphaBlending;\n\t\treturn;\n\t}\n\t/* Seek right */\n\trightLimit = x;\n\tfor (i = (x + 1); i < im->sx; i++) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t/* Look at lines above and below and start paints */\n\t/* Above */\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Below */\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y + 1);\n\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBlending;\n}\n",
        "start": 1743,
        "end": 1829,
        "buggy": "void gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit = -1, rightLimit;\n\tint i, restoreAlphaBlending = 0;\n\n\tif (border < 0) {\n\t\t/* Refuse to fill to a non-solid border */\n\t\treturn;\n\t}\n\n\tif (!im->trueColor) {\n\t\tif ((color > (im->colorsTotal - 1)) || (border > (im->colorsTotal - 1)) || (color < 0)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\trestoreAlphaBlending = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\n\tfor (i = x; i >= 0; i--) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == -1) {\n\t\tim->alphaBlendingFlag = restoreAlphaBlending;\n\t\treturn;\n\t}\n\t/* Seek right */\n\trightLimit = x;\n\tfor (i = (x + 1); i < im->sx; i++) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t/* Look at lines above and below and start paints */\n\t/* Above */\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Below */\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y + 1);\n\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBlending;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\tif (border < 0) {\n",
        "src_path": "863d37ea66d5c960db08d6f4a2cbd2518f0f80d1___gd.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/863d37ea66d5c960db08d6f4a2cbd2518f0f80d1",
        "commit_msg": "Fix #72696: imagefilltoborder stackoverflow on truecolor images\n\nWe must not allow negative color values be passed to\ngdImageFillToBorder(), because that can lead to infinite recursion\nsince the recursion termination condition will not necessarily be met.",
        "test_func_diff": [
            {
                "fn": "ext/gd/tests/bug72696.phpt",
                "patch": "@@ -0,0 +1,14 @@\n+--TEST--\n+Bug #72696 (imagefilltoborder stackoverflow on truecolor images)\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('gd')) die('skip gd extension not available');\n+?>\n+--FILE--\n+<?php\n+$im = imagecreatetruecolor(10, 10);\n+imagefilltoborder($im, 0, 0, 1, -2);\n+?>\n+===DONE===\n+--EXPECT--\n+===DONE==="
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.28-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux wangjian 5.4.0-173-generic #191-Ubuntu SMP Fri Feb 2 13:55:07 UTC 2024 x86_64 INI actual : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_863d37ea66d5c960db08d6f4a2cbd2518f0f80d1 More .INIs : CWD : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_863d37ea66d5c960db08d6f4a2cbd2518f0f80d1 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/gd/tests/bug72696.phpt]\nFAIL Bug #72696 (imagefilltoborder stackoverflow on truecolor images) [ext/gd/tests/bug72696.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72696 (imagefilltoborder stackoverflow on truecolor images) [ext/gd/tests/bug72696.phpt] =====================================================================\n"
    },
    "1cda0d7c2ffb62d8331c64e703131d9cabdc03ea___exif.c": {
        "prefix": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n",
        "suffix": "\t\t\t}\n\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\n\t\t/* Not sure if this is correct (never seen float used in Exif format) */\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}\n",
        "start": 1281,
        "end": 1325,
        "buggy": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n\t\t\t}\n\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\n\t\t/* Not sure if this is correct (never seen float used in Exif format) */\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n",
        "src_path": "1cda0d7c2ffb62d8331c64e703131d9cabdc03ea___exif.c",
        "uri": "https://api.github.com/repos/php/php-src/commits/1cda0d7c2ffb62d8331c64e703131d9cabdc03ea",
        "commit_msg": "Fix bug #73737 FPE when parsing a tag format",
        "test_func_diff": [
            {
                "fn": "ext/exif/tests/bug73737.phpt",
                "patch": "@@ -0,0 +1,12 @@\n+--TEST--\n+Bug #73737 (Crash when parsing a tag format)\n+--SKIPIF--\n+<?php if (!extension_loaded('exif')) print 'skip exif extension not available';?>\n+--FILE--\n+<?php\n+\t$exif = exif_thumbnail(__DIR__ . '/bug73737.tiff');\n+\tvar_dump($exif);\n+?>\n+--EXPECTF--\n+Warning: exif_thumbnail(bug73737.tiff): Error in TIFF: filesize(x0030) less than start of IFD dir(x10102) in %s line %d\n+bool(false)"
            }
        ],
        "error_msg": "===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.30-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux wangjian 5.4.0-173-generic #191-Ubuntu SMP Fri Feb 2 13:55:07 UTC 2024 x86_64 INI actual : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_1cda0d7c2ffb62d8331c64e703131d9cabdc03ea More .INIs : CWD : /mnt/local/home_dir/wj_code/dl_code/out/php___php-src/git_repo_dir_1cda0d7c2ffb62d8331c64e703131d9cabdc03ea Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/exif/tests/bug73737.phpt]\nFAIL Bug #73737 (Crash when parsing a tag format) [ext/exif/tests/bug73737.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #73737 (Crash when parsing a tag format) [ext/exif/tests/bug73737.phpt] =====================================================================\n"
    },
    "ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1___njs_module.c": {
        "prefix": "static njs_int_t\nnjs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n\n    trail = 0;\n    length = info->name.length;\n\n    if (dir != NULL) {\n",
        "suffix": "\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n\n        trail = (dir->start[dir->length - 1] != '/');\n\n        if (trail) {\n            length++;\n        }\n    }\n\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n\n    p = &src[0];\n\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n\n\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n\n    return NJS_OK;\n}\n",
        "start": 109,
        "end": 166,
        "buggy": "static njs_int_t\nnjs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n\n    trail = 0;\n    length = info->name.length;\n\n    if (dir != NULL) {\n        length = dir->length;\n\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n\n        trail = (dir->start[dir->length - 1] != '/');\n\n        if (trail) {\n            length++;\n        }\n    }\n\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n\n    p = &src[0];\n\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n\n\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n\n    return NJS_OK;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        length = dir->length;\n",
        "src_path": "ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1___njs_module.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1",
        "commit_msg": "Fixed typo while calculating module path length.\n\nThe issue was introduced in 77c398f26d7e (not released yet).",
        "test_func_diff": [
            {
                "fn": "test/js/import_very_long_path.t.js",
                "patch": "@@ -0,0 +1,9 @@\n+/*---\n+: []\n+paths: [test/js/module/]\n+negative:\n+  phase: runtime\n+---*/\n+\n+import name from 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';\n+ "
            }
        ],
        "error_msg": "==3079416==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fd596401021 at pc 0x55edf3809436 bp 0x7ffeef975e30 sp 0x7ffeef9755f8 WRITE of size 4097 at 0x7fd596401021 thread T0 #0 0x55edf3809435 in __asan_memcpy /src/llvm-project/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:22:3 #1 0x55edf38cdab1 in njs_module_path /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_module.c:148:18 #2 0x55edf38cdab1 in njs_module_lookup /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_module.c:83:11 #3 0x55edf38cdab1 in njs_default_module_loader /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_module.c:377:11 #4 0x55edf38cd119 in njs_parser_module /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_module.c:56:14 #5 0x55edf390a465 in njs_parser_import /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_parser.c:7793:24 #6 0x55edf38debd1 in njs_parser /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_parser.c:598:23 #7 0x55edf38590fd in njs_vm_compile /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_vm.c:159:11 #8 0x55edf3847293 in njs_process_script /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_shell.c:886:11 #9 0x55edf38466a5 in njs_process_file /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_shell.c:619:11 #10 0x55edf38466a5 in main /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_shell.c:303:15 #11 0x7fd59841a082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16 #12 0x55edf3771abd in _start (/mnt/local/home_dir/wj_code/dl_code/out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/build_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/njs+0x55abd) Address 0x7fd596401021 is located in stack of thread T0 at offset 4129 in frame #0 0x55edf38cd62f in njs_default_module_loader /out"
    },
    "8b39afdad9a0761e0a5d4af1a762bd9a6daef572___njs_array.c": {
        "prefix": "static njs_int_t\nnjs_array_prototype_sort(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t                i, und, len, nlen, length;\n    njs_int_t              ret, fast_path;\n    njs_array_t            *array;\n    njs_value_t            *this, *comparefn, *start, *strings;\n    njs_array_sort_ctx_t   ctx;\n    njs_array_sort_slot_t  *p, *end, *slots, *nslots;\n\n    comparefn = njs_arg(args, nargs, 1);\n\n    if (njs_is_defined(comparefn)) {\n        if (njs_slow_path(!njs_is_function(comparefn))) {\n            njs_type_error(vm, \"comparefn must be callable or undefined\");\n            return NJS_ERROR;\n        }\n\n        ctx.function = njs_function(comparefn);\n\n    } else {\n        ctx.function = NULL;\n    }\n\n    this = njs_argument(args, 0);\n\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_value_length(vm, this, &length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    if (njs_slow_path(length < 2)) {\n        vm->retval = *this;\n        return NJS_OK;\n    }\n\n    slots = NULL;\n    ctx.vm = vm;\n    ctx.strings.separate = 0;\n    ctx.strings.pointer = 0;\n    ctx.exception = 0;\n\n    fast_path = njs_is_fast_array(this);\n\n    if (njs_fast_path(fast_path)) {\n        array = njs_array(this);\n        start = array->start;\n\n        slots = njs_mp_alloc(vm->mem_pool,\n                             sizeof(njs_array_sort_slot_t) * length);\n        if (njs_slow_path(slots == NULL)) {\n                return NJS_ERROR;\n        }\n\n        und = 0;\n        p = slots;\n\n        for (i = 0; i < length; i++) {\n            if (njs_slow_path(!njs_is_valid(&start[i]))) {\n                fast_path = 0;\n                njs_mp_free(vm->mem_pool, slots);\n                slots = NULL;\n                goto slow_path;\n            }\n\n            if (njs_slow_path(njs_is_undefined(&start[i]))) {\n                und++;\n                continue;\n            }\n\n            p->value = start[i];\n            p->pos = i;\n            p->str = NULL;\n            p++;\n        }\n\n        len = p - slots;\n\n    } else {\n\nslow_path:\n\n        und = 0;\n        p = NULL;\n        end = NULL;\n\n        for (i = 0; i < length; i++) {\n            if (p >= end) {\n                nlen = njs_min(njs_max((p - slots) * 2, 8), length);\n                nslots = njs_mp_alloc(vm->mem_pool,\n                                      sizeof(njs_array_sort_slot_t) * nlen);\n                if (njs_slow_path(nslots == NULL)) {\n                    njs_memory_error(vm);\n                    return NJS_ERROR;\n                }\n\n                if (slots != NULL) {\n                    p = (void *) njs_cpymem(nslots, slots,\n                                  sizeof(njs_array_sort_slot_t) * (p - slots));\n                    njs_mp_free(vm->mem_pool, slots);\n\n                } else {\n                    p = nslots;\n                }\n\n                slots = nslots;\n                end = slots + nlen;\n            }\n\n            ret = njs_value_property_i64(vm, this, i, &p->value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                ret = NJS_ERROR;\n                goto exception;\n            }\n\n            if (ret == NJS_DECLINED) {\n                continue;\n            }\n\n            if (njs_is_undefined(&p->value)) {\n                und++;\n                continue;\n            }\n\n            p->pos = i;\n            p->str = NULL;\n            p++;\n        }\n\n        len = p - slots;\n    }\n\n    strings = njs_arr_init(vm->mem_pool, &ctx.strings, NULL, len + 1,\n                           sizeof(njs_value_t));\n    if (njs_slow_path(strings == NULL)) {\n        ret = NJS_ERROR;\n        goto exception;\n    }\n\n    njs_qsort(slots, len, sizeof(njs_array_sort_slot_t), njs_array_compare,\n              &ctx);\n\n    if (ctx.exception) {\n        ret = NJS_ERROR;\n        goto exception;\n    }\n\n",
        "suffix": "        array = njs_array(this);\n        start = array->start;\n\n        for (i = 0; i < len; i++) {\n            start[i] = slots[i].value;\n        }\n\n        for (i = len; und-- > 0; i++) {\n            start[i] = njs_value_undefined;\n        }\n\n    } else {\n        for (i = 0; i < len; i++) {\n            if (slots[i].pos != i) {\n                ret = njs_value_property_i64_set(vm, this, i, &slots[i].value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto exception;\n                }\n            }\n        }\n\n        for (i = len; und-- > 0; i++) {\n            ret = njs_value_property_i64_set(vm, this, i,\n                                          njs_value_arg(&njs_value_undefined));\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                goto exception;\n            }\n        }\n\n        for (; i < length; i++) {\n            ret = njs_value_property_i64_delete(vm, this, i, NULL);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                goto exception;\n            }\n        }\n    }\n\n    vm->retval = *this;\n\n    ret = NJS_OK;\n\nexception:\n\n    if (slots != NULL) {\n        njs_mp_free(vm->mem_pool, slots);\n    }\n\n    njs_arr_destroy(&ctx.strings);\n\n    return ret;\n}\n",
        "start": 2546,
        "end": 2750,
        "buggy": "static njs_int_t\nnjs_array_prototype_sort(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t                i, und, len, nlen, length;\n    njs_int_t              ret, fast_path;\n    njs_array_t            *array;\n    njs_value_t            *this, *comparefn, *start, *strings;\n    njs_array_sort_ctx_t   ctx;\n    njs_array_sort_slot_t  *p, *end, *slots, *nslots;\n\n    comparefn = njs_arg(args, nargs, 1);\n\n    if (njs_is_defined(comparefn)) {\n        if (njs_slow_path(!njs_is_function(comparefn))) {\n            njs_type_error(vm, \"comparefn must be callable or undefined\");\n            return NJS_ERROR;\n        }\n\n        ctx.function = njs_function(comparefn);\n\n    } else {\n        ctx.function = NULL;\n    }\n\n    this = njs_argument(args, 0);\n\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_value_length(vm, this, &length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    if (njs_slow_path(length < 2)) {\n        vm->retval = *this;\n        return NJS_OK;\n    }\n\n    slots = NULL;\n    ctx.vm = vm;\n    ctx.strings.separate = 0;\n    ctx.strings.pointer = 0;\n    ctx.exception = 0;\n\n    fast_path = njs_is_fast_array(this);\n\n    if (njs_fast_path(fast_path)) {\n        array = njs_array(this);\n        start = array->start;\n\n        slots = njs_mp_alloc(vm->mem_pool,\n                             sizeof(njs_array_sort_slot_t) * length);\n        if (njs_slow_path(slots == NULL)) {\n                return NJS_ERROR;\n        }\n\n        und = 0;\n        p = slots;\n\n        for (i = 0; i < length; i++) {\n            if (njs_slow_path(!njs_is_valid(&start[i]))) {\n                fast_path = 0;\n                njs_mp_free(vm->mem_pool, slots);\n                slots = NULL;\n                goto slow_path;\n            }\n\n            if (njs_slow_path(njs_is_undefined(&start[i]))) {\n                und++;\n                continue;\n            }\n\n            p->value = start[i];\n            p->pos = i;\n            p->str = NULL;\n            p++;\n        }\n\n        len = p - slots;\n\n    } else {\n\nslow_path:\n\n        und = 0;\n        p = NULL;\n        end = NULL;\n\n        for (i = 0; i < length; i++) {\n            if (p >= end) {\n                nlen = njs_min(njs_max((p - slots) * 2, 8), length);\n                nslots = njs_mp_alloc(vm->mem_pool,\n                                      sizeof(njs_array_sort_slot_t) * nlen);\n                if (njs_slow_path(nslots == NULL)) {\n                    njs_memory_error(vm);\n                    return NJS_ERROR;\n                }\n\n                if (slots != NULL) {\n                    p = (void *) njs_cpymem(nslots, slots,\n                                  sizeof(njs_array_sort_slot_t) * (p - slots));\n                    njs_mp_free(vm->mem_pool, slots);\n\n                } else {\n                    p = nslots;\n                }\n\n                slots = nslots;\n                end = slots + nlen;\n            }\n\n            ret = njs_value_property_i64(vm, this, i, &p->value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                ret = NJS_ERROR;\n                goto exception;\n            }\n\n            if (ret == NJS_DECLINED) {\n                continue;\n            }\n\n            if (njs_is_undefined(&p->value)) {\n                und++;\n                continue;\n            }\n\n            p->pos = i;\n            p->str = NULL;\n            p++;\n        }\n\n        len = p - slots;\n    }\n\n    strings = njs_arr_init(vm->mem_pool, &ctx.strings, NULL, len + 1,\n                           sizeof(njs_value_t));\n    if (njs_slow_path(strings == NULL)) {\n        ret = NJS_ERROR;\n        goto exception;\n    }\n\n    njs_qsort(slots, len, sizeof(njs_array_sort_slot_t), njs_array_compare,\n              &ctx);\n\n    if (ctx.exception) {\n        ret = NJS_ERROR;\n        goto exception;\n    }\n\n    if (njs_fast_path(fast_path)) {\n        array = njs_array(this);\n        start = array->start;\n\n        for (i = 0; i < len; i++) {\n            start[i] = slots[i].value;\n        }\n\n        for (i = len; und-- > 0; i++) {\n            start[i] = njs_value_undefined;\n        }\n\n    } else {\n        for (i = 0; i < len; i++) {\n            if (slots[i].pos != i) {\n                ret = njs_value_property_i64_set(vm, this, i, &slots[i].value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto exception;\n                }\n            }\n        }\n\n        for (i = len; und-- > 0; i++) {\n            ret = njs_value_property_i64_set(vm, this, i,\n                                          njs_value_arg(&njs_value_undefined));\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                goto exception;\n            }\n        }\n\n        for (; i < length; i++) {\n            ret = njs_value_property_i64_delete(vm, this, i, NULL);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                goto exception;\n            }\n        }\n    }\n\n    vm->retval = *this;\n\n    ret = NJS_OK;\n\nexception:\n\n    if (slots != NULL) {\n        njs_mp_free(vm->mem_pool, slots);\n    }\n\n    njs_arr_destroy(&ctx.strings);\n\n    return ret;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    if (njs_fast_path(fast_path)) {\n",
        "src_path": "8b39afdad9a0761e0a5d4af1a762bd9a6daef572___njs_array.c",
        "uri": "https://api.github.com/repos/nginx/njs/commits/8b39afdad9a0761e0a5d4af1a762bd9a6daef572",
        "commit_msg": "Fixed Array.prototype.sort() when arr size is changed in a comparator.\n\nThis fixed #468 issue on Github.",
        "test_func_diff": [
            {
                "fn": "src/test/njs_unit_test.c",
                "patch": "@@ -6989,6 +6989,9 @@ static njs_unit_test_t  njs_test[] =\n     { njs_str(\"[1,2].sort(1)\"),\n       njs_str(\"TypeError: comparefn must be callable or undefined\") },\n \n+    { njs_str(\"var a = [1,2]; a.sort(() => {a.length = 65535}); a.length\"),\n+      njs_str(\"65535\") },\n+\n     /*\n       Array.prototype.keys()\n       Array.prototype.values()"
            }
        ],
        "error_msg": "\n"
    },
    "d72ccf06c98259d7261e0f3ac4fd8717778782c1___extracts.cpp": {
        "prefix": "void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) {\n",
        "suffix": "  Trackage track = {0};\n\n  AtomicInfo *mvhdAtom = APar_FindAtom(\"moov.mvhd\", false, VERSIONED_ATOM, 0);\n  if (mvhdAtom != NULL) {\n    APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom);\n    fprintf(stdout,\n            \"Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate \"\n            \"(*=approximate)\\n\",\n            movie_info.seconds,\n            secsTOtime(movie_info.seconds),\n            movie_info.simple_bitrate_calc);\n    if (optional_output & SHOW_DATE_INFO) {\n      fprintf(stdout,\n              \"  Presentation Creation Date (UTC):     %s\\n\",\n              APar_extract_UTC(movie_info.creation_time));\n      fprintf(stdout,\n              \"  Presentation Modification Date (UTC): %s\\n\",\n              APar_extract_UTC(movie_info.modified_time));\n    }\n  }\n\n  AtomicInfo *iodsAtom = APar_FindAtom(\"moov.iods\", false, VERSIONED_ATOM, 0);\n  if (iodsAtom != NULL) {\n    movie_info.contains_iods = true;\n    APar_Extract_iods_Info(isofile, iodsAtom);\n  }\n\n  if (optional_output & SHOW_TRACK_INFO) {\n    APar_TrackLevelInfo(&track,\n                        NULL); // With track_num set to 0, it will return the\n                               // total trak atom into total_tracks here.\n\n    fprintf(\n        stdout, \"Low-level details. Total tracks: %u\\n\", track.total_tracks);\n    fprintf(stdout,\n            \"Trk  Type  Handler                    Kind  Lang  Bytes\\n\");\n\n    if (track.total_tracks > 0) {\n      while (track.total_tracks > track.track_num) {\n        track.track_num += 1;\n        TrackInfo track_info = {0};\n\n        // tracknum, handler type, handler name\n        APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info);\n        uint16_t more_whitespace =\n            purge_extraneous_characters(track_info.track_hdlr_name);\n\n        if (strlen(track_info.track_hdlr_name) == 0) {\n          memcpy(track_info.track_hdlr_name, \"[none listed]\", 13);\n        }\n        fprintf(stdout,\n                \"%u    %s  %s\",\n                track.track_num,\n                uint32tochar4(track_info.track_type, uint32_buffer),\n                track_info.track_hdlr_name);\n\n        uint16_t handler_len = strlen(track_info.track_hdlr_name);\n        if (handler_len < 25 + more_whitespace) {\n          for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) {\n            fprintf(stdout, \" \");\n          }\n        }\n\n        // codec, language\n        fprintf(stdout,\n                \"  %s  %s   %\" PRIu64,\n                uint32tochar4(track_info.track_codec, uint32_buffer),\n                track_info.unpacked_lang,\n                track_info.sample_aggregate);\n\n        if (track_info.encoder_name[0] != 0 && track_info.contains_esds) {\n          purge_extraneous_characters(track_info.encoder_name);\n          fprintf(stdout, \"   Encoder: %s\", track_info.encoder_name);\n        }\n        if (track_info.type_of_track & DRM_PROTECTED_TRACK) {\n          fprintf(stdout,\n                  \" (protected %s)\",\n                  uint32tochar4(track_info.protected_codec, uint32_buffer));\n        }\n\n        fprintf(stdout, \"\\n\");\n        /*---------------------------------*/\n\n        if (track_info.type_of_track & VIDEO_TRACK ||\n            track_info.type_of_track & AUDIO_TRACK) {\n          APar_Print_TrackDetails(&track_info);\n        }\n\n        if (optional_output & SHOW_DATE_INFO) {\n          fprintf(stdout,\n                  \"       Creation Date (UTC):     %s\\n\",\n                  APar_extract_UTC(track_info.creation_time));\n          fprintf(stdout,\n                  \"       Modification Date (UTC): %s\\n\",\n                  APar_extract_UTC(track_info.modified_time));\n        }\n      }\n    }\n  }\n}\n",
        "start": 1590,
        "end": 1691,
        "buggy": "void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) {\n  char uint32_buffer[5];\n  Trackage track = {0};\n\n  AtomicInfo *mvhdAtom = APar_FindAtom(\"moov.mvhd\", false, VERSIONED_ATOM, 0);\n  if (mvhdAtom != NULL) {\n    APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom);\n    fprintf(stdout,\n            \"Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate \"\n            \"(*=approximate)\\n\",\n            movie_info.seconds,\n            secsTOtime(movie_info.seconds),\n            movie_info.simple_bitrate_calc);\n    if (optional_output & SHOW_DATE_INFO) {\n      fprintf(stdout,\n              \"  Presentation Creation Date (UTC):     %s\\n\",\n              APar_extract_UTC(movie_info.creation_time));\n      fprintf(stdout,\n              \"  Presentation Modification Date (UTC): %s\\n\",\n              APar_extract_UTC(movie_info.modified_time));\n    }\n  }\n\n  AtomicInfo *iodsAtom = APar_FindAtom(\"moov.iods\", false, VERSIONED_ATOM, 0);\n  if (iodsAtom != NULL) {\n    movie_info.contains_iods = true;\n    APar_Extract_iods_Info(isofile, iodsAtom);\n  }\n\n  if (optional_output & SHOW_TRACK_INFO) {\n    APar_TrackLevelInfo(&track,\n                        NULL); // With track_num set to 0, it will return the\n                               // total trak atom into total_tracks here.\n\n    fprintf(\n        stdout, \"Low-level details. Total tracks: %u\\n\", track.total_tracks);\n    fprintf(stdout,\n            \"Trk  Type  Handler                    Kind  Lang  Bytes\\n\");\n\n    if (track.total_tracks > 0) {\n      while (track.total_tracks > track.track_num) {\n        track.track_num += 1;\n        TrackInfo track_info = {0};\n\n        // tracknum, handler type, handler name\n        APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info);\n        uint16_t more_whitespace =\n            purge_extraneous_characters(track_info.track_hdlr_name);\n\n        if (strlen(track_info.track_hdlr_name) == 0) {\n          memcpy(track_info.track_hdlr_name, \"[none listed]\", 13);\n        }\n        fprintf(stdout,\n                \"%u    %s  %s\",\n                track.track_num,\n                uint32tochar4(track_info.track_type, uint32_buffer),\n                track_info.track_hdlr_name);\n\n        uint16_t handler_len = strlen(track_info.track_hdlr_name);\n        if (handler_len < 25 + more_whitespace) {\n          for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) {\n            fprintf(stdout, \" \");\n          }\n        }\n\n        // codec, language\n        fprintf(stdout,\n                \"  %s  %s   %\" PRIu64,\n                uint32tochar4(track_info.track_codec, uint32_buffer),\n                track_info.unpacked_lang,\n                track_info.sample_aggregate);\n\n        if (track_info.encoder_name[0] != 0 && track_info.contains_esds) {\n          purge_extraneous_characters(track_info.encoder_name);\n          fprintf(stdout, \"   Encoder: %s\", track_info.encoder_name);\n        }\n        if (track_info.type_of_track & DRM_PROTECTED_TRACK) {\n          fprintf(stdout,\n                  \" (protected %s)\",\n                  uint32tochar4(track_info.protected_codec, uint32_buffer));\n        }\n\n        fprintf(stdout, \"\\n\");\n        /*---------------------------------*/\n\n        if (track_info.type_of_track & VIDEO_TRACK ||\n            track_info.type_of_track & AUDIO_TRACK) {\n          APar_Print_TrackDetails(&track_info);\n        }\n\n        if (optional_output & SHOW_DATE_INFO) {\n          fprintf(stdout,\n                  \"       Creation Date (UTC):     %s\\n\",\n                  APar_extract_UTC(track_info.creation_time));\n          fprintf(stdout,\n                  \"       Modification Date (UTC): %s\\n\",\n                  APar_extract_UTC(track_info.modified_time));\n        }\n      }\n    }\n  }\n}\n",
        "fix": null,
        "buggy_hunk_masked": "  char uint32_buffer[5];\n",
        "src_path": "d72ccf06c98259d7261e0f3ac4fd8717778782c1___extracts.cpp",
        "uri": "https://api.github.com/repos/wez/atomicparsley/commits/d72ccf06c98259d7261e0f3ac4fd8717778782c1",
        "commit_msg": "Avoid stack overflow\n\nrefs: https://github.com/wez/atomicparsley/issues/32",
        "test_func_diff": [
            {
                "fn": "tests/test.sh",
                "patch": "@@ -0,0 +1,3 @@\n+#!/bin/bash\n+set -xe\n+./AtomicParsley ./tests/issue-32.mp4 -T 1 -t +"
            }
        ],
        "error_msg": "==61839==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7f4646400225 at pc 0x55c03130fbc1 bp 0x7ffd9e6798a0 sp 0x7ffd9e679070\nWRITE of size 8 at 0x7f4646400225 thread T0\n[Detaching after fork from child process 62163]\n    #0 0x55c03130fbc0 in __interceptor_fread /src/llvm-project/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors.inc:1091:16\n    #1 0x55c0314223ec in APar_read64(char*, _IO_FILE*, unsigned long) /out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/src/util.cpp:299:10\n    #2 0x55c0313ce652 in APar_ExtractTrackDetails(char*, _IO_FILE*, Trackage*, TrackInfo*) /out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/src/extracts.cpp:1247:9\n    #3 0x55c0313d0f00 in APar_ExtractDetails(_IO_FILE*, unsigned char) /out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/src/extracts.cpp:1635:9\n    #4 0x55c0313ea236 in real_main(int, char**) /out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/src/main.cpp\n    #5 0x7f4648906082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #6 0x55c0312f256d in _start (/mnt/local/home_dir/wj_code/dl_code/out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/build_d72ccf06c98259d7261e0f3ac4fd8717778782c1/AtomicParsley+0x5f56d)\n\nAddress 0x7f4646400225 is located in stack of thread T0 at offset 37 in frame\n    #0 0x55c0313d0a9f in APar_ExtractDetails(_IO_FILE*, unsigned char) /out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/src/extracts.cpp:1590\n\n  This frame has 3 object(s):\n    [32, 37) 'uint32_buffer' (line 1591) <== Memory access at offset 37 overflows this variable\n    [64, 68) 'track' (line 1592)\n    [80, 416) 'track_info' (line 1632)\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /src/llvm"
    },
    "71c2ab509a8628dbbad4bc7b3f98a64aa90d3297___jv.c": {
        "prefix": "static const char* jvp_literal_number_literal(jv n) {\n  assert(JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL));\n  decNumber *pdec = jvp_dec_number_ptr(n);\n  jvp_literal_number* plit = jvp_literal_number_ptr(n);\n\n  if (decNumberIsNaN(pdec)) {\n    return \"null\";\n  }\n\n  if (decNumberIsInfinite(pdec)) {\n    // We cannot preserve the literal data of numbers outside the limited\n    // range of exponent. Since `decNumberToString` returns \"Infinity\"\n    // (or \"-Infinity\"), and to reduce stack allocations as possible, we\n    // normalize infinities in the callers instead of printing the maximum\n    // (or minimum) double here.\n    return NULL;\n  }\n\n  if (plit->literal_data == NULL) {\n",
        "suffix": "    plit->literal_data = jv_mem_alloc(len);\n\n    // Preserve the actual precision as we have parsed it\n    // don't do decNumberTrim(pdec);\n\n    decNumberToString(pdec, plit->literal_data);\n  }\n\n  return plit->literal_data;\n}\n",
        "start": 619,
        "end": 648,
        "buggy": "static const char* jvp_literal_number_literal(jv n) {\n  assert(JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL));\n  decNumber *pdec = jvp_dec_number_ptr(n);\n  jvp_literal_number* plit = jvp_literal_number_ptr(n);\n\n  if (decNumberIsNaN(pdec)) {\n    return \"null\";\n  }\n\n  if (decNumberIsInfinite(pdec)) {\n    // We cannot preserve the literal data of numbers outside the limited\n    // range of exponent. Since `decNumberToString` returns \"Infinity\"\n    // (or \"-Infinity\"), and to reduce stack allocations as possible, we\n    // normalize infinities in the callers instead of printing the maximum\n    // (or minimum) double here.\n    return NULL;\n  }\n\n  if (plit->literal_data == NULL) {\n    int len = jvp_dec_number_ptr(n)->digits + 14;\n    plit->literal_data = jv_mem_alloc(len);\n\n    // Preserve the actual precision as we have parsed it\n    // don't do decNumberTrim(pdec);\n\n    decNumberToString(pdec, plit->literal_data);\n  }\n\n  return plit->literal_data;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    int len = jvp_dec_number_ptr(n)->digits + 14;\n",
        "src_path": "71c2ab509a8628dbbad4bc7b3f98a64aa90d3297___jv.c",
        "uri": "https://api.github.com/repos/jqlang/jq/commits/71c2ab509a8628dbbad4bc7b3f98a64aa90d3297",
        "commit_msg": "Merge pull request from GHSA-686w-5m7m-54vc\n\ndecNumberToString calls for a buffer that can hold a string of digits+14\ncharacters, not a buffer of size digits+14.\nWe need to allocate an extra byte for the NUL byte.\n\n-10E-1000010001, for example, will be stringified as -1.0E-1000010000\nand decNumberToString will currently write an extra NUL byte after the\nallocated buffer in the heap.\n\nOriginally reported by @SEU-SSL on GitHub.\n\nRef: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=64574\n\nFixes GHSA-686w-5m7m-54vc",
        "test_func_diff": [
            {
                "fn": "tests/shtest",
                "patch": "@@ -609,4 +609,9 @@ if ! r=$($JQ --args -rn 1 -- '$ARGS.positional[0]' bar) || [ \"$r\" != 1 ]; then\n     exit 1\n fi\n \n+# CVE-2023-50246: No heap overflow for '-10E-1000000001'\n+$VALGRIND $Q $JQ . <<\\NUM\n+-10E-1000000001\n+NUM\n+\n exit 0"
            }
        ],
        "error_msg": "+ . ./setup\n+ [ -n  ]\n+ set -eu\n+ dirname ./xtest.sh\n+ cd .\n+ pwd\n+ JQTESTDIR=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests\n+ JQBASEDIR=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/..\n+ JQ=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/../jq\n+ [ -z  ]\n+ which valgrind\n+ VALGRIND=valgrind --error-exitcode=1 --leak-check=full                        --suppressions=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/onig.supp                        --suppressions=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/local.supp\n+ VG_EXIT0=--error-exitcode=0\n+ Q=-q\n+ mods=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/modules\n+ clean=true\n+ d=\n+ trap clean EXIT\n+ mktemp -d -t jqXXXXXX\n+ d=/tmp/jqKNlhu3\n+ [ -z /tmp/jqKNlhu3 ]\n+ msys=false\n+ mingw=false\n+ uname -s\n+ JQ_NO_B=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/../jq\n+ JQ=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/../jq -b\n+ valgrind --error-exitcode=1 --leak-check=full --suppressions=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/onig.supp --suppressions=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/local.supp -q /out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/../jq -b .\n==195171== Invalid write of size 1\n==195171==    at 0x130EE5: decToString (in /mnt/local/home_dir/wj_code/dl_code/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/jq)\n==195171==    by 0x13079A: decNumberToString (in /mnt/local/home_dir/wj_code/dl_code/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/jq)\n==195171==    by 0x11BE8A: jv_number_get_literal (in /mnt/local/home_dir/wj_code/dl_code/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/jq)\n==195171==    by 0x12C9BD: jv_dump_term.30 (in /mnt/local/home_dir/wj_co"
    },
    "be749d7efa7c9021da746e685bd6dec79f9dd99b___cJSON.c": {
        "prefix": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n    current_element = object->child;\n    if (case_sensitive)\n    {\n",
        "suffix": "        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n\n    return current_element;\n}\n",
        "start": 1772,
        "end": 1798,
        "buggy": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n    current_element = object->child;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n\n    return current_element;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n",
        "src_path": "be749d7efa7c9021da746e685bd6dec79f9dd99b___cJSON.c",
        "uri": "https://api.github.com/repos/DaveGamble/cJSON/commits/be749d7efa7c9021da746e685bd6dec79f9dd99b",
        "commit_msg": "Fix crash of cJSON_GetObjectItemCaseSensitive when calling it on arrays",
        "test_func_diff": [
            {
                "fn": "tests/misc_tests.c",
                "patch": "@@ -127,6 +127,28 @@ static void cjson_get_object_item_case_sensitive_should_get_object_items(void)\n     cJSON_Delete(item);\n }\n \n+static void cjson_get_object_item_should_not_crash_with_array(void) {\n+    cJSON *array = NULL;\n+    cJSON *found = NULL;\n+    array = cJSON_Parse(\"[1]\");\n+\n+    found = cJSON_GetObjectItem(array, \"name\");\n+    TEST_ASSERT_NULL(found);\n+\n+    cJSON_Delete(array);\n+}\n+\n+static void cjson_get_object_item_case_sensitive_should_not_crash_with_array(void) {\n+    cJSON *array = NULL;\n+    cJSON *found = NULL;\n+    array = cJSON_Parse(\"[1]\");\n+\n+    found = cJSON_GetObjectItemCaseSensitive(array, \"name\");\n+    TEST_ASSERT_NULL(found);\n+\n+    cJSON_Delete(array);\n+}\n+\n static void typecheck_functions_should_check_type(void)\n {\n     cJSON invalid[1];\n@@ -535,6 +557,8 @@ int CJSON_CDECL main(void)\n     RUN_TEST(cjson_array_foreach_should_not_dereference_null_pointer);\n     RUN_TEST(cjson_get_object_item_should_get_object_items);\n     RUN_TEST(cjson_get_object_item_case_sensitive_should_get_object_items);\n+    RUN_TEST(cjson_get_object_item_should_not_crash_with_array);\n+    RUN_TEST(cjson_get_object_item_case_sensitive_should_not_crash_with_array);\n     RUN_TEST(typecheck_functions_should_check_type);\n     RUN_TEST(cjson_should_not_parse_to_deeply_nested_jsons);\n     RUN_TEST(cjson_set_number_value_should_set_numbers);"
            }
        ],
        "error_msg": "/out/DaveGamble___cJSON/git_repo_dir/tests/../cJSON.c:1784:59: runtime error: null pointer passed as argument 2, which is declared to never be null\n/usr/include/string.h:138:33: note: nonnull attribute specified here\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /out/DaveGamble___cJSON/git_repo_dir/tests/../cJSON.c:1784:59 in \n"
    },
    "4a342f01e5439b9bb901aff1c6c23c536baeeb3f___object.c": {
        "prefix": "int yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n\n  int i;\n  int count;\n\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n\n  array = object_as_array(object);\n\n  if (array->items == NULL)\n  {\n",
        "suffix": "\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n\n    array->items->count = count;\n  }\n\n  item->parent = object;\n  array->items->objects[index] = item;\n\n  return ERROR_SUCCESS;\n}\n",
        "start": 711,
        "end": 760,
        "buggy": "int yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n\n  int i;\n  int count;\n\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n\n  array = object_as_array(object);\n\n  if (array->items == NULL)\n  {\n    count = yr_max(64, (index + 1) * 2);\n\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n\n    array->items->count = count;\n  }\n\n  item->parent = object;\n  array->items->objects[index] = item;\n\n  return ERROR_SUCCESS;\n}\n",
        "fix": null,
        "buggy_hunk_masked": "    count = yr_max(64, (index + 1) * 2);\n",
        "src_path": "4a342f01e5439b9bb901aff1c6c23c536baeeb3f___object.c",
        "uri": "https://api.github.com/repos/VirusTotal/yara/commits/4a342f01e5439b9bb901aff1c6c23c536baeeb3f",
        "commit_msg": "Fix heap overflow (reported by Jurriaan Bremer)\n\nWhen setting a new array item with yr_object_array_set_item() the array size is doubled if the index for the new item is larger than the already allocated ones. No further checks were made to ensure that the index fits into the array after doubling its capacity. If the array capacity was for example 64, and a new object is assigned to an index larger than 128 the overflow occurs. As yr_object_array_set_item() is usually invoked with indexes that increase monotonically by one, this bug never triggered before. But the new \"dotnet\" module has the potential to allow the exploitation of this bug by scanning a specially crafted .NET binary.",
        "test_func_diff": [
            {
                "fn": "libyara/modules/tests.c",
                "patch": "@@ -176,6 +176,7 @@ int module_load(\n   set_integer(0, module_object, \"integer_array[%i]\", 0);\n   set_integer(1, module_object, \"integer_array[%i]\", 1);\n   set_integer(2, module_object, \"integer_array[%i]\", 2);\n+  set_integer(256, module_object, \"integer_array[%i]\", 256);\n \n   set_string(\"foo\", module_object, \"string_array[%i]\", 0);\n   set_string(\"bar\", module_object, \"string_array[%i]\", 1);"
            },
            {
                "fn": "tests/test-rules.c",
                "patch": "@@ -1395,6 +1395,13 @@ static void test_modules()\n       }\",\n       NULL);\n \n+  assert_true_rule(\n+      \"import \\\"tests\\\" \\\n+       rule test { \\\n+        condition: tests.integer_array[256] == 256 \\\n+      }\",\n+      NULL);\n+\n   assert_true_rule(\n       \"import \\\"tests\\\" \\\n        rule test { \\"
            }
        ],
        "error_msg": "FAIL: test-rules\n================\n\ntests/test-rules.c:1403: rule does not match (but should)\n\n=================================================================\n==1029906==ERROR: LeakSanitizer: detected memory leaks\n\nDirect leak of 40 byte(s) in 1 object(s) allocated from:\n    #0 0x559963954bae in malloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:69:3\n    #1 0x5599639aca90 in yr_object_create /out/VirusTotal___yara/git_repo_dir/libyara/object.c:90:22\n    #2 0x5599639af356 in yr_object_array_get_item /out/VirusTotal___yara/git_repo_dir/libyara/object.c:701:5\n    #3 0x5599639af356 in _yr_object_lookup /out/VirusTotal___yara/git_repo_dir/libyara/object.c:510:17\n    #4 0x5599639ae0b6 in yr_object_set_integer /out/VirusTotal___yara/git_repo_dir/libyara/object.c:985:19\n    #5 0x5599639d15d0 in tests__load /out/VirusTotal___yara/git_repo_dir/libyara/modules/tests.c:179:3\n    #6 0x559963a054e2 in yr_execute_code /out/VirusTotal___yara/git_repo_dir/libyara/exec.c:847:18\n    #7 0x5599639c99ac in yr_rules_scan_mem_blocks /out/VirusTotal___yara/git_repo_dir/libyara/rules.c:472:3\n    #8 0x5599639ca88b in yr_rules_scan_mem /out/VirusTotal___yara/git_repo_dir/libyara/rules.c:586:10\n    #9 0x55996399ae5b in matches_blob /out/VirusTotal___yara/git_repo_dir/tests/util.c:122:21\n    #10 0x55996399716d in test_modules /out/VirusTotal___yara/git_repo_dir/tests/test-rules.c:1377:3\n    #11 0x55996399716d in main /out/VirusTotal___yara/git_repo_dir/tests/test-rules.c:1699:3\n    #12 0x7f7109314082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n\nDirect leak of 40 byte(s) in 1 object(s) allocated from:\n    #0 0x559963954bae in malloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:69:3\n    #1 0x5599639aca90 in yr_object_create /out/VirusTotal___yara/git_repo_dir/libyara/object.c:90:22\n    #2 0x5599639af356 in yr_object_array_get_item /out/VirusTotal___yara/git_repo_dir/libyara/object.c:701:5\n    #3 0x5599639af356 in _yr_object_lookup /out/VirusTotal___yara/git_repo_dir/libyar"
    }
}