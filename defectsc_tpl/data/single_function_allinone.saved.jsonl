{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nvoid\nicmp_print(netdissect_options *ndo, const u_char *bp, u_int plen, const u_char *bp2,\n           int fragmented)\n{\n\tchar *cp;\n\tconst struct icmp *dp;\n        const struct icmp_ext_t *ext_dp;\n\tconst struct ip *ip;\n\tconst char *str, *fmt;\n\tconst struct ip *oip;\n\tconst struct udphdr *ouh;\n        const uint8_t *obj_tptr;\n        uint32_t raw_label;\n        const u_char *snapend_save;\n\tconst struct icmp_mpls_ext_object_header_t *icmp_mpls_ext_object_header;\n\tu_int hlen, dport, mtu, obj_tlen, obj_class_num, obj_ctype;\n\tchar buf[MAXHOSTNAMELEN + 100];\n\tstruct cksum_vec vec[1];\n\n\tdp = (const struct icmp *)bp;\n        ext_dp = (const struct icmp_ext_t *)bp;\n\tip = (const struct ip *)bp2;\n\tstr = buf;\n\n\tND_TCHECK(dp->icmp_code);\n\tswitch (dp->icmp_type) {\n\n\tcase ICMP_ECHO:\n\tcase ICMP_ECHOREPLY:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf), \"echo %s, id %u, seq %u\",\n                               dp->icmp_type == ICMP_ECHO ?\n                               \"request\" : \"reply\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_UNREACH:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_UNREACH_PROTOCOL:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"%s protocol %d unreachable\",\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t\t    dp->icmp_ip.ip_p);\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_PORT:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\toip = &dp->icmp_ip;\n\t\t\thlen = IP_HL(oip) * 4;\n\t\t\touh = (const struct udphdr *)(((const u_char *)oip) + hlen);\n\t\t\tND_TCHECK(ouh->uh_dport);\n\t\t\tdport = EXTRACT_16BITS(&ouh->uh_dport);\n\t\t\tswitch (oip->ip_p) {\n\n\t\t\tcase IPPROTO_TCP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s tcp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\ttcpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tcase IPPROTO_UDP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s udp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\tudpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s protocol %d port %d unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\toip->ip_p, dport);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_NEEDFRAG:\n\t\t    {\n\t\t\tregister const struct mtu_discovery *mp;\n\t\t\tmp = (const struct mtu_discovery *)(const u_char *)&dp->icmp_void;\n\t\t\tmtu = EXTRACT_16BITS(&mp->nexthopmtu);\n\t\t\tif (mtu) {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag (mtu %d)\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst), mtu);\n\t\t\t} else {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\t}\n\t\t    }\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmt = tok2str(unreach2str, \"#%d %%s unreachable\",\n\t\t\t    dp->icmp_code);\n\t\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_REDIRECT:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tfmt = tok2str(type2str, \"redirect-#%d %%s to net %%s\",\n\t\t    dp->icmp_code);\n\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t    ipaddr_string(ndo, &dp->icmp_gwaddr));\n\t\tbreak;\n\n\tcase ICMP_ROUTERADVERT:\n\t    {\n\t\tregister const struct ih_rdiscovery *ihp;\n\t\tregister const struct id_rdiscovery *idp;\n\t\tu_int lifetime, num, size;\n\n\t\t(void)snprintf(buf, sizeof(buf), \"router advertisement\");\n\t\tcp = buf + strlen(buf);\n\n\t\tihp = (const struct ih_rdiscovery *)&dp->icmp_void;\n\t\tND_TCHECK(*ihp);\n\t\t(void)strncpy(cp, \" lifetime \", sizeof(buf) - (cp - buf));\n\t\tcp = buf + strlen(buf);\n\t\tlifetime = EXTRACT_16BITS(&ihp->ird_lifetime);\n\t\tif (lifetime < 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u\",\n\t\t\t    lifetime);\n\t\t} else if (lifetime < 60 * 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u:%02u\",\n\t\t\t    lifetime / 60, lifetime % 60);\n\t\t} else {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \"%u:%02u:%02u\",\n\t\t\t    lifetime / 3600,\n\t\t\t    (lifetime % 3600) / 60,\n\t\t\t    lifetime % 60);\n\t\t}\n\t\tcp = buf + strlen(buf);\n\n\t\tnum = ihp->ird_addrnum;\n\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" %d:\", num);\n\t\tcp = buf + strlen(buf);\n\n\t\tsize = ihp->ird_addrsiz;\n\t\tif (size != 2) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \" [size %d]\", size);\n\t\t\tbreak;\n\t\t}\n\t\tidp = (const struct id_rdiscovery *)&dp->icmp_data;\n\t\twhile (num-- > 0) {\n\t\t\tND_TCHECK(*idp);\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" {%s %u}\",\n\t\t\t    ipaddr_string(ndo, &idp->ird_addr),\n\t\t\t    EXTRACT_32BITS(&idp->ird_pref));\n\t\t\tcp = buf + strlen(buf);\n\t\t\t++idp;\n\t\t}\n\t    }\n\t\tbreak;\n\n\tcase ICMP_TIMXCEED:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_TIMXCEED_INTRANS:\n\t\t\tstr = \"time exceeded in-transit\";\n\t\t\tbreak;\n\n\t\tcase ICMP_TIMXCEED_REASS:\n\t\t\tstr = \"ip reassembly time exceeded\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"time exceeded-#%d\",\n\t\t\t    dp->icmp_code);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_PARAMPROB:\n\t\tif (dp->icmp_code)\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - code %d\", dp->icmp_code);\n\t\telse {\n\t\t\tND_TCHECK(dp->icmp_pptr);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - octet %d\", dp->icmp_pptr);\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_MASKREPLY:\n\t\tND_TCHECK(dp->icmp_mask);\n\t\t(void)snprintf(buf, sizeof(buf), \"address mask is 0x%08x\",\n\t\t    EXTRACT_32BITS(&dp->icmp_mask));\n\t\tbreak;\n\n\tcase ICMP_TSTAMP:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp query id %u seq %u\",\n\t\t    EXTRACT_16BITS(&dp->icmp_id),\n\t\t    EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_TSTAMPREPLY:\n\t\tND_TCHECK(dp->icmp_ttime);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp reply id %u seq %u: org %s\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq),\n                               icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_otime)));\n\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", recv %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_rtime)));\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", xmit %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_ttime)));\n                break;\n\n\tdefault:\n\t\tstr = tok2str(icmp2str, \"type-#%d\", dp->icmp_type);\n\t\tbreak;\n\t}\n\tND_PRINT((ndo, \"ICMP %s, length %u\", str, plen));\n\tif (ndo->ndo_vflag && !fragmented) { /* don't attempt checksumming if this is a frag */\n\t\tuint16_t sum, icmp_sum;\n\n\t\tif (ND_TTEST2(*bp, plen)) {\n\t\t\tvec[0].ptr = (const uint8_t *)(const void *)dp;\n\t\t\tvec[0].len = plen;\n\t\t\tsum = in_cksum(vec, 1);\n\t\t\tif (sum != 0) {\n\t\t\t\ticmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);\n\t\t\t\tND_PRINT((ndo, \" (wrong icmp cksum %x (->%x)!)\",\n\t\t\t\t\t     icmp_sum,\n\t\t\t\t\t     in_cksum_shouldbe(icmp_sum, sum)));\n\t\t\t}\n\t\t}\n\t}\n\n        /*\n         * print the remnants of the IP packet.\n         * save the snaplength as this may get overidden in the IP printer.\n         */\n\tif (ndo->ndo_vflag >= 1 && ICMP_ERRTYPE(dp->icmp_type)) {\n\t\tbp += 8;\n\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\tip = (const struct ip *)bp;\n                snapend_save = ndo->ndo_snapend;\n\t\tip_print(ndo, bp, EXTRACT_16BITS(&ip->ip_len));\n                ndo->ndo_snapend = snapend_save;\n\t}\n\n        /*\n         * Attempt to decode the MPLS extensions only for some ICMP types.\n         */\n        if (ndo->ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE(dp->icmp_type)) {\n\n            ND_TCHECK(*ext_dp);\n\n            /*\n             * Check first if the mpls extension header shows a non-zero length.\n             * If the length field is not set then silently verify the checksum\n             * to check if an extension header is present. This is expedient,\n             * however not all implementations set the length field proper.\n             */\n            if (!ext_dp->icmp_length) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = plen - ICMP_EXTD_MINLEN;\n                if (in_cksum(vec, 1)) {\n                    return;\n                }\n            }\n\n            ND_PRINT((ndo, \"\\n\\tMPLS extension v%u\",\n                   ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res))));\n\n            /*\n             * Sanity checking of the header.\n             */\n            if (ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res)) !=\n                ICMP_MPLS_EXT_VERSION) {\n                ND_PRINT((ndo, \" packet not supported\"));\n                return;\n            }\n\n            hlen = plen - ICMP_EXTD_MINLEN;\n            vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n            vec[0].len = hlen;\n            ND_PRINT((ndo, \", checksum 0x%04x (%scorrect), length %u\",\n                   EXTRACT_16BITS(ext_dp->icmp_ext_checksum),\n                   in_cksum(vec, 1) ? \"in\" : \"\",\n                   hlen));\n\n            hlen -= 4; /* subtract common header size */\n            obj_tptr = (const uint8_t *)ext_dp->icmp_ext_data;\n\n            while (hlen > sizeof(struct icmp_mpls_ext_object_header_t)) {\n\n                icmp_mpls_ext_object_header = (const struct icmp_mpls_ext_object_header_t *)obj_tptr;\n                ND_TCHECK(*icmp_mpls_ext_object_header);\n                obj_tlen = EXTRACT_16BITS(icmp_mpls_ext_object_header->length);\n                obj_class_num = icmp_mpls_ext_object_header->class_num;\n                obj_ctype = icmp_mpls_ext_object_header->ctype;\n                obj_tptr += sizeof(struct icmp_mpls_ext_object_header_t);\n\n                ND_PRINT((ndo, \"\\n\\t  %s Object (%u), Class-Type: %u, length %u\",\n                       tok2str(icmp_mpls_ext_obj_values,\"unknown\",obj_class_num),\n                       obj_class_num,\n                       obj_ctype,\n                       obj_tlen));\n\n                hlen-=sizeof(struct icmp_mpls_ext_object_header_t); /* length field includes tlv header */\n\n                /* infinite loop protection */\n                if ((obj_class_num == 0) ||\n                    (obj_tlen < sizeof(struct icmp_mpls_ext_object_header_t))) {\n                    return;\n                }\n                obj_tlen-=sizeof(struct icmp_mpls_ext_object_header_t);\n\n                switch (obj_class_num) {\n                case 1:\n                    switch(obj_ctype) {\n                    case 1:\n                        ND_TCHECK2(*obj_tptr, 4);\n                        raw_label = EXTRACT_32BITS(obj_tptr);\n                        ND_PRINT((ndo, \"\\n\\t    label %u, exp %u\", MPLS_LABEL(raw_label), MPLS_EXP(raw_label)));\n                        if (MPLS_STACK(raw_label))\n                            ND_PRINT((ndo, \", [S]\"));\n                        ND_PRINT((ndo, \", ttl %u\", MPLS_TTL(raw_label)));\n                        break;\n                    default:\n                        print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    }\n                    break;\n\n               /*\n                *  FIXME those are the defined objects that lack a decoder\n                *  you are welcome to contribute code ;-)\n                */\n                case 2:\n                default:\n                    print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    break;\n                }\n                if (hlen < obj_tlen)\n                    break;\n                hlen -= obj_tlen;\n                obj_tptr += obj_tlen;\n            }\n        }\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"[|icmp]\"));\n}\n```\n \n\n\nwith the following test error:     icmp-cksum-oobr-1                  : TEST FAILED(exit 256)\n    icmp-cksum-oobr-2                  : TEST FAILED(exit 256)\n    icmp-cksum-oobr-3                  : TEST FAILED(exit 256)\n    icmp-cksum-oobr-4                  : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "2b62d1dda41590db29368ec7ba5f4faf3464765a___print-icmp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nvoid\nripng_print(netdissect_options *ndo, const u_char *dat, unsigned int length)\n{\n\tregister const struct rip6 *rp = (const struct rip6 *)dat;\n\tregister const struct netinfo6 *ni;\n\tregister u_int amt;\n\tregister u_int i;\n\tint j;\n\tint trunc;\n\n\tif (ndo->ndo_snapend < dat)\n\t\treturn;\n\tamt = ndo->ndo_snapend - dat;\n\ti = min(length, amt);\n\tif (i < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n\t\treturn;\n\ti -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n\n\tswitch (rp->rip6_cmd) {\n\n\tcase RIP6_REQUEST:\n\t\tj = length / sizeof(*ni);\n\t\tif (j == 1\n\t\t    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6\n\t\t    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {\n\t\t\tND_PRINT((ndo, \" ripng-req dump\"));\n\t\t\tbreak;\n\t\t}\n\t\tif (j * sizeof(*ni) != length - 4)\n\t\t\tND_PRINT((ndo, \" ripng-req %d[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-req %d:\", j));\n\t\ttrunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);\n\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n\t\t    i -= sizeof(*ni), ++ni) {\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, 0);\n\t\t}\n\t\tbreak;\n\tcase RIP6_RESPONSE:\n\t\tj = length / sizeof(*ni);\n\t\tif (j * sizeof(*ni) != length - 4)\n\t\t\tND_PRINT((ndo, \" ripng-resp %d[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-resp %d:\", j));\n\t\ttrunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);\n\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n\t\t    i -= sizeof(*ni), ++ni) {\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, ni->rip6_metric);\n\t\t}\n\t\tif (trunc)\n\t\t\tND_PRINT((ndo, \"[|ripng]\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \" ripng-%d ?? %u\", rp->rip6_cmd, length));\n\t\tbreak;\n\t}\n\tif (rp->rip6_vers != RIP6_VERSION)\n\t\tND_PRINT((ndo, \" [vers %d]\", rp->rip6_vers));\n}\n```\n \n\n\nwith the following test error:     hoobr_ripng_print                  : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "e942fb84fbe3a73a98a00d2a279425872b5fb9d2___print-ripng.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic int\nbgp_attr_print(netdissect_options *ndo,\n               u_int atype, const u_char *pptr, u_int len)\n{\n\tint i;\n\tuint16_t af;\n\tuint8_t safi, snpa, nhlen;\n        union { /* copy buffer for bandwidth values */\n            float f;\n            uint32_t i;\n        } bw;\n\tint advance;\n\tu_int tlen;\n\tconst u_char *tptr;\n\tchar buf[MAXHOSTNAMELEN + 100];\n        int  as_size;\n\n        tptr = pptr;\n        tlen=len;\n\n\tswitch (atype) {\n\tcase BGPTYPE_ORIGIN:\n\t\tif (len != 1)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK(*tptr);\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(bgp_origin_values,\n\t\t\t\t\t\t\"Unknown Origin Typecode\",\n\t\t\t\t\t\ttptr[0])));\n\t\t}\n\t\tbreak;\n\n        /*\n         * Process AS4 byte path and AS2 byte path attributes here.\n         */\n\tcase BGPTYPE_AS4_PATH:\n\tcase BGPTYPE_AS_PATH:\n\t\tif (len % 2) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                if (!len) {\n\t\t\tND_PRINT((ndo, \"empty\"));\n\t\t\tbreak;\n                }\n\n                /*\n                 * BGP updates exchanged between New speakers that support 4\n                 * byte AS, ASs are always encoded in 4 bytes. There is no\n                 * definitive way to find this, just by the packet's\n                 * contents. So, check for packet's TLV's sanity assuming\n                 * 2 bytes first, and it does not pass, assume that ASs are\n                 * encoded in 4 bytes format and move on.\n                 */\n                as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);\n\n\t\twhile (tptr < pptr + len) {\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_open_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n\t\t\tND_TCHECK(tptr[1]);\n                        for (i = 0; i < tptr[1] * as_size; i += as_size) {\n                            ND_TCHECK2(tptr[2 + i], as_size);\n\t\t\t    ND_PRINT((ndo, \"%s \",\n\t\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\t\tas_size == 2 ?\n\t\t\t\tEXTRACT_16BITS(&tptr[2 + i]) :\n\t\t\t\tEXTRACT_32BITS(&tptr[2 + i]))));\n                        }\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_close_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n                        ND_TCHECK(tptr[1]);\n                        tptr += 2 + tptr[1] * as_size;\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_NEXT_HOP:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_MULTI_EXIT_DISC:\n\tcase BGPTYPE_LOCAL_PREF:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_ATOMIC_AGGREGATE:\n\t\tif (len != 0)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\tbreak;\n        case BGPTYPE_AGGREGATOR:\n\n                /*\n                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,\n                 * the length of this PA can be either 6 bytes or 8 bytes.\n                 */\n                if (len != 6 && len != 8) {\n                    ND_PRINT((ndo, \"invalid len\"));\n                    break;\n                }\n                ND_TCHECK2(tptr[0], len);\n                if (len == 6) {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),\n\t\t\tipaddr_string(ndo, tptr + 2)));\n                } else {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\tEXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));\n                }\n                break;\n\tcase BGPTYPE_AGGREGATOR4:\n\t\tif (len != 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 8);\n\t\tND_PRINT((ndo, \" AS #%s, origin %s\",\n\t   \t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),\n\t\t    ipaddr_string(ndo, tptr + 4)));\n\t\tbreak;\n\tcase BGPTYPE_COMMUNITIES:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\twhile (tlen>0) {\n\t\t\tuint32_t comm;\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tcomm = EXTRACT_32BITS(tptr);\n\t\t\tswitch (comm) {\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_ADVERT:\n\t\t\t\tND_PRINT((ndo, \" NO_ADVERTISE\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT_SUBCONFED:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT_SUBCONFED\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"%u:%u%s\",\n                                       (comm >> 16) & 0xffff,\n                                       comm & 0xffff,\n                                       (tlen>4) ? \", \" : \"\"));\n\t\t\t\tbreak;\n\t\t\t}\n                        tlen -=4;\n                        tptr +=4;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_ORIGINATOR_ID:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 4);\n                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                break;\n        case BGPTYPE_CLUSTER_LIST:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n\t\t\tND_TCHECK2(tptr[0], 4);\n                        ND_PRINT((ndo, \"%s%s\",\n                               ipaddr_string(ndo, tptr),\n                                (tlen>4) ? \", \" : \"\"));\n                        tlen -=4;\n                        tptr +=4;\n                }\n                break;\n\tcase BGPTYPE_MP_REACH_NLRI:\n\t\tND_TCHECK2(tptr[0], 3);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                switch(af<<8 | safi) {\n                case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n\t\tcase (AFNUM_INET<<8 | SAFNUM_MDT):\n                case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    break;\n                default:\n                    ND_TCHECK2(tptr[0], tlen);\n                    ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                    goto done;\n                    break;\n                }\n\n                tptr +=3;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tnhlen = tptr[0];\n                tlen = nhlen;\n                tptr++;\n\n\t\tif (tlen) {\n                    int nnh = 0;\n                    ND_PRINT((ndo, \"\\n\\t    nexthop: \"));\n                    while (tlen > 0) {\n                        if ( nnh++ > 0 ) {\n                            ND_PRINT((ndo,  \", \" ));\n                        }\n                        switch(af<<8 | safi) {\n                        case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n                        case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t\t    if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in_addr);\n                                tptr += sizeof(struct in_addr);\n                            }\n                            break;\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                            if (tlen < (int)sizeof(struct in6_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr));\n                                ND_PRINT((ndo, \"%s\", ip6addr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in6_addr);\n                                tptr += sizeof(struct in6_addr);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n                                tlen -= (sizeof(struct in_addr));\n                                tptr += (sizeof(struct in_addr));\n                            }\n                            break;\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"%s\", isonsap_string(ndo, tptr, tlen)));\n                            tptr += tlen;\n                            tlen = 0;\n                            break;\n\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < BGP_VPN_RD_LEN+1) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], tlen);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));\n                                /* rfc986 mapped IPv4 address ? */\n                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)\n                                    ND_PRINT((ndo, \" = %s\", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));\n                                /* rfc1888 mapped IPv6 address ? */\n                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)\n                                    ND_PRINT((ndo, \" = %s\", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));\n                                tptr += tlen;\n                                tlen = 0;\n                            }\n                            break;\n                        default:\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"no AFI %u/SAFI %u decoder\", af, safi));\n                            if (ndo->ndo_vflag <= 1)\n                                print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                            tptr += tlen;\n                            tlen = 0;\n                            goto done;\n                            break;\n                        }\n                    }\n\t\t}\n\t\tND_PRINT((ndo, \", nh-length: %u\", nhlen));\n\t\ttptr += tlen;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tsnpa = tptr[0];\n\t\ttptr++;\n\n\t\tif (snpa) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    %u SNPA\", snpa));\n\t\t\tfor (/*nothing*/; snpa > 0; snpa--) {\n\t\t\t\tND_TCHECK(tptr[0]);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      %d bytes\", tptr[0]));\n\t\t\t\ttptr += tptr[0] + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \", no SNPA\"));\n                }\n\n\t\twhile (len - (tptr - pptr) > 0) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,tlen);\n                        ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n        done:\n\t\tbreak;\n\n\tcase BGPTYPE_MP_UNREACH_NLRI:\n\t\tND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                if (len == BGP_MP_NLRI_MINSIZE)\n                    ND_PRINT((ndo, \"\\n\\t      End-of-Rib Marker (empty NLRI)\"));\n\n\t\ttptr += 3;\n\n\t\twhile (len - (tptr - pptr) > 0) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*(tptr-3),tlen);\n                        ND_PRINT((ndo, \"no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr-3, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_EXTD_COMMUNITIES:\n\t\tif (len % 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n                    uint16_t extd_comm;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    extd_comm=EXTRACT_16BITS(tptr);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s (0x%04x), Flags [%s]\",\n\t\t\t   tok2str(bgp_extd_comm_subtype_values,\n\t\t\t\t      \"unknown extd community typecode\",\n\t\t\t\t      extd_comm),\n\t\t\t   extd_comm,\n\t\t\t   bittok2str(bgp_extd_comm_flag_values, \"none\", extd_comm)));\n\n                    ND_TCHECK2(*(tptr+2), 6);\n                    switch(extd_comm) {\n                    case BGP_EXT_COM_RT_0:\n                    case BGP_EXT_COM_RO_0:\n                    case BGP_EXT_COM_L2VPN_RT_0:\n                        ND_PRINT((ndo, \": %u:%u (= %s)\",\n                               EXTRACT_16BITS(tptr+2),\n                               EXTRACT_32BITS(tptr+4),\n                               ipaddr_string(ndo, tptr+4)));\n                        break;\n                    case BGP_EXT_COM_RT_1:\n                    case BGP_EXT_COM_RO_1:\n                    case BGP_EXT_COM_L2VPN_RT_1:\n                    case BGP_EXT_COM_VRF_RT_IMP:\n                        ND_PRINT((ndo, \": %s:%u\",\n                               ipaddr_string(ndo, tptr+2),\n                               EXTRACT_16BITS(tptr+6)));\n                        break;\n                    case BGP_EXT_COM_RT_2:\n                    case BGP_EXT_COM_RO_2:\n\t\t\tND_PRINT((ndo, \": %s:%u\",\n\t\t\t    as_printf(ndo, astostr, sizeof(astostr),\n\t\t\t    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));\n\t\t\tbreak;\n                    case BGP_EXT_COM_LINKBAND:\n\t\t        bw.i = EXTRACT_32BITS(tptr+2);\n                        ND_PRINT((ndo, \": bandwidth: %.3f Mbps\",\n                               bw.f*8/1000000));\n                        break;\n                    case BGP_EXT_COM_VPN_ORIGIN:\n                    case BGP_EXT_COM_VPN_ORIGIN2:\n                    case BGP_EXT_COM_VPN_ORIGIN3:\n                    case BGP_EXT_COM_VPN_ORIGIN4:\n                    case BGP_EXT_COM_OSPF_RID:\n                    case BGP_EXT_COM_OSPF_RID2:\n                        ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr+2)));\n                        break;\n                    case BGP_EXT_COM_OSPF_RTYPE:\n                    case BGP_EXT_COM_OSPF_RTYPE2:\n                        ND_PRINT((ndo, \": area:%s, router-type:%s, metric-type:%s%s\",\n                               ipaddr_string(ndo, tptr+2),\n                               tok2str(bgp_extd_comm_ospf_rtype_values,\n\t\t\t\t\t  \"unknown (0x%02x)\",\n\t\t\t\t\t  *(tptr+6)),\n                               (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? \"E2\" : \"\",\n                               ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? \"E1\" : \"\"));\n                        break;\n                    case BGP_EXT_COM_L2INFO:\n                        ND_PRINT((ndo, \": %s Control Flags [0x%02x]:MTU %u\",\n                               tok2str(l2vpn_encaps_values,\n\t\t\t\t\t  \"unknown encaps\",\n\t\t\t\t\t  *(tptr+2)),\n                                       *(tptr+3),\n                               EXTRACT_16BITS(tptr+4)));\n                        break;\n                    case BGP_EXT_COM_SOURCE_AS:\n                        ND_PRINT((ndo, \": AS %u\", EXTRACT_16BITS(tptr+2)));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,8);\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", 8);\n                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n                ND_TCHECK2(tptr[0], 5);\n                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {\n                case BGP_PMSI_TUNNEL_PIM_SM: /* fall through */\n                case BGP_PMSI_TUNNEL_PIM_BIDIR:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Sender %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n\n                case BGP_PMSI_TUNNEL_PIM_SSM:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_INGRESS:\n                    ND_TCHECK2(tptr[0], 4);\n                    ND_PRINT((ndo, \"\\n\\t      Tunnel-Endpoint %s\",\n                           ipaddr_string(ndo, tptr)));\n                    break;\n                case BGP_PMSI_TUNNEL_LDP_P2MP: /* fall through */\n                case BGP_PMSI_TUNNEL_LDP_MP2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, LSP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_RSVP_P2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                default:\n                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\tND_TCHECK2(tptr[0], 3);\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length - 3);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        ND_TCHECK2(tptr[3], 8);\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr+3)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr+3,\"\\n\\t      \", length-3);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);\n                if (len < 4)\n                \tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t    Origin AS: %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));\n\t\ttptr+=4;\n                len -=4;\n\n                while (len) {\n                    u_int aflags, alenlen, alen;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    if (len < 2)\n                        goto trunc;\n                    aflags = *tptr;\n                    atype = *(tptr + 1);\n                    tptr += 2;\n                    len -= 2;\n                    alenlen = bgp_attr_lenlen(aflags, tptr);\n                    ND_TCHECK2(tptr[0], alenlen);\n                    if (len < alenlen)\n                        goto trunc;\n                    alen = bgp_attr_len(aflags, tptr);\n                    tptr += alenlen;\n                    len -= alenlen;\n\n                    ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                           tok2str(bgp_attr_values,\n                                      \"Unknown Attribute\", atype),\n                           atype,\n                           alen));\n\n                    if (aflags) {\n                        ND_PRINT((ndo, \", Flags [%s%s%s%s\",\n                               aflags & 0x80 ? \"O\" : \"\",\n                               aflags & 0x40 ? \"T\" : \"\",\n                               aflags & 0x20 ? \"P\" : \"\",\n                               aflags & 0x10 ? \"E\" : \"\"));\n                        if (aflags & 0xf)\n                            ND_PRINT((ndo, \"+%x\", aflags & 0xf));\n                        ND_PRINT((ndo, \"]: \"));\n                    }\n                    /* FIXME check for recursion */\n                    if (!bgp_attr_print(ndo, atype, tptr, alen))\n                        return 0;\n                    tptr += alen;\n                    len -= alen;\n\t\t}\n                break;\n\n\tcase BGPTYPE_LARGE_COMMUNITY:\n\t\tif (len == 0 || len % 12) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\twhile (len > 0) {\n\t\t\tND_TCHECK2(*tptr, 12);\n\t\t\tND_PRINT((ndo, \"%u:%u:%u%s\",\n\t\t\t\t EXTRACT_32BITS(tptr),\n\t\t\t\t EXTRACT_32BITS(tptr + 4),\n\t\t\t\t EXTRACT_32BITS(tptr + 8),\n\t\t\t\t (len > 12) ? \", \" : \"\"));\n                        tptr += 12;\n                        len -= 12;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t    ND_TCHECK2(*pptr,len);\n            ND_PRINT((ndo, \"\\n\\t    no Attribute %u decoder\", atype)); /* we have no decoder for the attribute */\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n            break;\n\t}\n        if (ndo->ndo_vflag > 1 && len) { /* omit zero length attributes*/\n            ND_TCHECK2(*pptr,len);\n            print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n        }\n        return 1;\n\ntrunc:\n        return 0;\n}\n```\n \n\n\nwith the following test error:     bgp-aigp-oobr                      : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "ffde45acf3348f8353fb4064a1b21683ee6b5ddf___print-bgp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nconst u_char *\nns_nprint(netdissect_options *ndo,\n          register const u_char *cp, register const u_char *bp)\n{\n\tregister u_int i, l;\n\tregister const u_char *rp = NULL;\n\tregister int compress = 0;\n\tint chars_processed;\n\tint elt;\n\tint data_size = ndo->ndo_snapend - bp;\n\n\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\treturn(NULL);\n\tif (!ND_TTEST2(*cp, 1))\n\t\treturn(NULL);\n\tchars_processed = 1;\n\tif (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {\n\t\tcompress = 0;\n\t\trp = cp + l;\n\t}\n\n\tif (i != 0)\n\t\twhile (i && cp < ndo->ndo_snapend) {\n\t\t\tif ((i & INDIR_MASK) == INDIR_MASK) {\n\t\t\t\tif (!compress) {\n\t\t\t\t\trp = cp + 1;\n\t\t\t\t\tcompress = 1;\n\t\t\t\t}\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\tcp = bp + (((i << 8) | *cp) & 0x3fff);\n\t\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\t\treturn(NULL);\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\ti = *cp++;\n\t\t\t\tchars_processed++;\n\n\t\t\t\t/*\n\t\t\t\t * If we've looked at every character in\n\t\t\t\t * the message, this pointer will make\n\t\t\t\t * us look at some character again,\n\t\t\t\t * which means we're looping.\n\t\t\t\t */\n\t\t\t\tif (chars_processed >= data_size) {\n\t\t\t\t\tND_PRINT((ndo, \"<LOOP>\"));\n\t\t\t\t\treturn (NULL);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((i & INDIR_MASK) == EDNS0_MASK) {\n\t\t\t\telt = (i & ~INDIR_MASK);\n\t\t\t\tswitch(elt) {\n\t\t\t\tcase EDNS0_ELT_BITLABEL:\n\t\t\t\t\tif (blabel_print(ndo, cp) == NULL)\n\t\t\t\t\t\treturn (NULL);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* unknown ELT */\n\t\t\t\t\tND_PRINT((ndo, \"<ELT %d>\", elt));\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (fn_printn(ndo, cp, l, ndo->ndo_snapend))\n\t\t\t\t\treturn(NULL);\n\t\t\t}\n\n\t\t\tcp += l;\n\t\t\tchars_processed += l;\n\t\t\tND_PRINT((ndo, \".\"));\n\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\treturn(NULL);\n\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\treturn(NULL);\n\t\t\ti = *cp++;\n\t\t\tchars_processed++;\n\t\t\tif (!compress)\n\t\t\t\trp += l + 1;\n\t\t}\n\telse\n\t\tND_PRINT((ndo, \".\"));\n\treturn (rp);\n}\n```\n \n\n\nwith the following test error:     dns-zlip-1                         : TEST FAILED(exit 256)\n    dns-zlip-2                         : TEST FAILED(exit 256)\n    dns-zlip-3                         : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "3a76fd7c95fced2c2f8c8148a9055c3a542eff29___print-domain.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic void\npimv2_print(netdissect_options *ndo,\n            register const u_char *bp, register u_int len, const u_char *bp2)\n{\n\tregister const u_char *ep;\n\tregister const struct pim *pim = (const struct pim *)bp;\n\tint advance;\n\tenum checksum_status cksum_status;\n\n\tep = (const u_char *)ndo->ndo_snapend;\n\tif (bp >= ep)\n\t\treturn;\n\tif (ep > bp + len)\n\t\tep = bp + len;\n\tND_TCHECK(pim->pim_rsv);\n\tpimv2_addr_len = pim->pim_rsv;\n\tif (pimv2_addr_len != 0)\n\t\tND_PRINT((ndo, \", RFC2117-encoding\"));\n\n\tND_PRINT((ndo, \", cksum 0x%04x \", EXTRACT_16BITS(&pim->pim_cksum)));\n\tif (EXTRACT_16BITS(&pim->pim_cksum) == 0) {\n\t\tND_PRINT((ndo, \"(unverified)\"));\n\t} else {\n\t\tif (PIM_TYPE(pim->pim_typever) == PIMV2_TYPE_REGISTER) {\n\t\t\t/*\n\t\t\t * The checksum only covers the packet header,\n\t\t\t * not the encapsulated packet.\n\t\t\t */\n\t\t\tcksum_status = pimv2_check_checksum(ndo, bp, bp2, 8);\n\t\t\tif (cksum_status == INCORRECT) {\n\t\t\t\t/*\n\t\t\t\t * To quote RFC 4601, \"For interoperability\n\t\t\t\t * reasons, a message carrying a checksum\n\t\t\t\t * calculated over the entire PIM Register\n\t\t\t\t * message should also be accepted.\"\n\t\t\t\t */\n\t\t\t\tcksum_status = pimv2_check_checksum(ndo, bp, bp2, len);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * The checksum covers the entire packet.\n\t\t\t */\n\t\t\tcksum_status = pimv2_check_checksum(ndo, bp, bp2, len);\n\t\t}\n\t\tswitch (cksum_status) {\n\n\t\tcase CORRECT:\n\t\t\tND_PRINT((ndo, \"(correct)\"));\n\t\t\tbreak;\n\n\t\tcase INCORRECT:\n\t\t\tND_PRINT((ndo, \"(incorrect)\"));\n\t\t\tbreak;\n\n\t\tcase UNVERIFIED:\n\t\t\tND_PRINT((ndo, \"(unverified)\"));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (PIM_TYPE(pim->pim_typever)) {\n\tcase PIMV2_TYPE_HELLO:\n\t    {\n\t\tuint16_t otype, olen;\n\t\tbp += 4;\n\t\twhile (bp < ep) {\n\t\t\tND_TCHECK2(bp[0], 4);\n\t\t\totype = EXTRACT_16BITS(&bp[0]);\n\t\t\tolen = EXTRACT_16BITS(&bp[2]);\n\t\t\tND_TCHECK2(bp[0], 4 + olen);\n\t\t\tND_PRINT((ndo, \"\\n\\t  %s Option (%u), length %u, Value: \",\n\t\t\t          tok2str(pimv2_hello_option_values, \"Unknown\", otype),\n\t\t\t          otype,\n\t\t\t          olen));\n\t\t\tbp += 4;\n\n\t\t\tswitch (otype) {\n\t\t\tcase PIMV2_HELLO_OPTION_HOLDTIME:\n\t\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(bp));\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_LANPRUNEDELAY:\n\t\t\t\tif (olen != 4) {\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: Option Length != 4 Bytes (%u)\", olen));\n\t\t\t\t} else {\n\t\t\t\t\tchar t_bit;\n\t\t\t\t\tuint16_t lan_delay, override_interval;\n\t\t\t\t\tlan_delay = EXTRACT_16BITS(bp);\n\t\t\t\t\toverride_interval = EXTRACT_16BITS(bp+2);\n\t\t\t\t\tt_bit = (lan_delay & 0x8000)? 1 : 0;\n\t\t\t\t\tlan_delay &= ~0x8000;\n\t\t\t\t\tND_PRINT((ndo, \"\\n\\t    T-bit=%d, LAN delay %dms, Override interval %dms\",\n\t\t\t\t\tt_bit, lan_delay, override_interval));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_DR_PRIORITY_OLD:\n\t\t\tcase PIMV2_HELLO_OPTION_DR_PRIORITY:\n\t\t\t\tswitch (olen) {\n\t\t\t\tcase 0:\n\t\t\t\t\tND_PRINT((ndo, \"Bi-Directional Capability (Old)\"));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(bp)));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tND_PRINT((ndo, \"ERROR: Option Length != 4 Bytes (%u)\", olen));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_GENID:\n\t\t\t\tND_PRINT((ndo, \"0x%08x\", EXTRACT_32BITS(bp)));\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_REFRESH_CAP:\n\t\t\t\tND_PRINT((ndo, \"v%d\", *bp));\n\t\t\t\tif (*(bp+1) != 0) {\n\t\t\t\t\tND_PRINT((ndo, \", interval \"));\n\t\t\t\t\tunsigned_relts_print(ndo, *(bp+1));\n\t\t\t\t}\n\t\t\t\tif (EXTRACT_16BITS(bp+2) != 0) {\n\t\t\t\t\tND_PRINT((ndo, \" ?0x%04x?\", EXTRACT_16BITS(bp+2)));\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase  PIMV2_HELLO_OPTION_BIDIR_CAP:\n\t\t\t\tbreak;\n\n\t\t\tcase PIMV2_HELLO_OPTION_ADDRESS_LIST_OLD:\n\t\t\tcase PIMV2_HELLO_OPTION_ADDRESS_LIST:\n\t\t\t\tif (ndo->ndo_vflag > 1) {\n\t\t\t\t\tconst u_char *ptr = bp;\n\t\t\t\t\twhile (ptr < (bp+olen)) {\n\t\t\t\t\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\t\t\t\t\tadvance = pimv2_addr_print(ndo, ptr, pimv2_unicast, 0);\n\t\t\t\t\t\tif (advance < 0) {\n\t\t\t\t\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tptr += advance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (ndo->ndo_vflag <= 1)\n\t\t\t\t\tprint_unknown_data(ndo, bp, \"\\n\\t    \", olen);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* do we want to see an additionally hexdump ? */\n\t\t\tif (ndo->ndo_vflag> 1)\n\t\t\t\tprint_unknown_data(ndo, bp, \"\\n\\t    \", olen);\n\t\t\tbp += olen;\n\t\t}\n\t\tbreak;\n\t    }\n\n\tcase PIMV2_TYPE_REGISTER:\n\t{\n\t\tconst struct ip *ip;\n\n\t\tND_TCHECK2(*(bp + 4), PIMV2_REGISTER_FLAG_LEN);\n\n\t\tND_PRINT((ndo, \", Flags [ %s ]\\n\\t\",\n\t\t          tok2str(pimv2_register_flag_values,\n\t\t          \"none\",\n\t\t          EXTRACT_32BITS(bp+4))));\n\n\t\tbp += 8; len -= 8;\n\t\t/* encapsulated multicast packet */\n\t\tip = (const struct ip *)bp;\n\t\tswitch (IP_V(ip)) {\n                case 0: /* Null header */\n\t\t\tND_PRINT((ndo, \"IP-Null-header %s > %s\",\n\t\t\t          ipaddr_string(ndo, &ip->ip_src),\n\t\t\t          ipaddr_string(ndo, &ip->ip_dst)));\n\t\t\tbreak;\n\n\t\tcase 4:\t/* IPv4 */\n\t\t\tip_print(ndo, bp, len);\n\t\t\tbreak;\n\n\t\tcase 6:\t/* IPv6 */\n\t\t\tip6_print(ndo, bp, len);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tND_PRINT((ndo, \"IP ver %d\", IP_V(ip)));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PIMV2_TYPE_REGISTER_STOP:\n\t\tbp += 4; len -= 4;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" group=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" source=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tbreak;\n\n\tcase PIMV2_TYPE_JOIN_PRUNE:\n\tcase PIMV2_TYPE_GRAFT:\n\tcase PIMV2_TYPE_GRAFT_ACK:\n\n\n        /*\n         * 0                   1                   2                   3\n         *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |PIM Ver| Type  | Addr length   |           Checksum            |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |             Unicast-Upstream Neighbor Address                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |  Reserved     | Num groups    |          Holdtime             |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |            Encoded-Multicast Group Address-1                  |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |   Number of Joined  Sources   |   Number of Pruned Sources    |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Joined Source Address-1                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                             .                                 |\n         *  |                             .                                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Joined Source Address-n                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Pruned Source Address-1                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                             .                                 |\n         *  |                             .                                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |               Encoded-Pruned Source Address-n                 |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                           .                                   |\n         *  |                           .                                   |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         *  |                Encoded-Multicast Group Address-n              |\n         *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         */\n\n\t    {\n\t\tuint8_t ngroup;\n\t\tuint16_t holdtime;\n\t\tuint16_t njoin;\n\t\tuint16_t nprune;\n\t\tint i, j;\n\n\t\tbp += 4; len -= 4;\n\t\tif (PIM_TYPE(pim->pim_typever) != 7) {\t/*not for Graft-ACK*/\n\t\t\tif (bp >= ep)\n\t\t\t\tbreak;\n\t\t\tND_PRINT((ndo, \", upstream-neighbor: \"));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbp += advance; len -= advance;\n\t\t}\n\t\tif (bp + 4 > ep)\n\t\t\tbreak;\n\t\tngroup = bp[1];\n\t\tholdtime = EXTRACT_16BITS(&bp[2]);\n\t\tND_PRINT((ndo, \"\\n\\t  %u group(s)\", ngroup));\n\t\tif (PIM_TYPE(pim->pim_typever) != 7) {\t/*not for Graft-ACK*/\n\t\t\tND_PRINT((ndo, \", holdtime: \"));\n\t\t\tif (holdtime == 0xffff)\n\t\t\t\tND_PRINT((ndo, \"infinite\"));\n\t\t\telse\n\t\t\t\tunsigned_relts_print(ndo, holdtime);\n\t\t}\n\t\tbp += 4; len -= 4;\n\t\tfor (i = 0; i < ngroup; i++) {\n\t\t\tif (bp >= ep)\n\t\t\t\tgoto jp_done;\n\t\t\tND_PRINT((ndo, \"\\n\\t    group #%u: \", i+1));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto jp_done;\n\t\t\t}\n\t\t\tbp += advance; len -= advance;\n\t\t\tif (bp + 4 > ep) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto jp_done;\n\t\t\t}\n\t\t\tnjoin = EXTRACT_16BITS(&bp[0]);\n\t\t\tnprune = EXTRACT_16BITS(&bp[2]);\n\t\t\tND_PRINT((ndo, \", joined sources: %u, pruned sources: %u\", njoin, nprune));\n\t\t\tbp += 4; len -= 4;\n\t\t\tfor (j = 0; j < njoin; j++) {\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      joined source #%u: \", j+1));\n\t\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_source, 0)) < 0) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto jp_done;\n\t\t\t\t}\n\t\t\t\tbp += advance; len -= advance;\n\t\t\t}\n\t\t\tfor (j = 0; j < nprune; j++) {\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      pruned source #%u: \", j+1));\n\t\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_source, 0)) < 0) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto jp_done;\n\t\t\t\t}\n\t\t\t\tbp += advance; len -= advance;\n\t\t\t}\n\t\t}\n\tjp_done:\n\t\tbreak;\n\t    }\n\n\tcase PIMV2_TYPE_BOOTSTRAP:\n\t{\n\t\tint i, j, frpcnt;\n\t\tbp += 4;\n\n\t\t/* Fragment Tag, Hash Mask len, and BSR-priority */\n\t\tif (bp + sizeof(uint16_t) >= ep) break;\n\t\tND_PRINT((ndo, \" tag=%x\", EXTRACT_16BITS(bp)));\n\t\tbp += sizeof(uint16_t);\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" hashmlen=%d\", bp[0]));\n\t\tif (bp + 1 >= ep) break;\n\t\tND_PRINT((ndo, \" BSRprio=%d\", bp[1]));\n\t\tbp += 2;\n\n\t\t/* Encoded-Unicast-BSR-Address */\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" BSR=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\n\t\tfor (i = 0; bp < ep; i++) {\n\t\t\t/* Encoded-Group Address */\n\t\t\tND_PRINT((ndo, \" (group%d: \", i));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0))\n\t\t\t    < 0) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto bs_done;\n\t\t\t}\n\t\t\tbp += advance;\n\n\t\t\t/* RP-Count, Frag RP-Cnt, and rsvd */\n\t\t\tif (bp >= ep) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto bs_done;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \" RPcnt=%d\", bp[0]));\n\t\t\tif (bp + 1 >= ep) {\n\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\tgoto bs_done;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \" FRPcnt=%d\", frpcnt = bp[1]));\n\t\t\tbp += 4;\n\n\t\t\tfor (j = 0; j < frpcnt && bp < ep; j++) {\n\t\t\t\t/* each RP info */\n\t\t\t\tND_PRINT((ndo, \" RP%d=\", j));\n\t\t\t\tif ((advance = pimv2_addr_print(ndo, bp,\n\t\t\t\t\t\t\t\tpimv2_unicast,\n\t\t\t\t\t\t\t\t0)) < 0) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto bs_done;\n\t\t\t\t}\n\t\t\t\tbp += advance;\n\n\t\t\t\tif (bp + 1 >= ep) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto bs_done;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, \",holdtime=\"));\n\t\t\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(bp));\n\t\t\t\tif (bp + 2 >= ep) {\n\t\t\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\t\t\tgoto bs_done;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, \",prio=%d\", bp[2]));\n\t\t\t\tbp += 4;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t}\n\t   bs_done:\n\t\tbreak;\n\t}\n\tcase PIMV2_TYPE_ASSERT:\n\t\tbp += 4; len -= 4;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" group=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tif (bp >= ep)\n\t\t\tbreak;\n\t\tND_PRINT((ndo, \" src=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance; len -= advance;\n\t\tif (bp + 8 > ep)\n\t\t\tbreak;\n\t\tif (bp[0] & 0x80)\n\t\t\tND_PRINT((ndo, \" RPT\"));\n\t\tND_PRINT((ndo, \" pref=%u\", EXTRACT_32BITS(&bp[0]) & 0x7fffffff));\n\t\tND_PRINT((ndo, \" metric=%u\", EXTRACT_32BITS(&bp[4])));\n\t\tbreak;\n\n\tcase PIMV2_TYPE_CANDIDATE_RP:\n\t{\n\t\tint i, pfxcnt;\n\t\tbp += 4;\n\n\t\t/* Prefix-Cnt, Priority, and Holdtime */\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" prefix-cnt=%d\", bp[0]));\n\t\tpfxcnt = bp[0];\n\t\tif (bp + 1 >= ep) break;\n\t\tND_PRINT((ndo, \" prio=%d\", bp[1]));\n\t\tif (bp + 3 >= ep) break;\n\t\tND_PRINT((ndo, \" holdtime=\"));\n\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(&bp[2]));\n\t\tbp += 4;\n\n\t\t/* Encoded-Unicast-RP-Address */\n\t\tif (bp >= ep) break;\n\t\tND_PRINT((ndo, \" RP=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\n\t\t/* Encoded-Group Addresses */\n\t\tfor (i = 0; i < pfxcnt && bp < ep; i++) {\n\t\t\tND_PRINT((ndo, \" Group%d=\", i));\n\t\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0))\n\t\t\t    < 0) {\n\t\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbp += advance;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PIMV2_TYPE_PRUNE_REFRESH:\n\t\tND_PRINT((ndo, \" src=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\t\tND_PRINT((ndo, \" grp=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_group, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\t\tND_PRINT((ndo, \" forwarder=\"));\n\t\tif ((advance = pimv2_addr_print(ndo, bp, pimv2_unicast, 0)) < 0) {\n\t\t\tND_PRINT((ndo, \"...\"));\n\t\t\tbreak;\n\t\t}\n\t\tbp += advance;\n\t\tND_TCHECK2(bp[0], 2);\n\t\tND_PRINT((ndo, \" TUNR \"));\n\t\tunsigned_relts_print(ndo, EXTRACT_16BITS(bp));\n\t\tbreak;\n\n\n\t default:\n\t\tND_PRINT((ndo, \" [type %d]\", PIM_TYPE(pim->pim_typever)));\n\t\tbreak;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pim]\"));\n}\n```\n \n\n\nwith the following test error:     pimv2-oobr-1                       : TEST FAILED(exit 256)\n    pimv2-oobr-2                       : TEST FAILED(exit 256)\n    pimv2-oobr-3                       : TEST FAILED(exit 256)\n    pimv2-oobr-4                       : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "6fca58f5f9c96749a575f52e20598ad43f5bdf30___print-pim.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic void\nnfs_printfh(netdissect_options *ndo,\n            register const uint32_t *dp, const u_int len)\n{\n\tmy_fsid fsid;\n\tuint32_t ino;\n\tconst char *sfsname = NULL;\n\tchar *spacep;\n\n\tif (ndo->ndo_uflag) {\n\t\tu_int i;\n\t\tchar const *sep = \"\";\n\n\t\tND_PRINT((ndo, \" fh[\"));\n\t\tfor (i=0; i<len; i++) {\n\t\t\tND_PRINT((ndo, \"%s%x\", sep, dp[i]));\n\t\t\tsep = \":\";\n\t\t}\n\t\tND_PRINT((ndo, \"]\"));\n\t\treturn;\n\t}\n\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n\n\tif (sfsname) {\n\t\t/* file system ID is ASCII, not numeric, for this server OS */\n\t\tstatic char temp[NFSX_V3FHMAX+1];\n\n\t\t/* Make sure string is null-terminated */\n\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n\t\ttemp[sizeof(temp) - 1] = '\\0';\n\t\t/* Remove trailing spaces */\n\t\tspacep = strchr(temp, ' ');\n\t\tif (spacep)\n\t\t\t*spacep = '\\0';\n\n\t\tND_PRINT((ndo, \" fh %s/\", temp));\n\t} else {\n\t\tND_PRINT((ndo, \" fh %d,%d/\",\n\t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n\t}\n\n\tif(fsid.Fsid_dev.Minor == 257)\n\t\t/* Print the undecoded handle */\n\t\tND_PRINT((ndo, \"%s\", fsid.Opaque_Handle));\n\telse\n\t\tND_PRINT((ndo, \"%ld\", (long) ino));\n}\n```\n \n\n\nwith the following test error:     hoobr_nfs_printfh                  : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "7a923447fd49a069a0fd3b6c3547438ab5ee2123___print-nfs.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic int\nxid_map_enter(netdissect_options *ndo,\n              const struct sunrpc_msg *rp, const u_char *bp)\n{\n\tconst struct ip *ip = NULL;\n\tconst struct ip6_hdr *ip6 = NULL;\n\tstruct xid_map_entry *xmep;\n\n\tif (!ND_TTEST(rp->rm_call.cb_vers))\n\t\treturn (0);\n\tswitch (IP_V((const struct ip *)bp)) {\n\tcase 4:\n\t\tip = (const struct ip *)bp;\n\t\tbreak;\n\tcase 6:\n\t\tip6 = (const struct ip6_hdr *)bp;\n\t\tbreak;\n\tdefault:\n\t\treturn (1);\n\t}\n\n\txmep = &xid_map[xid_map_next];\n\n\tif (++xid_map_next >= XIDMAPSIZE)\n\t\txid_map_next = 0;\n\n\tUNALIGNED_MEMCPY(&xmep->xid, &rp->rm_xid, sizeof(xmep->xid));\n\tif (ip) {\n\t\txmep->ipver = 4;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));\n\t}\n\telse if (ip6) {\n\t\txmep->ipver = 6;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));\n\t}\n\txmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);\n\txmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);\n\treturn (1);\n}\n```\n \n\n\nwith the following test error:     hoobr_nfs_xid_map_enter            : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "b45a9a167ca6a3ef2752ae9d48d56ac14b001bfd___print-nfs.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic int\nparse_elements(netdissect_options *ndo,\n               struct mgmt_body_t *pbody, const u_char *p, int offset,\n               u_int length)\n{\n\tu_int elementlen;\n\tstruct ssid_t ssid;\n\tstruct challenge_t challenge;\n\tstruct rates_t rates;\n\tstruct ds_t ds;\n\tstruct cf_t cf;\n\tstruct tim_t tim;\n\n\t/*\n\t * We haven't seen any elements yet.\n\t */\n\tpbody->challenge_present = 0;\n\tpbody->ssid_present = 0;\n\tpbody->rates_present = 0;\n\tpbody->ds_present = 0;\n\tpbody->cf_present = 0;\n\tpbody->tim_present = 0;\n\n\twhile (length != 0) {\n\t\t/* Make sure we at least have the element ID and length. */\n\t\tif (!ND_TTEST2(*(p + offset), 2))\n\t\t\treturn 0;\n\t\tif (length < 2)\n\t\t\treturn 0;\n\t\telementlen = *(p + offset + 1);\n\n\t\t/* Make sure we have the entire element. */\n\t\tif (!ND_TTEST2(*(p + offset + 2), elementlen))\n\t\t\treturn 0;\n\t\tif (length < elementlen + 2)\n\t\t\treturn 0;\n\n\t\tswitch (*(p + offset)) {\n\t\tcase E_SSID:\n\t\t\tmemcpy(&ssid, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (ssid.length != 0) {\n\t\t\t\tif (ssid.length > sizeof(ssid.ssid) - 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), ssid.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < ssid.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&ssid.ssid, p + offset, ssid.length);\n\t\t\t\toffset += ssid.length;\n\t\t\t\tlength -= ssid.length;\n\t\t\t}\n\t\t\tssid.ssid[ssid.length] = '\\0';\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen an SSID IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->ssid_present) {\n\t\t\t\tpbody->ssid = ssid;\n\t\t\t\tpbody->ssid_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_CHALLENGE:\n\t\t\tmemcpy(&challenge, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (challenge.length != 0) {\n\t\t\t\tif (challenge.length >\n\t\t\t\t    sizeof(challenge.text) - 1)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), challenge.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < challenge.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&challenge.text, p + offset,\n\t\t\t\t    challenge.length);\n\t\t\t\toffset += challenge.length;\n\t\t\t\tlength -= challenge.length;\n\t\t\t}\n\t\t\tchallenge.text[challenge.length] = '\\0';\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a challenge IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->challenge_present) {\n\t\t\t\tpbody->challenge = challenge;\n\t\t\t\tpbody->challenge_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_RATES:\n\t\t\tmemcpy(&rates, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (rates.length != 0) {\n\t\t\t\tif (rates.length > sizeof rates.rate)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (!ND_TTEST2(*(p + offset), rates.length))\n\t\t\t\t\treturn 0;\n\t\t\t\tif (length < rates.length)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy(&rates.rate, p + offset, rates.length);\n\t\t\t\toffset += rates.length;\n\t\t\t\tlength -= rates.length;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a rates IE,\n\t\t\t * copy this one if it's not zero-length,\n\t\t\t * otherwise ignore this one, so we later\n\t\t\t * report the first one we saw.\n\t\t\t *\n\t\t\t * We ignore zero-length rates IEs as some\n\t\t\t * devices seem to put a zero-length rates\n\t\t\t * IE, followed by an SSID IE, followed by\n\t\t\t * a non-zero-length rates IE into frames,\n\t\t\t * even though IEEE Std 802.11-2007 doesn't\n\t\t\t * seem to indicate that a zero-length rates\n\t\t\t * IE is valid.\n\t\t\t */\n\t\t\tif (!pbody->rates_present && rates.length != 0) {\n\t\t\t\tpbody->rates = rates;\n\t\t\t\tpbody->rates_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_DS:\n\t\t\tmemcpy(&ds, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (ds.length != 1) {\n\t\t\t\toffset += ds.length;\n\t\t\t\tlength -= ds.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tds.channel = *(p + offset);\n\t\t\toffset += 1;\n\t\t\tlength -= 1;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a DS IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->ds_present) {\n\t\t\t\tpbody->ds = ds;\n\t\t\t\tpbody->ds_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_CF:\n\t\t\tmemcpy(&cf, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (cf.length != 6) {\n\t\t\t\toffset += cf.length;\n\t\t\t\tlength -= cf.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(&cf.count, p + offset, 6);\n\t\t\toffset += 6;\n\t\t\tlength -= 6;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a CF IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->cf_present) {\n\t\t\t\tpbody->cf = cf;\n\t\t\t\tpbody->cf_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase E_TIM:\n\t\t\tmemcpy(&tim, p + offset, 2);\n\t\t\toffset += 2;\n\t\t\tlength -= 2;\n\t\t\tif (tim.length <= 3) {\n\t\t\t\toffset += tim.length;\n\t\t\t\tlength -= tim.length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tim.length - 3 > (int)sizeof tim.bitmap)\n\t\t\t\treturn 0;\n\t\t\tmemcpy(&tim.count, p + offset, 3);\n\t\t\toffset += 3;\n\t\t\tlength -= 3;\n\n\t\t\tmemcpy(tim.bitmap, p + offset + 3, tim.length - 3);\n\t\t\toffset += tim.length - 3;\n\t\t\tlength -= tim.length - 3;\n\t\t\t/*\n\t\t\t * Present and not truncated.\n\t\t\t *\n\t\t\t * If we haven't already seen a TIM IE,\n\t\t\t * copy this one, otherwise ignore this one,\n\t\t\t * so we later report the first one we saw.\n\t\t\t */\n\t\t\tif (!pbody->tim_present) {\n\t\t\t\tpbody->tim = tim;\n\t\t\t\tpbody->tim_present = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n#if 0\n\t\t\tND_PRINT((ndo, \"(1) unhandled element_id (%d)  \",\n\t\t\t    *(p + offset)));\n#endif\n\t\t\toffset += 2 + elementlen;\n\t\t\tlength -= 2 + elementlen;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* No problems found. */\n\treturn 1;\n}\n```\n \n\n\nwith the following test error:     ieee802.11_rates_oobr              : passed\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "5edf405d7ed9fc92f4f43e8a3d44baa4c6387562___print-802_11.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nvoid\neap_print(netdissect_options *ndo,\n          register const u_char *cp,\n          u_int length)\n{\n    const struct eap_frame_t *eap;\n    const u_char *tptr;\n    u_int tlen, type, subtype;\n    int count=0, len;\n\n    tptr = cp;\n    tlen = length;\n    eap = (const struct eap_frame_t *)cp;\n    ND_TCHECK(*eap);\n\n    /* in non-verbose mode just lets print the basic info */\n    if (ndo->ndo_vflag < 1) {\n\tND_PRINT((ndo, \"%s (%u) v%u, len %u\",\n               tok2str(eap_frame_type_values, \"unknown\", eap->type),\n               eap->type,\n               eap->version,\n               EXTRACT_16BITS(eap->length)));\n\treturn;\n    }\n\n    ND_PRINT((ndo, \"%s (%u) v%u, len %u\",\n           tok2str(eap_frame_type_values, \"unknown\", eap->type),\n           eap->type,\n           eap->version,\n           EXTRACT_16BITS(eap->length)));\n\n    tptr += sizeof(const struct eap_frame_t);\n    tlen -= sizeof(const struct eap_frame_t);\n\n    switch (eap->type) {\n    case EAP_FRAME_TYPE_PACKET:\n        type = *(tptr);\n        len = EXTRACT_16BITS(tptr+2);\n        ND_PRINT((ndo, \", %s (%u), id %u, len %u\",\n               tok2str(eap_code_values, \"unknown\", type),\n               type,\n               *(tptr+1),\n               len));\n\n        ND_TCHECK2(*tptr, len);\n\n        if (type <= 2) { /* For EAP_REQUEST and EAP_RESPONSE only */\n            subtype = *(tptr+4);\n            ND_PRINT((ndo, \"\\n\\t\\t Type %s (%u)\",\n                   tok2str(eap_type_values, \"unknown\", *(tptr+4)),\n                   *(tptr + 4)));\n\n            switch (subtype) {\n            case EAP_TYPE_IDENTITY:\n                if (len - 5 > 0) {\n                    ND_PRINT((ndo, \", Identity: \"));\n                    safeputs(ndo, tptr + 5, len - 5);\n                }\n                break;\n\n            case EAP_TYPE_NOTIFICATION:\n                if (len - 5 > 0) {\n                    ND_PRINT((ndo, \", Notification: \"));\n                    safeputs(ndo, tptr + 5, len - 5);\n                }\n                break;\n\n            case EAP_TYPE_NAK:\n                count = 5;\n\n                /*\n                 * one or more octets indicating\n                 * the desired authentication\n                 * type one octet per type\n                 */\n                while (count < len) {\n                    ND_PRINT((ndo, \" %s (%u),\",\n                           tok2str(eap_type_values, \"unknown\", *(tptr+count)),\n                           *(tptr + count)));\n                    count++;\n                }\n                break;\n\n            case EAP_TYPE_TTLS:\n                ND_PRINT((ndo, \" TTLSv%u\",\n                       EAP_TTLS_VERSION(*(tptr + 5)))); /* fall through */\n            case EAP_TYPE_TLS:\n                ND_PRINT((ndo, \" flags [%s] 0x%02x,\",\n                       bittok2str(eap_tls_flags_values, \"none\", *(tptr+5)),\n                       *(tptr + 5)));\n\n                if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {\n\t\t    ND_PRINT((ndo, \" len %u\", EXTRACT_32BITS(tptr + 6)));\n                }\n                break;\n\n            case EAP_TYPE_FAST:\n                ND_PRINT((ndo, \" FASTv%u\",\n                       EAP_TTLS_VERSION(*(tptr + 5))));\n                ND_PRINT((ndo, \" flags [%s] 0x%02x,\",\n                       bittok2str(eap_tls_flags_values, \"none\", *(tptr+5)),\n                       *(tptr + 5)));\n\n                if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {\n                    ND_PRINT((ndo, \" len %u\", EXTRACT_32BITS(tptr + 6)));\n                }\n\n                /* FIXME - TLV attributes follow */\n                break;\n\n            case EAP_TYPE_AKA:\n            case EAP_TYPE_SIM:\n                ND_PRINT((ndo, \" subtype [%s] 0x%02x,\",\n                       tok2str(eap_aka_subtype_values, \"unknown\", *(tptr+5)),\n                       *(tptr + 5)));\n\n                /* FIXME - TLV attributes follow */\n                break;\n\n            case EAP_TYPE_MD5_CHALLENGE:\n            case EAP_TYPE_OTP:\n            case EAP_TYPE_GTC:\n            case EAP_TYPE_EXPANDED_TYPES:\n            case EAP_TYPE_EXPERIMENTAL:\n            default:\n                break;\n            }\n        }\n        break;\n\n    case EAP_FRAME_TYPE_LOGOFF:\n    case EAP_FRAME_TYPE_ENCAP_ASF_ALERT:\n    default:\n        break;\n    }\n    return;\n\n trunc:\n    ND_PRINT((ndo, \"\\n\\t[|EAP]\"));\n}\n```\n \n\n\nwith the following test error:     eap_extract_read2_asan             : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "985122081165753c7442bd7824c473eb9ff56308___print-eap.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nvoid\npgm_print(netdissect_options *ndo,\n          register const u_char *bp, register u_int length,\n          register const u_char *bp2)\n{\n\tregister const struct pgm_header *pgm;\n\tregister const struct ip *ip;\n\tregister char ch;\n\tuint16_t sport, dport;\n\tu_int nla_afnum;\n\tchar nla_buf[INET6_ADDRSTRLEN];\n\tregister const struct ip6_hdr *ip6;\n\tuint8_t opt_type, opt_len;\n\tuint32_t seq, opts_len, len, offset;\n\n\tpgm = (const struct pgm_header *)bp;\n\tip = (const struct ip *)bp2;\n\tif (IP_V(ip) == 6)\n\t\tip6 = (const struct ip6_hdr *)bp2;\n\telse\n\t\tip6 = NULL;\n\tch = '\\0';\n\tif (!ND_TTEST(pgm->pgm_dport)) {\n\t\tif (ip6) {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst)));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst)));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsport = EXTRACT_16BITS(&pgm->pgm_sport);\n\tdport = EXTRACT_16BITS(&pgm->pgm_dport);\n\n\tif (ip6) {\n\t\tif (ip6->ip6_nxt == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t} else {\n\t\tif (ip->ip_p == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t}\n\n\tND_TCHECK(*pgm);\n\n        ND_PRINT((ndo, \"PGM, length %u\", EXTRACT_16BITS(&pgm->pgm_length)));\n\n        if (!ndo->ndo_vflag)\n            return;\n\n\tND_PRINT((ndo, \" 0x%02x%02x%02x%02x%02x%02x \",\n\t\t     pgm->pgm_gsid[0],\n                     pgm->pgm_gsid[1],\n                     pgm->pgm_gsid[2],\n\t\t     pgm->pgm_gsid[3],\n                     pgm->pgm_gsid[4],\n                     pgm->pgm_gsid[5]));\n\tswitch (pgm->pgm_type) {\n\tcase PGM_SPM: {\n\t    const struct pgm_spm *spm;\n\n\t    spm = (const struct pgm_spm *)(pgm + 1);\n\t    ND_TCHECK(*spm);\n\t    bp = (const u_char *) (spm + 1);\n\n\t    switch (EXTRACT_16BITS(&spm->pgms_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_PRINT((ndo, \"SPM seq %u trail %u lead %u nla %s\",\n\t\t\t EXTRACT_32BITS(&spm->pgms_seq),\n                         EXTRACT_32BITS(&spm->pgms_trailseq),\n\t\t\t EXTRACT_32BITS(&spm->pgms_leadseq),\n                         nla_buf));\n\t    break;\n\t}\n\n\tcase PGM_POLL: {\n\t    const struct pgm_poll *poll_msg;\n\n\t    poll_msg = (const struct pgm_poll *)(pgm + 1);\n\t    ND_TCHECK(*poll_msg);\n\t    ND_PRINT((ndo, \"POLL seq %u round %u\",\n\t\t\t EXTRACT_32BITS(&poll_msg->pgmp_seq),\n                         EXTRACT_16BITS(&poll_msg->pgmp_round)));\n\t    bp = (const u_char *) (poll_msg + 1);\n\t    break;\n\t}\n\tcase PGM_POLR: {\n\t    const struct pgm_polr *polr;\n\t    uint32_t ivl, rnd, mask;\n\n\t    polr = (const struct pgm_polr *)(pgm + 1);\n\t    ND_TCHECK(*polr);\n\t    bp = (const u_char *) (polr + 1);\n\n\t    switch (EXTRACT_16BITS(&polr->pgmp_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    ivl = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    rnd = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    mask = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_PRINT((ndo, \"POLR seq %u round %u nla %s ivl %u rnd 0x%08x \"\n\t\t\t \"mask 0x%08x\", EXTRACT_32BITS(&polr->pgmp_seq),\n\t\t\t EXTRACT_16BITS(&polr->pgmp_round), nla_buf, ivl, rnd, mask));\n\t    break;\n\t}\n\tcase PGM_ODATA: {\n\t    const struct pgm_data *odata;\n\n\t    odata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*odata);\n\t    ND_PRINT((ndo, \"ODATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&odata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&odata->pgmd_seq)));\n\t    bp = (const u_char *) (odata + 1);\n\t    break;\n\t}\n\n\tcase PGM_RDATA: {\n\t    const struct pgm_data *rdata;\n\n\t    rdata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*rdata);\n\t    ND_PRINT((ndo, \"RDATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_seq)));\n\t    bp = (const u_char *) (rdata + 1);\n\t    break;\n\t}\n\n\tcase PGM_NAK:\n\tcase PGM_NULLNAK:\n\tcase PGM_NCF: {\n\t    const struct pgm_nak *nak;\n\t    char source_buf[INET6_ADDRSTRLEN], group_buf[INET6_ADDRSTRLEN];\n\n\t    nak = (const struct pgm_nak *)(pgm + 1);\n\t    ND_TCHECK(*nak);\n\t    bp = (const u_char *) (nak + 1);\n\n\t    /*\n\t     * Skip past the source, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    switch (EXTRACT_16BITS(&nak->pgmn_source_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Skip past the group, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    bp += (2 * sizeof(uint16_t));\n\t    switch (EXTRACT_16BITS(bp)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Options decoding can go here.\n\t     */\n\t    switch (pgm->pgm_type) {\n\t\tcase PGM_NAK:\n\t\t    ND_PRINT((ndo, \"NAK \"));\n\t\t    break;\n\t\tcase PGM_NULLNAK:\n\t\t    ND_PRINT((ndo, \"NNAK \"));\n\t\t    break;\n\t\tcase PGM_NCF:\n\t\t    ND_PRINT((ndo, \"NCF \"));\n\t\t    break;\n\t\tdefault:\n                    break;\n\t    }\n\t    ND_PRINT((ndo, \"(%s -> %s), seq %u\",\n\t\t\t source_buf, group_buf, EXTRACT_32BITS(&nak->pgmn_seq)));\n\t    break;\n\t}\n\n\tcase PGM_ACK: {\n\t    const struct pgm_ack *ack;\n\n\t    ack = (const struct pgm_ack *)(pgm + 1);\n\t    ND_TCHECK(*ack);\n\t    ND_PRINT((ndo, \"ACK seq %u\",\n\t\t\t EXTRACT_32BITS(&ack->pgma_rx_max_seq)));\n\t    bp = (const u_char *) (ack + 1);\n\t    break;\n\t}\n\n\tcase PGM_SPMR:\n\t    ND_PRINT((ndo, \"SPMR\"));\n\t    break;\n\n\tdefault:\n\t    ND_PRINT((ndo, \"UNKNOWN type 0x%02x\", pgm->pgm_type));\n\t    break;\n\n\t}\n\tif (pgm->pgm_options & PGM_OPT_BIT_PRESENT) {\n\n\t    /*\n\t     * make sure there's enough for the first option header\n\t     */\n\t    if (!ND_TTEST2(*bp, PGM_MIN_OPT_LEN)) {\n\t\tND_PRINT((ndo, \"[|OPT]\"));\n\t\treturn;\n\t    }\n\n\t    /*\n\t     * That option header MUST be an OPT_LENGTH option\n\t     * (see the first paragraph of section 9.1 in RFC 3208).\n\t     */\n\t    opt_type = *bp++;\n\t    if ((opt_type & PGM_OPT_MASK) != PGM_OPT_LENGTH) {\n\t\tND_PRINT((ndo, \"[First option bad, should be PGM_OPT_LENGTH, is %u]\", opt_type & PGM_OPT_MASK));\n\t\treturn;\n\t    }\n\t    opt_len = *bp++;\n\t    if (opt_len != 4) {\n\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != 4]\", opt_len));\n\t\treturn;\n\t    }\n\t    opts_len = EXTRACT_16BITS(bp);\n\t    if (opts_len < 4) {\n\t\tND_PRINT((ndo, \"[Bad total option length %u < 4]\", opts_len));\n\t\treturn;\n\t    }\n\t    bp += sizeof(uint16_t);\n\t    ND_PRINT((ndo, \" OPTS LEN %d\", opts_len));\n\t    opts_len -= 4;\n\n\t    while (opts_len) {\n\t\tif (opts_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n\t\tif (!ND_TTEST2(*bp, 2)) {\n\t\t    ND_PRINT((ndo, \" [|OPT]\"));\n\t\t    return;\n\t\t}\n\t\topt_type = *bp++;\n\t\topt_len = *bp++;\n\t\tif (opt_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Bad option, length %u < %u]\", opt_len,\n\t\t        PGM_MIN_OPT_LEN));\n\t\t    break;\n\t\t}\n\t\tif (opts_len < opt_len) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n\t\tif (!ND_TTEST2(*bp, opt_len - 2)) {\n\t\t    ND_PRINT((ndo, \" [|OPT]\"));\n\t\t    return;\n\t\t}\n\n\t\tswitch (opt_type & PGM_OPT_MASK) {\n\t\tcase PGM_OPT_LENGTH:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    ND_PRINT((ndo, \" OPTS LEN (extra?) %d\", EXTRACT_16BITS(bp)));\n\t\t    bp += sizeof(uint16_t);\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_FRAGMENT:\n\t\t    if (opt_len != 16) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FRAGMENT option, length %u != 16]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" FRAG seq %u off %u len %u\", seq, offset, len));\n\t\t    opts_len -= 16;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_LIST:\n\t\t    bp += 2;\n\t\t    opt_len -= sizeof(uint32_t);\t/* option header */\n\t\t    ND_PRINT((ndo, \" NAK LIST\"));\n\t\t    while (opt_len) {\n\t\t\tif (opt_len < sizeof(uint32_t)) {\n\t\t\t    ND_PRINT((ndo, \"[Option length not a multiple of 4]\"));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(uint32_t));\n\t\t\tND_PRINT((ndo, \" %u\", EXTRACT_32BITS(bp)));\n\t\t\tbp += sizeof(uint32_t);\n\t\t\topt_len -= sizeof(uint32_t);\n\t\t\topts_len -= sizeof(uint32_t);\n\t\t    }\n\t\t    break;\n\n\t\tcase PGM_OPT_JOIN:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_JOIN option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" JOIN %u\", seq));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_BO_IVL:\n\t\t    if (opt_len != 12) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_IVL option, length %u != 12]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" BACKOFF ivl %u ivlseq %u\", offset, seq));\n\t\t    opts_len -= 12;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_BO_RNG:\n\t\t    if (opt_len != 12) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_RNG option, length %u != 12]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" BACKOFF max %u min %u\", offset, seq));\n\t\t    opts_len -= 12;\n\t\t    break;\n\n\t\tcase PGM_OPT_REDIRECT:\n\t\t    bp += 2;\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 4 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != 4 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 4 + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 4 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != 4 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 4 + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" REDIRECT %s\",  nla_buf));\n\t\t    break;\n\n\t\tcase PGM_OPT_PARITY_PRM:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_PRM option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" PARITY MAXTGS %u\", len));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_PARITY_GRP:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_GRP option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" PARITY GROUP %u\", seq));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_CURR_TGSIZE:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CURR_TGSIZE option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" PARITY ATGS %u\", len));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_NBR_UNREACH:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NBR_UNREACH option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" NBR_UNREACH\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_PATH_NLA:\n\t\t    ND_PRINT((ndo, \" PATH_NLA [%d]\", opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\n\t\tcase PGM_OPT_SYN:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_SYN option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" SYN\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_FIN:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FIN option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" FIN\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_RST:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_RST option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" RST\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_CR:\n\t\t    ND_PRINT((ndo, \" CR\"));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\n\t\tcase PGM_OPT_CRQST:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CRQST option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" CRQST\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_PGMCC_DATA:\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 12 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 12 + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 12 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 12 + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC DATA %u %s\", offset, nla_buf));\n\t\t    break;\n\n\t\tcase PGM_OPT_PGMCC_FEEDBACK:\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 12 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 12 + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 12 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 12 + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC FEEDBACK %u %s\", offset, nla_buf));\n\t\t    break;\n\n\t\tdefault:\n\t\t    ND_PRINT((ndo, \" OPT_%02X [%d] \", opt_type, opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\t\t}\n\n\t\tif (opt_type & PGM_OPT_END)\n\t\t    break;\n\t     }\n\t}\n\n\tND_PRINT((ndo, \" [%u]\", length));\n\tif (ndo->ndo_packettype == PT_PGM_ZMTP1 &&\n\t    (pgm->pgm_type == PGM_ODATA || pgm->pgm_type == PGM_RDATA))\n\t\tzmtp1_print_datagram(ndo, bp, EXTRACT_16BITS(&pgm->pgm_length));\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pgm]\"));\n\tif (ch != '\\0')\n\t\tND_PRINT((ndo, \">\"));\n}\n```\n \n\n\nwith the following test error:     pgm_opts_asan_2                    : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "4601c685e7fd19c3724d5e499c69b8d3ec49933e___print-pgm.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nvoid\nvtp_print (netdissect_options *ndo,\n           const u_char *pptr, u_int length)\n{\n    int type, len, tlv_len, tlv_value, mgmtd_len;\n    const u_char *tptr;\n    const struct vtp_vlan_ *vtp_vlan;\n\n    if (length < VTP_HEADER_LEN)\n        goto trunc;\n\n    tptr = pptr;\n\n    ND_TCHECK2(*tptr, VTP_HEADER_LEN);\n\n    type = *(tptr+1);\n    ND_PRINT((ndo, \"VTPv%u, Message %s (0x%02x), length %u\",\n\t   *tptr,\n\t   tok2str(vtp_message_type_values,\"Unknown message type\", type),\n\t   type,\n\t   length));\n\n    /* In non-verbose mode, just print version and message type */\n    if (ndo->ndo_vflag < 1) {\n        return;\n    }\n\n    /* verbose mode print all fields */\n    ND_PRINT((ndo, \"\\n\\tDomain name: \"));\n    mgmtd_len = *(tptr + 3);\n    if (mgmtd_len < 1 ||  mgmtd_len > 32) {\n\tND_PRINT((ndo, \" [invalid MgmtD Len %d]\", mgmtd_len));\n\treturn;\n    }\n    fn_printzp(ndo, tptr + 4, mgmtd_len, NULL);\n    ND_PRINT((ndo, \", %s: %u\",\n\t   tok2str(vtp_header_values, \"Unknown\", type),\n\t   *(tptr+2)));\n\n    tptr += VTP_HEADER_LEN;\n\n    switch (type) {\n\n    case VTP_SUMMARY_ADV:\n\n\t/*\n\t *  SUMMARY ADVERTISEMENT\n\t *\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |     Version   |     Code      |    Followers  |    MgmtD Len  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       Management Domain Name  (zero-padded to 32 bytes)       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                    Configuration revision number              |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                  Updater Identity IP address                  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                    Update Timestamp (12 bytes)                |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                        MD5 digest (16 bytes)                  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\tND_TCHECK2(*tptr, 8);\n\tND_PRINT((ndo, \"\\n\\t  Config Rev %x, Updater %s\",\n\t       EXTRACT_32BITS(tptr),\n\t       ipaddr_string(ndo, tptr+4)));\n\ttptr += 8;\n\tND_TCHECK2(*tptr, VTP_UPDATE_TIMESTAMP_LEN);\n\tND_PRINT((ndo, \", Timestamp 0x%08x 0x%08x 0x%08x\",\n\t       EXTRACT_32BITS(tptr),\n\t       EXTRACT_32BITS(tptr + 4),\n\t       EXTRACT_32BITS(tptr + 8)));\n\ttptr += VTP_UPDATE_TIMESTAMP_LEN;\n\tND_TCHECK2(*tptr, VTP_MD5_DIGEST_LEN);\n\tND_PRINT((ndo, \", MD5 digest: %08x%08x%08x%08x\",\n\t       EXTRACT_32BITS(tptr),\n\t       EXTRACT_32BITS(tptr + 4),\n\t       EXTRACT_32BITS(tptr + 8),\n\t       EXTRACT_32BITS(tptr + 12)));\n\ttptr += VTP_MD5_DIGEST_LEN;\n\tbreak;\n\n    case VTP_SUBSET_ADV:\n\n\t/*\n\t *  SUBSET ADVERTISEMENT\n\t *\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |     Version   |     Code      |   Seq number  |    MgmtD Len  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       Management Domain Name  (zero-padded to 32 bytes)       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                    Configuration revision number              |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         VLAN info field 1                     |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         ................                      |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         VLAN info field N                     |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\tND_PRINT((ndo, \", Config Rev %x\", EXTRACT_32BITS(tptr)));\n\n\t/*\n\t *  VLAN INFORMATION\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  | V info len    |    Status     |  VLAN type    | VLAN name len |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       ISL vlan id             |            MTU size           |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                     802.10 index (SAID)                       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                         VLAN name                             |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\ttptr += 4;\n\twhile (tptr < (pptr+length)) {\n\n\t    len = *tptr;\n\t    if (len == 0)\n\t\tbreak;\n\n\t    ND_TCHECK2(*tptr, len);\n\n\t    vtp_vlan = (const struct vtp_vlan_*)tptr;\n\t    ND_TCHECK(*vtp_vlan);\n\t    ND_PRINT((ndo, \"\\n\\tVLAN info status %s, type %s, VLAN-id %u, MTU %u, SAID 0x%08x, Name \",\n\t\t   tok2str(vtp_vlan_status,\"Unknown\",vtp_vlan->status),\n\t\t   tok2str(vtp_vlan_type_values,\"Unknown\",vtp_vlan->type),\n\t\t   EXTRACT_16BITS(&vtp_vlan->vlanid),\n\t\t   EXTRACT_16BITS(&vtp_vlan->mtu),\n\t\t   EXTRACT_32BITS(&vtp_vlan->index)));\n\t    fn_printzp(ndo, tptr + VTP_VLAN_INFO_OFFSET, vtp_vlan->name_len, NULL);\n\n            /*\n             * Vlan names are aligned to 32-bit boundaries.\n             */\n            len  -= VTP_VLAN_INFO_OFFSET + 4*((vtp_vlan->name_len + 3)/4);\n            tptr += VTP_VLAN_INFO_OFFSET + 4*((vtp_vlan->name_len + 3)/4);\n\n            /* TLV information follows */\n\n            while (len > 0) {\n\n                /*\n                 * Cisco specs says 2 bytes for type + 2 bytes for length, take only 1\n                 * See: http://www.cisco.com/univercd/cc/td/doc/product/lan/trsrb/frames.htm\n                 */\n                type = *tptr;\n                tlv_len = *(tptr+1);\n\n                ND_PRINT((ndo, \"\\n\\t\\t%s (0x%04x) TLV\",\n                       tok2str(vtp_vlan_tlv_values, \"Unknown\", type),\n                       type));\n\n                /*\n                 * infinite loop check\n                 */\n                if (type == 0 || tlv_len == 0) {\n                    return;\n                }\n\n                ND_TCHECK2(*tptr, tlv_len * 2 +2);\n\n                tlv_value = EXTRACT_16BITS(tptr+2);\n\n                switch (type) {\n                case VTP_VLAN_STE_HOP_COUNT:\n                    ND_PRINT((ndo, \", %u\", tlv_value));\n                    break;\n\n                case VTP_VLAN_PRUNING:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tlv_value == 1 ? \"Enabled\" : \"Disabled\",\n                           tlv_value));\n                    break;\n\n                case VTP_VLAN_STP_TYPE:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tok2str(vtp_stp_type_values, \"Unknown\", tlv_value),\n                           tlv_value));\n                    break;\n\n                case VTP_VLAN_BRIDGE_TYPE:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tlv_value == 1 ? \"SRB\" : \"SRT\",\n                           tlv_value));\n                    break;\n\n                case VTP_VLAN_BACKUP_CRF_MODE:\n                    ND_PRINT((ndo, \", %s (%u)\",\n                           tlv_value == 1 ? \"Backup\" : \"Not backup\",\n                           tlv_value));\n                    break;\n\n                    /*\n                     * FIXME those are the defined TLVs that lack a decoder\n                     * you are welcome to contribute code ;-)\n                     */\n\n                case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER:\n                case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER:\n                case VTP_VLAN_PARENT_VLAN:\n                case VTP_VLAN_TRANS_BRIDGED_VLAN:\n                case VTP_VLAN_ARP_HOP_COUNT:\n                default:\n\t\t    print_unknown_data(ndo, tptr, \"\\n\\t\\t  \", 2 + tlv_len*2);\n                    break;\n                }\n                len -= 2 + tlv_len*2;\n                tptr += 2 + tlv_len*2;\n            }\n\t}\n\tbreak;\n\n    case VTP_ADV_REQUEST:\n\n\t/*\n\t *  ADVERTISEMENT REQUEST\n\t *\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |     Version   |     Code      |   Reserved    |    MgmtD Len  |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |       Management Domain Name  (zero-padded to 32 bytes)       |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *  |                          Start value                          |\n\t *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t *\n\t */\n\n\tND_TCHECK2(*tptr, 4);\n\tND_PRINT((ndo, \"\\n\\tStart value: %u\", EXTRACT_32BITS(tptr)));\n\tbreak;\n\n    case VTP_JOIN_MESSAGE:\n\n\t/* FIXME - Could not find message format */\n\tbreak;\n\n    default:\n\tbreak;\n    }\n\n    return;\n\n trunc:\n    ND_PRINT((ndo, \"[|vtp]\"));\n}\n```\n \n\n\nwith the following test error:     vtp_asan                           : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "c5dd7bef5e54da5996dc4713284aa6266ae75b75___print-vtp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic void\nprint_attr_string(netdissect_options *ndo,\n                  register const u_char *data, u_int length, u_short attr_code)\n{\n   register u_int i;\n\n   ND_TCHECK2(data[0],length);\n\n   switch(attr_code)\n   {\n      case TUNNEL_PASS:\n           if (length < 3)\n           {\n              ND_PRINT((ndo, \"%s\", tstr));\n              return;\n           }\n           if (*data && (*data <=0x1F) )\n              ND_PRINT((ndo, \"Tag[%u] \", *data));\n           else\n              ND_PRINT((ndo, \"Tag[Unused] \"));\n           data++;\n           length--;\n           ND_PRINT((ndo, \"Salt %u \", EXTRACT_16BITS(data)));\n           data+=2;\n           length-=2;\n        break;\n      case TUNNEL_CLIENT_END:\n      case TUNNEL_SERVER_END:\n      case TUNNEL_PRIV_GROUP:\n      case TUNNEL_ASSIGN_ID:\n      case TUNNEL_CLIENT_AUTH:\n      case TUNNEL_SERVER_AUTH:\n           if (*data <= 0x1F)\n           {\n              if (length < 1)\n              {\n                 ND_PRINT((ndo, \"%s\", tstr));\n                 return;\n              }\n              if (*data)\n                ND_PRINT((ndo, \"Tag[%u] \", *data));\n              else\n                ND_PRINT((ndo, \"Tag[Unused] \"));\n              data++;\n              length--;\n           }\n        break;\n      case EGRESS_VLAN_NAME:\n           ND_PRINT((ndo, \"%s (0x%02x) \",\n                  tok2str(rfc4675_tagged,\"Unknown tag\",*data),\n                  *data));\n           data++;\n           length--;\n        break;\n   }\n\n   for (i=0; *data && i < length ; i++, data++)\n       ND_PRINT((ndo, \"%c\", (*data < 32 || *data > 126) ? '.' : *data));\n\n   return;\n\n   trunc:\n      ND_PRINT((ndo, \"%s\", tstr));\n}\n```\n \n\n\nwith the following test error:     radius_attr_asan                   : passed\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "1bc78d795cd5cad5525498658f414a11ea0a7e9c___print-radius.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nvoid\npgm_print(netdissect_options *ndo,\n          register const u_char *bp, register u_int length,\n          register const u_char *bp2)\n{\n\tregister const struct pgm_header *pgm;\n\tregister const struct ip *ip;\n\tregister char ch;\n\tuint16_t sport, dport;\n\tu_int nla_afnum;\n\tchar nla_buf[INET6_ADDRSTRLEN];\n\tregister const struct ip6_hdr *ip6;\n\tuint8_t opt_type, opt_len;\n\tuint32_t seq, opts_len, len, offset;\n\n\tpgm = (const struct pgm_header *)bp;\n\tip = (const struct ip *)bp2;\n\tif (IP_V(ip) == 6)\n\t\tip6 = (const struct ip6_hdr *)bp2;\n\telse\n\t\tip6 = NULL;\n\tch = '\\0';\n\tif (!ND_TTEST(pgm->pgm_dport)) {\n\t\tif (ip6) {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst)));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst)));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsport = EXTRACT_16BITS(&pgm->pgm_sport);\n\tdport = EXTRACT_16BITS(&pgm->pgm_dport);\n\n\tif (ip6) {\n\t\tif (ip6->ip6_nxt == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t} else {\n\t\tif (ip->ip_p == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t}\n\n\tND_TCHECK(*pgm);\n\n        ND_PRINT((ndo, \"PGM, length %u\", EXTRACT_16BITS(&pgm->pgm_length)));\n\n        if (!ndo->ndo_vflag)\n            return;\n\n\tND_PRINT((ndo, \" 0x%02x%02x%02x%02x%02x%02x \",\n\t\t     pgm->pgm_gsid[0],\n                     pgm->pgm_gsid[1],\n                     pgm->pgm_gsid[2],\n\t\t     pgm->pgm_gsid[3],\n                     pgm->pgm_gsid[4],\n                     pgm->pgm_gsid[5]));\n\tswitch (pgm->pgm_type) {\n\tcase PGM_SPM: {\n\t    const struct pgm_spm *spm;\n\n\t    spm = (const struct pgm_spm *)(pgm + 1);\n\t    ND_TCHECK(*spm);\n\t    bp = (const u_char *) (spm + 1);\n\n\t    switch (EXTRACT_16BITS(&spm->pgms_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_PRINT((ndo, \"SPM seq %u trail %u lead %u nla %s\",\n\t\t\t EXTRACT_32BITS(&spm->pgms_seq),\n                         EXTRACT_32BITS(&spm->pgms_trailseq),\n\t\t\t EXTRACT_32BITS(&spm->pgms_leadseq),\n                         nla_buf));\n\t    break;\n\t}\n\n\tcase PGM_POLL: {\n\t    const struct pgm_poll *poll_msg;\n\n\t    poll_msg = (const struct pgm_poll *)(pgm + 1);\n\t    ND_TCHECK(*poll_msg);\n\t    ND_PRINT((ndo, \"POLL seq %u round %u\",\n\t\t\t EXTRACT_32BITS(&poll_msg->pgmp_seq),\n                         EXTRACT_16BITS(&poll_msg->pgmp_round)));\n\t    bp = (const u_char *) (poll_msg + 1);\n\t    break;\n\t}\n\tcase PGM_POLR: {\n\t    const struct pgm_polr *polr;\n\t    uint32_t ivl, rnd, mask;\n\n\t    polr = (const struct pgm_polr *)(pgm + 1);\n\t    ND_TCHECK(*polr);\n\t    bp = (const u_char *) (polr + 1);\n\n\t    switch (EXTRACT_16BITS(&polr->pgmp_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    ivl = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    rnd = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    mask = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_PRINT((ndo, \"POLR seq %u round %u nla %s ivl %u rnd 0x%08x \"\n\t\t\t \"mask 0x%08x\", EXTRACT_32BITS(&polr->pgmp_seq),\n\t\t\t EXTRACT_16BITS(&polr->pgmp_round), nla_buf, ivl, rnd, mask));\n\t    break;\n\t}\n\tcase PGM_ODATA: {\n\t    const struct pgm_data *odata;\n\n\t    odata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*odata);\n\t    ND_PRINT((ndo, \"ODATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&odata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&odata->pgmd_seq)));\n\t    bp = (const u_char *) (odata + 1);\n\t    break;\n\t}\n\n\tcase PGM_RDATA: {\n\t    const struct pgm_data *rdata;\n\n\t    rdata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*rdata);\n\t    ND_PRINT((ndo, \"RDATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_seq)));\n\t    bp = (const u_char *) (rdata + 1);\n\t    break;\n\t}\n\n\tcase PGM_NAK:\n\tcase PGM_NULLNAK:\n\tcase PGM_NCF: {\n\t    const struct pgm_nak *nak;\n\t    char source_buf[INET6_ADDRSTRLEN], group_buf[INET6_ADDRSTRLEN];\n\n\t    nak = (const struct pgm_nak *)(pgm + 1);\n\t    ND_TCHECK(*nak);\n\t    bp = (const u_char *) (nak + 1);\n\n\t    /*\n\t     * Skip past the source, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    switch (EXTRACT_16BITS(&nak->pgmn_source_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Skip past the group, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    bp += (2 * sizeof(uint16_t));\n\t    switch (EXTRACT_16BITS(bp)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Options decoding can go here.\n\t     */\n\t    switch (pgm->pgm_type) {\n\t\tcase PGM_NAK:\n\t\t    ND_PRINT((ndo, \"NAK \"));\n\t\t    break;\n\t\tcase PGM_NULLNAK:\n\t\t    ND_PRINT((ndo, \"NNAK \"));\n\t\t    break;\n\t\tcase PGM_NCF:\n\t\t    ND_PRINT((ndo, \"NCF \"));\n\t\t    break;\n\t\tdefault:\n                    break;\n\t    }\n\t    ND_PRINT((ndo, \"(%s -> %s), seq %u\",\n\t\t\t source_buf, group_buf, EXTRACT_32BITS(&nak->pgmn_seq)));\n\t    break;\n\t}\n\n\tcase PGM_ACK: {\n\t    const struct pgm_ack *ack;\n\n\t    ack = (const struct pgm_ack *)(pgm + 1);\n\t    ND_TCHECK(*ack);\n\t    ND_PRINT((ndo, \"ACK seq %u\",\n\t\t\t EXTRACT_32BITS(&ack->pgma_rx_max_seq)));\n\t    bp = (const u_char *) (ack + 1);\n\t    break;\n\t}\n\n\tcase PGM_SPMR:\n\t    ND_PRINT((ndo, \"SPMR\"));\n\t    break;\n\n\tdefault:\n\t    ND_PRINT((ndo, \"UNKNOWN type 0x%02x\", pgm->pgm_type));\n\t    break;\n\n\t}\n\tif (pgm->pgm_options & PGM_OPT_BIT_PRESENT) {\n\n\t    /*\n\t     * make sure there's enough for the first option header\n\t     */\n\t    if (!ND_TTEST2(*bp, PGM_MIN_OPT_LEN)) {\n\t\tND_PRINT((ndo, \"[|OPT]\"));\n\t\treturn;\n\t    }\n\n\t    /*\n\t     * That option header MUST be an OPT_LENGTH option\n\t     * (see the first paragraph of section 9.1 in RFC 3208).\n\t     */\n\t    opt_type = *bp++;\n\t    if ((opt_type & PGM_OPT_MASK) != PGM_OPT_LENGTH) {\n\t\tND_PRINT((ndo, \"[First option bad, should be PGM_OPT_LENGTH, is %u]\", opt_type & PGM_OPT_MASK));\n\t\treturn;\n\t    }\n\t    opt_len = *bp++;\n\t    if (opt_len != 4) {\n\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != 4]\", opt_len));\n\t\treturn;\n\t    }\n\t    opts_len = EXTRACT_16BITS(bp);\n\t    if (opts_len < 4) {\n\t\tND_PRINT((ndo, \"[Bad total option length %u < 4]\", opts_len));\n\t\treturn;\n\t    }\n\t    bp += sizeof(uint16_t);\n\t    ND_PRINT((ndo, \" OPTS LEN %d\", opts_len));\n\t    opts_len -= 4;\n\n\t    while (opts_len) {\n\t\tif (opts_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n\t\tif (!ND_TTEST2(*bp, 2)) {\n\t\t    ND_PRINT((ndo, \" [|OPT]\"));\n\t\t    return;\n\t\t}\n\t\topt_type = *bp++;\n\t\topt_len = *bp++;\n\t\tif (opt_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Bad option, length %u < %u]\", opt_len,\n\t\t        PGM_MIN_OPT_LEN));\n\t\t    break;\n\t\t}\n\t\tif (opts_len < opt_len) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n\t\tif (!ND_TTEST2(*bp, opt_len - 2)) {\n\t\t    ND_PRINT((ndo, \" [|OPT]\"));\n\t\t    return;\n\t\t}\n\n\t\tswitch (opt_type & PGM_OPT_MASK) {\n\t\tcase PGM_OPT_LENGTH:\n#define PGM_OPT_LENGTH_LEN\t(2+2)\n\t\t    if (opt_len != PGM_OPT_LENGTH_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_LENGTH_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    ND_PRINT((ndo, \" OPTS LEN (extra?) %d\", EXTRACT_16BITS(bp)));\n\t\t    bp += 2;\n\t\t    opts_len -= PGM_OPT_LENGTH_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_FRAGMENT:\n#define PGM_OPT_FRAGMENT_LEN\t(2+2+4+4+4)\n\t\t    if (opt_len != PGM_OPT_FRAGMENT_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FRAGMENT option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_FRAGMENT_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    ND_PRINT((ndo, \" FRAG seq %u off %u len %u\", seq, offset, len));\n\t\t    opts_len -= PGM_OPT_FRAGMENT_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_LIST:\n\t\t    bp += 2;\n\t\t    opt_len -= 4;\t/* option header */\n\t\t    ND_PRINT((ndo, \" NAK LIST\"));\n\t\t    while (opt_len) {\n\t\t\tif (opt_len < 4) {\n\t\t\t    ND_PRINT((ndo, \"[Option length not a multiple of 4]\"));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, 4);\n\t\t\tND_PRINT((ndo, \" %u\", EXTRACT_32BITS(bp)));\n\t\t\tbp += 4;\n\t\t\topt_len -= 4;\n\t\t\topts_len -= 4;\n\t\t    }\n\t\t    break;\n\n\t\tcase PGM_OPT_JOIN:\n#define PGM_OPT_JOIN_LEN\t(2+2+4)\n\t\t    if (opt_len != PGM_OPT_JOIN_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_JOIN option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_JOIN_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    ND_PRINT((ndo, \" JOIN %u\", seq));\n\t\t    opts_len -= PGM_OPT_JOIN_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_BO_IVL:\n#define PGM_OPT_NAK_BO_IVL_LEN\t(2+2+4+4)\n\t\t    if (opt_len != PGM_OPT_NAK_BO_IVL_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_IVL option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_NAK_BO_IVL_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    ND_PRINT((ndo, \" BACKOFF ivl %u ivlseq %u\", offset, seq));\n\t\t    opts_len -= PGM_OPT_NAK_BO_IVL_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_BO_RNG:\n#define PGM_OPT_NAK_BO_RNG_LEN\t(2+2+4+4)\n\t\t    if (opt_len != PGM_OPT_NAK_BO_RNG_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_RNG option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_NAK_BO_RNG_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    ND_PRINT((ndo, \" BACKOFF max %u min %u\", offset, seq));\n\t\t    opts_len -= PGM_OPT_NAK_BO_RNG_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_REDIRECT:\n#define PGM_OPT_REDIRECT_FIXED_LEN\t(2+2+2+2)\n\t\t    if (opt_len < PGM_OPT_REDIRECT_FIXED_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u < %u]\",\n\t\t\t    opt_len, PGM_OPT_REDIRECT_FIXED_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += 2+2;\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != %u + address size]\",\n\t\t\t        opt_len, PGM_OPT_REDIRECT_FIXED_LEN));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != %u + address size]\",\n\t\t\t        PGM_OPT_REDIRECT_FIXED_LEN, opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" REDIRECT %s\",  nla_buf));\n\t\t    break;\n\n\t\tcase PGM_OPT_PARITY_PRM:\n#define PGM_OPT_PARITY_PRM_LEN\t(2+2+4)\n\t\t    if (opt_len != PGM_OPT_PARITY_PRM_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_PRM option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_PARITY_PRM_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    ND_PRINT((ndo, \" PARITY MAXTGS %u\", len));\n\t\t    opts_len -= PGM_OPT_PARITY_PRM_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_PARITY_GRP:\n#define PGM_OPT_PARITY_GRP_LEN\t(2+2+4)\n\t\t    if (opt_len != PGM_OPT_PARITY_GRP_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_GRP option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_PARITY_GRP_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    ND_PRINT((ndo, \" PARITY GROUP %u\", seq));\n\t\t    opts_len -= PGM_OPT_PARITY_GRP_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_CURR_TGSIZE:\n#define PGM_OPT_CURR_TGSIZE_LEN\t(2+2+4)\n\t\t    if (opt_len != PGM_OPT_CURR_TGSIZE_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CURR_TGSIZE option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_CURR_TGSIZE_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    ND_PRINT((ndo, \" PARITY ATGS %u\", len));\n\t\t    opts_len -= PGM_OPT_CURR_TGSIZE_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_NBR_UNREACH:\n#define PGM_OPT_NBR_UNREACH_LEN\t(2+2)\n\t\t    if (opt_len != PGM_OPT_NBR_UNREACH_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NBR_UNREACH option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_NBR_UNREACH_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" NBR_UNREACH\"));\n\t\t    opts_len -= PGM_OPT_NBR_UNREACH_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_PATH_NLA:\n\t\t    ND_PRINT((ndo, \" PATH_NLA [%d]\", opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\n\t\tcase PGM_OPT_SYN:\n#define PGM_OPT_SYN_LEN\t(2+2)\n\t\t    if (opt_len != PGM_OPT_SYN_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_SYN option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_SYN_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" SYN\"));\n\t\t    opts_len -= PGM_OPT_SYN_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_FIN:\n#define PGM_OPT_FIN_LEN\t(2+2)\n\t\t    if (opt_len != PGM_OPT_FIN_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FIN option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_FIN_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" FIN\"));\n\t\t    opts_len -= PGM_OPT_FIN_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_RST:\n#define PGM_OPT_RST_LEN\t(2+2)\n\t\t    if (opt_len != PGM_OPT_RST_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_RST option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_RST_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" RST\"));\n\t\t    opts_len -= PGM_OPT_RST_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_CR:\n\t\t    ND_PRINT((ndo, \" CR\"));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\n\t\tcase PGM_OPT_CRQST:\n#define PGM_OPT_CRQST_LEN\t(2+2)\n\t\t    if (opt_len != PGM_OPT_CRQST_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CRQST option, length %u != %u]\",\n\t\t\t    opt_len, PGM_OPT_CRQST_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" CRQST\"));\n\t\t    opts_len -= PGM_OPT_CRQST_LEN;\n\t\t    break;\n\n\t\tcase PGM_OPT_PGMCC_DATA:\n#define PGM_OPT_PGMCC_DATA_FIXED_LEN\t(2+2+4+2+2)\n\t\t    if (opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u < %u]\",\n\t\t\t    opt_len, PGM_OPT_PGMCC_DATA_FIXED_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += 2+2;\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != %u + address size]\",\n\t\t\t        opt_len, PGM_OPT_PGMCC_DATA_FIXED_LEN));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != %u + address size]\",\n\t\t\t        opt_len, PGM_OPT_PGMCC_DATA_FIXED_LEN));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC DATA %u %s\", offset, nla_buf));\n\t\t    break;\n\n\t\tcase PGM_OPT_PGMCC_FEEDBACK:\n#define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN\t(2+2+4+2+2)\n\t\t    if (opt_len < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN) {\n\t\t\tND_PRINT((ndo, \"[Bad PGM_OPT_PGMCC_FEEDBACK option, length %u < %u]\",\n\t\t\t    opt_len, PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += 4;\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += 2+2;\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_FEEDBACK option, length %u != %u + address size]\",\n\t\t\t        opt_len, PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_FEEDBACK option, length %u != %u + address size]\",\n\t\t\t        opt_len, PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC FEEDBACK %u %s\", offset, nla_buf));\n\t\t    break;\n\n\t\tdefault:\n\t\t    ND_PRINT((ndo, \" OPT_%02X [%d] \", opt_type, opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\t\t}\n\n\t\tif (opt_type & PGM_OPT_END)\n\t\t    break;\n\t     }\n\t}\n\n\tND_PRINT((ndo, \" [%u]\", length));\n\tif (ndo->ndo_packettype == PT_PGM_ZMTP1 &&\n\t    (pgm->pgm_type == PGM_ODATA || pgm->pgm_type == PGM_RDATA))\n\t\tzmtp1_print_datagram(ndo, bp, EXTRACT_16BITS(&pgm->pgm_length));\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pgm]\"));\n\tif (ch != '\\0')\n\t\tND_PRINT((ndo, \">\"));\n}\n```\n \n\n\nwith the following test error:     pgm_group_addr_asan                : passed\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "da6f1a677bfa4476abaeaf9b1afe1c4390f51b41___print-pgm.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic void\nicmp6_nodeinfo_print(netdissect_options *ndo, u_int icmp6len, const u_char *bp, const u_char *ep)\n{\n\tconst struct icmp6_nodeinfo *ni6;\n\tconst struct icmp6_hdr *dp;\n\tconst u_char *cp;\n\tsize_t siz, i;\n\tint needcomma;\n\n\tif (ep < bp)\n\t\treturn;\n\tdp = (const struct icmp6_hdr *)bp;\n\tni6 = (const struct icmp6_nodeinfo *)bp;\n\tsiz = ep - bp;\n\n\tswitch (ni6->ni_type) {\n\tcase ICMP6_NI_QUERY:\n\t\tif (siz == sizeof(*dp) + 4) {\n\t\t\t/* KAME who-are-you */\n\t\t\tND_PRINT((ndo,\" who-are-you request\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo,\" node information query\"));\n\n\t\tND_TCHECK2(*dp, sizeof(*ni6));\n\t\tni6 = (const struct icmp6_nodeinfo *)dp;\n\t\tND_PRINT((ndo,\" (\"));\t/*)*/\n\t\tswitch (EXTRACT_16BITS(&ni6->ni_qtype)) {\n\t\tcase NI_QTYPE_NOOP:\n\t\t\tND_PRINT((ndo,\"noop\"));\n\t\t\tbreak;\n\t\tcase NI_QTYPE_SUPTYPES:\n\t\t\tND_PRINT((ndo,\"supported qtypes\"));\n\t\t\ti = EXTRACT_16BITS(&ni6->ni_flags);\n\t\t\tif (i)\n\t\t\t\tND_PRINT((ndo,\" [%s]\", (i & 0x01) ? \"C\" : \"\"));\n\t\t\tbreak;\n\t\tcase NI_QTYPE_FQDN:\n\t\t\tND_PRINT((ndo,\"DNS name\"));\n\t\t\tbreak;\n\t\tcase NI_QTYPE_NODEADDR:\n\t\t\tND_PRINT((ndo,\"node addresses\"));\n\t\t\ti = ni6->ni_flags;\n\t\t\tif (!i)\n\t\t\t\tbreak;\n\t\t\t/* NI_NODEADDR_FLAG_TRUNCATE undefined for query */\n\t\t\tND_PRINT((ndo,\" [%s%s%s%s%s%s]\",\n\t\t\t    (i & NI_NODEADDR_FLAG_ANYCAST) ? \"a\" : \"\",\n\t\t\t    (i & NI_NODEADDR_FLAG_GLOBAL) ? \"G\" : \"\",\n\t\t\t    (i & NI_NODEADDR_FLAG_SITELOCAL) ? \"S\" : \"\",\n\t\t\t    (i & NI_NODEADDR_FLAG_LINKLOCAL) ? \"L\" : \"\",\n\t\t\t    (i & NI_NODEADDR_FLAG_COMPAT) ? \"C\" : \"\",\n\t\t\t    (i & NI_NODEADDR_FLAG_ALL) ? \"A\" : \"\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tND_PRINT((ndo,\"unknown\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ni6->ni_qtype == NI_QTYPE_NOOP ||\n\t\t    ni6->ni_qtype == NI_QTYPE_SUPTYPES) {\n\t\t\tif (siz != sizeof(*ni6))\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", invalid len\"));\n\t\t\t/*(*/\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\t}\n\n\n\t\t/* XXX backward compat, icmp-name-lookup-03 */\n\t\tif (siz == sizeof(*ni6)) {\n\t\t\tND_PRINT((ndo,\", 03 draft\"));\n\t\t\t/*(*/\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ni6->ni_code) {\n\t\tcase ICMP6_NI_SUBJ_IPV6:\n\t\t\tif (!ND_TTEST2(*dp,\n\t\t\t    sizeof(*ni6) + sizeof(struct in6_addr)))\n\t\t\t\tbreak;\n\t\t\tif (siz != sizeof(*ni6) + sizeof(struct in6_addr)) {\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", invalid subject len\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_PRINT((ndo,\", subject=%s\",\n                                  ip6addr_string(ndo, ni6 + 1)));\n\t\t\tbreak;\n\t\tcase ICMP6_NI_SUBJ_FQDN:\n\t\t\tND_PRINT((ndo,\", subject=DNS name\"));\n\t\t\tcp = (const u_char *)(ni6 + 1);\n\t\t\tif (cp[0] == ep - cp - 1) {\n\t\t\t\t/* icmp-name-lookup-03, pascal string */\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", 03 draft\"));\n\t\t\t\tcp++;\n\t\t\t\tND_PRINT((ndo,\", \\\"\"));\n\t\t\t\twhile (cp < ep) {\n\t\t\t\t\tsafeputchar(ndo, *cp);\n\t\t\t\t\tcp++;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo,\"\\\"\"));\n\t\t\t} else\n\t\t\t\tdnsname_print(ndo, cp, ep);\n\t\t\tbreak;\n\t\tcase ICMP6_NI_SUBJ_IPV4:\n\t\t\tif (!ND_TTEST2(*dp, sizeof(*ni6) + sizeof(struct in_addr)))\n\t\t\t\tbreak;\n\t\t\tif (siz != sizeof(*ni6) + sizeof(struct in_addr)) {\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", invalid subject len\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_PRINT((ndo,\", subject=%s\",\n                                  ipaddr_string(ndo, ni6 + 1)));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tND_PRINT((ndo,\", unknown subject\"));\n\t\t\tbreak;\n\t\t}\n\n\t\t/*(*/\n\t\tND_PRINT((ndo,\")\"));\n\t\tbreak;\n\n\tcase ICMP6_NI_REPLY:\n\t\tif (icmp6len > siz) {\n\t\t\tND_PRINT((ndo,\"[|icmp6: node information reply]\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tneedcomma = 0;\n\n\t\tni6 = (const struct icmp6_nodeinfo *)dp;\n\t\tND_PRINT((ndo,\" node information reply\"));\n\t\tND_PRINT((ndo,\" (\"));\t/*)*/\n\t\tswitch (ni6->ni_code) {\n\t\tcase ICMP6_NI_SUCCESS:\n\t\t\tif (ndo->ndo_vflag) {\n\t\t\t\tND_PRINT((ndo,\"success\"));\n\t\t\t\tneedcomma++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ICMP6_NI_REFUSED:\n\t\t\tND_PRINT((ndo,\"refused\"));\n\t\t\tneedcomma++;\n\t\t\tif (siz != sizeof(*ni6))\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", invalid length\"));\n\t\t\tbreak;\n\t\tcase ICMP6_NI_UNKNOWN:\n\t\t\tND_PRINT((ndo,\"unknown\"));\n\t\t\tneedcomma++;\n\t\t\tif (siz != sizeof(*ni6))\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", invalid length\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ni6->ni_code != ICMP6_NI_SUCCESS) {\n\t\t\t/*(*/\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (EXTRACT_16BITS(&ni6->ni_qtype)) {\n\t\tcase NI_QTYPE_NOOP:\n\t\t\tif (needcomma)\n\t\t\t\tND_PRINT((ndo,\", \"));\n\t\t\tND_PRINT((ndo,\"noop\"));\n\t\t\tif (siz != sizeof(*ni6))\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", invalid length\"));\n\t\t\tbreak;\n\t\tcase NI_QTYPE_SUPTYPES:\n\t\t\tif (needcomma)\n\t\t\t\tND_PRINT((ndo,\", \"));\n\t\t\tND_PRINT((ndo,\"supported qtypes\"));\n\t\t\ti = EXTRACT_16BITS(&ni6->ni_flags);\n\t\t\tif (i)\n\t\t\t\tND_PRINT((ndo,\" [%s]\", (i & 0x01) ? \"C\" : \"\"));\n\t\t\tbreak;\n\t\tcase NI_QTYPE_FQDN:\n\t\t\tif (needcomma)\n\t\t\t\tND_PRINT((ndo,\", \"));\n\t\t\tND_PRINT((ndo,\"DNS name\"));\n\t\t\tcp = (const u_char *)(ni6 + 1) + 4;\n\t\t\tif (cp[0] == ep - cp - 1) {\n\t\t\t\t/* icmp-name-lookup-03, pascal string */\n\t\t\t\tif (ndo->ndo_vflag)\n\t\t\t\t\tND_PRINT((ndo,\", 03 draft\"));\n\t\t\t\tcp++;\n\t\t\t\tND_PRINT((ndo,\", \\\"\"));\n\t\t\t\twhile (cp < ep) {\n\t\t\t\t\tsafeputchar(ndo, *cp);\n\t\t\t\t\tcp++;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo,\"\\\"\"));\n\t\t\t} else\n\t\t\t\tdnsname_print(ndo, cp, ep);\n\t\t\tif ((EXTRACT_16BITS(&ni6->ni_flags) & 0x01) != 0)\n\t\t\t\tND_PRINT((ndo,\" [TTL=%u]\", EXTRACT_32BITS(ni6 + 1)));\n\t\t\tbreak;\n\t\tcase NI_QTYPE_NODEADDR:\n\t\t\tif (needcomma)\n\t\t\t\tND_PRINT((ndo,\", \"));\n\t\t\tND_PRINT((ndo,\"node addresses\"));\n\t\t\ti = sizeof(*ni6);\n\t\t\twhile (i < siz) {\n\t\t\t\tif (i + sizeof(struct in6_addr) + sizeof(int32_t) > siz)\n\t\t\t\t\tbreak;\n\t\t\t\tND_PRINT((ndo,\" %s\", ip6addr_string(ndo, bp + i)));\n\t\t\t\ti += sizeof(struct in6_addr);\n\t\t\t\tND_PRINT((ndo,\"(%d)\", (int32_t)EXTRACT_32BITS(bp + i)));\n\t\t\t\ti += sizeof(int32_t);\n\t\t\t}\n\t\t\ti = ni6->ni_flags;\n\t\t\tif (!i)\n\t\t\t\tbreak;\n\t\t\tND_PRINT((ndo,\" [%s%s%s%s%s%s%s]\",\n                                  (i & NI_NODEADDR_FLAG_ANYCAST) ? \"a\" : \"\",\n                                  (i & NI_NODEADDR_FLAG_GLOBAL) ? \"G\" : \"\",\n                                  (i & NI_NODEADDR_FLAG_SITELOCAL) ? \"S\" : \"\",\n                                  (i & NI_NODEADDR_FLAG_LINKLOCAL) ? \"L\" : \"\",\n                                  (i & NI_NODEADDR_FLAG_COMPAT) ? \"C\" : \"\",\n                                  (i & NI_NODEADDR_FLAG_ALL) ? \"A\" : \"\",\n                                  (i & NI_NODEADDR_FLAG_TRUNCATE) ? \"T\" : \"\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (needcomma)\n\t\t\t\tND_PRINT((ndo,\", \"));\n\t\t\tND_PRINT((ndo,\"unknown\"));\n\t\t\tbreak;\n\t\t}\n\n\t\t/*(*/\n\t\tND_PRINT((ndo,\")\"));\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|icmp6]\"));\n}\n```\n \n\n\nwith the following test error:     icmp6_nodeinfo_oobr                : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "f4b9e24c7384d882a7f434cc7413925bf871d63e___print-icmp6.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic int\ndhcpv6_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint16_t type, optlen;\n\n    i = 0;\n    while (i < length) {\n        tlv = cp + i;\n        type = EXTRACT_16BITS(tlv);\n        optlen = EXTRACT_16BITS(tlv + 2);\n        value = tlv + 4;\n\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n\n        ND_PRINT((ndo, \"%s\", tok2str(dh6opt_str, \"Unknown\", type)));\n        ND_PRINT((ndo,\" (%u)\", optlen + 4 ));\n\n        switch (type) {\n            case DH6OPT_DNS_SERVERS:\n            case DH6OPT_SNTP_SERVERS: {\n                if (optlen % 16 != 0) {\n                    ND_PRINT((ndo, \" %s\", istr));\n                    return -1;\n                }\n                for (t = 0; t < optlen; t += 16)\n                    ND_PRINT((ndo, \" %s\", ip6addr_string(ndo, value + t)));\n            }\n                break;\n            case DH6OPT_DOMAIN_LIST: {\n                const u_char *tp = value;\n                while (tp < value + optlen) {\n                    ND_PRINT((ndo, \" \"));\n                    if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                        return -1;\n                }\n            }\n                break;\n        }\n\n        i += 4 + optlen;\n    }\n    return 0;\n}\n```\n \n\n\nwith the following test error:     hncp_dhcpv6data-oobr               : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "39582c04cc5e34054b2936b423072fb9df2ff6ef___print-hncp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic int\ndhcpv4_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint8_t type, optlen;\n\n    i = 0;\n    while (i < length) {\n        tlv = cp + i;\n        type = (uint8_t)tlv[0];\n        optlen = (uint8_t)tlv[1];\n        value = tlv + 2;\n\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n\n        ND_PRINT((ndo, \"%s\", tok2str(dh4opt_str, \"Unknown\", type)));\n        ND_PRINT((ndo,\" (%u)\", optlen + 2 ));\n\n        switch (type) {\n        case DH4OPT_DNS_SERVERS:\n        case DH4OPT_NTP_SERVERS: {\n            if (optlen < 4 || optlen % 4 != 0) {\n                return -1;\n            }\n            for (t = 0; t < optlen; t += 4)\n                ND_PRINT((ndo, \" %s\", ipaddr_string(ndo, value + t)));\n        }\n            break;\n        case DH4OPT_DOMAIN_SEARCH: {\n            const u_char *tp = value;\n            while (tp < value + optlen) {\n                ND_PRINT((ndo, \" \"));\n                if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                    return -1;\n            }\n        }\n            break;\n        }\n\n        i += 2 + optlen;\n    }\n    return 0;\n}\n```\n \n\n\nwith the following test error:     hncp_dhcpv4data-oobr               : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "c2f6833dddecf2d5fb89c9c898eee9981da342ed___print-hncp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic int\ndecode_multicast_vpn(netdissect_options *ndo,\n                     const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t route_type, route_length, addr_length, sg_length;\n        u_int offset;\n\n\tND_TCHECK2(pptr[0], 2);\n        route_type = *pptr++;\n        route_length = *pptr++;\n\n        snprintf(buf, buflen, \"Route-Type: %s (%u), length: %u\",\n                 tok2str(bgp_multicast_vpn_route_type_values,\n                         \"Unknown\", route_type),\n                 route_type, route_length);\n\n        switch(route_type) {\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s, Originator %s\",\n                     bgp_vpn_rd_print(ndo, pptr),\n                     bgp_vpn_ip_print(ndo, pptr + BGP_VPN_RD_LEN,\n                                      (route_length - BGP_VPN_RD_LEN) << 3));\n            break;\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            sg_length = bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            addr_length =  route_length - sg_length;\n\n            ND_TCHECK2(pptr[0], addr_length);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", Originator %s\",\n                     bgp_vpn_ip_print(ndo, pptr, addr_length << 3));\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN: /* fall through */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            pptr += BGP_VPN_RD_LEN;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n            /*\n             * no per route-type printing yet.\n             */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF:\n        default:\n            break;\n        }\n\n        return route_length + 2;\n\ntrunc:\n\treturn -2;\n}\n```\n \n\n\nwith the following test error:     bgp_mvpn_6_and_7                   : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "d515b4b4a300479cdf1a6e0d1bb95bc1f9fee514___print-bgp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic void\nesis_print(netdissect_options *ndo,\n           const uint8_t *pptr, u_int length)\n{\n\tconst uint8_t *optr;\n\tu_int li,esis_pdu_type,source_address_length, source_address_number;\n\tconst struct esis_header_t *esis_header;\n\n\tif (!ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"ES-IS\"));\n\n\tif (length <= 2) {\n\t\tND_PRINT((ndo, ndo->ndo_qflag ? \"bad pkt!\" : \"no header at all!\"));\n\t\treturn;\n\t}\n\n\tesis_header = (const struct esis_header_t *) pptr;\n        ND_TCHECK(*esis_header);\n        li = esis_header->length_indicator;\n        optr = pptr;\n\n        /*\n         * Sanity checking of the header.\n         */\n\n        if (esis_header->nlpid != NLPID_ESIS) {\n            ND_PRINT((ndo, \" nlpid 0x%02x packet not supported\", esis_header->nlpid));\n            return;\n        }\n\n        if (esis_header->version != ESIS_VERSION) {\n            ND_PRINT((ndo, \" version %d packet not supported\", esis_header->version));\n            return;\n        }\n\n\tif (li > length) {\n            ND_PRINT((ndo, \" length indicator(%u) > PDU size (%u)!\", li, length));\n            return;\n\t}\n\n\tif (li < sizeof(struct esis_header_t) + 2) {\n            ND_PRINT((ndo, \" length indicator %u < min PDU size:\", li));\n            while (pptr < ndo->ndo_snapend)\n                ND_PRINT((ndo, \"%02X\", *pptr++));\n            return;\n\t}\n\n        esis_pdu_type = esis_header->type & ESIS_PDU_TYPE_MASK;\n\n        if (ndo->ndo_vflag < 1) {\n            ND_PRINT((ndo, \"%s%s, length %u\",\n                   ndo->ndo_eflag ? \"\" : \", \",\n                   tok2str(esis_pdu_values,\"unknown type (%u)\",esis_pdu_type),\n                   length));\n            return;\n        } else\n            ND_PRINT((ndo, \"%slength %u\\n\\t%s (%u)\",\n                   ndo->ndo_eflag ? \"\" : \", \",\n                   length,\n                   tok2str(esis_pdu_values,\"unknown type: %u\", esis_pdu_type),\n                   esis_pdu_type));\n\n        ND_PRINT((ndo, \", v: %u%s\", esis_header->version, esis_header->version == ESIS_VERSION ? \"\" : \"unsupported\" ));\n        ND_PRINT((ndo, \", checksum: 0x%04x\", EXTRACT_16BITS(esis_header->cksum)));\n\n        osi_print_cksum(ndo, pptr, EXTRACT_16BITS(esis_header->cksum), 7, li);\n\n        ND_PRINT((ndo, \", holding time: %us, length indicator: %u\",\n                  EXTRACT_16BITS(esis_header->holdtime), li));\n\n        if (ndo->ndo_vflag > 1)\n            print_unknown_data(ndo, optr, \"\\n\\t\", sizeof(struct esis_header_t));\n\n\tpptr += sizeof(struct esis_header_t);\n\tli -= sizeof(struct esis_header_t);\n\n\tswitch (esis_pdu_type) {\n\tcase ESIS_PDU_REDIRECT: {\n\t\tconst uint8_t *dst, *snpa, *neta;\n\t\tu_int dstl, snpal, netal;\n\n\t\tND_TCHECK(*pptr);\n\t\tif (li < 1) {\n\t\t\tND_PRINT((ndo, \", bad redirect/li\"));\n\t\t\treturn;\n\t\t}\n\t\tdstl = *pptr;\n\t\tpptr++;\n\t\tli--;\n\t\tND_TCHECK2(*pptr, dstl);\n\t\tif (li < dstl) {\n\t\t\tND_PRINT((ndo, \", bad redirect/li\"));\n\t\t\treturn;\n\t\t}\n\t\tdst = pptr;\n\t\tpptr += dstl;\n                li -= dstl;\n\t\tND_PRINT((ndo, \"\\n\\t  %s\", isonsap_string(ndo, dst, dstl)));\n\n\t\tND_TCHECK(*pptr);\n\t\tif (li < 1) {\n\t\t\tND_PRINT((ndo, \", bad redirect/li\"));\n\t\t\treturn;\n\t\t}\n\t\tsnpal = *pptr;\n\t\tpptr++;\n\t\tli--;\n\t\tND_TCHECK2(*pptr, snpal);\n\t\tif (li < snpal) {\n\t\t\tND_PRINT((ndo, \", bad redirect/li\"));\n\t\t\treturn;\n\t\t}\n\t\tsnpa = pptr;\n\t\tpptr += snpal;\n                li -= snpal;\n\t\tND_TCHECK(*pptr);\n\t\tif (li < 1) {\n\t\t\tND_PRINT((ndo, \", bad redirect/li\"));\n\t\t\treturn;\n\t\t}\n\t\tnetal = *pptr;\n\t\tpptr++;\n\t\tND_TCHECK2(*pptr, netal);\n\t\tif (li < netal) {\n\t\t\tND_PRINT((ndo, \", bad redirect/li\"));\n\t\t\treturn;\n\t\t}\n\t\tneta = pptr;\n\t\tpptr += netal;\n                li -= netal;\n\n\t\tif (snpal == 6)\n\t\t\tND_PRINT((ndo, \"\\n\\t  SNPA (length: %u): %s\",\n\t\t\t       snpal,\n\t\t\t       etheraddr_string(ndo, snpa)));\n\t\telse\n\t\t\tND_PRINT((ndo, \"\\n\\t  SNPA (length: %u): %s\",\n\t\t\t       snpal,\n\t\t\t       linkaddr_string(ndo, snpa, LINKADDR_OTHER, snpal)));\n\t\tif (netal != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  NET (length: %u) %s\",\n\t\t\t       netal,\n\t\t\t       isonsap_string(ndo, neta, netal)));\n\t\tbreak;\n\t}\n\n\tcase ESIS_PDU_ESH:\n            ND_TCHECK(*pptr);\n            if (li < 1) {\n                ND_PRINT((ndo, \", bad esh/li\"));\n                return;\n            }\n            source_address_number = *pptr;\n            pptr++;\n            li--;\n\n            ND_PRINT((ndo, \"\\n\\t  Number of Source Addresses: %u\", source_address_number));\n\n            while (source_address_number > 0) {\n                ND_TCHECK(*pptr);\n            \tif (li < 1) {\n                    ND_PRINT((ndo, \", bad esh/li\"));\n            \t    return;\n            \t}\n                source_address_length = *pptr;\n                pptr++;\n            \tli--;\n\n                ND_TCHECK2(*pptr, source_address_length);\n            \tif (li < source_address_length) {\n                    ND_PRINT((ndo, \", bad esh/li\"));\n            \t    return;\n            \t}\n                ND_PRINT((ndo, \"\\n\\t  NET (length: %u): %s\",\n                       source_address_length,\n                       isonsap_string(ndo, pptr, source_address_length)));\n                pptr += source_address_length;\n                li -= source_address_length;\n                source_address_number--;\n            }\n\n            break;\n\n\tcase ESIS_PDU_ISH: {\n            ND_TCHECK(*pptr);\n            if (li < 1) {\n                ND_PRINT((ndo, \", bad ish/li\"));\n                return;\n            }\n            source_address_length = *pptr;\n            pptr++;\n            li--;\n            ND_TCHECK2(*pptr, source_address_length);\n            if (li < source_address_length) {\n                ND_PRINT((ndo, \", bad ish/li\"));\n                return;\n            }\n            ND_PRINT((ndo, \"\\n\\t  NET (length: %u): %s\", source_address_length, isonsap_string(ndo, pptr, source_address_length)));\n            pptr += source_address_length;\n            li -= source_address_length;\n            break;\n\t}\n\n\tdefault:\n\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\tif (pptr < ndo->ndo_snapend)\n\t\t\t\tprint_unknown_data(ndo, pptr, \"\\n\\t  \", ndo->ndo_snapend - pptr);\n\t\t}\n\t\treturn;\n\t}\n\n        /* now walk the options */\n        while (li != 0) {\n            u_int op, opli;\n            const uint8_t *tptr;\n\n            if (li < 2) {\n                ND_PRINT((ndo, \", bad opts/li\"));\n                return;\n            }\n            ND_TCHECK2(*pptr, 2);\n            op = *pptr++;\n            opli = *pptr++;\n            li -= 2;\n            if (opli > li) {\n                ND_PRINT((ndo, \", opt (%d) too long\", op));\n                return;\n            }\n            li -= opli;\n            tptr = pptr;\n\n            ND_PRINT((ndo, \"\\n\\t  %s Option #%u, length %u, value: \",\n                   tok2str(esis_option_values,\"Unknown\",op),\n                   op,\n                   opli));\n\n            switch (op) {\n\n            case ESIS_OPTION_ES_CONF_TIME:\n                if (opli == 2) {\n                    ND_TCHECK2(*pptr, 2);\n                    ND_PRINT((ndo, \"%us\", EXTRACT_16BITS(tptr)));\n                } else\n                    ND_PRINT((ndo, \"(bad length)\"));\n                break;\n\n            case ESIS_OPTION_PROTOCOLS:\n                while (opli>0) {\n                    ND_TCHECK(*pptr);\n                    ND_PRINT((ndo, \"%s (0x%02x)\",\n                           tok2str(nlpid_values,\n                                   \"unknown\",\n                                   *tptr),\n                           *tptr));\n                    if (opli>1) /* further NPLIDs ? - put comma */\n                        ND_PRINT((ndo, \", \"));\n                    tptr++;\n                    opli--;\n                }\n                break;\n\n                /*\n                 * FIXME those are the defined Options that lack a decoder\n                 * you are welcome to contribute code ;-)\n                 */\n\n            case ESIS_OPTION_QOS_MAINTENANCE:\n            case ESIS_OPTION_SECURITY:\n            case ESIS_OPTION_PRIORITY:\n            case ESIS_OPTION_ADDRESS_MASK:\n            case ESIS_OPTION_SNPA_MASK:\n\n            default:\n                print_unknown_data(ndo, tptr, \"\\n\\t  \", opli);\n                break;\n            }\n            if (ndo->ndo_vflag > 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t  \", opli);\n            pptr += opli;\n        }\ntrunc:\n\treturn;\n}\n```\n \n\n\nwith the following test error:     esis_opt_prot-oobr                 : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "331530a4076c69bbd2e3214db6ccbe834fb75640___print-isoclns.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic int\ndecode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n{\n\tuint8_t route_target[8];\n\tu_int plen;\n\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   /* get prefix length */\n\n\tif (0 == plen) {\n\t\tsnprintf(buf, buflen, \"default route target\");\n\t\treturn 1;\n\t}\n\n\tif (32 > plen)\n\t\treturn -1;\n\n        plen-=32; /* adjust prefix length */\n\n\tif (64 < plen)\n\t\treturn -1;\n\n\tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[1], (plen + 7) / 8);\n\tmemcpy(&route_target, &pptr[1], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),\n\t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n\n\treturn 5 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}\n```\n \n\n\nwith the following test error:     bgp_vpn_rt-oobr                    : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "bd4e697ebd6c8457efa8f28f6831fc929b88a014___print-bgp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nvoid\nolsr_print(netdissect_options *ndo,\n           const u_char *pptr, u_int length, int is_ipv6)\n{\n    union {\n        const struct olsr_common *common;\n        const struct olsr_msg4 *msg4;\n        const struct olsr_msg6 *msg6;\n        const struct olsr_hello *hello;\n        const struct olsr_hello_link *hello_link;\n        const struct olsr_tc *tc;\n        const struct olsr_hna4 *hna;\n    } ptr;\n\n    u_int msg_type, msg_len, msg_tlen, hello_len;\n    uint16_t name_entry_type, name_entry_len;\n    u_int name_entry_padding;\n    uint8_t link_type, neighbor_type;\n    const u_char *tptr, *msg_data;\n\n    tptr = pptr;\n\n    if (length < sizeof(struct olsr_common)) {\n        goto trunc;\n    }\n\n    ND_TCHECK2(*tptr, sizeof(struct olsr_common));\n\n    ptr.common = (const struct olsr_common *)tptr;\n    length = min(length, EXTRACT_16BITS(ptr.common->packet_len));\n\n    ND_PRINT((ndo, \"OLSRv%i, seq 0x%04x, length %u\",\n            (is_ipv6 == 0) ? 4 : 6,\n            EXTRACT_16BITS(ptr.common->packet_seq),\n            length));\n\n    tptr += sizeof(struct olsr_common);\n\n    /*\n     * In non-verbose mode, just print version.\n     */\n    if (ndo->ndo_vflag < 1) {\n        return;\n    }\n\n    while (tptr < (pptr+length)) {\n        union\n        {\n            const struct olsr_msg4 *v4;\n            const struct olsr_msg6 *v6;\n        } msgptr;\n        int msg_len_valid = 0;\n\n        ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));\n\n        if (is_ipv6)\n        {\n            msgptr.v6 = (const struct olsr_msg6 *) tptr;\n            msg_type = msgptr.v6->msg_type;\n            msg_len = EXTRACT_16BITS(msgptr.v6->msg_len);\n            if ((msg_len >= sizeof (struct olsr_msg6))\n                    && (msg_len <= length))\n                msg_len_valid = 1;\n\n            /* infinite loop check */\n            if (msg_type == 0 || msg_len == 0) {\n                return;\n            }\n\n            ND_PRINT((ndo, \"\\n\\t%s Message (%#04x), originator %s, ttl %u, hop %u\"\n                    \"\\n\\t  vtime %.3fs, msg-seq 0x%04x, length %u%s\",\n                    tok2str(olsr_msg_values, \"Unknown\", msg_type),\n                    msg_type, ip6addr_string(ndo, msgptr.v6->originator),\n                    msgptr.v6->ttl,\n                    msgptr.v6->hopcount,\n                    ME_TO_DOUBLE(msgptr.v6->vtime),\n                    EXTRACT_16BITS(msgptr.v6->msg_seq),\n                    msg_len, (msg_len_valid == 0) ? \" (invalid)\" : \"\"));\n            if (!msg_len_valid) {\n                return;\n            }\n\n            msg_tlen = msg_len - sizeof(struct olsr_msg6);\n            msg_data = tptr + sizeof(struct olsr_msg6);\n        }\n        else /* (!is_ipv6) */\n        {\n            msgptr.v4 = (const struct olsr_msg4 *) tptr;\n            msg_type = msgptr.v4->msg_type;\n            msg_len = EXTRACT_16BITS(msgptr.v4->msg_len);\n            if ((msg_len >= sizeof (struct olsr_msg4))\n                    && (msg_len <= length))\n                msg_len_valid = 1;\n\n            /* infinite loop check */\n            if (msg_type == 0 || msg_len == 0) {\n                return;\n            }\n\n            ND_PRINT((ndo, \"\\n\\t%s Message (%#04x), originator %s, ttl %u, hop %u\"\n                    \"\\n\\t  vtime %.3fs, msg-seq 0x%04x, length %u%s\",\n                    tok2str(olsr_msg_values, \"Unknown\", msg_type),\n                    msg_type, ipaddr_string(ndo, msgptr.v4->originator),\n                    msgptr.v4->ttl,\n                    msgptr.v4->hopcount,\n                    ME_TO_DOUBLE(msgptr.v4->vtime),\n                    EXTRACT_16BITS(msgptr.v4->msg_seq),\n                    msg_len, (msg_len_valid == 0) ? \" (invalid)\" : \"\"));\n            if (!msg_len_valid) {\n                return;\n            }\n\n            msg_tlen = msg_len - sizeof(struct olsr_msg4);\n            msg_data = tptr + sizeof(struct olsr_msg4);\n        }\n\n        switch (msg_type) {\n        case OLSR_HELLO_MSG:\n        case OLSR_HELLO_LQ_MSG:\n            if (msg_tlen < sizeof(struct olsr_hello))\n                goto trunc;\n            ND_TCHECK2(*msg_data, sizeof(struct olsr_hello));\n\n            ptr.hello = (const struct olsr_hello *)msg_data;\n            ND_PRINT((ndo, \"\\n\\t  hello-time %.3fs, MPR willingness %u\",\n                   ME_TO_DOUBLE(ptr.hello->htime), ptr.hello->will));\n            msg_data += sizeof(struct olsr_hello);\n            msg_tlen -= sizeof(struct olsr_hello);\n\n            while (msg_tlen >= sizeof(struct olsr_hello_link)) {\n                int hello_len_valid = 0;\n\n                /*\n                 * link-type.\n                 */\n                ND_TCHECK2(*msg_data, sizeof(struct olsr_hello_link));\n\n                ptr.hello_link = (const struct olsr_hello_link *)msg_data;\n\n                hello_len = EXTRACT_16BITS(ptr.hello_link->len);\n                link_type = OLSR_EXTRACT_LINK_TYPE(ptr.hello_link->link_code);\n                neighbor_type = OLSR_EXTRACT_NEIGHBOR_TYPE(ptr.hello_link->link_code);\n\n                if ((hello_len <= msg_tlen)\n                        && (hello_len >= sizeof(struct olsr_hello_link)))\n                    hello_len_valid = 1;\n\n                ND_PRINT((ndo, \"\\n\\t    link-type %s, neighbor-type %s, len %u%s\",\n                       tok2str(olsr_link_type_values, \"Unknown\", link_type),\n                       tok2str(olsr_neighbor_type_values, \"Unknown\", neighbor_type),\n                       hello_len,\n                       (hello_len_valid == 0) ? \" (invalid)\" : \"\"));\n\n                if (hello_len_valid == 0)\n                    break;\n\n                msg_data += sizeof(struct olsr_hello_link);\n                msg_tlen -= sizeof(struct olsr_hello_link);\n                hello_len -= sizeof(struct olsr_hello_link);\n\n                ND_TCHECK2(*msg_data, hello_len);\n                if (msg_type == OLSR_HELLO_MSG) {\n                    if (olsr_print_neighbor(ndo, msg_data, hello_len) == -1)\n                        goto trunc;\n                } else {\n                    if (is_ipv6) {\n                        if (olsr_print_lq_neighbor6(ndo, msg_data, hello_len) == -1)\n                            goto trunc;\n                    } else {\n                        if (olsr_print_lq_neighbor4(ndo, msg_data, hello_len) == -1)\n                            goto trunc;\n                    }\n                }\n\n                msg_data += hello_len;\n                msg_tlen -= hello_len;\n            }\n            break;\n\n        case OLSR_TC_MSG:\n        case OLSR_TC_LQ_MSG:\n            if (msg_tlen < sizeof(struct olsr_tc))\n                goto trunc;\n            ND_TCHECK2(*msg_data, sizeof(struct olsr_tc));\n\n            ptr.tc = (const struct olsr_tc *)msg_data;\n            ND_PRINT((ndo, \"\\n\\t    advertised neighbor seq 0x%04x\",\n                   EXTRACT_16BITS(ptr.tc->ans_seq)));\n            msg_data += sizeof(struct olsr_tc);\n            msg_tlen -= sizeof(struct olsr_tc);\n\n            if (msg_type == OLSR_TC_MSG) {\n                if (olsr_print_neighbor(ndo, msg_data, msg_tlen) == -1)\n                    goto trunc;\n            } else {\n                if (is_ipv6) {\n                    if (olsr_print_lq_neighbor6(ndo, msg_data, msg_tlen) == -1)\n                        goto trunc;\n                } else {\n                    if (olsr_print_lq_neighbor4(ndo, msg_data, msg_tlen) == -1)\n                        goto trunc;\n                }\n            }\n            break;\n\n        case OLSR_MID_MSG:\n        {\n            size_t addr_size = sizeof(struct in_addr);\n\n            if (is_ipv6)\n                addr_size = sizeof(struct in6_addr);\n\n            while (msg_tlen >= addr_size) {\n                ND_TCHECK2(*msg_data, addr_size);\n                ND_PRINT((ndo, \"\\n\\t  interface address %s\",\n                        is_ipv6 ? ip6addr_string(ndo, msg_data) :\n                        ipaddr_string(ndo, msg_data)));\n\n                msg_data += addr_size;\n                msg_tlen -= addr_size;\n            }\n            break;\n        }\n\n        case OLSR_HNA_MSG:\n            if (is_ipv6)\n            {\n                int i = 0;\n\n                ND_PRINT((ndo, \"\\n\\t  Advertised networks (total %u)\",\n                        (unsigned int) (msg_tlen / sizeof(struct olsr_hna6))));\n\n                while (msg_tlen >= sizeof(struct olsr_hna6)) {\n                    const struct olsr_hna6 *hna6;\n\n                    ND_TCHECK2(*msg_data, sizeof(struct olsr_hna6));\n\n                    hna6 = (const struct olsr_hna6 *)msg_data;\n\n                    ND_PRINT((ndo, \"\\n\\t    #%i: %s/%u\",\n                            i, ip6addr_string(ndo, hna6->network),\n                            mask62plen (hna6->mask)));\n\n                    msg_data += sizeof(struct olsr_hna6);\n                    msg_tlen -= sizeof(struct olsr_hna6);\n                }\n            }\n            else\n            {\n                int col = 0;\n\n                ND_PRINT((ndo, \"\\n\\t  Advertised networks (total %u)\",\n                        (unsigned int) (msg_tlen / sizeof(struct olsr_hna4))));\n\n                while (msg_tlen >= sizeof(struct olsr_hna4)) {\n                    ND_TCHECK2(*msg_data, sizeof(struct olsr_hna4));\n\n                    ptr.hna = (const struct olsr_hna4 *)msg_data;\n\n                    /* print 4 prefixes per line */\n                    if (!ptr.hna->network[0] && !ptr.hna->network[1] &&\n                        !ptr.hna->network[2] && !ptr.hna->network[3] &&\n                        !ptr.hna->mask[GW_HNA_PAD] &&\n                        ptr.hna->mask[GW_HNA_FLAGS]) {\n                            /* smart gateway */\n                            ND_PRINT((ndo, \"%sSmart-Gateway:%s%s%s%s%s %u/%u\",\n                                col == 0 ? \"\\n\\t    \" : \", \", /* indent */\n                                /* sgw */\n                                /* LINKSPEED */\n                                (ptr.hna->mask[GW_HNA_FLAGS] &\n                                 GW_HNA_FLAG_LINKSPEED) ? \" LINKSPEED\" : \"\",\n                                /* IPV4 */\n                                (ptr.hna->mask[GW_HNA_FLAGS] &\n                                 GW_HNA_FLAG_IPV4) ? \" IPV4\" : \"\",\n                                /* IPV4-NAT */\n                                (ptr.hna->mask[GW_HNA_FLAGS] &\n                                 GW_HNA_FLAG_IPV4_NAT) ? \" IPV4-NAT\" : \"\",\n                                /* IPV6 */\n                                (ptr.hna->mask[GW_HNA_FLAGS] &\n                                 GW_HNA_FLAG_IPV6) ? \" IPV6\" : \"\",\n                                /* IPv6PREFIX */\n                                (ptr.hna->mask[GW_HNA_FLAGS] &\n                                 GW_HNA_FLAG_IPV6PREFIX) ? \" IPv6-PREFIX\" : \"\",\n                                /* uplink */\n                                (ptr.hna->mask[GW_HNA_FLAGS] &\n                                 GW_HNA_FLAG_LINKSPEED) ?\n                                 deserialize_gw_speed(ptr.hna->mask[GW_HNA_UPLINK]) : 0,\n                                /* downlink */\n                                (ptr.hna->mask[GW_HNA_FLAGS] &\n                                 GW_HNA_FLAG_LINKSPEED) ?\n                                 deserialize_gw_speed(ptr.hna->mask[GW_HNA_DOWNLINK]) : 0\n                                ));\n                    } else {\n                        /* normal route */\n                        ND_PRINT((ndo, \"%s%s/%u\",\n                                col == 0 ? \"\\n\\t    \" : \", \",\n                                ipaddr_string(ndo, ptr.hna->network),\n                                mask2plen(EXTRACT_32BITS(ptr.hna->mask))));\n                    }\n\n                    msg_data += sizeof(struct olsr_hna4);\n                    msg_tlen -= sizeof(struct olsr_hna4);\n\n                    col = (col + 1) % 4;\n                }\n            }\n            break;\n\n        case OLSR_NAMESERVICE_MSG:\n        {\n            u_int name_entries = EXTRACT_16BITS(msg_data+2);\n            u_int addr_size = 4;\n            int name_entries_valid = 0;\n            u_int i;\n\n            if (is_ipv6)\n                addr_size = 16;\n\n            if ((name_entries > 0)\n                    && ((name_entries * (4 + addr_size)) <= msg_tlen))\n                name_entries_valid = 1;\n\n            if (msg_tlen < 4)\n                goto trunc;\n            ND_TCHECK2(*msg_data, 4);\n\n            ND_PRINT((ndo, \"\\n\\t  Version %u, Entries %u%s\",\n                   EXTRACT_16BITS(msg_data),\n                   name_entries, (name_entries_valid == 0) ? \" (invalid)\" : \"\"));\n\n            if (name_entries_valid == 0)\n                break;\n\n            msg_data += 4;\n            msg_tlen -= 4;\n\n            for (i = 0; i < name_entries; i++) {\n                int name_entry_len_valid = 0;\n\n                if (msg_tlen < 4)\n                    break;\n                ND_TCHECK2(*msg_data, 4);\n\n                name_entry_type = EXTRACT_16BITS(msg_data);\n                name_entry_len = EXTRACT_16BITS(msg_data+2);\n\n                msg_data += 4;\n                msg_tlen -= 4;\n\n                if ((name_entry_len > 0) && ((addr_size + name_entry_len) <= msg_tlen))\n                    name_entry_len_valid = 1;\n\n                ND_PRINT((ndo, \"\\n\\t    #%u: type %#06x, length %u%s\",\n                        (unsigned int) i, name_entry_type,\n                        name_entry_len, (name_entry_len_valid == 0) ? \" (invalid)\" : \"\"));\n\n                if (name_entry_len_valid == 0)\n                    break;\n\n                /* 32-bit alignment */\n                name_entry_padding = 0;\n                if (name_entry_len%4 != 0)\n                    name_entry_padding = 4-(name_entry_len%4);\n\n                if (msg_tlen < addr_size + name_entry_len + name_entry_padding)\n                    goto trunc;\n\n                ND_TCHECK2(*msg_data, addr_size + name_entry_len + name_entry_padding);\n\n                if (is_ipv6)\n                    ND_PRINT((ndo, \", address %s, name \\\"\",\n                            ip6addr_string(ndo, msg_data)));\n                else\n                    ND_PRINT((ndo, \", address %s, name \\\"\",\n                            ipaddr_string(ndo, msg_data)));\n                (void)fn_printn(ndo, msg_data + addr_size, name_entry_len, NULL);\n                ND_PRINT((ndo, \"\\\"\"));\n\n                msg_data += addr_size + name_entry_len + name_entry_padding;\n                msg_tlen -= addr_size + name_entry_len + name_entry_padding;\n            } /* for (i = 0; i < name_entries; i++) */\n            break;\n        } /* case OLSR_NAMESERVICE_MSG */\n\n            /*\n             * FIXME those are the defined messages that lack a decoder\n             * you are welcome to contribute code ;-)\n             */\n        case OLSR_POWERINFO_MSG:\n        default:\n            print_unknown_data(ndo, msg_data, \"\\n\\t    \", msg_tlen);\n            break;\n        } /* switch (msg_type) */\n        tptr += msg_len;\n    } /* while (tptr < (pptr+length)) */\n\n    return;\n\n trunc:\n    ND_PRINT((ndo, \"[|olsr]\"));\n}\n```\n \n\n\nwith the following test error:     olsr-oobr-2                        : TEST FAILED(exit 256)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "0cb1b8a434b599b8d636db029aadb757c24e39d6___print-olsr.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic int lookupName(\n  Parse *pParse,       /* The parsing context */\n  const char *zDb,     /* Name of the database containing table, or NULL */\n  const char *zTab,    /* Name of table containing column, or NULL */\n  const char *zCol,    /* Name of the column. */\n  NameContext *pNC,    /* The name context used to resolve the name */\n  Expr *pExpr          /* Make this EXPR node point to the selected column */\n){\n  int i, j;                         /* Loop counters */\n  int cnt = 0;                      /* Number of matching column names */\n  int cntTab = 0;                   /* Number of matching table names */\n  int nSubquery = 0;                /* How many levels of subquery */\n  sqlite3 *db = pParse->db;         /* The database connection */\n  struct SrcList_item *pItem;       /* Use for looping over pSrcList items */\n  struct SrcList_item *pMatch = 0;  /* The matching pSrcList item */\n  NameContext *pTopNC = pNC;        /* First namecontext in the list */\n  Schema *pSchema = 0;              /* Schema of the expression */\n  int eNewExprOp = TK_COLUMN;       /* New value for pExpr->op on success */\n  Table *pTab = 0;                  /* Table hold the row */\n  Column *pCol;                     /* A column of pTab */\n\n  assert( pNC );     /* the name context cannot be NULL. */\n  assert( zCol );    /* The Z in X.Y.Z cannot be NULL */\n  assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );\n\n  /* Initialize the node to no-match */\n  pExpr->iTable = -1;\n  ExprSetVVAProperty(pExpr, EP_NoReduce);\n\n  /* Translate the schema name in zDb into a pointer to the corresponding\n  ** schema.  If not found, pSchema will remain NULL and nothing will match\n  ** resulting in an appropriate error message toward the end of this routine\n  */\n  if( zDb ){\n    testcase( pNC->ncFlags & NC_PartIdx );\n    testcase( pNC->ncFlags & NC_IsCheck );\n    if( (pNC->ncFlags & (NC_PartIdx|NC_IsCheck))!=0 ){\n      /* Silently ignore database qualifiers inside CHECK constraints and\n      ** partial indices.  Do not raise errors because that might break\n      ** legacy and because it does not hurt anything to just ignore the\n      ** database name. */\n      zDb = 0;\n    }else{\n      for(i=0; i<db->nDb; i++){\n        assert( db->aDb[i].zDbSName );\n        if( sqlite3StrICmp(db->aDb[i].zDbSName,zDb)==0 ){\n          pSchema = db->aDb[i].pSchema;\n          break;\n        }\n      }\n    }\n  }\n\n  /* Start at the inner-most context and move outward until a match is found */\n  assert( pNC && cnt==0 );\n  do{\n    ExprList *pEList;\n    SrcList *pSrcList = pNC->pSrcList;\n\n    if( pSrcList ){\n      for(i=0, pItem=pSrcList->a; i<pSrcList->nSrc; i++, pItem++){\n        pTab = pItem->pTab;\n        assert( pTab!=0 && pTab->zName!=0 );\n        assert( pTab->nCol>0 );\n        if( pItem->pSelect && (pItem->pSelect->selFlags & SF_NestedFrom)!=0 ){\n          int hit = 0;\n          pEList = pItem->pSelect->pEList;\n          for(j=0; j<pEList->nExpr; j++){\n            if( sqlite3MatchSpanName(pEList->a[j].zSpan, zCol, zTab, zDb) ){\n              cnt++;\n              cntTab = 2;\n              pMatch = pItem;\n              pExpr->iColumn = j;\n              hit = 1;\n            }\n          }\n          if( hit || zTab==0 ) continue;\n        }\n        if( zDb && pTab->pSchema!=pSchema ){\n          continue;\n        }\n        if( zTab ){\n          const char *zTabName = pItem->zAlias ? pItem->zAlias : pTab->zName;\n          assert( zTabName!=0 );\n          if( sqlite3StrICmp(zTabName, zTab)!=0 ){\n            continue;\n          }\n          if( IN_RENAME_OBJECT && pItem->zAlias ){\n            sqlite3RenameTokenRemap(pParse, 0, (void*)&pExpr->y.pTab);\n          }\n        }\n        if( 0==(cntTab++) ){\n          pMatch = pItem;\n        }\n        for(j=0, pCol=pTab->aCol; j<pTab->nCol; j++, pCol++){\n          if( sqlite3StrICmp(pCol->zName, zCol)==0 ){\n            /* If there has been exactly one prior match and this match\n            ** is for the right-hand table of a NATURAL JOIN or is in a \n            ** USING clause, then skip this match.\n            */\n            if( cnt==1 ){\n              if( pItem->fg.jointype & JT_NATURAL ) continue;\n              if( nameInUsingClause(pItem->pUsing, zCol) ) continue;\n            }\n            cnt++;\n            pMatch = pItem;\n            /* Substitute the rowid (column -1) for the INTEGER PRIMARY KEY */\n            pExpr->iColumn = j==pTab->iPKey ? -1 : (i16)j;\n            break;\n          }\n        }\n      }\n      if( pMatch ){\n        pExpr->iTable = pMatch->iCursor;\n        pExpr->y.pTab = pMatch->pTab;\n        /* RIGHT JOIN not (yet) supported */\n        assert( (pMatch->fg.jointype & JT_RIGHT)==0 );\n        if( (pMatch->fg.jointype & JT_LEFT)!=0 ){\n          ExprSetProperty(pExpr, EP_CanBeNull);\n        }\n        pSchema = pExpr->y.pTab->pSchema;\n      }\n    } /* if( pSrcList ) */\n\n#if !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT)\n    /* If we have not already resolved the name, then maybe \n    ** it is a new.* or old.* trigger argument reference.  Or\n    ** maybe it is an excluded.* from an upsert.\n    */\n    if( zDb==0 && zTab!=0 && cntTab==0 ){\n      pTab = 0;\n#ifndef SQLITE_OMIT_TRIGGER\n      if( pParse->pTriggerTab!=0 ){\n        int op = pParse->eTriggerOp;\n        assert( op==TK_DELETE || op==TK_UPDATE || op==TK_INSERT );\n        if( op!=TK_DELETE && sqlite3StrICmp(\"new\",zTab) == 0 ){\n          pExpr->iTable = 1;\n          pTab = pParse->pTriggerTab;\n        }else if( op!=TK_INSERT && sqlite3StrICmp(\"old\",zTab)==0 ){\n          pExpr->iTable = 0;\n          pTab = pParse->pTriggerTab;\n        }\n      }\n#endif /* SQLITE_OMIT_TRIGGER */\n#ifndef SQLITE_OMIT_UPSERT\n      if( (pNC->ncFlags & NC_UUpsert)!=0 ){\n        Upsert *pUpsert = pNC->uNC.pUpsert;\n        if( pUpsert && sqlite3StrICmp(\"excluded\",zTab)==0 ){\n          pTab = pUpsert->pUpsertSrc->a[0].pTab;\n          pExpr->iTable = 2;\n        }\n      }\n#endif /* SQLITE_OMIT_UPSERT */\n\n      if( pTab ){ \n        int iCol;\n        pSchema = pTab->pSchema;\n        cntTab++;\n        for(iCol=0, pCol=pTab->aCol; iCol<pTab->nCol; iCol++, pCol++){\n          if( sqlite3StrICmp(pCol->zName, zCol)==0 ){\n            if( iCol==pTab->iPKey ){\n              iCol = -1;\n            }\n            break;\n          }\n        }\n        if( iCol>=pTab->nCol && sqlite3IsRowid(zCol) && VisibleRowid(pTab) ){\n          /* IMP: R-51414-32910 */\n          iCol = -1;\n        }\n        if( iCol<pTab->nCol ){\n          cnt++;\n#ifndef SQLITE_OMIT_UPSERT\n          if( pExpr->iTable==2 ){\n            testcase( iCol==(-1) );\n            if( IN_RENAME_OBJECT ){\n              pExpr->iColumn = iCol;\n              pExpr->y.pTab = pTab;\n              eNewExprOp = TK_COLUMN;\n            }else{\n              pExpr->iTable = pNC->uNC.pUpsert->regData + iCol;\n              eNewExprOp = TK_REGISTER;\n              ExprSetProperty(pExpr, EP_Alias);\n            }\n          }else\n#endif /* SQLITE_OMIT_UPSERT */\n          {\n#ifndef SQLITE_OMIT_TRIGGER\n            if( iCol<0 ){\n              pExpr->affExpr = SQLITE_AFF_INTEGER;\n            }else if( pExpr->iTable==0 ){\n              testcase( iCol==31 );\n              testcase( iCol==32 );\n              pParse->oldmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));\n            }else{\n              testcase( iCol==31 );\n              testcase( iCol==32 );\n              pParse->newmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));\n            }\n            pExpr->y.pTab = pTab;\n            pExpr->iColumn = (i16)iCol;\n            eNewExprOp = TK_TRIGGER;\n#endif /* SQLITE_OMIT_TRIGGER */\n          }\n        }\n      }\n    }\n#endif /* !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT) */\n\n    /*\n    ** Perhaps the name is a reference to the ROWID\n    */\n    if( cnt==0\n     && cntTab==1\n     && pMatch\n     && (pNC->ncFlags & (NC_IdxExpr|NC_GenCol))==0\n     && sqlite3IsRowid(zCol)\n     && VisibleRowid(pMatch->pTab)\n    ){\n      cnt = 1;\n      pExpr->iColumn = -1;\n      pExpr->affExpr = SQLITE_AFF_INTEGER;\n    }\n\n    /*\n    ** If the input is of the form Z (not Y.Z or X.Y.Z) then the name Z\n    ** might refer to an result-set alias.  This happens, for example, when\n    ** we are resolving names in the WHERE clause of the following command:\n    **\n    **     SELECT a+b AS x FROM table WHERE x<10;\n    **\n    ** In cases like this, replace pExpr with a copy of the expression that\n    ** forms the result set entry (\"a+b\" in the example) and return immediately.\n    ** Note that the expression in the result set should have already been\n    ** resolved by the time the WHERE clause is resolved.\n    **\n    ** The ability to use an output result-set column in the WHERE, GROUP BY,\n    ** or HAVING clauses, or as part of a larger expression in the ORDER BY\n    ** clause is not standard SQL.  This is a (goofy) SQLite extension, that\n    ** is supported for backwards compatibility only. Hence, we issue a warning\n    ** on sqlite3_log() whenever the capability is used.\n    */\n    if( (pNC->ncFlags & NC_UEList)!=0\n     && cnt==0\n     && zTab==0\n    ){\n      pEList = pNC->uNC.pEList;\n      assert( pEList!=0 );\n      for(j=0; j<pEList->nExpr; j++){\n        char *zAs = pEList->a[j].zName;\n        if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){\n          Expr *pOrig;\n          assert( pExpr->pLeft==0 && pExpr->pRight==0 );\n          assert( pExpr->x.pList==0 );\n          assert( pExpr->x.pSelect==0 );\n          pOrig = pEList->a[j].pExpr;\n          if( (pNC->ncFlags&NC_AllowAgg)==0 && ExprHasProperty(pOrig, EP_Agg) ){\n            sqlite3ErrorMsg(pParse, \"misuse of aliased aggregate %s\", zAs);\n            return WRC_Abort;\n          }\n          if( (pNC->ncFlags&NC_AllowWin)==0 && ExprHasProperty(pOrig, EP_Win) ){\n            sqlite3ErrorMsg(pParse, \"misuse of aliased window function %s\",zAs);\n            return WRC_Abort;\n          }\n          if( sqlite3ExprVectorSize(pOrig)!=1 ){\n            sqlite3ErrorMsg(pParse, \"row value misused\");\n            return WRC_Abort;\n          }\n          resolveAlias(pParse, pEList, j, pExpr, \"\", nSubquery);\n          cnt = 1;\n          pMatch = 0;\n          assert( zTab==0 && zDb==0 );\n          if( IN_RENAME_OBJECT ){\n            sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);\n          }\n          goto lookupname_end;\n        }\n      } \n    }\n\n    /* Advance to the next name context.  The loop will exit when either\n    ** we have a match (cnt>0) or when we run out of name contexts.\n    */\n    if( cnt ) break;\n    pNC = pNC->pNext;\n    nSubquery++;\n  }while( pNC );\n\n\n  /*\n  ** If X and Y are NULL (in other words if only the column name Z is\n  ** supplied) and the value of Z is enclosed in double-quotes, then\n  ** Z is a string literal if it doesn't match any column names.  In that\n  ** case, we need to return right away and not make any changes to\n  ** pExpr.\n  **\n  ** Because no reference was made to outer contexts, the pNC->nRef\n  ** fields are not changed in any context.\n  */\n  if( cnt==0 && zTab==0 ){\n    assert( pExpr->op==TK_ID );\n    if( ExprHasProperty(pExpr,EP_DblQuoted)\n     && areDoubleQuotedStringsEnabled(db, pTopNC)\n    ){\n      /* If a double-quoted identifier does not match any known column name,\n      ** then treat it as a string.\n      **\n      ** This hack was added in the early days of SQLite in a misguided attempt\n      ** to be compatible with MySQL 3.x, which used double-quotes for strings.\n      ** I now sorely regret putting in this hack. The effect of this hack is\n      ** that misspelled identifier names are silently converted into strings\n      ** rather than causing an error, to the frustration of countless\n      ** programmers. To all those frustrated programmers, my apologies.\n      **\n      ** Someday, I hope to get rid of this hack. Unfortunately there is\n      ** a huge amount of legacy SQL that uses it. So for now, we just\n      ** issue a warning.\n      */\n      sqlite3_log(SQLITE_WARNING,\n        \"double-quoted string literal: \\\"%w\\\"\", zCol);\n#ifdef SQLITE_ENABLE_NORMALIZE\n      sqlite3VdbeAddDblquoteStr(db, pParse->pVdbe, zCol);\n#endif\n      pExpr->op = TK_STRING;\n      pExpr->y.pTab = 0;\n      return WRC_Prune;\n    }\n    if( sqlite3ExprIdToTrueFalse(pExpr) ){\n      return WRC_Prune;\n    }\n  }\n\n  /*\n  ** cnt==0 means there was not match.  cnt>1 means there were two or\n  ** more matches.  Either way, we have an error.\n  */\n  if( cnt!=1 ){\n    const char *zErr;\n    zErr = cnt==0 ? \"no such column\" : \"ambiguous column name\";\n    if( zDb ){\n      sqlite3ErrorMsg(pParse, \"%s: %s.%s.%s\", zErr, zDb, zTab, zCol);\n    }else if( zTab ){\n      sqlite3ErrorMsg(pParse, \"%s: %s.%s\", zErr, zTab, zCol);\n    }else{\n      sqlite3ErrorMsg(pParse, \"%s: %s\", zErr, zCol);\n    }\n    pParse->checkSchema = 1;\n    pTopNC->nErr++;\n  }\n\n  /* If a column from a table in pSrcList is referenced, then record\n  ** this fact in the pSrcList.a[].colUsed bitmask.  Column 0 causes\n  ** bit 0 to be set.  Column 1 sets bit 1.  And so forth.  If the\n  ** column number is greater than the number of bits in the bitmask\n  ** then set the high-order bit of the bitmask.\n  */\n  if( pExpr->iColumn>=0 && pMatch!=0 ){\n    int n = pExpr->iColumn;\n    testcase( n==BMS-1 );\n    if( n>=BMS ){\n      n = BMS-1;\n    }\n    assert( pMatch->iCursor==pExpr->iTable );\n    pMatch->colUsed |= ((Bitmask)1)<<n;\n  }\n\n  /* Clean up and return\n  */\n  sqlite3ExprDelete(db, pExpr->pLeft);\n  pExpr->pLeft = 0;\n  sqlite3ExprDelete(db, pExpr->pRight);\n  pExpr->pRight = 0;\n  pExpr->op = eNewExprOp;\n  ExprSetProperty(pExpr, EP_Leaf);\nlookupname_end:\n  if( cnt==1 ){\n    assert( pNC!=0 );\n    if( !ExprHasProperty(pExpr, EP_Alias) ){\n      sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);\n    }\n    /* Increment the nRef value on all name contexts from TopNC up to\n    ** the point where the name matched. */\n    for(;;){\n      assert( pTopNC!=0 );\n      pTopNC->nRef++;\n      if( pTopNC==pNC ) break;\n      pTopNC = pTopNC->pNext;\n    }\n    return WRC_Prune;\n  } else {\n    return WRC_Abort;\n  }\n}\n```\n \n\n\nwith the following test error: warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\ngencol1-9.20...\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000559e4f188c8f in sqlite3VdbeCursorMoveto ()\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "522ebfa7cee96fb325a22ea3a2464a63485886a8___resolve.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nExpr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){\n  Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);\n  if( p ){\n    struct SrcList_item *pItem = &pSrc->a[iSrc];\n    p->y.pTab = pItem->pTab;\n    p->iTable = pItem->iCursor;\n    if( p->y.pTab->iPKey==iCol ){\n      p->iColumn = -1;\n    }else{\n      p->iColumn = (ynVar)iCol;\n      testcase( iCol==BMS );\n      testcase( iCol==BMS-1 );\n      pItem->colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);\n    }\n  }\n  return p;\n}\n```\n \n\n\nwith the following test error: warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\ngencol1-13.10...\n! gencol1-13.10 expected: [11]\n! gencol1-13.10 got:      []\n[Detaching after fork from child process 76627]\nSQLite 2019-12-09 17:14:48 1923efb283e8840fa7436eb20b9d2174ef7cace1690d3b97b572a0db2048b8e3\n1 errors out of 103 tests on deef54515472 Linux 64-bit little-endian\n!Failures on these tests: gencol1-13.10\nAll memory allocations freed - no leaks\nMemory used:          now          0  max     342200  max-size     120000\nAllocation count:     now          0  max        382\nPage-cache used:      now          0  max          0  max-size       1288\nPage-cache overflow:  now          0  max      14688\nMaximum memory usage: 342200 bytes\nCurrent memory usage: 0 bytes\nNumber of malloc()  : -1 calls\n[Inferior 1 (process 76444) exited with code 01]\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "926f796e8feec15f3836aa0a060ed906f8ae04d3___resolve.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic int jpc_pi_nextrpcl(register jpc_pi_t *pi)\n{\n\tint rlvlno;\n\tjpc_pirlvl_t *pirlvl;\n\tjpc_pchg_t *pchg;\n\tint prchind;\n\tint prcvind;\n\tint *prclyrno;\n\tint compno;\n\tjpc_picomp_t *picomp;\n\tint xstep;\n\tint ystep;\n\tuint_fast32_t r;\n\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\tuint_fast32_t trx0;\n\tuint_fast32_t try0;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->xstep = 0;\n\t\tpi->ystep = 0;\n\t\tfor (compno = 0, picomp = pi->picomps; compno < pi->numcomps;\n\t\t  ++compno, ++picomp) {\n\t\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n\t\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\t\t// Check for the potential for overflow problems.\n\t\t\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >\n\t\t\t\t  JAS_UINTFAST32_NUMBITS - 2 ||\n\t\t\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >\n\t\t\t\t  JAS_UINTFAST32_NUMBITS - 2) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\txstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t\t\t  (pirlvl->prcwidthexpn + picomp->numrlvls - rlvlno - 1));\n\t\t\t\tystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t\t\t  (pirlvl->prcheightexpn + picomp->numrlvls - rlvlno - 1));\n\t\t\t\tpi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);\n\t\t\t\tpi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);\n\t\t\t}\n\t\t}\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pchg->rlvlnoend &&\n\t  pi->rlvlno < pi->maxrlvls; ++pi->rlvlno) {\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend; pi->y +=\n\t\t  pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend; pi->x +=\n\t\t\t  pi->xstep - (pi->x % pi->xstep)) {\n\t\t\t\tfor (pi->compno = pchg->compnostart,\n\t\t\t\t  pi->picomp = &pi->picomps[pi->compno];\n\t\t\t\t  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno <\n\t\t\t\t  pi->numcomps; ++pi->compno, ++pi->picomp) {\n\t\t\t\t\tif (pi->rlvlno >= pi->picomp->numrlvls) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\tif (((pi->x == pi->xstart &&\n\t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx)))\n\t\t\t\t\t  || !(pi->x % (JAS_CAST(uint_fast32_t, 1) << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart &&\n\t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy)))\n\t\t\t\t\t  || !(pi->y % (JAS_CAST(uint_fast32_t, 1) << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,\n\t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,\n\t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;\n\n\t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <\n\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int,\n\t\t\t\t\t\t  pchg->lyrnoend); ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n```\n \n\n\nwith the following test error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==30069==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7f802242cf64 bp 0x7ffe608ad2f0 sp 0x7ffe608acb40 T0)\n==30069==The signal is caused by a READ memory access.\n==30069==Hint: address points to the zero page.\n    #0 0x7f802242cf64 in jpc_pi_nextrpcl jpc_t2cod.c\n    #1 0x7f802242a790 in jpc_pi_next (/out/mdadams___jasper/git_repo_dir_f25486c3d4aa472fec79150f2c41ed4333395d3d/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/libjasper/libjasper.so.4+0x116790)\n    #2 0x7f8022436681 in jpc_dec_decodepkts (/out/mdadams___jasper/git_repo_dir_f25486c3d4aa472fec79150f2c41ed4333395d3d/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/libjasper/libjasper.so.4+0x122681)\n    #3 0x7f802239dd16 in jpc_dec_process_sod jpc_dec.c\n    #4 0x7f80223a431f in jpc_dec_decode jpc_dec.c\n    #5 0x7f80223a2ddb in jpc_decode (/out/mdadams___jasper/git_repo_dir_f25486c3d4aa472fec79150f2c41ed4333395d3d/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/libjasper/libjasper.so.4+0x8eddb)\n    #6 0x7f8022353581 in jas_image_decode (/out/mdadams___jasper/git_repo_dir_f25486c3d4aa472fec79150f2c41ed4333395d3d/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/libjasper/libjasper.so.4+0x3f581)\n    #7 0x559ee05c49e5 in main (/out/mdadams___jasper/git_repo_dir_f25486c3d4aa472fec79150f2c41ed4333395d3d/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/appl/imginfo+0xf29e5)\n    #8 0x7f8021ef2082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #9 0x559ee04f13dd in _start (/out/mdadams___jasper/git_repo_dir_f25486c3d4aa472fec79150f2c41ed4333395d3d/build_f25486c3d4aa472fec79150f2c41ed4333395d3d/src/appl/imginfo+0x1f3dd)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV jpc_t2cod.c in jpc_pi_nextrpcl\n==30069==ABORTING\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "f25486c3d4aa472fec79150f2c41ed4333395d3d___jpc_t2cod.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nint read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tint* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint encoded_pixels;\n\tint rle_size;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\trle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);\n\t\tif (rle_size <= 0) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < rle_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n\t\t\t\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));\n\t\t\t\t\tbitmap_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));\n\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n```\n \n\n\nwith the following test error: ========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 152\n# PASS:  149\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  3\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:31: Total pixels changed: 9 with a maximum channel difference of 255.\nfreetype/bug00132.c:33: Reference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\ngdimagestringft/gdimagestringft_bbox.c:56: (491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\nFAIL: tga/heap_overflow\n=======================\n\ntga/heap_overflow.c:21: Assert failed in <tga/heap_overflow.c:21>\nFAIL tga/heap_overflow (exit status: 2)\n\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "fb0e0cce0b9f25389ab56604c3547351617e1415___gd_tga.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nBGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)\n{\n\tint sx, sy;\n\tint i;\n\tint ncx, ncy, nc, cs, cx, cy;\n\tint x, y, ylo, yhi, xlo, xhi;\n\tint vers, fmt;\n\tt_chunk_info *chunkIdx = NULL;\t/* So we can gdFree it with impunity. */\n\tunsigned char *chunkBuf = NULL;\t/* So we can gdFree it with impunity. */\n\tint chunkNum = 0;\n\tint chunkMax = 0;\n\tuLongf chunkLen;\n\tint chunkPos = 0;\n\tint compMax = 0;\n\tint bytesPerPixel;\n\tchar *compBuf = NULL;\t\t/* So we can gdFree it with impunity. */\n\n\tgdImagePtr im;\n\n\t/* Get the header */\n\tim =\n\t    _gd2CreateFromFile (in, &sx, &sy, &cs, &vers, &fmt, &ncx, &ncy,\n\t                        &chunkIdx);\n\tif (im == NULL) {\n\t\t/* No need to free chunkIdx as _gd2CreateFromFile does it for us. */\n\t\treturn 0;\n\t}\n\n\tbytesPerPixel = im->trueColor ? 4 : 1;\n\tnc = ncx * ncy;\n\n\tif (gd2_compressed (fmt)) {\n\t\t/* Find the maximum compressed chunk size. */\n\t\tcompMax = 0;\n\t\tfor (i = 0; (i < nc); i++) {\n\t\t\tif (chunkIdx[i].size > compMax) {\n\t\t\t\tcompMax = chunkIdx[i].size;\n\t\t\t};\n\t\t};\n\t\tcompMax++;\n\n\t\t/* Allocate buffers */\n\t\tchunkMax = cs * bytesPerPixel * cs;\n\t\tchunkBuf = gdCalloc (chunkMax, 1);\n\t\tif (!chunkBuf) {\n\t\t\tgoto fail;\n\t\t}\n\t\tcompBuf = gdCalloc (compMax, 1);\n\t\tif (!compBuf) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\tGD2_DBG (printf (\"Largest compressed chunk is %d bytes\\n\", compMax));\n\t};\n\n\t/*      if ( (ncx != sx / cs) || (ncy != sy / cs)) { */\n\t/*              goto fail2; */\n\t/*      }; */\n\n\t/* Read the data... */\n\tfor (cy = 0; (cy < ncy); cy++) {\n\t\tfor (cx = 0; (cx < ncx); cx++) {\n\n\t\t\tylo = cy * cs;\n\t\t\tyhi = ylo + cs;\n\t\t\tif (yhi > im->sy) {\n\t\t\t\tyhi = im->sy;\n\t\t\t};\n\n\t\t\tGD2_DBG (printf\n\t\t\t         (\"Processing Chunk %d (%d, %d), y from %d to %d\\n\",\n\t\t\t          chunkNum, cx, cy, ylo, yhi));\n\n\t\t\tif (gd2_compressed (fmt)) {\n\n\t\t\t\tchunkLen = chunkMax;\n\n\t\t\t\tif (!_gd2ReadChunk (chunkIdx[chunkNum].offset,\n\t\t\t\t                    compBuf,\n\t\t\t\t                    chunkIdx[chunkNum].size,\n\t\t\t\t                    (char *) chunkBuf, &chunkLen, in)) {\n\t\t\t\t\tGD2_DBG (printf (\"Error reading comproessed chunk\\n\"));\n\t\t\t\t\tgoto fail;\n\t\t\t\t};\n\n\t\t\t\tchunkPos = 0;\n\t\t\t};\n\n\t\t\tfor (y = ylo; (y < yhi); y++) {\n\n\t\t\t\txlo = cx * cs;\n\t\t\t\txhi = xlo + cs;\n\t\t\t\tif (xhi > im->sx) {\n\t\t\t\t\txhi = im->sx;\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"y=%d: \",y)); */\n\t\t\t\tif (!gd2_compressed (fmt)) {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\tif (!gdGetInt (&im->tpixels[y][x], in)) {\n\t\t\t\t\t\t\t\t/*printf(\"EOF while reading\\n\"); */\n\t\t\t\t\t\t\t\t/*gdImageDestroy(im); */\n\t\t\t\t\t\t\t\t/*return 0; */\n\t\t\t\t\t\t\t\tim->tpixels[y][x] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint ch;\n\t\t\t\t\t\t\tif (!gdGetByte (&ch, in)) {\n\t\t\t\t\t\t\t\t/*printf(\"EOF while reading\\n\"); */\n\t\t\t\t\t\t\t\t/*gdImageDestroy(im); */\n\t\t\t\t\t\t\t\t/*return 0; */\n\t\t\t\t\t\t\t\tch = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tim->pixels[y][x] = ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (x = xlo; x < xhi; x++) {\n\t\t\t\t\t\tif (im->trueColor) {\n\t\t\t\t\t\t\t/* 2.0.1: work around a gcc bug by being verbose.\n\t\t\t\t\t\t\t   TBB */\n\t\t\t\t\t\t\tint a = chunkBuf[chunkPos++] << 24;\n\t\t\t\t\t\t\tint r = chunkBuf[chunkPos++] << 16;\n\t\t\t\t\t\t\tint g = chunkBuf[chunkPos++] << 8;\n\t\t\t\t\t\t\tint b = chunkBuf[chunkPos++];\n\t\t\t\t\t\t\t/* 2.0.11: tpixels */\n\t\t\t\t\t\t\tim->tpixels[y][x] = a + r + g + b;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tim->pixels[y][x] = chunkBuf[chunkPos++];\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t/*GD2_DBG(printf(\"\\n\")); */\n\t\t\t};\n\t\t\tchunkNum++;\n\t\t};\n\t};\n\n\tGD2_DBG (printf (\"Freeing memory\\n\"));\n\n\tgdFree (chunkBuf);\n\tgdFree (compBuf);\n\tgdFree (chunkIdx);\n\n\tGD2_DBG (printf (\"Done\\n\"));\n\n\treturn im;\n\nfail:\n\tgdImageDestroy (im);\n\tif (chunkBuf) {\n\t\tgdFree (chunkBuf);\n\t}\n\tif (compBuf) {\n\t\tgdFree (compBuf);\n\t}\n\tif (chunkIdx) {\n\t\tgdFree (chunkIdx);\n\t}\n\treturn 0;\n}\n```\n \n\n\nwith the following test error: ========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 155\n# PASS:  152\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  3\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:31: Total pixels changed: 9 with a maximum channel difference of 255.\nfreetype/bug00132.c:33: Reference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gd2/too_few_image_data\n============================\n\ngd2/too_few_image_data.c:18: Assert failed in <gd2/too_few_image_data.c:18>\nFAIL gd2/too_few_image_data (exit status: 2)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\ngdimagestringft/gdimagestringft_bbox.c:56: (491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "fe9ed49dafa993e3af96b6a5a589efeea9bfb36f___gd_gd2.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nBGD_DECLARE(gdImagePtr) gdImageClone (gdImagePtr src) {\n\tgdImagePtr dst;\n\tregister int i, x;\n\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(src->sx , src->sy);\n\t} else {\n\t\tdst = gdImageCreate(src->sx , src->sy);\n\t}\n\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (src->trueColor == 0) {\n\t\tdst->colorsTotal = src->colorsTotal;\n\t\tfor (i = 0; i < gdMaxColors; i++) {\n\t\t\tdst->red[i]   = src->red[i];\n\t\t\tdst->green[i] = src->green[i];\n\t\t\tdst->blue[i]  = src->blue[i];\n\t\t\tdst->alpha[i] = src->alpha[i];\n\t\t\tdst->open[i]  = src->open[i];\n\t\t}\n\t\tfor (i = 0; i < src->sy; i++) {\n\t\t\tfor (x = 0; x < src->sx; x++) {\n\t\t\t\tdst->pixels[i][x] = src->pixels[i][x];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < src->sy; i++) {\n\t\t\tfor (x = 0; x < src->sx; x++) {\n\t\t\t\tdst->tpixels[i][x] = src->tpixels[i][x];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (src->styleLength > 0) {\n\t\tdst->styleLength = src->styleLength;\n\t\tdst->stylePos    = src->stylePos;\n\t\tfor (i = 0; i < src->styleLength; i++) {\n\t\t\tdst->style[i] = src->style[i];\n\t\t}\n\t}\n\n\tdst->interlace   = src->interlace;\n\n\tdst->alphaBlendingFlag = src->alphaBlendingFlag;\n\tdst->saveAlphaFlag     = src->saveAlphaFlag;\n\tdst->AA                = src->AA;\n\tdst->AA_color          = src->AA_color;\n\tdst->AA_dont_blend     = src->AA_dont_blend;\n\n\tdst->cx1 = src->cx1;\n\tdst->cy1 = src->cy1;\n\tdst->cx2 = src->cx2;\n\tdst->cy2 = src->cy2;\n\n\tdst->res_x = src->res_x;\n\tdst->res_y = src->res_y;\n\n\tdst->paletteQuantizationMethod     = src->paletteQuantizationMethod;\n\tdst->paletteQuantizationSpeed      = src->paletteQuantizationSpeed;\n\tdst->paletteQuantizationMinQuality = src->paletteQuantizationMinQuality;\n\tdst->paletteQuantizationMinQuality = src->paletteQuantizationMinQuality;\n\n\tdst->interpolation_id = src->interpolation_id;\n\tdst->interpolation    = src->interpolation;\n\n\tif (src->brush) {\n\t\tdst->brush = gdImageClone(src->brush);\n\t}\n\n\tif (src->tile) {\n\t\tdst->tile = gdImageClone(src->tile);\n\t}\n\n\tif (src->style) {\n\t\tgdImageSetStyle(dst, src->style, src->styleLength);\n\t}\n\n\tfor (i = 0; i < gdMaxColors; i++) {\n\t\tdst->brushColorMap[i] = src->brushColorMap[i];\n\t\tdst->tileColorMap[i] = src->tileColorMap[i];\n\t}\n\n\tif (src->polyAllocated > 0) {\n\t\tdst->polyAllocated = src->polyAllocated;\n\t\tfor (i = 0; i < src->polyAllocated; i++) {\n\t\t\tdst->polyInts[i] = src->polyInts[i];\n\t\t}\n\t}\n\n\treturn dst;\n}\n```\n \n\n\nwith the following test error: ========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 191\n# PASS:  190\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  1\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: gdimageclone/style\n========================\n\nFAIL gdimageclone/style (exit status: 139)\n\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "a93eac0e843148dc2d631c3ba80af17e9c8c860f___gd.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic void php_wddx_add_var(wddx_packet *packet, zval *name_var)\n{\n\tzval **val;\n\tHashTable *target_hash;\n\tTSRMLS_FETCH();\n\n\tif (Z_TYPE_P(name_var) == IS_STRING) {\n\t\tif (!EG(active_symbol_table)) {\n\t\t\tzend_rebuild_symbol_table(TSRMLS_C);\n\t\t}\n\t\tif (zend_hash_find(EG(active_symbol_table), Z_STRVAL_P(name_var),\n\t\t\t\t\t\t\tZ_STRLEN_P(name_var)+1, (void**)&val) != FAILURE) {\n\t\t\tphp_wddx_serialize_var(packet, *val, Z_STRVAL_P(name_var), Z_STRLEN_P(name_var) TSRMLS_CC);\n\t\t}\n\t} else if (Z_TYPE_P(name_var) == IS_ARRAY || Z_TYPE_P(name_var) == IS_OBJECT)\t{\n\t\tint is_array = Z_TYPE_P(name_var) == IS_ARRAY;\n\n\t\ttarget_hash = HASH_OF(name_var);\n\n\t\tif (is_array && target_hash->nApplyCount > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"recursion detected\");\n\t\t\treturn;\n\t\t}\n\n\t\tzend_hash_internal_pointer_reset(target_hash);\n\n\t\twhile(zend_hash_get_current_data(target_hash, (void**)&val) == SUCCESS) {\n\t\t\tif (is_array) {\n\t\t\t\ttarget_hash->nApplyCount++;\n\t\t\t}\n\n\t\t\tphp_wddx_add_var(packet, *val);\n\n\t\t\tif (is_array) {\n\t\t\t\ttarget_hash->nApplyCount--;\n\t\t\t}\n\t\t\tzend_hash_move_forward(target_hash);\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_push_element\n */\nstatic void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)\n{\n\tst_entry ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\n\tif (!strcmp(name, EL_PACKET)) {\n\t\tint i;\n\n\t\tif (atts) for (i=0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VERSION)) {\n\t\t\t\t/* nothing for now */\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_STRING)) {\n\t\tent.type = ST_STRING;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BINARY)) {\n\t\tent.type = ST_BINARY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_CHAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_CHAR_CODE) && atts[++i] && atts[i][0]) {\n\t\t\t\tchar tmp_buf[2];\n\n\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i], NULL, 16));\n\t\t\t\tphp_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NUMBER)) {\n\t\tent.type = ST_NUMBER;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\tZ_LVAL_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BOOLEAN)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[++i] && atts[i][0]) {\n\t\t\t\tent.type = ST_BOOLEAN;\n\t\t\t\tSET_STACK_VARNAME;\n\n\t\t\t\tALLOC_ZVAL(ent.data);\n\t\t\t\tINIT_PZVAL(ent.data);\n\t\t\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n\t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t\t\tphp_wddx_process_data(user_data, atts[i], strlen(atts[i]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NULL)) {\n\t\tent.type = ST_NULL;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZVAL_NULL(ent.data);\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_ARRAY)) {\n\t\tent.type = ST_ARRAY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_STRUCT)) {\n\t\tent.type = ST_STRUCT;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_VAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tstack->varname = estrdup(atts[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_RECORDSET)) {\n\t\tint i;\n\n\t\tent.type = ST_RECORDSET;\n\t\tSET_STACK_VARNAME;\n\t\tMAKE_STD_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], \"fieldNames\") && atts[++i] && atts[i][0]) {\n\t\t\t\tzval *tmp;\n\t\t\t\tchar *key;\n\t\t\t\tchar *p1, *p2, *endp;\n\n\t\t\t\tendp = (char *)atts[i] + strlen(atts[i]);\n\t\t\t\tp1 = (char *)atts[i];\n\t\t\t\twhile ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {\n\t\t\t\t\tkey = estrndup(p1, p2 - p1);\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp);\n\t\t\t\t\tp1 = p2 + sizeof(\",\")-1;\n\t\t\t\t\tefree(key);\n\t\t\t\t}\n\n\t\t\t\tif (p1 <= endp) {\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tint i;\n\t\tst_entry ent;\n\n\t\tent.type = ST_FIELD;\n\t\tent.varname = NULL;\n\t\tent.data = NULL;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tst_entry *recordset;\n\t\t\t\tzval **field;\n\n\t\t\t\tif (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i], strlen(atts[i])+1, (void**)&field) == SUCCESS) {\n\t\t\t\t\tent.data = *field;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_DATETIME)) {\n\t\tent.type = ST_DATETIME;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_pop_element\n */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_process_data\n */\nstatic void php_wddx_process_data(void *user_data, const XML_Char *s, int len)\n{\n\tst_entry *ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\tTSRMLS_FETCH();\n\n\tif (!wddx_stack_is_empty(stack) && !stack->done) {\n\t\twddx_stack_top(stack, (void**)&ent);\n\t\tswitch (ent->type) {\n\t\t\tcase ST_STRING:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BINARY:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len + 1);\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t}\n\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase ST_NUMBER:\n\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\tconvert_scalar_to_number(ent->data TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BOOLEAN:\n\t\t\t\tif (!strcmp(s, \"true\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 1;\n\t\t\t\t} else if (!strcmp(s, \"false\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 0;\n\t\t\t\t} else {\n\t\t\t\t\tzval_ptr_dtor(&ent->data);\n\t\t\t\t\tif (ent->varname) {\n\t\t\t\t\t\tefree(ent->varname);\n\t\t\t\t\t}\n\t\t\t\t\tent->data = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_DATETIME: {\n\t\t\t\tchar *tmp;\n\n\t\t\t\ttmp = emalloc(len + 1);\n\t\t\t\tmemcpy(tmp, s, len);\n\t\t\t\ttmp[len] = '\\0';\n\n\t\t\t\tZ_LVAL_P(ent->data) = php_parse_date(tmp, NULL);\n\t\t\t\t/* date out of range < 1969 or > 2038 */\n\t\t\t\tif (Z_LVAL_P(ent->data) == -1) {\n\t\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t}\n\t\t\t\tefree(tmp);\n\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_deserialize_ex\n */\nint php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)\n{\n\twddx_stack stack;\n\tXML_Parser parser;\n\tst_entry *ent;\n\tint retval;\n\n\twddx_stack_init(&stack);\n\tparser = XML_ParserCreate(\"UTF-8\");\n\n\tXML_SetUserData(parser, &stack);\n\tXML_SetElementHandler(parser, php_wddx_push_element, php_wddx_pop_element);\n\tXML_SetCharacterDataHandler(parser, php_wddx_process_data);\n\n\tXML_Parse(parser, value, vallen, 1);\n\n\tXML_ParserFree(parser);\n\n\tif (stack.top == 1) {\n\t\twddx_stack_top(&stack, (void**)&ent);\n\t\t*return_value = *(ent->data);\n\t\tzval_copy_ctor(return_value);\n\t\tretval = SUCCESS;\n\t} else {\n\t\tretval = FAILURE;\n\t}\n\n\twddx_stack_destroy(&stack);\n\n\treturn retval;\n}\n/* }}} */\n\n/* {{{ proto string wddx_serialize_value(mixed var [, string comment])\n   Creates a new packet and serializes the given value */\nPHP_FUNCTION(wddx_serialize_value)\n{\n\tzval *var;\n\tchar *comment = NULL;\n\tint comment_len = 0;\n\twddx_packet *packet;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|s\", &var, &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, comment, comment_len);\n\tphp_wddx_serialize_var(packet, var, NULL, 0 TSRMLS_CC);\n\tphp_wddx_packet_end(packet);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ proto string wddx_serialize_vars(mixed var_name [, mixed ...])\n   Creates a new packet and serializes given variables into a struct */\nPHP_FUNCTION(wddx_serialize_vars)\n{\n\tint num_args, i;\n\twddx_packet *packet;\n\tzval ***args = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"+\", &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, NULL, 0);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, *args[i]);\n\t}\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\tphp_wddx_packet_end(packet);\n\n\tefree(args);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ php_wddx_constructor\n */\nwddx_packet *php_wddx_constructor(void)\n{\n\tsmart_str *packet;\n\n\tpacket = (smart_str *)emalloc(sizeof(smart_str));\n\tpacket->c = NULL;\n\n\treturn packet;\n}\n/* }}} */\n\n/* {{{ php_wddx_destructor\n */\nvoid php_wddx_destructor(wddx_packet *packet)\n{\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ proto resource wddx_packet_start([string comment])\n   Starts a WDDX packet with optional comment and returns the packet id */\nPHP_FUNCTION(wddx_packet_start)\n{\n\tchar *comment = NULL;\n\tint comment_len = 0;\n\twddx_packet *packet;\n\n\tcomment = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, comment, comment_len);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tZEND_REGISTER_RESOURCE(return_value, packet, le_wddx);\n}\n/* }}} */\n\n/* {{{ proto string wddx_packet_end(resource packet_id)\n   Ends specified WDDX packet and returns the string containing the packet */\nPHP_FUNCTION(wddx_packet_end)\n{\n\tzval *packet_id;\n\twddx_packet *packet = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &packet_id) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(packet, wddx_packet *, &packet_id, -1, \"WDDX packet ID\", le_wddx);\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\n\tphp_wddx_packet_end(packet);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\n\tzend_list_delete(Z_LVAL_P(packet_id));\n}\n/* }}} */\n\n/* {{{ proto int wddx_add_vars(resource packet_id,  mixed var_names [, mixed ...])\n   Serializes given variables and adds them to packet given by packet_id */\nPHP_FUNCTION(wddx_add_vars)\n{\n\tint num_args, i;\n\tzval ***args = NULL;\n\tzval *packet_id;\n\twddx_packet *packet = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r+\", &packet_id, &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!ZEND_FETCH_RESOURCE_NO_RETURN(packet, wddx_packet *, &packet_id, -1, \"WDDX packet ID\", le_wddx)) {\n\t\tefree(args);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!packet) {\n\t\tefree(args);\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, (*args[i]));\n\t}\n\n\tefree(args);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto mixed wddx_deserialize(mixed packet)\n   Deserializes given packet and returns a PHP value */\nPHP_FUNCTION(wddx_deserialize)\n{\n\tzval *packet;\n\tchar *payload;\n\tint payload_len;\n\tphp_stream *stream = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &packet) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (Z_TYPE_P(packet) == IS_STRING) {\n\t\tpayload \t= Z_STRVAL_P(packet);\n\t\tpayload_len = Z_STRLEN_P(packet);\n\t} else if (Z_TYPE_P(packet) == IS_RESOURCE) {\n\t\tphp_stream_from_zval(stream, &packet);\n\t\tif (stream) {\n\t\t\tpayload_len = php_stream_copy_to_mem(stream, &payload, PHP_STREAM_COPY_ALL, 0);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Expecting parameter 1 to be a string or a stream\");\n\t\treturn;\n\t}\n\n\tif (payload_len == 0) {\n\t\treturn;\n\t}\n\n\tphp_wddx_deserialize_ex(payload, payload_len, return_value);\n\n\tif (stream) {\n\t\tpefree(payload, 0);\n\t}\n}\n```\n \n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.5.37-dev ZEND_VERSION: 2.5.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_a44c89e8af7c2410f4bfc5e097be2a5d0639a60c More .INIs : CWD : /out/php___php-src/git_repo_dir_a44c89e8af7c2410f4bfc5e097be2a5d0639a60c Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/wddx/tests/bug72340.phpt]\rFAIL Bug #72340: Double Free Courruption in wddx_deserialize [ext/wddx/tests/bug72340.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72340: Double Free Courruption in wddx_deserialize [ext/wddx/tests/bug72340.phpt] =====================================================================\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "a44c89e8af7c2410f4bfc5e097be2a5d0639a60c___wddx.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic int _gd2GetHeader(gdIOCtxPtr in, int *sx, int *sy, int *cs, int *vers, int *fmt, int *ncx, int *ncy, t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG(php_gd_error(\"Reading gd2 header info\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC(in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tid[i] = ch;\n\t}\n\tid[4] = 0;\n\n\tGD2_DBG(php_gd_error(\"Got file code: %s\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp(id, GD2_ID) != 0) {\n\t\tGD2_DBG(php_gd_error(\"Not a valid gd2 file\"));\n\t\tgoto fail1;\n\t}\n\n\t/* Version */\n\tif (gdGetWord(vers, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Version: %d\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG(php_gd_error(\"Bad version: %d\", *vers));\n\t\tgoto fail1;\n\t}\n\n\t/* Image Size */\n\tif (!gdGetWord(sx, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get x-size\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord(sy, in)) {\n\t\tGD2_DBG(php_gd_error(\"Could not get y-size\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Image is %dx%d\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord(cs, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"ChunkSize: %d\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG(php_gd_error(\"Bad chunk size: %d\", *cs));\n\t\tgoto fail1;\n\t}\n\n\t/* Data Format */\n\tif (gdGetWord(fmt, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"Format: %d\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) && (*fmt != GD2_FMT_TRUECOLOR_RAW) && (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG(php_gd_error(\"Bad data format: %d\", *fmt));\n\t\tgoto fail1;\n\t}\n\n\t/* # of chunks wide */\n\tif (gdGetWord(ncx, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks Wide\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord(ncy, in) != 1) {\n\t\tgoto fail1;\n\t}\n\tGD2_DBG(php_gd_error(\"%d Chunks vertically\", *ncy));\n\n\tif (gd2_compressed(*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG(php_gd_error(\"Reading %d chunk index entries\", nc));\n\t\tsidx = sizeof(t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tcidx = gdCalloc(sidx, 1);\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt(&cidx[i].offset, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (gdGetInt(&cidx[i].size, in) != 1) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0) {\n\t\t\t\tgdFree(cidx);\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t*chunkIdx = cidx;\n\t}\n\n\tGD2_DBG(php_gd_error(\"gd2 header complete\"));\n\n\treturn 1;\n\nfail1:\n\treturn 0;\n}\n```\n \n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.5.37-dev ZEND_VERSION: 2.5.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_7722455726bec8c53458a32851d2a87982cf0eac More .INIs : CWD : /out/php___php-src/git_repo_dir_7722455726bec8c53458a32851d2a87982cf0eac Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/gd/tests/bug72339.phpt]\rFAIL Bug #72339 Integer Overflow in _gd2GetHeader() resulting in heap overflow [ext/gd/tests/bug72339.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 1 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72339 Integer Overflow in _gd2GetHeader() resulting in heap overflow [ext/gd/tests/bug72339.phpt] =====================================================================\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "7722455726bec8c53458a32851d2a87982cf0eac___gd_gd2.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic void php_wddx_add_var(wddx_packet *packet, zval *name_var)\n{\n\tzval **val;\n\tHashTable *target_hash;\n\tTSRMLS_FETCH();\n\n\tif (Z_TYPE_P(name_var) == IS_STRING) {\n\t\tif (!EG(active_symbol_table)) {\n\t\t\tzend_rebuild_symbol_table(TSRMLS_C);\n\t\t}\n\t\tif (zend_hash_find(EG(active_symbol_table), Z_STRVAL_P(name_var),\n\t\t\t\t\t\t\tZ_STRLEN_P(name_var)+1, (void**)&val) != FAILURE) {\n\t\t\tphp_wddx_serialize_var(packet, *val, Z_STRVAL_P(name_var), Z_STRLEN_P(name_var) TSRMLS_CC);\n\t\t}\n\t} else if (Z_TYPE_P(name_var) == IS_ARRAY || Z_TYPE_P(name_var) == IS_OBJECT)\t{\n\t\tint is_array = Z_TYPE_P(name_var) == IS_ARRAY;\n\n\t\ttarget_hash = HASH_OF(name_var);\n\n\t\tif (is_array && target_hash->nApplyCount > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"recursion detected\");\n\t\t\treturn;\n\t\t}\n\n\t\tzend_hash_internal_pointer_reset(target_hash);\n\n\t\twhile(zend_hash_get_current_data(target_hash, (void**)&val) == SUCCESS) {\n\t\t\tif (is_array) {\n\t\t\t\ttarget_hash->nApplyCount++;\n\t\t\t}\n\n\t\t\tphp_wddx_add_var(packet, *val);\n\n\t\t\tif (is_array) {\n\t\t\t\ttarget_hash->nApplyCount--;\n\t\t\t}\n\t\t\tzend_hash_move_forward(target_hash);\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_push_element\n */\nstatic void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)\n{\n\tst_entry ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\n\tif (!strcmp(name, EL_PACKET)) {\n\t\tint i;\n\n\t\tif (atts) for (i=0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VERSION)) {\n\t\t\t\t/* nothing for now */\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_STRING)) {\n\t\tent.type = ST_STRING;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BINARY)) {\n\t\tent.type = ST_BINARY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_CHAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_CHAR_CODE) && atts[++i] && atts[i][0]) {\n\t\t\t\tchar tmp_buf[2];\n\n\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i], NULL, 16));\n\t\t\t\tphp_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NUMBER)) {\n\t\tent.type = ST_NUMBER;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\tZ_LVAL_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BOOLEAN)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[++i] && atts[i][0]) {\n\t\t\t\tent.type = ST_BOOLEAN;\n\t\t\t\tSET_STACK_VARNAME;\n\n\t\t\t\tALLOC_ZVAL(ent.data);\n\t\t\t\tINIT_PZVAL(ent.data);\n\t\t\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n\t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t\t\tphp_wddx_process_data(user_data, atts[i], strlen(atts[i]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NULL)) {\n\t\tent.type = ST_NULL;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZVAL_NULL(ent.data);\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_ARRAY)) {\n\t\tent.type = ST_ARRAY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_STRUCT)) {\n\t\tent.type = ST_STRUCT;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_VAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tif (stack->varname) efree(stack->varname);\n\t\t\t\tstack->varname = estrdup(atts[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_RECORDSET)) {\n\t\tint i;\n\n\t\tent.type = ST_RECORDSET;\n\t\tSET_STACK_VARNAME;\n\t\tMAKE_STD_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], \"fieldNames\") && atts[++i] && atts[i][0]) {\n\t\t\t\tzval *tmp;\n\t\t\t\tchar *key;\n\t\t\t\tchar *p1, *p2, *endp;\n\n\t\t\t\tendp = (char *)atts[i] + strlen(atts[i]);\n\t\t\t\tp1 = (char *)atts[i];\n\t\t\t\twhile ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {\n\t\t\t\t\tkey = estrndup(p1, p2 - p1);\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp);\n\t\t\t\t\tp1 = p2 + sizeof(\",\")-1;\n\t\t\t\t\tefree(key);\n\t\t\t\t}\n\n\t\t\t\tif (p1 <= endp) {\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tint i;\n\t\tst_entry ent;\n\n\t\tent.type = ST_FIELD;\n\t\tent.varname = NULL;\n\t\tent.data = NULL;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tst_entry *recordset;\n\t\t\t\tzval **field;\n\n\t\t\t\tif (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i], strlen(atts[i])+1, (void**)&field) == SUCCESS) {\n\t\t\t\t\tent.data = *field;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_DATETIME)) {\n\t\tent.type = ST_DATETIME;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_pop_element\n */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_process_data\n */\nstatic void php_wddx_process_data(void *user_data, const XML_Char *s, int len)\n{\n\tst_entry *ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\tTSRMLS_FETCH();\n\n\tif (!wddx_stack_is_empty(stack) && !stack->done) {\n\t\twddx_stack_top(stack, (void**)&ent);\n\t\tswitch (ent->type) {\n\t\t\tcase ST_STRING:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BINARY:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len + 1);\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t}\n\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase ST_NUMBER:\n\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\tconvert_scalar_to_number(ent->data TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BOOLEAN:\n\t\t\t\tif(!ent->data) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(s, \"true\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 1;\n\t\t\t\t} else if (!strcmp(s, \"false\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 0;\n\t\t\t\t} else {\n\t\t\t\t\tzval_ptr_dtor(&ent->data);\n\t\t\t\t\tif (ent->varname) {\n\t\t\t\t\t\tefree(ent->varname);\n\t\t\t\t\t\tent->varname = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tent->data = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_DATETIME: {\n\t\t\t\tchar *tmp;\n\n\t\t\t\ttmp = emalloc(len + 1);\n\t\t\t\tmemcpy(tmp, s, len);\n\t\t\t\ttmp[len] = '\\0';\n\n\t\t\t\tZ_LVAL_P(ent->data) = php_parse_date(tmp, NULL);\n\t\t\t\t/* date out of range < 1969 or > 2038 */\n\t\t\t\tif (Z_LVAL_P(ent->data) == -1) {\n\t\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t}\n\t\t\t\tefree(tmp);\n\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_deserialize_ex\n */\nint php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)\n{\n\twddx_stack stack;\n\tXML_Parser parser;\n\tst_entry *ent;\n\tint retval;\n\n\twddx_stack_init(&stack);\n\tparser = XML_ParserCreate(\"UTF-8\");\n\n\tXML_SetUserData(parser, &stack);\n\tXML_SetElementHandler(parser, php_wddx_push_element, php_wddx_pop_element);\n\tXML_SetCharacterDataHandler(parser, php_wddx_process_data);\n\n\tXML_Parse(parser, value, vallen, 1);\n\n\tXML_ParserFree(parser);\n\n\tif (stack.top == 1) {\n\t\twddx_stack_top(&stack, (void**)&ent);\n\t\t*return_value = *(ent->data);\n\t\tzval_copy_ctor(return_value);\n\t\tretval = SUCCESS;\n\t} else {\n\t\tretval = FAILURE;\n\t}\n\n\twddx_stack_destroy(&stack);\n\n\treturn retval;\n}\n/* }}} */\n\n/* {{{ proto string wddx_serialize_value(mixed var [, string comment])\n   Creates a new packet and serializes the given value */\nPHP_FUNCTION(wddx_serialize_value)\n{\n\tzval *var;\n\tchar *comment = NULL;\n\tint comment_len = 0;\n\twddx_packet *packet;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|s\", &var, &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, comment, comment_len);\n\tphp_wddx_serialize_var(packet, var, NULL, 0 TSRMLS_CC);\n\tphp_wddx_packet_end(packet);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ proto string wddx_serialize_vars(mixed var_name [, mixed ...])\n   Creates a new packet and serializes given variables into a struct */\nPHP_FUNCTION(wddx_serialize_vars)\n{\n\tint num_args, i;\n\twddx_packet *packet;\n\tzval ***args = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"+\", &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, NULL, 0);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, *args[i]);\n\t}\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\tphp_wddx_packet_end(packet);\n\n\tefree(args);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ php_wddx_constructor\n */\nwddx_packet *php_wddx_constructor(void)\n{\n\tsmart_str *packet;\n\n\tpacket = (smart_str *)emalloc(sizeof(smart_str));\n\tpacket->c = NULL;\n\n\treturn packet;\n}\n/* }}} */\n\n/* {{{ php_wddx_destructor\n */\nvoid php_wddx_destructor(wddx_packet *packet)\n{\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ proto resource wddx_packet_start([string comment])\n   Starts a WDDX packet with optional comment and returns the packet id */\nPHP_FUNCTION(wddx_packet_start)\n{\n\tchar *comment = NULL;\n\tint comment_len = 0;\n\twddx_packet *packet;\n\n\tcomment = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, comment, comment_len);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tZEND_REGISTER_RESOURCE(return_value, packet, le_wddx);\n}\n/* }}} */\n\n/* {{{ proto string wddx_packet_end(resource packet_id)\n   Ends specified WDDX packet and returns the string containing the packet */\nPHP_FUNCTION(wddx_packet_end)\n{\n\tzval *packet_id;\n\twddx_packet *packet = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &packet_id) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(packet, wddx_packet *, &packet_id, -1, \"WDDX packet ID\", le_wddx);\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\n\tphp_wddx_packet_end(packet);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\n\tzend_list_delete(Z_LVAL_P(packet_id));\n}\n/* }}} */\n\n/* {{{ proto int wddx_add_vars(resource packet_id,  mixed var_names [, mixed ...])\n   Serializes given variables and adds them to packet given by packet_id */\nPHP_FUNCTION(wddx_add_vars)\n{\n\tint num_args, i;\n\tzval ***args = NULL;\n\tzval *packet_id;\n\twddx_packet *packet = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r+\", &packet_id, &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!ZEND_FETCH_RESOURCE_NO_RETURN(packet, wddx_packet *, &packet_id, -1, \"WDDX packet ID\", le_wddx)) {\n\t\tefree(args);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!packet) {\n\t\tefree(args);\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, (*args[i]));\n\t}\n\n\tefree(args);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto mixed wddx_deserialize(mixed packet)\n   Deserializes given packet and returns a PHP value */\nPHP_FUNCTION(wddx_deserialize)\n{\n\tzval *packet;\n\tchar *payload;\n\tint payload_len;\n\tphp_stream *stream = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &packet) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (Z_TYPE_P(packet) == IS_STRING) {\n\t\tpayload \t= Z_STRVAL_P(packet);\n\t\tpayload_len = Z_STRLEN_P(packet);\n\t} else if (Z_TYPE_P(packet) == IS_RESOURCE) {\n\t\tphp_stream_from_zval(stream, &packet);\n\t\tif (stream) {\n\t\t\tpayload_len = php_stream_copy_to_mem(stream, &payload, PHP_STREAM_COPY_ALL, 0);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Expecting parameter 1 to be a string or a stream\");\n\t\treturn;\n\t}\n\n\tif (payload_len == 0) {\n\t\treturn;\n\t}\n\n\tphp_wddx_deserialize_ex(payload, payload_len, return_value);\n\n\tif (stream) {\n\t\tpefree(payload, 0);\n\t}\n}\n```\n \n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.26-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_426aeb2808955ee3d3f52e0cfb102834cdb836a5 More .INIs : CWD : /out/php___php-src/git_repo_dir_426aeb2808955ee3d3f52e0cfb102834cdb836a5 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/wddx/tests/bug72749.phpt]\rFAIL Bug #72749: wddx_deserialize allows illegal memory access [ext/wddx/tests/bug72749.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72749: wddx_deserialize allows illegal memory access [ext/wddx/tests/bug72749.phpt] =====================================================================\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "426aeb2808955ee3d3f52e0cfb102834cdb836a5___wddx.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nPHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tzend_long ncolors;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tif ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), \"Image\", le_gd)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Number of colors has to be greater than zero\");\n\t\tRETURN_FALSE;\n\t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n\n\tRETURN_TRUE;\n}\n```\n \n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 7.0.11-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_28022c9b1fd937436ab67bb3d61f652c108baf96 More .INIs : CWD : /out/php___php-src/git_repo_dir_28022c9b1fd937436ab67bb3d61f652c108baf96 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. FAIL Bug #72697: select_colors write out-of-bounds [ext/gd/tests/bug72697.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72697: select_colors write out-of-bounds [ext/gd/tests/bug72697.phpt] =====================================================================\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "28022c9b1fd937436ab67bb3d61f652c108baf96___gd.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nPHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n\tconst unsigned char *p;\n\tphp_unserialize_data_t var_hash;\n\tzval *options = NULL, *classes = NULL;\n\tHashTable *class_hash = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t}\n\t}\n\n\tif (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\tif (class_hash) {\n\t\t\tzend_hash_destroy(class_hash);\n\t\t\tFREE_HASHTABLE(class_hash);\n\t\t}\n\t\tzval_ptr_dtor(return_value);\n\t\tif (!EG(exception)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",\n\t\t\t\t(zend_long)((char*)p - buf), buf_len);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\t/* We should keep an reference to return_value to prevent it from being dtor\n\t   in case nesting calls to unserialize */\n\tvar_push_dtor(&var_hash, return_value);\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}\n```\n \n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 7.0.14-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_b2af4e8868726a040234de113436c6e4f6372d17 More .INIs : CWD : /out/php___php-src/git_repo_dir_b2af4e8868726a040234de113436c6e4f6372d17 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. FAIL Bug #70172 - Use After Free Vulnerability in unserialize() [ext/standard/tests/serialize/bug70172_2.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #70172 - Use After Free Vulnerability in unserialize() [ext/standard/tests/serialize/bug70172_2.phpt] =====================================================================\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "b2af4e8868726a040234de113436c6e4f6372d17___var.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nint phar_open_parsed_phar(char *fname, int fname_len, char *alias, int alias_len, int is_data, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *phar;\n#ifdef PHP_WIN32\n\tchar *unixfname;\n#endif\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n#ifdef PHP_WIN32\n\tunixfname = estrndup(fname, fname_len);\n\tphar_unixify_path_separators(unixfname, fname_len);\n\n\tif (SUCCESS == phar_get_archive(&phar, unixfname, fname_len, alias, alias_len, error TSRMLS_CC)\n\t\t&& ((alias && fname_len == phar->fname_len\n\t\t&& !strncmp(unixfname, phar->fname, fname_len)) || !alias)\n\t) {\n\t\tphar_entry_info *stub;\n\t\tefree(unixfname);\n#else\n\tif (SUCCESS == phar_get_archive(&phar, fname, fname_len, alias, alias_len, error TSRMLS_CC)\n\t\t&& ((alias && fname_len == phar->fname_len\n\t\t&& !strncmp(fname, phar->fname, fname_len)) || !alias)\n\t) {\n\t\tphar_entry_info *stub;\n#endif\n\t\t/* logic above is as follows:\n\t\t   If an explicit alias was requested, ensure the filename passed in\n\t\t   matches the phar's filename.\n\t\t   If no alias was passed in, then it can match either and be valid\n\t\t */\n\n\t\tif (!is_data) {\n\t\t\t/* prevent any \".phar\" without a stub getting through */\n\t\t\tif (!phar->halt_offset && !phar->is_brandnew && (phar->is_tar || phar->is_zip)) {\n\t\t\t\tif (PHAR_G(readonly) && FAILURE == zend_hash_find(&(phar->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1, (void **)&stub)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"'%s' is not a phar archive. Use PharData::__construct() for a standard zip or tar archive\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (pphar) {\n\t\t\t*pphar = phar;\n\t\t}\n\n\t\treturn SUCCESS;\n\t} else {\n#ifdef PHP_WIN32\n\t\tefree(unixfname);\n#endif\n\t\tif (pphar) {\n\t\t\t*pphar = NULL;\n\t\t}\n\n\t\tif (phar && error && !(options & REPORT_ERRORS)) {\n\t\t\tefree(error);\n\t\t}\n\n\t\treturn FAILURE;\n\t}\n}\n/* }}}*/\n\n/**\n * Parse out metadata from the manifest for a single file\n *\n * Meta-data is in this format:\n * [len32][data...]\n *\n * data is the serialized zval\n */\nint phar_parse_metadata(char **buffer, zval **metadata, php_uint32 zip_metadata_len TSRMLS_DC) /* {{{ */\n{\n\tphp_unserialize_data_t var_hash;\n\n\tif (zip_metadata_len) {\n\t\tconst unsigned char *p;\n\t\tunsigned char *p_buff = (unsigned char *)estrndup(*buffer, zip_metadata_len);\n\t\tp = p_buff;\n\t\tALLOC_ZVAL(*metadata);\n\t\tINIT_ZVAL(**metadata);\n\t\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\t\tif (!php_var_unserialize(metadata, &p, p + zip_metadata_len, &var_hash TSRMLS_CC)) {\n\t\t\tefree(p_buff);\n\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\t\tzval_ptr_dtor(metadata);\n\t\t\t*metadata = NULL;\n\t\t\treturn FAILURE;\n\t\t}\n\t\tefree(p_buff);\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\n\t\tif (PHAR_G(persist)) {\n\t\t\t/* lazy init metadata */\n\t\t\tzval_ptr_dtor(metadata);\n\t\t\t*metadata = (zval *) pemalloc(zip_metadata_len, 1);\n\t\t\tmemcpy(*metadata, *buffer, zip_metadata_len);\n\t\t\treturn SUCCESS;\n\t\t}\n\t} else {\n\t\t*metadata = NULL;\n\t}\n\n\treturn SUCCESS;\n}\n/* }}}*/\n\n/**\n * Does not check for a previously opened phar in the cache.\n *\n * Parse a new one and add it to the cache, returning either SUCCESS or\n * FAILURE, and setting pphar to the pointer to the manifest entry\n *\n * This is used by phar_open_from_filename to process the manifest, but can be called\n * directly.\n */\nstatic int phar_parse_pharfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, long halt_offset, phar_archive_data** pphar, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar b32[4], *buffer, *endbuffer, *savebuf;\n\tphar_archive_data *mydata = NULL;\n\tphar_entry_info entry;\n\tphp_uint32 manifest_len, manifest_count, manifest_flags, manifest_index, tmp_len, sig_flags;\n\tphp_uint16 manifest_ver;\n\tphp_uint32 len;\n\tlong offset;\n\tint sig_len, register_alias = 0, temp_alias = 0;\n\tchar *signature = NULL;\n\n\tif (pphar) {\n\t\t*pphar = NULL;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\t/* check for ?>\\n and increment accordingly */\n\tif (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot seek to __HALT_COMPILER(); location in phar \\\"%s\\\"\")\n\t}\n\n\tbuffer = b32;\n\n\tif (3 != php_stream_read(fp, buffer, 3)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t}\n\n\tif ((*buffer == ' ' || *buffer == '\\n') && *(buffer + 1) == '?' && *(buffer + 2) == '>') {\n\t\tint nextchar;\n\t\thalt_offset += 3;\n\t\tif (EOF == (nextchar = php_stream_getc(fp))) {\n\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t\t}\n\n\t\tif ((char) nextchar == '\\r') {\n\t\t\t/* if we have an \\r we require an \\n as well */\n\t\t\tif (EOF == (nextchar = php_stream_getc(fp)) || (char)nextchar != '\\n') {\n\t\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t\t\t}\n\t\t\t++halt_offset;\n\t\t}\n\n\t\tif ((char) nextchar == '\\n') {\n\t\t\t++halt_offset;\n\t\t}\n\t}\n\n\t/* make sure we are at the right location to read the manifest */\n\tif (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot seek to __HALT_COMPILER(); location in phar \\\"%s\\\"\")\n\t}\n\n\t/* read in manifest */\n\tbuffer = b32;\n\n\tif (4 != php_stream_read(fp, buffer, 4)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at manifest length)\")\n\t}\n\n\tPHAR_GET_32(buffer, manifest_len);\n\n\tif (manifest_len > 1048576 * 100) {\n\t\t/* prevent serious memory issues by limiting manifest to at most 100 MB in length */\n\t\tMAPPHAR_ALLOC_FAIL(\"manifest cannot be larger than 100 MB in phar \\\"%s\\\"\")\n\t}\n\n\tbuffer = (char *)emalloc(manifest_len);\n\tsavebuf = buffer;\n\tendbuffer = buffer + manifest_len;\n\n\tif (manifest_len < 10 || manifest_len != php_stream_read(fp, buffer, manifest_len)) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest header)\")\n\t}\n\n\t/* extract the number of entries */\n\tPHAR_GET_32(buffer, manifest_count);\n\n\tif (manifest_count == 0) {\n\t\tMAPPHAR_FAIL(\"in phar \\\"%s\\\", manifest claims to have zero entries.  Phars must have at least 1 entry\");\n\t}\n\n\t/* extract API version, lowest nibble currently unused */\n\tmanifest_ver = (((unsigned char)buffer[0]) << 8)\n\t\t\t\t + ((unsigned char)buffer[1]);\n\tbuffer += 2;\n\n\tif ((manifest_ver & PHAR_API_VER_MASK) < PHAR_API_MIN_READ) {\n\t\tefree(savebuf);\n\t\tphp_stream_close(fp);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" is API version %1.u.%1.u.%1.u, and cannot be processed\", fname, manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0x0F);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tPHAR_GET_32(buffer, manifest_flags);\n\n\tmanifest_flags &= ~PHAR_HDR_COMPRESSION_MASK;\n\tmanifest_flags &= ~PHAR_FILE_COMPRESSION_MASK;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmanifest_flags |= compression;\n\n\t/* The lowest nibble contains the phar wide flags. The compression flags can */\n\t/* be ignored on reading because it is being generated anyways. */\n\tif (manifest_flags & PHAR_HDR_SIGNATURE) {\n\t\tchar sig_buf[8], *sig_ptr = sig_buf;\n\t\toff_t read_len;\n\t\tsize_t end_of_phar;\n\n\t\tif (-1 == php_stream_seek(fp, -8, SEEK_END)\n\t\t|| (read_len = php_stream_tell(fp)) < 20\n\t\t|| 8 != php_stream_read(fp, sig_buf, 8)\n\t\t|| memcmp(sig_buf+4, \"GBMB\", 4)) {\n\t\t\tefree(savebuf);\n\t\t\tphp_stream_close(fp);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tPHAR_GET_32(sig_ptr, sig_flags);\n\n\t\tswitch(sig_flags) {\n\t\t\tcase PHAR_SIG_OPENSSL: {\n\t\t\t\tphp_uint32 signature_len;\n\t\t\t\tchar *sig;\n\t\t\t\toff_t whence;\n\n\t\t\t\t/* we store the signature followed by the signature length */\n\t\t\t\tif (-1 == php_stream_seek(fp, -12, SEEK_CUR)\n\t\t\t\t|| 4 != php_stream_read(fp, sig_buf, 4)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature length could not be read\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tsig_ptr = sig_buf;\n\t\t\t\tPHAR_GET_32(sig_ptr, signature_len);\n\t\t\t\tsig = (char *) emalloc(signature_len);\n\t\t\t\twhence = signature_len + 4;\n\t\t\t\twhence = -whence;\n\n\t\t\t\tif (-1 == php_stream_seek(fp, whence, SEEK_CUR)\n\t\t\t\t|| !(end_of_phar = php_stream_tell(fp))\n\t\t\t\t|| signature_len != php_stream_read(fp, sig, signature_len)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tefree(sig);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature could not be read\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, end_of_phar, PHAR_SIG_OPENSSL, sig, signature_len, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tefree(sig);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tefree(sig);\n\t\t\t}\n\t\t\tbreak;\n#if PHAR_HASH_OK\n\t\t\tcase PHAR_SIG_SHA512: {\n\t\t\t\tunsigned char digest[64];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 64), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA512, (char *)digest, 64, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA512 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PHAR_SIG_SHA256: {\n\t\t\t\tunsigned char digest[32];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 32), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA256, (char *)digest, 32, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA256 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#else\n\t\t\tcase PHAR_SIG_SHA512:\n\t\t\tcase PHAR_SIG_SHA256:\n\t\t\t\tefree(savebuf);\n\t\t\t\tphp_stream_close(fp);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a unsupported signature\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n#endif\n\t\t\tcase PHAR_SIG_SHA1: {\n\t\t\t\tunsigned char digest[20];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 20), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA1, (char *)digest, 20, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA1 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PHAR_SIG_MD5: {\n\t\t\t\tunsigned char digest[16];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 16), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_MD5, (char *)digest, 16, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" MD5 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tefree(savebuf);\n\t\t\t\tphp_stream_close(fp);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken or unsupported signature\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t}\n\t} else if (PHAR_G(require_hash)) {\n\t\tefree(savebuf);\n\t\tphp_stream_close(fp);\n\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t} else {\n\t\tsig_flags = 0;\n\t\tsig_len = 0;\n\t}\n\n\t/* extract alias */\n\tPHAR_GET_32(buffer, tmp_len);\n\n\tif (buffer + tmp_len > endbuffer) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (buffer overrun)\");\n\t}\n\n\tif (manifest_len < 10 + tmp_len) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest header)\")\n\t}\n\n\t/* tmp_len = 0 says alias length is 0, which means the alias is not stored in the phar */\n\tif (tmp_len) {\n\t\t/* if the alias is stored we enforce it (implicit overrides explicit) */\n\t\tif (alias && alias_len && (alias_len != (int)tmp_len || strncmp(alias, buffer, tmp_len)))\n\t\t{\n\t\t\tbuffer[tmp_len] = '\\0';\n\t\t\tphp_stream_close(fp);\n\n\t\t\tif (signature) {\n\t\t\t\tefree(signature);\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"cannot load phar \\\"%s\\\" with implicit alias \\\"%s\\\" under different alias \\\"%s\\\"\", fname, buffer, alias);\n\t\t\t}\n\n\t\t\tefree(savebuf);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\talias_len = tmp_len;\n\t\talias = buffer;\n\t\tbuffer += tmp_len;\n\t\tregister_alias = 1;\n\t} else if (!alias_len || !alias) {\n\t\t/* if we neither have an explicit nor an implicit alias, we use the filename */\n\t\talias = NULL;\n\t\talias_len = 0;\n\t\tregister_alias = 0;\n\t} else if (alias_len) {\n\t\tregister_alias = 1;\n\t\ttemp_alias = 1;\n\t}\n\n\t/* we have 5 32-bit items plus 1 byte at least */\n\tif (manifest_count > ((manifest_len - 10 - tmp_len) / (5 * 4 + 1))) {\n\t\t/* prevent serious memory issues */\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (too many manifest entries for size of manifest)\")\n\t}\n\n\tmydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmydata->is_persistent = PHAR_G(persist);\n\n\t/* check whether we have meta data, zero check works regardless of byte order */\n\tPHAR_GET_32(buffer, len);\n\tif (mydata->is_persistent) {\n\t\tmydata->metadata_len = len;\n\t\tif(!len) {\n\t\t\t/* FIXME: not sure why this is needed but removing it breaks tests */\n\t\t\tPHAR_GET_32(buffer, len);\n\t\t}\n\t}\n\tif(len > endbuffer - buffer) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (trying to read past buffer end)\");\n\t}\n\tif (phar_parse_metadata(&buffer, &mydata->metadata, len TSRMLS_CC) == FAILURE) {\n\t\tMAPPHAR_FAIL(\"unable to read phar metadata in .phar file \\\"%s\\\"\");\n\t}\n\tbuffer += len;\n\n\t/* set up our manifest */\n\tzend_hash_init(&mydata->manifest, manifest_count,\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->virtual_dirs, manifest_count * 2,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tmydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(mydata->fname, fname_len);\n#endif\n\tmydata->fname_len = fname_len;\n\toffset = halt_offset + manifest_len + 4;\n\tmemset(&entry, 0, sizeof(phar_entry_info));\n\tentry.phar = mydata;\n\tentry.fp_type = PHAR_FP;\n\tentry.is_persistent = mydata->is_persistent;\n\n\tfor (manifest_index = 0; manifest_index < manifest_count; ++manifest_index) {\n\t\tif (buffer + 4 > endbuffer) {\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\")\n\t\t}\n\n\t\tPHAR_GET_32(buffer, entry.filename_len);\n\n\t\tif (entry.filename_len == 0) {\n\t\t\tMAPPHAR_FAIL(\"zero-length filename encountered in phar \\\"%s\\\"\");\n\t\t}\n\n\t\tif (entry.is_persistent) {\n\t\t\tentry.manifest_pos = manifest_index;\n\t\t}\n\n\t\tif (entry.filename_len + 20 > endbuffer - buffer) {\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\");\n\t\t}\n\n\t\tif ((manifest_ver & PHAR_API_VER_MASK) >= PHAR_API_MIN_DIR && buffer[entry.filename_len - 1] == '/') {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tphar_add_virtual_dirs(mydata, buffer, entry.filename_len TSRMLS_CC);\n\t\tentry.filename = pestrndup(buffer, entry.filename_len, entry.is_persistent);\n\t\tbuffer += entry.filename_len;\n\t\tPHAR_GET_32(buffer, entry.uncompressed_filesize);\n\t\tPHAR_GET_32(buffer, entry.timestamp);\n\n\t\tif (offset == halt_offset + (int)manifest_len + 4) {\n\t\t\tmydata->min_timestamp = entry.timestamp;\n\t\t\tmydata->max_timestamp = entry.timestamp;\n\t\t} else {\n\t\t\tif (mydata->min_timestamp > entry.timestamp) {\n\t\t\t\tmydata->min_timestamp = entry.timestamp;\n\t\t\t} else if (mydata->max_timestamp < entry.timestamp) {\n\t\t\t\tmydata->max_timestamp = entry.timestamp;\n\t\t\t}\n\t\t}\n\n\t\tPHAR_GET_32(buffer, entry.compressed_filesize);\n\t\tPHAR_GET_32(buffer, entry.crc32);\n\t\tPHAR_GET_32(buffer, entry.flags);\n\n\t\tif (entry.is_dir) {\n\t\t\tentry.filename_len--;\n\t\t\tentry.flags |= PHAR_ENT_PERM_DEF_DIR;\n\t\t}\n\n\t\tPHAR_GET_32(buffer, len);\n\t\tif (entry.is_persistent) {\n\t\t\tentry.metadata_len = len;\n\t\t} else {\n\t\t\tentry.metadata_len = 0;\n\t\t}\n\t\tif (len > endbuffer - buffer) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\");\n\t\t}\n\t\tif (phar_parse_metadata(&buffer, &entry.metadata, len TSRMLS_CC) == FAILURE) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tMAPPHAR_FAIL(\"unable to read file metadata in .phar file \\\"%s\\\"\");\n\t\t}\n\t\tbuffer += len;\n\n\t\tentry.offset = entry.offset_abs = offset;\n\t\toffset += entry.compressed_filesize;\n\n\t\tswitch (entry.flags & PHAR_ENT_COMPRESSION_MASK) {\n\t\t\tcase PHAR_ENT_COMPRESSED_GZ:\n\t\t\t\tif (!PHAR_G(has_zlib)) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"zlib extension is required for gz compressed .phar file \\\"%s\\\"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHAR_ENT_COMPRESSED_BZ2:\n\t\t\t\tif (!PHAR_G(has_bz2)) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"bz2 extension is required for bzip2 compressed .phar file \\\"%s\\\"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (entry.uncompressed_filesize != entry.compressed_filesize) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (compressed and uncompressed size does not match for uncompressed entry)\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tmanifest_flags |= (entry.flags & PHAR_ENT_COMPRESSION_MASK);\n\t\t/* if signature matched, no need to check CRC32 for each file */\n\t\tentry.is_crc_checked = (manifest_flags & PHAR_HDR_SIGNATURE ? 1 : 0);\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&mydata->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), NULL);\n\t}\n\n\tsnprintf(mydata->version, sizeof(mydata->version), \"%u.%u.%u\", manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0xF);\n\tmydata->internal_file_start = halt_offset + manifest_len + 4;\n\tmydata->halt_offset = halt_offset;\n\tmydata->flags = manifest_flags;\n\tendbuffer = strrchr(mydata->fname, '/');\n\n\tif (endbuffer) {\n\t\tmydata->ext = memchr(endbuffer, '.', (mydata->fname + fname_len) - endbuffer);\n\t\tif (mydata->ext == endbuffer) {\n\t\t\tmydata->ext = memchr(endbuffer + 1, '.', (mydata->fname + fname_len) - endbuffer - 1);\n\t\t}\n\t\tif (mydata->ext) {\n\t\t\tmydata->ext_len = (mydata->fname + mydata->fname_len) - mydata->ext;\n\t\t}\n\t}\n\n\tmydata->alias = alias ?\n\t\tpestrndup(alias, alias_len, mydata->is_persistent) :\n\t\tpestrndup(mydata->fname, fname_len, mydata->is_persistent);\n\tmydata->alias_len = alias ? alias_len : fname_len;\n\tmydata->sig_flags = sig_flags;\n\tmydata->fp = fp;\n\tmydata->sig_len = sig_len;\n\tmydata->signature = signature;\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (register_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmydata->is_temporary_alias = temp_alias;\n\n\t\tif (!phar_validate_alias(mydata->alias, mydata->alias_len)) {\n\t\t\tsignature = NULL;\n\t\t\tfp = NULL;\n\t\t\tMAPPHAR_FAIL(\"Cannot open archive \\\"%s\\\", invalid alias\");\n\t\t}\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\tsignature = NULL;\n\t\t\t\tfp = NULL;\n\t\t\t\tMAPPHAR_FAIL(\"Cannot open archive \\\"%s\\\", alias is already in use by existing archive\");\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tmydata->is_temporary_alias = 1;\n\t}\n\n\tzend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*),  NULL);\n\tefree(savebuf);\n\n\tif (pphar) {\n\t\t*pphar = mydata;\n\t}\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/**\n * Create or open a phar for writing\n */\nint phar_open_or_create_filename(char *fname, int fname_len, char *alias, int alias_len, int is_data, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tconst char *ext_str, *z;\n\tchar *my_error;\n\tint ext_len;\n\tphar_archive_data **test, *unused = NULL;\n\n\ttest = &unused;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\t/* first try to open an existing file */\n\tif (phar_detect_phar_fname_ext(fname, fname_len, &ext_str, &ext_len, !is_data, 0, 1 TSRMLS_CC) == SUCCESS) {\n\t\tgoto check_file;\n\t}\n\n\t/* next try to create a new file */\n\tif (FAILURE == phar_detect_phar_fname_ext(fname, fname_len, &ext_str, &ext_len, !is_data, 1, 1 TSRMLS_CC)) {\n\t\tif (error) {\n\t\t\tif (ext_len == -2) {\n\t\t\t\tspprintf(error, 0, \"Cannot create a phar archive from a URL like \\\"%s\\\". Phar objects can only be created from local files\", fname);\n\t\t\t} else {\n\t\t\t\tspprintf(error, 0, \"Cannot create phar '%s', file extension (or combination) not recognised or the directory does not exist\", fname);\n\t\t\t}\n\t\t}\n\t\treturn FAILURE;\n\t}\ncheck_file:\n\tif (phar_open_parsed_phar(fname, fname_len, alias, alias_len, is_data, options, test, &my_error TSRMLS_CC) == SUCCESS) {\n\t\tif (pphar) {\n\t\t\t*pphar = *test;\n\t\t}\n\n\t\tif ((*test)->is_data && !(*test)->is_tar && !(*test)->is_zip) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"Cannot open '%s' as a PharData object. Use Phar::__construct() for executable archives\", fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tif (PHAR_G(readonly) && !(*test)->is_data && ((*test)->is_tar || (*test)->is_zip)) {\n\t\t\tphar_entry_info *stub;\n\t\t\tif (FAILURE == zend_hash_find(&((*test)->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1, (void **)&stub)) {\n\t\t\t\tspprintf(error, 0, \"'%s' is not a phar archive. Use PharData::__construct() for a standard zip or tar archive\", fname);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tif (!PHAR_G(readonly) || (*test)->is_data) {\n\t\t\t(*test)->is_writeable = 1;\n\t\t}\n\t\treturn SUCCESS;\n\t} else if (my_error) {\n\t\tif (error) {\n\t\t\t*error = my_error;\n\t\t} else {\n\t\t\tefree(my_error);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (ext_len > 3 && (z = memchr(ext_str, 'z', ext_len)) && ((ext_str + ext_len) - z >= 2) && !memcmp(z + 1, \"ip\", 2)) {\n\t\t/* assume zip-based phar */\n\t\treturn phar_open_or_create_zip(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC);\n\t}\n\n\tif (ext_len > 3 && (z = memchr(ext_str, 't', ext_len)) && ((ext_str + ext_len) - z >= 2) && !memcmp(z + 1, \"ar\", 2)) {\n\t\t/* assume tar-based phar */\n\t\treturn phar_open_or_create_tar(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC);\n\t}\n\n\treturn phar_create_or_parse_filename(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC);\n}\n/* }}} */\n\nint phar_create_or_parse_filename(char *fname, int fname_len, char *alias, int alias_len, int is_data, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *mydata;\n\tphp_stream *fp;\n\tchar *actual = NULL, *p;\n\n\tif (!pphar) {\n\t\tpphar = &mydata;\n\t}\n#if PHP_API_VERSION < 20100412\n\tif (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {\n\t\treturn FAILURE;\n\t}\n#endif\n\tif (php_check_open_basedir(fname TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\t/* first open readonly so it won't be created if not present */\n\tfp = php_stream_open_wrapper(fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK|0, &actual);\n\n\tif (actual) {\n\t\tfname = actual;\n\t\tfname_len = strlen(actual);\n\t}\n\n\tif (fp) {\n\t\tif (phar_open_from_fp(fp, fname, fname_len, alias, alias_len, options, pphar, is_data, error TSRMLS_CC) == SUCCESS) {\n\t\t\tif ((*pphar)->is_data || !PHAR_G(readonly)) {\n\t\t\t\t(*pphar)->is_writeable = 1;\n\t\t\t}\n\t\t\tif (actual) {\n\t\t\t\tefree(actual);\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\t} else {\n\t\t\t/* file exists, but is either corrupt or not a phar archive */\n\t\t\tif (actual) {\n\t\t\t\tefree(actual);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (actual) {\n\t\tefree(actual);\n\t}\n\n\tif (PHAR_G(readonly) && !is_data) {\n\t\tif (options & REPORT_ERRORS) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"creating archive \\\"%s\\\" disabled by the php.ini setting phar.readonly\", fname);\n\t\t\t}\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\t/* set up our manifest */\n\tmydata = ecalloc(1, sizeof(phar_archive_data));\n\tmydata->fname = expand_filepath(fname, NULL TSRMLS_CC);\n\tfname_len = strlen(mydata->fname);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(mydata->fname, fname_len);\n#endif\n\tp = strrchr(mydata->fname, '/');\n\n\tif (p) {\n\t\tmydata->ext = memchr(p, '.', (mydata->fname + fname_len) - p);\n\t\tif (mydata->ext == p) {\n\t\t\tmydata->ext = memchr(p + 1, '.', (mydata->fname + fname_len) - p - 1);\n\t\t}\n\t\tif (mydata->ext) {\n\t\t\tmydata->ext_len = (mydata->fname + fname_len) - mydata->ext;\n\t\t}\n\t}\n\n\tif (pphar) {\n\t\t*pphar = mydata;\n\t}\n\n\tzend_hash_init(&mydata->manifest, sizeof(phar_entry_info),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, 0);\n\tzend_hash_init(&mydata->mounted_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, 0);\n\tzend_hash_init(&mydata->virtual_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tmydata->fname_len = fname_len;\n\tsnprintf(mydata->version, sizeof(mydata->version), \"%s\", PHP_PHAR_API_VERSION);\n\tmydata->is_temporary_alias = alias ? 0 : 1;\n\tmydata->internal_file_start = -1;\n\tmydata->fp = NULL;\n\tmydata->is_writeable = 1;\n\tmydata->is_brandnew = 1;\n\tphar_request_initialize(TSRMLS_C);\n\tzend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*),  NULL);\n\n\tif (is_data) {\n\t\talias = NULL;\n\t\talias_len = 0;\n\t\tmydata->is_data = 1;\n\t\t/* assume tar format, PharData can specify other */\n\t\tmydata->is_tar = 1;\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias && SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: phar \\\"%s\\\" cannot set alias \\\"%s\\\", already in use by another phar archive\", mydata->fname, alias);\n\t\t\t\t}\n\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\n\t\t\t\tif (pphar) {\n\t\t\t\t\t*pphar = NULL;\n\t\t\t\t}\n\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tmydata->alias = alias ? estrndup(alias, alias_len) : estrndup(mydata->fname, fname_len);\n\t\tmydata->alias_len = alias ? alias_len : fname_len;\n\t}\n\n\tif (alias_len && alias) {\n\t\tif (FAILURE == zend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL)) {\n\t\t\tif (options & REPORT_ERRORS) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"archive \\\"%s\\\" cannot be associated with alias \\\"%s\\\", already in use\", fname, alias);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\n\t\t\tif (pphar) {\n\t\t\t\t*pphar = NULL;\n\t\t\t}\n\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\treturn SUCCESS;\n}\n/* }}}*/\n\n/**\n * Return an already opened filename.\n *\n * Or scan a phar file for the required __HALT_COMPILER(); ?> token and verify\n * that the manifest is proper, then pass it to phar_parse_pharfile().  SUCCESS\n * or FAILURE is returned and pphar is set to a pointer to the phar's manifest\n */\nint phar_open_from_filename(char *fname, int fname_len, char *alias, int alias_len, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphp_stream *fp;\n\tchar *actual;\n\tint ret, is_data = 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (!strstr(fname, \".phar\")) {\n\t\tis_data = 1;\n\t}\n\n\tif (phar_open_parsed_phar(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC) == SUCCESS) {\n\t\treturn SUCCESS;\n\t} else if (error && *error) {\n\t\treturn FAILURE;\n\t}\n#if PHP_API_VERSION < 20100412\n\tif (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {\n\t\treturn FAILURE;\n\t}\n#endif\n\tif (php_check_open_basedir(fname TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tfp = php_stream_open_wrapper(fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK, &actual);\n\n\tif (!fp) {\n\t\tif (options & REPORT_ERRORS) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to open phar for reading \\\"%s\\\"\", fname);\n\t\t\t}\n\t\t}\n\t\tif (actual) {\n\t\t\tefree(actual);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (actual) {\n\t\tfname = actual;\n\t\tfname_len = strlen(actual);\n\t}\n\n\tret =  phar_open_from_fp(fp, fname, fname_len, alias, alias_len, options, pphar, is_data, error TSRMLS_CC);\n\n\tif (actual) {\n\t\tefree(actual);\n\t}\n\n\treturn ret;\n}\n/* }}}*/\n\nstatic inline char *phar_strnstr(const char *buf, int buf_len, const char *search, int search_len) /* {{{ */\n{\n\tconst char *c;\n\tint so_far = 0;\n\n\tif (buf_len < search_len) {\n\t\treturn NULL;\n\t}\n\n\tc = buf - 1;\n\n\tdo {\n\t\tif (!(c = memchr(c + 1, search[0], buf_len - search_len - so_far))) {\n\t\t\treturn (char *) NULL;\n\t\t}\n\n\t\tso_far = c - buf;\n\n\t\tif (so_far >= (buf_len - search_len)) {\n\t\t\treturn (char *) NULL;\n\t\t}\n\n\t\tif (!memcmp(c, search, search_len)) {\n\t\t\treturn (char *) c;\n\t\t}\n\t} while (1);\n}\n/* }}} */\n\n/**\n * Scan an open fp for the required __HALT_COMPILER(); ?> token and verify\n * that the manifest is proper, then pass it to phar_parse_pharfile().  SUCCESS\n * or FAILURE is returned and pphar is set to a pointer to the phar's manifest\n */\nstatic int phar_open_from_fp(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, int options, phar_archive_data** pphar, int is_data, char **error TSRMLS_DC) /* {{{ */\n{\n\tconst char token[] = \"__HALT_COMPILER();\";\n\tconst char zip_magic[] = \"PK\\x03\\x04\";\n\tconst char gz_magic[] = \"\\x1f\\x8b\\x08\";\n\tconst char bz_magic[] = \"BZh\";\n\tchar *pos, test = '\\0';\n\tconst int window_size = 1024;\n\tchar buffer[1024 + sizeof(token)]; /* a 1024 byte window + the size of the halt_compiler token (moving window) */\n\tconst long readsize = sizeof(buffer) - sizeof(token);\n\tconst long tokenlen = sizeof(token) - 1;\n\tlong halt_offset;\n\tsize_t got;\n\tphp_uint32 compression = PHAR_FILE_COMPRESSED_NONE;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (-1 == php_stream_rewind(fp)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot rewind phar \\\"%s\\\"\")\n\t}\n\n\tbuffer[sizeof(buffer)-1] = '\\0';\n\tmemset(buffer, 32, sizeof(token));\n\thalt_offset = 0;\n\n\t/* Maybe it's better to compile the file instead of just searching,  */\n\t/* but we only want the offset. So we want a .re scanner to find it. */\n\twhile(!php_stream_eof(fp)) {\n\t\tif ((got = php_stream_read(fp, buffer+tokenlen, readsize)) < (size_t) tokenlen) {\n\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated entry)\")\n\t\t}\n\n\t\tif (!test) {\n\t\t\ttest = '\\1';\n\t\t\tpos = buffer+tokenlen;\n\t\t\tif (!memcmp(pos, gz_magic, 3)) {\n\t\t\t\tchar err = 0;\n\t\t\t\tphp_stream_filter *filter;\n\t\t\t\tphp_stream *temp;\n\t\t\t\t/* to properly decompress, we have to tell zlib to look for a zlib or gzip header */\n\t\t\t\tzval filterparams;\n\n\t\t\t\tif (!PHAR_G(has_zlib)) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\" to temporary file, enable zlib extension in php.ini\")\n\t\t\t\t}\n\t\t\t\tarray_init(&filterparams);\n/* this is defined in zlib's zconf.h */\n#ifndef MAX_WBITS\n#define MAX_WBITS 15\n#endif\n\t\t\t\tadd_assoc_long(&filterparams, \"window\", MAX_WBITS + 32);\n\n\t\t\t\t/* entire file is gzip-compressed, uncompress to temporary file */\n\t\t\t\tif (!(temp = php_stream_fopen_tmpfile())) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to create temporary file for decompression of gzipped phar archive \\\"%s\\\"\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tfilter = php_stream_filter_create(\"zlib.inflate\", &filterparams, php_stream_is_persistent(fp) TSRMLS_CC);\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\terr = 1;\n\t\t\t\t\tadd_assoc_long(&filterparams, \"window\", MAX_WBITS);\n\t\t\t\t\tfilter = php_stream_filter_create(\"zlib.inflate\", &filterparams, php_stream_is_persistent(fp) TSRMLS_CC);\n\t\t\t\t\tzval_dtor(&filterparams);\n\n\t\t\t\t\tif (!filter) {\n\t\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\", ext/zlib is buggy in PHP versions older than 5.2.6\")\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tzval_dtor(&filterparams);\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&temp->writefilters, filter);\n\n\t\t\t\tif (SUCCESS != php_stream_copy_to_stream_ex(fp, temp, PHP_STREAM_COPY_ALL, NULL)) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\", ext/zlib is buggy in PHP versions older than 5.2.6\")\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\" to temporary file\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tfp = temp;\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tcompression = PHAR_FILE_COMPRESSED_GZ;\n\n\t\t\t\t/* now, start over */\n\t\t\t\ttest = '\\0';\n\t\t\t\tcontinue;\n\t\t\t} else if (!memcmp(pos, bz_magic, 3)) {\n\t\t\t\tphp_stream_filter *filter;\n\t\t\t\tphp_stream *temp;\n\n\t\t\t\tif (!PHAR_G(has_bz2)) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress bzipped phar archive \\\"%s\\\" to temporary file, enable bz2 extension in php.ini\")\n\t\t\t\t}\n\n\t\t\t\t/* entire file is bzip-compressed, uncompress to temporary file */\n\t\t\t\tif (!(temp = php_stream_fopen_tmpfile())) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to create temporary file for decompression of bzipped phar archive \\\"%s\\\"\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tfilter = php_stream_filter_create(\"bzip2.decompress\", NULL, php_stream_is_persistent(fp) TSRMLS_CC);\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress bzipped phar archive \\\"%s\\\", filter creation failed\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&temp->writefilters, filter);\n\n\t\t\t\tif (SUCCESS != php_stream_copy_to_stream_ex(fp, temp, PHP_STREAM_COPY_ALL, NULL)) {\n\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress bzipped phar archive \\\"%s\\\" to temporary file\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tfp = temp;\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tcompression = PHAR_FILE_COMPRESSED_BZ2;\n\n\t\t\t\t/* now, start over */\n\t\t\t\ttest = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!memcmp(pos, zip_magic, 4)) {\n\t\t\t\tphp_stream_seek(fp, 0, SEEK_END);\n\t\t\t\treturn phar_parse_zipfile(fp, fname, fname_len, alias, alias_len, pphar, error TSRMLS_CC);\n\t\t\t}\n\n\t\t\tif (got > 512) {\n\t\t\t\tif (phar_is_tar(pos, fname)) {\n\t\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\t\treturn phar_parse_tarfile(fp, fname, fname_len, alias, alias_len, pphar, is_data, compression, error TSRMLS_CC);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (got > 0 && (pos = phar_strnstr(buffer, got + sizeof(token), token, sizeof(token)-1)) != NULL) {\n\t\t\thalt_offset += (pos - buffer); /* no -tokenlen+tokenlen here */\n\t\t\treturn phar_parse_pharfile(fp, fname, fname_len, alias, alias_len, halt_offset, pphar, compression, error TSRMLS_CC);\n\t\t}\n\n\t\thalt_offset += got;\n\t\tmemmove(buffer, buffer + window_size, tokenlen); /* move the memory buffer by the size of the window */\n\t}\n\n\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (__HALT_COMPILER(); not found)\")\n}\n/* }}} */\n\n/*\n * given the location of the file extension and the start of the file path,\n * determine the end of the portion of the path (i.e. /path/to/file.ext/blah\n * grabs \"/path/to/file.ext\" as does the straight /path/to/file.ext),\n * stat it to determine if it exists.\n * if so, check to see if it is a directory and fail if so\n * if not, check to see if its dirname() exists (i.e. \"/path/to\") and is a directory\n * succeed if we are creating the file, otherwise fail.\n */\nstatic int phar_analyze_path(const char *fname, const char *ext, int ext_len, int for_create TSRMLS_DC) /* {{{ */\n{\n\tphp_stream_statbuf ssb;\n\tchar *realpath;\n\tchar *filename = estrndup(fname, (ext - fname) + ext_len);\n\n\tif ((realpath = expand_filepath(filename, NULL TSRMLS_CC))) {\n#ifdef PHP_WIN32\n\t\tphar_unixify_path_separators(realpath, strlen(realpath));\n#endif\n\t\tif (zend_hash_exists(&(PHAR_GLOBALS->phar_fname_map), realpath, strlen(realpath))) {\n\t\t\tefree(realpath);\n\t\t\tefree(filename);\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && zend_hash_exists(&cached_phars, realpath, strlen(realpath))) {\n\t\t\tefree(realpath);\n\t\t\tefree(filename);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tefree(realpath);\n\t}\n\n\tif (SUCCESS == php_stream_stat_path((char *) filename, &ssb)) {\n\n\t\tefree(filename);\n\n\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tif (for_create == 1) {\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\treturn SUCCESS;\n\t} else {\n\t\tchar *slash;\n\n\t\tif (!for_create) {\n\t\t\tefree(filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tslash = (char *) strrchr(filename, '/');\n\n\t\tif (slash) {\n\t\t\t*slash = '\\0';\n\t\t}\n\n\t\tif (SUCCESS != php_stream_stat_path((char *) filename, &ssb)) {\n\t\t\tif (!slash) {\n\t\t\t\tif (!(realpath = expand_filepath(filename, NULL TSRMLS_CC))) {\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n#ifdef PHP_WIN32\n\t\t\t\tphar_unixify_path_separators(realpath, strlen(realpath));\n#endif\n\t\t\t\tslash = strstr(realpath, filename);\n\t\t\t\tif (slash) {\n\t\t\t\t\tslash += ((ext - fname) + ext_len);\n\t\t\t\t\t*slash = '\\0';\n\t\t\t\t}\n\t\t\t\tslash = strrchr(realpath, '/');\n\n\t\t\t\tif (slash) {\n\t\t\t\t\t*slash = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tefree(realpath);\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (SUCCESS != php_stream_stat_path(realpath, &ssb)) {\n\t\t\t\t\tefree(realpath);\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tefree(realpath);\n\n\t\t\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tefree(filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tefree(filename);\n\n\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\treturn FAILURE;\n\t}\n}\n/* }}} */\n\n/* check for \".phar\" in extension */\nstatic int phar_check_str(const char *fname, const char *ext_str, int ext_len, int executable, int for_create TSRMLS_DC) /* {{{ */\n{\n\tchar test[51];\n\tconst char *pos;\n\n\tif (ext_len >= 50) {\n\t\treturn FAILURE;\n\t}\n\n\tif (executable == 1) {\n\t\t/* copy \".\" as well */\n\t\tmemcpy(test, ext_str - 1, ext_len + 1);\n\t\ttest[ext_len + 1] = '\\0';\n\t\t/* executable phars must contain \".phar\" as a valid extension (phar://.pharmy/oops is invalid) */\n\t\t/* (phar://hi/there/.phar/oops is also invalid) */\n\t\tpos = strstr(test, \".phar\");\n\n\t\tif (pos && (*(pos - 1) != '/')\n\t\t\t\t&& (pos += 5) && (*pos == '\\0' || *pos == '/' || *pos == '.')) {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create TSRMLS_CC);\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\t/* data phars need only contain a single non-\".\" to be valid */\n\tif (!executable) {\n\t\tpos = strstr(ext_str, \".phar\");\n\t\tif (!(pos && (*(pos - 1) != '/')\n\t\t\t\t\t&& (pos += 5) && (*pos == '\\0' || *pos == '/' || *pos == '.')) && *(ext_str + 1) != '.' && *(ext_str + 1) != '/' && *(ext_str + 1) != '\\0') {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create TSRMLS_CC);\n\t\t}\n\t} else {\n\t\tif (*(ext_str + 1) != '.' && *(ext_str + 1) != '/' && *(ext_str + 1) != '\\0') {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create TSRMLS_CC);\n\t\t}\n\t}\n\n\treturn FAILURE;\n}\n/* }}} */\n\n/*\n * if executable is 1, only returns SUCCESS if the extension is one of the tar/zip .phar extensions\n * if executable is 0, it returns SUCCESS only if the filename does *not* contain \".phar\" anywhere, and treats\n * the first extension as the filename extension\n *\n * if an extension is found, it sets ext_str to the location of the file extension in filename,\n * and ext_len to the length of the extension.\n * for urls like \"phar://alias/oops\" it instead sets ext_len to -1 and returns FAILURE, which tells\n * the calling function to use \"alias\" as the phar alias\n *\n * the last parameter should be set to tell the thing to assume that filename is the full path, and only to check the\n * extension rules, not to iterate.\n */\nint phar_detect_phar_fname_ext(const char *filename, int filename_len, const char **ext_str, int *ext_len, int executable, int for_create, int is_complete TSRMLS_DC) /* {{{ */\n{\n\tconst char *pos, *slash;\n\n\t*ext_str = NULL;\n\t*ext_len = 0;\n\n\tif (!filename_len || filename_len == 1) {\n\t\treturn FAILURE;\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\t/* first check for alias in first segment */\n\tpos = memchr(filename, '/', filename_len);\n\n\tif (pos && pos != filename) {\n\t\t/* check for url like http:// or phar:// */\n\t\tif (*(pos - 1) == ':' && (pos - filename) < filename_len - 1 && *(pos + 1) == '/') {\n\t\t\t*ext_len = -2;\n\t\t\t*ext_str = NULL;\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (zend_hash_exists(&(PHAR_GLOBALS->phar_alias_map), (char *) filename, pos - filename)) {\n\t\t\t*ext_str = pos;\n\t\t\t*ext_len = -1;\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && zend_hash_exists(&cached_alias, (char *) filename, pos - filename)) {\n\t\t\t*ext_str = pos;\n\t\t\t*ext_len = -1;\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (zend_hash_num_elements(&(PHAR_GLOBALS->phar_fname_map)) || PHAR_G(manifest_cached)) {\n\t\tphar_archive_data **pphar;\n\n\t\tif (is_complete) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), (char *) filename, filename_len, (void **)&pphar)) {\n\t\t\t\t*ext_str = filename + (filename_len - (*pphar)->ext_len);\nwoohoo:\n\t\t\t\t*ext_len = (*pphar)->ext_len;\n\n\t\t\t\tif (executable == 2) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\n\t\t\t\tif (executable == 1 && !(*pphar)->is_data) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\n\t\t\t\tif (!executable && (*pphar)->is_data) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, (char *) filename, filename_len, (void **)&pphar)) {\n\t\t\t\t*ext_str = filename + (filename_len - (*pphar)->ext_len);\n\t\t\t\tgoto woohoo;\n\t\t\t}\n\t\t} else {\n\t\t\tchar *str_key;\n\t\t\tuint keylen;\n\t\t\tulong unused;\n\n\t\t\tfor (zend_hash_internal_pointer_reset(&(PHAR_GLOBALS->phar_fname_map));\n\t\t\t\tHASH_KEY_NON_EXISTENT != zend_hash_get_current_key_ex(&(PHAR_GLOBALS->phar_fname_map), &str_key, &keylen, &unused, 0, NULL);\n\t\t\t\tzend_hash_move_forward(&(PHAR_GLOBALS->phar_fname_map))\n\t\t\t) {\n\t\t\t\tif (keylen > (uint) filename_len) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!memcmp(filename, str_key, keylen) && ((uint)filename_len == keylen\n\t\t\t\t\t|| filename[keylen] == '/' || filename[keylen] == '\\0')) {\n\t\t\t\t\tif (FAILURE == zend_hash_get_current_data(&(PHAR_GLOBALS->phar_fname_map), (void **) &pphar)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*ext_str = filename + (keylen - (*pphar)->ext_len);\n\t\t\t\t\tgoto woohoo;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (PHAR_G(manifest_cached)) {\n\t\t\t\tfor (zend_hash_internal_pointer_reset(&cached_phars);\n\t\t\t\t\tHASH_KEY_NON_EXISTENT != zend_hash_get_current_key_ex(&cached_phars, &str_key, &keylen, &unused, 0, NULL);\n\t\t\t\t\tzend_hash_move_forward(&cached_phars)\n\t\t\t\t) {\n\t\t\t\t\tif (keylen > (uint) filename_len) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!memcmp(filename, str_key, keylen) && ((uint)filename_len == keylen\n\t\t\t\t\t\t|| filename[keylen] == '/' || filename[keylen] == '\\0')) {\n\t\t\t\t\t\tif (FAILURE == zend_hash_get_current_data(&cached_phars, (void **) &pphar)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*ext_str = filename + (keylen - (*pphar)->ext_len);\n\t\t\t\t\t\tgoto woohoo;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpos = memchr(filename + 1, '.', filename_len);\nnext_extension:\n\tif (!pos) {\n\t\treturn FAILURE;\n\t}\n\n\twhile (pos != filename && (*(pos - 1) == '/' || *(pos - 1) == '\\0')) {\n\t\tpos = memchr(pos + 1, '.', filename_len - (pos - filename) + 1);\n\t\tif (!pos) {\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tslash = memchr(pos, '/', filename_len - (pos - filename));\n\n\tif (!slash) {\n\t\t/* this is a url like \"phar://blah.phar\" with no directory */\n\t\t*ext_str = pos;\n\t\t*ext_len = strlen(pos);\n\n\t\t/* file extension must contain \"phar\" */\n\t\tswitch (phar_check_str(filename, *ext_str, *ext_len, executable, for_create TSRMLS_CC)) {\n\t\t\tcase SUCCESS:\n\t\t\t\treturn SUCCESS;\n\t\t\tcase FAILURE:\n\t\t\t\t/* we are at the end of the string, so we fail */\n\t\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\t/* we've found an extension that ends at a directory separator */\n\t*ext_str = pos;\n\t*ext_len = slash - pos;\n\n\tswitch (phar_check_str(filename, *ext_str, *ext_len, executable, for_create TSRMLS_CC)) {\n\t\tcase SUCCESS:\n\t\t\treturn SUCCESS;\n\t\tcase FAILURE:\n\t\t\t/* look for more extensions */\n\t\t\tpos = strchr(pos + 1, '.');\n\t\t\tif (pos) {\n\t\t\t\t*ext_str = NULL;\n\t\t\t\t*ext_len = 0;\n\t\t\t}\n\t\t\tgoto next_extension;\n\t}\n\n\treturn FAILURE;\n}\n/* }}} */\n\nstatic int php_check_dots(const char *element, int n) /* {{{ */\n{\n\tfor(n--; n >= 0; --n) {\n\t\tif (element[n] != '.') {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n/* }}} */\n\n#define IS_DIRECTORY_UP(element, len) \\\n\t(len >= 2 && !php_check_dots(element, len))\n\n#define IS_DIRECTORY_CURRENT(element, len) \\\n\t(len == 1 && element[0] == '.')\n\n#define IS_BACKSLASH(c) ((c) == '/')\n\n#ifdef COMPILE_DL_PHAR\n/* stupid-ass non-extern declaration in tsrm_strtok.h breaks dumbass MS compiler */\nstatic inline int in_character_class(char ch, const char *delim) /* {{{ */\n{\n\twhile (*delim) {\n\t\tif (*delim == ch) {\n\t\t\treturn 1;\n\t\t}\n\t\t++delim;\n\t}\n\treturn 0;\n}\n/* }}} */\n\nchar *tsrm_strtok_r(char *s, const char *delim, char **last) /* {{{ */\n{\n\tchar *token;\n\n\tif (s == NULL) {\n\t\ts = *last;\n\t}\n\n\twhile (*s && in_character_class(*s, delim)) {\n\t\t++s;\n\t}\n\n\tif (!*s) {\n\t\treturn NULL;\n\t}\n\n\ttoken = s;\n\n\twhile (*s && !in_character_class(*s, delim)) {\n\t\t++s;\n\t}\n\n\tif (!*s) {\n\t\t*last = s;\n\t} else {\n\t\t*s = '\\0';\n\t\t*last = s + 1;\n\t}\n\n\treturn token;\n}\n/* }}} */\n#endif\n\n/**\n * Remove .. and . references within a phar filename\n */\nchar *phar_fix_filepath(char *path, int *new_len, int use_cwd TSRMLS_DC) /* {{{ */\n{\n\tchar *newpath;\n\tint newpath_len;\n\tchar *ptr;\n\tchar *tok;\n\tint ptr_length, path_length = *new_len;\n\n\tif (PHAR_G(cwd_len) && use_cwd && path_length > 2 && path[0] == '.' && path[1] == '/') {\n\t\tnewpath_len = PHAR_G(cwd_len);\n\t\tnewpath = emalloc(strlen(path) + newpath_len + 1);\n\t\tmemcpy(newpath, PHAR_G(cwd), newpath_len);\n\t} else {\n\t\tnewpath = emalloc(strlen(path) + 2);\n\t\tnewpath[0] = '/';\n\t\tnewpath_len = 1;\n\t}\n\n\tptr = path;\n\n\tif (*ptr == '/') {\n\t\t++ptr;\n\t}\n\n\ttok = ptr;\n\n\tdo {\n\t\tptr = memchr(ptr, '/', path_length - (ptr - path));\n\t} while (ptr && ptr - tok == 0 && *ptr == '/' && ++ptr && ++tok);\n\n\tif (!ptr && (path_length - (tok - path))) {\n\t\tswitch (path_length - (tok - path)) {\n\t\t\tcase 1:\n\t\t\t\tif (*tok == '.') {\n\t\t\t\t\tefree(path);\n\t\t\t\t\t*new_len = 1;\n\t\t\t\t\tefree(newpath);\n\t\t\t\t\treturn estrndup(\"/\", 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (tok[0] == '.' && tok[1] == '.') {\n\t\t\t\t\tefree(path);\n\t\t\t\t\t*new_len = 1;\n\t\t\t\t\tefree(newpath);\n\t\t\t\t\treturn estrndup(\"/\", 1);\n\t\t\t\t}\n\t\t}\n\t\tefree(newpath);\n\t\treturn path;\n\t}\n\n\twhile (ptr) {\n\t\tptr_length = ptr - tok;\nlast_time:\n\t\tif (IS_DIRECTORY_UP(tok, ptr_length)) {\n#define PREVIOUS newpath[newpath_len - 1]\n\n\t\t\twhile (newpath_len > 1 && !IS_BACKSLASH(PREVIOUS)) {\n\t\t\t\tnewpath_len--;\n\t\t\t}\n\n\t\t\tif (newpath[0] != '/') {\n\t\t\t\tnewpath[newpath_len] = '\\0';\n\t\t\t} else if (newpath_len > 1) {\n\t\t\t\t--newpath_len;\n\t\t\t}\n\t\t} else if (!IS_DIRECTORY_CURRENT(tok, ptr_length)) {\n\t\t\tif (newpath_len > 1) {\n\t\t\t\tnewpath[newpath_len++] = '/';\n\t\t\t\tmemcpy(newpath + newpath_len, tok, ptr_length+1);\n\t\t\t} else {\n\t\t\t\tmemcpy(newpath + newpath_len, tok, ptr_length+1);\n\t\t\t}\n\n\t\t\tnewpath_len += ptr_length;\n\t\t}\n\n\t\tif (ptr == path + path_length) {\n\t\t\tbreak;\n\t\t}\n\n\t\ttok = ++ptr;\n\n\t\tdo {\n\t\t\tptr = memchr(ptr, '/', path_length - (ptr - path));\n\t\t} while (ptr && ptr - tok == 0 && *ptr == '/' && ++ptr && ++tok);\n\n\t\tif (!ptr && (path_length - (tok - path))) {\n\t\t\tptr_length = path_length - (tok - path);\n\t\t\tptr = path + path_length;\n\t\t\tgoto last_time;\n\t\t}\n\t}\n\n\tefree(path);\n\t*new_len = newpath_len;\n\tnewpath[newpath_len] = '\\0';\n\treturn erealloc(newpath, newpath_len + 1);\n}\n/* }}} */\n\n/**\n * Process a phar stream name, ensuring we can handle any of:\n *\n * - whatever.phar\n * - whatever.phar.gz\n * - whatever.phar.bz2\n * - whatever.phar.php\n *\n * Optionally the name might start with 'phar://'\n *\n * This is used by phar_parse_url()\n */\nint phar_split_fname(const char *filename, int filename_len, char **arch, int *arch_len, char **entry, int *entry_len, int executable, int for_create TSRMLS_DC) /* {{{ */\n{\n\tconst char *ext_str;\n#ifdef PHP_WIN32\n\tchar *save;\n#endif\n\tint ext_len;\n\n\tif (CHECK_NULL_PATH(filename, filename_len)) {\n\t\treturn FAILURE;\n\t}\n\n\tif (!strncasecmp(filename, \"phar://\", 7)) {\n\t\tfilename += 7;\n\t\tfilename_len -= 7;\n\t}\n\n\text_len = 0;\n#ifdef PHP_WIN32\n\tsave = filename;\n\tfilename = estrndup(filename, filename_len);\n\tphar_unixify_path_separators(filename, filename_len);\n#endif\n\tif (phar_detect_phar_fname_ext(filename, filename_len, &ext_str, &ext_len, executable, for_create, 0 TSRMLS_CC) == FAILURE) {\n\t\tif (ext_len != -1) {\n\t\t\tif (!ext_str) {\n\t\t\t\t/* no / detected, restore arch for error message */\n#ifdef PHP_WIN32\n\t\t\t\t*arch = save;\n#else\n\t\t\t\t*arch = filename;\n#endif\n\t\t\t}\n\n#ifdef PHP_WIN32\n\t\t\tefree(filename);\n#endif\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\text_len = 0;\n\t\t/* no extension detected - instead we are dealing with an alias */\n\t}\n\n\t*arch_len = ext_str - filename + ext_len;\n\t*arch = estrndup(filename, *arch_len);\n\n\tif (ext_str[ext_len]) {\n\t\t*entry_len = filename_len - *arch_len;\n\t\t*entry = estrndup(ext_str+ext_len, *entry_len);\n#ifdef PHP_WIN32\n\t\tphar_unixify_path_separators(*entry, *entry_len);\n#endif\n\t\t*entry = phar_fix_filepath(*entry, entry_len, 0 TSRMLS_CC);\n\t} else {\n\t\t*entry_len = 1;\n\t\t*entry = estrndup(\"/\", 1);\n\t}\n\n#ifdef PHP_WIN32\n\tefree(filename);\n#endif\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/**\n * Invoked when a user calls Phar::mapPhar() from within an executing .phar\n * to set up its manifest directly\n */\nint phar_open_executed_filename(char *alias, int alias_len, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar *fname;\n\tzval *halt_constant;\n\tphp_stream *fp;\n\tint fname_len;\n\tchar *actual = NULL;\n\tint ret;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tfname = (char*)zend_get_executed_filename(TSRMLS_C);\n\tfname_len = strlen(fname);\n\n\tif (phar_open_parsed_phar(fname, fname_len, alias, alias_len, 0, REPORT_ERRORS, NULL, 0 TSRMLS_CC) == SUCCESS) {\n\t\treturn SUCCESS;\n\t}\n\n\tif (!strcmp(fname, \"[no active file]\")) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"cannot initialize a phar outside of PHP execution\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tMAKE_STD_ZVAL(halt_constant);\n\n\tif (0 == zend_get_constant(\"__COMPILER_HALT_OFFSET__\", 24, halt_constant TSRMLS_CC)) {\n\t\tFREE_ZVAL(halt_constant);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"__HALT_COMPILER(); must be declared in a phar\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tFREE_ZVAL(halt_constant);\n\n#if PHP_API_VERSION < 20100412\n\tif (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {\n\t\treturn FAILURE;\n\t}\n#endif\n\n\tif (php_check_open_basedir(fname TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tfp = php_stream_open_wrapper(fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK|REPORT_ERRORS, &actual);\n\n\tif (!fp) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to open phar for reading \\\"%s\\\"\", fname);\n\t\t}\n\t\tif (actual) {\n\t\t\tefree(actual);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (actual) {\n\t\tfname = actual;\n\t\tfname_len = strlen(actual);\n\t}\n\n\tret = phar_open_from_fp(fp, fname, fname_len, alias, alias_len, REPORT_ERRORS, NULL, 0, error TSRMLS_CC);\n\n\tif (actual) {\n\t\tefree(actual);\n\t}\n\n\treturn ret;\n}\n/* }}} */\n\n/**\n * Validate the CRC32 of a file opened from within the phar\n */\nint phar_postprocess_file(phar_entry_data *idata, php_uint32 crc32, char **error, int process_zip TSRMLS_DC) /* {{{ */\n{\n\tphp_uint32 crc = ~0;\n\tint len = idata->internal_file->uncompressed_filesize;\n\tphp_stream *fp = idata->fp;\n\tphar_entry_info *entry = idata->internal_file;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (entry->is_zip && process_zip > 0) {\n\t\t/* verify local file header */\n\t\tphar_zip_file_header local;\n\t\tphar_zip_data_desc desc;\n\n\t\tif (SUCCESS != phar_open_archive_fp(idata->phar TSRMLS_CC)) {\n\t\t\tspprintf(error, 0, \"phar error: unable to open zip-based phar archive \\\"%s\\\" to verify local file header for file \\\"%s\\\"\", idata->phar->fname, entry->filename);\n\t\t\treturn FAILURE;\n\t\t}\n\t\tphp_stream_seek(phar_get_entrypfp(idata->internal_file TSRMLS_CC), entry->header_offset, SEEK_SET);\n\n\t\tif (sizeof(local) != php_stream_read(phar_get_entrypfp(idata->internal_file TSRMLS_CC), (char *) &local, sizeof(local))) {\n\n\t\t\tspprintf(error, 0, \"phar error: internal corruption of zip-based phar \\\"%s\\\" (cannot read local file header for file \\\"%s\\\")\", idata->phar->fname, entry->filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\t/* check for data descriptor */\n\t\tif (((PHAR_ZIP_16(local.flags)) & 0x8) == 0x8) {\n\t\t\tphp_stream_seek(phar_get_entrypfp(idata->internal_file TSRMLS_CC),\n\t\t\t\t\tentry->header_offset + sizeof(local) +\n\t\t\t\t\tPHAR_ZIP_16(local.filename_len) +\n\t\t\t\t\tPHAR_ZIP_16(local.extra_len) +\n\t\t\t\t\tentry->compressed_filesize, SEEK_SET);\n\t\t\tif (sizeof(desc) != php_stream_read(phar_get_entrypfp(idata->internal_file TSRMLS_CC),\n\t\t\t\t\t\t\t    (char *) &desc, sizeof(desc))) {\n\t\t\t\tspprintf(error, 0, \"phar error: internal corruption of zip-based phar \\\"%s\\\" (cannot read local data descriptor for file \\\"%s\\\")\", idata->phar->fname, entry->filename);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tif (desc.signature[0] == 'P' && desc.signature[1] == 'K') {\n\t\t\t\tmemcpy(&(local.crc32), &(desc.crc32), 12);\n\t\t\t} else {\n\t\t\t\t/* old data descriptors have no signature */\n\t\t\t\tmemcpy(&(local.crc32), &desc, 12);\n\t\t\t}\n\t\t}\n\t\t/* verify local header */\n\t\tif (entry->filename_len != PHAR_ZIP_16(local.filename_len) || entry->crc32 != PHAR_ZIP_32(local.crc32) || entry->uncompressed_filesize != PHAR_ZIP_32(local.uncompsize) || entry->compressed_filesize != PHAR_ZIP_32(local.compsize)) {\n\t\t\tspprintf(error, 0, \"phar error: internal corruption of zip-based phar \\\"%s\\\" (local header of file \\\"%s\\\" does not match central directory)\", idata->phar->fname, entry->filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\t/* construct actual offset to file start - local extra_len can be different from central extra_len */\n\t\tentry->offset = entry->offset_abs =\n\t\t\tsizeof(local) + entry->header_offset + PHAR_ZIP_16(local.filename_len) + PHAR_ZIP_16(local.extra_len);\n\n\t\tif (idata->zero && idata->zero != entry->offset_abs) {\n\t\t\tidata->zero = entry->offset_abs;\n\t\t}\n\t}\n\n\tif (process_zip == 1) {\n\t\treturn SUCCESS;\n\t}\n\n\tphp_stream_seek(fp, idata->zero, SEEK_SET);\n\n\twhile (len--) {\n\t\tCRC32(crc, php_stream_getc(fp));\n\t}\n\n\tphp_stream_seek(fp, idata->zero, SEEK_SET);\n\n\tif (~crc == crc32) {\n\t\tentry->is_crc_checked = 1;\n\t\treturn SUCCESS;\n\t} else {\n\t\tspprintf(error, 0, \"phar error: internal corruption of phar \\\"%s\\\" (crc32 mismatch on file \\\"%s\\\")\", idata->phar->fname, entry->filename);\n\t\treturn FAILURE;\n\t}\n}\n/* }}} */\n\nstatic inline void phar_set_32(char *buffer, int var) /* {{{ */\n{\n#ifdef WORDS_BIGENDIAN\n\t*((buffer) + 3) = (unsigned char) (((var) >> 24) & 0xFF);\n\t*((buffer) + 2) = (unsigned char) (((var) >> 16) & 0xFF);\n\t*((buffer) + 1) = (unsigned char) (((var) >> 8) & 0xFF);\n\t*((buffer) + 0) = (unsigned char) ((var) & 0xFF);\n#else\n\t memcpy(buffer, &var, sizeof(var));\n#endif\n} /* }}} */\n\nstatic int phar_flush_clean_deleted_apply(void *data TSRMLS_DC) /* {{{ */\n{\n\tphar_entry_info *entry = (phar_entry_info *)data;\n\n\tif (entry->fp_refcount <= 0 && entry->is_deleted) {\n\t\treturn ZEND_HASH_APPLY_REMOVE;\n\t} else {\n\t\treturn ZEND_HASH_APPLY_KEEP;\n\t}\n}\n/* }}} */\n\n#include \"stub.h\"\n\nchar *phar_create_default_stub(const char *index_php, const char *web_index, size_t *len, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar *stub = NULL;\n\tint index_len, web_len;\n\tsize_t dummy;\n\n\tif (!len) {\n\t\tlen = &dummy;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (!index_php) {\n\t\tindex_php = \"index.php\";\n\t}\n\n\tif (!web_index) {\n\t\tweb_index = \"index.php\";\n\t}\n\n\tindex_len = strlen(index_php);\n\tweb_len = strlen(web_index);\n\n\tif (index_len > 400) {\n\t\t/* ridiculous size not allowed for index.php startup filename */\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"Illegal filename passed in for stub creation, was %d characters long, and only 400 or less is allowed\", index_len);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (web_len > 400) {\n\t\t/* ridiculous size not allowed for index.php startup filename */\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"Illegal web filename passed in for stub creation, was %d characters long, and only 400 or less is allowed\", web_len);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tphar_get_stub(index_php, web_index, len, &stub, index_len+1, web_len+1 TSRMLS_CC);\n\treturn stub;\n}\n/* }}} */\n\n/**\n * Save phar contents to disk\n *\n * user_stub contains either a string, or a resource pointer, if len is a negative length.\n * user_stub and len should be both 0 if the default or existing stub should be used\n */\nint phar_flush(phar_archive_data *phar, char *user_stub, long len, int convert, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar halt_stub[] = \"__HALT_COMPILER();\";\n\tchar *newstub, *tmp;\n\tphar_entry_info *entry, *newentry;\n\tint halt_offset, restore_alias_len, global_flags = 0, closeoldfile;\n\tchar *pos, has_dirs = 0;\n\tchar manifest[18], entry_buffer[24];\n\toff_t manifest_ftell;\n\tlong offset;\n\tsize_t wrote;\n\tphp_uint32 manifest_len, mytime, loc, new_manifest_count;\n\tphp_uint32 newcrc32;\n\tphp_stream *file, *oldfile, *newfile, *stubfile;\n\tphp_stream_filter *filter;\n\tphp_serialize_data_t metadata_hash;\n\tsmart_str main_metadata_str = {0};\n\tint free_user_stub, free_fp = 1, free_ufp = 1;\n\tint manifest_hack = 0;\n\n\tif (phar->is_persistent) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"internal error: attempt to flush cached zip-based phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\t\treturn EOF;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (!zend_hash_num_elements(&phar->manifest) && !user_stub) {\n\t\treturn EOF;\n\t}\n\n\tzend_hash_clean(&phar->virtual_dirs);\n\n\tif (phar->is_zip) {\n\t\treturn phar_zip_flush(phar, user_stub, len, convert, error TSRMLS_CC);\n\t}\n\n\tif (phar->is_tar) {\n\t\treturn phar_tar_flush(phar, user_stub, len, convert, error TSRMLS_CC);\n\t}\n\n\tif (PHAR_G(readonly)) {\n\t\treturn EOF;\n\t}\n\n\tif (phar->fp && !phar->is_brandnew) {\n\t\toldfile = phar->fp;\n\t\tcloseoldfile = 0;\n\t\tphp_stream_rewind(oldfile);\n\t} else {\n\t\toldfile = php_stream_open_wrapper(phar->fname, \"rb\", 0, NULL);\n\t\tcloseoldfile = oldfile != NULL;\n\t}\n\tnewfile = php_stream_fopen_tmpfile();\n\tif (!newfile) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to create temporary file\");\n\t\t}\n\t\tif (closeoldfile) {\n\t\t\tphp_stream_close(oldfile);\n\t\t}\n\t\treturn EOF;\n\t}\n\n\tif (user_stub) {\n\t\tif (len < 0) {\n\t\t\t/* resource passed in */\n\t\t\tif (!(php_stream_from_zval_no_verify(stubfile, (zval **)user_stub))) {\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to access resource to copy stub to new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\tif (len == -1) {\n\t\t\t\tlen = PHP_STREAM_COPY_ALL;\n\t\t\t} else {\n\t\t\t\tlen = -len;\n\t\t\t}\n\t\t\tuser_stub = 0;\n\n\t\t\tif (!(len = php_stream_copy_to_mem(stubfile, &user_stub, len, 0)) || !user_stub) {\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to read resource to copy stub to new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\tfree_user_stub = 1;\n\t\t} else {\n\t\t\tfree_user_stub = 0;\n\t\t}\n\t\ttmp = estrndup(user_stub, len);\n\t\tif ((pos = php_stristr(tmp, halt_stub, len, sizeof(halt_stub) - 1)) == NULL) {\n\t\t\tefree(tmp);\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"illegal stub for phar \\\"%s\\\"\", phar->fname);\n\t\t\t}\n\t\t\tif (free_user_stub) {\n\t\t\t\tefree(user_stub);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tpos = user_stub + (pos - tmp);\n\t\tefree(tmp);\n\t\tlen = pos - user_stub + 18;\n\t\tif ((size_t)len != php_stream_write(newfile, user_stub, len)\n\t\t||\t\t\t  5 != php_stream_write(newfile, \" ?>\\r\\n\", 5)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to create stub from string in new phar \\\"%s\\\"\", phar->fname);\n\t\t\t}\n\t\t\tif (free_user_stub) {\n\t\t\t\tefree(user_stub);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tphar->halt_offset = len + 5;\n\t\tif (free_user_stub) {\n\t\t\tefree(user_stub);\n\t\t}\n\t} else {\n\t\tsize_t written;\n\n\t\tif (!user_stub && phar->halt_offset && oldfile && !phar->is_brandnew) {\n\t\t\tphp_stream_copy_to_stream_ex(oldfile, newfile, phar->halt_offset, &written);\n\t\t\tnewstub = NULL;\n\t\t} else {\n\t\t\t/* this is either a brand new phar or a default stub overwrite */\n\t\t\tnewstub = phar_create_default_stub(NULL, NULL, &(phar->halt_offset), NULL TSRMLS_CC);\n\t\t\twritten = php_stream_write(newfile, newstub, phar->halt_offset);\n\t\t}\n\t\tif (phar->halt_offset != written) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tif (newstub) {\n\t\t\t\t\tspprintf(error, 0, \"unable to create stub in new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t} else {\n\t\t\t\t\tspprintf(error, 0, \"unable to copy stub of old phar to new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newstub) {\n\t\t\t\tefree(newstub);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tif (newstub) {\n\t\t\tefree(newstub);\n\t\t}\n\t}\n\tmanifest_ftell = php_stream_tell(newfile);\n\thalt_offset = manifest_ftell;\n\n\t/* Check whether we can get rid of some of the deleted entries which are\n\t * unused. However some might still be in use so even after this clean-up\n\t * we need to skip entries marked is_deleted. */\n\tzend_hash_apply(&phar->manifest, phar_flush_clean_deleted_apply TSRMLS_CC);\n\n\t/* compress as necessary, calculate crcs, serialize meta-data, manifest size, and file sizes */\n\tmain_metadata_str.c = 0;\n\tif (phar->metadata) {\n\t\tPHP_VAR_SERIALIZE_INIT(metadata_hash);\n\t\tphp_var_serialize(&main_metadata_str, &phar->metadata, &metadata_hash TSRMLS_CC);\n\t\tPHP_VAR_SERIALIZE_DESTROY(metadata_hash);\n\t} else {\n\t\tmain_metadata_str.len = 0;\n\t}\n\tnew_manifest_count = 0;\n\toffset = 0;\n\tfor (zend_hash_internal_pointer_reset(&phar->manifest);\n\t\tzend_hash_has_more_elements(&phar->manifest) == SUCCESS;\n\t\tzend_hash_move_forward(&phar->manifest)) {\n\t\tif (zend_hash_get_current_data(&phar->manifest, (void **)&entry) == FAILURE) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->cfp) {\n\t\t\t/* did we forget to get rid of cfp last time? */\n\t\t\tphp_stream_close(entry->cfp);\n\t\t\tentry->cfp = 0;\n\t\t}\n\t\tif (entry->is_deleted || entry->is_mounted) {\n\t\t\t/* remove this from the new phar */\n\t\t\tcontinue;\n\t\t}\n\t\tif (!entry->is_modified && entry->fp_refcount) {\n\t\t\t/* open file pointers refer to this fp, do not free the stream */\n\t\t\tswitch (entry->fp_type) {\n\t\t\t\tcase PHAR_FP:\n\t\t\t\t\tfree_fp = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PHAR_UFP:\n\t\t\t\t\tfree_ufp = 0;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* after excluding deleted files, calculate manifest size in bytes and number of entries */\n\t\t++new_manifest_count;\n\t\tphar_add_virtual_dirs(phar, entry->filename, entry->filename_len TSRMLS_CC);\n\n\t\tif (entry->is_dir) {\n\t\t\t/* we use this to calculate API version, 1.1.1 is used for phars with directories */\n\t\t\thas_dirs = 1;\n\t\t}\n\t\tif (entry->metadata) {\n\t\t\tif (entry->metadata_str.c) {\n\t\t\t\tsmart_str_free(&entry->metadata_str);\n\t\t\t}\n\t\t\tentry->metadata_str.c = 0;\n\t\t\tentry->metadata_str.len = 0;\n\t\t\tPHP_VAR_SERIALIZE_INIT(metadata_hash);\n\t\t\tphp_var_serialize(&entry->metadata_str, &entry->metadata, &metadata_hash TSRMLS_CC);\n\t\t\tPHP_VAR_SERIALIZE_DESTROY(metadata_hash);\n\t\t} else {\n\t\t\tif (entry->metadata_str.c) {\n\t\t\t\tsmart_str_free(&entry->metadata_str);\n\t\t\t}\n\t\t\tentry->metadata_str.c = 0;\n\t\t\tentry->metadata_str.len = 0;\n\t\t}\n\n\t\t/* 32 bits for filename length, length of filename, manifest + metadata, and add 1 for trailing / if a directory */\n\t\toffset += 4 + entry->filename_len + sizeof(entry_buffer) + entry->metadata_str.len + (entry->is_dir ? 1 : 0);\n\n\t\t/* compress and rehash as necessary */\n\t\tif ((oldfile && !entry->is_modified) || entry->is_dir) {\n\t\t\tif (entry->fp_type == PHAR_UFP) {\n\t\t\t\t/* reset so we can copy the compressed data over */\n\t\t\t\tentry->fp_type = PHAR_FP;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!phar_get_efp(entry, 0 TSRMLS_CC)) {\n\t\t\t/* re-open internal file pointer just-in-time */\n\t\t\tnewentry = phar_open_jit(phar, entry, error TSRMLS_CC);\n\t\t\tif (!newentry) {\n\t\t\t\t/* major problem re-opening, so we ignore this file and the error */\n\t\t\t\tefree(*error);\n\t\t\t\t*error = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tentry = newentry;\n\t\t}\n\t\tfile = phar_get_efp(entry, 0 TSRMLS_CC);\n\t\tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tnewcrc32 = ~0;\n\t\tmytime = entry->uncompressed_filesize;\n\t\tfor (loc = 0;loc < mytime; ++loc) {\n\t\t\tCRC32(newcrc32, php_stream_getc(file));\n\t\t}\n\t\tentry->crc32 = ~newcrc32;\n\t\tentry->is_crc_checked = 1;\n\t\tif (!(entry->flags & PHAR_ENT_COMPRESSION_MASK)) {\n\t\t\t/* not compressed */\n\t\t\tentry->compressed_filesize = entry->uncompressed_filesize;\n\t\t\tcontinue;\n\t\t}\n\t\tfilter = php_stream_filter_create(phar_compress_filter(entry, 0), NULL, 0 TSRMLS_CC);\n\t\tif (!filter) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (entry->flags & PHAR_ENT_COMPRESSED_GZ) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to gzip compress file \\\"%s\\\" to new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to bzip2 compress file \\\"%s\\\" to new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\t/* create new file that holds the compressed version */\n\t\t/* work around inability to specify freedom in write and strictness\n\t\tin read count */\n\t\tentry->cfp = php_stream_fopen_tmpfile();\n\t\tif (!entry->cfp) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to create temporary file\");\n\t\t\t}\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\treturn EOF;\n\t\t}\n\t\tphp_stream_flush(file);\n\t\tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 0 TSRMLS_CC)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tphp_stream_filter_append((&entry->cfp->writefilters), filter);\n\t\tif (SUCCESS != php_stream_copy_to_stream_ex(file, entry->cfp, entry->uncompressed_filesize, NULL)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to copy compressed file contents of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tphp_stream_filter_flush(filter, 1);\n\t\tphp_stream_flush(entry->cfp);\n\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\tphp_stream_seek(entry->cfp, 0, SEEK_END);\n\t\tentry->compressed_filesize = (php_uint32) php_stream_tell(entry->cfp);\n\t\t/* generate crc on compressed file */\n\t\tphp_stream_rewind(entry->cfp);\n\t\tentry->old_flags = entry->flags;\n\t\tentry->is_modified = 1;\n\t\tglobal_flags |= (entry->flags & PHAR_ENT_COMPRESSION_MASK);\n\t}\n\tglobal_flags |= PHAR_HDR_SIGNATURE;\n\n\t/* write out manifest pre-header */\n\t/*  4: manifest length\n\t *  4: manifest entry count\n\t *  2: phar version\n\t *  4: phar global flags\n\t *  4: alias length\n\t *  ?: the alias itself\n\t *  4: phar metadata length\n\t *  ?: phar metadata\n\t */\n\trestore_alias_len = phar->alias_len;\n\tif (phar->is_temporary_alias) {\n\t\tphar->alias_len = 0;\n\t}\n\n\tmanifest_len = offset + phar->alias_len + sizeof(manifest) + main_metadata_str.len;\n\tphar_set_32(manifest, manifest_len);\n\t/* Hack - see bug #65028, add padding byte to the end of the manifest */\n\tif(manifest[0] == '\\r' || manifest[0] == '\\n') {\n\t\tmanifest_len++;\n\t\tphar_set_32(manifest, manifest_len);\n\t\tmanifest_hack = 1;\n\t}\n\tphar_set_32(manifest+4, new_manifest_count);\n\tif (has_dirs) {\n\t\t*(manifest + 8) = (unsigned char) (((PHAR_API_VERSION) >> 8) & 0xFF);\n\t\t*(manifest + 9) = (unsigned char) (((PHAR_API_VERSION) & 0xF0));\n\t} else {\n\t\t*(manifest + 8) = (unsigned char) (((PHAR_API_VERSION_NODIR) >> 8) & 0xFF);\n\t\t*(manifest + 9) = (unsigned char) (((PHAR_API_VERSION_NODIR) & 0xF0));\n\t}\n\tphar_set_32(manifest+10, global_flags);\n\tphar_set_32(manifest+14, phar->alias_len);\n\n\t/* write the manifest header */\n\tif (sizeof(manifest) != php_stream_write(newfile, manifest, sizeof(manifest))\n\t|| (size_t)phar->alias_len != php_stream_write(newfile, phar->alias, phar->alias_len)) {\n\n\t\tif (closeoldfile) {\n\t\t\tphp_stream_close(oldfile);\n\t\t}\n\n\t\tphp_stream_close(newfile);\n\t\tphar->alias_len = restore_alias_len;\n\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to write manifest header of new phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\n\t\treturn EOF;\n\t}\n\n\tphar->alias_len = restore_alias_len;\n\n\tphar_set_32(manifest, main_metadata_str.len);\n\tif (4 != php_stream_write(newfile, manifest, 4) || (main_metadata_str.len\n\t&& main_metadata_str.len != php_stream_write(newfile, main_metadata_str.c, main_metadata_str.len))) {\n\t\tsmart_str_free(&main_metadata_str);\n\n\t\tif (closeoldfile) {\n\t\t\tphp_stream_close(oldfile);\n\t\t}\n\n\t\tphp_stream_close(newfile);\n\t\tphar->alias_len = restore_alias_len;\n\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to write manifest meta-data of new phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\n\t\treturn EOF;\n\t}\n\tsmart_str_free(&main_metadata_str);\n\n\t/* re-calculate the manifest location to simplify later code */\n\tmanifest_ftell = php_stream_tell(newfile);\n\n\t/* now write the manifest */\n\tfor (zend_hash_internal_pointer_reset(&phar->manifest);\n\t\tzend_hash_has_more_elements(&phar->manifest) == SUCCESS;\n\t\tzend_hash_move_forward(&phar->manifest)) {\n\n\t\tif (zend_hash_get_current_data(&phar->manifest, (void **)&entry) == FAILURE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->is_deleted || entry->is_mounted) {\n\t\t\t/* remove this from the new phar if deleted, ignore if mounted */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->is_dir) {\n\t\t\t/* add 1 for trailing slash */\n\t\t\tphar_set_32(entry_buffer, entry->filename_len + 1);\n\t\t} else {\n\t\t\tphar_set_32(entry_buffer, entry->filename_len);\n\t\t}\n\n\t\tif (4 != php_stream_write(newfile, entry_buffer, 4)\n\t\t|| entry->filename_len != php_stream_write(newfile, entry->filename, entry->filename_len)\n\t\t|| (entry->is_dir && 1 != php_stream_write(newfile, \"/\", 1))) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tif (entry->is_dir) {\n\t\t\t\t\tspprintf(error, 0, \"unable to write filename of directory \\\"%s\\\" to manifest of new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t} else {\n\t\t\t\t\tspprintf(error, 0, \"unable to write filename of file \\\"%s\\\" to manifest of new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\t/* set the manifest meta-data:\n\t\t\t4: uncompressed filesize\n\t\t\t4: creation timestamp\n\t\t\t4: compressed filesize\n\t\t\t4: crc32\n\t\t\t4: flags\n\t\t\t4: metadata-len\n\t\t\t+: metadata\n\t\t*/\n\t\tmytime = time(NULL);\n\t\tphar_set_32(entry_buffer, entry->uncompressed_filesize);\n\t\tphar_set_32(entry_buffer+4, mytime);\n\t\tphar_set_32(entry_buffer+8, entry->compressed_filesize);\n\t\tphar_set_32(entry_buffer+12, entry->crc32);\n\t\tphar_set_32(entry_buffer+16, entry->flags);\n\t\tphar_set_32(entry_buffer+20, entry->metadata_str.len);\n\n\t\tif (sizeof(entry_buffer) != php_stream_write(newfile, entry_buffer, sizeof(entry_buffer))\n\t\t|| entry->metadata_str.len != php_stream_write(newfile, entry->metadata_str.c, entry->metadata_str.len)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\n\t\t\tphp_stream_close(newfile);\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to write temporary manifest of file \\\"%s\\\" to manifest of new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\n\t\t\treturn EOF;\n\t\t}\n\t}\n\t/* Hack - see bug #65028, add padding byte to the end of the manifest */\n\tif(manifest_hack) {\n\t\tif(1 != php_stream_write(newfile, manifest, 1)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\n\t\t\tphp_stream_close(newfile);\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to write manifest padding byte\");\n\t\t\t}\n\n\t\t\treturn EOF;\n\t\t}\n\t}\n\n\t/* now copy the actual file data to the new phar */\n\toffset = php_stream_tell(newfile);\n\tfor (zend_hash_internal_pointer_reset(&phar->manifest);\n\t\tzend_hash_has_more_elements(&phar->manifest) == SUCCESS;\n\t\tzend_hash_move_forward(&phar->manifest)) {\n\n\t\tif (zend_hash_get_current_data(&phar->manifest, (void **)&entry) == FAILURE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->is_deleted || entry->is_dir || entry->is_mounted) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->cfp) {\n\t\t\tfile = entry->cfp;\n\t\t\tphp_stream_rewind(file);\n\t\t} else {\n\t\t\tfile = phar_get_efp(entry, 0 TSRMLS_CC);\n\t\t\tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 0 TSRMLS_CC)) {\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t}\n\n\t\tif (!file) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\t/* this will have changed for all files that have either changed compression or been modified */\n\t\tentry->offset = entry->offset_abs = offset;\n\t\toffset += entry->compressed_filesize;\n\t\tif (php_stream_copy_to_stream_ex(file, newfile, entry->compressed_filesize, &wrote) == FAILURE) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\n\t\t\tphp_stream_close(newfile);\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to write contents of file \\\"%s\\\" to new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\n\t\t\treturn EOF;\n\t\t}\n\n\t\tentry->is_modified = 0;\n\n\t\tif (entry->cfp) {\n\t\t\tphp_stream_close(entry->cfp);\n\t\t\tentry->cfp = NULL;\n\t\t}\n\n\t\tif (entry->fp_type == PHAR_MOD) {\n\t\t\t/* this fp is in use by a phar_entry_data returned by phar_get_entry_data, it will be closed when the phar_entry_data is phar_entry_delref'ed */\n\t\t\tif (entry->fp_refcount == 0 && entry->fp != phar->fp && entry->fp != phar->ufp) {\n\t\t\t\tphp_stream_close(entry->fp);\n\t\t\t}\n\n\t\t\tentry->fp = NULL;\n\t\t\tentry->fp_type = PHAR_FP;\n\t\t} else if (entry->fp_type == PHAR_UFP) {\n\t\t\tentry->fp_type = PHAR_FP;\n\t\t}\n\t}\n\n\t/* append signature */\n\tif (global_flags & PHAR_HDR_SIGNATURE) {\n\t\tchar sig_buf[4];\n\n\t\tphp_stream_rewind(newfile);\n\n\t\tif (phar->signature) {\n\t\t\tefree(phar->signature);\n\t\t\tphar->signature = NULL;\n\t\t}\n\n\t\tswitch(phar->sig_flags) {\n#ifndef PHAR_HASH_OK\n\t\t\tcase PHAR_SIG_SHA512:\n\t\t\tcase PHAR_SIG_SHA256:\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to write contents of file \\\"%s\\\" to new phar \\\"%s\\\" with requested hash type\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n#endif\n\t\t\tdefault: {\n\t\t\t\tchar *digest = NULL;\n\t\t\t\tint digest_len;\n\n\t\t\t\tif (FAILURE == phar_create_signature(phar, newfile, &digest, &digest_len, error TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar error: unable to write signature: %s\", save);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\tif (digest) {\n\t\t\t\t\t\tefree(digest);\n\t\t\t\t\t}\n\t\t\t\t\tif (closeoldfile) {\n\t\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(newfile);\n\t\t\t\t\treturn EOF;\n\t\t\t\t}\n\n\t\t\t\tphp_stream_write(newfile, digest, digest_len);\n\t\t\t\tefree(digest);\n\t\t\t\tif (phar->sig_flags == PHAR_SIG_OPENSSL) {\n\t\t\t\t\tphar_set_32(sig_buf, digest_len);\n\t\t\t\t\tphp_stream_write(newfile, sig_buf, 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tphar_set_32(sig_buf, phar->sig_flags);\n\t\tphp_stream_write(newfile, sig_buf, 4);\n\t\tphp_stream_write(newfile, \"GBMB\", 4);\n\t}\n\n\t/* finally, close the temp file, rename the original phar,\n\t   move the temp to the old phar, unlink the old phar, and reload it into memory\n\t*/\n\tif (phar->fp && free_fp) {\n\t\tphp_stream_close(phar->fp);\n\t}\n\n\tif (phar->ufp) {\n\t\tif (free_ufp) {\n\t\t\tphp_stream_close(phar->ufp);\n\t\t}\n\t\tphar->ufp = NULL;\n\t}\n\n\tif (closeoldfile) {\n\t\tphp_stream_close(oldfile);\n\t}\n\n\tphar->internal_file_start = halt_offset + manifest_len + 4;\n\tphar->halt_offset = halt_offset;\n\tphar->is_brandnew = 0;\n\n\tphp_stream_rewind(newfile);\n\n\tif (phar->donotflush) {\n\t\t/* deferred flush */\n\t\tphar->fp = newfile;\n\t} else {\n\t\tphar->fp = php_stream_open_wrapper(phar->fname, \"w+b\", IGNORE_URL|STREAM_MUST_SEEK|REPORT_ERRORS, NULL);\n\t\tif (!phar->fp) {\n\t\t\tphar->fp = newfile;\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"unable to open new phar \\\"%s\\\" for writing\", phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\tif (phar->flags & PHAR_FILE_COMPRESSED_GZ) {\n\t\t\t/* to properly compress, we have to tell zlib to add a zlib header */\n\t\t\tzval filterparams;\n\n\t\t\tarray_init(&filterparams);\n\t\t\tadd_assoc_long(&filterparams, \"window\", MAX_WBITS+16);\n\t\t\tfilter = php_stream_filter_create(\"zlib.deflate\", &filterparams, php_stream_is_persistent(phar->fp) TSRMLS_CC);\n\t\t\tzval_dtor(&filterparams);\n\n\t\t\tif (!filter) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"unable to compress all contents of phar \\\"%s\\\" using zlib, PHP versions older than 5.2.6 have a buggy zlib\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\n\t\t\tphp_stream_filter_append(&phar->fp->writefilters, filter);\n\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\tphp_stream_close(phar->fp);\n\t\t\t/* use the temp stream as our base */\n\t\t\tphar->fp = newfile;\n\t\t} else if (phar->flags & PHAR_FILE_COMPRESSED_BZ2) {\n\t\t\tfilter = php_stream_filter_create(\"bzip2.compress\", NULL, php_stream_is_persistent(phar->fp) TSRMLS_CC);\n\t\t\tphp_stream_filter_append(&phar->fp->writefilters, filter);\n\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\tphp_stream_close(phar->fp);\n\t\t\t/* use the temp stream as our base */\n\t\t\tphar->fp = newfile;\n\t\t} else {\n\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\t/* we could also reopen the file in \"rb\" mode but there is no need for that */\n\t\t\tphp_stream_close(newfile);\n\t\t}\n\t}\n\n\tif (-1 == php_stream_seek(phar->fp, phar->halt_offset, SEEK_SET)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to seek to __HALT_COMPILER(); in new phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\t\treturn EOF;\n\t}\n\n\treturn EOF;\n}\n/* }}} */\n\n#ifdef COMPILE_DL_PHAR\nZEND_GET_MODULE(phar)\n#endif\n\n/* {{{ phar_functions[]\n *\n * Every user visible function must have an entry in phar_functions[].\n */\nzend_function_entry phar_functions[] = {\n\tPHP_FE_END\n};\n/* }}}*/\n\nstatic size_t phar_zend_stream_reader(void *handle, char *buf, size_t len TSRMLS_DC) /* {{{ */\n{\n\treturn php_stream_read(phar_get_pharfp((phar_archive_data*)handle TSRMLS_CC), buf, len);\n}\n/* }}} */\n\nstatic size_t phar_zend_stream_fsizer(void *handle TSRMLS_DC) /* {{{ */\n{\n\treturn ((phar_archive_data*)handle)->halt_offset + 32;\n} /* }}} */\n\nzend_op_array *(*phar_orig_compile_file)(zend_file_handle *file_handle, int type TSRMLS_DC);\n#define phar_orig_zend_open zend_stream_open_function\n\nstatic char *phar_resolve_path(const char *filename, int filename_len TSRMLS_DC)\n{\n\treturn phar_find_in_include_path((char *) filename, filename_len, NULL TSRMLS_CC);\n}\n\nstatic zend_op_array *phar_compile_file(zend_file_handle *file_handle, int type TSRMLS_DC) /* {{{ */\n{\n\tzend_op_array *res;\n\tchar *name = NULL;\n\tint failed;\n\tphar_archive_data *phar;\n\n\tif (!file_handle || !file_handle->filename) {\n\t\treturn phar_orig_compile_file(file_handle, type TSRMLS_CC);\n\t}\n\tif (strstr(file_handle->filename, \".phar\") && !strstr(file_handle->filename, \"://\")) {\n\t\tif (SUCCESS == phar_open_from_filename((char*)file_handle->filename, strlen(file_handle->filename), NULL, 0, 0, &phar, NULL TSRMLS_CC)) {\n\t\t\tif (phar->is_zip || phar->is_tar) {\n\t\t\t\tzend_file_handle f = *file_handle;\n\n\t\t\t\t/* zip or tar-based phar */\n\t\t\t\tspprintf(&name, 4096, \"phar://%s/%s\", file_handle->filename, \".phar/stub.php\");\n\t\t\t\tif (SUCCESS == phar_orig_zend_open((const char *)name, file_handle TSRMLS_CC)) {\n\t\t\t\t\tefree(name);\n\t\t\t\t\tname = NULL;\n\t\t\t\t\tfile_handle->filename = f.filename;\n\t\t\t\t\tif (file_handle->opened_path) {\n\t\t\t\t\t\tefree(file_handle->opened_path);\n\t\t\t\t\t}\n\t\t\t\t\tfile_handle->opened_path = f.opened_path;\n\t\t\t\t\tfile_handle->free_filename = f.free_filename;\n\t\t\t\t} else {\n\t\t\t\t\t*file_handle = f;\n\t\t\t\t}\n\t\t\t} else if (phar->flags & PHAR_FILE_COMPRESSION_MASK) {\n\t\t\t\t/* compressed phar */\n\t\t\t\tfile_handle->type = ZEND_HANDLE_STREAM;\n\t\t\t\t/* we do our own reading directly from the phar, don't change the next line */\n\t\t\t\tfile_handle->handle.stream.handle  = phar;\n\t\t\t\tfile_handle->handle.stream.reader  = phar_zend_stream_reader;\n\t\t\t\tfile_handle->handle.stream.closer  = NULL;\n\t\t\t\tfile_handle->handle.stream.fsizer  = phar_zend_stream_fsizer;\n\t\t\t\tfile_handle->handle.stream.isatty  = 0;\n\t\t\t\tphar->is_persistent ?\n\t\t\t\t\tphp_stream_rewind(PHAR_GLOBALS->cached_fp[phar->phar_pos].fp) :\n\t\t\t\t\tphp_stream_rewind(phar->fp);\n\t\t\t\tmemset(&file_handle->handle.stream.mmap, 0, sizeof(file_handle->handle.stream.mmap));\n\t\t\t}\n\t\t}\n\t}\n\n\tzend_try {\n\t\tfailed = 0;\n\t\tCG(zend_lineno) = 0;\n\t\tres = phar_orig_compile_file(file_handle, type TSRMLS_CC);\n\t} zend_catch {\n\t\tfailed = 1;\n\t\tres = NULL;\n\t} zend_end_try();\n```\n \n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.30-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_ca46d0acbce55019b970fcd4c1e8a10edfdded93 More .INIs : CWD : /out/php___php-src/git_repo_dir_ca46d0acbce55019b970fcd4c1e8a10edfdded93 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/phar/tests/bug73764.phpt]\rFAIL Phar: PHP bug #73764: Crash while loading hostile phar archive [ext/phar/tests/bug73764.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Phar: PHP bug #73764: Crash while loading hostile phar archive [ext/phar/tests/bug73764.phpt] =====================================================================\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "ca46d0acbce55019b970fcd4c1e8a10edfdded93___phar.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nint phar_open_parsed_phar(char *fname, int fname_len, char *alias, int alias_len, int is_data, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *phar;\n#ifdef PHP_WIN32\n\tchar *unixfname;\n#endif\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n#ifdef PHP_WIN32\n\tunixfname = estrndup(fname, fname_len);\n\tphar_unixify_path_separators(unixfname, fname_len);\n\n\tif (SUCCESS == phar_get_archive(&phar, unixfname, fname_len, alias, alias_len, error TSRMLS_CC)\n\t\t&& ((alias && fname_len == phar->fname_len\n\t\t&& !strncmp(unixfname, phar->fname, fname_len)) || !alias)\n\t) {\n\t\tphar_entry_info *stub;\n\t\tefree(unixfname);\n#else\n\tif (SUCCESS == phar_get_archive(&phar, fname, fname_len, alias, alias_len, error TSRMLS_CC)\n\t\t&& ((alias && fname_len == phar->fname_len\n\t\t&& !strncmp(fname, phar->fname, fname_len)) || !alias)\n\t) {\n\t\tphar_entry_info *stub;\n#endif\n\t\t/* logic above is as follows:\n\t\t   If an explicit alias was requested, ensure the filename passed in\n\t\t   matches the phar's filename.\n\t\t   If no alias was passed in, then it can match either and be valid\n\t\t */\n\n\t\tif (!is_data) {\n\t\t\t/* prevent any \".phar\" without a stub getting through */\n\t\t\tif (!phar->halt_offset && !phar->is_brandnew && (phar->is_tar || phar->is_zip)) {\n\t\t\t\tif (PHAR_G(readonly) && FAILURE == zend_hash_find(&(phar->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1, (void **)&stub)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"'%s' is not a phar archive. Use PharData::__construct() for a standard zip or tar archive\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (pphar) {\n\t\t\t*pphar = phar;\n\t\t}\n\n\t\treturn SUCCESS;\n\t} else {\n#ifdef PHP_WIN32\n\t\tefree(unixfname);\n#endif\n\t\tif (pphar) {\n\t\t\t*pphar = NULL;\n\t\t}\n\n\t\tif (phar && error && !(options & REPORT_ERRORS)) {\n\t\t\tefree(error);\n\t\t}\n\n\t\treturn FAILURE;\n\t}\n}\n/* }}}*/\n\n/**\n * Parse out metadata from the manifest for a single file\n *\n * Meta-data is in this format:\n * [len32][data...]\n *\n * data is the serialized zval\n */\nint phar_parse_metadata(char **buffer, zval **metadata, php_uint32 zip_metadata_len TSRMLS_DC) /* {{{ */\n{\n\tphp_unserialize_data_t var_hash;\n\n\tif (zip_metadata_len) {\n\t\tconst unsigned char *p;\n\t\tunsigned char *p_buff = (unsigned char *)estrndup(*buffer, zip_metadata_len);\n\t\tp = p_buff;\n\t\tALLOC_ZVAL(*metadata);\n\t\tINIT_ZVAL(**metadata);\n\t\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\n\t\tif (!php_var_unserialize(metadata, &p, p + zip_metadata_len, &var_hash TSRMLS_CC)) {\n\t\t\tefree(p_buff);\n\t\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\t\tzval_ptr_dtor(metadata);\n\t\t\t*metadata = NULL;\n\t\t\treturn FAILURE;\n\t\t}\n\t\tefree(p_buff);\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\n\t\tif (PHAR_G(persist)) {\n\t\t\t/* lazy init metadata */\n\t\t\tzval_ptr_dtor(metadata);\n\t\t\t*metadata = (zval *) pemalloc(zip_metadata_len, 1);\n\t\t\tmemcpy(*metadata, *buffer, zip_metadata_len);\n\t\t\treturn SUCCESS;\n\t\t}\n\t} else {\n\t\t*metadata = NULL;\n\t}\n\n\treturn SUCCESS;\n}\n/* }}}*/\n\n/**\n * Does not check for a previously opened phar in the cache.\n *\n * Parse a new one and add it to the cache, returning either SUCCESS or\n * FAILURE, and setting pphar to the pointer to the manifest entry\n *\n * This is used by phar_open_from_filename to process the manifest, but can be called\n * directly.\n */\nstatic int phar_parse_pharfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, long halt_offset, phar_archive_data** pphar, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar b32[4], *buffer, *endbuffer, *savebuf;\n\tphar_archive_data *mydata = NULL;\n\tphar_entry_info entry;\n\tphp_uint32 manifest_len, manifest_count, manifest_flags, manifest_index, tmp_len, sig_flags;\n\tphp_uint16 manifest_ver;\n\tphp_uint32 len;\n\tlong offset;\n\tint sig_len, register_alias = 0, temp_alias = 0;\n\tchar *signature = NULL;\n\n\tif (pphar) {\n\t\t*pphar = NULL;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\t/* check for ?>\\n and increment accordingly */\n\tif (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot seek to __HALT_COMPILER(); location in phar \\\"%s\\\"\")\n\t}\n\n\tbuffer = b32;\n\n\tif (3 != php_stream_read(fp, buffer, 3)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t}\n\n\tif ((*buffer == ' ' || *buffer == '\\n') && *(buffer + 1) == '?' && *(buffer + 2) == '>') {\n\t\tint nextchar;\n\t\thalt_offset += 3;\n\t\tif (EOF == (nextchar = php_stream_getc(fp))) {\n\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t\t}\n\n\t\tif ((char) nextchar == '\\r') {\n\t\t\t/* if we have an \\r we require an \\n as well */\n\t\t\tif (EOF == (nextchar = php_stream_getc(fp)) || (char)nextchar != '\\n') {\n\t\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")\n\t\t\t}\n\t\t\t++halt_offset;\n\t\t}\n\n\t\tif ((char) nextchar == '\\n') {\n\t\t\t++halt_offset;\n\t\t}\n\t}\n\n\t/* make sure we are at the right location to read the manifest */\n\tif (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot seek to __HALT_COMPILER(); location in phar \\\"%s\\\"\")\n\t}\n\n\t/* read in manifest */\n\tbuffer = b32;\n\n\tif (4 != php_stream_read(fp, buffer, 4)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at manifest length)\")\n\t}\n\n\tPHAR_GET_32(buffer, manifest_len);\n\n\tif (manifest_len > 1048576 * 100) {\n\t\t/* prevent serious memory issues by limiting manifest to at most 100 MB in length */\n\t\tMAPPHAR_ALLOC_FAIL(\"manifest cannot be larger than 100 MB in phar \\\"%s\\\"\")\n\t}\n\n\tbuffer = (char *)emalloc(manifest_len);\n\tsavebuf = buffer;\n\tendbuffer = buffer + manifest_len;\n\n\tif (manifest_len < 10 || manifest_len != php_stream_read(fp, buffer, manifest_len)) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest header)\")\n\t}\n\n\t/* extract the number of entries */\n\tPHAR_GET_32(buffer, manifest_count);\n\n\tif (manifest_count == 0) {\n\t\tMAPPHAR_FAIL(\"in phar \\\"%s\\\", manifest claims to have zero entries.  Phars must have at least 1 entry\");\n\t}\n\n\t/* extract API version, lowest nibble currently unused */\n\tmanifest_ver = (((unsigned char)buffer[0]) << 8)\n\t\t\t\t + ((unsigned char)buffer[1]);\n\tbuffer += 2;\n\n\tif ((manifest_ver & PHAR_API_VER_MASK) < PHAR_API_MIN_READ) {\n\t\tefree(savebuf);\n\t\tphp_stream_close(fp);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" is API version %1.u.%1.u.%1.u, and cannot be processed\", fname, manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0x0F);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tPHAR_GET_32(buffer, manifest_flags);\n\n\tmanifest_flags &= ~PHAR_HDR_COMPRESSION_MASK;\n\tmanifest_flags &= ~PHAR_FILE_COMPRESSION_MASK;\n\t/* remember whether this entire phar was compressed with gz/bzip2 */\n\tmanifest_flags |= compression;\n\n\t/* The lowest nibble contains the phar wide flags. The compression flags can */\n\t/* be ignored on reading because it is being generated anyways. */\n\tif (manifest_flags & PHAR_HDR_SIGNATURE) {\n\t\tchar sig_buf[8], *sig_ptr = sig_buf;\n\t\toff_t read_len;\n\t\tsize_t end_of_phar;\n\n\t\tif (-1 == php_stream_seek(fp, -8, SEEK_END)\n\t\t|| (read_len = php_stream_tell(fp)) < 20\n\t\t|| 8 != php_stream_read(fp, sig_buf, 8)\n\t\t|| memcmp(sig_buf+4, \"GBMB\", 4)) {\n\t\t\tefree(savebuf);\n\t\t\tphp_stream_close(fp);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tPHAR_GET_32(sig_ptr, sig_flags);\n\n\t\tswitch(sig_flags) {\n\t\t\tcase PHAR_SIG_OPENSSL: {\n\t\t\t\tphp_uint32 signature_len;\n\t\t\t\tchar *sig;\n\t\t\t\toff_t whence;\n\n\t\t\t\t/* we store the signature followed by the signature length */\n\t\t\t\tif (-1 == php_stream_seek(fp, -12, SEEK_CUR)\n\t\t\t\t|| 4 != php_stream_read(fp, sig_buf, 4)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature length could not be read\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tsig_ptr = sig_buf;\n\t\t\t\tPHAR_GET_32(sig_ptr, signature_len);\n\t\t\t\tsig = (char *) emalloc(signature_len);\n\t\t\t\twhence = signature_len + 4;\n\t\t\t\twhence = -whence;\n\n\t\t\t\tif (-1 == php_stream_seek(fp, whence, SEEK_CUR)\n\t\t\t\t|| !(end_of_phar = php_stream_tell(fp))\n\t\t\t\t|| signature_len != php_stream_read(fp, sig, signature_len)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tefree(sig);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature could not be read\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, end_of_phar, PHAR_SIG_OPENSSL, sig, signature_len, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tefree(sig);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" openssl signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tefree(sig);\n\t\t\t}\n\t\t\tbreak;\n#if PHAR_HASH_OK\n\t\t\tcase PHAR_SIG_SHA512: {\n\t\t\t\tunsigned char digest[64];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 64), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA512, (char *)digest, 64, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA512 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PHAR_SIG_SHA256: {\n\t\t\t\tunsigned char digest[32];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 32), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA256, (char *)digest, 32, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA256 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#else\n\t\t\tcase PHAR_SIG_SHA512:\n\t\t\tcase PHAR_SIG_SHA256:\n\t\t\t\tefree(savebuf);\n\t\t\t\tphp_stream_close(fp);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a unsupported signature\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n#endif\n\t\t\tcase PHAR_SIG_SHA1: {\n\t\t\t\tunsigned char digest[20];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 20), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA1, (char *)digest, 20, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" SHA1 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PHAR_SIG_MD5: {\n\t\t\t\tunsigned char digest[16];\n\n\t\t\t\tphp_stream_seek(fp, -(8 + 16), SEEK_END);\n\t\t\t\tread_len = php_stream_tell(fp);\n\n\t\t\t\tif (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_MD5, (char *)digest, 16, fname, &signature, &sig_len, error TSRMLS_CC)) {\n\t\t\t\t\tefree(savebuf);\n\t\t\t\t\tphp_stream_close(fp);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" MD5 signature could not be verified: %s\", fname, *error);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tefree(savebuf);\n\t\t\t\tphp_stream_close(fp);\n\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" has a broken or unsupported signature\", fname);\n\t\t\t\t}\n\t\t\t\treturn FAILURE;\n\t\t}\n\t} else if (PHAR_G(require_hash)) {\n\t\tefree(savebuf);\n\t\tphp_stream_close(fp);\n\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"phar \\\"%s\\\" does not have a signature\", fname);\n\t\t}\n\t\treturn FAILURE;\n\t} else {\n\t\tsig_flags = 0;\n\t\tsig_len = 0;\n\t}\n\n\t/* extract alias */\n\tPHAR_GET_32(buffer, tmp_len);\n\n\tif (buffer + tmp_len > endbuffer) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (buffer overrun)\");\n\t}\n\n\tif (manifest_len < 10 + tmp_len) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest header)\")\n\t}\n\n\t/* tmp_len = 0 says alias length is 0, which means the alias is not stored in the phar */\n\tif (tmp_len) {\n\t\t/* if the alias is stored we enforce it (implicit overrides explicit) */\n\t\tif (alias && alias_len && (alias_len != (int)tmp_len || strncmp(alias, buffer, tmp_len)))\n\t\t{\n\t\t\tbuffer[tmp_len] = '\\0';\n\t\t\tphp_stream_close(fp);\n\n\t\t\tif (signature) {\n\t\t\t\tefree(signature);\n\t\t\t}\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"cannot load phar \\\"%s\\\" with implicit alias \\\"%s\\\" under different alias \\\"%s\\\"\", fname, buffer, alias);\n\t\t\t}\n\n\t\t\tefree(savebuf);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\talias_len = tmp_len;\n\t\talias = buffer;\n\t\tbuffer += tmp_len;\n\t\tregister_alias = 1;\n\t} else if (!alias_len || !alias) {\n\t\t/* if we neither have an explicit nor an implicit alias, we use the filename */\n\t\talias = NULL;\n\t\talias_len = 0;\n\t\tregister_alias = 0;\n\t} else if (alias_len) {\n\t\tregister_alias = 1;\n\t\ttemp_alias = 1;\n\t}\n\n\t/* we have 5 32-bit items plus 1 byte at least */\n\tif (manifest_count > ((manifest_len - 10 - tmp_len) / (5 * 4 + 1))) {\n\t\t/* prevent serious memory issues */\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (too many manifest entries for size of manifest)\")\n\t}\n\n\tmydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));\n\tmydata->is_persistent = PHAR_G(persist);\n\n\t/* check whether we have meta data, zero check works regardless of byte order */\n\tPHAR_GET_32(buffer, len);\n\tif (mydata->is_persistent) {\n\t\tmydata->metadata_len = len;\n\t\tif(!len) {\n\t\t\t/* FIXME: not sure why this is needed but removing it breaks tests */\n\t\t\tPHAR_GET_32(buffer, len);\n\t\t}\n\t}\n\tif(len > endbuffer - buffer) {\n\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (trying to read past buffer end)\");\n\t}\n\tif (phar_parse_metadata(&buffer, &mydata->metadata, len TSRMLS_CC) == FAILURE) {\n\t\tMAPPHAR_FAIL(\"unable to read phar metadata in .phar file \\\"%s\\\"\");\n\t}\n\tbuffer += len;\n\n\t/* set up our manifest */\n\tzend_hash_init(&mydata->manifest, manifest_count,\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->mounted_dirs, 5,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tzend_hash_init(&mydata->virtual_dirs, manifest_count * 2,\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tmydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(mydata->fname, fname_len);\n#endif\n\tmydata->fname_len = fname_len;\n\toffset = halt_offset + manifest_len + 4;\n\tmemset(&entry, 0, sizeof(phar_entry_info));\n\tentry.phar = mydata;\n\tentry.fp_type = PHAR_FP;\n\tentry.is_persistent = mydata->is_persistent;\n\n\tfor (manifest_index = 0; manifest_index < manifest_count; ++manifest_index) {\n\t\tif (buffer + 24 > endbuffer) {\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\")\n\t\t}\n\n\t\tPHAR_GET_32(buffer, entry.filename_len);\n\n\t\tif (entry.filename_len == 0) {\n\t\t\tMAPPHAR_FAIL(\"zero-length filename encountered in phar \\\"%s\\\"\");\n\t\t}\n\n\t\tif (entry.is_persistent) {\n\t\t\tentry.manifest_pos = manifest_index;\n\t\t}\n\n\t\tif (entry.filename_len > endbuffer - buffer - 20) {\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\");\n\t\t}\n\n\t\tif ((manifest_ver & PHAR_API_VER_MASK) >= PHAR_API_MIN_DIR && buffer[entry.filename_len - 1] == '/') {\n\t\t\tentry.is_dir = 1;\n\t\t} else {\n\t\t\tentry.is_dir = 0;\n\t\t}\n\n\t\tphar_add_virtual_dirs(mydata, buffer, entry.filename_len TSRMLS_CC);\n\t\tentry.filename = pestrndup(buffer, entry.filename_len, entry.is_persistent);\n\t\tbuffer += entry.filename_len;\n\t\tPHAR_GET_32(buffer, entry.uncompressed_filesize);\n\t\tPHAR_GET_32(buffer, entry.timestamp);\n\n\t\tif (offset == halt_offset + (int)manifest_len + 4) {\n\t\t\tmydata->min_timestamp = entry.timestamp;\n\t\t\tmydata->max_timestamp = entry.timestamp;\n\t\t} else {\n\t\t\tif (mydata->min_timestamp > entry.timestamp) {\n\t\t\t\tmydata->min_timestamp = entry.timestamp;\n\t\t\t} else if (mydata->max_timestamp < entry.timestamp) {\n\t\t\t\tmydata->max_timestamp = entry.timestamp;\n\t\t\t}\n\t\t}\n\n\t\tPHAR_GET_32(buffer, entry.compressed_filesize);\n\t\tPHAR_GET_32(buffer, entry.crc32);\n\t\tPHAR_GET_32(buffer, entry.flags);\n\n\t\tif (entry.is_dir) {\n\t\t\tentry.filename_len--;\n\t\t\tentry.flags |= PHAR_ENT_PERM_DEF_DIR;\n\t\t}\n\n\t\tPHAR_GET_32(buffer, len);\n\t\tif (entry.is_persistent) {\n\t\t\tentry.metadata_len = len;\n\t\t} else {\n\t\t\tentry.metadata_len = 0;\n\t\t}\n\t\tif (len > endbuffer - buffer) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\");\n\t\t}\n\t\tif (phar_parse_metadata(&buffer, &entry.metadata, len TSRMLS_CC) == FAILURE) {\n\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\tMAPPHAR_FAIL(\"unable to read file metadata in .phar file \\\"%s\\\"\");\n\t\t}\n\t\tbuffer += len;\n\n\t\tentry.offset = entry.offset_abs = offset;\n\t\toffset += entry.compressed_filesize;\n\n\t\tswitch (entry.flags & PHAR_ENT_COMPRESSION_MASK) {\n\t\t\tcase PHAR_ENT_COMPRESSED_GZ:\n\t\t\t\tif (!PHAR_G(has_zlib)) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"zlib extension is required for gz compressed .phar file \\\"%s\\\"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PHAR_ENT_COMPRESSED_BZ2:\n\t\t\t\tif (!PHAR_G(has_bz2)) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"bz2 extension is required for bzip2 compressed .phar file \\\"%s\\\"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (entry.uncompressed_filesize != entry.compressed_filesize) {\n\t\t\t\t\tif (entry.metadata) {\n\t\t\t\t\t\tif (entry.is_persistent) {\n\t\t\t\t\t\t\tfree(entry.metadata);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tzval_ptr_dtor(&entry.metadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpefree(entry.filename, entry.is_persistent);\n\t\t\t\t\tMAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (compressed and uncompressed size does not match for uncompressed entry)\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tmanifest_flags |= (entry.flags & PHAR_ENT_COMPRESSION_MASK);\n\t\t/* if signature matched, no need to check CRC32 for each file */\n\t\tentry.is_crc_checked = (manifest_flags & PHAR_HDR_SIGNATURE ? 1 : 0);\n\t\tphar_set_inode(&entry TSRMLS_CC);\n\t\tzend_hash_add(&mydata->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), NULL);\n\t}\n\n\tsnprintf(mydata->version, sizeof(mydata->version), \"%u.%u.%u\", manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0xF);\n\tmydata->internal_file_start = halt_offset + manifest_len + 4;\n\tmydata->halt_offset = halt_offset;\n\tmydata->flags = manifest_flags;\n\tendbuffer = strrchr(mydata->fname, '/');\n\n\tif (endbuffer) {\n\t\tmydata->ext = memchr(endbuffer, '.', (mydata->fname + fname_len) - endbuffer);\n\t\tif (mydata->ext == endbuffer) {\n\t\t\tmydata->ext = memchr(endbuffer + 1, '.', (mydata->fname + fname_len) - endbuffer - 1);\n\t\t}\n\t\tif (mydata->ext) {\n\t\t\tmydata->ext_len = (mydata->fname + mydata->fname_len) - mydata->ext;\n\t\t}\n\t}\n\n\tmydata->alias = alias ?\n\t\tpestrndup(alias, alias_len, mydata->is_persistent) :\n\t\tpestrndup(mydata->fname, fname_len, mydata->is_persistent);\n\tmydata->alias_len = alias ? alias_len : fname_len;\n\tmydata->sig_flags = sig_flags;\n\tmydata->fp = fp;\n\tmydata->sig_len = sig_len;\n\tmydata->signature = signature;\n\tphar_request_initialize(TSRMLS_C);\n\n\tif (register_alias) {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tmydata->is_temporary_alias = temp_alias;\n\n\t\tif (!phar_validate_alias(mydata->alias, mydata->alias_len)) {\n\t\t\tsignature = NULL;\n\t\t\tfp = NULL;\n\t\t\tMAPPHAR_FAIL(\"Cannot open archive \\\"%s\\\", invalid alias\");\n\t\t}\n\n\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\tsignature = NULL;\n\t\t\t\tfp = NULL;\n\t\t\t\tMAPPHAR_FAIL(\"Cannot open archive \\\"%s\\\", alias is already in use by existing archive\");\n\t\t\t}\n\t\t}\n\n\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);\n\t} else {\n\t\tmydata->is_temporary_alias = 1;\n\t}\n\n\tzend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*),  NULL);\n\tefree(savebuf);\n\n\tif (pphar) {\n\t\t*pphar = mydata;\n\t}\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/**\n * Create or open a phar for writing\n */\nint phar_open_or_create_filename(char *fname, int fname_len, char *alias, int alias_len, int is_data, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tconst char *ext_str, *z;\n\tchar *my_error;\n\tint ext_len;\n\tphar_archive_data **test, *unused = NULL;\n\n\ttest = &unused;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\t/* first try to open an existing file */\n\tif (phar_detect_phar_fname_ext(fname, fname_len, &ext_str, &ext_len, !is_data, 0, 1 TSRMLS_CC) == SUCCESS) {\n\t\tgoto check_file;\n\t}\n\n\t/* next try to create a new file */\n\tif (FAILURE == phar_detect_phar_fname_ext(fname, fname_len, &ext_str, &ext_len, !is_data, 1, 1 TSRMLS_CC)) {\n\t\tif (error) {\n\t\t\tif (ext_len == -2) {\n\t\t\t\tspprintf(error, 0, \"Cannot create a phar archive from a URL like \\\"%s\\\". Phar objects can only be created from local files\", fname);\n\t\t\t} else {\n\t\t\t\tspprintf(error, 0, \"Cannot create phar '%s', file extension (or combination) not recognised or the directory does not exist\", fname);\n\t\t\t}\n\t\t}\n\t\treturn FAILURE;\n\t}\ncheck_file:\n\tif (phar_open_parsed_phar(fname, fname_len, alias, alias_len, is_data, options, test, &my_error TSRMLS_CC) == SUCCESS) {\n\t\tif (pphar) {\n\t\t\t*pphar = *test;\n\t\t}\n\n\t\tif ((*test)->is_data && !(*test)->is_tar && !(*test)->is_zip) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"Cannot open '%s' as a PharData object. Use Phar::__construct() for executable archives\", fname);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tif (PHAR_G(readonly) && !(*test)->is_data && ((*test)->is_tar || (*test)->is_zip)) {\n\t\t\tphar_entry_info *stub;\n\t\t\tif (FAILURE == zend_hash_find(&((*test)->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1, (void **)&stub)) {\n\t\t\t\tspprintf(error, 0, \"'%s' is not a phar archive. Use PharData::__construct() for a standard zip or tar archive\", fname);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tif (!PHAR_G(readonly) || (*test)->is_data) {\n\t\t\t(*test)->is_writeable = 1;\n\t\t}\n\t\treturn SUCCESS;\n\t} else if (my_error) {\n\t\tif (error) {\n\t\t\t*error = my_error;\n\t\t} else {\n\t\t\tefree(my_error);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (ext_len > 3 && (z = memchr(ext_str, 'z', ext_len)) && ((ext_str + ext_len) - z >= 2) && !memcmp(z + 1, \"ip\", 2)) {\n\t\t/* assume zip-based phar */\n\t\treturn phar_open_or_create_zip(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC);\n\t}\n\n\tif (ext_len > 3 && (z = memchr(ext_str, 't', ext_len)) && ((ext_str + ext_len) - z >= 2) && !memcmp(z + 1, \"ar\", 2)) {\n\t\t/* assume tar-based phar */\n\t\treturn phar_open_or_create_tar(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC);\n\t}\n\n\treturn phar_create_or_parse_filename(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC);\n}\n/* }}} */\n\nint phar_create_or_parse_filename(char *fname, int fname_len, char *alias, int alias_len, int is_data, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphar_archive_data *mydata;\n\tphp_stream *fp;\n\tchar *actual = NULL, *p;\n\n\tif (!pphar) {\n\t\tpphar = &mydata;\n\t}\n#if PHP_API_VERSION < 20100412\n\tif (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {\n\t\treturn FAILURE;\n\t}\n#endif\n\tif (php_check_open_basedir(fname TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\t/* first open readonly so it won't be created if not present */\n\tfp = php_stream_open_wrapper(fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK|0, &actual);\n\n\tif (actual) {\n\t\tfname = actual;\n\t\tfname_len = strlen(actual);\n\t}\n\n\tif (fp) {\n\t\tif (phar_open_from_fp(fp, fname, fname_len, alias, alias_len, options, pphar, is_data, error TSRMLS_CC) == SUCCESS) {\n\t\t\tif ((*pphar)->is_data || !PHAR_G(readonly)) {\n\t\t\t\t(*pphar)->is_writeable = 1;\n\t\t\t}\n\t\t\tif (actual) {\n\t\t\t\tefree(actual);\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\t} else {\n\t\t\t/* file exists, but is either corrupt or not a phar archive */\n\t\t\tif (actual) {\n\t\t\t\tefree(actual);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (actual) {\n\t\tefree(actual);\n\t}\n\n\tif (PHAR_G(readonly) && !is_data) {\n\t\tif (options & REPORT_ERRORS) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"creating archive \\\"%s\\\" disabled by the php.ini setting phar.readonly\", fname);\n\t\t\t}\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\t/* set up our manifest */\n\tmydata = ecalloc(1, sizeof(phar_archive_data));\n\tmydata->fname = expand_filepath(fname, NULL TSRMLS_CC);\n\tfname_len = strlen(mydata->fname);\n#ifdef PHP_WIN32\n\tphar_unixify_path_separators(mydata->fname, fname_len);\n#endif\n\tp = strrchr(mydata->fname, '/');\n\n\tif (p) {\n\t\tmydata->ext = memchr(p, '.', (mydata->fname + fname_len) - p);\n\t\tif (mydata->ext == p) {\n\t\t\tmydata->ext = memchr(p + 1, '.', (mydata->fname + fname_len) - p - 1);\n\t\t}\n\t\tif (mydata->ext) {\n\t\t\tmydata->ext_len = (mydata->fname + fname_len) - mydata->ext;\n\t\t}\n\t}\n\n\tif (pphar) {\n\t\t*pphar = mydata;\n\t}\n\n\tzend_hash_init(&mydata->manifest, sizeof(phar_entry_info),\n\t\tzend_get_hash_value, destroy_phar_manifest_entry, 0);\n\tzend_hash_init(&mydata->mounted_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, 0);\n\tzend_hash_init(&mydata->virtual_dirs, sizeof(char *),\n\t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);\n\tmydata->fname_len = fname_len;\n\tsnprintf(mydata->version, sizeof(mydata->version), \"%s\", PHP_PHAR_API_VERSION);\n\tmydata->is_temporary_alias = alias ? 0 : 1;\n\tmydata->internal_file_start = -1;\n\tmydata->fp = NULL;\n\tmydata->is_writeable = 1;\n\tmydata->is_brandnew = 1;\n\tphar_request_initialize(TSRMLS_C);\n\tzend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*),  NULL);\n\n\tif (is_data) {\n\t\talias = NULL;\n\t\talias_len = 0;\n\t\tmydata->is_data = 1;\n\t\t/* assume tar format, PharData can specify other */\n\t\tmydata->is_tar = 1;\n\t} else {\n\t\tphar_archive_data **fd_ptr;\n\n\t\tif (alias && SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {\n\t\t\tif (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"phar error: phar \\\"%s\\\" cannot set alias \\\"%s\\\", already in use by another phar archive\", mydata->fname, alias);\n\t\t\t\t}\n\n\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\n\t\t\t\tif (pphar) {\n\t\t\t\t\t*pphar = NULL;\n\t\t\t\t}\n\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t}\n\n\t\tmydata->alias = alias ? estrndup(alias, alias_len) : estrndup(mydata->fname, fname_len);\n\t\tmydata->alias_len = alias ? alias_len : fname_len;\n\t}\n\n\tif (alias_len && alias) {\n\t\tif (FAILURE == zend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL)) {\n\t\t\tif (options & REPORT_ERRORS) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"archive \\\"%s\\\" cannot be associated with alias \\\"%s\\\", already in use\", fname, alias);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len);\n\n\t\t\tif (pphar) {\n\t\t\t\t*pphar = NULL;\n\t\t\t}\n\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\treturn SUCCESS;\n}\n/* }}}*/\n\n/**\n * Return an already opened filename.\n *\n * Or scan a phar file for the required __HALT_COMPILER(); ?> token and verify\n * that the manifest is proper, then pass it to phar_parse_pharfile().  SUCCESS\n * or FAILURE is returned and pphar is set to a pointer to the phar's manifest\n */\nint phar_open_from_filename(char *fname, int fname_len, char *alias, int alias_len, int options, phar_archive_data** pphar, char **error TSRMLS_DC) /* {{{ */\n{\n\tphp_stream *fp;\n\tchar *actual;\n\tint ret, is_data = 0;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (!strstr(fname, \".phar\")) {\n\t\tis_data = 1;\n\t}\n\n\tif (phar_open_parsed_phar(fname, fname_len, alias, alias_len, is_data, options, pphar, error TSRMLS_CC) == SUCCESS) {\n\t\treturn SUCCESS;\n\t} else if (error && *error) {\n\t\treturn FAILURE;\n\t}\n#if PHP_API_VERSION < 20100412\n\tif (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {\n\t\treturn FAILURE;\n\t}\n#endif\n\tif (php_check_open_basedir(fname TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tfp = php_stream_open_wrapper(fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK, &actual);\n\n\tif (!fp) {\n\t\tif (options & REPORT_ERRORS) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to open phar for reading \\\"%s\\\"\", fname);\n\t\t\t}\n\t\t}\n\t\tif (actual) {\n\t\t\tefree(actual);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (actual) {\n\t\tfname = actual;\n\t\tfname_len = strlen(actual);\n\t}\n\n\tret =  phar_open_from_fp(fp, fname, fname_len, alias, alias_len, options, pphar, is_data, error TSRMLS_CC);\n\n\tif (actual) {\n\t\tefree(actual);\n\t}\n\n\treturn ret;\n}\n/* }}}*/\n\nstatic inline char *phar_strnstr(const char *buf, int buf_len, const char *search, int search_len) /* {{{ */\n{\n\tconst char *c;\n\tint so_far = 0;\n\n\tif (buf_len < search_len) {\n\t\treturn NULL;\n\t}\n\n\tc = buf - 1;\n\n\tdo {\n\t\tif (!(c = memchr(c + 1, search[0], buf_len - search_len - so_far))) {\n\t\t\treturn (char *) NULL;\n\t\t}\n\n\t\tso_far = c - buf;\n\n\t\tif (so_far >= (buf_len - search_len)) {\n\t\t\treturn (char *) NULL;\n\t\t}\n\n\t\tif (!memcmp(c, search, search_len)) {\n\t\t\treturn (char *) c;\n\t\t}\n\t} while (1);\n}\n/* }}} */\n\n/**\n * Scan an open fp for the required __HALT_COMPILER(); ?> token and verify\n * that the manifest is proper, then pass it to phar_parse_pharfile().  SUCCESS\n * or FAILURE is returned and pphar is set to a pointer to the phar's manifest\n */\nstatic int phar_open_from_fp(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, int options, phar_archive_data** pphar, int is_data, char **error TSRMLS_DC) /* {{{ */\n{\n\tconst char token[] = \"__HALT_COMPILER();\";\n\tconst char zip_magic[] = \"PK\\x03\\x04\";\n\tconst char gz_magic[] = \"\\x1f\\x8b\\x08\";\n\tconst char bz_magic[] = \"BZh\";\n\tchar *pos, test = '\\0';\n\tconst int window_size = 1024;\n\tchar buffer[1024 + sizeof(token)]; /* a 1024 byte window + the size of the halt_compiler token (moving window) */\n\tconst long readsize = sizeof(buffer) - sizeof(token);\n\tconst long tokenlen = sizeof(token) - 1;\n\tlong halt_offset;\n\tsize_t got;\n\tphp_uint32 compression = PHAR_FILE_COMPRESSED_NONE;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (-1 == php_stream_rewind(fp)) {\n\t\tMAPPHAR_ALLOC_FAIL(\"cannot rewind phar \\\"%s\\\"\")\n\t}\n\n\tbuffer[sizeof(buffer)-1] = '\\0';\n\tmemset(buffer, 32, sizeof(token));\n\thalt_offset = 0;\n\n\t/* Maybe it's better to compile the file instead of just searching,  */\n\t/* but we only want the offset. So we want a .re scanner to find it. */\n\twhile(!php_stream_eof(fp)) {\n\t\tif ((got = php_stream_read(fp, buffer+tokenlen, readsize)) < (size_t) tokenlen) {\n\t\t\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated entry)\")\n\t\t}\n\n\t\tif (!test) {\n\t\t\ttest = '\\1';\n\t\t\tpos = buffer+tokenlen;\n\t\t\tif (!memcmp(pos, gz_magic, 3)) {\n\t\t\t\tchar err = 0;\n\t\t\t\tphp_stream_filter *filter;\n\t\t\t\tphp_stream *temp;\n\t\t\t\t/* to properly decompress, we have to tell zlib to look for a zlib or gzip header */\n\t\t\t\tzval filterparams;\n\n\t\t\t\tif (!PHAR_G(has_zlib)) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\" to temporary file, enable zlib extension in php.ini\")\n\t\t\t\t}\n\t\t\t\tarray_init(&filterparams);\n/* this is defined in zlib's zconf.h */\n#ifndef MAX_WBITS\n#define MAX_WBITS 15\n#endif\n\t\t\t\tadd_assoc_long(&filterparams, \"window\", MAX_WBITS + 32);\n\n\t\t\t\t/* entire file is gzip-compressed, uncompress to temporary file */\n\t\t\t\tif (!(temp = php_stream_fopen_tmpfile())) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to create temporary file for decompression of gzipped phar archive \\\"%s\\\"\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tfilter = php_stream_filter_create(\"zlib.inflate\", &filterparams, php_stream_is_persistent(fp) TSRMLS_CC);\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\terr = 1;\n\t\t\t\t\tadd_assoc_long(&filterparams, \"window\", MAX_WBITS);\n\t\t\t\t\tfilter = php_stream_filter_create(\"zlib.inflate\", &filterparams, php_stream_is_persistent(fp) TSRMLS_CC);\n\t\t\t\t\tzval_dtor(&filterparams);\n\n\t\t\t\t\tif (!filter) {\n\t\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\", ext/zlib is buggy in PHP versions older than 5.2.6\")\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tzval_dtor(&filterparams);\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&temp->writefilters, filter);\n\n\t\t\t\tif (SUCCESS != php_stream_copy_to_stream_ex(fp, temp, PHP_STREAM_COPY_ALL, NULL)) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\", ext/zlib is buggy in PHP versions older than 5.2.6\")\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress gzipped phar archive \\\"%s\\\" to temporary file\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tfp = temp;\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tcompression = PHAR_FILE_COMPRESSED_GZ;\n\n\t\t\t\t/* now, start over */\n\t\t\t\ttest = '\\0';\n\t\t\t\tcontinue;\n\t\t\t} else if (!memcmp(pos, bz_magic, 3)) {\n\t\t\t\tphp_stream_filter *filter;\n\t\t\t\tphp_stream *temp;\n\n\t\t\t\tif (!PHAR_G(has_bz2)) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress bzipped phar archive \\\"%s\\\" to temporary file, enable bz2 extension in php.ini\")\n\t\t\t\t}\n\n\t\t\t\t/* entire file is bzip-compressed, uncompress to temporary file */\n\t\t\t\tif (!(temp = php_stream_fopen_tmpfile())) {\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to create temporary file for decompression of bzipped phar archive \\\"%s\\\"\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tfilter = php_stream_filter_create(\"bzip2.decompress\", NULL, php_stream_is_persistent(fp) TSRMLS_CC);\n\n\t\t\t\tif (!filter) {\n\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress bzipped phar archive \\\"%s\\\", filter creation failed\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_append(&temp->writefilters, filter);\n\n\t\t\t\tif (SUCCESS != php_stream_copy_to_stream_ex(fp, temp, PHP_STREAM_COPY_ALL, NULL)) {\n\t\t\t\t\tphp_stream_close(temp);\n\t\t\t\t\tMAPPHAR_ALLOC_FAIL(\"unable to decompress bzipped phar archive \\\"%s\\\" to temporary file\")\n\t\t\t\t}\n\n\t\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\t\tphp_stream_close(fp);\n\t\t\t\tfp = temp;\n\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\tcompression = PHAR_FILE_COMPRESSED_BZ2;\n\n\t\t\t\t/* now, start over */\n\t\t\t\ttest = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!memcmp(pos, zip_magic, 4)) {\n\t\t\t\tphp_stream_seek(fp, 0, SEEK_END);\n\t\t\t\treturn phar_parse_zipfile(fp, fname, fname_len, alias, alias_len, pphar, error TSRMLS_CC);\n\t\t\t}\n\n\t\t\tif (got > 512) {\n\t\t\t\tif (phar_is_tar(pos, fname)) {\n\t\t\t\t\tphp_stream_rewind(fp);\n\t\t\t\t\treturn phar_parse_tarfile(fp, fname, fname_len, alias, alias_len, pphar, is_data, compression, error TSRMLS_CC);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (got > 0 && (pos = phar_strnstr(buffer, got + sizeof(token), token, sizeof(token)-1)) != NULL) {\n\t\t\thalt_offset += (pos - buffer); /* no -tokenlen+tokenlen here */\n\t\t\treturn phar_parse_pharfile(fp, fname, fname_len, alias, alias_len, halt_offset, pphar, compression, error TSRMLS_CC);\n\t\t}\n\n\t\thalt_offset += got;\n\t\tmemmove(buffer, buffer + window_size, tokenlen); /* move the memory buffer by the size of the window */\n\t}\n\n\tMAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (__HALT_COMPILER(); not found)\")\n}\n/* }}} */\n\n/*\n * given the location of the file extension and the start of the file path,\n * determine the end of the portion of the path (i.e. /path/to/file.ext/blah\n * grabs \"/path/to/file.ext\" as does the straight /path/to/file.ext),\n * stat it to determine if it exists.\n * if so, check to see if it is a directory and fail if so\n * if not, check to see if its dirname() exists (i.e. \"/path/to\") and is a directory\n * succeed if we are creating the file, otherwise fail.\n */\nstatic int phar_analyze_path(const char *fname, const char *ext, int ext_len, int for_create TSRMLS_DC) /* {{{ */\n{\n\tphp_stream_statbuf ssb;\n\tchar *realpath;\n\tchar *filename = estrndup(fname, (ext - fname) + ext_len);\n\n\tif ((realpath = expand_filepath(filename, NULL TSRMLS_CC))) {\n#ifdef PHP_WIN32\n\t\tphar_unixify_path_separators(realpath, strlen(realpath));\n#endif\n\t\tif (zend_hash_exists(&(PHAR_GLOBALS->phar_fname_map), realpath, strlen(realpath))) {\n\t\t\tefree(realpath);\n\t\t\tefree(filename);\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && zend_hash_exists(&cached_phars, realpath, strlen(realpath))) {\n\t\t\tefree(realpath);\n\t\t\tefree(filename);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tefree(realpath);\n\t}\n\n\tif (SUCCESS == php_stream_stat_path((char *) filename, &ssb)) {\n\n\t\tefree(filename);\n\n\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tif (for_create == 1) {\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\treturn SUCCESS;\n\t} else {\n\t\tchar *slash;\n\n\t\tif (!for_create) {\n\t\t\tefree(filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tslash = (char *) strrchr(filename, '/');\n\n\t\tif (slash) {\n\t\t\t*slash = '\\0';\n\t\t}\n\n\t\tif (SUCCESS != php_stream_stat_path((char *) filename, &ssb)) {\n\t\t\tif (!slash) {\n\t\t\t\tif (!(realpath = expand_filepath(filename, NULL TSRMLS_CC))) {\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n#ifdef PHP_WIN32\n\t\t\t\tphar_unixify_path_separators(realpath, strlen(realpath));\n#endif\n\t\t\t\tslash = strstr(realpath, filename);\n\t\t\t\tif (slash) {\n\t\t\t\t\tslash += ((ext - fname) + ext_len);\n\t\t\t\t\t*slash = '\\0';\n\t\t\t\t}\n\t\t\t\tslash = strrchr(realpath, '/');\n\n\t\t\t\tif (slash) {\n\t\t\t\t\t*slash = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tefree(realpath);\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tif (SUCCESS != php_stream_stat_path(realpath, &ssb)) {\n\t\t\t\t\tefree(realpath);\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\n\t\t\t\tefree(realpath);\n\n\t\t\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\t\t\tefree(filename);\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tefree(filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tefree(filename);\n\n\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\treturn FAILURE;\n\t}\n}\n/* }}} */\n\n/* check for \".phar\" in extension */\nstatic int phar_check_str(const char *fname, const char *ext_str, int ext_len, int executable, int for_create TSRMLS_DC) /* {{{ */\n{\n\tchar test[51];\n\tconst char *pos;\n\n\tif (ext_len >= 50) {\n\t\treturn FAILURE;\n\t}\n\n\tif (executable == 1) {\n\t\t/* copy \".\" as well */\n\t\tmemcpy(test, ext_str - 1, ext_len + 1);\n\t\ttest[ext_len + 1] = '\\0';\n\t\t/* executable phars must contain \".phar\" as a valid extension (phar://.pharmy/oops is invalid) */\n\t\t/* (phar://hi/there/.phar/oops is also invalid) */\n\t\tpos = strstr(test, \".phar\");\n\n\t\tif (pos && (*(pos - 1) != '/')\n\t\t\t\t&& (pos += 5) && (*pos == '\\0' || *pos == '/' || *pos == '.')) {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create TSRMLS_CC);\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\t/* data phars need only contain a single non-\".\" to be valid */\n\tif (!executable) {\n\t\tpos = strstr(ext_str, \".phar\");\n\t\tif (!(pos && (*(pos - 1) != '/')\n\t\t\t\t\t&& (pos += 5) && (*pos == '\\0' || *pos == '/' || *pos == '.')) && *(ext_str + 1) != '.' && *(ext_str + 1) != '/' && *(ext_str + 1) != '\\0') {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create TSRMLS_CC);\n\t\t}\n\t} else {\n\t\tif (*(ext_str + 1) != '.' && *(ext_str + 1) != '/' && *(ext_str + 1) != '\\0') {\n\t\t\treturn phar_analyze_path(fname, ext_str, ext_len, for_create TSRMLS_CC);\n\t\t}\n\t}\n\n\treturn FAILURE;\n}\n/* }}} */\n\n/*\n * if executable is 1, only returns SUCCESS if the extension is one of the tar/zip .phar extensions\n * if executable is 0, it returns SUCCESS only if the filename does *not* contain \".phar\" anywhere, and treats\n * the first extension as the filename extension\n *\n * if an extension is found, it sets ext_str to the location of the file extension in filename,\n * and ext_len to the length of the extension.\n * for urls like \"phar://alias/oops\" it instead sets ext_len to -1 and returns FAILURE, which tells\n * the calling function to use \"alias\" as the phar alias\n *\n * the last parameter should be set to tell the thing to assume that filename is the full path, and only to check the\n * extension rules, not to iterate.\n */\nint phar_detect_phar_fname_ext(const char *filename, int filename_len, const char **ext_str, int *ext_len, int executable, int for_create, int is_complete TSRMLS_DC) /* {{{ */\n{\n\tconst char *pos, *slash;\n\n\t*ext_str = NULL;\n\t*ext_len = 0;\n\n\tif (!filename_len || filename_len == 1) {\n\t\treturn FAILURE;\n\t}\n\n\tphar_request_initialize(TSRMLS_C);\n\t/* first check for alias in first segment */\n\tpos = memchr(filename, '/', filename_len);\n\n\tif (pos && pos != filename) {\n\t\t/* check for url like http:// or phar:// */\n\t\tif (*(pos - 1) == ':' && (pos - filename) < filename_len - 1 && *(pos + 1) == '/') {\n\t\t\t*ext_len = -2;\n\t\t\t*ext_str = NULL;\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (zend_hash_exists(&(PHAR_GLOBALS->phar_alias_map), (char *) filename, pos - filename)) {\n\t\t\t*ext_str = pos;\n\t\t\t*ext_len = -1;\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\tif (PHAR_G(manifest_cached) && zend_hash_exists(&cached_alias, (char *) filename, pos - filename)) {\n\t\t\t*ext_str = pos;\n\t\t\t*ext_len = -1;\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (zend_hash_num_elements(&(PHAR_GLOBALS->phar_fname_map)) || PHAR_G(manifest_cached)) {\n\t\tphar_archive_data **pphar;\n\n\t\tif (is_complete) {\n\t\t\tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), (char *) filename, filename_len, (void **)&pphar)) {\n\t\t\t\t*ext_str = filename + (filename_len - (*pphar)->ext_len);\nwoohoo:\n\t\t\t\t*ext_len = (*pphar)->ext_len;\n\n\t\t\t\tif (executable == 2) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\n\t\t\t\tif (executable == 1 && !(*pphar)->is_data) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\n\t\t\t\tif (!executable && (*pphar)->is_data) {\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t}\n\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\n\t\t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, (char *) filename, filename_len, (void **)&pphar)) {\n\t\t\t\t*ext_str = filename + (filename_len - (*pphar)->ext_len);\n\t\t\t\tgoto woohoo;\n\t\t\t}\n\t\t} else {\n\t\t\tchar *str_key;\n\t\t\tuint keylen;\n\t\t\tulong unused;\n\n\t\t\tfor (zend_hash_internal_pointer_reset(&(PHAR_GLOBALS->phar_fname_map));\n\t\t\t\tHASH_KEY_NON_EXISTENT != zend_hash_get_current_key_ex(&(PHAR_GLOBALS->phar_fname_map), &str_key, &keylen, &unused, 0, NULL);\n\t\t\t\tzend_hash_move_forward(&(PHAR_GLOBALS->phar_fname_map))\n\t\t\t) {\n\t\t\t\tif (keylen > (uint) filename_len) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (!memcmp(filename, str_key, keylen) && ((uint)filename_len == keylen\n\t\t\t\t\t|| filename[keylen] == '/' || filename[keylen] == '\\0')) {\n\t\t\t\t\tif (FAILURE == zend_hash_get_current_data(&(PHAR_GLOBALS->phar_fname_map), (void **) &pphar)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t*ext_str = filename + (keylen - (*pphar)->ext_len);\n\t\t\t\t\tgoto woohoo;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (PHAR_G(manifest_cached)) {\n\t\t\t\tfor (zend_hash_internal_pointer_reset(&cached_phars);\n\t\t\t\t\tHASH_KEY_NON_EXISTENT != zend_hash_get_current_key_ex(&cached_phars, &str_key, &keylen, &unused, 0, NULL);\n\t\t\t\t\tzend_hash_move_forward(&cached_phars)\n\t\t\t\t) {\n\t\t\t\t\tif (keylen > (uint) filename_len) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!memcmp(filename, str_key, keylen) && ((uint)filename_len == keylen\n\t\t\t\t\t\t|| filename[keylen] == '/' || filename[keylen] == '\\0')) {\n\t\t\t\t\t\tif (FAILURE == zend_hash_get_current_data(&cached_phars, (void **) &pphar)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t*ext_str = filename + (keylen - (*pphar)->ext_len);\n\t\t\t\t\t\tgoto woohoo;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpos = memchr(filename + 1, '.', filename_len);\nnext_extension:\n\tif (!pos) {\n\t\treturn FAILURE;\n\t}\n\n\twhile (pos != filename && (*(pos - 1) == '/' || *(pos - 1) == '\\0')) {\n\t\tpos = memchr(pos + 1, '.', filename_len - (pos - filename) + 1);\n\t\tif (!pos) {\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tslash = memchr(pos, '/', filename_len - (pos - filename));\n\n\tif (!slash) {\n\t\t/* this is a url like \"phar://blah.phar\" with no directory */\n\t\t*ext_str = pos;\n\t\t*ext_len = strlen(pos);\n\n\t\t/* file extension must contain \"phar\" */\n\t\tswitch (phar_check_str(filename, *ext_str, *ext_len, executable, for_create TSRMLS_CC)) {\n\t\t\tcase SUCCESS:\n\t\t\t\treturn SUCCESS;\n\t\t\tcase FAILURE:\n\t\t\t\t/* we are at the end of the string, so we fail */\n\t\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\t/* we've found an extension that ends at a directory separator */\n\t*ext_str = pos;\n\t*ext_len = slash - pos;\n\n\tswitch (phar_check_str(filename, *ext_str, *ext_len, executable, for_create TSRMLS_CC)) {\n\t\tcase SUCCESS:\n\t\t\treturn SUCCESS;\n\t\tcase FAILURE:\n\t\t\t/* look for more extensions */\n\t\t\tpos = strchr(pos + 1, '.');\n\t\t\tif (pos) {\n\t\t\t\t*ext_str = NULL;\n\t\t\t\t*ext_len = 0;\n\t\t\t}\n\t\t\tgoto next_extension;\n\t}\n\n\treturn FAILURE;\n}\n/* }}} */\n\nstatic int php_check_dots(const char *element, int n) /* {{{ */\n{\n\tfor(n--; n >= 0; --n) {\n\t\tif (element[n] != '.') {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n/* }}} */\n\n#define IS_DIRECTORY_UP(element, len) \\\n\t(len >= 2 && !php_check_dots(element, len))\n\n#define IS_DIRECTORY_CURRENT(element, len) \\\n\t(len == 1 && element[0] == '.')\n\n#define IS_BACKSLASH(c) ((c) == '/')\n\n#ifdef COMPILE_DL_PHAR\n/* stupid-ass non-extern declaration in tsrm_strtok.h breaks dumbass MS compiler */\nstatic inline int in_character_class(char ch, const char *delim) /* {{{ */\n{\n\twhile (*delim) {\n\t\tif (*delim == ch) {\n\t\t\treturn 1;\n\t\t}\n\t\t++delim;\n\t}\n\treturn 0;\n}\n/* }}} */\n\nchar *tsrm_strtok_r(char *s, const char *delim, char **last) /* {{{ */\n{\n\tchar *token;\n\n\tif (s == NULL) {\n\t\ts = *last;\n\t}\n\n\twhile (*s && in_character_class(*s, delim)) {\n\t\t++s;\n\t}\n\n\tif (!*s) {\n\t\treturn NULL;\n\t}\n\n\ttoken = s;\n\n\twhile (*s && !in_character_class(*s, delim)) {\n\t\t++s;\n\t}\n\n\tif (!*s) {\n\t\t*last = s;\n\t} else {\n\t\t*s = '\\0';\n\t\t*last = s + 1;\n\t}\n\n\treturn token;\n}\n/* }}} */\n#endif\n\n/**\n * Remove .. and . references within a phar filename\n */\nchar *phar_fix_filepath(char *path, int *new_len, int use_cwd TSRMLS_DC) /* {{{ */\n{\n\tchar *newpath;\n\tint newpath_len;\n\tchar *ptr;\n\tchar *tok;\n\tint ptr_length, path_length = *new_len;\n\n\tif (PHAR_G(cwd_len) && use_cwd && path_length > 2 && path[0] == '.' && path[1] == '/') {\n\t\tnewpath_len = PHAR_G(cwd_len);\n\t\tnewpath = emalloc(strlen(path) + newpath_len + 1);\n\t\tmemcpy(newpath, PHAR_G(cwd), newpath_len);\n\t} else {\n\t\tnewpath = emalloc(strlen(path) + 2);\n\t\tnewpath[0] = '/';\n\t\tnewpath_len = 1;\n\t}\n\n\tptr = path;\n\n\tif (*ptr == '/') {\n\t\t++ptr;\n\t}\n\n\ttok = ptr;\n\n\tdo {\n\t\tptr = memchr(ptr, '/', path_length - (ptr - path));\n\t} while (ptr && ptr - tok == 0 && *ptr == '/' && ++ptr && ++tok);\n\n\tif (!ptr && (path_length - (tok - path))) {\n\t\tswitch (path_length - (tok - path)) {\n\t\t\tcase 1:\n\t\t\t\tif (*tok == '.') {\n\t\t\t\t\tefree(path);\n\t\t\t\t\t*new_len = 1;\n\t\t\t\t\tefree(newpath);\n\t\t\t\t\treturn estrndup(\"/\", 1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (tok[0] == '.' && tok[1] == '.') {\n\t\t\t\t\tefree(path);\n\t\t\t\t\t*new_len = 1;\n\t\t\t\t\tefree(newpath);\n\t\t\t\t\treturn estrndup(\"/\", 1);\n\t\t\t\t}\n\t\t}\n\t\tefree(newpath);\n\t\treturn path;\n\t}\n\n\twhile (ptr) {\n\t\tptr_length = ptr - tok;\nlast_time:\n\t\tif (IS_DIRECTORY_UP(tok, ptr_length)) {\n#define PREVIOUS newpath[newpath_len - 1]\n\n\t\t\twhile (newpath_len > 1 && !IS_BACKSLASH(PREVIOUS)) {\n\t\t\t\tnewpath_len--;\n\t\t\t}\n\n\t\t\tif (newpath[0] != '/') {\n\t\t\t\tnewpath[newpath_len] = '\\0';\n\t\t\t} else if (newpath_len > 1) {\n\t\t\t\t--newpath_len;\n\t\t\t}\n\t\t} else if (!IS_DIRECTORY_CURRENT(tok, ptr_length)) {\n\t\t\tif (newpath_len > 1) {\n\t\t\t\tnewpath[newpath_len++] = '/';\n\t\t\t\tmemcpy(newpath + newpath_len, tok, ptr_length+1);\n\t\t\t} else {\n\t\t\t\tmemcpy(newpath + newpath_len, tok, ptr_length+1);\n\t\t\t}\n\n\t\t\tnewpath_len += ptr_length;\n\t\t}\n\n\t\tif (ptr == path + path_length) {\n\t\t\tbreak;\n\t\t}\n\n\t\ttok = ++ptr;\n\n\t\tdo {\n\t\t\tptr = memchr(ptr, '/', path_length - (ptr - path));\n\t\t} while (ptr && ptr - tok == 0 && *ptr == '/' && ++ptr && ++tok);\n\n\t\tif (!ptr && (path_length - (tok - path))) {\n\t\t\tptr_length = path_length - (tok - path);\n\t\t\tptr = path + path_length;\n\t\t\tgoto last_time;\n\t\t}\n\t}\n\n\tefree(path);\n\t*new_len = newpath_len;\n\tnewpath[newpath_len] = '\\0';\n\treturn erealloc(newpath, newpath_len + 1);\n}\n/* }}} */\n\n/**\n * Process a phar stream name, ensuring we can handle any of:\n *\n * - whatever.phar\n * - whatever.phar.gz\n * - whatever.phar.bz2\n * - whatever.phar.php\n *\n * Optionally the name might start with 'phar://'\n *\n * This is used by phar_parse_url()\n */\nint phar_split_fname(const char *filename, int filename_len, char **arch, int *arch_len, char **entry, int *entry_len, int executable, int for_create TSRMLS_DC) /* {{{ */\n{\n\tconst char *ext_str;\n#ifdef PHP_WIN32\n\tchar *save;\n#endif\n\tint ext_len;\n\n\tif (CHECK_NULL_PATH(filename, filename_len)) {\n\t\treturn FAILURE;\n\t}\n\n\tif (!strncasecmp(filename, \"phar://\", 7)) {\n\t\tfilename += 7;\n\t\tfilename_len -= 7;\n\t}\n\n\text_len = 0;\n#ifdef PHP_WIN32\n\tsave = filename;\n\tfilename = estrndup(filename, filename_len);\n\tphar_unixify_path_separators(filename, filename_len);\n#endif\n\tif (phar_detect_phar_fname_ext(filename, filename_len, &ext_str, &ext_len, executable, for_create, 0 TSRMLS_CC) == FAILURE) {\n\t\tif (ext_len != -1) {\n\t\t\tif (!ext_str) {\n\t\t\t\t/* no / detected, restore arch for error message */\n#ifdef PHP_WIN32\n\t\t\t\t*arch = save;\n#else\n\t\t\t\t*arch = filename;\n#endif\n\t\t\t}\n\n#ifdef PHP_WIN32\n\t\t\tefree(filename);\n#endif\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\text_len = 0;\n\t\t/* no extension detected - instead we are dealing with an alias */\n\t}\n\n\t*arch_len = ext_str - filename + ext_len;\n\t*arch = estrndup(filename, *arch_len);\n\n\tif (ext_str[ext_len]) {\n\t\t*entry_len = filename_len - *arch_len;\n\t\t*entry = estrndup(ext_str+ext_len, *entry_len);\n#ifdef PHP_WIN32\n\t\tphar_unixify_path_separators(*entry, *entry_len);\n#endif\n\t\t*entry = phar_fix_filepath(*entry, entry_len, 0 TSRMLS_CC);\n\t} else {\n\t\t*entry_len = 1;\n\t\t*entry = estrndup(\"/\", 1);\n\t}\n\n#ifdef PHP_WIN32\n\tefree(filename);\n#endif\n\n\treturn SUCCESS;\n}\n/* }}} */\n\n/**\n * Invoked when a user calls Phar::mapPhar() from within an executing .phar\n * to set up its manifest directly\n */\nint phar_open_executed_filename(char *alias, int alias_len, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar *fname;\n\tzval *halt_constant;\n\tphp_stream *fp;\n\tint fname_len;\n\tchar *actual = NULL;\n\tint ret;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tfname = (char*)zend_get_executed_filename(TSRMLS_C);\n\tfname_len = strlen(fname);\n\n\tif (phar_open_parsed_phar(fname, fname_len, alias, alias_len, 0, REPORT_ERRORS, NULL, 0 TSRMLS_CC) == SUCCESS) {\n\t\treturn SUCCESS;\n\t}\n\n\tif (!strcmp(fname, \"[no active file]\")) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"cannot initialize a phar outside of PHP execution\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tMAKE_STD_ZVAL(halt_constant);\n\n\tif (0 == zend_get_constant(\"__COMPILER_HALT_OFFSET__\", 24, halt_constant TSRMLS_CC)) {\n\t\tFREE_ZVAL(halt_constant);\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"__HALT_COMPILER(); must be declared in a phar\");\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tFREE_ZVAL(halt_constant);\n\n#if PHP_API_VERSION < 20100412\n\tif (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {\n\t\treturn FAILURE;\n\t}\n#endif\n\n\tif (php_check_open_basedir(fname TSRMLS_CC)) {\n\t\treturn FAILURE;\n\t}\n\n\tfp = php_stream_open_wrapper(fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK|REPORT_ERRORS, &actual);\n\n\tif (!fp) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to open phar for reading \\\"%s\\\"\", fname);\n\t\t}\n\t\tif (actual) {\n\t\t\tefree(actual);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (actual) {\n\t\tfname = actual;\n\t\tfname_len = strlen(actual);\n\t}\n\n\tret = phar_open_from_fp(fp, fname, fname_len, alias, alias_len, REPORT_ERRORS, NULL, 0, error TSRMLS_CC);\n\n\tif (actual) {\n\t\tefree(actual);\n\t}\n\n\treturn ret;\n}\n/* }}} */\n\n/**\n * Validate the CRC32 of a file opened from within the phar\n */\nint phar_postprocess_file(phar_entry_data *idata, php_uint32 crc32, char **error, int process_zip TSRMLS_DC) /* {{{ */\n{\n\tphp_uint32 crc = ~0;\n\tint len = idata->internal_file->uncompressed_filesize;\n\tphp_stream *fp = idata->fp;\n\tphar_entry_info *entry = idata->internal_file;\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (entry->is_zip && process_zip > 0) {\n\t\t/* verify local file header */\n\t\tphar_zip_file_header local;\n\t\tphar_zip_data_desc desc;\n\n\t\tif (SUCCESS != phar_open_archive_fp(idata->phar TSRMLS_CC)) {\n\t\t\tspprintf(error, 0, \"phar error: unable to open zip-based phar archive \\\"%s\\\" to verify local file header for file \\\"%s\\\"\", idata->phar->fname, entry->filename);\n\t\t\treturn FAILURE;\n\t\t}\n\t\tphp_stream_seek(phar_get_entrypfp(idata->internal_file TSRMLS_CC), entry->header_offset, SEEK_SET);\n\n\t\tif (sizeof(local) != php_stream_read(phar_get_entrypfp(idata->internal_file TSRMLS_CC), (char *) &local, sizeof(local))) {\n\n\t\t\tspprintf(error, 0, \"phar error: internal corruption of zip-based phar \\\"%s\\\" (cannot read local file header for file \\\"%s\\\")\", idata->phar->fname, entry->filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\t/* check for data descriptor */\n\t\tif (((PHAR_ZIP_16(local.flags)) & 0x8) == 0x8) {\n\t\t\tphp_stream_seek(phar_get_entrypfp(idata->internal_file TSRMLS_CC),\n\t\t\t\t\tentry->header_offset + sizeof(local) +\n\t\t\t\t\tPHAR_ZIP_16(local.filename_len) +\n\t\t\t\t\tPHAR_ZIP_16(local.extra_len) +\n\t\t\t\t\tentry->compressed_filesize, SEEK_SET);\n\t\t\tif (sizeof(desc) != php_stream_read(phar_get_entrypfp(idata->internal_file TSRMLS_CC),\n\t\t\t\t\t\t\t    (char *) &desc, sizeof(desc))) {\n\t\t\t\tspprintf(error, 0, \"phar error: internal corruption of zip-based phar \\\"%s\\\" (cannot read local data descriptor for file \\\"%s\\\")\", idata->phar->fname, entry->filename);\n\t\t\t\treturn FAILURE;\n\t\t\t}\n\t\t\tif (desc.signature[0] == 'P' && desc.signature[1] == 'K') {\n\t\t\t\tmemcpy(&(local.crc32), &(desc.crc32), 12);\n\t\t\t} else {\n\t\t\t\t/* old data descriptors have no signature */\n\t\t\t\tmemcpy(&(local.crc32), &desc, 12);\n\t\t\t}\n\t\t}\n\t\t/* verify local header */\n\t\tif (entry->filename_len != PHAR_ZIP_16(local.filename_len) || entry->crc32 != PHAR_ZIP_32(local.crc32) || entry->uncompressed_filesize != PHAR_ZIP_32(local.uncompsize) || entry->compressed_filesize != PHAR_ZIP_32(local.compsize)) {\n\t\t\tspprintf(error, 0, \"phar error: internal corruption of zip-based phar \\\"%s\\\" (local header of file \\\"%s\\\" does not match central directory)\", idata->phar->fname, entry->filename);\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\t/* construct actual offset to file start - local extra_len can be different from central extra_len */\n\t\tentry->offset = entry->offset_abs =\n\t\t\tsizeof(local) + entry->header_offset + PHAR_ZIP_16(local.filename_len) + PHAR_ZIP_16(local.extra_len);\n\n\t\tif (idata->zero && idata->zero != entry->offset_abs) {\n\t\t\tidata->zero = entry->offset_abs;\n\t\t}\n\t}\n\n\tif (process_zip == 1) {\n\t\treturn SUCCESS;\n\t}\n\n\tphp_stream_seek(fp, idata->zero, SEEK_SET);\n\n\twhile (len--) {\n\t\tCRC32(crc, php_stream_getc(fp));\n\t}\n\n\tphp_stream_seek(fp, idata->zero, SEEK_SET);\n\n\tif (~crc == crc32) {\n\t\tentry->is_crc_checked = 1;\n\t\treturn SUCCESS;\n\t} else {\n\t\tspprintf(error, 0, \"phar error: internal corruption of phar \\\"%s\\\" (crc32 mismatch on file \\\"%s\\\")\", idata->phar->fname, entry->filename);\n\t\treturn FAILURE;\n\t}\n}\n/* }}} */\n\nstatic inline void phar_set_32(char *buffer, int var) /* {{{ */\n{\n#ifdef WORDS_BIGENDIAN\n\t*((buffer) + 3) = (unsigned char) (((var) >> 24) & 0xFF);\n\t*((buffer) + 2) = (unsigned char) (((var) >> 16) & 0xFF);\n\t*((buffer) + 1) = (unsigned char) (((var) >> 8) & 0xFF);\n\t*((buffer) + 0) = (unsigned char) ((var) & 0xFF);\n#else\n\t memcpy(buffer, &var, sizeof(var));\n#endif\n} /* }}} */\n\nstatic int phar_flush_clean_deleted_apply(void *data TSRMLS_DC) /* {{{ */\n{\n\tphar_entry_info *entry = (phar_entry_info *)data;\n\n\tif (entry->fp_refcount <= 0 && entry->is_deleted) {\n\t\treturn ZEND_HASH_APPLY_REMOVE;\n\t} else {\n\t\treturn ZEND_HASH_APPLY_KEEP;\n\t}\n}\n/* }}} */\n\n#include \"stub.h\"\n\nchar *phar_create_default_stub(const char *index_php, const char *web_index, size_t *len, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar *stub = NULL;\n\tint index_len, web_len;\n\tsize_t dummy;\n\n\tif (!len) {\n\t\tlen = &dummy;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (!index_php) {\n\t\tindex_php = \"index.php\";\n\t}\n\n\tif (!web_index) {\n\t\tweb_index = \"index.php\";\n\t}\n\n\tindex_len = strlen(index_php);\n\tweb_len = strlen(web_index);\n\n\tif (index_len > 400) {\n\t\t/* ridiculous size not allowed for index.php startup filename */\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"Illegal filename passed in for stub creation, was %d characters long, and only 400 or less is allowed\", index_len);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (web_len > 400) {\n\t\t/* ridiculous size not allowed for index.php startup filename */\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"Illegal web filename passed in for stub creation, was %d characters long, and only 400 or less is allowed\", web_len);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tphar_get_stub(index_php, web_index, len, &stub, index_len+1, web_len+1 TSRMLS_CC);\n\treturn stub;\n}\n/* }}} */\n\n/**\n * Save phar contents to disk\n *\n * user_stub contains either a string, or a resource pointer, if len is a negative length.\n * user_stub and len should be both 0 if the default or existing stub should be used\n */\nint phar_flush(phar_archive_data *phar, char *user_stub, long len, int convert, char **error TSRMLS_DC) /* {{{ */\n{\n\tchar halt_stub[] = \"__HALT_COMPILER();\";\n\tchar *newstub, *tmp;\n\tphar_entry_info *entry, *newentry;\n\tint halt_offset, restore_alias_len, global_flags = 0, closeoldfile;\n\tchar *pos, has_dirs = 0;\n\tchar manifest[18], entry_buffer[24];\n\toff_t manifest_ftell;\n\tlong offset;\n\tsize_t wrote;\n\tphp_uint32 manifest_len, mytime, loc, new_manifest_count;\n\tphp_uint32 newcrc32;\n\tphp_stream *file, *oldfile, *newfile, *stubfile;\n\tphp_stream_filter *filter;\n\tphp_serialize_data_t metadata_hash;\n\tsmart_str main_metadata_str = {0};\n\tint free_user_stub, free_fp = 1, free_ufp = 1;\n\tint manifest_hack = 0;\n\n\tif (phar->is_persistent) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"internal error: attempt to flush cached zip-based phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\t\treturn EOF;\n\t}\n\n\tif (error) {\n\t\t*error = NULL;\n\t}\n\n\tif (!zend_hash_num_elements(&phar->manifest) && !user_stub) {\n\t\treturn EOF;\n\t}\n\n\tzend_hash_clean(&phar->virtual_dirs);\n\n\tif (phar->is_zip) {\n\t\treturn phar_zip_flush(phar, user_stub, len, convert, error TSRMLS_CC);\n\t}\n\n\tif (phar->is_tar) {\n\t\treturn phar_tar_flush(phar, user_stub, len, convert, error TSRMLS_CC);\n\t}\n\n\tif (PHAR_G(readonly)) {\n\t\treturn EOF;\n\t}\n\n\tif (phar->fp && !phar->is_brandnew) {\n\t\toldfile = phar->fp;\n\t\tcloseoldfile = 0;\n\t\tphp_stream_rewind(oldfile);\n\t} else {\n\t\toldfile = php_stream_open_wrapper(phar->fname, \"rb\", 0, NULL);\n\t\tcloseoldfile = oldfile != NULL;\n\t}\n\tnewfile = php_stream_fopen_tmpfile();\n\tif (!newfile) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to create temporary file\");\n\t\t}\n\t\tif (closeoldfile) {\n\t\t\tphp_stream_close(oldfile);\n\t\t}\n\t\treturn EOF;\n\t}\n\n\tif (user_stub) {\n\t\tif (len < 0) {\n\t\t\t/* resource passed in */\n\t\t\tif (!(php_stream_from_zval_no_verify(stubfile, (zval **)user_stub))) {\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to access resource to copy stub to new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\tif (len == -1) {\n\t\t\t\tlen = PHP_STREAM_COPY_ALL;\n\t\t\t} else {\n\t\t\t\tlen = -len;\n\t\t\t}\n\t\t\tuser_stub = 0;\n\n\t\t\tif (!(len = php_stream_copy_to_mem(stubfile, &user_stub, len, 0)) || !user_stub) {\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to read resource to copy stub to new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\tfree_user_stub = 1;\n\t\t} else {\n\t\t\tfree_user_stub = 0;\n\t\t}\n\t\ttmp = estrndup(user_stub, len);\n\t\tif ((pos = php_stristr(tmp, halt_stub, len, sizeof(halt_stub) - 1)) == NULL) {\n\t\t\tefree(tmp);\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"illegal stub for phar \\\"%s\\\"\", phar->fname);\n\t\t\t}\n\t\t\tif (free_user_stub) {\n\t\t\t\tefree(user_stub);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tpos = user_stub + (pos - tmp);\n\t\tefree(tmp);\n\t\tlen = pos - user_stub + 18;\n\t\tif ((size_t)len != php_stream_write(newfile, user_stub, len)\n\t\t||\t\t\t  5 != php_stream_write(newfile, \" ?>\\r\\n\", 5)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to create stub from string in new phar \\\"%s\\\"\", phar->fname);\n\t\t\t}\n\t\t\tif (free_user_stub) {\n\t\t\t\tefree(user_stub);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tphar->halt_offset = len + 5;\n\t\tif (free_user_stub) {\n\t\t\tefree(user_stub);\n\t\t}\n\t} else {\n\t\tsize_t written;\n\n\t\tif (!user_stub && phar->halt_offset && oldfile && !phar->is_brandnew) {\n\t\t\tphp_stream_copy_to_stream_ex(oldfile, newfile, phar->halt_offset, &written);\n\t\t\tnewstub = NULL;\n\t\t} else {\n\t\t\t/* this is either a brand new phar or a default stub overwrite */\n\t\t\tnewstub = phar_create_default_stub(NULL, NULL, &(phar->halt_offset), NULL TSRMLS_CC);\n\t\t\twritten = php_stream_write(newfile, newstub, phar->halt_offset);\n\t\t}\n\t\tif (phar->halt_offset != written) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tif (newstub) {\n\t\t\t\t\tspprintf(error, 0, \"unable to create stub in new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t} else {\n\t\t\t\t\tspprintf(error, 0, \"unable to copy stub of old phar to new phar \\\"%s\\\"\", phar->fname);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (newstub) {\n\t\t\t\tefree(newstub);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tif (newstub) {\n\t\t\tefree(newstub);\n\t\t}\n\t}\n\tmanifest_ftell = php_stream_tell(newfile);\n\thalt_offset = manifest_ftell;\n\n\t/* Check whether we can get rid of some of the deleted entries which are\n\t * unused. However some might still be in use so even after this clean-up\n\t * we need to skip entries marked is_deleted. */\n\tzend_hash_apply(&phar->manifest, phar_flush_clean_deleted_apply TSRMLS_CC);\n\n\t/* compress as necessary, calculate crcs, serialize meta-data, manifest size, and file sizes */\n\tmain_metadata_str.c = 0;\n\tif (phar->metadata) {\n\t\tPHP_VAR_SERIALIZE_INIT(metadata_hash);\n\t\tphp_var_serialize(&main_metadata_str, &phar->metadata, &metadata_hash TSRMLS_CC);\n\t\tPHP_VAR_SERIALIZE_DESTROY(metadata_hash);\n\t} else {\n\t\tmain_metadata_str.len = 0;\n\t}\n\tnew_manifest_count = 0;\n\toffset = 0;\n\tfor (zend_hash_internal_pointer_reset(&phar->manifest);\n\t\tzend_hash_has_more_elements(&phar->manifest) == SUCCESS;\n\t\tzend_hash_move_forward(&phar->manifest)) {\n\t\tif (zend_hash_get_current_data(&phar->manifest, (void **)&entry) == FAILURE) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (entry->cfp) {\n\t\t\t/* did we forget to get rid of cfp last time? */\n\t\t\tphp_stream_close(entry->cfp);\n\t\t\tentry->cfp = 0;\n\t\t}\n\t\tif (entry->is_deleted || entry->is_mounted) {\n\t\t\t/* remove this from the new phar */\n\t\t\tcontinue;\n\t\t}\n\t\tif (!entry->is_modified && entry->fp_refcount) {\n\t\t\t/* open file pointers refer to this fp, do not free the stream */\n\t\t\tswitch (entry->fp_type) {\n\t\t\t\tcase PHAR_FP:\n\t\t\t\t\tfree_fp = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase PHAR_UFP:\n\t\t\t\t\tfree_ufp = 0;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* after excluding deleted files, calculate manifest size in bytes and number of entries */\n\t\t++new_manifest_count;\n\t\tphar_add_virtual_dirs(phar, entry->filename, entry->filename_len TSRMLS_CC);\n\n\t\tif (entry->is_dir) {\n\t\t\t/* we use this to calculate API version, 1.1.1 is used for phars with directories */\n\t\t\thas_dirs = 1;\n\t\t}\n\t\tif (entry->metadata) {\n\t\t\tif (entry->metadata_str.c) {\n\t\t\t\tsmart_str_free(&entry->metadata_str);\n\t\t\t}\n\t\t\tentry->metadata_str.c = 0;\n\t\t\tentry->metadata_str.len = 0;\n\t\t\tPHP_VAR_SERIALIZE_INIT(metadata_hash);\n\t\t\tphp_var_serialize(&entry->metadata_str, &entry->metadata, &metadata_hash TSRMLS_CC);\n\t\t\tPHP_VAR_SERIALIZE_DESTROY(metadata_hash);\n\t\t} else {\n\t\t\tif (entry->metadata_str.c) {\n\t\t\t\tsmart_str_free(&entry->metadata_str);\n\t\t\t}\n\t\t\tentry->metadata_str.c = 0;\n\t\t\tentry->metadata_str.len = 0;\n\t\t}\n\n\t\t/* 32 bits for filename length, length of filename, manifest + metadata, and add 1 for trailing / if a directory */\n\t\toffset += 4 + entry->filename_len + sizeof(entry_buffer) + entry->metadata_str.len + (entry->is_dir ? 1 : 0);\n\n\t\t/* compress and rehash as necessary */\n\t\tif ((oldfile && !entry->is_modified) || entry->is_dir) {\n\t\t\tif (entry->fp_type == PHAR_UFP) {\n\t\t\t\t/* reset so we can copy the compressed data over */\n\t\t\t\tentry->fp_type = PHAR_FP;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!phar_get_efp(entry, 0 TSRMLS_CC)) {\n\t\t\t/* re-open internal file pointer just-in-time */\n\t\t\tnewentry = phar_open_jit(phar, entry, error TSRMLS_CC);\n\t\t\tif (!newentry) {\n\t\t\t\t/* major problem re-opening, so we ignore this file and the error */\n\t\t\t\tefree(*error);\n\t\t\t\t*error = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tentry = newentry;\n\t\t}\n\t\tfile = phar_get_efp(entry, 0 TSRMLS_CC);\n\t\tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tnewcrc32 = ~0;\n\t\tmytime = entry->uncompressed_filesize;\n\t\tfor (loc = 0;loc < mytime; ++loc) {\n\t\t\tCRC32(newcrc32, php_stream_getc(file));\n\t\t}\n\t\tentry->crc32 = ~newcrc32;\n\t\tentry->is_crc_checked = 1;\n\t\tif (!(entry->flags & PHAR_ENT_COMPRESSION_MASK)) {\n\t\t\t/* not compressed */\n\t\t\tentry->compressed_filesize = entry->uncompressed_filesize;\n\t\t\tcontinue;\n\t\t}\n\t\tfilter = php_stream_filter_create(phar_compress_filter(entry, 0), NULL, 0 TSRMLS_CC);\n\t\tif (!filter) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (entry->flags & PHAR_ENT_COMPRESSED_GZ) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to gzip compress file \\\"%s\\\" to new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to bzip2 compress file \\\"%s\\\" to new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\t/* create new file that holds the compressed version */\n\t\t/* work around inability to specify freedom in write and strictness\n\t\tin read count */\n\t\tentry->cfp = php_stream_fopen_tmpfile();\n\t\tif (!entry->cfp) {\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to create temporary file\");\n\t\t\t}\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\treturn EOF;\n\t\t}\n\t\tphp_stream_flush(file);\n\t\tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 0 TSRMLS_CC)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tphp_stream_filter_append((&entry->cfp->writefilters), filter);\n\t\tif (SUCCESS != php_stream_copy_to_stream_ex(file, entry->cfp, entry->uncompressed_filesize, NULL)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to copy compressed file contents of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\t\tphp_stream_filter_flush(filter, 1);\n\t\tphp_stream_flush(entry->cfp);\n\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\tphp_stream_seek(entry->cfp, 0, SEEK_END);\n\t\tentry->compressed_filesize = (php_uint32) php_stream_tell(entry->cfp);\n\t\t/* generate crc on compressed file */\n\t\tphp_stream_rewind(entry->cfp);\n\t\tentry->old_flags = entry->flags;\n\t\tentry->is_modified = 1;\n\t\tglobal_flags |= (entry->flags & PHAR_ENT_COMPRESSION_MASK);\n\t}\n\tglobal_flags |= PHAR_HDR_SIGNATURE;\n\n\t/* write out manifest pre-header */\n\t/*  4: manifest length\n\t *  4: manifest entry count\n\t *  2: phar version\n\t *  4: phar global flags\n\t *  4: alias length\n\t *  ?: the alias itself\n\t *  4: phar metadata length\n\t *  ?: phar metadata\n\t */\n\trestore_alias_len = phar->alias_len;\n\tif (phar->is_temporary_alias) {\n\t\tphar->alias_len = 0;\n\t}\n\n\tmanifest_len = offset + phar->alias_len + sizeof(manifest) + main_metadata_str.len;\n\tphar_set_32(manifest, manifest_len);\n\t/* Hack - see bug #65028, add padding byte to the end of the manifest */\n\tif(manifest[0] == '\\r' || manifest[0] == '\\n') {\n\t\tmanifest_len++;\n\t\tphar_set_32(manifest, manifest_len);\n\t\tmanifest_hack = 1;\n\t}\n\tphar_set_32(manifest+4, new_manifest_count);\n\tif (has_dirs) {\n\t\t*(manifest + 8) = (unsigned char) (((PHAR_API_VERSION) >> 8) & 0xFF);\n\t\t*(manifest + 9) = (unsigned char) (((PHAR_API_VERSION) & 0xF0));\n\t} else {\n\t\t*(manifest + 8) = (unsigned char) (((PHAR_API_VERSION_NODIR) >> 8) & 0xFF);\n\t\t*(manifest + 9) = (unsigned char) (((PHAR_API_VERSION_NODIR) & 0xF0));\n\t}\n\tphar_set_32(manifest+10, global_flags);\n\tphar_set_32(manifest+14, phar->alias_len);\n\n\t/* write the manifest header */\n\tif (sizeof(manifest) != php_stream_write(newfile, manifest, sizeof(manifest))\n\t|| (size_t)phar->alias_len != php_stream_write(newfile, phar->alias, phar->alias_len)) {\n\n\t\tif (closeoldfile) {\n\t\t\tphp_stream_close(oldfile);\n\t\t}\n\n\t\tphp_stream_close(newfile);\n\t\tphar->alias_len = restore_alias_len;\n\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to write manifest header of new phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\n\t\treturn EOF;\n\t}\n\n\tphar->alias_len = restore_alias_len;\n\n\tphar_set_32(manifest, main_metadata_str.len);\n\tif (4 != php_stream_write(newfile, manifest, 4) || (main_metadata_str.len\n\t&& main_metadata_str.len != php_stream_write(newfile, main_metadata_str.c, main_metadata_str.len))) {\n\t\tsmart_str_free(&main_metadata_str);\n\n\t\tif (closeoldfile) {\n\t\t\tphp_stream_close(oldfile);\n\t\t}\n\n\t\tphp_stream_close(newfile);\n\t\tphar->alias_len = restore_alias_len;\n\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to write manifest meta-data of new phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\n\t\treturn EOF;\n\t}\n\tsmart_str_free(&main_metadata_str);\n\n\t/* re-calculate the manifest location to simplify later code */\n\tmanifest_ftell = php_stream_tell(newfile);\n\n\t/* now write the manifest */\n\tfor (zend_hash_internal_pointer_reset(&phar->manifest);\n\t\tzend_hash_has_more_elements(&phar->manifest) == SUCCESS;\n\t\tzend_hash_move_forward(&phar->manifest)) {\n\n\t\tif (zend_hash_get_current_data(&phar->manifest, (void **)&entry) == FAILURE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->is_deleted || entry->is_mounted) {\n\t\t\t/* remove this from the new phar if deleted, ignore if mounted */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->is_dir) {\n\t\t\t/* add 1 for trailing slash */\n\t\t\tphar_set_32(entry_buffer, entry->filename_len + 1);\n\t\t} else {\n\t\t\tphar_set_32(entry_buffer, entry->filename_len);\n\t\t}\n\n\t\tif (4 != php_stream_write(newfile, entry_buffer, 4)\n\t\t|| entry->filename_len != php_stream_write(newfile, entry->filename, entry->filename_len)\n\t\t|| (entry->is_dir && 1 != php_stream_write(newfile, \"/\", 1))) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tif (entry->is_dir) {\n\t\t\t\t\tspprintf(error, 0, \"unable to write filename of directory \\\"%s\\\" to manifest of new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t} else {\n\t\t\t\t\tspprintf(error, 0, \"unable to write filename of file \\\"%s\\\" to manifest of new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\t/* set the manifest meta-data:\n\t\t\t4: uncompressed filesize\n\t\t\t4: creation timestamp\n\t\t\t4: compressed filesize\n\t\t\t4: crc32\n\t\t\t4: flags\n\t\t\t4: metadata-len\n\t\t\t+: metadata\n\t\t*/\n\t\tmytime = time(NULL);\n\t\tphar_set_32(entry_buffer, entry->uncompressed_filesize);\n\t\tphar_set_32(entry_buffer+4, mytime);\n\t\tphar_set_32(entry_buffer+8, entry->compressed_filesize);\n\t\tphar_set_32(entry_buffer+12, entry->crc32);\n\t\tphar_set_32(entry_buffer+16, entry->flags);\n\t\tphar_set_32(entry_buffer+20, entry->metadata_str.len);\n\n\t\tif (sizeof(entry_buffer) != php_stream_write(newfile, entry_buffer, sizeof(entry_buffer))\n\t\t|| entry->metadata_str.len != php_stream_write(newfile, entry->metadata_str.c, entry->metadata_str.len)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\n\t\t\tphp_stream_close(newfile);\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to write temporary manifest of file \\\"%s\\\" to manifest of new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\n\t\t\treturn EOF;\n\t\t}\n\t}\n\t/* Hack - see bug #65028, add padding byte to the end of the manifest */\n\tif(manifest_hack) {\n\t\tif(1 != php_stream_write(newfile, manifest, 1)) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\n\t\t\tphp_stream_close(newfile);\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to write manifest padding byte\");\n\t\t\t}\n\n\t\t\treturn EOF;\n\t\t}\n\t}\n\n\t/* now copy the actual file data to the new phar */\n\toffset = php_stream_tell(newfile);\n\tfor (zend_hash_internal_pointer_reset(&phar->manifest);\n\t\tzend_hash_has_more_elements(&phar->manifest) == SUCCESS;\n\t\tzend_hash_move_forward(&phar->manifest)) {\n\n\t\tif (zend_hash_get_current_data(&phar->manifest, (void **)&entry) == FAILURE) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->is_deleted || entry->is_dir || entry->is_mounted) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (entry->cfp) {\n\t\t\tfile = entry->cfp;\n\t\t\tphp_stream_rewind(file);\n\t\t} else {\n\t\t\tfile = phar_get_efp(entry, 0 TSRMLS_CC);\n\t\t\tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 0 TSRMLS_CC)) {\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\t\t}\n\n\t\tif (!file) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\t\t\tphp_stream_close(newfile);\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to seek to start of file \\\"%s\\\" while creating new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\t/* this will have changed for all files that have either changed compression or been modified */\n\t\tentry->offset = entry->offset_abs = offset;\n\t\toffset += entry->compressed_filesize;\n\t\tif (php_stream_copy_to_stream_ex(file, newfile, entry->compressed_filesize, &wrote) == FAILURE) {\n\t\t\tif (closeoldfile) {\n\t\t\t\tphp_stream_close(oldfile);\n\t\t\t}\n\n\t\t\tphp_stream_close(newfile);\n\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 0, \"unable to write contents of file \\\"%s\\\" to new phar \\\"%s\\\"\", entry->filename, phar->fname);\n\t\t\t}\n\n\t\t\treturn EOF;\n\t\t}\n\n\t\tentry->is_modified = 0;\n\n\t\tif (entry->cfp) {\n\t\t\tphp_stream_close(entry->cfp);\n\t\t\tentry->cfp = NULL;\n\t\t}\n\n\t\tif (entry->fp_type == PHAR_MOD) {\n\t\t\t/* this fp is in use by a phar_entry_data returned by phar_get_entry_data, it will be closed when the phar_entry_data is phar_entry_delref'ed */\n\t\t\tif (entry->fp_refcount == 0 && entry->fp != phar->fp && entry->fp != phar->ufp) {\n\t\t\t\tphp_stream_close(entry->fp);\n\t\t\t}\n\n\t\t\tentry->fp = NULL;\n\t\t\tentry->fp_type = PHAR_FP;\n\t\t} else if (entry->fp_type == PHAR_UFP) {\n\t\t\tentry->fp_type = PHAR_FP;\n\t\t}\n\t}\n\n\t/* append signature */\n\tif (global_flags & PHAR_HDR_SIGNATURE) {\n\t\tchar sig_buf[4];\n\n\t\tphp_stream_rewind(newfile);\n\n\t\tif (phar->signature) {\n\t\t\tefree(phar->signature);\n\t\t\tphar->signature = NULL;\n\t\t}\n\n\t\tswitch(phar->sig_flags) {\n#ifndef PHAR_HASH_OK\n\t\t\tcase PHAR_SIG_SHA512:\n\t\t\tcase PHAR_SIG_SHA256:\n\t\t\t\tif (closeoldfile) {\n\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t}\n\t\t\t\tphp_stream_close(newfile);\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 0, \"unable to write contents of file \\\"%s\\\" to new phar \\\"%s\\\" with requested hash type\", entry->filename, phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n#endif\n\t\t\tdefault: {\n\t\t\t\tchar *digest = NULL;\n\t\t\t\tint digest_len;\n\n\t\t\t\tif (FAILURE == phar_create_signature(phar, newfile, &digest, &digest_len, error TSRMLS_CC)) {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tchar *save = *error;\n\t\t\t\t\t\tspprintf(error, 0, \"phar error: unable to write signature: %s\", save);\n\t\t\t\t\t\tefree(save);\n\t\t\t\t\t}\n\t\t\t\t\tif (digest) {\n\t\t\t\t\t\tefree(digest);\n\t\t\t\t\t}\n\t\t\t\t\tif (closeoldfile) {\n\t\t\t\t\t\tphp_stream_close(oldfile);\n\t\t\t\t\t}\n\t\t\t\t\tphp_stream_close(newfile);\n\t\t\t\t\treturn EOF;\n\t\t\t\t}\n\n\t\t\t\tphp_stream_write(newfile, digest, digest_len);\n\t\t\t\tefree(digest);\n\t\t\t\tif (phar->sig_flags == PHAR_SIG_OPENSSL) {\n\t\t\t\t\tphar_set_32(sig_buf, digest_len);\n\t\t\t\t\tphp_stream_write(newfile, sig_buf, 4);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tphar_set_32(sig_buf, phar->sig_flags);\n\t\tphp_stream_write(newfile, sig_buf, 4);\n\t\tphp_stream_write(newfile, \"GBMB\", 4);\n\t}\n\n\t/* finally, close the temp file, rename the original phar,\n\t   move the temp to the old phar, unlink the old phar, and reload it into memory\n\t*/\n\tif (phar->fp && free_fp) {\n\t\tphp_stream_close(phar->fp);\n\t}\n\n\tif (phar->ufp) {\n\t\tif (free_ufp) {\n\t\t\tphp_stream_close(phar->ufp);\n\t\t}\n\t\tphar->ufp = NULL;\n\t}\n\n\tif (closeoldfile) {\n\t\tphp_stream_close(oldfile);\n\t}\n\n\tphar->internal_file_start = halt_offset + manifest_len + 4;\n\tphar->halt_offset = halt_offset;\n\tphar->is_brandnew = 0;\n\n\tphp_stream_rewind(newfile);\n\n\tif (phar->donotflush) {\n\t\t/* deferred flush */\n\t\tphar->fp = newfile;\n\t} else {\n\t\tphar->fp = php_stream_open_wrapper(phar->fname, \"w+b\", IGNORE_URL|STREAM_MUST_SEEK|REPORT_ERRORS, NULL);\n\t\tif (!phar->fp) {\n\t\t\tphar->fp = newfile;\n\t\t\tif (error) {\n\t\t\t\tspprintf(error, 4096, \"unable to open new phar \\\"%s\\\" for writing\", phar->fname);\n\t\t\t}\n\t\t\treturn EOF;\n\t\t}\n\n\t\tif (phar->flags & PHAR_FILE_COMPRESSED_GZ) {\n\t\t\t/* to properly compress, we have to tell zlib to add a zlib header */\n\t\t\tzval filterparams;\n\n\t\t\tarray_init(&filterparams);\n\t\t\tadd_assoc_long(&filterparams, \"window\", MAX_WBITS+16);\n\t\t\tfilter = php_stream_filter_create(\"zlib.deflate\", &filterparams, php_stream_is_persistent(phar->fp) TSRMLS_CC);\n\t\t\tzval_dtor(&filterparams);\n\n\t\t\tif (!filter) {\n\t\t\t\tif (error) {\n\t\t\t\t\tspprintf(error, 4096, \"unable to compress all contents of phar \\\"%s\\\" using zlib, PHP versions older than 5.2.6 have a buggy zlib\", phar->fname);\n\t\t\t\t}\n\t\t\t\treturn EOF;\n\t\t\t}\n\n\t\t\tphp_stream_filter_append(&phar->fp->writefilters, filter);\n\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\tphp_stream_close(phar->fp);\n\t\t\t/* use the temp stream as our base */\n\t\t\tphar->fp = newfile;\n\t\t} else if (phar->flags & PHAR_FILE_COMPRESSED_BZ2) {\n\t\t\tfilter = php_stream_filter_create(\"bzip2.compress\", NULL, php_stream_is_persistent(phar->fp) TSRMLS_CC);\n\t\t\tphp_stream_filter_append(&phar->fp->writefilters, filter);\n\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\tphp_stream_filter_flush(filter, 1);\n\t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);\n\t\t\tphp_stream_close(phar->fp);\n\t\t\t/* use the temp stream as our base */\n\t\t\tphar->fp = newfile;\n\t\t} else {\n\t\t\tphp_stream_copy_to_stream_ex(newfile, phar->fp, PHP_STREAM_COPY_ALL, NULL);\n\t\t\t/* we could also reopen the file in \"rb\" mode but there is no need for that */\n\t\t\tphp_stream_close(newfile);\n\t\t}\n\t}\n\n\tif (-1 == php_stream_seek(phar->fp, phar->halt_offset, SEEK_SET)) {\n\t\tif (error) {\n\t\t\tspprintf(error, 0, \"unable to seek to __HALT_COMPILER(); in new phar \\\"%s\\\"\", phar->fname);\n\t\t}\n\t\treturn EOF;\n\t}\n\n\treturn EOF;\n}\n/* }}} */\n\n#ifdef COMPILE_DL_PHAR\nZEND_GET_MODULE(phar)\n#endif\n\n/* {{{ phar_functions[]\n *\n * Every user visible function must have an entry in phar_functions[].\n */\nzend_function_entry phar_functions[] = {\n\tPHP_FE_END\n};\n/* }}}*/\n\nstatic size_t phar_zend_stream_reader(void *handle, char *buf, size_t len TSRMLS_DC) /* {{{ */\n{\n\treturn php_stream_read(phar_get_pharfp((phar_archive_data*)handle TSRMLS_CC), buf, len);\n}\n/* }}} */\n\nstatic size_t phar_zend_stream_fsizer(void *handle TSRMLS_DC) /* {{{ */\n{\n\treturn ((phar_archive_data*)handle)->halt_offset + 32;\n} /* }}} */\n\nzend_op_array *(*phar_orig_compile_file)(zend_file_handle *file_handle, int type TSRMLS_DC);\n#define phar_orig_zend_open zend_stream_open_function\n\nstatic char *phar_resolve_path(const char *filename, int filename_len TSRMLS_DC)\n{\n\treturn phar_find_in_include_path((char *) filename, filename_len, NULL TSRMLS_CC);\n}\n\nstatic zend_op_array *phar_compile_file(zend_file_handle *file_handle, int type TSRMLS_DC) /* {{{ */\n{\n\tzend_op_array *res;\n\tchar *name = NULL;\n\tint failed;\n\tphar_archive_data *phar;\n\n\tif (!file_handle || !file_handle->filename) {\n\t\treturn phar_orig_compile_file(file_handle, type TSRMLS_CC);\n\t}\n\tif (strstr(file_handle->filename, \".phar\") && !strstr(file_handle->filename, \"://\")) {\n\t\tif (SUCCESS == phar_open_from_filename((char*)file_handle->filename, strlen(file_handle->filename), NULL, 0, 0, &phar, NULL TSRMLS_CC)) {\n\t\t\tif (phar->is_zip || phar->is_tar) {\n\t\t\t\tzend_file_handle f = *file_handle;\n\n\t\t\t\t/* zip or tar-based phar */\n\t\t\t\tspprintf(&name, 4096, \"phar://%s/%s\", file_handle->filename, \".phar/stub.php\");\n\t\t\t\tif (SUCCESS == phar_orig_zend_open((const char *)name, file_handle TSRMLS_CC)) {\n\t\t\t\t\tefree(name);\n\t\t\t\t\tname = NULL;\n\t\t\t\t\tfile_handle->filename = f.filename;\n\t\t\t\t\tif (file_handle->opened_path) {\n\t\t\t\t\t\tefree(file_handle->opened_path);\n\t\t\t\t\t}\n\t\t\t\t\tfile_handle->opened_path = f.opened_path;\n\t\t\t\t\tfile_handle->free_filename = f.free_filename;\n\t\t\t\t} else {\n\t\t\t\t\t*file_handle = f;\n\t\t\t\t}\n\t\t\t} else if (phar->flags & PHAR_FILE_COMPRESSION_MASK) {\n\t\t\t\t/* compressed phar */\n\t\t\t\tfile_handle->type = ZEND_HANDLE_STREAM;\n\t\t\t\t/* we do our own reading directly from the phar, don't change the next line */\n\t\t\t\tfile_handle->handle.stream.handle  = phar;\n\t\t\t\tfile_handle->handle.stream.reader  = phar_zend_stream_reader;\n\t\t\t\tfile_handle->handle.stream.closer  = NULL;\n\t\t\t\tfile_handle->handle.stream.fsizer  = phar_zend_stream_fsizer;\n\t\t\t\tfile_handle->handle.stream.isatty  = 0;\n\t\t\t\tphar->is_persistent ?\n\t\t\t\t\tphp_stream_rewind(PHAR_GLOBALS->cached_fp[phar->phar_pos].fp) :\n\t\t\t\t\tphp_stream_rewind(phar->fp);\n\t\t\t\tmemset(&file_handle->handle.stream.mmap, 0, sizeof(file_handle->handle.stream.mmap));\n\t\t\t}\n\t\t}\n\t}\n\n\tzend_try {\n\t\tfailed = 0;\n\t\tCG(zend_lineno) = 0;\n\t\tres = phar_orig_compile_file(file_handle, type TSRMLS_CC);\n\t} zend_catch {\n\t\tfailed = 1;\n\t\tres = NULL;\n\t} zend_end_try();\n```\n \n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.30-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_b28b8b2fee6dfa6fcd13305c581bb835689ac3be More .INIs : CWD : /out/php___php-src/git_repo_dir_b28b8b2fee6dfa6fcd13305c581bb835689ac3be Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/phar/tests/bug73768.phpt]\rFAIL Phar: PHP bug #73768: Memory corruption when loading hostile phar [ext/phar/tests/bug73768.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Phar: PHP bug #73768: Memory corruption when loading hostile phar [ext/phar/tests/bug73768.phpt] =====================================================================\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "b28b8b2fee6dfa6fcd13305c581bb835689ac3be___phar.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t*pce;\n\tzval\t\t\t\tobj;\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp((char *)name, EL_STRING) || !strcmp((char *)name, EL_NUMBER) ||\n\t\t!strcmp((char *)name, EL_BOOLEAN) || !strcmp((char *)name, EL_NULL) ||\n\t  \t!strcmp((char *)name, EL_ARRAY) || !strcmp((char *)name, EL_STRUCT) ||\n\t\t!strcmp((char *)name, EL_RECORDSET) || !strcmp((char *)name, EL_BINARY) ||\n\t\t!strcmp((char *)name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (Z_TYPE(ent1->data) == IS_UNDEF) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t\tefree(ent1);\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp((char *)name, EL_BINARY)) {\n\t\t\tzend_string *new_str = NULL;\n\t\t\t\n\t\t\tif (ZSTR_EMPTY_ALLOC() != Z_STR(ent1->data)) {\n\t\t\t\tnew_str = php_base64_decode(\n\t\t\t\t\t(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t}\n\n\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\tif (new_str) {\n\t\t\t\tZVAL_STR(&ent1->data, new_str);\n\t\t\t} else {\n\t\t\t\tZVAL_EMPTY_STRING(&ent1->data);\n\t\t\t}\n\t\t}\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE(ent1->data) == IS_OBJECT) {\n\t\t\tzval fname, retval;\n\n\t\t\tZVAL_STRING(&fname, \"__wakeup\");\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, &fname, &retval, 0, 0, 0, NULL);\n\n\t\t\tzval_ptr_dtor(&fname);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (Z_ISUNDEF(ent2->data)) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE(ent2->data) == IS_ARRAY || Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(&ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE(ent1->data) == IS_STRING && Z_STRLEN(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\tzend_string_forget_hash_val(Z_STR(ent1->data));\n\t\t\t\t\t\tif ((pce = zend_hash_find_ptr(EG(class_table), Z_STR(ent1->data))) == NULL) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (pce != PHP_IC_ENTRY && (pce->serialize || pce->unserialize)) {\n\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\t\t\t\t\t\t\tZVAL_UNDEF(&ent2->data);\n\t\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Class %s can not be unserialized\", Z_STRVAL(ent1->data));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\t\tobject_init_ex(&obj, pce);\n\n\t\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP(obj),\n\t\t\t\t\t\t\t\t\t\t\tZ_ARRVAL(ent2->data),\n\t\t\t\t\t\t\t\t\t\t\tzval_add_ref, 0);\n\n\t\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\t\tphp_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\t\tZVAL_COPY_VALUE(&ent2->data, &obj);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE(ent2->data);\n\t\t\t\t\t\tadd_property_zval(&ent2->data, ent1->varname, &ent1->data);\n\t\t\t\t\t\tif Z_REFCOUNTED(ent1->data) Z_DELREF(ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_str_update(target_hash, ent1->varname, strlen(ent1->varname), &ent1->data);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp((char *)name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp((char *)name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}\n}\n```\n \n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 7.0.15-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_8d2539fa0faf3f63e1d1e7635347c5b9e777d47b More .INIs : --------------------------------------------------------------------- PHP : /out/php___php-src/git_repo_dir_8d2539fa0faf3f63e1d1e7635347c5b9e777d47b/sapi/phpdbg/phpdbg PHP_SAPI : phpdbg PHP_VERSION : 7.0.15-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_8d2539fa0faf3f63e1d1e7635347c5b9e777d47b More .INIs : --------------------------------------------------------------------- CWD : /out/php___php-src/git_repo_dir_8d2539fa0faf3f63e1d1e7635347c5b9e777d47b Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. FAIL Bug #73831 (NULL Pointer Dereference while unserialize php object) [ext/wddx/tests/bug73831.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 1 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #73831 (NULL Pointer Dereference while unserialize php object) [ext/wddx/tests/bug73831.phpt] =====================================================================\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "8d2539fa0faf3f63e1d1e7635347c5b9e777d47b___wddx.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)\n{\n\tchar *colon;\n\tchar *host = NULL;\n\n#ifdef HAVE_IPV6\n\tchar *p;\n\n\tif (*(str) == '[' && str_len > 1) {\n\t\t/* IPV6 notation to specify raw address with port (i.e. [fe80::1]:80) */\n\t\tp = memchr(str + 1, ']', str_len - 2);\n\t\tif (!p || *(p + 1) != ':') {\n\t\t\tif (get_err) {\n\t\t\t\t*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\t*portno = atoi(p + 2);\n\t\treturn estrndup(str + 1, p - str - 1);\n\t}\n#endif\n\tif (str_len) {\n\t\tcolon = memchr(str, ':', str_len - 1);\n\t} else {\n\t\tcolon = NULL;\n\t}\n\tif (colon) {\n\t\t*portno = atoi(colon + 1);\n\t\thost = estrndup(str, colon - str);\n\t} else {\n\t\tif (get_err) {\n\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\treturn host;\n}\n```\n \n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 7.0.18-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_bab0b99f376dac9170ac81382a5ed526938d595a More .INIs : --------------------------------------------------------------------- PHP : /out/php___php-src/git_repo_dir_bab0b99f376dac9170ac81382a5ed526938d595a/sapi/phpdbg/phpdbg PHP_SAPI : phpdbg PHP_VERSION : 7.0.18-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_bab0b99f376dac9170ac81382a5ed526938d595a More .INIs : --------------------------------------------------------------------- CWD : /out/php___php-src/git_repo_dir_bab0b99f376dac9170ac81382a5ed526938d595a Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. FAIL Use of double-port in fsockopen() [ext/standard/tests/streams/parseip-001.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Use of double-port in fsockopen() [ext/standard/tests/streams/parseip-001.phpt] =====================================================================\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "bab0b99f376dac9170ac81382a5ed526938d595a___xp_socket.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nphp_stream *php_stream_url_wrap_http_ex(php_stream_wrapper *wrapper, \n\t\tconst char *path, const char *mode, int options, char **opened_path, \n\t\tphp_stream_context *context, int redirect_max, int flags STREAMS_DC TSRMLS_DC) /* {{{ */\n{\n\tphp_stream *stream = NULL;\n\tphp_url *resource = NULL;\n\tint use_ssl;\n\tint use_proxy = 0;\n\tchar *scratch = NULL;\n\tchar *tmp = NULL;\n\tchar *ua_str = NULL;\n\tzval **ua_zval = NULL, **tmpzval = NULL, *ssl_proxy_peer_name = NULL;\n\tint scratch_len = 0;\n\tint body = 0;\n\tchar location[HTTP_HEADER_BLOCK_SIZE];\n\tzval *response_header = NULL;\n\tint reqok = 0;\n\tchar *http_header_line = NULL;\n\tchar tmp_line[128];\n\tsize_t chunk_size = 0, file_size = 0;\n\tint eol_detect = 0;\n\tchar *transport_string, *errstr = NULL;\n\tint transport_len, have_header = 0, request_fulluri = 0, ignore_errors = 0;\n\tchar *protocol_version = NULL;\n\tint protocol_version_len = 3; /* Default: \"1.0\" */\n\tstruct timeval timeout;\n\tchar *user_headers = NULL;\n\tint header_init = ((flags & HTTP_WRAPPER_HEADER_INIT) != 0);\n\tint redirected = ((flags & HTTP_WRAPPER_REDIRECTED) != 0);\n\tint follow_location = 1;\n\tphp_stream_filter *transfer_encoding = NULL;\n\tint response_code;\n\n\ttmp_line[0] = '\\0';\n\n\tif (redirect_max < 1) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Redirection limit reached, aborting\");\n\t\treturn NULL;\n\t}\n\n\tresource = php_url_parse(path);\n\tif (resource == NULL) {\n\t\treturn NULL;\n\t}\n\n\tif (strncasecmp(resource->scheme, \"http\", sizeof(\"http\")) && strncasecmp(resource->scheme, \"https\", sizeof(\"https\"))) {\n\t\tif (!context ||\n\t\t\tphp_stream_context_get_option(context, wrapper->wops->label, \"proxy\", &tmpzval) == FAILURE ||\n\t\t\tZ_TYPE_PP(tmpzval) != IS_STRING ||\n\t\t\tZ_STRLEN_PP(tmpzval) <= 0) {\n\t\t\tphp_url_free(resource);\n\t\t\treturn php_stream_open_wrapper_ex(path, mode, REPORT_ERRORS, NULL, context);\n\t\t}\n\t\t/* Called from a non-http wrapper with http proxying requested (i.e. ftp) */\n\t\trequest_fulluri = 1;\n\t\tuse_ssl = 0;\n\t\tuse_proxy = 1;\n\n\t\ttransport_len = Z_STRLEN_PP(tmpzval);\n\t\ttransport_string = estrndup(Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval));\n\t} else {\n\t\t/* Normal http request (possibly with proxy) */\n\n\t\tif (strpbrk(mode, \"awx+\")) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP wrapper does not support writeable connections\");\n\t\t\tphp_url_free(resource);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuse_ssl = resource->scheme && (strlen(resource->scheme) > 4) && resource->scheme[4] == 's';\n\t\t/* choose default ports */\n\t\tif (use_ssl && resource->port == 0)\n\t\t\tresource->port = 443;\n\t\telse if (resource->port == 0)\n\t\t\tresource->port = 80;\n\n\t\tif (context &&\n\t\t\tphp_stream_context_get_option(context, wrapper->wops->label, \"proxy\", &tmpzval) == SUCCESS &&\n\t\t\tZ_TYPE_PP(tmpzval) == IS_STRING &&\n\t\t\tZ_STRLEN_PP(tmpzval) > 0) {\n\t\t\tuse_proxy = 1;\n\t\t\ttransport_len = Z_STRLEN_PP(tmpzval);\n\t\t\ttransport_string = estrndup(Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval));\n\t\t} else {\n\t\t\ttransport_len = spprintf(&transport_string, 0, \"%s://%s:%d\", use_ssl ? \"ssl\" : \"tcp\", resource->host, resource->port);\n\t\t}\n\t}\n\n\tif (context && php_stream_context_get_option(context, wrapper->wops->label, \"timeout\", &tmpzval) == SUCCESS) {\n\t\tSEPARATE_ZVAL(tmpzval);\n\t\tconvert_to_double_ex(tmpzval);\n\t\ttimeout.tv_sec = (time_t) Z_DVAL_PP(tmpzval);\n\t\ttimeout.tv_usec = (size_t) ((Z_DVAL_PP(tmpzval) - timeout.tv_sec) * 1000000);\n\t} else {\n\t\ttimeout.tv_sec = FG(default_socket_timeout);\n\t\ttimeout.tv_usec = 0;\n\t}\n\n\tstream = php_stream_xport_create(transport_string, transport_len, options,\n\t\t\tSTREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT,\n\t\t\tNULL, &timeout, context, &errstr, NULL);\n\n\tif (stream) {\n\t\tphp_stream_set_option(stream, PHP_STREAM_OPTION_READ_TIMEOUT, 0, &timeout);\n\t}\n\n\tif (errstr) {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"%s\", errstr);\n\t\tefree(errstr);\n\t\terrstr = NULL;\n\t}\n\n\tefree(transport_string);\n\n\tif (stream && use_proxy && use_ssl) {\n\t\tsmart_str header = {0};\n\n\t\t/* Set peer_name or name verification will try to use the proxy server name */\n\t\tif (!context || php_stream_context_get_option(context, \"ssl\", \"peer_name\", &tmpzval) == FAILURE) {\n\t\t\tMAKE_STD_ZVAL(ssl_proxy_peer_name);\n\t\t\tZVAL_STRING(ssl_proxy_peer_name, resource->host, 1);\n\t\t\tphp_stream_context_set_option(stream->context, \"ssl\", \"peer_name\", ssl_proxy_peer_name);\n\t\t}\n\n\t\tsmart_str_appendl(&header, \"CONNECT \", sizeof(\"CONNECT \")-1);\n\t\tsmart_str_appends(&header, resource->host);\n\t\tsmart_str_appendc(&header, ':');\n\t\tsmart_str_append_unsigned(&header, resource->port);\n\t\tsmart_str_appendl(&header, \" HTTP/1.0\\r\\n\", sizeof(\" HTTP/1.0\\r\\n\")-1);\n\n\t    /* check if we have Proxy-Authorization header */\n\t\tif (context && php_stream_context_get_option(context, \"http\", \"header\", &tmpzval) == SUCCESS) {\n\t\t\tchar *s, *p;\n\n\t\t\tif (Z_TYPE_PP(tmpzval) == IS_ARRAY) {\n\t\t\t\tHashPosition pos;\n\t\t\t\tzval **tmpheader = NULL;\n\n\t\t\t\tfor (zend_hash_internal_pointer_reset_ex(Z_ARRVAL_PP(tmpzval), &pos);\n\t\t\t\t\tSUCCESS == zend_hash_get_current_data_ex(Z_ARRVAL_PP(tmpzval), (void *)&tmpheader, &pos);\n\t\t\t\t\tzend_hash_move_forward_ex(Z_ARRVAL_PP(tmpzval), &pos)) {\n\t\t\t\t\tif (Z_TYPE_PP(tmpheader) == IS_STRING) {\n\t\t\t\t\t\ts = Z_STRVAL_PP(tmpheader);\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\twhile (*s == ' ' || *s == '\\t') s++;\n\t\t\t\t\t\t\tp = s;\n\t\t\t\t\t\t\twhile (*p != 0 && *p != ':' && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\tif (*p == ':') {\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\tif (p - s == sizeof(\"Proxy-Authorization:\") - 1 &&\n\t\t\t\t\t\t\t\t    zend_binary_strcasecmp(s, sizeof(\"Proxy-Authorization:\") - 1,\n\t\t\t\t\t\t\t\t        \"Proxy-Authorization:\", sizeof(\"Proxy-Authorization:\") - 1) == 0) {\n\t\t\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\t\t\tsmart_str_appendl(&header, s, p - s);\n\t\t\t\t\t\t\t\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\t\t\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts = p;\n\t\t\t\t\t\t\twhile (*s == '\\r' || *s == '\\n') s++;\n\t\t\t\t\t\t} while (*s != 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (Z_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval)) {\n\t\t\t\ts = Z_STRVAL_PP(tmpzval);\n\t\t\t\tdo {\n\t\t\t\t\twhile (*s == ' ' || *s == '\\t') s++;\n\t\t\t\t\tp = s;\n\t\t\t\t\twhile (*p != 0 && *p != ':' && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\tif (*p == ':') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tif (p - s == sizeof(\"Proxy-Authorization:\") - 1 &&\n\t\t\t\t\t\t    zend_binary_strcasecmp(s, sizeof(\"Proxy-Authorization:\") - 1,\n\t\t\t\t\t\t        \"Proxy-Authorization:\", sizeof(\"Proxy-Authorization:\") - 1) == 0) {\n\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t\tsmart_str_appendl(&header, s, p - s);\n\t\t\t\t\t\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\t\t\t\t\t\tgoto finish;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhile (*p != 0 && *p != '\\r' && *p !='\\n') p++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ts = p;\n\t\t\t\t\twhile (*s == '\\r' || *s == '\\n') s++;\n\t\t\t\t} while (*s != 0);\n\t\t\t}\n\t\t}\nfinish:\n\t\tsmart_str_appendl(&header, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\n\t\tif (php_stream_write(stream, header.c, header.len) != header.len) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Cannot connect to HTTPS server through proxy\");\n\t\t\tphp_stream_close(stream);\n\t\t\tstream = NULL;\n\t\t}\n \t \tsmart_str_free(&header);\n\n \t \tif (stream) {\n \t \t\tchar header_line[HTTP_HEADER_BLOCK_SIZE];\n\n\t\t\t/* get response header */\n\t\t\twhile (php_stream_gets(stream, header_line, HTTP_HEADER_BLOCK_SIZE-1) != NULL) {\n\t\t\t\tif (header_line[0] == '\\n' ||\n\t\t\t\t    header_line[0] == '\\r' ||\n\t\t\t\t    header_line[0] == '\\0') {\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* enable SSL transport layer */\n\t\tif (stream) {\n\t\t\tif (php_stream_xport_crypto_setup(stream, STREAM_CRYPTO_METHOD_SSLv23_CLIENT, NULL TSRMLS_CC) < 0 ||\n\t\t\t    php_stream_xport_crypto_enable(stream, 1 TSRMLS_CC) < 0) {\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Cannot connect to HTTPS server through proxy\");\n\t\t\t\tphp_stream_close(stream);\n\t\t\t\tstream = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stream == NULL)\n\t\tgoto out;\n\n\t/* avoid buffering issues while reading header */\n\tif (options & STREAM_WILL_CAST)\n\t\tchunk_size = php_stream_set_chunk_size(stream, 1);\n\n\t/* avoid problems with auto-detecting when reading the headers -> the headers\n\t * are always in canonical \\r\\n format */\n\teol_detect = stream->flags & (PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC);\n\tstream->flags &= ~(PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC);\n\n\tphp_stream_context_set(stream, context);\n\n\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_CONNECT, NULL, 0);\n\n\tif (header_init && context && php_stream_context_get_option(context, \"http\", \"max_redirects\", &tmpzval) == SUCCESS) {\n\t\tSEPARATE_ZVAL(tmpzval);\n\t\tconvert_to_long_ex(tmpzval);\n\t\tredirect_max = Z_LVAL_PP(tmpzval);\n\t}\n\n\tif (context && php_stream_context_get_option(context, \"http\", \"method\", &tmpzval) == SUCCESS) {\n\t\tif (Z_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval) > 0) {\n\t\t\t/* As per the RFC, automatically redirected requests MUST NOT use other methods than\n\t\t\t * GET and HEAD unless it can be confirmed by the user */\n\t\t\tif (!redirected\n\t\t\t\t|| (Z_STRLEN_PP(tmpzval) == 3 && memcmp(\"GET\", Z_STRVAL_PP(tmpzval), 3) == 0)\n\t\t\t\t|| (Z_STRLEN_PP(tmpzval) == 4 && memcmp(\"HEAD\",Z_STRVAL_PP(tmpzval), 4) == 0)\n\t\t\t) {\n\t\t\t\tscratch_len = strlen(path) + 29 + Z_STRLEN_PP(tmpzval);\n\t\t\t\tscratch = emalloc(scratch_len);\n\t\t\t\tstrlcpy(scratch, Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval) + 1);\n\t\t\t\tstrncat(scratch, \" \", 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (context && php_stream_context_get_option(context, \"http\", \"protocol_version\", &tmpzval) == SUCCESS) {\n\t\tSEPARATE_ZVAL(tmpzval);\n\t\tconvert_to_double_ex(tmpzval);\n\t\tprotocol_version_len = spprintf(&protocol_version, 0, \"%.1F\", Z_DVAL_PP(tmpzval));\n\t}\n\n\tif (!scratch) {\n\t\tscratch_len = strlen(path) + 29 + protocol_version_len;\n\t\tscratch = emalloc(scratch_len);\n\t\tstrncpy(scratch, \"GET \", scratch_len);\n\t}\n\n\t/* Should we send the entire path in the request line, default to no. */\n\tif (!request_fulluri &&\n\t\tcontext &&\n\t\tphp_stream_context_get_option(context, \"http\", \"request_fulluri\", &tmpzval) == SUCCESS) {\n\t\tzval ztmp = **tmpzval;\n\n\t\tzval_copy_ctor(&ztmp);\n\t\tconvert_to_boolean(&ztmp);\n\t\trequest_fulluri = Z_BVAL(ztmp) ? 1 : 0;\n\t\tzval_dtor(&ztmp);\n\t}\n\n\tif (request_fulluri) {\n\t\t/* Ask for everything */\n\t\tstrcat(scratch, path);\n\t} else {\n\t\t/* Send the traditional /path/to/file?query_string */\n\n\t\t/* file */\n\t\tif (resource->path && *resource->path) {\n\t\t\tstrlcat(scratch, resource->path, scratch_len);\n\t\t} else {\n\t\t\tstrlcat(scratch, \"/\", scratch_len);\n\t\t}\n\n\t\t/* query string */\n\t\tif (resource->query) {\n\t\t\tstrlcat(scratch, \"?\", scratch_len);\n\t\t\tstrlcat(scratch, resource->query, scratch_len);\n\t\t}\n\t}\n\n\t/* protocol version we are speaking */\n\tif (protocol_version) {\n\t\tstrlcat(scratch, \" HTTP/\", scratch_len);\n\t\tstrlcat(scratch, protocol_version, scratch_len);\n\t\tstrlcat(scratch, \"\\r\\n\", scratch_len);\n\t} else {\n\t\tstrlcat(scratch, \" HTTP/1.0\\r\\n\", scratch_len);\n\t}\n\n\t/* send it */\n\tphp_stream_write(stream, scratch, strlen(scratch));\n\n\tif (context && php_stream_context_get_option(context, \"http\", \"header\", &tmpzval) == SUCCESS) {\n\t\ttmp = NULL;\n\n\t\tif (Z_TYPE_PP(tmpzval) == IS_ARRAY) {\n\t\t\tHashPosition pos;\n\t\t\tzval **tmpheader = NULL;\n\t\t\tsmart_str tmpstr = {0};\n\n\t\t\tfor (zend_hash_internal_pointer_reset_ex(Z_ARRVAL_PP(tmpzval), &pos);\n\t\t\t\tSUCCESS == zend_hash_get_current_data_ex(Z_ARRVAL_PP(tmpzval), (void *)&tmpheader, &pos);\n\t\t\t\tzend_hash_move_forward_ex(Z_ARRVAL_PP(tmpzval), &pos)\n\t\t\t) {\n\t\t\t\tif (Z_TYPE_PP(tmpheader) == IS_STRING) {\n\t\t\t\t\tsmart_str_appendl(&tmpstr, Z_STRVAL_PP(tmpheader), Z_STRLEN_PP(tmpheader));\n\t\t\t\t\tsmart_str_appendl(&tmpstr, \"\\r\\n\", sizeof(\"\\r\\n\") - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsmart_str_0(&tmpstr);\n\t\t\t/* Remove newlines and spaces from start and end. there's at least one extra \\r\\n at the end that needs to go. */\n\t\t\tif (tmpstr.c) {\n\t\t\t\ttmp = php_trim(tmpstr.c, strlen(tmpstr.c), NULL, 0, NULL, 3 TSRMLS_CC);\n\t\t\t\tsmart_str_free(&tmpstr);\n\t\t\t}\n\t\t}\n\t\tif (Z_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval)) {\n\t\t\t/* Remove newlines and spaces from start and end php_trim will estrndup() */\n\t\t\ttmp = php_trim(Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval), NULL, 0, NULL, 3 TSRMLS_CC);\n\t\t}\n\t\tif (tmp && strlen(tmp) > 0) {\n\t\t\tchar *s;\n\n\t\t\tuser_headers = estrdup(tmp);\n\n\t\t\t/* Make lowercase for easy comparison against 'standard' headers */\n\t\t\tphp_strtolower(tmp, strlen(tmp));\n\n\t\t\tif (!header_init) {\n\t\t\t\t/* strip POST headers on redirect */\n\t\t\t\tstrip_header(user_headers, tmp, \"content-length:\");\n\t\t\t\tstrip_header(user_headers, tmp, \"content-type:\");\n\t\t\t}\n\n\t\t\tif ((s = strstr(tmp, \"user-agent:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_USER_AGENT;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"host:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_HOST;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"from:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_FROM;\n\t\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"authorization:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_AUTH;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"content-length:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_CONTENT_LENGTH;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"content-type:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_TYPE;\n\t\t\t}\n\t\t\tif ((s = strstr(tmp, \"connection:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' || \n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\t have_header |= HTTP_HEADER_CONNECTION;\n\t\t\t}\n\t\t\t/* remove Proxy-Authorization header */\n\t\t\tif (use_proxy && use_ssl && (s = strstr(tmp, \"proxy-authorization:\")) &&\n\t\t\t    (s == tmp || *(s-1) == '\\r' || *(s-1) == '\\n' ||\n\t\t\t                 *(s-1) == '\\t' || *(s-1) == ' ')) {\n\t\t\t\tchar *p = s + sizeof(\"proxy-authorization:\") - 1;\n\n\t\t\t\twhile (s > tmp && (*(s-1) == ' ' || *(s-1) == '\\t')) s--;\n\t\t\t\twhile (*p != 0 && *p != '\\r' && *p != '\\n') p++;\n\t\t\t\twhile (*p == '\\r' || *p == '\\n') p++;\n\t\t\t\tif (*p == 0) {\n\t\t\t\t\tif (s == tmp) {\n\t\t\t\t\t\tefree(user_headers);\n\t\t\t\t\t\tuser_headers = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile (s > tmp && (*(s-1) == '\\r' || *(s-1) == '\\n')) s--;\n\t\t\t\t\t\tuser_headers[s - tmp] = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmemmove(user_headers + (s - tmp), user_headers + (p - tmp), strlen(p) + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (tmp) {\n\t\t\tefree(tmp);\n\t\t}\n\t}\n\n\t/* auth header if it was specified */\n\tif (((have_header & HTTP_HEADER_AUTH) == 0) && resource->user) {\n\t\t/* decode the strings first */\n\t\tphp_url_decode(resource->user, strlen(resource->user));\n\n\t\t/* scratch is large enough, since it was made large enough for the whole URL */\n\t\tstrcpy(scratch, resource->user);\n\t\tstrcat(scratch, \":\");\n\n\t\t/* Note: password is optional! */\n\t\tif (resource->pass) {\n\t\t\tphp_url_decode(resource->pass, strlen(resource->pass));\n\t\t\tstrcat(scratch, resource->pass);\n\t\t}\n\n\t\ttmp = (char*)php_base64_encode((unsigned char*)scratch, strlen(scratch), NULL);\n\n\t\tif (snprintf(scratch, scratch_len, \"Authorization: Basic %s\\r\\n\", tmp) > 0) {\n\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_AUTH_REQUIRED, NULL, 0);\n\t\t}\n\n\t\tefree(tmp);\n\t\ttmp = NULL;\n\t}\n\n\t/* if the user has configured who they are, send a From: line */\n\tif (((have_header & HTTP_HEADER_FROM) == 0) && FG(from_address)) {\n\t\tif (snprintf(scratch, scratch_len, \"From: %s\\r\\n\", FG(from_address)) > 0)\n\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t}\n\n\t/* Send Host: header so name-based virtual hosts work */\n\tif ((have_header & HTTP_HEADER_HOST) == 0) {\n\t\tif ((use_ssl && resource->port != 443 && resource->port != 0) ||\n\t\t\t(!use_ssl && resource->port != 80 && resource->port != 0)) {\n\t\t\tif (snprintf(scratch, scratch_len, \"Host: %s:%i\\r\\n\", resource->host, resource->port) > 0)\n\t\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t} else {\n\t\t\tif (snprintf(scratch, scratch_len, \"Host: %s\\r\\n\", resource->host) > 0) {\n\t\t\t\tphp_stream_write(stream, scratch, strlen(scratch));\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Send a Connection: close header to avoid hanging when the server\n\t * interprets the RFC literally and establishes a keep-alive connection,\n\t * unless the user specifically requests something else by specifying a\n\t * Connection header in the context options. Send that header even for\n\t * HTTP/1.0 to avoid issues when the server respond with a HTTP/1.1\n\t * keep-alive response, which is the preferred response type. */\n\tif ((have_header & HTTP_HEADER_CONNECTION) == 0) {\n\t\tphp_stream_write_string(stream, \"Connection: close\\r\\n\");\n\t}\n\n\tif (context &&\n\t    php_stream_context_get_option(context, \"http\", \"user_agent\", &ua_zval) == SUCCESS &&\n\t\tZ_TYPE_PP(ua_zval) == IS_STRING) {\n\t\tua_str = Z_STRVAL_PP(ua_zval);\n\t} else if (FG(user_agent)) {\n\t\tua_str = FG(user_agent);\n\t}\n\n\tif (((have_header & HTTP_HEADER_USER_AGENT) == 0) && ua_str) {\n#define _UA_HEADER \"User-Agent: %s\\r\\n\"\n\t\tchar *ua;\n\t\tsize_t ua_len;\n\n\t\tua_len = sizeof(_UA_HEADER) + strlen(ua_str);\n\n\t\t/* ensure the header is only sent if user_agent is not blank */\n\t\tif (ua_len > sizeof(_UA_HEADER)) {\n\t\t\tua = emalloc(ua_len + 1);\n\t\t\tif ((ua_len = slprintf(ua, ua_len, _UA_HEADER, ua_str)) > 0) {\n\t\t\t\tua[ua_len] = 0;\n\t\t\t\tphp_stream_write(stream, ua, ua_len);\n\t\t\t} else {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot construct User-agent header\");\n\t\t\t}\n\n\t\t\tif (ua) {\n\t\t\t\tefree(ua);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (user_headers) {\n\t\t/* A bit weird, but some servers require that Content-Length be sent prior to Content-Type for POST\n\t\t * see bug #44603 for details. Since Content-Type maybe part of user's headers we need to do this check first.\n\t\t */\n\t\tif (\n\t\t\t\theader_init &&\n\t\t\t\tcontext &&\n\t\t\t\t!(have_header & HTTP_HEADER_CONTENT_LENGTH) &&\n\t\t\t\tphp_stream_context_get_option(context, \"http\", \"content\", &tmpzval) == SUCCESS &&\n\t\t\t\tZ_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval) > 0\n\t\t) {\n\t\t\tscratch_len = slprintf(scratch, scratch_len, \"Content-Length: %d\\r\\n\", Z_STRLEN_PP(tmpzval));\n\t\t\tphp_stream_write(stream, scratch, scratch_len);\n\t\t\thave_header |= HTTP_HEADER_CONTENT_LENGTH;\n\t\t}\n\n\t\tphp_stream_write(stream, user_headers, strlen(user_headers));\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\tefree(user_headers);\n\t}\n\n\t/* Request content, such as for POST requests */\n\tif (header_init && context &&\n\t\tphp_stream_context_get_option(context, \"http\", \"content\", &tmpzval) == SUCCESS &&\n\t\tZ_TYPE_PP(tmpzval) == IS_STRING && Z_STRLEN_PP(tmpzval) > 0) {\n\t\tif (!(have_header & HTTP_HEADER_CONTENT_LENGTH)) {\n\t\t\tscratch_len = slprintf(scratch, scratch_len, \"Content-Length: %d\\r\\n\", Z_STRLEN_PP(tmpzval));\n\t\t\tphp_stream_write(stream, scratch, scratch_len);\n\t\t}\n\t\tif (!(have_header & HTTP_HEADER_TYPE)) {\n\t\t\tphp_stream_write(stream, \"Content-Type: application/x-www-form-urlencoded\\r\\n\",\n\t\t\t\tsizeof(\"Content-Type: application/x-www-form-urlencoded\\r\\n\") - 1);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Content-type not specified assuming application/x-www-form-urlencoded\");\n\t\t}\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t\tphp_stream_write(stream, Z_STRVAL_PP(tmpzval), Z_STRLEN_PP(tmpzval));\n\t} else {\n\t\tphp_stream_write(stream, \"\\r\\n\", sizeof(\"\\r\\n\")-1);\n\t}\n\n\tlocation[0] = '\\0';\n\n\tif (!EG(active_symbol_table)) {\n\t\tzend_rebuild_symbol_table(TSRMLS_C);\n\t}\n\n\tif (header_init) {\n\t\tzval *ztmp;\n\t\tMAKE_STD_ZVAL(ztmp);\n\t\tarray_init(ztmp);\n\t\tZEND_SET_SYMBOL(EG(active_symbol_table), \"http_response_header\", ztmp);\n\t}\n\n\t{\n\t\tzval **rh;\n\t\tif(zend_hash_find(EG(active_symbol_table), \"http_response_header\", sizeof(\"http_response_header\"), (void **) &rh) != SUCCESS || Z_TYPE_PP(rh) != IS_ARRAY) {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP request failed, http_response_header overwritten\");\n\t\t\tgoto out;\n\t\t}\n\t\tresponse_header = *rh;\n\t\tZ_ADDREF_P(response_header);\n\t}\n\n\tif (!php_stream_eof(stream)) {\n\t\tsize_t tmp_line_len;\n\t\t/* get response header */\n\n\t\tif (php_stream_get_line(stream, tmp_line, sizeof(tmp_line) - 1, &tmp_line_len) != NULL) {\n\t\t\tzval *http_response;\n\n\t\t\tif (tmp_line_len > 9) {\n\t\t\t\tresponse_code = atoi(tmp_line + 9);\n\t\t\t} else {\n\t\t\t\tresponse_code = 0;\n\t\t\t}\n\t\t\tif (context && SUCCESS==php_stream_context_get_option(context, \"http\", \"ignore_errors\", &tmpzval)) {\n\t\t\t\tignore_errors = zend_is_true(*tmpzval);\n\t\t\t}\n\t\t\t/* when we request only the header, don't fail even on error codes */\n\t\t\tif ((options & STREAM_ONLY_GET_HEADERS) || ignore_errors) {\n\t\t\t\treqok = 1;\n\t\t\t}\n\n\t\t\t/* status codes of 1xx are \"informational\", and will be followed by a real response\n\t\t\t * e.g \"100 Continue\". RFC 7231 states that unexpected 1xx status MUST be parsed,\n\t\t\t * and MAY be ignored. As such, we need to skip ahead to the \"real\" status*/\n\t\t\tif (response_code >= 100 && response_code < 200) {\n\t\t\t\t/* consume lines until we find a line starting 'HTTP/1' */\n\t\t\t\twhile (\n\t\t\t\t\t!php_stream_eof(stream)\n\t\t\t\t\t&& php_stream_get_line(stream, tmp_line, sizeof(tmp_line) - 1, &tmp_line_len) != NULL\n\t\t\t\t\t&& ( tmp_line_len < sizeof(\"HTTP/1\") - 1 || strncasecmp(tmp_line, \"HTTP/1\", sizeof(\"HTTP/1\") - 1) )\n\t\t\t\t);\n\n\t\t\t\tif (tmp_line_len > 9) {\n\t\t\t\t\tresponse_code = atoi(tmp_line + 9);\n\t\t\t\t} else {\n\t\t\t\t\tresponse_code = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* all status codes in the 2xx range are defined by the specification as successful;\n\t\t\t * all status codes in the 3xx range are for redirection, and so also should never\n\t\t\t * fail */\n\t\t\tif (response_code >= 200 && response_code < 400) {\n\t\t\t\treqok = 1;\n\t\t\t} else {\n\t\t\t\tswitch(response_code) {\n\t\t\t\t\tcase 403:\n\t\t\t\t\t\tphp_stream_notify_error(context, PHP_STREAM_NOTIFY_AUTH_RESULT,\n\t\t\t\t\t\t\t\ttmp_line, response_code);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* safety net in the event tmp_line == NULL */\n\t\t\t\t\t\tif (!tmp_line_len) {\n\t\t\t\t\t\t\ttmp_line[0] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tphp_stream_notify_error(context, PHP_STREAM_NOTIFY_FAILURE,\n\t\t\t\t\t\t\t\ttmp_line, response_code);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmp_line[tmp_line_len - 1] == '\\n') {\n\t\t\t\t--tmp_line_len;\n\t\t\t\tif (tmp_line[tmp_line_len - 1] == '\\r') {\n\t\t\t\t\t--tmp_line_len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tMAKE_STD_ZVAL(http_response);\n\t\t\tZVAL_STRINGL(http_response, tmp_line, tmp_line_len, 1);\n\t\t\tzend_hash_next_index_insert(Z_ARRVAL_P(response_header), &http_response, sizeof(zval *), NULL);\n\t\t}\n\t} else {\n\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP request failed, unexpected end of socket!\");\n\t\tgoto out;\n\t}\n\n\t/* read past HTTP headers */\n\n\thttp_header_line = emalloc(HTTP_HEADER_BLOCK_SIZE);\n\n\twhile (!body && !php_stream_eof(stream)) {\n\t\tsize_t http_header_line_length;\n\t\tif (php_stream_get_line(stream, http_header_line, HTTP_HEADER_BLOCK_SIZE, &http_header_line_length) && *http_header_line != '\\n' && *http_header_line != '\\r') {\n\t\t\tchar *e = http_header_line + http_header_line_length - 1;\n\t\t\tif (*e != '\\n') {\n\t\t\t\tdo { /* partial header */\n\t\t\t\t\tif (php_stream_get_line(stream, http_header_line, HTTP_HEADER_BLOCK_SIZE, &http_header_line_length) == NULL) {\n\t\t\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Failed to read HTTP headers\");\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\te = http_header_line + http_header_line_length - 1;\n\t\t\t\t} while (*e != '\\n');\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (*e == '\\n' || *e == '\\r') {\n\t\t\t\te--;\n\t\t\t}\n\t\t\thttp_header_line_length = e - http_header_line + 1;\n\t\t\thttp_header_line[http_header_line_length] = '\\0';\n\n\t\t\tif (!strncasecmp(http_header_line, \"Location: \", 10)) {\n\t\t\t\tif (context && php_stream_context_get_option(context, \"http\", \"follow_location\", &tmpzval) == SUCCESS) {\n\t\t\t\t\tSEPARATE_ZVAL(tmpzval);\n\t\t\t\t\tconvert_to_long_ex(tmpzval);\n\t\t\t\t\tfollow_location = Z_LVAL_PP(tmpzval);\n\t\t\t\t} else if (!(response_code >= 300 && response_code < 304 || 307 == response_code || 308 == response_code)) {\n\t\t\t\t\t/* we shouldn't redirect automatically\n\t\t\t\t\tif follow_location isn't set and response_code not in (300, 301, 302, 303 and 307)\n\t\t\t\t\tsee http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.1\n\t\t\t\t\tRFC 7238 defines 308: http://tools.ietf.org/html/rfc7238 */\n\t\t\t\t\tfollow_location = 0;\n\t\t\t\t}\n\t\t\t\tstrlcpy(location, http_header_line + 10, sizeof(location));\n\t\t\t} else if (!strncasecmp(http_header_line, \"Content-Type: \", 14)) {\n\t\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_MIME_TYPE_IS, http_header_line + 14, 0);\n\t\t\t} else if (!strncasecmp(http_header_line, \"Content-Length: \", 16)) {\n\t\t\t\tfile_size = atoi(http_header_line + 16);\n\t\t\t\tphp_stream_notify_file_size(context, file_size, http_header_line, 0);\n\t\t\t} else if (!strncasecmp(http_header_line, \"Transfer-Encoding: chunked\", sizeof(\"Transfer-Encoding: chunked\"))) {\n\n\t\t\t\t/* create filter to decode response body */\n\t\t\t\tif (!(options & STREAM_ONLY_GET_HEADERS)) {\n\t\t\t\t\tlong decode = 1;\n\n\t\t\t\t\tif (context && php_stream_context_get_option(context, \"http\", \"auto_decode\", &tmpzval) == SUCCESS) {\n\t\t\t\t\t\tSEPARATE_ZVAL(tmpzval);\n\t\t\t\t\t\tconvert_to_boolean(*tmpzval);\n\t\t\t\t\t\tdecode = Z_LVAL_PP(tmpzval);\n\t\t\t\t\t}\n\t\t\t\t\tif (decode) {\n\t\t\t\t\t\ttransfer_encoding = php_stream_filter_create(\"dechunk\", NULL, php_stream_is_persistent(stream) TSRMLS_CC);\n\t\t\t\t\t\tif (transfer_encoding) {\n\t\t\t\t\t\t\t/* don't store transfer-encodeing header */\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (http_header_line[0] == '\\0') {\n\t\t\t\tbody = 1;\n\t\t\t} else {\n\t\t\t\tzval *http_header;\n\n\t\t\t\tMAKE_STD_ZVAL(http_header);\n\n\t\t\t\tZVAL_STRINGL(http_header, http_header_line, http_header_line_length, 1);\n\n\t\t\t\tzend_hash_next_index_insert(Z_ARRVAL_P(response_header), &http_header, sizeof(zval *), NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!reqok || (location[0] != '\\0' && follow_location)) {\n\t\tif (!follow_location || (((options & STREAM_ONLY_GET_HEADERS) || ignore_errors) && redirect_max <= 1)) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (location[0] != '\\0')\n\t\t\tphp_stream_notify_info(context, PHP_STREAM_NOTIFY_REDIRECTED, location, 0);\n\n\t\tphp_stream_close(stream);\n\t\tstream = NULL;\n\n\t\tif (location[0] != '\\0') {\n\n\t\t\tchar new_path[HTTP_HEADER_BLOCK_SIZE];\n\t\t\tchar loc_path[HTTP_HEADER_BLOCK_SIZE];\n\n\t\t\t*new_path='\\0';\n\t\t\tif (strlen(location)<8 || (strncasecmp(location, \"http://\", sizeof(\"http://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"https://\", sizeof(\"https://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"ftp://\", sizeof(\"ftp://\")-1) &&\n\t\t\t\t\t\t\tstrncasecmp(location, \"ftps://\", sizeof(\"ftps://\")-1)))\n\t\t\t{\n\t\t\t\tif (*location != '/') {\n\t\t\t\t\tif (*(location+1) != '\\0' && resource->path) {\n\t\t\t\t\t\tchar *s = strrchr(resource->path, '/');\n\t\t\t\t\t\tif (!s) {\n\t\t\t\t\t\t\ts = resource->path;\n\t\t\t\t\t\t\tif (!s[0]) {\n\t\t\t\t\t\t\t\tefree(s);\n\t\t\t\t\t\t\t\ts = resource->path = estrdup(\"/\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t*s = '/';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts[1] = '\\0';\n\t\t\t\t\t\tif (resource->path && *(resource->path) == '/' && *(resource->path + 1) == '\\0') {\n\t\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"%s%s\", resource->path, location);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"%s/%s\", resource->path, location);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsnprintf(loc_path, sizeof(loc_path) - 1, \"/%s\", location);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstrlcpy(loc_path, location, sizeof(loc_path));\n\t\t\t\t}\n\t\t\t\tif ((use_ssl && resource->port != 443) || (!use_ssl && resource->port != 80)) {\n\t\t\t\t\tsnprintf(new_path, sizeof(new_path) - 1, \"%s://%s:%d%s\", resource->scheme, resource->host, resource->port, loc_path);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf(new_path, sizeof(new_path) - 1, \"%s://%s%s\", resource->scheme, resource->host, loc_path);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstrlcpy(new_path, location, sizeof(new_path));\n\t\t\t}\n\n\t\t\tphp_url_free(resource);\n\t\t\t/* check for invalid redirection URLs */\n\t\t\tif ((resource = php_url_parse(new_path)) == NULL) {\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Invalid redirect URL! %s\", new_path);\n\t\t\t\tgoto out;\n\t\t\t}\n\n#define CHECK_FOR_CNTRL_CHARS(val) { \\\n\tif (val) { \\\n\t\tunsigned char *s, *e; \\\n\t\tint l; \\\n\t\tl = php_url_decode(val, strlen(val)); \\\n\t\ts = (unsigned char*)val; e = s + l; \\\n\t\twhile (s < e) { \\\n\t\t\tif (iscntrl(*s)) { \\\n\t\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"Invalid redirect URL! %s\", new_path); \\\n\t\t\t\tgoto out; \\\n\t\t\t} \\\n\t\t\ts++; \\\n\t\t} \\\n\t} \\\n}\n\t\t\t/* check for control characters in login, password & path */\n\t\t\tif (strncasecmp(new_path, \"http://\", sizeof(\"http://\") - 1) || strncasecmp(new_path, \"https://\", sizeof(\"https://\") - 1)) {\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->user)\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->pass)\n\t\t\t\tCHECK_FOR_CNTRL_CHARS(resource->path)\n\t\t\t}\n\t\t\tstream = php_stream_url_wrap_http_ex(wrapper, new_path, mode, options, opened_path, context, --redirect_max, HTTP_WRAPPER_REDIRECTED STREAMS_CC TSRMLS_CC);\n\t\t} else {\n\t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"HTTP request failed! %s\", tmp_line);\n\t\t}\n\t}\nout:\n\tif (protocol_version) {\n\t\tefree(protocol_version);\n\t}\n\n\tif (http_header_line) {\n\t\tefree(http_header_line);\n\t}\n\n\tif (scratch) {\n\t\tefree(scratch);\n\t}\n\n\tif (resource) {\n\t\tphp_url_free(resource);\n\t}\n\n\tif (stream) {\n\t\tif (header_init) {\n\t\t\tstream->wrapperdata = response_header;\n\t\t} else {\n\t\t\tif(response_header) {\n\t\t\t\tZ_DELREF_P(response_header);\n\t\t\t}\n\t\t}\n\t\tphp_stream_notify_progress_init(context, 0, file_size);\n\n\t\t/* Restore original chunk size now that we're done with headers */\n\t\tif (options & STREAM_WILL_CAST)\n\t\t\tphp_stream_set_chunk_size(stream, chunk_size);\n\n\t\t/* restore the users auto-detect-line-endings setting */\n\t\tstream->flags |= eol_detect;\n\n\t\t/* as far as streams are concerned, we are now at the start of\n\t\t * the stream */\n\t\tstream->position = 0;\n\n\t\t/* restore mode */\n\t\tstrlcpy(stream->mode, mode, sizeof(stream->mode));\n\n\t\tif (transfer_encoding) {\n\t\t\tphp_stream_filter_append(&stream->readfilters, transfer_encoding);\n\t\t}\n\t} else {\n\t\tif(response_header) {\n\t\t\tZ_DELREF_P(response_header);\n\t\t}\n\t\tif (transfer_encoding) {\n\t\t\tphp_stream_filter_free(transfer_encoding TSRMLS_CC);\n\t\t}\n\t}\n\n\treturn stream;\n}\n```\n \n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.34-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_523f230c831d7b33353203fa34aee4e92ac12bba More .INIs : CWD : /out/php___php-src/git_repo_dir_523f230c831d7b33353203fa34aee4e92ac12bba Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/standard/tests/http/bug75981.phpt]\r \r===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 0 ( 0.0%) ( 0.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 1 (100.0%) (100.0%) --------------------------------------------------------------------- Time taken : 0 seconds =====================================================================\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "523f230c831d7b33353203fa34aee4e92ac12bba___http_fopen_wrapper.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n  ds = d;\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* \u3002 */\n        if (c != 0xFF0E)  /* \uff0e */\n          if (c != 0xFF61)  /* \uff61 */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d < de)\n    *d++ = '\\0';\n\n  return d - ds;  /* Number of bytes written. */\n}\n```\n \n\n\nwith the following test error: not ok 35 - fork_fs_events_child\n# exit code 134\n# Output from process `fork_fs_events_child`:\n# Assertion failed in test/test-fork.c on line 426: `r >= 0` (-13 >= 0)\nnot ok 36 - fork_fs_events_child_dir\n# exit code 134\n# Output from process `fork_fs_events_child_dir`:\n# Assertion failed in test/test-fork.c on line 426: `r >= 0` (-13 >= 0)\nnot ok 37 - fork_fs_events_file_parent_child\n# exit code 134\n# Output from process `fork_fs_events_file_parent_child`:\n# Assertion failed in test/test-fork.c on line 426: `r >= 0` (-13 >= 0)\nok 38 - fork_signal_to_child\nnot ok 44 - fs_access\n# exit code 134\n# Output from process `fs_access`:\n# Assertion failed in test/test-fs.c on line 1631: `r >= 0` (-13 >= 0)\nnot ok 45 - fs_async_dir\n# exit code 134\n# Output from process `fs_async_dir`:\n# Assertion failed in test/test-fs.c on line 511: `req->result == 0` (-13 == 0)\nnot ok 46 - fs_async_sendfile\n# exit code 134\n# Output from process `fs_async_sendfile`:\n# Assertion failed in test/test-fs.c on line 1218: `f != -1` (-1 != -1)\nnot ok 47 - fs_async_sendfile_nodata\n# exit code 134\n# Output from process `fs_async_sendfile_nodata`:\n# Assertion failed in test/test-fs.c on line 1218: `f != -1` (-1 != -1)\nnot ok 48 - fs_chmod\n# exit code 134\n# Output from process `fs_chmod`:\n# Assertion failed in test/test-fs.c on line 1692: `r >= 0` (-13 >= 0)\nnot ok 49 - fs_chown\n# exit code 134\n# Output from process `fs_chown`:\n# Assertion failed in test/test-fs.c on line 1904: `r >= 0` (-13 >= 0)\nnot ok 50 - fs_copyfile\n# exit code 134\n# Output from process `fs_copyfile`:\n# Assertion failed in test/test-fs-copyfile.c on line 81: `r >= 0` (-13 >= 0)\nnot ok 51 - fs_event_close_in_callback\n# exit code 134\n# Output from process `fs_event_close_in_callback`:\n# Assertion failed in test/test-fs-event.c on line 74: r == 0 || r == UV_EEXIST\nnot ok 52 - fs_event_close_with_pending_delete_event\n# exit code 134\n# Output from process `fs_event_close_with_pending_delete_event`:\n# Assertion failed in test/test-fs-event.c on line 74: r == 0 || r == UV_EEXIST\nnot o \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "0f2d7e784a256b54b2385043438848047bc2a629___idna.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic njs_int_t\nnjs_function_prototype_apply(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t         i, length;\n    njs_int_t       ret;\n    njs_frame_t     *frame;\n    njs_value_t     *this, *arr_like;\n    njs_array_t     *arr;\n    njs_function_t  *func;\n\n    if (!njs_is_function(njs_argument(args, 0))) {\n        njs_type_error(vm, \"\\\"this\\\" argument is not a function\");\n        return NJS_ERROR;\n    }\n\n    func = njs_function(njs_argument(args, 0));\n    this = njs_arg(args, nargs, 1);\n    arr_like = njs_arg(args, nargs, 2);\n\n    if (njs_is_null_or_undefined(arr_like)) {\n        length = 0;\n\n        goto activate;\n\n    } else if (njs_is_array(arr_like)) {\n        arr = arr_like->data.u.array;\n\n        args = arr->start;\n        length = arr->length;\n\n        goto activate;\n\n    } else if (njs_slow_path(!njs_is_object(arr_like))) {\n        njs_type_error(vm, \"second argument is not an array-like object\");\n        return NJS_ERROR;\n    }\n\n    ret = njs_object_length(vm, arr_like, &length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    arr = njs_array_alloc(vm, 1, length, NJS_ARRAY_SPARE);\n    if (njs_slow_path(arr == NULL)) {\n        return NJS_ERROR;\n    }\n\n    args = arr->start;\n\n    for (i = 0; i < length; i++) {\n        ret = njs_value_property_i64(vm, arr_like, i, &args[i]);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return ret;\n        }\n    }\n\nactivate:\n\n    /* Skip the \"apply\" method frame. */\n    vm->top_frame->skip = 1;\n\n    frame = (njs_frame_t *) vm->top_frame;\n\n    ret = njs_function_frame(vm, func, this, args, length, 0);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_function_frame_invoke(vm, frame->native.retval);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    return NJS_DECLINED;\n}\n```\n \n\n\nwith the following test error: script tests: PASSED [5112/5112]\nsafe script tests: PASSED [5/5]\ndenormals tests: PASSED [9/9]\ndisabled denormals tests: PASSED [7/7]\nwebcrypto tests: PASSED [1/1]\nmodule tests: PASSED [5/5]\nfs module tests: PASSED [54/54]\ncrypto module tests: PASSED [36/36]\nquerystring module tests: PASSED [75/75]\nbuffer module tests: PASSED [196/196]\nexternals tests: PASSED [93/93]\nasync handler tests: PASSED [2/2]\nshared tests: PASSED [30/30]\ninteractive tests: PASSED [26/26]\nbacktraces tests: PASSED [34/34]\ntimezone tests: PASSED [28/28]\nregexp optional tests: PASSED [13/13]\nvm_json tests: PASSED [6/6]\nvm_value tests: PASSED [8/8]\nvm_internal_api tests: PASSED [67/67]\nTOTAL: PASSED [5807/5807]\nscript tests: PASSED [5112/5112]\nsafe script tests: PASSED [5/5]\ndenormals tests: PASSED [9/9]\ndisabled denormals tests: PASSED [7/7]\nwebcrypto tests: PASSED [1/1]\nmodule tests: PASSED [5/5]\nfs module tests: PASSED [54/54]\ncrypto module tests: PASSED [36/36]\nquerystring module tests: PASSED [75/75]\nbuffer module tests: PASSED [196/196]\nexternals tests: PASSED [93/93]\nasync handler tests: PASSED [2/2]\nshared tests: PASSED [30/30]\ninteractive tests: PASSED [26/26]\nbacktraces tests: PASSED [34/34]\ntimezone tests: PASSED [28/28]\nregexp optional tests: PASSED [13/13]\nvm_json tests: PASSED [6/6]\nvm_value tests: PASSED [8/8]\nvm_internal_api tests: PASSED [67/67]\nTOTAL: PASSED [5807/5807]\nscript tests: PASSED [5112/5112]\nsafe script tests: PASSED [5/5]\ndenormals tests: PASSED [9/9]\ndisabled denormals tests: PASSED [7/7]\nwebcrypto tests: PASSED [1/1]\nmodule tests: PASSED [5/5]\nfs module tests: PASSED [54/54]\ncrypto module tests: PASSED [36/36]\nquerystring module tests: PASSED [75/75]\nbuffer module tests: PASSED [196/196]\nexternals tests: PASSED [93/93]\nasync handler tests: PASSED [2/2]\nshared tests: PASSED [30/30]\ninteractive tests: PASSED [26/26]\nbacktraces tests: PASSED [34/34]\ntimezone tests: PASSED [28/28]\nregexp optional tests: PASSED [13/13]\nvm_json tests: PASSED [6/6]\nvm_value tests: PASSED [8/8]\nvm_internal_api tests: PASSED [67/67]\nTOT \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "39e8fa1b7db1680654527f8fa0e9ee93b334ecba___njs_function.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nnjs_int_t\nnjs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n\n    native = &frame->native;\n\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n\n    function = active->function;\n\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n\n\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n\n    /* Move all arguments. */\n\n    p = native->arguments;\n    local = native->local + function->args_offset;\n\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n\n        *local++ = p++;\n    }\n\n    return NJS_OK;\n}\n\n\nnjs_object_type_t\nnjs_function_object_type(njs_vm_t *vm, njs_function_t *function)\n{\n    if (function->object.shared_hash.slot\n        == vm->shared->async_function_instance_hash.slot)\n    {\n        return NJS_OBJ_TYPE_ASYNC_FUNCTION;\n    }\n\n    return NJS_OBJ_TYPE_FUNCTION;\n}\n\n\nnjs_int_t\nnjs_function_capture_closure(njs_vm_t *vm, njs_function_t *function,\n    njs_function_lambda_t *lambda)\n{\n    void                *start, *end;\n    uint32_t            n;\n    njs_value_t         *value, **closure;\n    njs_native_frame_t  *frame;\n\n    if (lambda->nclosures == 0) {\n        return NJS_OK;\n    }\n\n    frame = &vm->active_frame->native;\n\n    while (frame->native) {\n        frame = frame->previous;\n    }\n\n    start = frame;\n    end = frame->free;\n\n    closure = njs_function_closures(function);\n    n = lambda->nclosures;\n\n    do {\n        n--;\n\n        value = njs_scope_value(vm, lambda->closures[n]);\n\n        if (start <= (void *) value && (void *) value < end) {\n            value = njs_scope_value_clone(vm, lambda->closures[n], value);\n            if (njs_slow_path(value == NULL)) {\n                return NJS_ERROR;\n            }\n        }\n\n        closure[n] = value;\n\n    } while (n != 0);\n\n    return NJS_OK;\n}\n\n\nnjs_inline njs_value_t *\nnjs_function_closure_value(njs_vm_t *vm, njs_value_t **scope, njs_index_t index,\n    void *start, void *end)\n{\n    njs_value_t  *value, *newval;\n\n    value = scope[njs_scope_index_value(index)];\n\n    if (start <= (void *) value && end > (void *) value) {\n        newval = njs_mp_alloc(vm->mem_pool, sizeof(njs_value_t));\n        if (njs_slow_path(newval == NULL)) {\n            njs_memory_error(vm);\n            return NULL;\n        }\n\n        *newval = *value;\n        value = newval;\n    }\n\n    scope[njs_scope_index_value(index)] = value;\n\n    return value;\n}\n```\n \n\n\nwith the following test error: Thrown:\nReferenceError: \"$DONE\" is not defined\n    at Promise.prototype.then (native)\n    at main (test/js/async_recursive_large.t.js:26)\n\nThrown:\nReferenceError: \"$DONE\" is not defined\n    at Promise.prototype.then (native)\n    at main (test/js/async_recursive_mid.t.js:26)\n\nThrown:\nReferenceError: \"$DONE\" is not defined\n    at Promise.prototype.then (native)\n    at main (test/js/async_recursive_large.t.js:26)\n\nThrown:\nReferenceError: \"$DONE\" is not defined\n    at Promise.prototype.then (native)\n    at main (test/js/async_recursive_mid.t.js:26)\n\nThrown:\nReferenceError: \"$DONE\" is not defined\n    at Promise.prototype.then (native)\n    at main (test/js/async_recursive_large.t.js:26)\n\nThrown:\nReferenceError: \"$DONE\" is not defined\n    at Promise.prototype.then (native)\n    at main (test/js/async_recursive_mid.t.js:26)\n\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "ad48705bf1f04b4221a5f5b07715ac48b3160d53___njs_function.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nnjs_int_t\nnjs_vmcode_interpreter(njs_vm_t *vm, u_char *pc, void *promise_cap,\n    void *async_ctx)\n{\n    u_char                       *catch;\n    double                       num, exponent;\n    int32_t                      i32;\n    uint32_t                     u32;\n    njs_str_t                    string;\n    njs_uint_t                   hint;\n    njs_bool_t                   valid, lambda_call;\n    njs_value_t                  *retval, *value1, *value2;\n    njs_value_t                  *src, *s1, *s2, dst;\n    njs_value_t                  *function, name;\n    njs_value_t                  numeric1, numeric2, primitive1, primitive2;\n    njs_frame_t                  *frame;\n    njs_jump_off_t               ret;\n    njs_vmcode_await_t           *await;\n    njs_native_frame_t           *previous, *native;\n    njs_property_next_t          *next;\n    njs_vmcode_import_t          *import;\n    njs_vmcode_finally_t         *finally;\n    njs_vmcode_generic_t         *vmcode;\n    njs_vmcode_variable_t        *var;\n    njs_vmcode_move_arg_t        *move_arg;\n    njs_vmcode_prop_get_t        *get;\n    njs_vmcode_prop_set_t        *set;\n    njs_vmcode_operation_t       op;\n    njs_vmcode_prop_next_t       *pnext;\n    njs_vmcode_test_jump_t       *test_jump;\n    njs_vmcode_equal_jump_t      *equal;\n    njs_vmcode_try_return_t      *try_return;\n    njs_vmcode_method_frame_t    *method_frame;\n    njs_vmcode_function_copy_t   *fcopy;\n    njs_vmcode_prop_accessor_t   *accessor;\n    njs_vmcode_try_trampoline_t  *try_trampoline;\n    njs_vmcode_function_frame_t  *function_frame;\n\n#ifdef NJS_OPCODE_DEBUG\n    njs_vmcode_debug(vm, pc, \"ENTER\");\n#endif\n\nnext:\n\n    for ( ;; ) {\n\n        vmcode = (njs_vmcode_generic_t *) pc;\n\n        /*\n         * The first operand is passed as is in value2 to\n         *   NJS_VMCODE_JUMP,\n         *   NJS_VMCODE_IF_TRUE_JUMP,\n         *   NJS_VMCODE_IF_FALSE_JUMP,\n         *   NJS_VMCODE_FUNCTION_FRAME,\n         *   NJS_VMCODE_FUNCTION_CALL,\n         *   NJS_VMCODE_RETURN,\n         *   NJS_VMCODE_TRY_START,\n         *   NJS_VMCODE_TRY_CONTINUE,\n         *   NJS_VMCODE_TRY_BREAK,\n         *   NJS_VMCODE_TRY_END,\n         *   NJS_VMCODE_CATCH,\n         *   NJS_VMCODE_THROW,\n         *   NJS_VMCODE_STOP.\n         */\n        value2 = (njs_value_t *) vmcode->operand1;\n        value1 = NULL;\n\n        switch (vmcode->code.operands) {\n\n        case NJS_VMCODE_3OPERANDS:\n            njs_vmcode_operand(vm, vmcode->operand3, value2);\n\n            /* Fall through. */\n\n        case NJS_VMCODE_2OPERANDS:\n            njs_vmcode_operand(vm, vmcode->operand2, value1);\n        }\n\n        op = vmcode->code.operation;\n\n        /*\n         * On success an operation returns size of the bytecode,\n         * a jump offset or zero after the call or return operations.\n         * Jumps can return a negative offset.  Compilers can generate\n         *    (ret < 0 && ret >= NJS_PREEMPT)\n         * as a single unsigned comparision.\n         */\n\n#ifdef NJS_OPCODE_DEBUG\n        njs_disassemble(pc, NULL, 1, NULL);\n#endif\n\n        if (op > NJS_VMCODE_NORET) {\n\n            if (op == NJS_VMCODE_MOVE) {\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n                *retval = *value1;\n\n                pc += sizeof(njs_vmcode_move_t);\n                goto next;\n            }\n\n            if (op == NJS_VMCODE_PROPERTY_GET) {\n                get = (njs_vmcode_prop_get_t *) pc;\n                njs_vmcode_operand(vm, get->value, retval);\n\n                ret = njs_value_property(vm, value1, value2, retval);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                pc += sizeof(njs_vmcode_prop_get_t);\n                goto next;\n            }\n\n            switch (op) {\n            case NJS_VMCODE_INCREMENT:\n            case NJS_VMCODE_POST_INCREMENT:\n            case NJS_VMCODE_DECREMENT:\n            case NJS_VMCODE_POST_DECREMENT:\n                if (njs_slow_path(!njs_is_numeric(value2))) {\n                    ret = njs_value_to_numeric(vm, value2, &numeric1);\n                    if (njs_slow_path(ret != NJS_OK)) {\n                        goto error;\n                    }\n\n                    num = njs_number(&numeric1);\n\n                } else {\n                    num = njs_number(value2);\n                }\n\n                njs_set_number(value1,\n                           num + (1 - 2 * ((op - NJS_VMCODE_INCREMENT) >> 1)));\n\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n\n                if (op & 1) {\n                    njs_set_number(retval, num);\n\n                } else {\n                    *retval = *value1;\n                }\n\n                pc += sizeof(njs_vmcode_3addr_t);\n                goto next;\n\n            case NJS_VMCODE_GLOBAL_GET:\n                get = (njs_vmcode_prop_get_t *) pc;\n                njs_vmcode_operand(vm, get->value, retval);\n\n                ret = njs_value_property(vm, value1, value2, retval);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                pc += sizeof(njs_vmcode_prop_get_t);\n\n                if (ret == NJS_OK) {\n                    pc += sizeof(njs_vmcode_error_t);\n                }\n\n                goto next;\n\n            /*\n             * njs_vmcode_try_return() saves a return value to use it later by\n             * njs_vmcode_finally(), and jumps to the nearest try_break block.\n             */\n            case NJS_VMCODE_TRY_RETURN:\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n                *retval = *value1;\n\n                try_return = (njs_vmcode_try_return_t *) pc;\n                pc += try_return->offset;\n                goto next;\n\n            case NJS_VMCODE_LESS:\n            case NJS_VMCODE_GREATER:\n            case NJS_VMCODE_LESS_OR_EQUAL:\n            case NJS_VMCODE_GREATER_OR_EQUAL:\n            case NJS_VMCODE_ADDITION:\n                if (njs_slow_path(!njs_is_primitive(value1))) {\n                    hint = (op == NJS_VMCODE_ADDITION) && njs_is_date(value1);\n                    ret = njs_value_to_primitive(vm, &primitive1, value1, hint);\n                    if (ret != NJS_OK) {\n                        goto error;\n                    }\n\n                    value1 = &primitive1;\n                }\n\n                if (njs_slow_path(!njs_is_primitive(value2))) {\n                    hint = (op == NJS_VMCODE_ADDITION) && njs_is_date(value2);\n                    ret = njs_value_to_primitive(vm, &primitive2, value2, hint);\n                    if (ret != NJS_OK) {\n                        goto error;\n                    }\n\n                    value2 = &primitive2;\n                }\n\n                if (njs_slow_path(njs_is_symbol(value1)\n                                  || njs_is_symbol(value2)))\n                {\n                    njs_symbol_conversion_failed(vm,\n                        (op == NJS_VMCODE_ADDITION) &&\n                        (njs_is_string(value1) || njs_is_string(value2)));\n\n                    goto error;\n                }\n\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n\n                if (op == NJS_VMCODE_ADDITION) {\n                    if (njs_fast_path(njs_is_numeric(value1)\n                                      && njs_is_numeric(value2)))\n                    {\n                        njs_set_number(retval, njs_number(value1)\n                                               + njs_number(value2));\n                        pc += sizeof(njs_vmcode_3addr_t);\n                        goto next;\n                    }\n\n                    if (njs_is_string(value1)) {\n                        s1 = value1;\n                        s2 = &dst;\n                        src = value2;\n\n                    } else {\n                        s1 = &dst;\n                        s2 = value2;\n                        src = value1;\n                    }\n\n                    ret = njs_primitive_value_to_string(vm, &dst, src);\n                    if (njs_slow_path(ret != NJS_OK)) {\n                        goto error;\n                    }\n\n                    ret = njs_string_concat(vm, s1, s2);\n                    if (njs_slow_path(ret == NJS_ERROR)) {\n                        goto error;\n                    }\n\n                    *retval = vm->retval;\n\n                    pc += ret;\n                    goto next;\n                }\n\n                if ((uint8_t) (op - NJS_VMCODE_GREATER) < 2) {\n                    /* NJS_VMCODE_GREATER, NJS_VMCODE_LESS_OR_EQUAL */\n                    src = value1;\n                    value1 = value2;\n                    value2 = src;\n                }\n\n                ret = njs_primitive_values_compare(vm, value1, value2);\n\n                if (op < NJS_VMCODE_LESS_OR_EQUAL) {\n                    ret = ret > 0;\n\n                } else {\n                    ret = ret == 0;\n                }\n\n                njs_set_boolean(retval, ret);\n\n                pc += sizeof(njs_vmcode_3addr_t);\n                goto next;\n\n            case NJS_VMCODE_EQUAL:\n            case NJS_VMCODE_NOT_EQUAL:\n                ret = njs_values_equal(vm, value1, value2);\n                if (njs_slow_path(ret < 0)) {\n                    goto error;\n                }\n\n                ret ^= op - NJS_VMCODE_EQUAL;\n\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n                njs_set_boolean(retval, ret);\n\n                pc += sizeof(njs_vmcode_3addr_t);\n                goto next;\n\n            case NJS_VMCODE_SUBSTRACTION:\n            case NJS_VMCODE_MULTIPLICATION:\n            case NJS_VMCODE_EXPONENTIATION:\n            case NJS_VMCODE_DIVISION:\n            case NJS_VMCODE_REMAINDER:\n            case NJS_VMCODE_BITWISE_AND:\n            case NJS_VMCODE_BITWISE_OR:\n            case NJS_VMCODE_BITWISE_XOR:\n            case NJS_VMCODE_LEFT_SHIFT:\n            case NJS_VMCODE_RIGHT_SHIFT:\n            case NJS_VMCODE_UNSIGNED_RIGHT_SHIFT:\n                if (njs_slow_path(!njs_is_numeric(value1))) {\n                    ret = njs_value_to_numeric(vm, value1, &numeric1);\n                    if (njs_slow_path(ret != NJS_OK)) {\n                        goto error;\n                    }\n\n                    value1 = &numeric1;\n                }\n\n                if (njs_slow_path(!njs_is_numeric(value2))) {\n                    ret = njs_value_to_numeric(vm, value2, &numeric2);\n                    if (njs_slow_path(ret != NJS_OK)) {\n                        goto error;\n                    }\n\n                    value2 = &numeric2;\n                }\n\n                num = njs_number(value1);\n\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n                pc += sizeof(njs_vmcode_3addr_t);\n\n                switch (op) {\n                case NJS_VMCODE_SUBSTRACTION:\n                    num -= njs_number(value2);\n                    break;\n\n                case NJS_VMCODE_MULTIPLICATION:\n                    num *= njs_number(value2);\n                    break;\n\n                case NJS_VMCODE_EXPONENTIATION:\n                    exponent = njs_number(value2);\n\n                    /*\n                     * According to ES7:\n                     *  1. If exponent is NaN, the result should be NaN;\n                     *  2. The result of +/-1 ** +/-Infinity should be NaN.\n                     */\n                    valid = njs_expect(1, fabs(num) != 1\n                                          || (!isnan(exponent)\n                                              && !isinf(exponent)));\n\n                    num = valid ? pow(num, exponent) : NAN;\n                    break;\n\n                case NJS_VMCODE_DIVISION:\n                    num /= njs_number(value2);\n                    break;\n\n                case NJS_VMCODE_REMAINDER:\n                    num = fmod(num, njs_number(value2));\n                    break;\n\n                case NJS_VMCODE_BITWISE_AND:\n                case NJS_VMCODE_BITWISE_OR:\n                case NJS_VMCODE_BITWISE_XOR:\n                    i32 = njs_number_to_int32(njs_number(value2));\n\n                    switch (op) {\n                    case NJS_VMCODE_BITWISE_AND:\n                        i32 &= njs_number_to_int32(num);\n                        break;\n\n                    case NJS_VMCODE_BITWISE_OR:\n                        i32 |= njs_number_to_int32(num);\n                        break;\n\n                    case NJS_VMCODE_BITWISE_XOR:\n                        i32 ^= njs_number_to_int32(num);\n                        break;\n                    }\n\n                    njs_set_int32(retval, i32);\n                    goto next;\n\n                default:\n                    u32 = njs_number_to_uint32(njs_number(value2)) & 0x1f;\n\n                    switch (op) {\n                    case NJS_VMCODE_LEFT_SHIFT:\n                    case NJS_VMCODE_RIGHT_SHIFT:\n                        i32 = njs_number_to_int32(num);\n\n                        if (op == NJS_VMCODE_LEFT_SHIFT) {\n                            /* Shifting of negative numbers is undefined. */\n                            i32 = (uint32_t) i32 << u32;\n                        } else {\n                            i32 >>= u32;\n                        }\n\n                        njs_set_int32(retval, i32);\n                        break;\n\n                    default: /* NJS_VMCODE_UNSIGNED_RIGHT_SHIFT */\n                        njs_set_uint32(retval,\n                                       njs_number_to_uint32(num) >> u32);\n                    }\n\n                    goto next;\n                }\n\n                njs_set_number(retval, num);\n                goto next;\n\n            case NJS_VMCODE_OBJECT_COPY:\n                ret = njs_vmcode_object_copy(vm, value1, value2);\n                break;\n\n            case NJS_VMCODE_TEMPLATE_LITERAL:\n                ret = njs_vmcode_template_literal(vm, value1, value2);\n                break;\n\n            case NJS_VMCODE_PROPERTY_IN:\n                ret = njs_vmcode_property_in(vm, value1, value2);\n                break;\n\n            case NJS_VMCODE_PROPERTY_DELETE:\n                ret = njs_value_property_delete(vm, value1, value2, NULL);\n                if (njs_fast_path(ret != NJS_ERROR)) {\n                    vm->retval = njs_value_true;\n\n                    ret = sizeof(njs_vmcode_3addr_t);\n                }\n\n                break;\n\n            case NJS_VMCODE_PROPERTY_FOREACH:\n                ret = njs_vmcode_property_foreach(vm, value1, value2, pc);\n                break;\n\n            case NJS_VMCODE_STRICT_EQUAL:\n            case NJS_VMCODE_STRICT_NOT_EQUAL:\n                ret = njs_values_strict_equal(value1, value2);\n\n                ret ^= op - NJS_VMCODE_STRICT_EQUAL;\n\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n                njs_set_boolean(retval, ret);\n\n                pc += sizeof(njs_vmcode_3addr_t);\n                goto next;\n\n            case NJS_VMCODE_TEST_IF_TRUE:\n            case NJS_VMCODE_TEST_IF_FALSE:\n            case NJS_VMCODE_COALESCE:\n                if (op == NJS_VMCODE_COALESCE) {\n                    ret = !njs_is_null_or_undefined(value1);\n\n                } else {\n                    ret = njs_is_true(value1);\n                    ret ^= op - NJS_VMCODE_TEST_IF_TRUE;\n                }\n\n                if (ret) {\n                    test_jump = (njs_vmcode_test_jump_t *) pc;\n                    ret = test_jump->offset;\n\n                } else {\n                    ret = sizeof(njs_vmcode_3addr_t);\n                }\n\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n                *retval = *value1;\n\n                pc += ret;\n                goto next;\n\n            case NJS_VMCODE_UNARY_PLUS:\n            case NJS_VMCODE_UNARY_NEGATION:\n            case NJS_VMCODE_BITWISE_NOT:\n                if (njs_slow_path(!njs_is_numeric(value1))) {\n                    ret = njs_value_to_numeric(vm, value1, &numeric1);\n                    if (njs_slow_path(ret != NJS_OK)) {\n                        goto error;\n                    }\n\n                    value1 = &numeric1;\n                }\n\n                num = njs_number(value1);\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n\n                switch (op) {\n                case NJS_VMCODE_UNARY_NEGATION:\n                    num = -num;\n\n                    /* Fall through. */\n                case NJS_VMCODE_UNARY_PLUS:\n                    njs_set_number(retval, num);\n                    break;\n\n                case NJS_VMCODE_BITWISE_NOT:\n                    njs_set_int32(retval, ~njs_number_to_uint32(num));\n                }\n\n                pc += sizeof(njs_vmcode_2addr_t);\n                goto next;\n\n            case NJS_VMCODE_LOGICAL_NOT:\n                njs_vmcode_operand(vm, vmcode->operand1, retval);\n                njs_set_boolean(retval, !njs_is_true(value1));\n\n                pc += sizeof(njs_vmcode_2addr_t);\n                goto next;\n\n            case NJS_VMCODE_OBJECT:\n                ret = njs_vmcode_object(vm);\n                break;\n\n            case NJS_VMCODE_ARRAY:\n                ret = njs_vmcode_array(vm, pc);\n                break;\n\n            case NJS_VMCODE_FUNCTION:\n                ret = njs_vmcode_function(vm, pc);\n                break;\n\n            case NJS_VMCODE_REGEXP:\n                ret = njs_vmcode_regexp(vm, pc);\n                break;\n\n            case NJS_VMCODE_INSTANCE_OF:\n                ret = njs_vmcode_instance_of(vm, value1, value2);\n                break;\n\n            case NJS_VMCODE_TYPEOF:\n                ret = njs_vmcode_typeof(vm, value1, value2);\n                break;\n\n            case NJS_VMCODE_VOID:\n                njs_set_undefined(&vm->retval);\n\n                ret = sizeof(njs_vmcode_2addr_t);\n                break;\n\n            case NJS_VMCODE_DELETE:\n                njs_release(vm, value1);\n                vm->retval = njs_value_true;\n\n                ret = sizeof(njs_vmcode_2addr_t);\n                break;\n\n            case NJS_VMCODE_DEBUGGER:\n                ret = njs_vmcode_debugger(vm);\n                break;\n\n            default:\n                njs_internal_error(vm, \"%d has retval\", op);\n                goto error;\n            }\n\n            if (njs_slow_path(ret < 0 && ret >= NJS_PREEMPT)) {\n                break;\n            }\n\n            njs_vmcode_operand(vm, vmcode->operand1, retval);\n            njs_release(vm, retval);\n            *retval = vm->retval;\n\n        } else {\n\n            switch (op) {\n            case NJS_VMCODE_MOVE_ARG:\n                move_arg = (njs_vmcode_move_arg_t *) pc;\n                native = vm->top_frame;\n\n                hint = move_arg->dst;\n\n                value1 = &native->arguments_offset[hint];\n                njs_vmcode_operand(vm, move_arg->src, value2);\n\n                *value1 = *value2;\n\n                ret = sizeof(njs_vmcode_move_arg_t);\n                break;\n\n            case NJS_VMCODE_STOP:\n                njs_vmcode_operand(vm, (njs_index_t) value2, value2);\n                vm->retval = *value2;\n\n#ifdef NJS_OPCODE_DEBUG\n                njs_vmcode_debug(vm, pc, \"EXIT STOP\");\n#endif\n\n                return NJS_OK;\n\n            case NJS_VMCODE_JUMP:\n                ret = (njs_jump_off_t) value2;\n                break;\n\n            case NJS_VMCODE_PROPERTY_SET:\n                set = (njs_vmcode_prop_set_t *) pc;\n                njs_vmcode_operand(vm, set->value, retval);\n\n                ret = njs_value_property_set(vm, value1, value2, retval);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                ret = sizeof(njs_vmcode_prop_set_t);\n                break;\n\n            case NJS_VMCODE_PROPERTY_ACCESSOR:\n                accessor = (njs_vmcode_prop_accessor_t *) pc;\n                njs_vmcode_operand(vm, accessor->value, function);\n\n                ret = njs_value_to_key(vm, &name, value2);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    njs_internal_error(vm, \"failed conversion of type \\\"%s\\\" \"\n                                       \"to string while property define\",\n                                       njs_type_string(value2->type));\n                    goto error;\n                }\n\n                ret = njs_object_prop_define(vm, value1, &name, function,\n                                             accessor->type);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return NJS_ERROR;\n                }\n\n                ret = sizeof(njs_vmcode_prop_accessor_t);\n                break;\n\n            case NJS_VMCODE_IF_TRUE_JUMP:\n            case NJS_VMCODE_IF_FALSE_JUMP:\n                ret = njs_is_true(value1);\n\n                ret ^= op - NJS_VMCODE_IF_TRUE_JUMP;\n\n                ret = ret ? (njs_jump_off_t) value2\n                          : (njs_jump_off_t) sizeof(njs_vmcode_cond_jump_t);\n\n                break;\n\n            case NJS_VMCODE_IF_EQUAL_JUMP:\n                if (njs_values_strict_equal(value1, value2)) {\n                    equal = (njs_vmcode_equal_jump_t *) pc;\n                    ret = equal->offset;\n\n                } else {\n                    ret = sizeof(njs_vmcode_3addr_t);\n                }\n\n                break;\n\n            case NJS_VMCODE_PROPERTY_INIT:\n                set = (njs_vmcode_prop_set_t *) pc;\n                njs_vmcode_operand(vm, set->value, retval);\n                ret = njs_vmcode_property_init(vm, value1, value2, retval);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                break;\n\n            case NJS_VMCODE_RETURN:\n                njs_vmcode_operand(vm, (njs_index_t) value2, value2);\n\n#ifdef NJS_OPCODE_DEBUG\n                njs_vmcode_debug(vm, pc, \"EXIT RETURN\");\n#endif\n\n                return njs_vmcode_return(vm, NULL, value2);\n\n            case NJS_VMCODE_FUNCTION_COPY:\n                fcopy = (njs_vmcode_function_copy_t *) pc;\n                ret = njs_vmcode_function_copy(vm, fcopy->function,\n                                               fcopy->retval);\n                break;\n\n            case NJS_VMCODE_FUNCTION_FRAME:\n                function_frame = (njs_vmcode_function_frame_t *) pc;\n\n                /* TODO: external object instead of void this. */\n\n                ret = njs_function_frame_create(vm, value1,\n                                                &njs_value_undefined,\n                                                (uintptr_t) value2,\n                                                function_frame->ctor);\n\n                if (njs_slow_path(ret != NJS_OK)) {\n                    goto error;\n                }\n\n                ret = sizeof(njs_vmcode_function_frame_t);\n                break;\n\n            case NJS_VMCODE_METHOD_FRAME:\n                method_frame = (njs_vmcode_method_frame_t *) pc;\n\n                ret = njs_value_property(vm, value1, value2, &dst);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                if (njs_slow_path(!njs_is_function(&dst))) {\n                    ret = njs_value_to_key(vm, value2, value2);\n                    if (njs_slow_path(ret != NJS_OK)) {\n                        return NJS_ERROR;\n                    }\n\n                    njs_key_string_get(vm, value2, &string);\n                    njs_type_error(vm,\n                               \"(intermediate value)[\\\"%V\\\"] is not a function\",\n                               &string);\n                    goto error;\n                }\n\n                ret = njs_function_frame_create(vm, &dst, value1,\n                                                method_frame->nargs,\n                                                method_frame->ctor);\n\n                if (njs_slow_path(ret != NJS_OK)) {\n                    goto error;\n                }\n\n                ret = sizeof(njs_vmcode_method_frame_t);\n                break;\n\n            case NJS_VMCODE_FUNCTION_CALL:\n                vm->active_frame->native.pc = pc;\n\n                njs_vmcode_operand(vm, (njs_index_t) value2, value2);\n\n                ret = njs_function_frame_invoke(vm, value2);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                ret = sizeof(njs_vmcode_function_call_t);\n                break;\n\n            case NJS_VMCODE_PROPERTY_NEXT:\n                pnext = (njs_vmcode_prop_next_t *) pc;\n                retval = njs_scope_value(vm, pnext->retval);\n\n                next = value2->data.u.next;\n\n                if (next->index < next->array->length) {\n                    *retval = next->array->start[next->index++];\n\n                    ret = pnext->offset;\n                    break;\n                }\n\n                njs_mp_free(vm->mem_pool, next);\n\n                ret = sizeof(njs_vmcode_prop_next_t);\n                break;\n\n            case NJS_VMCODE_ARGUMENTS:\n                ret = njs_vmcode_arguments(vm, pc);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                break;\n\n            case NJS_VMCODE_PROTO_INIT:\n                set = (njs_vmcode_prop_set_t *) pc;\n                njs_vmcode_operand(vm, set->value, retval);\n                ret = njs_vmcode_proto_init(vm, value1, value2, retval);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                break;\n\n            case NJS_VMCODE_IMPORT:\n                import = (njs_vmcode_import_t *) pc;\n                retval = njs_scope_value(vm, import->retval);\n                ret = njs_vmcode_import(vm, import->module, retval);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                break;\n\n            case NJS_VMCODE_AWAIT:\n                await = (njs_vmcode_await_t *) pc;\n\n#ifdef NJS_OPCODE_DEBUG\n                njs_vmcode_debug(vm, pc, \"EXIT AWAIT\");\n#endif\n\n                return njs_vmcode_await(vm, await, promise_cap, async_ctx);\n\n            case NJS_VMCODE_TRY_START:\n                ret = njs_vmcode_try_start(vm, value1, value2, pc);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto error;\n                }\n\n                break;\n\n            case NJS_VMCODE_THROW:\n                njs_vmcode_operand(vm, (njs_index_t) value2, value2);\n                vm->retval = *value2;\n                goto error;\n\n            case NJS_VMCODE_TRY_BREAK:\n                try_trampoline = (njs_vmcode_try_trampoline_t *) pc;\n                value1 = njs_scope_value(vm, try_trampoline->exit_value);\n\n                ret = njs_vmcode_try_break(vm, value1, value2);\n                break;\n\n            case NJS_VMCODE_TRY_CONTINUE:\n                try_trampoline = (njs_vmcode_try_trampoline_t *) pc;\n                value1 = njs_scope_value(vm, try_trampoline->exit_value);\n\n                ret = njs_vmcode_try_continue(vm, value1, value2);\n                break;\n\n            case NJS_VMCODE_TRY_END:\n                ret = njs_vmcode_try_end(vm, value1, value2);\n                break;\n\n            /*\n             * njs_vmcode_catch() is set on the start of a \"catch\" block to\n             * store exception and to remove a \"try\" block if there is no\n             * \"finally\" block or to update a catch address to the start of\n             * a \"finally\" block.\n             * njs_vmcode_catch() is set on the start of a \"finally\" block\n             * to store uncaught exception and to remove a \"try\" block.\n             */\n            case NJS_VMCODE_CATCH:\n                *value1 = vm->retval;\n\n                if ((njs_jump_off_t) value2 == sizeof(njs_vmcode_catch_t)) {\n                    ret = njs_vmcode_try_end(vm, value1, value2);\n\n                } else {\n                    frame = (njs_frame_t *) vm->top_frame;\n                    frame->exception.catch = pc + (njs_jump_off_t) value2;\n                    ret = sizeof(njs_vmcode_catch_t);\n                }\n\n                break;\n\n            case NJS_VMCODE_FINALLY:\n                finally = (njs_vmcode_finally_t *) pc;\n                value1 = njs_scope_value(vm, finally->exit_value);\n\n                ret = njs_vmcode_finally(vm, value1, value2, pc);\n\n                switch (ret) {\n                case NJS_OK:\n\n#ifdef NJS_OPCODE_DEBUG\n                    njs_vmcode_debug(vm, pc, \"EXIT FINALLY\");\n#endif\n\n                    return NJS_OK;\n                case NJS_ERROR:\n                    goto error;\n                }\n\n                break;\n\n            case NJS_VMCODE_LET:\n                var = (njs_vmcode_variable_t *) pc;\n                value1 = njs_scope_value(vm, var->dst);\n\n                if (njs_is_valid(value1)) {\n                    value1 = njs_mp_alloc(vm->mem_pool, sizeof(njs_value_t));\n                    if (njs_slow_path(value1 == NULL)) {\n                        return NJS_ERROR;\n                    }\n\n                    njs_scope_value_set(vm, var->dst, value1);\n                }\n\n                njs_set_undefined(value1);\n\n                ret = sizeof(njs_vmcode_variable_t);\n                break;\n\n            case NJS_VMCODE_LET_UPDATE:\n                var = (njs_vmcode_variable_t *) pc;\n                value2 = njs_scope_value(vm, var->dst);\n\n                value1 = njs_mp_alloc(vm->mem_pool, sizeof(njs_value_t));\n                if (njs_slow_path(value1 == NULL)) {\n                    return NJS_ERROR;\n                }\n\n                *value1 = *value2;\n\n                njs_scope_value_set(vm, var->dst, value1);\n\n                ret = sizeof(njs_vmcode_variable_t);\n                break;\n\n            case NJS_VMCODE_INITIALIZATION_TEST:\n                var = (njs_vmcode_variable_t *) pc;\n                value1 = njs_scope_value(vm, var->dst);\n\n                if (njs_is_valid(value1)) {\n                    ret = sizeof(njs_vmcode_variable_t);\n                    break;\n                }\n\n                /* Fall through. */\n\n            case NJS_VMCODE_NOT_INITIALIZED:\n                njs_reference_error(vm, \"cannot access variable \"\n                                        \"before initialization\");\n                goto error;\n\n            case NJS_VMCODE_ERROR:\n                njs_vmcode_error(vm, pc);\n                goto error;\n\n            case NJS_VMCODE_ASSIGNMENT_ERROR:\n                njs_type_error(vm, \"assignment to constant variable\");\n                goto error;\n\n            default:\n                njs_internal_error(vm, \"%d has NO retval\", op);\n                goto error;\n            }\n        }\n\n        pc += ret;\n    }\n\nerror:\n\n    if (njs_is_error(&vm->retval)) {\n        vm->active_frame->native.pc = pc;\n        (void) njs_error_stack_attach(vm, &vm->retval);\n    }\n\n    for ( ;; ) {\n        native = vm->top_frame;\n\n        if (!native->native) {\n            frame = (njs_frame_t *) native;\n            catch = frame->exception.catch;\n\n            if (catch != NULL) {\n                pc = catch;\n\n                goto next;\n            }\n        }\n\n        previous = native->previous;\n        if (previous == NULL) {\n            break;\n        }\n\n        lambda_call = (native == &vm->active_frame->native);\n\n        njs_vm_scopes_restore(vm, native, previous);\n\n        if (native->size != 0) {\n            vm->stack_size -= native->size;\n            njs_mp_free(vm->mem_pool, native);\n        }\n\n        if (lambda_call) {\n            break;\n        }\n    }\n\n#ifdef NJS_OPCODE_DEBUG\n    njs_vmcode_debug(vm, pc, \"EXIT ERROR\");\n#endif\n\n    return NJS_ERROR;\n}\n```\n \n\n\nwith the following test error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==32123==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000008 (pc 0x564e67ce582c bp 0x7ffe71676420 sp 0x7ffe71676180 T0)\n==32123==The signal is caused by a READ memory access.\n==32123==Hint: address points to the zero page.\n    #0 0x564e67ce582c in njs_scope_value /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/njs_scope.h:73:12\n    #1 0x564e67ce582c in njs_scope_valid_value /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/njs_scope.h:83:13\n    #2 0x564e67ce582c in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/njs_vmcode.c:162:13\n    #3 0x564e67ce1caa in njs_vm_start /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/njs_vm.c:553:11\n    #4 0x564e67cc8fb0 in njs_process_test /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/test/njs_unit_test.c:21963:15\n    #5 0x564e67cc8fb0 in njs_unit_test /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/test/njs_unit_test.c:22115:23\n    #6 0x564e67cc8261 in main /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/test/njs_unit_test.c:23605:15\n    #7 0x7f70f7010082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #8 0x564e67bf2acd in _start (/out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/build_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/njs_unit_test+0x11eacd)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV /out/nginx___njs/git_repo_dir_222d6fdcf0c6485ec8e175f3a7b70d650c234b4e/src/njs_scope.h:73:12 in njs_scope_value\n==32123==ABORTING\nAddressSanitizer:DEADLYSIGNAL\n=================================================================\n==32354==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000008 (pc 0x55d0d693e82c bp 0x7fff99f3e5e0 sp 0x7fff99f3e340 T0)\n==32354==The signal is  \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "222d6fdcf0c6485ec8e175f3a7b70d650c234b4e___njs_vmcode.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nnjs_int_t\nnjs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_iterator_handler_t handler)\n{\n    double              idx;\n    int64_t             i, from, to, length;\n    njs_int_t           ret;\n    njs_array_t         *array, *keys;\n    njs_value_t         *entry, *value, prop, character, string_obj;\n    const u_char        *p, *end, *pos;\n    njs_string_prop_t   string_prop;\n    njs_object_value_t  *object;\n\n    value = args->value;\n    from = args->from;\n    to = args->to;\n\n    if (njs_is_array(value)) {\n        array = njs_array(value);\n\n        from += 1;\n\n        while (from-- > to) {\n            if (njs_slow_path(!array->object.fast_array)) {\n                goto process_object;\n            }\n\n            if (njs_fast_path(from < array->length\n                              && njs_is_valid(&array->start[from])))\n            {\n                ret = handler(vm, args, &array->start[from], from);\n\n            } else {\n                entry = njs_value_arg(&njs_value_invalid);\n                ret = njs_value_property_i64(vm, value, from, &prop);\n                if (njs_slow_path(ret != NJS_DECLINED)) {\n                    if (ret == NJS_ERROR) {\n                        return NJS_ERROR;\n                    }\n\n                    entry = &prop;\n                }\n\n                ret = handler(vm, args, entry, from);\n            }\n\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DONE) {\n                    return NJS_DONE;\n                }\n\n                return NJS_ERROR;\n            }\n        }\n\n        return NJS_OK;\n    }\n\n    if (njs_is_string(value) || njs_is_object_string(value)) {\n\n        if (njs_is_string(value)) {\n            object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value);\n            if (njs_slow_path(object == NULL)) {\n                return NJS_ERROR;\n            }\n\n            njs_set_object_value(&string_obj, object);\n\n            args->value = &string_obj;\n        }\n        else {\n            value = njs_object_value(value);\n        }\n\n        length = njs_string_prop(&string_prop, value);\n        end = string_prop.start + string_prop.size;\n\n        if ((size_t) length == string_prop.size) {\n            /* Byte or ASCII string. */\n\n            p = string_prop.start + from;\n\n            i = from + 1;\n\n            while (i-- > to) {\n                /* This cannot fail. */\n                (void) njs_string_new(vm, &character, p, 1, 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n\n                    return NJS_ERROR;\n                }\n\n                p--;\n            }\n\n        } else {\n            /* UTF-8 string. */\n\n            p = njs_string_offset(string_prop.start, end, from);\n            p = njs_utf8_next(p, end);\n\n            i = from + 1;\n\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n\n                /* This cannot fail. */\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n\n                    return NJS_ERROR;\n                }\n\n                p = pos;\n            }\n        }\n\n        return NJS_OK;\n    }\n\n    if (!njs_is_object(value)) {\n        return NJS_OK;\n    }\n\nprocess_object:\n\n    if (!njs_fast_object(from - to)) {\n        keys = njs_array_indices(vm, value);\n        if (njs_slow_path(keys == NULL)) {\n            return NJS_ERROR;\n        }\n\n        i = keys->length;\n\n        while (i > 0) {\n            idx = njs_string_to_index(&keys->start[--i]);\n\n            if (idx < to || idx > from) {\n                continue;\n            }\n\n            ret = njs_iterator_object_handler(vm, handler, args,\n                                              &keys->start[i], idx);\n            if (njs_slow_path(ret != NJS_OK)) {\n                njs_array_destroy(vm, keys);\n                return ret;\n            }\n        }\n\n        njs_array_destroy(vm, keys);\n\n        return NJS_OK;\n    }\n\n    i = from + 1;\n\n    while (i-- > to) {\n        ret = njs_iterator_object_handler(vm, handler, args, NULL, i);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    return NJS_OK;\n}\n```\n \n\n\nwith the following test error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==41021==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x556463e9ee30 bp 0x7ffe85b0f150 sp 0x7ffe85b0f140 T0)\n==41021==The signal is caused by a READ memory access.\n==41021==Hint: this fault was caused by a dereference of a high value address (see register values below).  Disassemble the provided pc to learn which register was used.\n    #0 0x556463e9ee30 in njs_string_offset /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_string.c:2535:18\n    #1 0x556463fa2206 in njs_object_iterate_reverse /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_iterator.c:563:17\n    #2 0x556463ecd0ec in njs_array_prototype_reverse_iterator /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_array.c:2424:11\n    #3 0x556463ee4291 in njs_function_native_call /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_function.c:739:11\n    #4 0x556463ee65c2 in njs_function_frame_invoke /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_function.c:777:16\n    #5 0x556463ee65c2 in njs_function_prototype_call /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_function.c:1351:11\n    #6 0x556463ee4291 in njs_function_native_call /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_function.c:739:11\n    #7 0x556463e9138f in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_vmcode.c:810:23\n    #8 0x556463ee372d in njs_function_lambda_call /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_function.c:703:11\n    #9 0x556463ee2962 in njs_function_frame_invoke /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_function.c:780:16\n    #10 0x556463ee2962 in njs_function_call2 /out/nginx___njs/git_repo_dir_eafe4c7a326b163612f10861392622b5da5b1792/src/njs_function. \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "eafe4c7a326b163612f10861392622b5da5b1792___njs_iterator.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\ninline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}\n```\n \n\n\nwith the following test error: ==70966==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fa942648440 at pc 0x560a6a8dcc6f bp 0x7ffdafe72c70 sp 0x7ffdafe72c68\nREAD of size 1 at 0x7fa942648440 thread T0\n[Detaching after fork from child process 70970]\n    #0 0x560a6a8dcc6e in peg::decode_codepoint(char const*, unsigned long, unsigned long&, char32_t&) /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:234:35\n    #1 0x560a6a8dcb49 in peg::decode_codepoint(char const*, unsigned long, char32_t&) /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:270:7\n    #2 0x560a6a87c0a6 in peg::CharacterClass::parse_core(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:1293:16\n    #3 0x560a6a870519 in peg::Ope::parse(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:2438:10\n    #4 0x560a6a87ba23 in peg::NotPredicate::parse_core(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:1211:22\n    #5 0x560a6a870519 in peg::Ope::parse(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:2438:10\n    #6 0x560a6a8796a8 in peg::Sequence::parse_core(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:1010:23\n    #7 0x560a6a870519 in peg::Ope::parse(char const*, unsigned long, peg::SemanticValues&, peg::Context&, peg::any&) const /out/yhirose___cpp-peglib/git_repo_dir_b3b29ce8f3acf3a32733d930105a17d7b0ba347e/test/../peglib.h:2438:10\n    #8 0x560a6 \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "b3b29ce8f3acf3a32733d930105a17d7b0ba347e___peglib.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nint jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    decNumber res;\n    decNumberCompare(&res,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res)) {\n      return 0;\n    } else if (decNumberIsNegative(&res)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n```\n \n\n\nwith the following test error: + . ./setup\n+ [ -n  ]\n+ set -eu\n+ dirname ./ytest.sh\n+ cd .\n+ pwd\n+ JQTESTDIR=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests\n+ JQBASEDIR=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/..\n+ JQ=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/../jq\n+ [ -z  ]\n+ which valgrind\n+ VALGRIND=valgrind --error-exitcode=1 --leak-check=full                        --suppressions=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/onig.supp                        --suppressions=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/local.supp\n+ VG_EXIT0=--error-exitcode=0\n+ Q=-q\n+ mods=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/modules\n+ clean=true\n+ d=\n+ trap clean EXIT\n+ mktemp -d -t jqXXXXXX\n+ d=/tmp/jqJQa0r1\n+ [ -z /tmp/jqJQa0r1 ]\n+ msys=false\n+ mingw=false\n+ uname -s\n+ JQ_NO_B=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/../jq\n+ JQ=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/../jq -b\n+ valgrind --error-exitcode=1 --leak-check=full --suppressions=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/onig.supp --suppressions=/out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/local.supp -q /out/jqlang___jq/git_repo_dir_c9a51565214eece8f1053089739aea73145bfd6b/tests/../jq -b 1 != .\n+ exit 0\n+ clean\n+ true\n+ [ -n /tmp/jqJQa0r1 ]\n+ rm -rf /tmp/jqJQa0r1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "c9a51565214eece8f1053089739aea73145bfd6b___jv.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nint mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const mbedtls_x509_crt_profile *profile,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy )\n{\n    size_t cn_len;\n    int ret;\n    int pathlen = 0, selfsigned = 0;\n    mbedtls_x509_crt *parent;\n    mbedtls_x509_name *name;\n    mbedtls_x509_sequence *cur = NULL;\n    mbedtls_pk_type_t pk_type;\n\n    if( profile == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    *flags = 0;\n\n    if( cn != NULL )\n    {\n        name = &crt->subject;\n        cn_len = strlen( cn );\n\n        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n        {\n            cur = &crt->subject_alt_names;\n\n            while( cur != NULL )\n            {\n                if( cur->buf.len == cn_len &&\n                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )\n                    break;\n\n                if( cur->buf.len > 2 &&\n                    memcmp( cur->buf.p, \"*.\", 2 ) == 0 &&\n                    x509_check_wildcard( cn, &cur->buf ) == 0 )\n                {\n                    break;\n                }\n\n                cur = cur->next;\n            }\n\n            if( cur == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n        else\n        {\n            while( name != NULL )\n            {\n                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )\n                {\n                    if( name->val.len == cn_len &&\n                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )\n                        break;\n\n                    if( name->val.len > 2 &&\n                        memcmp( name->val.p, \"*.\", 2 ) == 0 &&\n                        x509_check_wildcard( cn, &name->val ) == 0 )\n                        break;\n                }\n\n                name = name->next;\n            }\n\n            if( name == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n    }\n\n    /* Check the type and size of the key */\n    pk_type = mbedtls_pk_get_type( &crt->pk );\n\n    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n    /* Look for a parent in trusted CAs */\n    for( parent = trust_ca; parent != NULL; parent = parent->next )\n    {\n        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n            break;\n    }\n\n    if( parent != NULL )\n    {\n        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            return( ret );\n    }\n    else\n    {\n        /* Look for a parent upwards the chain */\n        for( parent = crt->next; parent != NULL; parent = parent->next )\n            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n                break;\n\n        /* Are we part of the chain or at the top? */\n        if( parent != NULL )\n        {\n            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n        {\n            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n\n    return( 0 );\n}\n```\n \n\n\nwith the following test error:   flags == (uint32_t) flags_chk\n  at line 534, /out/ARMmbed___mbedtls/git_repo_dir_d15795acd5074e0b44e71f7ede8bdfe1b48591fc/tests/suites/test_suite_x509parse.function\n\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "d15795acd5074e0b44e71f7ede8bdfe1b48591fc___x509_crt.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic inline bool isQuote(char c) { return c == '\\\"' || c == '\\''; }\n```\n \n\n\nwith the following test error: Running main() from gtest_main.cc\nNote: Google Test filter = QuotedString_ExtractFrom_Tests.UnterminatedEscapeSequence\n[==========] Running 1 test from 1 test case.\n[----------] Global test environment set-up.\n[----------] 1 test from QuotedString_ExtractFrom_Tests\n[ RUN      ] QuotedString_ExtractFrom_Tests.UnterminatedEscapeSequence\n/out/bblanchon___ArduinoJson/git_repo_dir_5e7b9ec688d79e7b16ec7064e1d37e8481a31e72/test/QuotedString_ExtractFrom_Tests.cpp:24: Failure\nValue of: _result\n  Actual: \"\"\nExpected: expected\nWhich is: NULL\n[  FAILED  ] QuotedString_ExtractFrom_Tests.UnterminatedEscapeSequence (0 ms)\n[----------] 1 test from QuotedString_ExtractFrom_Tests (0 ms total)\n\n[----------] Global test environment tear-down\n[==========] 1 test from 1 test case ran. (0 ms total)\n[  PASSED  ] 0 tests.\n[  FAILED  ] 1 test, listed below:\n[  FAILED  ] QuotedString_ExtractFrom_Tests.UnterminatedEscapeSequence\n\n 1 FAILED TEST\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "5e7b9ec688d79e7b16ec7064e1d37e8481a31e72___QuotedString.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstd::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();\n\n  LOG_DEBUG(5, \"Extracting: \" << path);\n\n  return extract(*SystemUtilities::oopen(path));\n}\n```\n \n\n\nwith the following test error: scons: Reading SConscript files ...\n   Compiler: gcc (gnu)\n   Platform: posix\n       Mode: gnu\n       Arch: x86\nGCC Version: 9\n       Jobs: 79\nChecking for C library pthread... (cached) yes\nChecking for C header file zlib.h... (cached) yes\nChecking for C library z... (cached) yes\nChecking for C header file bzlib.h... (cached) yes\nChecking for C library bz2... (cached) yes\nChecking for C header file expat.h... (cached) yes\nChecking for C library expat... (cached) yes\nChecking for C header file pthread.h... (cached) yes\nChecking for C library pthread... (cached) yes\nChecking for C library dl... (cached) yes\nChecking for C library sqlite3... (cached) yes\nChecking for C header file sqlite3.h... (cached) yes\nChecking for C function sqlite3_backup_init()... (cached) yes\nChecking for C header file yaml.h... (cached) yes\nChecking for C library yaml... (cached) yes\nChecking for C library snappy... (cached) yes\nChecking for C library leveldb... no\nNeed library leveldb(cached) error: no result\nChecking for C header file mysql/mysql.h... no\nChecking for C function clock_gettime()... (cached) yes\nChecking for C header file event.h... (cached) yes\nChecking for C library event... (cached) yes\nChecking for C++ header file re2/re2.h... (cached) yes\nChecking for C library re2... (cached) yes\nChecking for C function epoll_create1()... (cached) yes\nChecking for C library dl... (cached) yes\nChecking for C header file openssl/ssl.h... (cached) yes\nChecking for C library crypto... (cached) yes\nChecking for C library ssl... (cached) yes\nChecking for openssl version >= 1.1.0...(cached) yes\nChecking for C++ header file ChakraCore.h... no\nNeed C++ header ChakraCore.h(cached) error: no result\nChecking for C++ header file v8.h... (cached) yes\nChecking for C++ header file libplatform/libplatform.h... (cached) yes\nChecking for C library v8... (cached) yes\nChecking for C header file pthread.h... (cached) yes\nChecking for C library pthread... (cached) yes\nChecking for C header file valgrind/valgrind.h... (cached) yes\nChecking for C header file  \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "1c1dba62bd3e6fa9d0d0c0aa21926043b75382c7___TarFileReader.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic LY_ERR\nlys_compile_leafref_predicate_validate(struct lysc_ctx *ctx, const char **predicate, const struct lysc_node *start_node,\n                                       const struct lysc_node_list *context_node, const struct lys_module *path_context)\n{\n    LY_ERR ret = LY_EVALID;\n    const struct lys_module *mod;\n    const struct lysc_node *src_node, *dst_node;\n    const char *path_key_expr, *pke_start, *src, *src_prefix, *dst, *dst_prefix;\n    size_t src_len, src_prefix_len, dst_len, dst_prefix_len;\n    unsigned int dest_parent_times, c, u;\n    const char *start, *end, *pke_end;\n    struct ly_set keys = {0};\n    int i;\n\n    assert(path_context);\n\n    while (**predicate == '[') {\n        start = (*predicate)++;\n\n        while (isspace(**predicate)) {\n            ++(*predicate);\n        }\n        LY_CHECK_GOTO(lys_parse_nodeid(predicate, &src_prefix, &src_prefix_len, &src, &src_len), cleanup);\n        while (isspace(**predicate)) {\n            ++(*predicate);\n        }\n        if (**predicate != '=') {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - missing \\\"=\\\" after node-identifier.\",\n                   *predicate - start + 1, start);\n            goto cleanup;\n        }\n        ++(*predicate);\n        while (isspace(**predicate)) {\n            ++(*predicate);\n        }\n\n        if ((end = pke_end = strchr(*predicate, ']')) == NULL) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%s\\\" - missing predicate termination.\", start);\n            goto cleanup;\n        }\n        --pke_end;\n        while (isspace(*pke_end)) {\n            --pke_end;\n        }\n        ++pke_end;\n        /* localize path-key-expr */\n        pke_start = path_key_expr = *predicate;\n        /* move after the current predicate */\n        *predicate = end + 1;\n\n        /* source (must be leaf or leaf-list) */\n        if (src_prefix) {\n            mod = lys_module_find_prefix(path_context, src_prefix, src_prefix_len);\n            if (!mod) {\n                LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                       \"Invalid leafref path predicate \\\"%.*s\\\" - prefix \\\"%.*s\\\" not defined in module \\\"%s\\\".\",\n                       *predicate - start, start, src_prefix_len, src_prefix, path_context->name);\n                goto cleanup;\n            }\n        } else {\n            mod = start_node->module;\n        }\n        src_node = NULL;\n        if (context_node->keys) {\n            for (u = 0; u < LY_ARRAY_SIZE(context_node->keys); ++u) {\n                if (!strncmp(src, context_node->keys[u]->name, src_len) && context_node->keys[u]->name[src_len] == '\\0') {\n                    src_node = (const struct lysc_node*)context_node->keys[u];\n                    break;\n                }\n            }\n        }\n        if (!src_node) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - predicate's key node \\\"%.*s\\\" not found.\",\n                   *predicate - start, start, src_len, src, mod->name);\n            goto cleanup;\n        }\n\n        /* check that there is only one predicate for the */\n        c = keys.count;\n        i = ly_set_add(&keys, (void*)src_node, 0);\n        LY_CHECK_GOTO(i == -1, cleanup);\n        if (keys.count == c) { /* node was already present in the set */\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - multiple equality tests for the key \\\"%s\\\".\",\n                   *predicate - start, start, src_node->name);\n            goto cleanup;\n        }\n\n        /* destination */\n        dest_parent_times = 0;\n        dst_node = start_node;\n\n        /* current-function-invocation *WSP \"/\" *WSP rel-path-keyexpr */\n        if (strncmp(path_key_expr, \"current()\", 9)) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - missing current-function-invocation.\",\n                   *predicate - start, start);\n            goto cleanup;\n        }\n        path_key_expr += 9;\n        while (isspace(*path_key_expr)) {\n            ++path_key_expr;\n        }\n\n        if (*path_key_expr != '/') {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - missing \\\"/\\\" after current-function-invocation.\",\n                   *predicate - start, start);\n            goto cleanup;\n        }\n        ++path_key_expr;\n        while (isspace(*path_key_expr)) {\n            ++path_key_expr;\n        }\n\n        /* rel-path-keyexpr:\n         * 1*(\"..\" *WSP \"/\" *WSP) *(node-identifier *WSP \"/\" *WSP) node-identifier */\n        while (!strncmp(path_key_expr, \"..\", 2)) {\n            ++dest_parent_times;\n            path_key_expr += 2;\n            while (isspace(*path_key_expr)) {\n                ++path_key_expr;\n            }\n            if (*path_key_expr != '/') {\n                LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                       \"Invalid leafref path predicate \\\"%.*s\\\" - missing \\\"/\\\" in \\\"../\\\" rel-path-keyexpr pattern.\",\n                       *predicate - start, start);\n                goto cleanup;\n            }\n            ++path_key_expr;\n            while (isspace(*path_key_expr)) {\n                ++path_key_expr;\n            }\n\n            /* path is supposed to be evaluated in data tree, so we have to skip\n             * all schema nodes that cannot be instantiated in data tree */\n            MOVE_PATH_PARENT(dst_node, !strncmp(path_key_expr, \"..\", 2), goto cleanup,\n                             \"Invalid leafref path predicate \\\"%.*s\\\" - too many \\\"..\\\" in rel-path-keyexpr.\",\n                             *predicate - start, start);\n        }\n        if (!dest_parent_times) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - at least one \\\"..\\\" is expected in rel-path-keyexpr.\",\n                   *predicate - start, start);\n            goto cleanup;\n        }\n        if (path_key_expr == pke_end) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - at least one node-identifier is expected in rel-path-keyexpr.\",\n                   *predicate - start, start);\n            goto cleanup;\n        }\n\n        while(path_key_expr != pke_end) {\n            if (lys_parse_nodeid(&path_key_expr, &dst_prefix, &dst_prefix_len, &dst, &dst_len)) {\n                LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_SYNTAX_YANG,\n                       \"Invalid node identifier in leafref path predicate - character %d (of %.*s).\",\n                       path_key_expr - start + 1, *predicate - start, start);\n                goto cleanup;\n            }\n\n            if (dst_prefix) {\n                mod = lys_module_find_prefix(path_context, dst_prefix, dst_prefix_len);\n            } else {\n                mod = start_node->module;\n            }\n            if (!mod) {\n                LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                       \"Invalid leafref path predicate \\\"%.*s\\\" - unable to find module of the node \\\"%.*s\\\" in rel-path_keyexpr.\",\n                       *predicate - start, start, dst_len, dst);\n                goto cleanup;\n            }\n\n            dst_node = lys_child(dst_node, mod, dst, dst_len, 0, LYS_GETNEXT_NOSTATECHECK);\n            if (!dst_node) {\n                LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                       \"Invalid leafref path predicate \\\"%.*s\\\" - unable to find node \\\"%.*s\\\" in the rel-path_keyexpr.\",\n                       *predicate - start, start, path_key_expr - pke_start, pke_start);\n                goto cleanup;\n            }\n        }\n        if (!(dst_node->nodetype & (dst_node->module->version < LYS_VERSION_1_1 ? LYS_LEAF : LYS_LEAF | LYS_LEAFLIST))) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid leafref path predicate \\\"%.*s\\\" - rel-path_keyexpr \\\"%.*s\\\" refers %s instead of leaf.\",\n                   *predicate - start, start, path_key_expr - pke_start, pke_start, lys_nodetype2str(dst_node->nodetype));\n            goto cleanup;\n        }\n    }\n\n    ret = LY_SUCCESS;\ncleanup:\n    ly_set_erase(&keys, NULL);\n    return ret;\n}\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_92cc8517fcb85dcfbb93842758571f721c49c9cb/build_92cc8517fcb85dcfbb93842758571f721c49c9cb\nTest project /out/CESNET___libyang/git_repo_dir_92cc8517fcb85dcfbb93842758571f721c49c9cb/build_92cc8517fcb85dcfbb93842758571f721c49c9cb\n    Start 8: src_tree_schema_compile\n1/1 Test #8: src_tree_schema_compile ..........***Failed    0.11 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.11 sec\n\nThe following tests FAILED:\n\t  8 - src_tree_schema_compile (Failed)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "92cc8517fcb85dcfbb93842758571f721c49c9cb___tree_schema_compile.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nLIBYANG_API_DEF const struct lys_module *\nlyplg_type_identity_module(const struct ly_ctx *ctx, const struct lysc_node *ctx_node,\n        const char *prefix, size_t prefix_len, LY_VALUE_FORMAT format, const void *prefix_data)\n{\n    if (prefix_len) {\n        return ly_resolve_prefix(ctx, prefix, prefix_len, format, prefix_data);\n    } else {\n        switch (format) {\n        case LY_VALUE_SCHEMA:\n        case LY_VALUE_SCHEMA_RESOLVED:\n            /* use context node module, handles augments */\n            return ctx_node->module;\n        case LY_VALUE_CANON:\n        case LY_VALUE_JSON:\n        case LY_VALUE_LYB:\n            /* use context node module (as specified) */\n            return ctx_node->module;\n        case LY_VALUE_XML:\n            /* use the default namespace */\n            return ly_xml_resolve_prefix(ctx, NULL, 0, prefix_data);\n        }\n    }\n\n    return NULL;\n}\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_f128972045a5d4a36854ddc0a75d99803ff81f6d/build_f128972045a5d4a36854ddc0a75d99803ff81f6d\nTest project /out/CESNET___libyang/git_repo_dir_f128972045a5d4a36854ddc0a75d99803ff81f6d/build_f128972045a5d4a36854ddc0a75d99803ff81f6d\n    Start 38: utest_tree_schema_compile\n1/1 Test #38: utest_tree_schema_compile ........***Failed    0.22 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.22 sec\n\nThe following tests FAILED:\n\t 38 - utest_tree_schema_compile (Failed)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "f128972045a5d4a36854ddc0a75d99803ff81f6d___plugins_types.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic void\nevdns_base_free_and_unlock(struct evdns_base *base, int fail_requests)\n{\n\tstruct nameserver *server, *server_next;\n\tstruct search_domain *dom, *dom_next;\n\tint i;\n\n\t/* Requires that we hold the lock. */\n\n\t/* TODO(nickm) we might need to refcount here. */\n\n\tfor (i = 0; i < base->n_req_heads; ++i) {\n\t\twhile (base->req_heads[i]) {\n\t\t\tif (fail_requests)\n\t\t\t\treply_schedule_callback(base->req_heads[i], 0, DNS_ERR_SHUTDOWN, NULL);\n\t\t\trequest_finished(base->req_heads[i], &REQ_HEAD(base, base->req_heads[i]->trans_id), 1);\n\t\t}\n\t}\n\twhile (base->req_waiting_head) {\n\t\tif (fail_requests)\n\t\t\treply_schedule_callback(base->req_waiting_head, 0, DNS_ERR_SHUTDOWN, NULL);\n\t\trequest_finished(base->req_waiting_head, &base->req_waiting_head, 1);\n\t}\n\tbase->global_requests_inflight = base->global_requests_waiting = 0;\n\n\tfor (server = base->server_head; server; server = server_next) {\n\t\tserver_next = server->next;\n\t\t/** already done something before */\n\t\tserver->probe_request = NULL;\n\t\tevdns_nameserver_free(server);\n\t\tif (server_next == base->server_head)\n\t\t\tbreak;\n\t}\n\tbase->server_head = NULL;\n\tbase->global_good_nameservers = 0;\n\n\tif (base->global_search_state) {\n\t\tfor (dom = base->global_search_state->head; dom; dom = dom_next) {\n\t\t\tdom_next = dom->next;\n\t\t\tmm_free(dom);\n\t\t}\n\t\tmm_free(base->global_search_state);\n\t\tbase->global_search_state = NULL;\n\t}\n\n\t{\n\t\tstruct hosts_entry *victim;\n\t\twhile ((victim = TAILQ_FIRST(&base->hostsdb))) {\n\t\t\tTAILQ_REMOVE(&base->hostsdb, victim, next);\n\t\t\tmm_free(victim);\n\t\t}\n\t}\n\n\tmm_free(base->req_heads);\n\n\tEVDNS_UNLOCK(base);\n\tEVTHREAD_FREE_LOCK(base->lock, EVTHREAD_LOCKTYPE_RECURSIVE);\n\n\tmm_free(base);\n}\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/libevent___libevent/git_repo_dir_4da9f87ccbe71edb3b3aaf74b8b64d7e9c41dcaf/build_4da9f87ccbe71edb3b3aaf74b8b64d7e9c41dcaf\nTest project /out/libevent___libevent/git_repo_dir_4da9f87ccbe71edb3b3aaf74b8b64d7e9c41dcaf/build_4da9f87ccbe71edb3b3aaf74b8b64d7e9c41dcaf\n    Start 17: regress__changelist_EPOLL\n1/5 Test #17: regress__changelist_EPOLL .........***Failed   97.94 sec\n    Start 18: regress__changelist_EPOLL_debug\n2/5 Test #18: regress__changelist_EPOLL_debug ...***Failed   96.05 sec\n    Start 35: regress__SELECT\n3/5 Test #35: regress__SELECT ...................***Failed   98.57 sec\n    Start 36: regress__SELECT_debug\n4/5 Test #36: regress__SELECT_debug .............   Passed   94.45 sec\n    Start 45: regress__POLL_debug\n5/5 Test #45: regress__POLL_debug ...............***Failed   99.21 sec\n\n20% tests passed, 4 tests failed out of 5\n\nTotal Test time (real) = 486.22 sec\n\nThe following tests FAILED:\n\t 17 - regress__changelist_EPOLL (Failed)\n\t 18 - regress__changelist_EPOLL_debug (Failed)\n\t 35 - regress__SELECT (Failed)\n\t 45 - regress__POLL_debug (Failed)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "4da9f87ccbe71edb3b3aaf74b8b64d7e9c41dcaf___evdns.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nclass ARROW_EXPORT BasicDecimal128 {\n public:\n  /// \\brief Create a BasicDecimal128 from the two's complement representation.\n  constexpr BasicDecimal128(int64_t high, uint64_t low) noexcept\n      : low_bits_(low), high_bits_(high) {}\n\n  /// \\brief Empty constructor creates a BasicDecimal128 with a value of 0.\n  constexpr BasicDecimal128() noexcept : BasicDecimal128(0, 0) {}\n\n  /// \\brief Convert any integer value into a BasicDecimal128.\n  template <typename T,\n            typename = typename std::enable_if<std::is_integral<T>::value, T>::type>\n  constexpr BasicDecimal128(T value) noexcept\n      : BasicDecimal128(static_cast<int64_t>(value) >= 0 ? 0 : -1,\n                        static_cast<uint64_t>(value)) {}\n\n  /// \\brief Create a BasicDecimal128 from an array of bytes. Bytes are assumed to be in\n  /// native-endian byte order.\n  explicit BasicDecimal128(const uint8_t* bytes);\n\n  /// \\brief Negate the current value (in-place)\n  BasicDecimal128& Negate();\n\n  /// \\brief Absolute value (in-place)\n  BasicDecimal128& Abs();\n\n  /// \\brief Absolute value\n  static BasicDecimal128 Abs(const BasicDecimal128& left);\n\n  /// \\brief Add a number to this one. The result is truncated to 128 bits.\n  BasicDecimal128& operator+=(const BasicDecimal128& right);\n\n  /// \\brief Subtract a number from this one. The result is truncated to 128 bits.\n  BasicDecimal128& operator-=(const BasicDecimal128& right);\n\n  /// \\brief Multiply this number by another number. The result is truncated to 128 bits.\n  BasicDecimal128& operator*=(const BasicDecimal128& right);\n\n  /// Divide this number by right and return the result.\n  ///\n  /// This operation is not destructive.\n  /// The answer rounds to zero. Signs work like:\n  ///   21 /  5 ->  4,  1\n  ///  -21 /  5 -> -4, -1\n  ///   21 / -5 -> -4,  1\n  ///  -21 / -5 ->  4, -1\n  /// \\param[in] divisor the number to divide by\n  /// \\param[out] result the quotient\n  /// \\param[out] remainder the remainder after the division\n  DecimalStatus Divide(const BasicDecimal128& divisor, BasicDecimal128* result,\n                       BasicDecimal128* remainder) const;\n\n  /// \\brief In-place division.\n  BasicDecimal128& operator/=(const BasicDecimal128& right);\n\n  /// \\brief Bitwise \"or\" between two BasicDecimal128.\n  BasicDecimal128& operator|=(const BasicDecimal128& right);\n\n  /// \\brief Bitwise \"and\" between two BasicDecimal128.\n  BasicDecimal128& operator&=(const BasicDecimal128& right);\n\n  /// \\brief Shift left by the given number of bits.\n  BasicDecimal128& operator<<=(uint32_t bits);\n\n  /// \\brief Shift right by the given number of bits. Negative values will\n  BasicDecimal128& operator>>=(uint32_t bits);\n\n  /// \\brief Get the high bits of the two's complement representation of the number.\n  inline int64_t high_bits() const { return high_bits_; }\n\n  /// \\brief Get the low bits of the two's complement representation of the number.\n  inline uint64_t low_bits() const { return low_bits_; }\n\n  /// \\brief Return the raw bytes of the value in native-endian byte order.\n  std::array<uint8_t, 16> ToBytes() const;\n  void ToBytes(uint8_t* out) const;\n\n  /// \\brief separate the integer and fractional parts for the given scale.\n  void GetWholeAndFraction(int32_t scale, BasicDecimal128* whole,\n                           BasicDecimal128* fraction) const;\n\n  /// \\brief Scale multiplier for given scale value.\n  static const BasicDecimal128& GetScaleMultiplier(int32_t scale);\n\n  /// \\brief Convert BasicDecimal128 from one scale to another\n  DecimalStatus Rescale(int32_t original_scale, int32_t new_scale,\n                        BasicDecimal128* out) const;\n\n  /// \\brief Scale up.\n  BasicDecimal128 IncreaseScaleBy(int32_t increase_by) const;\n\n  /// \\brief Scale down.\n  /// - If 'round' is true, the right-most digits are dropped and the result value is\n  ///   rounded up (+1 for +ve, -1 for -ve) based on the value of the dropped digits\n  ///   (>= 10^reduce_by / 2).\n  /// - If 'round' is false, the right-most digits are simply dropped.\n  BasicDecimal128 ReduceScaleBy(int32_t reduce_by, bool round = true) const;\n\n  /// \\brief Whether this number fits in the given precision\n  ///\n  /// Return true if the number of significant digits is less or equal to `precision`.\n  bool FitsInPrecision(int32_t precision) const;\n\n  // returns 1 for positive and zero decimal values, -1 for negative decimal values.\n  inline int64_t Sign() const { return 1 | (high_bits_ >> 63); }\n\n  /// \\brief count the number of leading binary zeroes.\n  int32_t CountLeadingBinaryZeros() const;\n\n  /// \\brief Get the maximum valid unscaled decimal value.\n  static const BasicDecimal128& GetMaxValue();\n\n private:\n  uint64_t low_bits_;\n  int64_t high_bits_;\n};\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_3d0a9d58b6fe29dcb208c3fa244c789449517988/build_3d0a9d58b6fe29dcb208c3fa244c789449517988\nTest project /out/apache___arrow/git_repo_dir_3d0a9d58b6fe29dcb208c3fa244c789449517988/build_3d0a9d58b6fe29dcb208c3fa244c789449517988\n    Start 20: arrow-utility-test\n1/1 Test #20: arrow-utility-test ...............***Failed    0.53 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow-tests    =   0.53 sec*proc (1 test)\nunittest       =   0.53 sec*proc (1 test)\n\nTotal Test time (real) =   0.54 sec\n\nThe following tests FAILED:\n\t 20 - arrow-utility-test (Failed)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "3d0a9d58b6fe29dcb208c3fa244c789449517988___basic_decimal.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nnamespace arrow {\n\nusing internal::BitmapEquals;\nusing internal::checked_cast;\n\n// ----------------------------------------------------------------------\n// Public method implementations\n\nnamespace {\n\n// These helper functions assume we already checked the arrays have equal\n// sizes and null bitmaps.\n\ntemplate <typename ArrowType, typename EqualityFunc>\ninline bool BaseFloatingEquals(const NumericArray<ArrowType>& left,\n                               const NumericArray<ArrowType>& right,\n                               EqualityFunc&& equals) {\n  using T = typename ArrowType::c_type;\n\n  const T* left_data = left.raw_values();\n  const T* right_data = right.raw_values();\n\n  if (left.null_count() > 0) {\n    for (int64_t i = 0; i < left.length(); ++i) {\n      if (left.IsNull(i)) continue;\n      if (!equals(left_data[i], right_data[i])) {\n        return false;\n      }\n    }\n  } else {\n    for (int64_t i = 0; i < left.length(); ++i) {\n      if (!equals(left_data[i], right_data[i])) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\ntemplate <typename ArrowType>\ninline bool FloatingEquals(const NumericArray<ArrowType>& left,\n                           const NumericArray<ArrowType>& right,\n                           const EqualOptions& opts) {\n  using T = typename ArrowType::c_type;\n\n  if (opts.nans_equal()) {\n    return BaseFloatingEquals<ArrowType>(left, right, [](T x, T y) -> bool {\n      return (x == y) || (std::isnan(x) && std::isnan(y));\n    });\n  } else {\n    return BaseFloatingEquals<ArrowType>(left, right,\n                                         [](T x, T y) -> bool { return x == y; });\n  }\n}\n\ntemplate <typename ArrowType>\ninline bool FloatingApproxEquals(const NumericArray<ArrowType>& left,\n                                 const NumericArray<ArrowType>& right,\n                                 const EqualOptions& opts) {\n  using T = typename ArrowType::c_type;\n  const T epsilon = static_cast<T>(opts.atol());\n\n  if (opts.nans_equal()) {\n    return BaseFloatingEquals<ArrowType>(left, right, [epsilon](T x, T y) -> bool {\n      return (fabs(x - y) <= epsilon) || (std::isnan(x) && std::isnan(y));\n    });\n  } else {\n    return BaseFloatingEquals<ArrowType>(\n        left, right, [epsilon](T x, T y) -> bool { return fabs(x - y) <= epsilon; });\n  }\n}\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_c4f8436e2532524c2a2f9cc26f73c6b7dfababaa/build_c4f8436e2532524c2a2f9cc26f73c6b7dfababaa\nTest project /out/apache___arrow/git_repo_dir_c4f8436e2532524c2a2f9cc26f73c6b7dfababaa/build_c4f8436e2532524c2a2f9cc26f73c6b7dfababaa\n    Start 1: arrow-array-test\n1/1 Test #1: arrow-array-test .................***Failed    6.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow-tests    =   6.02 sec*proc (1 test)\nunittest       =   6.02 sec*proc (1 test)\n\nTotal Test time (real) =   6.03 sec\n\nThe following tests FAILED:\n\t  1 - arrow-array-test (Failed)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "c4f8436e2532524c2a2f9cc26f73c6b7dfababaa___compare.cc"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nFoldingRule VectorShuffleFeedingShuffle() {\n  return [](IRContext* context, Instruction* inst,\n            const std::vector<const analysis::Constant*>&) {\n    assert(inst->opcode() == SpvOpVectorShuffle &&\n           \"Wrong opcode.  Should be OpVectorShuffle.\");\n\n    analysis::DefUseManager* def_use_mgr = context->get_def_use_mgr();\n    analysis::TypeManager* type_mgr = context->get_type_mgr();\n\n    Instruction* feeding_shuffle_inst =\n        def_use_mgr->GetDef(inst->GetSingleWordInOperand(0));\n    analysis::Vector* op0_type =\n        type_mgr->GetType(feeding_shuffle_inst->type_id())->AsVector();\n    uint32_t op0_length = op0_type->element_count();\n\n    bool feeder_is_op0 = true;\n    if (feeding_shuffle_inst->opcode() != SpvOpVectorShuffle) {\n      feeding_shuffle_inst =\n          def_use_mgr->GetDef(inst->GetSingleWordInOperand(1));\n      feeder_is_op0 = false;\n    }\n\n    if (feeding_shuffle_inst->opcode() != SpvOpVectorShuffle) {\n      return false;\n    }\n\n    Instruction* feeder2 =\n        def_use_mgr->GetDef(feeding_shuffle_inst->GetSingleWordInOperand(0));\n    analysis::Vector* feeder_op0_type =\n        type_mgr->GetType(feeder2->type_id())->AsVector();\n    uint32_t feeder_op0_length = feeder_op0_type->element_count();\n\n    uint32_t new_feeder_id = 0;\n    std::vector<Operand> new_operands;\n    new_operands.resize(\n        2, {SPV_OPERAND_TYPE_ID, {0}});  // Place holders for vector operands.\n    const uint32_t undef_literal = 0xffffffff;\n    for (uint32_t op = 2; op < inst->NumInOperands(); ++op) {\n      uint32_t component_index = inst->GetSingleWordInOperand(op);\n\n      // Do not interpret the undefined value literal as coming from operand 1.\n      if (component_index != undef_literal &&\n          feeder_is_op0 == (component_index < op0_length)) {\n        // This component comes from the feeding_shuffle_inst.  Update\n        // |component_index| to be the index into the operand of the feeder.\n\n        // Adjust component_index to get the index into the operands of the\n        // feeding_shuffle_inst.\n        if (component_index >= op0_length) {\n          component_index -= op0_length;\n        }\n        component_index =\n            feeding_shuffle_inst->GetSingleWordInOperand(component_index + 2);\n\n        // Check if we are using a component from the first or second operand of\n        // the feeding instruction.\n        if (component_index < feeder_op0_length) {\n          if (new_feeder_id == 0) {\n            // First time through, save the id of the operand the element comes\n            // from.\n            new_feeder_id = feeding_shuffle_inst->GetSingleWordInOperand(0);\n          } else if (new_feeder_id !=\n                     feeding_shuffle_inst->GetSingleWordInOperand(0)) {\n            // We need both elements of the feeding_shuffle_inst, so we cannot\n            // fold.\n            return false;\n          }\n        } else {\n          if (new_feeder_id == 0) {\n            // First time through, save the id of the operand the element comes\n            // from.\n            new_feeder_id = feeding_shuffle_inst->GetSingleWordInOperand(1);\n          } else if (new_feeder_id !=\n                     feeding_shuffle_inst->GetSingleWordInOperand(1)) {\n            // We need both elements of the feeding_shuffle_inst, so we cannot\n            // fold.\n            return false;\n          }\n          component_index -= feeder_op0_length;\n        }\n\n        if (!feeder_is_op0) {\n          component_index += op0_length;\n        }\n      }\n      new_operands.push_back(\n          {SPV_OPERAND_TYPE_LITERAL_INTEGER, {component_index}});\n    }\n\n    if (new_feeder_id == 0) {\n      analysis::ConstantManager* const_mgr = context->get_constant_mgr();\n      const analysis::Type* type =\n          type_mgr->GetType(feeding_shuffle_inst->type_id());\n      const analysis::Constant* null_const = const_mgr->GetConstant(type, {});\n      new_feeder_id =\n          const_mgr->GetDefiningInstruction(null_const, 0)->result_id();\n    }\n\n    if (feeder_is_op0) {\n      // If the size of the first vector operand changed then the indices\n      // referring to the second operand need to be adjusted.\n      Instruction* new_feeder_inst = def_use_mgr->GetDef(new_feeder_id);\n      analysis::Type* new_feeder_type =\n          type_mgr->GetType(new_feeder_inst->type_id());\n      uint32_t new_op0_size = new_feeder_type->AsVector()->element_count();\n      int32_t adjustment = op0_length - new_op0_size;\n\n      if (adjustment != 0) {\n        for (uint32_t i = 2; i < new_operands.size(); i++) {\n          if (inst->GetSingleWordInOperand(i) >= op0_length) {\n            new_operands[i].words[0] -= adjustment;\n          }\n        }\n      }\n\n      new_operands[0].words[0] = new_feeder_id;\n      new_operands[1] = inst->GetInOperand(1);\n    } else {\n      new_operands[1].words[0] = new_feeder_id;\n      new_operands[0] = inst->GetInOperand(0);\n    }\n\n    inst->SetInOperands(std::move(new_operands));\n    return true;\n  };\n}\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_48a36c72e4d358ed9f0a5e53fe775a7ebb2f8f2b/build_48a36c72e4d358ed9f0a5e53fe775a7ebb2f8f2b\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_48a36c72e4d358ed9f0a5e53fe775a7ebb2f8f2b/build_48a36c72e4d358ed9f0a5e53fe775a7ebb2f8f2b\n    Start 18: spirv-tools-test_opt\n1/2 Test #18: spirv-tools-test_opt .............***Exception: SegFault 43.52 sec\n    Start 20: spirv-tools-test_opt_loops\n2/2 Test #20: spirv-tools-test_opt_loops .......   Passed    5.09 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  48.62 sec\n\nThe following tests FAILED:\n\t 18 - spirv-tools-test_opt (SEGFAULT)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "48a36c72e4d358ed9f0a5e53fe775a7ebb2f8f2b___folding_rules.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic bool\ndecode_modrm(decode_info_t *di, byte optype, opnd_size_t opsize, opnd_t *reg_opnd,\n             opnd_t *rm_opnd)\n{\n    /* for x64, addr prefix affects only base/index and truncates final addr:\n     * modrm + sib table is the same\n     */\n    bool addr16 = !X64_MODE(di) && TEST(PREFIX_ADDR, di->prefixes);\n\n    if (reg_opnd != NULL) {\n        reg_id_t reg = decode_reg(DECODE_REG_REG, di, optype, opsize);\n        if (reg == REG_NULL)\n            return false;\n        *reg_opnd = opnd_create_reg(reg);\n        opnd_set_size(reg_opnd, resolve_variable_size(di, opsize, true /*is reg*/));\n    }\n\n    if (rm_opnd != NULL) {\n        reg_id_t base_reg = REG_NULL;\n        int disp = 0;\n        reg_id_t index_reg = REG_NULL;\n        int scale = 0;\n        char memtype = (optype == TYPE_VSIB ? TYPE_VSIB : TYPE_M);\n        opnd_size_t memsize = resolve_addr_size(di);\n        bool encode_zero_disp, force_full_disp;\n        if (di->has_disp)\n            disp = di->disp;\n        else\n            disp = 0;\n        if (di->has_sib) {\n            CLIENT_ASSERT(!addr16, \"decode error: x86 addr16 cannot have a SIB byte\");\n            if (di->index == 4 &&\n                /* rex.x enables r12 as index */\n                (!X64_MODE(di) || !TEST(PREFIX_REX_X, di->prefixes)) &&\n                optype != TYPE_VSIB) {\n                /* no scale/index */\n                index_reg = REG_NULL;\n            } else {\n                index_reg = decode_reg(DECODE_REG_INDEX, di, memtype, memsize);\n                if (index_reg == REG_NULL) {\n                    CLIENT_ASSERT(false, \"decode error: !index: internal modrm error\");\n                    return false;\n                }\n                if (di->scale == 0)\n                    scale = 1;\n                else if (di->scale == 1)\n                    scale = 2;\n                else if (di->scale == 2)\n                    scale = 4;\n                else if (di->scale == 3)\n                    scale = 8;\n            }\n            if (di->base == 5 && di->mod == 0) {\n                /* no base */\n                base_reg = REG_NULL;\n            } else {\n                base_reg = decode_reg(DECODE_REG_BASE, di, TYPE_M, memsize);\n                if (base_reg == REG_NULL) {\n                    CLIENT_ASSERT(false, \"decode error: internal modrm decode error\");\n                    return false;\n                }\n            }\n        } else {\n            if (optype == TYPE_VSIB)\n                return false; /* invalid w/o vsib byte */\n            if ((!addr16 && di->mod == 0 && di->rm == 5) ||\n                (addr16 && di->mod == 0 && di->rm == 6)) {\n                /* just absolute displacement, or rip-relative for x64 */\n#ifdef X64\n                if (X64_MODE(di)) {\n                    /* rip-relative: convert from relative offset to absolute target pc */\n                    byte *addr;\n                    CLIENT_ASSERT(di->start_pc != NULL,\n                                  \"internal decode error: start pc not set\");\n                    if (di->orig_pc != di->start_pc)\n                        addr = di->orig_pc + di->len + di->disp;\n                    else\n                        addr = di->start_pc + di->len + di->disp;\n                    if (TEST(PREFIX_ADDR, di->prefixes)) {\n                        /* Need to clear upper 32 bits.\n                         * Debuggers do not display this truncation, though\n                         * both Intel and AMD manuals describe it.\n                         * I did verify it w/ actual execution.\n                         */\n                        ASSERT_NOT_TESTED();\n                        addr = (byte *)((ptr_uint_t)addr & 0xffffffff);\n                    }\n                    *rm_opnd = opnd_create_far_rel_addr(\n                        di->seg_override, (void *)addr,\n                        resolve_variable_size(di, opsize, false));\n                    return true;\n                } else\n#endif\n                    base_reg = REG_NULL;\n                index_reg = REG_NULL;\n            } else if (di->mod == 3) {\n                /* register */\n                reg_id_t rm_reg = decode_reg(DECODE_REG_RM, di, optype, opsize);\n                if (rm_reg == REG_NULL) /* no assert since happens, e.g., ff d9 */\n                    return false;\n                else {\n                    *rm_opnd = opnd_create_reg(rm_reg);\n                    opnd_set_size(rm_opnd,\n                                  resolve_variable_size(di, opsize, true /*is reg*/));\n                    return true;\n                }\n            } else {\n                /* non-sib reg-based memory address */\n                if (addr16) {\n                    /* funny order requiring custom decode */\n                    switch (di->rm) {\n                    case 0:\n                        base_reg = REG_BX;\n                        index_reg = REG_SI;\n                        scale = 1;\n                        break;\n                    case 1:\n                        base_reg = REG_BX;\n                        index_reg = REG_DI;\n                        scale = 1;\n                        break;\n                    case 2:\n                        base_reg = REG_BP;\n                        index_reg = REG_SI;\n                        scale = 1;\n                        break;\n                    case 3:\n                        base_reg = REG_BP;\n                        index_reg = REG_DI;\n                        scale = 1;\n                        break;\n                    case 4: base_reg = REG_SI; break;\n                    case 5: base_reg = REG_DI; break;\n                    case 6:\n                        base_reg = REG_BP;\n                        CLIENT_ASSERT(di->mod != 0,\n                                      \"decode error: %bp cannot have mod 0\");\n                        break;\n                    case 7: base_reg = REG_BX; break;\n                    default:\n                        CLIENT_ASSERT(false, \"decode error: unknown modrm rm\");\n                        break;\n                    }\n                } else {\n                    /* single base reg */\n                    base_reg = decode_reg(DECODE_REG_RM, di, memtype, memsize);\n                    if (base_reg == REG_NULL) {\n                        CLIENT_ASSERT(false,\n                                      \"decode error: !base: internal modrm decode error\");\n                        return false;\n                    }\n                }\n            }\n        }\n        /* We go ahead and preserve the force bools if the original really had a 0\n         * disp; up to user to unset bools when changing disp value (FIXME: should\n         * we auto-unset on first mod?)\n         */\n        encode_zero_disp = di->has_disp && disp == 0 &&\n            /* there is no bp base without a disp */\n            (!addr16 || base_reg != REG_BP);\n        /* With evex encoding, disp8 is subject to compression and a scale factor.\n         * Hence, displacments not divisible by the scale factor need to be encoded\n         * with full displacement, no need (and actually incorrect) to \"force\" it.\n         */\n        bool needs_full_disp = false;\n        int compressed_disp_scale = 0;\n        if (di->evex_encoded) {\n            compressed_disp_scale = decode_get_compressed_disp_scale(di);\n            if (compressed_disp_scale == -1)\n                return false;\n            needs_full_disp = disp % compressed_disp_scale != 0;\n        }\n        force_full_disp = !needs_full_disp && di->has_disp && disp >= INT8_MIN &&\n            disp <= INT8_MAX && di->mod == 2;\n        if (di->seg_override != REG_NULL) {\n            *rm_opnd = opnd_create_far_base_disp_ex(\n                di->seg_override, base_reg, index_reg, scale, disp,\n                resolve_variable_size(di, opsize, false), encode_zero_disp,\n                force_full_disp, TEST(PREFIX_ADDR, di->prefixes));\n        } else {\n            /* Note that OP_{jmp,call}_far_ind does NOT have a far base disp\n             * operand: it is a regular base disp containing 6 bytes that\n             * specify a segment selector and address.  The opcode must be\n             * examined to know how to interpret those 6 bytes.\n             */\n            if (di->evex_encoded) {\n                if (di->mod == 1)\n                    disp *= compressed_disp_scale;\n            }\n            *rm_opnd = opnd_create_base_disp_ex(base_reg, index_reg, scale, disp,\n                                                resolve_variable_size(di, opsize, false),\n                                                encode_zero_disp, force_full_disp,\n                                                TEST(PREFIX_ADDR, di->prefixes));\n        }\n    }\n    return true;\n}\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/DynamoRIO___dynamorio/git_repo_dir_452c17abfd19fdefff52d3f3d4e2b76af809c93d/build_452c17abfd19fdefff52d3f3d4e2b76af809c93d\nTest project /out/DynamoRIO___dynamorio/git_repo_dir_452c17abfd19fdefff52d3f3d4e2b76af809c93d/build_452c17abfd19fdefff52d3f3d4e2b76af809c93d\n    Start 367: code_api|api.ir\n1/3 Test #367: code_api|api.ir ..................***Failed  Required regular expression not found. Regex=[^(<Invalid VSIB register encoding encountered>\n<Invalid AVX-512 vector length encountered.>\n)?(<Application .*api\\.ir.*AVX-512 was detected at PC 0x[0-9a-f]+. AVX-512 is not fully supported yet.>\n)?all done\n$\n]  0.03 sec\n    Start 368: code_api|api.ir-static\n2/3 Test #368: code_api|api.ir-static ...........***Failed  Required regular expression not found. Regex=[^(<Invalid VSIB register encoding encountered>\n<Invalid AVX-512 vector length encountered.>\n)?(<Application .*api\\.ir.*AVX-512 was detected at PC 0x[0-9a-f]+. AVX-512 is not fully supported yet.>\n)?all done\n$\n]  0.24 sec\n    Start 384: code_api|api.ibl-stress\n3/3 Test #384: code_api|api.ibl-stress ..........   Passed    1.51 sec\n\n33% tests passed, 2 tests failed out of 3\n\nTotal Test time (real) =   1.94 sec\n\nThe following tests FAILED:\n\t367 - code_api|api.ir (Failed)\n\t368 - code_api|api.ir-static (Failed)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "452c17abfd19fdefff52d3f3d4e2b76af809c93d___decode.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic Value *isSafeToSpeculateStore(Instruction *I, BasicBlock *BrBB,\n                                     BasicBlock *StoreBB, BasicBlock *EndBB) {\n  StoreInst *StoreToHoist = dyn_cast<StoreInst>(I);\n  if (!StoreToHoist)\n    return nullptr;\n\n  // Volatile or atomic.\n  if (!StoreToHoist->isSimple())\n    return nullptr;\n\n  Value *StorePtr = StoreToHoist->getPointerOperand();\n\n  // Look for a store to the same pointer in BrBB.\n  unsigned MaxNumInstToLookAt = 10;\n  for (BasicBlock::reverse_iterator RI = BrBB->rbegin(),\n       RE = BrBB->rend(); RI != RE && (--MaxNumInstToLookAt); ++RI) {\n    Instruction *CurI = &*RI;\n\n    // Could be calling an instruction that effects memory like free().\n    if (CurI->mayHaveSideEffects() && !isa<StoreInst>(CurI))\n      return nullptr;\n\n    StoreInst *SI = dyn_cast<StoreInst>(CurI);\n    // Found the previous store make sure it stores to the same location.\n    if (SI && SI->getPointerOperand() == StorePtr)\n      // Found the previous store, return its value operand.\n      return SI->getValueOperand();\n    else if (SI)\n      return nullptr; // Unknown store.\n  }\n\n  return nullptr;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/SimplifyCFG/PR27615-simplify-cond-br.ll (1 of 1)\nTesting Time: 0.19s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/SimplifyCFG/PR27615-simplify-cond-br.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "0c3518e84b668975df03ac8b9620d7bf181bd349___SimplifyCFG.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nvoid DwarfUnit::constructMemberDIE(DIE &Buffer, const DIDerivedType *DT) {\n  DIE &MemberDie = createAndAddDIE(DT->getTag(), Buffer);\n  StringRef Name = DT->getName();\n  if (!Name.empty())\n    addString(MemberDie, dwarf::DW_AT_name, Name);\n\n  addType(MemberDie, resolve(DT->getBaseType()));\n\n  addSourceLine(MemberDie, DT);\n\n  if (DT->getTag() == dwarf::DW_TAG_inheritance && DT->isVirtual()) {\n\n    // For C++, virtual base classes are not at fixed offset. Use following\n    // expression to extract appropriate offset from vtable.\n    // BaseAddr = ObAddr + *((*ObAddr) - Offset)\n\n    DIELoc *VBaseLocationDie = new (DIEValueAllocator) DIELoc;\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_dup);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_constu);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_udata, DT->getOffsetInBits());\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_minus);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus);\n\n    addBlock(MemberDie, dwarf::DW_AT_data_member_location, VBaseLocationDie);\n  } else {\n    uint64_t Size = DT->getSizeInBits();\n    uint64_t FieldSize = getBaseTypeSize(DD, DT);\n    uint64_t OffsetInBytes;\n\n    if (FieldSize && Size != FieldSize) {\n      // Handle bitfield, assume bytes are 8 bits.\n      if (DD->getDwarfVersion() < 4)\n        addUInt(MemberDie, dwarf::DW_AT_byte_size, None, FieldSize/8);\n      addUInt(MemberDie, dwarf::DW_AT_bit_size, None, Size);\n\n      uint64_t Offset = DT->getOffsetInBits();\n      uint64_t Align = DT->getAlignInBits() ? DT->getAlignInBits() : FieldSize;\n      uint64_t AlignMask = ~(Align - 1);\n      // The bits from the start of the storage unit to the start of the field.\n      uint64_t StartBitOffset = Offset - (Offset & AlignMask);\n      // The byte offset of the field's aligned storage unit inside the struct.\n      OffsetInBytes = (Offset - StartBitOffset) / 8;\n\n      if (DD->getDwarfVersion() >= 4)\n        addUInt(MemberDie, dwarf::DW_AT_data_bit_offset, None, Offset);\n      else {\n        uint64_t HiMark = (Offset + FieldSize) & AlignMask;\n        uint64_t FieldOffset = (HiMark - FieldSize);\n        Offset -= FieldOffset;\n\n        // Maybe we need to work from the other end.\n        if (Asm->getDataLayout().isLittleEndian())\n          Offset = FieldSize - (Offset + Size);\n\n        addUInt(MemberDie, dwarf::DW_AT_bit_offset, None, Offset);\n        OffsetInBytes = FieldOffset >> 3;\n      }\n    } else\n      // This is not a bitfield.\n      OffsetInBytes = DT->getOffsetInBits() / 8;\n\n    if (DD->getDwarfVersion() <= 2) {\n      DIELoc *MemLocationDie = new (DIEValueAllocator) DIELoc;\n      addUInt(*MemLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus_uconst);\n      addUInt(*MemLocationDie, dwarf::DW_FORM_udata, OffsetInBytes);\n      addBlock(MemberDie, dwarf::DW_AT_data_member_location, MemLocationDie);\n    } else\n      addUInt(MemberDie, dwarf::DW_AT_data_member_location, None,\n              OffsetInBytes);\n  }\n\n  if (DT->isProtected())\n    addUInt(MemberDie, dwarf::DW_AT_accessibility, dwarf::DW_FORM_data1,\n            dwarf::DW_ACCESS_protected);\n  else if (DT->isPrivate())\n    addUInt(MemberDie, dwarf::DW_AT_accessibility, dwarf::DW_FORM_data1,\n            dwarf::DW_ACCESS_private);\n  // Otherwise C++ member and base classes are considered public.\n  else if (DT->isPublic())\n    addUInt(MemberDie, dwarf::DW_AT_accessibility, dwarf::DW_FORM_data1,\n            dwarf::DW_ACCESS_public);\n  if (DT->isVirtual())\n    addUInt(MemberDie, dwarf::DW_AT_virtuality, dwarf::DW_FORM_data1,\n            dwarf::DW_VIRTUALITY_virtual);\n\n  // Objective-C properties.\n  if (DINode *PNode = DT->getObjCProperty())\n    if (DIE *PDie = getDIE(PNode))\n      MemberDie.addValue(DIEValueAllocator, dwarf::DW_AT_APPLE_property,\n                         dwarf::DW_FORM_ref4, DIEEntry(*PDie));\n\n  if (DT->isArtificial())\n    addFlag(MemberDie, dwarf::DW_AT_artificial);\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/X86/bitfields-dwarf4.ll (1 of 1)\nTesting Time: 0.07s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/bitfields-dwarf4.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "7aa34c8cbb7f81737666d08217769d6ef81181d5___DwarfUnit.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic OverwriteResult isOverwrite(const MemoryLocation &Later,\n                                   const MemoryLocation &Earlier,\n                                   const DataLayout &DL,\n                                   const TargetLibraryInfo &TLI,\n                                   int64_t &EarlierOff, int64_t &LaterOff,\n                                   Instruction *DepWrite,\n                                   InstOverlapIntervalsTy &IOL) {\n  // If we don't know the sizes of either access, then we can't do a comparison.\n  if (Later.Size == MemoryLocation::UnknownSize ||\n      Earlier.Size == MemoryLocation::UnknownSize)\n    return OverwriteUnknown;\n\n  const Value *P1 = Earlier.Ptr->stripPointerCasts();\n  const Value *P2 = Later.Ptr->stripPointerCasts();\n\n  // If the start pointers are the same, we just have to compare sizes to see if\n  // the later store was larger than the earlier store.\n  if (P1 == P2) {\n    // Make sure that the Later size is >= the Earlier size.\n    if (Later.Size >= Earlier.Size)\n      return OverwriteComplete;\n  }\n\n  // Check to see if the later store is to the entire object (either a global,\n  // an alloca, or a byval/inalloca argument).  If so, then it clearly\n  // overwrites any other store to the same object.\n  const Value *UO1 = GetUnderlyingObject(P1, DL),\n              *UO2 = GetUnderlyingObject(P2, DL);\n\n  // If we can't resolve the same pointers to the same object, then we can't\n  // analyze them at all.\n  if (UO1 != UO2)\n    return OverwriteUnknown;\n\n  // If the \"Later\" store is to a recognizable object, get its size.\n  uint64_t ObjectSize = getPointerSize(UO2, DL, TLI);\n  if (ObjectSize != MemoryLocation::UnknownSize)\n    if (ObjectSize == Later.Size && ObjectSize >= Earlier.Size)\n      return OverwriteComplete;\n\n  // Okay, we have stores to two completely different pointers.  Try to\n  // decompose the pointer into a \"base + constant_offset\" form.  If the base\n  // pointers are equal, then we can reason about the two stores.\n  EarlierOff = 0;\n  LaterOff = 0;\n  const Value *BP1 = GetPointerBaseWithConstantOffset(P1, EarlierOff, DL);\n  const Value *BP2 = GetPointerBaseWithConstantOffset(P2, LaterOff, DL);\n\n  // If the base pointers still differ, we have two completely different stores.\n  if (BP1 != BP2)\n    return OverwriteUnknown;\n\n  // The later store completely overlaps the earlier store if:\n  //\n  // 1. Both start at the same offset and the later one's size is greater than\n  //    or equal to the earlier one's, or\n  //\n  //      |--earlier--|\n  //      |--   later   --|\n  //\n  // 2. The earlier store has an offset greater than the later offset, but which\n  //    still lies completely within the later store.\n  //\n  //        |--earlier--|\n  //    |-----  later  ------|\n  //\n  // We have to be careful here as *Off is signed while *.Size is unsigned.\n  if (EarlierOff >= LaterOff &&\n      Later.Size >= Earlier.Size &&\n      uint64_t(EarlierOff - LaterOff) + Earlier.Size <= Later.Size)\n    return OverwriteComplete;\n\n  // We may now overlap, although the overlap is not complete. There might also\n  // be other incomplete overlaps, and together, they might cover the complete\n  // earlier write.\n  // Note: The correctness of this logic depends on the fact that this function\n  // is not even called providing DepWrite when there are any intervening reads.\n  if (EnablePartialOverwriteTracking &&\n      LaterOff < int64_t(EarlierOff + Earlier.Size) &&\n      int64_t(LaterOff + Later.Size) >= EarlierOff) {\n\n    // Insert our part of the overlap into the map.\n    auto &IM = IOL[DepWrite];\n    DEBUG(dbgs() << \"DSE: Partial overwrite: Earlier [\" << EarlierOff << \", \" <<\n                    int64_t(EarlierOff + Earlier.Size) << \") Later [\" <<\n                    LaterOff << \", \" << int64_t(LaterOff + Later.Size) << \")\\n\");\n\n    // Make sure that we only insert non-overlapping intervals and combine\n    // adjacent intervals. The intervals are stored in the map with the ending\n    // offset as the key (in the half-open sense) and the starting offset as\n    // the value.\n    int64_t LaterIntStart = LaterOff, LaterIntEnd = LaterOff + Later.Size;\n\n    // Find any intervals ending at, or after, LaterIntStart which start\n    // before LaterIntEnd.\n    auto ILI = IM.lower_bound(LaterIntStart);\n    if (ILI != IM.end() && ILI->second < LaterIntEnd) {\n      // This existing interval ends in the middle of\n      // [LaterIntStart, LaterIntEnd), erase it adjusting our start.\n      LaterIntStart = std::min(LaterIntStart, ILI->second);\n      LaterIntEnd = std::max(LaterIntEnd, ILI->first);\n      ILI = IM.erase(ILI);\n\n      while (ILI != IM.end() && ILI->first <= LaterIntEnd)\n        ILI = IM.erase(ILI);\n\n      if (ILI != IM.end() && ILI->second < LaterIntEnd)\n        LaterIntEnd = std::max(LaterIntEnd, ILI->first);\n    }\n\n    IM[LaterIntEnd] = LaterIntStart;\n\n    ILI = IM.begin();\n    if (ILI->second <= EarlierOff &&\n        ILI->first >= int64_t(EarlierOff + Earlier.Size)) {\n      DEBUG(dbgs() << \"DSE: Full overwrite from partials: Earlier [\" <<\n                      EarlierOff << \", \" <<\n                      int64_t(EarlierOff + Earlier.Size) <<\n                      \") Composite Later [\" <<\n                      ILI->second << \", \" << ILI->first << \")\\n\");\n      ++NumCompletePartials;\n      return OverwriteComplete;\n    }\n  }\n\n  // Another interesting case is if the later store overwrites the end of the\n  // earlier store.\n  //\n  //      |--earlier--|\n  //                |--   later   --|\n  //\n  // In this case we may want to trim the size of earlier to avoid generating\n  // writes to addresses which will definitely be overwritten later\n  if (LaterOff > EarlierOff &&\n      LaterOff < int64_t(EarlierOff + Earlier.Size) &&\n      int64_t(LaterOff + Later.Size) >= int64_t(EarlierOff + Earlier.Size))\n    return OverwriteEnd;\n\n  // Finally, we also need to check if the later store overwrites the beginning\n  // of the earlier store.\n  //\n  //                |--earlier--|\n  //      |--   later   --|\n  //\n  // In this case we may want to move the destination address and trim the size\n  // of earlier to avoid generating writes to addresses which will definitely\n  // be overwritten later.\n  if (LaterOff <= EarlierOff && int64_t(LaterOff + Later.Size) > EarlierOff) {\n    assert (int64_t(LaterOff + Later.Size) < int64_t(EarlierOff + Earlier.Size)\n            && \"Expect to be handled as OverwriteComplete\" );\n    return OverwriteBegin;\n  }\n  // Otherwise, they don't completely overlap.\n  return OverwriteUnknown;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/DeadStoreElimination/combined-partial-overwrites.ll (1 of 1)\nTesting Time: 0.11s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/DeadStoreElimination/combined-partial-overwrites.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "596a3bd9ece335303c14cd3d33cbc4cb1717db88___DeadStoreElimination.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nbool llvm::UpgradeModuleFlags(Module &M) {\n  const NamedMDNode *ModFlags = M.getModuleFlagsMetadata();\n  if (!ModFlags)\n    return false;\n\n  bool HasObjCFlag = false, HasClassProperties = false;\n  for (unsigned I = 0, E = ModFlags->getNumOperands(); I != E; ++I) {\n    MDNode *Op = ModFlags->getOperand(I);\n    if (Op->getNumOperands() < 2)\n      continue;\n    MDString *ID = dyn_cast_or_null<MDString>(Op->getOperand(1));\n    if (!ID)\n      continue;\n    if (ID->getString() == \"Objective-C Image Info Version\")\n      HasObjCFlag = true;\n    if (ID->getString() == \"Objective-C Class Properties\")\n      HasClassProperties = true;\n  }\n  // \"Objective-C Class Properties\" is recently added for Objective-C. We\n  // upgrade ObjC bitcodes to contain a \"Objective-C Class Properties\" module\n  // flag of value 0, so we can correclty report error when trying to link\n  // an ObjC bitcode without this module flag with an ObjC bitcode with this\n  // module flag.\n  if (HasObjCFlag && !HasClassProperties) {\n    M.addModuleFlag(llvm::Module::Error, \"Objective-C Class Properties\",\n                    (uint32_t)0);\n    return true;\n  }\n  return false;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Bitcode/upgrade-module-flag.ll (1 of 1)\nTesting Time: 0.26s\n********************\nFailing Tests (1):\n    LLVM :: Bitcode/upgrade-module-flag.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Linker/objectivec-class-property-flag-mismatch.ll (1 of 1)\nTesting Time: 0.45s\n********************\nFailing Tests (1):\n    LLVM :: Linker/objectivec-class-property-flag-mismatch.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "b53b62eb69cd5768423786c5ced700bc2d1d2e20___AutoUpgrade.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic bool sinkLastInstruction(ArrayRef<BasicBlock*> Blocks) {\n  auto *BBEnd = Blocks[0]->getTerminator()->getSuccessor(0);\n\n  // canSinkLastInstruction returning true guarantees that every block has at\n  // least one non-terminator instruction.\n  SmallVector<Instruction*,4> Insts;\n  for (auto *BB : Blocks)\n    Insts.push_back(BB->getTerminator()->getPrevNode());\n\n  // The only checking we need to do now is that all users of all instructions\n  // are the same PHI node. canSinkLastInstruction should have checked this but\n  // it is slightly over-aggressive - it gets confused by commutative instructions\n  // so double-check it here.\n  Instruction *I0 = Insts.front();\n  if (!isa<StoreInst>(I0)) {\n    auto *PNUse = dyn_cast<PHINode>(*I0->user_begin());\n    if (!all_of(Insts, [&PNUse](const Instruction *I) -> bool {\n          auto *U = cast<Instruction>(*I->user_begin());\n          return U == PNUse;\n        }))\n      return false;\n  }\n  \n  // We don't need to do any more checking here; canSinkLastInstruction should\n  // have done it all for us.\n  SmallVector<Value*, 4> NewOperands;\n  for (unsigned O = 0, E = I0->getNumOperands(); O != E; ++O) {\n    // This check is different to that in canSinkLastInstruction. There, we\n    // cared about the global view once simplifycfg (and instcombine) have\n    // completed - it takes into account PHIs that become trivially\n    // simplifiable.  However here we need a more local view; if an operand\n    // differs we create a PHI and rely on instcombine to clean up the very\n    // small mess we may make.\n    bool NeedPHI = any_of(Insts, [&I0, O](const Instruction *I) {\n      return I->getOperand(O) != I0->getOperand(O);\n    });\n    if (!NeedPHI) {\n      NewOperands.push_back(I0->getOperand(O));\n      continue;\n    }\n\n    // Create a new PHI in the successor block and populate it.\n    auto *Op = I0->getOperand(O);\n    assert(!Op->getType()->isTokenTy() && \"Can't PHI tokens!\");\n    auto *PN = PHINode::Create(Op->getType(), Insts.size(),\n                               Op->getName() + \".sink\", &BBEnd->front());\n    for (auto *I : Insts)\n      PN->addIncoming(I->getOperand(O), I->getParent());\n    NewOperands.push_back(PN);\n  }\n\n  // Arbitrarily use I0 as the new \"common\" instruction; remap its operands\n  // and move it to the start of the successor block.\n  for (unsigned O = 0, E = I0->getNumOperands(); O != E; ++O)\n    I0->getOperandUse(O).set(NewOperands[O]);\n  I0->moveBefore(&*BBEnd->getFirstInsertionPt());\n\n  // Update metadata.\n  for (auto *I : Insts)\n    if (I != I0)\n      combineMetadataForCSE(I0, I);\n\n  if (!isa<StoreInst>(I0)) {\n    // canSinkLastInstruction checked that all instructions were used by\n    // one and only one PHI node. Find that now, RAUW it to our common\n    // instruction and nuke it.\n    assert(I0->hasOneUse());\n    auto *PN = cast<PHINode>(*I0->user_begin());\n    PN->replaceAllUsesWith(I0);\n    PN->eraseFromParent();\n  }\n\n  // Finally nuke all instructions apart from the common instruction.\n  for (auto *I : Insts)\n    if (I != I0)\n      I->eraseFromParent();\n\n  return true;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/SimplifyCFG/sink-common-code.ll (1 of 1)\nTesting Time: 0.15s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/SimplifyCFG/sink-common-code.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "0efb96a8ee1b57c39fb732a098f88b3410fc4aeb___SimplifyCFG.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nInstruction *InstCombiner::visitSwitchInst(SwitchInst &SI) {\n  Value *Cond = SI.getCondition();\n  unsigned BitWidth = cast<IntegerType>(Cond->getType())->getBitWidth();\n  APInt KnownZero(BitWidth, 0), KnownOne(BitWidth, 0);\n  computeKnownBits(Cond, KnownZero, KnownOne, 0, &SI);\n  unsigned LeadingKnownZeros = KnownZero.countLeadingOnes();\n  unsigned LeadingKnownOnes = KnownOne.countLeadingOnes();\n\n  // Compute the number of leading bits we can ignore.\n  // TODO: A better way to determine this would use ComputeNumSignBits().\n  for (auto &C : SI.cases()) {\n    LeadingKnownZeros = std::min(\n        LeadingKnownZeros, C.getCaseValue()->getValue().countLeadingZeros());\n    LeadingKnownOnes = std::min(\n        LeadingKnownOnes, C.getCaseValue()->getValue().countLeadingOnes());\n  }\n\n  unsigned NewWidth = BitWidth - std::max(LeadingKnownZeros, LeadingKnownOnes);\n\n  // Shrink the condition operand if the new type is smaller than the old type.\n  // This may produce a non-standard type for the switch, but that's ok because\n  // the backend should extend back to a legal type for the target.\n  bool TruncCond = false;\n  if (NewWidth > 0 && NewWidth < BitWidth) {\n    TruncCond = true;\n    IntegerType *Ty = IntegerType::get(SI.getContext(), NewWidth);\n    Builder->SetInsertPoint(&SI);\n    Value *NewCond = Builder->CreateTrunc(Cond, Ty, \"trunc\");\n    SI.setCondition(NewCond);\n\n    for (auto &C : SI.cases())\n      static_cast<SwitchInst::CaseIt *>(&C)->setValue(ConstantInt::get(\n          SI.getContext(), C.getCaseValue()->getValue().trunc(NewWidth)));\n  }\n\n  ConstantInt *AddRHS = nullptr;\n  if (match(Cond, m_Add(m_Value(), m_ConstantInt(AddRHS)))) {\n    Instruction *I = cast<Instruction>(Cond);\n    // Change 'switch (X+4) case 1:' into 'switch (X) case -3'.\n    for (SwitchInst::CaseIt i = SI.case_begin(), e = SI.case_end(); i != e;\n         ++i) {\n      ConstantInt *CaseVal = i.getCaseValue();\n      Constant *LHS = CaseVal;\n      if (TruncCond) {\n        LHS = LeadingKnownZeros\n                  ? ConstantExpr::getZExt(CaseVal, Cond->getType())\n                  : ConstantExpr::getSExt(CaseVal, Cond->getType());\n      }\n      Constant *NewCaseVal = ConstantExpr::getSub(LHS, AddRHS);\n      assert(isa<ConstantInt>(NewCaseVal) &&\n             \"Result of expression should be constant\");\n      i.setValue(cast<ConstantInt>(NewCaseVal));\n    }\n    SI.setCondition(I->getOperand(0));\n    Worklist.Add(I);\n    return &SI;\n  }\n\n  return TruncCond ? &SI : nullptr;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/switch-constant-expr.ll (1 of 1)\nTesting Time: 0.39s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/switch-constant-expr.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "fd0d7b21e0b974dcb8ee6257ae4ef4fa7398e80b___InstructionCombining.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nTypeIndex CodeViewDebug::lowerTypeArray(const DICompositeType *Ty) {\n  DITypeRef ElementTypeRef = Ty->getBaseType();\n  TypeIndex ElementTypeIndex = getTypeIndex(ElementTypeRef);\n  // IndexType is size_t, which depends on the bitness of the target.\n  TypeIndex IndexType = Asm->TM.getPointerSize() == 8\n                            ? TypeIndex(SimpleTypeKind::UInt64Quad)\n                            : TypeIndex(SimpleTypeKind::UInt32Long);\n\n  uint64_t ElementSize = getBaseTypeSize(ElementTypeRef) / 8;\n\n  // Add subranges to array type.\n  DINodeArray Elements = Ty->getElements();\n  for (int i = Elements.size() - 1; i >= 0; --i) {\n    const DINode *Element = Elements[i];\n    assert(Element->getTag() == dwarf::DW_TAG_subrange_type);\n\n    const DISubrange *Subrange = cast<DISubrange>(Element);\n    assert(Subrange->getLowerBound() == 0 &&\n           \"codeview doesn't support subranges with lower bounds\");\n    int64_t Count = Subrange->getCount();\n\n    // Variable Length Array (VLA) has Count equal to '-1'.\n    // Replace with Count '1', assume it is the minimum VLA length.\n    // FIXME: Make front-end support VLA subrange and emit LF_DIMVARLU.\n    if (Count == -1)\n      Count = 1;\n\n    // Update the element size and element type index for subsequent subranges.\n    ElementSize *= Count;\n\n    // If this is the outermost array, use the size from the array. It will be\n    // more accurate if we had a VLA or an incomplete element type size.\n    uint64_t ArraySize =\n        (i == 0 && ElementSize == 0) ? Ty->getSizeInBits() / 8 : ElementSize;\n\n    StringRef Name = (i == 0) ? Ty->getName() : \"\";\n    ArrayRecord AR(ElementTypeIndex, IndexType, ArraySize, Name);\n    ElementTypeIndex = TypeTable.writeKnownType(AR);\n  }\n\n  return ElementTypeIndex;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/COFF/types-array-advanced.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/COFF/types-array-advanced.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: DebugInfo/COFF/types-array-unsized.ll (1 of 1)\nTesting Time: 0.11s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/COFF/types-array-unsized.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "89af112cf590e76fbb1fd964086a3882b7f935f9___CodeViewDebug.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic const TargetRegisterClass *getDstRC(const TargetRegisterClass *SrcRC,\n                                           RegDomain Domain) {\n  assert(Domain == MaskDomain && \"add domain\");\n  if (SrcRC == &X86::GR8RegClass)\n    return &X86::VK8RegClass;\n  if (SrcRC == &X86::GR16RegClass)\n    return &X86::VK16RegClass;\n  if (SrcRC == &X86::GR32RegClass)\n    return &X86::VK32RegClass;\n  if (SrcRC == &X86::GR64RegClass)\n    return &X86::VK64RegClass;\n  llvm_unreachable(\"add register class\");\n  return nullptr;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/gpr-to-mask.ll (1 of 1)\nTesting Time: 0.71s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/gpr-to-mask.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "f3cefdd3505ebba0bd2c1625228033f2d3745564___X86DomainReassignment.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic GlobalVariable *SRAGlobal(GlobalVariable *GV, const DataLayout &DL) {\n  // Make sure this global only has simple uses that we can SRA.\n  if (!GlobalUsersSafeToSRA(GV))\n    return nullptr;\n\n  assert(GV->hasLocalLinkage());\n  Constant *Init = GV->getInitializer();\n  Type *Ty = Init->getType();\n\n  std::vector<GlobalVariable *> NewGlobals;\n  Module::GlobalListType &Globals = GV->getParent()->getGlobalList();\n\n  // Get the alignment of the global, either explicit or target-specific.\n  unsigned StartAlignment = GV->getAlignment();\n  if (StartAlignment == 0)\n    StartAlignment = DL.getABITypeAlignment(GV->getType());\n\n  if (StructType *STy = dyn_cast<StructType>(Ty)) {\n    unsigned NumElements = STy->getNumElements();\n    NewGlobals.reserve(NumElements);\n    const StructLayout &Layout = *DL.getStructLayout(STy);\n    for (unsigned i = 0, e = NumElements; i != e; ++i) {\n      Constant *In = Init->getAggregateElement(i);\n      assert(In && \"Couldn't get element of initializer?\");\n      GlobalVariable *NGV = new GlobalVariable(STy->getElementType(i), false,\n                                               GlobalVariable::InternalLinkage,\n                                               In, GV->getName()+\".\"+Twine(i),\n                                               GV->getThreadLocalMode(),\n                                              GV->getType()->getAddressSpace());\n      NGV->setExternallyInitialized(GV->isExternallyInitialized());\n      NGV->copyAttributesFrom(GV);\n      Globals.push_back(NGV);\n      NewGlobals.push_back(NGV);\n\n      // Calculate the known alignment of the field.  If the original aggregate\n      // had 256 byte alignment for example, something might depend on that:\n      // propagate info to each field.\n      uint64_t FieldOffset = Layout.getElementOffset(i);\n      unsigned NewAlign = (unsigned)MinAlign(StartAlignment, FieldOffset);\n      if (NewAlign > DL.getABITypeAlignment(STy->getElementType(i)))\n        NGV->setAlignment(NewAlign);\n\n      // Copy over the debug info for the variable.\n      uint64_t Size = DL.getTypeSizeInBits(NGV->getValueType());\n      uint64_t FragmentOffsetInBits = Layout.getElementOffsetInBits(i);\n      transferSRADebugInfo(GV, NGV, FragmentOffsetInBits, Size, NumElements);\n    }\n  } else if (SequentialType *STy = dyn_cast<SequentialType>(Ty)) {\n    unsigned NumElements = STy->getNumElements();\n    if (NumElements > 16 && GV->hasNUsesOrMore(16))\n      return nullptr; // It's not worth it.\n    NewGlobals.reserve(NumElements);\n    auto ElTy = STy->getElementType();\n    uint64_t EltSize = DL.getTypeAllocSize(ElTy);\n    unsigned EltAlign = DL.getABITypeAlignment(ElTy);\n    uint64_t FragmentSizeInBits = DL.getTypeSizeInBits(ElTy);\n    for (unsigned i = 0, e = NumElements; i != e; ++i) {\n      Constant *In = Init->getAggregateElement(i);\n      assert(In && \"Couldn't get element of initializer?\");\n\n      GlobalVariable *NGV = new GlobalVariable(STy->getElementType(), false,\n                                               GlobalVariable::InternalLinkage,\n                                               In, GV->getName()+\".\"+Twine(i),\n                                               GV->getThreadLocalMode(),\n                                              GV->getType()->getAddressSpace());\n      NGV->setExternallyInitialized(GV->isExternallyInitialized());\n      NGV->copyAttributesFrom(GV);\n      Globals.push_back(NGV);\n      NewGlobals.push_back(NGV);\n\n      // Calculate the known alignment of the field.  If the original aggregate\n      // had 256 byte alignment for example, something might depend on that:\n      // propagate info to each field.\n      unsigned NewAlign = (unsigned)MinAlign(StartAlignment, EltSize*i);\n      if (NewAlign > EltAlign)\n        NGV->setAlignment(NewAlign);\n      transferSRADebugInfo(GV, NGV, FragmentSizeInBits * i, FragmentSizeInBits,\n                           NumElements);\n    }\n  }\n\n  if (NewGlobals.empty())\n    return nullptr;\n\n  DEBUG(dbgs() << \"PERFORMING GLOBAL SRA ON: \" << *GV << \"\\n\");\n\n  Constant *NullInt =Constant::getNullValue(Type::getInt32Ty(GV->getContext()));\n\n  // Loop over all of the uses of the global, replacing the constantexpr geps,\n  // with smaller constantexpr geps or direct references.\n  while (!GV->use_empty()) {\n    User *GEP = GV->user_back();\n    assert(((isa<ConstantExpr>(GEP) &&\n             cast<ConstantExpr>(GEP)->getOpcode()==Instruction::GetElementPtr)||\n            isa<GetElementPtrInst>(GEP)) && \"NonGEP CE's are not SRAable!\");\n\n    // Ignore the 1th operand, which has to be zero or else the program is quite\n    // broken (undefined).  Get the 2nd operand, which is the structure or array\n    // index.\n    unsigned Val = cast<ConstantInt>(GEP->getOperand(2))->getZExtValue();\n    if (Val >= NewGlobals.size()) Val = 0; // Out of bound array access.\n\n    Value *NewPtr = NewGlobals[Val];\n    Type *NewTy = NewGlobals[Val]->getValueType();\n\n    // Form a shorter GEP if needed.\n    if (GEP->getNumOperands() > 3) {\n      if (ConstantExpr *CE = dyn_cast<ConstantExpr>(GEP)) {\n        SmallVector<Constant*, 8> Idxs;\n        Idxs.push_back(NullInt);\n        for (unsigned i = 3, e = CE->getNumOperands(); i != e; ++i)\n          Idxs.push_back(CE->getOperand(i));\n        NewPtr =\n            ConstantExpr::getGetElementPtr(NewTy, cast<Constant>(NewPtr), Idxs);\n      } else {\n        GetElementPtrInst *GEPI = cast<GetElementPtrInst>(GEP);\n        SmallVector<Value*, 8> Idxs;\n        Idxs.push_back(NullInt);\n        for (unsigned i = 3, e = GEPI->getNumOperands(); i != e; ++i)\n          Idxs.push_back(GEPI->getOperand(i));\n        NewPtr = GetElementPtrInst::Create(\n            NewTy, NewPtr, Idxs, GEPI->getName() + \".\" + Twine(Val), GEPI);\n      }\n    }\n    GEP->replaceAllUsesWith(NewPtr);\n\n    if (GetElementPtrInst *GEPI = dyn_cast<GetElementPtrInst>(GEP))\n      GEPI->eraseFromParent();\n    else\n      cast<ConstantExpr>(GEP)->destroyConstant();\n  }\n\n  // Delete the old global, now that it is dead.\n  Globals.erase(GV);\n  ++NumSRA;\n\n  // Loop over the new globals array deleting any globals that are obviously\n  // dead.  This can arise due to scalarization of a structure or an array that\n  // has elements that are dead.\n  unsigned FirstGlobal = 0;\n  for (unsigned i = 0, e = NewGlobals.size(); i != e; ++i)\n    if (NewGlobals[i]->use_empty()) {\n      Globals.erase(NewGlobals[i]);\n      if (FirstGlobal == i) ++FirstGlobal;\n    }\n\n  return FirstGlobal != NewGlobals.size() ? NewGlobals[FirstGlobal] : nullptr;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/X86/global-sra-fp80-array.ll (1 of 1)\nTesting Time: 0.53s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/global-sra-fp80-array.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: DebugInfo/X86/global-sra-fp80-struct.ll (1 of 1)\nTesting Time: 0.41s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/global-sra-fp80-struct.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "b69e5b739352d75f8adce23c3230e3be304ad89a___GlobalOpt.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nModRefInfo BasicAAResult::getModRefInfo(ImmutableCallSite CS,\n                                        const MemoryLocation &Loc) {\n  assert(notDifferentParent(CS.getInstruction(), Loc.Ptr) &&\n         \"AliasAnalysis query involving multiple functions!\");\n\n  const Value *Object = GetUnderlyingObject(Loc.Ptr, DL);\n\n  // If this is a tail call and Loc.Ptr points to a stack location, we know that\n  // the tail call cannot access or modify the local stack.\n  // We cannot exclude byval arguments here; these belong to the caller of\n  // the current function not to the current function, and a tail callee\n  // may reference them.\n  if (isa<AllocaInst>(Object))\n    if (const CallInst *CI = dyn_cast<CallInst>(CS.getInstruction()))\n      if (CI->isTailCall())\n        return ModRefInfo::NoModRef;\n\n  // If the pointer is to a locally allocated object that does not escape,\n  // then the call can not mod/ref the pointer unless the call takes the pointer\n  // as an argument, and itself doesn't capture it.\n  if (!isa<Constant>(Object) && CS.getInstruction() != Object &&\n      isNonEscapingLocalObject(Object)) {\n\n    // Optimistically assume that call doesn't touch Object and check this\n    // assumption in the following loop.\n    ModRefInfo Result = ModRefInfo::NoModRef;\n    bool IsMustAlias = true;\n\n    unsigned OperandNo = 0;\n    for (auto CI = CS.data_operands_begin(), CE = CS.data_operands_end();\n         CI != CE; ++CI, ++OperandNo) {\n      // Only look at the no-capture or byval pointer arguments.  If this\n      // pointer were passed to arguments that were neither of these, then it\n      // couldn't be no-capture.\n      if (!(*CI)->getType()->isPointerTy() ||\n          (!CS.doesNotCapture(OperandNo) &&\n           OperandNo < CS.getNumArgOperands() && !CS.isByValArgument(OperandNo)))\n        continue;\n\n      // Call doesn't access memory through this operand, so we don't care\n      // if it aliases with Object.\n      if (CS.doesNotAccessMemory(OperandNo))\n        continue;\n\n      // If this is a no-capture pointer argument, see if we can tell that it\n      // is impossible to alias the pointer we're checking.\n      AliasResult AR =\n          getBestAAResults().alias(MemoryLocation(*CI), MemoryLocation(Object));\n      if (AR != MustAlias)\n        IsMustAlias = false;\n      // Operand doesnt alias 'Object', continue looking for other aliases\n      if (AR == NoAlias)\n        continue;\n      // Operand aliases 'Object', but call doesn't modify it. Strengthen\n      // initial assumption and keep looking in case if there are more aliases.\n      if (CS.onlyReadsMemory(OperandNo)) {\n        Result = setRef(Result);\n        continue;\n      }\n      // Operand aliases 'Object' but call only writes into it.\n      if (CS.doesNotReadMemory(OperandNo)) {\n        Result = setMod(Result);\n        continue;\n      }\n      // This operand aliases 'Object' and call reads and writes into it.\n      // Setting ModRef will not yield an early return below, MustAlias is not\n      // used further.\n      Result = ModRefInfo::ModRef;\n      break;\n    }\n\n    // No operand aliases, reset Must bit. Add below if at least one aliases\n    // and all aliases found are MustAlias.\n    if (isNoModRef(Result))\n      IsMustAlias = false;\n\n    // Early return if we improved mod ref information\n    if (!isModAndRefSet(Result)) {\n      if (isNoModRef(Result))\n        return ModRefInfo::NoModRef;\n      return IsMustAlias ? setMust(Result) : clearMust(Result);\n    }\n  }\n\n  // If the CallSite is to malloc or calloc, we can assume that it doesn't\n  // modify any IR visible value.  This is only valid because we assume these\n  // routines do not read values visible in the IR.  TODO: Consider special\n  // casing realloc and strdup routines which access only their arguments as\n  // well.  Or alternatively, replace all of this with inaccessiblememonly once\n  // that's implemented fully.\n  auto *Inst = CS.getInstruction();\n  if (isMallocOrCallocLikeFn(Inst, &TLI)) {\n    // Be conservative if the accessed pointer may alias the allocation -\n    // fallback to the generic handling below.\n    if (getBestAAResults().alias(MemoryLocation(Inst), Loc) == NoAlias)\n      return ModRefInfo::NoModRef;\n  }\n\n  // The semantics of memcpy intrinsics forbid overlap between their respective\n  // operands, i.e., source and destination of any given memcpy must no-alias.\n  // If Loc must-aliases either one of these two locations, then it necessarily\n  // no-aliases the other.\n  if (auto *Inst = dyn_cast<AnyMemCpyInst>(CS.getInstruction())) {\n    AliasResult SrcAA, DestAA;\n\n    if ((SrcAA = getBestAAResults().alias(MemoryLocation::getForSource(Inst),\n                                          Loc)) == MustAlias)\n      // Loc is exactly the memcpy source thus disjoint from memcpy dest.\n      return ModRefInfo::Ref;\n    if ((DestAA = getBestAAResults().alias(MemoryLocation::getForDest(Inst),\n                                           Loc)) == MustAlias)\n      // The converse case.\n      return ModRefInfo::Mod;\n\n    // It's also possible for Loc to alias both src and dest, or neither.\n    ModRefInfo rv = ModRefInfo::NoModRef;\n    if (SrcAA != NoAlias)\n      rv = setRef(rv);\n    if (DestAA != NoAlias)\n      rv = setMod(rv);\n    return rv;\n  }\n\n  // While the assume intrinsic is marked as arbitrarily writing so that\n  // proper control dependencies will be maintained, it never aliases any\n  // particular memory location.\n  if (isIntrinsicCall(CS, Intrinsic::assume))\n    return ModRefInfo::NoModRef;\n\n  // Like assumes, guard intrinsics are also marked as arbitrarily writing so\n  // that proper control dependencies are maintained but they never mods any\n  // particular memory location.\n  //\n  // *Unlike* assumes, guard intrinsics are modeled as reading memory since the\n  // heap state at the point the guard is issued needs to be consistent in case\n  // the guard invokes the \"deopt\" continuation.\n  if (isIntrinsicCall(CS, Intrinsic::experimental_guard))\n    return ModRefInfo::Ref;\n\n  // Like assumes, invariant.start intrinsics were also marked as arbitrarily\n  // writing so that proper control dependencies are maintained but they never\n  // mod any particular memory location visible to the IR.\n  // *Unlike* assumes (which are now modeled as NoModRef), invariant.start\n  // intrinsic is now modeled as reading memory. This prevents hoisting the\n  // invariant.start intrinsic over stores. Consider:\n  // *ptr = 40;\n  // *ptr = 50;\n  // invariant_start(ptr)\n  // int val = *ptr;\n  // print(val);\n  //\n  // This cannot be transformed to:\n  //\n  // *ptr = 40;\n  // invariant_start(ptr)\n  // *ptr = 50;\n  // int val = *ptr;\n  // print(val);\n  //\n  // The transformation will cause the second store to be ignored (based on\n  // rules of invariant.start)  and print 40, while the first program always\n  // prints 50.\n  if (isIntrinsicCall(CS, Intrinsic::invariant_start))\n    return ModRefInfo::Ref;\n\n  // The AAResultBase base class has some smarts, lets use them.\n  return AAResultBase::getModRefInfo(CS, Loc);\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Analysis/BasicAA/tail-byval.ll (1 of 1)\nTesting Time: 1.14s\n********************\nFailing Tests (1):\n    LLVM :: Analysis/BasicAA/tail-byval.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Transforms/DeadStoreElimination/tail-byval.ll (1 of 1)\nTesting Time: 0.32s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/DeadStoreElimination/tail-byval.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "40e7663b1fca58b099c1cb1d5278f368494ea46d___BasicAliasAnalysis.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic SDValue combineInsertSubvector(SDNode *N, SelectionDAG &DAG,\n                                      TargetLowering::DAGCombinerInfo &DCI,\n                                      const X86Subtarget &Subtarget) {\n  if (DCI.isBeforeLegalizeOps())\n    return SDValue();\n\n  MVT OpVT = N->getSimpleValueType(0);\n\n  bool IsI1Vector = OpVT.getVectorElementType() == MVT::i1;\n\n  SDLoc dl(N);\n  SDValue Vec = N->getOperand(0);\n  SDValue SubVec = N->getOperand(1);\n\n  unsigned IdxVal = N->getConstantOperandVal(2);\n  MVT SubVecVT = SubVec.getSimpleValueType();\n\n  if (ISD::isBuildVectorAllZeros(Vec.getNode())) {\n    // Inserting zeros into zeros is a nop.\n    if (ISD::isBuildVectorAllZeros(SubVec.getNode()))\n      return getZeroVector(OpVT, Subtarget, DAG, dl);\n\n    // If we're inserting into a zero vector and then into a larger zero vector,\n    // just insert into the larger zero vector directly.\n    if (SubVec.getOpcode() == ISD::INSERT_SUBVECTOR &&\n        ISD::isBuildVectorAllZeros(SubVec.getOperand(0).getNode())) {\n      unsigned Idx2Val = SubVec.getConstantOperandVal(2);\n      return DAG.getNode(ISD::INSERT_SUBVECTOR, dl, OpVT,\n                         getZeroVector(OpVT, Subtarget, DAG, dl),\n                         SubVec.getOperand(1),\n                         DAG.getIntPtrConstant(IdxVal + Idx2Val, dl));\n    }\n\n    // If we're inserting into a zero vector and our input was extracted from an\n    // insert into a zero vector of the same type and the extraction was at\n    // least as large as the original insertion. Just insert the original\n    // subvector into a zero vector.\n    if (SubVec.getOpcode() == ISD::EXTRACT_SUBVECTOR && IdxVal == 0 &&\n        SubVec.getConstantOperandVal(1) == 0 &&\n        SubVec.getOperand(0).getOpcode() == ISD::INSERT_SUBVECTOR) {\n      SDValue Ins = SubVec.getOperand(0);\n      if (Ins.getConstantOperandVal(2) == 0 &&\n          ISD::isBuildVectorAllZeros(Ins.getOperand(0).getNode()) &&\n          Ins.getOperand(1).getValueSizeInBits() <= SubVecVT.getSizeInBits())\n        return DAG.getNode(ISD::INSERT_SUBVECTOR, dl, OpVT,\n                           getZeroVector(OpVT, Subtarget, DAG, dl),\n                           Ins.getOperand(1), N->getOperand(2));\n    }\n\n    // If we're inserting a bitcast into zeros, rewrite the insert and move the\n    // bitcast to the other side. This helps with detecting zero extending\n    // during isel.\n    // TODO: Is this useful for other indices than 0?\n    if (!IsI1Vector && SubVec.getOpcode() == ISD::BITCAST && IdxVal == 0) {\n      MVT CastVT = SubVec.getOperand(0).getSimpleValueType();\n      unsigned NumElems = OpVT.getSizeInBits() / CastVT.getScalarSizeInBits();\n      MVT NewVT = MVT::getVectorVT(CastVT.getVectorElementType(), NumElems);\n      SDValue Insert = DAG.getNode(ISD::INSERT_SUBVECTOR, dl, NewVT,\n                                   DAG.getBitcast(NewVT, Vec),\n                                   SubVec.getOperand(0), N->getOperand(2));\n      return DAG.getBitcast(OpVT, Insert);\n    }\n  }\n\n  // Stop here if this is an i1 vector.\n  if (IsI1Vector)\n    return SDValue();\n\n  // If this is an insert of an extract, combine to a shuffle. Don't do this\n  // if the insert or extract can be represented with a subregister operation.\n  if (SubVec.getOpcode() == ISD::EXTRACT_SUBVECTOR &&\n      SubVec.getOperand(0).getSimpleValueType() == OpVT &&\n      (IdxVal != 0 || !Vec.isUndef())) {\n    int ExtIdxVal = SubVec.getConstantOperandVal(1);\n    if (ExtIdxVal != 0) {\n      int VecNumElts = OpVT.getVectorNumElements();\n      int SubVecNumElts = SubVecVT.getVectorNumElements();\n      SmallVector<int, 64> Mask(VecNumElts);\n      // First create an identity shuffle mask.\n      for (int i = 0; i != VecNumElts; ++i)\n        Mask[i] = i;\n      // Now insert the extracted portion.\n      for (int i = 0; i != SubVecNumElts; ++i)\n        Mask[i + IdxVal] = i + ExtIdxVal + VecNumElts;\n\n      return DAG.getVectorShuffle(OpVT, dl, Vec, SubVec.getOperand(0), Mask);\n    }\n  }\n\n  // Fold two 16-byte or 32-byte subvector loads into one 32-byte or 64-byte\n  // load:\n  // (insert_subvector (insert_subvector undef, (load16 addr), 0),\n  //                   (load16 addr + 16), Elts/2)\n  // --> load32 addr\n  // or:\n  // (insert_subvector (insert_subvector undef, (load32 addr), 0),\n  //                   (load32 addr + 32), Elts/2)\n  // --> load64 addr\n  // or a 16-byte or 32-byte broadcast:\n  // (insert_subvector (insert_subvector undef, (load16 addr), 0),\n  //                   (load16 addr), Elts/2)\n  // --> X86SubVBroadcast(load16 addr)\n  // or:\n  // (insert_subvector (insert_subvector undef, (load32 addr), 0),\n  //                   (load32 addr), Elts/2)\n  // --> X86SubVBroadcast(load32 addr)\n  if ((IdxVal == OpVT.getVectorNumElements() / 2) &&\n      Vec.getOpcode() == ISD::INSERT_SUBVECTOR &&\n      OpVT.getSizeInBits() == SubVecVT.getSizeInBits() * 2) {\n    if (isNullConstant(Vec.getOperand(2))) {\n      SDValue SubVec2 = Vec.getOperand(1);\n      // If needed, look through bitcasts to get to the load.\n      if (auto *FirstLd = dyn_cast<LoadSDNode>(peekThroughBitcasts(SubVec2))) {\n        bool Fast;\n        unsigned Alignment = FirstLd->getAlignment();\n        unsigned AS = FirstLd->getAddressSpace();\n        const X86TargetLowering *TLI = Subtarget.getTargetLowering();\n        if (TLI->allowsMemoryAccess(*DAG.getContext(), DAG.getDataLayout(),\n                                    OpVT, AS, Alignment, &Fast) && Fast) {\n          SDValue Ops[] = {SubVec2, SubVec};\n          if (SDValue Ld = EltsFromConsecutiveLoads(OpVT, Ops, dl, DAG,\n                                                    Subtarget, false))\n            return Ld;\n        }\n      }\n      // If lower/upper loads are the same and the only users of the load, then\n      // lower to a VBROADCASTF128/VBROADCASTI128/etc.\n      if (auto *Ld = dyn_cast<LoadSDNode>(peekThroughOneUseBitcasts(SubVec2)))\n        if (SubVec2 == SubVec && ISD::isNormalLoad(Ld) &&\n            SDNode::areOnlyUsersOf({N, Vec.getNode()}, SubVec2.getNode()))\n          return DAG.getNode(X86ISD::SUBV_BROADCAST, dl, OpVT, SubVec);\n\n      // If this is subv_broadcast insert into both halves, use a larger\n      // subv_broadcast.\n      if (SubVec.getOpcode() == X86ISD::SUBV_BROADCAST && SubVec == SubVec2)\n        return DAG.getNode(X86ISD::SUBV_BROADCAST, dl, OpVT,\n                           SubVec.getOperand(0));\n\n      // If we're inserting all zeros into the upper half, change this to\n      // an insert into an all zeros vector. We will match this to a move\n      // with implicit upper bit zeroing during isel.\n      if (ISD::isBuildVectorAllZeros(SubVec.getNode()))\n        return DAG.getNode(ISD::INSERT_SUBVECTOR, dl, OpVT,\n                           getZeroVector(OpVT, Subtarget, DAG, dl), SubVec2,\n                           Vec.getOperand(2));\n\n      // If we are inserting into both halves of the vector, the starting\n      // vector should be undef. If it isn't, make it so. Only do this if the\n      // the early insert has no other uses.\n      // TODO: Should this be a generic DAG combine?\n      if (!Vec.getOperand(0).isUndef() && Vec.hasOneUse()) {\n        Vec = DAG.getNode(ISD::INSERT_SUBVECTOR, dl, OpVT, DAG.getUNDEF(OpVT),\n                          SubVec2, Vec.getOperand(2));\n        return DAG.getNode(ISD::INSERT_SUBVECTOR, dl, OpVT, Vec, SubVec,\n                           N->getOperand(2));\n\n      }\n    }\n  }\n\n  return SDValue();\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/avx-vbroadcastf128.ll (1 of 1)\nTesting Time: 0.22s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/avx-vbroadcastf128.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "bfee5a9b42d3b4190d6a41d848303d1fea1bdbf2___X86ISelLowering.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic bool isHorizontalBinOp(SDValue &LHS, SDValue &RHS, bool IsCommutative) {\n  // If either operand is undef, bail out. The binop should be simplified.\n  if (LHS.isUndef() || RHS.isUndef())\n    return false;\n\n  // Look for the following pattern:\n  //   A = < float a0, float a1, float a2, float a3 >\n  //   B = < float b0, float b1, float b2, float b3 >\n  // and\n  //   LHS = VECTOR_SHUFFLE A, B, <0, 2, 4, 6>\n  //   RHS = VECTOR_SHUFFLE A, B, <1, 3, 5, 7>\n  // then LHS op RHS = < a0 op a1, a2 op a3, b0 op b1, b2 op b3 >\n  // which is A horizontal-op B.\n\n  // At least one of the operands should be a vector shuffle.\n  if (LHS.getOpcode() != ISD::VECTOR_SHUFFLE &&\n      RHS.getOpcode() != ISD::VECTOR_SHUFFLE)\n    return false;\n\n  MVT VT = LHS.getSimpleValueType();\n  assert((VT.is128BitVector() || VT.is256BitVector()) &&\n         \"Unsupported vector type for horizontal add/sub\");\n\n  // View LHS in the form\n  //   LHS = VECTOR_SHUFFLE A, B, LMask\n  // If LHS is not a shuffle, then pretend it is the identity shuffle:\n  //   LHS = VECTOR_SHUFFLE LHS, undef, <0, 1, ..., N-1>\n  // NOTE: A default initialized SDValue represents an UNDEF of type VT.\n  unsigned NumElts = VT.getVectorNumElements();\n  SDValue A, B;\n  SmallVector<int, 16> LMask(NumElts);\n  if (LHS.getOpcode() == ISD::VECTOR_SHUFFLE) {\n    if (!LHS.getOperand(0).isUndef())\n      A = LHS.getOperand(0);\n    if (!LHS.getOperand(1).isUndef())\n      B = LHS.getOperand(1);\n    ArrayRef<int> Mask = cast<ShuffleVectorSDNode>(LHS.getNode())->getMask();\n    std::copy(Mask.begin(), Mask.end(), LMask.begin());\n  } else {\n    A = LHS;\n    for (unsigned i = 0; i != NumElts; ++i)\n      LMask[i] = i;\n  }\n\n  // Likewise, view RHS in the form\n  //   RHS = VECTOR_SHUFFLE C, D, RMask\n  SDValue C, D;\n  SmallVector<int, 16> RMask(NumElts);\n  if (RHS.getOpcode() == ISD::VECTOR_SHUFFLE) {\n    if (!RHS.getOperand(0).isUndef())\n      C = RHS.getOperand(0);\n    if (!RHS.getOperand(1).isUndef())\n      D = RHS.getOperand(1);\n    ArrayRef<int> Mask = cast<ShuffleVectorSDNode>(RHS.getNode())->getMask();\n    std::copy(Mask.begin(), Mask.end(), RMask.begin());\n  } else {\n    C = RHS;\n    for (unsigned i = 0; i != NumElts; ++i)\n      RMask[i] = i;\n  }\n\n  // If A and B occur in reverse order in RHS, then canonicalize by commuting\n  // RHS operands and shuffle mask.\n  if (A != C) {\n    std::swap(C, D);\n    ShuffleVectorSDNode::commuteMask(RMask);\n  }\n  // Check that the shuffles are both shuffling the same vectors.\n  if (!(A == C && B == D))\n    return false;\n\n  // LHS and RHS are now:\n  //   LHS = shuffle A, B, LMask\n  //   RHS = shuffle A, B, RMask\n  // Check that the masks correspond to performing a horizontal operation.\n  // AVX defines horizontal add/sub to operate independently on 128-bit lanes,\n  // so we just repeat the inner loop if this is a 256-bit op.\n  unsigned Num128BitChunks = VT.getSizeInBits() / 128;\n  unsigned NumEltsPer128BitChunk = NumElts / Num128BitChunks;\n  assert((NumEltsPer128BitChunk % 2 == 0) &&\n         \"Vector type should have an even number of elements in each lane\");\n  for (unsigned j = 0; j != NumElts; j += NumEltsPer128BitChunk) {\n    for (unsigned i = 0; i != NumEltsPer128BitChunk; ++i) {\n      // Ignore undefined components.\n      int LIdx = LMask[i + j], RIdx = RMask[i + j];\n      if (LIdx < 0 || RIdx < 0 ||\n          (!A.getNode() && (LIdx < (int)NumElts || RIdx < (int)NumElts)) ||\n          (!B.getNode() && (LIdx >= (int)NumElts || RIdx >= (int)NumElts)))\n        continue;\n\n      // The  low half of the 128-bit result must choose from A.\n      // The high half of the 128-bit result must choose from B.\n      unsigned NumEltsPer64BitChunk = NumEltsPer128BitChunk / 2;\n      unsigned Src = i >= NumEltsPer64BitChunk;\n\n      // Check that successive elements are being operated on. If not, this is\n      // not a horizontal operation.\n      int Index = 2 * (i % NumEltsPer64BitChunk) + NumElts * Src + j;\n      if (!(LIdx == Index && RIdx == Index + 1) &&\n          !(IsCommutative && LIdx == Index + 1 && RIdx == Index))\n        return false;\n    }\n  }\n\n  LHS = A.getNode() ? A : B; // If A is 'UNDEF', use B for it.\n  RHS = B.getNode() ? B : A; // If B is 'UNDEF', use A for it.\n  return true;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/avx512-intrinsics-fast-isel.ll (1 of 1)\nTesting Time: 5.14s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/avx512-intrinsics-fast-isel.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/haddsub-undef.ll (1 of 1)\nTesting Time: 0.62s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/haddsub-undef.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/phaddsub.ll (1 of 1)\nTesting Time: 0.54s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/phaddsub.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/vector-shuffle-combining.ll (1 of 1)\nTesting Time: 2.83s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/vector-shuffle-combining.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "6cca8af2270be8bc5494b44bb8856af591d0385b___X86ISelLowering.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic bool replaceMathCmpWithIntrinsic(BinaryOperator *BO, CmpInst *Cmp,\n                                        Intrinsic::ID IID, DominatorTree &DT) {\n  // We allow matching the canonical IR (add X, C) back to (usubo X, -C).\n  Value *Arg0 = BO->getOperand(0);\n  Value *Arg1 = BO->getOperand(1);\n  if (BO->getOpcode() == Instruction::Add &&\n      IID == Intrinsic::usub_with_overflow) {\n    assert(isa<Constant>(Arg1) && \"Unexpected input for usubo\");\n    Arg1 = ConstantExpr::getNeg(cast<Constant>(Arg1));\n  }\n\n  Instruction *InsertPt;\n  if (BO->hasOneUse() && BO->user_back() == Cmp) {\n    // If the math is only used by the compare, insert at the compare to keep\n    // the condition in the same block as its users. (CGP aggressively sinks\n    // compares to help out SDAG.)\n    InsertPt = Cmp;\n  } else {\n    // The math and compare may be independent instructions. Check dominance to\n    // determine the insertion point for the intrinsic.\n    bool MathDominates = DT.dominates(BO, Cmp);\n    if (!MathDominates && !DT.dominates(Cmp, BO))\n      return false;\n\n    // Check that the insertion doesn't create a value that is live across more\n    // than two blocks, so to minimise the increase in register pressure.\n    BasicBlock *MathBB = BO->getParent(), *CmpBB = Cmp->getParent();\n    if (MathBB != CmpBB) {\n      BasicBlock *Dominator = MathDominates ? MathBB : CmpBB;\n      BasicBlock *Dominated = MathDominates ? CmpBB : MathBB;\n      auto Successors = successors(Dominator);\n      if (llvm::find(Successors, Dominated) == Successors.end())\n        return false;\n    }\n\n    InsertPt = MathDominates ? cast<Instruction>(BO) : cast<Instruction>(Cmp);\n  }\n\n  IRBuilder<> Builder(InsertPt);\n  Value *MathOV = Builder.CreateBinaryIntrinsic(IID, Arg0, Arg1);\n  Value *Math = Builder.CreateExtractValue(MathOV, 0, \"math\");\n  Value *OV = Builder.CreateExtractValue(MathOV, 1, \"ov\");\n  BO->replaceAllUsesWith(Math);\n  Cmp->replaceAllUsesWith(OV);\n  BO->eraseFromParent();\n  Cmp->eraseFromParent();\n  return true;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/cgp-usubo.ll (1 of 1)\nTesting Time: 0.26s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/cgp-usubo.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/lsr-loop-exit-cond.ll (1 of 1)\nTesting Time: 0.14s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/lsr-loop-exit-cond.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Transforms/CodeGenPrepare/X86/overflow-intrinsics.ll (1 of 1)\nTesting Time: 0.13s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/CodeGenPrepare/X86/overflow-intrinsics.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "d47eac59efb1de3a4fe797c54e116de55c6559e2___CodeGenPrepare.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nvoid DwarfDebug::finalizeModuleInfo() {\n  const TargetLoweringObjectFile &TLOF = Asm->getObjFileLowering();\n\n  finishSubprogramDefinitions();\n\n  finishEntityDefinitions();\n\n  // Include the DWO file name in the hash if there's more than one CU.\n  // This handles ThinLTO's situation where imported CUs may very easily be\n  // duplicate with the same CU partially imported into another ThinLTO unit.\n  StringRef DWOName;\n  if (CUMap.size() > 1)\n    DWOName = Asm->TM.Options.MCOptions.SplitDwarfFile;\n\n  // Handle anything that needs to be done on a per-unit basis after\n  // all other generation.\n  for (const auto &P : CUMap) {\n    auto &TheCU = *P.second;\n    if (TheCU.getCUNode()->isDebugDirectivesOnly())\n      continue;\n    // Emit DW_AT_containing_type attribute to connect types with their\n    // vtable holding type.\n    TheCU.constructContainingTypeDIEs();\n\n    // Add CU specific attributes if we need to add any.\n    // If we're splitting the dwarf out now that we've got the entire\n    // CU then add the dwo id to it.\n    auto *SkCU = TheCU.getSkeleton();\n    if (useSplitDwarf() && !empty(TheCU.getUnitDie().children())) {\n      finishUnitAttributes(TheCU.getCUNode(), TheCU);\n      TheCU.addString(TheCU.getUnitDie(), dwarf::DW_AT_GNU_dwo_name,\n                      Asm->TM.Options.MCOptions.SplitDwarfFile);\n      SkCU->addString(SkCU->getUnitDie(), dwarf::DW_AT_GNU_dwo_name,\n                      Asm->TM.Options.MCOptions.SplitDwarfFile);\n      // Emit a unique identifier for this CU.\n      uint64_t ID =\n          DIEHash(Asm).computeCUSignature(DWOName, TheCU.getUnitDie());\n      if (getDwarfVersion() >= 5) {\n        TheCU.setDWOId(ID);\n        SkCU->setDWOId(ID);\n      } else {\n        TheCU.addUInt(TheCU.getUnitDie(), dwarf::DW_AT_GNU_dwo_id,\n                      dwarf::DW_FORM_data8, ID);\n        SkCU->addUInt(SkCU->getUnitDie(), dwarf::DW_AT_GNU_dwo_id,\n                      dwarf::DW_FORM_data8, ID);\n      }\n\n      if (getDwarfVersion() < 5 && !SkeletonHolder.getRangeLists().empty()) {\n        const MCSymbol *Sym = TLOF.getDwarfRangesSection()->getBeginSymbol();\n        SkCU->addSectionLabel(SkCU->getUnitDie(), dwarf::DW_AT_GNU_ranges_base,\n                              Sym, Sym);\n      }\n    } else if (SkCU) {\n      finishUnitAttributes(SkCU->getCUNode(), *SkCU);\n    }\n\n    // If we have code split among multiple sections or non-contiguous\n    // ranges of code then emit a DW_AT_ranges attribute on the unit that will\n    // remain in the .o file, otherwise add a DW_AT_low_pc.\n    // FIXME: We should use ranges allow reordering of code ala\n    // .subsections_via_symbols in mach-o. This would mean turning on\n    // ranges for all subprogram DIEs for mach-o.\n    DwarfCompileUnit &U = SkCU ? *SkCU : TheCU;\n\n    // We don't keep track of which addresses are used in which CU so this\n    // is a bit pessimistic under LTO.\n    if (!AddrPool.isEmpty() &&\n        (getDwarfVersion() >= 5 ||\n         (SkCU && !empty(TheCU.getUnitDie().children()))))\n      U.addAddrTableBase();\n\n    if (unsigned NumRanges = TheCU.getRanges().size()) {\n      if (NumRanges > 1 && useRangesSection())\n        // A DW_AT_low_pc attribute may also be specified in combination with\n        // DW_AT_ranges to specify the default base address for use in\n        // location lists (see Section 2.6.2) and range lists (see Section\n        // 2.17.3).\n        U.addUInt(U.getUnitDie(), dwarf::DW_AT_low_pc, dwarf::DW_FORM_addr, 0);\n      else\n        U.setBaseAddress(TheCU.getRanges().front().getStart());\n      U.attachRangesOrLowHighPC(U.getUnitDie(), TheCU.takeRanges());\n    }\n\n    if (getDwarfVersion() >= 5) {\n      if (U.hasRangeLists())\n        U.addRnglistsBase();\n\n      if (!DebugLocs.getLists().empty() && !useSplitDwarf())\n        U.addLoclistsBase();\n    }\n\n    auto *CUNode = cast<DICompileUnit>(P.first);\n    // If compile Unit has macros, emit \"DW_AT_macro_info\" attribute.\n    if (CUNode->getMacros())\n      U.addSectionLabel(U.getUnitDie(), dwarf::DW_AT_macro_info,\n                        U.getMacroLabelBegin(),\n                        TLOF.getDwarfMacinfoSection()->getBeginSymbol());\n  }\n\n  // Emit all frontend-produced Skeleton CUs, i.e., Clang modules.\n  for (auto *CUNode : MMI->getModule()->debug_compile_units())\n    if (CUNode->getDWOId())\n      getOrCreateDwarfCompileUnit(CUNode);\n\n  // Compute DIE offsets and sizes.\n  InfoHolder.computeSizeAndOffsets();\n  if (useSplitDwarf())\n    SkeletonHolder.computeSizeAndOffsets();\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/Generic/line-table-addrx.ll (1 of 1)\nTesting Time: 0.11s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/Generic/line-table-addrx.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: DebugInfo/X86/convert-debugloc.ll (1 of 1)\nTesting Time: 0.08s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/convert-debugloc.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: DebugInfo/X86/fission-ranges.ll (1 of 1)\nTesting Time: 0.10s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/fission-ranges.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "2f6ef2fc92955a5b77f302294ba97aa51dbaec4c___DwarfDebug.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nOptional<LoopICmp> LoopPredication::parseLoopLatchICmp() {\n  using namespace PatternMatch;\n\n  BasicBlock *LoopLatch = L->getLoopLatch();\n  if (!LoopLatch) {\n    LLVM_DEBUG(dbgs() << \"The loop doesn't have a single latch!\\n\");\n    return None;\n  }\n\n  auto *BI = dyn_cast<BranchInst>(LoopLatch->getTerminator());\n  if (!BI) {\n    LLVM_DEBUG(dbgs() << \"Failed to match the latch terminator!\\n\");\n    return None;\n  }\n  BasicBlock *TrueDest = BI->getSuccessor(0);\n  assert(\n      (TrueDest == L->getHeader() || BI->getSuccessor(1) == L->getHeader()) &&\n      \"One of the latch's destinations must be the header\");\n\n  auto *ICI = dyn_cast<ICmpInst>(BI->getCondition());\n  if (!ICI || !BI->isConditional()) {\n    LLVM_DEBUG(dbgs() << \"Failed to match the latch condition!\\n\");\n    return None;\n  }\n  auto Result = parseLoopICmp(ICI);\n  if (!Result) {\n    LLVM_DEBUG(dbgs() << \"Failed to parse the loop latch condition!\\n\");\n    return None;\n  }\n\n  if (TrueDest != L->getHeader())\n    Result->Pred = ICmpInst::getInversePredicate(Result->Pred);\n\n  // Check affine first, so if it's not we don't try to compute the step\n  // recurrence.\n  if (!Result->IV->isAffine()) {\n    LLVM_DEBUG(dbgs() << \"The induction variable is not affine!\\n\");\n    return None;\n  }\n\n  auto *Step = Result->IV->getStepRecurrence(*SE);\n  if (!isSupportedStep(Step)) {\n    LLVM_DEBUG(dbgs() << \"Unsupported loop stride(\" << *Step << \")!\\n\");\n    return None;\n  }\n\n  auto IsUnsupportedPredicate = [](const SCEV *Step, ICmpInst::Predicate Pred) {\n    if (Step->isOne()) {\n      return Pred != ICmpInst::ICMP_ULT && Pred != ICmpInst::ICMP_SLT &&\n             Pred != ICmpInst::ICMP_ULE && Pred != ICmpInst::ICMP_SLE;\n    } else {\n      assert(Step->isAllOnesValue() && \"Step should be -1!\");\n      return Pred != ICmpInst::ICMP_UGT && Pred != ICmpInst::ICMP_SGT &&\n             Pred != ICmpInst::ICMP_UGE && Pred != ICmpInst::ICMP_SGE;\n    }\n  };\n\n  normalizePredicate(SE, L, *Result);\n  if (IsUnsupportedPredicate(Step, Result->Pred)) {\n    LLVM_DEBUG(dbgs() << \"Unsupported loop latch predicate(\" << Result->Pred\n                      << \")!\\n\");\n    return None;\n  }\n\n  return Result;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/LoopPredication/basic.ll (1 of 1)\nTesting Time: 2.20s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LoopPredication/basic.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "101915cfdaba9284b5bb8dedbbca2b7788f68da4___LoopPredication.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nbool IndVarSimplify::optimizeLoopExits(Loop *L) {\n  SmallVector<BasicBlock*, 16> ExitingBlocks;\n  L->getExitingBlocks(ExitingBlocks);\n\n  // Form an expression for the maximum exit count possible for this loop. We\n  // merge the max and exact information to approximate a version of\n  // getMaxBackedgeTakenInfo which isn't restricted to just constants.\n  // TODO: factor this out as a version of getMaxBackedgeTakenCount which\n  // isn't guaranteed to return a constant.\n  SmallVector<const SCEV*, 4> ExitCounts;\n  const SCEV *MaxConstEC = SE->getMaxBackedgeTakenCount(L);\n  if (!isa<SCEVCouldNotCompute>(MaxConstEC))\n    ExitCounts.push_back(MaxConstEC);\n  for (BasicBlock *ExitingBB : ExitingBlocks) {\n    const SCEV *ExitCount = SE->getExitCount(L, ExitingBB);\n    if (!isa<SCEVCouldNotCompute>(ExitCount)) {\n      assert(DT->dominates(ExitingBB, L->getLoopLatch()) &&\n             \"We should only have known counts for exiting blocks that \"\n             \"dominate latch!\");\n      ExitCounts.push_back(ExitCount);\n    }\n  }\n  if (ExitCounts.empty())\n    return false;\n  const SCEV *MaxExitCount = SE->getUMinFromMismatchedTypes(ExitCounts);\n\n  bool Changed = false;\n  for (BasicBlock *ExitingBB : ExitingBlocks) {\n    // If our exitting block exits multiple loops, we can only rewrite the\n    // innermost one.  Otherwise, we're changing how many times the innermost\n    // loop runs before it exits. \n    if (LI->getLoopFor(ExitingBB) != L)\n      continue;\n\n    // Can't rewrite non-branch yet.\n    BranchInst *BI = dyn_cast<BranchInst>(ExitingBB->getTerminator());\n    if (!BI)\n      continue;\n\n    // If already constant, nothing to do.\n    if (isa<Constant>(BI->getCondition()))\n      continue;\n    \n    const SCEV *ExitCount = SE->getExitCount(L, ExitingBB);\n    if (isa<SCEVCouldNotCompute>(ExitCount))\n      continue;\n\n    // If we know we'd exit on the first iteration, rewrite the exit to\n    // reflect this.  This does not imply the loop must exit through this\n    // exit; there may be an earlier one taken on the first iteration.\n    // TODO: Given we know the backedge can't be taken, we should go ahead\n    // and break it.  Or at least, kill all the header phis and simplify.\n    if (ExitCount->isZero()) {\n      bool ExitIfTrue = !L->contains(*succ_begin(ExitingBB));\n      auto *OldCond = BI->getCondition();\n      auto *NewCond = ExitIfTrue ? ConstantInt::getTrue(OldCond->getType()) :\n        ConstantInt::getFalse(OldCond->getType());\n      BI->setCondition(NewCond);\n      if (OldCond->use_empty())\n        DeadInsts.push_back(OldCond);\n      Changed = true;\n      continue;\n    }\n\n    // If we end up with a pointer exit count, bail.\n    if (!ExitCount->getType()->isIntegerTy() ||\n        !MaxExitCount->getType()->isIntegerTy())\n      return false;\n    \n    Type *WiderType =\n      SE->getWiderType(MaxExitCount->getType(), ExitCount->getType());\n    ExitCount = SE->getNoopOrZeroExtend(ExitCount, WiderType);\n    MaxExitCount = SE->getNoopOrZeroExtend(MaxExitCount, WiderType);\n    assert(MaxExitCount->getType() == ExitCount->getType());\n    \n    // Can we prove that some other exit must be taken strictly before this\n    // one?  TODO: handle cases where ule is known, and equality is covered\n    // by a dominating exit\n    if (SE->isLoopEntryGuardedByCond(L, CmpInst::ICMP_ULT,\n                                     MaxExitCount, ExitCount)) {\n      bool ExitIfTrue = !L->contains(*succ_begin(ExitingBB));\n      auto *OldCond = BI->getCondition();\n      auto *NewCond = ExitIfTrue ? ConstantInt::getFalse(OldCond->getType()) :\n        ConstantInt::getTrue(OldCond->getType());\n      BI->setCondition(NewCond);\n      if (OldCond->use_empty())\n        DeadInsts.push_back(OldCond);\n      Changed = true;\n      continue;\n    }\n\n    // TODO: If we can prove that the exiting iteration is equal to the exit\n    // count for this exit and that no previous exit oppurtunities exist within\n    // the loop, then we can discharge all other exits.  (May fall out of\n    // previous TODO.) \n    \n    // TODO: If we can't prove any relation between our exit count and the\n    // loops exit count, but taking this exit doesn't require actually running\n    // the loop (i.e. no side effects, no computed values used in exit), then\n    // we can replace the exit test with a loop invariant test which exits on\n    // the first iteration.  \n  }\n  return Changed;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/IndVarSimplify/eliminate-exit-no-dl.ll (1 of 1)\nTesting Time: 0.25s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/IndVarSimplify/eliminate-exit-no-dl.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "ea5c94b497cfc43f9ec513f721e03aa5c669249a___IndVarSimplify.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic bool TryToShrinkGlobalToBoolean(GlobalVariable *GV, Constant *OtherVal) {\n  Type *GVElType = GV->getValueType();\n\n  // If GVElType is already i1, it is already shrunk.  If the type of the GV is\n  // an FP value, pointer or vector, don't do this optimization because a select\n  // between them is very expensive and unlikely to lead to later\n  // simplification.  In these cases, we typically end up with \"cond ? v1 : v2\"\n  // where v1 and v2 both require constant pool loads, a big loss.\n  if (GVElType == Type::getInt1Ty(GV->getContext()) ||\n      GVElType->isFloatingPointTy() ||\n      GVElType->isPointerTy() || GVElType->isVectorTy())\n    return false;\n\n  // Walk the use list of the global seeing if all the uses are load or store.\n  // If there is anything else, bail out.\n  for (User *U : GV->users())\n    if (!isa<LoadInst>(U) && !isa<StoreInst>(U))\n      return false;\n\n  LLVM_DEBUG(dbgs() << \"   *** SHRINKING TO BOOL: \" << *GV << \"\\n\");\n\n  // Create the new global, initializing it to false.\n  GlobalVariable *NewGV = new GlobalVariable(Type::getInt1Ty(GV->getContext()),\n                                             false,\n                                             GlobalValue::InternalLinkage,\n                                        ConstantInt::getFalse(GV->getContext()),\n                                             GV->getName()+\".b\",\n                                             GV->getThreadLocalMode(),\n                                             GV->getType()->getAddressSpace());\n  NewGV->copyAttributesFrom(GV);\n  GV->getParent()->getGlobalList().insert(GV->getIterator(), NewGV);\n\n  Constant *InitVal = GV->getInitializer();\n  assert(InitVal->getType() != Type::getInt1Ty(GV->getContext()) &&\n         \"No reason to shrink to bool!\");\n\n  SmallVector<DIGlobalVariableExpression *, 1> GVs;\n  GV->getDebugInfo(GVs);\n\n  // If initialized to zero and storing one into the global, we can use a cast\n  // instead of a select to synthesize the desired value.\n  bool IsOneZero = false;\n  bool EmitOneOrZero = true;\n  if (ConstantInt *CI = dyn_cast<ConstantInt>(OtherVal)){\n    IsOneZero = InitVal->isNullValue() && CI->isOne();\n\n    if (ConstantInt *CIInit = dyn_cast<ConstantInt>(GV->getInitializer())){\n      uint64_t ValInit = CIInit->getZExtValue();\n      uint64_t ValOther = CI->getZExtValue();\n      uint64_t ValMinus = ValOther - ValInit;\n\n      for(auto *GVe : GVs){\n        DIGlobalVariable *DGV = GVe->getVariable();\n        DIExpression *E = GVe->getExpression();\n        const DataLayout &DL = GV->getParent()->getDataLayout();\n        unsigned SizeInOctets =\n          DL.getTypeAllocSizeInBits(NewGV->getType()->getElementType()) / 8;\n\n        // It is expected that the address of global optimized variable is on\n        // top of the stack. After optimization, value of that variable will\n        // be ether 0 for initial value or 1 for other value. The following\n        // expression should return constant integer value depending on the\n        // value at global object address:\n        // val * (ValOther - ValInit) + ValInit:\n        // DW_OP_deref DW_OP_constu <ValMinus>\n        // DW_OP_mul DW_OP_constu <ValInit> DW_OP_plus DW_OP_stack_value\n        SmallVector<uint64_t, 12> Ops = {\n            dwarf::DW_OP_deref_size, SizeInOctets,\n            dwarf::DW_OP_constu, ValMinus,\n            dwarf::DW_OP_mul, dwarf::DW_OP_constu, ValInit,\n            dwarf::DW_OP_plus};\n        bool WithStackValue = true;\n        E = DIExpression::prependOpcodes(E, Ops, WithStackValue);\n        DIGlobalVariableExpression *DGVE =\n          DIGlobalVariableExpression::get(NewGV->getContext(), DGV, E);\n        NewGV->addDebugInfo(DGVE);\n     }\n     EmitOneOrZero = false;\n    }\n  }\n\n  if (EmitOneOrZero) {\n     // FIXME: This will only emit address for debugger on which will\n     // be written only 0 or 1.\n     for(auto *GV : GVs)\n       NewGV->addDebugInfo(GV);\n   }\n\n  while (!GV->use_empty()) {\n    Instruction *UI = cast<Instruction>(GV->user_back());\n    if (StoreInst *SI = dyn_cast<StoreInst>(UI)) {\n      // Change the store into a boolean store.\n      bool StoringOther = SI->getOperand(0) == OtherVal;\n      // Only do this if we weren't storing a loaded value.\n      Value *StoreVal;\n      if (StoringOther || SI->getOperand(0) == InitVal) {\n        StoreVal = ConstantInt::get(Type::getInt1Ty(GV->getContext()),\n                                    StoringOther);\n      } else {\n        // Otherwise, we are storing a previously loaded copy.  To do this,\n        // change the copy from copying the original value to just copying the\n        // bool.\n        Instruction *StoredVal = cast<Instruction>(SI->getOperand(0));\n\n        // If we've already replaced the input, StoredVal will be a cast or\n        // select instruction.  If not, it will be a load of the original\n        // global.\n        if (LoadInst *LI = dyn_cast<LoadInst>(StoredVal)) {\n          assert(LI->getOperand(0) == GV && \"Not a copy!\");\n          // Insert a new load, to preserve the saved value.\n          StoreVal = new LoadInst(NewGV->getValueType(), NewGV,\n                                  LI->getName() + \".b\", false, 0,\n                                  LI->getOrdering(), LI->getSyncScopeID(), LI);\n        } else {\n          assert((isa<CastInst>(StoredVal) || isa<SelectInst>(StoredVal)) &&\n                 \"This is not a form that we understand!\");\n          StoreVal = StoredVal->getOperand(0);\n          assert(isa<LoadInst>(StoreVal) && \"Not a load of NewGV!\");\n        }\n      }\n      StoreInst *NSI =\n          new StoreInst(StoreVal, NewGV, false, 0, SI->getOrdering(),\n                        SI->getSyncScopeID(), SI);\n      NSI->setDebugLoc(SI->getDebugLoc());\n    } else {\n      // Change the load into a load of bool then a select.\n      LoadInst *LI = cast<LoadInst>(UI);\n      LoadInst *NLI =\n          new LoadInst(NewGV->getValueType(), NewGV, LI->getName() + \".b\",\n                       false, 0, LI->getOrdering(), LI->getSyncScopeID(), LI);\n      Instruction *NSI;\n      if (IsOneZero)\n        NSI = new ZExtInst(NLI, LI->getType(), \"\", LI);\n      else\n        NSI = SelectInst::Create(NLI, OtherVal, InitVal, \"\", LI);\n      NSI->takeName(LI);\n      // Since LI is split into two instructions, NLI and NSI both inherit the\n      // same DebugLoc\n      NLI->setDebugLoc(LI->getDebugLoc());\n      NSI->setDebugLoc(LI->getDebugLoc());\n      LI->replaceAllUsesWith(NSI);\n    }\n    UI->eraseFromParent();\n  }\n\n  // Retain the name of the old global variable. People who are debugging their\n  // programs may expect these variables to be named the same.\n  NewGV->takeName(GV);\n  GV->eraseFromParent();\n  return true;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/GlobalOpt/large-int-crash.ll (1 of 1)\nTesting Time: 1.11s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/GlobalOpt/large-int-crash.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "991834a51616799456a5e65cefde2f41c350aca2___GlobalOpt.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nbool llvm::peelLoop(Loop *L, unsigned PeelCount, LoopInfo *LI,\n                    ScalarEvolution *SE, DominatorTree *DT,\n                    AssumptionCache *AC, bool PreserveLCSSA) {\n  assert(PeelCount > 0 && \"Attempt to peel out zero iterations?\");\n  assert(canPeel(L) && \"Attempt to peel a loop which is not peelable?\");\n\n  LoopBlocksDFS LoopBlocks(L);\n  LoopBlocks.perform(LI);\n\n  BasicBlock *Header = L->getHeader();\n  BasicBlock *PreHeader = L->getLoopPreheader();\n  BasicBlock *Latch = L->getLoopLatch();\n  SmallVector<std::pair<BasicBlock *, BasicBlock *>, 4> ExitEdges;\n  L->getExitEdges(ExitEdges);\n\n  DenseMap<BasicBlock *, BasicBlock *> ExitIDom;\n  if (DT) {\n    // We'd like to determine the idom of exit block after peeling one\n    // iteration.\n    // Let Exit is exit block.\n    // Let ExitingSet - is a set of predecessors of Exit block. They are exiting\n    // blocks.\n    // Let Latch' and ExitingSet' are copies after a peeling.\n    // We'd like to find an idom'(Exit) - idom of Exit after peeling.\n    // It is an evident that idom'(Exit) will be the nearest common dominator\n    // of ExitingSet and ExitingSet'.\n    // idom(Exit) is a nearest common dominator of ExitingSet.\n    // idom(Exit)' is a nearest common dominator of ExitingSet'.\n    // Taking into account that we have a single Latch, Latch' will dominate\n    // Header and idom(Exit).\n    // So the idom'(Exit) is nearest common dominator of idom(Exit)' and Latch'.\n    // All these basic blocks are in the same loop, so what we find is\n    // (nearest common dominator of idom(Exit) and Latch)'.\n    // In the loop below we remember nearest common dominator of idom(Exit) and\n    // Latch to update idom of Exit later.\n    assert(L->hasDedicatedExits() && \"No dedicated exits?\");\n    for (auto Edge : ExitEdges) {\n      if (ExitIDom.count(Edge.second))\n        continue;\n      BasicBlock *BB = DT->findNearestCommonDominator(\n          DT->getNode(Edge.second)->getIDom()->getBlock(), Latch);\n      assert(L->contains(BB) && \"IDom is not in a loop\");\n      ExitIDom[Edge.second] = BB;\n    }\n  }\n\n  Function *F = Header->getParent();\n\n  // Set up all the necessary basic blocks. It is convenient to split the\n  // preheader into 3 parts - two blocks to anchor the peeled copy of the loop\n  // body, and a new preheader for the \"real\" loop.\n\n  // Peeling the first iteration transforms.\n  //\n  // PreHeader:\n  // ...\n  // Header:\n  //   LoopBody\n  //   If (cond) goto Header\n  // Exit:\n  //\n  // into\n  //\n  // InsertTop:\n  //   LoopBody\n  //   If (!cond) goto Exit\n  // InsertBot:\n  // NewPreHeader:\n  // ...\n  // Header:\n  //  LoopBody\n  //  If (cond) goto Header\n  // Exit:\n  //\n  // Each following iteration will split the current bottom anchor in two,\n  // and put the new copy of the loop body between these two blocks. That is,\n  // after peeling another iteration from the example above, we'll split\n  // InsertBot, and get:\n  //\n  // InsertTop:\n  //   LoopBody\n  //   If (!cond) goto Exit\n  // InsertBot:\n  //   LoopBody\n  //   If (!cond) goto Exit\n  // InsertBot.next:\n  // NewPreHeader:\n  // ...\n  // Header:\n  //  LoopBody\n  //  If (cond) goto Header\n  // Exit:\n\n  BasicBlock *InsertTop = SplitEdge(PreHeader, Header, DT, LI);\n  BasicBlock *InsertBot =\n      SplitBlock(InsertTop, InsertTop->getTerminator(), DT, LI);\n  BasicBlock *NewPreHeader =\n      SplitBlock(InsertBot, InsertBot->getTerminator(), DT, LI);\n\n  InsertTop->setName(Header->getName() + \".peel.begin\");\n  InsertBot->setName(Header->getName() + \".peel.next\");\n  NewPreHeader->setName(PreHeader->getName() + \".peel.newph\");\n\n  ValueToValueMapTy LVMap;\n\n  // If we have branch weight information, we'll want to update it for the\n  // newly created branches.\n  BranchInst *LatchBR =\n      cast<BranchInst>(cast<BasicBlock>(Latch)->getTerminator());\n  uint64_t ExitWeight = 0, FallThroughWeight = 0;\n  initBranchWeights(Header, LatchBR, ExitWeight, FallThroughWeight);\n\n  // For each peeled-off iteration, make a copy of the loop.\n  for (unsigned Iter = 0; Iter < PeelCount; ++Iter) {\n    SmallVector<BasicBlock *, 8> NewBlocks;\n    ValueToValueMapTy VMap;\n\n    cloneLoopBlocks(L, Iter, InsertTop, InsertBot, ExitEdges, NewBlocks,\n                    LoopBlocks, VMap, LVMap, DT, LI);\n\n    // Remap to use values from the current iteration instead of the\n    // previous one.\n    remapInstructionsInBlocks(NewBlocks, VMap);\n\n    if (DT) {\n      // Latches of the cloned loops dominate over the loop exit, so idom of the\n      // latter is the first cloned loop body, as original PreHeader dominates\n      // the original loop body.\n      if (Iter == 0)\n        for (auto Exit : ExitIDom)\n          DT->changeImmediateDominator(Exit.first,\n                                       cast<BasicBlock>(LVMap[Exit.second]));\n#ifdef EXPENSIVE_CHECKS\n      assert(DT->verify(DominatorTree::VerificationLevel::Fast));\n#endif\n    }\n\n    auto *LatchBRCopy = cast<BranchInst>(VMap[LatchBR]);\n    updateBranchWeights(InsertBot, LatchBRCopy, ExitWeight, FallThroughWeight);\n    // Remove Loop metadata from the latch branch instruction\n    // because it is not the Loop's latch branch anymore.\n    LatchBRCopy->setMetadata(LLVMContext::MD_loop, nullptr);\n\n    InsertTop = InsertBot;\n    InsertBot = SplitBlock(InsertBot, InsertBot->getTerminator(), DT, LI);\n    InsertBot->setName(Header->getName() + \".peel.next\");\n\n    F->getBasicBlockList().splice(InsertTop->getIterator(),\n                                  F->getBasicBlockList(),\n                                  NewBlocks[0]->getIterator(), F->end());\n  }\n\n  // Now adjust the phi nodes in the loop header to get their initial values\n  // from the last peeled-off iteration instead of the preheader.\n  for (BasicBlock::iterator I = Header->begin(); isa<PHINode>(I); ++I) {\n    PHINode *PHI = cast<PHINode>(I);\n    Value *NewVal = PHI->getIncomingValueForBlock(Latch);\n    Instruction *LatchInst = dyn_cast<Instruction>(NewVal);\n    if (LatchInst && L->contains(LatchInst))\n      NewVal = LVMap[LatchInst];\n\n    PHI->setIncomingValueForBlock(NewPreHeader, NewVal);\n  }\n\n  fixupBranchWeights(Header, LatchBR, ExitWeight, FallThroughWeight);\n\n  if (Loop *ParentLoop = L->getParentLoop())\n    L = ParentLoop;\n\n  // We modified the loop, update SE.\n  SE->forgetTopmostLoop(L);\n\n  // Finally DomtTree must be correct.\n  assert(DT->verify(DominatorTree::VerificationLevel::Fast));\n\n  // FIXME: Incrementally update loop-simplify\n  simplifyLoop(L, DT, LI, SE, AC, nullptr, PreserveLCSSA);\n\n  NumPeeled++;\n\n  // Update Metadata for count of peeled off iterations.\n  unsigned AlreadyPeeled = 0;\n  if (auto Peeled = getOptionalIntLoopAttribute(L, PeeledCountMetaData))\n    AlreadyPeeled = *Peeled;\n  addStringMetadataToLoop(L, PeeledCountMetaData, AlreadyPeeled + PeelCount);\n\n  return true;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/LoopUnroll/peel-loop-inner.ll (1 of 1)\nTesting Time: 0.33s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LoopUnroll/peel-loop-inner.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "036e636aa7fc6d367ac19197936f3320f28214b0___LoopUnrollPeel.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic bool allSameBlock(ArrayRef<Value *> VL) {\n  Instruction *I0 = dyn_cast<Instruction>(VL[0]);\n  if (!I0)\n    return false;\n  BasicBlock *BB = I0->getParent();\n  for (int i = 1, e = VL.size(); i < e; i++) {\n    Instruction *I = dyn_cast<Instruction>(VL[i]);\n    if (!I)\n      return false;\n\n    if (BB != I->getParent())\n      return false;\n  }\n  return true;\n}\n```\n \n\n\nwith the following test error:  \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "b6a0faaa0c793aede7911be241b1895a9ebea41c___SLPVectorizer.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nChangeStatus AAReturnedValuesImpl::manifest(Attributor &A) {\n  ChangeStatus Changed = ChangeStatus::UNCHANGED;\n\n  // Bookkeeping.\n  assert(isValidState());\n  STATS_DECLTRACK(KnownReturnValues, FunctionReturn,\n                  \"Number of function with known return values\");\n\n  // Check if we have an assumed unique return value that we could manifest.\n  Optional<Value *> UniqueRV = getAssumedUniqueReturnValue(A);\n\n  if (!UniqueRV.hasValue() || !UniqueRV.getValue())\n    return Changed;\n\n  // Bookkeeping.\n  STATS_DECLTRACK(UniqueReturnValue, FunctionReturn,\n                  \"Number of function with unique return\");\n\n  // Callback to replace the uses of CB with the constant C.\n  auto ReplaceCallSiteUsersWith = [](CallBase &CB, Constant &C) {\n    if (CB.getNumUses() == 0 || CB.isMustTailCall())\n      return ChangeStatus::UNCHANGED;\n    CB.replaceAllUsesWith(&C);\n    return ChangeStatus::CHANGED;\n  };\n\n  // If the assumed unique return value is an argument, annotate it.\n  if (auto *UniqueRVArg = dyn_cast<Argument>(UniqueRV.getValue())) {\n    // TODO: This should be handled differently!\n    this->AnchorVal = UniqueRVArg;\n    this->KindOrArgNo = UniqueRVArg->getArgNo();\n    Changed = IRAttribute::manifest(A);\n  } else if (auto *RVC = dyn_cast<Constant>(UniqueRV.getValue())) {\n    // We can replace the returned value with the unique returned constant.\n    Value &AnchorValue = getAnchorValue();\n    if (Function *F = dyn_cast<Function>(&AnchorValue)) {\n      for (const Use &U : F->uses())\n        if (CallBase *CB = dyn_cast<CallBase>(U.getUser()))\n          if (CB->isCallee(&U)) {\n            Constant *RVCCast =\n                ConstantExpr::getTruncOrBitCast(RVC, CB->getType());\n            Changed = ReplaceCallSiteUsersWith(*CB, *RVCCast) | Changed;\n          }\n    } else {\n      assert(isa<CallBase>(AnchorValue) &&\n             \"Expcected a function or call base anchor!\");\n      Constant *RVCCast =\n          ConstantExpr::getTruncOrBitCast(RVC, AnchorValue.getType());\n      Changed = ReplaceCallSiteUsersWith(cast<CallBase>(AnchorValue), *RVCCast);\n    }\n    if (Changed == ChangeStatus::CHANGED)\n      STATS_DECLTRACK(UniqueConstantReturnValue, FunctionReturn,\n                      \"Number of function returns replaced by constant return\");\n  }\n\n  return Changed;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/IPConstantProp/PR43857.ll (1 of 1)\n\nTesting Time: 1.38s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/IPConstantProp/PR43857.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "07d16424f28482a852a35bd817189d4dfb1701ef___Attributor.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nInstruction *InstCombiner::foldICmpAddConstant(ICmpInst &Cmp,\n                                               BinaryOperator *Add,\n                                               const APInt &C) {\n  Value *Y = Add->getOperand(1);\n  const APInt *C2;\n  if (Cmp.isEquality() || !match(Y, m_APInt(C2)))\n    return nullptr;\n\n  // Fold icmp pred (add X, C2), C.\n  Value *X = Add->getOperand(0);\n  Type *Ty = Add->getType();\n  CmpInst::Predicate Pred = Cmp.getPredicate();\n\n  if (!Add->hasOneUse())\n    return nullptr;\n\n  // If the add does not wrap, we can always adjust the compare by subtracting\n  // the constants. Equality comparisons are handled elsewhere. SGE/SLE/UGE/ULE\n  // are canonicalized to SGT/SLT/UGT/ULT.\n  if ((Add->hasNoSignedWrap() &&\n       (Pred == ICmpInst::ICMP_SGT || Pred == ICmpInst::ICMP_SLT)) ||\n      (Add->hasNoUnsignedWrap() &&\n       (Pred == ICmpInst::ICMP_UGT || Pred == ICmpInst::ICMP_ULT))) {\n    bool Overflow;\n    APInt NewC =\n        Cmp.isSigned() ? C.ssub_ov(*C2, Overflow) : C.usub_ov(*C2, Overflow);\n    // If there is overflow, the result must be true or false.\n    // TODO: Can we assert there is no overflow because InstSimplify always\n    // handles those cases?\n    if (!Overflow)\n      // icmp Pred (add nsw X, C2), C --> icmp Pred X, (C - C2)\n      return new ICmpInst(Pred, X, ConstantInt::get(Ty, NewC));\n  }\n\n  auto CR = ConstantRange::makeExactICmpRegion(Pred, C).subtract(*C2);\n  const APInt &Upper = CR.getUpper();\n  const APInt &Lower = CR.getLower();\n  if (Cmp.isSigned()) {\n    if (Lower.isSignMask())\n      return new ICmpInst(ICmpInst::ICMP_SLT, X, ConstantInt::get(Ty, Upper));\n    if (Upper.isSignMask())\n      return new ICmpInst(ICmpInst::ICMP_SGE, X, ConstantInt::get(Ty, Lower));\n  } else {\n    if (Lower.isMinValue())\n      return new ICmpInst(ICmpInst::ICMP_ULT, X, ConstantInt::get(Ty, Upper));\n    if (Upper.isMinValue())\n      return new ICmpInst(ICmpInst::ICMP_UGE, X, ConstantInt::get(Ty, Lower));\n  }\n\n  // X+C <u C2 -> (X & -C2) == C\n  //   iff C & (C2-1) == 0\n  //       C2 is a power of 2\n  if (Pred == ICmpInst::ICMP_ULT && C.isPowerOf2() && (*C2 & (C - 1)) == 0)\n    return new ICmpInst(ICmpInst::ICMP_EQ, Builder.CreateAnd(X, -C),\n                        ConstantExpr::getNeg(cast<Constant>(Y)));\n\n  // X+C >u C2 -> (X & ~C2) != C\n  //   iff C & C2 == 0\n  //       C2+1 is a power of 2\n  if (Pred == ICmpInst::ICMP_UGT && (C + 1).isPowerOf2() && (*C2 & C) == 0)\n    return new ICmpInst(ICmpInst::ICMP_NE, Builder.CreateAnd(X, ~C),\n                        ConstantExpr::getNeg(cast<Constant>(Y)));\n\n  return nullptr;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/icmp-add.ll (1 of 1)\n\nTesting Time: 0.22s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/icmp-add.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Transforms/LoopUnroll/runtime-loop-multiple-exits.ll (1 of 1)\n\nTesting Time: 0.82s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LoopUnroll/runtime-loop-multiple-exits.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Transforms/LoopVectorize/if-conversion-nest.ll (1 of 1)\n\nTesting Time: 0.12s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LoopVectorize/if-conversion-nest.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Transforms/LoopVectorize/runtime-check.ll (1 of 1)\n\nTesting Time: 0.16s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LoopVectorize/runtime-check.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "0f22e783a038b6983f0fe161eef6cf2add3a4156___InstCombineCompares.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic FunctionOptions\ngetFunctionOptions(const DISubroutineType *Ty,\n                   const DICompositeType *ClassTy = nullptr,\n                   StringRef SPName = StringRef(\"\")) {\n  FunctionOptions FO = FunctionOptions::None;\n  const DIType *ReturnTy = nullptr;\n  if (auto TypeArray = Ty->getTypeArray()) {\n    if (TypeArray.size())\n      ReturnTy = TypeArray[0];\n  }\n\n  if (auto *ReturnDCTy = dyn_cast_or_null<DICompositeType>(ReturnTy)) {\n    if (isNonTrivial(ReturnDCTy))\n      FO |= FunctionOptions::CxxReturnUdt;\n  }\n\n  // DISubroutineType is unnamed. Use DISubprogram's i.e. SPName in comparison.\n  if (ClassTy && isNonTrivial(ClassTy) && SPName == ClassTy->getName()) {\n    FO |= FunctionOptions::Constructor;\n\n  // TODO: put the FunctionOptions::ConstructorWithVirtualBases flag.\n\n  }\n  return FO;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/COFF/function-options.ll (1 of 1)\n\nTesting Time: 0.25s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/COFF/function-options.ll\n\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "5b3b21f0258899d03f6299fba6b4c78d7e730353___CodeViewDebug.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nvoid DevirtModule::scanTypeTestUsers(Function *TypeTestFunc) {\n  // Find all virtual calls via a virtual table pointer %p under an assumption\n  // of the form llvm.assume(llvm.type.test(%p, %md)). This indicates that %p\n  // points to a member of the type identifier %md. Group calls by (type ID,\n  // offset) pair (effectively the identity of the virtual function) and store\n  // to CallSlots.\n  DenseSet<CallBase *> SeenCallSites;\n  for (auto I = TypeTestFunc->use_begin(), E = TypeTestFunc->use_end();\n       I != E;) {\n    auto CI = dyn_cast<CallInst>(I->getUser());\n    ++I;\n    if (!CI)\n      continue;\n\n    // Search for virtual calls based on %p and add them to DevirtCalls.\n    SmallVector<DevirtCallSite, 1> DevirtCalls;\n    SmallVector<CallInst *, 1> Assumes;\n    auto &DT = LookupDomTree(*CI->getFunction());\n    findDevirtualizableCallsForTypeTest(DevirtCalls, Assumes, CI, DT);\n\n    // If we found any, add them to CallSlots.\n    if (!Assumes.empty()) {\n      Metadata *TypeId =\n          cast<MetadataAsValue>(CI->getArgOperand(1))->getMetadata();\n      Value *Ptr = CI->getArgOperand(0)->stripPointerCasts();\n      for (DevirtCallSite Call : DevirtCalls) {\n        // Only add this CallSite if we haven't seen it before. The vtable\n        // pointer may have been CSE'd with pointers from other call sites,\n        // and we don't want to process call sites multiple times. We can't\n        // just skip the vtable Ptr if it has been seen before, however, since\n        // it may be shared by type tests that dominate different calls.\n        if (SeenCallSites.insert(&Call.CB).second)\n          CallSlots[{TypeId, Call.Offset}].addCallSite(Ptr, Call.CB, nullptr);\n      }\n    }\n\n    // We no longer need the assumes or the type test.\n    for (auto Assume : Assumes)\n      Assume->eraseFromParent();\n    // We can't use RecursivelyDeleteTriviallyDeadInstructions here because we\n    // may use the vtable argument later.\n    if (CI->use_empty())\n      CI->eraseFromParent();\n  }\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: ThinLTO/X86/devirt_multiple_type_test.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: ThinLTO/X86/devirt_multiple_type_test.ll\n\n\nTesting Time: 0.41s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "d291bd510e6a4e62594186cb8f3ddc18acf2ee1a___WholeProgramDevirt.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic SmallString<128>\ngetELFSectionNameForGlobal(const GlobalObject *GO, SectionKind Kind,\n                           Mangler &Mang, const TargetMachine &TM,\n                           unsigned EntrySize, bool UniqueSectionName) {\n  SmallString<128> Name;\n  if (Kind.isMergeableCString()) {\n    // We also need alignment here.\n    // FIXME: this is getting the alignment of the character, not the\n    // alignment of the global!\n    unsigned Align = GO->getParent()->getDataLayout().getPreferredAlignment(\n        cast<GlobalVariable>(GO));\n\n    std::string SizeSpec = \".rodata.str\" + utostr(EntrySize) + \".\";\n    Name = SizeSpec + utostr(Align);\n  } else if (Kind.isMergeableConst()) {\n    Name = \".rodata.cst\";\n    Name += utostr(EntrySize);\n  } else {\n    Name = getSectionPrefixForGlobal(Kind);\n  }\n\n  if (const auto *F = dyn_cast<Function>(GO)) {\n    if (Optional<StringRef> Prefix = F->getSectionPrefix())\n      Name += *Prefix;\n  }\n\n  if (UniqueSectionName) {\n    Name.push_back('.');\n    TM.getNameWithPrefix(Name, GO, Mang, /*MayAlwaysUsePrivate*/true);\n  }\n  return Name;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/CodeGenPrepare/X86/section.ll (1 of 1)\n********************\nFailing Tests (1):\n  LLVM :: Transforms/CodeGenPrepare/X86/section.ll\n\n\nTesting Time: 1.15s\n  Unexpected Failures: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "66055230bf6673b76e7330fef76d752a1ea8638e___TargetLoweringObjectFileImpl.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nValue *InstCombinerImpl::SimplifyUsingDistributiveLaws(BinaryOperator &I) {\n  Value *LHS = I.getOperand(0), *RHS = I.getOperand(1);\n  BinaryOperator *Op0 = dyn_cast<BinaryOperator>(LHS);\n  BinaryOperator *Op1 = dyn_cast<BinaryOperator>(RHS);\n  Instruction::BinaryOps TopLevelOpcode = I.getOpcode();\n\n  {\n    // Factorization.\n    Value *A, *B, *C, *D;\n    Instruction::BinaryOps LHSOpcode, RHSOpcode;\n    if (Op0)\n      LHSOpcode = getBinOpsForFactorization(TopLevelOpcode, Op0, A, B);\n    if (Op1)\n      RHSOpcode = getBinOpsForFactorization(TopLevelOpcode, Op1, C, D);\n\n    // The instruction has the form \"(A op' B) op (C op' D)\".  Try to factorize\n    // a common term.\n    if (Op0 && Op1 && LHSOpcode == RHSOpcode)\n      if (Value *V = tryFactorization(I, LHSOpcode, A, B, C, D))\n        return V;\n\n    // The instruction has the form \"(A op' B) op (C)\".  Try to factorize common\n    // term.\n    if (Op0)\n      if (Value *Ident = getIdentityValue(LHSOpcode, RHS))\n        if (Value *V = tryFactorization(I, LHSOpcode, A, B, RHS, Ident))\n          return V;\n\n    // The instruction has the form \"(B) op (C op' D)\".  Try to factorize common\n    // term.\n    if (Op1)\n      if (Value *Ident = getIdentityValue(RHSOpcode, LHS))\n        if (Value *V = tryFactorization(I, RHSOpcode, LHS, Ident, C, D))\n          return V;\n  }\n\n  // Expansion.\n  if (Op0 && rightDistributesOverLeft(Op0->getOpcode(), TopLevelOpcode)) {\n    // The instruction has the form \"(A op' B) op C\".  See if expanding it out\n    // to \"(A op C) op' (B op C)\" results in simplifications.\n    Value *A = Op0->getOperand(0), *B = Op0->getOperand(1), *C = RHS;\n    Instruction::BinaryOps InnerOpcode = Op0->getOpcode(); // op'\n\n    Value *L = SimplifyBinOp(TopLevelOpcode, A, C, SQ.getWithInstruction(&I));\n    Value *R = SimplifyBinOp(TopLevelOpcode, B, C, SQ.getWithInstruction(&I));\n\n    // Do \"A op C\" and \"B op C\" both simplify?\n    if (L && R) {\n      // They do! Return \"L op' R\".\n      ++NumExpand;\n      C = Builder.CreateBinOp(InnerOpcode, L, R);\n      C->takeName(&I);\n      return C;\n    }\n\n    // Does \"A op C\" simplify to the identity value for the inner opcode?\n    if (L && L == ConstantExpr::getBinOpIdentity(InnerOpcode, L->getType())) {\n      // They do! Return \"B op C\".\n      ++NumExpand;\n      C = Builder.CreateBinOp(TopLevelOpcode, B, C);\n      C->takeName(&I);\n      return C;\n    }\n\n    // Does \"B op C\" simplify to the identity value for the inner opcode?\n    if (R && R == ConstantExpr::getBinOpIdentity(InnerOpcode, R->getType())) {\n      // They do! Return \"A op C\".\n      ++NumExpand;\n      C = Builder.CreateBinOp(TopLevelOpcode, A, C);\n      C->takeName(&I);\n      return C;\n    }\n  }\n\n  if (Op1 && leftDistributesOverRight(TopLevelOpcode, Op1->getOpcode())) {\n    // The instruction has the form \"A op (B op' C)\".  See if expanding it out\n    // to \"(A op B) op' (A op C)\" results in simplifications.\n    Value *A = LHS, *B = Op1->getOperand(0), *C = Op1->getOperand(1);\n    Instruction::BinaryOps InnerOpcode = Op1->getOpcode(); // op'\n\n    Value *L = SimplifyBinOp(TopLevelOpcode, A, B, SQ.getWithInstruction(&I));\n    Value *R = SimplifyBinOp(TopLevelOpcode, A, C, SQ.getWithInstruction(&I));\n\n    // Do \"A op B\" and \"A op C\" both simplify?\n    if (L && R) {\n      // They do! Return \"L op' R\".\n      ++NumExpand;\n      A = Builder.CreateBinOp(InnerOpcode, L, R);\n      A->takeName(&I);\n      return A;\n    }\n\n    // Does \"A op B\" simplify to the identity value for the inner opcode?\n    if (L && L == ConstantExpr::getBinOpIdentity(InnerOpcode, L->getType())) {\n      // They do! Return \"A op C\".\n      ++NumExpand;\n      A = Builder.CreateBinOp(TopLevelOpcode, A, C);\n      A->takeName(&I);\n      return A;\n    }\n\n    // Does \"A op C\" simplify to the identity value for the inner opcode?\n    if (R && R == ConstantExpr::getBinOpIdentity(InnerOpcode, R->getType())) {\n      // They do! Return \"A op B\".\n      ++NumExpand;\n      A = Builder.CreateBinOp(TopLevelOpcode, A, B);\n      A->takeName(&I);\n      return A;\n    }\n  }\n\n  return SimplifySelectsFeedingBinaryOp(I, LHS, RHS);\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/dont-distribute-phi.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/dont-distribute-phi.ll\n\n\nTesting Time: 0.25s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "cfdc96714bdfeabea31b1f4d2e0c65e424933994___InstructionCombining.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nLoopIdiomRecognize::LegalStoreKind\nLoopIdiomRecognize::isLegalStore(StoreInst *SI) {\n  // Don't touch volatile stores.\n  if (SI->isVolatile())\n    return LegalStoreKind::None;\n  // We only want simple or unordered-atomic stores.\n  if (!SI->isUnordered())\n    return LegalStoreKind::None;\n\n  // Don't convert stores of non-integral pointer types to memsets (which stores\n  // integers).\n  if (DL->isNonIntegralPointerType(SI->getValueOperand()->getType()))\n    return LegalStoreKind::None;\n\n  // Avoid merging nontemporal stores.\n  if (SI->getMetadata(LLVMContext::MD_nontemporal))\n    return LegalStoreKind::None;\n\n  Value *StoredVal = SI->getValueOperand();\n  Value *StorePtr = SI->getPointerOperand();\n\n  // Reject stores that are so large that they overflow an unsigned.\n  // When storing out scalable vectors we bail out for now, since the code\n  // below currently only works for constant strides.\n  TypeSize SizeInBits = DL->getTypeSizeInBits(StoredVal->getType());\n  if (SizeInBits.isScalable() || (SizeInBits.getFixedSize() & 7) ||\n      (SizeInBits.getFixedSize() >> 32) != 0)\n    return LegalStoreKind::None;\n\n  // See if the pointer expression is an AddRec like {base,+,1} on the current\n  // loop, which indicates a strided store.  If we have something else, it's a\n  // random store we can't handle.\n  const SCEVAddRecExpr *StoreEv =\n      dyn_cast<SCEVAddRecExpr>(SE->getSCEV(StorePtr));\n  if (!StoreEv || StoreEv->getLoop() != CurLoop || !StoreEv->isAffine())\n    return LegalStoreKind::None;\n\n  // Check to see if we have a constant stride.\n  if (!isa<SCEVConstant>(StoreEv->getOperand(1)))\n    return LegalStoreKind::None;\n\n  // See if the store can be turned into a memset.\n\n  // If the stored value is a byte-wise value (like i32 -1), then it may be\n  // turned into a memset of i8 -1, assuming that all the consecutive bytes\n  // are stored.  A store of i32 0x01020304 can never be turned into a memset,\n  // but it can be turned into memset_pattern if the target supports it.\n  Value *SplatValue = isBytewiseValue(StoredVal, *DL);\n  Constant *PatternValue = nullptr;\n\n  // Note: memset and memset_pattern on unordered-atomic is yet not supported\n  bool UnorderedAtomic = SI->isUnordered() && !SI->isSimple();\n\n  // If we're allowed to form a memset, and the stored value would be\n  // acceptable for memset, use it.\n  if (!UnorderedAtomic && HasMemset && SplatValue && !DisableLIRP::Memset &&\n      // Verify that the stored value is loop invariant.  If not, we can't\n      // promote the memset.\n      CurLoop->isLoopInvariant(SplatValue)) {\n    // It looks like we can use SplatValue.\n    return LegalStoreKind::Memset;\n  } else if (!UnorderedAtomic && HasMemsetPattern && !DisableLIRP::Memset &&\n             // Don't create memset_pattern16s with address spaces.\n             StorePtr->getType()->getPointerAddressSpace() == 0 &&\n             (PatternValue = getMemSetPatternValue(StoredVal, DL))) {\n    // It looks like we can use PatternValue!\n    return LegalStoreKind::MemsetPattern;\n  }\n\n  // Otherwise, see if the store can be turned into a memcpy.\n  if (HasMemcpy && !DisableLIRP::Memcpy) {\n    // Check to see if the stride matches the size of the store.  If so, then we\n    // know that every byte is touched in the loop.\n    APInt Stride = getStoreStride(StoreEv);\n    unsigned StoreSize = DL->getTypeStoreSize(SI->getValueOperand()->getType());\n    if (StoreSize != Stride && StoreSize != -Stride)\n      return LegalStoreKind::None;\n\n    // The store must be feeding a non-volatile load.\n    LoadInst *LI = dyn_cast<LoadInst>(SI->getValueOperand());\n\n    // Only allow non-volatile loads\n    if (!LI || LI->isVolatile())\n      return LegalStoreKind::None;\n    // Only allow simple or unordered-atomic loads\n    if (!LI->isUnordered())\n      return LegalStoreKind::None;\n\n    // See if the pointer expression is an AddRec like {base,+,1} on the current\n    // loop, which indicates a strided load.  If we have something else, it's a\n    // random load we can't handle.\n    const SCEVAddRecExpr *LoadEv =\n        dyn_cast<SCEVAddRecExpr>(SE->getSCEV(LI->getPointerOperand()));\n    if (!LoadEv || LoadEv->getLoop() != CurLoop || !LoadEv->isAffine())\n      return LegalStoreKind::None;\n\n    // The store and load must share the same stride.\n    if (StoreEv->getOperand(1) != LoadEv->getOperand(1))\n      return LegalStoreKind::None;\n\n    // Success.  This store can be converted into a memcpy.\n    UnorderedAtomic = UnorderedAtomic || LI->isAtomic();\n    return UnorderedAtomic ? LegalStoreKind::UnorderedAtomicMemcpy\n                           : LegalStoreKind::Memcpy;\n  }\n  // This store can't be transformed into a memset/memcpy.\n  return LegalStoreKind::None;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/LoopIdiom/non-integral-pointers.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopIdiom/non-integral-pointers.ll\n\n\nTesting Time: 0.31s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "de3cb9548d77726186db2d384193e0565cb0afc5___LoopIdiomRecognize.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\n  bool foldGEPPhi(GetElementPtrInst &GEPI) {\n    if (!GEPI.hasAllConstantIndices())\n      return false;\n\n    PHINode *PHI = cast<PHINode>(GEPI.getPointerOperand());\n    if (GEPI.getParent() != PHI->getParent() ||\n        llvm::any_of(PHI->incoming_values(), [](Value *In)\n          { Instruction *I = dyn_cast<Instruction>(In);\n            return !I || isa<GetElementPtrInst>(I) || isa<PHINode>(I) ||\n                   succ_empty(I->getParent()) ||\n                   !I->getParent()->isLegalToHoistInto();\n          }))\n      return false;\n\n    LLVM_DEBUG(dbgs() << \"  Rewriting gep(phi) -> phi(gep):\"\n                      << \"\\n    original: \" << *PHI\n                      << \"\\n              \" << GEPI\n                      << \"\\n          to: \");\n\n    SmallVector<Value *, 4> Index(GEPI.idx_begin(), GEPI.idx_end());\n    bool IsInBounds = GEPI.isInBounds();\n    IRBuilderTy PHIBuilder(GEPI.getParent()->getFirstNonPHI());\n    PHINode *NewPN = PHIBuilder.CreatePHI(GEPI.getType(),\n                                          PHI->getNumIncomingValues(),\n                                          PHI->getName() + \".sroa.phi\");\n    for (unsigned I = 0, E = PHI->getNumIncomingValues(); I != E; ++I) {\n      Instruction *In = cast<Instruction>(PHI->getIncomingValue(I));\n\n      IRBuilderTy B(In->getParent(), std::next(In->getIterator()));\n      Value *NewVal = IsInBounds\n          ? B.CreateInBoundsGEP(In, Index, In->getName() + \".sroa.gep\")\n          : B.CreateGEP(In, Index, In->getName() + \".sroa.gep\");\n      NewPN->addIncoming(NewVal, PHI->getIncomingBlock(I));\n    }\n\n    Visited.erase(&GEPI);\n    GEPI.replaceAllUsesWith(NewPN);\n    GEPI.eraseFromParent();\n    Visited.insert(NewPN);\n    enqueueUsers(*NewPN);\n\n    LLVM_DEBUG(for (Value *In : NewPN->incoming_values())\n                 dbgs() << \"\\n              \" << *In;\n               dbgs() << \"\\n              \" << *NewPN << '\\n');\n\n    return true;\n  }\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/SROA/phi-gep.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SROA/phi-gep.ll\n\n\nTesting Time: 1.41s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "00928a1956a1618f394ffe99fc63b0d81e1f88c7___SROA.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nbool SampleProfileLoader::tryPromoteAndInlineCandidate(\n    Function &F, InlineCandidate &Candidate, uint64_t SumOrigin, uint64_t &Sum,\n    SmallVector<CallBase *, 8> *InlinedCallSite) {\n  auto CalleeFunctionName = Candidate.CalleeSamples->getFuncName();\n  auto R = SymbolMap.find(CalleeFunctionName);\n  if (R == SymbolMap.end() || !R->getValue())\n    return false;\n\n  auto &CI = *Candidate.CallInstr;\n  if (!doesHistoryAllowICP(CI, R->getValue()->getName()))\n    return false;\n\n  const char *Reason = \"Callee function not available\";\n  // R->getValue() != &F is to prevent promoting a recursive call.\n  // If it is a recursive call, we do not inline it as it could bloat\n  // the code exponentially. There is way to better handle this, e.g.\n  // clone the caller first, and inline the cloned caller if it is\n  // recursive. As llvm does not inline recursive calls, we will\n  // simply ignore it instead of handling it explicitly.\n  if (!R->getValue()->isDeclaration() && R->getValue()->getSubprogram() &&\n      R->getValue()->hasFnAttribute(\"use-sample-profile\") &&\n      R->getValue() != &F && isLegalToPromote(CI, R->getValue(), &Reason)) {\n    // For promoted target, set its value with NOMORE_ICP_MAGICNUM count\n    // in the value profile metadata so the target won't be promoted again.\n    SmallVector<InstrProfValueData, 1> SortedCallTargets = {InstrProfValueData{\n        Function::getGUID(R->getValue()->getName()), NOMORE_ICP_MAGICNUM}};\n    updateIDTMetaData(CI, SortedCallTargets, 0);\n\n    auto *DI = &pgo::promoteIndirectCall(\n        CI, R->getValue(), Candidate.CallsiteCount, Sum, false, ORE);\n    if (DI) {\n      Sum -= Candidate.CallsiteCount;\n      // Prorate the indirect callsite distribution.\n      // Do not update the promoted direct callsite distribution at this\n      // point since the original distribution combined with the callee\n      // profile will be used to prorate callsites from the callee if\n      // inlined. Once not inlined, the direct callsite distribution should\n      // be prorated so that the it will reflect the real callsite counts.\n      setProbeDistributionFactor(CI, Candidate.CallsiteDistribution * Sum /\n                                         SumOrigin);\n      Candidate.CallInstr = DI;\n      if (isa<CallInst>(DI) || isa<InvokeInst>(DI)) {\n        bool Inlined = tryInlineCandidate(Candidate, InlinedCallSite);\n        if (!Inlined) {\n          // Prorate the direct callsite distribution so that it reflects real\n          // callsite counts.\n          setProbeDistributionFactor(*DI, Candidate.CallsiteDistribution *\n                                              Candidate.CallsiteCount /\n                                              SumOrigin);\n        }\n        return Inlined;\n      }\n    }\n  } else {\n    LLVM_DEBUG(dbgs() << \"\\nFailed to promote indirect call to \"\n                      << Candidate.CalleeSamples->getFuncName() << \" because \"\n                      << Reason << \"\\n\");\n  }\n  return false;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/SampleProfile/pseudo-probe-icp-factor.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SampleProfile/pseudo-probe-icp-factor.ll\n\n\nTesting Time: 0.21s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "6d5132b426fbe23c5bc3e591ca2ca09a315d459b___SampleProfile.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nbool LoopInterchangeTransform::adjustLoopBranches() {\n  LLVM_DEBUG(dbgs() << \"adjustLoopBranches called\\n\");\n  std::vector<DominatorTree::UpdateType> DTUpdates;\n\n  BasicBlock *OuterLoopPreHeader = OuterLoop->getLoopPreheader();\n  BasicBlock *InnerLoopPreHeader = InnerLoop->getLoopPreheader();\n\n  assert(OuterLoopPreHeader != OuterLoop->getHeader() &&\n         InnerLoopPreHeader != InnerLoop->getHeader() && OuterLoopPreHeader &&\n         InnerLoopPreHeader && \"Guaranteed by loop-simplify form\");\n  // Ensure that both preheaders do not contain PHI nodes and have single\n  // predecessors. This allows us to move them easily. We use\n  // InsertPreHeaderForLoop to create an 'extra' preheader, if the existing\n  // preheaders do not satisfy those conditions.\n  if (isa<PHINode>(OuterLoopPreHeader->begin()) ||\n      !OuterLoopPreHeader->getUniquePredecessor())\n    OuterLoopPreHeader =\n        InsertPreheaderForLoop(OuterLoop, DT, LI, nullptr, true);\n  if (InnerLoopPreHeader == OuterLoop->getHeader())\n    InnerLoopPreHeader =\n        InsertPreheaderForLoop(InnerLoop, DT, LI, nullptr, true);\n\n  // Adjust the loop preheader\n  BasicBlock *InnerLoopHeader = InnerLoop->getHeader();\n  BasicBlock *OuterLoopHeader = OuterLoop->getHeader();\n  BasicBlock *InnerLoopLatch = InnerLoop->getLoopLatch();\n  BasicBlock *OuterLoopLatch = OuterLoop->getLoopLatch();\n  BasicBlock *OuterLoopPredecessor = OuterLoopPreHeader->getUniquePredecessor();\n  BasicBlock *InnerLoopLatchPredecessor =\n      InnerLoopLatch->getUniquePredecessor();\n  BasicBlock *InnerLoopLatchSuccessor;\n  BasicBlock *OuterLoopLatchSuccessor;\n\n  BranchInst *OuterLoopLatchBI =\n      dyn_cast<BranchInst>(OuterLoopLatch->getTerminator());\n  BranchInst *InnerLoopLatchBI =\n      dyn_cast<BranchInst>(InnerLoopLatch->getTerminator());\n  BranchInst *OuterLoopHeaderBI =\n      dyn_cast<BranchInst>(OuterLoopHeader->getTerminator());\n  BranchInst *InnerLoopHeaderBI =\n      dyn_cast<BranchInst>(InnerLoopHeader->getTerminator());\n\n  if (!OuterLoopPredecessor || !InnerLoopLatchPredecessor ||\n      !OuterLoopLatchBI || !InnerLoopLatchBI || !OuterLoopHeaderBI ||\n      !InnerLoopHeaderBI)\n    return false;\n\n  BranchInst *InnerLoopLatchPredecessorBI =\n      dyn_cast<BranchInst>(InnerLoopLatchPredecessor->getTerminator());\n  BranchInst *OuterLoopPredecessorBI =\n      dyn_cast<BranchInst>(OuterLoopPredecessor->getTerminator());\n\n  if (!OuterLoopPredecessorBI || !InnerLoopLatchPredecessorBI)\n    return false;\n  BasicBlock *InnerLoopHeaderSuccessor = InnerLoopHeader->getUniqueSuccessor();\n  if (!InnerLoopHeaderSuccessor)\n    return false;\n\n  // Adjust Loop Preheader and headers.\n  // The branches in the outer loop predecessor and the outer loop header can\n  // be unconditional branches or conditional branches with duplicates. Consider\n  // this when updating the successors.\n  updateSuccessor(OuterLoopPredecessorBI, OuterLoopPreHeader,\n                  InnerLoopPreHeader, DTUpdates, /*MustUpdateOnce=*/false);\n  // The outer loop header might or might not branch to the outer latch.\n  // We are guaranteed to branch to the inner loop preheader.\n  if (llvm::is_contained(OuterLoopHeaderBI->successors(), OuterLoopLatch))\n    updateSuccessor(OuterLoopHeaderBI, OuterLoopLatch, LoopExit, DTUpdates,\n                    /*MustUpdateOnce=*/false);\n  updateSuccessor(OuterLoopHeaderBI, InnerLoopPreHeader,\n                  InnerLoopHeaderSuccessor, DTUpdates,\n                  /*MustUpdateOnce=*/false);\n\n  // Adjust reduction PHI's now that the incoming block has changed.\n  InnerLoopHeaderSuccessor->replacePhiUsesWith(InnerLoopHeader,\n                                               OuterLoopHeader);\n\n  updateSuccessor(InnerLoopHeaderBI, InnerLoopHeaderSuccessor,\n                  OuterLoopPreHeader, DTUpdates);\n\n  // -------------Adjust loop latches-----------\n  if (InnerLoopLatchBI->getSuccessor(0) == InnerLoopHeader)\n    InnerLoopLatchSuccessor = InnerLoopLatchBI->getSuccessor(1);\n  else\n    InnerLoopLatchSuccessor = InnerLoopLatchBI->getSuccessor(0);\n\n  updateSuccessor(InnerLoopLatchPredecessorBI, InnerLoopLatch,\n                  InnerLoopLatchSuccessor, DTUpdates);\n\n\n  if (OuterLoopLatchBI->getSuccessor(0) == OuterLoopHeader)\n    OuterLoopLatchSuccessor = OuterLoopLatchBI->getSuccessor(1);\n  else\n    OuterLoopLatchSuccessor = OuterLoopLatchBI->getSuccessor(0);\n\n  updateSuccessor(InnerLoopLatchBI, InnerLoopLatchSuccessor,\n                  OuterLoopLatchSuccessor, DTUpdates);\n  updateSuccessor(OuterLoopLatchBI, OuterLoopLatchSuccessor, InnerLoopLatch,\n                  DTUpdates);\n\n  DT->applyUpdates(DTUpdates);\n  restructureLoops(OuterLoop, InnerLoop, InnerLoopPreHeader,\n                   OuterLoopPreHeader);\n\n  moveLCSSAPhis(InnerLoopLatchSuccessor, InnerLoopHeader, InnerLoopLatch,\n                OuterLoopHeader, OuterLoopLatch, InnerLoop->getExitBlock(),\n                InnerLoop, LI);\n  // For PHIs in the exit block of the outer loop, outer's latch has been\n  // replaced by Inners'.\n  OuterLoopLatchSuccessor->replacePhiUsesWith(OuterLoopLatch, InnerLoopLatch);\n\n  // Now update the reduction PHIs in the inner and outer loop headers.\n  SmallVector<PHINode *, 4> InnerLoopPHIs, OuterLoopPHIs;\n  for (PHINode &PHI : drop_begin(InnerLoopHeader->phis()))\n    InnerLoopPHIs.push_back(cast<PHINode>(&PHI));\n  for (PHINode &PHI : drop_begin(OuterLoopHeader->phis()))\n    OuterLoopPHIs.push_back(cast<PHINode>(&PHI));\n\n  auto &OuterInnerReductions = LIL.getOuterInnerReductions();\n  (void)OuterInnerReductions;\n\n  // Now move the remaining reduction PHIs from outer to inner loop header and\n  // vice versa. The PHI nodes must be part of a reduction across the inner and\n  // outer loop and all the remains to do is and updating the incoming blocks.\n  for (PHINode *PHI : OuterLoopPHIs) {\n    PHI->moveBefore(InnerLoopHeader->getFirstNonPHI());\n    assert(OuterInnerReductions.count(PHI) && \"Expected a reduction PHI node\");\n  }\n  for (PHINode *PHI : InnerLoopPHIs) {\n    PHI->moveBefore(OuterLoopHeader->getFirstNonPHI());\n    assert(OuterInnerReductions.count(PHI) && \"Expected a reduction PHI node\");\n  }\n\n  // Update the incoming blocks for moved PHI nodes.\n  OuterLoopHeader->replacePhiUsesWith(InnerLoopPreHeader, OuterLoopPreHeader);\n  OuterLoopHeader->replacePhiUsesWith(InnerLoopLatch, OuterLoopLatch);\n  InnerLoopHeader->replacePhiUsesWith(OuterLoopPreHeader, InnerLoopPreHeader);\n  InnerLoopHeader->replacePhiUsesWith(OuterLoopLatch, InnerLoopLatch);\n\n  // Values defined in the outer loop header could be used in the inner loop\n  // latch. In that case, we need to create LCSSA phis for them, because after\n  // interchanging they will be defined in the new inner loop and used in the\n  // new outer loop.\n  IRBuilder<> Builder(OuterLoopHeader->getContext());\n  SmallVector<Instruction *, 4> MayNeedLCSSAPhis;\n  for (Instruction &I :\n       make_range(OuterLoopHeader->begin(), std::prev(OuterLoopHeader->end())))\n    MayNeedLCSSAPhis.push_back(&I);\n  formLCSSAForInstructions(MayNeedLCSSAPhis, *DT, *LI, SE, Builder);\n\n  return true;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/LoopInterchange/lcssa-preheader.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopInterchange/lcssa-preheader.ll\n\n\nTesting Time: 1.33s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopInterchange/outer-header-jump-to-inner-latch.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopInterchange/outer-header-jump-to-inner-latch.ll\n\n\nTesting Time: 0.27s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "f5645ea65f0dfdef2ae9c74075cc4b44f05dcb82___LoopInterchange.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic bool passingValueIsAlwaysUndefined(Value *V, Instruction *I, bool PtrValueMayBeModified) {\n  Constant *C = dyn_cast<Constant>(V);\n  if (!C)\n    return false;\n\n  if (I->use_empty())\n    return false;\n\n  if (C->isNullValue() || isa<UndefValue>(C)) {\n    // Only look at the first use, avoid hurting compile time with long uselists\n    User *Use = *I->user_begin();\n\n    // Now make sure that there are no instructions in between that can alter\n    // control flow (eg. calls)\n    for (BasicBlock::iterator\n             i = ++BasicBlock::iterator(I),\n             UI = BasicBlock::iterator(dyn_cast<Instruction>(Use));\n         i != UI; ++i)\n      if (i == I->getParent()->end() || i->mayHaveSideEffects())\n        return false;\n\n    // Look through GEPs. A load from a GEP derived from NULL is still undefined\n    if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(Use))\n      if (GEP->getPointerOperand() == I) {\n        if (!GEP->isInBounds() || !GEP->hasAllZeroIndices())\n          PtrValueMayBeModified = true;\n        return passingValueIsAlwaysUndefined(V, GEP, PtrValueMayBeModified);\n      }\n\n    // Look through bitcasts.\n    if (BitCastInst *BC = dyn_cast<BitCastInst>(Use))\n      return passingValueIsAlwaysUndefined(V, BC, PtrValueMayBeModified);\n\n    // Load from null is undefined.\n    if (LoadInst *LI = dyn_cast<LoadInst>(Use))\n      if (!LI->isVolatile())\n        return !NullPointerIsDefined(LI->getFunction(),\n                                     LI->getPointerAddressSpace());\n\n    // Store to null is undefined.\n    if (StoreInst *SI = dyn_cast<StoreInst>(Use))\n      if (!SI->isVolatile())\n        return (!NullPointerIsDefined(SI->getFunction(),\n                                      SI->getPointerAddressSpace())) &&\n               SI->getPointerOperand() == I;\n\n    if (auto *CB = dyn_cast<CallBase>(Use)) {\n      if (C->isNullValue() && NullPointerIsDefined(CB->getFunction()))\n        return false;\n      // A call to null is undefined.\n      if (CB->getCalledOperand() == I)\n        return true;\n\n      if (C->isNullValue()) {\n        for (const llvm::Use &Arg : CB->args())\n          if (Arg == I) {\n            unsigned ArgIdx = CB->getArgOperandNo(&Arg);\n            if (CB->isPassingUndefUB(ArgIdx) &&\n                CB->paramHasAttr(ArgIdx, Attribute::NonNull)) {\n              // Passing null to a nonnnull+noundef argument is undefined.\n              return !PtrValueMayBeModified;\n            }\n          }\n      } else if (isa<UndefValue>(C)) {\n        // Passing undef to a noundef argument is undefined.\n        for (const llvm::Use &Arg : CB->args())\n          if (Arg == I) {\n            unsigned ArgIdx = CB->getArgOperandNo(&Arg);\n            if (CB->isPassingUndefUB(ArgIdx)) {\n              // Passing undef to a noundef argument is undefined.\n              return true;\n            }\n          }\n      }\n    }\n  }\n  return false;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/SimplifyCFG/UnreachableEliminate.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SimplifyCFG/UnreachableEliminate.ll\n\n\nTesting Time: 0.12s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "ea817d79be2686d1d5fad04d429dbe392ee22b5f___SimplifyCFG.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nbool checkDebugifyMetadata(Module &M,\n                           iterator_range<Module::iterator> Functions,\n                           StringRef NameOfWrappedPass, StringRef Banner,\n                           bool Strip, DebugifyStatsMap *StatsMap) {\n  // Skip modules without debugify metadata.\n  NamedMDNode *NMD = M.getNamedMetadata(\"llvm.debugify\");\n  if (!NMD) {\n    dbg() << Banner << \": Skipping module without debugify metadata\\n\";\n    return false;\n  }\n\n  auto getDebugifyOperand = [&](unsigned Idx) -> unsigned {\n    return mdconst::extract<ConstantInt>(NMD->getOperand(Idx)->getOperand(0))\n        ->getZExtValue();\n  };\n  assert(NMD->getNumOperands() == 2 &&\n         \"llvm.debugify should have exactly 2 operands!\");\n  unsigned OriginalNumLines = getDebugifyOperand(0);\n  unsigned OriginalNumVars = getDebugifyOperand(1);\n  bool HasErrors = false;\n\n  // Track debug info loss statistics if able.\n  DebugifyStatistics *Stats = nullptr;\n  if (StatsMap && !NameOfWrappedPass.empty())\n    Stats = &StatsMap->operator[](NameOfWrappedPass);\n\n  BitVector MissingLines{OriginalNumLines, true};\n  BitVector MissingVars{OriginalNumVars, true};\n  for (Function &F : Functions) {\n    if (isFunctionSkipped(F))\n      continue;\n\n    // Find missing lines.\n    for (Instruction &I : instructions(F)) {\n      if (isa<DbgValueInst>(&I) || isa<PHINode>(&I))\n        continue;\n\n      auto DL = I.getDebugLoc();\n      if (DL && DL.getLine() != 0) {\n        MissingLines.reset(DL.getLine() - 1);\n        continue;\n      }\n\n      if (!DL) {\n        dbg() << \"WARNING: Instruction with empty DebugLoc in function \";\n        dbg() << F.getName() << \" --\";\n        I.print(dbg());\n        dbg() << \"\\n\";\n      }\n    }\n\n    // Find missing variables and mis-sized debug values.\n    for (Instruction &I : instructions(F)) {\n      auto *DVI = dyn_cast<DbgValueInst>(&I);\n      if (!DVI)\n        continue;\n\n      unsigned Var = ~0U;\n      (void)to_integer(DVI->getVariable()->getName(), Var, 10);\n      assert(Var <= OriginalNumVars && \"Unexpected name for DILocalVariable\");\n      bool HasBadSize = diagnoseMisSizedDbgValue(M, DVI);\n      if (!HasBadSize)\n        MissingVars.reset(Var - 1);\n      HasErrors |= HasBadSize;\n    }\n  }\n\n  // Print the results.\n  for (unsigned Idx : MissingLines.set_bits())\n    dbg() << \"WARNING: Missing line \" << Idx + 1 << \"\\n\";\n\n  for (unsigned Idx : MissingVars.set_bits())\n    dbg() << \"WARNING: Missing variable \" << Idx + 1 << \"\\n\";\n\n  // Update DI loss statistics.\n  if (Stats) {\n    Stats->NumDbgLocsExpected += OriginalNumLines;\n    Stats->NumDbgLocsMissing += MissingLines.count();\n    Stats->NumDbgValuesExpected += OriginalNumVars;\n    Stats->NumDbgValuesMissing += MissingVars.count();\n  }\n\n  dbg() << Banner;\n  if (!NameOfWrappedPass.empty())\n    dbg() << \" [\" << NameOfWrappedPass << \"]\";\n  dbg() << \": \" << (HasErrors ? \"FAIL\" : \"PASS\") << '\\n';\n\n  // Strip debugify metadata if required.\n  if (Strip)\n    return stripDebugifyMetadata(M);\n\n  return false;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/debugify-ignore-phi.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: DebugInfo/debugify-ignore-phi.ll\n\n\nTesting Time: 0.34s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "01c90bbd4fd12aa86db4a47577addb47e6e84289___Debugify.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nError BitcodeReader::parseFunctionRecord(ArrayRef<uint64_t> Record) {\n  // v1: [type, callingconv, isproto, linkage, paramattr, alignment, section,\n  // visibility, gc, unnamed_addr, prologuedata, dllstorageclass, comdat,\n  // prefixdata,  personalityfn, preemption specifier, addrspace] (name in VST)\n  // v2: [strtab_offset, strtab_size, v1]\n  StringRef Name;\n  std::tie(Name, Record) = readNameFromStrtab(Record);\n\n  if (Record.size() < 8)\n    return error(\"Invalid record\");\n  Type *FTy = getTypeByID(Record[0]);\n  if (!FTy)\n    return error(\"Invalid record\");\n  if (auto *PTy = dyn_cast<PointerType>(FTy))\n    FTy = PTy->getElementType();\n\n  if (!isa<FunctionType>(FTy))\n    return error(\"Invalid type for value\");\n  auto CC = static_cast<CallingConv::ID>(Record[1]);\n  if (CC & ~CallingConv::MaxID)\n    return error(\"Invalid calling convention ID\");\n\n  unsigned AddrSpace = TheModule->getDataLayout().getProgramAddressSpace();\n  if (Record.size() > 16)\n    AddrSpace = Record[16];\n\n  Function *Func =\n      Function::Create(cast<FunctionType>(FTy), GlobalValue::ExternalLinkage,\n                       AddrSpace, Name, TheModule);\n\n  assert(Func->getFunctionType() == FTy &&\n         \"Incorrect fully specified type provided for function\");\n  FunctionTypes[Func] = cast<FunctionType>(FTy);\n\n  Func->setCallingConv(CC);\n  bool isProto = Record[2];\n  uint64_t RawLinkage = Record[3];\n  Func->setLinkage(getDecodedLinkage(RawLinkage));\n  Func->setAttributes(getAttributes(Record[4]));\n\n  // Upgrade any old-style byval or sret without a type by propagating the\n  // argument's pointee type. There should be no opaque pointers where the byval\n  // type is implicit.\n  for (unsigned i = 0; i != Func->arg_size(); ++i) {\n    for (Attribute::AttrKind Kind : {Attribute::ByVal, Attribute::StructRet,\n                                     Attribute::InAlloca}) {\n      if (!Func->hasParamAttribute(i, Kind))\n        continue;\n\n      Func->removeParamAttr(i, Kind);\n\n      Type *PTy = cast<FunctionType>(FTy)->getParamType(i);\n      Type *PtrEltTy = cast<PointerType>(PTy)->getElementType();\n      Attribute NewAttr;\n      switch (Kind) {\n      case Attribute::ByVal:\n        NewAttr = Attribute::getWithByValType(Context, PtrEltTy);\n        break;\n      case Attribute::StructRet:\n        NewAttr = Attribute::getWithStructRetType(Context, PtrEltTy);\n        break;\n      case Attribute::InAlloca:\n        NewAttr = Attribute::getWithInAllocaType(Context, PtrEltTy);\n        break;\n      default:\n        llvm_unreachable(\"not an upgraded type attribute\");\n      }\n\n      Func->addParamAttr(i, NewAttr);\n    }\n  }\n\n  MaybeAlign Alignment;\n  if (Error Err = parseAlignmentValue(Record[5], Alignment))\n    return Err;\n  Func->setAlignment(Alignment);\n  if (Record[6]) {\n    if (Record[6] - 1 >= SectionTable.size())\n      return error(\"Invalid ID\");\n    Func->setSection(SectionTable[Record[6] - 1]);\n  }\n  // Local linkage must have default visibility.\n  // auto-upgrade `hidden` and `protected` for old bitcode.\n  if (!Func->hasLocalLinkage())\n    Func->setVisibility(getDecodedVisibility(Record[7]));\n  if (Record.size() > 8 && Record[8]) {\n    if (Record[8] - 1 >= GCTable.size())\n      return error(\"Invalid ID\");\n    Func->setGC(GCTable[Record[8] - 1]);\n  }\n  GlobalValue::UnnamedAddr UnnamedAddr = GlobalValue::UnnamedAddr::None;\n  if (Record.size() > 9)\n    UnnamedAddr = getDecodedUnnamedAddrType(Record[9]);\n  Func->setUnnamedAddr(UnnamedAddr);\n  if (Record.size() > 10 && Record[10] != 0)\n    FunctionPrologues.push_back(std::make_pair(Func, Record[10] - 1));\n\n  if (Record.size() > 11)\n    Func->setDLLStorageClass(getDecodedDLLStorageClass(Record[11]));\n  else\n    upgradeDLLImportExportLinkage(Func, RawLinkage);\n\n  if (Record.size() > 12) {\n    if (unsigned ComdatID = Record[12]) {\n      if (ComdatID > ComdatList.size())\n        return error(\"Invalid function comdat ID\");\n      Func->setComdat(ComdatList[ComdatID - 1]);\n    }\n  } else if (hasImplicitComdat(RawLinkage)) {\n    Func->setComdat(reinterpret_cast<Comdat *>(1));\n  }\n\n  if (Record.size() > 13 && Record[13] != 0)\n    FunctionPrefixes.push_back(std::make_pair(Func, Record[13] - 1));\n\n  if (Record.size() > 14 && Record[14] != 0)\n    FunctionPersonalityFns.push_back(std::make_pair(Func, Record[14] - 1));\n\n  if (Record.size() > 15) {\n    Func->setDSOLocal(getDecodedDSOLocal(Record[15]));\n  }\n  inferDSOLocal(Func);\n\n  // Record[16] is the address space number.\n\n  // Check whether we have enough values to read a partition name.\n  if (Record.size() > 18)\n    Func->setPartition(StringRef(Strtab.data() + Record[17], Record[18]));\n\n  ValueList.push_back(Func);\n\n  // If this is a function with a body, remember the prototype we are\n  // creating now, so that we can match up the body with them later.\n  if (!isProto) {\n    Func->setIsMaterializable(true);\n    FunctionsWithBodies.push_back(Func);\n    DeferredFunctionInfo[Func] = 0;\n  }\n  return Error::success();\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Bitcode/invalid-record-strtab.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Bitcode/invalid-record-strtab.ll\n\n\nTesting Time: 1.98s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "34cccdaed7e7952a9191231ffa62b1b22eac35c8___BitcodeReader.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic Value *handleOtherCmpSelSimplifications(Value *TCmp, Value *FCmp,\n                                               Value *Cond,\n                                               const SimplifyQuery &Q,\n                                               unsigned MaxRecurse) {\n  // If the false value simplified to false, then the result of the compare\n  // is equal to \"Cond && TCmp\".  This also catches the case when the false\n  // value simplified to false and the true value to true, returning \"Cond\".\n  if (match(FCmp, m_Zero()))\n    if (Value *V = SimplifyAndInst(Cond, TCmp, Q, MaxRecurse))\n      return V;\n  // If the true value simplified to true, then the result of the compare\n  // is equal to \"Cond || FCmp\".\n  if (match(TCmp, m_One()))\n    if (Value *V = SimplifyOrInst(Cond, FCmp, Q, MaxRecurse))\n      return V;\n  // Finally, if the false value simplified to true and the true value to\n  // false, then the result of the compare is equal to \"!Cond\".\n  if (match(FCmp, m_One()) && match(TCmp, m_Zero()))\n    if (Value *V = SimplifyXorInst(\n            Cond, Constant::getAllOnesValue(Cond->getType()), Q, MaxRecurse))\n      return V;\n  return nullptr;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/icmp.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/icmp.ll\n\n\nTesting Time: 0.66s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "9eb613b2de3163686b1a4bd1160f15ac56a4b083___InstructionSimplify.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nauto MachineFunction::salvageCopySSA(MachineInstr &MI)\n    -> DebugInstrOperandPair {\n  MachineRegisterInfo &MRI = getRegInfo();\n  const TargetRegisterInfo &TRI = *MRI.getTargetRegisterInfo();\n  const TargetInstrInfo &TII = *getSubtarget().getInstrInfo();\n\n  // Chase the value read by a copy-like instruction back to the instruction\n  // that ultimately _defines_ that value. This may pass:\n  //  * Through multiple intermediate copies, including subregister moves /\n  //    copies,\n  //  * Copies from physical registers that must then be traced back to the\n  //    defining instruction,\n  //  * Or, physical registers may be live-in to (only) the entry block, which\n  //    requires a DBG_PHI to be created.\n  // We can pursue this problem in that order: trace back through copies,\n  // optionally through a physical register, to a defining instruction. We\n  // should never move from physreg to vreg. As we're still in SSA form, no need\n  // to worry about partial definitions of registers.\n\n  // Helper lambda to interpret a copy-like instruction. Takes instruction,\n  // returns the register read and any subregister identifying which part is\n  // read.\n  auto GetRegAndSubreg =\n      [&](const MachineInstr &Cpy) -> std::pair<Register, unsigned> {\n    Register NewReg, OldReg;\n    unsigned SubReg;\n    if (Cpy.isCopy()) {\n      OldReg = Cpy.getOperand(0).getReg();\n      NewReg = Cpy.getOperand(1).getReg();\n      SubReg = Cpy.getOperand(1).getSubReg();\n    } else if (Cpy.isSubregToReg()) {\n      OldReg = Cpy.getOperand(0).getReg();\n      NewReg = Cpy.getOperand(2).getReg();\n      SubReg = Cpy.getOperand(3).getImm();\n    } else {\n      auto CopyDetails = *TII.isCopyInstr(Cpy);\n      const MachineOperand &Src = *CopyDetails.Source;\n      const MachineOperand &Dest = *CopyDetails.Destination;\n      OldReg = Dest.getReg();\n      NewReg = Src.getReg();\n      SubReg = Src.getSubReg();\n    }\n\n    return {NewReg, SubReg};\n  };\n\n  // First seek either the defining instruction, or a copy from a physreg.\n  // During search, the current state is the current copy instruction, and which\n  // register we've read. Accumulate qualifying subregisters into SubregsSeen;\n  // deal with those later.\n  auto State = GetRegAndSubreg(MI);\n  auto CurInst = MI.getIterator();\n  SmallVector<unsigned, 4> SubregsSeen;\n  while (true) {\n    // If we've found a copy from a physreg, first portion of search is over.\n    if (!State.first.isVirtual())\n      break;\n\n    // Record any subregister qualifier.\n    if (State.second)\n      SubregsSeen.push_back(State.second);\n\n    assert(MRI.hasOneDef(State.first));\n    MachineInstr &Inst = *MRI.def_begin(State.first)->getParent();\n    CurInst = Inst.getIterator();\n\n    // Any non-copy instruction is the defining instruction we're seeking.\n    if (!Inst.isCopyLike() && !TII.isCopyInstr(Inst))\n      break;\n    State = GetRegAndSubreg(Inst);\n  };\n\n  // Helper lambda to apply additional subregister substitutions to a known\n  // instruction/operand pair. Adds new (fake) substitutions so that we can\n  // record the subregister. FIXME: this isn't very space efficient if multiple\n  // values are tracked back through the same copies; cache something later.\n  auto ApplySubregisters =\n      [&](DebugInstrOperandPair P) -> DebugInstrOperandPair {\n    for (unsigned Subreg : reverse(SubregsSeen)) {\n      // Fetch a new instruction number, not attached to an actual instruction.\n      unsigned NewInstrNumber = getNewDebugInstrNum();\n      // Add a substitution from the \"new\" number to the known one, with a\n      // qualifying subreg.\n      makeDebugValueSubstitution({NewInstrNumber, 0}, P, Subreg);\n      // Return the new number; to find the underlying value, consumers need to\n      // deal with the qualifying subreg.\n      P = {NewInstrNumber, 0};\n    }\n    return P;\n  };\n\n  // If we managed to find the defining instruction after COPYs, return an\n  // instruction / operand pair after adding subregister qualifiers.\n  if (State.first.isVirtual()) {\n    // Virtual register def -- we can just look up where this happens.\n    MachineInstr *Inst = MRI.def_begin(State.first)->getParent();\n    for (auto &MO : Inst->operands()) {\n      if (!MO.isReg() || !MO.isDef() || MO.getReg() != State.first)\n        continue;\n      return ApplySubregisters(\n          {Inst->getDebugInstrNum(), Inst->getOperandNo(&MO)});\n    }\n\n    llvm_unreachable(\"Vreg def with no corresponding operand?\");\n  }\n\n  // Our search ended in a copy from a physreg: walk back up the function\n  // looking for whatever defines the physreg.\n  assert(CurInst->isCopyLike() || TII.isCopyInstr(*CurInst));\n  State = GetRegAndSubreg(*CurInst);\n  Register RegToSeek = State.first;\n\n  auto RMII = CurInst->getReverseIterator();\n  auto PrevInstrs = make_range(RMII, CurInst->getParent()->instr_rend());\n  for (auto &ToExamine : PrevInstrs) {\n    for (auto &MO : ToExamine.operands()) {\n      // Test for operand that defines something aliasing RegToSeek.\n      if (!MO.isReg() || !MO.isDef() ||\n          !TRI.regsOverlap(RegToSeek, MO.getReg()))\n        continue;\n\n      return ApplySubregisters(\n          {ToExamine.getDebugInstrNum(), ToExamine.getOperandNo(&MO)});\n    }\n  }\n\n  MachineBasicBlock &InsertBB = *CurInst->getParent();\n\n  // We reached the start of the block before finding a defining instruction.\n  // It could be from a constant register, otherwise it must be an argument.\n  if (TRI.isConstantPhysReg(State.first)) {\n    // We can produce a DBG_PHI that identifies the constant physreg. Doesn't\n    // matter where we put it, as it's constant valued.\n    assert(CurInst->isCopy());\n  } else if (State.first == TRI.getFrameRegister(*this)) {\n    // LLVM IR is allowed to read the framepointer by calling a\n    // llvm.frameaddress.* intrinsic. We can support this by emitting a\n    // DBG_PHI $fp. This isn't ideal, because it extends the behaviours /\n    // position that DBG_PHIs appear at, limiting what can be done later.\n    // TODO: see if there's a better way of expressing these variable\n    // locations.\n    ;\n  } else {\n    // Assert that this is the entry block. If it isn't, then there is some\n    // code construct we don't recognise that deals with physregs across\n    // blocks.\n    assert(!State.first.isVirtual());\n    assert(&*InsertBB.getParent()->begin() == &InsertBB);\n  }\n\n  // Create DBG_PHI for specified physreg.\n  auto Builder = BuildMI(InsertBB, InsertBB.getFirstNonPHI(), DebugLoc(),\n                         TII.get(TargetOpcode::DBG_PHI));\n  Builder.addReg(State.first, RegState::Debug);\n  unsigned NewNum = getNewDebugInstrNum();\n  Builder.addImm(NewNum);\n  return ApplySubregisters({NewNum, 0u});\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/X86/instr-ref-eh-landing-pad.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: DebugInfo/X86/instr-ref-eh-landing-pad.ll\n\n\nTesting Time: 7.27s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "e2b838dd913200702f2eee29100a788c0573bc50___MachineFunction.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nvoid coro::salvageDebugInfo(\n    SmallDenseMap<llvm::Value *, llvm::AllocaInst *, 4> &DbgPtrAllocaCache,\n    DbgVariableIntrinsic *DVI, bool OptimizeFrame) {\n  Function *F = DVI->getFunction();\n  IRBuilder<> Builder(F->getContext());\n  auto InsertPt = F->getEntryBlock().getFirstInsertionPt();\n  while (isa<IntrinsicInst>(InsertPt))\n    ++InsertPt;\n  Builder.SetInsertPoint(&F->getEntryBlock(), InsertPt);\n  DIExpression *Expr = DVI->getExpression();\n  // Follow the pointer arithmetic all the way to the incoming\n  // function argument and convert into a DIExpression.\n  bool SkipOutermostLoad = !isa<DbgValueInst>(DVI);\n  Value *Storage = DVI->getVariableLocationOp(0);\n  Value *OriginalStorage = Storage;\n  while (auto *Inst = dyn_cast_or_null<Instruction>(Storage)) {\n    if (auto *LdInst = dyn_cast<LoadInst>(Inst)) {\n      Storage = LdInst->getOperand(0);\n      // FIXME: This is a heuristic that works around the fact that\n      // LLVM IR debug intrinsics cannot yet distinguish between\n      // memory and value locations: Because a dbg.declare(alloca) is\n      // implicitly a memory location no DW_OP_deref operation for the\n      // last direct load from an alloca is necessary.  This condition\n      // effectively drops the *last* DW_OP_deref in the expression.\n      if (!SkipOutermostLoad)\n        Expr = DIExpression::prepend(Expr, DIExpression::DerefBefore);\n    } else if (auto *StInst = dyn_cast<StoreInst>(Inst)) {\n      Storage = StInst->getOperand(0);\n    } else {\n      SmallVector<uint64_t, 16> Ops;\n      SmallVector<Value *, 0> AdditionalValues;\n      Value *Op = llvm::salvageDebugInfoImpl(\n          *Inst, Expr ? Expr->getNumLocationOperands() : 0, Ops,\n          AdditionalValues);\n      if (!Op || !AdditionalValues.empty()) {\n        // If salvaging failed or salvaging produced more than one location\n        // operand, give up.\n        break;\n      }\n      Storage = Op;\n      Expr = DIExpression::appendOpsToArg(Expr, Ops, 0, /*StackValue*/ false);\n    }\n    SkipOutermostLoad = false;\n  }\n  if (!Storage)\n    return;\n\n  // Store a pointer to the coroutine frame object in an alloca so it\n  // is available throughout the function when producing unoptimized\n  // code. Extending the lifetime this way is correct because the\n  // variable has been declared by a dbg.declare intrinsic.\n  //\n  // Avoid to create the alloca would be eliminated by optimization\n  // passes and the corresponding dbg.declares would be invalid.\n  if (!OptimizeFrame)\n    if (auto *Arg = dyn_cast<llvm::Argument>(Storage)) {\n      auto &Cached = DbgPtrAllocaCache[Storage];\n      if (!Cached) {\n        Cached = Builder.CreateAlloca(Storage->getType(), 0, nullptr,\n                                      Arg->getName() + \".debug\");\n        Builder.CreateStore(Storage, Cached);\n      }\n      Storage = Cached;\n      // FIXME: LLVM lacks nuanced semantics to differentiate between\n      // memory and direct locations at the IR level. The backend will\n      // turn a dbg.declare(alloca, ..., DIExpression()) into a memory\n      // location. Thus, if there are deref and offset operations in the\n      // expression, we need to add a DW_OP_deref at the *start* of the\n      // expression to first load the contents of the alloca before\n      // adjusting it with the expression.\n      if (Expr && Expr->isComplex())\n        Expr = DIExpression::prepend(Expr, DIExpression::DerefBefore);\n    }\n\n  DVI->replaceVariableLocationOp(OriginalStorage, Storage);\n  DVI->setExpression(Expr);\n  // We only hoist dbg.declare today since it doesn't make sense to hoist\n  // dbg.value or dbg.addr since they do not have the same function wide\n  // guarantees that dbg.declare does.\n  if (!isa<DbgValueInst>(DVI) && !isa<DbgAddrIntrinsic>(DVI)) {\n    if (auto *II = dyn_cast<InvokeInst>(Storage))\n      DVI->moveBefore(II->getNormalDest()->getFirstNonPHI());\n    else if (auto *CBI = dyn_cast<CallBrInst>(Storage))\n      DVI->moveBefore(CBI->getDefaultDest()->getFirstNonPHI());\n    else if (auto *InsertPt = dyn_cast<Instruction>(Storage)) {\n      assert(!InsertPt->isTerminator() &&\n             \"Unimaged terminator that could return a storage.\");\n      DVI->moveAfter(InsertPt);\n    } else if (isa<Argument>(Storage))\n      DVI->moveAfter(F->getEntryBlock().getFirstNonPHI());\n  }\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/Coroutines/coro-debug-coro-frame.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/Coroutines/coro-debug-coro-frame.ll\n\n\nTesting Time: 0.50s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "733d7cf9649968c05f41480747ed91c7b0c3a82f___CoroFrame.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nbool Loop::isSafeToClone() const {\n  // Return false if any loop blocks contain indirectbrs, or there are any calls\n  // to noduplicate functions.\n  // FIXME: it should be ok to clone CallBrInst's if we correctly update the\n  // operand list to reflect the newly cloned labels.\n  for (BasicBlock *BB : this->blocks()) {\n    if (isa<IndirectBrInst>(BB->getTerminator()) ||\n        isa<CallBrInst>(BB->getTerminator()))\n      return false;\n\n    for (Instruction &I : *BB)\n      if (auto *CB = dyn_cast<CallBase>(&I))\n        if (CB->cannotDuplicate())\n          return false;\n  }\n  return true;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/LoopUnroll/callbr.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopUnroll/callbr.ll\n\n\nTesting Time: 1.40s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/SimpleLoopUnswitch/callbr.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SimpleLoopUnswitch/callbr.ll\n\n\nTesting Time: 0.25s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "534b9246a20498e2cd4d2b9a512e7c5e75c83bc7___LoopInfo.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic bool\nhasOnlyColdCalls(Function &F,\n                 function_ref<BlockFrequencyInfo &(Function &)> GetBFI) {\n  for (BasicBlock &BB : F) {\n    for (Instruction &I : BB) {\n      if (CallInst *CI = dyn_cast<CallInst>(&I)) {\n        // Skip over isline asm instructions since they aren't function calls.\n        if (CI->isInlineAsm())\n          continue;\n        Function *CalledFn = CI->getCalledFunction();\n        if (!CalledFn)\n          return false;\n        if (!CalledFn->hasLocalLinkage())\n          return false;\n        // Skip over intrinsics since they won't remain as function calls.\n        if (CalledFn->getIntrinsicID() != Intrinsic::not_intrinsic)\n          continue;\n        // Check if it's valid to use coldcc calling convention.\n        if (!hasChangeableCC(CalledFn) || CalledFn->isVarArg() ||\n            CalledFn->hasAddressTaken())\n          return false;\n        BlockFrequencyInfo &CallerBFI = GetBFI(F);\n        if (!isColdCallSite(*CI, CallerBFI))\n          return false;\n      }\n    }\n  }\n  return true;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/GlobalOpt/dbg-intrinsic-loopanalysis.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/GlobalOpt/dbg-intrinsic-loopanalysis.ll\n\n\nTesting Time: 0.22s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "51d4c7ceea61b5d83ba52398b5ca6d58d7551044___GlobalOpt.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nInstruction *InstCombinerImpl::transformZExtICmp(ICmpInst *Cmp, ZExtInst &Zext) {\n  // If we are just checking for a icmp eq of a single bit and zext'ing it\n  // to an integer, then shift the bit to the appropriate place and then\n  // cast to integer to avoid the comparison.\n\n  // FIXME: This set of transforms does not check for extra uses and/or creates\n  //        an extra instruction (an optional final cast is not included\n  //        in the transform comments). We may also want to favor icmp over\n  //        shifts in cases of equal instructions because icmp has better\n  //        analysis in general (invert the transform).\n\n  const APInt *Op1CV;\n  if (match(Cmp->getOperand(1), m_APInt(Op1CV))) {\n\n    // zext (x <s  0) to i32 --> x>>u31      true if signbit set.\n    if (Cmp->getPredicate() == ICmpInst::ICMP_SLT && Op1CV->isZero()) {\n      Value *In = Cmp->getOperand(0);\n      Value *Sh = ConstantInt::get(In->getType(),\n                                   In->getType()->getScalarSizeInBits() - 1);\n      In = Builder.CreateLShr(In, Sh, In->getName() + \".lobit\");\n      if (In->getType() != Zext.getType())\n        In = Builder.CreateIntCast(In, Zext.getType(), false /*ZExt*/);\n\n      return replaceInstUsesWith(Zext, In);\n    }\n\n    // zext (X == 0) to i32 --> X^1      iff X has only the low bit set.\n    // zext (X == 0) to i32 --> (X>>1)^1 iff X has only the 2nd bit set.\n    // zext (X == 1) to i32 --> X        iff X has only the low bit set.\n    // zext (X == 2) to i32 --> X>>1     iff X has only the 2nd bit set.\n    // zext (X != 0) to i32 --> X        iff X has only the low bit set.\n    // zext (X != 0) to i32 --> X>>1     iff X has only the 2nd bit set.\n    // zext (X != 1) to i32 --> X^1      iff X has only the low bit set.\n    // zext (X != 2) to i32 --> (X>>1)^1 iff X has only the 2nd bit set.\n    if ((Op1CV->isZero() || Op1CV->isPowerOf2()) &&\n        // This only works for EQ and NE\n        Cmp->isEquality()) {\n      // If Op1C some other power of two, convert:\n      KnownBits Known = computeKnownBits(Cmp->getOperand(0), 0, &Zext);\n\n      APInt KnownZeroMask(~Known.Zero);\n      if (KnownZeroMask.isPowerOf2()) { // Exactly 1 possible 1?\n        bool isNE = Cmp->getPredicate() == ICmpInst::ICMP_NE;\n        uint32_t ShAmt = KnownZeroMask.logBase2();\n        Value *In = Cmp->getOperand(0);\n        if (ShAmt) {\n          // Perform a logical shr by shiftamt.\n          // Insert the shift to put the result in the low bit.\n          In = Builder.CreateLShr(In, ConstantInt::get(In->getType(), ShAmt),\n                                  In->getName() + \".lobit\");\n        }\n\n        if (!Op1CV->isZero() == isNE) { // Toggle the low bit.\n          Constant *One = ConstantInt::get(In->getType(), 1);\n          In = Builder.CreateXor(In, One);\n        }\n\n        if (Zext.getType() == In->getType())\n          return replaceInstUsesWith(Zext, In);\n\n        Value *IntCast = Builder.CreateIntCast(In, Zext.getType(), false);\n        return replaceInstUsesWith(Zext, IntCast);\n      }\n    }\n  }\n\n  if (Cmp->isEquality() && Zext.getType() == Cmp->getOperand(0)->getType()) {\n    // Test if a bit is clear/set using a shifted-one mask:\n    // zext (icmp eq (and X, (1 << ShAmt)), 0) --> and (lshr (not X), ShAmt), 1\n    // zext (icmp ne (and X, (1 << ShAmt)), 0) --> and (lshr X, ShAmt), 1\n    Value *X, *ShAmt;\n    if (Cmp->hasOneUse() && match(Cmp->getOperand(1), m_ZeroInt()) &&\n        match(Cmp->getOperand(0),\n              m_OneUse(m_c_And(m_Shl(m_One(), m_Value(ShAmt)), m_Value(X))))) {\n      if (Cmp->getPredicate() == ICmpInst::ICMP_EQ)\n        X = Builder.CreateNot(X);\n      Value *Lshr = Builder.CreateLShr(X, ShAmt);\n      Value *And1 = Builder.CreateAnd(Lshr, ConstantInt::get(X->getType(), 1));\n      return replaceInstUsesWith(Zext, And1);\n    }\n\n    // icmp ne A, B is equal to xor A, B when A and B only really have one bit.\n    // It is also profitable to transform icmp eq into not(xor(A, B)) because\n    // that may lead to additional simplifications.\n    if (IntegerType *ITy = dyn_cast<IntegerType>(Zext.getType())) {\n      Value *LHS = Cmp->getOperand(0);\n      Value *RHS = Cmp->getOperand(1);\n\n      KnownBits KnownLHS = computeKnownBits(LHS, 0, &Zext);\n      KnownBits KnownRHS = computeKnownBits(RHS, 0, &Zext);\n\n      if (KnownLHS == KnownRHS) {\n        APInt KnownBits = KnownLHS.Zero | KnownLHS.One;\n        APInt UnknownBit = ~KnownBits;\n        if (UnknownBit.countPopulation() == 1) {\n          Value *Result = Builder.CreateXor(LHS, RHS);\n\n          // Mask off any bits that are set and won't be shifted away.\n          if (KnownLHS.One.uge(UnknownBit))\n            Result = Builder.CreateAnd(Result,\n                                        ConstantInt::get(ITy, UnknownBit));\n\n          // Shift the bit we're testing down to the lsb.\n          Result = Builder.CreateLShr(\n               Result, ConstantInt::get(ITy, UnknownBit.countTrailingZeros()));\n\n          if (Cmp->getPredicate() == ICmpInst::ICMP_EQ)\n            Result = Builder.CreateXor(Result, ConstantInt::get(ITy, 1));\n          Result->takeName(Cmp);\n          return replaceInstUsesWith(Zext, Result);\n        }\n      }\n    }\n  }\n\n  return nullptr;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/zext.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/zext.ll\n\n\nTesting Time: 0.31s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "8df376db7282b955e7990cb8887ee9dcd3565040___InstCombineCasts.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nSDValue DAGCombiner::visitFREEZE(SDNode *N) {\n  SDValue N0 = N->getOperand(0);\n\n  if (DAG.isGuaranteedNotToBeUndefOrPoison(N0, /*PoisonOnly*/ false))\n    return N0;\n\n  // Fold freeze(op(x, ...)) -> op(freeze(x), ...).\n  // Try to push freeze through instructions that propagate but don't produce\n  // poison as far as possible. If an operand of freeze follows three\n  // conditions 1) one-use, 2) does not produce poison, and 3) has all but one\n  // guaranteed-non-poison operands (or is a BUILD_VECTOR or similar) then push\n  // the freeze through to the operands that are not guaranteed non-poison.\n  if (DAG.canCreateUndefOrPoison(N0, /*PoisonOnly*/ false,\n                                 /*ConsiderFlags*/ false) ||\n      N0->getNumValues() != 1 || !N0->hasOneUse())\n    return SDValue();\n\n  bool AllowMultipleMaybePoisonOperands = N0.getOpcode() == ISD::BUILD_VECTOR;\n\n  SmallSetVector<SDValue, 8> MaybePoisonOperands;\n  for (SDValue Op : N0->ops()) {\n    if (DAG.isGuaranteedNotToBeUndefOrPoison(Op, /*PoisonOnly*/ false,\n                                             /*Depth*/ 1))\n      continue;\n    bool HadMaybePoisonOperands = !MaybePoisonOperands.empty();\n    bool IsNewMaybePoisonOperand = MaybePoisonOperands.insert(Op);\n    if (!HadMaybePoisonOperands)\n      continue;\n    if (IsNewMaybePoisonOperand && !AllowMultipleMaybePoisonOperands) {\n      // Multiple maybe-poison ops when not allowed - bail out.\n      return SDValue();\n    }\n  }\n  if (MaybePoisonOperands.empty())\n    return SDValue();\n\n  for (SDValue MaybePoisonOperand : MaybePoisonOperands) {\n    // Don't replace every single UNDEF everywhere with frozen UNDEF, though.\n    if (MaybePoisonOperand.getOpcode() == ISD::UNDEF)\n      continue;\n    // First, freeze each offending operand.\n    SDValue FrozenMaybePoisonOperand = DAG.getFreeze(MaybePoisonOperand);\n    // Then, change all other uses of unfrozen operand to use frozen operand.\n    DAG.ReplaceAllUsesOfValueWith(MaybePoisonOperand, FrozenMaybePoisonOperand);\n    // But, that also updated the use in the freeze we just created, thus\n    // creating a cycle in a DAG. Let's undo that by mutating the freeze.\n    DAG.UpdateNodeOperands(FrozenMaybePoisonOperand.getNode(),\n                           MaybePoisonOperand);\n  }\n\n  // Finally, recreate the node, it's operands were updated to use\n  // frozen operands, so we just need to use it's \"original\" operands.\n  SmallVector<SDValue> Ops(N0->op_begin(), N0->op_end());\n  // Special-handle ISD::UNDEF, each single one of them can be it's own thing.\n  for (SDValue &Op : Ops) {\n    if (Op.getOpcode() == ISD::UNDEF)\n      Op = DAG.getFreeze(Op);\n  }\n  // TODO: Just strip poison generating flags?\n  SDValue R = DAG.getNode(N0.getOpcode(), SDLoc(N0), N0->getVTList(), Ops);\n  assert(DAG.isGuaranteedNotToBeUndefOrPoison(R, /*PoisonOnly*/ false) &&\n         \"Can't create node that may be undef/poison!\");\n  return R;\n}\n```\n \n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/freeze-binary.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/freeze-binary.ll\n\n\nTesting Time: 0.50s\n  Failed: 1\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "d8f541efe7b40fe49664054ad0e7306641762131___DAGCombiner.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nconst Function* Scope::findFunction(const Token *tok, bool requireConst) const\n{\n    // make sure this is a function call\n    const Token *end = tok->linkAt(1);\n    if (!end)\n        return nullptr;\n\n    std::vector<const Token *> arguments;\n\n    // find all the arguments for this function call\n    const Token *arg = tok->tokAt(2);\n    while (arg && arg != end) {\n        arguments.push_back(arg);\n        arg = arg->nextArgument();\n    }\n\n    std::vector<const Function *> matches;\n\n    // find all the possible functions that could match\n    const std::size_t args = arguments.size();\n    for (std::multimap<std::string, const Function *>::const_iterator it = functionMap.find(tok->str()); it != functionMap.end() && it->first == tok->str(); ++it) {\n        const Function *func = it->second;\n        if (args == func->argCount() ||\n            (func->isVariadic() && args >= (func->argCount() - 1)) ||\n            (args < func->argCount() && args >= func->minArgCount())) {\n            matches.push_back(func);\n        }\n    }\n\n    // check in base classes\n    findFunctionInBase(tok->str(), args, matches);\n\n    // check each function against the arguments in the function call for a match\n    for (std::size_t i = 0; i < matches.size();) {\n        bool erased = false;\n        const Function * func = matches[i];\n        size_t same = 0;\n        for (std::size_t j = 0; j < args; ++j) {\n            // don't check variadic arguments\n            if (func->isVariadic() && j > (func->argCount() - 1)) {\n                break;\n            }\n            const Variable *funcarg = func->getArgumentVar(j);\n            // check for a match with a variable\n            if (Token::Match(arguments[j], \"%var% ,|)\")) {\n                const Variable * callarg = check->getVariableFromVarId(arguments[j]->varId());\n                if (callarg &&\n                    callarg->typeStartToken()->str() == funcarg->typeStartToken()->str() &&\n                    callarg->typeStartToken()->isUnsigned() == funcarg->typeStartToken()->isUnsigned() &&\n                    callarg->typeStartToken()->isLong() == funcarg->typeStartToken()->isLong()) {\n                    same++;\n                }\n            }\n\n            // check for a match with address of a variable\n            else if (Token::Match(arguments[j], \"& %var% ,|)\")) {\n                const Variable * callarg = check->getVariableFromVarId(arguments[j]->next()->varId());\n                if (callarg) {\n                    if (funcarg->typeEndToken()->str() == \"*\" &&\n                        (funcarg->typeStartToken()->str() == \"void\" ||\n                         (callarg->typeStartToken()->str() == funcarg->typeStartToken()->str() &&\n                          callarg->typeStartToken()->isUnsigned() == funcarg->typeStartToken()->isUnsigned() &&\n                          callarg->typeStartToken()->isLong() == funcarg->typeStartToken()->isLong()))) {\n                        same++;\n                    } else {\n                        // can't match so remove this function from possible matches\n                        matches.erase(matches.begin() + i);\n                        erased = true;\n                        break;\n                    }\n                }\n            }\n\n            // check for a match with a numeric literal\n            else if (Token::Match(arguments[j], \"%num% ,|)\")) {\n                if (MathLib::isInt(arguments[j]->str())) {\n                    if (arguments[j]->str().find(\"ll\") != std::string::npos ||\n                        arguments[j]->str().find(\"LL\") != std::string::npos) {\n                        if (arguments[j]->str().find('u') != std::string::npos ||\n                            arguments[j]->str().find('U') != std::string::npos) {\n                            if (funcarg->typeStartToken()->str() == \"long\" &&\n                                funcarg->typeStartToken()->isLong() &&\n                                funcarg->typeStartToken()->isUnsigned()) {\n                                same++;\n                            }\n                        } else {\n                            if (funcarg->typeStartToken()->str() == \"long\" &&\n                                funcarg->typeStartToken()->isLong() &&\n                                !funcarg->typeStartToken()->isUnsigned()) {\n                                same++;\n                            }\n                        }\n                    } else if (arguments[j]->str().find('l') != std::string::npos ||\n                               arguments[j]->str().find('L') != std::string::npos) {\n                        if (arguments[j]->str().find('u') != std::string::npos ||\n                            arguments[j]->str().find('U') != std::string::npos) {\n                            if (funcarg->typeStartToken()->str() == \"long\" &&\n                                !funcarg->typeStartToken()->isLong() &&\n                                funcarg->typeStartToken()->isUnsigned()) {\n                                same++;\n                            }\n                        } else {\n                            if (funcarg->typeStartToken()->str() == \"long\" &&\n                                !funcarg->typeStartToken()->isLong() &&\n                                !funcarg->typeStartToken()->isUnsigned()) {\n                                same++;\n                            }\n                        }\n                    } else if (arguments[j]->str().find('u') != std::string::npos ||\n                               arguments[j]->str().find('U') != std::string::npos) {\n                        if (funcarg->typeStartToken()->str() == \"int\" &&\n                            funcarg->typeStartToken()->isUnsigned()) {\n                            same++;\n                        } else if (Token::Match(funcarg->typeStartToken(), \"char|short\")) {\n                            same++;\n                        }\n                    } else {\n                        if (Token::Match(funcarg->typeStartToken(), \"char|short|int|long\")) {\n                            same++;\n                        }\n                    }\n                } else {\n                    if (arguments[j]->str().find('f') != std::string::npos ||\n                        arguments[j]->str().find('F') != std::string::npos) {\n                        if (funcarg->typeStartToken()->str() == \"float\") {\n                            same++;\n                        }\n                    } else if (arguments[j]->str().find('l') != std::string::npos ||\n                               arguments[j]->str().find('L') != std::string::npos) {\n                        if (funcarg->typeStartToken()->str() == \"double\" &&\n                            funcarg->typeStartToken()->isLong())  {\n                            same++;\n                        }\n                    } else {\n                        if (funcarg->typeStartToken()->str() == \"double\" &&\n                            !funcarg->typeStartToken()->isLong()) {\n                            same++;\n                        }\n                    }\n                }\n            }\n\n            // check for a match with a string literal\n            else if (Token::Match(arguments[j], \"%str% ,|)\") &&\n                     funcarg->typeStartToken() != funcarg->typeEndToken() &&\n                     ((!arguments[j]->isLong() && Token::simpleMatch(funcarg->typeStartToken(), \"char *\")) ||\n                      (arguments[j]->isLong() && Token::simpleMatch(funcarg->typeStartToken(), \"wchar_t *\")))) {\n                same++;\n            }\n\n            // check that function argument type is not mismatching\n            else if (arguments[j]->str() == \"&\" && funcarg && funcarg->isReference()) {\n                // can't match so remove this function from possible matches\n                matches.erase(matches.begin() + i);\n                erased = true;\n                break;\n            }\n        }\n\n        // check if all arguments matched\n        if ((func->isVariadic() && same == (func->argCount() - 1)) ||\n            (!func->isVariadic() && same == args)) {\n            if (requireConst && func->isConst())\n                return func;\n\n            // get the function this call is in\n            const Scope * scope = tok->scope();\n\n            // check if this function is a member function\n            if (scope && scope->functionOf && scope->functionOf->isClassOrStruct()) {\n                // check if isConst match\n                if (scope->function && scope->function->isConst() == func->isConst())\n                    return func;\n            } else\n                return func;\n        }\n\n        if (!erased)\n            ++i;\n    }\n\n    // no exact match so just return first function found\n    if (!matches.empty()) {\n        return matches[0];\n    }\n\n    return nullptr;\n}\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_3f1e2b42700a1eb1466d4200eb87265defd962f6/build_3f1e2b42700a1eb1466d4200eb87265defd962f6\nTest project /out/danmar___cppcheck/git_repo_dir_3f1e2b42700a1eb1466d4200eb87265defd962f6/build_3f1e2b42700a1eb1466d4200eb87265defd962f6\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   11.77 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  11.78 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "3f1e2b42700a1eb1466d4200eb87265defd962f6___symboldatabase.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic void valueFlowLifetimeConstructor(Token* tok, TokenList* tokenlist, ErrorLogger* errorLogger, const Settings* settings)\n{\n    if (!Token::Match(tok, \"(|{\"))\n        return;\n    Token* parent = tok->astParent();\n    while (Token::simpleMatch(parent, \",\"))\n        parent = parent->astParent();\n    if (Token::simpleMatch(parent, \"{\") && hasInitList(parent->astParent())) {\n        valueFlowLifetimeConstructor(tok, Token::typeOf(parent->previous()), tokenlist, errorLogger, settings);\n    } else if (Token::simpleMatch(tok, \"{\") && hasInitList(parent)) {\n        std::vector<const Token *> args = getArguments(tok);\n        // Assume range constructor if passed a pair of iterators\n        if (astIsContainer(parent) && args.size() == 2 && astIsIterator(args[0]) && astIsIterator(args[1])) {\n            LifetimeStore::forEach(\n            args, \"Passed to initializer list.\", ValueFlow::Value::LifetimeKind::Object, [&](const LifetimeStore& ls) {\n                ls.byDerefCopy(tok, tokenlist, errorLogger, settings);\n            });\n        } else {\n            LifetimeStore::forEach(args,\n                                   \"Passed to initializer list.\",\n                                   ValueFlow::Value::LifetimeKind::Object,\n            [&](const LifetimeStore& ls) {\n                ls.byVal(tok, tokenlist, errorLogger, settings);\n            });\n        }\n    } else {\n        valueFlowLifetimeConstructor(tok, Token::typeOf(tok->previous()), tokenlist, errorLogger, settings);\n    }\n}\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_6a81b4c17c87241c6f205e9d47ebc9b5af7f0f38/build_6a81b4c17c87241c6f205e9d47ebc9b5af7f0f38\nTest project /out/danmar___cppcheck/git_repo_dir_6a81b4c17c87241c6f205e9d47ebc9b5af7f0f38/build_6a81b4c17c87241c6f205e9d47ebc9b5af7f0f38\n    Start 44: TestStl\n1/1 Test #44: TestStl ..........................***Failed    1.71 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.72 sec\n\nThe following tests FAILED:\n\t 44 - TestStl (Failed)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "6a81b4c17c87241c6f205e9d47ebc9b5af7f0f38___valueflow.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nstatic std::vector<ValueFlow::Value> infer(const ValuePtr<InferModel>& model,\n                                           const std::string& op,\n                                           std::list<ValueFlow::Value> lhsValues,\n                                           std::list<ValueFlow::Value> rhsValues)\n{\n    std::vector<ValueFlow::Value> result;\n    auto notMatch = [&](const ValueFlow::Value& value) {\n        return !model->match(value);\n    };\n    lhsValues.remove_if(notMatch);\n    rhsValues.remove_if(notMatch);\n    if (lhsValues.empty() || rhsValues.empty())\n        return result;\n\n    Interval lhs = Interval::fromValues(lhsValues);\n    Interval rhs = Interval::fromValues(rhsValues);\n\n    if (op == \"-\") {\n        Interval diff = lhs - rhs;\n        if (diff.isScalar()) {\n            std::vector<const ValueFlow::Value*> refs = diff.getScalarRef();\n            ValueFlow::Value value(diff.getScalar());\n            addToErrorPath(value, refs);\n            setValueKind(value, refs);\n            result.push_back(value);\n        } else {\n            if (!diff.minvalue.empty()) {\n                ValueFlow::Value value(diff.minvalue.front() - 1);\n                value.setImpossible();\n                value.bound = ValueFlow::Value::Bound::Lower;\n                addToErrorPath(value, diff.minRef);\n                result.push_back(value);\n            }\n            if (!diff.maxvalue.empty()) {\n                ValueFlow::Value value(diff.maxvalue.front() + 1);\n                value.setImpossible();\n                value.bound = ValueFlow::Value::Bound::Upper;\n                addToErrorPath(value, diff.maxRef);\n                result.push_back(value);\n            }\n        }\n    } else if ((op == \"!=\" || op == \"==\") && lhs.isScalarOrEmpty() && rhs.isScalarOrEmpty()) {\n        if (lhs.isScalar() && rhs.isScalar()) {\n            std::vector<const ValueFlow::Value*> refs = Interval::merge(lhs.getScalarRef(), rhs.getScalarRef());\n            ValueFlow::Value value(calculate(op, lhs.getScalar(), rhs.getScalar()));\n            addToErrorPath(value, refs);\n            setValueKind(value, refs);\n            result.push_back(value);\n        } else {\n            std::vector<const ValueFlow::Value*> refs;\n            if (lhs.isScalar() && inferNotEqual(rhsValues, lhs.getScalar()))\n                refs = lhs.getScalarRef();\n            else if (rhs.isScalar() && inferNotEqual(lhsValues, rhs.getScalar()))\n                refs = rhs.getScalarRef();\n            if (!refs.empty()) {\n                ValueFlow::Value value(op == \"!=\");\n                addToErrorPath(value, refs);\n                setValueKind(value, refs);\n                result.push_back(value);\n            }\n        }\n    } else {\n        std::vector<const ValueFlow::Value*> refs;\n        std::vector<int> r = Interval::compare(lhs, rhs, &refs);\n        if (!r.empty()) {\n            int x = r.front();\n            ValueFlow::Value value(calculate(op, x, 0));\n            addToErrorPath(value, refs);\n            setValueKind(value, refs);\n            result.push_back(value);\n        }\n    }\n\n    return result;\n}\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_a0c37ceba27179496fa2f44072f85e2a5448216e/build_a0c37ceba27179496fa2f44072f85e2a5448216e\nTest project /out/danmar___cppcheck/git_repo_dir_a0c37ceba27179496fa2f44072f85e2a5448216e/build_a0c37ceba27179496fa2f44072f85e2a5448216e\n    Start 14: TestCondition\n1/1 Test #14: TestCondition ....................***Failed    2.25 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   2.25 sec\n\nThe following tests FAILED:\n\t 14 - TestCondition (Failed)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "a0c37ceba27179496fa2f44072f85e2a5448216e___valueflow.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nvoid CheckMemoryLeakNoVar::checkForUnreleasedInputArgument(const Scope *scope)\n{\n    // parse the executable scope until tok is reached...\n    for (const Token *tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {\n        // allocating memory in parameter for function call..\n        if (!Token::Match(tok, \"%name% (\"))\n            continue;\n\n        // check if the output of the function is assigned\n        const Token* tok2 = tok->next()->astParent();\n        while (tok2 && tok2->isCast())\n            tok2 = tok2->astParent();\n        if (tok2 && tok2->isAssignmentOp())\n            continue;\n\n        const std::string& functionName = tok->str();\n        if ((mTokenizer->isCPP() && functionName == \"delete\") ||\n            functionName == \"free\" ||\n            functionName == \"fclose\" ||\n            functionName == \"realloc\")\n            break;\n\n        if (!CheckMemoryLeakInFunction::test_white_list(functionName, mSettings, mTokenizer->isCPP()))\n            continue;\n\n        const std::vector<const Token *> args = getArguments(tok);\n        for (const Token* arg : args) {\n            if (arg->isOp())\n                continue;\n            while (arg->astOperand1())\n                arg = arg->astOperand1();\n            if (getAllocationType(arg, 0) == No)\n                continue;\n            if (isReopenStandardStream(arg))\n                continue;\n            functionCallLeak(arg, arg->str(), functionName);\n            break;\n        }\n\n    }\n}\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_fd3cb2497364d350632c288ce3771738499f718e/build_fd3cb2497364d350632c288ce3771738499f718e\nTest project /out/danmar___cppcheck/git_repo_dir_fd3cb2497364d350632c288ce3771738499f718e/build_fd3cb2497364d350632c288ce3771738499f718e\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   57.17 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  57.22 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "fd3cb2497364d350632c288ce3771738499f718e___checkmemoryleak.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nclass meta_associative_container::meta_iterator {\n    enum operation { INCR, DEREF };\n\n    using vtable_type = void(const operation, const any &, void *);\n\n    template<bool KeyOnly, typename It>\n    static void basic_vtable(const operation op, const any &from, void *to) {\n        switch(op) {\n        case operation::INCR:\n            ++any_cast<It &>(const_cast<any &>(from));\n            break;\n        case operation::DEREF:\n            if constexpr(KeyOnly) {\n                static_cast<std::pair<meta_any, meta_any> *>(to)->first = *any_cast<const It &>(from);\n            } else {\n                *static_cast<std::pair<meta_any, meta_any> *>(to) = std::make_pair<meta_any, meta_any>(any_cast<const It &>(from)->first, std::reference_wrapper{any_cast<const It &>(from)->second});\n            }\n            break;\n        }\n    }\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/skypjack___entt/git_repo_dir_cf0da32fd0d0c9fe6ac322f18a8b6176407f7679/build_cf0da32fd0d0c9fe6ac322f18a8b6176407f7679\nTest project /out/skypjack___entt/git_repo_dir_cf0da32fd0d0c9fe6ac322f18a8b6176407f7679/build_cf0da32fd0d0c9fe6ac322f18a8b6176407f7679\n    Start 27: meta_container\n1/1 Test #27: meta_container ...................***Failed    5.16 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   5.16 sec\n\nThe following tests FAILED:\n\t 27 - meta_container (Failed)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "cf0da32fd0d0c9fe6ac322f18a8b6176407f7679___meta.hpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nint\nnng_recv(nng_socket s, void *buf, size_t *szp, int flags)\n{\n\tnng_msg *msg;\n\tint      rv;\n\n\t// Note that while it would be nice to make this a zero copy operation,\n\t// its not normally possible if a size was specified.\n\tif ((rv = nng_recvmsg(s, &msg, flags & ~(NNG_FLAG_ALLOC))) != 0) {\n\t\treturn (rv);\n\t}\n\tif (!(flags & NNG_FLAG_ALLOC)) {\n\t\tmemcpy(buf, nng_msg_body(msg),\n\t\t    *szp > nng_msg_len(msg) ? nng_msg_len(msg) : *szp);\n\t\t*szp = nng_msg_len(msg);\n\t} else {\n\t\t// We'd really like to avoid a separate data copy, but since\n\t\t// we have allocated messages with headroom, we can't really\n\t\t// make free() work on the base pointer.  We'd have to have\n\t\t// some other API for this.  Folks that want zero copy had\n\t\t// better use nng_recvmsg() instead.\n\t\tvoid *nbuf;\n\n\t\tif ((nbuf = nni_alloc(nng_msg_len(msg))) == NULL) {\n\t\t\tnng_msg_free(msg);\n\t\t\treturn (NNG_ENOMEM);\n\t\t}\n\n\t\t*(void **) buf = nbuf;\n\t\tmemcpy(nbuf, nni_msg_body(msg), nni_msg_len(msg));\n\t\t*szp = nng_msg_len(msg);\n\t}\n\tnni_msg_free(msg);\n\treturn (0);\n}\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/nanomsg___nng/git_repo_dir_6a59b15fba1085432c4c18952680e14d80dd134a/build_6a59b15fba1085432c4c18952680e14d80dd134a\nTest project /out/nanomsg___nng/git_repo_dir_6a59b15fba1085432c4c18952680e14d80dd134a/build_6a59b15fba1085432c4c18952680e14d80dd134a\n    Start 17: websocket_test\n1/2 Test #17: websocket_test ...................   Passed    0.30 sec\n    Start 22: sock\n2/2 Test #22: sock .............................***Failed    0.41 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =   0.71 sec\n\nThe following tests FAILED:\n\t 22 - sock (Failed)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "6a59b15fba1085432c4c18952680e14d80dd134a___nng.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\n  void write(long double value) { write_double(value, format_specs()); }\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_287eaab3b2777daa5d0d0cf72d977196ba54efb7/build_287eaab3b2777daa5d0d0cf72d977196ba54efb7\nTest project /out/fmtlib___fmt/git_repo_dir_287eaab3b2777daa5d0d0cf72d977196ba54efb7/build_287eaab3b2777daa5d0d0cf72d977196ba54efb7\n    Start 6: format-test\n1/1 Test #6: format-test ......................***Failed    0.12 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.12 sec\n\nThe following tests FAILED:\n\t  6 - format-test (Failed)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "287eaab3b2777daa5d0d0cf72d977196ba54efb7___format.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nFMT_FUNC internal::utf8_to_utf16::utf8_to_utf16(string_view s) {\n  auto transcode = [this](const char* p) {\n    auto cp = uint32_t();\n    auto error = 0;\n    p = utf8_decode(p, &cp, &error);\n    if (error != 0) FMT_THROW(std::runtime_error(\"invalid utf8\"));\n    if (cp <= 0xFFFF) {\n      buffer_.push_back(static_cast<wchar_t>(cp));\n    } else {\n      cp -= 0x10000;\n      buffer_.push_back(static_cast<wchar_t>(0xD800 + (cp >> 10)));\n      buffer_.push_back(static_cast<wchar_t>(0xDC00 + (cp & 0x3FF)));\n    }\n    return p;\n  };\n  auto p = s.data();\n  const size_t block_size = 4;  // utf8_decode always reads blocks of 4 chars.\n  if (s.size() >= block_size) {\n    for (auto end = p + s.size() - block_size + 1; p < end;) p = transcode(p);\n  }\n  if (auto num_chars_left = s.data() + s.size() - p) {\n    char buf[4] = {};\n    memcpy(buf, p, num_chars_left);\n    transcode(buf);\n  }\n  buffer_.push_back(0);\n}\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_e6b37b4aff1a673cb735b9b287aa637142120f6d/build_e6b37b4aff1a673cb735b9b287aa637142120f6d\nTest project /out/fmtlib___fmt/git_repo_dir_e6b37b4aff1a673cb735b9b287aa637142120f6d/build_e6b37b4aff1a673cb735b9b287aa637142120f6d\n    Start 7: format-test\n1/1 Test #7: format-test ......................***Failed    0.08 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.08 sec\n\nThe following tests FAILED:\n\t  7 - format-test (Failed)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "e6b37b4aff1a673cb735b9b287aa637142120f6d___format-inl.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following function contains bugs:```cpp\nvoid zmq::v3_1_encoder_t::message_ready ()\n{\n    //  Encode flags.\n    size_t size = in_progress ()->size ();\n    size_t header_size = 2; // flags byte + size byte\n    unsigned char &protocol_flags = _tmp_buf[0];\n    protocol_flags = 0;\n    if (in_progress ()->flags () & msg_t::more)\n        protocol_flags |= v2_protocol_t::more_flag;\n    if (in_progress ()->size () > UCHAR_MAX)\n        protocol_flags |= v2_protocol_t::large_flag;\n    if (in_progress ()->flags () & msg_t::command\n        || in_progress ()->is_subscribe () || in_progress ()->is_cancel ()) {\n        protocol_flags |= v2_protocol_t::command_flag;\n        if (in_progress ()->is_subscribe ())\n            size += zmq::msg_t::sub_cmd_name_size;\n        else if (in_progress ()->is_cancel ())\n            size += zmq::msg_t::cancel_cmd_name_size;\n    }\n\n    //  Encode the message length. For messages less then 256 bytes,\n    //  the length is encoded as 8-bit unsigned integer. For larger\n    //  messages, 64-bit unsigned integer in network byte order is used.\n    if (unlikely (size > UCHAR_MAX)) {\n        put_uint64 (_tmp_buf + 1, size);\n        header_size = 9; // flags byte + size 8 bytes\n    } else {\n        _tmp_buf[1] = static_cast<uint8_t> (size);\n    }\n\n    //  Encode the sub/cancel command string. This is done in the encoder as\n    //  opposed to when the subscribe message is created to allow different\n    //  protocol behaviour on the wire in the v3.1 and legacy encoders.\n    //  It results in the work being done multiple times in case the sub\n    //  is sending the subscription/cancel to multiple pubs, but it cannot\n    //  be avoided. This processing can be moved to xsub once support for\n    //  ZMTP < 3.1 is dropped.\n    if (in_progress ()->is_subscribe ()) {\n        memcpy (_tmp_buf + header_size, zmq::sub_cmd_name,\n                zmq::msg_t::sub_cmd_name_size);\n        header_size += zmq::msg_t::sub_cmd_name_size;\n    } else if (in_progress ()->is_cancel ()) {\n        memcpy (_tmp_buf + header_size, zmq::cancel_cmd_name,\n                zmq::msg_t::cancel_cmd_name_size);\n        header_size += zmq::msg_t::cancel_cmd_name_size;\n    }\n\n    next_step (_tmp_buf, header_size, &v3_1_encoder_t::size_ready, false);\n}\n```\n \n\n\nwith the following test error: Internal ctest changing into directory: /out/zeromq___libzmq/git_repo_dir_ecc63d0d3b0e1a62c90b58b1ccdb5ac16cb2400a/build_ecc63d0d3b0e1a62c90b58b1ccdb5ac16cb2400a\nTest project /out/zeromq___libzmq/git_repo_dir_ecc63d0d3b0e1a62c90b58b1ccdb5ac16cb2400a/build_ecc63d0d3b0e1a62c90b58b1ccdb5ac16cb2400a\n    Start 60: test_xpub_topic\n1/1 Test #60: test_xpub_topic ..................***Failed    0.01 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.01 sec\n\nThe following tests FAILED:\n\t 60 - test_xpub_topic (Failed)\n \nPlease fix bugs in the function and tell me the complete fixed function."}], "idx": "ecc63d0d3b0e1a62c90b58b1ccdb5ac16cb2400a___v3_1_encoder.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  /* global name? */\n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */\n    lua_assert(var->k != VVOID);  /* this one must exist */\n\n>>> [ INFILL ] <<<\n    luaK_indexed(fs, var, &key);  /* env[varname] */\n  }\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    codestring(&key, varname);  /* key is variable name */\n\n```\n\n\n\nwith the following test error: testing require\npackage config: /|;|?|!|-|\ntesting 'require' message\n+\n+\ntesting assignments, logical operators, and constructors\n+\n../lua: attrib.lua:444: assertion failed!\nstack traceback:\n\t[C]: in function 'assert'\n\tattrib.lua:444: in main chunk\n\t[C]: in ?\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "1f3c6f4534c6411313361697d98d1145a1f030fa___lparser.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstruct Address *\nnew_address(const char *hostname_or_ip) {\n    union {\n        struct sockaddr a;\n        struct sockaddr_in in;\n        struct sockaddr_in6 in6;\n        struct sockaddr_un un;\n        struct sockaddr_storage s;\n    } s;\n    char ip_buf[ADDRESS_BUFFER_SIZE];\n    char *port;\n    size_t len;\n\n    if (hostname_or_ip == NULL)\n        return NULL;\n\n    /* IPv6 address */\n    /* we need to test for raw IPv6 address for IPv4 port combinations since a\n     * colon would give false positives\n     */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET6, hostname_or_ip,\n                &s.in6.sin6_addr) == 1) {\n        s.in6.sin6_family = AF_INET6;\n\n        return new_address_sa(&s.a, sizeof(s.in6));\n    }\n\n    /* Unix socket */\n    memset(&s, 0, sizeof(s));\n    if (strncmp(\"unix:\", hostname_or_ip, 5) == 0) {\n        if (strlen(hostname_or_ip) >=\n                sizeof(s.un.sun_path))\n            return NULL;\n\n        /* XXX: only supporting pathname unix sockets */\n        s.un.sun_family = AF_UNIX;\n        strncpy(s.un.sun_path,\n                hostname_or_ip + 5,\n                sizeof(s.un.sun_path) - 1);\n\n        return new_address_sa(&s.a, offsetof(struct sockaddr_un, sun_path) +\n                              strlen(s.un.sun_path) + 1);\n    }\n\n    /* Trailing port */\n    if ((port = strrchr(hostname_or_ip, ':')) != NULL &&\n            is_numeric(port + 1)) {\n        len = (size_t)(port - hostname_or_ip);\n        int port_num = atoi(port + 1);\n\n        if (len < sizeof(ip_buf) && port_num >= 0 && port_num <= 65535) {\n            strncpy(ip_buf, hostname_or_ip, len);\n            ip_buf[len] = '\\0';\n\n            struct Address *addr = new_address(ip_buf);\n            if (addr != NULL)\n                address_set_port(addr, (uint16_t) port_num);\n\n            return addr;\n        }\n    }\n\n    /* Wildcard */\n    if (strcmp(\"*\", hostname_or_ip) == 0) {\n        struct Address *addr = malloc(sizeof(struct Address));\n        if (addr != NULL) {\n            addr->type = WILDCARD;\n            addr->len = 0;\n            address_set_port(addr, 0);\n        }\n        return addr;\n    }\n\n    /* IPv4 address */\n    memset(&s, 0, sizeof(s));\n    if (inet_pton(AF_INET, hostname_or_ip,\n                  &s.in.sin_addr) == 1) {\n        s.in.sin_family = AF_INET;\n\n        return new_address_sa(&s.a, sizeof(s.in));\n    }\n\n    /* [IPv6 address] */\n    memset(&s, 0, sizeof(s));\n    if (hostname_or_ip[0] == '[' &&\n            (port = strchr(hostname_or_ip, ']')) != NULL) {\n        len = (size_t)(port - hostname_or_ip - 1);\n\n>>> [ INFILL ] <<<\n        /* inet_pton() will not parse the IP correctly unless it is in a\n         * separate string.\n         */\n        strncpy(ip_buf, hostname_or_ip + 1, len);\n        ip_buf[len] = '\\0';\n\n        if (inet_pton(AF_INET6, ip_buf,\n                      &s.in6.sin6_addr) == 1) {\n            s.in6.sin6_family = AF_INET6;\n\n            return new_address_sa(&s.a, sizeof(s.in6));\n        }\n    }\n\n    /* hostname */\n    if (valid_hostname(hostname_or_ip)) {\n        len = strlen(hostname_or_ip);\n        struct Address *addr = malloc(\n                offsetof(struct Address, data) + len + 1);\n        if (addr != NULL) {\n            addr->type = HOSTNAME;\n            addr->port = 0;\n            addr->len = len;\n            memcpy(addr->data, hostname_or_ip, len);\n            addr->data[addr->len] = '\\0';\n\n            /* Store address in lower case */\n            for (char *c = addr->data; *c != '\\0'; c++)\n                *c = tolower(*c);\n        }\n\n        return addr;\n    }\n\n    return NULL;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\n\n```\n\n\n\nwith the following test error: Test failed.\nserver died with signal 11, with coredump\nworker failed with exit code 111\nworker failed with exit code 111\nworker failed with exit code 111\nLibVEX; rerun with -h for copyright info\n==55383== Command: ../src/sniproxy -f -c /tmp/yoldJo0egL\n==55383== \n--55383-- WARNING: Serious error when reading debug info\n--55383-- When reading debug info from /out/dlundquist___sniproxy/git_repo_dir_f8d9a433fe22ab2fa15c00179048ab02ae23d583/src/sniproxy:\n--55383-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--55383-- WARNING: Serious error when reading debug info\n--55383-- When reading debug info from /out/dlundquist___sniproxy/git_repo_dir_f8d9a433fe22ab2fa15c00179048ab02ae23d583/src/sniproxy:\n--55383-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--55383-- WARNING: Serious error when reading debug info\n--55383-- When reading debug info from /out/dlundquist___sniproxy/git_repo_dir_f8d9a433fe22ab2fa15c00179048ab02ae23d583/src/sniproxy:\n--55383-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--55383-- WARNING: Serious error when reading debug info\n--55383-- When reading debug info from /out/dlundquist___sniproxy/git_repo_dir_f8d9a433fe22ab2fa15c00179048ab02ae23d583/src/sniproxy:\n--55383-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--55383-- WARNING: Serious error when reading debug info\n--55383-- When reading debug info from /out/dlundquist___sniproxy/git_repo_dir_f8d9a433fe22ab2fa15c00179048ab02ae23d583/src/sniproxy:\n--55383-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--55383-- WARNING: Serious error when reading debug info\n--55383-- When reading debug info from /out/dlundquist___sniproxy/git_repo_dir_f8d9a433fe22ab2fa15c00179048ab02ae23d583/src/sniproxy:\n--55383-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--55383-- WARNING: Serious error when reading debug info\n--55383-- When reading debug info from /out/dlundquist___sniproxy/git_repo_dir_f8d9a433fe22ab2fa15c00179048ab02ae23d583/src/sniproxy:\n--55383-- Ignoring non-Dwarf2/3/4 block in .debug_info\n--55383-- WARNING: Serious error when reading debug info\n--553 \nPlease provide the correct line following commit message at the infill location."}], "idx": "f8d9a433fe22ab2fa15c00179048ab02ae23d583___address.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic int\nname_len(netdissect_options *ndo,\n         const unsigned char *s, const unsigned char *maxbuf)\n{\n    const unsigned char *s0 = s;\n    unsigned char c;\n\n    if (s >= maxbuf)\n\treturn(-1);\t/* name goes past the end of the buffer */\n    ND_TCHECK2(*s, 1);\n    c = *s;\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (*s) {\n\tif (s >= maxbuf)\n\t    return(-1);\t/* name goes past the end of the buffer */\n\tND_TCHECK2(*s, 1);\n\ts += (*s) + 1;\n\n>>> [ INFILL ] <<<\n    return(PTR_DIFF(s, s0) + 1);\n\ntrunc:\n    return(-1);\t/* name goes past the end of the buffer */\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    }\n\n```\n\n\n\nwith the following test error:     nbns-valgrind                      : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "6f5ba2b651cd9d4b7fa8ee5c4f94460645877c45___smbutil.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic int\ntelnet_parse(netdissect_options *ndo, const u_char *sp, u_int length, int print)\n{\n\tint i, x;\n\tu_int c;\n\tconst u_char *osp, *p;\n#define FETCH(c, sp, length) \\\n\tdo { \\\n\t\tif (length < 1) \\\n\t\t\tgoto pktend; \\\n\t\tND_TCHECK(*sp); \\\n\t\tc = *sp++; \\\n\t\tlength--; \\\n\t} while (0)\n\n\tosp = sp;\n\n\tFETCH(c, sp, length);\n\tif (c != IAC)\n\t\tgoto pktend;\n\tFETCH(c, sp, length);\n\tif (c == IAC) {\t\t/* <IAC><IAC>! */\n\t\tif (print)\n\t\t\tND_PRINT((ndo, \"IAC IAC\"));\n\t\tgoto done;\n\t}\n\n\ti = c - TELCMD_FIRST;\n\tif (i < 0 || i > IAC - TELCMD_FIRST)\n\t\tgoto pktend;\n\n\tswitch (c) {\n\tcase DONT:\n\tcase DO:\n\tcase WONT:\n\tcase WILL:\n\tcase SB:\n\t\t/* DONT/DO/WONT/WILL x */\n\t\tFETCH(x, sp, length);\n\t\tif (x >= 0 && x < NTELOPTS) {\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \"%s %s\", telcmds[i], telopts[x]));\n\t\t} else {\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \"%s %#x\", telcmds[i], x));\n\t\t}\n\t\tif (c != SB)\n\t\t\tbreak;\n\t\t/* IAC SB .... IAC SE */\n\t\tp = sp;\n\t\twhile (length > (u_int)(p + 1 - sp)) {\n\t\t\tND_TCHECK2(*p, 2);\n\t\t\tif (p[0] == IAC && p[1] == SE)\n\t\t\t\tbreak;\n\t\t\tp++;\n\t\t}\n\n>>> [ INFILL ] <<<\n\t\t\tgoto pktend;\n\n\t\tswitch (x) {\n\t\tcase TELOPT_AUTHENTICATION:\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, authcmd)));\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, authtype)));\n\t\t\tbreak;\n\t\tcase TELOPT_ENCRYPT:\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, enccmd)));\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, enctype)));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (p <= sp)\n\t\t\t\tbreak;\n\t\t\tFETCH(c, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %s\", STR_OR_ID(c, cmds)));\n\t\t\tbreak;\n\t\t}\n\t\twhile (p > sp) {\n\t\t\tFETCH(x, sp, length);\n\t\t\tif (print)\n\t\t\t\tND_PRINT((ndo, \" %#x\", x));\n\t\t}\n\t\t/* terminating IAC SE */\n\t\tif (print)\n\t\t\tND_PRINT((ndo, \" SE\"));\n\t\tsp += 2;\n\t\tbreak;\n\tdefault:\n\t\tif (print)\n\t\t\tND_PRINT((ndo, \"%s\", telcmds[i]));\n\t\tgoto done;\n\t}\n\ndone:\n\treturn sp - osp;\n\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\npktend:\n\treturn -1;\n#undef FETCH\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\tif (*p != IAC)\n\n```\n\n\n\nwith the following test error:     telnet-iac-check-oobr              : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "8934a7d6307267d301182f19ed162563717e29e3___print-telnet.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic int\nisis_print(netdissect_options *ndo,\n           const uint8_t *p, u_int length)\n{\n    const struct isis_common_header *isis_header;\n\n    const struct isis_iih_lan_header *header_iih_lan;\n    const struct isis_iih_ptp_header *header_iih_ptp;\n    const struct isis_lsp_header *header_lsp;\n    const struct isis_csnp_header *header_csnp;\n    const struct isis_psnp_header *header_psnp;\n\n    const struct isis_tlv_lsp *tlv_lsp;\n    const struct isis_tlv_ptp_adj *tlv_ptp_adj;\n    const struct isis_tlv_is_reach *tlv_is_reach;\n    const struct isis_tlv_es_reach *tlv_es_reach;\n\n    uint8_t pdu_type, max_area, id_length, tlv_type, tlv_len, tmp, alen, lan_alen, prefix_len;\n    uint8_t ext_is_len, ext_ip_len, mt_len;\n    const uint8_t *optr, *pptr, *tptr;\n    u_short packet_len,pdu_len, key_id;\n    u_int i,vendor_id;\n    int sigcheck;\n\n    packet_len=length;\n    optr = p; /* initialize the _o_riginal pointer to the packet start -\n                 need it for parsing the checksum TLV and authentication\n                 TLV verification */\n    isis_header = (const struct isis_common_header *)p;\n    ND_TCHECK(*isis_header);\n    if (length < ISIS_COMMON_HEADER_SIZE)\n        goto trunc;\n    pptr = p+(ISIS_COMMON_HEADER_SIZE);\n    header_iih_lan = (const struct isis_iih_lan_header *)pptr;\n    header_iih_ptp = (const struct isis_iih_ptp_header *)pptr;\n    header_lsp = (const struct isis_lsp_header *)pptr;\n    header_csnp = (const struct isis_csnp_header *)pptr;\n    header_psnp = (const struct isis_psnp_header *)pptr;\n\n    if (!ndo->ndo_eflag)\n        ND_PRINT((ndo, \"IS-IS\"));\n\n    /*\n     * Sanity checking of the header.\n     */\n\n    if (isis_header->version != ISIS_VERSION) {\n\tND_PRINT((ndo, \"version %d packet not supported\", isis_header->version));\n\treturn (0);\n    }\n\n    if ((isis_header->id_length != SYSTEM_ID_LEN) && (isis_header->id_length != 0)) {\n\tND_PRINT((ndo, \"system ID length of %d is not supported\",\n\t       isis_header->id_length));\n\treturn (0);\n    }\n\n    if (isis_header->pdu_version != ISIS_VERSION) {\n\tND_PRINT((ndo, \"version %d packet not supported\", isis_header->pdu_version));\n\treturn (0);\n    }\n\n    if (length < isis_header->fixed_len) {\n\tND_PRINT((ndo, \"fixed header length %u > packet length %u\", isis_header->fixed_len, length));\n\treturn (0);\n    }\n\n    if (isis_header->fixed_len < ISIS_COMMON_HEADER_SIZE) {\n\tND_PRINT((ndo, \"fixed header length %u < minimum header size %u\", isis_header->fixed_len, (u_int)ISIS_COMMON_HEADER_SIZE));\n\treturn (0);\n    }\n\n    max_area = isis_header->max_area;\n    switch(max_area) {\n    case 0:\n\tmax_area = 3;\t /* silly shit */\n\tbreak;\n    case 255:\n\tND_PRINT((ndo, \"bad packet -- 255 areas\"));\n\treturn (0);\n    default:\n\tbreak;\n    }\n\n    id_length = isis_header->id_length;\n    switch(id_length) {\n    case 0:\n        id_length = 6;\t /* silly shit again */\n\tbreak;\n    case 1:              /* 1-8 are valid sys-ID lenghts */\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n    case 6:\n    case 7:\n    case 8:\n        break;\n    case 255:\n        id_length = 0;   /* entirely useless */\n\tbreak;\n    default:\n        break;\n    }\n\n    /* toss any non 6-byte sys-ID len PDUs */\n    if (id_length != 6 ) {\n\tND_PRINT((ndo, \"bad packet -- illegal sys-ID length (%u)\", id_length));\n\treturn (0);\n    }\n\n    pdu_type=isis_header->pdu_type;\n\n    /* in non-verbose mode print the basic PDU Type plus PDU specific brief information*/\n    if (ndo->ndo_vflag == 0) {\n        ND_PRINT((ndo, \"%s%s\",\n               ndo->ndo_eflag ? \"\" : \", \",\n               tok2str(isis_pdu_values, \"unknown PDU-Type %u\", pdu_type)));\n    } else {\n        /* ok they seem to want to know everything - lets fully decode it */\n        ND_PRINT((ndo, \"%slength %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\n        ND_PRINT((ndo, \"\\n\\t%s, hlen: %u, v: %u, pdu-v: %u, sys-id-len: %u (%u), max-area: %u (%u)\",\n               tok2str(isis_pdu_values,\n                       \"unknown, type %u\",\n                       pdu_type),\n               isis_header->fixed_len,\n               isis_header->version,\n               isis_header->pdu_version,\n               id_length,\n               isis_header->id_length,\n               max_area,\n               isis_header->max_area));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, optr, \"\\n\\t\", 8)) /* provide the _o_riginal pointer */\n                return (0);                         /* for optionally debugging the common header */\n        }\n    }\n\n    switch (pdu_type) {\n\n    case ISIS_PDU_L1_LAN_IIH:\n    case ISIS_PDU_L2_LAN_IIH:\n        if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)) {\n            ND_PRINT((ndo, \", bogus fixed header length %u should be %lu\",\n                     isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)));\n            return (0);\n        }\n        ND_TCHECK(*header_iih_lan);\n        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)\n            goto trunc;\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", src-id %s\",\n                      isis_print_id(header_iih_lan->source_id, SYSTEM_ID_LEN)));\n            ND_PRINT((ndo, \", lan-id %s, prio %u\",\n                      isis_print_id(header_iih_lan->lan_id,NODE_ID_LEN),\n                      header_iih_lan->priority));\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n        pdu_len=EXTRACT_16BITS(header_iih_lan->pdu_len);\n        if (packet_len>pdu_len) {\n           packet_len=pdu_len; /* do TLV decoding as long as it makes sense */\n           length=pdu_len;\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  source-id: %s,  holding time: %us, Flags: [%s]\",\n                  isis_print_id(header_iih_lan->source_id,SYSTEM_ID_LEN),\n                  EXTRACT_16BITS(header_iih_lan->holding_time),\n                  tok2str(isis_iih_circuit_type_values,\n                          \"unknown circuit type 0x%02x\",\n                          header_iih_lan->circuit_type)));\n\n        ND_PRINT((ndo, \"\\n\\t  lan-id:    %s, Priority: %u, PDU length: %u\",\n                  isis_print_id(header_iih_lan->lan_id, NODE_ID_LEN),\n                  (header_iih_lan->priority) & ISIS_LAN_PRIORITY_MASK,\n                  pdu_len));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, pptr, \"\\n\\t  \", ISIS_IIH_LAN_HEADER_SIZE))\n                return (0);\n        }\n\n        packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE);\n        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE);\n        break;\n\n    case ISIS_PDU_PTP_IIH:\n        if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)) {\n            ND_PRINT((ndo, \", bogus fixed header length %u should be %lu\",\n                      isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)));\n            return (0);\n        }\n        ND_TCHECK(*header_iih_ptp);\n        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)\n            goto trunc;\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", src-id %s\", isis_print_id(header_iih_ptp->source_id, SYSTEM_ID_LEN)));\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n        pdu_len=EXTRACT_16BITS(header_iih_ptp->pdu_len);\n        if (packet_len>pdu_len) {\n            packet_len=pdu_len; /* do TLV decoding as long as it makes sense */\n            length=pdu_len;\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  source-id: %s, holding time: %us, Flags: [%s]\",\n                  isis_print_id(header_iih_ptp->source_id,SYSTEM_ID_LEN),\n                  EXTRACT_16BITS(header_iih_ptp->holding_time),\n                  tok2str(isis_iih_circuit_type_values,\n                          \"unknown circuit type 0x%02x\",\n                          header_iih_ptp->circuit_type)));\n\n        ND_PRINT((ndo, \"\\n\\t  circuit-id: 0x%02x, PDU length: %u\",\n                  header_iih_ptp->circuit_id,\n                  pdu_len));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, pptr, \"\\n\\t  \", ISIS_IIH_PTP_HEADER_SIZE))\n                return (0);\n        }\n\n        packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE);\n        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE);\n        break;\n\n    case ISIS_PDU_L1_LSP:\n    case ISIS_PDU_L2_LSP:\n        if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE)) {\n            ND_PRINT((ndo, \", bogus fixed header length %u should be %lu\",\n                   isis_header->fixed_len, (unsigned long)ISIS_LSP_HEADER_SIZE));\n            return (0);\n        }\n        ND_TCHECK(*header_lsp);\n        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE)\n            goto trunc;\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", lsp-id %s, seq 0x%08x, lifetime %5us\",\n                      isis_print_id(header_lsp->lsp_id, LSP_ID_LEN),\n                      EXTRACT_32BITS(header_lsp->sequence_number),\n                      EXTRACT_16BITS(header_lsp->remaining_lifetime)));\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n        pdu_len=EXTRACT_16BITS(header_lsp->pdu_len);\n        if (packet_len>pdu_len) {\n            packet_len=pdu_len; /* do TLV decoding as long as it makes sense */\n            length=pdu_len;\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  lsp-id: %s, seq: 0x%08x, lifetime: %5us\\n\\t  chksum: 0x%04x\",\n               isis_print_id(header_lsp->lsp_id, LSP_ID_LEN),\n               EXTRACT_32BITS(header_lsp->sequence_number),\n               EXTRACT_16BITS(header_lsp->remaining_lifetime),\n               EXTRACT_16BITS(header_lsp->checksum)));\n\n        osi_print_cksum(ndo, (const uint8_t *)header_lsp->lsp_id,\n                        EXTRACT_16BITS(header_lsp->checksum),\n                        12, length-12);\n\n        ND_PRINT((ndo, \", PDU length: %u, Flags: [ %s\",\n               pdu_len,\n               ISIS_MASK_LSP_OL_BIT(header_lsp->typeblock) ? \"Overload bit set, \" : \"\"));\n\n        if (ISIS_MASK_LSP_ATT_BITS(header_lsp->typeblock)) {\n            ND_PRINT((ndo, \"%s\", ISIS_MASK_LSP_ATT_DEFAULT_BIT(header_lsp->typeblock) ? \"default \" : \"\"));\n            ND_PRINT((ndo, \"%s\", ISIS_MASK_LSP_ATT_DELAY_BIT(header_lsp->typeblock) ? \"delay \" : \"\"));\n            ND_PRINT((ndo, \"%s\", ISIS_MASK_LSP_ATT_EXPENSE_BIT(header_lsp->typeblock) ? \"expense \" : \"\"));\n            ND_PRINT((ndo, \"%s\", ISIS_MASK_LSP_ATT_ERROR_BIT(header_lsp->typeblock) ? \"error \" : \"\"));\n            ND_PRINT((ndo, \"ATT bit set, \"));\n        }\n        ND_PRINT((ndo, \"%s\", ISIS_MASK_LSP_PARTITION_BIT(header_lsp->typeblock) ? \"P bit set, \" : \"\"));\n        ND_PRINT((ndo, \"%s ]\", tok2str(isis_lsp_istype_values, \"Unknown(0x%x)\",\n                  ISIS_MASK_LSP_ISTYPE_BITS(header_lsp->typeblock))));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, pptr, \"\\n\\t  \", ISIS_LSP_HEADER_SIZE))\n                return (0);\n        }\n\n        packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE);\n        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE);\n        break;\n\n    case ISIS_PDU_L1_CSNP:\n    case ISIS_PDU_L2_CSNP:\n        if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)) {\n            ND_PRINT((ndo, \", bogus fixed header length %u should be %lu\",\n                      isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)));\n            return (0);\n        }\n        ND_TCHECK(*header_csnp);\n        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)\n            goto trunc;\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", src-id %s\", isis_print_id(header_csnp->source_id, NODE_ID_LEN)));\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n        pdu_len=EXTRACT_16BITS(header_csnp->pdu_len);\n        if (packet_len>pdu_len) {\n            packet_len=pdu_len; /* do TLV decoding as long as it makes sense */\n            length=pdu_len;\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  source-id:    %s, PDU length: %u\",\n               isis_print_id(header_csnp->source_id, NODE_ID_LEN),\n               pdu_len));\n        ND_PRINT((ndo, \"\\n\\t  start lsp-id: %s\",\n               isis_print_id(header_csnp->start_lsp_id, LSP_ID_LEN)));\n        ND_PRINT((ndo, \"\\n\\t  end lsp-id:   %s\",\n               isis_print_id(header_csnp->end_lsp_id, LSP_ID_LEN)));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, pptr, \"\\n\\t  \", ISIS_CSNP_HEADER_SIZE))\n                return (0);\n        }\n\n        packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE);\n        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE);\n        break;\n\n    case ISIS_PDU_L1_PSNP:\n    case ISIS_PDU_L2_PSNP:\n        if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)) {\n            ND_PRINT((ndo, \"- bogus fixed header length %u should be %lu\",\n                   isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)));\n            return (0);\n        }\n        ND_TCHECK(*header_psnp);\n        if (length < ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)\n            goto trunc;\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", src-id %s\", isis_print_id(header_psnp->source_id, NODE_ID_LEN)));\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n        pdu_len=EXTRACT_16BITS(header_psnp->pdu_len);\n        if (packet_len>pdu_len) {\n            packet_len=pdu_len; /* do TLV decoding as long as it makes sense */\n            length=pdu_len;\n        }\n\n        ND_PRINT((ndo, \"\\n\\t  source-id:    %s, PDU length: %u\",\n               isis_print_id(header_psnp->source_id, NODE_ID_LEN),\n               pdu_len));\n\n        if (ndo->ndo_vflag > 1) {\n            if (!print_unknown_data(ndo, pptr, \"\\n\\t  \", ISIS_PSNP_HEADER_SIZE))\n                return (0);\n        }\n\n        packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE);\n        pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE);\n        break;\n\n    default:\n        if (ndo->ndo_vflag == 0) {\n            ND_PRINT((ndo, \", length %u\", length));\n            return (1);\n        }\n\t(void)print_unknown_data(ndo, pptr, \"\\n\\t  \", length);\n\treturn (0);\n    }\n\n    /*\n     * Now print the TLV's.\n     */\n\n    while (packet_len > 0) {\n\tND_TCHECK2(*pptr, 2);\n\tif (packet_len < 2)\n\t    goto trunc;\n\ttlv_type = *pptr++;\n\ttlv_len = *pptr++;\n        tmp =tlv_len; /* copy temporary len & pointer to packet data */\n        tptr = pptr;\n\tpacket_len -= 2;\n\n        /* first lets see if we know the TLVs name*/\n\tND_PRINT((ndo, \"\\n\\t    %s TLV #%u, length: %u\",\n               tok2str(isis_tlv_values,\n                       \"unknown\",\n                       tlv_type),\n               tlv_type,\n               tlv_len));\n\n        if (tlv_len == 0) /* something is invalid */\n\t    continue;\n\n\tif (packet_len < tlv_len)\n\t    goto trunc;\n\n        /* now check if we have a decoder otherwise do a hexdump at the end*/\n\tswitch (tlv_type) {\n\tcase ISIS_TLV_AREA_ADDR:\n\t    ND_TCHECK2(*tptr, 1);\n\t    alen = *tptr++;\n\t    while (tmp && alen < tmp) {\n\n>>> [ INFILL ] <<<\n                       alen,\n                       isonsap_string(ndo, tptr, alen)));\n\t\ttptr += alen;\n\t\ttmp -= alen + 1;\n\t\tif (tmp==0) /* if this is the last area address do not attemt a boundary check */\n                    break;\n\t\tND_TCHECK2(*tptr, 1);\n\t\talen = *tptr++;\n\t    }\n\t    break;\n\tcase ISIS_TLV_ISNEIGH:\n\t    while (tmp >= ETHER_ADDR_LEN) {\n                ND_TCHECK2(*tptr, ETHER_ADDR_LEN);\n                ND_PRINT((ndo, \"\\n\\t      SNPA: %s\", isis_print_id(tptr, ETHER_ADDR_LEN)));\n                tmp -= ETHER_ADDR_LEN;\n                tptr += ETHER_ADDR_LEN;\n\t    }\n\t    break;\n\n        case ISIS_TLV_ISNEIGH_VARLEN:\n            if (!ND_TTEST2(*tptr, 1) || tmp < 3) /* min. TLV length */\n\t\tgoto trunctlv;\n\t    lan_alen = *tptr++; /* LAN address length */\n\t    if (lan_alen == 0) {\n                ND_PRINT((ndo, \"\\n\\t      LAN address length 0 bytes (invalid)\"));\n                break;\n            }\n            tmp --;\n            ND_PRINT((ndo, \"\\n\\t      LAN address length %u bytes \", lan_alen));\n\t    while (tmp >= lan_alen) {\n                ND_TCHECK2(*tptr, lan_alen);\n                ND_PRINT((ndo, \"\\n\\t\\tIS Neighbor: %s\", isis_print_id(tptr, lan_alen)));\n                tmp -= lan_alen;\n                tptr +=lan_alen;\n            }\n            break;\n\n\tcase ISIS_TLV_PADDING:\n\t    break;\n\n        case ISIS_TLV_MT_IS_REACH:\n            mt_len = isis_print_mtid(ndo, tptr, \"\\n\\t      \");\n            if (mt_len == 0) /* did something go wrong ? */\n                goto trunctlv;\n            tptr+=mt_len;\n            tmp-=mt_len;\n            while (tmp >= 2+NODE_ID_LEN+3+1) {\n                ext_is_len = isis_print_ext_is_reach(ndo, tptr, \"\\n\\t      \", tlv_type);\n                if (ext_is_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n\n                tmp-=ext_is_len;\n                tptr+=ext_is_len;\n            }\n            break;\n\n        case ISIS_TLV_IS_ALIAS_ID:\n\t    while (tmp >= NODE_ID_LEN+1) { /* is it worth attempting a decode ? */\n\t        ext_is_len = isis_print_ext_is_reach(ndo, tptr, \"\\n\\t      \", tlv_type);\n\t\tif (ext_is_len == 0) /* did something go wrong ? */\n\t            goto trunctlv;\n\t\ttmp-=ext_is_len;\n\t\ttptr+=ext_is_len;\n\t    }\n\t    break;\n\n        case ISIS_TLV_EXT_IS_REACH:\n            while (tmp >= NODE_ID_LEN+3+1) { /* is it worth attempting a decode ? */\n                ext_is_len = isis_print_ext_is_reach(ndo, tptr, \"\\n\\t      \", tlv_type);\n                if (ext_is_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n                tmp-=ext_is_len;\n                tptr+=ext_is_len;\n            }\n            break;\n        case ISIS_TLV_IS_REACH:\n\t    ND_TCHECK2(*tptr,1);  /* check if there is one byte left to read out the virtual flag */\n            ND_PRINT((ndo, \"\\n\\t      %s\",\n                   tok2str(isis_is_reach_virtual_values,\n                           \"bogus virtual flag 0x%02x\",\n                           *tptr++)));\n\t    tlv_is_reach = (const struct isis_tlv_is_reach *)tptr;\n            while (tmp >= sizeof(struct isis_tlv_is_reach)) {\n\t\tND_TCHECK(*tlv_is_reach);\n\t\tND_PRINT((ndo, \"\\n\\t      IS Neighbor: %s\",\n\t\t       isis_print_id(tlv_is_reach->neighbor_nodeid, NODE_ID_LEN)));\n\t\tisis_print_metric_block(ndo, &tlv_is_reach->isis_metric_block);\n\t\ttmp -= sizeof(struct isis_tlv_is_reach);\n\t\ttlv_is_reach++;\n\t    }\n            break;\n\n        case ISIS_TLV_ESNEIGH:\n\t    tlv_es_reach = (const struct isis_tlv_es_reach *)tptr;\n            while (tmp >= sizeof(struct isis_tlv_es_reach)) {\n\t\tND_TCHECK(*tlv_es_reach);\n\t\tND_PRINT((ndo, \"\\n\\t      ES Neighbor: %s\",\n                       isis_print_id(tlv_es_reach->neighbor_sysid, SYSTEM_ID_LEN)));\n\t\tisis_print_metric_block(ndo, &tlv_es_reach->isis_metric_block);\n\t\ttmp -= sizeof(struct isis_tlv_es_reach);\n\t\ttlv_es_reach++;\n\t    }\n            break;\n\n            /* those two TLVs share the same format */\n\tcase ISIS_TLV_INT_IP_REACH:\n\tcase ISIS_TLV_EXT_IP_REACH:\n\t\tif (!isis_print_tlv_ip_reach(ndo, pptr, \"\\n\\t      \", tlv_len))\n\t\t\treturn (1);\n\t\tbreak;\n\n\tcase ISIS_TLV_EXTD_IP_REACH:\n\t    while (tmp>0) {\n                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, \"\\n\\t      \", AF_INET);\n                if (ext_ip_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n                tptr+=ext_ip_len;\n\t\ttmp-=ext_ip_len;\n\t    }\n\t    break;\n\n        case ISIS_TLV_MT_IP_REACH:\n            mt_len = isis_print_mtid(ndo, tptr, \"\\n\\t      \");\n            if (mt_len == 0) { /* did something go wrong ? */\n                goto trunctlv;\n            }\n            tptr+=mt_len;\n            tmp-=mt_len;\n\n            while (tmp>0) {\n                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, \"\\n\\t      \", AF_INET);\n                if (ext_ip_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n                tptr+=ext_ip_len;\n\t\ttmp-=ext_ip_len;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_IP6_REACH:\n\t    while (tmp>0) {\n                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, \"\\n\\t      \", AF_INET6);\n                if (ext_ip_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n                tptr+=ext_ip_len;\n\t\ttmp-=ext_ip_len;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_MT_IP6_REACH:\n            mt_len = isis_print_mtid(ndo, tptr, \"\\n\\t      \");\n            if (mt_len == 0) { /* did something go wrong ? */\n                goto trunctlv;\n            }\n            tptr+=mt_len;\n            tmp-=mt_len;\n\n\t    while (tmp>0) {\n                ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, \"\\n\\t      \", AF_INET6);\n                if (ext_ip_len == 0) /* did something go wrong ? */\n                    goto trunctlv;\n                tptr+=ext_ip_len;\n\t\ttmp-=ext_ip_len;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_IP6ADDR:\n\t    while (tmp>=sizeof(struct in6_addr)) {\n\t\tND_TCHECK2(*tptr, sizeof(struct in6_addr));\n\n                ND_PRINT((ndo, \"\\n\\t      IPv6 interface address: %s\",\n\t\t       ip6addr_string(ndo, tptr)));\n\n\t\ttptr += sizeof(struct in6_addr);\n\t\ttmp -= sizeof(struct in6_addr);\n\t    }\n\t    break;\n\tcase ISIS_TLV_AUTH:\n\t    ND_TCHECK2(*tptr, 1);\n\n            ND_PRINT((ndo, \"\\n\\t      %s: \",\n                   tok2str(isis_subtlv_auth_values,\n                           \"unknown Authentication type 0x%02x\",\n                           *tptr)));\n\n\t    switch (*tptr) {\n\t    case ISIS_SUBTLV_AUTH_SIMPLE:\n\t\tif (fn_printzp(ndo, tptr + 1, tlv_len - 1, ndo->ndo_snapend))\n\t\t    goto trunctlv;\n\t\tbreak;\n\t    case ISIS_SUBTLV_AUTH_MD5:\n\t\tfor(i=1;i<tlv_len;i++) {\n\t\t    ND_TCHECK2(*(tptr + i), 1);\n\t\t    ND_PRINT((ndo, \"%02x\", *(tptr + i)));\n\t\t}\n\t\tif (tlv_len != ISIS_SUBTLV_AUTH_MD5_LEN+1)\n                    ND_PRINT((ndo, \", (invalid subTLV) \"));\n\n                sigcheck = signature_verify(ndo, optr, length, tptr + 1,\n                                            isis_clear_checksum_lifetime,\n                                            header_lsp);\n                ND_PRINT((ndo, \" (%s)\", tok2str(signature_check_values, \"Unknown\", sigcheck)));\n\n\t\tbreak;\n            case ISIS_SUBTLV_AUTH_GENERIC:\n\t\tND_TCHECK2(*(tptr + 1), 2);\n                key_id = EXTRACT_16BITS((tptr+1));\n                ND_PRINT((ndo, \"%u, password: \", key_id));\n                for(i=1 + sizeof(uint16_t);i<tlv_len;i++) {\n                    ND_TCHECK2(*(tptr + i), 1);\n                    ND_PRINT((ndo, \"%02x\", *(tptr + i)));\n                }\n                break;\n\t    case ISIS_SUBTLV_AUTH_PRIVATE:\n\t    default:\n\t\tif (!print_unknown_data(ndo, tptr + 1, \"\\n\\t\\t  \", tlv_len - 1))\n\t\t    return(0);\n\t\tbreak;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_PTP_ADJ:\n\t    tlv_ptp_adj = (const struct isis_tlv_ptp_adj *)tptr;\n\t    if(tmp>=1) {\n\t\tND_TCHECK2(*tptr, 1);\n\t\tND_PRINT((ndo, \"\\n\\t      Adjacency State: %s (%u)\",\n\t\t       tok2str(isis_ptp_adjancey_values, \"unknown\", *tptr),\n                        *tptr));\n\t\ttmp--;\n\t    }\n\t    if(tmp>sizeof(tlv_ptp_adj->extd_local_circuit_id)) {\n\t\tND_TCHECK(tlv_ptp_adj->extd_local_circuit_id);\n\t\tND_PRINT((ndo, \"\\n\\t      Extended Local circuit-ID: 0x%08x\",\n\t\t       EXTRACT_32BITS(tlv_ptp_adj->extd_local_circuit_id)));\n\t\ttmp-=sizeof(tlv_ptp_adj->extd_local_circuit_id);\n\t    }\n\t    if(tmp>=SYSTEM_ID_LEN) {\n\t\tND_TCHECK2(tlv_ptp_adj->neighbor_sysid, SYSTEM_ID_LEN);\n\t\tND_PRINT((ndo, \"\\n\\t      Neighbor System-ID: %s\",\n\t\t       isis_print_id(tlv_ptp_adj->neighbor_sysid, SYSTEM_ID_LEN)));\n\t\ttmp-=SYSTEM_ID_LEN;\n\t    }\n\t    if(tmp>=sizeof(tlv_ptp_adj->neighbor_extd_local_circuit_id)) {\n\t\tND_TCHECK(tlv_ptp_adj->neighbor_extd_local_circuit_id);\n\t\tND_PRINT((ndo, \"\\n\\t      Neighbor Extended Local circuit-ID: 0x%08x\",\n\t\t       EXTRACT_32BITS(tlv_ptp_adj->neighbor_extd_local_circuit_id)));\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_PROTOCOLS:\n\t    ND_PRINT((ndo, \"\\n\\t      NLPID(s): \"));\n\t    while (tmp>0) {\n\t\tND_TCHECK2(*(tptr), 1);\n\t\tND_PRINT((ndo, \"%s (0x%02x)\",\n                       tok2str(nlpid_values,\n                               \"unknown\",\n                               *tptr),\n                       *tptr));\n\t\tif (tmp>1) /* further NPLIDs ? - put comma */\n\t\t    ND_PRINT((ndo, \", \"));\n                tptr++;\n                tmp--;\n\t    }\n\t    break;\n\n    case ISIS_TLV_MT_PORT_CAP:\n    {\n      ND_TCHECK2(*(tptr), 2);\n\n      ND_PRINT((ndo, \"\\n\\t       RES: %d, MTID(s): %d\",\n              (EXTRACT_16BITS (tptr) >> 12),\n              (EXTRACT_16BITS (tptr) & 0x0fff)));\n\n      tmp = tmp-2;\n      tptr = tptr+2;\n\n      if (tmp)\n        isis_print_mt_port_cap_subtlv(ndo, tptr, tmp);\n\n      break;\n    }\n\n    case ISIS_TLV_MT_CAPABILITY:\n\n      ND_TCHECK2(*(tptr), 2);\n\n      ND_PRINT((ndo, \"\\n\\t      O: %d, RES: %d, MTID(s): %d\",\n                (EXTRACT_16BITS(tptr) >> 15) & 0x01,\n                (EXTRACT_16BITS(tptr) >> 12) & 0x07,\n                EXTRACT_16BITS(tptr) & 0x0fff));\n\n      tmp = tmp-2;\n      tptr = tptr+2;\n\n      if (tmp)\n        isis_print_mt_capability_subtlv(ndo, tptr, tmp);\n\n      break;\n\n\tcase ISIS_TLV_TE_ROUTER_ID:\n\t    ND_TCHECK2(*pptr, sizeof(struct in_addr));\n\t    ND_PRINT((ndo, \"\\n\\t      Traffic Engineering Router ID: %s\", ipaddr_string(ndo, pptr)));\n\t    break;\n\n\tcase ISIS_TLV_IPADDR:\n\t    while (tmp>=sizeof(struct in_addr)) {\n\t\tND_TCHECK2(*tptr, sizeof(struct in_addr));\n\t\tND_PRINT((ndo, \"\\n\\t      IPv4 interface address: %s\", ipaddr_string(ndo, tptr)));\n\t\ttptr += sizeof(struct in_addr);\n\t\ttmp -= sizeof(struct in_addr);\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_HOSTNAME:\n\t    ND_PRINT((ndo, \"\\n\\t      Hostname: \"));\n\t    if (fn_printzp(ndo, tptr, tmp, ndo->ndo_snapend))\n\t\tgoto trunctlv;\n\t    break;\n\n\tcase ISIS_TLV_SHARED_RISK_GROUP:\n\t    if (tmp < NODE_ID_LEN)\n\t        break;\n\t    ND_TCHECK2(*tptr, NODE_ID_LEN);\n\t    ND_PRINT((ndo, \"\\n\\t      IS Neighbor: %s\", isis_print_id(tptr, NODE_ID_LEN)));\n\t    tptr+=(NODE_ID_LEN);\n\t    tmp-=(NODE_ID_LEN);\n\n\t    if (tmp < 1)\n\t        break;\n\t    ND_TCHECK2(*tptr, 1);\n\t    ND_PRINT((ndo, \", Flags: [%s]\", ISIS_MASK_TLV_SHARED_RISK_GROUP(*tptr++) ? \"numbered\" : \"unnumbered\"));\n\t    tmp--;\n\n\t    if (tmp < sizeof(struct in_addr))\n\t        break;\n\t    ND_TCHECK2(*tptr, sizeof(struct in_addr));\n\t    ND_PRINT((ndo, \"\\n\\t      IPv4 interface address: %s\", ipaddr_string(ndo, tptr)));\n\t    tptr+=sizeof(struct in_addr);\n\t    tmp-=sizeof(struct in_addr);\n\n\t    if (tmp < sizeof(struct in_addr))\n\t        break;\n\t    ND_TCHECK2(*tptr, sizeof(struct in_addr));\n\t    ND_PRINT((ndo, \"\\n\\t      IPv4 neighbor address: %s\", ipaddr_string(ndo, tptr)));\n\t    tptr+=sizeof(struct in_addr);\n\t    tmp-=sizeof(struct in_addr);\n\n\t    while (tmp>=4) {\n                ND_TCHECK2(*tptr, 4);\n                ND_PRINT((ndo, \"\\n\\t      Link-ID: 0x%08x\", EXTRACT_32BITS(tptr)));\n                tptr+=4;\n                tmp-=4;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_LSP:\n\t    tlv_lsp = (const struct isis_tlv_lsp *)tptr;\n\t    while(tmp>=sizeof(struct isis_tlv_lsp)) {\n\t\tND_TCHECK((tlv_lsp->lsp_id)[LSP_ID_LEN-1]);\n\t\tND_PRINT((ndo, \"\\n\\t      lsp-id: %s\",\n                       isis_print_id(tlv_lsp->lsp_id, LSP_ID_LEN)));\n\t\tND_TCHECK2(tlv_lsp->sequence_number, 4);\n\t\tND_PRINT((ndo, \", seq: 0x%08x\", EXTRACT_32BITS(tlv_lsp->sequence_number)));\n\t\tND_TCHECK2(tlv_lsp->remaining_lifetime, 2);\n\t\tND_PRINT((ndo, \", lifetime: %5ds\", EXTRACT_16BITS(tlv_lsp->remaining_lifetime)));\n\t\tND_TCHECK2(tlv_lsp->checksum, 2);\n\t\tND_PRINT((ndo, \", chksum: 0x%04x\", EXTRACT_16BITS(tlv_lsp->checksum)));\n\t\ttmp-=sizeof(struct isis_tlv_lsp);\n\t\ttlv_lsp++;\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_CHECKSUM:\n\t    if (tmp < ISIS_TLV_CHECKSUM_MINLEN)\n\t        break;\n\t    ND_TCHECK2(*tptr, ISIS_TLV_CHECKSUM_MINLEN);\n\t    ND_PRINT((ndo, \"\\n\\t      checksum: 0x%04x \", EXTRACT_16BITS(tptr)));\n            /* do not attempt to verify the checksum if it is zero\n             * most likely a HMAC-MD5 TLV is also present and\n             * to avoid conflicts the checksum TLV is zeroed.\n             * see rfc3358 for details\n             */\n            osi_print_cksum(ndo, optr, EXTRACT_16BITS(tptr), tptr-optr,\n                length);\n\t    break;\n\n\tcase ISIS_TLV_POI:\n\t    if (tlv_len >= SYSTEM_ID_LEN + 1) {\n\t\tND_TCHECK2(*tptr, SYSTEM_ID_LEN + 1);\n\t\tND_PRINT((ndo, \"\\n\\t      Purge Originator System-ID: %s\",\n\t\t       isis_print_id(tptr + 1, SYSTEM_ID_LEN)));\n\t    }\n\n\t    if (tlv_len == 2 * SYSTEM_ID_LEN + 1) {\n\t\tND_TCHECK2(*tptr, 2 * SYSTEM_ID_LEN + 1);\n\t\tND_PRINT((ndo, \"\\n\\t      Received from System-ID: %s\",\n\t\t       isis_print_id(tptr + SYSTEM_ID_LEN + 1, SYSTEM_ID_LEN)));\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_MT_SUPPORTED:\n            if (tmp < ISIS_TLV_MT_SUPPORTED_MINLEN)\n                break;\n\t    while (tmp>1) {\n\t\t/* length can only be a multiple of 2, otherwise there is\n\t\t   something broken -> so decode down until length is 1 */\n\t\tif (tmp!=1) {\n                    mt_len = isis_print_mtid(ndo, tptr, \"\\n\\t      \");\n                    if (mt_len == 0) /* did something go wrong ? */\n                        goto trunctlv;\n                    tptr+=mt_len;\n                    tmp-=mt_len;\n\t\t} else {\n\t\t    ND_PRINT((ndo, \"\\n\\t      invalid MT-ID\"));\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\n\tcase ISIS_TLV_RESTART_SIGNALING:\n            /* first attempt to decode the flags */\n            if (tmp < ISIS_TLV_RESTART_SIGNALING_FLAGLEN)\n                break;\n            ND_TCHECK2(*tptr, ISIS_TLV_RESTART_SIGNALING_FLAGLEN);\n            ND_PRINT((ndo, \"\\n\\t      Flags [%s]\",\n                   bittok2str(isis_restart_flag_values, \"none\", *tptr)));\n            tptr+=ISIS_TLV_RESTART_SIGNALING_FLAGLEN;\n            tmp-=ISIS_TLV_RESTART_SIGNALING_FLAGLEN;\n\n            /* is there anything other than the flags field? */\n            if (tmp == 0)\n                break;\n\n            if (tmp < ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN)\n                break;\n            ND_TCHECK2(*tptr, ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN);\n\n            ND_PRINT((ndo, \", Remaining holding time %us\", EXTRACT_16BITS(tptr)));\n            tptr+=ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN;\n            tmp-=ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN;\n\n            /* is there an additional sysid field present ?*/\n            if (tmp == SYSTEM_ID_LEN) {\n                    ND_TCHECK2(*tptr, SYSTEM_ID_LEN);\n                    ND_PRINT((ndo, \", for %s\", isis_print_id(tptr,SYSTEM_ID_LEN)));\n            }\n\t    break;\n\n        case ISIS_TLV_IDRP_INFO:\n\t    if (tmp < ISIS_TLV_IDRP_INFO_MINLEN)\n\t        break;\n            ND_TCHECK2(*tptr, ISIS_TLV_IDRP_INFO_MINLEN);\n            ND_PRINT((ndo, \"\\n\\t      Inter-Domain Information Type: %s\",\n                   tok2str(isis_subtlv_idrp_values,\n                           \"Unknown (0x%02x)\",\n                           *tptr)));\n            switch (*tptr++) {\n            case ISIS_SUBTLV_IDRP_ASN:\n                ND_TCHECK2(*tptr, 2); /* fetch AS number */\n                ND_PRINT((ndo, \"AS Number: %u\", EXTRACT_16BITS(tptr)));\n                break;\n            case ISIS_SUBTLV_IDRP_LOCAL:\n            case ISIS_SUBTLV_IDRP_RES:\n            default:\n                if (!print_unknown_data(ndo, tptr, \"\\n\\t      \", tlv_len - 1))\n                    return(0);\n                break;\n            }\n            break;\n\n        case ISIS_TLV_LSP_BUFFERSIZE:\n\t    if (tmp < ISIS_TLV_LSP_BUFFERSIZE_MINLEN)\n\t        break;\n            ND_TCHECK2(*tptr, ISIS_TLV_LSP_BUFFERSIZE_MINLEN);\n            ND_PRINT((ndo, \"\\n\\t      LSP Buffersize: %u\", EXTRACT_16BITS(tptr)));\n            break;\n\n        case ISIS_TLV_PART_DIS:\n            while (tmp >= SYSTEM_ID_LEN) {\n                ND_TCHECK2(*tptr, SYSTEM_ID_LEN);\n                ND_PRINT((ndo, \"\\n\\t      %s\", isis_print_id(tptr, SYSTEM_ID_LEN)));\n                tptr+=SYSTEM_ID_LEN;\n                tmp-=SYSTEM_ID_LEN;\n            }\n            break;\n\n        case ISIS_TLV_PREFIX_NEIGH:\n\t    if (tmp < sizeof(struct isis_metric_block))\n\t        break;\n            ND_TCHECK2(*tptr, sizeof(struct isis_metric_block));\n            ND_PRINT((ndo, \"\\n\\t      Metric Block\"));\n            isis_print_metric_block(ndo, (const struct isis_metric_block *)tptr);\n            tptr+=sizeof(struct isis_metric_block);\n            tmp-=sizeof(struct isis_metric_block);\n\n            while(tmp>0) {\n                ND_TCHECK2(*tptr, 1);\n                prefix_len=*tptr++; /* read out prefix length in semioctets*/\n                if (prefix_len < 2) {\n                    ND_PRINT((ndo, \"\\n\\t\\tAddress: prefix length %u < 2\", prefix_len));\n                    break;\n                }\n                tmp--;\n                if (tmp < prefix_len/2)\n                    break;\n                ND_TCHECK2(*tptr, prefix_len / 2);\n                ND_PRINT((ndo, \"\\n\\t\\tAddress: %s/%u\",\n                       isonsap_string(ndo, tptr, prefix_len / 2), prefix_len * 4));\n                tptr+=prefix_len/2;\n                tmp-=prefix_len/2;\n            }\n            break;\n\n        case ISIS_TLV_IIH_SEQNR:\n\t    if (tmp < ISIS_TLV_IIH_SEQNR_MINLEN)\n\t        break;\n            ND_TCHECK2(*tptr, ISIS_TLV_IIH_SEQNR_MINLEN); /* check if four bytes are on the wire */\n            ND_PRINT((ndo, \"\\n\\t      Sequence number: %u\", EXTRACT_32BITS(tptr)));\n            break;\n\n        case ISIS_TLV_VENDOR_PRIVATE:\n\t    if (tmp < ISIS_TLV_VENDOR_PRIVATE_MINLEN)\n\t        break;\n            ND_TCHECK2(*tptr, ISIS_TLV_VENDOR_PRIVATE_MINLEN); /* check if enough byte for a full oui */\n            vendor_id = EXTRACT_24BITS(tptr);\n            ND_PRINT((ndo, \"\\n\\t      Vendor: %s (%u)\",\n                   tok2str(oui_values, \"Unknown\", vendor_id),\n                   vendor_id));\n            tptr+=3;\n            tmp-=3;\n            if (tmp > 0) /* hexdump the rest */\n                if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t\", tmp))\n                    return(0);\n            break;\n            /*\n             * FIXME those are the defined TLVs that lack a decoder\n             * you are welcome to contribute code ;-)\n             */\n\n        case ISIS_TLV_DECNET_PHASE4:\n        case ISIS_TLV_LUCENT_PRIVATE:\n        case ISIS_TLV_IPAUTH:\n        case ISIS_TLV_NORTEL_PRIVATE1:\n        case ISIS_TLV_NORTEL_PRIVATE2:\n\n\tdefault:\n\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\tif (!print_unknown_data(ndo, pptr, \"\\n\\t\\t\", tlv_len))\n\t\t\t\treturn(0);\n\t\t}\n\t\tbreak;\n\t}\n        /* do we want to see an additionally hexdump ? */\n\tif (ndo->ndo_vflag> 1) {\n\t\tif (!print_unknown_data(ndo, pptr, \"\\n\\t      \", tlv_len))\n\t\t\treturn(0);\n\t}\n\n\tpptr += tlv_len;\n\tpacket_len -= tlv_len;\n    }\n\n    if (packet_len != 0) {\n\tND_PRINT((ndo, \"\\n\\t      %u straggler bytes\", packet_len));\n    }\n    return (1);\n\n trunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n    return (1);\n\n trunctlv:\n    ND_PRINT((ndo, \"\\n\\t\\t\"));\n    ND_PRINT((ndo, \"%s\", tstr));\n    return(1);\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\tND_PRINT((ndo, \"\\n\\t      Area address (length: %u): %s\",\n\n```\n\n\n\nwith the following test error:     isis-areaaddr-oobr-1               : TEST FAILED(exit 256)\n    isis-areaaddr-oobr-2               : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "3b32029db354cbc875127869d9b12a9addc75b50___print-isoclns.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic int\njuniper_parse_header(netdissect_options *ndo,\n                     const u_char *p, const struct pcap_pkthdr *h, struct juniper_l2info_t *l2info)\n{\n    const struct juniper_cookie_table_t *lp = juniper_cookie_table;\n    u_int idx, jnx_ext_len, jnx_header_len = 0;\n    uint8_t tlv_type,tlv_len;\n    uint32_t control_word;\n    int tlv_value;\n    const u_char *tptr;\n\n\n    l2info->header_len = 0;\n    l2info->cookie_len = 0;\n    l2info->proto = 0;\n\n\n    l2info->length = h->len;\n    l2info->caplen = h->caplen;\n    ND_TCHECK2(p[0], 4);\n    l2info->flags = p[3];\n    l2info->direction = p[3]&JUNIPER_BPF_PKT_IN;\n\n    if (EXTRACT_24BITS(p) != JUNIPER_MGC_NUMBER) { /* magic number found ? */\n        ND_PRINT((ndo, \"no magic-number found!\"));\n        return 0;\n    }\n\n    if (ndo->ndo_eflag) /* print direction */\n        ND_PRINT((ndo, \"%3s \", tok2str(juniper_direction_values, \"---\", l2info->direction)));\n\n    /* magic number + flags */\n    jnx_header_len = 4;\n\n    if (ndo->ndo_vflag > 1)\n        ND_PRINT((ndo, \"\\n\\tJuniper PCAP Flags [%s]\",\n               bittok2str(jnx_flag_values, \"none\", l2info->flags)));\n\n    /* extensions present ?  - calculate how much bytes to skip */\n    if ((l2info->flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) {\n\n        tptr = p+jnx_header_len;\n\n        /* ok to read extension length ? */\n        ND_TCHECK2(tptr[0], 2);\n        jnx_ext_len = EXTRACT_16BITS(tptr);\n        jnx_header_len += 2;\n        tptr +=2;\n\n        /* nail up the total length -\n         * just in case something goes wrong\n         * with TLV parsing */\n        jnx_header_len += jnx_ext_len;\n\n        if (ndo->ndo_vflag > 1)\n            ND_PRINT((ndo, \", PCAP Extension(s) total length %u\", jnx_ext_len));\n\n        ND_TCHECK2(tptr[0], jnx_ext_len);\n        while (jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD) {\n            tlv_type = *(tptr++);\n            tlv_len = *(tptr++);\n            tlv_value = 0;\n\n            /* sanity checks */\n            if (tlv_type == 0 || tlv_len == 0)\n                break;\n            if (tlv_len+JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len)\n                goto trunc;\n\n            if (ndo->ndo_vflag > 1)\n                ND_PRINT((ndo, \"\\n\\t  %s Extension TLV #%u, length %u, value \",\n                       tok2str(jnx_ext_tlv_values,\"Unknown\",tlv_type),\n                       tlv_type,\n                       tlv_len));\n\n            tlv_value = juniper_read_tlv_value(tptr, tlv_type, tlv_len);\n            switch (tlv_type) {\n            case JUNIPER_EXT_TLV_IFD_NAME:\n                /* FIXME */\n                break;\n            case JUNIPER_EXT_TLV_IFD_MEDIATYPE:\n            case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%s (%u)\",\n                               tok2str(juniper_ifmt_values, \"Unknown\", tlv_value),\n                               tlv_value));\n                }\n                break;\n            case JUNIPER_EXT_TLV_IFL_ENCAPS:\n            case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%s (%u)\",\n                               tok2str(juniper_ifle_values, \"Unknown\", tlv_value),\n                               tlv_value));\n                }\n                break;\n            case JUNIPER_EXT_TLV_IFL_IDX: /* fall through */\n            case JUNIPER_EXT_TLV_IFL_UNIT:\n            case JUNIPER_EXT_TLV_IFD_IDX:\n            default:\n                if (tlv_value != -1) {\n                    if (ndo->ndo_vflag > 1)\n                        ND_PRINT((ndo, \"%u\", tlv_value));\n                }\n                break;\n            }\n\n            tptr+=tlv_len;\n            jnx_ext_len -= tlv_len+JUNIPER_EXT_TLV_OVERHEAD;\n        }\n\n        if (ndo->ndo_vflag > 1)\n            ND_PRINT((ndo, \"\\n\\t-----original packet-----\\n\\t\"));\n    }\n\n    if ((l2info->flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) {\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"no-L2-hdr, \"));\n\n        /* there is no link-layer present -\n         * perform the v4/v6 heuristics\n         * to figure out what it is\n         */\n        ND_TCHECK2(p[jnx_header_len + 4], 1);\n        if (ip_heuristic_guess(ndo, p + jnx_header_len + 4,\n                               l2info->length - (jnx_header_len + 4)) == 0)\n            ND_PRINT((ndo, \"no IP-hdr found!\"));\n\n        l2info->header_len=jnx_header_len+4;\n        return 0; /* stop parsing the output further */\n\n    }\n    l2info->header_len = jnx_header_len;\n    p+=l2info->header_len;\n    l2info->length -= l2info->header_len;\n    l2info->caplen -= l2info->header_len;\n\n    /* search through the cookie table and copy values matching for our PIC type */\n    ND_TCHECK(p[0]);\n    while (lp->s != NULL) {\n        if (lp->pictype == l2info->pictype) {\n\n            l2info->cookie_len += lp->cookie_len;\n\n            switch (p[0]) {\n            case LS_COOKIE_ID:\n                l2info->cookie_type = LS_COOKIE_ID;\n                l2info->cookie_len += 2;\n                break;\n            case AS_COOKIE_ID:\n                l2info->cookie_type = AS_COOKIE_ID;\n                l2info->cookie_len = 8;\n                break;\n\n            default:\n                l2info->bundle = l2info->cookie[0];\n                break;\n            }\n\n\n#ifdef DLT_JUNIPER_MFR\n            /* MFR child links don't carry cookies */\n            if (l2info->pictype == DLT_JUNIPER_MFR &&\n                (p[0] & MFR_BE_MASK) == MFR_BE_MASK) {\n                l2info->cookie_len = 0;\n            }\n#endif\n\n            l2info->header_len += l2info->cookie_len;\n            l2info->length -= l2info->cookie_len;\n            l2info->caplen -= l2info->cookie_len;\n\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"%s-PIC, cookie-len %u\",\n                       lp->s,\n                       l2info->cookie_len));\n\n            if (l2info->cookie_len > 0) {\n                ND_TCHECK2(p[0], l2info->cookie_len);\n                if (ndo->ndo_eflag)\n                    ND_PRINT((ndo, \", cookie 0x\"));\n                for (idx = 0; idx < l2info->cookie_len; idx++) {\n                    l2info->cookie[idx] = p[idx]; /* copy cookie data */\n                    if (ndo->ndo_eflag) ND_PRINT((ndo, \"%02x\", p[idx]));\n                }\n            }\n\n            if (ndo->ndo_eflag) ND_PRINT((ndo, \": \")); /* print demarc b/w L2/L3*/\n\n\n\n>>> [ INFILL ] <<<\n            break;\n        }\n        ++lp;\n    }\n    p+=l2info->cookie_len;\n\n    /* DLT_ specific parsing */\n    switch(l2info->pictype) {\n#ifdef DLT_JUNIPER_MLPPP\n    case DLT_JUNIPER_MLPPP:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            l2info->bundle = l2info->cookie[1];\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_MLFR\n    case DLT_JUNIPER_MLFR:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            ND_TCHECK2(p[0], 2);\n            l2info->bundle = l2info->cookie[1];\n            l2info->proto = EXTRACT_16BITS(p);\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_MFR\n    case DLT_JUNIPER_MFR:\n        switch (l2info->cookie_type) {\n        case LS_COOKIE_ID:\n            ND_TCHECK2(p[0], 2);\n            l2info->bundle = l2info->cookie[1];\n            l2info->proto = EXTRACT_16BITS(p);\n            l2info->header_len += 2;\n            l2info->length -= 2;\n            l2info->caplen -= 2;\n            break;\n        case AS_COOKIE_ID:\n            l2info->bundle = (EXTRACT_16BITS(&l2info->cookie[6])>>3)&0xfff;\n            l2info->proto = (l2info->cookie[5])&JUNIPER_LSQ_L3_PROTO_MASK;\n            break;\n        default:\n            l2info->bundle = l2info->cookie[0];\n            break;\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_ATM2\n    case DLT_JUNIPER_ATM2:\n        ND_TCHECK2(p[0], 4);\n        /* ATM cell relay control word present ? */\n        if (l2info->cookie[7] & ATM2_PKT_TYPE_MASK) {\n            control_word = EXTRACT_32BITS(p);\n            /* some control word heuristics */\n            switch(control_word) {\n            case 0: /* zero control word */\n            case 0x08000000: /* < JUNOS 7.4 control-word */\n            case 0x08380000: /* cntl word plus cell length (56) >= JUNOS 7.4*/\n                l2info->header_len += 4;\n                break;\n            default:\n                break;\n            }\n\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"control-word 0x%08x \", control_word));\n        }\n        break;\n#endif\n#ifdef DLT_JUNIPER_GGSN\n    case DLT_JUNIPER_GGSN:\n        break;\n#endif\n#ifdef DLT_JUNIPER_ATM1\n    case DLT_JUNIPER_ATM1:\n        break;\n#endif\n#ifdef DLT_JUNIPER_PPP\n    case DLT_JUNIPER_PPP:\n        break;\n#endif\n#ifdef DLT_JUNIPER_CHDLC\n    case DLT_JUNIPER_CHDLC:\n        break;\n#endif\n#ifdef DLT_JUNIPER_ETHER\n    case DLT_JUNIPER_ETHER:\n        break;\n#endif\n#ifdef DLT_JUNIPER_FRELAY\n    case DLT_JUNIPER_FRELAY:\n        break;\n#endif\n\n    default:\n        ND_PRINT((ndo, \"Unknown Juniper DLT_ type %u: \", l2info->pictype));\n        break;\n    }\n\n    if (ndo->ndo_eflag > 1)\n        ND_PRINT((ndo, \"hlen %u, proto 0x%04x, \", l2info->header_len, l2info->proto));\n\n    return 1; /* everything went ok so far. continue parsing */\n trunc:\n    ND_PRINT((ndo, \"[|juniper_hdr], length %u\", h->len));\n    return 0;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n            l2info->proto = EXTRACT_16BITS(p+l2info->cookie_len);\n\n```\n\n\n\nwith the following test error:     juniper_atm1                       : TEST FAILED(exit 256)\n    juniper_es                         : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "42073d54c53a496be40ae84152bbfe2c923ac7bc___print-juniper.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nvoid\nicmp_print(netdissect_options *ndo, const u_char *bp, u_int plen, const u_char *bp2,\n           int fragmented)\n{\n\tchar *cp;\n\tconst struct icmp *dp;\n        const struct icmp_ext_t *ext_dp;\n\tconst struct ip *ip;\n\tconst char *str, *fmt;\n\tconst struct ip *oip;\n\tconst struct udphdr *ouh;\n        const uint8_t *obj_tptr;\n        uint32_t raw_label;\n        const u_char *snapend_save;\n\tconst struct icmp_mpls_ext_object_header_t *icmp_mpls_ext_object_header;\n\tu_int hlen, dport, mtu, obj_tlen, obj_class_num, obj_ctype;\n\tchar buf[MAXHOSTNAMELEN + 100];\n\tstruct cksum_vec vec[1];\n\n\tdp = (const struct icmp *)bp;\n        ext_dp = (const struct icmp_ext_t *)bp;\n\tip = (const struct ip *)bp2;\n\tstr = buf;\n\n\tND_TCHECK(dp->icmp_code);\n\tswitch (dp->icmp_type) {\n\n\tcase ICMP_ECHO:\n\tcase ICMP_ECHOREPLY:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf), \"echo %s, id %u, seq %u\",\n                               dp->icmp_type == ICMP_ECHO ?\n                               \"request\" : \"reply\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_UNREACH:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_UNREACH_PROTOCOL:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"%s protocol %d unreachable\",\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t\t    dp->icmp_ip.ip_p);\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_PORT:\n\t\t\tND_TCHECK(dp->icmp_ip.ip_p);\n\t\t\toip = &dp->icmp_ip;\n\t\t\thlen = IP_HL(oip) * 4;\n\t\t\touh = (const struct udphdr *)(((const u_char *)oip) + hlen);\n\t\t\tND_TCHECK(ouh->uh_dport);\n\t\t\tdport = EXTRACT_16BITS(&ouh->uh_dport);\n\t\t\tswitch (oip->ip_p) {\n\n\t\t\tcase IPPROTO_TCP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s tcp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\ttcpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tcase IPPROTO_UDP:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s udp port %s unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\tudpport_string(ndo, dport));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t\t\"%s protocol %d port %d unreachable\",\n\t\t\t\t\tipaddr_string(ndo, &oip->ip_dst),\n\t\t\t\t\toip->ip_p, dport);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ICMP_UNREACH_NEEDFRAG:\n\t\t    {\n\t\t\tregister const struct mtu_discovery *mp;\n\t\t\tmp = (const struct mtu_discovery *)(const u_char *)&dp->icmp_void;\n\t\t\tmtu = EXTRACT_16BITS(&mp->nexthopmtu);\n\t\t\tif (mtu) {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag (mtu %d)\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst), mtu);\n\t\t\t} else {\n\t\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t\t    \"%s unreachable - need to frag\",\n\t\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\t}\n\t\t    }\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmt = tok2str(unreach2str, \"#%d %%s unreachable\",\n\t\t\t    dp->icmp_code);\n\t\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_REDIRECT:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tfmt = tok2str(type2str, \"redirect-#%d %%s to net %%s\",\n\t\t    dp->icmp_code);\n\t\t(void)snprintf(buf, sizeof(buf), fmt,\n\t\t    ipaddr_string(ndo, &dp->icmp_ip.ip_dst),\n\t\t    ipaddr_string(ndo, &dp->icmp_gwaddr));\n\t\tbreak;\n\n\tcase ICMP_ROUTERADVERT:\n\t    {\n\t\tregister const struct ih_rdiscovery *ihp;\n\t\tregister const struct id_rdiscovery *idp;\n\t\tu_int lifetime, num, size;\n\n\t\t(void)snprintf(buf, sizeof(buf), \"router advertisement\");\n\t\tcp = buf + strlen(buf);\n\n\t\tihp = (const struct ih_rdiscovery *)&dp->icmp_void;\n\t\tND_TCHECK(*ihp);\n\t\t(void)strncpy(cp, \" lifetime \", sizeof(buf) - (cp - buf));\n\t\tcp = buf + strlen(buf);\n\t\tlifetime = EXTRACT_16BITS(&ihp->ird_lifetime);\n\t\tif (lifetime < 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u\",\n\t\t\t    lifetime);\n\t\t} else if (lifetime < 60 * 60) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \"%u:%02u\",\n\t\t\t    lifetime / 60, lifetime % 60);\n\t\t} else {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \"%u:%02u:%02u\",\n\t\t\t    lifetime / 3600,\n\t\t\t    (lifetime % 3600) / 60,\n\t\t\t    lifetime % 60);\n\t\t}\n\t\tcp = buf + strlen(buf);\n\n\t\tnum = ihp->ird_addrnum;\n\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" %d:\", num);\n\t\tcp = buf + strlen(buf);\n\n\t\tsize = ihp->ird_addrsiz;\n\t\tif (size != 2) {\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf),\n\t\t\t    \" [size %d]\", size);\n\t\t\tbreak;\n\t\t}\n\t\tidp = (const struct id_rdiscovery *)&dp->icmp_data;\n\t\twhile (num-- > 0) {\n\t\t\tND_TCHECK(*idp);\n\t\t\t(void)snprintf(cp, sizeof(buf) - (cp - buf), \" {%s %u}\",\n\t\t\t    ipaddr_string(ndo, &idp->ird_addr),\n\t\t\t    EXTRACT_32BITS(&idp->ird_pref));\n\t\t\tcp = buf + strlen(buf);\n\t\t\t++idp;\n\t\t}\n\t    }\n\t\tbreak;\n\n\tcase ICMP_TIMXCEED:\n\t\tND_TCHECK(dp->icmp_ip.ip_dst);\n\t\tswitch (dp->icmp_code) {\n\n\t\tcase ICMP_TIMXCEED_INTRANS:\n\t\t\tstr = \"time exceeded in-transit\";\n\t\t\tbreak;\n\n\t\tcase ICMP_TIMXCEED_REASS:\n\t\t\tstr = \"ip reassembly time exceeded\";\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t(void)snprintf(buf, sizeof(buf), \"time exceeded-#%d\",\n\t\t\t    dp->icmp_code);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_PARAMPROB:\n\t\tif (dp->icmp_code)\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - code %d\", dp->icmp_code);\n\t\telse {\n\t\t\tND_TCHECK(dp->icmp_pptr);\n\t\t\t(void)snprintf(buf, sizeof(buf),\n\t\t\t    \"parameter problem - octet %d\", dp->icmp_pptr);\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_MASKREPLY:\n\t\tND_TCHECK(dp->icmp_mask);\n\t\t(void)snprintf(buf, sizeof(buf), \"address mask is 0x%08x\",\n\t\t    EXTRACT_32BITS(&dp->icmp_mask));\n\t\tbreak;\n\n\tcase ICMP_TSTAMP:\n\t\tND_TCHECK(dp->icmp_seq);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp query id %u seq %u\",\n\t\t    EXTRACT_16BITS(&dp->icmp_id),\n\t\t    EXTRACT_16BITS(&dp->icmp_seq));\n\t\tbreak;\n\n\tcase ICMP_TSTAMPREPLY:\n\t\tND_TCHECK(dp->icmp_ttime);\n\t\t(void)snprintf(buf, sizeof(buf),\n\t\t    \"time stamp reply id %u seq %u: org %s\",\n                               EXTRACT_16BITS(&dp->icmp_id),\n                               EXTRACT_16BITS(&dp->icmp_seq),\n                               icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_otime)));\n\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", recv %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_rtime)));\n                (void)snprintf(buf+strlen(buf),sizeof(buf)-strlen(buf),\", xmit %s\",\n                         icmp_tstamp_print(EXTRACT_32BITS(&dp->icmp_ttime)));\n                break;\n\n\tdefault:\n\t\tstr = tok2str(icmp2str, \"type-#%d\", dp->icmp_type);\n\t\tbreak;\n\t}\n\tND_PRINT((ndo, \"ICMP %s, length %u\", str, plen));\n\tif (ndo->ndo_vflag && !fragmented) { /* don't attempt checksumming if this is a frag */\n\t\tuint16_t sum, icmp_sum;\n\n\t\tif (ND_TTEST2(*bp, plen)) {\n\t\t\tvec[0].ptr = (const uint8_t *)(const void *)dp;\n\t\t\tvec[0].len = plen;\n\t\t\tsum = in_cksum(vec, 1);\n\t\t\tif (sum != 0) {\n\t\t\t\ticmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);\n\t\t\t\tND_PRINT((ndo, \" (wrong icmp cksum %x (->%x)!)\",\n\t\t\t\t\t     icmp_sum,\n\t\t\t\t\t     in_cksum_shouldbe(icmp_sum, sum)));\n\t\t\t}\n\t\t}\n\t}\n\n        /*\n         * print the remnants of the IP packet.\n         * save the snaplength as this may get overidden in the IP printer.\n         */\n\tif (ndo->ndo_vflag >= 1 && ICMP_ERRTYPE(dp->icmp_type)) {\n\t\tbp += 8;\n\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\tip = (const struct ip *)bp;\n                snapend_save = ndo->ndo_snapend;\n\n>>> [ INFILL ] <<<\n                ndo->ndo_snapend = snapend_save;\n\t}\n\n        /*\n         * Attempt to decode the MPLS extensions only for some ICMP types.\n         */\n        if (ndo->ndo_vflag >= 1 && plen > ICMP_EXTD_MINLEN && ICMP_MPLS_EXT_TYPE(dp->icmp_type)) {\n\n            ND_TCHECK(*ext_dp);\n\n            /*\n             * Check first if the mpls extension header shows a non-zero length.\n             * If the length field is not set then silently verify the checksum\n             * to check if an extension header is present. This is expedient,\n             * however not all implementations set the length field proper.\n             */\n            if (!ext_dp->icmp_length &&\n                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = plen - ICMP_EXTD_MINLEN;\n                if (in_cksum(vec, 1)) {\n                    return;\n                }\n            }\n\n            ND_PRINT((ndo, \"\\n\\tMPLS extension v%u\",\n                   ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res))));\n\n            /*\n             * Sanity checking of the header.\n             */\n            if (ICMP_MPLS_EXT_EXTRACT_VERSION(*(ext_dp->icmp_ext_version_res)) !=\n                ICMP_MPLS_EXT_VERSION) {\n                ND_PRINT((ndo, \" packet not supported\"));\n                return;\n            }\n\n            hlen = plen - ICMP_EXTD_MINLEN;\n            if (ND_TTEST2(ext_dp->icmp_ext_version_res, hlen)) {\n                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;\n                vec[0].len = hlen;\n                ND_PRINT((ndo, \", checksum 0x%04x (%scorrect), length %u\",\n                       EXTRACT_16BITS(ext_dp->icmp_ext_checksum),\n                       in_cksum(vec, 1) ? \"in\" : \"\",\n                       hlen));\n            }\n\n            hlen -= 4; /* subtract common header size */\n            obj_tptr = (const uint8_t *)ext_dp->icmp_ext_data;\n\n            while (hlen > sizeof(struct icmp_mpls_ext_object_header_t)) {\n\n                icmp_mpls_ext_object_header = (const struct icmp_mpls_ext_object_header_t *)obj_tptr;\n                ND_TCHECK(*icmp_mpls_ext_object_header);\n                obj_tlen = EXTRACT_16BITS(icmp_mpls_ext_object_header->length);\n                obj_class_num = icmp_mpls_ext_object_header->class_num;\n                obj_ctype = icmp_mpls_ext_object_header->ctype;\n                obj_tptr += sizeof(struct icmp_mpls_ext_object_header_t);\n\n                ND_PRINT((ndo, \"\\n\\t  %s Object (%u), Class-Type: %u, length %u\",\n                       tok2str(icmp_mpls_ext_obj_values,\"unknown\",obj_class_num),\n                       obj_class_num,\n                       obj_ctype,\n                       obj_tlen));\n\n                hlen-=sizeof(struct icmp_mpls_ext_object_header_t); /* length field includes tlv header */\n\n                /* infinite loop protection */\n                if ((obj_class_num == 0) ||\n                    (obj_tlen < sizeof(struct icmp_mpls_ext_object_header_t))) {\n                    return;\n                }\n                obj_tlen-=sizeof(struct icmp_mpls_ext_object_header_t);\n\n                switch (obj_class_num) {\n                case 1:\n                    switch(obj_ctype) {\n                    case 1:\n                        ND_TCHECK2(*obj_tptr, 4);\n                        raw_label = EXTRACT_32BITS(obj_tptr);\n                        ND_PRINT((ndo, \"\\n\\t    label %u, exp %u\", MPLS_LABEL(raw_label), MPLS_EXP(raw_label)));\n                        if (MPLS_STACK(raw_label))\n                            ND_PRINT((ndo, \", [S]\"));\n                        ND_PRINT((ndo, \", ttl %u\", MPLS_TTL(raw_label)));\n                        break;\n                    default:\n                        print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    }\n                    break;\n\n               /*\n                *  FIXME those are the defined objects that lack a decoder\n                *  you are welcome to contribute code ;-)\n                */\n                case 2:\n                default:\n                    print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen);\n                    break;\n                }\n                if (hlen < obj_tlen)\n                    break;\n                hlen -= obj_tlen;\n                obj_tptr += obj_tlen;\n            }\n        }\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"[|icmp]\"));\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\tip_print(ndo, bp, EXTRACT_16BITS(&ip->ip_len));\n\n```\n\n\n\nwith the following test error:     extract_read2_asan                 : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "8509ef02eceb2bbb479cea10fe4a7ec6395f1a8b___print-icmp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic void\ndhcp6opt_print(netdissect_options *ndo,\n               const u_char *cp, const u_char *ep)\n{\n\tconst struct dhcp6opt *dh6o;\n\tconst u_char *tp;\n\tsize_t i;\n\tuint16_t opttype;\n\tsize_t optlen;\n\tuint8_t auth_proto;\n\tu_int authinfolen, authrealmlen;\n\tint remain_len;  /* Length of remaining options */\n\tint label_len;   /* Label length */\n\tuint16_t subopt_code;\n\tuint16_t subopt_len;\n\n\tif (cp == ep)\n\t\treturn;\n\twhile (cp < ep) {\n\t\tif (ep < cp + sizeof(*dh6o))\n\t\t\tgoto trunc;\n\t\tdh6o = (const struct dhcp6opt *)cp;\n\t\tND_TCHECK(*dh6o);\n\t\toptlen = EXTRACT_16BITS(&dh6o->dh6opt_len);\n\t\tif (ep < cp + sizeof(*dh6o) + optlen)\n\t\t\tgoto trunc;\n\t\topttype = EXTRACT_16BITS(&dh6o->dh6opt_type);\n\t\tND_PRINT((ndo, \" (%s\", tok2str(dh6opt_str, \"opt_%u\", opttype)));\n\t\tND_TCHECK2(*(cp + sizeof(*dh6o)), optlen);\n\t\tswitch (opttype) {\n\t\tcase DH6OPT_CLIENTID:\n\t\tcase DH6OPT_SERVERID:\n\t\t\tif (optlen < 2) {\n\t\t\t\t/*(*/\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tswitch (EXTRACT_16BITS(tp)) {\n\t\t\tcase 1:\n\t\t\t\tif (optlen >= 2 + 6) {\n\t\t\t\t\tND_PRINT((ndo, \" hwaddr/time type %u time %u \",\n\t\t\t\t\t    EXTRACT_16BITS(&tp[2]),\n\t\t\t\t\t    EXTRACT_32BITS(&tp[4])));\n\t\t\t\t\tfor (i = 8; i < optlen; i++)\n\t\t\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \")\"));\n\t\t\t\t} else {\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (optlen >= 2 + 8) {\n\t\t\t\t\tND_PRINT((ndo, \" vid \"));\n\t\t\t\t\tfor (i = 2; i < 2 + 8; i++)\n\t\t\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \")\"));\n\t\t\t\t} else {\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (optlen >= 2 + 2) {\n\t\t\t\t\tND_PRINT((ndo, \" hwaddr type %u \",\n\t\t\t\t\t    EXTRACT_16BITS(&tp[2])));\n\t\t\t\t\tfor (i = 4; i < optlen; i++)\n\t\t\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \")\"));\n\t\t\t\t} else {\n\t\t\t\t\t/*(*/\n\t\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" type %d)\", EXTRACT_16BITS(tp)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_ADDR:\n\t\t\tif (optlen < 24) {\n\t\t\t\t/*(*/\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[0])));\n\t\t\tND_PRINT((ndo, \" pltime:%u vltime:%u\",\n\t\t\t    EXTRACT_32BITS(&tp[16]),\n\t\t\t    EXTRACT_32BITS(&tp[20])));\n\t\t\tif (optlen > 24) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 24, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_ORO:\n\t\tcase DH6OPT_ERO:\n\t\t\tif (optlen % 2) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tfor (i = 0; i < optlen; i += 2) {\n\t\t\t\tND_PRINT((ndo, \" %s\",\n\t\t\t\t    tok2str(dh6opt_str, \"opt_%u\", EXTRACT_16BITS(&tp[i]))));\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_PREFERENCE:\n\t\t\tif (optlen != 1) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d)\", *tp));\n\t\t\tbreak;\n\t\tcase DH6OPT_ELAPSED_TIME:\n\t\t\tif (optlen != 2) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d)\", EXTRACT_16BITS(tp)));\n\t\t\tbreak;\n\t\tcase DH6OPT_RELAY_MSG:\n\t\t\tND_PRINT((ndo, \" (\"));\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tdhcp6_print(ndo, tp, optlen);\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_AUTH:\n\t\t\tif (optlen < 11) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tauth_proto = *tp;\n\t\t\tswitch (auth_proto) {\n\t\t\tcase DH6OPT_AUTHPROTO_DELAYED:\n\t\t\t\tND_PRINT((ndo, \" proto: delayed\"));\n\t\t\t\tbreak;\n\t\t\tcase DH6OPT_AUTHPROTO_RECONFIG:\n\t\t\t\tND_PRINT((ndo, \" proto: reconfigure\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" proto: %d\", auth_proto));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp++;\n\t\t\tswitch (*tp) {\n\t\t\tcase DH6OPT_AUTHALG_HMACMD5:\n\t\t\t\t/* XXX: may depend on the protocol */\n\t\t\t\tND_PRINT((ndo, \", alg: HMAC-MD5\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \", alg: %d\", *tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp++;\n\t\t\tswitch (*tp) {\n\t\t\tcase DH6OPT_AUTHRDM_MONOCOUNTER:\n\t\t\t\tND_PRINT((ndo, \", RDM: mono\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \", RDM: %d\", *tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp++;\n\t\t\tND_PRINT((ndo, \", RD:\"));\n\t\t\tfor (i = 0; i < 4; i++, tp += 2)\n\t\t\t\tND_PRINT((ndo, \" %04x\", EXTRACT_16BITS(tp)));\n\n\t\t\t/* protocol dependent part */\n\t\t\tauthinfolen = optlen - 11;\n\t\t\tswitch (auth_proto) {\n\t\t\tcase DH6OPT_AUTHPROTO_DELAYED:\n\t\t\t\tif (authinfolen == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (authinfolen < 20) {\n\t\t\t\t\tND_PRINT((ndo, \" ??\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tauthrealmlen = authinfolen - 20;\n\t\t\t\tif (authrealmlen > 0) {\n\t\t\t\t\tND_PRINT((ndo, \", realm: \"));\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < authrealmlen; i++, tp++)\n\t\t\t\t\tND_PRINT((ndo, \"%02x\", *tp));\n\t\t\t\tND_PRINT((ndo, \", key ID: %08x\", EXTRACT_32BITS(tp)));\n\t\t\t\ttp += 4;\n\t\t\t\tND_PRINT((ndo, \", HMAC-MD5:\"));\n\t\t\t\tfor (i = 0; i < 4; i++, tp+= 4)\n\t\t\t\t\tND_PRINT((ndo, \" %08x\", EXTRACT_32BITS(tp)));\n\t\t\t\tbreak;\n\t\t\tcase DH6OPT_AUTHPROTO_RECONFIG:\n\t\t\t\tif (authinfolen != 17) {\n\t\t\t\t\tND_PRINT((ndo, \" ??\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (*tp++) {\n\t\t\t\tcase DH6OPT_AUTHRECONFIG_KEY:\n\t\t\t\t\tND_PRINT((ndo, \" reconfig-key\"));\n\t\t\t\t\tbreak;\n\t\t\t\tcase DH6OPT_AUTHRECONFIG_HMACMD5:\n\t\t\t\t\tND_PRINT((ndo, \" type: HMAC-MD5\"));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tND_PRINT((ndo, \" type: ??\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tND_PRINT((ndo, \" value:\"));\n\t\t\t\tfor (i = 0; i < 4; i++, tp+= 4)\n\t\t\t\t\tND_PRINT((ndo, \" %08x\", EXTRACT_32BITS(tp)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" ??\"));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_RAPID_COMMIT: /* nothing todo */\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_INTERFACE_ID:\n\t\tcase DH6OPT_SUBSCRIBER_ID:\n\t\t\t/*\n\t\t\t * Since we cannot predict the encoding, print hex dump\n\t\t\t * at most 10 characters.\n\t\t\t */\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" \"));\n\t\t\tfor (i = 0; i < optlen && i < 10; i++)\n\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_RECONF_MSG:\n\n>>> [ INFILL ] <<<\n\t\t\tswitch (*tp) {\n\t\t\tcase DH6_RENEW:\n\t\t\t\tND_PRINT((ndo, \" for renew)\"));\n\t\t\t\tbreak;\n\t\t\tcase DH6_INFORM_REQ:\n\t\t\t\tND_PRINT((ndo, \" for inf-req)\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" for ?\\?\\?(%02x))\", *tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DH6OPT_RECONF_ACCEPT: /* nothing todo */\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_SIP_SERVER_A:\n\t\tcase DH6OPT_DNS_SERVERS:\n\t\tcase DH6OPT_SNTP_SERVERS:\n\t\tcase DH6OPT_NIS_SERVERS:\n\t\tcase DH6OPT_NISP_SERVERS:\n\t\tcase DH6OPT_BCMCS_SERVER_A:\n\t\tcase DH6OPT_PANA_AGENT:\n\t\tcase DH6OPT_LQ_CLIENT_LINK:\n\t\t\tif (optlen % 16) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tfor (i = 0; i < optlen; i += 16)\n\t\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[i])));\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_SIP_SERVER_D:\n\t\tcase DH6OPT_DOMAIN_LIST:\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\twhile (tp < cp + sizeof(*dh6o) + optlen) {\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\t\tif ((tp = ns_nprint(ndo, tp, cp + sizeof(*dh6o) + optlen)) == NULL)\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_STATUS_CODE:\n\t\t\tif (optlen < 2) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s)\", dhcp6stcode(EXTRACT_16BITS(&tp[0]))));\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_NA:\n\t\tcase DH6OPT_IA_PD:\n\t\t\tif (optlen < 12) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" IAID:%u T1:%u T2:%u\",\n\t\t\t    EXTRACT_32BITS(&tp[0]),\n\t\t\t    EXTRACT_32BITS(&tp[4]),\n\t\t\t    EXTRACT_32BITS(&tp[8])));\n\t\t\tif (optlen > 12) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 12, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_TA:\n\t\t\tif (optlen < 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" IAID:%u\", EXTRACT_32BITS(tp)));\n\t\t\tif (optlen > 4) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 4, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_IA_PD_PREFIX:\n\t\t\tif (optlen < 25) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s/%d\", ip6addr_string(ndo, &tp[9]), tp[8]));\n\t\t\tND_PRINT((ndo, \" pltime:%u vltime:%u\",\n\t\t\t    EXTRACT_32BITS(&tp[0]),\n\t\t\t    EXTRACT_32BITS(&tp[4])));\n\t\t\tif (optlen > 25) {\n\t\t\t\t/* there are sub-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 25, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_LIFETIME:\n\t\tcase DH6OPT_CLT_TIME:\n\t\t\tif (optlen != 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d)\", EXTRACT_32BITS(tp)));\n\t\t\tbreak;\n\t\tcase DH6OPT_REMOTE_ID:\n\t\t\tif (optlen < 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %d \", EXTRACT_32BITS(tp)));\n\t\t\t/*\n\t\t\t * Print hex dump first 10 characters.\n\t\t\t */\n\t\t\tfor (i = 4; i < optlen && i < 14; i++)\n\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_LQ_QUERY:\n\t\t\tif (optlen < 17) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tswitch (*tp) {\n\t\t\tcase 1:\n\t\t\t\tND_PRINT((ndo, \" by-address\"));\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tND_PRINT((ndo, \" by-clientID\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \" type_%d\", (int)*tp));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[1])));\n\t\t\tif (optlen > 17) {\n\t\t\t\t/* there are query-options */\n\t\t\t\tdhcp6opt_print(ndo, tp + 17, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_CLIENT_DATA:\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tif (optlen > 0) {\n\t\t\t\t/* there are encapsulated options */\n\t\t\t\tdhcp6opt_print(ndo, tp, tp + optlen);\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_LQ_RELAY_DATA:\n\t\t\tif (optlen < 16) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \" %s \", ip6addr_string(ndo, &tp[0])));\n\t\t\t/*\n\t\t\t * Print hex dump first 10 characters.\n\t\t\t */\n\t\t\tfor (i = 16; i < optlen && i < 26; i++)\n\t\t\t\tND_PRINT((ndo, \"%02x\", tp[i]));\n\t\t\tND_PRINT((ndo, \"...)\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_NTP_SERVER:\n\t\t\tif (optlen < 4) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\twhile (tp < cp + sizeof(*dh6o) + optlen - 4) {\n\t\t\t\tsubopt_code = EXTRACT_16BITS(tp);\n\t\t\t\ttp += 2;\n\t\t\t\tsubopt_len = EXTRACT_16BITS(tp);\n\t\t\t\ttp += 2;\n\t\t\t\tif (tp + subopt_len > cp + sizeof(*dh6o) + optlen)\n\t\t\t\t\tgoto trunc;\n\t\t\t\tND_PRINT((ndo, \" subopt:%d\", subopt_code));\n\t\t\t\tswitch (subopt_code) {\n\t\t\t\tcase DH6OPT_NTP_SUBOPTION_SRV_ADDR:\n\t\t\t\tcase DH6OPT_NTP_SUBOPTION_MC_ADDR:\n\t\t\t\t\tif (subopt_len != 16) {\n\t\t\t\t\t\tND_PRINT((ndo, \" ?\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tND_PRINT((ndo, \" %s\", ip6addr_string(ndo, &tp[0])));\n\t\t\t\t\tbreak;\n\t\t\t\tcase DH6OPT_NTP_SUBOPTION_SRV_FQDN:\n\t\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\t\t\tif (ns_nprint(ndo, tp, tp + subopt_len) == NULL)\n\t\t\t\t\t\tgoto trunc;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tND_PRINT((ndo, \" ?\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttp += subopt_len;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_AFTR_NAME:\n\t\t\tif (optlen < 3) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tremain_len = optlen;\n\t\t\tND_PRINT((ndo, \" \"));\n\t\t\t/* Encoding is described in section 3.1 of RFC 1035 */\n\t\t\twhile (remain_len && *tp) {\n\t\t\t\tlabel_len =  *tp++;\n\t\t\t\tif (label_len < remain_len - 1) {\n\t\t\t\t\t(void)fn_printn(ndo, tp, label_len, NULL);\n\t\t\t\t\ttp += label_len;\n\t\t\t\t\tremain_len -= (label_len + 1);\n\t\t\t\t\tif(*tp) ND_PRINT((ndo, \".\"));\n\t\t\t\t} else {\n\t\t\t\t\tND_PRINT((ndo, \" ?\"));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\tcase DH6OPT_NEW_POSIX_TIMEZONE: /* all three of these options */\n\t\tcase DH6OPT_NEW_TZDB_TIMEZONE:\t/* are encoded similarly */\n\t\tcase DH6OPT_MUDURL:\t\t/* although GMT might not work */\n\t\t        if (optlen < 5) {\n\t\t\t\tND_PRINT((ndo, \" ?)\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\t\t\tND_PRINT((ndo, \"=\"));\n\t\t\t(void)fn_printn(ndo, tp, (u_int)optlen, NULL);\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t\tbreak;\n\t\t}\n\n\t\tcp += sizeof(*dh6o) + optlen;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|dhcp6ext]\"));\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\ttp = (const u_char *)(dh6o + 1);\n\n```\n\n\n\nwith the following test error:     dhcp6_reconf_asan                  : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "11b426ee05eb62ed103218526f1fa616851c43ce___print-dhcp6.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nvoid\npgm_print(netdissect_options *ndo,\n          register const u_char *bp, register u_int length,\n          register const u_char *bp2)\n{\n\tregister const struct pgm_header *pgm;\n\tregister const struct ip *ip;\n\tregister char ch;\n\tuint16_t sport, dport;\n\tu_int nla_afnum;\n\tchar nla_buf[INET6_ADDRSTRLEN];\n\tregister const struct ip6_hdr *ip6;\n\tuint8_t opt_type, opt_len;\n\tuint32_t seq, opts_len, len, offset;\n\n\tpgm = (const struct pgm_header *)bp;\n\tip = (const struct ip *)bp2;\n\tif (IP_V(ip) == 6)\n\t\tip6 = (const struct ip6_hdr *)bp2;\n\telse\n\t\tip6 = NULL;\n\tch = '\\0';\n\tif (!ND_TTEST(pgm->pgm_dport)) {\n\t\tif (ip6) {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst)));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst)));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsport = EXTRACT_16BITS(&pgm->pgm_sport);\n\tdport = EXTRACT_16BITS(&pgm->pgm_dport);\n\n\tif (ip6) {\n\t\tif (ip6->ip6_nxt == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t} else {\n\t\tif (ip->ip_p == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst),\n\t\t\t\ttcpport_string(ndo, dport)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: \",\n\t\t\t\ttcpport_string(ndo, sport), tcpport_string(ndo, dport)));\n\t\t}\n\t}\n\n\tND_TCHECK(*pgm);\n\n        ND_PRINT((ndo, \"PGM, length %u\", EXTRACT_16BITS(&pgm->pgm_length)));\n\n        if (!ndo->ndo_vflag)\n            return;\n\n\tND_PRINT((ndo, \" 0x%02x%02x%02x%02x%02x%02x \",\n\t\t     pgm->pgm_gsid[0],\n                     pgm->pgm_gsid[1],\n                     pgm->pgm_gsid[2],\n\t\t     pgm->pgm_gsid[3],\n                     pgm->pgm_gsid[4],\n                     pgm->pgm_gsid[5]));\n\tswitch (pgm->pgm_type) {\n\tcase PGM_SPM: {\n\t    const struct pgm_spm *spm;\n\n\t    spm = (const struct pgm_spm *)(pgm + 1);\n\t    ND_TCHECK(*spm);\n\t    bp = (const u_char *) (spm + 1);\n\n\t    switch (EXTRACT_16BITS(&spm->pgms_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_PRINT((ndo, \"SPM seq %u trail %u lead %u nla %s\",\n\t\t\t EXTRACT_32BITS(&spm->pgms_seq),\n                         EXTRACT_32BITS(&spm->pgms_trailseq),\n\t\t\t EXTRACT_32BITS(&spm->pgms_leadseq),\n                         nla_buf));\n\t    break;\n\t}\n\n\tcase PGM_POLL: {\n\t    const struct pgm_poll *poll_msg;\n\n\t    poll_msg = (const struct pgm_poll *)(pgm + 1);\n\t    ND_TCHECK(*poll_msg);\n\t    ND_PRINT((ndo, \"POLL seq %u round %u\",\n\t\t\t EXTRACT_32BITS(&poll_msg->pgmp_seq),\n                         EXTRACT_16BITS(&poll_msg->pgmp_round)));\n\t    bp = (const u_char *) (poll_msg + 1);\n\t    break;\n\t}\n\tcase PGM_POLR: {\n\t    const struct pgm_polr *polr;\n\t    uint32_t ivl, rnd, mask;\n\n\t    polr = (const struct pgm_polr *)(pgm + 1);\n\t    ND_TCHECK(*polr);\n\t    bp = (const u_char *) (polr + 1);\n\n\t    switch (EXTRACT_16BITS(&polr->pgmp_nla_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    ivl = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    rnd = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_TCHECK2(*bp, sizeof(uint32_t));\n\t    mask = EXTRACT_32BITS(bp);\n\t    bp += sizeof(uint32_t);\n\n\t    ND_PRINT((ndo, \"POLR seq %u round %u nla %s ivl %u rnd 0x%08x \"\n\t\t\t \"mask 0x%08x\", EXTRACT_32BITS(&polr->pgmp_seq),\n\t\t\t EXTRACT_16BITS(&polr->pgmp_round), nla_buf, ivl, rnd, mask));\n\t    break;\n\t}\n\tcase PGM_ODATA: {\n\t    const struct pgm_data *odata;\n\n\t    odata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*odata);\n\t    ND_PRINT((ndo, \"ODATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&odata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&odata->pgmd_seq)));\n\t    bp = (const u_char *) (odata + 1);\n\t    break;\n\t}\n\n\tcase PGM_RDATA: {\n\t    const struct pgm_data *rdata;\n\n\t    rdata = (const struct pgm_data *)(pgm + 1);\n\t    ND_TCHECK(*rdata);\n\t    ND_PRINT((ndo, \"RDATA trail %u seq %u\",\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_trailseq),\n\t\t\t EXTRACT_32BITS(&rdata->pgmd_seq)));\n\t    bp = (const u_char *) (rdata + 1);\n\t    break;\n\t}\n\n\tcase PGM_NAK:\n\tcase PGM_NULLNAK:\n\tcase PGM_NCF: {\n\t    const struct pgm_nak *nak;\n\t    char source_buf[INET6_ADDRSTRLEN], group_buf[INET6_ADDRSTRLEN];\n\n\t    nak = (const struct pgm_nak *)(pgm + 1);\n\t    ND_TCHECK(*nak);\n\t    bp = (const u_char *) (nak + 1);\n\n\t    /*\n\t     * Skip past the source, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    switch (EXTRACT_16BITS(&nak->pgmn_source_afi)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, source_buf, sizeof(source_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Skip past the group, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    bp += (2 * sizeof(uint16_t));\n\t    switch (EXTRACT_16BITS(bp)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in6_addr);\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Options decoding can go here.\n\t     */\n\t    switch (pgm->pgm_type) {\n\t\tcase PGM_NAK:\n\t\t    ND_PRINT((ndo, \"NAK \"));\n\t\t    break;\n\t\tcase PGM_NULLNAK:\n\t\t    ND_PRINT((ndo, \"NNAK \"));\n\t\t    break;\n\t\tcase PGM_NCF:\n\t\t    ND_PRINT((ndo, \"NCF \"));\n\t\t    break;\n\t\tdefault:\n                    break;\n\t    }\n\t    ND_PRINT((ndo, \"(%s -> %s), seq %u\",\n\t\t\t source_buf, group_buf, EXTRACT_32BITS(&nak->pgmn_seq)));\n\t    break;\n\t}\n\n\tcase PGM_ACK: {\n\t    const struct pgm_ack *ack;\n\n\t    ack = (const struct pgm_ack *)(pgm + 1);\n\t    ND_TCHECK(*ack);\n\t    ND_PRINT((ndo, \"ACK seq %u\",\n\t\t\t EXTRACT_32BITS(&ack->pgma_rx_max_seq)));\n\t    bp = (const u_char *) (ack + 1);\n\t    break;\n\t}\n\n\tcase PGM_SPMR:\n\t    ND_PRINT((ndo, \"SPMR\"));\n\t    break;\n\n\tdefault:\n\t    ND_PRINT((ndo, \"UNKNOWN type 0x%02x\", pgm->pgm_type));\n\t    break;\n\n\t}\n\tif (pgm->pgm_options & PGM_OPT_BIT_PRESENT) {\n\n\t    /*\n\t     * make sure there's enough for the first option header\n\t     */\n\t    if (!ND_TTEST2(*bp, PGM_MIN_OPT_LEN)) {\n\t\tND_PRINT((ndo, \"[|OPT]\"));\n\t\treturn;\n\t    }\n\n\t    /*\n\t     * That option header MUST be an OPT_LENGTH option\n\t     * (see the first paragraph of section 9.1 in RFC 3208).\n\t     */\n\t    opt_type = *bp++;\n\t    if ((opt_type & PGM_OPT_MASK) != PGM_OPT_LENGTH) {\n\t\tND_PRINT((ndo, \"[First option bad, should be PGM_OPT_LENGTH, is %u]\", opt_type & PGM_OPT_MASK));\n\t\treturn;\n\t    }\n\t    opt_len = *bp++;\n\t    if (opt_len != 4) {\n\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != 4]\", opt_len));\n\t\treturn;\n\t    }\n\t    opts_len = EXTRACT_16BITS(bp);\n\t    if (opts_len < 4) {\n\t\tND_PRINT((ndo, \"[Bad total option length %u < 4]\", opts_len));\n\t\treturn;\n\t    }\n\t    bp += sizeof(uint16_t);\n\t    ND_PRINT((ndo, \" OPTS LEN %d\", opts_len));\n\t    opts_len -= 4;\n\n\t    while (opts_len) {\n\t\tif (opts_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n\n>>> [ INFILL ] <<<\n\t\topt_len = *bp++;\n\t\tif (opt_len < PGM_MIN_OPT_LEN) {\n\t\t    ND_PRINT((ndo, \"[Bad option, length %u < %u]\", opt_len,\n\t\t        PGM_MIN_OPT_LEN));\n\t\t    break;\n\t\t}\n\t\tif (opts_len < opt_len) {\n\t\t    ND_PRINT((ndo, \"[Total option length leaves no room for final option]\"));\n\t\t    return;\n\t\t}\n\t\tif (!ND_TTEST2(*bp, opt_len - 2)) {\n\t\t    ND_PRINT((ndo, \" [|OPT]\"));\n\t\t    return;\n\t\t}\n\n\t\tswitch (opt_type & PGM_OPT_MASK) {\n\t\tcase PGM_OPT_LENGTH:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_LENGTH option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    ND_PRINT((ndo, \" OPTS LEN (extra?) %d\", EXTRACT_16BITS(bp)));\n\t\t    bp += sizeof(uint16_t);\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_FRAGMENT:\n\t\t    if (opt_len != 16) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FRAGMENT option, length %u != 16]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" FRAG seq %u off %u len %u\", seq, offset, len));\n\t\t    opts_len -= 16;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_LIST:\n\t\t    bp += 2;\n\t\t    opt_len -= sizeof(uint32_t);\t/* option header */\n\t\t    ND_PRINT((ndo, \" NAK LIST\"));\n\t\t    while (opt_len) {\n\t\t\tif (opt_len < sizeof(uint32_t)) {\n\t\t\t    ND_PRINT((ndo, \"[Option length not a multiple of 4]\"));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(uint32_t));\n\t\t\tND_PRINT((ndo, \" %u\", EXTRACT_32BITS(bp)));\n\t\t\tbp += sizeof(uint32_t);\n\t\t\topt_len -= sizeof(uint32_t);\n\t\t\topts_len -= sizeof(uint32_t);\n\t\t    }\n\t\t    break;\n\n\t\tcase PGM_OPT_JOIN:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_JOIN option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" JOIN %u\", seq));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_BO_IVL:\n\t\t    if (opt_len != 12) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_IVL option, length %u != 12]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" BACKOFF ivl %u ivlseq %u\", offset, seq));\n\t\t    opts_len -= 12;\n\t\t    break;\n\n\t\tcase PGM_OPT_NAK_BO_RNG:\n\t\t    if (opt_len != 12) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NAK_BO_RNG option, length %u != 12]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" BACKOFF max %u min %u\", offset, seq));\n\t\t    opts_len -= 12;\n\t\t    break;\n\n\t\tcase PGM_OPT_REDIRECT:\n\t\t    bp += 2;\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 4 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != 4 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 4 + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 4 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_REDIRECT option, length %u != 4 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 4 + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" REDIRECT %s\",  nla_buf));\n\t\t    break;\n\n\t\tcase PGM_OPT_PARITY_PRM:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_PRM option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" PARITY MAXTGS %u\", len));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_PARITY_GRP:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_PARITY_GRP option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    seq = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" PARITY GROUP %u\", seq));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_CURR_TGSIZE:\n\t\t    if (opt_len != 8) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CURR_TGSIZE option, length %u != 8]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    len = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    ND_PRINT((ndo, \" PARITY ATGS %u\", len));\n\t\t    opts_len -= 8;\n\t\t    break;\n\n\t\tcase PGM_OPT_NBR_UNREACH:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_NBR_UNREACH option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" NBR_UNREACH\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_PATH_NLA:\n\t\t    ND_PRINT((ndo, \" PATH_NLA [%d]\", opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\n\t\tcase PGM_OPT_SYN:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_SYN option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" SYN\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_FIN:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_FIN option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" FIN\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_RST:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_RST option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" RST\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_CR:\n\t\t    ND_PRINT((ndo, \" CR\"));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\n\t\tcase PGM_OPT_CRQST:\n\t\t    if (opt_len != 4) {\n\t\t\tND_PRINT((ndo, \"[Bad OPT_CRQST option, length %u != 4]\", opt_len));\n\t\t\treturn;\n\t\t    }\n\t\t    bp += 2;\n\t\t    ND_PRINT((ndo, \" CRQST\"));\n\t\t    opts_len -= 4;\n\t\t    break;\n\n\t\tcase PGM_OPT_PGMCC_DATA:\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 12 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 12 + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 12 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 12 + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC DATA %u %s\", offset, nla_buf));\n\t\t    break;\n\n\t\tcase PGM_OPT_PGMCC_FEEDBACK:\n\t\t    bp += 2;\n\t\t    offset = EXTRACT_32BITS(bp);\n\t\t    bp += sizeof(uint32_t);\n\t\t    nla_afnum = EXTRACT_16BITS(bp);\n\t\t    bp += (2 * sizeof(uint16_t));\n\t\t    switch (nla_afnum) {\n\t\t    case AFNUM_INET:\n\t\t\tif (opt_len != 12 + sizeof(struct in_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\t\taddrtostr(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in_addr);\n\t\t\topts_len -= 12 + sizeof(struct in_addr);\n\t\t\tbreak;\n\t\t    case AFNUM_INET6:\n\t\t\tif (opt_len != 12 + sizeof(struct in6_addr)) {\n\t\t\t    ND_PRINT((ndo, \"[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]\", opt_len));\n\t\t\t    return;\n\t\t\t}\n\t\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\t\taddrtostr6(bp, nla_buf, sizeof(nla_buf));\n\t\t\tbp += sizeof(struct in6_addr);\n\t\t\topts_len -= 12 + sizeof(struct in6_addr);\n\t\t\tbreak;\n\t\t    default:\n\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    ND_PRINT((ndo, \" PGMCC FEEDBACK %u %s\", offset, nla_buf));\n\t\t    break;\n\n\t\tdefault:\n\t\t    ND_PRINT((ndo, \" OPT_%02X [%d] \", opt_type, opt_len));\n\t\t    bp += opt_len;\n\t\t    opts_len -= opt_len;\n\t\t    break;\n\t\t}\n\n\t\tif (opt_type & PGM_OPT_END)\n\t\t    break;\n\t     }\n\t}\n\n\tND_PRINT((ndo, \" [%u]\", length));\n\tif (ndo->ndo_packettype == PT_PGM_ZMTP1 &&\n\t    (pgm->pgm_type == PGM_ODATA || pgm->pgm_type == PGM_RDATA))\n\t\tzmtp1_print_datagram(ndo, bp, EXTRACT_16BITS(&pgm->pgm_length));\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|pgm]\"));\n\tif (ch != '\\0')\n\t\tND_PRINT((ndo, \">\"));\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\topt_type = *bp++;\n\n```\n\n\n\nwith the following test error:     pgm_opts_asan                      : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "26a6799b9ca80508c05cac7a9a3bef922991520b___print-pgm.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nvoid\nicmp6_print(netdissect_options *ndo,\n            const u_char *bp, u_int length, const u_char *bp2, int fragmented)\n{\n\tconst struct icmp6_hdr *dp;\n\tconst struct ip6_hdr *ip;\n\tconst struct ip6_hdr *oip;\n\tconst struct udphdr *ouh;\n\tint dport;\n\tconst u_char *ep;\n\tu_int prot;\n\n\tdp = (const struct icmp6_hdr *)bp;\n\tip = (const struct ip6_hdr *)bp2;\n\toip = (const struct ip6_hdr *)(dp + 1);\n\t/* 'ep' points to the end of available data. */\n\tep = ndo->ndo_snapend;\n\n\tND_TCHECK(dp->icmp6_cksum);\n\n\tif (ndo->ndo_vflag && !fragmented) {\n\t\tuint16_t sum, udp_sum;\n\n\t\tif (ND_TTEST2(bp[0], length)) {\n\t\t\tudp_sum = EXTRACT_16BITS(&dp->icmp6_cksum);\n\t\t\tsum = icmp6_cksum(ndo, ip, dp, length);\n\t\t\tif (sum != 0)\n\t\t\t\tND_PRINT((ndo,\"[bad icmp6 cksum 0x%04x -> 0x%04x!] \",\n                                                udp_sum,\n                                                in_cksum_shouldbe(udp_sum, sum)));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo,\"[icmp6 sum ok] \"));\n\t\t}\n\t}\n\n        ND_PRINT((ndo,\"ICMP6, %s\", tok2str(icmp6_type_values,\"unknown icmp6 type (%u)\",dp->icmp6_type)));\n\n        /* display cosmetics: print the packet length for printer that use the vflag now */\n        if (ndo->ndo_vflag && (dp->icmp6_type == ND_ROUTER_SOLICIT ||\n                      dp->icmp6_type == ND_ROUTER_ADVERT ||\n                      dp->icmp6_type == ND_NEIGHBOR_ADVERT ||\n                      dp->icmp6_type == ND_NEIGHBOR_SOLICIT ||\n                      dp->icmp6_type == ND_REDIRECT ||\n                      dp->icmp6_type == ICMP6_HADISCOV_REPLY ||\n                      dp->icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ))\n                ND_PRINT((ndo,\", length %u\", length));\n\n\tswitch (dp->icmp6_type) {\n\tcase ICMP6_DST_UNREACH:\n\t\tND_TCHECK(oip->ip6_dst);\n                ND_PRINT((ndo,\", %s\", tok2str(icmp6_dst_unreach_code_values,\"unknown unreach code (%u)\",dp->icmp6_code)));\n\t\tswitch (dp->icmp6_code) {\n\n\t\tcase ICMP6_DST_UNREACH_NOROUTE: /* fall through */\n\t\tcase ICMP6_DST_UNREACH_ADMIN:\n\t\tcase ICMP6_DST_UNREACH_ADDR:\n                        ND_PRINT((ndo,\" %s\",ip6addr_string(ndo, &oip->ip6_dst)));\n                        break;\n\t\tcase ICMP6_DST_UNREACH_BEYONDSCOPE:\n\t\t\tND_PRINT((ndo,\" %s, source address %s\",\n\t\t\t       ip6addr_string(ndo, &oip->ip6_dst),\n                                  ip6addr_string(ndo, &oip->ip6_src)));\n\t\t\tbreak;\n\t\tcase ICMP6_DST_UNREACH_NOPORT:\n\t\t\tif ((ouh = get_upperlayer(ndo, (const u_char *)oip, &prot))\n\t\t\t    == NULL)\n\t\t\t\tgoto trunc;\n\n\t\t\tdport = EXTRACT_16BITS(&ouh->uh_dport);\n\t\t\tswitch (prot) {\n\t\t\tcase IPPROTO_TCP:\n\t\t\t\tND_PRINT((ndo,\", %s tcp port %s\",\n\t\t\t\t\tip6addr_string(ndo, &oip->ip6_dst),\n                                          tcpport_string(ndo, dport)));\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_UDP:\n\t\t\t\tND_PRINT((ndo,\", %s udp port %s\",\n\t\t\t\t\tip6addr_string(ndo, &oip->ip6_dst),\n                                          udpport_string(ndo, dport)));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo,\", %s protocol %d port %d unreachable\",\n\t\t\t\t\tip6addr_string(ndo, &oip->ip6_dst),\n                                          oip->ip6_nxt, dport));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n                  if (ndo->ndo_vflag <= 1) {\n                    print_unknown_data(ndo, bp,\"\\n\\t\",length);\n                    return;\n                  }\n                    break;\n\t\t}\n\t\tbreak;\n\tcase ICMP6_PACKET_TOO_BIG:\n\t\tND_TCHECK(dp->icmp6_mtu);\n\t\tND_PRINT((ndo,\", mtu %u\", EXTRACT_32BITS(&dp->icmp6_mtu)));\n\t\tbreak;\n\tcase ICMP6_TIME_EXCEEDED:\n\t\tND_TCHECK(oip->ip6_dst);\n\t\tswitch (dp->icmp6_code) {\n\t\tcase ICMP6_TIME_EXCEED_TRANSIT:\n\t\t\tND_PRINT((ndo,\" for %s\",\n                                  ip6addr_string(ndo, &oip->ip6_dst)));\n\t\t\tbreak;\n\t\tcase ICMP6_TIME_EXCEED_REASSEMBLY:\n\t\t\tND_PRINT((ndo,\" (reassembly)\"));\n\t\t\tbreak;\n\t\tdefault:\n                        ND_PRINT((ndo,\", unknown code (%u)\", dp->icmp6_code));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMP6_PARAM_PROB:\n\t\tND_TCHECK(oip->ip6_dst);\n\t\tswitch (dp->icmp6_code) {\n\t\tcase ICMP6_PARAMPROB_HEADER:\n                        ND_PRINT((ndo,\", erroneous - octet %u\", EXTRACT_32BITS(&dp->icmp6_pptr)));\n                        break;\n\t\tcase ICMP6_PARAMPROB_NEXTHEADER:\n                        ND_PRINT((ndo,\", next header - octet %u\", EXTRACT_32BITS(&dp->icmp6_pptr)));\n                        break;\n\t\tcase ICMP6_PARAMPROB_OPTION:\n                        ND_PRINT((ndo,\", option - octet %u\", EXTRACT_32BITS(&dp->icmp6_pptr)));\n                        break;\n\t\tdefault:\n                        ND_PRINT((ndo,\", code-#%d\",\n                                  dp->icmp6_code));\n                        break;\n\t\t}\n\t\tbreak;\n\tcase ICMP6_ECHO_REQUEST:\n\tcase ICMP6_ECHO_REPLY:\n                ND_TCHECK(dp->icmp6_seq);\n                ND_PRINT((ndo,\", seq %u\", EXTRACT_16BITS(&dp->icmp6_seq)));\n\t\tbreak;\n\tcase ICMP6_MEMBERSHIP_QUERY:\n\t\tif (length == MLD_MINLEN) {\n\t\t\tmld6_print(ndo, (const u_char *)dp);\n\t\t} else if (length >= MLDV2_MINLEN) {\n\t\t\tND_PRINT((ndo,\" v2\"));\n\t\t\tmldv2_query_print(ndo, (const u_char *)dp, length);\n\t\t} else {\n                        ND_PRINT((ndo,\" unknown-version (len %u) \", length));\n\t\t}\n\t\tbreak;\n\tcase ICMP6_MEMBERSHIP_REPORT:\n\t\tmld6_print(ndo, (const u_char *)dp);\n\t\tbreak;\n\tcase ICMP6_MEMBERSHIP_REDUCTION:\n\t\tmld6_print(ndo, (const u_char *)dp);\n\t\tbreak;\n\tcase ND_ROUTER_SOLICIT:\n#define RTSOLLEN 8\n\t\tif (ndo->ndo_vflag) {\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + RTSOLLEN,\n\t\t\t\t\tlength - RTSOLLEN);\n\t\t}\n\t\tbreak;\n\tcase ND_ROUTER_ADVERT:\n#define RTADVLEN 16\n\t\tif (ndo->ndo_vflag) {\n\t\t\tconst struct nd_router_advert *p;\n\n\t\t\tp = (const struct nd_router_advert *)dp;\n\t\t\tND_TCHECK(p->nd_ra_retransmit);\n\t\t\tND_PRINT((ndo,\"\\n\\thop limit %u, Flags [%s]\" \\\n                                  \", pref %s, router lifetime %us, reachable time %us, retrans time %us\",\n                                  (u_int)p->nd_ra_curhoplimit,\n                                  bittok2str(icmp6_opt_ra_flag_values,\"none\",(p->nd_ra_flags_reserved)),\n                                  get_rtpref(p->nd_ra_flags_reserved),\n                                  EXTRACT_16BITS(&p->nd_ra_router_lifetime),\n                                  EXTRACT_32BITS(&p->nd_ra_reachable),\n                                  EXTRACT_32BITS(&p->nd_ra_retransmit)));\n\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + RTADVLEN,\n\t\t\t\t\tlength - RTADVLEN);\n\t\t}\n\t\tbreak;\n\tcase ND_NEIGHBOR_SOLICIT:\n\t    {\n\t\tconst struct nd_neighbor_solicit *p;\n\t\tp = (const struct nd_neighbor_solicit *)dp;\n\t\tND_TCHECK(p->nd_ns_target);\n\t\tND_PRINT((ndo,\", who has %s\", ip6addr_string(ndo, &p->nd_ns_target)));\n\t\tif (ndo->ndo_vflag) {\n#define NDSOLLEN 24\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + NDSOLLEN,\n\t\t\t\t\tlength - NDSOLLEN);\n\t\t}\n\t    }\n\t\tbreak;\n\tcase ND_NEIGHBOR_ADVERT:\n\t    {\n\t\tconst struct nd_neighbor_advert *p;\n\n\t\tp = (const struct nd_neighbor_advert *)dp;\n\t\tND_TCHECK(p->nd_na_target);\n\t\tND_PRINT((ndo,\", tgt is %s\",\n                          ip6addr_string(ndo, &p->nd_na_target)));\n\t\tif (ndo->ndo_vflag) {\n                        ND_PRINT((ndo,\", Flags [%s]\",\n                                  bittok2str(icmp6_nd_na_flag_values,\n                                             \"none\",\n                                             EXTRACT_32BITS(&p->nd_na_flags_reserved))));\n#define NDADVLEN 24\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + NDADVLEN,\n\t\t\t\t\tlength - NDADVLEN);\n#undef NDADVLEN\n\t\t}\n\t    }\n\t\tbreak;\n\tcase ND_REDIRECT:\n#define RDR(i) ((const struct nd_redirect *)(i))\n                         ND_TCHECK(RDR(dp)->nd_rd_dst);\n                         ND_PRINT((ndo,\", %s\", ip6addr_string(ndo, &RDR(dp)->nd_rd_dst)));\n\t\tND_TCHECK(RDR(dp)->nd_rd_target);\n\t\tND_PRINT((ndo,\" to %s\",\n                          ip6addr_string(ndo, &RDR(dp)->nd_rd_target)));\n#define REDIRECTLEN 40\n\t\tif (ndo->ndo_vflag) {\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + REDIRECTLEN,\n\t\t\t\t\tlength - REDIRECTLEN);\n\t\t}\n\t\tbreak;\n#undef REDIRECTLEN\n#undef RDR\n\tcase ICMP6_ROUTER_RENUMBERING:\n\t\ticmp6_rrenum_print(ndo, bp, ep);\n\t\tbreak;\n\tcase ICMP6_NI_QUERY:\n\tcase ICMP6_NI_REPLY:\n\t\ticmp6_nodeinfo_print(ndo, length, bp, ep);\n\t\tbreak;\n\tcase IND_SOLICIT:\n\tcase IND_ADVERT:\n\t\tbreak;\n\tcase ICMP6_V2_MEMBERSHIP_REPORT:\n\t\tmldv2_report_print(ndo, (const u_char *) dp, length);\n\t\tbreak;\n\tcase ICMP6_MOBILEPREFIX_SOLICIT: /* fall through */\n\tcase ICMP6_HADISCOV_REQUEST:\n                ND_TCHECK(dp->icmp6_data16[0]);\n                ND_PRINT((ndo,\", id 0x%04x\", EXTRACT_16BITS(&dp->icmp6_data16[0])));\n                break;\n\tcase ICMP6_HADISCOV_REPLY:\n\t\tif (ndo->ndo_vflag) {\n\t\t\tconst struct in6_addr *in6;\n\t\t\tconst u_char *cp;\n\n\t\t\tND_TCHECK(dp->icmp6_data16[0]);\n\t\t\tND_PRINT((ndo,\", id 0x%04x\", EXTRACT_16BITS(&dp->icmp6_data16[0])));\n\t\t\tcp = (const u_char *)dp + length;\n\t\t\tin6 = (const struct in6_addr *)(dp + 1);\n\t\t\tfor (; (const u_char *)in6 < cp; in6++) {\n\t\t\t\tND_TCHECK(*in6);\n\t\t\t\tND_PRINT((ndo,\", %s\", ip6addr_string(ndo, in6)));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ICMP6_MOBILEPREFIX_ADVERT:\n\t\tif (ndo->ndo_vflag) {\n\t\t\tND_TCHECK(dp->icmp6_data16[0]);\n\t\t\tND_PRINT((ndo,\", id 0x%04x\", EXTRACT_16BITS(&dp->icmp6_data16[0])));\n\n>>> [ INFILL ] <<<\n\t\t\t\tND_PRINT((ndo,\" \"));\n\t\t\tif (dp->icmp6_data16[1] & 0x80)\n\t\t\t\tND_PRINT((ndo,\"M\"));\n\t\t\tif (dp->icmp6_data16[1] & 0x40)\n\t\t\t\tND_PRINT((ndo,\"O\"));\n#define MPADVLEN 8\n\t\t\ticmp6_opt_print(ndo, (const u_char *)dp + MPADVLEN,\n\t\t\t\t\tlength - MPADVLEN);\n\t\t}\n\t\tbreak;\n        case ND_RPL_MESSAGE:\n                /* plus 4, because struct icmp6_hdr contains 4 bytes of icmp payload */\n                rpl_print(ndo, dp, &dp->icmp6_data8[0], length-sizeof(struct icmp6_hdr)+4);\n                break;\n\tdefault:\n                ND_PRINT((ndo,\", length %u\", length));\n                if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, bp,\"\\n\\t\", length);\n                return;\n        }\n        if (!ndo->ndo_vflag)\n                ND_PRINT((ndo,\", length %u\", length));\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"[|icmp6]\"));\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\tif (dp->icmp6_data16[1] & 0xc0)\n\n```\n\n\n\nwith the following test error:     icmp6_mobileprefix_asan            : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "67c7126062d59729cd421bb38f9594015c9907ba___print-icmp6.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic int\nmobility_opt_print(netdissect_options *ndo,\n                   const u_char *bp, const unsigned len)\n{\n\tunsigned i, optlen;\n\n\tfor (i = 0; i < len; i += optlen) {\n\t\tND_TCHECK(bp[i]);\n\t\tif (bp[i] == IP6MOPT_PAD1)\n\t\t\toptlen = 1;\n\t\telse {\n\t\t\tif (i + 1 < len) {\n\t\t\t\tND_TCHECK(bp[i + 1]);\n\t\t\t\toptlen = bp[i + 1] + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto trunc;\n\t\t}\n\t\tif (i + optlen > len)\n\t\t\tgoto trunc;\n\t\tND_TCHECK(bp[i + optlen]);\n\n\t\tswitch (bp[i]) {\n\t\tcase IP6MOPT_PAD1:\n\t\t\tND_PRINT((ndo, \"(pad1)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_PADN:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(padn: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(padn)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_REFRESH:\n\t\t\tif (len - i < IP6MOPT_REFRESH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(refresh: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\t/* units of 4 secs */\n\n>>> [ INFILL ] <<<\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]) << 2));\n\t\t\tbreak;\n\t\tcase IP6MOPT_ALTCOA:\n\t\t\tif (len - i < IP6MOPT_ALTCOA_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(altcoa: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(alt-CoA: %s)\", ip6addr_string(ndo, &bp[i+2])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_NONCEID:\n\t\t\tif (len - i < IP6MOPT_NONCEID_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(ni: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(ni: ho=0x%04x co=0x%04x)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]),\n\t\t\t\tEXTRACT_16BITS(&bp[i+4])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_AUTH:\n\t\t\tif (len - i < IP6MOPT_AUTH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(auth: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(auth)\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(sopt_type %u: trunc)\", bp[i]));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(type-0x%02x: len=%u)\", bp[i], bp[i + 1]));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n\ntrunc:\n\treturn 1;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\tND_PRINT((ndo, \"(refresh: %u)\",\n\n```\n\n\n\nwith the following test error:     mobility_opt_asan                  : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "b8e559afaeb8fe0604a1f8e3ad4dc1445de07a00___print-mobility.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic int\nmobility_opt_print(netdissect_options *ndo,\n                   const u_char *bp, const unsigned len)\n{\n\tunsigned i, optlen;\n\n\tfor (i = 0; i < len; i += optlen) {\n\t\tND_TCHECK(bp[i]);\n\t\tif (bp[i] == IP6MOPT_PAD1)\n\t\t\toptlen = 1;\n\t\telse {\n\t\t\tif (i + 1 < len) {\n\t\t\t\tND_TCHECK(bp[i + 1]);\n\t\t\t\toptlen = bp[i + 1] + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto trunc;\n\t\t}\n\t\tif (i + optlen > len)\n\t\t\tgoto trunc;\n\t\tND_TCHECK(bp[i + optlen]);\n\n\t\tswitch (bp[i]) {\n\t\tcase IP6MOPT_PAD1:\n\t\t\tND_PRINT((ndo, \"(pad1)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_PADN:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(padn: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(padn)\"));\n\t\t\tbreak;\n\t\tcase IP6MOPT_REFRESH:\n\t\t\tif (len - i < IP6MOPT_REFRESH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(refresh: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\t/* units of 4 secs */\n\t\t\tND_TCHECK_16BITS(&bp[i+2]);\n\t\t\tND_PRINT((ndo, \"(refresh: %u)\",\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]) << 2));\n\t\t\tbreak;\n\t\tcase IP6MOPT_ALTCOA:\n\t\t\tif (len - i < IP6MOPT_ALTCOA_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(altcoa: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(alt-CoA: %s)\", ip6addr_string(ndo, &bp[i+2])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_NONCEID:\n\t\t\tif (len - i < IP6MOPT_NONCEID_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(ni: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\n>>> [ INFILL ] <<<\n\t\t\t\tEXTRACT_16BITS(&bp[i+2]),\n\t\t\t\tEXTRACT_16BITS(&bp[i+4])));\n\t\t\tbreak;\n\t\tcase IP6MOPT_AUTH:\n\t\t\tif (len - i < IP6MOPT_AUTH_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(auth: trunc)\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(auth)\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len - i < IP6MOPT_MINLEN) {\n\t\t\t\tND_PRINT((ndo, \"(sopt_type %u: trunc)\", bp[i]));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tND_PRINT((ndo, \"(type-0x%02x: len=%u)\", bp[i], bp[i + 1]));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n\ntrunc:\n\treturn 1;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\tND_PRINT((ndo, \"(ni: ho=0x%04x co=0x%04x)\",\n\n```\n\n\n\nwith the following test error:     mobility_opt_asan_2                : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "7d3aba9f06899d0128ef46e8a2fa143c6fad8f62___print-mobility.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nvoid\nbootp_print(netdissect_options *ndo,\n\t    register const u_char *cp, u_int length)\n{\n\tregister const struct bootp *bp;\n\tstatic const u_char vm_cmu[4] = VM_CMU;\n\tstatic const u_char vm_rfc1048[4] = VM_RFC1048;\n\n\tbp = (const struct bootp *)cp;\n\tND_TCHECK(bp->bp_op);\n\n\tND_PRINT((ndo, \"BOOTP/DHCP, %s\",\n\t\t  tok2str(bootp_op_values, \"unknown (0x%02x)\", bp->bp_op)));\n\n\tND_TCHECK(bp->bp_hlen);\n\tif (bp->bp_htype == 1 && bp->bp_hlen == 6 && bp->bp_op == BOOTPREQUEST) {\n\t\tND_TCHECK2(bp->bp_chaddr[0], 6);\n\t\tND_PRINT((ndo, \" from %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n\t}\n\n\tND_PRINT((ndo, \", length %u\", length));\n\n\tif (!ndo->ndo_vflag)\n\t\treturn;\n\n\tND_TCHECK(bp->bp_secs);\n\n\t/* The usual hardware address type is 1 (10Mb Ethernet) */\n\tif (bp->bp_htype != 1)\n\t\tND_PRINT((ndo, \", htype %d\", bp->bp_htype));\n\n\t/* The usual length for 10Mb Ethernet address is 6 bytes */\n\tif (bp->bp_htype != 1 || bp->bp_hlen != 6)\n\t\tND_PRINT((ndo, \", hlen %d\", bp->bp_hlen));\n\n\t/* Only print interesting fields */\n\tif (bp->bp_hops)\n\t\tND_PRINT((ndo, \", hops %d\", bp->bp_hops));\n\tif (EXTRACT_32BITS(&bp->bp_xid))\n\t\tND_PRINT((ndo, \", xid 0x%x\", EXTRACT_32BITS(&bp->bp_xid)));\n\tif (EXTRACT_16BITS(&bp->bp_secs))\n\t\tND_PRINT((ndo, \", secs %d\", EXTRACT_16BITS(&bp->bp_secs)));\n\n\n>>> [ INFILL ] <<<\n\t\t  bittok2str(bootp_flag_values, \"none\", EXTRACT_16BITS(&bp->bp_flags))));\n\tif (ndo->ndo_vflag > 1)\n\t\tND_PRINT((ndo, \" (0x%04x)\", EXTRACT_16BITS(&bp->bp_flags)));\n\n\t/* Client's ip address */\n\tND_TCHECK(bp->bp_ciaddr);\n\tif (EXTRACT_32BITS(&bp->bp_ciaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Client-IP %s\", ipaddr_string(ndo, &bp->bp_ciaddr)));\n\n\t/* 'your' ip address (bootp client) */\n\tND_TCHECK(bp->bp_yiaddr);\n\tif (EXTRACT_32BITS(&bp->bp_yiaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Your-IP %s\", ipaddr_string(ndo, &bp->bp_yiaddr)));\n\n\t/* Server's ip address */\n\tND_TCHECK(bp->bp_siaddr);\n\tif (EXTRACT_32BITS(&bp->bp_siaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Server-IP %s\", ipaddr_string(ndo, &bp->bp_siaddr)));\n\n\t/* Gateway's ip address */\n\tND_TCHECK(bp->bp_giaddr);\n\tif (EXTRACT_32BITS(&bp->bp_giaddr.s_addr))\n\t\tND_PRINT((ndo, \"\\n\\t  Gateway-IP %s\", ipaddr_string(ndo, &bp->bp_giaddr)));\n\n\t/* Client's Ethernet address */\n\tif (bp->bp_htype == 1 && bp->bp_hlen == 6) {\n\t\tND_TCHECK2(bp->bp_chaddr[0], 6);\n\t\tND_PRINT((ndo, \"\\n\\t  Client-Ethernet-Address %s\", etheraddr_string(ndo, bp->bp_chaddr)));\n\t}\n\n\tND_TCHECK2(bp->bp_sname[0], 1);\t\t/* check first char only */\n\tif (*bp->bp_sname) {\n\t\tND_PRINT((ndo, \"\\n\\t  sname \\\"\"));\n\t\tif (fn_printztn(ndo, bp->bp_sname, (u_int)sizeof bp->bp_sname,\n\t\t    ndo->ndo_snapend)) {\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tND_PRINT((ndo, \"%s\", tstr + 1));\n\t\t\treturn;\n\t\t}\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\tND_TCHECK2(bp->bp_file[0], 1);\t\t/* check first char only */\n\tif (*bp->bp_file) {\n\t\tND_PRINT((ndo, \"\\n\\t  file \\\"\"));\n\t\tif (fn_printztn(ndo, bp->bp_file, (u_int)sizeof bp->bp_file,\n\t\t    ndo->ndo_snapend)) {\n\t\t\tND_PRINT((ndo, \"\\\"\"));\n\t\t\tND_PRINT((ndo, \"%s\", tstr + 1));\n\t\t\treturn;\n\t\t}\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\n\t/* Decode the vendor buffer */\n\tND_TCHECK(bp->bp_vend[0]);\n\tif (memcmp((const char *)bp->bp_vend, vm_rfc1048,\n\t\t    sizeof(uint32_t)) == 0)\n\t\trfc1048_print(ndo, bp->bp_vend);\n\telse if (memcmp((const char *)bp->bp_vend, vm_cmu,\n\t\t\tsizeof(uint32_t)) == 0)\n\t\tcmu_print(ndo, bp->bp_vend);\n\telse {\n\t\tuint32_t ul;\n\n\t\tul = EXTRACT_32BITS(&bp->bp_vend);\n\t\tif (ul != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  Vendor-#0x%x\", ul));\n\t}\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\tND_PRINT((ndo, \", Flags [%s]\",\n\n```\n\n\n\nwith the following test error:     bootp_asan                         : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "29e5470e6ab84badbc31f4532bb7554a796d9d52___print-bootp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic int\nospf6_decode_v3(netdissect_options *ndo,\n                register const struct ospf6hdr *op,\n                register const u_char *dataend)\n{\n\tregister const rtrid_t *ap;\n\tregister const struct lsr6 *lsrp;\n\tregister const struct lsa6_hdr *lshp;\n\tregister const struct lsa6 *lsap;\n\tregister int i;\n\n\tswitch (op->ospf6_type) {\n\n\tcase OSPF_TYPE_HELLO: {\n\t\tregister const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\n>>> [ INFILL ] <<<\n\t\t          bittok2str(ospf6_option_values, \"none\",\n\t\t          EXTRACT_32BITS(&hellop->hello_options))));\n\n\t\tND_TCHECK(hellop->hello_deadint);\n\t\tND_PRINT((ndo, \"\\n\\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u\",\n\t\t          EXTRACT_16BITS(&hellop->hello_helloint),\n\t\t          EXTRACT_16BITS(&hellop->hello_deadint),\n\t\t          ipaddr_string(ndo, &hellop->hello_ifid),\n\t\t          hellop->hello_priority));\n\n\t\tND_TCHECK(hellop->hello_dr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_dr) != 0)\n\t\t\tND_PRINT((ndo, \"\\n\\t  Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_dr)));\n\t\tND_TCHECK(hellop->hello_bdr);\n\t\tif (EXTRACT_32BITS(&hellop->hello_bdr) != 0)\n\t\t\tND_PRINT((ndo, \", Backup Designated Router %s\",\n\t\t\t    ipaddr_string(ndo, &hellop->hello_bdr)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \"\\n\\t  Neighbor List:\"));\n\t\t\tap = hellop->hello_neighbor;\n\t\t\twhile ((const u_char *)ap < dataend) {\n\t\t\t\tND_TCHECK(*ap);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t    %s\", ipaddr_string(ndo, ap)));\n\t\t\t\t++ap;\n\t\t\t}\n\t\t}\n\t\tbreak;\t/* HELLO */\n\t}\n\n\tcase OSPF_TYPE_DD: {\n\t\tregister const struct dd6 *ddp = (const struct dd6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\tND_TCHECK(ddp->db_options);\n\t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n\t\t          bittok2str(ospf6_option_values, \"none\",\n\t\t          EXTRACT_32BITS(&ddp->db_options))));\n\t\tND_TCHECK(ddp->db_flags);\n\t\tND_PRINT((ndo, \", DD Flags [%s]\",\n\t\t          bittok2str(ospf6_dd_flag_values,\"none\",ddp->db_flags)));\n\n\t\tND_TCHECK(ddp->db_seq);\n\t\tND_PRINT((ndo, \", MTU %u, DD-Sequence 0x%08x\",\n                       EXTRACT_16BITS(&ddp->db_mtu),\n                       EXTRACT_32BITS(&ddp->db_seq)));\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\t/* Print all the LS adv's */\n\t\t\tlshp = ddp->db_lshdr;\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase OSPF_TYPE_LS_REQ:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlsrp = (const struct lsr6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lsrp < dataend) {\n\t\t\t\tND_TCHECK(*lsrp);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s\",\n\t\t\t\t          ipaddr_string(ndo, &lsrp->ls_router)));\n\t\t\t\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lsrp->ls_type),\n                                                    &lsrp->ls_stateid);\n\t\t\t\t++lsrp;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_UPDATE:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tregister const struct lsu6 *lsup = (const struct lsu6 *)((const uint8_t *)op + OSPF6HDR_LEN);\n\n\t\t\tND_TCHECK(lsup->lsu_count);\n\t\t\ti = EXTRACT_32BITS(&lsup->lsu_count);\n\t\t\tlsap = lsup->lsu_lsa;\n\t\t\twhile ((const u_char *)lsap < dataend && i--) {\n\t\t\t\tif (ospf6_print_lsa(ndo, lsap, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tlsap = (const struct lsa6 *)((const u_char *)lsap +\n\t\t\t\t    EXTRACT_16BITS(&lsap->ls_hdr.ls_length));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OSPF_TYPE_LS_ACK:\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tlshp = (const struct lsa6_hdr *)((const uint8_t *)op + OSPF6HDR_LEN);\n\t\t\twhile ((const u_char *)lshp < dataend) {\n\t\t\t\tif (ospf6_print_lshdr(ndo, lshp++, dataend))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn (0);\ntrunc:\n\treturn (1);\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\tND_PRINT((ndo, \"\\n\\tOptions [%s]\",\n\n```\n\n\n\nwith the following test error:     ospf6_decode_v3_asan               : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "88b2dac837e81cf56dce05e6e7b5989332c0092d___print-ospf6.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic void\nhandle_mlppp(netdissect_options *ndo,\n             const u_char *p, int length)\n{\n    if (!ndo->ndo_eflag)\n        ND_PRINT((ndo, \"MLPPP, \"));\n\n\n>>> [ INFILL ] <<<\n           (EXTRACT_16BITS(p))&0x0fff, /* only support 12-Bit sequence space for now */\n           bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0),\n           length));\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\",\n\n```\n\n\n\nwith the following test error:     mlppp-oobr                         : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "7335163a6ef82d46ff18f3e6099a157747241629___print-ppp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic void\nubik_print(netdissect_options *ndo,\n           register const u_char *bp)\n{\n\tint ubik_op;\n\tint32_t temp;\n\n\t/*\n\t * Print out the afs call we're invoking.  The table used here was\n\t * gleaned from ubik/ubik_int.xg\n\t */\n\n\tubik_op = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n\n\tND_PRINT((ndo, \" ubik call %s\", tok2str(ubik_req, \"op#%d\", ubik_op)));\n\n\t/*\n\t * Decode some of the arguments to the Ubik calls\n\t */\n\n\tbp += sizeof(struct rx_header) + 4;\n\n\tswitch (ubik_op) {\n\t\tcase 10000:\t\t/* Beacon */\n\t\t\tND_TCHECK2(bp[0], 4);\n\t\t\ttemp = EXTRACT_32BITS(bp);\n\t\t\tbp += sizeof(int32_t);\n\t\t\tND_PRINT((ndo, \" syncsite %s\", temp ? \"yes\" : \"no\"));\n\t\t\tND_PRINT((ndo, \" votestart\"));\n\t\t\tDATEOUT();\n\t\t\tND_PRINT((ndo, \" dbversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 10003:\t\t/* Get sync site */\n\t\t\tND_PRINT((ndo, \" site\"));\n\t\t\tUINTOUT();\n\t\t\tbreak;\n\t\tcase 20000:\t\t/* Begin */\n\t\tcase 20001:\t\t/* Commit */\n\t\tcase 20007:\t\t/* Abort */\n\t\tcase 20008:\t\t/* Release locks */\n\t\tcase 20010:\t\t/* Writev */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20002:\t\t/* Lock */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" pos\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\n>>> [ INFILL ] <<<\n\t\t\tbp += sizeof(int32_t);\n\t\t\ttok2str(ubik_lock_types, \"type %d\", temp);\n\t\t\tbreak;\n\t\tcase 20003:\t\t/* Write */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" pos\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20005:\t\t/* Get file */\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20006:\t\t/* Send file */\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" dbversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tcase 20009:\t\t/* Truncate */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" file\"));\n\t\t\tINTOUT();\n\t\t\tND_PRINT((ndo, \" length\"));\n\t\t\tINTOUT();\n\t\t\tbreak;\n\t\tcase 20012:\t\t/* Set version */\n\t\t\tND_PRINT((ndo, \" tid\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" oldversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tND_PRINT((ndo, \" newversion\"));\n\t\t\tUBIK_VERSIONOUT();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t;\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|ubik]\"));\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\ttemp = EXTRACT_32BITS(bp);\n\n```\n\n\n\nwith the following test error:     rx_ubik-oobr                       : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "aa0858100096a3490edf93034a80e66a4d61aad5___print-rx.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic int\nlldp_private_8023_print(netdissect_options *ndo,\n                        const u_char *tptr, u_int tlv_len)\n{\n    int subtype, hexdump = FALSE;\n\n    if (tlv_len < 4) {\n        return hexdump;\n    }\n    subtype = *(tptr+3);\n\n    ND_PRINT((ndo, \"\\n\\t  %s Subtype (%u)\",\n           tok2str(lldp_8023_subtype_values, \"unknown\", subtype),\n           subtype));\n\n    switch (subtype) {\n    case LLDP_PRIVATE_8023_SUBTYPE_MACPHY:\n        if (tlv_len < 9) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    autonegotiation [%s] (0x%02x)\",\n               bittok2str(lldp_8023_autonegotiation_values, \"none\", *(tptr+4)),\n               *(tptr + 4)));\n        ND_PRINT((ndo, \"\\n\\t    PMD autoneg capability [%s] (0x%04x)\",\n               bittok2str(lldp_pmd_capability_values,\"unknown\", EXTRACT_16BITS(tptr+5)),\n               EXTRACT_16BITS(tptr + 5)));\n        ND_PRINT((ndo, \"\\n\\t    MAU type %s (0x%04x)\",\n               tok2str(lldp_mau_types_values, \"unknown\", EXTRACT_16BITS(tptr+7)),\n               EXTRACT_16BITS(tptr + 7)));\n        break;\n\n    case LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER:\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    MDI power support [%s], power pair %s, power class %s\",\n               bittok2str(lldp_mdi_values, \"none\", *(tptr+4)),\n               tok2str(lldp_mdi_power_pairs_values, \"unknown\", *(tptr+5)),\n               tok2str(lldp_mdi_power_class_values, \"unknown\", *(tptr + 6))));\n        break;\n\n    case LLDP_PRIVATE_8023_SUBTYPE_LINKAGGR:\n        if (tlv_len < 9) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    aggregation status [%s], aggregation port ID %u\",\n               bittok2str(lldp_aggregation_values, \"none\", *(tptr+4)),\n               EXTRACT_32BITS(tptr + 5)));\n        break;\n\n    case LLDP_PRIVATE_8023_SUBTYPE_MTU:\n\n>>> [ INFILL ] <<<\n        break;\n\n    default:\n        hexdump = TRUE;\n        break;\n    }\n\n    return hexdump;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n        ND_PRINT((ndo, \"\\n\\t    MTU size %u\", EXTRACT_16BITS(tptr + 4)));\n\n```\n\n\n\nwith the following test error:     lldp_8023_mtu-oobr                 : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "e6511cc1a950fe1566b2236329d6b4bd0826cc7a___print-lldp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic const u_char *\nikev1_id_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len,\n\t       const u_char *ep _U_, uint32_t phase, uint32_t doi _U_,\n\t       uint32_t proto _U_, int depth _U_)\n{\n#define USE_IPSECDOI_IN_PHASE1\t1\n\tconst struct ikev1_pl_id *p;\n\tstruct ikev1_pl_id id;\n\tstatic const char *idtypestr[] = {\n\t\t\"IPv4\", \"IPv4net\", \"IPv6\", \"IPv6net\",\n\t};\n\tstatic const char *ipsecidtypestr[] = {\n\t\tNULL, \"IPv4\", \"FQDN\", \"user FQDN\", \"IPv4net\", \"IPv6\",\n\t\t\"IPv6net\", \"IPv4range\", \"IPv6range\", \"ASN1 DN\", \"ASN1 GN\",\n\t\t\"keyid\",\n\t};\n\tint len;\n\tconst u_char *data;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_ID)));\n\n\tp = (const struct ikev1_pl_id *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&id, ext, sizeof(id));\n\tif (sizeof(*p) < item_len) {\n\t\tdata = (const u_char *)(p + 1);\n\t\tlen = item_len - sizeof(*p);\n\t} else {\n\t\tdata = NULL;\n\t\tlen = 0;\n\t}\n\n#if 0 /*debug*/\n\tND_PRINT((ndo,\" [phase=%d doi=%d proto=%d]\", phase, doi, proto));\n#endif\n\tswitch (phase) {\n#ifndef USE_IPSECDOI_IN_PHASE1\n\tcase 1:\n#endif\n\tdefault:\n\t\tND_PRINT((ndo,\" idtype=%s\", STR_OR_ID(id.d.id_type, idtypestr)));\n\t\tND_PRINT((ndo,\" doi_data=%u\",\n\t\t\t  (uint32_t)(ntohl(id.d.doi_data) & 0xffffff)));\n\t\tbreak;\n\n#ifdef USE_IPSECDOI_IN_PHASE1\n\tcase 1:\n#endif\n\tcase 2:\n\t    {\n\t\tconst struct ipsecdoi_id *doi_p;\n\t\tstruct ipsecdoi_id doi_id;\n\t\tconst char *p_name;\n\n\t\tdoi_p = (const struct ipsecdoi_id *)ext;\n\t\tND_TCHECK(*doi_p);\n\t\tUNALIGNED_MEMCPY(&doi_id, ext, sizeof(doi_id));\n\t\tND_PRINT((ndo,\" idtype=%s\", STR_OR_ID(doi_id.type, ipsecidtypestr)));\n\t\t/* A protocol ID of 0 DOES NOT mean IPPROTO_IP! */\n\t\tif (!ndo->ndo_nflag && doi_id.proto_id && (p_name = netdb_protoname(doi_id.proto_id)) != NULL)\n\t\t\tND_PRINT((ndo,\" protoid=%s\", p_name));\n\t\telse\n\t\t\tND_PRINT((ndo,\" protoid=%u\", doi_id.proto_id));\n\t\tND_PRINT((ndo,\" port=%d\", ntohs(doi_id.port)));\n\t\tif (!len)\n\t\t\tbreak;\n\t\tif (data == NULL)\n\t\t\tgoto trunc;\n\t\tND_TCHECK2(*data, len);\n\t\tswitch (doi_id.type) {\n\t\tcase IPSECDOI_ID_IPV4_ADDR:\n\t\t\tif (len < 4)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 4]\", len));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo,\" len=%d %s\", len, ipaddr_string(ndo, data)));\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_FQDN:\n\t\tcase IPSECDOI_ID_USER_FQDN:\n\t\t    {\n\t\t\tint i;\n\t\t\tND_PRINT((ndo,\" len=%d \", len));\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t\tsafeputchar(ndo, data[i]);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_ID_IPV4_ADDR_SUBNET:\n\t\t    {\n\t\t\tconst u_char *mask;\n\t\t\tif (len < 8)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 8]\", len));\n\t\t\telse {\n\t\t\t\tmask = data + sizeof(struct in_addr);\n\t\t\t\tND_PRINT((ndo,\" len=%d %s/%u.%u.%u.%u\", len,\n\t\t\t\t\t  ipaddr_string(ndo, data),\n\t\t\t\t\t  mask[0], mask[1], mask[2], mask[3]));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_ID_IPV6_ADDR:\n\t\t\tif (len < 16)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 16]\", len));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo,\" len=%d %s\", len, ip6addr_string(ndo, data)));\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_IPV6_ADDR_SUBNET:\n\t\t    {\n\t\t\tconst u_char *mask;\n\n>>> [ INFILL ] <<<\n\t\t\t\tmask = (const u_char *)(data + sizeof(struct in6_addr));\n\t\t\t\t/*XXX*/\n\t\t\t\tND_PRINT((ndo,\" len=%d %s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\", len,\n\t\t\t\t\t  ip6addr_string(ndo, data),\n\t\t\t\t\t  mask[0], mask[1], mask[2], mask[3],\n\t\t\t\t\t  mask[4], mask[5], mask[6], mask[7],\n\t\t\t\t\t  mask[8], mask[9], mask[10], mask[11],\n\t\t\t\t\t  mask[12], mask[13], mask[14], mask[15]));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_ID_IPV4_ADDR_RANGE:\n\t\t\tif (len < 8)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 8]\", len));\n\t\t\telse {\n\t\t\t\tND_PRINT((ndo,\" len=%d %s-%s\", len,\n\t\t\t\t\t  ipaddr_string(ndo, data),\n\t\t\t\t\t  ipaddr_string(ndo, data + sizeof(struct in_addr))));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_IPV6_ADDR_RANGE:\n\t\t\tif (len < 32)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 32]\", len));\n\t\t\telse {\n\t\t\t\tND_PRINT((ndo,\" len=%d %s-%s\", len,\n\t\t\t\t\t  ip6addr_string(ndo, data),\n\t\t\t\t\t  ip6addr_string(ndo, data + sizeof(struct in6_addr))));\n\t\t\t}\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase IPSECDOI_ID_DER_ASN1_DN:\n\t\tcase IPSECDOI_ID_DER_ASN1_GN:\n\t\tcase IPSECDOI_ID_KEY_ID:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tif (data && len) {\n\t\tND_PRINT((ndo,\" len=%d\", len));\n\t\tif (2 < ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo,\" \"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)data, len))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_ID)));\n\treturn NULL;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\tif (len < 20)\n\t\t\t\tND_PRINT((ndo,\" len=%d [bad: < 20]\", len));\n\t\t\telse {\n\n```\n\n\n\nwith the following test error:     ikev1_id_ipv6_addr_subnet-oobr     : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "061e7371a944588f231cb1b66d6fb070b646e376___print-isakmp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nbool CClient::OnTextMessage(CTextMessage& Message) {\n    CString sTargets = Message.GetTarget();\n\n    VCString vTargets;\n    sTargets.Split(\",\", vTargets, false);\n\n    for (CString& sTarget : vTargets) {\n        Message.SetTarget(sTarget);\n        if (m_pNetwork) {\n            // May be nullptr.\n            Message.SetChan(m_pNetwork->FindChan(sTarget));\n        }\n\n        if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) {\n\n>>> [ INFILL ] <<<\n                CString sMsg = Message.GetText();\n                UserCommand(sMsg);\n            } else {\n                CALLMOD(sTarget, this, m_pUser, m_pNetwork,\n                        OnModCommand(Message.GetText()));\n            }\n            continue;\n        }\n\n        bool bContinue = false;\n        NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this,\n                          &bContinue);\n        if (bContinue) continue;\n\n        if (!GetIRCSock()) {\n            // Some lagmeters do a PRIVMSG to their own nick, ignore those.\n            if (!sTarget.Equals(m_sNick))\n                PutStatus(\n                    t_f(\"Your message to {1} got lost, you are not connected \"\n                        \"to IRC!\")(Message.GetTarget()));\n            continue;\n        }\n\n        if (m_pNetwork) {\n            AddBuffer(Message);\n            EchoMessage(Message);\n            PutIRC(Message.ToString(CMessage::ExcludePrefix |\n                                    CMessage::ExcludeTags));\n        }\n    }\n\n    return true;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n            if (sTarget.Equals(\"status\")) {\n\n```\n\n\n\nwith the following test error:       <failure message=\"test/integration/framework/base.h:116&#x0A;Value of: m_device-&gt;waitForReadyRead(timeout_ms)&#x0A;  Actual: false&#x0A;Expected: true&#x0A;Wanted: :nick!user@irc.znc.in PRIVMSG *status :blah\" type=\"\"><![CDATA[test/integration/framework/base.h:116\nValue of: m_device->waitForReadyRead(timeout_ms)\n  Actual: false\nExpected: true\nWanted: :nick!user@irc.znc.in PRIVMSG *status :blah]]></failure>\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "d229761821da38d984a9e4098ad96842490dc001___Client.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nvoid vp8_change_config(VP8_COMP *cpi, VP8_CONFIG *oxcf) {\n  VP8_COMMON *cm = &cpi->common;\n  int last_w, last_h;\n  unsigned int prev_number_of_layers;\n  unsigned int raw_target_rate;\n\n  if (!cpi) return;\n\n  if (!oxcf) return;\n\n  if (cm->version != oxcf->Version) {\n    cm->version = oxcf->Version;\n    vp8_setup_version(cm);\n  }\n\n  last_w = cpi->oxcf.Width;\n  last_h = cpi->oxcf.Height;\n  prev_number_of_layers = cpi->oxcf.number_of_layers;\n\n\n>>> [ INFILL ] <<<\n\n  switch (cpi->oxcf.Mode) {\n    case MODE_REALTIME:\n      cpi->pass = 0;\n      cpi->compressor_speed = 2;\n\n      if (cpi->oxcf.cpu_used < -16) {\n        cpi->oxcf.cpu_used = -16;\n      }\n\n      if (cpi->oxcf.cpu_used > 16) cpi->oxcf.cpu_used = 16;\n\n      break;\n\n    case MODE_GOODQUALITY:\n      cpi->pass = 0;\n      cpi->compressor_speed = 1;\n\n      if (cpi->oxcf.cpu_used < -5) {\n        cpi->oxcf.cpu_used = -5;\n      }\n\n      if (cpi->oxcf.cpu_used > 5) cpi->oxcf.cpu_used = 5;\n\n      break;\n\n    case MODE_BESTQUALITY:\n      cpi->pass = 0;\n      cpi->compressor_speed = 0;\n      break;\n\n    case MODE_FIRSTPASS:\n      cpi->pass = 1;\n      cpi->compressor_speed = 1;\n      break;\n    case MODE_SECONDPASS:\n      cpi->pass = 2;\n      cpi->compressor_speed = 1;\n\n      if (cpi->oxcf.cpu_used < -5) {\n        cpi->oxcf.cpu_used = -5;\n      }\n\n      if (cpi->oxcf.cpu_used > 5) cpi->oxcf.cpu_used = 5;\n\n      break;\n    case MODE_SECONDPASS_BEST:\n      cpi->pass = 2;\n      cpi->compressor_speed = 0;\n      break;\n  }\n\n  if (cpi->pass == 0) cpi->auto_worst_q = 1;\n\n  cpi->oxcf.worst_allowed_q = q_trans[oxcf->worst_allowed_q];\n  cpi->oxcf.best_allowed_q = q_trans[oxcf->best_allowed_q];\n  cpi->oxcf.cq_level = q_trans[cpi->oxcf.cq_level];\n\n  if (oxcf->fixed_q >= 0) {\n    if (oxcf->worst_allowed_q < 0) {\n      cpi->oxcf.fixed_q = q_trans[0];\n    } else {\n      cpi->oxcf.fixed_q = q_trans[oxcf->worst_allowed_q];\n    }\n\n    if (oxcf->alt_q < 0) {\n      cpi->oxcf.alt_q = q_trans[0];\n    } else {\n      cpi->oxcf.alt_q = q_trans[oxcf->alt_q];\n    }\n\n    if (oxcf->key_q < 0) {\n      cpi->oxcf.key_q = q_trans[0];\n    } else {\n      cpi->oxcf.key_q = q_trans[oxcf->key_q];\n    }\n\n    if (oxcf->gold_q < 0) {\n      cpi->oxcf.gold_q = q_trans[0];\n    } else {\n      cpi->oxcf.gold_q = q_trans[oxcf->gold_q];\n    }\n  }\n\n  cpi->ext_refresh_frame_flags_pending = 0;\n\n  cpi->baseline_gf_interval =\n      cpi->oxcf.alt_freq ? cpi->oxcf.alt_freq : DEFAULT_GF_INTERVAL;\n\n  // GF behavior for 1 pass CBR, used when error_resilience is off.\n  if (!cpi->oxcf.error_resilient_mode &&\n      cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER &&\n      cpi->oxcf.Mode == MODE_REALTIME)\n    cpi->baseline_gf_interval = cpi->gf_interval_onepass_cbr;\n\n#if (CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING)\n  cpi->oxcf.token_partitions = 3;\n#endif\n\n  if (cpi->oxcf.token_partitions >= 0 && cpi->oxcf.token_partitions <= 3) {\n    cm->multi_token_partition = (TOKEN_PARTITION)cpi->oxcf.token_partitions;\n  }\n\n  setup_features(cpi);\n\n  if (!cpi->use_roi_static_threshold) {\n    int i;\n    for (i = 0; i < MAX_MB_SEGMENTS; ++i) {\n      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;\n    }\n  }\n\n  /* At the moment the first order values may not be > MAXQ */\n  if (cpi->oxcf.fixed_q > MAXQ) cpi->oxcf.fixed_q = MAXQ;\n\n  /* local file playback mode == really big buffer */\n  if (cpi->oxcf.end_usage == USAGE_LOCAL_FILE_PLAYBACK) {\n    cpi->oxcf.starting_buffer_level = 60000;\n    cpi->oxcf.optimal_buffer_level = 60000;\n    cpi->oxcf.maximum_buffer_size = 240000;\n    cpi->oxcf.starting_buffer_level_in_ms = 60000;\n    cpi->oxcf.optimal_buffer_level_in_ms = 60000;\n    cpi->oxcf.maximum_buffer_size_in_ms = 240000;\n  }\n\n  raw_target_rate = (unsigned int)((int64_t)cpi->oxcf.Width * cpi->oxcf.Height *\n                                   8 * 3 * cpi->framerate / 1000);\n  if (cpi->oxcf.target_bandwidth > raw_target_rate)\n    cpi->oxcf.target_bandwidth = raw_target_rate;\n  /* Convert target bandwidth from Kbit/s to Bit/s */\n  cpi->oxcf.target_bandwidth *= 1000;\n\n  cpi->oxcf.starting_buffer_level = rescale(\n      (int)cpi->oxcf.starting_buffer_level, cpi->oxcf.target_bandwidth, 1000);\n\n  /* Set or reset optimal and maximum buffer levels. */\n  if (cpi->oxcf.optimal_buffer_level == 0) {\n    cpi->oxcf.optimal_buffer_level = cpi->oxcf.target_bandwidth / 8;\n  } else {\n    cpi->oxcf.optimal_buffer_level = rescale(\n        (int)cpi->oxcf.optimal_buffer_level, cpi->oxcf.target_bandwidth, 1000);\n  }\n\n  if (cpi->oxcf.maximum_buffer_size == 0) {\n    cpi->oxcf.maximum_buffer_size = cpi->oxcf.target_bandwidth / 8;\n  } else {\n    cpi->oxcf.maximum_buffer_size = rescale((int)cpi->oxcf.maximum_buffer_size,\n                                            cpi->oxcf.target_bandwidth, 1000);\n  }\n  // Under a configuration change, where maximum_buffer_size may change,\n  // keep buffer level clipped to the maximum allowed buffer size.\n  if (cpi->bits_off_target > cpi->oxcf.maximum_buffer_size) {\n    cpi->bits_off_target = cpi->oxcf.maximum_buffer_size;\n    cpi->buffer_level = cpi->bits_off_target;\n  }\n\n  /* Set up frame rate and related parameters rate control values. */\n  vp8_new_framerate(cpi, cpi->framerate);\n\n  /* Set absolute upper and lower quality limits */\n  cpi->worst_quality = cpi->oxcf.worst_allowed_q;\n  cpi->best_quality = cpi->oxcf.best_allowed_q;\n\n  /* active values should only be modified if out of new range */\n  if (cpi->active_worst_quality > cpi->oxcf.worst_allowed_q) {\n    cpi->active_worst_quality = cpi->oxcf.worst_allowed_q;\n  }\n  /* less likely */\n  else if (cpi->active_worst_quality < cpi->oxcf.best_allowed_q) {\n    cpi->active_worst_quality = cpi->oxcf.best_allowed_q;\n  }\n  if (cpi->active_best_quality < cpi->oxcf.best_allowed_q) {\n    cpi->active_best_quality = cpi->oxcf.best_allowed_q;\n  }\n  /* less likely */\n  else if (cpi->active_best_quality > cpi->oxcf.worst_allowed_q) {\n    cpi->active_best_quality = cpi->oxcf.worst_allowed_q;\n  }\n\n  cpi->buffered_mode = cpi->oxcf.optimal_buffer_level > 0;\n\n  cpi->cq_target_quality = cpi->oxcf.cq_level;\n\n  /* Only allow dropped frames in buffered mode */\n  cpi->drop_frames_allowed = cpi->oxcf.allow_df && cpi->buffered_mode;\n\n  cpi->target_bandwidth = cpi->oxcf.target_bandwidth;\n\n  // Check if the number of temporal layers has changed, and if so reset the\n  // pattern counter and set/initialize the temporal layer context for the\n  // new layer configuration.\n  if (cpi->oxcf.number_of_layers != prev_number_of_layers) {\n    // If the number of temporal layers are changed we must start at the\n    // base of the pattern cycle, so set the layer id to 0 and reset\n    // the temporal pattern counter.\n    if (cpi->temporal_layer_id > 0) {\n      cpi->temporal_layer_id = 0;\n    }\n    cpi->temporal_pattern_counter = 0;\n    vp8_reset_temporal_layer_change(cpi, oxcf, prev_number_of_layers);\n  }\n\n  if (!cpi->initial_width) {\n    cpi->initial_width = cpi->oxcf.Width;\n    cpi->initial_height = cpi->oxcf.Height;\n  }\n\n  cm->Width = cpi->oxcf.Width;\n  cm->Height = cpi->oxcf.Height;\n  assert(cm->Width <= cpi->initial_width);\n  assert(cm->Height <= cpi->initial_height);\n\n  /* TODO(jkoleszar): if an internal spatial resampling is active,\n   * and we downsize the input image, maybe we should clear the\n   * internal scale immediately rather than waiting for it to\n   * correct.\n   */\n\n  /* VP8 sharpness level mapping 0-7 (vs 0-10 in general VPx dialogs) */\n  if (cpi->oxcf.Sharpness > 7) cpi->oxcf.Sharpness = 7;\n\n  cm->sharpness_level = cpi->oxcf.Sharpness;\n\n  if (cm->horiz_scale != VP8E_NORMAL || cm->vert_scale != VP8E_NORMAL) {\n    int hr, hs, vr, vs;\n\n    Scale2Ratio(cm->horiz_scale, &hr, &hs);\n    Scale2Ratio(cm->vert_scale, &vr, &vs);\n\n    /* always go to the next whole number */\n    cm->Width = (hs - 1 + cpi->oxcf.Width * hr) / hs;\n    cm->Height = (vs - 1 + cpi->oxcf.Height * vr) / vs;\n  }\n\n  if (last_w != cpi->oxcf.Width || last_h != cpi->oxcf.Height) {\n    cpi->force_next_frame_intra = 1;\n  }\n\n  if (((cm->Width + 15) & ~15) != cm->yv12_fb[cm->lst_fb_idx].y_width ||\n      ((cm->Height + 15) & ~15) != cm->yv12_fb[cm->lst_fb_idx].y_height ||\n      cm->yv12_fb[cm->lst_fb_idx].y_width == 0) {\n    dealloc_raw_frame_buffers(cpi);\n    alloc_raw_frame_buffers(cpi);\n    vp8_alloc_compressor_data(cpi);\n  }\n\n  if (cpi->oxcf.fixed_q >= 0) {\n    cpi->last_q[0] = cpi->oxcf.fixed_q;\n    cpi->last_q[1] = cpi->oxcf.fixed_q;\n  }\n\n  cpi->Speed = cpi->oxcf.cpu_used;\n\n  /* force to allowlag to 0 if lag_in_frames is 0; */\n  if (cpi->oxcf.lag_in_frames == 0) {\n    cpi->oxcf.allow_lag = 0;\n  }\n  /* Limit on lag buffers as these are not currently dynamically allocated */\n  else if (cpi->oxcf.lag_in_frames > MAX_LAG_BUFFERS) {\n    cpi->oxcf.lag_in_frames = MAX_LAG_BUFFERS;\n  }\n\n  /* YX Temp */\n  cpi->alt_ref_source = NULL;\n  cpi->is_src_frame_alt_ref = 0;\n\n#if CONFIG_TEMPORAL_DENOISING\n  if (cpi->oxcf.noise_sensitivity) {\n    if (!cpi->denoiser.yv12_mc_running_avg.buffer_alloc) {\n      int width = (cpi->oxcf.Width + 15) & ~15;\n      int height = (cpi->oxcf.Height + 15) & ~15;\n      if (vp8_denoiser_allocate(&cpi->denoiser, width, height, cm->mb_rows,\n                                cm->mb_cols, cpi->oxcf.noise_sensitivity)) {\n        vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,\n                           \"Failed to allocate denoiser\");\n      }\n    }\n  }\n#endif\n\n#if 0\n    /* Experimental RD Code */\n    cpi->frame_distortion = 0;\n    cpi->last_frame_distortion = 0;\n#endif\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  cpi->oxcf = *oxcf;\n\n```\n\n\n\nwith the following test error: warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\nNote: Google Test filter = EncodeAPI.ConfigResizeChangeThreadCount-:AVX512.*:AVX512/*\n[==========] Running 1 test from 1 test suite.\n[----------] Global test environment set-up.\n[----------] 1 test from EncodeAPI\n[ RUN      ] EncodeAPI.ConfigResizeChangeThreadCount\n[New Thread 0x7f7b1de0d700 (LWP 19995)]\n[New Thread 0x7f7b1d60c700 (LWP 19996)]\n[New Thread 0x7f7b1ce0b700 (LWP 19998)]\n[New Thread 0x7f7b1c60a700 (LWP 19999)]\nmunmap_chunk(): invalid pointer\n[Thread 0x7f7b1ce0b700 (LWP 19998) exited]\n[Thread 0x7f7b1c60a700 (LWP 19999) exited]\n[Thread 0x7f7b1d60c700 (LWP 19996) exited]\n[Thread 0x7f7b1de0d700 (LWP 19995) exited]\n\nThread 1 \"test_libvpx\" received signal SIGABRT, Aborted.\n__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50\n50\t../sysdeps/unix/sysv/linux/raise.c: No such file or directory.\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "3fbd1dca6a4d2dad332a2110d646e4ffef36d590___onyx_if.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nint sqlite3Select(\n  Parse *pParse,         /* The parser context */\n  Select *p,             /* The SELECT statement being coded. */\n  SelectDest *pDest      /* What to do with the query results */\n){\n  int i, j;              /* Loop counters */\n  WhereInfo *pWInfo;     /* Return from sqlite3WhereBegin() */\n  Vdbe *v;               /* The virtual machine under construction */\n  int isAgg;             /* True for select lists like \"count(*)\" */\n  ExprList *pEList = 0;  /* List of columns to extract. */\n  SrcList *pTabList;     /* List of tables to select from */\n  Expr *pWhere;          /* The WHERE clause.  May be NULL */\n  ExprList *pGroupBy;    /* The GROUP BY clause.  May be NULL */\n  Expr *pHaving;         /* The HAVING clause.  May be NULL */\n  int rc = 1;            /* Value to return from this function */\n  DistinctCtx sDistinct; /* Info on how to code the DISTINCT keyword */\n  SortCtx sSort;         /* Info on how to code the ORDER BY clause */\n  AggInfo sAggInfo;      /* Information used by aggregate queries */\n  int iEnd;              /* Address of the end of the query */\n  sqlite3 *db;           /* The database connection */\n  ExprList *pMinMaxOrderBy = 0;  /* Added ORDER BY for min/max queries */\n  u8 minMaxFlag;                 /* Flag for min/max queries */\n\n  db = pParse->db;\n  v = sqlite3GetVdbe(pParse);\n  if( p==0 || db->mallocFailed || pParse->nErr ){\n    return 1;\n  }\n  if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) return 1;\n  memset(&sAggInfo, 0, sizeof(sAggInfo));\n#if SELECTTRACE_ENABLED\n  SELECTTRACE(1,pParse,p, (\"begin processing:\\n\", pParse->addrExplain));\n  if( sqlite3SelectTrace & 0x100 ){\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistFifo );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Fifo );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistQueue );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Queue );\n  if( IgnorableOrderby(pDest) ){\n    assert(pDest->eDest==SRT_Exists || pDest->eDest==SRT_Union || \n           pDest->eDest==SRT_Except || pDest->eDest==SRT_Discard ||\n           pDest->eDest==SRT_Queue  || pDest->eDest==SRT_DistFifo ||\n           pDest->eDest==SRT_DistQueue || pDest->eDest==SRT_Fifo);\n    /* If ORDER BY makes no difference in the output then neither does\n    ** DISTINCT so it can be removed too. */\n    sqlite3ExprListDelete(db, p->pOrderBy);\n    p->pOrderBy = 0;\n    p->selFlags &= ~SF_Distinct;\n  }\n  sqlite3SelectPrep(pParse, p, 0);\n  if( pParse->nErr || db->mallocFailed ){\n    goto select_end;\n  }\n  assert( p->pEList!=0 );\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x104 ){\n    SELECTTRACE(0x104,pParse,p, (\"after name resolution:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  if( pDest->eDest==SRT_Output ){\n    generateColumnNames(pParse, p);\n  }\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( sqlite3WindowRewrite(pParse, p) ){\n    goto select_end;\n  }\n#if SELECTTRACE_ENABLED\n  if( p->pWin && (sqlite3SelectTrace & 0x108)!=0 ){\n    SELECTTRACE(0x104,pParse,p, (\"after window rewrite:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n  pTabList = p->pSrc;\n  isAgg = (p->selFlags & SF_Aggregate)!=0;\n  memset(&sSort, 0, sizeof(sSort));\n  sSort.pOrderBy = p->pOrderBy;\n\n  /* Try to various optimizations (flattening subqueries, and strength\n  ** reduction of join operators) in the FROM clause up into the main query\n  */\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n  for(i=0; !p->pPrior && i<pTabList->nSrc; i++){\n    struct SrcList_item *pItem = &pTabList->a[i];\n    Select *pSub = pItem->pSelect;\n    Table *pTab = pItem->pTab;\n\n    /* Convert LEFT JOIN into JOIN if there are terms of the right table\n    ** of the LEFT JOIN used in the WHERE clause.\n    */\n    if( (pItem->fg.jointype & JT_LEFT)!=0\n     && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor)\n     && OptimizationEnabled(db, SQLITE_SimplifyJoin)\n    ){\n      SELECTTRACE(0x100,pParse,p,\n                (\"LEFT-JOIN simplifies to JOIN on term %d\\n\",i));\n      pItem->fg.jointype &= ~(JT_LEFT|JT_OUTER);\n      unsetJoinExpr(p->pWhere, pItem->iCursor);\n    }\n\n    /* No futher action if this term of the FROM clause is no a subquery */\n    if( pSub==0 ) continue;\n\n    /* Catch mismatch in the declared columns of a view and the number of\n    ** columns in the SELECT on the RHS */\n    if( pTab->nCol!=pSub->pEList->nExpr ){\n      sqlite3ErrorMsg(pParse, \"expected %d columns for '%s' but got %d\",\n                      pTab->nCol, pTab->zName, pSub->pEList->nExpr);\n      goto select_end;\n    }\n\n    /* Do not try to flatten an aggregate subquery.\n    **\n    ** Flattening an aggregate subquery is only possible if the outer query\n    ** is not a join.  But if the outer query is not a join, then the subquery\n    ** will be implemented as a co-routine and there is no advantage to\n    ** flattening in that case.\n    */\n    if( (pSub->selFlags & SF_Aggregate)!=0 ) continue;\n    assert( pSub->pGroupBy==0 );\n\n    /* If the outer query contains a \"complex\" result set (that is,\n    ** if the result set of the outer query uses functions or subqueries)\n    ** and if the subquery contains an ORDER BY clause and if\n    ** it will be implemented as a co-routine, then do not flatten.  This\n    ** restriction allows SQL constructs like this:\n    **\n    **  SELECT expensive_function(x)\n    **    FROM (SELECT x FROM tab ORDER BY y LIMIT 10);\n    **\n    ** The expensive_function() is only computed on the 10 rows that\n    ** are output, rather than every row of the table.\n    **\n    ** The requirement that the outer query have a complex result set\n    ** means that flattening does occur on simpler SQL constraints without\n    ** the expensive_function() like:\n    **\n    **  SELECT x FROM (SELECT x FROM tab ORDER BY y LIMIT 10);\n    */\n    if( pSub->pOrderBy!=0\n     && i==0\n     && (p->selFlags & SF_ComplexResult)!=0\n     && (pTabList->nSrc==1\n         || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)\n    ){\n      continue;\n    }\n\n    if( flattenSubquery(pParse, p, i, isAgg) ){\n      if( pParse->nErr ) goto select_end;\n      /* This subquery can be absorbed into its parent. */\n      i = -1;\n    }\n    pTabList = p->pSrc;\n    if( db->mallocFailed ) goto select_end;\n    if( !IgnorableOrderby(pDest) ){\n      sSort.pOrderBy = p->pOrderBy;\n    }\n  }\n#endif\n\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n  /* Handle compound SELECT statements using the separate multiSelect()\n  ** procedure.\n  */\n  if( p->pPrior ){\n    rc = multiSelect(pParse, p, pDest);\n#if SELECTTRACE_ENABLED\n    SELECTTRACE(0x1,pParse,p,(\"end compound-select processing\\n\"));\n    if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n    if( p->pNext==0 ) ExplainQueryPlanPop(pParse);\n    return rc;\n  }\n#endif\n\n  /* Do the WHERE-clause constant propagation optimization if this is\n  ** a join.  No need to speed time on this operation for non-join queries\n  ** as the equivalent optimization will be handled by query planner in\n  ** sqlite3WhereBegin().\n  */\n  if( pTabList->nSrc>1\n   && OptimizationEnabled(db, SQLITE_PropagateConst)\n   && propagateConstants(pParse, p)\n  ){\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x100 ){\n      SELECTTRACE(0x100,pParse,p,(\"After constant propagation:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n  }else{\n    SELECTTRACE(0x100,pParse,p,(\"Constant propagation not helpful\\n\"));\n  }\n\n#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION\n  if( OptimizationEnabled(db, SQLITE_QueryFlattener|SQLITE_CountOfView)\n   && countOfViewOptimization(pParse, p)\n  ){\n    if( db->mallocFailed ) goto select_end;\n    pEList = p->pEList;\n    pTabList = p->pSrc;\n  }\n#endif\n\n  /* For each term in the FROM clause, do two things:\n  ** (1) Authorized unreferenced tables\n  ** (2) Generate code for all sub-queries\n  */\n  for(i=0; i<pTabList->nSrc; i++){\n    struct SrcList_item *pItem = &pTabList->a[i];\n    SelectDest dest;\n    Select *pSub;\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n    const char *zSavedAuthContext;\n#endif\n\n    /* Issue SQLITE_READ authorizations with a fake column name for any\n    ** tables that are referenced but from which no values are extracted.\n    ** Examples of where these kinds of null SQLITE_READ authorizations\n    ** would occur:\n    **\n    **     SELECT count(*) FROM t1;   -- SQLITE_READ t1.\"\"\n    **     SELECT t1.* FROM t1, t2;   -- SQLITE_READ t2.\"\"\n    **\n    ** The fake column name is an empty string.  It is possible for a table to\n    ** have a column named by the empty string, in which case there is no way to\n    ** distinguish between an unreferenced table and an actual reference to the\n    ** \"\" column. The original design was for the fake column name to be a NULL,\n    ** which would be unambiguous.  But legacy authorization callbacks might\n    ** assume the column name is non-NULL and segfault.  The use of an empty\n    ** string for the fake column name seems safer.\n    */\n    if( pItem->colUsed==0 && pItem->zName!=0 ){\n      sqlite3AuthCheck(pParse, SQLITE_READ, pItem->zName, \"\", pItem->zDatabase);\n    }\n\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n    /* Generate code for all sub-queries in the FROM clause\n    */\n    pSub = pItem->pSelect;\n    if( pSub==0 ) continue;\n\n    /* The code for a subquery should only be generated once, though it is\n    ** technically harmless for it to be generated multiple times. The\n    ** following assert() will detect if something changes to cause\n    ** the same subquery to be coded multiple times, as a signal to the\n    ** developers to try to optimize the situation.\n    **\n    ** Update 2019-07-24:\n    ** See ticket https://sqlite.org/src/tktview/c52b09c7f38903b1311cec40.\n    ** The dbsqlfuzz fuzzer found a case where the same subquery gets\n    ** coded twice.  So this assert() now becomes a testcase().  It should\n    ** be very rare, though.\n    */\n    testcase( pItem->addrFillSub!=0 );\n\n    /* Increment Parse.nHeight by the height of the largest expression\n    ** tree referred to by this, the parent select. The child select\n    ** may contain expression trees of at most\n    ** (SQLITE_MAX_EXPR_DEPTH-Parse.nHeight) height. This is a bit\n    ** more conservative than necessary, but much easier than enforcing\n    ** an exact limit.\n    */\n    pParse->nHeight += sqlite3SelectExprHeight(p);\n\n    /* Make copies of constant WHERE-clause terms in the outer query down\n    ** inside the subquery.  This can help the subquery to run more efficiently.\n    */\n    if( OptimizationEnabled(db, SQLITE_PushDown)\n     && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem->iCursor,\n                           (pItem->fg.jointype & JT_OUTER)!=0)\n    ){\n#if SELECTTRACE_ENABLED\n      if( sqlite3SelectTrace & 0x100 ){\n        SELECTTRACE(0x100,pParse,p,\n            (\"After WHERE-clause push-down into subquery %d:\\n\", pSub->selId));\n        sqlite3TreeViewSelect(0, p, 0);\n      }\n#endif\n    }else{\n      SELECTTRACE(0x100,pParse,p,(\"Push-down not possible\\n\"));\n    }\n\n    zSavedAuthContext = pParse->zAuthContext;\n    pParse->zAuthContext = pItem->zName;\n\n    /* Generate code to implement the subquery\n    **\n    ** The subquery is implemented as a co-routine if the subquery is\n    ** guaranteed to be the outer loop (so that it does not need to be\n    ** computed more than once)\n    **\n    ** TODO: Are there other reasons beside (1) to use a co-routine\n    ** implementation?\n    */\n    if( i==0\n     && (pTabList->nSrc==1\n            || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)  /* (1) */\n    ){\n      /* Implement a co-routine that will return a single row of the result\n      ** set on each invocation.\n      */\n      int addrTop = sqlite3VdbeCurrentAddr(v)+1;\n     \n      pItem->regReturn = ++pParse->nMem;\n      sqlite3VdbeAddOp3(v, OP_InitCoroutine, pItem->regReturn, 0, addrTop);\n      VdbeComment((v, \"%s\", pItem->pTab->zName));\n      pItem->addrFillSub = addrTop;\n      sqlite3SelectDestInit(&dest, SRT_Coroutine, pItem->regReturn);\n      ExplainQueryPlan((pParse, 1, \"CO-ROUTINE %u\", pSub->selId));\n      sqlite3Select(pParse, pSub, &dest);\n      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n      pItem->fg.viaCoroutine = 1;\n      pItem->regResult = dest.iSdst;\n      sqlite3VdbeEndCoroutine(v, pItem->regReturn);\n      sqlite3VdbeJumpHere(v, addrTop-1);\n      sqlite3ClearTempRegCache(pParse);\n    }else{\n      /* Generate a subroutine that will fill an ephemeral table with\n      ** the content of this subquery.  pItem->addrFillSub will point\n      ** to the address of the generated subroutine.  pItem->regReturn\n      ** is a register allocated to hold the subroutine return address\n      */\n      int topAddr;\n      int onceAddr = 0;\n      int retAddr;\n      struct SrcList_item *pPrior;\n\n      testcase( pItem->addrFillSub==0 ); /* Ticket c52b09c7f38903b1311 */\n      pItem->regReturn = ++pParse->nMem;\n      topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);\n      pItem->addrFillSub = topAddr+1;\n      if( pItem->fg.isCorrelated==0 ){\n        /* If the subquery is not correlated and if we are not inside of\n        ** a trigger, then we only need to compute the value of the subquery\n        ** once. */\n        onceAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n        VdbeComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n      }else{\n        VdbeNoopComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n      }\n      pPrior = isSelfJoinView(pTabList, pItem);\n      if( pPrior ){\n        sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pPrior->iCursor);\n        assert( pPrior->pSelect!=0 );\n        pSub->nSelectRow = pPrior->pSelect->nSelectRow;\n      }else{\n        sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);\n        ExplainQueryPlan((pParse, 1, \"MATERIALIZE %u\", pSub->selId));\n        sqlite3Select(pParse, pSub, &dest);\n      }\n      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n      if( onceAddr ) sqlite3VdbeJumpHere(v, onceAddr);\n      retAddr = sqlite3VdbeAddOp1(v, OP_Return, pItem->regReturn);\n      VdbeComment((v, \"end %s\", pItem->pTab->zName));\n      sqlite3VdbeChangeP1(v, topAddr, retAddr);\n      sqlite3ClearTempRegCache(pParse);\n    }\n    if( db->mallocFailed ) goto select_end;\n    pParse->nHeight -= sqlite3SelectExprHeight(p);\n    pParse->zAuthContext = zSavedAuthContext;\n#endif\n  }\n\n  /* Various elements of the SELECT copied into local variables for\n  ** convenience */\n  pEList = p->pEList;\n  pWhere = p->pWhere;\n  pGroupBy = p->pGroupBy;\n  pHaving = p->pHaving;\n  sDistinct.isTnct = (p->selFlags & SF_Distinct)!=0;\n\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x400 ){\n    SELECTTRACE(0x400,pParse,p,(\"After all FROM-clause analysis:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  /* If the query is DISTINCT with an ORDER BY but is not an aggregate, and \n  ** if the select-list is the same as the ORDER BY list, then this query\n  ** can be rewritten as a GROUP BY. In other words, this:\n  **\n  **     SELECT DISTINCT xyz FROM ... ORDER BY xyz\n  **\n  ** is transformed to:\n  **\n  **     SELECT xyz FROM ... GROUP BY xyz ORDER BY xyz\n  **\n  ** The second form is preferred as a single index (or temp-table) may be \n  ** used for both the ORDER BY and DISTINCT processing. As originally \n  ** written the query must use a temp-table for at least one of the ORDER \n  ** BY and DISTINCT, and an index or separate temp-table for the other.\n  */\n  if( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct \n   && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1)==0\n\n>>> [ INFILL ] <<<\n    p->selFlags &= ~SF_Distinct;\n    pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);\n    /* Notice that even thought SF_Distinct has been cleared from p->selFlags,\n    ** the sDistinct.isTnct is still set.  Hence, isTnct represents the\n    ** original setting of the SF_Distinct flag, not the current setting */\n    assert( sDistinct.isTnct );\n\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x400 ){\n      SELECTTRACE(0x400,pParse,p,(\"Transform DISTINCT into GROUP BY:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n  }\n\n  /* If there is an ORDER BY clause, then create an ephemeral index to\n  ** do the sorting.  But this sorting ephemeral index might end up\n  ** being unused if the data can be extracted in pre-sorted order.\n  ** If that is the case, then the OP_OpenEphemeral instruction will be\n  ** changed to an OP_Noop once we figure out that the sorting index is\n  ** not needed.  The sSort.addrSortIndex variable is used to facilitate\n  ** that change.\n  */\n  if( sSort.pOrderBy ){\n    KeyInfo *pKeyInfo;\n    pKeyInfo = sqlite3KeyInfoFromExprList(\n        pParse, sSort.pOrderBy, 0, pEList->nExpr);\n    sSort.iECursor = pParse->nTab++;\n    sSort.addrSortIndex =\n      sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n          sSort.iECursor, sSort.pOrderBy->nExpr+1+pEList->nExpr, 0,\n          (char*)pKeyInfo, P4_KEYINFO\n      );\n  }else{\n    sSort.addrSortIndex = -1;\n  }\n\n  /* If the output is destined for a temporary table, open that table.\n  */\n  if( pDest->eDest==SRT_EphemTab ){\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pDest->iSDParm, pEList->nExpr);\n  }\n\n  /* Set the limiter.\n  */\n  iEnd = sqlite3VdbeMakeLabel(pParse);\n  if( (p->selFlags & SF_FixedLimit)==0 ){\n    p->nSelectRow = 320;  /* 4 billion rows */\n  }\n  computeLimitRegisters(pParse, p, iEnd);\n  if( p->iLimit==0 && sSort.addrSortIndex>=0 ){\n    sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, OP_SorterOpen);\n    sSort.sortFlags |= SORTFLAG_UseSorter;\n  }\n\n  /* Open an ephemeral index to use for the distinct set.\n  */\n  if( p->selFlags & SF_Distinct ){\n    sDistinct.tabTnct = pParse->nTab++;\n    sDistinct.addrTnct = sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n                       sDistinct.tabTnct, 0, 0,\n                       (char*)sqlite3KeyInfoFromExprList(pParse, p->pEList,0,0),\n                       P4_KEYINFO);\n    sqlite3VdbeChangeP5(v, BTREE_UNORDERED);\n    sDistinct.eTnctType = WHERE_DISTINCT_UNORDERED;\n  }else{\n    sDistinct.eTnctType = WHERE_DISTINCT_NOOP;\n  }\n\n  if( !isAgg && pGroupBy==0 ){\n    /* No aggregate functions and no GROUP BY clause */\n    u16 wctrlFlags = (sDistinct.isTnct ? WHERE_WANT_DISTINCT : 0)\n                   | (p->selFlags & SF_FixedLimit);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    Window *pWin = p->pWin;      /* Master window object (or NULL) */\n    if( pWin ){\n      sqlite3WindowCodeInit(pParse, pWin);\n    }\n#endif\n    assert( WHERE_USE_LIMIT==SF_FixedLimit );\n\n\n    /* Begin the database scan. */\n    SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy,\n                               p->pEList, wctrlFlags, p->nSelectRow);\n    if( pWInfo==0 ) goto select_end;\n    if( sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow ){\n      p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);\n    }\n    if( sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo) ){\n      sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);\n    }\n    if( sSort.pOrderBy ){\n      sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);\n      sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);\n      if( sSort.nOBSat==sSort.pOrderBy->nExpr ){\n        sSort.pOrderBy = 0;\n      }\n    }\n\n    /* If sorting index that was created by a prior OP_OpenEphemeral \n    ** instruction ended up not being needed, then change the OP_OpenEphemeral\n    ** into an OP_Noop.\n    */\n    if( sSort.addrSortIndex>=0 && sSort.pOrderBy==0 ){\n      sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n    }\n\n    assert( p->pEList==pEList );\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    if( pWin ){\n      int addrGosub = sqlite3VdbeMakeLabel(pParse);\n      int iCont = sqlite3VdbeMakeLabel(pParse);\n      int iBreak = sqlite3VdbeMakeLabel(pParse);\n      int regGosub = ++pParse->nMem;\n\n      sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);\n\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, iBreak);\n      sqlite3VdbeResolveLabel(v, addrGosub);\n      VdbeNoopComment((v, \"inner-loop subroutine\"));\n      sSort.labelOBLopt = 0;\n      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);\n      sqlite3VdbeResolveLabel(v, iCont);\n      sqlite3VdbeAddOp1(v, OP_Return, regGosub);\n      VdbeComment((v, \"end inner-loop subroutine\"));\n      sqlite3VdbeResolveLabel(v, iBreak);\n    }else\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n    {\n      /* Use the standard inner loop. */\n      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest,\n          sqlite3WhereContinueLabel(pWInfo),\n          sqlite3WhereBreakLabel(pWInfo));\n\n      /* End the database scan loop.\n      */\n      sqlite3WhereEnd(pWInfo);\n    }\n  }else{\n    /* This case when there exist aggregate functions or a GROUP BY clause\n    ** or both */\n    NameContext sNC;    /* Name context for processing aggregate information */\n    int iAMem;          /* First Mem address for storing current GROUP BY */\n    int iBMem;          /* First Mem address for previous GROUP BY */\n    int iUseFlag;       /* Mem address holding flag indicating that at least\n                        ** one row of the input to the aggregator has been\n                        ** processed */\n    int iAbortFlag;     /* Mem address which causes query abort if positive */\n    int groupBySort;    /* Rows come from source in GROUP BY order */\n    int addrEnd;        /* End of processing for this SELECT */\n    int sortPTab = 0;   /* Pseudotable used to decode sorting results */\n    int sortOut = 0;    /* Output register from the sorter */\n    int orderByGrp = 0; /* True if the GROUP BY and ORDER BY are the same */\n\n    /* Remove any and all aliases between the result set and the\n    ** GROUP BY clause.\n    */\n    if( pGroupBy ){\n      int k;                        /* Loop counter */\n      struct ExprList_item *pItem;  /* For looping over expression in a list */\n\n      for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++){\n        pItem->u.x.iAlias = 0;\n      }\n      for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++){\n        pItem->u.x.iAlias = 0;\n      }\n      assert( 66==sqlite3LogEst(100) );\n      if( p->nSelectRow>66 ) p->nSelectRow = 66;\n\n      /* If there is both a GROUP BY and an ORDER BY clause and they are\n      ** identical, then it may be possible to disable the ORDER BY clause \n      ** on the grounds that the GROUP BY will cause elements to come out \n      ** in the correct order. It also may not - the GROUP BY might use a\n      ** database index that causes rows to be grouped together as required\n      ** but not actually sorted. Either way, record the fact that the\n      ** ORDER BY and GROUP BY clauses are the same by setting the orderByGrp\n      ** variable.  */\n      if( sSort.pOrderBy && pGroupBy->nExpr==sSort.pOrderBy->nExpr ){\n        int ii;\n        /* The GROUP BY processing doesn't care whether rows are delivered in\n        ** ASC or DESC order - only that each group is returned contiguously.\n        ** So set the ASC/DESC flags in the GROUP BY to match those in the \n        ** ORDER BY to maximize the chances of rows being delivered in an \n        ** order that makes the ORDER BY redundant.  */\n        for(ii=0; ii<pGroupBy->nExpr; ii++){\n          u8 sortFlags = sSort.pOrderBy->a[ii].sortFlags & KEYINFO_ORDER_DESC;\n          pGroupBy->a[ii].sortFlags = sortFlags;\n        }\n        if( sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1)==0 ){\n          orderByGrp = 1;\n        }\n      }\n    }else{\n      assert( 0==sqlite3LogEst(1) );\n      p->nSelectRow = 0;\n    }\n\n    /* Create a label to jump to when we want to abort the query */\n    addrEnd = sqlite3VdbeMakeLabel(pParse);\n\n    /* Convert TK_COLUMN nodes into TK_AGG_COLUMN and make entries in\n    ** sAggInfo for all TK_AGG_FUNCTION nodes in expressions of the\n    ** SELECT statement.\n    */\n    memset(&sNC, 0, sizeof(sNC));\n    sNC.pParse = pParse;\n    sNC.pSrcList = pTabList;\n    sNC.uNC.pAggInfo = &sAggInfo;\n    VVA_ONLY( sNC.ncFlags = NC_UAggInfo; )\n    sAggInfo.mnReg = pParse->nMem+1;\n    sAggInfo.nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;\n    sAggInfo.pGroupBy = pGroupBy;\n    sqlite3ExprAnalyzeAggList(&sNC, pEList);\n    sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);\n    if( pHaving ){\n      if( pGroupBy ){\n        assert( pWhere==p->pWhere );\n        assert( pHaving==p->pHaving );\n        assert( pGroupBy==p->pGroupBy );\n        havingToWhere(pParse, p);\n        pWhere = p->pWhere;\n      }\n      sqlite3ExprAnalyzeAggregates(&sNC, pHaving);\n    }\n    sAggInfo.nAccumulator = sAggInfo.nColumn;\n    if( p->pGroupBy==0 && p->pHaving==0 && sAggInfo.nFunc==1 ){\n      minMaxFlag = minMaxQuery(db, sAggInfo.aFunc[0].pExpr, &pMinMaxOrderBy);\n    }else{\n      minMaxFlag = WHERE_ORDERBY_NORMAL;\n    }\n    for(i=0; i<sAggInfo.nFunc; i++){\n      Expr *pExpr = sAggInfo.aFunc[i].pExpr;\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      sNC.ncFlags |= NC_InAggFunc;\n      sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      assert( !IsWindowFunc(pExpr) );\n      if( ExprHasProperty(pExpr, EP_WinFunc) ){\n        sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);\n      }\n#endif\n      sNC.ncFlags &= ~NC_InAggFunc;\n    }\n    sAggInfo.mxReg = pParse->nMem;\n    if( db->mallocFailed ) goto select_end;\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x400 ){\n      int ii;\n      SELECTTRACE(0x400,pParse,p,(\"After aggregate analysis:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n      for(ii=0; ii<sAggInfo.nColumn; ii++){\n        sqlite3DebugPrintf(\"agg-column[%d] iMem=%d\\n\",\n            ii, sAggInfo.aCol[ii].iMem);\n        sqlite3TreeViewExpr(0, sAggInfo.aCol[ii].pExpr, 0);\n      }\n      for(ii=0; ii<sAggInfo.nFunc; ii++){\n        sqlite3DebugPrintf(\"agg-func[%d]: iMem=%d\\n\",\n            ii, sAggInfo.aFunc[ii].iMem);\n        sqlite3TreeViewExpr(0, sAggInfo.aFunc[ii].pExpr, 0);\n      }\n    }\n#endif\n\n\n    /* Processing for aggregates with GROUP BY is very different and\n    ** much more complex than aggregates without a GROUP BY.\n    */\n    if( pGroupBy ){\n      KeyInfo *pKeyInfo;  /* Keying information for the group by clause */\n      int addr1;          /* A-vs-B comparision jump */\n      int addrOutputRow;  /* Start of subroutine that outputs a result row */\n      int regOutputRow;   /* Return address register for output subroutine */\n      int addrSetAbort;   /* Set the abort flag and return */\n      int addrTopOfLoop;  /* Top of the input loop */\n      int addrSortingIdx; /* The OP_OpenEphemeral for the sorting index */\n      int addrReset;      /* Subroutine for resetting the accumulator */\n      int regReset;       /* Return address register for reset subroutine */\n\n      /* If there is a GROUP BY clause we might need a sorting index to\n      ** implement it.  Allocate that sorting index now.  If it turns out\n      ** that we do not need it after all, the OP_SorterOpen instruction\n      ** will be converted into a Noop.  \n      */\n      sAggInfo.sortingIdx = pParse->nTab++;\n      pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pGroupBy,0,sAggInfo.nColumn);\n      addrSortingIdx = sqlite3VdbeAddOp4(v, OP_SorterOpen, \n          sAggInfo.sortingIdx, sAggInfo.nSortingColumn, \n          0, (char*)pKeyInfo, P4_KEYINFO);\n\n      /* Initialize memory locations used by GROUP BY aggregate processing\n      */\n      iUseFlag = ++pParse->nMem;\n      iAbortFlag = ++pParse->nMem;\n      regOutputRow = ++pParse->nMem;\n      addrOutputRow = sqlite3VdbeMakeLabel(pParse);\n      regReset = ++pParse->nMem;\n      addrReset = sqlite3VdbeMakeLabel(pParse);\n      iAMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      iBMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iAbortFlag);\n      VdbeComment((v, \"clear abort flag\"));\n      sqlite3VdbeAddOp3(v, OP_Null, 0, iAMem, iAMem+pGroupBy->nExpr-1);\n\n      /* Begin a loop that will extract all source rows in GROUP BY order.\n      ** This might involve two separate loops with an OP_Sort in between, or\n      ** it might be a single loop that uses an index to extract information\n      ** in the right order to begin with.\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, 0,\n          WHERE_GROUPBY | (orderByGrp ? WHERE_SORTBYGROUP : 0), 0\n      );\n      if( pWInfo==0 ) goto select_end;\n      if( sqlite3WhereIsOrdered(pWInfo)==pGroupBy->nExpr ){\n        /* The optimizer is able to deliver rows in group by order so\n        ** we do not have to sort.  The OP_OpenEphemeral table will be\n        ** cancelled later because we still need to use the pKeyInfo\n        */\n        groupBySort = 0;\n      }else{\n        /* Rows are coming out in undetermined order.  We have to push\n        ** each row into a sorting index, terminate the first loop,\n        ** then loop over the sorting index in order to get the output\n        ** in sorted order\n        */\n        int regBase;\n        int regRecord;\n        int nCol;\n        int nGroupBy;\n\n        explainTempTable(pParse, \n            (sDistinct.isTnct && (p->selFlags&SF_Distinct)==0) ?\n                    \"DISTINCT\" : \"GROUP BY\");\n\n        groupBySort = 1;\n        nGroupBy = pGroupBy->nExpr;\n        nCol = nGroupBy;\n        j = nGroupBy;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          if( sAggInfo.aCol[i].iSorterColumn>=j ){\n            nCol++;\n            j++;\n          }\n        }\n        regBase = sqlite3GetTempRange(pParse, nCol);\n        sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);\n        j = nGroupBy;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          struct AggInfo_col *pCol = &sAggInfo.aCol[i];\n          if( pCol->iSorterColumn>=j ){\n            int r1 = j + regBase;\n            sqlite3ExprCodeGetColumnOfTable(v,\n                               pCol->pTab, pCol->iTable, pCol->iColumn, r1);\n            j++;\n          }\n        }\n        regRecord = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regRecord);\n        sqlite3VdbeAddOp2(v, OP_SorterInsert, sAggInfo.sortingIdx, regRecord);\n        sqlite3ReleaseTempReg(pParse, regRecord);\n        sqlite3ReleaseTempRange(pParse, regBase, nCol);\n        sqlite3WhereEnd(pWInfo);\n        sAggInfo.sortingIdxPTab = sortPTab = pParse->nTab++;\n        sortOut = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_OpenPseudo, sortPTab, sortOut, nCol);\n        sqlite3VdbeAddOp2(v, OP_SorterSort, sAggInfo.sortingIdx, addrEnd);\n        VdbeComment((v, \"GROUP BY sort\")); VdbeCoverage(v);\n        sAggInfo.useSortingIdx = 1;\n      }\n\n      /* If the index or temporary table used by the GROUP BY sort\n      ** will naturally deliver rows in the order required by the ORDER BY\n      ** clause, cancel the ephemeral table open coded earlier.\n      **\n      ** This is an optimization - the correct answer should result regardless.\n      ** Use the SQLITE_GroupByOrder flag with SQLITE_TESTCTRL_OPTIMIZER to \n      ** disable this optimization for testing purposes.  */\n      if( orderByGrp && OptimizationEnabled(db, SQLITE_GroupByOrder) \n       && (groupBySort || sqlite3WhereIsSorted(pWInfo))\n      ){\n        sSort.pOrderBy = 0;\n        sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n      }\n\n      /* Evaluate the current GROUP BY terms and store in b0, b1, b2...\n      ** (b0 is memory location iBMem+0, b1 is iBMem+1, and so forth)\n      ** Then compare the current GROUP BY terms against the GROUP BY terms\n      ** from the previous row currently stored in a0, a1, a2...\n      */\n      addrTopOfLoop = sqlite3VdbeCurrentAddr(v);\n      if( groupBySort ){\n        sqlite3VdbeAddOp3(v, OP_SorterData, sAggInfo.sortingIdx,\n                          sortOut, sortPTab);\n      }\n      for(j=0; j<pGroupBy->nExpr; j++){\n        if( groupBySort ){\n          sqlite3VdbeAddOp3(v, OP_Column, sortPTab, j, iBMem+j);\n        }else{\n          sAggInfo.directMode = 1;\n          sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j);\n        }\n      }\n      sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy->nExpr,\n                          (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);\n      addr1 = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp3(v, OP_Jump, addr1+1, 0, addr1+1); VdbeCoverage(v);\n\n      /* Generate code that runs whenever the GROUP BY changes.\n      ** Changes in the GROUP BY are detected by the previous code\n      ** block.  If there were no changes, this block is skipped.\n      **\n      ** This code copies current group by terms in b0,b1,b2,...\n      ** over to a0,a1,a2.  It then calls the output subroutine\n      ** and resets the aggregate accumulator registers in preparation\n      ** for the next GROUP BY batch.\n      */\n      sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output one row\"));\n      sqlite3VdbeAddOp2(v, OP_IfPos, iAbortFlag, addrEnd); VdbeCoverage(v);\n      VdbeComment((v, \"check abort flag\"));\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      VdbeComment((v, \"reset accumulator\"));\n\n      /* Update the aggregate accumulators based on the content of\n      ** the current row\n      */\n      sqlite3VdbeJumpHere(v, addr1);\n      updateAccumulator(pParse, iUseFlag, &sAggInfo);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag);\n      VdbeComment((v, \"indicate data in accumulator\"));\n\n      /* End of the loop\n      */\n      if( groupBySort ){\n        sqlite3VdbeAddOp2(v, OP_SorterNext, sAggInfo.sortingIdx, addrTopOfLoop);\n        VdbeCoverage(v);\n      }else{\n        sqlite3WhereEnd(pWInfo);\n        sqlite3VdbeChangeToNoop(v, addrSortingIdx);\n      }\n\n      /* Output the final row of result\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output final row\"));\n\n      /* Jump over the subroutines\n      */\n      sqlite3VdbeGoto(v, addrEnd);\n\n      /* Generate a subroutine that outputs a single row of the result\n      ** set.  This subroutine first looks at the iUseFlag.  If iUseFlag\n      ** is less than or equal to zero, the subroutine is a no-op.  If\n      ** the processing calls for the query to abort, this subroutine\n      ** increments the iAbortFlag memory location before returning in\n      ** order to signal the caller to abort.\n      */\n      addrSetAbort = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iAbortFlag);\n      VdbeComment((v, \"set abort flag\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      sqlite3VdbeResolveLabel(v, addrOutputRow);\n      addrOutputRow = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_IfPos, iUseFlag, addrOutputRow+2);\n      VdbeCoverage(v);\n      VdbeComment((v, \"Groupby result generator entry point\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      finalizeAggFunctions(pParse, &sAggInfo);\n      sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, -1, &sSort,\n                      &sDistinct, pDest,\n                      addrOutputRow+1, addrSetAbort);\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      VdbeComment((v, \"end groupby result generator\"));\n\n      /* Generate a subroutine that will reset the group-by accumulator\n      */\n      sqlite3VdbeResolveLabel(v, addrReset);\n      resetAccumulator(pParse, &sAggInfo);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iUseFlag);\n      VdbeComment((v, \"indicate accumulator empty\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regReset);\n     \n    } /* endif pGroupBy.  Begin aggregate queries without GROUP BY: */\n    else {\n#ifndef SQLITE_OMIT_BTREECOUNT\n      Table *pTab;\n      if( (pTab = isSimpleCount(p, &sAggInfo))!=0 ){\n        /* If isSimpleCount() returns a pointer to a Table structure, then\n        ** the SQL statement is of the form:\n        **\n        **   SELECT count(*) FROM <tbl>\n        **\n        ** where the Table structure returned represents table <tbl>.\n        **\n        ** This statement is so common that it is optimized specially. The\n        ** OP_Count instruction is executed either on the intkey table that\n        ** contains the data for table <tbl> or on one of its indexes. It\n        ** is better to execute the op on an index, as indexes are almost\n        ** always spread across less pages than their corresponding tables.\n        */\n        const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n        const int iCsr = pParse->nTab++;     /* Cursor to scan b-tree */\n        Index *pIdx;                         /* Iterator variable */\n        KeyInfo *pKeyInfo = 0;               /* Keyinfo for scanned index */\n        Index *pBest = 0;                    /* Best index found so far */\n        int iRoot = pTab->tnum;              /* Root page of scanned b-tree */\n\n        sqlite3CodeVerifySchema(pParse, iDb);\n        sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n\n        /* Search for the index that has the lowest scan cost.\n        **\n        ** (2011-04-15) Do not do a full scan of an unordered index.\n        **\n        ** (2013-10-03) Do not count the entries in a partial index.\n        **\n        ** In practice the KeyInfo structure will not be used. It is only \n        ** passed to keep OP_OpenRead happy.\n        */\n        if( !HasRowid(pTab) ) pBest = sqlite3PrimaryKeyIndex(pTab);\n        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n          if( pIdx->bUnordered==0\n           && pIdx->szIdxRow<pTab->szTabRow\n           && pIdx->pPartIdxWhere==0\n           && (!pBest || pIdx->szIdxRow<pBest->szIdxRow)\n          ){\n            pBest = pIdx;\n          }\n        }\n        if( pBest ){\n          iRoot = pBest->tnum;\n          pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);\n        }\n\n        /* Open a read-only cursor, execute the OP_Count, close the cursor. */\n        sqlite3VdbeAddOp4Int(v, OP_OpenRead, iCsr, iRoot, iDb, 1);\n        if( pKeyInfo ){\n          sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, P4_KEYINFO);\n        }\n        sqlite3VdbeAddOp2(v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem);\n        sqlite3VdbeAddOp1(v, OP_Close, iCsr);\n        explainSimpleCount(pParse, pTab, pBest);\n      }else\n#endif /* SQLITE_OMIT_BTREECOUNT */\n      {\n        int regAcc = 0;           /* \"populate accumulators\" flag */\n\n        /* If there are accumulator registers but no min() or max() functions\n        ** without FILTER clauses, allocate register regAcc. Register regAcc\n        ** will contain 0 the first time the inner loop runs, and 1 thereafter.\n        ** The code generated by updateAccumulator() uses this to ensure\n        ** that the accumulator registers are (a) updated only once if\n        ** there are no min() or max functions or (b) always updated for the\n        ** first row visited by the aggregate, so that they are updated at\n        ** least once even if the FILTER clause means the min() or max() \n        ** function visits zero rows.  */\n        if( sAggInfo.nAccumulator ){\n          for(i=0; i<sAggInfo.nFunc; i++){\n            if( ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_WinFunc) ) continue;\n            if( sAggInfo.aFunc[i].pFunc->funcFlags&SQLITE_FUNC_NEEDCOLL ) break;\n          }\n          if( i==sAggInfo.nFunc ){\n            regAcc = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, OP_Integer, 0, regAcc);\n          }\n        }\n\n        /* This case runs if the aggregate has no GROUP BY clause.  The\n        ** processing is much simpler since there is only a single row\n        ** of output.\n        */\n        assert( p->pGroupBy==0 );\n        resetAccumulator(pParse, &sAggInfo);\n\n        /* If this query is a candidate for the min/max optimization, then\n        ** minMaxFlag will have been previously set to either\n        ** WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX and pMinMaxOrderBy will\n        ** be an appropriate ORDER BY expression for the optimization.\n        */\n        assert( minMaxFlag==WHERE_ORDERBY_NORMAL || pMinMaxOrderBy!=0 );\n        assert( pMinMaxOrderBy==0 || pMinMaxOrderBy->nExpr==1 );\n\n        SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy,\n                                   0, minMaxFlag, 0);\n        if( pWInfo==0 ){\n          goto select_end;\n        }\n        updateAccumulator(pParse, regAcc, &sAggInfo);\n        if( regAcc ) sqlite3VdbeAddOp2(v, OP_Integer, 1, regAcc);\n        if( sqlite3WhereIsOrdered(pWInfo)>0 ){\n          sqlite3VdbeGoto(v, sqlite3WhereBreakLabel(pWInfo));\n          VdbeComment((v, \"%s() by index\",\n                (minMaxFlag==WHERE_ORDERBY_MIN?\"min\":\"max\")));\n        }\n        sqlite3WhereEnd(pWInfo);\n        finalizeAggFunctions(pParse, &sAggInfo);\n      }\n\n      sSort.pOrderBy = 0;\n      sqlite3ExprIfFalse(pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, -1, 0, 0, \n                      pDest, addrEnd, addrEnd);\n    }\n    sqlite3VdbeResolveLabel(v, addrEnd);\n    \n  } /* endif aggregate query */\n\n  if( sDistinct.eTnctType==WHERE_DISTINCT_UNORDERED ){\n    explainTempTable(pParse, \"DISTINCT\");\n  }\n\n  /* If there is an ORDER BY clause, then we need to sort the results\n  ** and send them to the callback one by one.\n  */\n  if( sSort.pOrderBy ){\n    explainTempTable(pParse,\n                     sSort.nOBSat>0 ? \"RIGHT PART OF ORDER BY\":\"ORDER BY\");\n    assert( p->pEList==pEList );\n    generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);\n  }\n\n  /* Jump here to skip this query\n  */\n  sqlite3VdbeResolveLabel(v, iEnd);\n\n  /* The SELECT has been coded. If there is an error in the Parse structure,\n  ** set the return code to 1. Otherwise 0. */\n  rc = (pParse->nErr>0);\n\n  /* Control jumps to here if an error is encountered above, or upon\n  ** successful coding of the SELECT.\n  */\nselect_end:\n  sqlite3ExprListDelete(db, pMinMaxOrderBy);\n  sqlite3DbFree(db, sAggInfo.aCol);\n  sqlite3DbFree(db, sAggInfo.aFunc);\n#if SELECTTRACE_ENABLED\n  SELECTTRACE(0x1,pParse,p,(\"end processing\\n\"));\n  if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n  ExplainQueryPlanPop(pParse);\n  return rc;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  ){\n\n```\n\n\n\nwith the following test error: warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\nwindow1-33.2...\n! window1-33.2 expected: [6 1]\n! window1-33.2 got:      [{} 1]\n[Detaching after fork from child process 17063]\nSQLite 2019-11-22 10:14:01 bcdd66c1691955c697f3d756c2b035acfe98f6aad72e90b0021bab6e9023b3ba\n1 errors out of 179 tests on deef54515472 Linux 64-bit little-endian\n!Failures on these tests: window1-33.2\nAll memory allocations freed - no leaks\nMemory used:          now          0  max     358312  max-size     120000\nAllocation count:     now          0  max        453\nPage-cache used:      now          0  max          0  max-size       1288\nPage-cache overflow:  now          0  max      18312\nMaximum memory usage: 358312 bytes\nCurrent memory usage: 0 bytes\nNumber of malloc()  : -1 calls\n[Inferior 1 (process 15013) exited with code 01]\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "e59c562b3f6894f84c715772c4b116d7b5c01348___select.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic int zipfileUpdate(\n  sqlite3_vtab *pVtab, \n  int nVal, \n  sqlite3_value **apVal, \n  sqlite_int64 *pRowid\n){\n  ZipfileTab *pTab = (ZipfileTab*)pVtab;\n  int rc = SQLITE_OK;             /* Return Code */\n  ZipfileEntry *pNew = 0;         /* New in-memory CDS entry */\n\n  u32 mode = 0;                   /* Mode for new entry */\n  u32 mTime = 0;                  /* Modification time for new entry */\n  i64 sz = 0;                     /* Uncompressed size */\n  const char *zPath = 0;          /* Path for new entry */\n  int nPath = 0;                  /* strlen(zPath) */\n  const u8 *pData = 0;            /* Pointer to buffer containing content */\n  int nData = 0;                  /* Size of pData buffer in bytes */\n  int iMethod = 0;                /* Compression method for new entry */\n  u8 *pFree = 0;                  /* Free this */\n  char *zFree = 0;                /* Also free this */\n  ZipfileEntry *pOld = 0;\n  ZipfileEntry *pOld2 = 0;\n  int bUpdate = 0;                /* True for an update that modifies \"name\" */\n  int bIsDir = 0;\n  u32 iCrc32 = 0;\n\n  if( pTab->pWriteFd==0 ){\n    rc = zipfileBegin(pVtab);\n    if( rc!=SQLITE_OK ) return rc;\n  }\n\n  /* If this is a DELETE or UPDATE, find the archive entry to delete. */\n  if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){\n    const char *zDelete = (const char*)sqlite3_value_text(apVal[0]);\n    int nDelete = (int)strlen(zDelete);\n    if( nVal>1 ){\n      const char *zUpdate = (const char*)sqlite3_value_text(apVal[1]);\n      if( zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete)!=0 ){\n        bUpdate = 1;\n      }\n    }\n    for(pOld=pTab->pFirstEntry; 1; pOld=pOld->pNext){\n      if( zipfileComparePath(pOld->cds.zFile, zDelete, nDelete)==0 ){\n        break;\n      }\n      assert( pOld->pNext );\n    }\n  }\n\n  if( nVal>1 ){\n    /* Check that \"sz\" and \"rawdata\" are both NULL: */\n    if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){\n      zipfileTableErr(pTab, \"sz must be NULL\");\n      rc = SQLITE_CONSTRAINT;\n    }\n    if( sqlite3_value_type(apVal[6])!=SQLITE_NULL ){\n      zipfileTableErr(pTab, \"rawdata must be NULL\"); \n      rc = SQLITE_CONSTRAINT;\n    }\n\n    if( rc==SQLITE_OK ){\n      if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){\n        /* data=NULL. A directory */\n        bIsDir = 1;\n      }else{\n        /* Value specified for \"data\", and possibly \"method\". This must be\n        ** a regular file or a symlink. */\n        const u8 *aIn = sqlite3_value_blob(apVal[7]);\n        int nIn = sqlite3_value_bytes(apVal[7]);\n        int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;\n\n        iMethod = sqlite3_value_int(apVal[8]);\n        sz = nIn;\n        pData = aIn;\n        nData = nIn;\n        if( iMethod!=0 && iMethod!=8 ){\n          zipfileTableErr(pTab, \"unknown compression method: %d\", iMethod);\n          rc = SQLITE_CONSTRAINT;\n        }else{\n          if( bAuto || iMethod ){\n            int nCmp;\n            rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);\n            if( rc==SQLITE_OK ){\n              if( iMethod || nCmp<nIn ){\n                iMethod = 8;\n                pData = pFree;\n                nData = nCmp;\n              }\n            }\n          }\n          iCrc32 = crc32(0, aIn, nIn);\n        }\n      }\n    }\n\n    if( rc==SQLITE_OK ){\n      rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);\n    }\n\n    if( rc==SQLITE_OK ){\n      zPath = (const char*)sqlite3_value_text(apVal[2]);\n\n>>> [ INFILL ] <<<\n      mTime = zipfileGetTime(apVal[4]);\n    }\n\n    if( rc==SQLITE_OK && bIsDir ){\n      /* For a directory, check that the last character in the path is a\n      ** '/'. This appears to be required for compatibility with info-zip\n      ** (the unzip command on unix). It does not create directories\n      ** otherwise.  */\n      if( zPath[nPath-1]!='/' ){\n        zFree = sqlite3_mprintf(\"%s/\", zPath);\n        if( zFree==0 ){ rc = SQLITE_NOMEM; }\n        zPath = (const char*)zFree;\n        nPath++;\n      }\n    }\n\n    /* Check that we're not inserting a duplicate entry -OR- updating an\n    ** entry with a path, thereby making it into a duplicate. */\n    if( (pOld==0 || bUpdate) && rc==SQLITE_OK ){\n      ZipfileEntry *p;\n      for(p=pTab->pFirstEntry; p; p=p->pNext){\n        if( zipfileComparePath(p->cds.zFile, zPath, nPath)==0 ){\n          switch( sqlite3_vtab_on_conflict(pTab->db) ){\n            case SQLITE_IGNORE: {\n              goto zipfile_update_done;\n            }\n            case SQLITE_REPLACE: {\n              pOld2 = p;\n              break;\n            }\n            default: {\n              zipfileTableErr(pTab, \"duplicate name: \\\"%s\\\"\", zPath);\n              rc = SQLITE_CONSTRAINT;\n              break;\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    if( rc==SQLITE_OK ){\n      /* Create the new CDS record. */\n      pNew = zipfileNewEntry(zPath);\n      if( pNew==0 ){\n        rc = SQLITE_NOMEM;\n      }else{\n        pNew->cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;\n        pNew->cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;\n        pNew->cds.flags = ZIPFILE_NEWENTRY_FLAGS;\n        pNew->cds.iCompression = (u16)iMethod;\n        zipfileMtimeToDos(&pNew->cds, mTime);\n        pNew->cds.crc32 = iCrc32;\n        pNew->cds.szCompressed = nData;\n        pNew->cds.szUncompressed = (u32)sz;\n        pNew->cds.iExternalAttr = (mode<<16);\n        pNew->cds.iOffset = (u32)pTab->szCurrent;\n        pNew->cds.nFile = (u16)nPath;\n        pNew->mUnixTime = (u32)mTime;\n        rc = zipfileAppendEntry(pTab, pNew, pData, nData);\n        zipfileAddEntry(pTab, pOld, pNew);\n      }\n    }\n  }\n\n  if( rc==SQLITE_OK && (pOld || pOld2) ){\n    ZipfileCsr *pCsr;\n    for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){\n      if( pCsr->pCurrent && (pCsr->pCurrent==pOld || pCsr->pCurrent==pOld2) ){\n        pCsr->pCurrent = pCsr->pCurrent->pNext;\n        pCsr->bNoop = 1;\n      }\n    }\n\n    zipfileRemoveEntryFromList(pTab, pOld);\n    zipfileRemoveEntryFromList(pTab, pOld2);\n  }\n\nzipfile_update_done:\n  sqlite3_free(pFree);\n  sqlite3_free(zFree);\n  return rc;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n      nPath = (int)strlen(zPath);\n\n```\n\n\n\nwith the following test error: warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n[Detaching after fork from child process 73615]\n[Detaching after fork from child process 73627]\n[Detaching after fork from child process 73634]\n[Detaching after fork from child process 73643]\n[Detaching after fork from child process 73647]\n[Detaching after fork from child process 73656]\n[Detaching after fork from child process 73661]\n[Detaching after fork from child process 73673]\n[Detaching after fork from child process 73679]\n[Detaching after fork from child process 73685]\n[Detaching after fork from child process 73688]\n[Detaching after fork from child process 73696]\n[Detaching after fork from child process 73700]\nzipfile-2.5.1...[Detaching after fork from child process 73706]\nzipfile-6.0...[Detaching after fork from child process 73717]\nzipfile-6.2...[Detaching after fork from child process 73718]\nzipfile-13.10...\nProgram received signal SIGSEGV, Segmentation fault.\n__strlen_avx2 () at ../sysdeps/x86_64/multiarch/strlen-avx2.S:65\n65\t../sysdeps/x86_64/multiarch/strlen-avx2.S: No such file or directory.\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "54d501092d88c0cf89bec4279951f548fb0b8618___zipfile.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nvoid hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n\n>>> [ INFILL ] <<<\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n\n    /* Always replicate HINCRBYFLOAT as an HSET command with the final value\n     * in order to make sure that differences in float precision or formatting\n     * will not create differences in replicas or after an AOF restart. */\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n\n```\n\n\n\nwith the following test error: [\u001b[0;31;49merr\u001b[0m]: HINCRBYFLOAT does not allow NaN or Infinity in tests/unit/type/hash.tcl\nExpected 'ERR increment would produce NaN or Infinity' to match '*value is NaN or Infinity*' (context: type source line 87 file /out/redis___redis/git_repo_dir_bc7fe41e5857a0854d524e2a63a028e9394d2a5c/tests/support/test.tcl cmd {assert_match $pattern $error $detail} proc ::assert_error level 1) \n[1/1 \u001b[0;33;49mdone\u001b[0m]: unit/type/hash (4 seconds)\n\n                   The End\n\nExecution time of different units:\n  4 seconds - unit/type/hash\n\n\u001b[1;31;49m!!! WARNING\u001b[0m The following tests failed:\n\n*** [\u001b[0;31;49merr\u001b[0m]: HINCRBYFLOAT does not allow NaN or Infinity in tests/unit/type/hash.tcl\nExpected 'ERR increment would produce NaN or Infinity' to match '*value is NaN or Infinity*' (context: type source line 87 file /out/redis___redis/git_repo_dir_bc7fe41e5857a0854d524e2a63a028e9394d2a5c/tests/support/test.tcl cmd {assert_match $pattern $error $detail} proc ::assert_error level 1) \nCleanup: may take some time... OK\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "bc7fe41e5857a0854d524e2a63a028e9394d2a5c___t_hash.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n\n    if (elements > 0) {\n\n>>> [ INFILL ] <<<\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n\n    r->elements = elements;\n\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n        r->element = hi_calloc(elements,sizeof(redisReply*));\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/redis___hiredis/git_repo_dir_76a7b10005c70babee357a7d0f2becf28ec7ed1e/build_76a7b10005c70babee357a7d0f2becf28ec7ed1e\nUpdateCTestConfiguration  from :/out/redis___hiredis/git_repo_dir_76a7b10005c70babee357a7d0f2becf28ec7ed1e/build_76a7b10005c70babee357a7d0f2becf28ec7ed1e/DartConfiguration.tcl\nUpdateCTestConfiguration  from :/out/redis___hiredis/git_repo_dir_76a7b10005c70babee357a7d0f2becf28ec7ed1e/build_76a7b10005c70babee357a7d0f2becf28ec7ed1e/DartConfiguration.tcl\nTest project /out/redis___hiredis/git_repo_dir_76a7b10005c70babee357a7d0f2becf28ec7ed1e/build_76a7b10005c70babee357a7d0f2becf28ec7ed1e\nConstructing a list of tests\nDone constructing a list of tests\nUpdating test list for fixtures\nAdded 0 tests to meet fixture requirements\nChecking test dependency graph...\nChecking test dependency graph end\ntest 1\n    Start 1: hiredis-test\n\n1: Test command: /out/redis___hiredis/git_repo_dir_76a7b10005c70babee357a7d0f2becf28ec7ed1e/test.sh\n1: Working Directory: /out/redis___hiredis/git_repo_dir_76a7b10005c70babee357a7d0f2becf28ec7ed1e/build_76a7b10005c70babee357a7d0f2becf28ec7ed1e\n1: Test timeout computed to be: 10000000\n1: daemonize yes\n1: pidfile /tmp/tmp.huJiQk2vYX/hiredis-test-redis.pid\n1: port 56379\n1: bind 127.0.0.1\n1: unixsocket /tmp/tmp.huJiQk2vYX/hiredis-test-redis.sock\n1: 25103:C 28 Mar 2024 08:41:34.774 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\n1: 25103:C 28 Mar 2024 08:41:34.775 # Redis version=5.0.7, bits=64, commit=00000000, modified=0, pid=25103, just started\n1: 25103:C 28 Mar 2024 08:41:34.775 # Configuration loaded\n1/1 Test #1: hiredis-test .....................***Failed    1.67 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.67 sec\n\nThe following tests FAILED:\n\t  1 - hiredis-test (Failed)\nErrors while running CTest\nOutput from these tests are in: /out/redis___hiredis/git_repo_dir_76a7b10005c70babee357a7d0f2becf28ec7ed1e/build_76a7b10005c70babee357a7d0f2becf28ec7ed1e/Testing/Temporary/LastTest.log\nUse \"--rerun-failed --output- \nPlease provide the correct line following commit message at the infill location."}], "idx": "76a7b10005c70babee357a7d0f2becf28ec7ed1e___hiredis.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic int\n_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n\t\tnc = (*ncx) * (*ncy);\n\t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (!cidx) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\n>>> [ INFILL ] <<<\n\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t};\n\n```\n\n\n\nwith the following test error: ========================================\n   GD 2.2.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 102\n# PASS:  99\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  3\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: gd2/gd2_read_corrupt\n==========================\n\ncorrupted size vs. prev_size\nFAIL gd2/gd2_read_corrupt (exit status: 134)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\n(491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:35: Total pixels changed: 9 with a maximum channel difference of 0.\nReference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "2bb97f407c1145c850416a3bfbcc8cf124e68a19___gd_gd2.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nBGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\n>>> [ INFILL ] <<<\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char), sx)) {\n\t\treturn NULL;\n\t}\n\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n\n\t/* Row-major ever since gd 1.3 */\n\tim->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; (i < sy); i++) {\n\t\t/* Row-major ever since gd 1.3 */\n\t\tim->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\tif (!im->pixels[i]) {\n\t\t\tfor (--i ; i >= 0; i--) {\n\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t}\n\t\t\tgdFree(im->pixels);\n\t\t\tgdFree(im);\n\t\t\treturn NULL;\n\t\t}\n\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tim->open[i] = 1;\n\t};\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->res_x = GD_RESOLUTION;\n\tim->res_y = GD_RESOLUTION;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\tif (overflow2(sizeof (unsigned char *), sy)) {\n\n```\n\n\n\nwith the following test error: ========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 156\n# PASS:  154\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  2\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:31: Total pixels changed: 9 with a maximum channel difference of 255.\nfreetype/bug00132.c:33: Reference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\ngdimagestringft/gdimagestringft_bbox.c:56: (491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "1846f48e5fcdde996e7c27a4bbac5d0aef183e4b___gd.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic int\n_gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n               int *cs, int *vers, int *fmt, int *ncx, int *ncy,\n               t_chunk_info ** chunkIdx)\n{\n\tint i;\n\tint ch;\n\tchar id[5];\n\tt_chunk_info *cidx;\n\tint sidx;\n\tint nc;\n\n\tGD2_DBG (printf (\"Reading gd2 header info\\n\"));\n\n\tfor (i = 0; i < 4; i++) {\n\t\tch = gdGetC (in);\n\t\tif (ch == EOF) {\n\t\t\tgoto fail1;\n\t\t};\n\t\tid[i] = ch;\n\t};\n\tid[4] = 0;\n\n\tGD2_DBG (printf (\"Got file code: %s\\n\", id));\n\n\t/* Equiv. of 'magick'.  */\n\tif (strcmp (id, GD2_ID) != 0) {\n\t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));\n\t\tgoto fail1;\n\t};\n\n\t/* Version */\n\tif (gdGetWord (vers, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Version: %d\\n\", *vers));\n\n\tif ((*vers != 1) && (*vers != 2)) {\n\t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));\n\t\tgoto fail1;\n\t};\n\n\t/* Image Size */\n\tif (!gdGetWord (sx, in)) {\n\t\tGD2_DBG (printf (\"Could not get x-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tif (!gdGetWord (sy, in)) {\n\t\tGD2_DBG (printf (\"Could not get y-size\\n\"));\n\t\tgoto fail1;\n\t}\n\tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));\n\n\t/* Chunk Size (pixels, not bytes!) */\n\tif (gdGetWord (cs, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));\n\n\tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {\n\t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));\n\t\tgoto fail1;\n\t};\n\n\t/* Data Format */\n\tif (gdGetWord (fmt, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"Format: %d\\n\", *fmt));\n\n\tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&\n\t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {\n\t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));\n\t\tgoto fail1;\n\t};\n\n\n\t/* # of chunks wide */\n\tif (gdGetWord (ncx, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));\n\n\t/* # of chunks high */\n\tif (gdGetWord (ncy, in) != 1) {\n\t\tgoto fail1;\n\t};\n\tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));\n\n\tif (gd2_compressed (*fmt)) {\n\n>>> [ INFILL ] <<<\n\n\t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));\n\t\tif (overflow2(sizeof(t_chunk_info), nc)) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tsidx = sizeof (t_chunk_info) * nc;\n\t\tif (sidx <= 0) {\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tcidx = gdCalloc (sidx, 1);\n\t\tif (cidx == NULL) {\n\t\t\tgoto fail1;\n\t\t}\n\t\tfor (i = 0; i < nc; i++) {\n\t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n\t\t\t\tgoto fail2;\n\t\t\t};\n\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0)\n\t\t\t\tgoto fail2;\n\t\t};\n\t\t*chunkIdx = cidx;\n\t};\n\n\tGD2_DBG (printf (\"gd2 header complete\\n\"));\n\n\treturn 1;\nfail2:\n\tgdFree(cidx);\nfail1:\n\treturn 0;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\tnc = (*ncx) * (*ncy);\n\n```\n\n\n\nwith the following test error: ========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 157\n# PASS:  155\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  2\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:31: Total pixels changed: 9 with a maximum channel difference of 255.\nfreetype/bug00132.c:33: Reference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\ngdimagestringft/gdimagestringft_bbox.c:56: (491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "69d2fd2c597ffc0c217de1238b9bf4d4bceba8e6___gd_gd2.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic bool _cjose_jwe_decrypt_dat_aes_gcm(cjose_jwe_t *jwe, cjose_err *err)\n{\n    EVP_CIPHER_CTX *ctx = NULL;\n\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // get AES GCM cipher\n    const EVP_CIPHER *cipher = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128GCM) == 0)\n        cipher = EVP_aes_128_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A192GCM) == 0)\n        cipher = EVP_aes_192_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A256GCM) == 0)\n        cipher = EVP_aes_256_gcm();\n\n    if (NULL == cipher)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // instantiate and initialize a new openssl cipher context\n    ctx = EVP_CIPHER_CTX_new();\n    if (NULL == ctx)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    EVP_CIPHER_CTX_init(ctx);\n\n    // initialize context for decryption using AES GCM cipher and CEK and IV\n    if (EVP_DecryptInit_ex(ctx, cipher, NULL, jwe->cek, jwe->enc_iv.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n\n>>> [ INFILL ] <<<\n    if (EVP_CIPHER_CTX_ctrl(ctx, CJOSE_EVP_CTRL_GCM_SET_TAG, jwe->enc_auth_tag.raw_len, jwe->enc_auth_tag.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // set GCM mode AAD data (hdr_b64u) by setting \"out\" to NULL\n    int bytes_decrypted = 0;\n    if (EVP_DecryptUpdate(ctx, NULL, &bytes_decrypted, (unsigned char *)jwe->enc_header.b64u, jwe->enc_header.b64u_len) != 1\n        || bytes_decrypted != jwe->enc_header.b64u_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // allocate buffer for the plaintext\n    cjose_get_dealloc()(jwe->dat);\n    jwe->dat_len = jwe->enc_ct.raw_len;\n    if (!_cjose_jwe_malloc(jwe->dat_len, false, &jwe->dat, err))\n    {\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // decrypt ciphertext to plaintext buffer\n    if (EVP_DecryptUpdate(ctx, jwe->dat, &bytes_decrypted, jwe->enc_ct.raw, jwe->enc_ct.raw_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    jwe->dat_len = bytes_decrypted;\n\n    // finalize the decryption\n    if (EVP_DecryptFinal_ex(ctx, NULL, &bytes_decrypted) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    EVP_CIPHER_CTX_free(ctx);\n    return true;\n\n_cjose_jwe_decrypt_dat_aes_gcm_fail:\n    if (NULL != ctx)\n    {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n    return false;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    // set the expected GCM-mode authentication tag\n\n```\n\n\n\nwith the following test error: check_jwe.c:1017:F:core:test_cjose_jwe_decrypt_aes_gcm:0: cjose_jwe_decrypt succeeded where it should have failed: (, file: H\bD]A\\\u000f\u001f, function: (null), line: 0\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "7325e9a5e71e2fc0e350487ecac7d84acdf0ed5e___jwe.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nPHP_FUNCTION(flock)\n{\n\tzval *arg1, *arg3 = NULL;\n\tint act;\n\tphp_stream *stream;\n\tlong operation = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl|z\", &arg1, &operation, &arg3) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tact = operation & 3;\n\tif (act < 1 || act > 3) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Illegal operation argument\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (arg3 && PZVAL_IS_REF(arg3)) {\n\t\tconvert_to_long_ex(&arg3);\n\t\tZ_LVAL_P(arg3) = 0;\n\t}\n\n\t/* flock_values contains all possible actions if (operation & 4) we won't block on the lock */\n\tact = flock_values[act - 1] | (operation & PHP_LOCK_NB ? LOCK_NB : 0);\n\tif (php_stream_lock(stream, act)) {\n\t\tif (operation && errno == EWOULDBLOCK && arg3 && PZVAL_IS_REF(arg3)) {\n\t\t\tZ_LVAL_P(arg3) = 1;\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n#define PHP_META_UNSAFE \".\\\\+*?[^]$() \"\n\n/* {{{ proto array get_meta_tags(string filename [, bool use_include_path])\n   Extracts all meta tag content attributes from a file and returns an array */\nPHP_FUNCTION(get_meta_tags)\n{\n\tchar *filename;\n\tint filename_len;\n\tzend_bool use_include_path = 0;\n\tint in_tag = 0, done = 0;\n\tint looking_for_val = 0, have_name = 0, have_content = 0;\n\tint saw_name = 0, saw_content = 0;\n\tchar *name = NULL, *value = NULL, *temp = NULL;\n\tphp_meta_tags_token tok, tok_last;\n\tphp_meta_tags_data md;\n\n\t/* Initiailize our structure */\n\tmemset(&md, 0, sizeof(md));\n\n\t/* Parse arguments */\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|b\", &filename, &filename_len, &use_include_path) == FAILURE) {\n\t\treturn;\n\t}\n\n\tmd.stream = php_stream_open_wrapper(filename, \"rb\",\n\t\t\t(use_include_path ? USE_PATH : 0) | REPORT_ERRORS,\n\t\t\tNULL);\n\tif (!md.stream)\t{\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\ttok_last = TOK_EOF;\n\n\twhile (!done && (tok = php_next_meta_token(&md TSRMLS_CC)) != TOK_EOF) {\n\t\tif (tok == TOK_ID) {\n\t\t\tif (tok_last == TOK_OPENTAG) {\n\t\t\t\tmd.in_meta = !strcasecmp(\"meta\", md.token_data);\n\t\t\t} else if (tok_last == TOK_SLASH && in_tag) {\n\t\t\t\tif (strcasecmp(\"head\", md.token_data) == 0) {\n\t\t\t\t\t/* We are done here! */\n\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t} else if (tok_last == TOK_EQUAL && looking_for_val) {\n\t\t\t\tif (saw_name) {\n\t\t\t\t\tSTR_FREE(name);\n\t\t\t\t\t/* Get the NAME attr (Single word attr, non-quoted) */\n\t\t\t\t\ttemp = name = estrndup(md.token_data, md.token_len);\n\n\t\t\t\t\twhile (temp && *temp) {\n\t\t\t\t\t\tif (strchr(PHP_META_UNSAFE, *temp)) {\n\t\t\t\t\t\t\t*temp = '_';\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp++;\n\t\t\t\t\t}\n\n\t\t\t\t\thave_name = 1;\n\t\t\t\t} else if (saw_content) {\n\t\t\t\t\tSTR_FREE(value);\n\t\t\t\t\tvalue = estrndup(md.token_data, md.token_len);\n\t\t\t\t\thave_content = 1;\n\t\t\t\t}\n\n\t\t\t\tlooking_for_val = 0;\n\t\t\t} else {\n\t\t\t\tif (md.in_meta) {\n\t\t\t\t\tif (strcasecmp(\"name\", md.token_data) == 0) {\n\t\t\t\t\t\tsaw_name = 1;\n\t\t\t\t\t\tsaw_content = 0;\n\t\t\t\t\t\tlooking_for_val = 1;\n\t\t\t\t\t} else if (strcasecmp(\"content\", md.token_data) == 0) {\n\t\t\t\t\t\tsaw_name = 0;\n\t\t\t\t\t\tsaw_content = 1;\n\t\t\t\t\t\tlooking_for_val = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tok == TOK_STRING && tok_last == TOK_EQUAL && looking_for_val) {\n\t\t\tif (saw_name) {\n\t\t\t\tSTR_FREE(name);\n\t\t\t\t/* Get the NAME attr (Quoted single/double) */\n\t\t\t\ttemp = name = estrndup(md.token_data, md.token_len);\n\n\t\t\t\twhile (temp && *temp) {\n\t\t\t\t\tif (strchr(PHP_META_UNSAFE, *temp)) {\n\t\t\t\t\t\t*temp = '_';\n\t\t\t\t\t}\n\t\t\t\t\ttemp++;\n\t\t\t\t}\n\n\t\t\t\thave_name = 1;\n\t\t\t} else if (saw_content) {\n\t\t\t\tSTR_FREE(value);\n\t\t\t\tvalue = estrndup(md.token_data, md.token_len);\n\t\t\t\thave_content = 1;\n\t\t\t}\n\n\t\t\tlooking_for_val = 0;\n\t\t} else if (tok == TOK_OPENTAG) {\n\t\t\tif (looking_for_val) {\n\t\t\t\tlooking_for_val = 0;\n\t\t\t\thave_name = saw_name = 0;\n\t\t\t\thave_content = saw_content = 0;\n\t\t\t}\n\t\t\tin_tag = 1;\n\t\t} else if (tok == TOK_CLOSETAG) {\n\t\t\tif (have_name) {\n\t\t\t\t/* For BC */\n\t\t\t\tphp_strtolower(name, strlen(name));\n\t\t\t\tif (have_content) {\n\t\t\t\t\tadd_assoc_string(return_value, name, value, 1);\n\t\t\t\t} else {\n\t\t\t\t\tadd_assoc_string(return_value, name, \"\", 1);\n\t\t\t\t}\n\n\t\t\t\tefree(name);\n\t\t\t\tSTR_FREE(value);\n\t\t\t} else if (have_content) {\n\t\t\t\tefree(value);\n\t\t\t}\n\n\t\t\tname = value = NULL;\n\n\t\t\t/* Reset all of our flags */\n\t\t\tin_tag = looking_for_val = 0;\n\t\t\thave_name = saw_name = 0;\n\t\t\thave_content = saw_content = 0;\n\t\t\tmd.in_meta = 0;\n\t\t}\n\n\t\ttok_last = tok;\n\n\t\tif (md.token_data)\n\t\t\tefree(md.token_data);\n\n\t\tmd.token_data = NULL;\n\t}\n\n\tSTR_FREE(value);\n\tSTR_FREE(name);\n\tphp_stream_close(md.stream);\n}\n/* }}} */\n\n/* {{{ proto string file_get_contents(string filename [, bool use_include_path [, resource context [, long offset [, long maxlen]]]])\n   Read the entire file into a string */\nPHP_FUNCTION(file_get_contents)\n{\n\tchar *filename;\n\tint filename_len;\n\tchar *contents;\n\tzend_bool use_include_path = 0;\n\tphp_stream *stream;\n\tlong len;\n\tlong offset = -1;\n\tlong maxlen = PHP_STREAM_COPY_ALL;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\n\t/* Parse arguments */\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|br!ll\", &filename, &filename_len, &use_include_path, &zcontext, &offset, &maxlen) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZEND_NUM_ARGS() == 5 && maxlen < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"length must be greater than or equal to zero\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\",\n\t\t\t\t(use_include_path ? USE_PATH : 0) | REPORT_ERRORS,\n\t\t\t\tNULL, context);\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (offset > 0 && php_stream_seek(stream, offset, SEEK_SET) < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to seek to position %ld in the stream\", offset);\n\t\tphp_stream_close(stream);\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((len = php_stream_copy_to_mem(stream, &contents, maxlen, 0)) > 0) {\n\t\tif (len > INT_MAX) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"content truncated from %ld to %d bytes\", len, INT_MAX);\n\t\t\tlen = INT_MAX;\n\t\t}\n\t\tRETVAL_STRINGL(contents, len, 0);\n\t} else if (len == 0) {\n\t\tRETVAL_EMPTY_STRING();\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n\n\tphp_stream_close(stream);\n}\n/* }}} */\n\n/* {{{ proto int file_put_contents(string file, mixed data [, int flags [, resource context]])\n   Write/Create a file with contents data and return the number of bytes written */\nPHP_FUNCTION(file_put_contents)\n{\n\tphp_stream *stream;\n\tchar *filename;\n\tint filename_len;\n\tzval *data;\n\tlong numbytes = 0;\n\tlong flags = 0;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\tphp_stream *srcstream = NULL;\n\tchar mode[3] = \"wb\";\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pz/|lr!\", &filename, &filename_len, &data, &flags, &zcontext) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (Z_TYPE_P(data) == IS_RESOURCE) {\n\t\tphp_stream_from_zval(srcstream, &data);\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, flags & PHP_FILE_NO_DEFAULT_CONTEXT);\n\n\tif (flags & PHP_FILE_APPEND) {\n\t\tmode[0] = 'a';\n\t} else if (flags & LOCK_EX) {\n\t\t/* check to make sure we are dealing with a regular file */\n\t\tif (php_memnstr(filename, \"://\", sizeof(\"://\") - 1, filename + filename_len)) {\n\t\t\tif (strncasecmp(filename, \"file://\", sizeof(\"file://\") - 1)) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Exclusive locks may only be set for regular files\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t\tmode[0] = 'c';\n\t}\n\tmode[2] = '\\0';\n\n\tstream = php_stream_open_wrapper_ex(filename, mode, ((flags & PHP_FILE_USE_INCLUDE_PATH) ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\tif (stream == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (flags & LOCK_EX && (!php_stream_supports_lock(stream) || php_stream_lock(stream, LOCK_EX))) {\n\t\tphp_stream_close(stream);\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Exclusive locks are not supported for this stream\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (mode[0] == 'c') {\n\t\tphp_stream_truncate_set_size(stream, 0);\n\t}\n\n\tswitch (Z_TYPE_P(data)) {\n\t\tcase IS_RESOURCE: {\n\t\t\tsize_t len;\n\t\t\tif (php_stream_copy_to_stream_ex(srcstream, stream, PHP_STREAM_COPY_ALL, &len) != SUCCESS) {\n\t\t\t\tnumbytes = -1;\n\t\t\t} else {\n\t\t\t\tif (len > LONG_MAX) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"content truncated from %lu to %ld bytes\", (unsigned long) len, LONG_MAX);\n\t\t\t\t\tlen = LONG_MAX;\n\t\t\t\t}\n\t\t\t\tnumbytes = len;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase IS_NULL:\n\t\tcase IS_LONG:\n\t\tcase IS_DOUBLE:\n\t\tcase IS_BOOL:\n\t\tcase IS_CONSTANT:\n\t\t\tconvert_to_string_ex(&data);\n\n\t\tcase IS_STRING:\n\t\t\tif (Z_STRLEN_P(data)) {\n\t\t\t\tnumbytes = php_stream_write(stream, Z_STRVAL_P(data), Z_STRLEN_P(data));\n\t\t\t\tif (numbytes != Z_STRLEN_P(data)) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Only %ld of %d bytes written, possibly out of free disk space\", numbytes, Z_STRLEN_P(data));\n\t\t\t\t\tnumbytes = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IS_ARRAY:\n\t\t\tif (zend_hash_num_elements(Z_ARRVAL_P(data))) {\n\t\t\t\tint bytes_written;\n\t\t\t\tzval **tmp;\n\t\t\t\tHashPosition pos;\n\n\t\t\t\tzend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(data), &pos);\n\t\t\t\twhile (zend_hash_get_current_data_ex(Z_ARRVAL_P(data), (void **) &tmp, &pos) == SUCCESS) {\n\t\t\t\t\tif (Z_TYPE_PP(tmp) != IS_STRING) {\n\t\t\t\t\t\tSEPARATE_ZVAL(tmp);\n\t\t\t\t\t\tconvert_to_string(*tmp);\n\t\t\t\t\t}\n\t\t\t\t\tif (Z_STRLEN_PP(tmp)) {\n\t\t\t\t\t\tnumbytes += Z_STRLEN_PP(tmp);\n\t\t\t\t\t\tbytes_written = php_stream_write(stream, Z_STRVAL_PP(tmp), Z_STRLEN_PP(tmp));\n\t\t\t\t\t\tif (bytes_written < 0 || bytes_written != Z_STRLEN_PP(tmp)) {\n\t\t\t\t\t\t\tif (bytes_written < 0) {\n\t\t\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to write %d bytes to %s\", Z_STRLEN_PP(tmp), filename);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Only %d of %d bytes written, possibly out of free disk space\", bytes_written, Z_STRLEN_PP(tmp));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnumbytes = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tzend_hash_move_forward_ex(Z_ARRVAL_P(data), &pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IS_OBJECT:\n\t\t\tif (Z_OBJ_HT_P(data) != NULL) {\n\t\t\t\tzval out;\n\n\t\t\t\tif (zend_std_cast_object_tostring(data, &out, IS_STRING TSRMLS_CC) == SUCCESS) {\n\t\t\t\t\tnumbytes = php_stream_write(stream, Z_STRVAL(out), Z_STRLEN(out));\n\t\t\t\t\tif (numbytes != Z_STRLEN(out)) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Only %ld of %d bytes written, possibly out of free disk space\", numbytes, Z_STRLEN(out));\n\t\t\t\t\t\tnumbytes = -1;\n\t\t\t\t\t}\n\t\t\t\t\tzval_dtor(&out);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tnumbytes = -1;\n\t\t\tbreak;\n\t}\n\tphp_stream_close(stream);\n\n\tif (numbytes < 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_LONG(numbytes);\n}\n/* }}} */\n\n#define PHP_FILE_BUF_SIZE\t80\n\n/* {{{ proto array file(string filename [, int flags[, resource context]])\n   Read entire file into an array */\nPHP_FUNCTION(file)\n{\n\tchar *filename;\n\tint filename_len;\n\tchar *target_buf=NULL, *p, *s, *e;\n\tregister int i = 0;\n\tint target_len;\n\tchar eol_marker = '\\n';\n\tlong flags = 0;\n\tzend_bool use_include_path;\n\tzend_bool include_new_line;\n\tzend_bool skip_blank_lines;\n\tphp_stream *stream;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\n\t/* Parse arguments */\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|lr!\", &filename, &filename_len, &flags, &zcontext) == FAILURE) {\n\t\treturn;\n\t}\n\tif (flags < 0 || flags > (PHP_FILE_USE_INCLUDE_PATH | PHP_FILE_IGNORE_NEW_LINES | PHP_FILE_SKIP_EMPTY_LINES | PHP_FILE_NO_DEFAULT_CONTEXT)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"'%ld' flag is not supported\", flags);\n\t\tRETURN_FALSE;\n\t}\n\n\tuse_include_path = flags & PHP_FILE_USE_INCLUDE_PATH;\n\tinclude_new_line = !(flags & PHP_FILE_IGNORE_NEW_LINES);\n\tskip_blank_lines = flags & PHP_FILE_SKIP_EMPTY_LINES;\n\n\tcontext = php_stream_context_from_zval(zcontext, flags & PHP_FILE_NO_DEFAULT_CONTEXT);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\", (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Initialize return array */\n\tarray_init(return_value);\n\n\tif ((target_len = php_stream_copy_to_mem(stream, &target_buf, PHP_STREAM_COPY_ALL, 0))) {\n\t\ts = target_buf;\n\t\te = target_buf + target_len;\n\n\t\tif (!(p = php_stream_locate_eol(stream, target_buf, target_len TSRMLS_CC))) {\n\t\t\tp = e;\n\t\t\tgoto parse_eol;\n\t\t}\n\n\t\tif (stream->flags & PHP_STREAM_FLAG_EOL_MAC) {\n\t\t\teol_marker = '\\r';\n\t\t}\n\n\t\t/* for performance reasons the code is duplicated, so that the if (include_new_line)\n\t\t * will not need to be done for every single line in the file. */\n\t\tif (include_new_line) {\n\t\t\tdo {\n\t\t\t\tp++;\nparse_eol:\n\t\t\t\tadd_index_stringl(return_value, i++, estrndup(s, p-s), p-s, 0);\n\t\t\t\ts = p;\n\t\t\t} while ((p = memchr(p, eol_marker, (e-p))));\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tint windows_eol = 0;\n\t\t\t\tif (p != target_buf && eol_marker == '\\n' && *(p - 1) == '\\r') {\n\t\t\t\t\twindows_eol++;\n\t\t\t\t}\n\t\t\t\tif (skip_blank_lines && !(p-s-windows_eol)) {\n\t\t\t\t\ts = ++p;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tadd_index_stringl(return_value, i++, estrndup(s, p-s-windows_eol), p-s-windows_eol, 0);\n\t\t\t\ts = ++p;\n\t\t\t} while ((p = memchr(p, eol_marker, (e-p))));\n\t\t}\n\n\t\t/* handle any left overs of files without new lines */\n\t\tif (s != e) {\n\t\t\tp = e;\n\t\t\tgoto parse_eol;\n\t\t}\n\t}\n\n\tif (target_buf) {\n\t\tefree(target_buf);\n\t}\n\tphp_stream_close(stream);\n}\n/* }}} */\n\n/* {{{ proto string tempnam(string dir, string prefix)\n   Create a unique filename in a directory */\nPHP_FUNCTION(tempnam)\n{\n\tchar *dir, *prefix;\n\tint dir_len, prefix_len;\n\tsize_t p_len;\n\tchar *opened_path;\n\tchar *p;\n\tint fd;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp\", &dir, &dir_len, &prefix, &prefix_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (php_check_open_basedir(dir TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_basename(prefix, prefix_len, NULL, 0, &p, &p_len TSRMLS_CC);\n\tif (p_len > 64) {\n\t\tp[63] = '\\0';\n\t}\n\n\tRETVAL_FALSE;\n\n\tif ((fd = php_open_temporary_fd_ex(dir, p, &opened_path, 1 TSRMLS_CC)) >= 0) {\n\t\tclose(fd);\n\t\tRETVAL_STRING(opened_path, 0);\n\t}\n\tefree(p);\n}\n/* }}} */\n\n/* {{{ proto resource tmpfile(void)\n   Create a temporary file that will be deleted automatically after use */\nPHP_NAMED_FUNCTION(php_if_tmpfile)\n{\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tstream = php_stream_fopen_tmpfile();\n\n\tif (stream) {\n\t\tphp_stream_to_zval(stream, return_value);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource fopen(string filename, string mode [, bool use_include_path [, resource context]])\n   Open a file or a URL and return a file pointer */\nPHP_NAMED_FUNCTION(php_if_fopen)\n{\n\tchar *filename, *mode;\n\tint filename_len, mode_len;\n\tzend_bool use_include_path = 0;\n\tzval *zcontext = NULL;\n\tphp_stream *stream;\n\tphp_stream_context *context = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ps|br\", &filename, &filename_len, &mode, &mode_len, &use_include_path, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, mode, (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\n\tif (stream == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_stream_to_zval(stream, return_value);\n}\n/* }}} */\n\n/* {{{ proto bool fclose(resource fp)\n   Close an open file pointer */\nPHPAPI PHP_FUNCTION(fclose)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif ((stream->flags & PHP_STREAM_FLAG_NO_FCLOSE) != 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%d is not a valid stream resource\", stream->rsrc_id);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!stream->is_persistent) {\n\t\tphp_stream_close(stream);\n\t} else {\n\t\tphp_stream_pclose(stream);\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto resource popen(string command, string mode)\n   Execute a command and open either a read or a write pipe to it */\nPHP_FUNCTION(popen)\n{\n\tchar *command, *mode;\n\tint command_len, mode_len;\n\tFILE *fp;\n\tphp_stream *stream;\n\tchar *posix_mode;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ps\", &command, &command_len, &mode, &mode_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tposix_mode = estrndup(mode, mode_len);\n#ifndef PHP_WIN32\n\t{\n\t\tchar *z = memchr(posix_mode, 'b', mode_len);\n\t\tif (z) {\n\t\t\tmemmove(z, z + 1, mode_len - (z - posix_mode));\n\t\t}\n\t}\n#endif\n\n\tfp = VCWD_POPEN(command, posix_mode);\n\tif (!fp) {\n\t\tphp_error_docref2(NULL TSRMLS_CC, command, posix_mode, E_WARNING, \"%s\", strerror(errno));\n\t\tefree(posix_mode);\n\t\tRETURN_FALSE;\n\t}\n\n\tstream = php_stream_fopen_from_pipe(fp, mode);\n\n\tif (stream == NULL)\t{\n\t\tphp_error_docref2(NULL TSRMLS_CC, command, mode, E_WARNING, \"%s\", strerror(errno));\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tphp_stream_to_zval(stream, return_value);\n\t}\n\n\tefree(posix_mode);\n}\n/* }}} */\n\n/* {{{ proto int pclose(resource fp)\n   Close a file pointer opened by popen() */\nPHP_FUNCTION(pclose)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tFG(pclose_wait) = 1;\n\tzend_list_delete(stream->rsrc_id);\n\tFG(pclose_wait) = 0;\n\tRETURN_LONG(FG(pclose_ret));\n}\n/* }}} */\n\n/* {{{ proto bool feof(resource fp)\n   Test for end-of-file on a file pointer */\nPHPAPI PHP_FUNCTION(feof)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (php_stream_eof(stream)) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string fgets(resource fp[, int length])\n   Get a line from file pointer */\nPHPAPI PHP_FUNCTION(fgets)\n{\n\tzval *arg1;\n\tlong len = 1024;\n\tchar *buf = NULL;\n\tint argc = ZEND_NUM_ARGS();\n\tsize_t line_len = 0;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|l\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (argc == 1) {\n\t\t/* ask streams to give us a buffer of an appropriate size */\n\t\tbuf = php_stream_get_line(stream, NULL, 0, &line_len);\n\t\tif (buf == NULL) {\n\t\t\tgoto exit_failed;\n\t\t}\n\t} else if (argc > 1) {\n\t\tif (len <= 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tbuf = ecalloc(len + 1, sizeof(char));\n\t\tif (php_stream_get_line(stream, buf, len, &line_len) == NULL) {\n\t\t\tgoto exit_failed;\n\t\t}\n\t}\n\n\tZVAL_STRINGL(return_value, buf, line_len, 0);\n\t/* resize buffer if it's much larger than the result.\n\t * Only needed if the user requested a buffer size. */\n\tif (argc > 1 && Z_STRLEN_P(return_value) < len / 2) {\n\t\tZ_STRVAL_P(return_value) = erealloc(buf, line_len + 1);\n\t}\n\treturn;\n\nexit_failed:\n\tRETVAL_FALSE;\n\tif (buf) {\n\t\tefree(buf);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string fgetc(resource fp)\n   Get a character from file pointer */\nPHPAPI PHP_FUNCTION(fgetc)\n{\n\tzval *arg1;\n\tchar buf[2];\n\tint result;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tresult = php_stream_getc(stream);\n\n\tif (result == EOF) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tbuf[0] = result;\n\t\tbuf[1] = '\\0';\n\n\t\tRETURN_STRINGL(buf, 1, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string fgetss(resource fp [, int length [, string allowable_tags]])\n   Get a line from file pointer and strip HTML tags */\nPHPAPI PHP_FUNCTION(fgetss)\n{\n\tzval *fd;\n\tlong bytes = 0;\n\tsize_t len = 0;\n\tsize_t actual_len, retval_len;\n\tchar *buf = NULL, *retval;\n\tphp_stream *stream;\n\tchar *allowed_tags=NULL;\n\tint allowed_tags_len=0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|ls\", &fd, &bytes, &allowed_tags, &allowed_tags_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fd);\n\n\tif (ZEND_NUM_ARGS() >= 2) {\n\t\tif (bytes <= 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tlen = (size_t) bytes;\n\t\tbuf = safe_emalloc(sizeof(char), (len + 1), 0);\n\t\t/*needed because recv doesnt set null char at end*/\n\t\tmemset(buf, 0, len + 1);\n\t}\n\n\tif ((retval = php_stream_get_line(stream, buf, len, &actual_len)) == NULL)\t{\n\t\tif (buf != NULL) {\n\t\t\tefree(buf);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tretval_len = php_strip_tags(retval, actual_len, &stream->fgetss_state, allowed_tags, allowed_tags_len);\n\n\tRETURN_STRINGL(retval, retval_len, 0);\n}\n/* }}} */\n\n/* {{{ proto mixed fscanf(resource stream, string format [, string ...])\n   Implements a mostly ANSI compatible fscanf() */\nPHP_FUNCTION(fscanf)\n{\n\tint result, format_len, type, argc = 0;\n\tzval ***args = NULL;\n\tzval *file_handle;\n\tchar *buf, *format;\n\tsize_t len;\n\tvoid *what;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs*\", &file_handle, &format, &format_len, &args, &argc) == FAILURE) {\n\t\treturn;\n\t}\n\n\twhat = zend_fetch_resource(&file_handle TSRMLS_CC, -1, \"File-Handle\", &type, 2, php_file_le_stream(), php_file_le_pstream());\n\n\t/* we can't do a ZEND_VERIFY_RESOURCE(what), otherwise we end up\n\t * with a leak if we have an invalid filehandle. This needs changing\n\t * if the code behind ZEND_VERIFY_RESOURCE changed. - cc */\n\tif (!what) {\n\t\tif (args) {\n\t\t\tefree(args);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tbuf = php_stream_get_line((php_stream *) what, NULL, 0, &len);\n\tif (buf == NULL) {\n\t\tif (args) {\n\t\t\tefree(args);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\n\tresult = php_sscanf_internal(buf, format, argc, args, 0, &return_value TSRMLS_CC);\n\n\tif (args) {\n\t\tefree(args);\n\t}\n\tefree(buf);\n\n\tif (SCAN_ERROR_WRONG_PARAM_COUNT == result) {\n\t\tWRONG_PARAM_COUNT;\n\t}\n}\n/* }}} */\n\n/* {{{ proto int fwrite(resource fp, string str [, int length])\n   Binary-safe file write */\nPHPAPI PHP_FUNCTION(fwrite)\n{\n\tzval *arg1;\n\tchar *arg2;\n\tint arg2len;\n\tint ret;\n\tint num_bytes;\n\tlong arg3 = 0;\n\tchar *buffer = NULL;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs|l\", &arg1, &arg2, &arg2len, &arg3) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZEND_NUM_ARGS() == 2) {\n\t\tnum_bytes = arg2len;\n\t} else {\n\t\tnum_bytes = MAX(0, MIN((int)arg3, arg2len));\n\t}\n\n\tif (!num_bytes) {\n\t\tRETURN_LONG(0);\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tret = php_stream_write(stream, buffer ? buffer : arg2, num_bytes);\n\tif (buffer) {\n\t\tefree(buffer);\n\t}\n\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ proto bool fflush(resource fp)\n   Flushes output */\nPHPAPI PHP_FUNCTION(fflush)\n{\n\tzval *arg1;\n\tint ret;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tret = php_stream_flush(stream);\n\tif (ret) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool rewind(resource fp)\n   Rewind the position of a file pointer */\nPHPAPI PHP_FUNCTION(rewind)\n{\n\tzval *arg1;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (-1 == php_stream_rewind(stream)) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto int ftell(resource fp)\n   Get file pointer's read/write position */\nPHPAPI PHP_FUNCTION(ftell)\n{\n\tzval *arg1;\n\tlong ret;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tret = php_stream_tell(stream);\n\tif (ret == -1)\t{\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ proto int fseek(resource fp, int offset [, int whence])\n   Seek on a file pointer */\nPHPAPI PHP_FUNCTION(fseek)\n{\n\tzval *arg1;\n\tlong arg2, whence = SEEK_SET;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl|l\", &arg1, &arg2, &whence) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tRETURN_LONG(php_stream_seek(stream, arg2, whence));\n}\n/* }}} */\n\n/* {{{ php_mkdir\n*/\n\n/* DEPRECATED APIs: Use php_stream_mkdir() instead */\nPHPAPI int php_mkdir_ex(char *dir, long mode, int options TSRMLS_DC)\n{\n\tint ret;\n\n\tif (php_check_open_basedir(dir TSRMLS_CC)) {\n\t\treturn -1;\n\t}\n\n\tif ((ret = VCWD_MKDIR(dir, (mode_t)mode)) < 0 && (options & REPORT_ERRORS)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t}\n\n\treturn ret;\n}\n\nPHPAPI int php_mkdir(char *dir, long mode TSRMLS_DC)\n{\n\treturn php_mkdir_ex(dir, mode, REPORT_ERRORS TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto bool mkdir(string pathname [, int mode [, bool recursive [, resource context]]])\n   Create a directory */\nPHP_FUNCTION(mkdir)\n{\n\tchar *dir;\n\tint dir_len;\n\tzval *zcontext = NULL;\n\tlong mode = 0777;\n\tzend_bool recursive = 0;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|lbr\", &dir, &dir_len, &mode, &recursive, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(php_stream_mkdir(dir, mode, (recursive ? PHP_STREAM_MKDIR_RECURSIVE : 0) | REPORT_ERRORS, context));\n}\n/* }}} */\n\n/* {{{ proto bool rmdir(string dirname[, resource context])\n   Remove a directory */\nPHP_FUNCTION(rmdir)\n{\n\tchar *dir;\n\tint dir_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|r\", &dir, &dir_len, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(php_stream_rmdir(dir, REPORT_ERRORS, context));\n}\n/* }}} */\n\n/* {{{ proto int readfile(string filename [, bool use_include_path[, resource context]])\n   Output a file or a URL */\nPHP_FUNCTION(readfile)\n{\n\tchar *filename;\n\tint filename_len;\n\tint size = 0;\n\tzend_bool use_include_path = 0;\n\tzval *zcontext = NULL;\n\tphp_stream *stream;\n\tphp_stream_context *context = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|br!\", &filename, &filename_len, &use_include_path, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\", (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, context);\n\tif (stream) {\n\t\tsize = php_stream_passthru(stream);\n\t\tphp_stream_close(stream);\n\t\tRETURN_LONG(size);\n\t}\n\n\tRETURN_FALSE;\n}\n/* }}} */\n\n/* {{{ proto int umask([int mask])\n   Return or change the umask */\nPHP_FUNCTION(umask)\n{\n\tlong arg1 = 0;\n\tint oldumask;\n\n\toldumask = umask(077);\n\n\tif (BG(umask) == -1) {\n\t\tBG(umask) = oldumask;\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZEND_NUM_ARGS() == 0) {\n\t\tumask(oldumask);\n\t} else {\n\t\tumask(arg1);\n\t}\n\n\tRETURN_LONG(oldumask);\n}\n/* }}} */\n\n/* {{{ proto int fpassthru(resource fp)\n   Output all remaining data from a file pointer */\nPHPAPI PHP_FUNCTION(fpassthru)\n{\n\tzval *arg1;\n\tint size;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &arg1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tsize = php_stream_passthru(stream);\n\tRETURN_LONG(size);\n}\n/* }}} */\n\n/* {{{ proto bool rename(string old_name, string new_name[, resource context])\n   Rename a file */\nPHP_FUNCTION(rename)\n{\n\tchar *old_name, *new_name;\n\tint old_name_len, new_name_len;\n\tzval *zcontext = NULL;\n\tphp_stream_wrapper *wrapper;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp|r\", &old_name, &old_name_len, &new_name, &new_name_len, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\twrapper = php_stream_locate_url_wrapper(old_name, NULL, 0 TSRMLS_CC);\n\n\tif (!wrapper || !wrapper->wops) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to locate stream wrapper\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!wrapper->wops->rename) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s wrapper does not support renaming\", wrapper->wops->label ? wrapper->wops->label : \"Source\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (wrapper != php_stream_locate_url_wrapper(new_name, NULL, 0 TSRMLS_CC)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot rename a file across wrapper types\");\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(wrapper->wops->rename(wrapper, old_name, new_name, 0, context TSRMLS_CC));\n}\n/* }}} */\n\n/* {{{ proto bool unlink(string filename[, context context])\n   Delete a file */\nPHP_FUNCTION(unlink)\n{\n\tchar *filename;\n\tint filename_len;\n\tphp_stream_wrapper *wrapper;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|r\", &filename, &filename_len, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\twrapper = php_stream_locate_url_wrapper(filename, NULL, 0 TSRMLS_CC);\n\n\tif (!wrapper || !wrapper->wops) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to locate stream wrapper\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!wrapper->wops->unlink) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s does not allow unlinking\", wrapper->wops->label ? wrapper->wops->label : \"Wrapper\");\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_BOOL(wrapper->wops->unlink(wrapper, filename, REPORT_ERRORS, context TSRMLS_CC));\n}\n/* }}} */\n\n/* {{{ proto bool ftruncate(resource fp, int size)\n   Truncate file to 'size' length */\nPHP_NAMED_FUNCTION(php_if_ftruncate)\n{\n\tzval *fp;\n\tlong size;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &fp, &size) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fp);\n\n\tif (!php_stream_truncate_supported(stream)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Can't truncate this stream!\");\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL(0 == php_stream_truncate_set_size(stream, size));\n}\n/* }}} */\n\n/* {{{ proto array fstat(resource fp)\n   Stat() on a filehandle */\nPHP_NAMED_FUNCTION(php_if_fstat)\n{\n\tzval *fp;\n\tzval *stat_dev, *stat_ino, *stat_mode, *stat_nlink, *stat_uid, *stat_gid, *stat_rdev,\n\t\t *stat_size, *stat_atime, *stat_mtime, *stat_ctime, *stat_blksize, *stat_blocks;\n\tphp_stream *stream;\n\tphp_stream_statbuf stat_ssb;\n\tchar *stat_sb_names[13] = {\n\t\t\"dev\", \"ino\", \"mode\", \"nlink\", \"uid\", \"gid\", \"rdev\",\n\t\t\"size\", \"atime\", \"mtime\", \"ctime\", \"blksize\", \"blocks\"\n\t};\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &fp) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fp);\n\n\tif (php_stream_stat(stream, &stat_ssb)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\tMAKE_LONG_ZVAL_INCREF(stat_dev, stat_ssb.sb.st_dev);\n\tMAKE_LONG_ZVAL_INCREF(stat_ino, stat_ssb.sb.st_ino);\n\tMAKE_LONG_ZVAL_INCREF(stat_mode, stat_ssb.sb.st_mode);\n\tMAKE_LONG_ZVAL_INCREF(stat_nlink, stat_ssb.sb.st_nlink);\n\tMAKE_LONG_ZVAL_INCREF(stat_uid, stat_ssb.sb.st_uid);\n\tMAKE_LONG_ZVAL_INCREF(stat_gid, stat_ssb.sb.st_gid);\n#ifdef HAVE_ST_RDEV\n\tMAKE_LONG_ZVAL_INCREF(stat_rdev, stat_ssb.sb.st_rdev);\n#else\n\tMAKE_LONG_ZVAL_INCREF(stat_rdev, -1);\n#endif\n\tMAKE_LONG_ZVAL_INCREF(stat_size, stat_ssb.sb.st_size);\n\tMAKE_LONG_ZVAL_INCREF(stat_atime, stat_ssb.sb.st_atime);\n\tMAKE_LONG_ZVAL_INCREF(stat_mtime, stat_ssb.sb.st_mtime);\n\tMAKE_LONG_ZVAL_INCREF(stat_ctime, stat_ssb.sb.st_ctime);\n#ifdef HAVE_ST_BLKSIZE\n\tMAKE_LONG_ZVAL_INCREF(stat_blksize, stat_ssb.sb.st_blksize);\n#else\n\tMAKE_LONG_ZVAL_INCREF(stat_blksize,-1);\n#endif\n#ifdef HAVE_ST_BLOCKS\n\tMAKE_LONG_ZVAL_INCREF(stat_blocks, stat_ssb.sb.st_blocks);\n#else\n\tMAKE_LONG_ZVAL_INCREF(stat_blocks,-1);\n#endif\n\t/* Store numeric indexes in propper order */\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_dev, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_ino, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_mode, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_nlink, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_uid, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_gid, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_rdev, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_size, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_atime, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_mtime, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_ctime, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_blksize, sizeof(zval *), NULL);\n\tzend_hash_next_index_insert(HASH_OF(return_value), (void *)&stat_blocks, sizeof(zval *), NULL);\n\n\t/* Store string indexes referencing the same zval*/\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[0], strlen(stat_sb_names[0])+1, (void *)&stat_dev, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[1], strlen(stat_sb_names[1])+1, (void *)&stat_ino, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[2], strlen(stat_sb_names[2])+1, (void *)&stat_mode, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[3], strlen(stat_sb_names[3])+1, (void *)&stat_nlink, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[4], strlen(stat_sb_names[4])+1, (void *)&stat_uid, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[5], strlen(stat_sb_names[5])+1, (void *)&stat_gid, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[6], strlen(stat_sb_names[6])+1, (void *)&stat_rdev, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[7], strlen(stat_sb_names[7])+1, (void *)&stat_size, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[8], strlen(stat_sb_names[8])+1, (void *)&stat_atime, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[9], strlen(stat_sb_names[9])+1, (void *)&stat_mtime, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[10], strlen(stat_sb_names[10])+1, (void *)&stat_ctime, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[11], strlen(stat_sb_names[11])+1, (void *)&stat_blksize, sizeof(zval *), NULL);\n\tzend_hash_update(HASH_OF(return_value), stat_sb_names[12], strlen(stat_sb_names[12])+1, (void *)&stat_blocks, sizeof(zval *), NULL);\n}\n/* }}} */\n\n/* {{{ proto bool copy(string source_file, string destination_file [, resource context])\n   Copy a file */\nPHP_FUNCTION(copy)\n{\n\tchar *source, *target;\n\tint source_len, target_len;\n\tzval *zcontext = NULL;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp|r\", &source, &source_len, &target, &target_len, &zcontext) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (php_check_open_basedir(source TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tif (php_copy_file_ctx(source, target, 0, context TSRMLS_CC) == SUCCESS) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ php_copy_file\n */\nPHPAPI int php_copy_file(char *src, char *dest TSRMLS_DC)\n{\n\treturn php_copy_file_ctx(src, dest, 0, NULL TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ php_copy_file_ex\n */\nPHPAPI int php_copy_file_ex(char *src, char *dest, int src_flg TSRMLS_DC)\n{\n\treturn php_copy_file_ctx(src, dest, 0, NULL TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ php_copy_file_ctx\n */\nPHPAPI int php_copy_file_ctx(char *src, char *dest, int src_flg, php_stream_context *ctx TSRMLS_DC)\n{\n\tphp_stream *srcstream = NULL, *deststream = NULL;\n\tint ret = FAILURE;\n\tphp_stream_statbuf src_s, dest_s;\n\n\tswitch (php_stream_stat_path_ex(src, 0, &src_s, ctx)) {\n\t\tcase -1:\n\t\t\t/* non-statable stream */\n\t\t\tgoto safe_to_copy;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault: /* failed to stat file, does not exist? */\n\t\t\treturn ret;\n\t}\n\tif (S_ISDIR(src_s.sb.st_mode)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The first argument to copy() function cannot be a directory\");\n\t\treturn FAILURE;\n\t}\n\n\tswitch (php_stream_stat_path_ex(dest, PHP_STREAM_URL_STAT_QUIET | PHP_STREAM_URL_STAT_NOCACHE, &dest_s, ctx)) {\n\t\tcase -1:\n\t\t\t/* non-statable stream */\n\t\t\tgoto safe_to_copy;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault: /* failed to stat file, does not exist? */\n\t\t\treturn ret;\n\t}\n\tif (S_ISDIR(dest_s.sb.st_mode)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The second argument to copy() function cannot be a directory\");\n\t\treturn FAILURE;\n\t}\n\tif (!src_s.sb.st_ino || !dest_s.sb.st_ino) {\n\t\tgoto no_stat;\n\t}\n\tif (src_s.sb.st_ino == dest_s.sb.st_ino && src_s.sb.st_dev == dest_s.sb.st_dev) {\n\t\treturn ret;\n\t} else {\n\t\tgoto safe_to_copy;\n\t}\nno_stat:\n\t{\n\t\tchar *sp, *dp;\n\t\tint res;\n\n\t\tif ((sp = expand_filepath(src, NULL TSRMLS_CC)) == NULL) {\n\t\t\treturn ret;\n\t\t}\n\t\tif ((dp = expand_filepath(dest, NULL TSRMLS_CC)) == NULL) {\n\t\t\tefree(sp);\n\t\t\tgoto safe_to_copy;\n\t\t}\n\n\t\tres =\n#ifndef PHP_WIN32\n\t\t\t!strcmp(sp, dp);\n#else\n\t\t\t!strcasecmp(sp, dp);\n#endif\n\n\t\tefree(sp);\n\t\tefree(dp);\n\t\tif (res) {\n\t\t\treturn ret;\n\t\t}\n\t}\nsafe_to_copy:\n\n\tsrcstream = php_stream_open_wrapper_ex(src, \"rb\", src_flg | REPORT_ERRORS, NULL, ctx);\n\n\tif (!srcstream) {\n\t\treturn ret;\n\t}\n\n\tdeststream = php_stream_open_wrapper_ex(dest, \"wb\", REPORT_ERRORS, NULL, ctx);\n\n\tif (srcstream && deststream) {\n\t\tret = php_stream_copy_to_stream_ex(srcstream, deststream, PHP_STREAM_COPY_ALL, NULL);\n\t}\n\tif (srcstream) {\n\t\tphp_stream_close(srcstream);\n\t}\n\tif (deststream) {\n\t\tphp_stream_close(deststream);\n\t}\n\treturn ret;\n}\n/* }}} */\n\n/* {{{ proto string fread(resource fp, int length)\n   Binary-safe file read */\nPHPAPI PHP_FUNCTION(fread)\n{\n\tzval *arg1;\n\tlong len;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (len <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\n\n>>> [ INFILL ] <<<\n\tZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\n\n\t/* needed because recv/read/gzread doesnt put a null at the end*/\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}\n/* }}} */\n\nstatic const char *php_fgetcsv_lookup_trailing_spaces(const char *ptr, size_t len, const char delimiter TSRMLS_DC) /* {{{ */\n{\n\tint inc_len;\n\tunsigned char last_chars[2] = { 0, 0 };\n\n\twhile (len > 0) {\n\t\tinc_len = (*ptr == '\\0' ? 1: php_mblen(ptr, len));\n\t\tswitch (inc_len) {\n\t\t\tcase -2:\n\t\t\tcase -1:\n\t\t\t\tinc_len = 1;\n\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tgoto quit_loop;\n\t\t\tcase 1:\n\t\t\tdefault:\n\t\t\t\tlast_chars[0] = last_chars[1];\n\t\t\t\tlast_chars[1] = *ptr;\n\t\t\t\tbreak;\n\t\t}\n\t\tptr += inc_len;\n\t\tlen -= inc_len;\n\t}\nquit_loop:\n\tswitch (last_chars[1]) {\n\t\tcase '\\n':\n\t\t\tif (last_chars[0] == '\\r') {\n\t\t\t\treturn ptr - 2;\n\t\t\t}\n\t\t\t/* break is omitted intentionally */\n\t\tcase '\\r':\n\t\t\treturn ptr - 1;\n\t}\n\treturn ptr;\n}\n/* }}} */\n\n#define FPUTCSV_FLD_CHK(c) memchr(Z_STRVAL(field), c, Z_STRLEN(field))\n\n/* {{{ proto int fputcsv(resource fp, array fields [, string delimiter [, string enclosure [, string escape_char]]])\n   Format line as CSV and write to file pointer */\nPHP_FUNCTION(fputcsv)\n{\n\tchar delimiter = ',';\t /* allow this to be set as parameter */\n\tchar enclosure = '\"';\t /* allow this to be set as parameter */\n\tchar escape_char = '\\\\'; /* allow this to be set as parameter */\n\tphp_stream *stream;\n\tzval *fp = NULL, *fields = NULL;\n\tint ret;\n\tchar *delimiter_str = NULL, *enclosure_str = NULL, *escape_str = NULL;\n\tint delimiter_str_len = 0, enclosure_str_len = 0, escape_str_len = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra|sss\",\n\t\t\t&fp, &fields, &delimiter_str, &delimiter_str_len,\n\t\t\t&enclosure_str, &enclosure_str_len,\n\t\t\t&escape_str, &escape_str_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (delimiter_str != NULL) {\n\t\t/* Make sure that there is at least one character in string */\n\t\tif (delimiter_str_len < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n\t\t\tRETURN_FALSE;\n\t\t} else if (delimiter_str_len > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"delimiter must be a single character\");\n\t\t}\n\n\t\t/* use first character from string */\n\t\tdelimiter = *delimiter_str;\n\t}\n\n\tif (enclosure_str != NULL) {\n\t\tif (enclosure_str_len < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n\t\t\tRETURN_FALSE;\n\t\t} else if (enclosure_str_len > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"enclosure must be a single character\");\n\t\t}\n\t\t/* use first character from string */\n\t\tenclosure = *enclosure_str;\n\t}\n\n\tif (escape_str != NULL) {\n\t\tif (escape_str_len < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be a character\");\n\t\t\tRETURN_FALSE;\n\t\t} else if (escape_str_len > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"escape must be a single character\");\n\t\t}\n\t\t/* use first character from string */\n\t\tescape_char = *escape_str;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &fp);\n\n\tret = php_fputcsv(stream, fields, delimiter, enclosure, escape_char TSRMLS_CC);\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ PHPAPI int php_fputcsv(php_stream *stream, zval *fields, char delimiter, char enclosure, char escape_char TSRMLS_DC) */\nPHPAPI int php_fputcsv(php_stream *stream, zval *fields, char delimiter, char enclosure, char escape_char TSRMLS_DC)\n{\n\tint count, i = 0, ret;\n\tzval **field_tmp = NULL, field;\n\tsmart_str csvline = {0};\n\tHashPosition pos;\n\n\tcount = zend_hash_num_elements(Z_ARRVAL_P(fields));\n\tzend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(fields), &pos);\n\twhile (zend_hash_get_current_data_ex(Z_ARRVAL_P(fields), (void **) &field_tmp, &pos) == SUCCESS) {\n\t\tfield = **field_tmp;\n\n\t\tif (Z_TYPE_PP(field_tmp) != IS_STRING) {\n\t\t\tzval_copy_ctor(&field);\n\t\t\tconvert_to_string(&field);\n\t\t}\n\n\t\t/* enclose a field that contains a delimiter, an enclosure character, or a newline */\n\t\tif (FPUTCSV_FLD_CHK(delimiter) ||\n\t\t\tFPUTCSV_FLD_CHK(enclosure) ||\n\t\t\tFPUTCSV_FLD_CHK(escape_char) ||\n\t\t\tFPUTCSV_FLD_CHK('\\n') ||\n\t\t\tFPUTCSV_FLD_CHK('\\r') ||\n\t\t\tFPUTCSV_FLD_CHK('\\t') ||\n\t\t\tFPUTCSV_FLD_CHK(' ')\n\t\t) {\n\t\t\tchar *ch = Z_STRVAL(field);\n\t\t\tchar *end = ch + Z_STRLEN(field);\n\t\t\tint escaped = 0;\n\n\t\t\tsmart_str_appendc(&csvline, enclosure);\n\t\t\twhile (ch < end) {\n\t\t\t\tif (*ch == escape_char) {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t} else if (!escaped && *ch == enclosure) {\n\t\t\t\t\tsmart_str_appendc(&csvline, enclosure);\n\t\t\t\t} else {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t}\n\t\t\t\tsmart_str_appendc(&csvline, *ch);\n\t\t\t\tch++;\n\t\t\t}\n\t\t\tsmart_str_appendc(&csvline, enclosure);\n\t\t} else {\n\t\t\tsmart_str_appendl(&csvline, Z_STRVAL(field), Z_STRLEN(field));\n\t\t}\n\n\t\tif (++i != count) {\n\t\t\tsmart_str_appendl(&csvline, &delimiter, 1);\n\t\t}\n\t\tzend_hash_move_forward_ex(Z_ARRVAL_P(fields), &pos);\n\n\t\tif (Z_TYPE_PP(field_tmp) != IS_STRING) {\n\t\t\tzval_dtor(&field);\n\t\t}\n\t}\n\n\tsmart_str_appendc(&csvline, '\\n');\n\tsmart_str_0(&csvline);\n\n\tret = php_stream_write(stream, csvline.c, csvline.len);\n\n\tsmart_str_free(&csvline);\n\n\treturn ret;\n}\n/* }}} */\n\n/* {{{ proto array fgetcsv(resource fp [,int length [, string delimiter [, string enclosure [, string escape]]]])\n   Get line from file pointer and parse for CSV fields */\nPHP_FUNCTION(fgetcsv)\n{\n\tchar delimiter = ',';\t/* allow this to be set as parameter */\n\tchar enclosure = '\"';\t/* allow this to be set as parameter */\n\tchar escape = '\\\\';\n\n\t/* first section exactly as php_fgetss */\n\n\tlong len = 0;\n\tsize_t buf_len;\n\tchar *buf;\n\tphp_stream *stream;\n\n\t{\n\t\tzval *fd, **len_zv = NULL;\n\t\tchar *delimiter_str = NULL;\n\t\tint delimiter_str_len = 0;\n\t\tchar *enclosure_str = NULL;\n\t\tint enclosure_str_len = 0;\n\t\tchar *escape_str = NULL;\n\t\tint escape_str_len = 0;\n\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|Zsss\",\n\t\t\t&fd, &len_zv, &delimiter_str, &delimiter_str_len,\n\t\t\t&enclosure_str, &enclosure_str_len,\n\t\t\t&escape_str, &escape_str_len) == FAILURE\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (delimiter_str != NULL) {\n\t\t\t/* Make sure that there is at least one character in string */\n\t\t\tif (delimiter_str_len < 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (delimiter_str_len > 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"delimiter must be a single character\");\n\t\t\t}\n\n\t\t\t/* use first character from string */\n\t\t\tdelimiter = delimiter_str[0];\n\t\t}\n\n\t\tif (enclosure_str != NULL) {\n\t\t\tif (enclosure_str_len < 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (enclosure_str_len > 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"enclosure must be a single character\");\n\t\t\t}\n\n\t\t\t/* use first character from string */\n\t\t\tenclosure = enclosure_str[0];\n\t\t}\n\n\t\tif (escape_str != NULL) {\n\t\t\tif (escape_str_len < 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (escape_str_len > 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"escape must be a single character\");\n\t\t\t}\n\n\t\t\tescape = escape_str[0];\n\t\t}\n\n\t\tif (len_zv != NULL && Z_TYPE_PP(len_zv) != IS_NULL) {\n\t\t\tconvert_to_long_ex(len_zv);\n\t\t\tlen = Z_LVAL_PP(len_zv);\n\t\t\tif (len < 0) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter may not be negative\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t} else if (len == 0) {\n\t\t\t\tlen = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tlen = -1;\n\t\t}\n\n\t\tPHP_STREAM_TO_ZVAL(stream, &fd);\n\t}\n\n\tif (len < 0) {\n\t\tif ((buf = php_stream_get_line(stream, NULL, 0, &buf_len)) == NULL) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tbuf = emalloc(len + 1);\n\t\tif (php_stream_get_line(stream, buf, len + 1, &buf_len) == NULL) {\n\t\t\tefree(buf);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tphp_fgetcsv(stream, delimiter, enclosure, escape, buf_len, buf, return_value TSRMLS_CC);\n}\n/* }}} */\n\nPHPAPI void php_fgetcsv(php_stream *stream, char delimiter, char enclosure, char escape_char, size_t buf_len, char *buf, zval *return_value TSRMLS_DC) /* {{{ */\n{\n\tchar *temp, *tptr, *bptr, *line_end, *limit;\n\tsize_t temp_len, line_end_len;\n\tint inc_len;\n\tzend_bool first_field = 1;\n\n\t/* initialize internal state */\n\tphp_ignore_value(php_mblen(NULL, 0));\n\n\t/* Now into new section that parses buf for delimiter/enclosure fields */\n\n\t/* Strip trailing space from buf, saving end of line in case required for enclosure field */\n\n\tbptr = buf;\n\ttptr = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len, delimiter TSRMLS_CC);\n\tline_end_len = buf_len - (size_t)(tptr - buf);\n\tline_end = limit = tptr;\n\n\t/* reserve workspace for building each individual field */\n\ttemp_len = buf_len;\n\ttemp = emalloc(temp_len + line_end_len + 1);\n\n\t/* Initialize return array */\n\tarray_init(return_value);\n\n\t/* Main loop to read CSV fields */\n\t/* NB this routine will return a single null entry for a blank line */\n\n\tdo {\n\t\tchar *comp_end, *hunk_begin;\n\n\t\ttptr = temp;\n\n\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\tif (inc_len == 1) {\n\t\t\tchar *tmp = bptr;\n\t\t\twhile ((*tmp != delimiter) && isspace((int)*(unsigned char *)tmp)) {\n\t\t\t\ttmp++;\n  \t\t\t}\n\t\t\tif (*tmp == enclosure) {\n\t\t\t\tbptr = tmp;\n\t\t\t}\n  \t\t}\n\n\t\tif (first_field && bptr == line_end) {\n\t\t\tadd_next_index_null(return_value);\n\t\t\tbreak;\n\t\t}\n\t\tfirst_field = 0;\n\t\t/* 2. Read field, leaving bptr pointing at start of next field */\n\t\tif (inc_len != 0 && *bptr == enclosure) {\n\t\t\tint state = 0;\n\n\t\t\tbptr++;\t/* move on to first character in field */\n\t\t\thunk_begin = bptr;\n\n\t\t\t/* 2A. handle enclosure delimited field */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (inc_len) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\t/* break is omitted intentionally */\n\n\t\t\t\t\t\t\tcase 0: {\n\t\t\t\t\t\t\t\tchar *new_buf;\n\t\t\t\t\t\t\t\tsize_t new_len;\n\t\t\t\t\t\t\t\tchar *new_temp;\n\n\t\t\t\t\t\t\t\tif (hunk_begin != line_end) {\n\t\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t/* add the embedded line end to the field */\n\t\t\t\t\t\t\t\tmemcpy(tptr, line_end, line_end_len);\n\t\t\t\t\t\t\t\ttptr += line_end_len;\n\n\t\t\t\t\t\t\t\tif (stream == NULL) {\n\t\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\t\t} else if ((new_buf = php_stream_get_line(stream, NULL, 0, &new_len)) == NULL) {\n\t\t\t\t\t\t\t\t\t/* we've got an unterminated enclosure,\n\t\t\t\t\t\t\t\t\t * assign all the data from the start of\n\t\t\t\t\t\t\t\t\t * the enclosure to end of data to the\n\t\t\t\t\t\t\t\t\t * last element */\n\t\t\t\t\t\t\t\t\tif ((size_t)temp_len > (size_t)(limit - buf)) {\n\t\t\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tzval_dtor(return_value);\n\t\t\t\t\t\t\t\t\tRETVAL_FALSE;\n\t\t\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttemp_len += new_len;\n\t\t\t\t\t\t\t\tnew_temp = erealloc(temp, temp_len);\n\t\t\t\t\t\t\t\ttptr = new_temp + (size_t)(tptr - temp);\n\t\t\t\t\t\t\t\ttemp = new_temp;\n\n\t\t\t\t\t\t\t\tefree(buf);\n\t\t\t\t\t\t\t\tbuf_len = new_len;\n\t\t\t\t\t\t\t\tbptr = buf = new_buf;\n\t\t\t\t\t\t\t\thunk_begin = buf;\n\n\t\t\t\t\t\t\t\tline_end = limit = (char *)php_fgetcsv_lookup_trailing_spaces(buf, buf_len, delimiter TSRMLS_CC);\n\t\t\t\t\t\t\t\tline_end_len = buf_len - (size_t)(limit - buf);\n\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t} break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase -2:\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\t\t\t/* break is omitted intentionally */\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t/* we need to determine if the enclosure is\n\t\t\t\t\t\t * 'real' or is it escaped */\n\t\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\t\tcase 1: /* escaped */\n\t\t\t\t\t\t\t\tbptr++;\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2: /* embedded enclosure ? let's check it */\n\t\t\t\t\t\t\t\tif (*bptr != enclosure) {\n\t\t\t\t\t\t\t\t\t/* real enclosure */\n\t\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\tbptr++;\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tif (*bptr == enclosure) {\n\t\t\t\t\t\t\t\t\tstate = 2;\n\t\t\t\t\t\t\t\t} else if (*bptr == escape_char) {\n\t\t\t\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbptr++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tswitch (state) {\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t/* real enclosure */\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin - 1);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tgoto quit_loop_2;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tbptr += inc_len;\n\t\t\t\t\t\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\t\t\t\t\t\ttptr += (bptr - hunk_begin);\n\t\t\t\t\t\t\t\thunk_begin = bptr;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbptr += inc_len;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\t\t}\n\n\t\tquit_loop_2:\n\t\t\t/* look up for a delimiter */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (inc_len) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tgoto quit_loop_3;\n\n\t\t\t\t\tcase -2:\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tinc_len = 1;\n\t\t\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\t\t\t/* break is omitted intentionally */\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (*bptr == delimiter) {\n\t\t\t\t\t\t\tgoto quit_loop_3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbptr += inc_len;\n\t\t\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\t\t}\n\n\t\tquit_loop_3:\n\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\ttptr += (bptr - hunk_begin);\n\t\t\tbptr += inc_len;\n\t\t\tcomp_end = tptr;\n\t\t} else {\n\t\t\t/* 2B. Handle non-enclosure field */\n\n\t\t\thunk_begin = bptr;\n\n\t\t\tfor (;;) {\n\t\t\t\tswitch (inc_len) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tgoto quit_loop_4;\n\t\t\t\t\tcase -2:\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tinc_len = 1;\n\t\t\t\t\t\tphp_ignore_value(php_mblen(NULL, 0));\n\t\t\t\t\t\t/* break is omitted intentionally */\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (*bptr == delimiter) {\n\t\t\t\t\t\t\tgoto quit_loop_4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbptr += inc_len;\n\t\t\t\tinc_len = (bptr < limit ? (*bptr == '\\0' ? 1: php_mblen(bptr, limit - bptr)): 0);\n\t\t\t}\n\t\tquit_loop_4:\n\t\t\tmemcpy(tptr, hunk_begin, bptr - hunk_begin);\n\t\t\ttptr += (bptr - hunk_begin);\n\n\t\t\tcomp_end = (char *)php_fgetcsv_lookup_trailing_spaces(temp, tptr - temp, delimiter TSRMLS_CC);\n\t\t\tif (*bptr == delimiter) {\n\t\t\t\tbptr++;\n\t\t\t}\n\t\t}\n\n\t\t/* 3. Now pass our field back to php */\n\t\t*comp_end = '\\0';\n\t\tadd_next_index_stringl(return_value, temp, comp_end - temp, 1);\n\t} while (inc_len > 0);\n\nout:\n\tefree(temp);\n\tif (stream) {\n\t\tefree(buf);\n\t}\n}\n/* }}} */\n\n#if (!defined(__BEOS__) && !defined(NETWARE) && HAVE_REALPATH) || defined(ZTS)\n/* {{{ proto string realpath(string path)\n   Return the resolved path */\nPHP_FUNCTION(realpath)\n{\n\tchar *filename;\n\tint filename_len;\n\tchar resolved_path_buff[MAXPATHLEN];\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p\", &filename, &filename_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (VCWD_REALPATH(filename, resolved_path_buff)) {\n\t\tif (php_check_open_basedir(resolved_path_buff TSRMLS_CC)) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\n#ifdef ZTS\n\t\tif (VCWD_ACCESS(resolved_path_buff, F_OK)) {\n\t\t\tRETURN_FALSE;\n\t\t}\n#endif\n\t\tRETURN_STRING(resolved_path_buff, 1);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n#endif\n\n/* See http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2 */\n#define PHP_META_HTML401_CHARS \"-_.:\"\n\n/* {{{ php_next_meta_token\n   Tokenizes an HTML file for get_meta_tags */\nphp_meta_tags_token php_next_meta_token(php_meta_tags_data *md TSRMLS_DC)\n{\n\tint ch = 0, compliment;\n\tchar buff[META_DEF_BUFSIZE + 1];\n\n\tmemset((void *)buff, 0, META_DEF_BUFSIZE + 1);\n\n\twhile (md->ulc || (!php_stream_eof(md->stream) && (ch = php_stream_getc(md->stream)))) {\n\t\tif (php_stream_eof(md->stream)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (md->ulc) {\n\t\t\tch = md->lc;\n\t\t\tmd->ulc = 0;\n\t\t}\n\n\t\tswitch (ch) {\n\t\t\tcase '<':\n\t\t\t\treturn TOK_OPENTAG;\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\treturn TOK_CLOSETAG;\n\t\t\t\tbreak;\n\n\t\t\tcase '=':\n\t\t\t\treturn TOK_EQUAL;\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\treturn TOK_SLASH;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tcompliment = ch;\n\t\t\t\tmd->token_len = 0;\n\t\t\t\twhile (!php_stream_eof(md->stream) && (ch = php_stream_getc(md->stream)) && ch != compliment && ch != '<' && ch != '>') {\n\t\t\t\t\tbuff[(md->token_len)++] = ch;\n\n\t\t\t\t\tif (md->token_len == META_DEF_BUFSIZE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ch == '<' || ch == '>') {\n\t\t\t\t\t/* Was just an apostrohpe */\n\t\t\t\t\tmd->ulc = 1;\n\t\t\t\t\tmd->lc = ch;\n\t\t\t\t}\n\n\t\t\t\t/* We don't need to alloc unless we are in a meta tag */\n\t\t\t\tif (md->in_meta) {\n\t\t\t\t\tmd->token_data = (char *) emalloc(md->token_len + 1);\n\t\t\t\t\tmemcpy(md->token_data, buff, md->token_len+1);\n\t\t\t\t}\n\n\t\t\t\treturn TOK_STRING;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\n':\n\t\t\tcase '\\r':\n\t\t\tcase '\\t':\n\t\t\t\tbreak;\n\n\t\t\tcase ' ':\n\t\t\t\treturn TOK_SPACE;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (isalnum(ch)) {\n\t\t\t\t\tmd->token_len = 0;\n\t\t\t\t\tbuff[(md->token_len)++] = ch;\n\t\t\t\t\twhile (!php_stream_eof(md->stream) && (ch = php_stream_getc(md->stream)) && (isalnum(ch) || strchr(PHP_META_HTML401_CHARS, ch))) {\n\t\t\t\t\t\tbuff[(md->token_len)++] = ch;\n\n\t\t\t\t\t\tif (md->token_len == META_DEF_BUFSIZE) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* This is ugly, but we have to replace ungetc */\n\t\t\t\t\tif (!isalpha(ch) && ch != '-') {\n\t\t\t\t\t\tmd->ulc = 1;\n\t\t\t\t\t\tmd->lc = ch;\n\t\t\t\t\t}\n\n\t\t\t\t\tmd->token_data = (char *) emalloc(md->token_len + 1);\n\t\t\t\t\tmemcpy(md->token_data, buff, md->token_len+1);\n\n\t\t\t\t\treturn TOK_ID;\n\t\t\t\t} else {\n\t\t\t\t\treturn TOK_OTHER;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn TOK_EOF;\n}\n/* }}} */\n\n#ifdef HAVE_FNMATCH\n/* {{{ proto bool fnmatch(string pattern, string filename [, int flags])\n   Match filename against pattern */\nPHP_FUNCTION(fnmatch)\n{\n\tchar *pattern, *filename;\n\tint pattern_len, filename_len;\n\tlong flags = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pp|l\", &pattern, &pattern_len, &filename, &filename_len, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (filename_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Filename exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\tRETURN_FALSE;\n\t}\n\tif (pattern_len >= MAXPATHLEN) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Pattern exceeds the maximum allowed length of %d characters\", MAXPATHLEN);\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL( ! fnmatch( pattern, filename, flags ));\n}\n/* }}} */\n#endif\n\n/* {{{ proto string sys_get_temp_dir()\n   Returns directory path used for temporary files */\nPHP_FUNCTION(sys_get_temp_dir)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_STRING((char *)php_get_temporary_directory(TSRMLS_C), 1);\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\tZ_STRVAL_P(return_value) = emalloc(len + 1);\n\n```\n\n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.5.36-dev ZEND_VERSION: 2.5.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_abd159cce48f3e34f08e4751c568e09677d5ec9c More .INIs : CWD : /out/php___php-src/git_repo_dir_abd159cce48f3e34f08e4751c568e09677d5ec9c Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/standard/tests/file/bug72114.phpt]\rFAIL Bug #72114 (Integer underflow / arbitrary null write in fread/gzread) [ext/standard/tests/file/bug72114.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 2 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72114 (Integer underflow / arbitrary null write in fread/gzread) [ext/standard/tests/file/bug72114.phpt] =====================================================================\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "abd159cce48f3e34f08e4751c568e09677d5ec9c___file.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic void php_wddx_add_var(wddx_packet *packet, zval *name_var)\n{\n\tzval **val;\n\tHashTable *target_hash;\n\tTSRMLS_FETCH();\n\n\tif (Z_TYPE_P(name_var) == IS_STRING) {\n\t\tif (!EG(active_symbol_table)) {\n\t\t\tzend_rebuild_symbol_table(TSRMLS_C);\n\t\t}\n\t\tif (zend_hash_find(EG(active_symbol_table), Z_STRVAL_P(name_var),\n\t\t\t\t\t\t\tZ_STRLEN_P(name_var)+1, (void**)&val) != FAILURE) {\n\t\t\tphp_wddx_serialize_var(packet, *val, Z_STRVAL_P(name_var), Z_STRLEN_P(name_var) TSRMLS_CC);\n\t\t}\n\t} else if (Z_TYPE_P(name_var) == IS_ARRAY || Z_TYPE_P(name_var) == IS_OBJECT)\t{\n\t\tint is_array = Z_TYPE_P(name_var) == IS_ARRAY;\n\n\t\ttarget_hash = HASH_OF(name_var);\n\n\t\tif (is_array && target_hash->nApplyCount > 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"recursion detected\");\n\t\t\treturn;\n\t\t}\n\n\t\tzend_hash_internal_pointer_reset(target_hash);\n\n\t\twhile(zend_hash_get_current_data(target_hash, (void**)&val) == SUCCESS) {\n\t\t\tif (is_array) {\n\t\t\t\ttarget_hash->nApplyCount++;\n\t\t\t}\n\n\t\t\tphp_wddx_add_var(packet, *val);\n\n\t\t\tif (is_array) {\n\t\t\t\ttarget_hash->nApplyCount--;\n\t\t\t}\n\t\t\tzend_hash_move_forward(target_hash);\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_push_element\n */\nstatic void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)\n{\n\tst_entry ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\n\tif (!strcmp(name, EL_PACKET)) {\n\t\tint i;\n\n\t\tif (atts) for (i=0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VERSION)) {\n\t\t\t\t/* nothing for now */\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_STRING)) {\n\t\tent.type = ST_STRING;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BINARY)) {\n\t\tent.type = ST_BINARY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_CHAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_CHAR_CODE) && atts[++i] && atts[i][0]) {\n\t\t\t\tchar tmp_buf[2];\n\n\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i], NULL, 16));\n\t\t\t\tphp_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NUMBER)) {\n\t\tent.type = ST_NUMBER;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\tZ_LVAL_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BOOLEAN)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[++i] && atts[i][0]) {\n\t\t\t\tent.type = ST_BOOLEAN;\n\t\t\t\tSET_STACK_VARNAME;\n\n\t\t\t\tALLOC_ZVAL(ent.data);\n\t\t\t\tINIT_PZVAL(ent.data);\n\t\t\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n\t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t\t\tphp_wddx_process_data(user_data, atts[i], strlen(atts[i]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NULL)) {\n\t\tent.type = ST_NULL;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZVAL_NULL(ent.data);\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_ARRAY)) {\n\t\tent.type = ST_ARRAY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_STRUCT)) {\n\t\tent.type = ST_STRUCT;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_VAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tif (stack->varname) efree(stack->varname);\n\t\t\t\tstack->varname = estrdup(atts[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_RECORDSET)) {\n\t\tint i;\n\n\t\tent.type = ST_RECORDSET;\n\t\tSET_STACK_VARNAME;\n\t\tMAKE_STD_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], \"fieldNames\") && atts[++i] && atts[i][0]) {\n\t\t\t\tzval *tmp;\n\t\t\t\tchar *key;\n\t\t\t\tchar *p1, *p2, *endp;\n\n\t\t\t\tendp = (char *)atts[i] + strlen(atts[i]);\n\t\t\t\tp1 = (char *)atts[i];\n\t\t\t\twhile ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {\n\t\t\t\t\tkey = estrndup(p1, p2 - p1);\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp);\n\t\t\t\t\tp1 = p2 + sizeof(\",\")-1;\n\t\t\t\t\tefree(key);\n\t\t\t\t}\n\n\t\t\t\tif (p1 <= endp) {\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tint i;\n\t\tst_entry ent;\n\n\t\tent.type = ST_FIELD;\n\t\tent.varname = NULL;\n\t\tent.data = NULL;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) {\n\t\t\t\tst_entry *recordset;\n\t\t\t\tzval **field;\n\n\t\t\t\tif (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i], strlen(atts[i])+1, (void**)&field) == SUCCESS) {\n\t\t\t\t\tent.data = *field;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_DATETIME)) {\n\t\tent.type = ST_DATETIME;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_pop_element\n */\nstatic void php_wddx_pop_element(void *user_data, const XML_Char *name)\n{\n\tst_entry \t\t\t*ent1, *ent2;\n\twddx_stack \t\t\t*stack = (wddx_stack *)user_data;\n\tHashTable \t\t\t*target_hash;\n\tzend_class_entry \t**pce;\n\tzval\t\t\t\t*obj;\n\tzval\t\t\t\t*tmp;\n\tTSRMLS_FETCH();\n\n/* OBJECTS_FIXME */\n\tif (stack->top == 0) {\n\t\treturn;\n\t}\n\n\tif (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||\n\t\t!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||\n\t  \t!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||\n\t\t!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||\n\t\t!strcmp(name, EL_DATETIME)) {\n\t\twddx_stack_top(stack, (void**)&ent1);\n\n\t\tif (!ent1->data) {\n\t\t\tif (stack->top > 1) {\n\t\t\t\tstack->top--;\n\t\t\t} else {\n\t\t\t\tstack->done = 1;\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!strcmp(name, EL_BINARY)) {\n\t\t\tint new_len=0;\n\t\t\tunsigned char *new_str;\n\n\t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n\t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n\n>>> [ INFILL ] <<<\n\n\t\t/* Call __wakeup() method on the object. */\n\t\tif (Z_TYPE_P(ent1->data) == IS_OBJECT) {\n\t\t\tzval *fname, *retval = NULL;\n\n\t\t\tMAKE_STD_ZVAL(fname);\n\t\t\tZVAL_STRING(fname, \"__wakeup\", 1);\n\n\t\t\tcall_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);\n\n\t\t\tzval_dtor(fname);\n\t\t\tFREE_ZVAL(fname);\n\t\t\tif (retval) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t}\n\n\t\tif (stack->top > 1) {\n\t\t\tstack->top--;\n\t\t\twddx_stack_top(stack, (void**)&ent2);\n\n\t\t\t/* if non-existent field */\n\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\tefree(ent1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\ttarget_hash = HASH_OF(ent2->data);\n\n\t\t\t\tif (ent1->varname) {\n\t\t\t\t\tif (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&\n\t\t\t\t\t\tZ_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&\n\t\t\t\t\t\tent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {\n\t\t\t\t\t\tzend_bool incomplete_class = 0;\n\n\t\t\t\t\t\tzend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\tif (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),\n\t\t\t\t\t\t\t\t\t\t   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {\n\t\t\t\t\t\t\tincomplete_class = 1;\n\t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Initialize target object */\n\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n\t\t\t\t\t\tobject_init_ex(obj, *pce);\n\n\t\t\t\t\t\t/* Merge current hashtable with object's default properties */\n\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n\n\t\t\t\t\t\tif (incomplete_class) {\n\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Clean up old array entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n\n\t\t\t\t\t\t/* Set stack entry to point to the newly created object */\n\t\t\t\t\t\tent2->data = obj;\n\n\t\t\t\t\t\t/* Clean up class name var entry */\n\t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n\t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n\t\t\t\t\t\tzend_class_entry *old_scope = EG(scope);\n\n\t\t\t\t\t\tEG(scope) = Z_OBJCE_P(ent2->data);\n\t\t\t\t\t\tZ_DELREF_P(ent1->data);\n\t\t\t\t\t\tadd_property_zval(ent2->data, ent1->varname, ent1->data);\n\t\t\t\t\t\tEG(scope) = old_scope;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t\t}\n\t\t\t\t\tefree(ent1->varname);\n\t\t\t\t} else\t{\n\t\t\t\t\tzend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tefree(ent1);\n\t\t} else {\n\t\t\tstack->done = 1;\n\t\t}\n\t} else if (!strcmp(name, EL_VAR) && stack->varname) {\n\t\tefree(stack->varname);\n\t\tstack->varname = NULL;\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tst_entry *ent;\n\t\twddx_stack_top(stack, (void **)&ent);\n\t\tefree(ent);\n\t\tstack->top--;\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_process_data\n */\nstatic void php_wddx_process_data(void *user_data, const XML_Char *s, int len)\n{\n\tst_entry *ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\tTSRMLS_FETCH();\n\n\tif (!wddx_stack_is_empty(stack) && !stack->done) {\n\t\twddx_stack_top(stack, (void**)&ent);\n\t\tswitch (ent->type) {\n\t\t\tcase ST_STRING:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BINARY:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len + 1);\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t}\n\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase ST_NUMBER:\n\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\tconvert_scalar_to_number(ent->data TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BOOLEAN:\n\t\t\t\tif(!ent->data) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(s, \"true\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 1;\n\t\t\t\t} else if (!strcmp(s, \"false\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 0;\n\t\t\t\t} else {\n\t\t\t\t\tzval_ptr_dtor(&ent->data);\n\t\t\t\t\tif (ent->varname) {\n\t\t\t\t\t\tefree(ent->varname);\n\t\t\t\t\t\tent->varname = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tent->data = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_DATETIME: {\n\t\t\t\tchar *tmp;\n\n\t\t\t\tif (Z_TYPE_P(ent->data) == IS_STRING) {\n\t\t\t\t\ttmp = safe_emalloc(Z_STRLEN_P(ent->data), 1, (size_t)len + 1);\n\t\t\t\t\tmemcpy(tmp, Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data));\n\t\t\t\t\tmemcpy(tmp + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t\tlen += Z_STRLEN_P(ent->data);\n\t\t\t\t\tefree(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_TYPE_P(ent->data) = IS_LONG;\n\t\t\t\t} else {\n\t\t\t\t\ttmp = emalloc(len + 1);\n\t\t\t\t\tmemcpy(tmp, s, len);\n\t\t\t\t}\n\t\t\t\ttmp[len] = '\\0';\n\n\t\t\t\tZ_LVAL_P(ent->data) = php_parse_date(tmp, NULL);\n\t\t\t\t/* date out of range < 1969 or > 2038 */\n\t\t\t\tif (Z_LVAL_P(ent->data) == -1) {\n\t\t\t\t\tZVAL_STRINGL(ent->data, tmp, len, 0);\n\t\t\t\t} else {\n\t\t\t\t\tefree(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ php_wddx_deserialize_ex\n */\nint php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)\n{\n\twddx_stack stack;\n\tXML_Parser parser;\n\tst_entry *ent;\n\tint retval;\n\n\twddx_stack_init(&stack);\n\tparser = XML_ParserCreate(\"UTF-8\");\n\n\tXML_SetUserData(parser, &stack);\n\tXML_SetElementHandler(parser, php_wddx_push_element, php_wddx_pop_element);\n\tXML_SetCharacterDataHandler(parser, php_wddx_process_data);\n\n\tXML_Parse(parser, value, vallen, 1);\n\n\tXML_ParserFree(parser);\n\n\tif (stack.top == 1) {\n\t\twddx_stack_top(&stack, (void**)&ent);\n\t\t*return_value = *(ent->data);\n\t\tzval_copy_ctor(return_value);\n\t\tretval = SUCCESS;\n\t} else {\n\t\tretval = FAILURE;\n\t}\n\n\twddx_stack_destroy(&stack);\n\n\treturn retval;\n}\n/* }}} */\n\n/* {{{ proto string wddx_serialize_value(mixed var [, string comment])\n   Creates a new packet and serializes the given value */\nPHP_FUNCTION(wddx_serialize_value)\n{\n\tzval *var;\n\tchar *comment = NULL;\n\tint comment_len = 0;\n\twddx_packet *packet;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z|s\", &var, &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, comment, comment_len);\n\tphp_wddx_serialize_var(packet, var, NULL, 0 TSRMLS_CC);\n\tphp_wddx_packet_end(packet);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ proto string wddx_serialize_vars(mixed var_name [, mixed ...])\n   Creates a new packet and serializes given variables into a struct */\nPHP_FUNCTION(wddx_serialize_vars)\n{\n\tint num_args, i;\n\twddx_packet *packet;\n\tzval ***args = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"+\", &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, NULL, 0);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, *args[i]);\n\t}\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\tphp_wddx_packet_end(packet);\n\n\tefree(args);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ php_wddx_constructor\n */\nwddx_packet *php_wddx_constructor(void)\n{\n\tsmart_str *packet;\n\n\tpacket = (smart_str *)emalloc(sizeof(smart_str));\n\tpacket->c = NULL;\n\n\treturn packet;\n}\n/* }}} */\n\n/* {{{ php_wddx_destructor\n */\nvoid php_wddx_destructor(wddx_packet *packet)\n{\n\tsmart_str_free(packet);\n\tefree(packet);\n}\n/* }}} */\n\n/* {{{ proto resource wddx_packet_start([string comment])\n   Starts a WDDX packet with optional comment and returns the packet id */\nPHP_FUNCTION(wddx_packet_start)\n{\n\tchar *comment = NULL;\n\tint comment_len = 0;\n\twddx_packet *packet;\n\n\tcomment = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &comment, &comment_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, comment, comment_len);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\n\tZEND_REGISTER_RESOURCE(return_value, packet, le_wddx);\n}\n/* }}} */\n\n/* {{{ proto string wddx_packet_end(resource packet_id)\n   Ends specified WDDX packet and returns the string containing the packet */\nPHP_FUNCTION(wddx_packet_end)\n{\n\tzval *packet_id;\n\twddx_packet *packet = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &packet_id) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(packet, wddx_packet *, &packet_id, -1, \"WDDX packet ID\", le_wddx);\n\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\n\tphp_wddx_packet_end(packet);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\n\tzend_list_delete(Z_LVAL_P(packet_id));\n}\n/* }}} */\n\n/* {{{ proto int wddx_add_vars(resource packet_id,  mixed var_names [, mixed ...])\n   Serializes given variables and adds them to packet given by packet_id */\nPHP_FUNCTION(wddx_add_vars)\n{\n\tint num_args, i;\n\tzval ***args = NULL;\n\tzval *packet_id;\n\twddx_packet *packet = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r+\", &packet_id, &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!ZEND_FETCH_RESOURCE_NO_RETURN(packet, wddx_packet *, &packet_id, -1, \"WDDX packet ID\", le_wddx)) {\n\t\tefree(args);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (!packet) {\n\t\tefree(args);\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, (*args[i]));\n\t}\n\n\tefree(args);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto mixed wddx_deserialize(mixed packet)\n   Deserializes given packet and returns a PHP value */\nPHP_FUNCTION(wddx_deserialize)\n{\n\tzval *packet;\n\tchar *payload;\n\tint payload_len;\n\tphp_stream *stream = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &packet) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (Z_TYPE_P(packet) == IS_STRING) {\n\t\tpayload \t= Z_STRVAL_P(packet);\n\t\tpayload_len = Z_STRLEN_P(packet);\n\t} else if (Z_TYPE_P(packet) == IS_RESOURCE) {\n\t\tphp_stream_from_zval(stream, &packet);\n\t\tif (stream) {\n\t\t\tpayload_len = php_stream_copy_to_mem(stream, &payload, PHP_STREAM_COPY_ALL, 0);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Expecting parameter 1 to be a string or a stream\");\n\t\treturn;\n\t}\n\n\tif (payload_len == 0) {\n\t\treturn;\n\t}\n\n\tphp_wddx_deserialize_ex(payload, payload_len, return_value);\n\n\tif (stream) {\n\t\tpefree(payload, 0);\n\t}\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n\t\t}\n\n```\n\n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.26-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_698a691724c0a949295991e5df091ce16f899e02 More .INIs : CWD : /out/php___php-src/git_repo_dir_698a691724c0a949295991e5df091ce16f899e02 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/wddx/tests/bug72750.phpt]\r \r===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 0 ( 0.0%) ( 0.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 1 (100.0%) (100.0%) --------------------------------------------------------------------- Time taken : 0 seconds =====================================================================\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "698a691724c0a949295991e5df091ce16f899e02___wddx.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nPHP_FUNCTION(imagegrabwindow)\n{\n\tHWND window;\n\tlong client_area = 0;\n\tRECT rc = {0};\n\tRECT rc_win = {0};\n\tint Width, Height;\n\tHDC\t\thdc;\n\tHDC memDC;\n\tHBITMAP memBM;\n\tHBITMAP hOld;\n\tHINSTANCE handle;\n\tlong lwindow_handle;\n\ttypedef BOOL (WINAPI *tPrintWindow)(HWND, HDC,UINT);\n\ttPrintWindow pPrintWindow = 0;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|l\", &lwindow_handle, &client_area) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\twindow = (HWND) lwindow_handle;\n\n\tif (!IsWindow(window)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Invalid window handle\");\n\t\tRETURN_FALSE;\n\t}\n\n\thdc\t\t= GetDC(0);\n\n\tif (client_area) {\n\t\tGetClientRect(window, &rc);\n\t\tWidth = rc.right;\n\t\tHeight = rc.bottom;\n\t} else {\n\t\tGetWindowRect(window, &rc);\n\t\tWidth\t= rc.right - rc.left;\n\t\tHeight\t= rc.bottom - rc.top;\n\t}\n\n\tWidth\t\t= (Width/4)*4;\n\n\tmemDC\t= CreateCompatibleDC(hdc);\n\tmemBM\t= CreateCompatibleBitmap(hdc, Width, Height);\n\thOld\t= (HBITMAP) SelectObject (memDC, memBM);\n\n\n\thandle = LoadLibrary(\"User32.dll\");\n\tif ( handle == 0 ) {\n\t\tgoto clean;\n\t}\n\tpPrintWindow = (tPrintWindow) GetProcAddress(handle, \"PrintWindow\");\n\n\tif ( pPrintWindow )  {\n\t\tpPrintWindow(window, memDC, (UINT) client_area);\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Windows API too old\");\n\t\tgoto clean;\n\t}\n\n\tFreeLibrary(handle);\n\n\tim = gdImageCreateTrueColor(Width, Height);\n\tif (im) {\n\t\tint x,y;\n\t\tfor (y=0; y <= Height; y++) {\n\t\t\tfor (x=0; x <= Width; x++) {\n\t\t\t\tint c = GetPixel(memDC, x,y);\n\t\t\t\tgdImageSetPixel(im, x, y, gdTrueColor(GetRValue(c), GetGValue(c), GetBValue(c)));\n\t\t\t}\n\t\t}\n\t}\n\nclean:\n\tSelectObject(memDC,hOld);\n\tDeleteObject(memBM);\n\tDeleteDC(memDC);\n\tReleaseDC( 0, hdc );\n\n\tif (!im) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource imagegrabscreen()\n   Grab a screenshot */\nPHP_FUNCTION(imagegrabscreen)\n{\n\tHWND window = GetDesktopWindow();\n\tRECT rc = {0};\n\tint Width, Height;\n\tHDC\t\thdc;\n\tHDC memDC;\n\tHBITMAP memBM;\n\tHBITMAP hOld;\n\ttypedef BOOL (WINAPI *tPrintWindow)(HWND, HDC,UINT);\n\ttPrintWindow pPrintWindow = 0;\n\tgdImagePtr im;\n\thdc\t\t= GetDC(0);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!hdc) {\n\t\tRETURN_FALSE;\n\t}\n\n\tGetWindowRect(window, &rc);\n\tWidth\t= rc.right - rc.left;\n\tHeight\t= rc.bottom - rc.top;\n\n\tWidth\t\t= (Width/4)*4;\n\n\tmemDC\t= CreateCompatibleDC(hdc);\n\tmemBM\t= CreateCompatibleBitmap(hdc, Width, Height);\n\thOld\t= (HBITMAP) SelectObject (memDC, memBM);\n\tBitBlt( memDC, 0, 0, Width, Height , hdc, rc.left, rc.top , SRCCOPY );\n\n\tim = gdImageCreateTrueColor(Width, Height);\n\tif (im) {\n\t\tint x,y;\n\t\tfor (y=0; y <= Height; y++) {\n\t\t\tfor (x=0; x <= Width; x++) {\n\t\t\t\tint c = GetPixel(memDC, x,y);\n\t\t\t\tgdImageSetPixel(im, x, y, gdTrueColor(GetRValue(c), GetGValue(c), GetBValue(c)));\n\t\t\t}\n\t\t}\n\t}\n\n\tSelectObject(memDC,hOld);\n\tDeleteObject(memBM);\n\tDeleteDC(memDC);\n\tReleaseDC( 0, hdc );\n\n\tif (!im) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n\t}\n}\n/* }}} */\n#endif /* PHP_WIN32 */\n\n/* {{{ proto resource imagerotate(resource src_im, float angle, int bgdcolor [, int ignoretransparent])\n   Rotate an image using a custom angle */\nPHP_FUNCTION(imagerotate)\n{\n\tzval *SIM;\n\tgdImagePtr im_dst, im_src;\n\tdouble degrees;\n\tlong color;\n\tlong ignoretransparent = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rdl|l\", &SIM, &degrees, &color, &ignoretransparent) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tim_dst = gdImageRotateInterpolated(im_src, (const float)degrees, color);\n\n\tif (im_dst != NULL) {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_dst, le_gd);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool imagesettile(resource image, resource tile)\n   Set the tile image to $tile when filling $image with the \"IMG_COLOR_TILED\" color */\nPHP_FUNCTION(imagesettile)\n{\n\tzval *IM, *TILE;\n\tgdImagePtr im, tile;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rr\", &IM, &TILE) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(tile, gdImagePtr, &TILE, -1, \"Image\", le_gd);\n\n\tgdImageSetTile(im, tile);\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagesetbrush(resource image, resource brush)\n   Set the brush image to $brush when filling $image with the \"IMG_COLOR_BRUSHED\" color */\nPHP_FUNCTION(imagesetbrush)\n{\n\tzval *IM, *TILE;\n\tgdImagePtr im, tile;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rr\", &IM, &TILE) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(tile, gdImagePtr, &TILE, -1, \"Image\", le_gd);\n\n\tgdImageSetBrush(im, tile);\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto resource imagecreate(int x_size, int y_size)\n   Create a new image */\nPHP_FUNCTION(imagecreate)\n{\n\tlong x_size, y_size;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ll\", &x_size, &y_size) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (x_size <= 0 || y_size <= 0 || x_size >= INT_MAX || y_size >= INT_MAX) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid image dimensions\");\n\t\tRETURN_FALSE;\n\t}\n\n\tim = gdImageCreate(x_size, y_size);\n\n\tif (!im) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n}\n/* }}} */\n\n/* {{{ proto int imagetypes(void)\n   Return the types of images supported in a bitfield - 1=GIF, 2=JPEG, 4=PNG, 8=WBMP, 16=XPM */\nPHP_FUNCTION(imagetypes)\n{\n\tint ret=0;\n\tret = 1;\n#ifdef HAVE_GD_JPG\n\tret |= 2;\n#endif\n#ifdef HAVE_GD_PNG\n\tret |= 4;\n#endif\n\tret |= 8;\n#if defined(HAVE_GD_XPM)\n\tret |= 16;\n#endif\n#ifdef HAVE_GD_WEBP\n\tret |= 32;\n#endif\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(ret);\n}\n/* }}} */\n\n/* {{{ _php_ctx_getmbi\n */\n\nstatic int _php_ctx_getmbi(gdIOCtx *ctx)\n{\n\tint i, mbi = 0;\n\n\tdo {\n\t\ti = (ctx->getC)(ctx);\n\t\tif (i < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tmbi = (mbi << 7) | (i & 0x7f);\n\t} while (i & 0x80);\n\n\treturn mbi;\n}\n/* }}} */\n\n/* {{{ _php_image_type\n */\nstatic const char php_sig_gd2[3] = {'g', 'd', '2'};\n\nstatic int _php_image_type (char data[8])\n{\n\t/* Based on ext/standard/image.c */\n\n\tif (data == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (!memcmp(data, php_sig_gd2, 3)) {\n\t\treturn PHP_GDIMG_TYPE_GD2;\n\t} else if (!memcmp(data, php_sig_jpg, 3)) {\n\t\treturn PHP_GDIMG_TYPE_JPG;\n\t} else if (!memcmp(data, php_sig_png, 3)) {\n\t\tif (!memcmp(data, php_sig_png, 8)) {\n\t\t\treturn PHP_GDIMG_TYPE_PNG;\n\t\t}\n\t} else if (!memcmp(data, php_sig_gif, 3)) {\n\t\treturn PHP_GDIMG_TYPE_GIF;\n\t}\n\telse {\n\t\tgdIOCtx *io_ctx;\n\t\tio_ctx = gdNewDynamicCtxEx(8, data, 0);\n\t\tif (io_ctx) {\n\t\t\tif (_php_ctx_getmbi(io_ctx) == 0 && _php_ctx_getmbi(io_ctx) >= 0) {\n\t\t\t\tio_ctx->gd_free(io_ctx);\n\t\t\t\treturn PHP_GDIMG_TYPE_WBM;\n\t\t\t} else {\n\t\t\t\tio_ctx->gd_free(io_ctx);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n/* }}} */\n\n/* {{{ _php_image_create_from_string\n */\ngdImagePtr _php_image_create_from_string(zval **data, char *tn, gdImagePtr (*ioctx_func_p)() TSRMLS_DC)\n{\n\tgdImagePtr im;\n\tgdIOCtx *io_ctx;\n\n\tio_ctx = gdNewDynamicCtxEx(Z_STRLEN_PP(data), Z_STRVAL_PP(data), 0);\n\n\tif (!io_ctx) {\n\t\treturn NULL;\n\t}\n\n\tim = (*ioctx_func_p)(io_ctx);\n\tif (!im) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Passed data is not in '%s' format\", tn);\n\t\tio_ctx->gd_free(io_ctx);\n\t\treturn NULL;\n\t}\n\n\tio_ctx->gd_free(io_ctx);\n\n\treturn im;\n}\n/* }}} */\n\n/* {{{ proto resource imagecreatefromstring(string image)\n   Create a new image from the image stream in the string */\nPHP_FUNCTION(imagecreatefromstring)\n{\n\tzval **data;\n\tgdImagePtr im;\n\tint imtype;\n\tchar sig[8];\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z\", &data) == FAILURE) {\n\t\treturn;\n\t}\n\n\tconvert_to_string_ex(data);\n\tif (Z_STRLEN_PP(data) < 8) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty string or invalid image\");\n\t\tRETURN_FALSE;\n\t}\n\n\tmemcpy(sig, Z_STRVAL_PP(data), 8);\n\n\timtype = _php_image_type(sig);\n\n\tswitch (imtype) {\n\t\tcase PHP_GDIMG_TYPE_JPG:\n#ifdef HAVE_GD_JPG\n\t\t\tim = _php_image_create_from_string(data, \"JPEG\", gdImageCreateFromJpegCtx TSRMLS_CC);\n#else\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No JPEG support in this PHP build\");\n\t\t\tRETURN_FALSE;\n#endif\n\t\t\tbreak;\n\n\t\tcase PHP_GDIMG_TYPE_PNG:\n#ifdef HAVE_GD_PNG\n\t\t\tim = _php_image_create_from_string(data, \"PNG\", gdImageCreateFromPngCtx TSRMLS_CC);\n#else\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No PNG support in this PHP build\");\n\t\t\tRETURN_FALSE;\n#endif\n\t\t\tbreak;\n\n\t\tcase PHP_GDIMG_TYPE_GIF:\n\t\t\tim = _php_image_create_from_string(data, \"GIF\", gdImageCreateFromGifCtx TSRMLS_CC);\n\t\t\tbreak;\n\n\t\tcase PHP_GDIMG_TYPE_WBM:\n\t\t\tim = _php_image_create_from_string(data, \"WBMP\", gdImageCreateFromWBMPCtx TSRMLS_CC);\n\t\t\tbreak;\n\n\t\tcase PHP_GDIMG_TYPE_GD2:\n\t\t\tim = _php_image_create_from_string(data, \"GD2\", gdImageCreateFromGd2Ctx TSRMLS_CC);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Data is not in a recognized format\");\n\t\t\tRETURN_FALSE;\n\t}\n\n\tif (!im) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Couldn't create GD Image Stream out of Data\");\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n}\n/* }}} */\n\n/* {{{ _php_image_create_from\n */\nstatic void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, gdImagePtr (*func_p)(), gdImagePtr (*ioctx_func_p)())\n{\n\tchar *file;\n\tint file_len;\n\tlong srcx, srcy, width, height;\n\tgdImagePtr im = NULL;\n\tphp_stream *stream;\n\tFILE * fp = NULL;\n\tlong ignore_warning;\n\n\tif (image_type == PHP_GDIMG_TYPE_GD2PART) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pllll\", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tif (width < 1 || height < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Zero width or height not allowed\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p\", &file, &file_len) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\tstream = php_stream_open_wrapper(file, \"rb\", REPORT_ERRORS|IGNORE_PATH|IGNORE_URL_WIN, NULL);\n\tif (stream == NULL)\t{\n\t\tRETURN_FALSE;\n\t}\n\n\t/* try and avoid allocating a FILE* if the stream is not naturally a FILE* */\n\tif (php_stream_is(stream, PHP_STREAM_IS_STDIO))\t{\n\t\tif (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS)) {\n\t\t\tgoto out_err;\n\t\t}\n\t} else if (ioctx_func_p) {\n\t\t/* we can create an io context */\n\t\tgdIOCtx* io_ctx;\n\t\tsize_t buff_size;\n\t\tchar *buff;\n\n\t\t/* needs to be malloc (persistent) - GD will free() it later */\n\t\tbuff_size = php_stream_copy_to_mem(stream, &buff, PHP_STREAM_COPY_ALL, 1);\n\n\t\tif (!buff_size) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Cannot read image data\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tio_ctx = gdNewDynamicCtxEx(buff_size, buff, 0);\n\t\tif (!io_ctx) {\n\t\t\tpefree(buff, 1);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Cannot allocate GD IO context\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (image_type == PHP_GDIMG_TYPE_GD2PART) {\n\t\t\tim = (*ioctx_func_p)(io_ctx, srcx, srcy, width, height);\n\t\t} else {\n\t\t\tim = (*ioctx_func_p)(io_ctx);\n\t\t}\n\t\tio_ctx->gd_free(io_ctx);\n\t\tpefree(buff, 1);\n\t}\n\telse if (php_stream_can_cast(stream, PHP_STREAM_AS_STDIO)) {\n\t\t/* try and force the stream to be FILE* */\n\t\tif (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO | PHP_STREAM_CAST_TRY_HARD, (void **) &fp, REPORT_ERRORS)) {\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (!im && fp) {\n\t\tswitch (image_type) {\n\t\t\tcase PHP_GDIMG_TYPE_GD2PART:\n\t\t\t\tim = (*func_p)(fp, srcx, srcy, width, height);\n\t\t\t\tbreak;\n#if defined(HAVE_GD_XPM)\n\t\t\tcase PHP_GDIMG_TYPE_XPM:\n\t\t\t\tim = gdImageCreateFromXpm(file);\n\t\t\t\tbreak;\n#endif\n\n#ifdef HAVE_GD_JPG\n\t\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\t\tignore_warning = INI_INT(\"gd.jpeg_ignore_warning\");\n\t\t\t\tim = gdImageCreateFromJpegEx(fp, ignore_warning);\n\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\tim = (*func_p)(fp);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfflush(fp);\n\t}\n\n/* register_im: */\n\tif (im) {\n\t\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n\t\tphp_stream_close(stream);\n\t\treturn;\n\t}\n\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"'%s' is not a valid %s file\", file, tn);\nout_err:\n\tphp_stream_close(stream);\n\tRETURN_FALSE;\n\n}\n/* }}} */\n\n/* {{{ proto resource imagecreatefromgif(string filename)\n   Create a new image from GIF file or URL */\nPHP_FUNCTION(imagecreatefromgif)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GIF, \"GIF\", gdImageCreateFromGif, gdImageCreateFromGifCtx);\n}\n/* }}} */\n\n#ifdef HAVE_GD_JPG\n/* {{{ proto resource imagecreatefromjpeg(string filename)\n   Create a new image from JPEG file or URL */\nPHP_FUNCTION(imagecreatefromjpeg)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_JPG, \"JPEG\", gdImageCreateFromJpeg, gdImageCreateFromJpegCtx);\n}\n/* }}} */\n#endif /* HAVE_GD_JPG */\n\n#ifdef HAVE_GD_PNG\n/* {{{ proto resource imagecreatefrompng(string filename)\n   Create a new image from PNG file or URL */\nPHP_FUNCTION(imagecreatefrompng)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, \"PNG\", gdImageCreateFromPng, gdImageCreateFromPngCtx);\n}\n/* }}} */\n#endif /* HAVE_GD_PNG */\n\n#ifdef HAVE_GD_WEBP\n/* {{{ proto resource imagecreatefromwebp(string filename)\n   Create a new image from WEBP file or URL */\nPHP_FUNCTION(imagecreatefromwebp)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WEBP, \"WEBP\", gdImageCreateFromWebp, gdImageCreateFromWebpCtx);\n}\n/* }}} */\n#endif /* HAVE_GD_VPX */\n\n/* {{{ proto resource imagecreatefromxbm(string filename)\n   Create a new image from XBM file or URL */\nPHP_FUNCTION(imagecreatefromxbm)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XBM, \"XBM\", gdImageCreateFromXbm, NULL);\n}\n/* }}} */\n\n#if defined(HAVE_GD_XPM)\n/* {{{ proto resource imagecreatefromxpm(string filename)\n   Create a new image from XPM file or URL */\nPHP_FUNCTION(imagecreatefromxpm)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XPM, \"XPM\", gdImageCreateFromXpm, NULL);\n}\n/* }}} */\n#endif\n\n/* {{{ proto resource imagecreatefromwbmp(string filename)\n   Create a new image from WBMP file or URL */\nPHP_FUNCTION(imagecreatefromwbmp)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WBM, \"WBMP\", gdImageCreateFromWBMP, gdImageCreateFromWBMPCtx);\n}\n/* }}} */\n\n/* {{{ proto resource imagecreatefromgd(string filename)\n   Create a new image from GD file or URL */\nPHP_FUNCTION(imagecreatefromgd)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD, \"GD\", gdImageCreateFromGd, gdImageCreateFromGdCtx);\n}\n/* }}} */\n\n/* {{{ proto resource imagecreatefromgd2(string filename)\n   Create a new image from GD2 file or URL */\nPHP_FUNCTION(imagecreatefromgd2)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2, \"GD2\", gdImageCreateFromGd2, gdImageCreateFromGd2Ctx);\n}\n/* }}} */\n\n/* {{{ proto resource imagecreatefromgd2part(string filename, int srcX, int srcY, int width, int height)\n   Create a new image from a given part of GD2 file or URL */\nPHP_FUNCTION(imagecreatefromgd2part)\n{\n\t_php_image_create_from(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2PART, \"GD2\", gdImageCreateFromGd2Part, gdImageCreateFromGd2PartCtx);\n}\n/* }}} */\n\n/* {{{ _php_image_output\n */\nstatic void _php_image_output(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, void (*func_p)())\n{\n\tzval *imgind;\n\tchar *file = NULL;\n\tlong quality = 0, type = 0;\n\tgdImagePtr im;\n\tchar *fn = NULL;\n\tFILE *fp;\n\tint file_len = 0, argc = ZEND_NUM_ARGS();\n\tint q = -1, i, t = 1;\n\n\t/* The quality parameter for Wbmp stands for the threshold when called from image2wbmp() */\n\t/* When called from imagewbmp() the quality parameter stands for the foreground color. Default: black. */\n\t/* The quality parameter for gd2 stands for chunk size */\n\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"r|pll\", &imgind, &file, &file_len, &quality, &type) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &imgind, -1, \"Image\", le_gd);\n\n\tif (argc > 1) {\n\t\tfn = file;\n\t\tif (argc == 3) {\n\t\t\tq = quality;\n\t\t}\n\t\tif (argc == 4) {\n\t\t\tt = type;\n\t\t}\n\t}\n\n\tif (argc >= 2 && file_len) {\n\t\tPHP_GD_CHECK_OPEN_BASEDIR(fn, \"Invalid filename\");\n\n\t\tfp = VCWD_FOPEN(fn, \"wb\");\n\t\tif (!fp) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' for writing\", fn);\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tswitch (image_type) {\n\t\t\tcase PHP_GDIMG_CONVERT_WBM:\n\t\t\t\tif (q == -1) {\n\t\t\t\t\tq = 0;\n\t\t\t\t} else if (q < 0 || q > 255) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid threshold value '%d'. It must be between 0 and 255\", q);\n\t\t\t\t\tq = 0;\n\t\t\t\t}\n\t\t\t\tgdImageWBMP(im, q, fp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\t\t(*func_p)(im, fp, q);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_WBM:\n\t\t\t\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\t\t\t\tif (gdImageRed(im, i) == 0) break;\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, i, fp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_GD:\n\t\t\t\tif (im->trueColor){\n\t\t\t\t\tgdImageTrueColorToPalette(im,1,256);\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, fp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_GD2:\n\t\t\t\tif (q == -1) {\n\t\t\t\t\tq = 128;\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, fp, q, t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (q == -1) {\n\t\t\t\t\tq = 128;\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, fp, q, t);\n\t\t\t\tbreak;\n\t\t}\n\t\tfflush(fp);\n\t\tfclose(fp);\n\t} else {\n\t\tint   b;\n\t\tFILE *tmp;\n\t\tchar  buf[4096];\n\t\tchar *path;\n\n\t\ttmp = php_open_temporary_file(NULL, NULL, &path TSRMLS_CC);\n\t\tif (tmp == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open temporary file\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tswitch (image_type) {\n\t\t\tcase PHP_GDIMG_CONVERT_WBM:\n \t\t\t\tif (q == -1) {\n  \t\t\t\t\tq = 0;\n  \t\t\t\t} else if (q < 0 || q > 255) {\n  \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid threshold value '%d'. It must be between 0 and 255\", q);\n \t\t\t\t\tq = 0;\n  \t\t\t\t}\n\t\t\t\tgdImageWBMP(im, q, tmp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\t\t(*func_p)(im, tmp, q);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_WBM:\n\t\t\t\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\t\t\t\tif (gdImageRed(im, i) == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, q, tmp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_GD:\n\t\t\t\tif (im->trueColor) {\n\t\t\t\t\tgdImageTrueColorToPalette(im,1,256);\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, tmp);\n\t\t\t\tbreak;\n\t\t\tcase PHP_GDIMG_TYPE_GD2:\n\t\t\t\tif (q == -1) {\n\t\t\t\t\tq = 128;\n\t\t\t\t}\n\t\t\t\t(*func_p)(im, tmp, q, t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t(*func_p)(im, tmp);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfseek(tmp, 0, SEEK_SET);\n\n#if APACHE && defined(CHARSET_EBCDIC)\n\t\t/* XXX this is unlikely to work any more thies@thieso.net */\n\n\t\t/* This is a binary file already: avoid EBCDIC->ASCII conversion */\n\t\tap_bsetflag(php3_rqst->connection->client, B_EBCDIC2ASCII, 0);\n#endif\n\t\twhile ((b = fread(buf, 1, sizeof(buf), tmp)) > 0) {\n\t\t\tphp_write(buf, b TSRMLS_CC);\n\t\t}\n\n\t\tfclose(tmp);\n\t\tVCWD_UNLINK((const char *)path); /* make sure that the temporary file is removed */\n\t\tefree(path);\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto int imagexbm(int im, string filename [, int foreground])\n   Output XBM image to browser or file */\nPHP_FUNCTION(imagexbm)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_XBM, \"XBM\", gdImageXbmCtx);\n}\n/* }}} */\n\n/* {{{ proto bool imagegif(resource im [, string filename])\n   Output GIF image to browser or file */\nPHP_FUNCTION(imagegif)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GIF, \"GIF\", gdImageGifCtx);\n}\n/* }}} */\n\n#ifdef HAVE_GD_PNG\n/* {{{ proto bool imagepng(resource im [, string filename])\n   Output PNG image to browser or file */\nPHP_FUNCTION(imagepng)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, \"PNG\", gdImagePngCtxEx);\n}\n/* }}} */\n#endif /* HAVE_GD_PNG */\n\n\n#ifdef HAVE_GD_WEBP\n/* {{{ proto bool imagewebp(resource im [, string filename[, quality]] )\n   Output WEBP image to browser or file */\nPHP_FUNCTION(imagewebp)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WEBP, \"WEBP\", gdImageWebpCtx);\n}\n/* }}} */\n#endif /* HAVE_GD_WEBP */\n\n\n#ifdef HAVE_GD_JPG\n/* {{{ proto bool imagejpeg(resource im [, string filename [, int quality]])\n   Output JPEG image to browser or file */\nPHP_FUNCTION(imagejpeg)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_JPG, \"JPEG\", gdImageJpegCtx);\n}\n/* }}} */\n#endif /* HAVE_GD_JPG */\n\n/* {{{ proto bool imagewbmp(resource im [, string filename, [, int foreground]])\n   Output WBMP image to browser or file */\nPHP_FUNCTION(imagewbmp)\n{\n\t_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_WBM, \"WBMP\", gdImageWBMPCtx);\n}\n/* }}} */\n\n/* {{{ proto bool imagegd(resource im [, string filename])\n   Output GD image to browser or file */\nPHP_FUNCTION(imagegd)\n{\n\t_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD, \"GD\", gdImageGd);\n}\n/* }}} */\n\n/* {{{ proto bool imagegd2(resource im [, string filename, [, int chunk_size, [, int type]]])\n   Output GD2 image to browser or file */\nPHP_FUNCTION(imagegd2)\n{\n\t_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_GD2, \"GD2\", gdImageGd2);\n}\n/* }}} */\n\n/* {{{ proto bool imagedestroy(resource im)\n   Destroy an image */\nPHP_FUNCTION(imagedestroy)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &IM) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tzend_list_delete(Z_LVAL_P(IM));\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n\n/* {{{ proto int imagecolorallocate(resource im, int red, int green, int blue)\n   Allocate a color for an image */\nPHP_FUNCTION(imagecolorallocate)\n{\n\tzval *IM;\n\tlong red, green, blue;\n\tgdImagePtr im;\n\tint ct = (-1);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tct = gdImageColorAllocate(im, red, green, blue);\n\tif (ct < 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_LONG(ct);\n}\n/* }}} */\n\n/* {{{ proto void imagepalettecopy(resource dst, resource src)\n   Copy the palette from the src image onto the dst image */\nPHP_FUNCTION(imagepalettecopy)\n{\n\tzval *dstim, *srcim;\n\tgdImagePtr dst, src;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rr\", &dstim, &srcim) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(dst, gdImagePtr, &dstim, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(src, gdImagePtr, &srcim, -1, \"Image\", le_gd);\n\n\tgdImagePaletteCopy(dst, src);\n}\n/* }}} */\n\n/* {{{ proto int imagecolorat(resource im, int x, int y)\n   Get the index of the color of a pixel */\nPHP_FUNCTION(imagecolorat)\n{\n\tzval *IM;\n\tlong x, y;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rll\", &IM, &x, &y) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (gdImageTrueColor(im)) {\n\t\tif (im->tpixels && gdImageBoundsSafe(im, x, y)) {\n\t\t\tRETURN_LONG(gdImageTrueColorPixel(im, x, y));\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"%ld,%ld is out of bounds\", x, y);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tif (im->pixels && gdImageBoundsSafe(im, x, y)) {\n\t\t\tRETURN_LONG(im->pixels[y][x]);\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"%ld,%ld is out of bounds\", x, y);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ proto int imagecolorclosest(resource im, int red, int green, int blue)\n   Get the index of the closest color to the specified color */\nPHP_FUNCTION(imagecolorclosest)\n{\n\tzval *IM;\n\tlong red, green, blue;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageColorClosest(im, red, green, blue));\n}\n/* }}} */\n\n/* {{{ proto int imagecolorclosesthwb(resource im, int red, int green, int blue)\n   Get the index of the color which has the hue, white and blackness nearest to the given color */\nPHP_FUNCTION(imagecolorclosesthwb)\n{\n\tzval *IM;\n\tlong red, green, blue;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageColorClosestHWB(im, red, green, blue));\n}\n/* }}} */\n\n/* {{{ proto bool imagecolordeallocate(resource im, int index)\n   De-allocate a color for an image */\nPHP_FUNCTION(imagecolordeallocate)\n{\n\tzval *IM;\n\tlong index;\n\tint col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &IM, &index) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\t/* We can return right away for a truecolor image as deallocating colours is meaningless here */\n\tif (gdImageTrueColor(im)) {\n\t\tRETURN_TRUE;\n\t}\n\n\tcol = index;\n\n\tif (col >= 0 && col < gdImageColorsTotal(im)) {\n\t\tgdImageColorDeallocate(im, col);\n\t\tRETURN_TRUE;\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Color index %d out of range\",\tcol);\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto int imagecolorresolve(resource im, int red, int green, int blue)\n   Get the index of the specified color or its closest possible alternative */\nPHP_FUNCTION(imagecolorresolve)\n{\n\tzval *IM;\n\tlong red, green, blue;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageColorResolve(im, red, green, blue));\n}\n/* }}} */\n\n/* {{{ proto int imagecolorexact(resource im, int red, int green, int blue)\n   Get the index of the specified color */\nPHP_FUNCTION(imagecolorexact)\n{\n\tzval *IM;\n\tlong red, green, blue;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageColorExact(im, red, green, blue));\n}\n/* }}} */\n\n/* {{{ proto void imagecolorset(resource im, int col, int red, int green, int blue)\n   Set the color for the specified palette index */\nPHP_FUNCTION(imagecolorset)\n{\n\tzval *IM;\n\tlong color, red, green, blue, alpha = 0;\n\tint col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rllll|l\", &IM, &color, &red, &green, &blue, &alpha) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tcol = color;\n\n\tif (col >= 0 && col < gdImageColorsTotal(im)) {\n\t\tim->red[col]   = red;\n\t\tim->green[col] = green;\n\t\tim->blue[col]  = blue;\n\t\tim->alpha[col]  = alpha;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto array imagecolorsforindex(resource im, int col)\n   Get the colors for an index */\nPHP_FUNCTION(imagecolorsforindex)\n{\n\tzval *IM;\n\tlong index;\n\tint col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &IM, &index) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tcol = index;\n\n\tif ((col >= 0 && gdImageTrueColor(im)) || (!gdImageTrueColor(im) && col >= 0 && col < gdImageColorsTotal(im))) {\n\t\tarray_init(return_value);\n\n\t\tadd_assoc_long(return_value,\"red\",  gdImageRed(im,col));\n\t\tadd_assoc_long(return_value,\"green\", gdImageGreen(im,col));\n\t\tadd_assoc_long(return_value,\"blue\", gdImageBlue(im,col));\n\t\tadd_assoc_long(return_value,\"alpha\", gdImageAlpha(im,col));\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Color index %d out of range\", col);\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool imagegammacorrect(resource im, float inputgamma, float outputgamma)\n   Apply a gamma correction to a GD image */\nPHP_FUNCTION(imagegammacorrect)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tint i;\n\tdouble input, output;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rdd\", &IM, &input, &output) == FAILURE) {\n\t\treturn;\n\t}\n\n\n>>> [ INFILL ] <<<\n\n\tif (gdImageTrueColor(im))\t{\n\t\tint x, y, c;\n\n\t\tfor (y = 0; y < gdImageSY(im); y++)\t{\n\t\t\tfor (x = 0; x < gdImageSX(im); x++)\t{\n\t\t\t\tc = gdImageGetPixel(im, x, y);\n\t\t\t\tgdImageSetPixel(im, x, y,\n\t\t\t\t\tgdTrueColorAlpha(\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetRed(c)   / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetGreen(c) / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetBlue(c)  / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\tgdTrueColorGetAlpha(c)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tRETURN_TRUE;\n\t}\n\n\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\tim->red[i]   = (int)((pow((pow((im->red[i]   / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->green[i] = (int)((pow((pow((im->green[i] / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->blue[i]  = (int)((pow((pow((im->blue[i]  / 255.0), input)), 1.0 / output) * 255) + .5);\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagesetpixel(resource im, int x, int y, int col)\n   Set a single pixel */\nPHP_FUNCTION(imagesetpixel)\n{\n\tzval *IM;\n\tlong x, y, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &x, &y, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageSetPixel(im, x, y, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imageline(resource im, int x1, int y1, int x2, int y2, int col)\n   Draw a line */\nPHP_FUNCTION(imageline)\n{\n\tzval *IM;\n\tlong x1, y1, x2, y2, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllll\", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n#ifdef HAVE_GD_BUNDLED\n\tif (im->antialias) {\n\t\tgdImageAALine(im, x1, y1, x2, y2, col);\n\t} else\n#endif\n\t{\n\t\tgdImageLine(im, x1, y1, x2, y2, col);\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagedashedline(resource im, int x1, int y1, int x2, int y2, int col)\n   Draw a dashed line */\nPHP_FUNCTION(imagedashedline)\n{\n\tzval *IM;\n\tlong x1, y1, x2, y2, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllll\", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageDashedLine(im, x1, y1, x2, y2, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagerectangle(resource im, int x1, int y1, int x2, int y2, int col)\n   Draw a rectangle */\nPHP_FUNCTION(imagerectangle)\n{\n\tzval *IM;\n\tlong x1, y1, x2, y2, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllll\", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageRectangle(im, x1, y1, x2, y2, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagefilledrectangle(resource im, int x1, int y1, int x2, int y2, int col)\n   Draw a filled rectangle */\nPHP_FUNCTION(imagefilledrectangle)\n{\n\tzval *IM;\n\tlong x1, y1, x2, y2, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllll\", &IM, &x1, &y1, &x2, &y2, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageFilledRectangle(im, x1, y1, x2, y2, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagearc(resource im, int cx, int cy, int w, int h, int s, int e, int col)\n   Draw a partial ellipse */\nPHP_FUNCTION(imagearc)\n{\n\tzval *IM;\n\tlong cx, cy, w, h, ST, E, col;\n\tgdImagePtr im;\n\tint e, st;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllllll\", &IM, &cx, &cy, &w, &h, &ST, &E, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\te = E;\n\tif (e < 0) {\n\t\te %= 360;\n\t}\n\n\tst = ST;\n\tif (st < 0) {\n\t\tst %= 360;\n\t}\n\n\tgdImageArc(im, cx, cy, w, h, st, e, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imageellipse(resource im, int cx, int cy, int w, int h, int color)\n   Draw an ellipse */\nPHP_FUNCTION(imageellipse)\n{\n\tzval *IM;\n\tlong cx, cy, w, h, color;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllll\", &IM, &cx, &cy, &w, &h, &color) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tgdImageEllipse(im, cx, cy, w, h, color);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagefilltoborder(resource im, int x, int y, int border, int col)\n   Flood fill to specific color */\nPHP_FUNCTION(imagefilltoborder)\n{\n\tzval *IM;\n\tlong x, y, border, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rllll\", &IM, &x, &y, &border, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageFillToBorder(im, x, y, border, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagefill(resource im, int x, int y, int col)\n   Flood fill */\nPHP_FUNCTION(imagefill)\n{\n\tzval *IM;\n\tlong x, y, col;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &x, &y, &col) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageFill(im, x, y, col);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto int imagecolorstotal(resource im)\n   Find out the number of colors in an image's palette */\nPHP_FUNCTION(imagecolorstotal)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &IM) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageColorsTotal(im));\n}\n/* }}} */\n\n/* {{{ proto int imagecolortransparent(resource im [, int col])\n   Define a color as transparent */\nPHP_FUNCTION(imagecolortransparent)\n{\n\tzval *IM;\n\tlong COL = 0;\n\tgdImagePtr im;\n\tint argc = ZEND_NUM_ARGS();\n\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"r|l\", &IM, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (argc > 1) {\n\t\tgdImageColorTransparent(im, COL);\n\t}\n\n\tRETURN_LONG(gdImageGetTransparent(im));\n}\n/* }}} */\n\n/* {{{ proto int imageinterlace(resource im [, int interlace])\n   Enable or disable interlace */\nPHP_FUNCTION(imageinterlace)\n{\n\tzval *IM;\n\tint argc = ZEND_NUM_ARGS();\n\tlong INT = 0;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"r|l\", &IM, &INT) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (argc > 1) {\n\t\tgdImageInterlace(im, INT);\n\t}\n\n\tRETURN_LONG(gdImageGetInterlaced(im));\n}\n/* }}} */\n\n/* {{{ php_imagepolygon\n   arg = 0  normal polygon\n   arg = 1  filled polygon */\n/* im, points, num_points, col */\nstatic void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n{\n\tzval *IM, *POINTS;\n\tlong NPOINTS, COL;\n\tzval **var = NULL;\n\tgdImagePtr im;\n\tgdPointPtr points;\n\tint npoints, col, nelem, i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rall\", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tnpoints = NPOINTS;\n\tcol = COL;\n\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));\n\tif (nelem < 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have at least 3 points in your array\");\n\t\tRETURN_FALSE;\n\t}\n\tif (npoints <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must give a positive number of points\");\n\t\tRETURN_FALSE;\n\t}\n\tif (nelem < npoints * 2) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Trying to use %d points in array with only %d points\", npoints, nelem/2);\n\t\tRETURN_FALSE;\n\t}\n\n\tpoints = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);\n\n\tfor (i = 0; i < npoints; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **var;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\tpoints[i].x = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\tpoints[i].x = Z_LVAL_PP(var);\n\t\t\t}\n\t\t}\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **var;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\tpoints[i].y = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\tpoints[i].y = Z_LVAL_PP(var);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (filled) {\n\t\tgdImageFilledPolygon(im, points, npoints, col);\n\t} else {\n\t\tgdImagePolygon(im, points, npoints, col);\n\t}\n\n\tefree(points);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagepolygon(resource im, array point, int num_points, int col)\n   Draw a polygon */\nPHP_FUNCTION(imagepolygon)\n{\n\tphp_imagepolygon(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto bool imagefilledpolygon(resource im, array point, int num_points, int col)\n   Draw a filled polygon */\nPHP_FUNCTION(imagefilledpolygon)\n{\n\tphp_imagepolygon(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ php_find_gd_font\n */\nstatic gdFontPtr php_find_gd_font(int size TSRMLS_DC)\n{\n\tgdFontPtr font;\n\tint ind_type;\n\n\tswitch (size) {\n\t\tcase 1:\n\t\t\t font = gdFontTiny;\n\t\t\t break;\n\t\tcase 2:\n\t\t\t font = gdFontSmall;\n\t\t\t break;\n\t\tcase 3:\n\t\t\t font = gdFontMediumBold;\n\t\t\t break;\n\t\tcase 4:\n\t\t\t font = gdFontLarge;\n\t\t\t break;\n\t\tcase 5:\n\t\t\t font = gdFontGiant;\n\t\t\t break;\n\t\tdefault:\n\t\t\tfont = zend_list_find(size - 5, &ind_type);\n\t\t\t if (!font || ind_type != le_gd_font) {\n\t\t\t\t  if (size < 1) {\n\t\t\t\t\t   font = gdFontTiny;\n\t\t\t\t  } else {\n\t\t\t\t\t   font = gdFontGiant;\n\t\t\t\t  }\n\t\t\t }\n\t\t\t break;\n\t}\n\n\treturn font;\n}\n/* }}} */\n\n/* {{{ php_imagefontsize\n * arg = 0  ImageFontWidth\n * arg = 1  ImageFontHeight\n */\nstatic void php_imagefontsize(INTERNAL_FUNCTION_PARAMETERS, int arg)\n{\n\tlong SIZE;\n\tgdFontPtr font;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &SIZE) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfont = php_find_gd_font(SIZE TSRMLS_CC);\n\tRETURN_LONG(arg ? font->h : font->w);\n}\n/* }}} */\n\n/* {{{ proto int imagefontwidth(int font)\n   Get font width */\nPHP_FUNCTION(imagefontwidth)\n{\n\tphp_imagefontsize(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto int imagefontheight(int font)\n   Get font height */\nPHP_FUNCTION(imagefontheight)\n{\n\tphp_imagefontsize(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ php_gdimagecharup\n * workaround for a bug in gd 1.2 */\nstatic void php_gdimagecharup(gdImagePtr im, gdFontPtr f, int x, int y, int c, int color)\n{\n\tint cx, cy, px, py, fline;\n\tcx = 0;\n\tcy = 0;\n\n\tif ((c < f->offset) || (c >= (f->offset + f->nchars))) {\n\t\treturn;\n\t}\n\n\tfline = (c - f->offset) * f->h * f->w;\n\tfor (py = y; (py > (y - f->w)); py--) {\n\t\tfor (px = x; (px < (x + f->h)); px++) {\n\t\t\tif (f->data[fline + cy * f->w + cx]) {\n\t\t\t\tgdImageSetPixel(im, px, py, color);\n\t\t\t}\n\t\t\tcy++;\n\t\t}\n\t\tcy = 0;\n\t\tcx++;\n\t}\n}\n/* }}} */\n\n/* {{{ php_imagechar\n * arg = 0  ImageChar\n * arg = 1  ImageCharUp\n * arg = 2  ImageString\n * arg = 3  ImageStringUp\n */\nstatic void php_imagechar(INTERNAL_FUNCTION_PARAMETERS, int mode)\n{\n\tzval *IM;\n\tlong SIZE, X, Y, COL;\n\tchar *C;\n\tint C_len;\n\tgdImagePtr im;\n\tint ch = 0, col, x, y, size, i, l = 0;\n\tunsigned char *str = NULL;\n\tgdFontPtr font;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlllsl\", &IM, &SIZE, &X, &Y, &C, &C_len, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tcol = COL;\n\n\tif (mode < 2) {\n\t\tch = (int)((unsigned char)*C);\n\t} else {\n\t\tstr = (unsigned char *) estrndup(C, C_len);\n\t\tl = strlen((char *)str);\n\t}\n\n\ty = Y;\n\tx = X;\n\tsize = SIZE;\n\n\tfont = php_find_gd_font(size TSRMLS_CC);\n\n\tswitch (mode) {\n\t\tcase 0:\n\t\t\tgdImageChar(im, font, x, y, ch, col);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tphp_gdimagecharup(im, font, x, y, ch, col);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfor (i = 0; (i < l); i++) {\n\t\t\t\tgdImageChar(im, font, x, y, (int) ((unsigned char) str[i]), col);\n\t\t\t\tx += font->w;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3: {\n\t\t\tfor (i = 0; (i < l); i++) {\n\t\t\t\t/* php_gdimagecharup(im, font, x, y, (int) str[i], col); */\n\t\t\t\tgdImageCharUp(im, font, x, y, (int) str[i], col);\n\t\t\t\ty -= font->w;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (str) {\n\t\tefree(str);\n\t}\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagechar(resource im, int font, int x, int y, string c, int col)\n   Draw a character */\nPHP_FUNCTION(imagechar)\n{\n\tphp_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto bool imagecharup(resource im, int font, int x, int y, string c, int col)\n   Draw a character rotated 90 degrees counter-clockwise */\nPHP_FUNCTION(imagecharup)\n{\n\tphp_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 1);\n}\n/* }}} */\n\n/* {{{ proto bool imagestring(resource im, int font, int x, int y, string str, int col)\n   Draw a string horizontally */\nPHP_FUNCTION(imagestring)\n{\n\tphp_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 2);\n}\n/* }}} */\n\n/* {{{ proto bool imagestringup(resource im, int font, int x, int y, string str, int col)\n   Draw a string vertically - rotated 90 degrees counter-clockwise */\nPHP_FUNCTION(imagestringup)\n{\n\tphp_imagechar(INTERNAL_FUNCTION_PARAM_PASSTHRU, 3);\n}\n/* }}} */\n\n/* {{{ proto bool imagecopy(resource dst_im, resource src_im, int dst_x, int dst_y, int src_x, int src_y, int src_w, int src_h)\n   Copy part of an image */\nPHP_FUNCTION(imagecopy)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, srcY, srcX, dstY, dstX;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &SW, &SH) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\n\tgdImageCopy(im_dst, im_src, dstX, dstY, srcX, srcY, srcW, srcH);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagecopymerge(resource src_im, resource dst_im, int dst_x, int dst_y, int src_x, int src_y, int src_w, int src_h, int pct)\n   Merge one part of an image with another */\nPHP_FUNCTION(imagecopymerge)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY, PCT;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, srcY, srcX, dstY, dstX, pct;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrlllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &SW, &SH, &PCT) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\tpct  = PCT;\n\n\tgdImageCopyMerge(im_dst, im_src, dstX, dstY, srcX, srcY, srcW, srcH, pct);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagecopymergegray(resource src_im, resource dst_im, int dst_x, int dst_y, int src_x, int src_y, int src_w, int src_h, int pct)\n   Merge one part of an image with another */\nPHP_FUNCTION(imagecopymergegray)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY, PCT;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, srcY, srcX, dstY, dstX, pct;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrlllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &SW, &SH, &PCT) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\tpct  = PCT;\n\n\tgdImageCopyMergeGray(im_dst, im_src, dstX, dstY, srcX, srcY, srcW, srcH, pct);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagecopyresized(resource dst_im, resource src_im, int dst_x, int dst_y, int src_x, int src_y, int dst_w, int dst_h, int src_w, int src_h)\n   Copy and resize part of an image */\nPHP_FUNCTION(imagecopyresized)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY, DW, DH;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrllllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\tdstH = DH;\n\tdstW = DW;\n\n\tif (dstW <= 0 || dstH <= 0 || srcW <= 0 || srcH <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid image dimensions\");\n\t\tRETURN_FALSE;\n\t}\n\n\tgdImageCopyResized(im_dst, im_src, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto int imagesx(resource im)\n   Get image width */\nPHP_FUNCTION(imagesx)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &IM) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageSX(im));\n}\n/* }}} */\n\n/* {{{ proto int imagesy(resource im)\n   Get image height */\nPHP_FUNCTION(imagesy)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &IM) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tRETURN_LONG(gdImageSY(im));\n}\n/* }}} */\n\n#ifdef ENABLE_GD_TTF\n#define TTFTEXT_DRAW 0\n#define TTFTEXT_BBOX 1\n#endif\n\n#ifdef ENABLE_GD_TTF\n\n#if HAVE_GD_FREETYPE && HAVE_LIBFREETYPE\n/* {{{ proto array imageftbbox(float size, float angle, string font_file, string text [, array extrainfo])\n   Give the bounding box of a text using fonts via freetype2 */\nPHP_FUNCTION(imageftbbox)\n{\n\tphp_imagettftext_common(INTERNAL_FUNCTION_PARAM_PASSTHRU, TTFTEXT_BBOX, 1);\n}\n/* }}} */\n\n/* {{{ proto array imagefttext(resource im, float size, float angle, int x, int y, int col, string font_file, string text [, array extrainfo])\n   Write text to the image using fonts via freetype2 */\nPHP_FUNCTION(imagefttext)\n{\n\tphp_imagettftext_common(INTERNAL_FUNCTION_PARAM_PASSTHRU, TTFTEXT_DRAW, 1);\n}\n/* }}} */\n#endif /* HAVE_GD_FREETYPE && HAVE_LIBFREETYPE */\n\n/* {{{ proto array imagettfbbox(float size, float angle, string font_file, string text)\n   Give the bounding box of a text using TrueType fonts */\nPHP_FUNCTION(imagettfbbox)\n{\n\tphp_imagettftext_common(INTERNAL_FUNCTION_PARAM_PASSTHRU, TTFTEXT_BBOX, 0);\n}\n/* }}} */\n\n/* {{{ proto array imagettftext(resource im, float size, float angle, int x, int y, int col, string font_file, string text)\n   Write text to the image using a TrueType font */\nPHP_FUNCTION(imagettftext)\n{\n\tphp_imagettftext_common(INTERNAL_FUNCTION_PARAM_PASSTHRU, TTFTEXT_DRAW, 0);\n}\n/* }}} */\n\n/* {{{ php_imagettftext_common\n */\nstatic void php_imagettftext_common(INTERNAL_FUNCTION_PARAMETERS, int mode, int extended)\n{\n\tzval *IM, *EXT = NULL;\n\tgdImagePtr im=NULL;\n\tlong col = -1, x = -1, y = -1;\n\tint str_len, fontname_len, i, brect[8];\n\tdouble ptsize, angle;\n\tchar *str = NULL, *fontname = NULL;\n\tchar *error = NULL;\n\tint argc = ZEND_NUM_ARGS();\n\tgdFTStringExtra strex = {0};\n\n\tif (mode == TTFTEXT_BBOX) {\n\t\tif (argc < 4 || argc > ((extended) ? 5 : 4)) {\n\t\t\tZEND_WRONG_PARAM_COUNT();\n\t\t} else if (zend_parse_parameters(argc TSRMLS_CC, \"ddss|a\", &ptsize, &angle, &fontname, &fontname_len, &str, &str_len, &EXT) == FAILURE) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tif (argc < 8 || argc > ((extended) ? 9 : 8)) {\n\t\t\tZEND_WRONG_PARAM_COUNT();\n\t\t} else if (zend_parse_parameters(argc TSRMLS_CC, \"rddlllss|a\", &IM, &ptsize, &angle, &x, &y, &col, &fontname, &fontname_len, &str, &str_len, &EXT) == FAILURE) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\t}\n\n\t/* convert angle to radians */\n\tangle = angle * (M_PI/180);\n\n\tif (extended && EXT) {\t/* parse extended info */\n\t\tHashPosition pos;\n\n\t\t/* walk the assoc array */\n\t\tzend_hash_internal_pointer_reset_ex(HASH_OF(EXT), &pos);\n\t\tdo {\n\t\t\tzval ** item;\n\t\t\tchar * key;\n\t\t\tulong num_key;\n\n\t\t\tif (zend_hash_get_current_key_ex(HASH_OF(EXT), &key, NULL, &num_key, 0, &pos) != HASH_KEY_IS_STRING) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (zend_hash_get_current_data_ex(HASH_OF(EXT), (void **) &item, &pos) == FAILURE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (strcmp(\"linespacing\", key) == 0) {\n\t\t\t\tconvert_to_double_ex(item);\n\t\t\t\tstrex.flags |= gdFTEX_LINESPACE;\n\t\t\t\tstrex.linespacing = Z_DVAL_PP(item);\n\t\t\t}\n\n\t\t} while (zend_hash_move_forward_ex(HASH_OF(EXT), &pos) == SUCCESS);\n\t}\n\n#ifdef VIRTUAL_DIR\n\t{\n\t\tchar tmp_font_path[MAXPATHLEN];\n\n\t\tif (!VCWD_REALPATH(fontname, tmp_font_path)) {\n\t\t\tfontname = NULL;\n\t\t}\n\t}\n#endif /* VIRTUAL_DIR */\n\n\tPHP_GD_CHECK_OPEN_BASEDIR(fontname, \"Invalid font filename\");\n\n#ifdef HAVE_GD_FREETYPE\n\tif (extended) {\n\t\terror = gdImageStringFTEx(im, brect, col, fontname, ptsize, angle, x, y, str, &strex);\n\t}\n\telse\n\t\terror = gdImageStringFT(im, brect, col, fontname, ptsize, angle, x, y, str);\n\n#endif /* HAVE_GD_FREETYPE */\n\n\tif (error) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", error);\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\n\t/* return array with the text's bounding box */\n\tfor (i = 0; i < 8; i++) {\n\t\tadd_next_index_long(return_value, brect[i]);\n\t}\n}\n/* }}} */\n#endif\t/* ENABLE_GD_TTF */\n\n#if HAVE_LIBT1\n\n/* {{{ php_free_ps_font\n */\nstatic void php_free_ps_font(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tint *font = (int *) rsrc->ptr;\n\n\tT1_DeleteFont(*font);\n\tefree(font);\n}\n/* }}} */\n\n/* {{{ php_free_ps_enc\n */\nstatic void php_free_ps_enc(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tchar **enc = (char **) rsrc->ptr;\n\n\tT1_DeleteEncoding(enc);\n}\n/* }}} */\n\n/* {{{ proto resource imagepsloadfont(string pathname)\n   Load a new font from specified file */\nPHP_FUNCTION(imagepsloadfont)\n{\n\tchar *file;\n\tint file_len, f_ind, *font;\n#ifdef PHP_WIN32\n\tstruct stat st;\n#endif\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p\", &file, &file_len) == FAILURE) {\n\t\treturn;\n\t}\n\n#ifdef PHP_WIN32\n\tif (VCWD_STAT(file, &st) < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Font file not found (%s)\", file);\n\t\tRETURN_FALSE;\n\t}\n#endif\n\n\tf_ind = T1_AddFont(file);\n\n\tif (f_ind < 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"T1Lib Error (%i): %s\", f_ind, T1_StrError(f_ind));\n\t\tRETURN_FALSE;\n\t}\n\n\tif (T1_LoadFont(f_ind)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Couldn't load the font\");\n\t\tRETURN_FALSE;\n\t}\n\n\tfont = (int *) emalloc(sizeof(int));\n\t*font = f_ind;\n\tZEND_REGISTER_RESOURCE(return_value, font, le_ps_font);\n}\n/* }}} */\n\n/* {{{ proto int imagepscopyfont(int font_index)\n   Make a copy of a font for purposes like extending or reenconding */\n/* The function in t1lib which this function uses seem to be buggy...\nPHP_FUNCTION(imagepscopyfont)\n{\n\tint l_ind, type;\n\tgd_ps_font *nf_ind, *of_ind;\n\tlong fnt;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &fnt) == FAILURE) {\n\t\treturn;\n\t}\n\n\tof_ind = zend_list_find(fnt, &type);\n\n\tif (type != le_ps_font) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%ld is not a Type 1 font index\", fnt);\n\t\tRETURN_FALSE;\n\t}\n\n\tnf_ind = emalloc(sizeof(gd_ps_font));\n\tnf_ind->font_id = T1_CopyFont(of_ind->font_id);\n\n\tif (nf_ind->font_id < 0) {\n\t\tl_ind = nf_ind->font_id;\n\t\tefree(nf_ind);\n\t\tswitch (l_ind) {\n\t\t\tcase -1:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"FontID %d is not loaded in memory\", l_ind);\n\t\t\t\tRETURN_FALSE;\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Tried to copy a logical font\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t\tbreak;\n\t\t\tcase -3:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Memory allocation fault in t1lib\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"An unknown error occurred in t1lib\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tnf_ind->extend = 1;\n\tl_ind = zend_list_insert(nf_ind, le_ps_font TSRMLS_CC);\n\tRETURN_LONG(l_ind);\n}\n*/\n/* }}} */\n\n/* {{{ proto bool imagepsfreefont(resource font_index)\n   Free memory used by a font */\nPHP_FUNCTION(imagepsfreefont)\n{\n\tzval *fnt;\n\tint *f_ind;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &fnt) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\tzend_list_delete(Z_LVAL_P(fnt));\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagepsencodefont(resource font_index, string filename)\n   To change a fonts character encoding vector */\nPHP_FUNCTION(imagepsencodefont)\n{\n\tzval *fnt;\n\tchar *enc, **enc_vector;\n\tint enc_len, *f_ind;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rp\", &fnt, &enc, &enc_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n\tif ((enc_vector = T1_LoadEncoding(enc)) == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Couldn't load encoding vector from %s\", enc);\n\t\tRETURN_FALSE;\n\t}\n\n\tT1_DeleteAllSizes(*f_ind);\n\tif (T1_ReencodeFont(*f_ind, enc_vector)) {\n\t\tT1_DeleteEncoding(enc_vector);\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Couldn't re-encode font\");\n\t\tRETURN_FALSE;\n\t}\n\n\tzend_list_insert(enc_vector, le_ps_enc TSRMLS_CC);\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagepsextendfont(resource font_index, float extend)\n   Extend or or condense (if extend < 1) a font */\nPHP_FUNCTION(imagepsextendfont)\n{\n\tzval *fnt;\n\tdouble ext;\n\tint *f_ind;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rd\", &fnt, &ext) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n\tT1_DeleteAllSizes(*f_ind);\n\n\tif (ext <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Second parameter %F out of range (must be > 0)\", ext);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (T1_ExtendFont(*f_ind, ext) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto bool imagepsslantfont(resource font_index, float slant)\n   Slant a font */\nPHP_FUNCTION(imagepsslantfont)\n{\n\tzval *fnt;\n\tdouble slt;\n\tint *f_ind;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rd\", &fnt, &slt) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n\tif (T1_SlantFont(*f_ind, slt) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* {{{ proto array imagepstext(resource image, string text, resource font, int size, int foreground, int background, int xcoord, int ycoord [, int space [, int tightness [, float angle [, int antialias])\n   Rasterize a string over an image */\nPHP_FUNCTION(imagepstext)\n{\n\tzval *img, *fnt;\n\tint i, j;\n\tlong _fg, _bg, x, y, size, space = 0, aa_steps = 4, width = 0;\n\tint *f_ind;\n\tint h_lines, v_lines, c_ind;\n\tint rd, gr, bl, fg_rd, fg_gr, fg_bl, bg_rd, bg_gr, bg_bl;\n\tint fg_al, bg_al, al;\n\tint aa[16];\n\tint amount_kern, add_width;\n\tdouble angle = 0.0, extend;\n\tunsigned long aa_greys[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n\tgdImagePtr bg_img;\n\tGLYPH *str_img;\n\tT1_OUTLINE *char_path, *str_path;\n\tT1_TMATRIX *transform = NULL;\n\tchar *str;\n\tint str_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rsrlllll|lldl\", &img, &str, &str_len, &fnt, &size, &_fg, &_bg, &x, &y, &space, &width, &angle, &aa_steps) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (aa_steps != 4 && aa_steps != 16) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Antialias steps must be 4 or 16\");\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(bg_img, gdImagePtr, &img, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n\t/* Ensure that the provided colors are valid */\n\tif (_fg < 0 || (!gdImageTrueColor(bg_img) && _fg > gdImageColorsTotal(bg_img))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Foreground color index %ld out of range\", _fg);\n\t\tRETURN_FALSE;\n\t}\n\n\tif (_bg < 0 || (!gdImageTrueColor(bg_img) && _fg > gdImageColorsTotal(bg_img))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Background color index %ld out of range\", _bg);\n\t\tRETURN_FALSE;\n\t}\n\n\tfg_rd = gdImageRed  (bg_img, _fg);\n\tfg_gr = gdImageGreen(bg_img, _fg);\n\tfg_bl = gdImageBlue (bg_img, _fg);\n\tfg_al = gdImageAlpha(bg_img, _fg);\n\n\tbg_rd = gdImageRed  (bg_img, _bg);\n\tbg_gr = gdImageGreen(bg_img, _bg);\n\tbg_bl = gdImageBlue (bg_img, _bg);\n\tbg_al = gdImageAlpha(bg_img, _bg);\n\n\tfor (i = 0; i < aa_steps; i++) {\n\t\trd = bg_rd + (double) (fg_rd - bg_rd) / aa_steps * (i + 1);\n\t\tgr = bg_gr + (double) (fg_gr - bg_gr) / aa_steps * (i + 1);\n\t\tbl = bg_bl + (double) (fg_bl - bg_bl) / aa_steps * (i + 1);\n\t\tal = bg_al + (double) (fg_al - bg_al) / aa_steps * (i + 1);\n\t\taa[i] = gdImageColorResolveAlpha(bg_img, rd, gr, bl, al);\n\t}\n\n\tT1_AASetBitsPerPixel(8);\n\n\tswitch (aa_steps) {\n\t\tcase 4:\n\t\t\tT1_AASetGrayValues(0, 1, 2, 3, 4);\n\t\t\tT1_AASetLevel(T1_AA_LOW);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tT1_AAHSetGrayValues(aa_greys);\n\t\t\tT1_AASetLevel(T1_AA_HIGH);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid value %ld as number of steps for antialiasing\", aa_steps);\n\t\t\tRETURN_FALSE;\n\t}\n\n\tif (angle) {\n\t\ttransform = T1_RotateMatrix(NULL, angle);\n\t}\n\n\tif (width) {\n\t\textend = T1_GetExtend(*f_ind);\n\t\tstr_path = T1_GetCharOutline(*f_ind, str[0], size, transform);\n\n\t\tif (!str_path) {\n\t\t\tif (T1_errno) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"T1Lib Error: %s\", T1_StrError(T1_errno));\n\t\t\t}\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tfor (i = 1; i < str_len; i++) {\n\t\t\tamount_kern = (int) T1_GetKerning(*f_ind, str[i - 1], str[i]);\n\t\t\tamount_kern += str[i - 1] == ' ' ? space : 0;\n\t\t\tadd_width = (int) (amount_kern + width) / extend;\n\n\t\t\tchar_path = T1_GetMoveOutline(*f_ind, add_width, 0, 0, size, transform);\n\t\t\tstr_path = T1_ConcatOutlines(str_path, char_path);\n\n\t\t\tchar_path = T1_GetCharOutline(*f_ind, str[i], size, transform);\n\t\t\tstr_path = T1_ConcatOutlines(str_path, char_path);\n\t\t}\n\t\tstr_img = T1_AAFillOutline(str_path, 0);\n\t} else {\n\t\tstr_img = T1_AASetString(*f_ind, str,  str_len, space, T1_KERNING, size, transform);\n\t}\n\tif (T1_errno) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"T1Lib Error: %s\", T1_StrError(T1_errno));\n\t\tRETURN_FALSE;\n\t}\n\n\th_lines = str_img->metrics.ascent -  str_img->metrics.descent;\n\tv_lines = str_img->metrics.rightSideBearing - str_img->metrics.leftSideBearing;\n\n\tfor (i = 0; i < v_lines; i++) {\n\t\tfor (j = 0; j < h_lines; j++) {\n\t\t\tswitch (str_img->bits[j * v_lines + i]) {\n\t\t\t\tcase 0:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tc_ind = aa[str_img->bits[j * v_lines + i] - 1];\n\t\t\t\t\tgdImageSetPixel(bg_img, x + str_img->metrics.leftSideBearing + i, y - str_img->metrics.ascent + j, c_ind);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tarray_init(return_value);\n\n\tadd_next_index_long(return_value, str_img->metrics.leftSideBearing);\n\tadd_next_index_long(return_value, str_img->metrics.descent);\n\tadd_next_index_long(return_value, str_img->metrics.rightSideBearing);\n\tadd_next_index_long(return_value, str_img->metrics.ascent);\n}\n/* }}} */\n\n/* {{{ proto array imagepsbbox(string text, resource font, int size [, int space, int tightness, float angle])\n   Return the bounding box needed by a string if rasterized */\nPHP_FUNCTION(imagepsbbox)\n{\n\tzval *fnt;\n\tlong sz = 0, sp = 0, wd = 0;\n\tchar *str;\n\tint i, space = 0, add_width = 0, char_width, amount_kern;\n\tint cur_x, cur_y, dx, dy;\n\tint x1, y1, x2, y2, x3, y3, x4, y4;\n\tint *f_ind;\n\tint str_len, per_char = 0;\n\tint argc = ZEND_NUM_ARGS();\n\tdouble angle = 0, sin_a = 0, cos_a = 0;\n\tBBox char_bbox, str_bbox = {0, 0, 0, 0};\n\n\tif (argc != 3 && argc != 6) {\n\t\tZEND_WRONG_PARAM_COUNT();\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"srl|lld\", &str, &str_len, &fnt, &sz, &sp, &wd, &angle) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (argc == 6) {\n\t\tspace = sp;\n\t\tadd_width = wd;\n\t\tangle = angle * M_PI / 180;\n\t\tsin_a = sin(angle);\n\t\tcos_a = cos(angle);\n\t\tper_char =  add_width || angle ? 1 : 0;\n\t}\n\n\tZEND_FETCH_RESOURCE(f_ind, int *, &fnt, -1, \"Type 1 font\", le_ps_font);\n\n#define max(a, b) (a > b ? a : b)\n#define min(a, b) (a < b ? a : b)\n#define new_x(a, b) (int) ((a) * cos_a - (b) * sin_a)\n#define new_y(a, b) (int) ((a) * sin_a + (b) * cos_a)\n\n\tif (per_char) {\n\t\tspace += T1_GetCharWidth(*f_ind, ' ');\n\t\tcur_x = cur_y = 0;\n\n\t\tfor (i = 0; i < str_len; i++) {\n\t\t\tif (str[i] == ' ') {\n\t\t\t\tchar_bbox.llx = char_bbox.lly = char_bbox.ury = 0;\n\t\t\t\tchar_bbox.urx = char_width = space;\n\t\t\t} else {\n\t\t\t\tchar_bbox = T1_GetCharBBox(*f_ind, str[i]);\n\t\t\t\tchar_width = T1_GetCharWidth(*f_ind, str[i]);\n\t\t\t}\n\t\t\tamount_kern = i ? T1_GetKerning(*f_ind, str[i - 1], str[i]) : 0;\n\n\t\t\t/* Transfer character bounding box to right place */\n\t\t\tx1 = new_x(char_bbox.llx, char_bbox.lly) + cur_x;\n\t\t\ty1 = new_y(char_bbox.llx, char_bbox.lly) + cur_y;\n\t\t\tx2 = new_x(char_bbox.llx, char_bbox.ury) + cur_x;\n\t\t\ty2 = new_y(char_bbox.llx, char_bbox.ury) + cur_y;\n\t\t\tx3 = new_x(char_bbox.urx, char_bbox.ury) + cur_x;\n\t\t\ty3 = new_y(char_bbox.urx, char_bbox.ury) + cur_y;\n\t\t\tx4 = new_x(char_bbox.urx, char_bbox.lly) + cur_x;\n\t\t\ty4 = new_y(char_bbox.urx, char_bbox.lly) + cur_y;\n\n\t\t\t/* Find min & max values and compare them with current bounding box */\n\t\t\tstr_bbox.llx = min(str_bbox.llx, min(x1, min(x2, min(x3, x4))));\n\t\t\tstr_bbox.lly = min(str_bbox.lly, min(y1, min(y2, min(y3, y4))));\n\t\t\tstr_bbox.urx = max(str_bbox.urx, max(x1, max(x2, max(x3, x4))));\n\t\t\tstr_bbox.ury = max(str_bbox.ury, max(y1, max(y2, max(y3, y4))));\n\n\t\t\t/* Move to the next base point */\n\t\t\tdx = new_x(char_width + add_width + amount_kern, 0);\n\t\t\tdy = new_y(char_width + add_width + amount_kern, 0);\n\t\t\tcur_x += dx;\n\t\t\tcur_y += dy;\n\t\t\t/*\n\t\t\tprintf(\"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\n\", x1, y1, x2, y2, x3, y3, x4, y4, char_bbox.llx, char_bbox.lly, char_bbox.urx, char_bbox.ury, char_width, amount_kern, cur_x, cur_y, dx, dy);\n\t\t\t*/\n\t\t}\n\n\t} else {\n\t\tstr_bbox = T1_GetStringBBox(*f_ind, str, str_len, space, T1_KERNING);\n\t}\n\n\tif (T1_errno) {\n\t\tRETURN_FALSE;\n\t}\n\n\tarray_init(return_value);\n\t/*\n\tprintf(\"%d %d %d %d\\n\", str_bbox.llx, str_bbox.lly, str_bbox.urx, str_bbox.ury);\n\t*/\n\tadd_next_index_long(return_value, (int) ceil(((double) str_bbox.llx)*sz/1000));\n\tadd_next_index_long(return_value, (int) ceil(((double) str_bbox.lly)*sz/1000));\n\tadd_next_index_long(return_value, (int) ceil(((double) str_bbox.urx)*sz/1000));\n\tadd_next_index_long(return_value, (int) ceil(((double) str_bbox.ury)*sz/1000));\n}\n/* }}} */\n#endif\n\n/* {{{ proto bool image2wbmp(resource im [, string filename [, int threshold]])\n   Output WBMP image to browser or file */\nPHP_FUNCTION(image2wbmp)\n{\n\t_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_CONVERT_WBM, \"WBMP\", _php_image_bw_convert);\n}\n/* }}} */\n\n#if defined(HAVE_GD_JPG)\n/* {{{ proto bool jpeg2wbmp (string f_org, string f_dest, int d_height, int d_width, int threshold)\n   Convert JPEG image to WBMP image */\nPHP_FUNCTION(jpeg2wbmp)\n{\n\t_php_image_convert(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_JPG);\n}\n/* }}} */\n#endif\n\n#if defined(HAVE_GD_PNG)\n/* {{{ proto bool png2wbmp (string f_org, string f_dest, int d_height, int d_width, int threshold)\n   Convert PNG image to WBMP image */\nPHP_FUNCTION(png2wbmp)\n{\n\t_php_image_convert(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG);\n}\n/* }}} */\n#endif\n\n/* {{{ _php_image_bw_convert\n * It converts a gd Image to bw using a threshold value */\nstatic void _php_image_bw_convert(gdImagePtr im_org, gdIOCtx *out, int threshold)\n{\n\tgdImagePtr im_dest;\n\tint white, black;\n\tint color, color_org, median;\n\tint dest_height = gdImageSY(im_org);\n\tint dest_width = gdImageSX(im_org);\n\tint x, y;\n\tTSRMLS_FETCH();\n\n\tim_dest = gdImageCreate(dest_width, dest_height);\n\tif (im_dest == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate temporary buffer\");\n\t\treturn;\n\t}\n\n\twhite = gdImageColorAllocate(im_dest, 255, 255, 255);\n\tif (white == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate the colors for the destination buffer\");\n\t\treturn;\n\t}\n\n\tblack = gdImageColorAllocate(im_dest, 0, 0, 0);\n\tif (black == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate the colors for the destination buffer\");\n\t\treturn;\n\t}\n\n\tif (im_org->trueColor) {\n\t\tgdImageTrueColorToPalette(im_org, 1, 256);\n\t}\n\n\tfor (y = 0; y < dest_height; y++) {\n\t\tfor (x = 0; x < dest_width; x++) {\n\t\t\tcolor_org = gdImageGetPixel(im_org, x, y);\n\t\t\tmedian = (im_org->red[color_org] + im_org->green[color_org] + im_org->blue[color_org]) / 3;\n\t\t\tif (median < threshold) {\n\t\t\t\tcolor = black;\n\t\t\t} else {\n\t\t\t\tcolor = white;\n\t\t\t}\n\t\t\tgdImageSetPixel (im_dest, x, y, color);\n\t\t}\n\t}\n\tgdImageWBMPCtx (im_dest, black, out);\n\n}\n/* }}} */\n\n/* {{{ _php_image_convert\n * _php_image_convert converts jpeg/png images to wbmp and resizes them as needed  */\nstatic void _php_image_convert(INTERNAL_FUNCTION_PARAMETERS, int image_type )\n{\n\tchar *f_org, *f_dest;\n\tint f_org_len, f_dest_len;\n\tlong height, width, threshold;\n\tgdImagePtr im_org, im_dest, im_tmp;\n\tchar *fn_org = NULL;\n\tchar *fn_dest = NULL;\n\tFILE *org, *dest;\n\tint dest_height = -1;\n\tint dest_width = -1;\n\tint org_height, org_width;\n\tint white, black;\n\tint color, color_org, median;\n\tint int_threshold;\n\tint x, y;\n\tfloat x_ratio, y_ratio;\n    long ignore_warning;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pplll\", &f_org, &f_org_len, &f_dest, &f_dest_len, &height, &width, &threshold) == FAILURE) {\n\t\treturn;\n\t}\n\n\tfn_org  = f_org;\n\tfn_dest = f_dest;\n\tdest_height = height;\n\tdest_width = width;\n\tint_threshold = threshold;\n\n\t/* Check threshold value */\n\tif (int_threshold < 0 || int_threshold > 8) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid threshold value '%d'\", int_threshold);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Check origin file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_org, \"Invalid origin filename\");\n\n\t/* Check destination file */\n\tPHP_GD_CHECK_OPEN_BASEDIR(fn_dest, \"Invalid destination filename\");\n\n\t/* Open origin file */\n\torg = VCWD_FOPEN(fn_org, \"rb\");\n\tif (!org) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' for reading\", fn_org);\n\t\tRETURN_FALSE;\n\t}\n\n\t/* Open destination file */\n\tdest = VCWD_FOPEN(fn_dest, \"wb\");\n\tif (!dest) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' for writing\", fn_dest);\n\t\tRETURN_FALSE;\n\t}\n\n\tswitch (image_type) {\n\t\tcase PHP_GDIMG_TYPE_GIF:\n\t\t\tim_org = gdImageCreateFromGif(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' Not a valid GIF file\", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n\n#ifdef HAVE_GD_JPG\n\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\tignore_warning = INI_INT(\"gd.jpeg_ignore_warning\");\n\t\t\tim_org = gdImageCreateFromJpegEx(org, ignore_warning);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' Not a valid JPEG file\", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_JPG */\n\n#ifdef HAVE_GD_PNG\n\t\tcase PHP_GDIMG_TYPE_PNG:\n\t\t\tim_org = gdImageCreateFromPng(org);\n\t\t\tif (im_org == NULL) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to open '%s' Not a valid PNG file\", fn_dest);\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tbreak;\n#endif /* HAVE_GD_PNG */\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Format not supported\");\n\t\t\tRETURN_FALSE;\n\t\t\tbreak;\n\t}\n\n\torg_width  = gdImageSX (im_org);\n\torg_height = gdImageSY (im_org);\n\n\tx_ratio = (float) org_width / (float) dest_width;\n\ty_ratio = (float) org_height / (float) dest_height;\n\n\tif (x_ratio > 1 && y_ratio > 1) {\n\t\tif (y_ratio > x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width / x_ratio);\n\t\tdest_height = (int) (org_height / y_ratio);\n\t} else {\n\t\tx_ratio = (float) dest_width / (float) org_width;\n\t\ty_ratio = (float) dest_height / (float) org_height;\n\n\t\tif (y_ratio < x_ratio) {\n\t\t\tx_ratio = y_ratio;\n\t\t} else {\n\t\t\ty_ratio = x_ratio;\n\t\t}\n\t\tdest_width = (int) (org_width * x_ratio);\n\t\tdest_height = (int) (org_height * y_ratio);\n\t}\n\n\tim_tmp = gdImageCreate (dest_width, dest_height);\n\tif (im_tmp == NULL ) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate temporary buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\tgdImageCopyResized (im_tmp, im_org, 0, 0, 0, 0, dest_width, dest_height, org_width, org_height);\n\n\tgdImageDestroy(im_org);\n\n\tfclose(org);\n\n\tim_dest = gdImageCreate(dest_width, dest_height);\n\tif (im_dest == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate destination buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\twhite = gdImageColorAllocate(im_dest, 255, 255, 255);\n\tif (white == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate the colors for the destination buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\tblack = gdImageColorAllocate(im_dest, 0, 0, 0);\n\tif (black == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to allocate the colors for the destination buffer\");\n\t\tRETURN_FALSE;\n\t}\n\n\tint_threshold = int_threshold * 32;\n\n\tfor (y = 0; y < dest_height; y++) {\n\t\tfor (x = 0; x < dest_width; x++) {\n\t\t\tcolor_org = gdImageGetPixel (im_tmp, x, y);\n\t\t\tmedian = (im_tmp->red[color_org] + im_tmp->green[color_org] + im_tmp->blue[color_org]) / 3;\n\t\t\tif (median < int_threshold) {\n\t\t\t\tcolor = black;\n\t\t\t} else {\n\t\t\t\tcolor = white;\n\t\t\t}\n\t\t\tgdImageSetPixel (im_dest, x, y, color);\n\t\t}\n\t}\n\n\tgdImageDestroy (im_tmp );\n\n\tgdImageWBMP(im_dest, black , dest);\n\n\tfflush(dest);\n\tfclose(dest);\n\n\tgdImageDestroy(im_dest);\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n/* Section Filters */\n#define PHP_GD_SINGLE_RES\t\\\n\tzval *SIM;\t\\\n\tgdImagePtr im_src;\t\\\n\tif (zend_parse_parameters(1 TSRMLS_CC, \"r\", &SIM) == FAILURE) {\t\\\n\t\tRETURN_FALSE;\t\\\n\t}\t\\\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\t\\\n\tif (im_src == NULL) {\t\\\n\t\tRETURN_FALSE;\t\\\n\t}\n\nstatic void php_image_filter_negate(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageNegate(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_grayscale(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageGrayScale(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_brightness(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *SIM;\n\tgdImagePtr im_src;\n\tlong brightness, tmp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zll\", &SIM, &tmp, &brightness) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tif (im_src == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImageBrightness(im_src, (int)brightness) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_contrast(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *SIM;\n\tgdImagePtr im_src;\n\tlong contrast, tmp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rll\", &SIM, &tmp, &contrast) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tif (im_src == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImageContrast(im_src, (int)contrast) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_colorize(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *SIM;\n\tgdImagePtr im_src;\n\tlong r,g,b,tmp;\n\tlong a = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rllll|l\", &SIM, &tmp, &r, &g, &b, &a) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tif (im_src == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImageColor(im_src, (int) r, (int) g, (int) b, (int) a) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_edgedetect(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageEdgeDetectQuick(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_emboss(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageEmboss(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_gaussian_blur(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageGaussianBlur(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_selective_blur(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageSelectiveBlur(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_mean_removal(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tPHP_GD_SINGLE_RES\n\n\tif (gdImageMeanRemoval(im_src) == 1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_smooth(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *SIM;\n\tlong tmp;\n\tgdImagePtr im_src;\n\tdouble weight;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rld\", &SIM, &tmp, &weight) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tif (im_src == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImageSmooth(im_src, (float)weight)==1) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\nstatic void php_image_filter_pixelate(INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tlong tmp, blocksize;\n\tzend_bool mode = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rll|b\", &IM, &tmp, &blocksize, &mode) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (im == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (gdImagePixelate(im, (int) blocksize, (const unsigned int) mode)) {\n\t\tRETURN_TRUE;\n\t}\n\n\tRETURN_FALSE;\n}\n\n/* {{{ proto bool imagefilter(resource src_im, int filtertype, [args] )\n   Applies Filter an image using a custom angle */\nPHP_FUNCTION(imagefilter)\n{\n\tzval *tmp;\n\n\ttypedef void (*image_filter)(INTERNAL_FUNCTION_PARAMETERS);\n\tlong filtertype;\n\timage_filter filters[] =\n\t{\n\t\tphp_image_filter_negate ,\n\t\tphp_image_filter_grayscale,\n\t\tphp_image_filter_brightness,\n\t\tphp_image_filter_contrast,\n\t\tphp_image_filter_colorize,\n\t\tphp_image_filter_edgedetect,\n\t\tphp_image_filter_emboss,\n\t\tphp_image_filter_gaussian_blur,\n\t\tphp_image_filter_selective_blur,\n\t\tphp_image_filter_mean_removal,\n\t\tphp_image_filter_smooth,\n\t\tphp_image_filter_pixelate\n\t};\n\n\tif (ZEND_NUM_ARGS() < 2 || ZEND_NUM_ARGS() > IMAGE_FILTER_MAX_ARGS) {\n\t\tWRONG_PARAM_COUNT;\n\t} else if (zend_parse_parameters(2 TSRMLS_CC, \"rl\", &tmp, &filtertype) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (filtertype >= 0 && filtertype <= IMAGE_FILTER_MAX) {\n\t\tfilters[filtertype](INTERNAL_FUNCTION_PARAM_PASSTHRU);\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource imageconvolution(resource src_im, array matrix3x3, double div, double offset)\n   Apply a 3x3 convolution matrix, using coefficient div and offset */\nPHP_FUNCTION(imageconvolution)\n{\n\tzval *SIM, *hash_matrix;\n\tzval **var = NULL, **var2 = NULL;\n\tgdImagePtr im_src = NULL;\n\tdouble div, offset;\n\tint nelem, i, j, res;\n\tfloat matrix[3][3] = {{0,0,0}, {0,0,0}, {0,0,0}};\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"radd\", &SIM, &hash_matrix, &div, &offset) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(hash_matrix));\n\tif (nelem != 3) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have 3x3 array\");\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i=0; i<3; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(hash_matrix), (i), (void **) &var) == SUCCESS && Z_TYPE_PP(var) == IS_ARRAY) {\n\t\t\tif (Z_TYPE_PP(var) != IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_PP(var)) != 3 ) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have 3x3 array\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tfor (j=0; j<3; j++) {\n\t\t\t\tif (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {\n\t\t\t\t\tif (Z_TYPE_PP(var2) != IS_DOUBLE) {\n\t\t\t\t\t\tzval dval;\n\t\t\t\t\t\tdval = **var2;\n\t\t\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\t\t\tconvert_to_double(&dval);\n\t\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL(dval);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL_PP(var2);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have a 3x3 matrix\");\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres = gdImageConvolution(im_src, matrix, (float)div, (float)offset);\n\n\tif (res) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n/* End section: Filters */\n\n/* {{{ proto void imageflip(resource im, int mode)\n   Flip an image (in place) horizontally, vertically or both directions. */\nPHP_FUNCTION(imageflip)\n{\n\tzval *IM;\n\tlong mode;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &IM, &mode) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tswitch (mode) {\n\t\tcase GD_FLIP_VERTICAL:\n\t\t\tgdImageFlipVertical(im);\n\t\t\tbreak;\n\n\t\tcase GD_FLIP_HORINZONTAL:\n\t\t\tgdImageFlipHorizontal(im);\n\t\t\tbreak;\n\n\t\tcase GD_FLIP_BOTH:\n\t\t\tgdImageFlipBoth(im);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown flip mode\");\n\t\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_TRUE;\n}\n/* }}} */\n\n#ifdef HAVE_GD_BUNDLED\n/* {{{ proto bool imageantialias(resource im, bool on)\n   Should antialiased functions used or not*/\nPHP_FUNCTION(imageantialias)\n{\n\tzval *IM;\n\tzend_bool alias;\n\tgdImagePtr im;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rb\", &IM, &alias) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tgdImageAntialias(im, alias);\n\tRETURN_TRUE;\n}\n/* }}} */\n#endif\n\n/* {{{ proto void imagecrop(resource im, array rect)\n   Crop an image using the given coordinates and size, x, y, width and height. */\nPHP_FUNCTION(imagecrop)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tgdImagePtr im_crop;\n\tgdRect rect;\n\tzval *z_rect;\n\tzval **tmp;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra\", &IM, &z_rect) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (zend_hash_find(HASH_OF(z_rect), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\tzval lval;\n\t\t\tlval = **tmp;\n\t\t\tzval_copy_ctor(&lval);\n\t\t\tconvert_to_long(&lval);\n\t\t\trect.x = Z_LVAL(lval);\n\t\t} else {\n\t\t\trect.x = Z_LVAL_PP(tmp);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_hash_find(HASH_OF(z_rect), \"y\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\tzval lval;\n\t\t\tlval = **tmp;\n\t\t\tzval_copy_ctor(&lval);\n\t\t\tconvert_to_long(&lval);\n\t\t\trect.y = Z_LVAL(lval);\n\t\t} else {\n\t\t\trect.y = Z_LVAL_PP(tmp);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_hash_find(HASH_OF(z_rect), \"width\", sizeof(\"width\"), (void **)&tmp) != FAILURE) {\n\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\tzval lval;\n\t\t\tlval = **tmp;\n\t\t\tzval_copy_ctor(&lval);\n\t\t\tconvert_to_long(&lval);\n\t\t\trect.width = Z_LVAL(lval);\n\t\t} else {\n\t\t\trect.width = Z_LVAL_PP(tmp);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing width\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_hash_find(HASH_OF(z_rect), \"height\", sizeof(\"height\"), (void **)&tmp) != FAILURE) {\n\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\tzval lval;\n\t\t\tlval = **tmp;\n\t\t\tzval_copy_ctor(&lval);\n\t\t\tconvert_to_long(&lval);\n\t\t\trect.height = Z_LVAL(lval);\n\t\t} else {\n\t\t\trect.height = Z_LVAL_PP(tmp);\n\t\t}\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing height\");\n\t\tRETURN_FALSE;\n\t}\n\n\tim_crop = gdImageCrop(im, &rect);\n\n\tif (im_crop == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);\n\t}\n}\n/* }}} */\n\n/* {{{ proto void imagecropauto(resource im [, int mode [, threshold [, color]]])\n   Crop an image automatically using one of the available modes. */\nPHP_FUNCTION(imagecropauto)\n{\n\tzval *IM;\n\tlong mode = -1;\n\tlong color = -1;\n\tdouble threshold = 0.5f;\n\tgdImagePtr im;\n\tgdImagePtr im_crop;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r|ldl\", &IM, &mode, &threshold, &color) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tswitch (mode) {\n\t\tcase -1:\n\t\t\tmode = GD_CROP_DEFAULT;\n\t\tcase GD_CROP_DEFAULT:\n\t\tcase GD_CROP_TRANSPARENT:\n\t\tcase GD_CROP_BLACK:\n\t\tcase GD_CROP_WHITE:\n\t\tcase GD_CROP_SIDES:\n\t\t\tim_crop = gdImageCropAuto(im, mode);\n\t\t\tbreak;\n\n\t\tcase GD_CROP_THRESHOLD:\n\t\t\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Color argument missing with threshold mode\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tim_crop = gdImageCropThreshold(im, color, (float) threshold);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown crop mode\");\n\t\t\tRETURN_FALSE;\n\t}\n\tif (im_crop == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource imagescale(resource im, new_width[, new_height[, method]])\n   Scale an image using the given new width and height. */\nPHP_FUNCTION(imagescale)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tgdImagePtr im_scaled = NULL;\n\tint new_width, new_height;\n\tlong tmp_w, tmp_h=-1, tmp_m = GD_BILINEAR_FIXED;\n\tgdInterpolationMethod method;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl|ll\", &IM, &tmp_w, &tmp_h, &tmp_m) == FAILURE)  {\n\t\treturn;\n\t}\n\tmethod = tmp_m;\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif (tmp_h < 0) {\n\t\t/* preserve ratio */\n\t\tlong src_x, src_y;\n\n\t\tsrc_x = gdImageSX(im);\n\t\tsrc_y = gdImageSY(im);\n\t\tif (src_x) {\n\t\t\ttmp_h = tmp_w * src_y / src_x;\n\t\t}\n\t}\n\n\tif (tmp_h <= 0 || tmp_w <= 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tnew_width = tmp_w;\n\tnew_height = tmp_h;\n\n\tif (gdImageSetInterpolationMethod(im, method)) {\n\t\tim_scaled = gdImageScale(im, new_width, new_height);\n\t}\n\n\tif (im_scaled == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, im_scaled, le_gd);\n\t}\n}\n/* }}} */\n\n/* {{{ proto resource imageaffine(resource src, array affine[, array clip])\n   Return an image containing the affine tramsformed src image, using an optional clipping area */\nPHP_FUNCTION(imageaffine)\n{\n\tzval *IM;\n\tgdImagePtr src;\n\tgdImagePtr dst;\n\tgdRect rect;\n\tgdRectPtr pRect = NULL;\n\tzval *z_rect = NULL;\n\tzval *z_affine;\n\tzval **tmp;\n\tdouble affine[6];\n\tint i, nelems;\n\tzval **zval_affine_elem = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra|a\", &IM, &z_affine, &z_rect) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(src, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\tif ((nelems = zend_hash_num_elements(Z_ARRVAL_P(z_affine))) != 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Affine array must have six elements\");\n\t\tRETURN_FALSE;\n\t}\n\n\tfor (i = 0; i < nelems; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(z_affine), i, (void **) &zval_affine_elem) == SUCCESS) {\n\t\t\tswitch (Z_TYPE_PP(zval_affine_elem)) {\n\t\t\t\tcase IS_LONG:\n\t\t\t\t\taffine[i]  = Z_LVAL_PP(zval_affine_elem);\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_DOUBLE:\n\t\t\t\t\taffine[i] = Z_DVAL_PP(zval_affine_elem);\n\t\t\t\t\tbreak;\n\t\t\t\tcase IS_STRING:\n\t\t\t\t\t{\n\t\t\t\t\t\tzval dval;\n\t\t\t\t\t\tdval = **zval_affine_elem;\n\t\t\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\t\t\tconvert_to_double(&dval);\n\t\t\t\t\t\taffine[i] = Z_DVAL(dval);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %i\", i);\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (z_rect != NULL) {\n\t\tif (zend_hash_find(HASH_OF(z_rect), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **tmp;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\trect.x = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\trect.x = Z_LVAL_PP(tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tif (zend_hash_find(HASH_OF(z_rect), \"y\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **tmp;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\trect.y = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\trect.y = Z_LVAL_PP(tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tif (zend_hash_find(HASH_OF(z_rect), \"width\", sizeof(\"width\"), (void **)&tmp) != FAILURE) {\n\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **tmp;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\trect.width = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\trect.width = Z_LVAL_PP(tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing width\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tif (zend_hash_find(HASH_OF(z_rect), \"height\", sizeof(\"height\"), (void **)&tmp) != FAILURE) {\n\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n\t\t\t\tzval lval;\n\t\t\t\tlval = **tmp;\n\t\t\t\tzval_copy_ctor(&lval);\n\t\t\t\tconvert_to_long(&lval);\n\t\t\t\trect.height = Z_LVAL(lval);\n\t\t\t} else {\n\t\t\t\trect.height = Z_LVAL_PP(tmp);\n\t\t\t}\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing height\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tpRect = &rect;\n\t} else {\n\t\trect.x = -1;\n\t\trect.y = -1;\n\t\trect.width = gdImageSX(src);\n\t\trect.height = gdImageSY(src);\n\t\tpRect = NULL;\n\t}\n\n\tif (gdTransformAffineGetImage(&dst, src, pRect, affine) != GD_TRUE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (dst == NULL) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tZEND_REGISTER_RESOURCE(return_value, dst, le_gd);\n\t}\n}\n/* }}} */\n\n/* {{{ proto array imageaffinematrixget(type[, options])\n   Return an image containing the affine tramsformed src image, using an optional clipping area */\nPHP_FUNCTION(imageaffinematrixget)\n{\n\tdouble affine[6];\n\tlong type;\n\tzval *options = NULL;\n\tzval **tmp;\n\tint res = GD_FALSE, i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|z\", &type, &options) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tswitch((gdAffineStandardMatrix)type) {\n\t\tcase GD_AFFINE_TRANSLATE:\n\t\tcase GD_AFFINE_SCALE: {\n\t\t\tdouble x, y;\n\t\t\tif (!options || Z_TYPE_P(options) != IS_ARRAY) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Array expected as options\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tif (zend_hash_find(HASH_OF(options), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n\t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\n\t\t\t\t\tzval dval;\n\t\t\t\t\tdval = **tmp;\n\t\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\t\tconvert_to_double(&dval);\n\t\t\t\t\tx = Z_DVAL(dval);\n\t\t\t\t} else {\n\t\t\t\t\tx = Z_DVAL_PP(tmp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tif (zend_hash_find(HASH_OF(options), \"y\", sizeof(\"y\"), (void **)&tmp) != FAILURE) {\n\t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\n\t\t\t\t\tzval dval;\n\t\t\t\t\tdval = **tmp;\n\t\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\t\tconvert_to_double(&dval);\n\t\t\t\t\ty = Z_DVAL(dval);\n\t\t\t\t} else {\n\t\t\t\t\ty = Z_DVAL_PP(tmp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\n\t\t\tif (type == GD_AFFINE_TRANSLATE) {\n\t\t\t\tres = gdAffineTranslate(affine, x, y);\n\t\t\t} else {\n\t\t\t\tres = gdAffineScale(affine, x, y);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase GD_AFFINE_ROTATE:\n\t\tcase GD_AFFINE_SHEAR_HORIZONTAL:\n\t\tcase GD_AFFINE_SHEAR_VERTICAL: {\n\t\t\tdouble angle;\n\n\t\t\tif (!options) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Number is expected as option\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tif(Z_TYPE_P(options) != IS_DOUBLE) {\n\t\t\t\tzval dval;\n\t\t\t\tdval = *options;\n\t\t\t\tzval_copy_ctor(&dval);\n\t\t\t\tconvert_to_double(&dval);\n\t\t\t\tangle = Z_DVAL(dval);\n\t\t\t} else {\n\t\t\t\tangle = Z_DVAL_P(options);\n\t\t\t}\n\n\t\t\tif (type == GD_AFFINE_SHEAR_HORIZONTAL) {\n\t\t\t\tres = gdAffineShearHorizontal(affine, angle);\n\t\t\t} else if (type == GD_AFFINE_SHEAR_VERTICAL) {\n\t\t\t\tres = gdAffineShearVertical(affine, angle);\n\t\t\t} else {\n\t\t\t\tres = gdAffineRotate(affine, angle);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %li\", type);\n\t\t\tRETURN_FALSE;\n\t}\n\n\tif (res == GD_FALSE) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tarray_init(return_value);\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tadd_index_double(return_value, i, affine[i]);\n\t\t}\n\t}\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n```\n\n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.26-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_1bd103df00f49cf4d4ade2cfe3f456ac058a4eae More .INIs : CWD : /out/php___php-src/git_repo_dir_1bd103df00f49cf4d4ade2cfe3f456ac058a4eae Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/gd/tests/bug72730.phpt]\rFAIL Bug #72730: imagegammacorrect allows arbitrary write access [ext/gd/tests/bug72730.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72730: imagegammacorrect allows arbitrary write access [ext/gd/tests/bug72730.phpt] =====================================================================\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "1bd103df00f49cf4d4ade2cfe3f456ac058a4eae___gd.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n\n\n>>> [ INFILL ] <<<\n\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n\n    if (c != '.')\n      if (c != 0x3002)  /* \u3002 */\n        if (c != 0xFF0E)  /* \uff0e */\n          if (c != 0xFF61)  /* \uff61 */\n            continue;\n\n    rc = uv__idna_toascii_label(s, st, &d, de);\n\n    if (rc < 0)\n      return rc;\n\n    if (d < de)\n      *d++ = '.';\n\n    s = si;\n  }\n\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n\n    if (rc < 0)\n      return rc;\n  }\n\n  if (d >= de)\n    return UV_EINVAL;\n\n  *d++ = '\\0';\n  return d - ds;  /* Number of bytes written. */\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  ds = d;\n\n```\n\n\n\nwith the following test error: not ok 35 - fork_fs_events_child\n# exit code 134\n# Output from process `fork_fs_events_child`:\n# Assertion failed in test/test-fork.c on line 426: `r >= 0` (-13 >= 0)\nnot ok 36 - fork_fs_events_child_dir\n# exit code 134\n# Output from process `fork_fs_events_child_dir`:\n# Assertion failed in test/test-fork.c on line 426: `r >= 0` (-13 >= 0)\nnot ok 37 - fork_fs_events_file_parent_child\n# exit code 134\n# Output from process `fork_fs_events_file_parent_child`:\n# Assertion failed in test/test-fork.c on line 426: `r >= 0` (-13 >= 0)\nok 38 - fork_signal_to_child\nnot ok 44 - fs_access\n# exit code 134\n# Output from process `fs_access`:\n# Assertion failed in test/test-fs.c on line 1631: `r >= 0` (-13 >= 0)\nnot ok 45 - fs_async_dir\n# exit code 134\n# Output from process `fs_async_dir`:\n# Assertion failed in test/test-fs.c on line 511: `req->result == 0` (-13 == 0)\nnot ok 46 - fs_async_sendfile\n# exit code 134\n# Output from process `fs_async_sendfile`:\n# Assertion failed in test/test-fs.c on line 1218: `f != -1` (-1 != -1)\nnot ok 47 - fs_async_sendfile_nodata\n# exit code 134\n# Output from process `fs_async_sendfile_nodata`:\n# Assertion failed in test/test-fs.c on line 1218: `f != -1` (-1 != -1)\nnot ok 48 - fs_chmod\n# exit code 134\n# Output from process `fs_chmod`:\n# Assertion failed in test/test-fs.c on line 1692: `r >= 0` (-13 >= 0)\nnot ok 49 - fs_chown\n# exit code 134\n# Output from process `fs_chown`:\n# Assertion failed in test/test-fs.c on line 1904: `r >= 0` (-13 >= 0)\nnot ok 50 - fs_copyfile\n# exit code 134\n# Output from process `fs_copyfile`:\n# Assertion failed in test/test-fs-copyfile.c on line 81: `r >= 0` (-13 >= 0)\nnot ok 51 - fs_event_close_in_callback\n# exit code 134\n# Output from process `fs_event_close_in_callback`:\n# Assertion failed in test/test-fs-event.c on line 74: r == 0 || r == UV_EEXIST\nnot ok 52 - fs_event_close_with_pending_delete_event\n# exit code 134\n# Output from process `fs_event_close_with_pending_delete_event`:\n# Assertion failed in test/test-fs-event.c on line 74: r == 0 || r == UV_EEXIST\nnot o \nPlease provide the correct line following commit message at the infill location."}], "idx": "3530bcc30350d4a6ccf35d2f7b33e23292b9de70___idna.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic njs_jump_off_t\nnjs_vmcode_typeof(njs_vm_t *vm, njs_value_t *value, njs_value_t *invld)\n{\n    /* ECMAScript 5.1: null, array and regexp are objects. */\n\n    static const njs_value_t  *types[NJS_VALUE_TYPE_MAX] = {\n        &njs_string_object,\n        &njs_string_undefined,\n        &njs_string_boolean,\n        &njs_string_number,\n        &njs_string_symbol,\n        &njs_string_string,\n        &njs_string_data,\n        &njs_string_external,\n        &njs_string_invalid,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_function,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n\n>>> [ INFILL ] <<<\n\n    vm->retval = *types[value->type];\n\n    return sizeof(njs_vmcode_2addr_t);\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    };\n\n```\n\n\n\nwith the following test error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==20698==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7f1d3afadaeb bp 0x7ffe851a25f0 sp 0x7ffe851a1da8 T0)\n==20698==The signal is caused by a READ memory access.\n==20698==Hint: address points to the zero page.\n    #0 0x7f1d3afadaeb in memcpy /build/glibc-wuryBv/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:142\n    #1 0x556a0332e1a3 in __asan_memcpy /src/llvm-project/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:22:3\n    #2 0x556a0338bbcd in njs_vmcode_typeof /out/nginx___njs/git_repo_dir_d457c9545e7e71ebb5c0479eb16b9d33175855e2/src/njs_vmcode.c:1521:18\n    #3 0x556a0338bbcd in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_d457c9545e7e71ebb5c0479eb16b9d33175855e2/src/njs_vmcode.c:594:23\n    #4 0x556a033856a7 in njs_vm_start /out/nginx___njs/git_repo_dir_d457c9545e7e71ebb5c0479eb16b9d33175855e2/src/njs_vm.c:493:11\n    #5 0x556a0336cfb0 in njs_process_test /out/nginx___njs/git_repo_dir_d457c9545e7e71ebb5c0479eb16b9d33175855e2/src/test/njs_unit_test.c:21859:15\n    #6 0x556a0336cfb0 in njs_unit_test /out/nginx___njs/git_repo_dir_d457c9545e7e71ebb5c0479eb16b9d33175855e2/src/test/njs_unit_test.c:22011:23\n    #7 0x556a0336c261 in main /out/nginx___njs/git_repo_dir_d457c9545e7e71ebb5c0479eb16b9d33175855e2/src/test/njs_unit_test.c:23501:15\n    #8 0x7f1d3af16082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #9 0x556a03296acd in _start (/out/nginx___njs/git_repo_dir_d457c9545e7e71ebb5c0479eb16b9d33175855e2/build/njs_unit_test+0x11dacd)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV /build/glibc-wuryBv/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:142 in memcpy\n==20698==ABORTING\nAddressSanitizer:DEADLYSIGNAL\n=================================================================\n==67766==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7feb8 \nPlease provide the correct line following commit message at the infill location."}], "idx": "d457c9545e7e71ebb5c0479eb16b9d33175855e2___njs_vmcode.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic njs_jump_off_t\nnjs_vmcode_array(njs_vm_t *vm, u_char *pc)\n{\n    uint32_t            length;\n    njs_array_t         *array;\n    njs_value_t         *value;\n    njs_vmcode_array_t  *code;\n\n    code = (njs_vmcode_array_t *) pc;\n\n    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);\n\n    if (njs_fast_path(array != NULL)) {\n\n        if (code->ctor) {\n            /* Array of the form [,,,], [1,,]. */\n\n>>> [ INFILL ] <<<\n        } else {\n            /* Array of the form [], [,,1], [1,2,3]. */\n            array->length = 0;\n        }\n\n        njs_set_array(&vm->retval, array);\n\n        return sizeof(njs_vmcode_array_t);\n    }\n\n    return NJS_ERROR;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n            value = array->start;\n            length = array->length;\n\n            do {\n                njs_set_invalid(value);\n                value++;\n                length--;\n            } while (length != 0);\n\n\n```\n\n\n\nwith the following test error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==25378==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x555a008e63c9 bp 0x7fff7783fd50 sp 0x7fff7783fac0 T0)\n==25378==The signal is caused by a WRITE memory access.\n==25378==Hint: address points to the zero page.\n    #0 0x555a008e63c9 in njs_vmcode_array /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/njs_vmcode.c:1062:17\n    #1 0x555a008e63c9 in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/njs_vmcode.c:583:23\n    #2 0x555a0093942d in njs_function_lambda_call /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/njs_function.c:703:11\n    #3 0x555a008e728f in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/njs_vmcode.c:788:23\n    #4 0x555a008dfcaa in njs_vm_start /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/njs_vm.c:553:11\n    #5 0x555a008c6fb0 in njs_process_test /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/test/njs_unit_test.c:21958:15\n    #6 0x555a008c6fb0 in njs_unit_test /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/test/njs_unit_test.c:22110:23\n    #7 0x555a008c6261 in main /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/test/njs_unit_test.c:23600:15\n    #8 0x7fe5c3507082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #9 0x555a007f0acd in _start (/out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/build_f65981b0b8fcf02d69a40bc934803c25c9f607ab/njs_unit_test+0x11dacd)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV /out/nginx___njs/git_repo_dir_f65981b0b8fcf02d69a40bc934803c25c9f607ab/src/njs_vmcode.c:1062:17 in njs_vmcode_array\n==25378==ABORTING\nAddressSanitizer:DEADLYSIGNAL\n============================================================== \nPlease provide the correct line following commit message at the infill location."}], "idx": "f65981b0b8fcf02d69a40bc934803c25c9f607ab___njs_vmcode.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic njs_int_t\nnjs_array_prototype_splice(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t      i, n, start, length, items, delta, delete;\n    njs_int_t    ret;\n    njs_value_t  *this, value, del_object;\n    njs_array_t  *array, *deleted;\n\n    this = njs_argument(args, 0);\n\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_object_length(vm, this, &length);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    start = (start < 0) ? njs_max(length + start, 0) : njs_min(start, length);\n\n    items = 0;\n    delete = 0;\n\n    if (nargs == 2) {\n        delete = length - start;\n\n    } else if (nargs > 2) {\n        items = nargs - 3;\n\n        ret = njs_value_to_integer(vm, njs_arg(args, nargs, 2), &delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n\n        delete = njs_min(njs_max(delete, 0), length - start);\n    }\n\n    delta = items - delete;\n\n    if (njs_slow_path((length + delta) > NJS_MAX_LENGTH)) {\n        njs_type_error(vm, \"Invalid length\");\n        return NJS_ERROR;\n    }\n\n    /* TODO: ArraySpeciesCreate(). */\n\n    deleted = njs_array_alloc(vm, 0, delete, 0);\n    if (njs_slow_path(deleted == NULL)) {\n        return NJS_ERROR;\n    }\n\n    if (njs_fast_path(njs_is_fast_array(this) && deleted->object.fast_array)) {\n        array = njs_array(this);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            deleted->start[i] = array->start[n];\n        }\n\n    } else {\n        njs_set_array(&del_object, deleted);\n\n        for (i = 0, n = start; i < delete; i++, n++) {\n            ret = njs_value_property_i64(vm, this, n, &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n\n            if (ret == NJS_OK) {\n                /* TODO:  CreateDataPropertyOrThrow(). */\n                ret = njs_value_property_i64_set(vm, &del_object, i, &value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return ret;\n                }\n\n>>> [ INFILL ] <<<\n        }\n\n        ret = njs_object_length_set(vm, &del_object, delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    if (njs_fast_path(njs_is_fast_array(this))) {\n        array = njs_array(this);\n\n        if (delta != 0) {\n            /*\n             * Relocate the rest of items.\n             * Index of the first item is in \"n\".\n             */\n            if (delta > 0) {\n                ret = njs_array_expand(vm, array, 0, delta);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n            }\n\n            ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                        array->length - (start + delete), 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n            array->length += delta;\n        }\n\n        /* Copy new items. */\n\n        if (items > 0) {\n            memcpy(&array->start[start], &args[3],\n                   items * sizeof(njs_value_t));\n        }\n\n    } else {\n\n       if (delta != 0) {\n           ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                       length - (start + delete), delta < 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n\n            for (i = length - 1; i >= length + delta; i--) {\n                ret = njs_value_property_i64_delete(vm, this, i, NULL);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return NJS_ERROR;\n                }\n            }\n       }\n\n        /* Copy new items. */\n\n        for (i = 3, n = start; items-- > 0; i++, n++) {\n            ret = njs_value_property_i64_set(vm, this, n, &args[i]);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n        }\n\n        ret = njs_object_length_set(vm, this, length + delta);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n\n    njs_set_array(&vm->retval, deleted);\n\n    return NJS_OK;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n            }\n\n```\n\n\n\nwith the following test error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==40169==ERROR: AddressSanitizer: SEGV on unknown address (pc 0x55811be8f248 bp 0x7fffbffba850 sp 0x7fffbffba810 T0)\n==40169==The signal is caused by a READ memory access.\n==40169==Hint: this fault was caused by a dereference of a high value address (see register values below).  Disassemble the provided pc to learn which register was used.\n    #0 0x55811be8f248 in njs_lvlhsh_find /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_lvlhsh.c:176:16\n    #1 0x55811bed9f2f in njs_object_property /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_object_prop.c:59:15\n    #2 0x55811be99e13 in njs_value_to_primitive /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_value.c:159:19\n    #3 0x55811bee56e9 in njs_value_to_chain /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_value_conversion.h:217:19\n    #4 0x55811bee56e9 in njs_array_prototype_join /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_array.c:1535:23\n    #5 0x55811befd051 in njs_function_native_call /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_function.c:739:11\n    #6 0x55811befb707 in njs_function_frame_invoke /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_function.c:777:16\n    #7 0x55811befb707 in njs_function_call2 /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_function.c:600:11\n    #8 0x55811bee1761 in njs_function_apply /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_function.h:188:12\n    #9 0x55811bee1761 in njs_array_prototype_to_string /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_array.c:1459:20\n    #10 0x55811befd051 in njs_function_native_call /out/nginx___njs/git_repo_dir_2e00e95473861846aa8538be87db07699d9f676d/src/njs_function.c:739:11\n    #11 0x55811bef \nPlease provide the correct line following commit message at the infill location."}], "idx": "2e00e95473861846aa8538be87db07699d9f676d___njs_array.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nnjs_int_t\nnjs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)\n{\n    uint32_t           i, length;\n    njs_value_t        index, value;\n    njs_object_prop_t  *prop;\n\n\n>>> [ INFILL ] <<<\n    array->object.fast_array = 0;\n\n    length = array->length;\n\n    for (i = 0; i < length; i++) {\n        if (njs_is_valid(&array->start[i])) {\n            njs_uint32_to_string(&index, i);\n            prop = njs_object_property_add(vm, &value, &index, 0);\n            if (njs_slow_path(prop == NULL)) {\n                return NJS_ERROR;\n            }\n\n            prop->value = array->start[i];\n        }\n    }\n\n    /* GC: release value. */\n\n    njs_mp_free(vm->mem_pool, array->start);\n    array->start = NULL;\n\n    return NJS_OK;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    njs_set_array(&value, array);\n\n```\n\n\n\nwith the following test error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==41829==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x564e05c665fe bp 0x7ffe16d6e1f0 sp 0x7ffe16d6e140 T0)\n==41829==The signal is caused by a READ memory access.\n==41829==Hint: address points to the zero page.\n    #0 0x564e05c665fe in njs_array_convert_to_slow_array /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_array.c:151:13\n    #1 0x564e05c61147 in njs_object_prop_define /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_object_prop.c:288:19\n    #2 0x564e05c5d06b in njs_object_define_property /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_object.c:1268:11\n    #3 0x564e05c828d1 in njs_function_native_call /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_function.c:739:11\n    #4 0x564e05c303bf in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_vmcode.c:810:23\n    #5 0x564e05c81d6d in njs_function_lambda_call /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_function.c:703:11\n    #6 0x564e05c303bf in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_vmcode.c:810:23\n    #7 0x564e05c28cca in njs_vm_start /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/njs_vm.c:553:11\n    #8 0x564e05c0ffc0 in njs_process_test /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/test/njs_unit_test.c:22026:15\n    #9 0x564e05c0ffc0 in njs_unit_test /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/test/njs_unit_test.c:22178:23\n    #10 0x564e05c0f271 in main /out/nginx___njs/git_repo_dir_81af26364c21c196dd21fb5e14c7fa9ce7debd17/src/test/njs_unit_test.c:23668:15\n    #11 0x7fc0a51e8082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #12 0x564e05b39add in _ \nPlease provide the correct line following commit message at the infill location."}], "idx": "81af26364c21c196dd21fb5e14c7fa9ce7debd17___njs_array.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nnjs_int_t\nnjs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n\n    njs_typed_array_prop_set(vm, array, index, num);\n\n\n>>> [ INFILL ] <<<\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    njs_set_number(setval, num);\n\n    return NJS_OK;\n\n```\n\n\n\nwith the following test error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==43483==ERROR: AddressSanitizer: SEGV on unknown address 0x55e087212088 (pc 0x55e0870e5b1a bp 0x7ffe88707990 sp 0x7ffe88707900 T0)\n==43483==The signal is caused by a WRITE memory access.\n    #0 0x55e0870e5b1a in njs_set_number /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_value.h:852:26\n    #1 0x55e0870e5b1a in njs_typed_array_set_value /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_typed_array.c:705:5\n    #2 0x55e086fe6ec7 in njs_value_property_set /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_value.c\n    #3 0x55e08702df4d in njs_value_property_i64_set /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_value.h:1097:12\n    #4 0x55e08702df4d in njs_array_prototype_fill /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_array.c:1894:15\n    #5 0x55e087045921 in njs_function_native_call /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_function.c:739:11\n    #6 0x55e087047c52 in njs_function_frame_invoke /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_function.c:777:16\n    #7 0x55e087047c52 in njs_function_prototype_call /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_function.c:1351:11\n    #8 0x55e087045921 in njs_function_native_call /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_function.c:739:11\n    #9 0x55e086ff33bf in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_vmcode.c:810:23\n    #10 0x55e086febcca in njs_vm_start /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/njs_vm.c:553:11\n    #11 0x55e086fd2fc0 in njs_process_test /out/nginx___njs/git_repo_dir_5c6130a2a0b4c41ab415f6b8992aa323636338b9/src/test/njs_unit_test.c:22029:15\n    #12 0x55e086fd2fc0 in njs_unit_tes \nPlease provide the correct line following commit message at the infill location."}], "idx": "5c6130a2a0b4c41ab415f6b8992aa323636338b9___njs_typed_array.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic void\n_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\n\tfn_size = strlen(cs->function) + 1;\n\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\n\tif (chunk == NULL) {\n\t\t/* something bad has happened. abort blackbox logging */\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\n\t/* line number */\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* tags */\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\n\t/* log level/priority */\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\n\t/* function name */\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\n\t/* timestamp */\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\n\t/* log message length */\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\n\t/* log message */\n\n>>> [ INFILL ] <<<\n\n\t    /* Leave this at QB_LOG_MAX_LEN so as not to overflow the blackbox */\n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\n\tactual_size += msg_len;\n\n\t/* now that we know the length, write it\n\t */\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);\n\tif (msg_len >= max_size) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); /* Reset */\n\n```\n\n\n\nwith the following test error: Running suite(s): logging\nthr_send_logs_1\nthr_send_logs_1\nthr_send_logs_2\nthr_send_logs_2\n93%: Checks: 16, Failures: 1, Errors: 0\ncheck_log.c:131:P:va_serialize:test_va_serialize:0: Passed\ncheck_log.c:189:P:log_stupid_inputs:test_log_stupid_inputs:0: Passed\ncheck_log.c:597:P:log_basic:test_log_basic:0: Passed\ncheck_log.c:678:P:log_format:test_log_format:0: Passed\ncheck_log.c:716:P:log_enable:test_log_enable:0: Passed\ncheck_log.c:783:P:log_threads:test_log_threads:0: Passed\ncheck_log.c:836:F:log_long_msg:test_log_long_msg:0: Assertion 'rc > 0' failed: rc == -2, 0 == 0\ncheck_log.c:295:P:log_filter_fn:test_log_filter_fn:0: Passed\ncheck_log.c:880:P:threaded_logging:test_threaded_logging:0: Passed\ncheck_log.c:432:P:line_length:test_line_length:0: Passed\ncheck_log.c:340:P:file_logging:test_file_logging:0: Passed\ncheck_log.c:914:P:threaded_logging_bad_sched_params:test_threaded_logging_bad_sched_params:0: Passed\ncheck_log.c:374:P:timestamps:test_timestamps:0: Passed\ncheck_log.c:971:P:extended_information:test_extended_information:0: Passed\ncheck_log.c:1009:P:zero_tags:test_zero_tags:0: Passed\ncheck_log.c:1083:P:syslog:test_syslog:0: Passed\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "1bbaa929b77113532785c408dd1b41cd0521ffc8___log_blackbox.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nint TNEFParse(TNEFStruct *TNEF) {\n  WORD key;\n  DWORD type;\n  DWORD size;\n  DWORD signature;\n  BYTE *data;\n  WORD checksum, header_checksum;\n  int i;\n\n  if (TNEF->IO.ReadProc == NULL) {\n    printf(\"ERROR: Setup incorrectly: No ReadProc\\n\");\n    return YTNEF_INCORRECT_SETUP;\n  }\n\n  if (TNEF->IO.InitProc != NULL) {\n    DEBUG(TNEF->Debug, 2, \"About to initialize\");\n    if (TNEF->IO.InitProc(&TNEF->IO) != 0) {\n      return YTNEF_CANNOT_INIT_DATA;\n    }\n    DEBUG(TNEF->Debug, 2, \"Initialization finished\");\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Signature\");\n  if (TNEF->IO.ReadProc(&TNEF->IO, sizeof(DWORD), 1, &signature) < 1) {\n    printf(\"ERROR: Error reading signature\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_ERROR_READING_DATA;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Checking Signature\");\n  if (TNEFCheckForSignature(signature) < 0) {\n    printf(\"ERROR: Signature does not match. Not TNEF.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NOT_TNEF_STREAM;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Reading Key.\");\n\n  if (TNEFGetKey(TNEF, &key) < 0) {\n    printf(\"ERROR: Unable to retrieve key.\\n\");\n    if (TNEF->IO.CloseProc != NULL) {\n      TNEF->IO.CloseProc(&TNEF->IO);\n    }\n    return YTNEF_NO_KEY;\n  }\n\n  DEBUG(TNEF->Debug, 2, \"Starting Full Processing.\");\n\n  while (TNEFGetHeader(TNEF, &type, &size) == 0) {\n    DEBUG2(TNEF->Debug, 2, \"Header says type=0x%X, size=%u\", type, size);\n    DEBUG2(TNEF->Debug, 2, \"Header says type=%u, size=%u\", type, size);\n\n>>> [ INFILL ] <<<\n    ALLOCCHECK(data);\n    if (TNEFRawRead(TNEF, data, size, &header_checksum) < 0) {\n      printf(\"ERROR: Unable to read data.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    if (TNEFRawRead(TNEF, (BYTE *)&checksum, 2, NULL) < 0) {\n      printf(\"ERROR: Unable to read checksum.\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_ERROR_READING_DATA;\n    }\n    checksum = SwapWord((BYTE *)&checksum, sizeof(WORD));\n    if (checksum != header_checksum) {\n      printf(\"ERROR: Checksum mismatch. Data corruption?:\\n\");\n      if (TNEF->IO.CloseProc != NULL) {\n        TNEF->IO.CloseProc(&TNEF->IO);\n      }\n      free(data);\n      return YTNEF_BAD_CHECKSUM;\n    }\n    for (i = 0; i < (sizeof(TNEFList) / sizeof(TNEFHandler)); i++) {\n      if (TNEFList[i].id == type) {\n        if (TNEFList[i].handler != NULL) {\n          if (TNEFList[i].handler(TNEF, i, (char*)data, size) < 0) {\n            free(data);\n            if (TNEF->IO.CloseProc != NULL) {\n              TNEF->IO.CloseProc(&TNEF->IO);\n            }\n            return YTNEF_ERROR_IN_HANDLER;\n          } else {\n            //  Found our handler and processed it.  now time to get out\n            break;\n          }\n        } else {\n          DEBUG2(TNEF->Debug, 1, \"No handler for %s: %u bytes\",\n                 TNEFList[i].name, size);\n        }\n      }\n    }\n\n    free(data);\n  }\n\n  if (TNEF->IO.CloseProc != NULL) {\n    TNEF->IO.CloseProc(&TNEF->IO);\n  }\n  return 0;\n\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    data = calloc(size, sizeof(BYTE));\n\n```\n\n\n\nwith the following test error: ==20774==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000012 at pc 0x7fb1e9e612eb bp 0x7ffff6dbd950 sp 0x7ffff6dbd948\nREAD of size 1 at 0x602000000012 thread T0\n    #0 0x7fb1e9e612ea in SwapWord /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:153:28\n    #1 0x7fb1e9e60c38 in TNEFVersion /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:338:11\n    #2 0x7fb1e9e6e02d in TNEFParse /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:1180:15\n    #3 0x7fb1e9e6cad6 in TNEFParseFile /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:1042:10\n    #4 0x55feb14dd4f0 in main /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/ytnefprint/main.c:80:9\n    #5 0x7fb1e9abc082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #6 0x55feb140a35d in _start (/out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/ytnefprint/.libs/ytnefprint+0x1f35d)\n\n0x602000000012 is located 1 bytes after 1-byte region [0x602000000010,0x602000000011)\nallocated by thread T0 here:\n    #0 0x55feb14a2b08 in __interceptor_calloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:77:3\n    #1 0x7fb1e9e6d9f1 in TNEFParse /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:1150:12\n    #2 0x7fb1e9e6cad6 in TNEFParseFile /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:1042:10\n    #3 0x55feb14dd4f0 in main /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/ytnefprint/main.c:80:9\n    #4 0x7fb1e9abc082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /out/Yeraze___ytnef/git_repo_dir_3cb0f914d6427073f262e1b2b5fd973e3043cdf7/lib/ytnef.c:153:28 in SwapWord\nShadow bytes around the buggy address:\n  0x601ffffffd80: 00 00 00 00 00 00 00 00 00 00 00 00 00 \nPlease provide the correct line following commit message at the infill location."}], "idx": "3cb0f914d6427073f262e1b2b5fd973e3043cdf7___ytnef.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nint URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  /* increased to 1 from second item on */\n\tURI_CHAR * write = dest;\n\n\t/* Subtract terminator */\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\t\t\t\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t} else {\n\t\t\tURI_CHAR * afterKey;\n\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\n\t\t\t/* Copy key */\n\t\t\tif (firstItem == URI_TRUE) {\n\n>>> [ INFILL ] <<<\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\tafterKey = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\twrite += (afterKey - write);\n\n\t\t\tif (value != NULL) {\n\t\t\t\tURI_CHAR * afterValue;\n\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\n\t\t\t\t/* Copy value */\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\tafterValue = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t\twrite += (afterValue - write);\n\t\t\t}\n\t\t}\n\n\t\tqueryList = queryList->next;\n\t}\n\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; /* .. for terminator */\n\t\t}\n\t}\n\n\treturn URI_SUCCESS;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\t\tfirstItem = URI_FALSE;\n\n```\n\n\n\nwith the following test error: UriSuite: 0/56\rUriSuite: 1/56\rUriSuite: 2/56\rUriSuite: 3/56\rUriSuite: 4/56\rUriSuite: 5/56\rUriSuite: 6/56\rUriSuite: 7/56\rUriSuite: 8/56\rUriSuite: 9/56\rUriSuite: 10/56\rUriSuite: 11/56\rUriSuite: 12/56\rUriSuite: 13/56\rUriSuite: 14/56\rUriSuite: 15/56\rUriSuite: 16/56\rUriSuite: 17/56\rUriSuite: 18/56\rUriSuite: 19/56\rUriSuite: 20/56\rUriSuite: 21/56\rUriSuite: 22/56\rUriSuite: 23/56\rUriSuite: 24/56\rUriSuite: 25/56\rUriSuite: 26/56\rUriSuite: 27/56\rUriSuite: 28/56\rUriSuite: 29/56\rUriSuite: 30/56\rUriSuite: 31/56\rUriSuite: 32/56\rUriSuite: 33/56\rUriSuite: 34/56\rUriSuite: 35/56\rUriSuite: 36/56\rUriSuite: 37/56\rUriSuite: 38/56\rUriSuite: 39/56\rUriSuite: 40/56\rUriSuite: 41/56\rUriSuite: 42/56\rUriSuite: 43/56\rUriSuite: 44/56\rUriSuite: 45/56\rUriSuite: 46/56\rUriSuite: 47/56\rUriSuite: 48/56\rUriSuite: 49/56\rUriSuite: 50/56\rUriSuite: 51/56\rUriSuite: 52/56\rUriSuite: 53/56\rUriSuite: 54/56\rUriSuite: 55/56\rUriSuite: 56/56\rUriSuite: 56/56, 98% correct in 0.000306 seconds\n\tTest:    testQueryCompositionMathWrite_GoogleAutofuzz113244572\n\tSuite:   UriSuite\n\tFile:    test/test.cpp\n\tLine:    1780\n\tMessage: uriComposeQueryExA(dest, &first, sizeof(dest), &charsWritten, spaceToPlus, normalizeBreaks) == URI_ERROR_OUTPUT_TOO_LARGE\n\nFourSuite: 0/7\rFourSuite: 1/7\rFourSuite: 2/7\rFourSuite: 3/7\rFourSuite: 4/7\rFourSuite: 5/7\rFourSuite: 6/7\rFourSuite: 7/7\rFourSuite: 7/7, 100% correct in 0.000245 seconds\nVersionSuite: 0/1\rbytes_printed: 5\nVersionSuite: 1/1\rVersionSuite: 1/1, 100% correct in 0.000012 seconds\nTotal: 64 tests, 98% correct in 0.000563 seconds\nFAIL test/uriparser_test (exit status: 1)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "864f5d4c127def386dd5cc926ad96934b297f04e___UriQuery.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic const URI_CHAR * URI_FUNC(ParseIPv6address2)(\n\t\tURI_TYPE(ParserState) * state,\n\t\tconst URI_CHAR * first, const URI_CHAR * afterLast,\n\t\tUriMemoryManager * memory) {\n\tint zipperEver = 0;\n\tint quadsDone = 0;\n\tint digitCount = 0;\n\tunsigned char digitHistory[4];\n\tint ip4OctetsDone = 0;\n\n\tunsigned char quadsAfterZipper[14];\n\tint quadsAfterZipperCount = 0;\n\n\n\tfor (;;) {\n\t\tif (first >= afterLast) {\n\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Inside IPv4 part? */\n\t\tif (ip4OctetsDone > 0) {\n\t\t\t/* Eat rest of IPv4 address */\n\t\t\tfor (;;) {\n\t\t\t\tswitch (*first) {\n\t\t\t\tcase URI_SET_DIGIT:\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount++] = (unsigned char)(9 + *first - _UT('9'));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT('.'):\n\t\t\t\t\tif ((ip4OctetsDone == 4) /* NOTE! */\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid digit or octet count */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4 + ip4OctetsDone] = uriGetOctetValue(digitHistory, digitCount);\n\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\tip4OctetsDone++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(']'):\n\t\t\t\t\tif ((ip4OctetsDone != 3) /* NOTE! */\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid digit or octet count */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate->uri->hostText.afterLast = first; /* HOST END */\n\n\t\t\t\t\t/* Copy missing quads right before IPv4 */\n\t\t\t\t\tmemcpy(state->uri->hostData.ip6->data + 16 - 4 - 2 * quadsAfterZipperCount,\n\t\t\t\t\t\t\t\tquadsAfterZipper, 2 * quadsAfterZipperCount);\n\n\t\t\t\t\t/* Copy last IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4 + 3] = uriGetOctetValue(digitHistory, digitCount);\n\n\t\t\t\t\treturn first + 1;\n\n\t\t\t\tdefault:\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tfirst++;\n\n>>> [ INFILL ] <<<\n\t\t} else {\n\t\t\t/* Eat while no dot in sight */\n\t\t\tint letterAmong = 0;\n\t\t\tint walking = 1;\n\t\t\tdo {\n\t\t\t\tswitch (*first) {\n\t\t\t\tcase URI_SET_HEX_LETTER_LOWER:\n\t\t\t\t\tletterAmong = 1;\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(15 + *first - _UT('f'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase URI_SET_HEX_LETTER_UPPER:\n\t\t\t\t\tletterAmong = 1;\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(15 + *first - _UT('F'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase URI_SET_DIGIT:\n\t\t\t\t\tif (digitCount == 4) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tdigitHistory[digitCount] = (unsigned char)(9 + *first - _UT('9'));\n\t\t\t\t\tdigitCount++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(':'):\n\t\t\t\t\t{\n\t\t\t\t\t\tint setZipper = 0;\n\n\t\t\t\t\t\tif (digitCount > 0) {\n\t\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, quadsAfterZipper + 2 * quadsAfterZipperCount);\n\t\t\t\t\t\t\t\tquadsAfterZipperCount++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, state->uri->hostData.ip6->data + 2 * quadsDone);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tquadsDone++;\n\t\t\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tletterAmong = 0;\n\n\t\t\t\t\t\t/* Too many quads? */\n\t\t\t\t\t\tif (quadsDone >= 8 - zipperEver) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* \"::\"? */\n\t\t\t\t\t\tif (first + 1 >= afterLast) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (first[1] == _UT(':')) {\n\t\t\t\t\t\t\tconst int resetOffset = 2 * (quadsDone + (digitCount > 0));\n\n\t\t\t\t\t\t\tfirst++;\n\t\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* \"::.+::\" */\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/* Zero everything after zipper */\n\t\t\t\t\t\t\tmemset(state->uri->hostData.ip6->data + resetOffset, 0, 16 - resetOffset);\n\t\t\t\t\t\t\tsetZipper = 1;\n\n\t\t\t\t\t\t\t/* \":::+\"? */\n\t\t\t\t\t\t\tif (first + 1 >= afterLast) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* No ']' yet */\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (first[1] == _UT(':')) {\n\t\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first + 1, memory);\n\t\t\t\t\t\t\t\treturn NULL; /* \":::+ \"*/\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (setZipper) {\n\t\t\t\t\t\t\tzipperEver = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT('.'):\n\t\t\t\t\tif ((quadsDone > 6) /* NOTE */\n\t\t\t\t\t\t\t|| (!zipperEver && (quadsDone < 6))\n\t\t\t\t\t\t\t|| letterAmong\n\t\t\t\t\t\t\t|| (digitCount == 0)\n\t\t\t\t\t\t\t|| (digitCount == 4)) {\n\t\t\t\t\t\t/* Invalid octet before */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 1)\n\t\t\t\t\t\t\t&& (digitHistory[0] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount > 2)\n\t\t\t\t\t\t\t&& (digitHistory[1] == 0)) {\n\t\t\t\t\t\t/* Leading zero */\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - digitCount + 1, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t} else if ((digitCount == 3)\n\t\t\t\t\t\t\t&& (100 * digitHistory[0]\n\t\t\t\t\t\t\t\t+ 10 * digitHistory[1]\n\t\t\t\t\t\t\t\t+ digitHistory[2] > 255)) {\n\t\t\t\t\t\t/* Octet value too large */\n\t\t\t\t\t\tif (digitHistory[0] > 2) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 3, memory);\n\t\t\t\t\t\t} else if (digitHistory[1] > 5) {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 2, memory);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first - 1, memory);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy first IPv4 octet */\n\t\t\t\t\tstate->uri->hostData.ip6->data[16 - 4] = uriGetOctetValue(digitHistory, digitCount);\n\t\t\t\t\tdigitCount = 0;\n\n\t\t\t\t\t/* Switch over to IPv4 loop */\n\t\t\t\t\tip4OctetsDone = 1;\n\t\t\t\t\twalking = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _UT(']'):\n\t\t\t\t\t/* Too little quads? */\n\t\t\t\t\tif (!zipperEver && !((quadsDone == 7) && (digitCount > 0))) {\n\t\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (digitCount > 0) {\n\t\t\t\t\t\tif (zipperEver) {\n\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, quadsAfterZipper + 2 * quadsAfterZipperCount);\n\t\t\t\t\t\t\tquadsAfterZipperCount++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\turiWriteQuadToDoubleByte(digitHistory, digitCount, state->uri->hostData.ip6->data + 2 * quadsDone);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tquadsDone++;\n\t\t\t\t\t\tdigitCount = 0;\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Copy missing quads to the end */\n\t\t\t\t\tmemcpy(state->uri->hostData.ip6->data + 16 - 2 * quadsAfterZipperCount,\n\t\t\t\t\t\t\t\tquadsAfterZipper, 2 * quadsAfterZipperCount);\n\n\t\t\t\t\tstate->uri->hostText.afterLast = first; /* HOST END */\n\t\t\t\t\treturn first + 1; /* Fine */\n\n\t\t\t\tdefault:\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tfirst++;\n\n\t\t\t\tif (first >= afterLast) {\n\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n\t\t\t\t\treturn NULL; /* No ']' yet */\n\t\t\t\t}\n\t\t\t} while (walking);\n\t\t}\n\t}\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\t}\n\n```\n\n\n\nwith the following test error: [==========] Running 88 tests from 9 test suites.\n[----------] Global test environment set-up.\n[----------] 7 tests from FourSuite\n[ RUN      ] FourSuite.AbsolutizeTestCases\n[       OK ] FourSuite.AbsolutizeTestCases (0 ms)\n[ RUN      ] FourSuite.RelativizeTestCases\n[       OK ] FourSuite.RelativizeTestCases (0 ms)\n[ RUN      ] FourSuite.GoodUriReferences\n[       OK ] FourSuite.GoodUriReferences (0 ms)\n[ RUN      ] FourSuite.BadUriReferences\n[       OK ] FourSuite.BadUriReferences (0 ms)\n[ RUN      ] FourSuite.CaseNormalizationTests\n[       OK ] FourSuite.CaseNormalizationTests (0 ms)\n[ RUN      ] FourSuite.PctEncNormalizationTests\n[       OK ] FourSuite.PctEncNormalizationTests (0 ms)\n[ RUN      ] FourSuite.PathSegmentNormalizationTests\n[       OK ] FourSuite.PathSegmentNormalizationTests (0 ms)\n[----------] 7 tests from FourSuite (0 ms total)\n\n[----------] 2 tests from MemoryManagerCompletenessSuite\n[ RUN      ] MemoryManagerCompletenessSuite.AllFunctionMembersRequired\n[       OK ] MemoryManagerCompletenessSuite.AllFunctionMembersRequired (0 ms)\n[ RUN      ] MemoryManagerCompletenessSuite.MallocAndFreeRequiredOnly\n[       OK ] MemoryManagerCompletenessSuite.MallocAndFreeRequiredOnly (0 ms)\n[----------] 2 tests from MemoryManagerCompletenessSuite (0 ms total)\n\n[----------] 5 tests from MemoryManagerTestingSuite\n[ RUN      ] MemoryManagerTestingSuite.DefaultMemoryManager\n[       OK ] MemoryManagerTestingSuite.DefaultMemoryManager (0 ms)\n[ RUN      ] MemoryManagerTestingSuite.CompleteMemoryManager\n[       OK ] MemoryManagerTestingSuite.CompleteMemoryManager (0 ms)\n[ RUN      ] MemoryManagerTestingSuite.EmulateCalloc\n[       OK ] MemoryManagerTestingSuite.EmulateCalloc (0 ms)\n[ RUN      ] MemoryManagerTestingSuite.EmulateReallocarray\n[       OK ] MemoryManagerTestingSuite.EmulateReallocarray (0 ms)\n[ RUN      ] MemoryManagerTestingSuite.EmulateCallocAndReallocarray\n[       OK ] MemoryManagerTestingSuite.EmulateCallocAndReallocarray (0 ms)\n[----------] 5 tests from MemoryManagerTestingSuite (0 ms total)\n\n[--------- \nPlease provide the correct line following commit message at the infill location."}], "idx": "cef25028de5ff872c2e1f0a6c562eb3ea9ecbce4___UriParse.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic LY_ERR\nxml_print_opaq_open(struct xmlpr_ctx *pctx, const struct lyd_node_opaq *node)\n{\n    /* print node name */\n    ly_print_(pctx->out, \"%*s<%s\", INDENT, node->name.name);\n\n\n>>> [ INFILL ] <<<\n    /* print attributes */\n    LY_CHECK_RET(xml_print_attr(pctx, node));\n\n    return LY_SUCCESS;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    /* print default namespace */\n    xml_print_ns_opaq(pctx, node->format, &node->name, LYXML_PREFIX_DEFAULT);\n\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_ea0f96cf45deed39fb98b28f30d0acdc304db243/build_ea0f96cf45deed39fb98b28f30d0acdc304db243\nTest project /out/CESNET___libyang/git_repo_dir_ea0f96cf45deed39fb98b28f30d0acdc304db243/build_ea0f96cf45deed39fb98b28f30d0acdc304db243\n    Start 42: utest_new\n1/1 Test #42: utest_new ........................***Failed    0.04 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.05 sec\n\nThe following tests FAILED:\n\t 42 - utest_new (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ea0f96cf45deed39fb98b28f30d0acdc304db243___printer_xml.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic LY_ERR\nlys_compile_node_leaf(struct lysc_ctx *ctx, struct lysp_node *node_p, struct lysc_node *node)\n{\n    struct lysp_node_leaf *leaf_p = (struct lysp_node_leaf*)node_p;\n    struct lysc_node_leaf *leaf = (struct lysc_node_leaf*)node;\n    unsigned int u;\n    LY_ERR ret = LY_SUCCESS;\n\n    COMPILE_ARRAY_GOTO(ctx, leaf_p->musts, leaf->musts, u, lys_compile_must, ret, done);\n    if (leaf_p->units) {\n        leaf->units = lydict_insert(ctx->ctx, leaf_p->units, 0);\n        leaf->flags |= LYS_SET_UNITS;\n    }\n\n    /* the dflt member is just filled to avoid getting the default value from the type */\n    leaf->dflt = (void*)leaf_p->dflt;\n    ret = lys_compile_node_type(ctx, node_p, &leaf_p->type, leaf);\n\n>>> [ INFILL ] <<<\n    if (leaf_p->dflt) {\n        struct ly_err_item *err = NULL;\n        leaf->dflt_mod = ctx->mod_def;\n        leaf->dflt = calloc(1, sizeof *leaf->dflt);\n        leaf->dflt->realtype = leaf->type;\n        ret = leaf->type->plugin->store(ctx->ctx, leaf->type, leaf_p->dflt, strlen(leaf_p->dflt),\n                                        LY_TYPE_OPTS_INCOMPLETE_DATA | LY_TYPE_OPTS_SCHEMA | LY_TYPE_OPTS_STORE,\n                                        lys_resolve_prefix, (void*)leaf->dflt_mod, LYD_XML, node, NULL, leaf->dflt, NULL, &err);\n        leaf->dflt->realtype->refcount++;\n        if (err) {\n            ly_err_print(err);\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_SEMANTICS,\n                   \"Invalid leaf's default value \\\"%s\\\" which does not fit the type (%s).\", leaf_p->dflt, err->msg);\n            ly_err_free(err);\n        }\n        if (ret == LY_EINCOMPLETE) {\n            /* postpone default compilation when the tree is complete */\n            LY_CHECK_RET(lysc_incomplete_dflts_add(ctx, node, leaf->dflt, leaf->dflt_mod));\n\n            /* but in general result is so far ok */\n            ret = LY_SUCCESS;\n        }\n        LY_CHECK_RET(ret);\n        leaf->flags |= LYS_SET_DFLT;\n    }\n\n\ndone:\n    return ret;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    leaf->dflt = NULL;\n    LY_CHECK_RET(ret);\n\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_812a5bff4857a485db96fe7269af944d0bdb91b3/build_812a5bff4857a485db96fe7269af944d0bdb91b3\nTest project /out/CESNET___libyang/git_repo_dir_812a5bff4857a485db96fe7269af944d0bdb91b3/build_812a5bff4857a485db96fe7269af944d0bdb91b3\n    Start 9: src_tree_schema_compile\n1/1 Test #9: src_tree_schema_compile ..........***Failed    0.12 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.12 sec\n\nThe following tests FAILED:\n\t  9 - src_tree_schema_compile (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "812a5bff4857a485db96fe7269af944d0bdb91b3___tree_schema_compile.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic void\nlys_switch_deviation(struct lys_deviation *dev, const struct lys_module *module, struct unres_schema *unres)\n{\n    int ret, reapply = 0;\n    char *parent_path;\n    struct lys_node *target = NULL, *parent;\n    struct ly_set *set;\n\n    if (!dev->deviate) {\n        return;\n    }\n\n    if (dev->deviate[0].mod == LY_DEVIATE_NO) {\n        if (dev->orig_node) {\n            /* removing not-supported deviation ... */\n            if (strrchr(dev->target_name, '/') != dev->target_name) {\n                /* ... from a parent */\n\n                /* reconnect to its previous position */\n                parent = dev->orig_node->parent;\n                if (parent) {\n                    dev->orig_node->parent = NULL;\n                    /* the original node was actually from augment, we have to get know if the augment is\n                     * applied (its module is enabled and implemented). If yes, the node will be connected\n                     * to the augment and the linkage with the target will be fixed if needed, otherwise\n                     * it will be connected only to the augment */\n                    if (!(parent->flags & LYS_NOTAPPLIED)) {\n                        /* start with removing augment if applied before adding nodes, we have to make sure\n                         * that everything will be connect correctly */\n                        remove_aug((struct lys_node_augment *)parent);\n                        reapply = 1;\n                    }\n                    /* connect the deviated node back into the augment */\n                    lys_node_addchild(parent, NULL, dev->orig_node);\n                    if (reapply) {\n                        /* augment is supposed to be applied, so fix pointers in target and the status of the original node */\n\n>>> [ INFILL ] <<<\n                } else {\n                    /* non-augment, non-toplevel */\n                    parent_path = strndup(dev->target_name, strrchr(dev->target_name, '/') - dev->target_name);\n                    ret = resolve_schema_nodeid(parent_path, NULL, module, &set, 0, 1);\n                    free(parent_path);\n                    if (ret == -1) {\n                        LOGINT;\n                        ly_set_free(set);\n                        return;\n                    }\n                    target = set->set.s[0];\n                    ly_set_free(set);\n\n                    lys_node_addchild(target, NULL, dev->orig_node);\n                }\n            } else {\n                /* ... from top-level data */\n                lys_node_addchild(NULL, (struct lys_module *)dev->orig_node->module, dev->orig_node);\n            }\n\n            dev->orig_node = NULL;\n        } else {\n            /* adding not-supported deviation */\n            ret = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n            if (ret == -1) {\n                LOGINT;\n                ly_set_free(set);\n                return;\n            }\n            target = set->set.s[0];\n            ly_set_free(set);\n\n            /* unlink and store the original node */\n            parent = target->parent;\n            lys_node_unlink(target);\n            if (parent && parent->nodetype == LYS_AUGMENT) {\n                /* hack for augment, because when the original will be sometime reconnected back, we actually need\n                 * to reconnect it to both - the augment and its target (which is deduced from the deviations target\n                 * path), so we need to remember the augment as an addition */\n                target->parent = parent;\n            }\n            dev->orig_node = target;\n        }\n    } else {\n        ret = resolve_schema_nodeid(dev->target_name, NULL, module, &set, 0, 1);\n        if (ret == -1) {\n            LOGINT;\n            ly_set_free(set);\n            return;\n        }\n        target = set->set.s[0];\n        ly_set_free(set);\n\n        lys_node_switch(target, dev->orig_node);\n        dev->orig_node = target;\n    }\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n                        if (parent->child == dev->orig_node) {\n                            /* the only node in augment */\n                            parent->flags |= LYS_NOTAPPLIED; /* allow apply_aug() */\n                            apply_aug((struct lys_node_augment *)parent, unres);\n                            /* else other nodes from augment applied, nothing more needed in target, everything was done\n                             * by lys_node_addchild() */\n                        }\n                    }\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_823fbe0f7a7b50b7c80cfd948eb3c189579126ab/build_823fbe0f7a7b50b7c80cfd948eb3c189579126ab\nTest project /out/CESNET___libyang/git_repo_dir_823fbe0f7a7b50b7c80cfd948eb3c189579126ab/build_823fbe0f7a7b50b7c80cfd948eb3c189579126ab\n    Start 31: test_deviation\n1/1 Test #31: test_deviation ...................***Failed    0.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.02 sec\n\nThe following tests FAILED:\n\t 31 - test_deviation (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "823fbe0f7a7b50b7c80cfd948eb3c189579126ab___tree_schema.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\n  Result<std::shared_ptr<Buffer>> ConcatenateDictionaryIndices(\n      const DataType& index_type, const BufferVector& index_transpositions) {\n    const auto index_width =\n        internal::checked_cast<const FixedWidthType&>(index_type).bit_width() / 8;\n    int64_t out_length = 0;\n    for (const auto& data : in_) {\n      out_length += data->length;\n    }\n    ARROW_ASSIGN_OR_RAISE(auto out, AllocateBuffer(out_length * index_width, pool_));\n    uint8_t* out_data = out->mutable_data();\n    for (size_t i = 0; i < in_.size(); i++) {\n      const auto& data = in_[i];\n      auto transpose_map =\n          reinterpret_cast<const int32_t*>(index_transpositions[i]->data());\n      const uint8_t* src = data->GetValues<uint8_t>(1, 0);\n      if (!data->buffers[0]) {\n        RETURN_NOT_OK(internal::TransposeInts(index_type, index_type,\n                                              /*src=*/data->GetValues<uint8_t>(1, 0),\n                                              /*dest=*/out_data,\n                                              /*src_offset=*/data->offset,\n                                              /*dest_offset=*/0, /*length=*/data->length,\n                                              transpose_map));\n      } else {\n        internal::BitRunReader reader(data->buffers[0]->data(), data->offset,\n                                      data->length);\n        int64_t position = 0;\n        while (true) {\n          internal::BitRun run = reader.NextRun();\n          if (run.length == 0) break;\n\n          if (run.set) {\n            RETURN_NOT_OK(internal::TransposeInts(index_type, index_type, src,\n                                                  /*dest=*/out_data,\n                                                  /*src_offset=*/data->offset + position,\n                                                  /*dest_offset=*/position, run.length,\n                                                  transpose_map));\n          } else {\n\n>>> [ INFILL ] <<<\n\n          position += run.length;\n        }\n      }\n      out_data += data->length * index_width;\n    }\n    return std::move(out);\n  }\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n            std::fill(out_data + position,\n                      out_data + position + (run.length * index_width), 0x00);\n          }\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_68e0fa7499876fc0cf86b8be784a890226648645/build_68e0fa7499876fc0cf86b8be784a890226648645\nTest project /out/apache___arrow/git_repo_dir_68e0fa7499876fc0cf86b8be784a890226648645/build_68e0fa7499876fc0cf86b8be784a890226648645\n    Start 14: arrow-concatenate-test\n1/1 Test #14: arrow-concatenate-test ...........***Failed    0.22 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow-tests    =   0.22 sec*proc (1 test)\nunittest       =   0.22 sec*proc (1 test)\n\nTotal Test time (real) =   0.23 sec\n\nThe following tests FAILED:\n\t 14 - arrow-concatenate-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "68e0fa7499876fc0cf86b8be784a890226648645___concatenate.cc"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\n    void convert_to_base() SOCI_OVERRIDE\n    {\n\n>>> [ INFILL ] <<<\n            base_value_holder<T>::val_, ind_);\n    }\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n        type_conversion<T>::to_base(value_,\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/SOCI___soci/git_repo_dir_9ff3016c00108f21760d438bfbb451188886274c/build_9ff3016c00108f21760d438bfbb451188886274c\nTest project /out/SOCI___soci/git_repo_dir_9ff3016c00108f21760d438bfbb451188886274c/build_9ff3016c00108f21760d438bfbb451188886274c\n    Start 3: soci_sqlite3_test\n1/2 Test #3: soci_sqlite3_test ................***Failed    0.10 sec\n    Start 4: soci_sqlite3_test_static\n2/2 Test #4: soci_sqlite3_test_static .........***Failed    0.09 sec\n\n0% tests passed, 2 tests failed out of 2\n\nTotal Test time (real) =   0.20 sec\n\nThe following tests FAILED:\n\t  3 - soci_sqlite3_test (Failed)\n\t  4 - soci_sqlite3_test_static (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "9ff3016c00108f21760d438bfbb451188886274c___type-conversion.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nbool Optimizer::Run(const uint32_t* original_binary,\n                    const size_t original_binary_size,\n                    std::vector<uint32_t>* optimized_binary,\n                    const spv_optimizer_options opt_options) const {\n  spvtools::SpirvTools tools(impl_->target_env);\n  tools.SetMessageConsumer(impl_->pass_manager.consumer());\n  if (opt_options->run_validator_ &&\n      !tools.Validate(original_binary, original_binary_size,\n                      &opt_options->val_options_)) {\n    return false;\n  }\n\n  std::unique_ptr<opt::IRContext> context = BuildModule(\n      impl_->target_env, consumer(), original_binary, original_binary_size);\n  if (context == nullptr) return false;\n\n  context->set_max_id_bound(opt_options->max_id_bound_);\n  context->set_preserve_bindings(opt_options->preserve_bindings_);\n  context->set_preserve_spec_constants(opt_options->preserve_spec_constants_);\n\n  impl_->pass_manager.SetValidatorOptions(&opt_options->val_options_);\n  impl_->pass_manager.SetTargetEnv(impl_->target_env);\n  auto status = impl_->pass_manager.Run(context.get());\n\n  if (status == opt::Pass::Status::Failure) {\n    return false;\n  }\n\n  optimized_binary->clear();\n  context->module()->ToBinary(optimized_binary, /* skip_nop = */ true);\n\n#ifndef NDEBUG\n  if (status == opt::Pass::Status::SuccessWithoutChange) {\n\n>>> [ INFILL ] <<<\n    assert(!changed &&\n           \"Binary unexpectedly changed despite optimizer saying there was no \"\n           \"change\");\n  }\n#endif  // !NDEBUG\n\n  return true;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    auto changed = optimized_binary->size() != original_binary_size ||\n                   memcmp(optimized_binary->data(), original_binary,\n                          original_binary_size) != 0;\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_6a9be627c760cf1efa43d155d4e6ee5e801deba3/build_6a9be627c760cf1efa43d155d4e6ee5e801deba3\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_6a9be627c760cf1efa43d155d4e6ee5e801deba3/build_6a9be627c760cf1efa43d155d4e6ee5e801deba3\n    Start 13: spirv-tools-test_opt\n1/2 Test #13: spirv-tools-test_opt .............Subprocess aborted***Exception:  10.80 sec\n    Start 15: spirv-tools-test_opt_loops\n2/2 Test #15: spirv-tools-test_opt_loops .......   Passed    5.04 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  15.85 sec\n\nThe following tests FAILED:\n\t 13 - spirv-tools-test_opt (Subprocess aborted)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "6a9be627c760cf1efa43d155d4e6ee5e801deba3___optimizer.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\n  void Compute() {\n\n>>> [ INFILL ] <<<\n    EvaluateRegisterRequirements();\n  }\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    cfg_.ForEachBlockInPostOrder(&*function_->begin(), [this](BasicBlock* bb) {\n      ComputePartialLiveness(bb);\n    });\n    DoLoopLivenessUnification();\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_54385458ca2f7a7b06699e441822753dbc2d018d/build_54385458ca2f7a7b06699e441822753dbc2d018d\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_54385458ca2f7a7b06699e441822753dbc2d018d/build_54385458ca2f7a7b06699e441822753dbc2d018d\n    Start 13: spirv-tools-test_opt\n1/2 Test #13: spirv-tools-test_opt .............Subprocess aborted***Exception:  11.83 sec\n    Start 15: spirv-tools-test_opt_loops\n2/2 Test #15: spirv-tools-test_opt_loops .......   Passed    4.86 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  16.70 sec\n\nThe following tests FAILED:\n\t 13 - spirv-tools-test_opt (Subprocess aborted)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "54385458ca2f7a7b06699e441822753dbc2d018d___register_pressure.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nOptimizer& Optimizer::RegisterVulkanToWebGPUPasses() {\n\n>>> [ INFILL ] <<<\n      .RegisterPass(CreateLegalizeVectorShufflePass())\n      .RegisterPass(CreateSplitInvalidUnreachablePass())\n      .RegisterPass(CreateEliminateDeadConstantPass())\n      .RegisterPass(CreateFlattenDecorationPass())\n      .RegisterPass(CreateAggressiveDCEPass())\n      .RegisterPass(CreateDeadBranchElimPass())\n      .RegisterPass(CreateCompactIdsPass());\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  return RegisterPass(CreateStripDebugInfoPass())\n      .RegisterPass(CreateStripAtomicCounterMemoryPass())\n      .RegisterPass(CreateGenerateWebGPUInitializersPass())\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0a5d99d02cb8c0edd41c7a9d4f309c0974d076d0/build_0a5d99d02cb8c0edd41c7a9d4f309c0974d076d0\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0a5d99d02cb8c0edd41c7a9d4f309c0974d076d0/build_0a5d99d02cb8c0edd41c7a9d4f309c0974d076d0\n    Start 13: spirv-tools-test_opt\n1/2 Test #13: spirv-tools-test_opt .............***Failed   33.68 sec\n    Start 15: spirv-tools-test_opt_loops\n2/2 Test #15: spirv-tools-test_opt_loops .......   Passed    4.86 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  38.55 sec\n\nThe following tests FAILED:\n\t 13 - spirv-tools-test_opt (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "0a5d99d02cb8c0edd41c7a9d4f309c0974d076d0___optimizer.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nNonSemanticShaderDebugInfo100Instructions Instruction::GetShader100DebugOpcode()\n    const {\n  if (opcode() != SpvOpExtInst) {\n    return NonSemanticShaderDebugInfo100InstructionsMax;\n  }\n\n  if (!context()->get_feature_mgr()->GetExtInstImportId_Shader100DebugInfo()) {\n    return NonSemanticShaderDebugInfo100InstructionsMax;\n  }\n\n  if (GetSingleWordInOperand(kExtInstSetIdInIdx) !=\n      context()->get_feature_mgr()->GetExtInstImportId_Shader100DebugInfo()) {\n    return NonSemanticShaderDebugInfo100InstructionsMax;\n  }\n\n\n>>> [ INFILL ] <<<\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  return NonSemanticShaderDebugInfo100Instructions(\n      GetSingleWordInOperand(kExtInstInstructionInIdx));\n}\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_d5a3bfcf2ffd154a244e7ffae54dd1766d98efa4/build_d5a3bfcf2ffd154a244e7ffae54dd1766d98efa4\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_d5a3bfcf2ffd154a244e7ffae54dd1766d98efa4/build_d5a3bfcf2ffd154a244e7ffae54dd1766d98efa4\n    Start 18: spirv-tools-test_opt\n1/2 Test #18: spirv-tools-test_opt .............***Failed   49.79 sec\n    Start 20: spirv-tools-test_opt_loops\n2/2 Test #20: spirv-tools-test_opt_loops .......   Passed    5.27 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  55.08 sec\n\nThe following tests FAILED:\n\t 18 - spirv-tools-test_opt (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "d5a3bfcf2ffd154a244e7ffae54dd1766d98efa4___instruction.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nvoid Verifier::verifyCallSite(CallSite CS) {\n  Instruction *I = CS.getInstruction();\n\n  Assert(CS.getCalledValue()->getType()->isPointerTy(),\n         \"Called function must be a pointer!\", I);\n  PointerType *FPTy = cast<PointerType>(CS.getCalledValue()->getType());\n\n  Assert(FPTy->getElementType()->isFunctionTy(),\n         \"Called function is not pointer to function type!\", I);\n\n  Assert(FPTy->getElementType() == CS.getFunctionType(),\n         \"Called function is not the same type as the call!\", I);\n\n  FunctionType *FTy = CS.getFunctionType();\n\n  // Verify that the correct number of arguments are being passed\n  if (FTy->isVarArg())\n    Assert(CS.arg_size() >= FTy->getNumParams(),\n           \"Called function requires more parameters than were provided!\", I);\n  else\n    Assert(CS.arg_size() == FTy->getNumParams(),\n           \"Incorrect number of arguments passed to called function!\", I);\n\n  // Verify that all arguments to the call match the function type.\n  for (unsigned i = 0, e = FTy->getNumParams(); i != e; ++i)\n    Assert(CS.getArgument(i)->getType() == FTy->getParamType(i),\n           \"Call parameter type does not match function signature!\",\n           CS.getArgument(i), FTy->getParamType(i), I);\n\n  AttributeSet Attrs = CS.getAttributes();\n\n  Assert(verifyAttributeCount(Attrs, CS.arg_size()),\n         \"Attribute after last parameter!\", I);\n\n  // Verify call attributes.\n  verifyFunctionAttrs(FTy, Attrs, I);\n\n  // Conservatively check the inalloca argument.\n  // We have a bug if we can find that there is an underlying alloca without\n  // inalloca.\n  if (CS.hasInAllocaArgument()) {\n    Value *InAllocaArg = CS.getArgument(FTy->getNumParams() - 1);\n    if (auto AI = dyn_cast<AllocaInst>(InAllocaArg->stripInBoundsOffsets()))\n      Assert(AI->isUsedWithInAlloca(),\n             \"inalloca argument for call has mismatched alloca\", AI, I);\n  }\n\n  // For each argument of the callsite, if it has the swifterror argument,\n  // make sure the underlying alloca has swifterror as well.\n  for (unsigned i = 0, e = FTy->getNumParams(); i != e; ++i)\n    if (CS.paramHasAttr(i+1, Attribute::SwiftError)) {\n      Value *SwiftErrorArg = CS.getArgument(i);\n      auto AI = dyn_cast<AllocaInst>(SwiftErrorArg->stripInBoundsOffsets());\n      Assert(AI, \"swifterror argument should come from alloca\", AI, I);\n      if (AI)\n        Assert(AI->isSwiftError(),\n               \"swifterror argument for call has mismatched alloca\", AI, I);\n    }\n\n  if (FTy->isVarArg()) {\n    // FIXME? is 'nest' even legal here?\n    bool SawNest = false;\n    bool SawReturned = false;\n\n    for (unsigned Idx = 1; Idx < 1 + FTy->getNumParams(); ++Idx) {\n      if (Attrs.hasAttribute(Idx, Attribute::Nest))\n        SawNest = true;\n      if (Attrs.hasAttribute(Idx, Attribute::Returned))\n        SawReturned = true;\n    }\n\n    // Check attributes on the varargs part.\n    for (unsigned Idx = 1 + FTy->getNumParams(); Idx <= CS.arg_size(); ++Idx) {\n      Type *Ty = CS.getArgument(Idx-1)->getType();\n      verifyParameterAttrs(Attrs, Idx, Ty, false, I);\n\n      if (Attrs.hasAttribute(Idx, Attribute::Nest)) {\n        Assert(!SawNest, \"More than one parameter has attribute nest!\", I);\n        SawNest = true;\n      }\n\n      if (Attrs.hasAttribute(Idx, Attribute::Returned)) {\n        Assert(!SawReturned, \"More than one parameter has attribute returned!\",\n               I);\n        Assert(Ty->canLosslesslyBitCastTo(FTy->getReturnType()),\n               \"Incompatible argument and return types for 'returned' \"\n               \"attribute\",\n               I);\n        SawReturned = true;\n      }\n\n      Assert(!Attrs.hasAttribute(Idx, Attribute::StructRet),\n             \"Attribute 'sret' cannot be used for vararg call arguments!\", I);\n\n      if (Attrs.hasAttribute(Idx, Attribute::InAlloca))\n        Assert(Idx == CS.arg_size(), \"inalloca isn't on the last argument!\", I);\n    }\n  }\n\n  // Verify that there's no metadata unless it's a direct call to an intrinsic.\n  if (CS.getCalledFunction() == nullptr ||\n      !CS.getCalledFunction()->getName().startswith(\"llvm.\")) {\n    for (Type *ParamTy : FTy->params()) {\n      Assert(!ParamTy->isMetadataTy(),\n             \"Function has metadata parameter but isn't an intrinsic\", I);\n      Assert(!ParamTy->isTokenTy(),\n             \"Function has token parameter but isn't an intrinsic\", I);\n    }\n  }\n\n  // Verify that indirect calls don't return tokens.\n  if (CS.getCalledFunction() == nullptr)\n    Assert(!FTy->getReturnType()->isTokenTy(),\n           \"Return type cannot be token for indirect call!\");\n\n  if (Function *F = CS.getCalledFunction())\n    if (Intrinsic::ID ID = (Intrinsic::ID)F->getIntrinsicID())\n      visitIntrinsicCallSite(ID, CS);\n\n  // Verify that a callsite has at most one \"deopt\", at most one \"funclet\" and\n  // at most one \"gc-transition\" operand bundle.\n  bool FoundDeoptBundle = false, FoundFuncletBundle = false,\n       FoundGCTransitionBundle = false;\n  for (unsigned i = 0, e = CS.getNumOperandBundles(); i < e; ++i) {\n    OperandBundleUse BU = CS.getOperandBundleAt(i);\n    uint32_t Tag = BU.getTagID();\n    if (Tag == LLVMContext::OB_deopt) {\n      Assert(!FoundDeoptBundle, \"Multiple deopt operand bundles\", I);\n      FoundDeoptBundle = true;\n    } else if (Tag == LLVMContext::OB_gc_transition) {\n      Assert(!FoundGCTransitionBundle, \"Multiple gc-transition operand bundles\",\n             I);\n      FoundGCTransitionBundle = true;\n    } else if (Tag == LLVMContext::OB_funclet) {\n      Assert(!FoundFuncletBundle, \"Multiple funclet operand bundles\", I);\n      FoundFuncletBundle = true;\n      Assert(BU.Inputs.size() == 1,\n             \"Expected exactly one funclet bundle operand\", I);\n      Assert(isa<FuncletPadInst>(BU.Inputs.front()),\n             \"Funclet bundle operands should correspond to a FuncletPadInst\",\n             I);\n    }\n  }\n\n\n>>> [ INFILL ] <<<\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  visitInstruction(*I);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Verifier/callsite-dbgloc.ll (1 of 1)\nTesting Time: 0.03s\n********************\nFailing Tests (1):\n    LLVM :: Verifier/callsite-dbgloc.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "93035c8f47589590b65041603524f48a7c007e1f___Verifier.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic ICmpInst *canonicalizeCmpWithConstant(ICmpInst &I,\n                                             InstCombiner::BuilderTy &Builder) {\n  Value *Op0 = I.getOperand(0);\n  Value *Op1 = I.getOperand(1);\n\n  if (auto *Op1C = dyn_cast<ConstantInt>(Op1)) {\n    // For scalars, SimplifyICmpInst has already handled the edge cases for us,\n    // so we just assert on them.\n    APInt Op1Val = Op1C->getValue();\n    switch (I.getPredicate()) {\n    case ICmpInst::ICMP_ULE:\n      assert(!Op1C->isMaxValue(false)); // A <=u MAX -> TRUE\n      return new ICmpInst(ICmpInst::ICMP_ULT, Op0, Builder.getInt(Op1Val + 1));\n    case ICmpInst::ICMP_SLE:\n      assert(!Op1C->isMaxValue(true));  // A <=s MAX -> TRUE\n      return new ICmpInst(ICmpInst::ICMP_SLT, Op0, Builder.getInt(Op1Val + 1));\n    case ICmpInst::ICMP_UGE:\n      assert(!Op1C->isMinValue(false)); // A >=u MIN -> TRUE\n      return new ICmpInst(ICmpInst::ICMP_UGT, Op0, Builder.getInt(Op1Val - 1));\n    case ICmpInst::ICMP_SGE:\n      assert(!Op1C->isMinValue(true));  // A >=s MIN -> TRUE\n      return new ICmpInst(ICmpInst::ICMP_SGT, Op0, Builder.getInt(Op1Val - 1));\n    default:\n      return nullptr;\n    }\n  }\n\n  // The usual vector types are ConstantDataVector. Exotic vector types are\n\n>>> [ INFILL ] <<<\n    Type *Op1Type = Op1->getType();\n    unsigned NumElts = Op1Type->getVectorNumElements();\n\n    // Set the new comparison predicate and splat a vector of 1 or -1 to\n    // increment or decrement the vector constants. But first, check that no\n    // elements of the constant vector would overflow/underflow when we\n    // increment/decrement the constants.\n    //\n    // TODO? If the edge cases for vectors were guaranteed to be handled as they\n    // are for scalar, we could remove the min/max checks here. However, to do\n    // that, we would have to use insertelement/shufflevector to replace edge\n    // values.\n    \n    CmpInst::Predicate NewPred;\n    Constant *OneOrNegOne = nullptr;\n    switch (I.getPredicate()) {\n    case ICmpInst::ICMP_ULE:\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (cast<ConstantInt>(Op1C->getAggregateElement(i))->isMaxValue(false))\n          return nullptr;\n      NewPred = ICmpInst::ICMP_ULT;\n      OneOrNegOne = ConstantInt::get(Op1Type, 1);\n      break;\n    case ICmpInst::ICMP_SLE:\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (cast<ConstantInt>(Op1C->getAggregateElement(i))->isMaxValue(true))\n          return nullptr;\n      NewPred = ICmpInst::ICMP_SLT;\n      OneOrNegOne = ConstantInt::get(Op1Type, 1);\n      break;\n    case ICmpInst::ICMP_UGE:\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (cast<ConstantInt>(Op1C->getAggregateElement(i))->isMinValue(false))\n          return nullptr;\n      NewPred = ICmpInst::ICMP_UGT;\n      OneOrNegOne = ConstantInt::get(Op1Type, -1);\n      break;\n    case ICmpInst::ICMP_SGE:\n      for (unsigned i = 0; i != NumElts; ++i)\n        if (cast<ConstantInt>(Op1C->getAggregateElement(i))->isMinValue(true))\n          return nullptr;\n      NewPred = ICmpInst::ICMP_SGT;\n      OneOrNegOne = ConstantInt::get(Op1Type, -1);\n      break;\n    default:\n      return nullptr;\n    }\n\n    return new ICmpInst(NewPred, Op0, ConstantExpr::getAdd(Op1C, OneOrNegOne));\n  }\n\n  return nullptr;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  // ConstantVector. They both derive from Constant.\n  if (isa<ConstantDataVector>(Op1) || isa<ConstantVector>(Op1)) {\n    Constant *Op1C = cast<Constant>(Op1);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/icmp-vec.ll (1 of 1)\nTesting Time: 0.12s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/icmp-vec.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "0c8f3f9332929b12c0f81dcf07169c1869098c3b___InstCombineCompares.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic bool tryToUnrollLoop(Loop *L, DominatorTree &DT, LoopInfo *LI,\n                            ScalarEvolution *SE, const TargetTransformInfo &TTI,\n                            AssumptionCache &AC, bool PreserveLCSSA,\n                            Optional<unsigned> ProvidedCount,\n                            Optional<unsigned> ProvidedThreshold,\n                            Optional<bool> ProvidedAllowPartial,\n                            Optional<bool> ProvidedRuntime) {\n  DEBUG(dbgs() << \"Loop Unroll: F[\" << L->getHeader()->getParent()->getName()\n               << \"] Loop %\" << L->getHeader()->getName() << \"\\n\");\n  if (HasUnrollDisablePragma(L)) {\n    return false;\n  }\n\n  unsigned NumInlineCandidates;\n  bool NotDuplicatable;\n  bool Convergent;\n  unsigned LoopSize = ApproximateLoopSize(\n      L, NumInlineCandidates, NotDuplicatable, Convergent, TTI, &AC);\n  DEBUG(dbgs() << \"  Loop Size = \" << LoopSize << \"\\n\");\n  if (NotDuplicatable) {\n    DEBUG(dbgs() << \"  Not unrolling loop which contains non-duplicatable\"\n                 << \" instructions.\\n\");\n    return false;\n  }\n  if (NumInlineCandidates != 0) {\n    DEBUG(dbgs() << \"  Not unrolling loop with inlinable calls.\\n\");\n    return false;\n  }\n\n>>> [ INFILL ] <<<\n  // Find trip count and trip multiple if count is not available\n  unsigned TripCount = 0;\n  unsigned TripMultiple = 1;\n  // If there are multiple exiting blocks but one of them is the latch, use the\n  // latch for the trip count estimation. Otherwise insist on a single exiting\n  // block for the trip count estimation.\n  BasicBlock *ExitingBlock = L->getLoopLatch();\n  if (!ExitingBlock || !L->isLoopExiting(ExitingBlock))\n    ExitingBlock = L->getExitingBlock();\n  if (ExitingBlock) {\n    TripCount = SE->getSmallConstantTripCount(L, ExitingBlock);\n    TripMultiple = SE->getSmallConstantTripMultiple(L, ExitingBlock);\n  }\n\n  TargetTransformInfo::UnrollingPreferences UP = gatherUnrollingPreferences(\n      L, TTI, ProvidedThreshold, ProvidedCount, ProvidedAllowPartial,\n      ProvidedRuntime);\n\n  // If the loop contains a convergent operation, the prelude we'd add\n  // to do the first few instructions before we hit the unrolled loop\n  // is unsafe -- it adds a control-flow dependency to the convergent\n  // operation.  Therefore restrict remainder loop (try unrollig without).\n  //\n  // TODO: This is quite conservative.  In practice, convergent_op()\n  // is likely to be called unconditionally in the loop.  In this\n  // case, the program would be ill-formed (on most architectures)\n  // unless n were the same on all threads in a thread group.\n  // Assuming n is the same on all threads, any kind of unrolling is\n  // safe.  But currently llvm's notion of convergence isn't powerful\n  // enough to express this.\n  if (Convergent)\n    UP.AllowRemainder = false;\n\n  bool IsCountSetExplicitly = computeUnrollCount(L, TTI, DT, LI, SE, TripCount,\n                                                 TripMultiple, LoopSize, UP);\n  if (!UP.Count)\n    return false;\n  // Unroll factor (Count) must be less or equal to TripCount.\n  if (TripCount && UP.Count > TripCount)\n    UP.Count = TripCount;\n\n  // Unroll the loop.\n  if (!UnrollLoop(L, UP.Count, TripCount, UP.Force, UP.Runtime,\n                  UP.AllowExpensiveTripCount, TripMultiple, LI, SE, &DT, &AC,\n                  PreserveLCSSA))\n    return false;\n\n  // If loop has an unroll count pragma or unrolled by explicitly set count\n  // mark loop as unrolled to prevent unrolling beyond that requested.\n  if (IsCountSetExplicitly)\n    SetLoopAlreadyUnrolled(L);\n  return true;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/LoopUnroll/pr28132.ll (1 of 1)\nTesting Time: 0.49s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LoopUnroll/pr28132.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "4a697c312f901a3a1ec92e24c91cefd64f6b4346___LoopUnrollPass.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nvoid ExeDepsFix::processDefs(MachineInstr *MI, bool Kill) {\n  assert(!MI->isDebugValue() && \"Won't process debug values\");\n\n  // Break dependence on undef uses. Do this before updating LiveRegs below.\n  unsigned OpNum;\n  unsigned Pref = TII->getUndefRegClearance(*MI, OpNum, TRI);\n  if (Pref) {\n    if (shouldBreakDependence(MI, OpNum, Pref))\n      UndefReads.push_back(std::make_pair(MI, OpNum));\n  }\n  const MCInstrDesc &MCID = MI->getDesc();\n  for (unsigned i = 0,\n         e = MI->isVariadic() ? MI->getNumOperands() : MCID.getNumDefs();\n         i != e; ++i) {\n    MachineOperand &MO = MI->getOperand(i);\n    if (!MO.isReg())\n      continue;\n\n>>> [ INFILL ] <<<\n      continue;\n    for (int rx : regIndices(MO.getReg())) {\n      // This instruction explicitly defines rx.\n      DEBUG(dbgs() << TRI->getName(RC->getRegister(rx)) << \":\\t\" << CurInstr\n                   << '\\t' << *MI);\n\n      // Check clearance before partial register updates.\n      // Call breakDependence before setting LiveRegs[rx].Def.\n      unsigned Pref = TII->getPartialRegUpdateClearance(*MI, i, TRI);\n      if (Pref && shouldBreakDependence(MI, i, Pref))\n        TII->breakPartialRegDependency(*MI, i, TRI);\n\n      // How many instructions since rx was last written?\n      LiveRegs[rx].Def = CurInstr;\n\n      // Kill off domains redefined by generic instructions.\n      if (Kill)\n        kill(rx);\n    }\n  }\n  ++CurInstr;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    if (MO.isImplicit())\n      break;\n    if (MO.isUse())\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/break-false-dep.ll (1 of 1)\nTesting Time: 0.37s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/break-false-dep.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "c1fa163392f52d2119dec645f4f127ef79b83310___ExecutionDepsFix.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nvoid MIPrinter::print(const MachineBasicBlock &MBB) {\n  assert(MBB.getNumber() >= 0 && \"Invalid MBB number\");\n  OS << \"bb.\" << MBB.getNumber();\n  bool HasAttributes = false;\n  if (const auto *BB = MBB.getBasicBlock()) {\n    if (BB->hasName()) {\n      OS << \".\" << BB->getName();\n    } else {\n      HasAttributes = true;\n      OS << \" (\";\n      int Slot = MST.getLocalSlot(BB);\n      if (Slot == -1)\n        OS << \"<ir-block badref>\";\n      else\n        OS << (Twine(\"%ir-block.\") + Twine(Slot)).str();\n    }\n  }\n  if (MBB.hasAddressTaken()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"address-taken\";\n    HasAttributes = true;\n  }\n  if (MBB.isEHPad()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"landing-pad\";\n    HasAttributes = true;\n  }\n  if (MBB.getAlignment()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"align \" << MBB.getAlignment();\n    HasAttributes = true;\n  }\n  if (HasAttributes)\n    OS << \")\";\n  OS << \":\\n\";\n\n  bool HasLineAttributes = false;\n  // Print the successors\n  bool canPredictProbs = canPredictBranchProbabilities(MBB);\n\n>>> [ INFILL ] <<<\n    for (auto I = MBB.succ_begin(), E = MBB.succ_end(); I != E; ++I) {\n      if (I != MBB.succ_begin())\n        OS << \", \";\n      printMBBReference(**I);\n      if (!SimplifyMIR || !canPredictProbs)\n        OS << '('\n           << format(\"0x%08\" PRIx32, MBB.getSuccProbability(I).getNumerator())\n           << ')';\n    }\n    OS << \"\\n\";\n    HasLineAttributes = true;\n  }\n\n  // Print the live in registers.\n  const MachineRegisterInfo &MRI = MBB.getParent()->getRegInfo();\n  if (MRI.tracksLiveness() && !MBB.livein_empty()) {\n    const TargetRegisterInfo &TRI = *MRI.getTargetRegisterInfo();\n    OS.indent(2) << \"liveins: \";\n    bool First = true;\n    for (const auto &LI : MBB.liveins()) {\n      if (!First)\n        OS << \", \";\n      First = false;\n      printReg(LI.PhysReg, OS, &TRI);\n      if (!LI.LaneMask.all())\n        OS << \":0x\" << PrintLaneMask(LI.LaneMask);\n    }\n    OS << \"\\n\";\n    HasLineAttributes = true;\n  }\n\n  if (HasLineAttributes)\n    OS << \"\\n\";\n  bool IsInBundle = false;\n  for (auto I = MBB.instr_begin(), E = MBB.instr_end(); I != E; ++I) {\n    const MachineInstr &MI = *I;\n    if (IsInBundle && !MI.isInsideBundle()) {\n      OS.indent(2) << \"}\\n\";\n      IsInBundle = false;\n    }\n    OS.indent(IsInBundle ? 4 : 2);\n    print(MI);\n    if (!IsInBundle && MI.getFlag(MachineInstr::BundledSucc)) {\n      OS << \" {\";\n      IsInBundle = true;\n    }\n    OS << \"\\n\";\n  }\n  if (IsInBundle)\n    OS.indent(2) << \"}\\n\";\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  if (!MBB.succ_empty() && (!SimplifyMIR || !canPredictProbs ||\n                            !canPredictSuccessors(MBB))) {\n    OS.indent(2) << \"successors: \";\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/MIR/X86/unreachable_block.ll (1 of 1)\nTesting Time: 0.22s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/MIR/X86/unreachable_block.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "7fdaa5e64114bd5b614cff87bc350e4358b95200___MIRPrinter.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nInstruction *InstCombiner::transformZExtICmp(ICmpInst *ICI, ZExtInst &CI,\n                                             bool DoTransform) {\n  // If we are just checking for a icmp eq of a single bit and zext'ing it\n  // to an integer, then shift the bit to the appropriate place and then\n  // cast to integer to avoid the comparison.\n  const APInt *Op1CV;\n  if (match(ICI->getOperand(1), m_APInt(Op1CV))) {\n\n    // zext (x <s  0) to i32 --> x>>u31      true if signbit set.\n    // zext (x >s -1) to i32 --> (x>>u31)^1  true if signbit clear.\n    if ((ICI->getPredicate() == ICmpInst::ICMP_SLT && Op1CV->isNullValue()) ||\n        (ICI->getPredicate() == ICmpInst::ICMP_SGT && Op1CV->isAllOnesValue())) {\n      if (!DoTransform) return ICI;\n\n      Value *In = ICI->getOperand(0);\n      Value *Sh = ConstantInt::get(In->getType(),\n                                   In->getType()->getScalarSizeInBits() - 1);\n      In = Builder.CreateLShr(In, Sh, In->getName() + \".lobit\");\n      if (In->getType() != CI.getType())\n        In = Builder.CreateIntCast(In, CI.getType(), false /*ZExt*/);\n\n      if (ICI->getPredicate() == ICmpInst::ICMP_SGT) {\n        Constant *One = ConstantInt::get(In->getType(), 1);\n        In = Builder.CreateXor(In, One, In->getName() + \".not\");\n      }\n\n      return replaceInstUsesWith(CI, In);\n    }\n\n    // zext (X == 0) to i32 --> X^1      iff X has only the low bit set.\n    // zext (X == 0) to i32 --> (X>>1)^1 iff X has only the 2nd bit set.\n    // zext (X == 1) to i32 --> X        iff X has only the low bit set.\n    // zext (X == 2) to i32 --> X>>1     iff X has only the 2nd bit set.\n    // zext (X != 0) to i32 --> X        iff X has only the low bit set.\n    // zext (X != 0) to i32 --> X>>1     iff X has only the 2nd bit set.\n    // zext (X != 1) to i32 --> X^1      iff X has only the low bit set.\n    // zext (X != 2) to i32 --> (X>>1)^1 iff X has only the 2nd bit set.\n    if ((Op1CV->isNullValue() || Op1CV->isPowerOf2()) &&\n        // This only works for EQ and NE\n        ICI->isEquality()) {\n      // If Op1C some other power of two, convert:\n      KnownBits Known = computeKnownBits(ICI->getOperand(0), 0, &CI);\n\n      APInt KnownZeroMask(~Known.Zero);\n      if (KnownZeroMask.isPowerOf2()) { // Exactly 1 possible 1?\n        if (!DoTransform) return ICI;\n\n        bool isNE = ICI->getPredicate() == ICmpInst::ICMP_NE;\n        if (!Op1CV->isNullValue() && (*Op1CV != KnownZeroMask)) {\n          // (X&4) == 2 --> false\n          // (X&4) != 2 --> true\n\n>>> [ INFILL ] <<<\n        }\n\n        uint32_t ShAmt = KnownZeroMask.logBase2();\n        Value *In = ICI->getOperand(0);\n        if (ShAmt) {\n          // Perform a logical shr by shiftamt.\n          // Insert the shift to put the result in the low bit.\n          In = Builder.CreateLShr(In, ConstantInt::get(In->getType(), ShAmt),\n                                  In->getName() + \".lobit\");\n        }\n\n        if (!Op1CV->isNullValue() == isNE) { // Toggle the low bit.\n          Constant *One = ConstantInt::get(In->getType(), 1);\n          In = Builder.CreateXor(In, One);\n        }\n\n        if (CI.getType() == In->getType())\n          return replaceInstUsesWith(CI, In);\n\n        Value *IntCast = Builder.CreateIntCast(In, CI.getType(), false);\n        return replaceInstUsesWith(CI, IntCast);\n      }\n    }\n  }\n\n  // icmp ne A, B is equal to xor A, B when A and B only really have one bit.\n  // It is also profitable to transform icmp eq into not(xor(A, B)) because that\n  // may lead to additional simplifications.\n  if (ICI->isEquality() && CI.getType() == ICI->getOperand(0)->getType()) {\n    if (IntegerType *ITy = dyn_cast<IntegerType>(CI.getType())) {\n      Value *LHS = ICI->getOperand(0);\n      Value *RHS = ICI->getOperand(1);\n\n      KnownBits KnownLHS = computeKnownBits(LHS, 0, &CI);\n      KnownBits KnownRHS = computeKnownBits(RHS, 0, &CI);\n\n      if (KnownLHS.Zero == KnownRHS.Zero && KnownLHS.One == KnownRHS.One) {\n        APInt KnownBits = KnownLHS.Zero | KnownLHS.One;\n        APInt UnknownBit = ~KnownBits;\n        if (UnknownBit.countPopulation() == 1) {\n          if (!DoTransform) return ICI;\n\n          Value *Result = Builder.CreateXor(LHS, RHS);\n\n          // Mask off any bits that are set and won't be shifted away.\n          if (KnownLHS.One.uge(UnknownBit))\n            Result = Builder.CreateAnd(Result,\n                                        ConstantInt::get(ITy, UnknownBit));\n\n          // Shift the bit we're testing down to the lsb.\n          Result = Builder.CreateLShr(\n               Result, ConstantInt::get(ITy, UnknownBit.countTrailingZeros()));\n\n          if (ICI->getPredicate() == ICmpInst::ICMP_EQ)\n            Result = Builder.CreateXor(Result, ConstantInt::get(ITy, 1));\n          Result->takeName(ICI);\n          return replaceInstUsesWith(CI, Result);\n        }\n      }\n    }\n  }\n\n  return nullptr;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n          Constant *Res = ConstantInt::get(Type::getInt1Ty(CI.getContext()),\n                                           isNE);\n          Res = ConstantExpr::getZExt(Res, CI.getType());\n          return replaceInstUsesWith(CI, Res);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/div.ll (1 of 1)\nTesting Time: 0.61s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/div.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "17b0c78447e094e8465abc5dfb3a491f02521647___InstCombineCasts.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nbool SROA::splitAlloca(AllocaInst &AI, AllocaSlices &AS) {\n  if (AS.begin() == AS.end())\n    return false;\n\n  unsigned NumPartitions = 0;\n  bool Changed = false;\n  const DataLayout &DL = AI.getModule()->getDataLayout();\n\n  // First try to pre-split loads and stores.\n  Changed |= presplitLoadsAndStores(AI, AS);\n\n  // Now that we have identified any pre-splitting opportunities, mark any\n  // splittable (non-whole-alloca) loads and stores as unsplittable. If we fail\n  // to split these during pre-splitting, we want to force them to be\n  // rewritten into a partition.\n  bool IsSorted = true;\n  for (Slice &S : AS) {\n    if (!S.isSplittable())\n      continue;\n    // FIXME: We currently leave whole-alloca splittable loads and stores. This\n    // used to be the only splittable loads and stores and we need to be\n    // confident that the above handling of splittable loads and stores is\n    // completely sufficient before we forcibly disable the remaining handling.\n    if (S.beginOffset() == 0 &&\n        S.endOffset() >= DL.getTypeAllocSize(AI.getAllocatedType()))\n      continue;\n    if (isa<LoadInst>(S.getUse()->getUser()) ||\n        isa<StoreInst>(S.getUse()->getUser())) {\n      S.makeUnsplittable();\n      IsSorted = false;\n    }\n  }\n  if (!IsSorted)\n    std::sort(AS.begin(), AS.end());\n\n  /// Describes the allocas introduced by rewritePartition in order to migrate\n  /// the debug info.\n  struct Fragment {\n    AllocaInst *Alloca;\n    uint64_t Offset;\n    uint64_t Size;\n    Fragment(AllocaInst *AI, uint64_t O, uint64_t S)\n      : Alloca(AI), Offset(O), Size(S) {}\n  };\n  SmallVector<Fragment, 4> Fragments;\n\n  // Rewrite each partition.\n  for (auto &P : AS.partitions()) {\n    if (AllocaInst *NewAI = rewritePartition(AI, AS, P)) {\n      Changed = true;\n      if (NewAI != &AI) {\n        uint64_t SizeOfByte = 8;\n        uint64_t AllocaSize = DL.getTypeSizeInBits(NewAI->getAllocatedType());\n        // Don't include any padding.\n        uint64_t Size = std::min(AllocaSize, P.size() * SizeOfByte);\n        Fragments.push_back(Fragment(NewAI, P.beginOffset() * SizeOfByte, Size));\n      }\n    }\n    ++NumPartitions;\n  }\n\n  NumAllocaPartitions += NumPartitions;\n  MaxPartitionsPerAlloca.updateMax(NumPartitions);\n\n  // Migrate debug information from the old alloca to the new alloca(s)\n  // and the individual partitions.\n  TinyPtrVector<DbgInfoIntrinsic *> DbgDeclares = FindDbgAddrUses(&AI);\n  if (!DbgDeclares.empty()) {\n    auto *Var = DbgDeclares.front()->getVariable();\n    auto *Expr = DbgDeclares.front()->getExpression();\n    auto VarSize = Var->getSizeInBits();\n    DIBuilder DIB(*AI.getModule(), /*AllowUnresolved*/ false);\n    uint64_t AllocaSize = DL.getTypeSizeInBits(AI.getAllocatedType());\n    for (auto Fragment : Fragments) {\n      // Create a fragment expression describing the new partition or reuse AI's\n      // expression if there is only one partition.\n      auto *FragmentExpr = Expr;\n      if (Fragment.Size < AllocaSize || Expr->isFragment()) {\n        // If this alloca is already a scalar replacement of a larger aggregate,\n        // Fragment.Offset describes the offset inside the scalar.\n        auto ExprFragment = Expr->getFragmentInfo();\n        uint64_t Offset = ExprFragment ? ExprFragment->OffsetInBits : 0;\n        uint64_t Start = Offset + Fragment.Offset;\n        uint64_t Size = Fragment.Size;\n        if (ExprFragment) {\n          uint64_t AbsEnd =\n              ExprFragment->OffsetInBits + ExprFragment->SizeInBits;\n          if (Start >= AbsEnd)\n            // No need to describe a SROAed padding.\n            continue;\n          Size = std::min(Size, AbsEnd - Start);\n        }\n        // The new, smaller fragment is stenciled out from the old fragment.\n        if (auto OrigFragment = FragmentExpr->getFragmentInfo()) {\n          assert(Start >= OrigFragment->OffsetInBits &&\n                 \"new fragment is outside of original fragment\");\n          Start -= OrigFragment->OffsetInBits;\n        }\n\n>>> [ INFILL ] <<<\n        if (!VarSize || *VarSize != Size) {\n          if (auto E =\n                  DIExpression::createFragmentExpression(Expr, Start, Size))\n            FragmentExpr = *E;\n          else\n            continue;\n        }\n      }\n\n      // Remove any existing intrinsics describing the same alloca.\n      for (DbgInfoIntrinsic *OldDII : FindDbgAddrUses(Fragment.Alloca))\n        OldDII->eraseFromParent();\n\n      DIB.insertDeclare(Fragment.Alloca, Var, FragmentExpr,\n                        DbgDeclares.front()->getDebugLoc(), &AI);\n    }\n  }\n  return Changed;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n        // Avoid creating a fragment expression that covers the entire variable.\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/Generic/sroa-larger.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/Generic/sroa-larger.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "77d90b0c39f079b8871c39772a5bad8b8bfac322___SROA.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nvoid X86FrameLowering::determineCalleeSaves(MachineFunction &MF,\n                                            BitVector &SavedRegs,\n                                            RegScavenger *RS) const {\n  TargetFrameLowering::determineCalleeSaves(MF, SavedRegs, RS);\n\n  // Spill the BasePtr if it's used.\n\n>>> [ INFILL ] <<<\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  if (TRI->hasBasePointer(MF))\n    SavedRegs.set(TRI->getBaseRegister());\n}\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/x86-64-baseptr.ll (1 of 1)\nTesting Time: 0.22s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/x86-64-baseptr.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "57feeed3076137da48c43010130eddbb8e81cb54___X86FrameLowering.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nbool llvm::isGuaranteedToExecute(const Instruction &Inst,\n                                 const DominatorTree *DT, const Loop *CurLoop,\n                                 const LoopSafetyInfo *SafetyInfo) {\n  // We have to check to make sure that the instruction dominates all\n  // of the exit blocks.  If it doesn't, then there is a path out of the loop\n  // which does not execute this instruction, so we can't hoist it.\n\n  // If the instruction is in the header block for the loop (which is very\n  // common), it is always guaranteed to dominate the exit blocks.  Since this\n  // is a common case, and can save some work, check it now.\n  if (Inst.getParent() == CurLoop->getHeader())\n    // If there's a throw in the header block, we can't guarantee we'll reach\n\n>>> [ INFILL ] <<<\n  // Somewhere in this loop there is an instruction which may throw and make us\n  // exit the loop.\n  if (SafetyInfo->MayThrow)\n    return false;\n\n  // Note: There are two styles of reasoning intermixed below for\n  // implementation efficiency reasons.  They are:\n  // 1) If we can prove that the instruction dominates all exit blocks, then we\n  // know the instruction must have executed on *some* iteration before we\n  // exit.  We do not prove *which* iteration the instruction must execute on.\n  // 2) If we can prove that the instruction dominates the latch and all exits\n  // which might be taken on the first iteration, we know the instruction must\n  // execute on the first iteration.  This second style allows a conditional\n  // exit before the instruction of interest which is provably not taken on the\n  // first iteration.  This is a quite common case for range check like\n  // patterns.  TODO: support loops with multiple latches.\n\n  const bool InstDominatesLatch =\n    CurLoop->getLoopLatch() != nullptr &&\n    DT->dominates(Inst.getParent(), CurLoop->getLoopLatch());\n\n  // Get the exit blocks for the current loop.\n  SmallVector<BasicBlock *, 8> ExitBlocks;\n  CurLoop->getExitBlocks(ExitBlocks);\n\n  // Verify that the block dominates each of the exit blocks of the loop.\n  for (BasicBlock *ExitBlock : ExitBlocks)\n    if (!DT->dominates(Inst.getParent(), ExitBlock))\n      if (!InstDominatesLatch ||\n          !CanProveNotTakenFirstIteration(ExitBlock, DT, CurLoop))\n        return false;\n\n  // As a degenerate case, if the loop is statically infinite then we haven't\n  // proven anything since there are no exit blocks.\n  if (ExitBlocks.empty())\n    return false;\n\n  // FIXME: In general, we have to prove that the loop isn't an infinite loop.\n  // See http::llvm.org/PR24078 .  (The \"ExitBlocks.empty()\" check above is\n  // just a special case of this.)\n  return true;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    // Inst.\n    return !SafetyInfo->HeaderMayThrow;\n\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/LICM/preheader-safe.ll (1 of 1)\nTesting Time: 0.31s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LICM/preheader-safe.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "e4ec473b3ff94ecec6fe2c828770a124b139e1a5___MustExecute.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nvoid DwarfCompileUnit::finishEntityDefinition(const DbgEntity *Entity) {\n  DbgEntity *AbsEntity = getExistingAbstractEntity(Entity->getEntity());\n\n  auto *Die = Entity->getDIE();\n  /// Label may be used to generate DW_AT_low_pc, so put it outside\n  /// if/else block.\n  const DbgLabel *Label = nullptr;\n  if (AbsEntity && AbsEntity->getDIE()) {\n    addDIEEntry(*Die, dwarf::DW_AT_abstract_origin, *AbsEntity->getDIE());\n    Label = dyn_cast<const DbgLabel>(Entity);\n  } else {\n    if (const DbgVariable *Var = dyn_cast<const DbgVariable>(Entity))\n      applyVariableAttributes(*Var, *Die);\n    else if ((Label = dyn_cast<const DbgLabel>(Entity)))\n      applyLabelAttributes(*Label, *Die);\n    else\n      llvm_unreachable(\"DbgEntity must be DbgVariable or DbgLabel.\");\n  }\n\n\n>>> [ INFILL ] <<<\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  if (Label) {\n    const MCSymbol *Sym = Label->getSymbol();\n    addLabelAddress(*Die, dwarf::DW_AT_low_pc, Sym);\n  }\n}\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/X86/debug-label-unreached.ll (1 of 1)\nTesting Time: 0.52s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/debug-label-unreached.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "55321d82bd329bb88799e5a853a256b4a70e4106___DwarfCompileUnit.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic Value *evaluateGEPOffsetExpression(User *GEP, InstCombiner &IC,\n                                          const DataLayout &DL) {\n  gep_type_iterator GTI = gep_type_begin(GEP);\n\n  // Check to see if this gep only has a single variable index.  If so, and if\n  // any constant indices are a multiple of its scale, then we can compute this\n  // in terms of the scale of the variable index.  For example, if the GEP\n  // implies an offset of \"12 + i*4\", then we can codegen this as \"3 + i\",\n  // because the expression will cross zero at the same point.\n  unsigned i, e = GEP->getNumOperands();\n  int64_t Offset = 0;\n  for (i = 1; i != e; ++i, ++GTI) {\n    if (ConstantInt *CI = dyn_cast<ConstantInt>(GEP->getOperand(i))) {\n      // Compute the aggregate offset of constant indices.\n      if (CI->isZero()) continue;\n\n      // Handle a struct index, which adds its field offset to the pointer.\n      if (StructType *STy = GTI.getStructTypeOrNull()) {\n        Offset += DL.getStructLayout(STy)->getElementOffset(CI->getZExtValue());\n      } else {\n        uint64_t Size = DL.getTypeAllocSize(GTI.getIndexedType());\n        Offset += Size*CI->getSExtValue();\n      }\n    } else {\n      // Found our variable index.\n      break;\n    }\n  }\n\n  // If there are no variable indices, we must have a constant offset, just\n  // evaluate it the general way.\n  if (i == e) return nullptr;\n\n  Value *VariableIdx = GEP->getOperand(i);\n  // Determine the scale factor of the variable element.  For example, this is\n  // 4 if the variable index is into an array of i32.\n  uint64_t VariableScale = DL.getTypeAllocSize(GTI.getIndexedType());\n\n  // Verify that there are no other variable indices.  If so, emit the hard way.\n  for (++i, ++GTI; i != e; ++i, ++GTI) {\n    ConstantInt *CI = dyn_cast<ConstantInt>(GEP->getOperand(i));\n    if (!CI) return nullptr;\n\n    // Compute the aggregate offset of constant indices.\n    if (CI->isZero()) continue;\n\n    // Handle a struct index, which adds its field offset to the pointer.\n    if (StructType *STy = GTI.getStructTypeOrNull()) {\n      Offset += DL.getStructLayout(STy)->getElementOffset(CI->getZExtValue());\n    } else {\n      uint64_t Size = DL.getTypeAllocSize(GTI.getIndexedType());\n      Offset += Size*CI->getSExtValue();\n    }\n  }\n\n  // Okay, we know we have a single variable index, which must be a\n  // pointer/array/vector index.  If there is no offset, life is simple, return\n  // the index.\n  Type *IntPtrTy = DL.getIntPtrType(GEP->getOperand(0)->getType());\n  unsigned IntPtrWidth = IntPtrTy->getIntegerBitWidth();\n  if (Offset == 0) {\n    // Cast to intptrty in case a truncation occurs.  If an extension is needed,\n    // we don't need to bother extending: the extension won't affect where the\n    // computation crosses zero.\n    if (VariableIdx->getType()->getPrimitiveSizeInBits() > IntPtrWidth) {\n      VariableIdx = IC.Builder.CreateTrunc(VariableIdx, IntPtrTy);\n    }\n    return VariableIdx;\n  }\n\n  // Otherwise, there is an index.  The computation we will do will be modulo\n\n>>> [ INFILL ] <<<\n  // To do this transformation, any constant index must be a multiple of the\n  // variable scale factor.  For example, we can evaluate \"12 + 4*i\" as \"3 + i\",\n  // but we can't evaluate \"10 + 3*i\" in terms of i.  Check that the offset is a\n  // multiple of the variable scale.\n  int64_t NewOffs = Offset / (int64_t)VariableScale;\n  if (Offset != NewOffs*(int64_t)VariableScale)\n    return nullptr;\n\n  // Okay, we can do this evaluation.  Start by converting the index to intptr.\n  if (VariableIdx->getType() != IntPtrTy)\n    VariableIdx = IC.Builder.CreateIntCast(VariableIdx, IntPtrTy,\n                                            true /*Signed*/);\n  Constant *OffsetVal = ConstantInt::get(IntPtrTy, NewOffs);\n  return IC.Builder.CreateAdd(VariableIdx, OffsetVal, \"offset\");\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  // the pointer size, so get it.\n  uint64_t PtrSizeMask = ~0ULL >> (64-IntPtrWidth);\n\n  Offset &= PtrSizeMask;\n  VariableScale &= PtrSizeMask;\n\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/pr39908.ll (1 of 1)\nTesting Time: 0.22s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/pr39908.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "36e03ac6ee91366225f446db6437f184de258be6___InstCombineCompares.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic SDValue LowerFunnelShift(SDValue Op, const X86Subtarget &Subtarget,\n                                SelectionDAG &DAG) {\n  MVT VT = Op.getSimpleValueType();\n  assert((Op.getOpcode() == ISD::FSHL || Op.getOpcode() == ISD::FSHR) &&\n         \"Unexpected funnel shift opcode!\");\n  assert((VT == MVT::i16 || VT == MVT::i32 || VT == MVT::i64) &&\n         \"Unexpected funnel shift type!\");\n\n  SDLoc DL(Op);\n  SDValue Op0 = Op.getOperand(0);\n  SDValue Op1 = Op.getOperand(1);\n  SDValue Amt = Op.getOperand(2);\n\n\n>>> [ INFILL ] <<<\n\n  bool IsFSHR = Op.getOpcode() == ISD::FSHR;\n  if (IsFSHR)\n    std::swap(Op0, Op1);\n\n  // i16 needs to modulo the shift amount, but i32/i64 have implicit modulo.\n  if (VT == MVT::i16)\n    Amt = DAG.getNode(ISD::AND, DL, Amt.getValueType(), Amt,\n                      DAG.getConstant(15, DL, Amt.getValueType()));\n\n  unsigned SHDOp = (IsFSHR ? X86ISD::SHRD : X86ISD::SHLD);\n  return DAG.getNode(SHDOp, DL, VT, Op0, Op1, Amt);\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  // Expand slow SHLD/SHRD cases.\n  // TODO - can we be more selective here: OptSize/RMW etc.?\n  if (Subtarget.isSHLDSlow())\n    return SDValue();\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/fshl.ll (1 of 1)\nTesting Time: 0.32s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/fshl.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/fshr.ll (1 of 1)\nTesting Time: 0.32s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/fshr.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ef7b5949e5c35fdeefb69b8f9a8eef9cfa012ed0___X86ISelLowering.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nbool AtomicExpand::expandAtomicLoadToCmpXchg(LoadInst *LI) {\n  IRBuilder<> Builder(LI);\n  AtomicOrdering Order = LI->getOrdering();\n\n>>> [ INFILL ] <<<\n  Type *Ty = cast<PointerType>(Addr->getType())->getElementType();\n  Constant *DummyVal = Constant::getNullValue(Ty);\n\n  Value *Pair = Builder.CreateAtomicCmpXchg(\n      Addr, DummyVal, DummyVal, Order,\n      AtomicCmpXchgInst::getStrongestFailureOrdering(Order));\n  Value *Loaded = Builder.CreateExtractValue(Pair, 0, \"loaded\");\n\n  LI->replaceAllUsesWith(Loaded);\n  LI->eraseFromParent();\n\n  return true;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  Value *Addr = LI->getPointerOperand();\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/atomic-unordered.ll (1 of 1)\nTesting Time: 1.73s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/atomic-unordered.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "2153c4b8281c1e5f25887ef9183947198c50a9d2___AtomicExpandPass.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nbool ShrinkWrap::useOrDefCSROrFI(const MachineInstr &MI,\n                                 RegScavenger *RS) const {\n\n>>> [ INFILL ] <<<\n      MI.getOpcode() == FrameDestroyOpcode) {\n    LLVM_DEBUG(dbgs() << \"Frame instruction: \" << MI << '\\n');\n    return true;\n  }\n  for (const MachineOperand &MO : MI.operands()) {\n    bool UseOrDefCSR = false;\n    if (MO.isReg()) {\n      // Ignore instructions like DBG_VALUE which don't read/def the register.\n      if (!MO.isDef() && !MO.readsReg())\n        continue;\n      unsigned PhysReg = MO.getReg();\n      if (!PhysReg)\n        continue;\n      assert(TargetRegisterInfo::isPhysicalRegister(PhysReg) &&\n             \"Unallocated register?!\");\n      // The stack pointer is not normally described as a callee-saved register\n      // in calling convention definitions, so we need to watch for it\n      // separately. An SP mentioned by a call instruction, we can ignore,\n      // though, as it's harmless and we do not want to effectively disable tail\n      // calls by forcing the restore point to post-dominate them.\n      UseOrDefCSR = (!MI.isCall() && PhysReg == SP) ||\n                    RCI.getLastCalleeSavedAlias(PhysReg);\n    } else if (MO.isRegMask()) {\n      // Check if this regmask clobbers any of the CSRs.\n      for (unsigned Reg : getCurrentCSRs(RS)) {\n        if (MO.clobbersPhysReg(Reg)) {\n          UseOrDefCSR = true;\n          break;\n        }\n      }\n    }\n    // Skip FrameIndex operands in DBG_VALUE instructions.\n    if (UseOrDefCSR || (MO.isFI() && !MI.isDebugValue())) {\n      LLVM_DEBUG(dbgs() << \"Use or define CSR(\" << UseOrDefCSR << \") or FI(\"\n                        << MO.isFI() << \"): \" << MI << '\\n');\n      return true;\n    }\n  }\n  return false;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  if (MI.getOpcode() == FrameSetupOpcode ||\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/2010-08-04-MaskedSignedCompare.ll (1 of 1)\nTesting Time: 0.22s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/2010-08-04-MaskedSignedCompare.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/MachineSink-eflags.ll (1 of 1)\nTesting Time: 0.09s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/MachineSink-eflags.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/cmov.ll (1 of 1)\nTesting Time: 0.19s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/cmov.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/copy-eflags.ll (1 of 1)\nTesting Time: 0.24s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/copy-eflags.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/fold-pcmpeqd-2.ll (1 of 1)\nTesting Time: 0.10s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/fold-pcmpeqd-2.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/i386-shrink-wrapping.ll (1 of 1)\nTesting Time: 0.09s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/i386-shrink-wrapping.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/shrink-wrap-chkstk-x86_64.ll (1 of 1)\nTesting Time: 0.09s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/shrink-wrap-chkstk-x86_64.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/x86-shrink-wrapping.ll (1 of 1)\nTesting Time: 0.30s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/x86-shrink-wrapping.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/xchg-nofold.ll (1 of 1)\nTesting Time: 0.09s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/xchg-nofold.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "0be2d25ecc7d9b71e03b07529eb1581efa92674a___ShrinkWrap.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic char isNegatibleForFree(SDValue Op, bool LegalOperations,\n                               const TargetLowering &TLI,\n                               const TargetOptions *Options,\n                               bool ForCodeSize,\n                               unsigned Depth = 0) {\n  // fneg is removable even if it has multiple uses.\n  if (Op.getOpcode() == ISD::FNEG)\n    return 2;\n\n  // Don't allow anything with multiple uses unless we know it is free.\n  EVT VT = Op.getValueType();\n  const SDNodeFlags Flags = Op->getFlags();\n  if (!Op.hasOneUse() &&\n      !(Op.getOpcode() == ISD::FP_EXTEND &&\n        TLI.isFPExtFree(VT, Op.getOperand(0).getValueType())))\n    return 0;\n\n  // Don't recurse exponentially.\n  if (Depth > 6)\n    return 0;\n\n  switch (Op.getOpcode()) {\n  default: return false;\n  case ISD::ConstantFP: {\n    if (!LegalOperations)\n      return 1;\n\n    // Don't invert constant FP values after legalization unless the target says\n    // the negated constant is legal.\n    return TLI.isOperationLegal(ISD::ConstantFP, VT) ||\n           TLI.isFPImmLegal(neg(cast<ConstantFPSDNode>(Op)->getValueAPF()), VT,\n                            ForCodeSize);\n  }\n  case ISD::BUILD_VECTOR: {\n    // Only permit BUILD_VECTOR of constants.\n    if (llvm::any_of(Op->op_values(), [&](SDValue N) {\n          return !N.isUndef() && !isa<ConstantFPSDNode>(N);\n        }))\n      return 0;\n    if (!LegalOperations)\n      return 1;\n    if (TLI.isOperationLegal(ISD::ConstantFP, VT) &&\n        TLI.isOperationLegal(ISD::BUILD_VECTOR, VT))\n      return 1;\n    return llvm::all_of(Op->op_values(), [&](SDValue N) {\n      return N.isUndef() ||\n             TLI.isFPImmLegal(neg(cast<ConstantFPSDNode>(N)->getValueAPF()), VT,\n                              ForCodeSize);\n    });\n  }\n  case ISD::FADD:\n    if (!Options->NoSignedZerosFPMath && !Flags.hasNoSignedZeros())\n      return 0;\n\n    // After operation legalization, it might not be legal to create new FSUBs.\n    if (LegalOperations && !TLI.isOperationLegalOrCustom(ISD::FSUB, VT))\n      return 0;\n\n    // fold (fneg (fadd A, B)) -> (fsub (fneg A), B)\n    if (char V = isNegatibleForFree(Op.getOperand(0), LegalOperations, TLI,\n                                    Options, ForCodeSize, Depth + 1))\n      return V;\n    // fold (fneg (fadd A, B)) -> (fsub (fneg B), A)\n    return isNegatibleForFree(Op.getOperand(1), LegalOperations, TLI, Options,\n                              ForCodeSize, Depth + 1);\n  case ISD::FSUB:\n    // We can't turn -(A-B) into B-A when we honor signed zeros.\n    if (!Options->NoSignedZerosFPMath && !Flags.hasNoSignedZeros())\n      return 0;\n\n    // fold (fneg (fsub A, B)) -> (fsub B, A)\n    return 1;\n\n  case ISD::FMUL:\n  case ISD::FDIV:\n    // fold (fneg (fmul X, Y)) -> (fmul (fneg X), Y) or (fmul X, (fneg Y))\n    if (char V = isNegatibleForFree(Op.getOperand(0), LegalOperations, TLI,\n                                    Options, ForCodeSize, Depth + 1))\n      return V;\n\n\n>>> [ INFILL ] <<<\n                              ForCodeSize, Depth + 1);\n\n  case ISD::FP_EXTEND:\n  case ISD::FP_ROUND:\n  case ISD::FSIN:\n    return isNegatibleForFree(Op.getOperand(0), LegalOperations, TLI, Options,\n                              ForCodeSize, Depth + 1);\n  }\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    return isNegatibleForFree(Op.getOperand(1), LegalOperations, TLI, Options,\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/fadd-combines.ll (1 of 1)\nTesting Time: 0.27s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/fadd-combines.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "26b2c114515a8d011a952fe414ac92417298ea00___DAGCombiner.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nbool CallAnalyzer::visitSwitchInst(SwitchInst &SI) {\n  // We model unconditional switches as free, see the comments on handling\n  // branches.\n  if (isa<ConstantInt>(SI.getCondition()))\n    return true;\n  if (Value *V = SimplifiedValues.lookup(SI.getCondition()))\n    if (isa<ConstantInt>(V))\n      return true;\n\n  // Assume the most general case where the switch is lowered into\n  // either a jump table, bit test, or a balanced binary tree consisting of\n  // case clusters without merging adjacent clusters with the same\n  // destination. We do not consider the switches that are lowered with a mix\n  // of jump table/bit test/binary search tree. The cost of the switch is\n  // proportional to the size of the tree or the size of jump table range.\n  //\n  // NB: We convert large switches which are just used to initialize large phi\n  // nodes to lookup tables instead in simplify-cfg, so this shouldn't prevent\n  // inlining those. It will prevent inlining in cases where the optimization\n  // does not (yet) fire.\n\n  // Maximum valid cost increased in this function.\n  int CostUpperBound = INT_MAX - InlineConstants::InstrCost - 1;\n\n\n>>> [ INFILL ] <<<\n  unsigned NumCaseCluster =\n      TTI.getEstimatedNumberOfCaseClusters(SI, JumpTableSize);\n\n  // If suitable for a jump table, consider the cost for the table size and\n  // branch to destination.\n  if (JumpTableSize) {\n    int64_t JTCost = (int64_t)JumpTableSize * InlineConstants::InstrCost +\n                     4 * InlineConstants::InstrCost;\n\n    addCost(JTCost, (int64_t)CostUpperBound);\n    return false;\n  }\n\n  // Considering forming a binary search, we should find the number of nodes\n  // which is same as the number of comparisons when lowered. For a given\n  // number of clusters, n, we can define a recursive function, f(n), to find\n  // the number of nodes in the tree. The recursion is :\n  // f(n) = 1 + f(n/2) + f (n - n/2), when n > 3,\n  // and f(n) = n, when n <= 3.\n  // This will lead a binary tree where the leaf should be either f(2) or f(3)\n  // when n > 3.  So, the number of comparisons from leaves should be n, while\n  // the number of non-leaf should be :\n  //   2^(log2(n) - 1) - 1\n  //   = 2^log2(n) * 2^-1 - 1\n  //   = n / 2 - 1.\n  // Considering comparisons from leaf and non-leaf nodes, we can estimate the\n  // number of comparisons in a simple closed form :\n  //   n + n / 2 - 1 = n * 3 / 2 - 1\n  if (NumCaseCluster <= 3) {\n    // Suppose a comparison includes one compare and one conditional branch.\n    addCost(NumCaseCluster * 2 * InlineConstants::InstrCost);\n    return false;\n  }\n\n  int64_t ExpectedNumberOfCompare = 3 * (int64_t)NumCaseCluster / 2 - 1;\n  int64_t SwitchCost =\n      ExpectedNumberOfCompare * 2 * InlineConstants::InstrCost;\n\n  addCost(SwitchCost, (int64_t)CostUpperBound);\n  return false;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  // Exit early for a large switch, assuming one case needs at least one\n  // instruction.\n  // FIXME: This is not true for a bit test, but ignore such case for now to\n  // save compile-time.\n  int64_t CostLowerBound =\n      std::min((int64_t)CostUpperBound,\n               (int64_t)SI.getNumCases() * InlineConstants::InstrCost + Cost);\n\n  if (CostLowerBound > Threshold && !ComputeFullInlineCost) {\n    addCost((int64_t)SI.getNumCases() * InlineConstants::InstrCost);\n    return false;\n  }\n\n  unsigned JumpTableSize = 0;\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/Inline/X86/switch.ll (1 of 1)\nTesting Time: 0.33s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/Inline/X86/switch.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "2f32e5d84d3483a0d6170fc61d2cceb49fc930a3___InlineCost.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic bool optimizeDivRem(Function &F, const TargetTransformInfo &TTI,\n                           const DominatorTree &DT) {\n  bool Changed = false;\n\n  // Get the matching pairs of div-rem instructions. We want this extra\n  // indirection to avoid dealing with having to RAUW the keys of the maps.\n  DivRemWorklistTy Worklist = getWorklist(F);\n\n  // Process each entry in the worklist.\n  for (DivRemPairWorklistEntry &E : Worklist) {\n    if (!DebugCounter::shouldExecute(DRPCounter))\n      continue;\n\n    bool HasDivRemOp = TTI.hasDivRemOp(E.getType(), E.isSigned());\n\n    auto &DivInst = E.DivInst;\n    auto &RemInst = E.RemInst;\n\n    const bool RemOriginallyWasInExpandedForm = E.isRemExpanded();\n    (void)RemOriginallyWasInExpandedForm; // suppress unused variable warning\n\n    if (HasDivRemOp && E.isRemExpanded()) {\n      // The target supports div+rem but the rem is expanded.\n      // We should recompose it first.\n      Value *X = E.getDividend();\n      Value *Y = E.getDivisor();\n      Instruction *RealRem = E.isSigned() ? BinaryOperator::CreateSRem(X, Y)\n                                          : BinaryOperator::CreateURem(X, Y);\n      // Note that we place it right next to the original expanded instruction,\n      // and letting further handling to move it if needed.\n      RealRem->setName(RemInst->getName() + \".recomposed\");\n      RealRem->insertAfter(RemInst);\n      Instruction *OrigRemInst = RemInst;\n      // Update AssertingVH<> with new instruction so it doesn't assert.\n      RemInst = RealRem;\n      // And replace the original instruction with the new one.\n      OrigRemInst->replaceAllUsesWith(RealRem);\n      OrigRemInst->eraseFromParent();\n      NumRecomposed++;\n      // Note that we have left ((X / Y) * Y) around.\n      // If it had other uses we could rewrite it as X - X % Y\n    }\n\n    assert((!E.isRemExpanded() || !HasDivRemOp) &&\n           \"*If* the target supports div-rem, then by now the RemInst *is* \"\n           \"Instruction::[US]Rem.\");\n\n    // If the target supports div+rem and the instructions are in the same block\n    // already, there's nothing to do. The backend should handle this. If the\n    // target does not support div+rem, then we will decompose the rem.\n    if (HasDivRemOp && RemInst->getParent() == DivInst->getParent())\n      continue;\n\n    bool DivDominates = DT.dominates(DivInst, RemInst);\n    if (!DivDominates && !DT.dominates(RemInst, DivInst)) {\n      // We have matching div-rem pair, but they are in two different blocks,\n      // neither of which dominates one another.\n\n>>> [ INFILL ] <<<\n      continue;\n    }\n\n    // The target does not have a single div/rem operation,\n    // and the rem is already in expanded form. Nothing to do.\n    if (!HasDivRemOp && E.isRemExpanded())\n      continue;\n\n    if (HasDivRemOp) {\n      // The target has a single div/rem operation. Hoist the lower instruction\n      // to make the matched pair visible to the backend.\n      if (DivDominates)\n        RemInst->moveAfter(DivInst);\n      else\n        DivInst->moveAfter(RemInst);\n      NumHoisted++;\n    } else {\n      // The target does not have a single div/rem operation,\n      // and the rem is *not* in a already-expanded form.\n      // Decompose the remainder calculation as:\n      // X % Y --> X - ((X / Y) * Y).\n\n      assert(!RemOriginallyWasInExpandedForm &&\n             \"We should not be expanding if the rem was in expanded form to \"\n             \"begin with.\");\n\n      Value *X = E.getDividend();\n      Value *Y = E.getDivisor();\n      Instruction *Mul = BinaryOperator::CreateMul(DivInst, Y);\n      Instruction *Sub = BinaryOperator::CreateSub(X, Mul);\n\n      // If the remainder dominates, then hoist the division up to that block:\n      //\n      // bb1:\n      //   %rem = srem %x, %y\n      // bb2:\n      //   %div = sdiv %x, %y\n      // -->\n      // bb1:\n      //   %div = sdiv %x, %y\n      //   %mul = mul %div, %y\n      //   %rem = sub %x, %mul\n      //\n      // If the division dominates, it's already in the right place. The mul+sub\n      // will be in a different block because we don't assume that they are\n      // cheap to speculatively execute:\n      //\n      // bb1:\n      //   %div = sdiv %x, %y\n      // bb2:\n      //   %rem = srem %x, %y\n      // -->\n      // bb1:\n      //   %div = sdiv %x, %y\n      // bb2:\n      //   %mul = mul %div, %y\n      //   %rem = sub %x, %mul\n      //\n      // If the div and rem are in the same block, we do the same transform,\n      // but any code movement would be within the same block.\n\n      if (!DivDominates)\n        DivInst->moveBefore(RemInst);\n      Mul->insertAfter(RemInst);\n      Sub->insertAfter(Mul);\n\n      // Now kill the explicit remainder. We have replaced it with:\n      // (sub X, (mul (div X, Y), Y)\n      Sub->setName(RemInst->getName() + \".decomposed\");\n      Instruction *OrigRemInst = RemInst;\n      // Update AssertingVH<> with new instruction so it doesn't assert.\n      RemInst = Sub;\n      // And replace the original instruction with the new one.\n      OrigRemInst->replaceAllUsesWith(Sub);\n      OrigRemInst->eraseFromParent();\n      NumDecomposed++;\n    }\n    Changed = true;\n  }\n\n  return Changed;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n      assert(!RemOriginallyWasInExpandedForm &&\n             \"Won't happen for expanded-form rem.\");\n      // FIXME: We could hoist both ops to the common predecessor block?\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/DivRemPairs/X86/div-expanded-rem-pair.ll (1 of 1)\nTesting Time: 1.43s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/DivRemPairs/X86/div-expanded-rem-pair.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "d30093bb8a3f12d35d176a85cf93e354a38ff116___DivRemPairs.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic Instruction *visitMaskedMerge(BinaryOperator &I,\n                                     InstCombiner::BuilderTy &Builder) {\n  Value *B, *X, *D;\n  Value *M;\n  if (!match(&I, m_c_Xor(m_Value(B),\n                         m_OneUse(m_c_And(\n                             m_CombineAnd(m_c_Xor(m_Deferred(B), m_Value(X)),\n                                          m_Value(D)),\n                             m_Value(M))))))\n    return nullptr;\n\n  Value *NotM;\n  if (match(M, m_Not(m_Value(NotM)))) {\n    // De-invert the mask and swap the value in B part.\n    Value *NewA = Builder.CreateAnd(D, NotM);\n    return BinaryOperator::CreateXor(NewA, X);\n  }\n\n  Constant *C;\n  if (D->hasOneUse() && match(M, m_Constant(C))) {\n\n>>> [ INFILL ] <<<\n    Value *LHS = Builder.CreateAnd(X, C);\n    Value *NotC = Builder.CreateNot(C);\n    Value *RHS = Builder.CreateAnd(B, NotC);\n    return BinaryOperator::CreateOr(LHS, RHS);\n  }\n\n  return nullptr;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    // Unfold.\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/unfold-masked-merge-with-const-mask-vector.ll (1 of 1)\n********************\nFailing Tests (1):\n  LLVM :: Transforms/InstCombine/unfold-masked-merge-with-const-mask-vector.ll\n\n\nTesting Time: 0.41s\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "fde8eb00e1466cecd0fc6697f8c2ab837c5b7cf3___InstCombineAndOrXor.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nvoid SelectionDAGBuilder::visitInvoke(const InvokeInst &I) {\n  MachineBasicBlock *InvokeMBB = FuncInfo.MBB;\n\n  // Retrieve successors. Look through artificial IR level blocks like\n  // catchswitch for successors.\n  MachineBasicBlock *Return = FuncInfo.MBBMap[I.getSuccessor(0)];\n  const BasicBlock *EHPadBB = I.getSuccessor(1);\n\n  // Deopt bundles are lowered in LowerCallSiteWithDeoptBundle, and we don't\n  // have to do anything here to lower funclet bundles.\n  assert(!I.hasOperandBundlesOtherThan({LLVMContext::OB_deopt,\n                                        LLVMContext::OB_gc_transition,\n\n>>> [ INFILL ] <<<\n                                        LLVMContext::OB_cfguardtarget}) &&\n         \"Cannot lower invokes with arbitrary operand bundles yet!\");\n\n  const Value *Callee(I.getCalledOperand());\n  const Function *Fn = dyn_cast<Function>(Callee);\n  if (isa<InlineAsm>(Callee))\n    visitInlineAsm(I);\n  else if (Fn && Fn->isIntrinsic()) {\n    switch (Fn->getIntrinsicID()) {\n    default:\n      llvm_unreachable(\"Cannot invoke this intrinsic\");\n    case Intrinsic::donothing:\n      // Ignore invokes to @llvm.donothing: jump directly to the next BB.\n      break;\n    case Intrinsic::experimental_patchpoint_void:\n    case Intrinsic::experimental_patchpoint_i64:\n      visitPatchpoint(I, EHPadBB);\n      break;\n    case Intrinsic::experimental_gc_statepoint:\n      LowerStatepoint(cast<GCStatepointInst>(I), EHPadBB);\n      break;\n    case Intrinsic::wasm_rethrow_in_catch: {\n      // This is usually done in visitTargetIntrinsic, but this intrinsic is\n      // special because it can be invoked, so we manually lower it to a DAG\n      // node here.\n      SmallVector<SDValue, 8> Ops;\n      Ops.push_back(getRoot()); // inchain\n      const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n      Ops.push_back(\n          DAG.getTargetConstant(Intrinsic::wasm_rethrow_in_catch, getCurSDLoc(),\n                                TLI.getPointerTy(DAG.getDataLayout())));\n      SDVTList VTs = DAG.getVTList(ArrayRef<EVT>({MVT::Other})); // outchain\n      DAG.setRoot(DAG.getNode(ISD::INTRINSIC_VOID, getCurSDLoc(), VTs, Ops));\n      break;\n    }\n    }\n  } else if (I.countOperandBundlesOfType(LLVMContext::OB_deopt)) {\n    // Currently we do not lower any intrinsic calls with deopt operand bundles.\n    // Eventually we will support lowering the @llvm.experimental.deoptimize\n    // intrinsic, and right now there are no plans to support other intrinsics\n    // with deopt state.\n    LowerCallSiteWithDeoptBundle(&I, getValue(Callee), EHPadBB);\n  } else {\n    LowerCallTo(I, getValue(Callee), false, EHPadBB);\n  }\n\n  // If the value of the invoke is used outside of its defining block, make it\n  // available as a virtual register.\n  // We already took care of the exported value for the statepoint instruction\n  // during call to the LowerStatepoint.\n  if (!isa<GCStatepointInst>(I)) {\n    CopyToExportRegsIfNeeded(&I);\n  }\n\n  SmallVector<std::pair<MachineBasicBlock *, BranchProbability>, 1> UnwindDests;\n  BranchProbabilityInfo *BPI = FuncInfo.BPI;\n  BranchProbability EHPadBBProb =\n      BPI ? BPI->getEdgeProbability(InvokeMBB->getBasicBlock(), EHPadBB)\n          : BranchProbability::getZero();\n  findUnwindDestinations(FuncInfo, EHPadBB, EHPadBBProb, UnwindDests);\n\n  // Update successor info.\n  addSuccessorWithProb(InvokeMBB, Return);\n  for (auto &UnwindDest : UnwindDests) {\n    UnwindDest.first->setIsEHPad();\n    addSuccessorWithProb(InvokeMBB, UnwindDest.first, UnwindDest.second);\n  }\n  InvokeMBB->normalizeSuccProbs();\n\n  // Drop into normal successor.\n  DAG.setRoot(DAG.getNode(ISD::BR, getCurSDLoc(), MVT::Other, getControlRoot(),\n                          DAG.getBasicBlock(Return)));\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n                                        LLVMContext::OB_funclet,\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/statepoint-invoke.ll (1 of 1)\n********************\nFailing Tests (1):\n  LLVM :: CodeGen/X86/statepoint-invoke.ll\n\n\nTesting Time: 2.91s\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "4c735439fd9a0cfea9ae366df8b36281436d4708___SelectionDAGBuilder.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nError BitcodeReader::materializeMetadata() {\n  for (uint64_t BitPos : DeferredMetadataInfo) {\n    // Move the bit stream to the saved position.\n    if (Error JumpFailed = Stream.JumpToBit(BitPos))\n      return JumpFailed;\n    if (Error Err = MDLoader->parseModuleMetadata())\n      return Err;\n  }\n\n  // Upgrade \"Linker Options\" module flag to \"llvm.linker.options\" module-level\n\n>>> [ INFILL ] <<<\n\n  DeferredMetadataInfo.clear();\n  return Error::success();\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  // metadata.\n  if (Metadata *Val = TheModule->getModuleFlag(\"Linker Options\")) {\n    NamedMDNode *LinkerOpts =\n        TheModule->getOrInsertNamedMetadata(\"llvm.linker.options\");\n    for (const MDOperand &MDOptions : cast<MDNode>(Val)->operands())\n      LinkerOpts->addOperand(cast<MDNode>(MDOptions));\n  }\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Bitcode/upgrade-linker-options-2.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Bitcode/upgrade-linker-options-2.ll\n\n\nTesting Time: 0.11s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ac375c2fe316dae6eb770b38f90d6b67fadd22ec___BitcodeReader.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nScalarEvolution::ExitLimit\nScalarEvolution::howManyGreaterThans(const SCEV *LHS, const SCEV *RHS,\n                                     const Loop *L, bool IsSigned,\n                                     bool ControlsExit, bool AllowPredicates) {\n  SmallPtrSet<const SCEVPredicate *, 4> Predicates;\n  // We handle only IV > Invariant\n  if (!isLoopInvariant(RHS, L))\n    return getCouldNotCompute();\n\n  const SCEVAddRecExpr *IV = dyn_cast<SCEVAddRecExpr>(LHS);\n  if (!IV && AllowPredicates)\n    // Try to make this an AddRec using runtime tests, in the first X\n    // iterations of this loop, where X is the SCEV expression found by the\n    // algorithm below.\n    IV = convertSCEVToAddRecWithPredicates(LHS, L, Predicates);\n\n  // Avoid weird loops\n  if (!IV || IV->getLoop() != L || !IV->isAffine())\n    return getCouldNotCompute();\n\n  bool NoWrap = ControlsExit &&\n                IV->getNoWrapFlags(IsSigned ? SCEV::FlagNSW : SCEV::FlagNUW);\n\n  const SCEV *Stride = getNegativeSCEV(IV->getStepRecurrence(*this));\n\n  // Avoid negative or zero stride values\n  if (!isKnownPositive(Stride))\n    return getCouldNotCompute();\n\n  // Avoid proven overflow cases: this will ensure that the backedge taken count\n  // will not generate any unsigned overflow. Relaxed no-overflow conditions\n  // exploit NoWrapFlags, allowing to optimize in presence of undefined\n  // behaviors like the case of C language.\n  if (!Stride->isOne() && doesIVOverflowOnGT(RHS, Stride, IsSigned, NoWrap))\n    return getCouldNotCompute();\n\n  ICmpInst::Predicate Cond = IsSigned ? ICmpInst::ICMP_SGT\n                                      : ICmpInst::ICMP_UGT;\n\n  const SCEV *Start = IV->getStart();\n  const SCEV *End = RHS;\n\n>>> [ INFILL ] <<<\n  const SCEV *BECount = computeBECount(getMinusSCEV(Start, End), Stride, false);\n\n  APInt MaxStart = IsSigned ? getSignedRangeMax(Start)\n                            : getUnsignedRangeMax(Start);\n\n  APInt MinStride = IsSigned ? getSignedRangeMin(Stride)\n                             : getUnsignedRangeMin(Stride);\n\n  unsigned BitWidth = getTypeSizeInBits(LHS->getType());\n  APInt Limit = IsSigned ? APInt::getSignedMinValue(BitWidth) + (MinStride - 1)\n                         : APInt::getMinValue(BitWidth) + (MinStride - 1);\n\n  // Although End can be a MIN expression we estimate MinEnd considering only\n  // the case End = RHS. This is safe because in the other case (Start - End)\n  // is zero, leading to a zero maximum backedge taken count.\n  APInt MinEnd =\n    IsSigned ? APIntOps::smax(getSignedRangeMin(RHS), Limit)\n             : APIntOps::umax(getUnsignedRangeMin(RHS), Limit);\n\n  const SCEV *MaxBECount = isa<SCEVConstant>(BECount)\n                               ? BECount\n                               : computeBECount(getConstant(MaxStart - MinEnd),\n                                                getConstant(MinStride), false);\n\n  if (isa<SCEVCouldNotCompute>(MaxBECount))\n    MaxBECount = BECount;\n\n  return ExitLimit(BECount, MaxBECount, false, Predicates);\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  if (!isLoopEntryGuardedByCond(L, Cond, getAddExpr(Start, Stride), RHS))\n    End = IsSigned ? getSMinExpr(RHS, Start) : getUMinExpr(RHS, Start);\n\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Analysis/ScalarEvolution/pr46939-trip-count-count-down.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Analysis/ScalarEvolution/pr46939-trip-count-count-down.ll\n\n\nTesting Time: 0.33s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/HardwareLoops/scalar-while.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/HardwareLoops/scalar-while.ll\n\n\nTesting Time: 0.13s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ee1c12708a4519361729205168dedb2b61bc2638___ScalarEvolution.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\n  bool isWriteAtEndOfFunction(MemoryDef *Def) {\n    LLVM_DEBUG(dbgs() << \"  Check if def \" << *Def << \" (\"\n                      << *Def->getMemoryInst()\n                      << \") is at the end the function \\n\");\n\n    auto MaybeLoc = getLocForWriteEx(Def->getMemoryInst());\n    if (!MaybeLoc) {\n      LLVM_DEBUG(dbgs() << \"  ... could not get location for write.\\n\");\n      return false;\n    }\n\n    SmallVector<MemoryAccess *, 4> WorkList;\n    SmallPtrSet<MemoryAccess *, 8> Visited;\n    auto PushMemUses = [&WorkList, &Visited](MemoryAccess *Acc) {\n      if (!Visited.insert(Acc).second)\n        return;\n      for (Use &U : Acc->uses())\n        WorkList.push_back(cast<MemoryAccess>(U.getUser()));\n    };\n    PushMemUses(Def);\n    for (unsigned I = 0; I < WorkList.size(); I++) {\n      if (WorkList.size() >= MemorySSAScanLimit) {\n        LLVM_DEBUG(dbgs() << \"  ... hit exploration limit.\\n\");\n        return false;\n      }\n\n      MemoryAccess *UseAccess = WorkList[I];\n\n>>> [ INFILL ] <<<\n      // TODO: Checking for aliasing is expensive. Consider reducing the amount\n      // of times this is called and/or caching it.\n      Instruction *UseInst = cast<MemoryUseOrDef>(UseAccess)->getMemoryInst();\n      if (isReadClobber(*MaybeLoc, UseInst)) {\n        LLVM_DEBUG(dbgs() << \"  ... hit read clobber \" << *UseInst << \".\\n\");\n        return false;\n      }\n\n      if (MemoryDef *UseDef = dyn_cast<MemoryDef>(UseAccess))\n        PushMemUses(UseDef);\n    }\n    return true;\n  }\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n      if (isa<MemoryPhi>(UseAccess)) {\n        PushMemUses(UseAccess);\n        continue;\n      }\n\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/DeadStoreElimination/MSSA/multiblock-loop-carried-dependence.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/DeadStoreElimination/MSSA/multiblock-loop-carried-dependence.ll\n\n\nTesting Time: 1.00s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/DeadStoreElimination/MSSA/multiblock-malloc-free.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/DeadStoreElimination/MSSA/multiblock-malloc-free.ll\n\n\nTesting Time: 0.26s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/DeadStoreElimination/MSSA/multiblock-memintrinsics.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/DeadStoreElimination/MSSA/multiblock-memintrinsics.ll\n\n\nTesting Time: 0.29s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "e082dee2b5885bba65e20b22b088bcaca5546984___DeadStoreElimination.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nValue *LibCallSimplifier::optimizePow(CallInst *Pow, IRBuilderBase &B) {\n  Value *Base = Pow->getArgOperand(0);\n  Value *Expo = Pow->getArgOperand(1);\n  Function *Callee = Pow->getCalledFunction();\n  StringRef Name = Callee->getName();\n  Type *Ty = Pow->getType();\n  Module *M = Pow->getModule();\n  Value *Shrunk = nullptr;\n  bool AllowApprox = Pow->hasApproxFunc();\n  bool Ignored;\n\n  // Propagate the math semantics from the call to any created instructions.\n  IRBuilderBase::FastMathFlagGuard Guard(B);\n  B.setFastMathFlags(Pow->getFastMathFlags());\n\n  // Shrink pow() to powf() if the arguments are single precision,\n  // unless the result is expected to be double precision.\n  if (UnsafeFPShrink && Name == TLI->getName(LibFunc_pow) &&\n      hasFloatVersion(Name))\n    Shrunk = optimizeBinaryDoubleFP(Pow, B, true);\n\n  // Evaluate special cases related to the base.\n\n  // pow(1.0, x) -> 1.0\n  if (match(Base, m_FPOne()))\n    return Base;\n\n  if (Value *Exp = replacePowWithExp(Pow, B))\n    return Exp;\n\n  // Evaluate special cases related to the exponent.\n\n  // pow(x, -1.0) -> 1.0 / x\n  if (match(Expo, m_SpecificFP(-1.0)))\n    return B.CreateFDiv(ConstantFP::get(Ty, 1.0), Base, \"reciprocal\");\n\n  // pow(x, +/-0.0) -> 1.0\n  if (match(Expo, m_AnyZeroFP()))\n    return ConstantFP::get(Ty, 1.0);\n\n  // pow(x, 1.0) -> x\n  if (match(Expo, m_FPOne()))\n    return Base;\n\n  // pow(x, 2.0) -> x * x\n  if (match(Expo, m_SpecificFP(2.0)))\n    return B.CreateFMul(Base, Base, \"square\");\n\n  if (Value *Sqrt = replacePowWithSqrt(Pow, B))\n    return Sqrt;\n\n  // pow(x, n) -> x * x * x * ...\n  const APFloat *ExpoF;\n  if (AllowApprox && match(Expo, m_APFloat(ExpoF))) {\n    // We limit to a max of 7 multiplications, thus the maximum exponent is 32.\n    // If the exponent is an integer+0.5 we generate a call to sqrt and an\n    // additional fmul.\n    // TODO: This whole transformation should be backend specific (e.g. some\n    //       backends might prefer libcalls or the limit for the exponent might\n    //       be different) and it should also consider optimizing for size.\n    APFloat LimF(ExpoF->getSemantics(), 33),\n            ExpoA(abs(*ExpoF));\n    if (ExpoA < LimF) {\n      // This transformation applies to integer or integer+0.5 exponents only.\n      // For integer+0.5, we create a sqrt(Base) call.\n      Value *Sqrt = nullptr;\n      if (!ExpoA.isInteger()) {\n        APFloat Expo2 = ExpoA;\n        // To check if ExpoA is an integer + 0.5, we add it to itself. If there\n        // is no floating point exception and the result is an integer, then\n        // ExpoA == integer + 0.5\n        if (Expo2.add(ExpoA, APFloat::rmNearestTiesToEven) != APFloat::opOK)\n          return nullptr;\n\n        if (!Expo2.isInteger())\n          return nullptr;\n\n        Sqrt = getSqrtCall(Base, Pow->getCalledFunction()->getAttributes(),\n                           Pow->doesNotAccessMemory(), M, B, TLI);\n\n>>> [ INFILL ] <<<\n\n      // We will memoize intermediate products of the Addition Chain.\n      Value *InnerChain[33] = {nullptr};\n      InnerChain[1] = Base;\n      InnerChain[2] = B.CreateFMul(Base, Base, \"square\");\n\n      // We cannot readily convert a non-double type (like float) to a double.\n      // So we first convert it to something which could be converted to double.\n      ExpoA.convert(APFloat::IEEEdouble(), APFloat::rmTowardZero, &Ignored);\n      Value *FMul = getPow(InnerChain, ExpoA.convertToDouble(), B);\n\n      // Expand pow(x, y+0.5) to pow(x, y) * sqrt(x).\n      if (Sqrt)\n        FMul = B.CreateFMul(FMul, Sqrt);\n\n      // If the exponent is negative, then get the reciprocal.\n      if (ExpoF->isNegative())\n        FMul = B.CreateFDiv(ConstantFP::get(Ty, 1.0), FMul, \"reciprocal\");\n\n      return FMul;\n    }\n\n    APSInt IntExpo(32, /*isUnsigned=*/false);\n    // powf(x, n) -> powi(x, n) if n is a constant signed integer value\n    if (ExpoF->isInteger() &&\n        ExpoF->convertToInteger(IntExpo, APFloat::rmTowardZero, &Ignored) ==\n            APFloat::opOK) {\n      return createPowWithIntegerExponent(\n          Base, ConstantInt::get(B.getInt32Ty(), IntExpo), M, B);\n    }\n  }\n\n  // powf(x, itofp(y)) -> powi(x, y)\n  if (AllowApprox && (isa<SIToFPInst>(Expo) || isa<UIToFPInst>(Expo))) {\n    if (Value *ExpoI = getIntToFPVal(Expo, B))\n      return createPowWithIntegerExponent(Base, ExpoI, M, B);\n  }\n\n  return Shrunk;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n      }\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/pow-4.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/pow-4.ll\n\n\nTesting Time: 0.44s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "aa57c1c967078a8c02e7fc2c837853dbd7cc66f4___SimplifyLibCalls.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nValue *LibCallSimplifier::replacePowWithSqrt(CallInst *Pow, IRBuilderBase &B) {\n  Value *Sqrt, *Base = Pow->getArgOperand(0), *Expo = Pow->getArgOperand(1);\n  AttributeList Attrs; // Attributes are only meaningful on the original call\n  Module *Mod = Pow->getModule();\n  Type *Ty = Pow->getType();\n\n  const APFloat *ExpoF;\n  if (!match(Expo, m_APFloat(ExpoF)) ||\n      (!ExpoF->isExactlyValue(0.5) && !ExpoF->isExactlyValue(-0.5)))\n    return nullptr;\n\n  // Converting pow(X, -0.5) to 1/sqrt(X) may introduce an extra rounding step,\n  // so that requires fast-math-flags (afn or reassoc).\n  if (ExpoF->isNegative() && (!Pow->hasApproxFunc() && !Pow->hasAllowReassoc()))\n    return nullptr;\n\n\n>>> [ INFILL ] <<<\n  if (!Sqrt)\n    return nullptr;\n\n  // Handle signed zero base by expanding to fabs(sqrt(x)).\n  if (!Pow->hasNoSignedZeros()) {\n    Function *FAbsFn = Intrinsic::getDeclaration(Mod, Intrinsic::fabs, Ty);\n    Sqrt = B.CreateCall(FAbsFn, Sqrt, \"abs\");\n  }\n\n  // Handle non finite base by expanding to\n  // (x == -infinity ? +infinity : sqrt(x)).\n  if (!Pow->hasNoInfs()) {\n    Value *PosInf = ConstantFP::getInfinity(Ty),\n          *NegInf = ConstantFP::getInfinity(Ty, true);\n    Value *FCmp = B.CreateFCmpOEQ(Base, NegInf, \"isinf\");\n    Sqrt = B.CreateSelect(FCmp, PosInf, Sqrt);\n  }\n\n  // If the exponent is negative, then get the reciprocal.\n  if (ExpoF->isNegative())\n    Sqrt = B.CreateFDiv(ConstantFP::get(Ty, 1.0), Sqrt, \"reciprocal\");\n\n  return Sqrt;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  Sqrt = getSqrtCall(Base, Attrs, Pow->doesNotAccessMemory(), Mod, B, TLI);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/pow-1.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/pow-1.ll\n\n\nTesting Time: 0.36s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/InstCombine/pow-sqrt.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/pow-sqrt.ll\n\n\nTesting Time: 0.17s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nPASS: LLVM :: Transforms/InstCombine/win-math.ll (1 of 1)\n\nTesting Time: 2.03s\n  Passed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "32c9991dab5cb1454959561c77f9d0089d981429___SimplifyLibCalls.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic bool SinkInstruction(Instruction *Inst,\n                            SmallPtrSetImpl<Instruction *> &Stores,\n                            DominatorTree &DT, LoopInfo &LI, AAResults &AA) {\n\n  // Don't sink static alloca instructions.  CodeGen assumes allocas outside the\n  // entry block are dynamically sized stack objects.\n  if (AllocaInst *AI = dyn_cast<AllocaInst>(Inst))\n    if (AI->isStaticAlloca())\n      return false;\n\n  // Check if it's safe to move the instruction.\n  if (!isSafeToMove(Inst, AA, Stores))\n    return false;\n\n  // FIXME: This should include support for sinking instructions within the\n  // block they are currently in to shorten the live ranges.  We often get\n  // instructions sunk into the top of a large block, but it would be better to\n  // also sink them down before their first use in the block.  This xform has to\n  // be careful not to *increase* register pressure though, e.g. sinking\n  // \"x = y + z\" down if it kills y and z would increase the live ranges of y\n  // and z and only shrink the live range of x.\n\n  // SuccToSinkTo - This is the successor to sink this instruction to, once we\n  // decide.\n  BasicBlock *SuccToSinkTo = nullptr;\n\n  // Find the nearest common dominator of all users as the candidate.\n  BasicBlock *BB = Inst->getParent();\n  for (Use &U : Inst->uses()) {\n    Instruction *UseInst = cast<Instruction>(U.getUser());\n    BasicBlock *UseBlock = UseInst->getParent();\n\n>>> [ INFILL ] <<<\n      // PHI nodes use the operand in the predecessor block, not the block with\n      // the PHI.\n      unsigned Num = PHINode::getIncomingValueNumForOperand(U.getOperandNo());\n      UseBlock = PN->getIncomingBlock(Num);\n    }\n    if (SuccToSinkTo)\n      SuccToSinkTo = DT.findNearestCommonDominator(SuccToSinkTo, UseBlock);\n    else\n      SuccToSinkTo = UseBlock;\n    // The current basic block needs to dominate the candidate.\n    if (!DT.dominates(BB, SuccToSinkTo))\n      return false;\n  }\n\n  if (SuccToSinkTo) {\n    // The nearest common dominator may be in a parent loop of BB, which may not\n    // be beneficial. Find an ancestor.\n    while (SuccToSinkTo != BB &&\n           !IsAcceptableTarget(Inst, SuccToSinkTo, DT, LI))\n      SuccToSinkTo = DT.getNode(SuccToSinkTo)->getIDom()->getBlock();\n    if (SuccToSinkTo == BB)\n      SuccToSinkTo = nullptr;\n  }\n\n  // If we couldn't find a block to sink to, ignore this instruction.\n  if (!SuccToSinkTo)\n    return false;\n\n  LLVM_DEBUG(dbgs() << \"Sink\" << *Inst << \" (\";\n             Inst->getParent()->printAsOperand(dbgs(), false); dbgs() << \" -> \";\n             SuccToSinkTo->printAsOperand(dbgs(), false); dbgs() << \")\\n\");\n\n  // Move the instruction.\n  Inst->moveBefore(&*SuccToSinkTo->getFirstInsertionPt());\n  return true;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    if (PHINode *PN = dyn_cast<PHINode>(UseInst)) {\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/Sink/dead-user.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/Sink/dead-user.ll\n\n\nTesting Time: 1.94s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "f192a27ed3bacdf727f27857adeb6d3762383295___Sink.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nbool X86FastISel::foldX86XALUIntrinsic(X86::CondCode &CC, const Instruction *I,\n                                       const Value *Cond) {\n  if (!isa<ExtractValueInst>(Cond))\n    return false;\n\n  const auto *EV = cast<ExtractValueInst>(Cond);\n  if (!isa<IntrinsicInst>(EV->getAggregateOperand()))\n    return false;\n\n  const auto *II = cast<IntrinsicInst>(EV->getAggregateOperand());\n  MVT RetVT;\n  const Function *Callee = II->getCalledFunction();\n  Type *RetTy =\n    cast<StructType>(Callee->getReturnType())->getTypeAtIndex(0U);\n  if (!isTypeLegal(RetTy, RetVT))\n    return false;\n\n  if (RetVT != MVT::i32 && RetVT != MVT::i64)\n    return false;\n\n  X86::CondCode TmpCC;\n  switch (II->getIntrinsicID()) {\n  default: return false;\n  case Intrinsic::sadd_with_overflow:\n  case Intrinsic::ssub_with_overflow:\n  case Intrinsic::smul_with_overflow:\n  case Intrinsic::umul_with_overflow: TmpCC = X86::COND_O; break;\n  case Intrinsic::uadd_with_overflow:\n  case Intrinsic::usub_with_overflow: TmpCC = X86::COND_B; break;\n  }\n\n  // Check if both instructions are in the same basic block.\n  if (II->getParent() != I->getParent())\n    return false;\n\n  // Make sure nothing is in the way\n  BasicBlock::const_iterator Start(I);\n  BasicBlock::const_iterator End(II);\n  for (auto Itr = std::prev(Start); Itr != End; --Itr) {\n    // We only expect extractvalue instructions between the intrinsic and the\n    // instruction to be selected.\n    if (!isa<ExtractValueInst>(Itr))\n      return false;\n\n    // Check that the extractvalue operand comes from the intrinsic.\n    const auto *EVI = cast<ExtractValueInst>(Itr);\n    if (EVI->getAggregateOperand() != II)\n      return false;\n  }\n\n\n>>> [ INFILL ] <<<\n  return true;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  CC = TmpCC;\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/pr49587.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/pr49587.ll\n\n\nTesting Time: 0.12s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "7669455df49e6fc8ae7d9f4bd4ee95bb20e7eb6e___X86FastISel.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic void CloneInstructionsIntoPredecessorBlockAndUpdateSSAUses(\n    BasicBlock *BB, BasicBlock *PredBlock, ValueToValueMapTy &VMap) {\n  Instruction *PTI = PredBlock->getTerminator();\n\n  // If we have bonus instructions, clone them into the predecessor block.\n  // Note that there may be multiple predecessor blocks, so we cannot move\n  // bonus instructions to a predecessor block.\n  for (Instruction &BonusInst : *BB) {\n    if (isa<DbgInfoIntrinsic>(BonusInst) || BonusInst.isTerminator())\n      continue;\n\n    Instruction *NewBonusInst = BonusInst.clone();\n\n    if (PTI->getDebugLoc() != NewBonusInst->getDebugLoc()) {\n      // Unless the instruction has the same !dbg location as the original\n      // branch, drop it. When we fold the bonus instructions we want to make\n      // sure we reset their debug locations in order to avoid stepping on\n      // dead code caused by folding dead branches.\n      NewBonusInst->setDebugLoc(DebugLoc());\n    }\n\n    RemapInstruction(NewBonusInst, VMap,\n                     RF_NoModuleLevelChanges | RF_IgnoreMissingLocals);\n    VMap[&BonusInst] = NewBonusInst;\n\n    // If we moved a load, we cannot any longer claim any knowledge about\n    // its potential value. The previous information might have been valid\n    // only given the branch precondition.\n    // For an analogous reason, we must also drop all the metadata whose\n    // semantics we don't understand. We *can* preserve !annotation, because\n    // it is tied to the instruction itself, not the value or position.\n    NewBonusInst->dropUnknownNonDebugMetadata(LLVMContext::MD_annotation);\n\n    PredBlock->getInstList().insert(PTI->getIterator(), NewBonusInst);\n    NewBonusInst->takeName(&BonusInst);\n    BonusInst.setName(NewBonusInst->getName() + \".old\");\n\n    // Update (liveout) uses of bonus instructions,\n    // now that the bonus instruction has been cloned into predecessor.\n    SSAUpdater SSAUpdate;\n    SSAUpdate.Initialize(BonusInst.getType(),\n                         (NewBonusInst->getName() + \".merge\").str());\n    SSAUpdate.AddAvailableValue(BB, &BonusInst);\n    SSAUpdate.AddAvailableValue(PredBlock, NewBonusInst);\n\n>>> [ INFILL ] <<<\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    for (Use &U : make_early_inc_range(BonusInst.uses()))\n      SSAUpdate.RewriteUseAfterInsertions(U);\n  }\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/SimplifyCFG/fold-branch-to-common-dest.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SimplifyCFG/fold-branch-to-common-dest.ll\n\n\nTesting Time: 6.33s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "514bc01ca3b9f97945dd49aa40e01922fed0e41d___SimplifyCFG.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic bool isDereferenceableAndAlignedPointer(\n    const Value *V, Align Alignment, const APInt &Size, const DataLayout &DL,\n    const Instruction *CtxI, const DominatorTree *DT,\n    const TargetLibraryInfo *TLI, SmallPtrSetImpl<const Value *> &Visited,\n    unsigned MaxDepth) {\n  assert(V->getType()->isPointerTy() && \"Base must be pointer\");\n\n  // Recursion limit.\n  if (MaxDepth-- == 0)\n    return false;\n\n  // Already visited?  Bail out, we've likely hit unreachable code.\n  if (!Visited.insert(V).second)\n    return false;\n\n  // Note that it is not safe to speculate into a malloc'd region because\n  // malloc may return null.\n\n  // bitcast instructions are no-ops as far as dereferenceability is concerned.\n  if (const BitCastOperator *BC = dyn_cast<BitCastOperator>(V)) {\n    if (BC->getSrcTy()->isPointerTy())\n      return isDereferenceableAndAlignedPointer(\n          BC->getOperand(0), Alignment, Size, DL, CtxI, DT, TLI,\n          Visited, MaxDepth);\n  }\n\n  bool CheckForNonNull, CheckForFreed;\n  APInt KnownDerefBytes(Size.getBitWidth(),\n                        V->getPointerDereferenceableBytes(DL, CheckForNonNull,\n                                                          CheckForFreed));\n  if (KnownDerefBytes.getBoolValue() && KnownDerefBytes.uge(Size) &&\n      !CheckForFreed)\n    if (!CheckForNonNull || isKnownNonZero(V, DL, 0, nullptr, CtxI, DT)) {\n      // As we recursed through GEPs to get here, we've incrementally checked\n      // that each step advanced by a multiple of the alignment. If our base is\n      // properly aligned, then the original offset accessed must also be.\n      Type *Ty = V->getType();\n      assert(Ty->isSized() && \"must be sized\");\n      APInt Offset(DL.getTypeStoreSizeInBits(Ty), 0);\n      return isAligned(V, Offset, Alignment, DL);\n    }\n\n  if (CtxI) {\n    /// Look through assumes to see if both dereferencability and alignment can\n    /// be provent by an assume\n    RetainedKnowledge AlignRK;\n    RetainedKnowledge DerefRK;\n    if (getKnowledgeForValue(\n            V, {Attribute::Dereferenceable, Attribute::Alignment}, nullptr,\n            [&](RetainedKnowledge RK, Instruction *Assume, auto) {\n              if (!isValidAssumeForContext(Assume, CtxI))\n                return false;\n              if (RK.AttrKind == Attribute::Alignment)\n                AlignRK = std::max(AlignRK, RK);\n              if (RK.AttrKind == Attribute::Dereferenceable)\n                DerefRK = std::max(DerefRK, RK);\n              if (AlignRK && DerefRK && AlignRK.ArgValue >= Alignment.value() &&\n                  DerefRK.ArgValue >= Size.getZExtValue())\n                return true; // We have found what we needed so we stop looking\n              return false;  // Other assumes may have better information. so\n                             // keep looking\n            }))\n      return true;\n  }\n  /// TODO refactor this function to be able to search independently for\n  /// Dereferencability and Alignment requirements.\n\n  // For GEPs, determine if the indexing lands within the allocated object.\n  if (const GEPOperator *GEP = dyn_cast<GEPOperator>(V)) {\n    const Value *Base = GEP->getPointerOperand();\n\n    APInt Offset(DL.getIndexTypeSizeInBits(GEP->getType()), 0);\n    if (!GEP->accumulateConstantOffset(DL, Offset) || Offset.isNegative() ||\n        !Offset.urem(APInt(Offset.getBitWidth(), Alignment.value()))\n             .isMinValue())\n      return false;\n\n    // If the base pointer is dereferenceable for Offset+Size bytes, then the\n    // GEP (== Base + Offset) is dereferenceable for Size bytes.  If the base\n    // pointer is aligned to Align bytes, and the Offset is divisible by Align\n    // then the GEP (== Base + Offset == k_0 * Align + k_1 * Align) is also\n    // aligned to Align bytes.\n\n    // Offset and Size may have different bit widths if we have visited an\n    // addrspacecast, so we can't do arithmetic directly on the APInt values.\n    return isDereferenceableAndAlignedPointer(\n        Base, Alignment, Offset + Size.sextOrTrunc(Offset.getBitWidth()), DL,\n        CtxI, DT, TLI, Visited, MaxDepth);\n  }\n\n  // For gc.relocate, look through relocations\n  if (const GCRelocateInst *RelocateInst = dyn_cast<GCRelocateInst>(V))\n    return isDereferenceableAndAlignedPointer(RelocateInst->getDerivedPtr(),\n                                              Alignment, Size, DL, CtxI, DT,\n                                              TLI, Visited, MaxDepth);\n\n  if (const AddrSpaceCastInst *ASC = dyn_cast<AddrSpaceCastInst>(V))\n    return isDereferenceableAndAlignedPointer(ASC->getOperand(0), Alignment,\n                                              Size, DL, CtxI, DT, TLI,\n                                              Visited, MaxDepth);\n\n  if (const auto *Call = dyn_cast<CallBase>(V)) {\n    if (auto *RP = getArgumentAliasingToReturnedPointer(Call, true))\n      return isDereferenceableAndAlignedPointer(RP, Alignment, Size, DL, CtxI,\n                                                DT, TLI, Visited, MaxDepth);\n\n    // If we have a call we can't recurse through, check to see if this is an\n    // allocation function for which we can establish an minimum object size.\n    // Such a minimum object size is analogous to a deref_or_null attribute in\n    // that we still need to prove the result non-null at point of use.\n    // NOTE: We can only use the object size as a base fact as we a) need to\n    // prove alignment too, and b) don't want the compile time impact of a\n    // separate recursive walk.\n    ObjectSizeOpts Opts;\n    // TODO: It may be okay to round to align, but that would imply that\n    // accessing slightly out of bounds was legal, and we're currently\n    // inconsistent about that.  For the moment, be conservative.\n    Opts.RoundToAlign = false;\n    Opts.NullIsUnknownSize = true;\n    uint64_t ObjSize;\n\n>>> [ INFILL ] <<<\n      if (KnownDerefBytes.getBoolValue() && KnownDerefBytes.uge(Size) &&\n          isKnownNonZero(V, DL, 0, nullptr, CtxI, DT) && !V->canBeFreed()) {\n        // As we recursed through GEPs to get here, we've incrementally\n        // checked that each step advanced by a multiple of the alignment. If\n        // our base is properly aligned, then the original offset accessed\n        // must also be. \n        Type *Ty = V->getType();\n        assert(Ty->isSized() && \"must be sized\");\n        APInt Offset(DL.getTypeStoreSizeInBits(Ty), 0);\n        return isAligned(V, Offset, Alignment, DL);\n      }\n    }\n  }\n\n  // If we don't know, assume the worst.\n  return false;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    // TODO: Plumb through TLI so that malloc routines and such work.\n    if (getObjectSize(V, ObjSize, DL, nullptr, Opts)) {\n      APInt KnownDerefBytes(Size.getBitWidth(), ObjSize);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/LICM/hoist-alloc.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LICM/hoist-alloc.ll\n\n\nTesting Time: 0.39s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "db357891f0cf76253be3cd75f682b68544a411da___Loads.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic bool isDereferenceableAndAlignedPointer(\n    const Value *V, Align Alignment, const APInt &Size, const DataLayout &DL,\n    const Instruction *CtxI, const DominatorTree *DT,\n    const TargetLibraryInfo *TLI, SmallPtrSetImpl<const Value *> &Visited,\n    unsigned MaxDepth) {\n  assert(V->getType()->isPointerTy() && \"Base must be pointer\");\n\n  // Recursion limit.\n  if (MaxDepth-- == 0)\n    return false;\n\n  // Already visited?  Bail out, we've likely hit unreachable code.\n  if (!Visited.insert(V).second)\n    return false;\n\n  // Note that it is not safe to speculate into a malloc'd region because\n  // malloc may return null.\n\n\n>>> [ INFILL ] <<<\n  if (const BitCastOperator *BC = dyn_cast<BitCastOperator>(V)) {\n    if (BC->getSrcTy()->isPointerTy())\n      return isDereferenceableAndAlignedPointer(\n          BC->getOperand(0), Alignment, Size, DL, CtxI, DT, TLI,\n          Visited, MaxDepth);\n  }\n\n  bool CheckForNonNull, CheckForFreed;\n  APInt KnownDerefBytes(Size.getBitWidth(),\n                        V->getPointerDereferenceableBytes(DL, CheckForNonNull,\n                                                          CheckForFreed));\n  if (KnownDerefBytes.getBoolValue() && KnownDerefBytes.uge(Size) &&\n      !CheckForFreed)\n    if (!CheckForNonNull || isKnownNonZero(V, DL, 0, nullptr, CtxI, DT)) {\n      // As we recursed through GEPs to get here, we've incrementally checked\n      // that each step advanced by a multiple of the alignment. If our base is\n      // properly aligned, then the original offset accessed must also be.\n      Type *Ty = V->getType();\n      assert(Ty->isSized() && \"must be sized\");\n      APInt Offset(DL.getTypeStoreSizeInBits(Ty), 0);\n      return isAligned(V, Offset, Alignment, DL);\n    }\n\n  if (CtxI) {\n    /// Look through assumes to see if both dereferencability and alignment can\n    /// be provent by an assume\n    RetainedKnowledge AlignRK;\n    RetainedKnowledge DerefRK;\n    if (getKnowledgeForValue(\n            V, {Attribute::Dereferenceable, Attribute::Alignment}, nullptr,\n            [&](RetainedKnowledge RK, Instruction *Assume, auto) {\n              if (!isValidAssumeForContext(Assume, CtxI))\n                return false;\n              if (RK.AttrKind == Attribute::Alignment)\n                AlignRK = std::max(AlignRK, RK);\n              if (RK.AttrKind == Attribute::Dereferenceable)\n                DerefRK = std::max(DerefRK, RK);\n              if (AlignRK && DerefRK && AlignRK.ArgValue >= Alignment.value() &&\n                  DerefRK.ArgValue >= Size.getZExtValue())\n                return true; // We have found what we needed so we stop looking\n              return false;  // Other assumes may have better information. so\n                             // keep looking\n            }))\n      return true;\n  }\n  /// TODO refactor this function to be able to search independently for\n  /// Dereferencability and Alignment requirements.\n\n  // For GEPs, determine if the indexing lands within the allocated object.\n  if (const GEPOperator *GEP = dyn_cast<GEPOperator>(V)) {\n    const Value *Base = GEP->getPointerOperand();\n\n    APInt Offset(DL.getIndexTypeSizeInBits(GEP->getType()), 0);\n    if (!GEP->accumulateConstantOffset(DL, Offset) || Offset.isNegative() ||\n        !Offset.urem(APInt(Offset.getBitWidth(), Alignment.value()))\n             .isMinValue())\n      return false;\n\n    // If the base pointer is dereferenceable for Offset+Size bytes, then the\n    // GEP (== Base + Offset) is dereferenceable for Size bytes.  If the base\n    // pointer is aligned to Align bytes, and the Offset is divisible by Align\n    // then the GEP (== Base + Offset == k_0 * Align + k_1 * Align) is also\n    // aligned to Align bytes.\n\n    // Offset and Size may have different bit widths if we have visited an\n    // addrspacecast, so we can't do arithmetic directly on the APInt values.\n    return isDereferenceableAndAlignedPointer(\n        Base, Alignment, Offset + Size.sextOrTrunc(Offset.getBitWidth()), DL,\n        CtxI, DT, TLI, Visited, MaxDepth);\n  }\n\n  // For gc.relocate, look through relocations\n  if (const GCRelocateInst *RelocateInst = dyn_cast<GCRelocateInst>(V))\n    return isDereferenceableAndAlignedPointer(RelocateInst->getDerivedPtr(),\n                                              Alignment, Size, DL, CtxI, DT,\n                                              TLI, Visited, MaxDepth);\n\n  if (const AddrSpaceCastInst *ASC = dyn_cast<AddrSpaceCastInst>(V))\n    return isDereferenceableAndAlignedPointer(ASC->getOperand(0), Alignment,\n                                              Size, DL, CtxI, DT, TLI,\n                                              Visited, MaxDepth);\n\n  if (const auto *Call = dyn_cast<CallBase>(V)) {\n    if (auto *RP = getArgumentAliasingToReturnedPointer(Call, true))\n      return isDereferenceableAndAlignedPointer(RP, Alignment, Size, DL, CtxI,\n                                                DT, TLI, Visited, MaxDepth);\n\n    // If we have a call we can't recurse through, check to see if this is an\n    // allocation function for which we can establish an minimum object size.\n    // Such a minimum object size is analogous to a deref_or_null attribute in\n    // that we still need to prove the result non-null at point of use.\n    // NOTE: We can only use the object size as a base fact as we a) need to\n    // prove alignment too, and b) don't want the compile time impact of a\n    // separate recursive walk.\n    ObjectSizeOpts Opts;\n    // TODO: It may be okay to round to align, but that would imply that\n    // accessing slightly out of bounds was legal, and we're currently\n    // inconsistent about that.  For the moment, be conservative.\n    Opts.RoundToAlign = false;\n    Opts.NullIsUnknownSize = true;\n    uint64_t ObjSize;\n    if (getObjectSize(V, ObjSize, DL, TLI, Opts)) {\n      APInt KnownDerefBytes(Size.getBitWidth(), ObjSize);\n      if (KnownDerefBytes.getBoolValue() && KnownDerefBytes.uge(Size) &&\n          isKnownNonZero(V, DL, 0, nullptr, CtxI, DT) && !V->canBeFreed()) {\n        // As we recursed through GEPs to get here, we've incrementally\n        // checked that each step advanced by a multiple of the alignment. If\n        // our base is properly aligned, then the original offset accessed\n        // must also be. \n        Type *Ty = V->getType();\n        assert(Ty->isSized() && \"must be sized\");\n        APInt Offset(DL.getTypeStoreSizeInBits(Ty), 0);\n        return isAligned(V, Offset, Alignment, DL);\n      }\n    }\n  }\n\n  // If we don't know, assume the worst.\n  return false;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  // bitcast instructions are no-ops as far as dereferenceability is concerned.\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/SROA/std-clamp.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SROA/std-clamp.ll\n\n\nTesting Time: 0.35s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "077bff39d46364035a5dcfa32fc69910ad0975d0___Loads.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic void moveLCSSAPhis(BasicBlock *InnerExit, BasicBlock *InnerHeader,\n                          BasicBlock *InnerLatch, BasicBlock *OuterHeader,\n                          BasicBlock *OuterLatch, BasicBlock *OuterExit,\n                          Loop *InnerLoop, LoopInfo *LI) {\n\n  // Deal with LCSSA PHI nodes in the exit block of the inner loop, that are\n  // defined either in the header or latch. Those blocks will become header and\n  // latch of the new outer loop, and the only possible users can PHI nodes\n  // in the exit block of the loop nest or the outer loop header (reduction\n  // PHIs, in that case, the incoming value must be defined in the inner loop\n  // header). We can just substitute the user with the incoming value and remove\n  // the PHI.\n  for (PHINode &P : make_early_inc_range(InnerExit->phis())) {\n    assert(P.getNumIncomingValues() == 1 &&\n           \"Only loops with a single exit are supported!\");\n\n    // Incoming values are guaranteed be instructions currently.\n    auto IncI = cast<Instruction>(P.getIncomingValueForBlock(InnerLatch));\n    // Skip phis with incoming values from the inner loop body, excluding the\n    // header and latch.\n    if (IncI->getParent() != InnerLatch && IncI->getParent() != InnerHeader)\n      continue;\n\n    assert(all_of(P.users(),\n                  [OuterHeader, OuterExit, IncI, InnerHeader](User *U) {\n                    return (cast<PHINode>(U)->getParent() == OuterHeader &&\n                            IncI->getParent() == InnerHeader) ||\n                           cast<PHINode>(U)->getParent() == OuterExit;\n                  }) &&\n           \"Can only replace phis iff the uses are in the loop nest exit or \"\n           \"the incoming value is defined in the inner header (it will \"\n           \"dominate all loop blocks after interchanging)\");\n    P.replaceAllUsesWith(IncI);\n    P.eraseFromParent();\n  }\n\n  SmallVector<PHINode *, 8> LcssaInnerExit;\n  for (PHINode &P : InnerExit->phis())\n    LcssaInnerExit.push_back(&P);\n\n  SmallVector<PHINode *, 8> LcssaInnerLatch;\n  for (PHINode &P : InnerLatch->phis())\n    LcssaInnerLatch.push_back(&P);\n\n  // Lcssa PHIs for values used outside the inner loop are in InnerExit.\n  // If a PHI node has users outside of InnerExit, it has a use outside the\n  // interchanged loop and we have to preserve it. We move these to\n  // InnerLatch, which will become the new exit block for the innermost\n  // loop after interchanging.\n  for (PHINode *P : LcssaInnerExit)\n    P->moveBefore(InnerLatch->getFirstNonPHI());\n\n  // If the inner loop latch contains LCSSA PHIs, those come from a child loop\n  // and we have to move them to the new inner latch.\n  for (PHINode *P : LcssaInnerLatch)\n    P->moveBefore(InnerExit->getFirstNonPHI());\n\n  // Deal with LCSSA PHI nodes in the loop nest exit block. For PHIs that have\n  // incoming values defined in the outer loop, we have to add a new PHI\n  // in the inner loop latch, which became the exit block of the outer loop,\n  // after interchanging.\n  if (OuterExit) {\n    for (PHINode &P : OuterExit->phis()) {\n      if (P.getNumIncomingValues() != 1)\n        continue;\n      // Skip Phis with incoming values defined in the inner loop. Those should\n      // already have been updated.\n      auto I = dyn_cast<Instruction>(P.getIncomingValue(0));\n      if (!I || LI->getLoopFor(I->getParent()) == InnerLoop)\n        continue;\n\n      PHINode *NewPhi = dyn_cast<PHINode>(P.clone());\n      NewPhi->setIncomingValue(0, P.getIncomingValue(0));\n      NewPhi->setIncomingBlock(0, OuterLatch);\n\n>>> [ INFILL ] <<<\n      P.setIncomingValue(0, NewPhi);\n    }\n  }\n\n  // Now adjust the incoming blocks for the LCSSA PHIs.\n  // For PHIs moved from Inner's exit block, we need to replace Inner's latch\n  // with the new latch.\n  InnerLatch->replacePhiUsesWith(InnerLatch, OuterLatch);\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n      NewPhi->insertBefore(InnerLatch->getFirstNonPHI());\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/LoopInterchange/lcssa.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopInterchange/lcssa.ll\n\n\nTesting Time: 1.72s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "3f8be15f2911a3d3645030911be83a115bfe9e5c___LoopInterchange.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nCHRScope * CHR::findScope(Region *R) {\n  CHRScope *Result = nullptr;\n  BasicBlock *Entry = R->getEntry();\n  BasicBlock *Exit = R->getExit();  // null if top level.\n  assert(Entry && \"Entry must not be null\");\n  assert((Exit == nullptr) == (R->isTopLevelRegion()) &&\n         \"Only top level region has a null exit\");\n  if (Entry)\n    CHR_DEBUG(dbgs() << \"Entry \" << Entry->getName() << \"\\n\");\n  else\n    CHR_DEBUG(dbgs() << \"Entry null\\n\");\n  if (Exit)\n    CHR_DEBUG(dbgs() << \"Exit \" << Exit->getName() << \"\\n\");\n  else\n    CHR_DEBUG(dbgs() << \"Exit null\\n\");\n  // Exclude cases where Entry is part of a subregion (hence it doesn't belong\n  // to this region).\n  bool EntryInSubregion = RI.getRegionFor(Entry) != R;\n  if (EntryInSubregion)\n    return nullptr;\n  // Exclude loops\n  for (BasicBlock *Pred : predecessors(Entry))\n    if (R->contains(Pred))\n      return nullptr;\n\n>>> [ INFILL ] <<<\n    // Try to find an if-then block (check if R is an if-then).\n    // if (cond) {\n    //  ...\n    // }\n    auto *BI = dyn_cast<BranchInst>(Entry->getTerminator());\n    if (BI)\n      CHR_DEBUG(dbgs() << \"BI.isConditional \" << BI->isConditional() << \"\\n\");\n    else\n      CHR_DEBUG(dbgs() << \"BI null\\n\");\n    if (BI && BI->isConditional()) {\n      BasicBlock *S0 = BI->getSuccessor(0);\n      BasicBlock *S1 = BI->getSuccessor(1);\n      CHR_DEBUG(dbgs() << \"S0 \" << S0->getName() << \"\\n\");\n      CHR_DEBUG(dbgs() << \"S1 \" << S1->getName() << \"\\n\");\n      if (S0 != S1 && (S0 == Exit || S1 == Exit)) {\n        RegInfo RI(R);\n        RI.HasBranch = checkBiasedBranch(\n            BI, R, TrueBiasedRegionsGlobal, FalseBiasedRegionsGlobal,\n            BranchBiasMap);\n        Result = new CHRScope(RI);\n        Scopes.insert(Result);\n        CHR_DEBUG(dbgs() << \"Found a region with a branch\\n\");\n        ++Stats.NumBranches;\n        if (!RI.HasBranch) {\n          ORE.emit([&]() {\n            return OptimizationRemarkMissed(DEBUG_TYPE, \"BranchNotBiased\", BI)\n                << \"Branch not biased\";\n          });\n        }\n      }\n    }\n  }\n  {\n    // Try to look for selects in the direct child blocks (as opposed to in\n    // subregions) of R.\n    // ...\n    // if (..) { // Some subregion\n    //   ...\n    // }\n    // if (..) { // Some subregion\n    //   ...\n    // }\n    // ...\n    // a = cond ? b : c;\n    // ...\n    SmallVector<SelectInst *, 8> Selects;\n    for (RegionNode *E : R->elements()) {\n      if (E->isSubRegion())\n        continue;\n      // This returns the basic block of E if E is a direct child of R (not a\n      // subregion.)\n      BasicBlock *BB = E->getEntry();\n      // Need to push in the order to make it easier to find the first Select\n      // later.\n      for (Instruction &I : *BB) {\n        if (auto *SI = dyn_cast<SelectInst>(&I)) {\n          Selects.push_back(SI);\n          ++Stats.NumBranches;\n        }\n      }\n    }\n    if (Selects.size() > 0) {\n      auto AddSelects = [&](RegInfo &RI) {\n        for (auto *SI : Selects)\n          if (checkBiasedSelect(SI, RI.R,\n                                TrueBiasedSelectsGlobal,\n                                FalseBiasedSelectsGlobal,\n                                SelectBiasMap))\n            RI.Selects.push_back(SI);\n          else\n            ORE.emit([&]() {\n              return OptimizationRemarkMissed(DEBUG_TYPE, \"SelectNotBiased\", SI)\n                  << \"Select not biased\";\n            });\n      };\n      if (!Result) {\n        CHR_DEBUG(dbgs() << \"Found a select-only region\\n\");\n        RegInfo RI(R);\n        AddSelects(RI);\n        Result = new CHRScope(RI);\n        Scopes.insert(Result);\n      } else {\n        CHR_DEBUG(dbgs() << \"Found select(s) in a region with a branch\\n\");\n        AddSelects(Result->RegInfos[0]);\n      }\n    }\n  }\n\n  if (Result) {\n    checkScopeHoistable(Result);\n  }\n  return Result;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  if (Exit) {\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/PGOProfile/chr.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/PGOProfile/chr.ll\n\n\nTesting Time: 1.05s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "fae7debadcea335d4aaddee82406a8d10426e730___ControlHeightReduction.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\n  bool getPossibleConstants(Argument *A,\n                            SmallVectorImpl<Constant *> &Constants) {\n    Function *F = A->getParent();\n    bool AllConstant = true;\n\n    // Iterate over all the call sites of the argument's parent function.\n    for (User *U : F->users()) {\n      if (!isa<CallInst>(U) && !isa<InvokeInst>(U))\n        continue;\n      auto &CS = *cast<CallBase>(U);\n      // If the call site has attribute minsize set, that callsite won't be\n      // specialized.\n      if (CS.hasFnAttr(Attribute::MinSize)) {\n        AllConstant = false;\n        continue;\n      }\n\n      // If the parent of the call site will never be executed, we don't need\n      // to worry about the passed value.\n      if (!Solver.isBlockExecutable(CS.getParent()))\n        continue;\n\n      auto *V = CS.getArgOperand(A->getArgNo());\n\n>>> [ INFILL ] <<<\n      if (auto *GV = dyn_cast<GlobalVariable>(V)) {\n        // Check if we want to specialize on the address of non-constant\n        // global values.\n        if (!GV->isConstant())\n          if (!SpecializeOnAddresses)\n            return false;\n\n        if (!GV->getValueType()->isSingleValueType())\n          return false;\n      }\n\n      if (isa<Constant>(V) && (Solver.getLatticeValueFor(V).isConstant() ||\n                               EnableSpecializationForLiteralConstant))\n        Constants.push_back(cast<Constant>(V));\n      else\n        AllConstant = false;\n    }\n\n    // If the argument can only take on constant values, AllConstant will be\n    // true.\n    return AllConstant;\n  }\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n      // TrackValueOfGlobalVariable only tracks scalar global variables.\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/FunctionSpecialization/function-specialization-constant-expression.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/FunctionSpecialization/function-specialization-constant-expression.ll\n\n\nTesting Time: 0.79s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/FunctionSpecialization/function-specialization-constant-expression2.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/FunctionSpecialization/function-specialization-constant-expression2.ll\n\n\nTesting Time: 6.59s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/FunctionSpecialization/function-specialization-poison.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/FunctionSpecialization/function-specialization-poison.ll\n\n\nTesting Time: 4.40s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "eba76056a364d206de7f0ac944c8601c988b6405___FunctionSpecialization.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic void addByteCountSuffix(raw_ostream &OS, const Function *F,\n                               const DataLayout &DL) {\n  // Calculate arguments size total.\n  unsigned ArgWords = 0;\n\n  const unsigned PtrSize = DL.getPointerSize();\n\n  for (const Argument &A : F->args()) {\n\n>>> [ INFILL ] <<<\n    uint64_t AllocSize = A.hasPassPointeeByValueCopyAttr() ?\n      A.getPassPointeeByValueCopySize(DL) :\n      DL.getTypeAllocSize(A.getType());\n\n    // Size should be aligned to pointer size.\n    ArgWords += alignTo(AllocSize, PtrSize);\n  }\n\n  OS << '@' << ArgWords;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    // 'Dereference' type in case of byval or inalloca parameter attribute.\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/stdcall.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/stdcall.ll\n\n\nTesting Time: 0.31s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vectorcall.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vectorcall.ll\n\n\nTesting Time: 0.25s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "2dd883439c7886182902c0aa17b34c0a8ed88b66___Mangler.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nbool LazyCallGraph::invalidate(Module &, const PreservedAnalyses &PA,\n                               ModuleAnalysisManager::Invalidator &) {\n  // Check whether the analysis, all analyses on functions, or the function's\n  // CFG have been preserved.\n  auto PAC = PA.getChecker<llvm::LazyCallGraphAnalysis>();\n\n>>> [ INFILL ] <<<\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  return !(PAC.preserved() || PAC.preservedSet<AllAnalysesOn<Module>>() ||\n           PAC.preservedSet<CFGAnalyses>());\n}\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Analysis/LazyCallGraph/invalidate.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Analysis/LazyCallGraph/invalidate.ll\n\n\nTesting Time: 0.30s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "259390de9af659e2432c5b2af041ec6576c1b26d___LazyCallGraph.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic bool canCreateUndefOrPoison(const Operator *Op, bool PoisonOnly,\n                                   bool ConsiderFlags) {\n  if (ConsiderFlags) {\n    // See whether I has flags that may create poison\n    if (const auto *OvOp = dyn_cast<OverflowingBinaryOperator>(Op)) {\n      if (OvOp->hasNoSignedWrap() || OvOp->hasNoUnsignedWrap())\n        return true;\n    }\n    if (const auto *ExactOp = dyn_cast<PossiblyExactOperator>(Op))\n      if (ExactOp->isExact())\n        return true;\n\n>>> [ INFILL ] <<<\n\n  unsigned Opcode = Op->getOpcode();\n\n  // Check whether opcode is a poison/undef-generating operation\n  switch (Opcode) {\n  case Instruction::Shl:\n  case Instruction::AShr:\n  case Instruction::LShr: {\n    // Shifts return poison if shiftwidth is larger than the bitwidth.\n    if (auto *C = dyn_cast<Constant>(Op->getOperand(1))) {\n      SmallVector<Constant *, 4> ShiftAmounts;\n      if (auto *FVTy = dyn_cast<FixedVectorType>(C->getType())) {\n        unsigned NumElts = FVTy->getNumElements();\n        for (unsigned i = 0; i < NumElts; ++i)\n          ShiftAmounts.push_back(C->getAggregateElement(i));\n      } else if (isa<ScalableVectorType>(C->getType()))\n        return true; // Can't tell, just return true to be safe\n      else\n        ShiftAmounts.push_back(C);\n\n      bool Safe = llvm::all_of(ShiftAmounts, [](Constant *C) {\n        auto *CI = dyn_cast_or_null<ConstantInt>(C);\n        return CI && CI->getValue().ult(C->getType()->getIntegerBitWidth());\n      });\n      return !Safe;\n    }\n    return true;\n  }\n  case Instruction::FPToSI:\n  case Instruction::FPToUI:\n    // fptosi/ui yields poison if the resulting value does not fit in the\n    // destination type.\n    return true;\n  case Instruction::Call:\n    if (auto *II = dyn_cast<IntrinsicInst>(Op)) {\n      switch (II->getIntrinsicID()) {\n      // TODO: Add more intrinsics.\n      case Intrinsic::ctpop:\n      case Intrinsic::sadd_with_overflow:\n      case Intrinsic::ssub_with_overflow:\n      case Intrinsic::smul_with_overflow:\n      case Intrinsic::uadd_with_overflow:\n      case Intrinsic::usub_with_overflow:\n      case Intrinsic::umul_with_overflow:\n        return false;\n      }\n    }\n    LLVM_FALLTHROUGH;\n  case Instruction::CallBr:\n  case Instruction::Invoke: {\n    const auto *CB = cast<CallBase>(Op);\n    return !CB->hasRetAttr(Attribute::NoUndef);\n  }\n  case Instruction::InsertElement:\n  case Instruction::ExtractElement: {\n    // If index exceeds the length of the vector, it returns poison\n    auto *VTy = cast<VectorType>(Op->getOperand(0)->getType());\n    unsigned IdxOp = Op->getOpcode() == Instruction::InsertElement ? 2 : 1;\n    auto *Idx = dyn_cast<ConstantInt>(Op->getOperand(IdxOp));\n    if (!Idx || Idx->getValue().uge(VTy->getElementCount().getKnownMinValue()))\n      return true;\n    return false;\n  }\n  case Instruction::ShuffleVector: {\n    // shufflevector may return undef.\n    if (PoisonOnly)\n      return false;\n    ArrayRef<int> Mask = isa<ConstantExpr>(Op)\n                             ? cast<ConstantExpr>(Op)->getShuffleMask()\n                             : cast<ShuffleVectorInst>(Op)->getShuffleMask();\n    return is_contained(Mask, UndefMaskElem);\n  }\n  case Instruction::FNeg:\n  case Instruction::PHI:\n  case Instruction::Select:\n  case Instruction::URem:\n  case Instruction::SRem:\n  case Instruction::ExtractValue:\n  case Instruction::InsertValue:\n  case Instruction::Freeze:\n  case Instruction::ICmp:\n  case Instruction::FCmp:\n    return false;\n  case Instruction::GetElementPtr: {\n    const auto *GEP = cast<GEPOperator>(Op);\n    return GEP->isInBounds();\n  }\n  default: {\n    const auto *CE = dyn_cast<ConstantExpr>(Op);\n    if (isa<CastInst>(Op) || (CE && CE->isCast()))\n      return false;\n    else if (Instruction::isBinaryOp(Opcode))\n      return false;\n    // Be conservative and return true.\n    return true;\n  }\n  }\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    if (const auto *FP = dyn_cast<FPMathOperator>(Op)) {\n      auto FMF = FP->getFastMathFlags();\n      if (FMF.noNaNs() || FMF.noInfs())\n        return true;\n    }\n  }\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/freeze.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/freeze.ll\n\n\nTesting Time: 0.35s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "4c5702cb123b8fd705982c638fb18c999f69d63a___ValueTracking.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nvoid SelectionDAGBuilder::visitRet(const ReturnInst &I) {\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n  auto &DL = DAG.getDataLayout();\n  SDValue Chain = getControlRoot();\n  SmallVector<ISD::OutputArg, 8> Outs;\n  SmallVector<SDValue, 8> OutVals;\n\n  // Calls to @llvm.experimental.deoptimize don't generate a return value, so\n  // lower\n  //\n  //   %val = call <ty> @llvm.experimental.deoptimize()\n  //   ret <ty> %val\n  //\n  // differently.\n  if (I.getParent()->getTerminatingDeoptimizeCall()) {\n    LowerDeoptimizingReturn();\n    return;\n  }\n\n  if (!FuncInfo.CanLowerReturn) {\n    unsigned DemoteReg = FuncInfo.DemoteRegister;\n    const Function *F = I.getParent()->getParent();\n\n    // Emit a store of the return value through the virtual register.\n    // Leave Outs empty so that LowerReturn won't try to load return\n    // registers the usual way.\n    SmallVector<EVT, 1> PtrValueVTs;\n    ComputeValueVTs(TLI, DL,\n                    F->getReturnType()->getPointerTo(\n                        DAG.getDataLayout().getAllocaAddrSpace()),\n                    PtrValueVTs);\n\n\n>>> [ INFILL ] <<<\n\n    SmallVector<EVT, 4> ValueVTs, MemVTs;\n    SmallVector<uint64_t, 4> Offsets;\n    ComputeValueVTs(TLI, DL, I.getOperand(0)->getType(), ValueVTs, &MemVTs,\n                    &Offsets);\n    unsigned NumValues = ValueVTs.size();\n\n    SmallVector<SDValue, 4> Chains(NumValues);\n    Align BaseAlign = DL.getPrefTypeAlign(I.getOperand(0)->getType());\n    for (unsigned i = 0; i != NumValues; ++i) {\n      // An aggregate return value cannot wrap around the address space, so\n      // offsets to its parts don't wrap either.\n      SDValue Ptr = DAG.getObjectPtrOffset(getCurSDLoc(), RetPtr,\n                                           TypeSize::Fixed(Offsets[i]));\n\n      SDValue Val = RetOp.getValue(RetOp.getResNo() + i);\n      if (MemVTs[i] != ValueVTs[i])\n        Val = DAG.getPtrExtOrTrunc(Val, getCurSDLoc(), MemVTs[i]);\n      Chains[i] = DAG.getStore(\n          Chain, getCurSDLoc(), Val,\n          // FIXME: better loc info would be nice.\n          Ptr, MachinePointerInfo::getUnknownStack(DAG.getMachineFunction()),\n          commonAlignment(BaseAlign, Offsets[i]));\n    }\n\n    Chain = DAG.getNode(ISD::TokenFactor, getCurSDLoc(),\n                        MVT::Other, Chains);\n  } else if (I.getNumOperands() != 0) {\n    SmallVector<EVT, 4> ValueVTs;\n    ComputeValueVTs(TLI, DL, I.getOperand(0)->getType(), ValueVTs);\n    unsigned NumValues = ValueVTs.size();\n    if (NumValues) {\n      SDValue RetOp = getValue(I.getOperand(0));\n\n      const Function *F = I.getParent()->getParent();\n\n      bool NeedsRegBlock = TLI.functionArgumentNeedsConsecutiveRegisters(\n          I.getOperand(0)->getType(), F->getCallingConv(),\n          /*IsVarArg*/ false, DL);\n\n      ISD::NodeType ExtendKind = ISD::ANY_EXTEND;\n      if (F->getAttributes().hasRetAttr(Attribute::SExt))\n        ExtendKind = ISD::SIGN_EXTEND;\n      else if (F->getAttributes().hasRetAttr(Attribute::ZExt))\n        ExtendKind = ISD::ZERO_EXTEND;\n\n      LLVMContext &Context = F->getContext();\n      bool RetInReg = F->getAttributes().hasRetAttr(Attribute::InReg);\n\n      for (unsigned j = 0; j != NumValues; ++j) {\n        EVT VT = ValueVTs[j];\n\n        if (ExtendKind != ISD::ANY_EXTEND && VT.isInteger())\n          VT = TLI.getTypeForExtReturn(Context, VT, ExtendKind);\n\n        CallingConv::ID CC = F->getCallingConv();\n\n        unsigned NumParts = TLI.getNumRegistersForCallingConv(Context, CC, VT);\n        MVT PartVT = TLI.getRegisterTypeForCallingConv(Context, CC, VT);\n        SmallVector<SDValue, 4> Parts(NumParts);\n        getCopyToParts(DAG, getCurSDLoc(),\n                       SDValue(RetOp.getNode(), RetOp.getResNo() + j),\n                       &Parts[0], NumParts, PartVT, &I, CC, ExtendKind);\n\n        // 'inreg' on function refers to return value\n        ISD::ArgFlagsTy Flags = ISD::ArgFlagsTy();\n        if (RetInReg)\n          Flags.setInReg();\n\n        if (I.getOperand(0)->getType()->isPointerTy()) {\n          Flags.setPointer();\n          Flags.setPointerAddrSpace(\n              cast<PointerType>(I.getOperand(0)->getType())->getAddressSpace());\n        }\n\n        if (NeedsRegBlock) {\n          Flags.setInConsecutiveRegs();\n          if (j == NumValues - 1)\n            Flags.setInConsecutiveRegsLast();\n        }\n\n        // Propagate extension type if any\n        if (ExtendKind == ISD::SIGN_EXTEND)\n          Flags.setSExt();\n        else if (ExtendKind == ISD::ZERO_EXTEND)\n          Flags.setZExt();\n\n        for (unsigned i = 0; i < NumParts; ++i) {\n          Outs.push_back(ISD::OutputArg(Flags,\n                                        Parts[i].getValueType().getSimpleVT(),\n                                        VT, /*isfixed=*/true, 0, 0));\n          OutVals.push_back(Parts[i]);\n        }\n      }\n    }\n  }\n\n  // Push in swifterror virtual register as the last element of Outs. This makes\n  // sure swifterror virtual register will be returned in the swifterror\n  // physical register.\n  const Function *F = I.getParent()->getParent();\n  if (TLI.supportSwiftError() &&\n      F->getAttributes().hasAttrSomewhere(Attribute::SwiftError)) {\n    assert(SwiftError.getFunctionArg() && \"Need a swift error argument\");\n    ISD::ArgFlagsTy Flags = ISD::ArgFlagsTy();\n    Flags.setSwiftError();\n    Outs.push_back(ISD::OutputArg(\n        Flags, /*vt=*/TLI.getPointerTy(DL), /*argvt=*/EVT(TLI.getPointerTy(DL)),\n        /*isfixed=*/true, /*origidx=*/1, /*partOffs=*/0));\n    // Create SDNode for the swifterror virtual register.\n    OutVals.push_back(\n        DAG.getRegister(SwiftError.getOrCreateVRegUseAt(\n                            &I, FuncInfo.MBB, SwiftError.getFunctionArg()),\n                        EVT(TLI.getPointerTy(DL))));\n  }\n\n  bool isVarArg = DAG.getMachineFunction().getFunction().isVarArg();\n  CallingConv::ID CallConv =\n    DAG.getMachineFunction().getFunction().getCallingConv();\n  Chain = DAG.getTargetLoweringInfo().LowerReturn(\n      Chain, CallConv, isVarArg, Outs, OutVals, getCurSDLoc(), DAG);\n\n  // Verify that the target's LowerReturn behaved as expected.\n  assert(Chain.getNode() && Chain.getValueType() == MVT::Other &&\n         \"LowerReturn didn't return a valid chain!\");\n\n  // Update the DAG with the new chain value resulting from return lowering.\n  DAG.setRoot(Chain);\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    SDValue RetPtr = DAG.getCopyFromReg(DAG.getEntryNode(), getCurSDLoc(),\n                                        DemoteReg, PtrValueVTs[0]);\n    SDValue RetOp = getValue(I.getOperand(0));\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/addcarry.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/addcarry.ll\n\n\nTesting Time: 0.99s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/fp128-cast.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/fp128-cast.ll\n\n\nTesting Time: 2.06s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/i128-add.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/i128-add.ll\n\n\nTesting Time: 0.43s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/masked_load.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/masked_load.ll\n\n\nTesting Time: 2.36s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/mul128.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/mul128.ll\n\n\nTesting Time: 0.56s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/pmulh.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/pmulh.ll\n\n\nTesting Time: 2.22s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/scheduler-backtracking.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/scheduler-backtracking.ll\n\n\nTesting Time: 0.57s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/subcarry.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/subcarry.ll\n\n\nTesting Time: 0.65s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/umul-with-overflow.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/umul-with-overflow.ll\n\n\nTesting Time: 0.86s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/umulo-128-legalisation-lowering.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/umulo-128-legalisation-lowering.ll\n\n\nTesting Time: 0.61s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "b0319ab79bf59669803cc2475fae1d12f8eeaca9___SelectionDAGBuilder.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic void convertToRelLookupTable(GlobalVariable &LookupTable) {\n  GetElementPtrInst *GEP =\n      cast<GetElementPtrInst>(LookupTable.use_begin()->getUser());\n  LoadInst *Load = cast<LoadInst>(GEP->use_begin()->getUser());\n\n  Module &M = *LookupTable.getParent();\n  BasicBlock *BB = GEP->getParent();\n  IRBuilder<> Builder(BB);\n  Function &Func = *BB->getParent();\n\n  // Generate an array that consists of relative offsets.\n  GlobalVariable *RelLookupTable = createRelLookupTable(Func, LookupTable);\n\n  // Place new instruction sequence before GEP.\n  Builder.SetInsertPoint(GEP);\n  Value *Index = GEP->getOperand(2);\n  IntegerType *IntTy = cast<IntegerType>(Index->getType());\n  Value *Offset =\n      Builder.CreateShl(Index, ConstantInt::get(IntTy, 2), \"reltable.shift\");\n\n\n>>> [ INFILL ] <<<\n      &M, Intrinsic::load_relative, {Index->getType()});\n  Value *Base = Builder.CreateBitCast(RelLookupTable, Builder.getInt8PtrTy());\n\n  // Create a call to load.relative intrinsic that computes the target address\n  // by adding base address (lookup table address) and relative offset.\n  Value *Result = Builder.CreateCall(LoadRelIntrinsic, {Base, Offset},\n                                     \"reltable.intrinsic\");\n\n  // Create a bitcast instruction if necessary.\n  if (Load->getType() != Builder.getInt8PtrTy())\n    Result = Builder.CreateBitCast(Result, Load->getType(), \"reltable.bitcast\");\n\n  // Replace load instruction with the new generated instruction sequence.\n  Load->replaceAllUsesWith(Result);\n  // Remove Load and GEP instructions.\n  Load->eraseFromParent();\n  GEP->eraseFromParent();\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  Function *LoadRelIntrinsic = llvm::Intrinsic::getDeclaration(\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/RelLookupTableConverter/X86/relative_lookup_table.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/RelLookupTableConverter/X86/relative_lookup_table.ll\n\n\nTesting Time: 0.34s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "e5a8af7a90c6a9ac46293eb3600029d43d695b8e___RelLookupTableConverter.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic Value *getAvailableLoadStore(Instruction *Inst, const Value *Ptr,\n                                    Type *AccessTy, bool AtLeastAtomic,\n                                    const DataLayout &DL, bool *IsLoadCSE) {\n  // If this is a load of Ptr, the loaded value is available.\n  // (This is true even if the load is volatile or atomic, although\n  // those cases are unlikely.)\n  if (LoadInst *LI = dyn_cast<LoadInst>(Inst)) {\n    // We can value forward from an atomic to a non-atomic, but not the\n    // other way around.\n    if (LI->isAtomic() < AtLeastAtomic)\n      return nullptr;\n\n    Value *LoadPtr = LI->getPointerOperand()->stripPointerCasts();\n    if (!AreEquivalentAddressValues(LoadPtr, Ptr))\n      return nullptr;\n\n    if (CastInst::isBitOrNoopPointerCastable(LI->getType(), AccessTy, DL)) {\n      if (IsLoadCSE)\n        *IsLoadCSE = true;\n      return LI;\n    }\n  }\n\n  // If this is a store through Ptr, the value is available!\n  // (This is true even if the store is volatile or atomic, although\n  // those cases are unlikely.)\n  if (StoreInst *SI = dyn_cast<StoreInst>(Inst)) {\n    // We can value forward from an atomic to a non-atomic, but not the\n    // other way around.\n    if (SI->isAtomic() < AtLeastAtomic)\n      return nullptr;\n\n    Value *StorePtr = SI->getPointerOperand()->stripPointerCasts();\n    if (!AreEquivalentAddressValues(StorePtr, Ptr))\n      return nullptr;\n\n    if (IsLoadCSE)\n      *IsLoadCSE = false;\n\n    Value *Val = SI->getValueOperand();\n    if (CastInst::isBitOrNoopPointerCastable(Val->getType(), AccessTy, DL))\n      return Val;\n\n\n>>> [ INFILL ] <<<\n      if (auto *C = dyn_cast<Constant>(Val))\n        return ConstantFoldLoadFromConst(C, AccessTy, DL);\n  }\n\n  return nullptr;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    TypeSize StoreSize = DL.getTypeStoreSize(Val->getType());\n    TypeSize LoadSize = DL.getTypeStoreSize(AccessTy);\n    if (TypeSize::isKnownLE(LoadSize, StoreSize))\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/load-store-forward.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/load-store-forward.ll\n\n\nTesting Time: 0.39s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "930a68765dff96927d706d258ef0c2ad9c7ec2ab___Loads.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nbool PHITransAddr::PHITranslateValue(BasicBlock *CurBB, BasicBlock *PredBB,\n                                     const DominatorTree *DT,\n                                     bool MustDominate) {\n  assert(DT || !MustDominate);\n  assert(Verify() && \"Invalid PHITransAddr!\");\n  if (DT && DT->isReachableFromEntry(PredBB))\n\n>>> [ INFILL ] <<<\n    Addr = nullptr;\n  assert(Verify() && \"Invalid PHITransAddr!\");\n\n  if (MustDominate)\n    // Make sure the value is live in the predecessor.\n    if (Instruction *Inst = dyn_cast_or_null<Instruction>(Addr))\n      if (!DT->dominates(Inst->getParent(), PredBB))\n        Addr = nullptr;\n\n  return Addr == nullptr;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    Addr =\n        PHITranslateSubExpr(Addr, CurBB, PredBB, MustDominate ? DT : nullptr);\n  else\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/GVN/condprop-memdep-invalidation.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/GVN/condprop-memdep-invalidation.ll\n\n\nTesting Time: 0.33s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/GVN/memdep-unknown-deadblocks.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/GVN/memdep-unknown-deadblocks.ll\n\n\nTesting Time: 0.09s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/GVN/phi-translation-to-wrong-context.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/GVN/phi-translation-to-wrong-context.ll\n\n\nTesting Time: 0.11s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "4f046bc8e0b9439efeb2906ced7930f831495ee4___PHITransAddr.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic Constant *constantFoldCanonicalize(const Type *Ty, const CallBase *CI,\n                                          const APFloat &Src) {\n  // Zero, positive and negative, is always OK to fold.\n  if (Src.isZero()) {\n    // Get a fresh 0, since ppc_fp128 does have non-canonical zeros.\n    return ConstantFP::get(\n        CI->getContext(),\n        APFloat::getZero(Src.getSemantics(), Src.isNegative()));\n  }\n\n  if (!Ty->isIEEELikeFPTy())\n    return nullptr;\n\n  // Zero is always canonical and the sign must be preserved.\n  //\n  // Denorms and nans may have special encodings, but it should be OK to fold a\n  // totally average number.\n  if (Src.isNormal() || Src.isInfinity())\n    return ConstantFP::get(CI->getContext(), Src);\n\n  if (Src.isDenormal() && CI->getParent() && CI->getFunction()) {\n    DenormalMode DenormMode =\n        CI->getFunction()->getDenormalMode(Src.getSemantics());\n    if (DenormMode == DenormalMode::getIEEE())\n      return nullptr;\n\n\n>>> [ INFILL ] <<<\n                           APFloat::getZero(Src.getSemantics(), !IsPositive));\n  }\n\n  return nullptr;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    bool IsPositive = !Src.isNegative() ||\n                      DenormMode.Input == DenormalMode::PositiveZero ||\n                      DenormMode.Output == DenormalMode::PositiveZero;\n    return ConstantFP::get(CI->getContext(),\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstSimplify/canonicalize.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstSimplify/canonicalize.ll\n\n\nTesting Time: 0.40s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "6acf6661dd17af9f9858f3d3ff67eb88f7675d31___ConstantFolding.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nvoid LoopVectorizationPlanner::executePlan(ElementCount BestVF, unsigned BestUF,\n                                           VPlan &BestVPlan,\n                                           InnerLoopVectorizer &ILV,\n                                           DominatorTree *DT,\n                                           bool IsEpilogueVectorization) {\n  assert(BestVPlan.hasVF(BestVF) &&\n         \"Trying to execute plan with unsupported VF\");\n  assert(BestVPlan.hasUF(BestUF) &&\n         \"Trying to execute plan with unsupported UF\");\n\n  LLVM_DEBUG(dbgs() << \"Executing best plan with VF=\" << BestVF << \", UF=\" << BestUF\n                    << '\\n');\n\n  // Workaround!  Compute the trip count of the original loop and cache it\n  // before we start modifying the CFG.  This code has a systemic problem\n  // wherein it tries to run analysis over partially constructed IR; this is\n  // wrong, and not simply for SCEV.  The trip count of the original loop\n  // simply happens to be prone to hitting this in practice.  In theory, we\n  // can hit the same issue for any SCEV, or ValueTracking query done during\n  // mutation.  See PR49900.\n  ILV.getOrCreateTripCount(OrigLoop->getLoopPreheader());\n\n  if (!IsEpilogueVectorization)\n    VPlanTransforms::optimizeForVFAndUF(BestVPlan, BestVF, BestUF, PSE);\n\n  // Perform the actual loop transformation.\n\n  // 1. Set up the skeleton for vectorization, including vector pre-header and\n  // middle block. The vector loop is created during VPlan execution.\n  VPTransformState State{BestVF, BestUF, LI, DT, ILV.Builder, &ILV, &BestVPlan};\n  Value *CanonicalIVStartValue;\n  std::tie(State.CFG.PrevBB, CanonicalIVStartValue) =\n      ILV.createVectorizedLoopSkeleton();\n\n  // Only use noalias metadata when using memory checks guaranteeing no overlap\n  // across all iterations.\n  const LoopAccessInfo *LAI = ILV.Legal->getLAI();\n  if (LAI && !LAI->getRuntimePointerChecking()->getChecks().empty() &&\n      !LAI->getRuntimePointerChecking()->getDiffChecks()) {\n\n    //  We currently don't use LoopVersioning for the actual loop cloning but we\n    //  still use it to add the noalias metadata.\n    //  TODO: Find a better way to re-use LoopVersioning functionality to add\n    //        metadata.\n    State.LVer = std::make_unique<LoopVersioning>(\n        *LAI, LAI->getRuntimePointerChecking()->getChecks(), OrigLoop, LI, DT,\n        PSE.getSE());\n    State.LVer->prepareNoAliasMetadata();\n  }\n\n  ILV.collectPoisonGeneratingRecipes(State);\n\n  ILV.printDebugTracesAtStart();\n\n  //===------------------------------------------------===//\n  //\n  // Notice: any optimization or new instruction that go\n  // into the code below should also be implemented in\n  // the cost-model.\n  //\n  //===------------------------------------------------===//\n\n  // 2. Copy and widen instructions from the old loop into the new loop.\n  BestVPlan.prepareToExecute(ILV.getOrCreateTripCount(nullptr),\n                             ILV.getOrCreateVectorTripCount(nullptr),\n                             CanonicalIVStartValue, State,\n                             IsEpilogueVectorization);\n\n  BestVPlan.execute(&State);\n\n  // Keep all loop hints from the original loop on the vector loop (we'll\n  // replace the vectorizer-specific hints below).\n  MDNode *OrigLoopID = OrigLoop->getLoopID();\n\n  std::optional<MDNode *> VectorizedLoopID =\n      makeFollowupLoopID(OrigLoopID, {LLVMLoopVectorizeFollowupAll,\n                                      LLVMLoopVectorizeFollowupVectorized});\n\n  VPBasicBlock *HeaderVPBB =\n      BestVPlan.getVectorLoopRegion()->getEntryBasicBlock();\n  Loop *L = LI->getLoopFor(State.CFG.VPBB2IRBB[HeaderVPBB]);\n  if (VectorizedLoopID)\n    L->setLoopID(*VectorizedLoopID);\n  else {\n    // Keep all loop hints from the original loop on the vector loop (we'll\n    // replace the vectorizer-specific hints below).\n    if (MDNode *LID = OrigLoop->getLoopID())\n      L->setLoopID(LID);\n\n    LoopVectorizeHints Hints(L, true, *ORE);\n    Hints.setAlreadyVectorized();\n  }\n\n>>> [ INFILL ] <<<\n  // 3. Fix the vectorized code: take care of header phi's, live-outs,\n  //    predication, updating analyses.\n  ILV.fixVectorizedLoop(State, BestVPlan);\n\n  ILV.printDebugTracesAtEnd();\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  // Disable runtime unrolling when vectorizing the epilogue loop.\n  if (CanonicalIVStartValue)\n    AddRuntimeUnrollDisableMetaData(L);\n\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/LoopVectorize/X86/already-vectorized.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/X86/already-vectorized.ll\n\n\nTesting Time: 0.23s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopVectorize/X86/float-induction-x86.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/X86/float-induction-x86.ll\n\n\nTesting Time: 0.44s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nPASS: LLVM :: Transforms/LoopVectorize/X86/gather_scatter.ll (1 of 1)\n\nTesting Time: 0.42s\n  Passed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopVectorize/X86/invariant-load-gather.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/X86/invariant-load-gather.ll\n\n\nTesting Time: 0.26s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopVectorize/X86/invariant-store-vectorization.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/X86/invariant-store-vectorization.ll\n\n\nTesting Time: 0.35s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopVectorize/X86/masked_load_store.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/X86/masked_load_store.ll\n\n\nTesting Time: 0.68s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nPASS: LLVM :: Transforms/LoopVectorize/X86/metadata-enable.ll (1 of 1)\n\nTesting Time: 3.78s\n  Passed: 1\n-- Testing: 1 tests, 1 workers --\nPASS: LLVM :: Transforms/LoopVectorize/X86/tail_loop_folding.ll (1 of 1)\n\nTesting Time: 0.76s\n  Passed: 1\n-- Testing: 1 tests, 1 workers --\nPASS: LLVM :: Transforms/LoopVectorize/X86/uniform_mem_op.ll (1 of 1)\n\nTesting Time: 0.34s\n  Passed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopVectorize/followup.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/followup.ll\n\n\nTesting Time: 0.44s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopVectorize/if-p \nPlease provide the correct line following commit message at the infill location."}], "idx": "68469a80cb7468c577701d725a56a86454b8f0cb___LoopVectorize.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic bool checkBitcastSrcVectorSize(SDValue Src, unsigned Size,\n                                      bool AllowTruncate) {\n  switch (Src.getOpcode()) {\n  case ISD::TRUNCATE:\n    if (!AllowTruncate)\n      return false;\n    [[fallthrough]];\n  case ISD::SETCC:\n    return Src.getOperand(0).getValueSizeInBits() == Size;\n  case ISD::AND:\n  case ISD::XOR:\n  case ISD::OR:\n    return checkBitcastSrcVectorSize(Src.getOperand(0), Size, AllowTruncate) &&\n           checkBitcastSrcVectorSize(Src.getOperand(1), Size, AllowTruncate);\n  case ISD::VSELECT:\n    return Src.getOperand(0).getScalarValueSizeInBits() == 1 &&\n           checkBitcastSrcVectorSize(Src.getOperand(1), Size, AllowTruncate) &&\n           checkBitcastSrcVectorSize(Src.getOperand(2), Size, AllowTruncate);\n  case ISD::BUILD_VECTOR:\n\n>>> [ INFILL ] <<<\n  return false;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    return ISD::isBuildVectorAllZeros(Src.getNode());\n\n  }\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/bitcast-and-setcc-256.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/bitcast-and-setcc-256.ll\n\n\nTesting Time: 0.74s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "7b54a29c2e72e3e6bf7bb8cb5acfe254335584d7___X86ISelLowering.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic Value *getStrideFromPointer(Value *Ptr, ScalarEvolution *SE, Loop *Lp) {\n  auto *PtrTy = dyn_cast<PointerType>(Ptr->getType());\n  if (!PtrTy || PtrTy->isAggregateType())\n    return nullptr;\n\n  // Try to remove a gep instruction to make the pointer (actually index at this\n  // point) easier analyzable. If OrigPtr is equal to Ptr we are analyzing the\n  // pointer, otherwise, we are analyzing the index.\n  Value *OrigPtr = Ptr;\n\n  // The size of the pointer access.\n  int64_t PtrAccessSize = 1;\n\n  Ptr = stripGetElementPtr(Ptr, SE, Lp);\n  const SCEV *V = SE->getSCEV(Ptr);\n\n  if (Ptr != OrigPtr)\n    // Strip off casts.\n    while (const SCEVIntegralCastExpr *C = dyn_cast<SCEVIntegralCastExpr>(V))\n      V = C->getOperand();\n\n  const SCEVAddRecExpr *S = dyn_cast<SCEVAddRecExpr>(V);\n  if (!S)\n    return nullptr;\n\n\n>>> [ INFILL ] <<<\n  if (!V)\n    return nullptr;\n\n  // Strip off the size of access multiplication if we are still analyzing the\n  // pointer.\n  if (OrigPtr == Ptr) {\n    if (const SCEVMulExpr *M = dyn_cast<SCEVMulExpr>(V)) {\n      if (M->getOperand(0)->getSCEVType() != scConstant)\n        return nullptr;\n\n      const APInt &APStepVal = cast<SCEVConstant>(M->getOperand(0))->getAPInt();\n\n      // Huge step value - give up.\n      if (APStepVal.getBitWidth() > 64)\n        return nullptr;\n\n      int64_t StepVal = APStepVal.getSExtValue();\n      if (PtrAccessSize != StepVal)\n        return nullptr;\n      V = M->getOperand(1);\n    }\n  }\n\n  // Strip off casts.\n  Type *StripedOffRecurrenceCast = nullptr;\n  if (const SCEVIntegralCastExpr *C = dyn_cast<SCEVIntegralCastExpr>(V)) {\n    StripedOffRecurrenceCast = C->getType();\n    V = C->getOperand();\n  }\n\n  // Look for the loop invariant symbolic value.\n  const SCEVUnknown *U = dyn_cast<SCEVUnknown>(V);\n  if (!U)\n    return nullptr;\n\n  Value *Stride = U->getValue();\n  if (!Lp->isLoopInvariant(Stride))\n    return nullptr;\n\n  // If we have stripped off the recurrence cast we have to make sure that we\n  // return the value that is used in this loop so that we can replace it later.\n  if (StripedOffRecurrenceCast)\n    Stride = getUniqueCastUse(Stride, Lp, StripedOffRecurrenceCast);\n\n  return Stride;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  V = S->getStepRecurrence(*SE);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/LoopVectorize/vector-no-scevcheck.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/vector-no-scevcheck.ll\n\n\nTesting Time: 0.37s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "9cf1881f8f12a70c28432278a2878a6113c017c1___LoopAccessAnalysis.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nbool SimplifyIndvar::makeIVComparisonInvariant(ICmpInst *ICmp,\n                                               Instruction *IVOperand) {\n  auto *Preheader = L->getLoopPreheader();\n  if (!Preheader)\n    return false;\n  unsigned IVOperIdx = 0;\n  ICmpInst::Predicate Pred = ICmp->getPredicate();\n  if (IVOperand != ICmp->getOperand(0)) {\n    // Swapped\n    assert(IVOperand == ICmp->getOperand(1) && \"Can't find IVOperand\");\n    IVOperIdx = 1;\n    Pred = ICmpInst::getSwappedPredicate(Pred);\n  }\n\n  // Get the SCEVs for the ICmp operands (in the specific context of the\n  // current loop)\n  const Loop *ICmpLoop = LI->getLoopFor(ICmp->getParent());\n  const SCEV *S = SE->getSCEVAtScope(ICmp->getOperand(IVOperIdx), ICmpLoop);\n  const SCEV *X = SE->getSCEVAtScope(ICmp->getOperand(1 - IVOperIdx), ICmpLoop);\n  auto LIP = SE->getLoopInvariantPredicate(Pred, S, X, L, ICmp);\n  if (!LIP)\n    return false;\n  ICmpInst::Predicate InvariantPredicate = LIP->Pred;\n  const SCEV *InvariantLHS = LIP->LHS;\n  const SCEV *InvariantRHS = LIP->RHS;\n\n  // Do not generate something ridiculous.\n  auto *PHTerm = Preheader->getTerminator();\n\n>>> [ INFILL ] <<<\n  auto *NewLHS =\n      Rewriter.expandCodeFor(InvariantLHS, IVOperand->getType(), PHTerm);\n  auto *NewRHS =\n      Rewriter.expandCodeFor(InvariantRHS, IVOperand->getType(), PHTerm);\n  LLVM_DEBUG(dbgs() << \"INDVARS: Simplified comparison: \" << *ICmp << '\\n');\n  ICmp->setPredicate(InvariantPredicate);\n  ICmp->setOperand(0, NewLHS);\n  ICmp->setOperand(1, NewRHS);\n  return true;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  if (Rewriter.isHighCostExpansion({ InvariantLHS, InvariantRHS }, L,\n                                   2 * SCEVCheapExpansionBudget, TTI, PHTerm))\n    return false;\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/IndVarSimplify/pr62992.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/IndVarSimplify/pr62992.ll\n\n\nTesting Time: 0.36s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "dc81e69eb126ea1dbab202733ae34b1a3d6eb0cf___SimplifyIndVar.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\n  bool checkUse(Attributor &A, AANoCapture::StateType &State, const Use &U,\n                bool &Follow) {\n    Instruction *UInst = cast<Instruction>(U.getUser());\n    LLVM_DEBUG(dbgs() << \"[AANoCapture] Check use: \" << *U.get() << \" in \"\n                      << *UInst << \"\\n\");\n\n    // Deal with ptr2int by following uses.\n    if (isa<PtrToIntInst>(UInst)) {\n      LLVM_DEBUG(dbgs() << \" - ptr2int assume the worst!\\n\");\n      return isCapturedIn(State, /* Memory */ true, /* Integer */ true,\n                          /* Return */ true);\n    }\n\n    // For stores we already checked if we can follow them, if they make it\n    // here we give up.\n    if (isa<StoreInst>(UInst))\n\n>>> [ INFILL ] <<<\n    // Explicitly catch return instructions.\n    if (isa<ReturnInst>(UInst)) {\n      if (UInst->getFunction() == getAnchorScope())\n        return isCapturedIn(State, /* Memory */ false, /* Integer */ false,\n                            /* Return */ true);\n      return isCapturedIn(State, /* Memory */ true, /* Integer */ true,\n                          /* Return */ true);\n    }\n\n    // For now we only use special logic for call sites. However, the tracker\n    // itself knows about a lot of other non-capturing cases already.\n    auto *CB = dyn_cast<CallBase>(UInst);\n    if (!CB || !CB->isArgOperand(&U))\n      return isCapturedIn(State, /* Memory */ true, /* Integer */ true,\n                          /* Return */ true);\n\n    unsigned ArgNo = CB->getArgOperandNo(&U);\n    const IRPosition &CSArgPos = IRPosition::callsite_argument(*CB, ArgNo);\n    // If we have a abstract no-capture attribute for the argument we can use\n    // it to justify a non-capture attribute here. This allows recursion!\n    bool IsKnownNoCapture;\n    const AANoCapture *ArgNoCaptureAA = nullptr;\n    bool IsAssumedNoCapture = AA::hasAssumedIRAttr<Attribute::NoCapture>(\n        A, this, CSArgPos, DepClassTy::REQUIRED, IsKnownNoCapture, false,\n        &ArgNoCaptureAA);\n    if (IsAssumedNoCapture)\n      return isCapturedIn(State, /* Memory */ false, /* Integer */ false,\n                          /* Return */ false);\n    if (ArgNoCaptureAA && ArgNoCaptureAA->isAssumedNoCaptureMaybeReturned()) {\n      Follow = true;\n      return isCapturedIn(State, /* Memory */ false, /* Integer */ false,\n                          /* Return */ false);\n    }\n\n    // Lastly, we could not find a reason no-capture can be assumed so we don't.\n    return isCapturedIn(State, /* Memory */ true, /* Integer */ true,\n                        /* Return */ true);\n  }\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n      return isCapturedIn(State, /* Memory */ true, /* Integer */ false,\n                          /* Return */ false);\n\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/Attributor/nocapture-2.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/Attributor/nocapture-2.ll\n\n\nTesting Time: 1.05s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "5a406b63e9d70225cd56fd5c3b791e78f4aed3cc___AttributorAttributes.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic void updateBranchWeights(Instruction *Term, WeightInfo &Info) {\n  MDBuilder MDB(Term->getContext());\n  Term->setMetadata(LLVMContext::MD_prof,\n                    MDB.createBranchWeights(Info.Weights));\n  for (auto [Idx, SubWeight] : enumerate(Info.SubWeights))\n    if (SubWeight != 0)\n\n>>> [ INFILL ] <<<\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n      Info.Weights[Idx] = Info.Weights[Idx] > SubWeight\n                              ? Info.Weights[Idx] - SubWeight\n                              : 1;\n}\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/LoopUnroll/peel-loop-pgo-deopt.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopUnroll/peel-loop-pgo-deopt.ll\n\n\nTesting Time: 2.08s\n\nTotal Discovered Tests: 1\n  Failed: 1 (100.00%)\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/LoopUnroll/peel-loop-pgo.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopUnroll/peel-loop-pgo.ll\n\n\nTesting Time: 0.59s\n\nTotal Discovered Tests: 1\n  Failed: 1 (100.00%)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "e8d5db206c2f5c4afac8288ab96193a5638270ae___LoopPeel.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic Instruction *foldNestedSelects(SelectInst &OuterSelVal,\n                                      InstCombiner::BuilderTy &Builder) {\n  // We must start with a `select`.\n  DecomposedSelect OuterSel;\n  match(&OuterSelVal,\n        m_Select(m_Value(OuterSel.Cond), m_Value(OuterSel.TrueVal),\n                 m_Value(OuterSel.FalseVal)));\n\n  // Canonicalize inversion of the outermost `select`'s condition.\n  if (match(OuterSel.Cond, m_Not(m_Value(OuterSel.Cond))))\n    std::swap(OuterSel.TrueVal, OuterSel.FalseVal);\n\n  // The condition of the outermost select must be an `and`/`or`.\n  if (!match(OuterSel.Cond, m_c_LogicalOp(m_Value(), m_Value())))\n    return nullptr;\n\n  // Depending on the logical op, inner select might be in different hand.\n  bool IsAndVariant = match(OuterSel.Cond, m_LogicalAnd());\n  Value *InnerSelVal = IsAndVariant ? OuterSel.FalseVal : OuterSel.TrueVal;\n\n  // Profitability check - avoid increasing instruction count.\n  if (none_of(ArrayRef<Value *>({OuterSelVal.getCondition(), InnerSelVal}),\n              [](Value *V) { return V->hasOneUse(); }))\n    return nullptr;\n\n  // The appropriate hand of the outermost `select` must be a select itself.\n  DecomposedSelect InnerSel;\n  if (!match(InnerSelVal,\n             m_Select(m_Value(InnerSel.Cond), m_Value(InnerSel.TrueVal),\n                      m_Value(InnerSel.FalseVal))))\n    return nullptr;\n\n  // Canonicalize inversion of the innermost `select`'s condition.\n  if (match(InnerSel.Cond, m_Not(m_Value(InnerSel.Cond))))\n    std::swap(InnerSel.TrueVal, InnerSel.FalseVal);\n\n  Value *AltCond = nullptr;\n\n>>> [ INFILL ] <<<\n\n  // Finally, match the condition that was driving the outermost `select`,\n  // it should be a logical operation between the condition that was driving\n  // the innermost `select` (after accounting for the possible inversions\n  // of the condition), and some other condition.\n  if (matchOuterCond(m_Specific(InnerSel.Cond))) {\n    // Done!\n  } else if (Value * NotInnerCond; matchOuterCond(m_CombineAnd(\n                 m_Not(m_Specific(InnerSel.Cond)), m_Value(NotInnerCond)))) {\n    // Done!\n    std::swap(InnerSel.TrueVal, InnerSel.FalseVal);\n    InnerSel.Cond = NotInnerCond;\n  } else // Not the pattern we were looking for.\n    return nullptr;\n\n  Value *SelInner = Builder.CreateSelect(\n      AltCond, IsAndVariant ? OuterSel.TrueVal : InnerSel.FalseVal,\n      IsAndVariant ? InnerSel.TrueVal : OuterSel.FalseVal);\n  SelInner->takeName(InnerSelVal);\n  return SelectInst::Create(InnerSel.Cond,\n                            IsAndVariant ? SelInner : InnerSel.TrueVal,\n                            !IsAndVariant ? SelInner : InnerSel.FalseVal);\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  auto matchOuterCond = [OuterSel, &AltCond](auto m_InnerCond) {\n    return match(OuterSel.Cond, m_c_LogicalOp(m_InnerCond, m_Value(AltCond)));\n  };\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/pr71330.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/pr71330.ll\n\n\nTesting Time: 0.35s\n\nTotal Discovered Tests: 1\n  Failed: 1 (100.00%)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "9ef829097bbc4cf908698e3891af11a154e1d3e2___InstCombineSelect.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nconst Value *GCProjectionInst::getStatepoint() const {\n  const Value *Token = getArgOperand(0);\n  if (isa<UndefValue>(Token))\n    return Token;\n\n\n>>> [ INFILL ] <<<\n  // on normal path of invoke statepoint.\n  if (!isa<LandingPadInst>(Token))\n    return cast<GCStatepointInst>(Token);\n\n  // This relocate is on exceptional path of an invoke statepoint\n  const BasicBlock *InvokeBB =\n    cast<Instruction>(Token)->getParent()->getUniquePredecessor();\n\n  assert(InvokeBB && \"safepoints should have unique landingpads\");\n  assert(InvokeBB->getTerminator() &&\n         \"safepoint block should be well formed\");\n\n  return cast<GCStatepointInst>(InvokeBB->getTerminator());\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  // This takes care both of relocates for call statepoints and relocates\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Verifier/gc_none_token.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Verifier/gc_none_token.ll\n\n\nTesting Time: 5.12s\n\nTotal Discovered Tests: 1\n  Failed: 1 (100.00%)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "44af5924b1cbbb395e7e71250a5445053c4ec4a3___IntrinsicInst.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic void getConfigs(const simplecpp::TokenList &tokens, std::set<std::string> &defined, const std::string &userDefines, const std::set<std::string> &undefined, std::set<std::string> &ret)\n{\n    std::vector<std::string> configs_if;\n    std::vector<std::string> configs_ifndef;\n    std::string elseError;\n\n    for (const simplecpp::Token *tok = tokens.cfront(); tok; tok = tok->next) {\n        if (tok->op != '#' || sameline(tok->previous, tok))\n            continue;\n        const simplecpp::Token *cmdtok = tok->next;\n        if (!sameline(tok, cmdtok))\n            continue;\n        if (cmdtok->str == \"ifdef\" || cmdtok->str == \"ifndef\" || cmdtok->str == \"if\") {\n            std::string config;\n            if (cmdtok->str == \"ifdef\" || cmdtok->str == \"ifndef\") {\n                const simplecpp::Token *expr1 = cmdtok->next;\n                if (sameline(tok,expr1) && expr1->name && !sameline(tok,expr1->next))\n                    config = expr1->str;\n                if (defined.find(config) != defined.end())\n                    config.clear();\n            } else if (cmdtok->str == \"if\") {\n                config = readcondition(cmdtok, defined, undefined);\n            }\n\n            // skip undefined configurations..\n            if (isUndefined(config, undefined))\n                config.clear();\n\n            configs_if.push_back((cmdtok->str == \"ifndef\") ? std::string() : config);\n            configs_ifndef.push_back((cmdtok->str == \"ifndef\") ? config : std::string());\n            ret.insert(cfg(configs_if,userDefines));\n        } else if (cmdtok->str == \"elif\" || cmdtok->str == \"else\") {\n            if (getConfigsElseIsFalse(configs_if,userDefines)) {\n                tok = gotoEndIf(tok);\n                if (!tok)\n                    break;\n                tok = tok->previous;\n                continue;\n            }\n            if (cmdtok->str == \"else\" &&\n                cmdtok->next &&\n                !sameline(cmdtok,cmdtok->next) &&\n                sameline(cmdtok->next, cmdtok->next->next) &&\n                cmdtok->next->op == '#' &&\n                cmdtok->next->next->str == \"error\") {\n\n>>> [ INFILL ] <<<\n            if (!configs_if.empty())\n                configs_if.pop_back();\n            if (cmdtok->str == \"elif\") {\n                std::string config = readcondition(cmdtok, defined, undefined);\n                if (isUndefined(config,undefined))\n                    config.clear();\n                configs_if.push_back(config);\n                ret.insert(cfg(configs_if, userDefines));\n            } else if (!configs_ifndef.empty()) {\n                configs_if.push_back(configs_ifndef.back());\n                ret.insert(cfg(configs_if, userDefines));\n            }\n        } else if (cmdtok->str == \"endif\" && !sameline(tok, cmdtok->next)) {\n            if (!configs_if.empty())\n                configs_if.pop_back();\n            if (!configs_ifndef.empty())\n                configs_ifndef.pop_back();\n        } else if (cmdtok->str == \"error\") {\n            if (!configs_ifndef.empty() && !configs_ifndef.back().empty()) {\n                if (configs_ifndef.size() == 1U)\n                    ret.erase(\"\");\n                std::vector<std::string> configs(configs_if);\n                configs.push_back(configs_ifndef.back());\n                ret.erase(cfg(configs, userDefines));\n                if (!elseError.empty())\n                    elseError += ';';\n                elseError += cfg(configs_ifndef, userDefines);\n            }\n            if (!configs_if.empty() && !configs_if.back().empty()) {\n                const std::string &last = configs_if.back();\n                if (last.size() > 2U && last.compare(last.size()-2U,2,\"=0\") == 0) {\n                    std::vector<std::string> configs(configs_if);\n                    ret.erase(cfg(configs, userDefines));\n                    configs[configs.size() - 1U] = last.substr(0,last.size()-2U);\n                    if (configs.size() == 1U)\n                        ret.erase(\"\");\n                    if (!elseError.empty())\n                        elseError += ';';\n                    elseError += cfg(configs, userDefines);\n                }\n            }\n        } else if (cmdtok->str == \"define\" && sameline(tok, cmdtok->next) && cmdtok->next->name) {\n            defined.insert(cmdtok->next->str);\n        }\n    }\n    if (!elseError.empty())\n        ret.insert(elseError);\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n                if (!elseError.empty())\n                    elseError += ';';\n                elseError += cfg(configs_if, userDefines);\n            }\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_099b4435c38dd52ddb38e6b1706d9c988699c082/build_099b4435c38dd52ddb38e6b1706d9c988699c082\nTest project /out/danmar___cppcheck/git_repo_dir_099b4435c38dd52ddb38e6b1706d9c988699c082/build_099b4435c38dd52ddb38e6b1706d9c988699c082\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   14.38 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  14.39 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "099b4435c38dd52ddb38e6b1706d9c988699c082___preprocessor.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nconst Token* CheckUninitVar::checkLoopBodyRecursive(const Token *start, const Variable& var, const Alloc alloc, const std::string &membervar, bool &bailout) const\n{\n    assert(start->str() == \"{\");\n\n    const Token *errorToken = nullptr;\n\n    const Token *const end = start->link();\n    for (const Token *tok = start->next(); tok != end; tok = tok->next()) {\n        // skip sizeof / offsetof\n        if (isSizeOfEtc(tok)) {\n            tok = tok->linkAt(1);\n            continue;\n        }\n\n        if (Token::Match(tok, \"asm ( %str% ) ;\")) {\n            bailout = true;\n            return nullptr;\n        }\n\n        // for loop; skip third expression until loop body has been analyzed..\n        if (tok->str() == \";\" && Token::simpleMatch(tok->astParent(), \";\") && Token::simpleMatch(tok->astParent()->astParent(), \"(\")) {\n            const Token *top = tok->astParent()->astParent();\n            if (!Token::simpleMatch(top->previous(), \"for (\") || !Token::simpleMatch(top->link(), \") {\"))\n                continue;\n            const Token *bodyStart = top->link()->next();\n            const Token *errorToken1 = checkLoopBodyRecursive(bodyStart, var, alloc, membervar, bailout);\n\n>>> [ INFILL ] <<<\n                return nullptr;\n        }\n        // for loop; skip loop body if there is third expression\n        if (Token::simpleMatch(tok, \") {\") &&\n            Token::simpleMatch(tok->link()->previous(), \"for (\") &&\n            Token::simpleMatch(tok->link()->astOperand2(), \";\")  &&\n            Token::simpleMatch(tok->link()->astOperand2()->astOperand2(), \";\")) {\n            tok = tok->linkAt(1);\n        }\n\n        if (tok->str() == \"{\") {\n            // switch => bailout\n            if (tok->scope() && tok->scope()->type == Scope::ScopeType::eSwitch) {\n                bailout = true;\n                return nullptr;\n            }\n\n            const Token *errorToken1 = checkLoopBodyRecursive(tok, var, alloc, membervar, bailout);\n            tok = tok->link();\n            if (Token::simpleMatch(tok, \"} else {\")) {\n                const Token *elseBody = tok->tokAt(2);\n                const Token *errorToken2 = checkLoopBodyRecursive(elseBody, var, alloc, membervar, bailout);\n                tok = elseBody->link();\n                if (errorToken1 && errorToken2)\n                    return errorToken1;\n                if (errorToken2)\n                    errorToken = errorToken2;\n            }\n            if (bailout)\n                return nullptr;\n            if (!errorToken)\n                errorToken = errorToken1;\n        }\n\n        if (tok->varId() != var.declarationId())\n            continue;\n\n        bool conditionalUsage = false;\n        for (const Token* parent = tok; parent; parent = parent->astParent()) {\n            if (Token::Match(parent->astParent(), \"%oror%|&&|?\") && astIsRHS(parent)) {\n                conditionalUsage = true;\n                break;\n            }\n        }\n\n        if (!membervar.empty()) {\n            if (isMemberVariableAssignment(tok, membervar)) {\n                bool assign = true;\n                bool rhs = false;\n                // Used for tracking if an \")\" is inner or outer\n                const Token *rpar = nullptr;\n                for (const Token *tok2 = tok->next(); tok2; tok2 = tok2->next()) {\n                    if (tok2->str() == \"=\")\n                        rhs = true;\n\n                    // Look at inner expressions but not outer expressions\n                    if (!rpar && tok2->str() == \"(\")\n                        rpar = tok2->link();\n                    else if (tok2->str() == \")\") {\n                        // No rpar => this is an outer right parenthesis\n                        if (!rpar)\n                            break;\n                        if (rpar == tok2)\n                            rpar = nullptr;\n                    }\n\n                    if (tok2->str() == \";\" || (!rpar && tok2->str() == \",\"))\n                        break;\n                    if (rhs && tok2->varId() == var.declarationId() && isMemberVariableUsage(tok2, var.isPointer(), alloc, membervar)) {\n                        assign = false;\n                        break;\n                    }\n                }\n                if (assign) {\n                    bailout = true;\n                    return nullptr;\n                }\n            }\n            if (isMemberVariableUsage(tok, var.isPointer(), alloc, membervar)) {\n                if (!conditionalUsage)\n                    return tok;\n                if (!errorToken)\n                    errorToken = tok;\n            } else if (Token::Match(tok->previous(), \"[(,] %name% [,)]\")) {\n                bailout = true;\n                return nullptr;\n            }\n        } else {\n            if (const Token *errtok = isVariableUsage(tok, var.isPointer(), alloc)) {\n                if (!conditionalUsage)\n                    return errtok;\n                if (!errorToken)\n                    errorToken = errtok;\n            } else if (tok->strAt(1) == \"=\") {\n                bool varIsUsedInRhs = false;\n                visitAstNodes(tok->next()->astOperand2(), [&](const Token * t) {\n                    if (!t)\n                        return ChildrenToVisit::none;\n                    if (t->varId() == var.declarationId()) {\n                        varIsUsedInRhs = true;\n                        return ChildrenToVisit::done;\n                    }\n                    if (isSizeOfEtc(t->previous()))\n                        return ChildrenToVisit::none;\n                    return ChildrenToVisit::op1_and_op2;\n                });\n                if (!varIsUsedInRhs) {\n                    bailout = true;\n                    return nullptr;\n                }\n            } else {\n                bailout = true;\n                return nullptr;\n            }\n        }\n    }\n\n    return errorToken;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n            if (errorToken1)\n                return errorToken1;\n            if (bailout)\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_4ad90bf6f1cb0149c79324dff027cf8558c041c1/build_4ad90bf6f1cb0149c79324dff027cf8558c041c1\nTest project /out/danmar___cppcheck/git_repo_dir_4ad90bf6f1cb0149c79324dff027cf8558c041c1/build_4ad90bf6f1cb0149c79324dff027cf8558c041c1\n    Start 55: TestUninitVar\n1/1 Test #55: TestUninitVar ....................***Failed    1.26 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.27 sec\n\nThe following tests FAILED:\n\t 55 - TestUninitVar (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "4ad90bf6f1cb0149c79324dff027cf8558c041c1___checkuninitvar.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nbool Tokenizer::simplifyTokenList2()\n{\n    // clear the _functionList so it can't contain dead pointers\n    deleteSymbolDatabase();\n\n    // Clear AST,ValueFlow. These will be created again at the end of this function.\n    for (Token *tok = list.front(); tok; tok = tok->next()) {\n        tok->clearAst();\n        tok->clearValueFlow();\n    }\n\n    // f(x=g())   =>   x=g(); f(x)\n    simplifyAssignmentInFunctionCall();\n\n    // \";a+=b;\" => \";a=a+b;\"\n    simplifyCompoundAssignment();\n\n    simplifyCharAt();\n\n    // simplify references\n    simplifyReference();\n\n    simplifyStd();\n\n    if (_settings->terminated())\n        return false;\n\n    simplifySizeof();\n\n    simplifyUndefinedSizeArray();\n\n    simplifyCasts();\n\n    // Simplify simple calculations before replace constants, this allows the replacement of constants that are calculated\n    // e.g. const static int value = sizeof(X)/sizeof(Y);\n    simplifyCalculations();\n\n    if (_settings->terminated())\n        return false;\n\n    // Replace \"*(ptr + num)\" => \"ptr[num]\"\n    simplifyOffsetPointerDereference();\n\n    // Replace \"&str[num]\" => \"(str + num)\"\n    simplifyOffsetPointerReference();\n\n    removeRedundantAssignment();\n\n    simplifyRealloc();\n\n    // Change initialisation of variable to assignment\n    simplifyInitVar();\n\n    // Simplify variable declarations\n    simplifyVarDecl(false);\n\n    simplifyErrNoInWhile();\n    simplifyIfAndWhileAssign();\n    simplifyRedundantParentheses();\n    simplifyNestedStrcat();\n    simplifyFuncInWhile();\n\n    simplifyIfAndWhileAssign();\n\n    // replace strlen(str)\n    for (Token *tok = list.front(); tok; tok = tok->next()) {\n        if (Token::Match(tok, \"strlen ( %str% )\")) {\n            tok->str(MathLib::toString(Token::getStrLength(tok->tokAt(2))));\n            tok->deleteNext(3);\n        }\n    }\n\n    bool modified = true;\n    while (modified) {\n        if (_settings->terminated())\n            return false;\n\n        modified = false;\n        modified |= simplifyConditions();\n        modified |= simplifyFunctionReturn();\n        modified |= simplifyKnownVariables();\n        modified |= simplifyStrlen();\n\n        modified |= removeRedundantConditions();\n        modified |= simplifyRedundantParentheses();\n        modified |= simplifyConstTernaryOp();\n        modified |= simplifyCalculations();\n        validate();\n    }\n\n    // simplify redundant loops\n    simplifyWhile0();\n    removeRedundantFor();\n\n    // Remove redundant parentheses in return..\n    for (Token *tok = list.front(); tok; tok = tok->next()) {\n        while (Token::simpleMatch(tok, \"return (\")) {\n            Token *tok2 = tok->next()->link();\n            if (Token::simpleMatch(tok2, \") ;\")) {\n                tok->deleteNext();\n                tok2->deleteThis();\n            } else {\n                break;\n            }\n        }\n    }\n\n    simplifyReturnStrncat();\n\n    removeRedundantAssignment();\n\n    simplifyComma();\n\n    removeRedundantSemicolons();\n\n    simplifyFlowControl();\n\n    simplifyRedundantConsecutiveBraces();\n\n    simplifyEmptyNamespaces();\n\n    simplifyMathFunctions();\n\n    validate();\n\n    Token::assignProgressValues(list.front());\n\n    list.createAst();\n\n>>> [ INFILL ] <<<\n    // Create symbol database and then remove const keywords\n    createSymbolDatabase();\n    _symbolDatabase->setValueTypeInTokenList();\n\n    ValueFlow::setValues(&list, _symbolDatabase, _errorLogger, _settings);\n\n    if (_settings->terminated())\n        return false;\n\n    printDebugOutput(2);\n\n    return true;\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    // skipping this here may help improve performance. Might be enabled later on demand. #7208\n    // list.validateAst();\n\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_26bd863d0a4c5499258c9672fbb945343c3901dd/build_26bd863d0a4c5499258c9672fbb945343c3901dd\nTest project /out/danmar___cppcheck/git_repo_dir_26bd863d0a4c5499258c9672fbb945343c3901dd/build_26bd863d0a4c5499258c9672fbb945343c3901dd\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   23.62 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  23.63 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "26bd863d0a4c5499258c9672fbb945343c3901dd___tokenize.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nCLI11_INLINE std::string\nConfigBase::to_config(const App *app, bool default_also, bool write_description, std::string prefix) const {\n    std::stringstream out;\n    std::string commentLead;\n    commentLead.push_back(commentChar);\n    commentLead.push_back(' ');\n\n    std::vector<std::string> groups = app->get_groups();\n    bool defaultUsed = false;\n    groups.insert(groups.begin(), std::string(\"Options\"));\n    if(write_description && (app->get_configurable() || app->get_parent() == nullptr || app->get_name().empty())) {\n        out << commentLead << detail::fix_newlines(commentLead, app->get_description()) << '\\n';\n    }\n    for(auto &group : groups) {\n        if(group == \"Options\" || group.empty()) {\n            if(defaultUsed) {\n                continue;\n            }\n            defaultUsed = true;\n        }\n        if(write_description && group != \"Options\" && !group.empty()) {\n            out << '\\n' << commentLead << group << \" Options\\n\";\n        }\n        for(const Option *opt : app->get_options({})) {\n\n            // Only process options that are configurable\n            if(opt->get_configurable()) {\n                if(opt->get_group() != group) {\n                    if(!(group == \"Options\" && opt->get_group().empty())) {\n                        continue;\n                    }\n                }\n                std::string name = prefix + opt->get_single_name();\n                std::string value = detail::ini_join(\n                    opt->reduced_results(), arraySeparator, arrayStart, arrayEnd, stringQuote, characterQuote);\n\n                if(value.empty() && default_also) {\n                    if(!opt->get_default_str().empty()) {\n                        value = detail::convert_arg_for_ini(opt->get_default_str(), stringQuote, characterQuote);\n                    } else if(opt->get_expected_min() == 0) {\n                        value = \"false\";\n                    } else if(opt->get_run_callback_for_default()) {\n                        value = \"\\\"\\\"\";  // empty string default value\n                    }\n                }\n\n                if(!value.empty()) {\n\n>>> [ INFILL ] <<<\n                        out << '\\n';\n                        out << commentLead << detail::fix_newlines(commentLead, opt->get_description()) << '\\n';\n                    }\n                    out << name << valueDelimiter << value << '\\n';\n                }\n            }\n        }\n    }\n    auto subcommands = app->get_subcommands({});\n    for(const App *subcom : subcommands) {\n        if(subcom->get_name().empty()) {\n            if(write_description && !subcom->get_group().empty()) {\n                out << '\\n' << commentLead << subcom->get_group() << \" Options\\n\";\n            }\n            out << to_config(subcom, default_also, write_description, prefix);\n        }\n    }\n\n    for(const App *subcom : subcommands) {\n        if(!subcom->get_name().empty()) {\n            if(subcom->get_configurable() && app->got_subcommand(subcom)) {\n                if(!prefix.empty() || app->get_parent() == nullptr) {\n                    out << '[' << prefix << subcom->get_name() << \"]\\n\";\n                } else {\n                    std::string subname = app->get_name() + parentSeparatorChar + subcom->get_name();\n                    const auto *p = app->get_parent();\n                    while(p->get_parent() != nullptr) {\n                        subname = p->get_name() + parentSeparatorChar + subname;\n                        p = p->get_parent();\n                    }\n                    out << '[' << subname << \"]\\n\";\n                }\n                out << to_config(subcom, default_also, write_description, \"\");\n            } else {\n                out << to_config(\n                    subcom, default_also, write_description, prefix + subcom->get_name() + parentSeparatorChar);\n            }\n        }\n    }\n\n    return out.str();\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n                    if(write_description && opt->has_description()) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CLIUtils___CLI11/git_repo_dir_dcbcb4721dda5dab0a56d9faaaee50e6a30f7758/build_dcbcb4721dda5dab0a56d9faaaee50e6a30f7758\nTest project /out/CLIUtils___CLI11/git_repo_dir_dcbcb4721dda5dab0a56d9faaaee50e6a30f7758/build_dcbcb4721dda5dab0a56d9faaaee50e6a30f7758\n\nCLI11 information:\n  C++ standard: 11\n  __has_include: yes\n  No optional library found\n\n    Start 2: ConfigFileTest\n1/1 Test #2: ConfigFileTest ...................***Failed    0.04 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.04 sec\n\nThe following tests FAILED:\n\t  2 - ConfigFileTest (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "dcbcb4721dda5dab0a56d9faaaee50e6a30f7758___Config_inl.hpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstatic bool split_line(chunk_t *start)\n{\n   LOG_FUNC_ENTRY();\n   LOG_FMT(LSPLIT, \"%s(%d): start->flags \", __func__, __LINE__);\n   log_pcf_flags(LSPLIT, start->flags);\n   LOG_FMT(LSPLIT, \"%s(%d): orig_line is %zu, column is %zu, text() '%s', type is %s,\\n\",\n           __func__, __LINE__, start->orig_line, start->column, start->text(),\n           get_token_name(start->type));\n   LOG_FMT(LSPLIT, \"   parent_type %s, (PCF_IN_FCN_DEF is %s), (PCF_IN_FCN_CALL is %s),\",\n           get_token_name(start->parent_type),\n           ((start->flags & (PCF_IN_FCN_DEF)) != 0) ? \"TRUE\" : \"FALSE\",\n           ((start->flags & (PCF_IN_FCN_CALL)) != 0) ? \"TRUE\" : \"FALSE\");\n#ifdef DEBUG\n   LOG_FMT(LSPLIT, \"\\n\");\n#endif // DEBUG\n\n   // break at maximum line length if ls_code_width is true\n   if (start->flags & PCF_ONE_LINER)\n   {\n      LOG_FMT(LSPLIT, \" ** ONCE LINER SPLIT **\\n\");\n      undo_one_liner(start);\n      newlines_cleanup_braces(false);\n\n>>> [ INFILL ] <<<\n   }\n\n   LOG_FMT(LSPLIT, \"%s(%d):\\n\", __func__, __LINE__);\n   if (cpd.settings[UO_ls_code_width].b)\n   {\n   }\n   // Check to see if we are in a for statement\n   else if (start->flags & PCF_IN_FOR)\n   {\n      LOG_FMT(LSPLIT, \" ** FOR SPLIT **\\n\");\n      split_for_stmt(start);\n      if (!is_past_width(start))\n      {\n         return(true);\n      }\n      LOG_FMT(LSPLIT, \"%s(%d): for split didn't work\\n\", __func__, __LINE__);\n   }\n\n   /*\n    * If this is in a function call or prototype, split on commas or right\n    * after the open parenthesis\n    */\n   else if (  (start->flags & PCF_IN_FCN_DEF)\n           || start->parent_type == CT_FUNC_PROTO            // Issue #1169\n           || (  (start->level == (start->brace_level + 1))\n              && (start->flags & PCF_IN_FCN_CALL)))\n   {\n      LOG_FMT(LSPLIT, \" ** FUNC SPLIT **\\n\");\n\n      if (cpd.settings[UO_ls_func_split_full].b)\n      {\n         split_fcn_params_full(start);\n         if (!is_past_width(start))\n         {\n            return(true);\n         }\n      }\n      split_fcn_params(start);\n      return(true);\n   }\n\n   /*\n    * If this is in a template, split on commas, Issue #1170\n    */\n   else if (start->flags & PCF_IN_TEMPLATE)\n   {\n      LOG_FMT(LSPLIT, \" ** TEMPLATE SPLIT **\\n\");\n      split_template(start);\n      return(true);\n   }\n\n   LOG_FMT(LSPLIT, \"%s(%d):\\n\", __func__, __LINE__);\n   // Try to find the best spot to split the line\n   cw_entry ent;\n\n   memset(&ent, 0, sizeof(ent));\n   chunk_t *pc = start;\n   chunk_t *prev;\n\n   while (((pc = chunk_get_prev(pc)) != nullptr) && !chunk_is_newline(pc))\n   {\n      LOG_FMT(LSPLIT, \"%s(%d): at %s, orig_line=%zu, orig_col=%zu\\n\",\n              __func__, __LINE__, pc->text(), pc->orig_line, pc->orig_col);\n      if (pc->type != CT_SPACE)\n      {\n         try_split_here(ent, pc);\n         // break at maximum line length\n         if (ent.pc != nullptr && (cpd.settings[UO_ls_code_width].b))\n         {\n            break;\n         }\n      }\n   }\n\n   if (ent.pc == nullptr)\n   {\n      LOG_FMT(LSPLIT, \"\\n%s(%d):    TRY_SPLIT yielded NO SOLUTION for orig_line %zu at %s [%s]\\n\",\n              __func__, __LINE__, start->orig_line, start->text(), get_token_name(start->type));\n   }\n   else\n   {\n      LOG_FMT(LSPLIT, \"\\n%s(%d):    TRY_SPLIT yielded '%s' [%s] on orig_line %zu\\n\",\n              __func__, __LINE__, ent.pc->text(), get_token_name(ent.pc->type), ent.pc->orig_line);\n      LOG_FMT(LSPLIT, \"%s(%d): ent at %s, orig_col=%zu\\n\",\n              __func__, __LINE__, ent.pc->text(), ent.pc->orig_col);\n   }\n\n   // Break before the token instead of after it according to the pos_xxx rules\n   if (ent.pc == nullptr)\n   {\n      pc = nullptr;\n   }\n   else\n   {\n      if (  (  (  chunk_is_token(ent.pc, CT_ARITH)\n               || chunk_is_token(ent.pc, CT_CARET))\n            && (cpd.settings[UO_pos_arith].tp & TP_LEAD))\n         || (  chunk_is_token(ent.pc, CT_ASSIGN)\n            && (cpd.settings[UO_pos_assign].tp & TP_LEAD))\n         || (  chunk_is_token(ent.pc, CT_COMPARE)\n            && (cpd.settings[UO_pos_compare].tp & TP_LEAD))\n         || (  (  chunk_is_token(ent.pc, CT_COND_COLON)\n               || chunk_is_token(ent.pc, CT_QUESTION))\n            && (cpd.settings[UO_pos_conditional].tp & TP_LEAD))\n         || (  chunk_is_token(ent.pc, CT_BOOL)\n            && (cpd.settings[UO_pos_bool].tp & TP_LEAD)))\n      {\n         pc = ent.pc;\n      }\n      else\n      {\n         pc = chunk_get_next(ent.pc);\n      }\n      LOG_FMT(LSPLIT, \"%s(%d): at %s, col=%zu\\n\", __func__, __LINE__, pc->text(), pc->orig_col);\n   }\n\n   if (pc == nullptr)\n   {\n      pc = start;\n      // Don't break before a close, comma, or colon\n      if (  start->type == CT_PAREN_CLOSE\n         || start->type == CT_PAREN_OPEN\n         || start->type == CT_FPAREN_CLOSE\n         || start->type == CT_FPAREN_OPEN\n         || start->type == CT_SPAREN_CLOSE\n         || start->type == CT_SPAREN_OPEN\n         || start->type == CT_ANGLE_CLOSE\n         || start->type == CT_BRACE_CLOSE\n         || start->type == CT_COMMA\n         || start->type == CT_SEMICOLON\n         || start->type == CT_VSEMICOLON\n         || start->len() == 0)\n      {\n         LOG_FMT(LSPLIT, \" ** NO GO **\\n\");\n\n         // TODO: Add in logic to handle 'hard' limits by backing up a token\n         return(true);\n      }\n   }\n\n   // add a newline before pc\n   prev = chunk_get_prev(pc);\n   if (  prev != nullptr\n      && !chunk_is_newline(pc)\n      && !chunk_is_newline(prev))\n   {\n      //int plen = (pc->len() < 5) ? pc->len() : 5;\n      //int slen = (start->len() < 5) ? start->len() : 5;\n      //LOG_FMT(LSPLIT, \" '%.*s' [%s], started on token '%.*s' [%s]\\n\",\n      //        plen, pc->text(), get_token_name(pc->type),\n      //        slen, start->text(), get_token_name(start->type));\n      LOG_FMT(LSPLIT, \"  %s(%d): %s [%s], started on token '%s' [%s]\\n\",\n              __func__, __LINE__, pc->text(), get_token_name(pc->type),\n              start->text(), get_token_name(start->type));\n\n      split_before_chunk(pc);\n   }\n   return(true);\n} // split_line\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n      return(false);\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/uncrustify___uncrustify/git_repo_dir_dfe791684b24adc9eef81baef867f824866abdfa/build_dfe791684b24adc9eef81baef867f824866abdfa\nTest project /out/uncrustify___uncrustify/git_repo_dir_dfe791684b24adc9eef81baef867f824866abdfa/build_dfe791684b24adc9eef81baef867f824866abdfa\n    Start 148: c_00451\n1/2 Test #148: c_00451 ..........................***Failed    0.01 sec\n    Start 150: c_00453\n2/2 Test #150: c_00453 ..........................***Failed    0.01 sec\n\n0% tests passed, 2 tests failed out of 2\n\nLabel Time Summary:\nc    =   0.03 sec*proc (2 tests)\n\nTotal Test time (real) =   0.07 sec\n\nThe following tests FAILED:\n\t148 - c_00451 (Failed)\n\t150 - c_00453 (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "dfe791684b24adc9eef81baef867f824866abdfa___width.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\ntemplate <typename OutputIt, typename Char, typename UInt> struct int_writer {\n  OutputIt out;\n  locale_ref locale;\n  const basic_format_specs<Char>& specs;\n  UInt abs_value;\n  char prefix[4];\n  unsigned prefix_size;\n\n  using iterator =\n      remove_reference_t<decltype(reserve(std::declval<OutputIt&>(), 0))>;\n\n  string_view get_prefix() const { return string_view(prefix, prefix_size); }\n\n  template <typename Int>\n  int_writer(OutputIt output, locale_ref loc, Int value,\n             const basic_format_specs<Char>& s)\n      : out(output),\n        locale(loc),\n        specs(s),\n        abs_value(static_cast<UInt>(value)),\n        prefix_size(0) {\n    static_assert(std::is_same<uint32_or_64_or_128_t<Int>, UInt>::value, \"\");\n    if (is_negative(value)) {\n      prefix[0] = '-';\n      ++prefix_size;\n      abs_value = 0 - abs_value;\n    } else if (specs.sign != sign::none && specs.sign != sign::minus) {\n      prefix[0] = specs.sign == sign::plus ? '+' : ' ';\n      ++prefix_size;\n    }\n  }\n\n  void on_dec() {\n    auto num_digits = count_digits(abs_value);\n    out = write_int(\n        out, num_digits, get_prefix(), specs, [this, num_digits](iterator it) {\n          return format_decimal<Char>(it, abs_value, num_digits).end;\n        });\n  }\n\n  void on_hex() {\n    if (specs.alt) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = specs.type;\n    }\n    int num_digits = count_digits<4>(abs_value);\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<4, Char>(it, abs_value, num_digits,\n                                                  specs.type != 'x');\n                    });\n  }\n\n  void on_bin() {\n    if (specs.alt) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = static_cast<char>(specs.type);\n    }\n    int num_digits = count_digits<1>(abs_value);\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<1, Char>(it, abs_value, num_digits);\n                    });\n  }\n\n  void on_oct() {\n    int num_digits = count_digits<3>(abs_value);\n    if (specs.alt && specs.precision <= num_digits && abs_value != 0) {\n      // Octal prefix '0' is counted as a digit, so only add it if precision\n      // is not greater than the number of digits.\n      prefix[prefix_size++] = '0';\n    }\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<3, Char>(it, abs_value, num_digits);\n                    });\n  }\n\n  enum { sep_size = 1 };\n\n  void on_num() {\n    std::string groups = grouping<Char>(locale);\n    if (groups.empty()) return on_dec();\n    auto sep = thousands_sep<Char>(locale);\n    if (!sep) return on_dec();\n    int num_digits = count_digits(abs_value);\n    int size = num_digits, n = num_digits;\n    std::string::const_iterator group = groups.cbegin();\n    while (group != groups.cend() && n > *group && *group > 0 &&\n           *group != max_value<char>()) {\n      size += sep_size;\n      n -= *group;\n      ++group;\n    }\n    if (group == groups.cend()) size += sep_size * ((n - 1) / groups.back());\n    char digits[40];\n    format_decimal(digits, abs_value, num_digits);\n    basic_memory_buffer<Char> buffer;\n    size += prefix_size;\n    buffer.resize(size);\n    basic_string_view<Char> s(&sep, sep_size);\n    // Index of a decimal digit with the least significant digit having index 0.\n    int digit_index = 0;\n    group = groups.cbegin();\n    auto p = buffer.data() + size;\n    for (int i = num_digits - 1; i >= 0; --i) {\n      *--p = static_cast<Char>(digits[i]);\n      if (*group <= 0 || ++digit_index % *group != 0 ||\n          *group == max_value<char>())\n        continue;\n      if (group + 1 != groups.cend()) {\n        digit_index = 0;\n        ++group;\n      }\n      p -= s.size();\n      std::uninitialized_copy(s.data(), s.data() + s.size(),\n                              make_checked(p, s.size()));\n    }\n    if (prefix_size != 0) p[-1] = static_cast<Char>('-');\n\n>>> [ INFILL ] <<<\n\n  void on_chr() { *out++ = static_cast<Char>(abs_value); }\n\n  FMT_NORETURN void on_error() {\n    FMT_THROW(format_error(\"invalid type specifier\"));\n  }\n};\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    out = write(out, basic_string_view<Char>(buffer.data(), buffer.size()),\n                specs);\n  }\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_279d698e1b37f3f0a9b5c21b12198894d31c381d/build_279d698e1b37f3f0a9b5c21b12198894d31c381d\nTest project /out/fmtlib___fmt/git_repo_dir_279d698e1b37f3f0a9b5c21b12198894d31c381d/build_279d698e1b37f3f0a9b5c21b12198894d31c381d\n    Start 9: locale-test\n1/1 Test #9: locale-test ......................***Failed    0.00 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.00 sec\n\nThe following tests FAILED:\n\t  9 - locale-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "279d698e1b37f3f0a9b5c21b12198894d31c381d___format.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\nstruct chrono_formatter {\n  FormatContext& context;\n  OutputIt out;\n  int precision;\n  Rep val;\n  typedef std::chrono::duration<Rep> seconds;\n  seconds s;\n  typedef std::chrono::duration<Rep, std::milli> milliseconds;\n  milliseconds ms;\n\n  typedef typename FormatContext::char_type char_type;\n\n  explicit chrono_formatter(FormatContext& ctx, OutputIt o,\n                            std::chrono::duration<Rep, Period> d)\n\n>>> [ INFILL ] <<<\n  int hour() const { return to_int(mod((s.count() / 3600), 24)); }\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n      : context(ctx),\n        out(o),\n        val(d.count()),\n        s(std::chrono::duration_cast<seconds>(d)),\n        ms(std::chrono::duration_cast<milliseconds>(d - s)) {}\n\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_c1d430e61ab306e0e1d454fea6e07b4f66667a65/build_c1d430e61ab306e0e1d454fea6e07b4f66667a65\nTest project /out/fmtlib___fmt/git_repo_dir_c1d430e61ab306e0e1d454fea6e07b4f66667a65/build_c1d430e61ab306e0e1d454fea6e07b4f66667a65\n    Start 2: chrono-test\n1/1 Test #2: chrono-test ......................***Failed    0.00 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.00 sec\n\nThe following tests FAILED:\n\t  2 - chrono-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "c1d430e61ab306e0e1d454fea6e07b4f66667a65___chrono.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\n  basic_context<Char>::get_arg(basic_string_view<Char> name) {\n\n>>> [ INFILL ] <<<\n}\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n  if (this->check_no_auto_index()) {\n    map_.init(this->args());\n    if (const format_arg *arg = map_.find(name))\n      return *arg;\n    this->on_error(\"argument not found\");\n  }\n  return format_arg();\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_971fb584c3ea548c12dcfa813b0bafb94e1c0fde/build_971fb584c3ea548c12dcfa813b0bafb94e1c0fde\nTest project /out/fmtlib___fmt/git_repo_dir_971fb584c3ea548c12dcfa813b0bafb94e1c0fde/build_971fb584c3ea548c12dcfa813b0bafb94e1c0fde\n    Start 3: format-test\n1/1 Test #3: format-test ......................***Failed    0.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.02 sec\n\nThe following tests FAILED:\n\t  3 - format-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "971fb584c3ea548c12dcfa813b0bafb94e1c0fde___format.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy hunk that has been removed.\n```cpp\n  auto format(const T &val, FormatContext &ctx) -> decltype(ctx.out()) {\n    internal::handle_dynamic_spec<internal::width_checker>(\n      specs_.width_, specs_.width_ref, ctx);\n    internal::handle_dynamic_spec<internal::precision_checker>(\n      specs_.precision_, specs_.precision_ref, ctx);\n    typedef output_range<typename FormatContext::iterator,\n                         typename FormatContext::char_type> range_type;\n\n>>> [ INFILL ] <<<\n\n```\nThis was the original buggy hunk which was removed by the infill location\n```cpp\n// buggy hunk\n    visit(arg_formatter<range_type>(ctx, specs_),\n          internal::make_arg<FormatContext>(val));\n    return ctx.out();\n  }\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_c04fb91b03cb6480c4a39b214efb6b05e452b20c/build_c04fb91b03cb6480c4a39b214efb6b05e452b20c\nTest project /out/fmtlib___fmt/git_repo_dir_c04fb91b03cb6480c4a39b214efb6b05e452b20c/build_c04fb91b03cb6480c4a39b214efb6b05e452b20c\n    Start 3: format-test\n1/1 Test #3: format-test ......................***Failed    0.03 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.03 sec\n\nThe following tests FAILED:\n\t  3 - format-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "c04fb91b03cb6480c4a39b214efb6b05e452b20c___format.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n\n>>> [ INFILL ] <<<\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  return 0;  /* no line changes in the way */\n\n```\n\n\n\nwith the following test error: testing debug library and debug information\n+\ntesting inspection of parameters/returned values\n+\n+\ntesting traceback sizes\ntesting debug functions on chunk without debug info\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ae5b5ba529753c7a653901ffc29b5ea24c3fdf3a___ldebug.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid ourWriteOut(CURL *curl, struct OutStruct *outs, const char *writeinfo)\n{\n  FILE *stream = stdout;\n  const char *ptr = writeinfo;\n  char *stringp = NULL;\n  long longinfo;\n  double doubleinfo;\n\n  while(ptr && *ptr) {\n\n>>> [ INFILL ] <<<\n      if('%' == ptr[1]) {\n        /* an escaped %-letter */\n        fputc('%', stream);\n        ptr += 2;\n      }\n      else {\n        /* this is meant as a variable to output */\n        char *end;\n        char keepit;\n        int i;\n        if('{' == ptr[1]) {\n          bool match = FALSE;\n          end = strchr(ptr, '}');\n          ptr += 2; /* pass the % and the { */\n          if(!end) {\n            fputs(\"%{\", stream);\n            continue;\n          }\n          keepit = *end;\n          *end = 0; /* zero terminate */\n          for(i = 0; replacements[i].name; i++) {\n            if(curl_strequal(ptr, replacements[i].name)) {\n              match = TRUE;\n              switch(replacements[i].id) {\n              case VAR_EFFECTIVE_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_HTTP_CODE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HTTP_CODE_PROXY:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE,\n                                     &longinfo))\n                  fprintf(stream, \"%03ld\", longinfo);\n                break;\n              case VAR_HEADER_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REQUEST_SIZE:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_NUM_CONNECTS:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_COUNT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_REDIRECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_TOTAL_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_NAMELOOKUP_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_CONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_APPCONNECT_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_PRETRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_STARTTRANSFER_TIME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.6f\", doubleinfo);\n                break;\n              case VAR_SIZE_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SIZE_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.0f\", doubleinfo);\n                break;\n              case VAR_SPEED_DOWNLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD,\n                                     &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_SPEED_UPLOAD:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &doubleinfo))\n                  fprintf(stream, \"%.3f\", doubleinfo);\n                break;\n              case VAR_CONTENT_TYPE:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_FTP_ENTRY_PATH:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_REDIRECT_URL:\n                if((CURLE_OK ==\n                    curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &stringp))\n                   && stringp)\n                  fputs(stringp, stream);\n                break;\n              case VAR_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_PROXY_SSL_VERIFY_RESULT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PROXY_SSL_VERIFYRESULT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_EFFECTIVE_FILENAME:\n                if(outs->filename)\n                  fprintf(stream, \"%s\", outs->filename);\n                break;\n              case VAR_PRIMARY_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_PRIMARY_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_LOCAL_IP:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_IP,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              case VAR_LOCAL_PORT:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT,\n                                     &longinfo))\n                  fprintf(stream, \"%ld\", longinfo);\n                break;\n              case VAR_HTTP_VERSION:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_HTTP_VERSION,\n                                     &longinfo)) {\n                  const char *version = \"0\";\n                  switch(longinfo) {\n                  case CURL_HTTP_VERSION_1_0:\n                    version = \"1.0\";\n                    break;\n                  case CURL_HTTP_VERSION_1_1:\n                    version = \"1.1\";\n                    break;\n                  case CURL_HTTP_VERSION_2_0:\n                    version = \"2\";\n                    break;\n                  }\n\n                  fprintf(stream, version);\n                }\n                break;\n              case VAR_SCHEME:\n                if(CURLE_OK ==\n                   curl_easy_getinfo(curl, CURLINFO_SCHEME,\n                                     &stringp))\n                  fprintf(stream, \"%s\", stringp);\n                break;\n              default:\n                break;\n              }\n              break;\n            }\n          }\n          if(!match) {\n            fprintf(stderr, \"curl: unknown --write-out variable: '%s'\\n\", ptr);\n          }\n          ptr = end + 1; /* pass the end */\n          *end = keepit;\n        }\n        else {\n          /* illegal syntax, then just output the characters that are used */\n          fputc('%', stream);\n          fputc(ptr[1], stream);\n          ptr += 2;\n        }\n      }\n    }\n    else if('\\\\' == *ptr) {\n      switch(ptr[1]) {\n      case 'r':\n        fputc('\\r', stream);\n        break;\n      case 'n':\n        fputc('\\n', stream);\n        break;\n      case 't':\n        fputc('\\t', stream);\n        break;\n      default:\n        /* unknown, just output this */\n        fputc(*ptr, stream);\n        fputc(ptr[1], stream);\n        break;\n      }\n      ptr += 2;\n    }\n    else {\n      fputc(*ptr, stream);\n      ptr++;\n    }\n  }\n\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    if('%' == *ptr) {\n\n```\n\n\n\nwith the following test error: ********* System characteristics ******** \n* curl 7.54.0-DEV (x86_64-pc-linux-gnu) \n* libcurl/7.54.0-DEV OpenSSL/1.1.1f\n* Features: Debug TrackMemory IPv6 Largefile NTLM NTLM_WB SSL TLS-SRP UnixSockets HTTPS-proxy \n* Host: deef54515472\n* System: Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux\n* Servers: \n* Env: Valgrind \n***************************************** \ntest 1440...[Check --write-out with trailing %{]\ns-----emv- OK (1   out of 2  , remaining: 00:01)\ntest 1441...[Check --write-out with trailing %]\n\n 1441: stdout FAILED:\nBinary files log/check-expected and log/check-generated differ\n\n - abort tests\nTESTDONE: 1 tests out of 2 reported OK: 50%\nTESTFAIL: These test cases failed: 1441 \nTESTDONE: 2 tests were considered during 4 seconds.\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "1890d59905414ab84a35892b2e45833654aa5c13___tool_writeout.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid\nisakmp_rfc3948_print(netdissect_options *ndo,\n\t\t     const u_char *bp, u_int length,\n\t\t     const u_char *bp2)\n{\n\n>>> [ INFILL ] <<<\n\tif(length == 1 && bp[0]==0xff) {\n\t\tND_PRINT((ndo, \"isakmp-nat-keep-alive\"));\n\t\treturn;\n\t}\n\n\tif(length < 4) {\n\t\tgoto trunc;\n\t}\n\n\t/*\n\t * see if this is an IKE packet\n\t */\n\tif(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {\n\t\tND_PRINT((ndo, \"NONESP-encap: \"));\n\t\tisakmp_print(ndo, bp+4, length-4, bp2);\n\t\treturn;\n\t}\n\n\t/* must be an ESP packet */\n\t{\n\t\tint nh, enh, padlen;\n\t\tint advance;\n\n\t\tND_PRINT((ndo, \"UDP-encap: \"));\n\n\t\tadvance = esp_print(ndo, bp, length, bp2, &enh, &padlen);\n\t\tif(advance <= 0)\n\t\t\treturn;\n\n\t\tbp += advance;\n\t\tlength -= advance + padlen;\n\t\tnh = enh & 0xff;\n\n\t\tip_print_inner(ndo, bp, length, nh, bp2);\n\t\treturn;\n\t}\n\ntrunc:\n\tND_PRINT((ndo,\"[|isakmp]\"));\n\treturn;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\n\n```\n\n\n\nwith the following test error:     isakmp-rfc3948-oobr                : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "f76e7feb41a4327d2b0978449bbdafe98d4a3771___print-isakmp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic int\nisis_print_extd_ip_reach(netdissect_options *ndo,\n                         const uint8_t *tptr, const char *ident, uint16_t afi)\n{\n    char ident_buffer[20];\n    uint8_t prefix[sizeof(struct in6_addr)]; /* shared copy buffer for IPv4 and IPv6 prefixes */\n    u_int metric, status_byte, bit_length, byte_length, sublen, processed, subtlvtype, subtlvlen;\n\n    if (!ND_TTEST2(*tptr, 4))\n        return (0);\n    metric = EXTRACT_32BITS(tptr);\n    processed=4;\n    tptr+=4;\n\n    if (afi == AF_INET) {\n        if (!ND_TTEST2(*tptr, 1)) /* fetch status byte */\n            return (0);\n        status_byte=*(tptr++);\n        bit_length = status_byte&0x3f;\n        if (bit_length > 32) {\n            ND_PRINT((ndo, \"%sIPv4 prefix: bad bit length %u\",\n                   ident,\n                   bit_length));\n            return (0);\n        }\n        processed++;\n    } else if (afi == AF_INET6) {\n\n>>> [ INFILL ] <<<\n            return (0);\n        status_byte=*(tptr++);\n        bit_length=*(tptr++);\n        if (bit_length > 128) {\n            ND_PRINT((ndo, \"%sIPv6 prefix: bad bit length %u\",\n                   ident,\n                   bit_length));\n            return (0);\n        }\n        processed+=2;\n    } else\n        return (0); /* somebody is fooling us */\n\n    byte_length = (bit_length + 7) / 8; /* prefix has variable length encoding */\n\n    if (!ND_TTEST2(*tptr, byte_length))\n        return (0);\n    memset(prefix, 0, sizeof prefix);   /* clear the copy buffer */\n    memcpy(prefix,tptr,byte_length);    /* copy as much as is stored in the TLV */\n    tptr+=byte_length;\n    processed+=byte_length;\n\n    if (afi == AF_INET)\n        ND_PRINT((ndo, \"%sIPv4 prefix: %15s/%u\",\n               ident,\n               ipaddr_string(ndo, prefix),\n               bit_length));\n    else if (afi == AF_INET6)\n        ND_PRINT((ndo, \"%sIPv6 prefix: %s/%u\",\n               ident,\n               ip6addr_string(ndo, prefix),\n               bit_length));\n\n    ND_PRINT((ndo, \", Distribution: %s, Metric: %u\",\n           ISIS_MASK_TLV_EXTD_IP_UPDOWN(status_byte) ? \"down\" : \"up\",\n           metric));\n\n    if (afi == AF_INET && ISIS_MASK_TLV_EXTD_IP_SUBTLV(status_byte))\n        ND_PRINT((ndo, \", sub-TLVs present\"));\n    else if (afi == AF_INET6)\n        ND_PRINT((ndo, \", %s%s\",\n               ISIS_MASK_TLV_EXTD_IP6_IE(status_byte) ? \"External\" : \"Internal\",\n               ISIS_MASK_TLV_EXTD_IP6_SUBTLV(status_byte) ? \", sub-TLVs present\" : \"\"));\n\n    if ((afi == AF_INET  && ISIS_MASK_TLV_EXTD_IP_SUBTLV(status_byte))\n     || (afi == AF_INET6 && ISIS_MASK_TLV_EXTD_IP6_SUBTLV(status_byte))\n\t) {\n        /* assume that one prefix can hold more\n           than one subTLV - therefore the first byte must reflect\n           the aggregate bytecount of the subTLVs for this prefix\n        */\n        if (!ND_TTEST2(*tptr, 1))\n            return (0);\n        sublen=*(tptr++);\n        processed+=sublen+1;\n        ND_PRINT((ndo, \" (%u)\", sublen));   /* print out subTLV length */\n\n        while (sublen>0) {\n            if (!ND_TTEST2(*tptr,2))\n                return (0);\n            subtlvtype=*(tptr++);\n            subtlvlen=*(tptr++);\n            /* prepend the indent string */\n            snprintf(ident_buffer, sizeof(ident_buffer), \"%s  \",ident);\n            if (!isis_print_ip_reach_subtlv(ndo, tptr, subtlvtype, subtlvlen, ident_buffer))\n                return(0);\n            tptr+=subtlvlen;\n            sublen-=(subtlvlen+2);\n        }\n    }\n    return (processed);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        if (!ND_TTEST2(*tptr, 1)) /* fetch status & prefix_len byte */\n\n```\n\n\n\nwith the following test error:     isis-extd-ipreach-oobr             : passed\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "979dcefd7b259e9e233f77fe1c5312793bfd948f___print-isoclns.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nu_int\nieee802_15_4_if_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int hdrlen;\n\tuint16_t fc;\n\tuint8_t seq;\n\tuint16_t panid = 0;\n\n\tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\treturn caplen;\n\t}\n\thdrlen = 3;\n\n\tfc = EXTRACT_LE_16BITS(p);\n\tseq = EXTRACT_LE_8BITS(p + 2);\n\n\tp += 3;\n\tcaplen -= 3;\n\n\tND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[FC_FRAME_TYPE(fc)]));\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"seq %02x \", seq));\n\n\t/*\n\t * Destination address and PAN ID, if present.\n\t */\n\tswitch (FC_DEST_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (fc & FC_PAN_ID_COMPRESSION) {\n\t\t\t/*\n\t\t\t * PAN ID compression; this requires that both\n\t\t\t * the source and destination addresses be present,\n\t\t\t * but the destination address is missing.\n\t\t\t */\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved destination addressing mode\"));\n\t\treturn hdrlen;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\n>>> [ INFILL ] <<<\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"< \"));\n\n\t/*\n\t * Source address and PAN ID, if present.\n\t */\n\tswitch (FC_SRC_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved source addressing mode\"));\n\t\treturn 0;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\n\tif (!ndo->ndo_suppress_default_print)\n\t\tND_DEFAULTPRINT(p, caplen);\n\n\treturn hdrlen;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p + 2)));\n\n```\n\n\n\nwith the following test error:     802_15_4-data                      : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "a7e5f58f402e6919ec444a57946bade7dfd6b184___print-802_15_4.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nu_int\nieee802_15_4_if_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int hdrlen;\n\tuint16_t fc;\n\tuint8_t seq;\n\tuint16_t panid = 0;\n\n\tif (caplen < 3) {\n\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\treturn caplen;\n\t}\n\thdrlen = 3;\n\n\tfc = EXTRACT_LE_16BITS(p);\n\tseq = EXTRACT_LE_8BITS(p + 2);\n\n\tp += 3;\n\tcaplen -= 3;\n\n\tND_PRINT((ndo,\"IEEE 802.15.4 %s packet \", ftypes[FC_FRAME_TYPE(fc)]));\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"seq %02x \", seq));\n\n\t/*\n\t * Destination address and PAN ID, if present.\n\t */\n\tswitch (FC_DEST_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (fc & FC_PAN_ID_COMPRESSION) {\n\t\t\t/*\n\t\t\t * PAN ID compression; this requires that both\n\t\t\t * the source and destination addresses be present,\n\t\t\t * but the destination address is missing.\n\t\t\t */\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved destination addressing mode\"));\n\t\treturn hdrlen;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\n>>> [ INFILL ] <<<\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag)\n\t\tND_PRINT((ndo,\"< \"));\n\n\t/*\n\t * Source address and PAN ID, if present.\n\t */\n\tswitch (FC_SRC_ADDRESSING_MODE(fc)) {\n\tcase FC_ADDRESSING_MODE_NONE:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"none \"));\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_RESERVED:\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"reserved source addressing mode\"));\n\t\treturn 0;\n\tcase FC_ADDRESSING_MODE_SHORT:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 2) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p)));\n\t\tp += 2;\n\t\tcaplen -= 2;\n\t\thdrlen += 2;\n\t\tbreak;\n\tcase FC_ADDRESSING_MODE_LONG:\n\t\tif (!(fc & FC_PAN_ID_COMPRESSION)) {\n\t\t\t/*\n\t\t\t * The source PAN ID is not compressed out, so\n\t\t\t * fetch it.  (Otherwise, we'll use the destination\n\t\t\t * PAN ID, fetched above.)\n\t\t\t */\n\t\t\tif (caplen < 2) {\n\t\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\t\treturn hdrlen;\n\t\t\t}\n\t\t\tpanid = EXTRACT_LE_16BITS(p);\n\t\t\tp += 2;\n\t\t\tcaplen -= 2;\n\t\t\thdrlen += 2;\n\t\t}\n\t\tif (caplen < 8) {\n\t\t\tND_PRINT((ndo, \"[|802.15.4]\"));\n\t\t\treturn hdrlen;\n\t\t}\n\t\tif (ndo->ndo_vflag)\n\t\t\tND_PRINT((ndo,\"%04x:%s \", panid, le64addr_string(ndo, p)));\n\t\tp += 8;\n\t\tcaplen -= 8;\n\t\thdrlen += 8;\n\t\tbreak;\n\t}\n\n\tif (!ndo->ndo_suppress_default_print)\n\t\tND_DEFAULTPRINT(p, caplen);\n\n\treturn hdrlen;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\tND_PRINT((ndo,\"%04x:%04x \", panid, EXTRACT_LE_16BITS(p + 2)));\n\n```\n\n\n\nwith the following test error:     802_15_4_beacon                    : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "8512734883227c11568bb35da1d48b9f8466f43f___print-802_15_4.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nu_int\npktap_if_print(netdissect_options *ndo,\n               const struct pcap_pkthdr *h, const u_char *p)\n{\n\tuint32_t dlt, hdrlen, rectype;\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tif_printer printer;\n\tconst pktap_header_t *hdr;\n\n\tif (caplen < sizeof(pktap_header_t) || length < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\thdr = (const pktap_header_t *)p;\n\tdlt = EXTRACT_LE_32BITS(&hdr->pkt_dlt);\n\n>>> [ INFILL ] <<<\n\tif (hdrlen < sizeof(pktap_header_t)) {\n\t\t/*\n\t\t * Claimed header length < structure length.\n\t\t * XXX - does this just mean some fields aren't\n\t\t * being supplied, or is it truly an error (i.e.,\n\t\t * is the length supplied so that the header can\n\t\t * be expanded in the future)?\n\t\t */\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\tif (caplen < hdrlen || length < hdrlen) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (hdrlen);\n\t}\n\n\tif (ndo->ndo_eflag)\n\t\tpktap_header_print(ndo, p, length);\n\n\tlength -= hdrlen;\n\tcaplen -= hdrlen;\n\tp += hdrlen;\n\n\trectype = EXTRACT_LE_32BITS(&hdr->pkt_rectype);\n\tswitch (rectype) {\n\n\tcase PKT_REC_NONE:\n\t\tND_PRINT((ndo, \"no data\"));\n\t\tbreak;\n\n\tcase PKT_REC_PACKET:\n\t\tif ((printer = lookup_printer(dlt)) != NULL) {\n\t\t\thdrlen += printer(ndo, h, p);\n\t\t} else {\n\t\t\tif (!ndo->ndo_eflag)\n\t\t\t\tpktap_header_print(ndo, (const u_char *)hdr,\n\t\t\t\t\t\tlength + hdrlen);\n\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p, caplen);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn (hdrlen);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\thdrlen = EXTRACT_LE_32BITS(&hdr->pkt_len);\n\n```\n\n\n\nwith the following test error:     pktap-heap-overflow                : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ca336198e8bebccc18502de27672fdbd6eb34856___print-pktap.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic int\nlldp_mgmt_addr_tlv_print(netdissect_options *ndo,\n                         const u_char *pptr, u_int len)\n{\n    uint8_t mgmt_addr_len, intf_num_subtype, oid_len;\n    const u_char *tptr;\n    u_int tlen;\n    char *mgmt_addr;\n\n    tlen = len;\n    tptr = pptr;\n\n    if (tlen < 1) {\n        return 0;\n    }\n    mgmt_addr_len = *tptr++;\n    tlen--;\n\n    if (tlen < mgmt_addr_len) {\n        return 0;\n    }\n\n    mgmt_addr = lldp_network_addr_print(ndo, tptr, mgmt_addr_len);\n    if (mgmt_addr == NULL) {\n        return 0;\n    }\n    ND_PRINT((ndo, \"\\n\\t  Management Address length %u, %s\",\n           mgmt_addr_len, mgmt_addr));\n    tptr += mgmt_addr_len;\n    tlen -= mgmt_addr_len;\n\n    if (tlen < LLDP_INTF_NUM_LEN) {\n        return 0;\n    }\n\n    intf_num_subtype = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  %s Interface Numbering (%u): %u\",\n           tok2str(lldp_intf_numb_subtype_values, \"Unknown\", intf_num_subtype),\n           intf_num_subtype,\n           EXTRACT_32BITS(tptr + 1)));\n\n    tptr += LLDP_INTF_NUM_LEN;\n    tlen -= LLDP_INTF_NUM_LEN;\n\n    /*\n     * The OID is optional.\n     */\n    if (tlen) {\n        oid_len = *tptr;\n\n\n>>> [ INFILL ] <<<\n            return 0;\n        }\n        if (oid_len) {\n            ND_PRINT((ndo, \"\\n\\t  OID length %u\", oid_len));\n            safeputs(ndo, tptr + 1, oid_len);\n        }\n    }\n\n    return 1;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        if (tlen < oid_len) {\n\n```\n\n\n\nwith the following test error:     lldp_mgmt_addr_tlv_asan            : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "a77ff09c46560bc895dea11dc9fe643486b056ac___print-lldp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nint\nfrag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)\n{\n\tregister const struct ip6_frag *dp;\n\tregister const struct ip6_hdr *ip6;\n\n\tdp = (const struct ip6_frag *)bp;\n\tip6 = (const struct ip6_hdr *)bp2;\n\n\n>>> [ INFILL ] <<<\n\n\tif (ndo->ndo_vflag) {\n\t\tND_PRINT((ndo, \"frag (0x%08x:%d|%ld)\",\n\t\t       EXTRACT_32BITS(&dp->ip6f_ident),\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t} else {\n\t\tND_PRINT((ndo, \"frag (%d|%ld)\",\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t}\n\n\t/* it is meaningless to decode non-first fragment */\n\tif ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)\n\t\treturn -1;\n\telse\n\t{\n\t\tND_PRINT((ndo, \" \"));\n\t\treturn sizeof(struct ip6_frag);\n\t}\ntrunc:\n\tND_PRINT((ndo, \"[|frag]\"));\n\treturn -1;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\tND_TCHECK(dp->ip6f_offlg);\n\n```\n\n\n\nwith the following test error:     ip6_frag_asan                      : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "2d669862df7cd17f539129049f6fb70d17174125___print-frag6.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic char *\nisis_print_id(const uint8_t *cp, int id_len)\n{\n    int i;\n    static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n    char *pos = id;\n\n\n>>> [ INFILL ] <<<\n        snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n\tpos += strlen(pos);\n\tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n\n```\n\n\n\nwith the following test error:     isis_sysid_asan                    : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "571a6f33f47e7a2394fa08f925e534135c29cf1e___print-isoclns.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic int\nbgp_attr_print(netdissect_options *ndo,\n               u_int atype, const u_char *pptr, u_int len)\n{\n\tint i;\n\tuint16_t af;\n\tuint8_t safi, snpa, nhlen;\n        union { /* copy buffer for bandwidth values */\n            float f;\n            uint32_t i;\n        } bw;\n\tint advance;\n\tu_int tlen;\n\tconst u_char *tptr;\n\tchar buf[MAXHOSTNAMELEN + 100];\n        int  as_size;\n\n        tptr = pptr;\n        tlen=len;\n\n\tswitch (atype) {\n\tcase BGPTYPE_ORIGIN:\n\t\tif (len != 1)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK(*tptr);\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(bgp_origin_values,\n\t\t\t\t\t\t\"Unknown Origin Typecode\",\n\t\t\t\t\t\ttptr[0])));\n\t\t}\n\t\tbreak;\n\n        /*\n         * Process AS4 byte path and AS2 byte path attributes here.\n         */\n\tcase BGPTYPE_AS4_PATH:\n\tcase BGPTYPE_AS_PATH:\n\t\tif (len % 2) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                if (!len) {\n\t\t\tND_PRINT((ndo, \"empty\"));\n\t\t\tbreak;\n                }\n\n                /*\n                 * BGP updates exchanged between New speakers that support 4\n                 * byte AS, ASs are always encoded in 4 bytes. There is no\n                 * definitive way to find this, just by the packet's\n                 * contents. So, check for packet's TLV's sanity assuming\n                 * 2 bytes first, and it does not pass, assume that ASs are\n                 * encoded in 4 bytes format and move on.\n                 */\n                as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);\n\n\t\twhile (tptr < pptr + len) {\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_open_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n\t\t\tND_TCHECK(tptr[1]);\n                        for (i = 0; i < tptr[1] * as_size; i += as_size) {\n                            ND_TCHECK2(tptr[2 + i], as_size);\n\t\t\t    ND_PRINT((ndo, \"%s \",\n\t\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\t\tas_size == 2 ?\n\t\t\t\tEXTRACT_16BITS(&tptr[2 + i]) :\n\t\t\t\tEXTRACT_32BITS(&tptr[2 + i]))));\n                        }\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_close_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n                        ND_TCHECK(tptr[1]);\n                        tptr += 2 + tptr[1] * as_size;\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_NEXT_HOP:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_MULTI_EXIT_DISC:\n\tcase BGPTYPE_LOCAL_PREF:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_ATOMIC_AGGREGATE:\n\t\tif (len != 0)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\tbreak;\n        case BGPTYPE_AGGREGATOR:\n\n                /*\n                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,\n                 * the length of this PA can be either 6 bytes or 8 bytes.\n                 */\n                if (len != 6 && len != 8) {\n                    ND_PRINT((ndo, \"invalid len\"));\n                    break;\n                }\n                ND_TCHECK2(tptr[0], len);\n                if (len == 6) {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),\n\t\t\tipaddr_string(ndo, tptr + 2)));\n                } else {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\tEXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));\n                }\n                break;\n\tcase BGPTYPE_AGGREGATOR4:\n\t\tif (len != 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 8);\n\t\tND_PRINT((ndo, \" AS #%s, origin %s\",\n\t   \t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),\n\t\t    ipaddr_string(ndo, tptr + 4)));\n\t\tbreak;\n\tcase BGPTYPE_COMMUNITIES:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\twhile (tlen>0) {\n\t\t\tuint32_t comm;\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tcomm = EXTRACT_32BITS(tptr);\n\t\t\tswitch (comm) {\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_ADVERT:\n\t\t\t\tND_PRINT((ndo, \" NO_ADVERTISE\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT_SUBCONFED:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT_SUBCONFED\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"%u:%u%s\",\n                                       (comm >> 16) & 0xffff,\n                                       comm & 0xffff,\n                                       (tlen>4) ? \", \" : \"\"));\n\t\t\t\tbreak;\n\t\t\t}\n                        tlen -=4;\n                        tptr +=4;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_ORIGINATOR_ID:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 4);\n                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                break;\n        case BGPTYPE_CLUSTER_LIST:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n\t\t\tND_TCHECK2(tptr[0], 4);\n                        ND_PRINT((ndo, \"%s%s\",\n                               ipaddr_string(ndo, tptr),\n                                (tlen>4) ? \", \" : \"\"));\n                        tlen -=4;\n                        tptr +=4;\n                }\n                break;\n\tcase BGPTYPE_MP_REACH_NLRI:\n\t\tND_TCHECK2(tptr[0], 3);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                switch(af<<8 | safi) {\n                case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n\t\tcase (AFNUM_INET<<8 | SAFNUM_MDT):\n                case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    break;\n                default:\n                    ND_TCHECK2(tptr[0], tlen);\n                    ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                    goto done;\n                    break;\n                }\n\n                tptr +=3;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tnhlen = tptr[0];\n                tlen = nhlen;\n                tptr++;\n\n\t\tif (tlen) {\n                    int nnh = 0;\n                    ND_PRINT((ndo, \"\\n\\t    nexthop: \"));\n                    while (tlen > 0) {\n                        if ( nnh++ > 0 ) {\n                            ND_PRINT((ndo,  \", \" ));\n                        }\n                        switch(af<<8 | safi) {\n                        case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n                        case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t\t    if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in_addr);\n                                tptr += sizeof(struct in_addr);\n                            }\n                            break;\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                            if (tlen < (int)sizeof(struct in6_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr));\n                                ND_PRINT((ndo, \"%s\", ip6addr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in6_addr);\n                                tptr += sizeof(struct in6_addr);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n                                tlen -= (sizeof(struct in_addr));\n                                tptr += (sizeof(struct in_addr));\n                            }\n                            break;\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"%s\", isonsap_string(ndo, tptr, tlen)));\n                            tptr += tlen;\n                            tlen = 0;\n                            break;\n\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < BGP_VPN_RD_LEN+1) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], tlen);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));\n                                /* rfc986 mapped IPv4 address ? */\n                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)\n                                    ND_PRINT((ndo, \" = %s\", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));\n                                /* rfc1888 mapped IPv6 address ? */\n                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)\n                                    ND_PRINT((ndo, \" = %s\", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));\n                                tptr += tlen;\n                                tlen = 0;\n                            }\n                            break;\n                        default:\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"no AFI %u/SAFI %u decoder\", af, safi));\n                            if (ndo->ndo_vflag <= 1)\n                                print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                            tptr += tlen;\n                            tlen = 0;\n                            goto done;\n                            break;\n                        }\n                    }\n\t\t}\n\t\tND_PRINT((ndo, \", nh-length: %u\", nhlen));\n\t\ttptr += tlen;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tsnpa = tptr[0];\n\t\ttptr++;\n\n\t\tif (snpa) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    %u SNPA\", snpa));\n\t\t\tfor (/*nothing*/; snpa > 0; snpa--) {\n\t\t\t\tND_TCHECK(tptr[0]);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      %d bytes\", tptr[0]));\n\t\t\t\ttptr += tptr[0] + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \", no SNPA\"));\n                }\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,tlen);\n                        ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n        done:\n\t\tbreak;\n\n\tcase BGPTYPE_MP_UNREACH_NLRI:\n\t\tND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                if (len == BGP_MP_NLRI_MINSIZE)\n                    ND_PRINT((ndo, \"\\n\\t      End-of-Rib Marker (empty NLRI)\"));\n\n\t\ttptr += 3;\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*(tptr-3),tlen);\n                        ND_PRINT((ndo, \"no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr-3, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_EXTD_COMMUNITIES:\n\t\tif (len % 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n                    uint16_t extd_comm;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    extd_comm=EXTRACT_16BITS(tptr);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s (0x%04x), Flags [%s]\",\n\t\t\t   tok2str(bgp_extd_comm_subtype_values,\n\t\t\t\t      \"unknown extd community typecode\",\n\t\t\t\t      extd_comm),\n\t\t\t   extd_comm,\n\t\t\t   bittok2str(bgp_extd_comm_flag_values, \"none\", extd_comm)));\n\n                    ND_TCHECK2(*(tptr+2), 6);\n                    switch(extd_comm) {\n                    case BGP_EXT_COM_RT_0:\n                    case BGP_EXT_COM_RO_0:\n                    case BGP_EXT_COM_L2VPN_RT_0:\n                        ND_PRINT((ndo, \": %u:%u (= %s)\",\n                               EXTRACT_16BITS(tptr+2),\n                               EXTRACT_32BITS(tptr+4),\n                               ipaddr_string(ndo, tptr+4)));\n                        break;\n                    case BGP_EXT_COM_RT_1:\n                    case BGP_EXT_COM_RO_1:\n                    case BGP_EXT_COM_L2VPN_RT_1:\n                    case BGP_EXT_COM_VRF_RT_IMP:\n                        ND_PRINT((ndo, \": %s:%u\",\n                               ipaddr_string(ndo, tptr+2),\n                               EXTRACT_16BITS(tptr+6)));\n                        break;\n                    case BGP_EXT_COM_RT_2:\n                    case BGP_EXT_COM_RO_2:\n\t\t\tND_PRINT((ndo, \": %s:%u\",\n\t\t\t    as_printf(ndo, astostr, sizeof(astostr),\n\t\t\t    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));\n\t\t\tbreak;\n                    case BGP_EXT_COM_LINKBAND:\n\t\t        bw.i = EXTRACT_32BITS(tptr+2);\n                        ND_PRINT((ndo, \": bandwidth: %.3f Mbps\",\n                               bw.f*8/1000000));\n                        break;\n                    case BGP_EXT_COM_VPN_ORIGIN:\n                    case BGP_EXT_COM_VPN_ORIGIN2:\n                    case BGP_EXT_COM_VPN_ORIGIN3:\n                    case BGP_EXT_COM_VPN_ORIGIN4:\n                    case BGP_EXT_COM_OSPF_RID:\n                    case BGP_EXT_COM_OSPF_RID2:\n                        ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr+2)));\n                        break;\n                    case BGP_EXT_COM_OSPF_RTYPE:\n                    case BGP_EXT_COM_OSPF_RTYPE2:\n                        ND_PRINT((ndo, \": area:%s, router-type:%s, metric-type:%s%s\",\n                               ipaddr_string(ndo, tptr+2),\n                               tok2str(bgp_extd_comm_ospf_rtype_values,\n\t\t\t\t\t  \"unknown (0x%02x)\",\n\t\t\t\t\t  *(tptr+6)),\n                               (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? \"E2\" : \"\",\n                               ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? \"E1\" : \"\"));\n                        break;\n                    case BGP_EXT_COM_L2INFO:\n                        ND_PRINT((ndo, \": %s Control Flags [0x%02x]:MTU %u\",\n                               tok2str(l2vpn_encaps_values,\n\t\t\t\t\t  \"unknown encaps\",\n\t\t\t\t\t  *(tptr+2)),\n                                       *(tptr+3),\n                               EXTRACT_16BITS(tptr+4)));\n                        break;\n                    case BGP_EXT_COM_SOURCE_AS:\n                        ND_PRINT((ndo, \": AS %u\", EXTRACT_16BITS(tptr+2)));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,8);\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", 8);\n                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n\n>>> [ INFILL ] <<<\n                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {\n                case BGP_PMSI_TUNNEL_PIM_SM: /* fall through */\n                case BGP_PMSI_TUNNEL_PIM_BIDIR:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Sender %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n\n                case BGP_PMSI_TUNNEL_PIM_SSM:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_INGRESS:\n                    ND_TCHECK2(tptr[0], 4);\n                    ND_PRINT((ndo, \"\\n\\t      Tunnel-Endpoint %s\",\n                           ipaddr_string(ndo, tptr)));\n                    break;\n                case BGP_PMSI_TUNNEL_LDP_P2MP: /* fall through */\n                case BGP_PMSI_TUNNEL_LDP_MP2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, LSP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_RSVP_P2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                default:\n                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    ND_TCHECK2(tptr[0], 3);\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\t\t    tptr += 3;\n\t\t    tlen -= 3;\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    if (length < 3)\n\t\t\tgoto trunc;\n\t\t    length -= 3;\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        if (length < 8)\n\t\t            goto trunc;\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr,\"\\n\\t      \", length);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);\n                if (len < 4)\n                \tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t    Origin AS: %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));\n\t\ttptr+=4;\n                len -=4;\n\n                while (len) {\n                    u_int aflags, alenlen, alen;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    if (len < 2)\n                        goto trunc;\n                    aflags = *tptr;\n                    atype = *(tptr + 1);\n                    tptr += 2;\n                    len -= 2;\n                    alenlen = bgp_attr_lenlen(aflags, tptr);\n                    ND_TCHECK2(tptr[0], alenlen);\n                    if (len < alenlen)\n                        goto trunc;\n                    alen = bgp_attr_len(aflags, tptr);\n                    tptr += alenlen;\n                    len -= alenlen;\n\n                    ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                           tok2str(bgp_attr_values,\n                                      \"Unknown Attribute\", atype),\n                           atype,\n                           alen));\n\n                    if (aflags) {\n                        ND_PRINT((ndo, \", Flags [%s%s%s%s\",\n                               aflags & 0x80 ? \"O\" : \"\",\n                               aflags & 0x40 ? \"T\" : \"\",\n                               aflags & 0x20 ? \"P\" : \"\",\n                               aflags & 0x10 ? \"E\" : \"\"));\n                        if (aflags & 0xf)\n                            ND_PRINT((ndo, \"+%x\", aflags & 0xf));\n                        ND_PRINT((ndo, \"]: \"));\n                    }\n                    /* FIXME check for recursion */\n                    if (!bgp_attr_print(ndo, atype, tptr, alen))\n                        return 0;\n                    tptr += alen;\n                    len -= alen;\n\t\t}\n                break;\n\n\tcase BGPTYPE_LARGE_COMMUNITY:\n\t\tif (len == 0 || len % 12) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\twhile (len > 0) {\n\t\t\tND_TCHECK2(*tptr, 12);\n\t\t\tND_PRINT((ndo, \"%u:%u:%u%s\",\n\t\t\t\t EXTRACT_32BITS(tptr),\n\t\t\t\t EXTRACT_32BITS(tptr + 4),\n\t\t\t\t EXTRACT_32BITS(tptr + 8),\n\t\t\t\t (len > 12) ? \", \" : \"\"));\n                        tptr += 12;\n                        len -= 12;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t    ND_TCHECK2(*pptr,len);\n            ND_PRINT((ndo, \"\\n\\t    no Attribute %u decoder\", atype)); /* we have no decoder for the attribute */\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n            break;\n\t}\n        if (ndo->ndo_vflag > 1 && len) { /* omit zero length attributes*/\n            ND_TCHECK2(*pptr,len);\n            print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n        }\n        return 1;\n\ntrunc:\n        return 0;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                ND_TCHECK2(tptr[0], 5);\n\n```\n\n\n\nwith the following test error:     bgp_pmsi_tunnel-oobr               : passed\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "d10a0f980fe8f9407ab1ffbd612641433ebe175e___print-bgp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic int\nrsvp_obj_print(netdissect_options *ndo,\n               const u_char *pptr, u_int plen, const u_char *tptr,\n               const char *ident, u_int tlen,\n               const struct rsvp_common_header *rsvp_com_header)\n{\n    const struct rsvp_object_header *rsvp_obj_header;\n    const u_char *obj_tptr;\n    union {\n        const struct rsvp_obj_integrity_t *rsvp_obj_integrity;\n        const struct rsvp_obj_frr_t *rsvp_obj_frr;\n    } obj_ptr;\n\n    u_short rsvp_obj_len,rsvp_obj_ctype,obj_tlen,intserv_serv_tlen;\n    int hexdump,processed,padbytes,error_code,error_value,i,sigcheck;\n    union {\n\tfloat f;\n\tuint32_t i;\n    } bw;\n    uint8_t namelen;\n\n    u_int action, subchannel;\n\n    while(tlen>=sizeof(struct rsvp_object_header)) {\n        /* did we capture enough for fully decoding the object header ? */\n        ND_TCHECK2(*tptr, sizeof(struct rsvp_object_header));\n\n        rsvp_obj_header = (const struct rsvp_object_header *)tptr;\n        rsvp_obj_len=EXTRACT_16BITS(rsvp_obj_header->length);\n        rsvp_obj_ctype=rsvp_obj_header->ctype;\n\n        if(rsvp_obj_len % 4) {\n            ND_PRINT((ndo, \"%sERROR: object header size %u not a multiple of 4\", ident, rsvp_obj_len));\n            return -1;\n        }\n        if(rsvp_obj_len < sizeof(struct rsvp_object_header)) {\n            ND_PRINT((ndo, \"%sERROR: object header too short %u < %lu\", ident, rsvp_obj_len,\n                   (unsigned long)sizeof(const struct rsvp_object_header)));\n            return -1;\n        }\n\n        ND_PRINT((ndo, \"%s%s Object (%u) Flags: [%s\",\n               ident,\n               tok2str(rsvp_obj_values,\n                       \"Unknown\",\n                       rsvp_obj_header->class_num),\n               rsvp_obj_header->class_num,\n               ((rsvp_obj_header->class_num) & 0x80) ? \"ignore\" : \"reject\"));\n\n        if (rsvp_obj_header->class_num > 128)\n            ND_PRINT((ndo, \" %s\",\n                   ((rsvp_obj_header->class_num) & 0x40) ? \"and forward\" : \"silently\"));\n\n        ND_PRINT((ndo, \" if unknown], Class-Type: %s (%u), length: %u\",\n               tok2str(rsvp_ctype_values,\n                       \"Unknown\",\n                       ((rsvp_obj_header->class_num)<<8)+rsvp_obj_ctype),\n               rsvp_obj_ctype,\n               rsvp_obj_len));\n\n        if(tlen < rsvp_obj_len) {\n            ND_PRINT((ndo, \"%sERROR: object goes past end of objects TLV\", ident));\n            return -1;\n        }\n\n        obj_tptr=tptr+sizeof(struct rsvp_object_header);\n        obj_tlen=rsvp_obj_len-sizeof(struct rsvp_object_header);\n\n        /* did we capture enough for fully decoding the object ? */\n        if (!ND_TTEST2(*tptr, rsvp_obj_len))\n            return -1;\n        hexdump=FALSE;\n\n        switch(rsvp_obj_header->class_num) {\n        case RSVP_OBJ_SESSION:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 DestAddress: %s, Protocol ID: 0x%02x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       *(obj_tptr + sizeof(struct in_addr))));\n                ND_PRINT((ndo, \"%s  Flags: [0x%02x], DestPort %u\",\n                       ident,\n                       *(obj_tptr+5),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 DestAddress: %s, Protocol ID: 0x%02x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       *(obj_tptr + sizeof(struct in6_addr))));\n                ND_PRINT((ndo, \"%s  Flags: [0x%02x], DestPort %u\",\n                       ident,\n                       *(obj_tptr+sizeof(struct in6_addr)+1),\n                       EXTRACT_16BITS(obj_tptr + sizeof(struct in6_addr) + 2)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n\n            case RSVP_CTYPE_TUNNEL_IPV6:\n                if (obj_tlen < 36)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ip6addr_string(ndo, obj_tptr + 20)));\n                obj_tlen-=36;\n                obj_tptr+=36;\n                break;\n\n            case RSVP_CTYPE_14: /* IPv6 p2mp LSP Tunnel */\n                if (obj_tlen < 26)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 P2MP LSP ID: 0x%08x, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ip6addr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=26;\n                obj_tptr+=26;\n                break;\n            case RSVP_CTYPE_13: /* IPv4 p2mp LSP Tunnel */\n                if (obj_tlen < 12)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 P2MP LSP ID: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ipaddr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n            case RSVP_CTYPE_UNI_IPV4:\n                if (obj_tlen < 12)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ipaddr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_CONFIRM:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < sizeof(struct in_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Receiver Address: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in_addr);\n                obj_tptr+=sizeof(struct in_addr);\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < sizeof(struct in6_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 Receiver Address: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in6_addr);\n                obj_tptr+=sizeof(struct in6_addr);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_NOTIFY_REQ:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < sizeof(struct in_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Notify Node Address: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in_addr);\n                obj_tptr+=sizeof(struct in_addr);\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < sizeof(struct in6_addr))\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Notify Node Address: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in6_addr);\n                obj_tptr+=sizeof(struct in6_addr);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SUGGESTED_LABEL: /* fall through */\n        case RSVP_OBJ_UPSTREAM_LABEL:  /* fall through */\n        case RSVP_OBJ_RECOVERY_LABEL:  /* fall through */\n        case RSVP_OBJ_LABEL:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                while(obj_tlen >= 4 ) {\n                    ND_PRINT((ndo, \"%s  Label: %u\", ident, EXTRACT_32BITS(obj_tptr)));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Generalized Label: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Waveband ID: %u%s  Start Label: %u, Stop Label: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       ident,\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_STYLE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Reservation Style: %s, Flags: [0x%02x]\",\n                       ident,\n                       tok2str(rsvp_resstyle_values,\n                               \"Unknown\",\n                               EXTRACT_24BITS(obj_tptr+1)),\n                       *(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SENDER_TEMPLATE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_13: /* IPv6 p2mp LSP tunnel */\n                if (obj_tlen < 40)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ident,\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_16BITS(obj_tptr + 38)));\n                obj_tlen-=40;\n                obj_tptr+=40;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_12: /* IPv4 p2mp LSP tunnel */\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ident,\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_16BITS(obj_tptr + 12)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_LABEL_REQ:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                while(obj_tlen >= 4 ) {\n                    ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                           ident,\n                           tok2str(ethertype_values,\n                                   \"Unknown Protocol (0x%04x)\",\n                                   EXTRACT_16BITS(obj_tptr + 2))));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                       ident,\n                       tok2str(ethertype_values,\n                               \"Unknown Protocol (0x%04x)\",\n                               EXTRACT_16BITS(obj_tptr + 2))));\n                ND_PRINT((ndo, \",%s merge capability\",((*(obj_tptr + 4)) & 0x80) ? \"no\" : \"\" ));\n                ND_PRINT((ndo, \"%s  Minimum VPI/VCI: %u/%u\",\n                       ident,\n                       (EXTRACT_16BITS(obj_tptr+4))&0xfff,\n                       (EXTRACT_16BITS(obj_tptr + 6)) & 0xfff));\n                ND_PRINT((ndo, \"%s  Maximum VPI/VCI: %u/%u\",\n                       ident,\n                       (EXTRACT_16BITS(obj_tptr+8))&0xfff,\n                       (EXTRACT_16BITS(obj_tptr + 10)) & 0xfff));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                       ident,\n                       tok2str(ethertype_values,\n                               \"Unknown Protocol (0x%04x)\",\n                               EXTRACT_16BITS(obj_tptr + 2))));\n                ND_PRINT((ndo, \"%s  Minimum/Maximum DLCI: %u/%u, %s%s bit DLCI\",\n                       ident,\n                       (EXTRACT_32BITS(obj_tptr+4))&0x7fffff,\n                       (EXTRACT_32BITS(obj_tptr+8))&0x7fffff,\n                       (((EXTRACT_16BITS(obj_tptr+4)>>7)&3) == 0 ) ? \"10\" : \"\",\n                       (((EXTRACT_16BITS(obj_tptr + 4) >> 7) & 3) == 2 ) ? \"23\" : \"\"));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_4:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  LSP Encoding Type: %s (%u)\",\n                       ident,\n                       tok2str(gmpls_encoding_values,\n                               \"Unknown\",\n                               *obj_tptr),\n\t\t       *obj_tptr));\n                ND_PRINT((ndo, \"%s  Switching Type: %s (%u), Payload ID: %s (0x%04x)\",\n                       ident,\n                       tok2str(gmpls_switch_cap_values,\n                               \"Unknown\",\n                               *(obj_tptr+1)),\n\t\t       *(obj_tptr+1),\n                       tok2str(gmpls_payload_values,\n                               \"Unknown\",\n                               EXTRACT_16BITS(obj_tptr+2)),\n\t\t       EXTRACT_16BITS(obj_tptr + 2)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RRO:\n        case RSVP_OBJ_ERO:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                while(obj_tlen >= 4 ) {\n\t\t    u_char length;\n\n\t\t    ND_TCHECK2(*obj_tptr, 4);\n\t\t    length = *(obj_tptr + 1);\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s, length %u\",\n                           ident,\n                           tok2str(rsvp_obj_xro_values,\n                                   \"Unknown %u\",\n                                   RSVP_OBJ_XRO_MASK_SUBOBJ(*obj_tptr)),\n                           length));\n\n                    if (length == 0) { /* prevent infinite loops */\n                        ND_PRINT((ndo, \"%s  ERROR: zero length ERO subtype\", ident));\n                        break;\n                    }\n\n                    switch(RSVP_OBJ_XRO_MASK_SUBOBJ(*obj_tptr)) {\n\t\t    u_char prefix_length;\n\n                    case RSVP_OBJ_XRO_IPV4:\n\t\t\tif (length != 8) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: length != 8\"));\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tND_TCHECK2(*obj_tptr, 8);\n\t\t\tprefix_length = *(obj_tptr+6);\n\t\t\tif (prefix_length != 32) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: Prefix length %u != 32\",\n\t\t\t\t\t  prefix_length));\n\t\t\t\tgoto invalid;\n\t\t\t}\n                        ND_PRINT((ndo, \", %s, %s/%u, Flags: [%s]\",\n                               RSVP_OBJ_XRO_MASK_LOOSE(*obj_tptr) ? \"Loose\" : \"Strict\",\n                               ipaddr_string(ndo, obj_tptr+2),\n                               *(obj_tptr+6),\n                               bittok2str(rsvp_obj_rro_flag_values,\n                                   \"none\",\n                                   *(obj_tptr + 7)))); /* rfc3209 says that this field is rsvd. */\n                    break;\n                    case RSVP_OBJ_XRO_LABEL:\n\t\t\tif (length != 8) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: length != 8\"));\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tND_TCHECK2(*obj_tptr, 8);\n                        ND_PRINT((ndo, \", Flags: [%s] (%#x), Class-Type: %s (%u), %u\",\n                               bittok2str(rsvp_obj_rro_label_flag_values,\n                                   \"none\",\n                                   *(obj_tptr+2)),\n                               *(obj_tptr+2),\n                               tok2str(rsvp_ctype_values,\n                                       \"Unknown\",\n                                       *(obj_tptr+3) + 256*RSVP_OBJ_RRO),\n                               *(obj_tptr+3),\n                               EXTRACT_32BITS(obj_tptr + 4)));\n                    }\n                    obj_tlen-=*(obj_tptr+1);\n                    obj_tptr+=*(obj_tptr+1);\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_HELLO:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Instance: 0x%08x, Destination Instance: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RESTART_CAPABILITY:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Restart  Time: %ums, Recovery Time: %ums\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SESSION_ATTRIBUTE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 4)\n                    return-1;\n                namelen = *(obj_tptr+3);\n                if (obj_tlen < 4+namelen)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Session Name: \", ident));\n                for (i = 0; i < namelen; i++)\n                    safeputchar(ndo, *(obj_tptr + 4 + i));\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Flags: [%s] (%#x)\",\n                       ident,\n                       (int)*obj_tptr,\n                       (int)*(obj_tptr+1),\n                       bittok2str(rsvp_session_attribute_flag_values,\n                                  \"none\",\n                                  *(obj_tptr+2)),\n                       *(obj_tptr + 2)));\n                obj_tlen-=4+*(obj_tptr+3);\n                obj_tptr+=4+*(obj_tptr+3);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase RSVP_OBJ_GENERALIZED_UNI:\n            switch(rsvp_obj_ctype) {\n\t\tint subobj_type,af,subobj_len,total_subobj_len;\n\n            case RSVP_CTYPE_1:\n\n                if (obj_tlen < 4)\n                    return-1;\n\n\t\t/* read variable length subobjects */\n\t\ttotal_subobj_len = obj_tlen;\n                while(total_subobj_len > 0) {\n                    subobj_len  = EXTRACT_16BITS(obj_tptr);\n                    subobj_type = (EXTRACT_16BITS(obj_tptr+2))>>8;\n                    af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;\n\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s (%u), AF: %s (%u), length: %u\",\n                           ident,\n                           tok2str(rsvp_obj_generalized_uni_values, \"Unknown\", subobj_type),\n                           subobj_type,\n                           tok2str(af_values, \"Unknown\", af), af,\n                           subobj_len));\n\n                    if(subobj_len == 0)\n                        goto invalid;\n\n                    switch(subobj_type) {\n                    case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS:\n                    case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS:\n\n                        switch(af) {\n                        case AFNUM_INET:\n                            if (subobj_len < 8)\n                                return -1;\n                            ND_PRINT((ndo, \"%s    UNI IPv4 TNA address: %s\",\n                                   ident, ipaddr_string(ndo, obj_tptr + 4)));\n                            break;\n                        case AFNUM_INET6:\n                            if (subobj_len < 20)\n                                return -1;\n                            ND_PRINT((ndo, \"%s    UNI IPv6 TNA address: %s\",\n                                   ident, ip6addr_string(ndo, obj_tptr + 4)));\n                            break;\n                        case AFNUM_NSAP:\n                            if (subobj_len) {\n                                /* unless we have a TLV parser lets just hexdump */\n                                hexdump=TRUE;\n                            }\n                            break;\n                        }\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_DIVERSITY:\n                        if (subobj_len) {\n                            /* unless we have a TLV parser lets just hexdump */\n                            hexdump=TRUE;\n                        }\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL:\n                        if (subobj_len < 16) {\n                            return -1;\n                        }\n\n                        ND_PRINT((ndo, \"%s    U-bit: %x, Label type: %u, Logical port id: %u, Label: %u\",\n                               ident,\n                               ((EXTRACT_32BITS(obj_tptr+4))>>31),\n                               ((EXTRACT_32BITS(obj_tptr+4))&0xFF),\n                               EXTRACT_32BITS(obj_tptr+8),\n                               EXTRACT_32BITS(obj_tptr + 12)));\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL:\n                        if (subobj_len < 8) {\n                            return -1;\n                        }\n\n                        ND_PRINT((ndo, \"%s    Service level: %u\",\n                               ident, (EXTRACT_32BITS(obj_tptr + 4)) >> 24));\n                        break;\n\n                    default:\n                        hexdump=TRUE;\n                        break;\n                    }\n                    total_subobj_len-=subobj_len;\n                    obj_tptr+=subobj_len;\n                    obj_tlen+=subobj_len;\n\t\t}\n\n                if (total_subobj_len) {\n                    /* unless we have a TLV parser lets just hexdump */\n                    hexdump=TRUE;\n                }\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RSVP_HOP:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_3: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                if (obj_tlen)\n                    hexdump=TRUE; /* unless we have a TLV parser lets just hexdump */\n                break;\n            case RSVP_CTYPE_4: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 16)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                hexdump=TRUE; /* unless we have a TLV parser lets just hexdump */\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_TIME_VALUES:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Refresh Period: %ums\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        /* those three objects do share the same semantics */\n        case RSVP_OBJ_SENDER_TSPEC:\n        case RSVP_OBJ_ADSPEC:\n        case RSVP_OBJ_FLOWSPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Msg-Version: %u, length: %u\",\n                       ident,\n                       (*obj_tptr & 0xf0) >> 4,\n                       EXTRACT_16BITS(obj_tptr + 2) << 2));\n                obj_tptr+=4; /* get to the start of the service header */\n                obj_tlen-=4;\n\n                while (obj_tlen >= 4) {\n                    intserv_serv_tlen=EXTRACT_16BITS(obj_tptr+2)<<2;\n                    ND_PRINT((ndo, \"%s  Service Type: %s (%u), break bit %s set, Service length: %u\",\n                           ident,\n                           tok2str(rsvp_intserv_service_type_values,\"unknown\",*(obj_tptr)),\n                           *(obj_tptr),\n                           (*(obj_tptr+1)&0x80) ? \"\" : \"not\",\n                           intserv_serv_tlen));\n\n                    obj_tptr+=4; /* get to the start of the parameter list */\n                    obj_tlen-=4;\n\n                    while (intserv_serv_tlen>=4) {\n                        processed = rsvp_intserv_print(ndo, obj_tptr, obj_tlen);\n                        if (processed == 0)\n                            break;\n                        obj_tlen-=processed;\n                        intserv_serv_tlen-=processed;\n                        obj_tptr+=processed;\n                    }\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_FILTERSPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Flow Label: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_24BITS(obj_tptr + 17)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_13: /* IPv6 p2mp LSP tunnel */\n                if (obj_tlen < 40)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ident,\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_16BITS(obj_tptr + 38)));\n                obj_tlen-=40;\n                obj_tptr+=40;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_12: /* IPv4 p2mp LSP tunnel */\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ident,\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_16BITS(obj_tptr + 12)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_FASTREROUTE:\n            /* the differences between c-type 1 and 7 are minor */\n            obj_ptr.rsvp_obj_frr = (const struct rsvp_obj_frr_t *)obj_tptr;\n\n>>> [ INFILL ] <<<\n\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1: /* new style */\n                if (obj_tlen < sizeof(struct rsvp_obj_frr_t))\n                    return-1;\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps\",\n                       ident,\n                       (int)obj_ptr.rsvp_obj_frr->setup_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hold_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hop_limit,\n                        bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Include-any: 0x%08x, Exclude-any: 0x%08x, Include-all: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->exclude_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_all)));\n                obj_tlen-=sizeof(struct rsvp_obj_frr_t);\n                obj_tptr+=sizeof(struct rsvp_obj_frr_t);\n                break;\n\n            case RSVP_CTYPE_TUNNEL_IPV4: /* old style */\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps\",\n                       ident,\n                       (int)obj_ptr.rsvp_obj_frr->setup_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hold_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hop_limit,\n                        bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Include Colors: 0x%08x, Exclude Colors: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->exclude_any)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_DETOUR:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                while(obj_tlen >= 8) {\n                    ND_PRINT((ndo, \"%s  PLR-ID: %s, Avoid-Node-ID: %s\",\n                           ident,\n                           ipaddr_string(ndo, obj_tptr),\n                           ipaddr_string(ndo, obj_tptr + 4)));\n                    obj_tlen-=8;\n                    obj_tptr+=8;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_CLASSTYPE:\n        case RSVP_OBJ_CLASSTYPE_OLD: /* fall through */\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                ND_PRINT((ndo, \"%s  CT: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr) & 0x7));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_ERROR_SPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_3: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                error_code=*(obj_tptr+5);\n                error_value=EXTRACT_16BITS(obj_tptr+6);\n                ND_PRINT((ndo, \"%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       *(obj_tptr+4),\n                       ident,\n                       tok2str(rsvp_obj_error_code_values,\"unknown\",error_code),\n                       error_code));\n                switch (error_code) {\n                case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_routing_values,\"unknown\",error_value),\n                           error_value));\n                    break;\n                case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE: /* fall through */\n                case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_diffserv_te_values,\"unknown\",error_value),\n                           error_value));\n                    break;\n                default:\n                    ND_PRINT((ndo, \", Unknown Error Value (%u)\", error_value));\n                    break;\n                }\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_4: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                error_code=*(obj_tptr+17);\n                error_value=EXTRACT_16BITS(obj_tptr+18);\n                ND_PRINT((ndo, \"%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       *(obj_tptr+16),\n                       ident,\n                       tok2str(rsvp_obj_error_code_values,\"unknown\",error_code),\n                       error_code));\n\n                switch (error_code) {\n                case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_routing_values,\"unknown\",error_value),\n\t\t\t   error_value));\n                    break;\n                default:\n                    break;\n                }\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_PROPERTIES:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                padbytes = EXTRACT_16BITS(obj_tptr+2);\n                ND_PRINT((ndo, \"%s  TLV count: %u, padding bytes: %u\",\n                       ident,\n                       EXTRACT_16BITS(obj_tptr),\n                       padbytes));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                /* loop through as long there is anything longer than the TLV header (2) */\n                while(obj_tlen >= 2 + padbytes) {\n                    ND_PRINT((ndo, \"%s    %s TLV (0x%02x), length: %u\", /* length includes header */\n                           ident,\n                           tok2str(rsvp_obj_prop_tlv_values,\"unknown\",*obj_tptr),\n                           *obj_tptr,\n                           *(obj_tptr + 1)));\n                    if (obj_tlen < *(obj_tptr+1))\n                        return-1;\n                    if (*(obj_tptr+1) < 2)\n                        return -1;\n                    print_unknown_data(ndo, obj_tptr + 2, \"\\n\\t\\t\", *(obj_tptr + 1) - 2);\n                    obj_tlen-=*(obj_tptr+1);\n                    obj_tptr+=*(obj_tptr+1);\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_MESSAGE_ID:     /* fall through */\n        case RSVP_OBJ_MESSAGE_ID_ACK: /* fall through */\n        case RSVP_OBJ_MESSAGE_ID_LIST:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Flags [0x%02x], epoch: %u\",\n                       ident,\n                       *obj_tptr,\n                       EXTRACT_24BITS(obj_tptr + 1)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                /* loop through as long there are no messages left */\n                while(obj_tlen >= 4) {\n                    ND_PRINT((ndo, \"%s    Message-ID 0x%08x (%u)\",\n                           ident,\n                           EXTRACT_32BITS(obj_tptr),\n                           EXTRACT_32BITS(obj_tptr)));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_INTEGRITY:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < sizeof(struct rsvp_obj_integrity_t))\n                    return-1;\n                obj_ptr.rsvp_obj_integrity = (const struct rsvp_obj_integrity_t *)obj_tptr;\n                ND_PRINT((ndo, \"%s  Key-ID 0x%04x%08x, Sequence 0x%08x%08x, Flags [%s]\",\n                       ident,\n                       EXTRACT_16BITS(obj_ptr.rsvp_obj_integrity->key_id),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->key_id+2),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->sequence),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->sequence+4),\n                       bittok2str(rsvp_obj_integrity_flag_values,\n                                  \"none\",\n                                  obj_ptr.rsvp_obj_integrity->flags)));\n                ND_PRINT((ndo, \"%s  MD5-sum 0x%08x%08x%08x%08x \",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest+4),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest+8),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest + 12)));\n\n                sigcheck = signature_verify(ndo, pptr, plen,\n                                            obj_ptr.rsvp_obj_integrity->digest,\n                                            rsvp_clear_checksum,\n                                            rsvp_com_header);\n                ND_PRINT((ndo, \" (%s)\", tok2str(signature_check_values, \"Unknown\", sigcheck)));\n\n                obj_tlen+=sizeof(struct rsvp_obj_integrity_t);\n                obj_tptr+=sizeof(struct rsvp_obj_integrity_t);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_ADMIN_STATUS:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Flags [%s]\", ident,\n                       bittok2str(rsvp_obj_admin_status_flag_values, \"none\",\n                                  EXTRACT_32BITS(obj_tptr))));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_LABEL_SET:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                action = (EXTRACT_16BITS(obj_tptr)>>8);\n\n                ND_PRINT((ndo, \"%s  Action: %s (%u), Label type: %u\", ident,\n                       tok2str(rsvp_obj_label_set_action_values, \"Unknown\", action),\n                       action, ((EXTRACT_32BITS(obj_tptr) & 0x7F))));\n\n                switch (action) {\n                case LABEL_SET_INCLUSIVE_RANGE:\n                case LABEL_SET_EXCLUSIVE_RANGE: /* fall through */\n\n\t\t    /* only a couple of subchannels are expected */\n\t\t    if (obj_tlen < 12)\n\t\t\treturn -1;\n\t\t    ND_PRINT((ndo, \"%s  Start range: %u, End range: %u\", ident,\n                           EXTRACT_32BITS(obj_tptr+4),\n                           EXTRACT_32BITS(obj_tptr + 8)));\n\t\t    obj_tlen-=12;\n\t\t    obj_tptr+=12;\n                    break;\n\n                default:\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                    subchannel = 1;\n                    while(obj_tlen >= 4 ) {\n                        ND_PRINT((ndo, \"%s  Subchannel #%u: %u\", ident, subchannel,\n                               EXTRACT_32BITS(obj_tptr)));\n                        obj_tptr+=4;\n                        obj_tlen-=4;\n                        subchannel++;\n                    }\n                    break;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_S2L:\n            switch (rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Sub-LSP destination address: %s\",\n                       ident, ipaddr_string(ndo, obj_tptr)));\n\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Sub-LSP destination address: %s\",\n                       ident, ip6addr_string(ndo, obj_tptr)));\n\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        /*\n         *  FIXME those are the defined objects that lack a decoder\n         *  you are welcome to contribute code ;-)\n         */\n\n        case RSVP_OBJ_SCOPE:\n        case RSVP_OBJ_POLICY_DATA:\n        case RSVP_OBJ_ACCEPT_LABEL_SET:\n        case RSVP_OBJ_PROTECTION:\n        default:\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen); /* FIXME indentation */\n            break;\n        }\n        /* do we also want to see a hex dump ? */\n        if (ndo->ndo_vflag > 1 || hexdump == TRUE)\n            print_unknown_data(ndo, tptr + sizeof(struct rsvp_object_header), \"\\n\\t    \", /* FIXME indentation */\n                               rsvp_obj_len - sizeof(struct rsvp_object_header));\n\n        tptr+=rsvp_obj_len;\n        tlen-=rsvp_obj_len;\n    }\n    return 0;\ninvalid:\n    ND_PRINT((ndo, \"%s\", istr));\n    return -1;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t\\t\"));\n    ND_PRINT((ndo, \"%s\", tstr));\n    return -1;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n            bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);\n\n```\n\n\n\nwith the following test error:     rsvp_fast_reroute-oobr             : passed\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "3c8a2b0e91d8d8947e89384dacf6b54673083e71___print-rsvp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic int\nrsvp_obj_print(netdissect_options *ndo,\n               const u_char *pptr, u_int plen, const u_char *tptr,\n               const char *ident, u_int tlen,\n               const struct rsvp_common_header *rsvp_com_header)\n{\n    const struct rsvp_object_header *rsvp_obj_header;\n    const u_char *obj_tptr;\n    union {\n        const struct rsvp_obj_integrity_t *rsvp_obj_integrity;\n        const struct rsvp_obj_frr_t *rsvp_obj_frr;\n    } obj_ptr;\n\n    u_short rsvp_obj_len,rsvp_obj_ctype,obj_tlen,intserv_serv_tlen;\n    int hexdump,processed,padbytes,error_code,error_value,i,sigcheck;\n    union {\n\tfloat f;\n\tuint32_t i;\n    } bw;\n    uint8_t namelen;\n\n    u_int action, subchannel;\n\n    while(tlen>=sizeof(struct rsvp_object_header)) {\n        /* did we capture enough for fully decoding the object header ? */\n        ND_TCHECK2(*tptr, sizeof(struct rsvp_object_header));\n\n        rsvp_obj_header = (const struct rsvp_object_header *)tptr;\n        rsvp_obj_len=EXTRACT_16BITS(rsvp_obj_header->length);\n        rsvp_obj_ctype=rsvp_obj_header->ctype;\n\n        if(rsvp_obj_len % 4) {\n            ND_PRINT((ndo, \"%sERROR: object header size %u not a multiple of 4\", ident, rsvp_obj_len));\n            return -1;\n        }\n        if(rsvp_obj_len < sizeof(struct rsvp_object_header)) {\n            ND_PRINT((ndo, \"%sERROR: object header too short %u < %lu\", ident, rsvp_obj_len,\n                   (unsigned long)sizeof(const struct rsvp_object_header)));\n            return -1;\n        }\n\n        ND_PRINT((ndo, \"%s%s Object (%u) Flags: [%s\",\n               ident,\n               tok2str(rsvp_obj_values,\n                       \"Unknown\",\n                       rsvp_obj_header->class_num),\n               rsvp_obj_header->class_num,\n               ((rsvp_obj_header->class_num) & 0x80) ? \"ignore\" : \"reject\"));\n\n        if (rsvp_obj_header->class_num > 128)\n            ND_PRINT((ndo, \" %s\",\n                   ((rsvp_obj_header->class_num) & 0x40) ? \"and forward\" : \"silently\"));\n\n        ND_PRINT((ndo, \" if unknown], Class-Type: %s (%u), length: %u\",\n               tok2str(rsvp_ctype_values,\n                       \"Unknown\",\n                       ((rsvp_obj_header->class_num)<<8)+rsvp_obj_ctype),\n               rsvp_obj_ctype,\n               rsvp_obj_len));\n\n        if(tlen < rsvp_obj_len) {\n            ND_PRINT((ndo, \"%sERROR: object goes past end of objects TLV\", ident));\n            return -1;\n        }\n\n        obj_tptr=tptr+sizeof(struct rsvp_object_header);\n        obj_tlen=rsvp_obj_len-sizeof(struct rsvp_object_header);\n\n        /* did we capture enough for fully decoding the object ? */\n        if (!ND_TTEST2(*tptr, rsvp_obj_len))\n            return -1;\n        hexdump=FALSE;\n\n        switch(rsvp_obj_header->class_num) {\n        case RSVP_OBJ_SESSION:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 DestAddress: %s, Protocol ID: 0x%02x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       *(obj_tptr + sizeof(struct in_addr))));\n                ND_PRINT((ndo, \"%s  Flags: [0x%02x], DestPort %u\",\n                       ident,\n                       *(obj_tptr+5),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 DestAddress: %s, Protocol ID: 0x%02x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       *(obj_tptr + sizeof(struct in6_addr))));\n                ND_PRINT((ndo, \"%s  Flags: [0x%02x], DestPort %u\",\n                       ident,\n                       *(obj_tptr+sizeof(struct in6_addr)+1),\n                       EXTRACT_16BITS(obj_tptr + sizeof(struct in6_addr) + 2)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n\n            case RSVP_CTYPE_TUNNEL_IPV6:\n                if (obj_tlen < 36)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ip6addr_string(ndo, obj_tptr + 20)));\n                obj_tlen-=36;\n                obj_tptr+=36;\n                break;\n\n            case RSVP_CTYPE_14: /* IPv6 p2mp LSP Tunnel */\n                if (obj_tlen < 26)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 P2MP LSP ID: 0x%08x, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ip6addr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=26;\n                obj_tptr+=26;\n                break;\n            case RSVP_CTYPE_13: /* IPv4 p2mp LSP Tunnel */\n                if (obj_tlen < 12)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 P2MP LSP ID: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ipaddr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n            case RSVP_CTYPE_UNI_IPV4:\n                if (obj_tlen < 12)\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ipaddr_string(ndo, obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_CONFIRM:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < sizeof(struct in_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Receiver Address: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in_addr);\n                obj_tptr+=sizeof(struct in_addr);\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < sizeof(struct in6_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv6 Receiver Address: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in6_addr);\n                obj_tptr+=sizeof(struct in6_addr);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_NOTIFY_REQ:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < sizeof(struct in_addr))\n                    return -1;\n                ND_PRINT((ndo, \"%s  IPv4 Notify Node Address: %s\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in_addr);\n                obj_tptr+=sizeof(struct in_addr);\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < sizeof(struct in6_addr))\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Notify Node Address: %s\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr)));\n                obj_tlen-=sizeof(struct in6_addr);\n                obj_tptr+=sizeof(struct in6_addr);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SUGGESTED_LABEL: /* fall through */\n        case RSVP_OBJ_UPSTREAM_LABEL:  /* fall through */\n        case RSVP_OBJ_RECOVERY_LABEL:  /* fall through */\n        case RSVP_OBJ_LABEL:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                while(obj_tlen >= 4 ) {\n                    ND_PRINT((ndo, \"%s  Label: %u\", ident, EXTRACT_32BITS(obj_tptr)));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Generalized Label: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Waveband ID: %u%s  Start Label: %u, Stop Label: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       ident,\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr + 8)));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_STYLE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Reservation Style: %s, Flags: [0x%02x]\",\n                       ident,\n                       tok2str(rsvp_resstyle_values,\n                               \"Unknown\",\n                               EXTRACT_24BITS(obj_tptr+1)),\n                       *(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SENDER_TEMPLATE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_13: /* IPv6 p2mp LSP tunnel */\n                if (obj_tlen < 40)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ident,\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_16BITS(obj_tptr + 38)));\n                obj_tlen-=40;\n                obj_tptr+=40;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_12: /* IPv4 p2mp LSP tunnel */\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ident,\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_16BITS(obj_tptr + 12)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_LABEL_REQ:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                while(obj_tlen >= 4 ) {\n                    ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                           ident,\n                           tok2str(ethertype_values,\n                                   \"Unknown Protocol (0x%04x)\",\n                                   EXTRACT_16BITS(obj_tptr + 2))));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                       ident,\n                       tok2str(ethertype_values,\n                               \"Unknown Protocol (0x%04x)\",\n                               EXTRACT_16BITS(obj_tptr + 2))));\n                ND_PRINT((ndo, \",%s merge capability\",((*(obj_tptr + 4)) & 0x80) ? \"no\" : \"\" ));\n                ND_PRINT((ndo, \"%s  Minimum VPI/VCI: %u/%u\",\n                       ident,\n                       (EXTRACT_16BITS(obj_tptr+4))&0xfff,\n                       (EXTRACT_16BITS(obj_tptr + 6)) & 0xfff));\n                ND_PRINT((ndo, \"%s  Maximum VPI/VCI: %u/%u\",\n                       ident,\n                       (EXTRACT_16BITS(obj_tptr+8))&0xfff,\n                       (EXTRACT_16BITS(obj_tptr + 10)) & 0xfff));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 12)\n                    return-1;\n                ND_PRINT((ndo, \"%s  L3 Protocol ID: %s\",\n                       ident,\n                       tok2str(ethertype_values,\n                               \"Unknown Protocol (0x%04x)\",\n                               EXTRACT_16BITS(obj_tptr + 2))));\n                ND_PRINT((ndo, \"%s  Minimum/Maximum DLCI: %u/%u, %s%s bit DLCI\",\n                       ident,\n                       (EXTRACT_32BITS(obj_tptr+4))&0x7fffff,\n                       (EXTRACT_32BITS(obj_tptr+8))&0x7fffff,\n                       (((EXTRACT_16BITS(obj_tptr+4)>>7)&3) == 0 ) ? \"10\" : \"\",\n                       (((EXTRACT_16BITS(obj_tptr + 4) >> 7) & 3) == 2 ) ? \"23\" : \"\"));\n                obj_tlen-=12;\n                obj_tptr+=12;\n                break;\n            case RSVP_CTYPE_4:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  LSP Encoding Type: %s (%u)\",\n                       ident,\n                       tok2str(gmpls_encoding_values,\n                               \"Unknown\",\n                               *obj_tptr),\n\t\t       *obj_tptr));\n                ND_PRINT((ndo, \"%s  Switching Type: %s (%u), Payload ID: %s (0x%04x)\",\n                       ident,\n                       tok2str(gmpls_switch_cap_values,\n                               \"Unknown\",\n                               *(obj_tptr+1)),\n\t\t       *(obj_tptr+1),\n                       tok2str(gmpls_payload_values,\n                               \"Unknown\",\n                               EXTRACT_16BITS(obj_tptr+2)),\n\t\t       EXTRACT_16BITS(obj_tptr + 2)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RRO:\n        case RSVP_OBJ_ERO:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                while(obj_tlen >= 4 ) {\n\t\t    u_char length;\n\n\t\t    ND_TCHECK2(*obj_tptr, 4);\n\t\t    length = *(obj_tptr + 1);\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s, length %u\",\n                           ident,\n                           tok2str(rsvp_obj_xro_values,\n                                   \"Unknown %u\",\n                                   RSVP_OBJ_XRO_MASK_SUBOBJ(*obj_tptr)),\n                           length));\n\n                    if (length == 0) { /* prevent infinite loops */\n                        ND_PRINT((ndo, \"%s  ERROR: zero length ERO subtype\", ident));\n                        break;\n                    }\n\n                    switch(RSVP_OBJ_XRO_MASK_SUBOBJ(*obj_tptr)) {\n\t\t    u_char prefix_length;\n\n                    case RSVP_OBJ_XRO_IPV4:\n\t\t\tif (length != 8) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: length != 8\"));\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tND_TCHECK2(*obj_tptr, 8);\n\t\t\tprefix_length = *(obj_tptr+6);\n\t\t\tif (prefix_length != 32) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: Prefix length %u != 32\",\n\t\t\t\t\t  prefix_length));\n\t\t\t\tgoto invalid;\n\t\t\t}\n                        ND_PRINT((ndo, \", %s, %s/%u, Flags: [%s]\",\n                               RSVP_OBJ_XRO_MASK_LOOSE(*obj_tptr) ? \"Loose\" : \"Strict\",\n                               ipaddr_string(ndo, obj_tptr+2),\n                               *(obj_tptr+6),\n                               bittok2str(rsvp_obj_rro_flag_values,\n                                   \"none\",\n                                   *(obj_tptr + 7)))); /* rfc3209 says that this field is rsvd. */\n                    break;\n                    case RSVP_OBJ_XRO_LABEL:\n\t\t\tif (length != 8) {\n\t\t\t\tND_PRINT((ndo, \" ERROR: length != 8\"));\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tND_TCHECK2(*obj_tptr, 8);\n                        ND_PRINT((ndo, \", Flags: [%s] (%#x), Class-Type: %s (%u), %u\",\n                               bittok2str(rsvp_obj_rro_label_flag_values,\n                                   \"none\",\n                                   *(obj_tptr+2)),\n                               *(obj_tptr+2),\n                               tok2str(rsvp_ctype_values,\n                                       \"Unknown\",\n                                       *(obj_tptr+3) + 256*RSVP_OBJ_RRO),\n                               *(obj_tptr+3),\n                               EXTRACT_32BITS(obj_tptr + 4)));\n                    }\n                    obj_tlen-=*(obj_tptr+1);\n                    obj_tptr+=*(obj_tptr+1);\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_HELLO:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Instance: 0x%08x, Destination Instance: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RESTART_CAPABILITY:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Restart  Time: %ums, Recovery Time: %ums\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_SESSION_ATTRIBUTE:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 4)\n                    return-1;\n                namelen = *(obj_tptr+3);\n                if (obj_tlen < 4+namelen)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Session Name: \", ident));\n                for (i = 0; i < namelen; i++)\n                    safeputchar(ndo, *(obj_tptr + 4 + i));\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Flags: [%s] (%#x)\",\n                       ident,\n                       (int)*obj_tptr,\n                       (int)*(obj_tptr+1),\n                       bittok2str(rsvp_session_attribute_flag_values,\n                                  \"none\",\n                                  *(obj_tptr+2)),\n                       *(obj_tptr + 2)));\n                obj_tlen-=4+*(obj_tptr+3);\n                obj_tptr+=4+*(obj_tptr+3);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase RSVP_OBJ_GENERALIZED_UNI:\n            switch(rsvp_obj_ctype) {\n\t\tint subobj_type,af,subobj_len,total_subobj_len;\n\n            case RSVP_CTYPE_1:\n\n                if (obj_tlen < 4)\n                    return-1;\n\n\t\t/* read variable length subobjects */\n\t\ttotal_subobj_len = obj_tlen;\n                while(total_subobj_len > 0) {\n                    subobj_len  = EXTRACT_16BITS(obj_tptr);\n                    subobj_type = (EXTRACT_16BITS(obj_tptr+2))>>8;\n                    af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;\n\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s (%u), AF: %s (%u), length: %u\",\n                           ident,\n                           tok2str(rsvp_obj_generalized_uni_values, \"Unknown\", subobj_type),\n\n>>> [ INFILL ] <<<\n                           tok2str(af_values, \"Unknown\", af), af,\n                           subobj_len));\n\n                    if(subobj_len == 0)\n                        goto invalid;\n\n                    switch(subobj_type) {\n                    case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS:\n                    case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS:\n\n                        switch(af) {\n                        case AFNUM_INET:\n                            if (subobj_len < 8)\n                                return -1;\n                            ND_PRINT((ndo, \"%s    UNI IPv4 TNA address: %s\",\n                                   ident, ipaddr_string(ndo, obj_tptr + 4)));\n                            break;\n                        case AFNUM_INET6:\n                            if (subobj_len < 20)\n                                return -1;\n                            ND_PRINT((ndo, \"%s    UNI IPv6 TNA address: %s\",\n                                   ident, ip6addr_string(ndo, obj_tptr + 4)));\n                            break;\n                        case AFNUM_NSAP:\n                            if (subobj_len) {\n                                /* unless we have a TLV parser lets just hexdump */\n                                hexdump=TRUE;\n                            }\n                            break;\n                        }\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_DIVERSITY:\n                        if (subobj_len) {\n                            /* unless we have a TLV parser lets just hexdump */\n                            hexdump=TRUE;\n                        }\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL:\n                        if (subobj_len < 16) {\n                            return -1;\n                        }\n\n                        ND_PRINT((ndo, \"%s    U-bit: %x, Label type: %u, Logical port id: %u, Label: %u\",\n                               ident,\n                               ((EXTRACT_32BITS(obj_tptr+4))>>31),\n                               ((EXTRACT_32BITS(obj_tptr+4))&0xFF),\n                               EXTRACT_32BITS(obj_tptr+8),\n                               EXTRACT_32BITS(obj_tptr + 12)));\n                        break;\n\n                    case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL:\n                        if (subobj_len < 8) {\n                            return -1;\n                        }\n\n                        ND_PRINT((ndo, \"%s    Service level: %u\",\n                               ident, (EXTRACT_32BITS(obj_tptr + 4)) >> 24));\n                        break;\n\n                    default:\n                        hexdump=TRUE;\n                        break;\n                    }\n                    total_subobj_len-=subobj_len;\n                    obj_tptr+=subobj_len;\n                    obj_tlen+=subobj_len;\n\t\t}\n\n                if (total_subobj_len) {\n                    /* unless we have a TLV parser lets just hexdump */\n                    hexdump=TRUE;\n                }\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_RSVP_HOP:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_3: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 4)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                if (obj_tlen)\n                    hexdump=TRUE; /* unless we have a TLV parser lets just hexdump */\n                break;\n            case RSVP_CTYPE_4: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr + 16)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                hexdump=TRUE; /* unless we have a TLV parser lets just hexdump */\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_TIME_VALUES:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Refresh Period: %ums\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        /* those three objects do share the same semantics */\n        case RSVP_OBJ_SENDER_TSPEC:\n        case RSVP_OBJ_ADSPEC:\n        case RSVP_OBJ_FLOWSPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Msg-Version: %u, length: %u\",\n                       ident,\n                       (*obj_tptr & 0xf0) >> 4,\n                       EXTRACT_16BITS(obj_tptr + 2) << 2));\n                obj_tptr+=4; /* get to the start of the service header */\n                obj_tlen-=4;\n\n                while (obj_tlen >= 4) {\n                    intserv_serv_tlen=EXTRACT_16BITS(obj_tptr+2)<<2;\n                    ND_PRINT((ndo, \"%s  Service Type: %s (%u), break bit %s set, Service length: %u\",\n                           ident,\n                           tok2str(rsvp_intserv_service_type_values,\"unknown\",*(obj_tptr)),\n                           *(obj_tptr),\n                           (*(obj_tptr+1)&0x80) ? \"\" : \"not\",\n                           intserv_serv_tlen));\n\n                    obj_tptr+=4; /* get to the start of the parameter list */\n                    obj_tlen-=4;\n\n                    while (intserv_serv_tlen>=4) {\n                        processed = rsvp_intserv_print(ndo, obj_tptr, obj_tlen);\n                        if (processed == 0)\n                            break;\n                        obj_tlen-=processed;\n                        intserv_serv_tlen-=processed;\n                        obj_tptr+=processed;\n                    }\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_FILTERSPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Source Port: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_3:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, Flow Label: %u\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_24BITS(obj_tptr + 17)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 18)));\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            case RSVP_CTYPE_13: /* IPv6 p2mp LSP tunnel */\n                if (obj_tlen < 40)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+18),\n                       ident,\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_16BITS(obj_tptr + 38)));\n                obj_tlen-=40;\n                obj_tptr+=40;\n                break;\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Source Address: %s, LSP-ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr + 6)));\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_12: /* IPv4 p2mp LSP tunnel */\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x\"\n                       \"%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+6),\n                       ident,\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_16BITS(obj_tptr + 12)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_FASTREROUTE:\n            /* the differences between c-type 1 and 7 are minor */\n            obj_ptr.rsvp_obj_frr = (const struct rsvp_obj_frr_t *)obj_tptr;\n\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1: /* new style */\n                if (obj_tlen < sizeof(struct rsvp_obj_frr_t))\n                    return-1;\n                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps\",\n                       ident,\n                       (int)obj_ptr.rsvp_obj_frr->setup_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hold_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hop_limit,\n                        bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Include-any: 0x%08x, Exclude-any: 0x%08x, Include-all: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->exclude_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_all)));\n                obj_tlen-=sizeof(struct rsvp_obj_frr_t);\n                obj_tptr+=sizeof(struct rsvp_obj_frr_t);\n                break;\n\n            case RSVP_CTYPE_TUNNEL_IPV4: /* old style */\n                if (obj_tlen < 16)\n                    return-1;\n                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);\n                ND_PRINT((ndo, \"%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps\",\n                       ident,\n                       (int)obj_ptr.rsvp_obj_frr->setup_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hold_prio,\n                       (int)obj_ptr.rsvp_obj_frr->hop_limit,\n                        bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Include Colors: 0x%08x, Exclude Colors: 0x%08x\",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_any),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->exclude_any)));\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_DETOUR:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_TUNNEL_IPV4:\n                while(obj_tlen >= 8) {\n                    ND_PRINT((ndo, \"%s  PLR-ID: %s, Avoid-Node-ID: %s\",\n                           ident,\n                           ipaddr_string(ndo, obj_tptr),\n                           ipaddr_string(ndo, obj_tptr + 4)));\n                    obj_tlen-=8;\n                    obj_tptr+=8;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_CLASSTYPE:\n        case RSVP_OBJ_CLASSTYPE_OLD: /* fall through */\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                ND_PRINT((ndo, \"%s  CT: %u\",\n                       ident,\n                       EXTRACT_32BITS(obj_tptr) & 0x7));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_ERROR_SPEC:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_3: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 8)\n                    return-1;\n                error_code=*(obj_tptr+5);\n                error_value=EXTRACT_16BITS(obj_tptr+6);\n                ND_PRINT((ndo, \"%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)\",\n                       ident,\n                       ipaddr_string(ndo, obj_tptr),\n                       *(obj_tptr+4),\n                       ident,\n                       tok2str(rsvp_obj_error_code_values,\"unknown\",error_code),\n                       error_code));\n                switch (error_code) {\n                case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_routing_values,\"unknown\",error_value),\n                           error_value));\n                    break;\n                case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE: /* fall through */\n                case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_diffserv_te_values,\"unknown\",error_value),\n                           error_value));\n                    break;\n                default:\n                    ND_PRINT((ndo, \", Unknown Error Value (%u)\", error_value));\n                    break;\n                }\n                obj_tlen-=8;\n                obj_tptr+=8;\n                break;\n            case RSVP_CTYPE_4: /* fall through - FIXME add TLV parser */\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 20)\n                    return-1;\n                error_code=*(obj_tptr+17);\n                error_value=EXTRACT_16BITS(obj_tptr+18);\n                ND_PRINT((ndo, \"%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)\",\n                       ident,\n                       ip6addr_string(ndo, obj_tptr),\n                       *(obj_tptr+16),\n                       ident,\n                       tok2str(rsvp_obj_error_code_values,\"unknown\",error_code),\n                       error_code));\n\n                switch (error_code) {\n                case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:\n                    ND_PRINT((ndo, \", Error Value: %s (%u)\",\n                           tok2str(rsvp_obj_error_code_routing_values,\"unknown\",error_value),\n\t\t\t   error_value));\n                    break;\n                default:\n                    break;\n                }\n                obj_tlen-=20;\n                obj_tptr+=20;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_PROPERTIES:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                padbytes = EXTRACT_16BITS(obj_tptr+2);\n                ND_PRINT((ndo, \"%s  TLV count: %u, padding bytes: %u\",\n                       ident,\n                       EXTRACT_16BITS(obj_tptr),\n                       padbytes));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                /* loop through as long there is anything longer than the TLV header (2) */\n                while(obj_tlen >= 2 + padbytes) {\n                    ND_PRINT((ndo, \"%s    %s TLV (0x%02x), length: %u\", /* length includes header */\n                           ident,\n                           tok2str(rsvp_obj_prop_tlv_values,\"unknown\",*obj_tptr),\n                           *obj_tptr,\n                           *(obj_tptr + 1)));\n                    if (obj_tlen < *(obj_tptr+1))\n                        return-1;\n                    if (*(obj_tptr+1) < 2)\n                        return -1;\n                    print_unknown_data(ndo, obj_tptr + 2, \"\\n\\t\\t\", *(obj_tptr + 1) - 2);\n                    obj_tlen-=*(obj_tptr+1);\n                    obj_tptr+=*(obj_tptr+1);\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_MESSAGE_ID:     /* fall through */\n        case RSVP_OBJ_MESSAGE_ID_ACK: /* fall through */\n        case RSVP_OBJ_MESSAGE_ID_LIST:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n            case RSVP_CTYPE_2:\n                if (obj_tlen < 8)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Flags [0x%02x], epoch: %u\",\n                       ident,\n                       *obj_tptr,\n                       EXTRACT_24BITS(obj_tptr + 1)));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                /* loop through as long there are no messages left */\n                while(obj_tlen >= 4) {\n                    ND_PRINT((ndo, \"%s    Message-ID 0x%08x (%u)\",\n                           ident,\n                           EXTRACT_32BITS(obj_tptr),\n                           EXTRACT_32BITS(obj_tptr)));\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_INTEGRITY:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < sizeof(struct rsvp_obj_integrity_t))\n                    return-1;\n                obj_ptr.rsvp_obj_integrity = (const struct rsvp_obj_integrity_t *)obj_tptr;\n                ND_PRINT((ndo, \"%s  Key-ID 0x%04x%08x, Sequence 0x%08x%08x, Flags [%s]\",\n                       ident,\n                       EXTRACT_16BITS(obj_ptr.rsvp_obj_integrity->key_id),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->key_id+2),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->sequence),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->sequence+4),\n                       bittok2str(rsvp_obj_integrity_flag_values,\n                                  \"none\",\n                                  obj_ptr.rsvp_obj_integrity->flags)));\n                ND_PRINT((ndo, \"%s  MD5-sum 0x%08x%08x%08x%08x \",\n                       ident,\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest+4),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest+8),\n                       EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest + 12)));\n\n                sigcheck = signature_verify(ndo, pptr, plen,\n                                            obj_ptr.rsvp_obj_integrity->digest,\n                                            rsvp_clear_checksum,\n                                            rsvp_com_header);\n                ND_PRINT((ndo, \" (%s)\", tok2str(signature_check_values, \"Unknown\", sigcheck)));\n\n                obj_tlen+=sizeof(struct rsvp_obj_integrity_t);\n                obj_tptr+=sizeof(struct rsvp_obj_integrity_t);\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_ADMIN_STATUS:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Flags [%s]\", ident,\n                       bittok2str(rsvp_obj_admin_status_flag_values, \"none\",\n                                  EXTRACT_32BITS(obj_tptr))));\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_LABEL_SET:\n            switch(rsvp_obj_ctype) {\n            case RSVP_CTYPE_1:\n                if (obj_tlen < 4)\n                    return-1;\n                action = (EXTRACT_16BITS(obj_tptr)>>8);\n\n                ND_PRINT((ndo, \"%s  Action: %s (%u), Label type: %u\", ident,\n                       tok2str(rsvp_obj_label_set_action_values, \"Unknown\", action),\n                       action, ((EXTRACT_32BITS(obj_tptr) & 0x7F))));\n\n                switch (action) {\n                case LABEL_SET_INCLUSIVE_RANGE:\n                case LABEL_SET_EXCLUSIVE_RANGE: /* fall through */\n\n\t\t    /* only a couple of subchannels are expected */\n\t\t    if (obj_tlen < 12)\n\t\t\treturn -1;\n\t\t    ND_PRINT((ndo, \"%s  Start range: %u, End range: %u\", ident,\n                           EXTRACT_32BITS(obj_tptr+4),\n                           EXTRACT_32BITS(obj_tptr + 8)));\n\t\t    obj_tlen-=12;\n\t\t    obj_tptr+=12;\n                    break;\n\n                default:\n                    obj_tlen-=4;\n                    obj_tptr+=4;\n                    subchannel = 1;\n                    while(obj_tlen >= 4 ) {\n                        ND_PRINT((ndo, \"%s  Subchannel #%u: %u\", ident, subchannel,\n                               EXTRACT_32BITS(obj_tptr)));\n                        obj_tptr+=4;\n                        obj_tlen-=4;\n                        subchannel++;\n                    }\n                    break;\n                }\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case RSVP_OBJ_S2L:\n            switch (rsvp_obj_ctype) {\n            case RSVP_CTYPE_IPV4:\n                if (obj_tlen < 4)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Sub-LSP destination address: %s\",\n                       ident, ipaddr_string(ndo, obj_tptr)));\n\n                obj_tlen-=4;\n                obj_tptr+=4;\n                break;\n            case RSVP_CTYPE_IPV6:\n                if (obj_tlen < 16)\n                    return-1;\n                ND_PRINT((ndo, \"%s  Sub-LSP destination address: %s\",\n                       ident, ip6addr_string(ndo, obj_tptr)));\n\n                obj_tlen-=16;\n                obj_tptr+=16;\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        /*\n         *  FIXME those are the defined objects that lack a decoder\n         *  you are welcome to contribute code ;-)\n         */\n\n        case RSVP_OBJ_SCOPE:\n        case RSVP_OBJ_POLICY_DATA:\n        case RSVP_OBJ_ACCEPT_LABEL_SET:\n        case RSVP_OBJ_PROTECTION:\n        default:\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, obj_tptr, \"\\n\\t    \", obj_tlen); /* FIXME indentation */\n            break;\n        }\n        /* do we also want to see a hex dump ? */\n        if (ndo->ndo_vflag > 1 || hexdump == TRUE)\n            print_unknown_data(ndo, tptr + sizeof(struct rsvp_object_header), \"\\n\\t    \", /* FIXME indentation */\n                               rsvp_obj_len - sizeof(struct rsvp_object_header));\n\n        tptr+=rsvp_obj_len;\n        tlen-=rsvp_obj_len;\n    }\n    return 0;\ninvalid:\n    ND_PRINT((ndo, \"%s\", istr));\n    return -1;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t\\t\"));\n    ND_PRINT((ndo, \"%s\", tstr));\n    return -1;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                           subobj_type,\n\n```\n\n\n\nwith the following test error:     rsvp_uni-oobr-1                    : TEST FAILED(exit 256)\n    rsvp_uni-oobr-2                    : TEST FAILED(exit 256)\n    rsvp_uni-oobr-3                    : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "289c672020280529fd382f3502efab7100d638ec___print-rsvp.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic int\nisis_print_is_reach_subtlv(netdissect_options *ndo,\n                           const uint8_t *tptr, u_int subt, u_int subl,\n                           const char *ident)\n{\n        u_int te_class,priority_level,gmpls_switch_cap;\n        union { /* int to float conversion buffer for several subTLVs */\n            float f;\n            uint32_t i;\n        } bw;\n\n        /* first lets see if we know the subTLVs name*/\n\tND_PRINT((ndo, \"%s%s subTLV #%u, length: %u\",\n\t          ident, tok2str(isis_ext_is_reach_subtlv_values, \"unknown\", subt),\n\t          subt, subl));\n\n\tND_TCHECK2(*tptr, subl);\n\n        switch(subt) {\n        case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP:\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID:\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID:\n\t    if (subl >= 4) {\n\t      ND_PRINT((ndo, \", 0x%08x\", EXTRACT_32BITS(tptr)));\n\t      if (subl == 8) /* rfc4205 */\n\t        ND_PRINT((ndo, \", 0x%08x\", EXTRACT_32BITS(tptr+4)));\n\t    }\n\t    break;\n        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR:\n        case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR:\n            if (subl >= sizeof(struct in_addr))\n              ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr)));\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW :\n\tcase ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW:\n            if (subl >= 4) {\n              bw.i = EXTRACT_32BITS(tptr);\n              ND_PRINT((ndo, \", %.3f Mbps\", bw.f * 8 / 1000000));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW :\n            if (subl >= 32) {\n              for (te_class = 0; te_class < 8; te_class++) {\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  TE-Class %u: %.3f Mbps\",\n                       ident,\n                       te_class,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n\t      }\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS: /* fall through */\n        case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD:\n            ND_PRINT((ndo, \"%sBandwidth Constraints Model ID: %s (%u)\",\n                   ident,\n                   tok2str(diffserv_te_bc_values, \"unknown\", *tptr),\n                   *tptr));\n            tptr++;\n            /* decode BCs until the subTLV ends */\n            for (te_class = 0; te_class < (subl-1)/4; te_class++) {\n\n>>> [ INFILL ] <<<\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Bandwidth constraint CT%u: %.3f Mbps\",\n                       ident,\n                       te_class,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC:\n            if (subl >= 3)\n              ND_PRINT((ndo, \", %u\", EXTRACT_24BITS(tptr)));\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE:\n            if (subl == 2) {\n               ND_PRINT((ndo, \", [ %s ] (0x%04x)\",\n                      bittok2str(isis_subtlv_link_attribute_values,\n                                 \"Unknown\",\n                                 EXTRACT_16BITS(tptr)),\n                      EXTRACT_16BITS(tptr)));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE:\n            if (subl >= 2) {\n              ND_PRINT((ndo, \", %s, Priority %u\",\n\t\t   bittok2str(gmpls_link_prot_values, \"none\", *tptr),\n                   *(tptr+1)));\n            }\n            break;\n        case ISIS_SUBTLV_SPB_METRIC:\n            if (subl >= 6) {\n              ND_PRINT((ndo, \", LM: %u\", EXTRACT_24BITS(tptr)));\n              tptr=tptr+3;\n              ND_PRINT((ndo, \", P: %u\", *(tptr)));\n              tptr++;\n              ND_PRINT((ndo, \", P-ID: %u\", EXTRACT_16BITS(tptr)));\n            }\n            break;\n        case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR:\n            if (subl >= 36) {\n              gmpls_switch_cap = *tptr;\n              ND_PRINT((ndo, \"%s  Interface Switching Capability:%s\",\n                   ident,\n                   tok2str(gmpls_switch_cap_values, \"Unknown\", gmpls_switch_cap)));\n              ND_PRINT((ndo, \", LSP Encoding: %s\",\n                   tok2str(gmpls_encoding_values, \"Unknown\", *(tptr + 1))));\n\t      tptr+=4;\n              ND_PRINT((ndo, \"%s  Max LSP Bandwidth:\", ident));\n              for (priority_level = 0; priority_level < 8; priority_level++) {\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s    priority level %d: %.3f Mbps\",\n                       ident,\n                       priority_level,\n                       bw.f * 8 / 1000000));\n\t\ttptr+=4;\n              }\n              subl-=36;\n              switch (gmpls_switch_cap) {\n              case GMPLS_PSC1:\n              case GMPLS_PSC2:\n              case GMPLS_PSC3:\n              case GMPLS_PSC4:\n                ND_TCHECK2(*tptr, 6);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Min LSP Bandwidth: %.3f Mbps\", ident, bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Interface MTU: %u\", ident, EXTRACT_16BITS(tptr + 4)));\n                break;\n              case GMPLS_TSC:\n                ND_TCHECK2(*tptr, 8);\n                bw.i = EXTRACT_32BITS(tptr);\n                ND_PRINT((ndo, \"%s  Min LSP Bandwidth: %.3f Mbps\", ident, bw.f * 8 / 1000000));\n                ND_PRINT((ndo, \"%s  Indication %s\", ident,\n                       tok2str(gmpls_switch_cap_tsc_indication_values, \"Unknown (%u)\", *(tptr + 4))));\n                break;\n              default:\n                /* there is some optional stuff left to decode but this is as of yet\n                   not specified so just lets hexdump what is left */\n                if(subl>0){\n                  if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t    \", subl))\n                    return(0);\n                }\n              }\n            }\n            break;\n        default:\n            if (!print_unknown_data(ndo, tptr, \"\\n\\t\\t    \", subl))\n                return(0);\n            break;\n        }\n        return(1);\n\ntrunc:\n    return(0);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                ND_TCHECK2(*tptr, 4);\n\n```\n\n\n\nwith the following test error:     isis-extd-isreach-oobr             : TEST FAILED(exit 256)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "5d0d76e88ee2d3236d7e032589d6f1d4ec5f7b1e___print-isoclns.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid CClient::EchoMessage(const CMessage& Message) {\n    CMessage EchoedMessage = Message;\n    for (CClient* pClient : GetClients()) {\n        if (pClient->HasEchoMessage() ||\n\n>>> [ INFILL ] <<<\n                                 pClient->HasSelfMessage()))) {\n            EchoedMessage.SetNick(GetNickMask());\n            pClient->PutClient(EchoedMessage);\n        }\n    }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n            (pClient != this && (m_pNetwork->IsChan(Message.GetParam(0)) ||\n\n```\n\n\n\nwith the following test error:       <failure message=\"test/integration/framework/base.h:118&#x0A;Value of: m_device-&gt;waitForReadyRead(timeout_ms)&#x0A;  Actual: false&#x0A;Expected: true&#x0A;Wanted: :*status!znc@znc.in PRIVMSG nick :Unknown command\" type=\"\"><![CDATA[test/integration/framework/base.h:118\nValue of: m_device->waitForReadyRead(timeout_ms)\n  Actual: false\nExpected: true\nWanted: :*status!znc@znc.in PRIVMSG nick :Unknown command]]></failure>\n      <failure message=\"test/integration/framework/base.cpp:52&#x0A;Expected equality of these values:&#x0A;  m_proc.exitStatus()&#x0A;    Which is: 1&#x0A;  QProcess::NormalExit&#x0A;    Which is: 0\" type=\"\"><![CDATA[test/integration/framework/base.cpp:52\nExpected equality of these values:\n  m_proc.exitStatus()\n    Which is: 1\n  QProcess::NormalExit\n    Which is: 0]]></failure>\n      <failure message=\"test/integration/framework/base.cpp:56&#x0A;Expected equality of these values:&#x0A;  m_proc.exitCode()&#x0A;    Which is: 11&#x0A;  m_exit&#x0A;    Which is: 0\" type=\"\"><![CDATA[test/integration/framework/base.cpp:56\nExpected equality of these values:\n  m_proc.exitCode()\n    Which is: 11\n  m_exit\n    Which is: 0]]></failure>\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "2390ad111bde16a78c98ac44572090b33c3bd2d8___Client.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic bool\n_bson_iter_next_internal (bson_iter_t *iter,    /* INOUT */\n                          uint32_t next_keylen, /* IN */\n                          const char **key,     /* OUT */\n                          uint32_t *bson_type,  /* OUT */\n                          bool *unsupported)    /* OUT */\n{\n   const uint8_t *data;\n   uint32_t o;\n   unsigned int len;\n\n   BSON_ASSERT (iter);\n\n   *unsupported = false;\n\n   if (!iter->raw) {\n      *key = NULL;\n      *bson_type = BSON_TYPE_EOD;\n      return false;\n   }\n\n   data = iter->raw;\n   len = iter->len;\n\n   iter->off = iter->next_off;\n   iter->type = iter->off;\n   iter->key = iter->off + 1;\n   iter->d1 = 0;\n   iter->d2 = 0;\n   iter->d3 = 0;\n   iter->d4 = 0;\n\n   if (next_keylen == 0) {\n      /* iterate from start to end of NULL-terminated key string */\n      for (o = iter->key; o < len; o++) {\n         if (!data[o]) {\n            iter->d1 = ++o;\n            goto fill_data_fields;\n         }\n      }\n   } else {\n      o = iter->key + next_keylen + 1;\n      iter->d1 = o;\n      goto fill_data_fields;\n   }\n\n   goto mark_invalid;\n\nfill_data_fields:\n\n   *key = bson_iter_key_unsafe (iter);\n   *bson_type = ITER_TYPE (iter);\n\n   switch (*bson_type) {\n   case BSON_TYPE_DATE_TIME:\n   case BSON_TYPE_DOUBLE:\n   case BSON_TYPE_INT64:\n   case BSON_TYPE_TIMESTAMP:\n      iter->next_off = o + 8;\n      break;\n   case BSON_TYPE_CODE:\n   case BSON_TYPE_SYMBOL:\n   case BSON_TYPE_UTF8: {\n      uint32_t l;\n\n      if ((o + 4) >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l > (len - (o + 4))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 4 + l;\n\n      /*\n       * Make sure the string length includes the NUL byte.\n       */\n      if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      /*\n       * Make sure the last byte is a NUL byte.\n       */\n      if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {\n         iter->err_off = o + 4 + l - 1;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_BINARY: {\n      bson_subtype_t subtype;\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      iter->d3 = o + 5;\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n\n>>> [ INFILL ] <<<\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      subtype = *(iter->raw + iter->d2);\n\n      if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {\n         int32_t binary_len;\n\n         if (l < 4) {\n            iter->err_off = o;\n            goto mark_invalid;\n         }\n\n         /* subtype 2 has a redundant length header in the data */\n         memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));\n         binary_len = BSON_UINT32_FROM_LE (binary_len);\n         if (binary_len + 4 != l) {\n            iter->err_off = iter->d3;\n            goto mark_invalid;\n         }\n      }\n\n      iter->next_off = o + 5 + l;\n   } break;\n   case BSON_TYPE_ARRAY:\n   case BSON_TYPE_DOCUMENT: {\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if ((l > len) || (l > (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + l;\n   } break;\n   case BSON_TYPE_OID:\n      iter->next_off = o + 12;\n      break;\n   case BSON_TYPE_BOOL: {\n      char val;\n\n      if (iter->d1 >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&val, iter->raw + iter->d1, 1);\n      if (val != 0x00 && val != 0x01) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_REGEX: {\n      bool eor = false;\n      bool eoo = false;\n\n      for (; o < len; o++) {\n         if (!data[o]) {\n            iter->d2 = ++o;\n            eor = true;\n            break;\n         }\n      }\n\n      if (!eor) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }\n\n      for (; o < len; o++) {\n         if (!data[o]) {\n            eoo = true;\n            break;\n         }\n      }\n\n      if (!eoo) {\n         iter->err_off = iter->next_off;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + 1;\n   } break;\n   case BSON_TYPE_DBPOINTER: {\n      uint32_t l;\n\n      if (o >= (len - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      /* Check valid string length. l counts '\\0' but not 4 bytes for itself. */\n      if (l == 0 || l > (len - o - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      if (*(iter->raw + o + l + 3)) {\n         /* not null terminated */\n         iter->err_off = o + l + 3;\n         goto mark_invalid;\n      }\n\n      iter->d3 = o + 4 + l;\n      iter->next_off = o + 4 + l + 12;\n   } break;\n   case BSON_TYPE_CODEWSCOPE: {\n      uint32_t l;\n      uint32_t doclen;\n\n      if ((len < 19) || (o >= (len - 14))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->d2 = o + 4;\n      iter->d3 = o + 8;\n\n      memcpy (&l, iter->raw + iter->d1, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if ((l < 14) || (l >= (len - o))) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      iter->next_off = o + l;\n\n      if (iter->next_off >= len) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      memcpy (&l, iter->raw + iter->d2, sizeof (l));\n      l = BSON_UINT32_FROM_LE (l);\n\n      if (l == 0 || l >= (len - o - 4 - 4)) {\n         iter->err_off = o;\n         goto mark_invalid;\n      }\n\n      if ((o + 4 + 4 + l + 4) >= iter->next_off) {\n         iter->err_off = o + 4;\n         goto mark_invalid;\n      }\n\n      iter->d4 = o + 4 + 4 + l;\n      memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));\n      doclen = BSON_UINT32_FROM_LE (doclen);\n\n      if ((o + 4 + 4 + l + doclen) != iter->next_off) {\n         iter->err_off = o + 4 + 4 + l;\n         goto mark_invalid;\n      }\n   } break;\n   case BSON_TYPE_INT32:\n      iter->next_off = o + 4;\n      break;\n   case BSON_TYPE_DECIMAL128:\n      iter->next_off = o + 16;\n      break;\n   case BSON_TYPE_MAXKEY:\n   case BSON_TYPE_MINKEY:\n   case BSON_TYPE_NULL:\n   case BSON_TYPE_UNDEFINED:\n      iter->next_off = o;\n      break;\n   default:\n      *unsupported = true;\n   /* FALL THROUGH */\n   case BSON_TYPE_EOD:\n      iter->err_off = o;\n      goto mark_invalid;\n   }\n\n   /*\n    * Check to see if any of the field locations would overflow the\n    * current BSON buffer. If so, set the error location to the offset\n    * of where the field starts.\n    */\n   if (iter->next_off >= len) {\n      iter->err_off = o;\n      goto mark_invalid;\n   }\n\n   iter->err_off = 0;\n\n   return true;\n\nmark_invalid:\n   iter->raw = NULL;\n   iter->len = 0;\n   iter->next_off = 0;\n\n   return false;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n      if (l >= (len - o)) {\n\n```\n\n\n\nwith the following test error: FAIL\n\nAssert Failure: 14 == 9\n/out/mongodb___mongo-c-driver/git_repo_dir_0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84/src/libbson/tests/test-bson.c:1256  test_bson_validate()\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "0d9a4d98bfdf4acd2c0138d4aaeb4e2e0934bd84___bson-iter.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid sqlite3Pragma(\n  Parse *pParse, \n  Token *pId1,        /* First part of [schema.]id field */\n  Token *pId2,        /* Second part of [schema.]id field, or NULL */\n  Token *pValue,      /* Token for <value>, or NULL */\n  int minusFlag       /* True if a '-' sign preceded <value> */\n){\n  char *zLeft = 0;       /* Nul-terminated UTF-8 string <id> */\n  char *zRight = 0;      /* Nul-terminated UTF-8 string <value>, or NULL */\n  const char *zDb = 0;   /* The database name */\n  Token *pId;            /* Pointer to <id> token */\n  char *aFcntl[4];       /* Argument to SQLITE_FCNTL_PRAGMA */\n  int iDb;               /* Database index for <database> */\n  int rc;                      /* return value form SQLITE_FCNTL_PRAGMA */\n  sqlite3 *db = pParse->db;    /* The database connection */\n  Db *pDb;                     /* The specific database being pragmaed */\n  Vdbe *v = sqlite3GetVdbe(pParse);  /* Prepared statement */\n  const PragmaName *pPragma;   /* The pragma */\n\n  if( v==0 ) return;\n  sqlite3VdbeRunOnlyOnce(v);\n  pParse->nMem = 2;\n\n  /* Interpret the [schema.] part of the pragma statement. iDb is the\n  ** index of the database this pragma is being applied to in db.aDb[]. */\n  iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);\n  if( iDb<0 ) return;\n  pDb = &db->aDb[iDb];\n\n  /* If the temp database has been explicitly named as part of the \n  ** pragma, make sure it is open. \n  */\n  if( iDb==1 && sqlite3OpenTempDatabase(pParse) ){\n    return;\n  }\n\n  zLeft = sqlite3NameFromToken(db, pId);\n  if( !zLeft ) return;\n  if( minusFlag ){\n    zRight = sqlite3MPrintf(db, \"-%T\", pValue);\n  }else{\n    zRight = sqlite3NameFromToken(db, pValue);\n  }\n\n  assert( pId2 );\n  zDb = pId2->n>0 ? pDb->zDbSName : 0;\n  if( sqlite3AuthCheck(pParse, SQLITE_PRAGMA, zLeft, zRight, zDb) ){\n    goto pragma_out;\n  }\n\n  /* Send an SQLITE_FCNTL_PRAGMA file-control to the underlying VFS\n  ** connection.  If it returns SQLITE_OK, then assume that the VFS\n  ** handled the pragma and generate a no-op prepared statement.\n  **\n  ** IMPLEMENTATION-OF: R-12238-55120 Whenever a PRAGMA statement is parsed,\n  ** an SQLITE_FCNTL_PRAGMA file control is sent to the open sqlite3_file\n  ** object corresponding to the database file to which the pragma\n  ** statement refers.\n  **\n  ** IMPLEMENTATION-OF: R-29875-31678 The argument to the SQLITE_FCNTL_PRAGMA\n  ** file control is an array of pointers to strings (char**) in which the\n  ** second element of the array is the name of the pragma and the third\n  ** element is the argument to the pragma or NULL if the pragma has no\n  ** argument.\n  */\n  aFcntl[0] = 0;\n  aFcntl[1] = zLeft;\n  aFcntl[2] = zRight;\n  aFcntl[3] = 0;\n  db->busyHandler.nBusy = 0;\n  rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_PRAGMA, (void*)aFcntl);\n  if( rc==SQLITE_OK ){\n    sqlite3VdbeSetNumCols(v, 1);\n    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, aFcntl[0], SQLITE_TRANSIENT);\n    returnSingleText(v, aFcntl[0]);\n    sqlite3_free(aFcntl[0]);\n    goto pragma_out;\n  }\n  if( rc!=SQLITE_NOTFOUND ){\n    if( aFcntl[0] ){\n      sqlite3ErrorMsg(pParse, \"%s\", aFcntl[0]);\n      sqlite3_free(aFcntl[0]);\n    }\n    pParse->nErr++;\n    pParse->rc = rc;\n    goto pragma_out;\n  }\n\n  /* Locate the pragma in the lookup table */\n  pPragma = pragmaLocate(zLeft);\n  if( pPragma==0 ) goto pragma_out;\n\n  /* Make sure the database schema is loaded if the pragma requires that */\n  if( (pPragma->mPragFlg & PragFlg_NeedSchema)!=0 ){\n    if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n  }\n\n  /* Register the result column names for pragmas that return results */\n  if( (pPragma->mPragFlg & PragFlg_NoColumns)==0 \n   && ((pPragma->mPragFlg & PragFlg_NoColumns1)==0 || zRight==0)\n  ){\n    setPragmaResultColumnNames(v, pPragma);\n  }\n\n  /* Jump to the appropriate pragma handler */\n  switch( pPragma->ePragTyp ){\n  \n#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) && !defined(SQLITE_OMIT_DEPRECATED)\n  /*\n  **  PRAGMA [schema.]default_cache_size\n  **  PRAGMA [schema.]default_cache_size=N\n  **\n  ** The first form reports the current persistent setting for the\n  ** page cache size.  The value returned is the maximum number of\n  ** pages in the page cache.  The second form sets both the current\n  ** page cache size value and the persistent page cache size value\n  ** stored in the database file.\n  **\n  ** Older versions of SQLite would set the default cache size to a\n  ** negative number to indicate synchronous=OFF.  These days, synchronous\n  ** is always on by default regardless of the sign of the default cache\n  ** size.  But continue to take the absolute value of the default cache\n  ** size of historical compatibility.\n  */\n  case PragTyp_DEFAULT_CACHE_SIZE: {\n    static const int iLn = VDBE_OFFSET_LINENO(2);\n    static const VdbeOpList getCacheSize[] = {\n      { OP_Transaction, 0, 0,        0},                         /* 0 */\n      { OP_ReadCookie,  0, 1,        BTREE_DEFAULT_CACHE_SIZE},  /* 1 */\n      { OP_IfPos,       1, 8,        0},\n      { OP_Integer,     0, 2,        0},\n      { OP_Subtract,    1, 2,        1},\n      { OP_IfPos,       1, 8,        0},\n      { OP_Integer,     0, 1,        0},                         /* 6 */\n      { OP_Noop,        0, 0,        0},\n      { OP_ResultRow,   1, 1,        0},\n    };\n    VdbeOp *aOp;\n    sqlite3VdbeUsesBtree(v, iDb);\n    if( !zRight ){\n      pParse->nMem += 2;\n      sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(getCacheSize));\n      aOp = sqlite3VdbeAddOpList(v, ArraySize(getCacheSize), getCacheSize, iLn);\n      if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;\n      aOp[0].p1 = iDb;\n      aOp[1].p1 = iDb;\n      aOp[6].p1 = SQLITE_DEFAULT_CACHE_SIZE;\n    }else{\n      int size = sqlite3AbsInt32(sqlite3Atoi(zRight));\n      sqlite3BeginWriteOperation(pParse, 0, iDb);\n      sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_DEFAULT_CACHE_SIZE, size);\n      assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n      pDb->pSchema->cache_size = size;\n      sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n    }\n    break;\n  }\n#endif /* !SQLITE_OMIT_PAGER_PRAGMAS && !SQLITE_OMIT_DEPRECATED */\n\n#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)\n  /*\n  **  PRAGMA [schema.]page_size\n  **  PRAGMA [schema.]page_size=N\n  **\n  ** The first form reports the current setting for the\n  ** database page size in bytes.  The second form sets the\n  ** database page size value.  The value can only be set if\n  ** the database has not yet been created.\n  */\n  case PragTyp_PAGE_SIZE: {\n    Btree *pBt = pDb->pBt;\n    assert( pBt!=0 );\n    if( !zRight ){\n      int size = ALWAYS(pBt) ? sqlite3BtreeGetPageSize(pBt) : 0;\n      returnSingleInt(v, size);\n    }else{\n      /* Malloc may fail when setting the page-size, as there is an internal\n      ** buffer that the pager module resizes using sqlite3_realloc().\n      */\n      db->nextPagesize = sqlite3Atoi(zRight);\n      if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db->nextPagesize,-1,0) ){\n        sqlite3OomFault(db);\n      }\n    }\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]secure_delete\n  **  PRAGMA [schema.]secure_delete=ON/OFF/FAST\n  **\n  ** The first form reports the current setting for the\n  ** secure_delete flag.  The second form changes the secure_delete\n  ** flag setting and reports the new value.\n  */\n  case PragTyp_SECURE_DELETE: {\n    Btree *pBt = pDb->pBt;\n    int b = -1;\n    assert( pBt!=0 );\n    if( zRight ){\n      if( sqlite3_stricmp(zRight, \"fast\")==0 ){\n        b = 2;\n      }else{\n        b = sqlite3GetBoolean(zRight, 0);\n      }\n    }\n    if( pId2->n==0 && b>=0 ){\n      int ii;\n      for(ii=0; ii<db->nDb; ii++){\n        sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);\n      }\n    }\n    b = sqlite3BtreeSecureDelete(pBt, b);\n    returnSingleInt(v, b);\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]max_page_count\n  **  PRAGMA [schema.]max_page_count=N\n  **\n  ** The first form reports the current setting for the\n  ** maximum number of pages in the database file.  The \n  ** second form attempts to change this setting.  Both\n  ** forms return the current setting.\n  **\n  ** The absolute value of N is used.  This is undocumented and might\n  ** change.  The only purpose is to provide an easy way to test\n  ** the sqlite3AbsInt32() function.\n  **\n  **  PRAGMA [schema.]page_count\n  **\n  ** Return the number of pages in the specified database.\n  */\n  case PragTyp_PAGE_COUNT: {\n    int iReg;\n    sqlite3CodeVerifySchema(pParse, iDb);\n    iReg = ++pParse->nMem;\n    if( sqlite3Tolower(zLeft[0])=='p' ){\n      sqlite3VdbeAddOp2(v, OP_Pagecount, iDb, iReg);\n    }else{\n      sqlite3VdbeAddOp3(v, OP_MaxPgcnt, iDb, iReg, \n                        sqlite3AbsInt32(sqlite3Atoi(zRight)));\n    }\n    sqlite3VdbeAddOp2(v, OP_ResultRow, iReg, 1);\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]locking_mode\n  **  PRAGMA [schema.]locking_mode = (normal|exclusive)\n  */\n  case PragTyp_LOCKING_MODE: {\n    const char *zRet = \"normal\";\n    int eMode = getLockingMode(zRight);\n\n    if( pId2->n==0 && eMode==PAGER_LOCKINGMODE_QUERY ){\n      /* Simple \"PRAGMA locking_mode;\" statement. This is a query for\n      ** the current default locking mode (which may be different to\n      ** the locking-mode of the main database).\n      */\n      eMode = db->dfltLockMode;\n    }else{\n      Pager *pPager;\n      if( pId2->n==0 ){\n        /* This indicates that no database name was specified as part\n        ** of the PRAGMA command. In this case the locking-mode must be\n        ** set on all attached databases, as well as the main db file.\n        **\n        ** Also, the sqlite3.dfltLockMode variable is set so that\n        ** any subsequently attached databases also use the specified\n        ** locking mode.\n        */\n        int ii;\n        assert(pDb==&db->aDb[0]);\n        for(ii=2; ii<db->nDb; ii++){\n          pPager = sqlite3BtreePager(db->aDb[ii].pBt);\n          sqlite3PagerLockingMode(pPager, eMode);\n        }\n        db->dfltLockMode = (u8)eMode;\n      }\n      pPager = sqlite3BtreePager(pDb->pBt);\n      eMode = sqlite3PagerLockingMode(pPager, eMode);\n    }\n\n    assert( eMode==PAGER_LOCKINGMODE_NORMAL\n            || eMode==PAGER_LOCKINGMODE_EXCLUSIVE );\n    if( eMode==PAGER_LOCKINGMODE_EXCLUSIVE ){\n      zRet = \"exclusive\";\n    }\n    returnSingleText(v, zRet);\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]journal_mode\n  **  PRAGMA [schema.]journal_mode =\n  **                      (delete|persist|off|truncate|memory|wal|off)\n  */\n  case PragTyp_JOURNAL_MODE: {\n    int eMode;        /* One of the PAGER_JOURNALMODE_XXX symbols */\n    int ii;           /* Loop counter */\n\n    if( zRight==0 ){\n      /* If there is no \"=MODE\" part of the pragma, do a query for the\n      ** current mode */\n      eMode = PAGER_JOURNALMODE_QUERY;\n    }else{\n      const char *zMode;\n      int n = sqlite3Strlen30(zRight);\n      for(eMode=0; (zMode = sqlite3JournalModename(eMode))!=0; eMode++){\n        if( sqlite3StrNICmp(zRight, zMode, n)==0 ) break;\n      }\n      if( !zMode ){\n        /* If the \"=MODE\" part does not match any known journal mode,\n        ** then do a query */\n        eMode = PAGER_JOURNALMODE_QUERY;\n      }\n      if( eMode==PAGER_JOURNALMODE_OFF && (db->flags & SQLITE_Defensive)!=0 ){\n        /* Do not allow journal-mode \"OFF\" in defensive since the database\n        ** can become corrupted using ordinary SQL when the journal is off */\n        eMode = PAGER_JOURNALMODE_QUERY;\n      }\n    }\n    if( eMode==PAGER_JOURNALMODE_QUERY && pId2->n==0 ){\n      /* Convert \"PRAGMA journal_mode\" into \"PRAGMA main.journal_mode\" */\n      iDb = 0;\n      pId2->n = 1;\n    }\n    for(ii=db->nDb-1; ii>=0; ii--){\n      if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){\n        sqlite3VdbeUsesBtree(v, ii);\n        sqlite3VdbeAddOp3(v, OP_JournalMode, ii, 1, eMode);\n      }\n    }\n    sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]journal_size_limit\n  **  PRAGMA [schema.]journal_size_limit=N\n  **\n  ** Get or set the size limit on rollback journal files.\n  */\n  case PragTyp_JOURNAL_SIZE_LIMIT: {\n    Pager *pPager = sqlite3BtreePager(pDb->pBt);\n    i64 iLimit = -2;\n    if( zRight ){\n      sqlite3DecOrHexToI64(zRight, &iLimit);\n      if( iLimit<-1 ) iLimit = -1;\n    }\n    iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit);\n    returnSingleInt(v, iLimit);\n    break;\n  }\n\n#endif /* SQLITE_OMIT_PAGER_PRAGMAS */\n\n  /*\n  **  PRAGMA [schema.]auto_vacuum\n  **  PRAGMA [schema.]auto_vacuum=N\n  **\n  ** Get or set the value of the database 'auto-vacuum' parameter.\n  ** The value is one of:  0 NONE 1 FULL 2 INCREMENTAL\n  */\n#ifndef SQLITE_OMIT_AUTOVACUUM\n  case PragTyp_AUTO_VACUUM: {\n    Btree *pBt = pDb->pBt;\n    assert( pBt!=0 );\n    if( !zRight ){\n      returnSingleInt(v, sqlite3BtreeGetAutoVacuum(pBt));\n    }else{\n      int eAuto = getAutoVacuum(zRight);\n      assert( eAuto>=0 && eAuto<=2 );\n      db->nextAutovac = (u8)eAuto;\n      /* Call SetAutoVacuum() to set initialize the internal auto and\n      ** incr-vacuum flags. This is required in case this connection\n      ** creates the database file. It is important that it is created\n      ** as an auto-vacuum capable db.\n      */\n      rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto);\n      if( rc==SQLITE_OK && (eAuto==1 || eAuto==2) ){\n        /* When setting the auto_vacuum mode to either \"full\" or \n        ** \"incremental\", write the value of meta[6] in the database\n        ** file. Before writing to meta[6], check that meta[3] indicates\n        ** that this really is an auto-vacuum capable database.\n        */\n        static const int iLn = VDBE_OFFSET_LINENO(2);\n        static const VdbeOpList setMeta6[] = {\n          { OP_Transaction,    0,         1,                 0},    /* 0 */\n          { OP_ReadCookie,     0,         1,         BTREE_LARGEST_ROOT_PAGE},\n          { OP_If,             1,         0,                 0},    /* 2 */\n          { OP_Halt,           SQLITE_OK, OE_Abort,          0},    /* 3 */\n          { OP_SetCookie,      0,         BTREE_INCR_VACUUM, 0},    /* 4 */\n        };\n        VdbeOp *aOp;\n        int iAddr = sqlite3VdbeCurrentAddr(v);\n        sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setMeta6));\n        aOp = sqlite3VdbeAddOpList(v, ArraySize(setMeta6), setMeta6, iLn);\n        if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;\n        aOp[0].p1 = iDb;\n        aOp[1].p1 = iDb;\n        aOp[2].p2 = iAddr+4;\n        aOp[4].p1 = iDb;\n        aOp[4].p3 = eAuto - 1;\n        sqlite3VdbeUsesBtree(v, iDb);\n      }\n    }\n    break;\n  }\n#endif\n\n  /*\n  **  PRAGMA [schema.]incremental_vacuum(N)\n  **\n  ** Do N steps of incremental vacuuming on a database.\n  */\n#ifndef SQLITE_OMIT_AUTOVACUUM\n  case PragTyp_INCREMENTAL_VACUUM: {\n    int iLimit, addr;\n    if( zRight==0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit<=0 ){\n      iLimit = 0x7fffffff;\n    }\n    sqlite3BeginWriteOperation(pParse, 0, iDb);\n    sqlite3VdbeAddOp2(v, OP_Integer, iLimit, 1);\n    addr = sqlite3VdbeAddOp1(v, OP_IncrVacuum, iDb); VdbeCoverage(v);\n    sqlite3VdbeAddOp1(v, OP_ResultRow, 1);\n    sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1);\n    sqlite3VdbeAddOp2(v, OP_IfPos, 1, addr); VdbeCoverage(v);\n    sqlite3VdbeJumpHere(v, addr);\n    break;\n  }\n#endif\n\n#ifndef SQLITE_OMIT_PAGER_PRAGMAS\n  /*\n  **  PRAGMA [schema.]cache_size\n  **  PRAGMA [schema.]cache_size=N\n  **\n  ** The first form reports the current local setting for the\n  ** page cache size. The second form sets the local\n  ** page cache size value.  If N is positive then that is the\n  ** number of pages in the cache.  If N is negative, then the\n  ** number of pages is adjusted so that the cache uses -N kibibytes\n  ** of memory.\n  */\n  case PragTyp_CACHE_SIZE: {\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    if( !zRight ){\n      returnSingleInt(v, pDb->pSchema->cache_size);\n    }else{\n      int size = sqlite3Atoi(zRight);\n      pDb->pSchema->cache_size = size;\n      sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n    }\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]cache_spill\n  **  PRAGMA cache_spill=BOOLEAN\n  **  PRAGMA [schema.]cache_spill=N\n  **\n  ** The first form reports the current local setting for the\n  ** page cache spill size. The second form turns cache spill on\n  ** or off.  When turnning cache spill on, the size is set to the\n  ** current cache_size.  The third form sets a spill size that\n  ** may be different form the cache size.\n  ** If N is positive then that is the\n  ** number of pages in the cache.  If N is negative, then the\n  ** number of pages is adjusted so that the cache uses -N kibibytes\n  ** of memory.\n  **\n  ** If the number of cache_spill pages is less then the number of\n  ** cache_size pages, no spilling occurs until the page count exceeds\n  ** the number of cache_size pages.\n  **\n  ** The cache_spill=BOOLEAN setting applies to all attached schemas,\n  ** not just the schema specified.\n  */\n  case PragTyp_CACHE_SPILL: {\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    if( !zRight ){\n      returnSingleInt(v,\n         (db->flags & SQLITE_CacheSpill)==0 ? 0 : \n            sqlite3BtreeSetSpillSize(pDb->pBt,0));\n    }else{\n      int size = 1;\n      if( sqlite3GetInt32(zRight, &size) ){\n        sqlite3BtreeSetSpillSize(pDb->pBt, size);\n      }\n      if( sqlite3GetBoolean(zRight, size!=0) ){\n        db->flags |= SQLITE_CacheSpill;\n      }else{\n        db->flags &= ~(u64)SQLITE_CacheSpill;\n      }\n      setAllPagerFlags(db);\n    }\n    break;\n  }\n\n  /*\n  **  PRAGMA [schema.]mmap_size(N)\n  **\n  ** Used to set mapping size limit. The mapping size limit is\n  ** used to limit the aggregate size of all memory mapped regions of the\n  ** database file. If this parameter is set to zero, then memory mapping\n  ** is not used at all.  If N is negative, then the default memory map\n  ** limit determined by sqlite3_config(SQLITE_CONFIG_MMAP_SIZE) is set.\n  ** The parameter N is measured in bytes.\n  **\n  ** This value is advisory.  The underlying VFS is free to memory map\n  ** as little or as much as it wants.  Except, if N is set to 0 then the\n  ** upper layers will never invoke the xFetch interfaces to the VFS.\n  */\n  case PragTyp_MMAP_SIZE: {\n    sqlite3_int64 sz;\n#if SQLITE_MAX_MMAP_SIZE>0\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    if( zRight ){\n      int ii;\n      sqlite3DecOrHexToI64(zRight, &sz);\n      if( sz<0 ) sz = sqlite3GlobalConfig.szMmap;\n      if( pId2->n==0 ) db->szMmap = sz;\n      for(ii=db->nDb-1; ii>=0; ii--){\n        if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){\n          sqlite3BtreeSetMmapLimit(db->aDb[ii].pBt, sz);\n        }\n      }\n    }\n    sz = -1;\n    rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_MMAP_SIZE, &sz);\n#else\n    sz = 0;\n    rc = SQLITE_OK;\n#endif\n    if( rc==SQLITE_OK ){\n      returnSingleInt(v, sz);\n    }else if( rc!=SQLITE_NOTFOUND ){\n      pParse->nErr++;\n      pParse->rc = rc;\n    }\n    break;\n  }\n\n  /*\n  **   PRAGMA temp_store\n  **   PRAGMA temp_store = \"default\"|\"memory\"|\"file\"\n  **\n  ** Return or set the local value of the temp_store flag.  Changing\n  ** the local value does not make changes to the disk file and the default\n  ** value will be restored the next time the database is opened.\n  **\n  ** Note that it is possible for the library compile-time options to\n  ** override this setting\n  */\n  case PragTyp_TEMP_STORE: {\n    if( !zRight ){\n      returnSingleInt(v, db->temp_store);\n    }else{\n      changeTempStorage(pParse, zRight);\n    }\n    break;\n  }\n\n  /*\n  **   PRAGMA temp_store_directory\n  **   PRAGMA temp_store_directory = \"\"|\"directory_name\"\n  **\n  ** Return or set the local value of the temp_store_directory flag.  Changing\n  ** the value sets a specific directory to be used for temporary files.\n  ** Setting to a null string reverts to the default temporary directory search.\n  ** If temporary directory is changed, then invalidateTempStorage.\n  **\n  */\n  case PragTyp_TEMP_STORE_DIRECTORY: {\n    if( !zRight ){\n      returnSingleText(v, sqlite3_temp_directory);\n    }else{\n#ifndef SQLITE_OMIT_WSD\n      if( zRight[0] ){\n        int res;\n        rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);\n        if( rc!=SQLITE_OK || res==0 ){\n          sqlite3ErrorMsg(pParse, \"not a writable directory\");\n          goto pragma_out;\n        }\n      }\n      if( SQLITE_TEMP_STORE==0\n       || (SQLITE_TEMP_STORE==1 && db->temp_store<=1)\n       || (SQLITE_TEMP_STORE==2 && db->temp_store==1)\n      ){\n        invalidateTempStorage(pParse);\n      }\n      sqlite3_free(sqlite3_temp_directory);\n      if( zRight[0] ){\n        sqlite3_temp_directory = sqlite3_mprintf(\"%s\", zRight);\n      }else{\n        sqlite3_temp_directory = 0;\n      }\n#endif /* SQLITE_OMIT_WSD */\n    }\n    break;\n  }\n\n#if SQLITE_OS_WIN\n  /*\n  **   PRAGMA data_store_directory\n  **   PRAGMA data_store_directory = \"\"|\"directory_name\"\n  **\n  ** Return or set the local value of the data_store_directory flag.  Changing\n  ** the value sets a specific directory to be used for database files that\n  ** were specified with a relative pathname.  Setting to a null string reverts\n  ** to the default database directory, which for database files specified with\n  ** a relative path will probably be based on the current directory for the\n  ** process.  Database file specified with an absolute path are not impacted\n  ** by this setting, regardless of its value.\n  **\n  */\n  case PragTyp_DATA_STORE_DIRECTORY: {\n    if( !zRight ){\n      returnSingleText(v, sqlite3_data_directory);\n    }else{\n#ifndef SQLITE_OMIT_WSD\n      if( zRight[0] ){\n        int res;\n        rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);\n        if( rc!=SQLITE_OK || res==0 ){\n          sqlite3ErrorMsg(pParse, \"not a writable directory\");\n          goto pragma_out;\n        }\n      }\n      sqlite3_free(sqlite3_data_directory);\n      if( zRight[0] ){\n        sqlite3_data_directory = sqlite3_mprintf(\"%s\", zRight);\n      }else{\n        sqlite3_data_directory = 0;\n      }\n#endif /* SQLITE_OMIT_WSD */\n    }\n    break;\n  }\n#endif\n\n#if SQLITE_ENABLE_LOCKING_STYLE\n  /*\n  **   PRAGMA [schema.]lock_proxy_file\n  **   PRAGMA [schema.]lock_proxy_file = \":auto:\"|\"lock_file_path\"\n  **\n  ** Return or set the value of the lock_proxy_file flag.  Changing\n  ** the value sets a specific file to be used for database access locks.\n  **\n  */\n  case PragTyp_LOCK_PROXY_FILE: {\n    if( !zRight ){\n      Pager *pPager = sqlite3BtreePager(pDb->pBt);\n      char *proxy_file_path = NULL;\n      sqlite3_file *pFile = sqlite3PagerFile(pPager);\n      sqlite3OsFileControlHint(pFile, SQLITE_GET_LOCKPROXYFILE, \n                           &proxy_file_path);\n      returnSingleText(v, proxy_file_path);\n    }else{\n      Pager *pPager = sqlite3BtreePager(pDb->pBt);\n      sqlite3_file *pFile = sqlite3PagerFile(pPager);\n      int res;\n      if( zRight[0] ){\n        res=sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE, \n                                     zRight);\n      } else {\n        res=sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE, \n                                     NULL);\n      }\n      if( res!=SQLITE_OK ){\n        sqlite3ErrorMsg(pParse, \"failed to set lock proxy file\");\n        goto pragma_out;\n      }\n    }\n    break;\n  }\n#endif /* SQLITE_ENABLE_LOCKING_STYLE */      \n    \n  /*\n  **   PRAGMA [schema.]synchronous\n  **   PRAGMA [schema.]synchronous=OFF|ON|NORMAL|FULL|EXTRA\n  **\n  ** Return or set the local value of the synchronous flag.  Changing\n  ** the local value does not make changes to the disk file and the\n  ** default value will be restored the next time the database is\n  ** opened.\n  */\n  case PragTyp_SYNCHRONOUS: {\n    if( !zRight ){\n      returnSingleInt(v, pDb->safety_level-1);\n    }else{\n      if( !db->autoCommit ){\n        sqlite3ErrorMsg(pParse, \n            \"Safety level may not be changed inside a transaction\");\n      }else if( iDb!=1 ){\n        int iLevel = (getSafetyLevel(zRight,0,1)+1) & PAGER_SYNCHRONOUS_MASK;\n        if( iLevel==0 ) iLevel = 1;\n        pDb->safety_level = iLevel;\n        pDb->bSyncSet = 1;\n        setAllPagerFlags(db);\n      }\n    }\n    break;\n  }\n#endif /* SQLITE_OMIT_PAGER_PRAGMAS */\n\n#ifndef SQLITE_OMIT_FLAG_PRAGMAS\n  case PragTyp_FLAG: {\n    if( zRight==0 ){\n      setPragmaResultColumnNames(v, pPragma);\n      returnSingleInt(v, (db->flags & pPragma->iArg)!=0 );\n    }else{\n      u64 mask = pPragma->iArg;    /* Mask of bits to set or clear. */\n      if( db->autoCommit==0 ){\n        /* Foreign key support may not be enabled or disabled while not\n        ** in auto-commit mode.  */\n        mask &= ~(SQLITE_ForeignKeys);\n      }\n#if SQLITE_USER_AUTHENTICATION\n      if( db->auth.authLevel==UAUTH_User ){\n        /* Do not allow non-admin users to modify the schema arbitrarily */\n        mask &= ~(SQLITE_WriteSchema);\n      }\n#endif\n\n      if( sqlite3GetBoolean(zRight, 0) ){\n        db->flags |= mask;\n      }else{\n        db->flags &= ~mask;\n        if( mask==SQLITE_DeferFKs ) db->nDeferredImmCons = 0;\n      }\n\n      /* Many of the flag-pragmas modify the code generated by the SQL \n      ** compiler (eg. count_changes). So add an opcode to expire all\n      ** compiled SQL statements after modifying a pragma value.\n      */\n      sqlite3VdbeAddOp0(v, OP_Expire);\n      setAllPagerFlags(db);\n    }\n    break;\n  }\n#endif /* SQLITE_OMIT_FLAG_PRAGMAS */\n\n#ifndef SQLITE_OMIT_SCHEMA_PRAGMAS\n  /*\n  **   PRAGMA table_info(<table>)\n  **\n  ** Return a single row for each column of the named table. The columns of\n  ** the returned data set are:\n  **\n  ** cid:        Column id (numbered from left to right, starting at 0)\n  ** name:       Column name\n  ** type:       Column declaration type.\n  ** notnull:    True if 'NOT NULL' is part of column declaration\n  ** dflt_value: The default value for the column, if any.\n  ** pk:         Non-zero for PK fields.\n  */\n  case PragTyp_TABLE_INFO: if( zRight ){\n    Table *pTab;\n    pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);\n    if( pTab ){\n      int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n      int i, k;\n      int nHidden = 0;\n      Column *pCol;\n      Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n      pParse->nMem = 7;\n      sqlite3CodeVerifySchema(pParse, iTabDb);\n      sqlite3ViewGetColumnNames(pParse, pTab);\n      for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){\n        int isHidden = 0;\n        if( pCol->colFlags & COLFLAG_NOINSERT ){\n          if( pPragma->iArg==0 ){\n            nHidden++;\n            continue;\n          }\n          if( pCol->colFlags & COLFLAG_VIRTUAL ){\n            isHidden = 2;  /* GENERATED ALWAYS AS ... VIRTUAL */\n          }else if( pCol->colFlags & COLFLAG_STORED ){\n            isHidden = 3;  /* GENERATED ALWAYS AS ... STORED */\n          }else{ assert( pCol->colFlags & COLFLAG_HIDDEN );\n            isHidden = 1;  /* HIDDEN */\n          }\n        }\n        if( (pCol->colFlags & COLFLAG_PRIMKEY)==0 ){\n          k = 0;\n        }else if( pPk==0 ){\n          k = 1;\n        }else{\n          for(k=1; k<=pTab->nCol && pPk->aiColumn[k-1]!=i; k++){}\n        }\n        assert( pCol->pDflt==0 || pCol->pDflt->op==TK_SPAN || isHidden>=2 );\n        sqlite3VdbeMultiLoad(v, 1, pPragma->iArg ? \"issisii\" : \"issisi\",\n               i-nHidden,\n               pCol->zName,\n               sqlite3ColumnType(pCol,\"\"),\n               pCol->notNull ? 1 : 0,\n               pCol->pDflt && isHidden<2 ? pCol->pDflt->u.zToken : 0,\n               k,\n               isHidden);\n      }\n    }\n  }\n  break;\n\n#ifdef SQLITE_DEBUG\n  case PragTyp_STATS: {\n    Index *pIdx;\n    HashElem *i;\n    pParse->nMem = 5;\n    sqlite3CodeVerifySchema(pParse, iDb);\n    for(i=sqliteHashFirst(&pDb->pSchema->tblHash); i; i=sqliteHashNext(i)){\n      Table *pTab = sqliteHashData(i);\n      sqlite3VdbeMultiLoad(v, 1, \"ssiii\",\n           pTab->zName,\n           0,\n           pTab->szTabRow,\n           pTab->nRowLogEst,\n           pTab->tabFlags);\n      for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n        sqlite3VdbeMultiLoad(v, 2, \"siiiX\",\n           pIdx->zName,\n           pIdx->szIdxRow,\n           pIdx->aiRowLogEst[0],\n           pIdx->hasStat1);\n        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 5);\n      }\n    }\n  }\n  break;\n#endif\n\n  case PragTyp_INDEX_INFO: if( zRight ){\n    Index *pIdx;\n    Table *pTab;\n    pIdx = sqlite3FindIndex(db, zRight, zDb);\n    if( pIdx==0 ){\n      /* If there is no index named zRight, check to see if there is a\n      ** WITHOUT ROWID table named zRight, and if there is, show the\n      ** structure of the PRIMARY KEY index for that table. */\n      pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);\n      if( pTab && !HasRowid(pTab) ){\n        pIdx = sqlite3PrimaryKeyIndex(pTab);\n      }\n    }\n    if( pIdx ){\n      int iIdxDb = sqlite3SchemaToIndex(db, pIdx->pSchema);\n      int i;\n      int mx;\n      if( pPragma->iArg ){\n        /* PRAGMA index_xinfo (newer version with more rows and columns) */\n        mx = pIdx->nColumn;\n        pParse->nMem = 6;\n      }else{\n        /* PRAGMA index_info (legacy version) */\n        mx = pIdx->nKeyCol;\n        pParse->nMem = 3;\n      }\n      pTab = pIdx->pTable;\n      sqlite3CodeVerifySchema(pParse, iIdxDb);\n      assert( pParse->nMem<=pPragma->nPragCName );\n      for(i=0; i<mx; i++){\n        i16 cnum = pIdx->aiColumn[i];\n        sqlite3VdbeMultiLoad(v, 1, \"iisX\", i, cnum,\n                             cnum<0 ? 0 : pTab->aCol[cnum].zName);\n        if( pPragma->iArg ){\n          sqlite3VdbeMultiLoad(v, 4, \"isiX\",\n            pIdx->aSortOrder[i],\n            pIdx->azColl[i],\n            i<pIdx->nKeyCol);\n        }\n        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, pParse->nMem);\n      }\n    }\n  }\n  break;\n\n  case PragTyp_INDEX_LIST: if( zRight ){\n    Index *pIdx;\n    Table *pTab;\n    int i;\n    pTab = sqlite3FindTable(db, zRight, zDb);\n    if( pTab ){\n      int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n      pParse->nMem = 5;\n      sqlite3CodeVerifySchema(pParse, iTabDb);\n      for(pIdx=pTab->pIndex, i=0; pIdx; pIdx=pIdx->pNext, i++){\n        const char *azOrigin[] = { \"c\", \"u\", \"pk\" };\n        sqlite3VdbeMultiLoad(v, 1, \"isisi\",\n           i,\n           pIdx->zName,\n           IsUniqueIndex(pIdx),\n           azOrigin[pIdx->idxType],\n           pIdx->pPartIdxWhere!=0);\n      }\n    }\n  }\n  break;\n\n  case PragTyp_DATABASE_LIST: {\n    int i;\n    pParse->nMem = 3;\n    for(i=0; i<db->nDb; i++){\n      if( db->aDb[i].pBt==0 ) continue;\n      assert( db->aDb[i].zDbSName!=0 );\n      sqlite3VdbeMultiLoad(v, 1, \"iss\",\n         i,\n         db->aDb[i].zDbSName,\n         sqlite3BtreeGetFilename(db->aDb[i].pBt));\n    }\n  }\n  break;\n\n  case PragTyp_COLLATION_LIST: {\n    int i = 0;\n    HashElem *p;\n    pParse->nMem = 2;\n    for(p=sqliteHashFirst(&db->aCollSeq); p; p=sqliteHashNext(p)){\n      CollSeq *pColl = (CollSeq *)sqliteHashData(p);\n      sqlite3VdbeMultiLoad(v, 1, \"is\", i++, pColl->zName);\n    }\n  }\n  break;\n\n#ifndef SQLITE_OMIT_INTROSPECTION_PRAGMAS\n  case PragTyp_FUNCTION_LIST: {\n    int i;\n    HashElem *j;\n    FuncDef *p;\n    pParse->nMem = 2;\n    for(i=0; i<SQLITE_FUNC_HASH_SZ; i++){\n      for(p=sqlite3BuiltinFunctions.a[i]; p; p=p->u.pHash ){\n        if( p->funcFlags & SQLITE_FUNC_INTERNAL ) continue;\n        sqlite3VdbeMultiLoad(v, 1, \"si\", p->zName, 1);\n      }\n    }\n    for(j=sqliteHashFirst(&db->aFunc); j; j=sqliteHashNext(j)){\n      p = (FuncDef*)sqliteHashData(j);\n      sqlite3VdbeMultiLoad(v, 1, \"si\", p->zName, 0);\n    }\n  }\n  break;\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  case PragTyp_MODULE_LIST: {\n    HashElem *j;\n    pParse->nMem = 1;\n    for(j=sqliteHashFirst(&db->aModule); j; j=sqliteHashNext(j)){\n      Module *pMod = (Module*)sqliteHashData(j);\n      sqlite3VdbeMultiLoad(v, 1, \"s\", pMod->zName);\n    }\n  }\n  break;\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n  case PragTyp_PRAGMA_LIST: {\n    int i;\n    for(i=0; i<ArraySize(aPragmaName); i++){\n      sqlite3VdbeMultiLoad(v, 1, \"s\", aPragmaName[i].zName);\n    }\n  }\n  break;\n#endif /* SQLITE_INTROSPECTION_PRAGMAS */\n\n#endif /* SQLITE_OMIT_SCHEMA_PRAGMAS */\n\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n  case PragTyp_FOREIGN_KEY_LIST: if( zRight ){\n    FKey *pFK;\n    Table *pTab;\n    pTab = sqlite3FindTable(db, zRight, zDb);\n    if( pTab ){\n      pFK = pTab->pFKey;\n      if( pFK ){\n        int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n        int i = 0; \n        pParse->nMem = 8;\n        sqlite3CodeVerifySchema(pParse, iTabDb);\n        while(pFK){\n          int j;\n          for(j=0; j<pFK->nCol; j++){\n            sqlite3VdbeMultiLoad(v, 1, \"iissssss\",\n                   i,\n                   j,\n                   pFK->zTo,\n                   pTab->aCol[pFK->aCol[j].iFrom].zName,\n                   pFK->aCol[j].zCol,\n                   actionName(pFK->aAction[1]),  /* ON UPDATE */\n                   actionName(pFK->aAction[0]),  /* ON DELETE */\n                   \"NONE\");\n          }\n          ++i;\n          pFK = pFK->pNextFrom;\n        }\n      }\n    }\n  }\n  break;\n#endif /* !defined(SQLITE_OMIT_FOREIGN_KEY) */\n\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n#ifndef SQLITE_OMIT_TRIGGER\n  case PragTyp_FOREIGN_KEY_CHECK: {\n    FKey *pFK;             /* A foreign key constraint */\n    Table *pTab;           /* Child table contain \"REFERENCES\" keyword */\n    Table *pParent;        /* Parent table that child points to */\n    Index *pIdx;           /* Index in the parent table */\n    int i;                 /* Loop counter:  Foreign key number for pTab */\n    int j;                 /* Loop counter:  Field of the foreign key */\n    HashElem *k;           /* Loop counter:  Next table in schema */\n    int x;                 /* result variable */\n    int regResult;         /* 3 registers to hold a result row */\n    int regKey;            /* Register to hold key for checking the FK */\n    int regRow;            /* Registers to hold a row from pTab */\n    int addrTop;           /* Top of a loop checking foreign keys */\n    int addrOk;            /* Jump here if the key is OK */\n    int *aiCols;           /* child to parent column mapping */\n\n    regResult = pParse->nMem+1;\n    pParse->nMem += 4;\n    regKey = ++pParse->nMem;\n    regRow = ++pParse->nMem;\n    k = sqliteHashFirst(&db->aDb[iDb].pSchema->tblHash);\n    while( k ){\n      int iTabDb;\n      if( zRight ){\n        pTab = sqlite3LocateTable(pParse, 0, zRight, zDb);\n        k = 0;\n      }else{\n        pTab = (Table*)sqliteHashData(k);\n        k = sqliteHashNext(k);\n      }\n      if( pTab==0 || pTab->pFKey==0 ) continue;\n      iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n      sqlite3CodeVerifySchema(pParse, iTabDb);\n      sqlite3TableLock(pParse, iTabDb, pTab->tnum, 0, pTab->zName);\n      if( pTab->nCol+regRow>pParse->nMem ) pParse->nMem = pTab->nCol + regRow;\n      sqlite3OpenTable(pParse, 0, iTabDb, pTab, OP_OpenRead);\n      sqlite3VdbeLoadString(v, regResult, pTab->zName);\n      for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom){\n        pParent = sqlite3FindTable(db, pFK->zTo, zDb);\n        if( pParent==0 ) continue;\n        pIdx = 0;\n        sqlite3TableLock(pParse, iTabDb, pParent->tnum, 0, pParent->zName);\n        x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, 0);\n        if( x==0 ){\n          if( pIdx==0 ){\n            sqlite3OpenTable(pParse, i, iTabDb, pParent, OP_OpenRead);\n          }else{\n            sqlite3VdbeAddOp3(v, OP_OpenRead, i, pIdx->tnum, iTabDb);\n            sqlite3VdbeSetP4KeyInfo(pParse, pIdx);\n          }\n        }else{\n          k = 0;\n          break;\n        }\n      }\n      assert( pParse->nErr>0 || pFK==0 );\n      if( pFK ) break;\n      if( pParse->nTab<i ) pParse->nTab = i;\n      addrTop = sqlite3VdbeAddOp1(v, OP_Rewind, 0); VdbeCoverage(v);\n      for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom){\n        pParent = sqlite3FindTable(db, pFK->zTo, zDb);\n        pIdx = 0;\n        aiCols = 0;\n        if( pParent ){\n          x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, &aiCols);\n          assert( x==0 );\n        }\n        addrOk = sqlite3VdbeMakeLabel(pParse);\n\n        /* Generate code to read the child key values into registers\n        ** regRow..regRow+n. If any of the child key values are NULL, this \n        ** row cannot cause an FK violation. Jump directly to addrOk in \n        ** this case. */\n        for(j=0; j<pFK->nCol; j++){\n          int iCol = aiCols ? aiCols[j] : pFK->aCol[j].iFrom;\n          sqlite3ExprCodeGetColumnOfTable(v, pTab, 0, iCol, regRow+j);\n          sqlite3VdbeAddOp2(v, OP_IsNull, regRow+j, addrOk); VdbeCoverage(v);\n        }\n\n        /* Generate code to query the parent index for a matching parent\n        ** key. If a match is found, jump to addrOk. */\n        if( pIdx ){\n          sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, pFK->nCol, regKey,\n              sqlite3IndexAffinityStr(db,pIdx), pFK->nCol);\n          sqlite3VdbeAddOp4Int(v, OP_Found, i, addrOk, regKey, 0);\n          VdbeCoverage(v);\n        }else if( pParent ){\n          int jmp = sqlite3VdbeCurrentAddr(v)+2;\n          sqlite3VdbeAddOp3(v, OP_SeekRowid, i, jmp, regRow); VdbeCoverage(v);\n          sqlite3VdbeGoto(v, addrOk);\n          assert( pFK->nCol==1 );\n        }\n\n        /* Generate code to report an FK violation to the caller. */\n        if( HasRowid(pTab) ){\n          sqlite3VdbeAddOp2(v, OP_Rowid, 0, regResult+1);\n        }else{\n          sqlite3VdbeAddOp2(v, OP_Null, 0, regResult+1);\n        }\n        sqlite3VdbeMultiLoad(v, regResult+2, \"siX\", pFK->zTo, i-1);\n        sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, 4);\n        sqlite3VdbeResolveLabel(v, addrOk);\n        sqlite3DbFree(db, aiCols);\n      }\n      sqlite3VdbeAddOp2(v, OP_Next, 0, addrTop+1); VdbeCoverage(v);\n      sqlite3VdbeJumpHere(v, addrTop);\n    }\n  }\n  break;\n#endif /* !defined(SQLITE_OMIT_TRIGGER) */\n#endif /* !defined(SQLITE_OMIT_FOREIGN_KEY) */\n\n#ifndef SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA\n  /* Reinstall the LIKE and GLOB functions.  The variant of LIKE\n  ** used will be case sensitive or not depending on the RHS.\n  */\n  case PragTyp_CASE_SENSITIVE_LIKE: {\n    if( zRight ){\n      sqlite3RegisterLikeFunctions(db, sqlite3GetBoolean(zRight, 0));\n    }\n  }\n  break;\n#endif /* SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA */\n\n#ifndef SQLITE_INTEGRITY_CHECK_ERROR_MAX\n# define SQLITE_INTEGRITY_CHECK_ERROR_MAX 100\n#endif\n\n#ifndef SQLITE_OMIT_INTEGRITY_CHECK\n  /*    PRAGMA integrity_check\n  **    PRAGMA integrity_check(N)\n  **    PRAGMA quick_check\n  **    PRAGMA quick_check(N)\n  **\n  ** Verify the integrity of the database.\n  **\n  ** The \"quick_check\" is reduced version of \n  ** integrity_check designed to detect most database corruption\n  ** without the overhead of cross-checking indexes.  Quick_check\n  ** is linear time wherease integrity_check is O(NlogN).\n  */\n  case PragTyp_INTEGRITY_CHECK: {\n    int i, j, addr, mxErr;\n\n    int isQuick = (sqlite3Tolower(zLeft[0])=='q');\n\n    /* If the PRAGMA command was of the form \"PRAGMA <db>.integrity_check\",\n    ** then iDb is set to the index of the database identified by <db>.\n    ** In this case, the integrity of database iDb only is verified by\n    ** the VDBE created below.\n    **\n    ** Otherwise, if the command was simply \"PRAGMA integrity_check\" (or\n    ** \"PRAGMA quick_check\"), then iDb is set to 0. In this case, set iDb\n    ** to -1 here, to indicate that the VDBE should verify the integrity\n    ** of all attached databases.  */\n    assert( iDb>=0 );\n    assert( iDb==0 || pId2->z );\n    if( pId2->z==0 ) iDb = -1;\n\n    /* Initialize the VDBE program */\n    pParse->nMem = 6;\n\n    /* Set the maximum error count */\n    mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;\n    if( zRight ){\n      sqlite3GetInt32(zRight, &mxErr);\n      if( mxErr<=0 ){\n        mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;\n      }\n    }\n    sqlite3VdbeAddOp2(v, OP_Integer, mxErr-1, 1); /* reg[1] holds errors left */\n\n    /* Do an integrity check on each database file */\n    for(i=0; i<db->nDb; i++){\n      HashElem *x;     /* For looping over tables in the schema */\n      Hash *pTbls;     /* Set of all tables in the schema */\n      int *aRoot;      /* Array of root page numbers of all btrees */\n      int cnt = 0;     /* Number of entries in aRoot[] */\n      int mxIdx = 0;   /* Maximum number of indexes for any table */\n\n      if( OMIT_TEMPDB && i==1 ) continue;\n      if( iDb>=0 && i!=iDb ) continue;\n\n      sqlite3CodeVerifySchema(pParse, i);\n\n      /* Do an integrity check of the B-Tree\n      **\n      ** Begin by finding the root pages numbers\n      ** for all tables and indices in the database.\n      */\n      assert( sqlite3SchemaMutexHeld(db, i, 0) );\n      pTbls = &db->aDb[i].pSchema->tblHash;\n      for(cnt=0, x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){\n        Table *pTab = sqliteHashData(x);  /* Current table */\n        Index *pIdx;                      /* An index on pTab */\n        int nIdx;                         /* Number of indexes on pTab */\n        if( HasRowid(pTab) ) cnt++;\n        for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){ cnt++; }\n        if( nIdx>mxIdx ) mxIdx = nIdx;\n      }\n      aRoot = sqlite3DbMallocRawNN(db, sizeof(int)*(cnt+1));\n      if( aRoot==0 ) break;\n      for(cnt=0, x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){\n        Table *pTab = sqliteHashData(x);\n        Index *pIdx;\n        if( HasRowid(pTab) ) aRoot[++cnt] = pTab->tnum;\n        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n          aRoot[++cnt] = pIdx->tnum;\n        }\n      }\n      aRoot[0] = cnt;\n\n      /* Make sure sufficient number of registers have been allocated */\n      pParse->nMem = MAX( pParse->nMem, 8+mxIdx );\n      sqlite3ClearTempRegCache(pParse);\n\n      /* Do the b-tree integrity checks */\n      sqlite3VdbeAddOp4(v, OP_IntegrityCk, 2, cnt, 1, (char*)aRoot,P4_INTARRAY);\n      sqlite3VdbeChangeP5(v, (u8)i);\n      addr = sqlite3VdbeAddOp1(v, OP_IsNull, 2); VdbeCoverage(v);\n      sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0,\n         sqlite3MPrintf(db, \"*** in database %s ***\\n\", db->aDb[i].zDbSName),\n         P4_DYNAMIC);\n      sqlite3VdbeAddOp3(v, OP_Concat, 2, 3, 3);\n      integrityCheckResultRow(v);\n      sqlite3VdbeJumpHere(v, addr);\n\n      /* Make sure all the indices are constructed correctly.\n      */\n      for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){\n        Table *pTab = sqliteHashData(x);\n        Index *pIdx, *pPk;\n        Index *pPrior = 0;\n        int loopTop;\n        int iDataCur, iIdxCur;\n        int r1 = -1;\n\n        if( pTab->tnum<1 ) continue;  /* Skip VIEWs or VIRTUAL TABLEs */\n        pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);\n        sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenRead, 0,\n                                   1, 0, &iDataCur, &iIdxCur);\n        /* reg[7] counts the number of entries in the table.\n        ** reg[8+i] counts the number of entries in the i-th index \n        */\n        sqlite3VdbeAddOp2(v, OP_Integer, 0, 7);\n        for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){\n          sqlite3VdbeAddOp2(v, OP_Integer, 0, 8+j); /* index entries counter */\n        }\n        assert( pParse->nMem>=8+j );\n        assert( sqlite3NoTempsInRange(pParse,1,7+j) );\n        sqlite3VdbeAddOp2(v, OP_Rewind, iDataCur, 0); VdbeCoverage(v);\n        loopTop = sqlite3VdbeAddOp2(v, OP_AddImm, 7, 1);\n        if( !isQuick ){\n          /* Sanity check on record header decoding */\n          sqlite3VdbeAddOp3(v, OP_Column, iDataCur, pTab->nNVCol-1,3);\n          sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n        }\n        /* Verify that all NOT NULL columns really are NOT NULL */\n        for(j=0; j<pTab->nCol; j++){\n          char *zErr;\n          int jmp2;\n          if( j==pTab->iPKey ) continue;\n          if( pTab->aCol[j].notNull==0 ) continue;\n          sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n\n>>> [ INFILL ] <<<\n          jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);\n          zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,\n                              pTab->aCol[j].zName);\n          sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n          integrityCheckResultRow(v);\n          sqlite3VdbeJumpHere(v, jmp2);\n        }\n        /* Verify CHECK constraints */\n        if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){\n          ExprList *pCheck = sqlite3ExprListDup(db, pTab->pCheck, 0);\n          if( db->mallocFailed==0 ){\n            int addrCkFault = sqlite3VdbeMakeLabel(pParse);\n            int addrCkOk = sqlite3VdbeMakeLabel(pParse);\n            char *zErr;\n            int k;\n            pParse->iSelfTab = iDataCur + 1;\n            for(k=pCheck->nExpr-1; k>0; k--){\n              sqlite3ExprIfFalse(pParse, pCheck->a[k].pExpr, addrCkFault, 0);\n            }\n            sqlite3ExprIfTrue(pParse, pCheck->a[0].pExpr, addrCkOk, \n                SQLITE_JUMPIFNULL);\n            sqlite3VdbeResolveLabel(v, addrCkFault);\n            pParse->iSelfTab = 0;\n            zErr = sqlite3MPrintf(db, \"CHECK constraint failed in %s\",\n                pTab->zName);\n            sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n            integrityCheckResultRow(v);\n            sqlite3VdbeResolveLabel(v, addrCkOk);\n          }\n          sqlite3ExprListDelete(db, pCheck);\n        }\n        if( !isQuick ){ /* Omit the remaining tests for quick_check */\n          /* Validate index entries for the current row */\n          for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){\n            int jmp2, jmp3, jmp4, jmp5;\n            int ckUniq = sqlite3VdbeMakeLabel(pParse);\n            if( pPk==pIdx ) continue;\n            r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 0, &jmp3,\n                                         pPrior, r1);\n            pPrior = pIdx;\n            sqlite3VdbeAddOp2(v, OP_AddImm, 8+j, 1);/* increment entry count */\n            /* Verify that an index entry exists for the current table row */\n            jmp2 = sqlite3VdbeAddOp4Int(v, OP_Found, iIdxCur+j, ckUniq, r1,\n                                        pIdx->nColumn); VdbeCoverage(v);\n            sqlite3VdbeLoadString(v, 3, \"row \");\n            sqlite3VdbeAddOp3(v, OP_Concat, 7, 3, 3);\n            sqlite3VdbeLoadString(v, 4, \" missing from index \");\n            sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);\n            jmp5 = sqlite3VdbeLoadString(v, 4, pIdx->zName);\n            sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);\n            jmp4 = integrityCheckResultRow(v);\n            sqlite3VdbeJumpHere(v, jmp2);\n            /* For UNIQUE indexes, verify that only one entry exists with the\n            ** current key.  The entry is unique if (1) any column is NULL\n            ** or (2) the next entry has a different key */\n            if( IsUniqueIndex(pIdx) ){\n              int uniqOk = sqlite3VdbeMakeLabel(pParse);\n              int jmp6;\n              int kk;\n              for(kk=0; kk<pIdx->nKeyCol; kk++){\n                int iCol = pIdx->aiColumn[kk];\n                assert( iCol!=XN_ROWID && iCol<pTab->nCol );\n                if( iCol>=0 && pTab->aCol[iCol].notNull ) continue;\n                sqlite3VdbeAddOp2(v, OP_IsNull, r1+kk, uniqOk);\n                VdbeCoverage(v);\n              }\n              jmp6 = sqlite3VdbeAddOp1(v, OP_Next, iIdxCur+j); VdbeCoverage(v);\n              sqlite3VdbeGoto(v, uniqOk);\n              sqlite3VdbeJumpHere(v, jmp6);\n              sqlite3VdbeAddOp4Int(v, OP_IdxGT, iIdxCur+j, uniqOk, r1,\n                                   pIdx->nKeyCol); VdbeCoverage(v);\n              sqlite3VdbeLoadString(v, 3, \"non-unique entry in index \");\n              sqlite3VdbeGoto(v, jmp5);\n              sqlite3VdbeResolveLabel(v, uniqOk);\n            }\n            sqlite3VdbeJumpHere(v, jmp4);\n            sqlite3ResolvePartIdxLabel(pParse, jmp3);\n          }\n        }\n        sqlite3VdbeAddOp2(v, OP_Next, iDataCur, loopTop); VdbeCoverage(v);\n        sqlite3VdbeJumpHere(v, loopTop-1);\n#ifndef SQLITE_OMIT_BTREECOUNT\n        if( !isQuick ){\n          sqlite3VdbeLoadString(v, 2, \"wrong # of entries in index \");\n          for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){\n            if( pPk==pIdx ) continue;\n            sqlite3VdbeAddOp2(v, OP_Count, iIdxCur+j, 3);\n            addr = sqlite3VdbeAddOp3(v, OP_Eq, 8+j, 0, 3); VdbeCoverage(v);\n            sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);\n            sqlite3VdbeLoadString(v, 4, pIdx->zName);\n            sqlite3VdbeAddOp3(v, OP_Concat, 4, 2, 3);\n            integrityCheckResultRow(v);\n            sqlite3VdbeJumpHere(v, addr);\n          }\n        }\n#endif /* SQLITE_OMIT_BTREECOUNT */\n      } \n    }\n    {\n      static const int iLn = VDBE_OFFSET_LINENO(2);\n      static const VdbeOpList endCode[] = {\n        { OP_AddImm,      1, 0,        0},    /* 0 */\n        { OP_IfNotZero,   1, 4,        0},    /* 1 */\n        { OP_String8,     0, 3,        0},    /* 2 */\n        { OP_ResultRow,   3, 1,        0},    /* 3 */\n        { OP_Halt,        0, 0,        0},    /* 4 */\n        { OP_String8,     0, 3,        0},    /* 5 */\n        { OP_Goto,        0, 3,        0},    /* 6 */\n      };\n      VdbeOp *aOp;\n\n      aOp = sqlite3VdbeAddOpList(v, ArraySize(endCode), endCode, iLn);\n      if( aOp ){\n        aOp[0].p2 = 1-mxErr;\n        aOp[2].p4type = P4_STATIC;\n        aOp[2].p4.z = \"ok\";\n        aOp[5].p4type = P4_STATIC;\n        aOp[5].p4.z = (char*)sqlite3ErrStr(SQLITE_CORRUPT);\n      }\n      sqlite3VdbeChangeP3(v, 0, sqlite3VdbeCurrentAddr(v)-2);\n    }\n  }\n  break;\n#endif /* SQLITE_OMIT_INTEGRITY_CHECK */\n\n#ifndef SQLITE_OMIT_UTF16\n  /*\n  **   PRAGMA encoding\n  **   PRAGMA encoding = \"utf-8\"|\"utf-16\"|\"utf-16le\"|\"utf-16be\"\n  **\n  ** In its first form, this pragma returns the encoding of the main\n  ** database. If the database is not initialized, it is initialized now.\n  **\n  ** The second form of this pragma is a no-op if the main database file\n  ** has not already been initialized. In this case it sets the default\n  ** encoding that will be used for the main database file if a new file\n  ** is created. If an existing main database file is opened, then the\n  ** default text encoding for the existing database is used.\n  ** \n  ** In all cases new databases created using the ATTACH command are\n  ** created to use the same default text encoding as the main database. If\n  ** the main database has not been initialized and/or created when ATTACH\n  ** is executed, this is done before the ATTACH operation.\n  **\n  ** In the second form this pragma sets the text encoding to be used in\n  ** new database files created using this database handle. It is only\n  ** useful if invoked immediately after the main database i\n  */\n  case PragTyp_ENCODING: {\n    static const struct EncName {\n      char *zName;\n      u8 enc;\n    } encnames[] = {\n      { \"UTF8\",     SQLITE_UTF8        },\n      { \"UTF-8\",    SQLITE_UTF8        },  /* Must be element [1] */\n      { \"UTF-16le\", SQLITE_UTF16LE     },  /* Must be element [2] */\n      { \"UTF-16be\", SQLITE_UTF16BE     },  /* Must be element [3] */\n      { \"UTF16le\",  SQLITE_UTF16LE     },\n      { \"UTF16be\",  SQLITE_UTF16BE     },\n      { \"UTF-16\",   0                  }, /* SQLITE_UTF16NATIVE */\n      { \"UTF16\",    0                  }, /* SQLITE_UTF16NATIVE */\n      { 0, 0 }\n    };\n    const struct EncName *pEnc;\n    if( !zRight ){    /* \"PRAGMA encoding\" */\n      if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n      assert( encnames[SQLITE_UTF8].enc==SQLITE_UTF8 );\n      assert( encnames[SQLITE_UTF16LE].enc==SQLITE_UTF16LE );\n      assert( encnames[SQLITE_UTF16BE].enc==SQLITE_UTF16BE );\n      returnSingleText(v, encnames[ENC(pParse->db)].zName);\n    }else{                        /* \"PRAGMA encoding = XXX\" */\n      /* Only change the value of sqlite.enc if the database handle is not\n      ** initialized. If the main database exists, the new sqlite.enc value\n      ** will be overwritten when the schema is next loaded. If it does not\n      ** already exists, it will be created to use the new encoding value.\n      */\n      if( \n        !(DbHasProperty(db, 0, DB_SchemaLoaded)) || \n        DbHasProperty(db, 0, DB_Empty) \n      ){\n        for(pEnc=&encnames[0]; pEnc->zName; pEnc++){\n          if( 0==sqlite3StrICmp(zRight, pEnc->zName) ){\n            SCHEMA_ENC(db) = ENC(db) =\n                pEnc->enc ? pEnc->enc : SQLITE_UTF16NATIVE;\n            break;\n          }\n        }\n        if( !pEnc->zName ){\n          sqlite3ErrorMsg(pParse, \"unsupported encoding: %s\", zRight);\n        }\n      }\n    }\n  }\n  break;\n#endif /* SQLITE_OMIT_UTF16 */\n\n#ifndef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS\n  /*\n  **   PRAGMA [schema.]schema_version\n  **   PRAGMA [schema.]schema_version = <integer>\n  **\n  **   PRAGMA [schema.]user_version\n  **   PRAGMA [schema.]user_version = <integer>\n  **\n  **   PRAGMA [schema.]freelist_count\n  **\n  **   PRAGMA [schema.]data_version\n  **\n  **   PRAGMA [schema.]application_id\n  **   PRAGMA [schema.]application_id = <integer>\n  **\n  ** The pragma's schema_version and user_version are used to set or get\n  ** the value of the schema-version and user-version, respectively. Both\n  ** the schema-version and the user-version are 32-bit signed integers\n  ** stored in the database header.\n  **\n  ** The schema-cookie is usually only manipulated internally by SQLite. It\n  ** is incremented by SQLite whenever the database schema is modified (by\n  ** creating or dropping a table or index). The schema version is used by\n  ** SQLite each time a query is executed to ensure that the internal cache\n  ** of the schema used when compiling the SQL query matches the schema of\n  ** the database against which the compiled query is actually executed.\n  ** Subverting this mechanism by using \"PRAGMA schema_version\" to modify\n  ** the schema-version is potentially dangerous and may lead to program\n  ** crashes or database corruption. Use with caution!\n  **\n  ** The user-version is not used internally by SQLite. It may be used by\n  ** applications for any purpose.\n  */\n  case PragTyp_HEADER_VALUE: {\n    int iCookie = pPragma->iArg;  /* Which cookie to read or write */\n    sqlite3VdbeUsesBtree(v, iDb);\n    if( zRight && (pPragma->mPragFlg & PragFlg_ReadOnly)==0 ){\n      /* Write the specified cookie value */\n      static const VdbeOpList setCookie[] = {\n        { OP_Transaction,    0,  1,  0},    /* 0 */\n        { OP_SetCookie,      0,  0,  0},    /* 1 */\n      };\n      VdbeOp *aOp;\n      sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setCookie));\n      aOp = sqlite3VdbeAddOpList(v, ArraySize(setCookie), setCookie, 0);\n      if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;\n      aOp[0].p1 = iDb;\n      aOp[1].p1 = iDb;\n      aOp[1].p2 = iCookie;\n      aOp[1].p3 = sqlite3Atoi(zRight);\n    }else{\n      /* Read the specified cookie value */\n      static const VdbeOpList readCookie[] = {\n        { OP_Transaction,     0,  0,  0},    /* 0 */\n        { OP_ReadCookie,      0,  1,  0},    /* 1 */\n        { OP_ResultRow,       1,  1,  0}\n      };\n      VdbeOp *aOp;\n      sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(readCookie));\n      aOp = sqlite3VdbeAddOpList(v, ArraySize(readCookie),readCookie,0);\n      if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;\n      aOp[0].p1 = iDb;\n      aOp[1].p1 = iDb;\n      aOp[1].p3 = iCookie;\n      sqlite3VdbeReusable(v);\n    }\n  }\n  break;\n#endif /* SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS */\n\n#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS\n  /*\n  **   PRAGMA compile_options\n  **\n  ** Return the names of all compile-time options used in this build,\n  ** one option per row.\n  */\n  case PragTyp_COMPILE_OPTIONS: {\n    int i = 0;\n    const char *zOpt;\n    pParse->nMem = 1;\n    while( (zOpt = sqlite3_compileoption_get(i++))!=0 ){\n      sqlite3VdbeLoadString(v, 1, zOpt);\n      sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n    }\n    sqlite3VdbeReusable(v);\n  }\n  break;\n#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */\n\n#ifndef SQLITE_OMIT_WAL\n  /*\n  **   PRAGMA [schema.]wal_checkpoint = passive|full|restart|truncate\n  **\n  ** Checkpoint the database.\n  */\n  case PragTyp_WAL_CHECKPOINT: {\n    int iBt = (pId2->z?iDb:SQLITE_MAX_ATTACHED);\n    int eMode = SQLITE_CHECKPOINT_PASSIVE;\n    if( zRight ){\n      if( sqlite3StrICmp(zRight, \"full\")==0 ){\n        eMode = SQLITE_CHECKPOINT_FULL;\n      }else if( sqlite3StrICmp(zRight, \"restart\")==0 ){\n        eMode = SQLITE_CHECKPOINT_RESTART;\n      }else if( sqlite3StrICmp(zRight, \"truncate\")==0 ){\n        eMode = SQLITE_CHECKPOINT_TRUNCATE;\n      }\n    }\n    pParse->nMem = 3;\n    sqlite3VdbeAddOp3(v, OP_Checkpoint, iBt, eMode, 1);\n    sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);\n  }\n  break;\n\n  /*\n  **   PRAGMA wal_autocheckpoint\n  **   PRAGMA wal_autocheckpoint = N\n  **\n  ** Configure a database connection to automatically checkpoint a database\n  ** after accumulating N frames in the log. Or query for the current value\n  ** of N.\n  */\n  case PragTyp_WAL_AUTOCHECKPOINT: {\n    if( zRight ){\n      sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));\n    }\n    returnSingleInt(v, \n       db->xWalCallback==sqlite3WalDefaultHook ? \n           SQLITE_PTR_TO_INT(db->pWalArg) : 0);\n  }\n  break;\n#endif\n\n  /*\n  **  PRAGMA shrink_memory\n  **\n  ** IMPLEMENTATION-OF: R-23445-46109 This pragma causes the database\n  ** connection on which it is invoked to free up as much memory as it\n  ** can, by calling sqlite3_db_release_memory().\n  */\n  case PragTyp_SHRINK_MEMORY: {\n    sqlite3_db_release_memory(db);\n    break;\n  }\n\n  /*\n  **  PRAGMA optimize\n  **  PRAGMA optimize(MASK)\n  **  PRAGMA schema.optimize\n  **  PRAGMA schema.optimize(MASK)\n  **\n  ** Attempt to optimize the database.  All schemas are optimized in the first\n  ** two forms, and only the specified schema is optimized in the latter two.\n  **\n  ** The details of optimizations performed by this pragma are expected\n  ** to change and improve over time.  Applications should anticipate that\n  ** this pragma will perform new optimizations in future releases.\n  **\n  ** The optional argument is a bitmask of optimizations to perform:\n  **\n  **    0x0001    Debugging mode.  Do not actually perform any optimizations\n  **              but instead return one line of text for each optimization\n  **              that would have been done.  Off by default.\n  **\n  **    0x0002    Run ANALYZE on tables that might benefit.  On by default.\n  **              See below for additional information.\n  **\n  **    0x0004    (Not yet implemented) Record usage and performance \n  **              information from the current session in the\n  **              database file so that it will be available to \"optimize\"\n  **              pragmas run by future database connections.\n  **\n  **    0x0008    (Not yet implemented) Create indexes that might have\n  **              been helpful to recent queries\n  **\n  ** The default MASK is and always shall be 0xfffe.  0xfffe means perform all\n  ** of the optimizations listed above except Debug Mode, including new\n  ** optimizations that have not yet been invented.  If new optimizations are\n  ** ever added that should be off by default, those off-by-default \n  ** optimizations will have bitmasks of 0x10000 or larger.\n  **\n  ** DETERMINATION OF WHEN TO RUN ANALYZE\n  **\n  ** In the current implementation, a table is analyzed if only if all of\n  ** the following are true:\n  **\n  ** (1) MASK bit 0x02 is set.\n  **\n  ** (2) The query planner used sqlite_stat1-style statistics for one or\n  **     more indexes of the table at some point during the lifetime of\n  **     the current connection.\n  **\n  ** (3) One or more indexes of the table are currently unanalyzed OR\n  **     the number of rows in the table has increased by 25 times or more\n  **     since the last time ANALYZE was run.\n  **\n  ** The rules for when tables are analyzed are likely to change in\n  ** future releases.\n  */\n  case PragTyp_OPTIMIZE: {\n    int iDbLast;           /* Loop termination point for the schema loop */\n    int iTabCur;           /* Cursor for a table whose size needs checking */\n    HashElem *k;           /* Loop over tables of a schema */\n    Schema *pSchema;       /* The current schema */\n    Table *pTab;           /* A table in the schema */\n    Index *pIdx;           /* An index of the table */\n    LogEst szThreshold;    /* Size threshold above which reanalysis is needd */\n    char *zSubSql;         /* SQL statement for the OP_SqlExec opcode */\n    u32 opMask;            /* Mask of operations to perform */\n\n    if( zRight ){\n      opMask = (u32)sqlite3Atoi(zRight);\n      if( (opMask & 0x02)==0 ) break;\n    }else{\n      opMask = 0xfffe;\n    }\n    iTabCur = pParse->nTab++;\n    for(iDbLast = zDb?iDb:db->nDb-1; iDb<=iDbLast; iDb++){\n      if( iDb==1 ) continue;\n      sqlite3CodeVerifySchema(pParse, iDb);\n      pSchema = db->aDb[iDb].pSchema;\n      for(k=sqliteHashFirst(&pSchema->tblHash); k; k=sqliteHashNext(k)){\n        pTab = (Table*)sqliteHashData(k);\n\n        /* If table pTab has not been used in a way that would benefit from\n        ** having analysis statistics during the current session, then skip it.\n        ** This also has the effect of skipping virtual tables and views */\n        if( (pTab->tabFlags & TF_StatsUsed)==0 ) continue;\n\n        /* Reanalyze if the table is 25 times larger than the last analysis */\n        szThreshold = pTab->nRowLogEst + 46; assert( sqlite3LogEst(25)==46 );\n        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n          if( !pIdx->hasStat1 ){\n            szThreshold = 0; /* Always analyze if any index lacks statistics */\n            break;\n          }\n        }\n        if( szThreshold ){\n          sqlite3OpenTable(pParse, iTabCur, iDb, pTab, OP_OpenRead);\n          sqlite3VdbeAddOp3(v, OP_IfSmaller, iTabCur, \n                         sqlite3VdbeCurrentAddr(v)+2+(opMask&1), szThreshold);\n          VdbeCoverage(v);\n        }\n        zSubSql = sqlite3MPrintf(db, \"ANALYZE \\\"%w\\\".\\\"%w\\\"\",\n                                 db->aDb[iDb].zDbSName, pTab->zName);\n        if( opMask & 0x01 ){\n          int r1 = sqlite3GetTempReg(pParse);\n          sqlite3VdbeAddOp4(v, OP_String8, 0, r1, 0, zSubSql, P4_DYNAMIC);\n          sqlite3VdbeAddOp2(v, OP_ResultRow, r1, 1);\n        }else{\n          sqlite3VdbeAddOp4(v, OP_SqlExec, 0, 0, 0, zSubSql, P4_DYNAMIC);\n        }\n      }\n    }\n    sqlite3VdbeAddOp0(v, OP_Expire);\n    break;\n  }\n\n  /*\n  **   PRAGMA busy_timeout\n  **   PRAGMA busy_timeout = N\n  **\n  ** Call sqlite3_busy_timeout(db, N).  Return the current timeout value\n  ** if one is set.  If no busy handler or a different busy handler is set\n  ** then 0 is returned.  Setting the busy_timeout to 0 or negative\n  ** disables the timeout.\n  */\n  /*case PragTyp_BUSY_TIMEOUT*/ default: {\n    assert( pPragma->ePragTyp==PragTyp_BUSY_TIMEOUT );\n    if( zRight ){\n      sqlite3_busy_timeout(db, sqlite3Atoi(zRight));\n    }\n    returnSingleInt(v, db->busyTimeout);\n    break;\n  }\n\n  /*\n  **   PRAGMA soft_heap_limit\n  **   PRAGMA soft_heap_limit = N\n  **\n  ** IMPLEMENTATION-OF: R-26343-45930 This pragma invokes the\n  ** sqlite3_soft_heap_limit64() interface with the argument N, if N is\n  ** specified and is a non-negative integer.\n  ** IMPLEMENTATION-OF: R-64451-07163 The soft_heap_limit pragma always\n  ** returns the same integer that would be returned by the\n  ** sqlite3_soft_heap_limit64(-1) C-language function.\n  */\n  case PragTyp_SOFT_HEAP_LIMIT: {\n    sqlite3_int64 N;\n    if( zRight && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK ){\n      sqlite3_soft_heap_limit64(N);\n    }\n    returnSingleInt(v, sqlite3_soft_heap_limit64(-1));\n    break;\n  }\n\n  /*\n  **   PRAGMA hard_heap_limit\n  **   PRAGMA hard_heap_limit = N\n  **\n  ** Invoke sqlite3_hard_heap_limit64() to query or set the hard heap\n  ** limit.  The hard heap limit can be activated or lowered by this\n  ** pragma, but not raised or deactivated.  Only the\n  ** sqlite3_hard_heap_limit64() C-language API can raise or deactivate\n  ** the hard heap limit.  This allows an application to set a heap limit\n  ** constraint that cannot be relaxed by an untrusted SQL script.\n  */\n  case PragTyp_HARD_HEAP_LIMIT: {\n    sqlite3_int64 N;\n    if( zRight && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK ){\n      sqlite3_int64 iPrior = sqlite3_hard_heap_limit64(-1);\n      if( N>0 && (iPrior==0 || iPrior>N) ) sqlite3_hard_heap_limit64(N);\n    }\n    returnSingleInt(v, sqlite3_hard_heap_limit64(-1));\n    break;\n  }\n\n  /*\n  **   PRAGMA threads\n  **   PRAGMA threads = N\n  **\n  ** Configure the maximum number of worker threads.  Return the new\n  ** maximum, which might be less than requested.\n  */\n  case PragTyp_THREADS: {\n    sqlite3_int64 N;\n    if( zRight\n     && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK\n     && N>=0\n    ){\n      sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, (int)(N&0x7fffffff));\n    }\n    returnSingleInt(v, sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, -1));\n    break;\n  }\n\n#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)\n  /*\n  ** Report the current state of file logs for all databases\n  */\n  case PragTyp_LOCK_STATUS: {\n    static const char *const azLockName[] = {\n      \"unlocked\", \"shared\", \"reserved\", \"pending\", \"exclusive\"\n    };\n    int i;\n    pParse->nMem = 2;\n    for(i=0; i<db->nDb; i++){\n      Btree *pBt;\n      const char *zState = \"unknown\";\n      int j;\n      if( db->aDb[i].zDbSName==0 ) continue;\n      pBt = db->aDb[i].pBt;\n      if( pBt==0 || sqlite3BtreePager(pBt)==0 ){\n        zState = \"closed\";\n      }else if( sqlite3_file_control(db, i ? db->aDb[i].zDbSName : 0, \n                                     SQLITE_FCNTL_LOCKSTATE, &j)==SQLITE_OK ){\n         zState = azLockName[j];\n      }\n      sqlite3VdbeMultiLoad(v, 1, \"ss\", db->aDb[i].zDbSName, zState);\n    }\n    break;\n  }\n#endif\n\n#ifdef SQLITE_HAS_CODEC\n  /* Pragma        iArg\n  ** ----------   ------\n  **  key           0\n  **  rekey         1\n  **  hexkey        2\n  **  hexrekey      3\n  **  textkey       4\n  **  textrekey     5\n  */\n  case PragTyp_KEY: {\n    if( zRight ){\n      char zBuf[40];\n      const char *zKey = zRight;\n      int n;\n      if( pPragma->iArg==2 || pPragma->iArg==3 ){\n        u8 iByte;\n        int i;\n        for(i=0, iByte=0; i<sizeof(zBuf)*2 && sqlite3Isxdigit(zRight[i]); i++){\n          iByte = (iByte<<4) + sqlite3HexToInt(zRight[i]);\n          if( (i&1)!=0 ) zBuf[i/2] = iByte;\n        }\n        zKey = zBuf;\n        n = i/2;\n      }else{\n        n = pPragma->iArg<4 ? sqlite3Strlen30(zRight) : -1;\n      }\n      if( (pPragma->iArg & 1)==0 ){\n        rc = sqlite3_key_v2(db, zDb, zKey, n);\n      }else{\n        rc = sqlite3_rekey_v2(db, zDb, zKey, n);\n      }\n      if( rc==SQLITE_OK && n!=0 ){\n        sqlite3VdbeSetNumCols(v, 1);\n        sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"ok\", SQLITE_STATIC);\n        returnSingleText(v, \"ok\");\n      }\n    }\n    break;\n  }\n#endif\n#if defined(SQLITE_HAS_CODEC) || defined(SQLITE_ENABLE_CEROD)\n  case PragTyp_ACTIVATE_EXTENSIONS: if( zRight ){\n#ifdef SQLITE_HAS_CODEC\n    if( sqlite3StrNICmp(zRight, \"see-\", 4)==0 ){\n      sqlite3_activate_see(&zRight[4]);\n    }\n#endif\n#ifdef SQLITE_ENABLE_CEROD\n    if( sqlite3StrNICmp(zRight, \"cerod-\", 6)==0 ){\n      sqlite3_activate_cerod(&zRight[6]);\n    }\n#endif\n  }\n  break;\n#endif\n\n  } /* End of the PRAGMA switch */\n\n  /* The following block is a no-op unless SQLITE_DEBUG is defined. Its only\n  ** purpose is to execute assert() statements to verify that if the\n  ** PragFlg_NoColumns1 flag is set and the caller specified an argument\n  ** to the PRAGMA, the implementation has not added any OP_ResultRow \n  ** instructions to the VM.  */\n  if( (pPragma->mPragFlg & PragFlg_NoColumns1) && zRight ){\n    sqlite3VdbeVerifyNoResultRow(v);\n  }\n\npragma_out:\n  sqlite3DbFree(db, zLeft);\n  sqlite3DbFree(db, zRight);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n          sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n\n```\n\n\n\nwith the following test error: warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\ngencol1-12.10...Exception ignored in: <gdb._GdbOutputFile object at 0x7f8ee7d2d790>\nTraceback (most recent call last):\n  File \"/usr/share/gdb/python/gdb/__init__.py\", line 43, in flush\n    def flush(self):\nKeyboardInterrupt: \n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ebd70eedd5d6e6a890a670b5ee874a5eae86b4dd___pragma.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic int selectExpander(Walker *pWalker, Select *p){\n  Parse *pParse = pWalker->pParse;\n  int i, j, k;\n  SrcList *pTabList;\n  ExprList *pEList;\n  struct SrcList_item *pFrom;\n  sqlite3 *db = pParse->db;\n  Expr *pE, *pRight, *pExpr;\n  u16 selFlags = p->selFlags;\n  u32 elistFlags = 0;\n\n  p->selFlags |= SF_Expanded;\n  if( db->mallocFailed  ){\n    return WRC_Abort;\n  }\n  assert( p->pSrc!=0 );\n  if( (selFlags & SF_Expanded)!=0 ){\n    return WRC_Prune;\n  }\n  if( pWalker->eCode ){\n    /* Renumber selId because it has been copied from a view */\n    p->selId = ++pParse->nSelect;\n  }\n  pTabList = p->pSrc;\n  pEList = p->pEList;\n  sqlite3WithPush(pParse, p->pWith, 0);\n\n  /* Make sure cursor numbers have been assigned to all entries in\n  ** the FROM clause of the SELECT statement.\n  */\n  sqlite3SrcListAssignCursors(pParse, pTabList);\n\n  /* Look up every table named in the FROM clause of the select.  If\n  ** an entry of the FROM clause is a subquery instead of a table or view,\n  ** then create a transient table structure to describe the subquery.\n  */\n  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n    Table *pTab;\n    assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );\n    if( pFrom->fg.isRecursive ) continue;\n    assert( pFrom->pTab==0 );\n#ifndef SQLITE_OMIT_CTE\n    if( withExpand(pWalker, pFrom) ) return WRC_Abort;\n    if( pFrom->pTab ) {} else\n#endif\n    if( pFrom->zName==0 ){\n#ifndef SQLITE_OMIT_SUBQUERY\n      Select *pSel = pFrom->pSelect;\n      /* A sub-query in the FROM clause of a SELECT */\n      assert( pSel!=0 );\n      assert( pFrom->pTab==0 );\n      if( sqlite3WalkSelect(pWalker, pSel) ) return WRC_Abort;\n      if( sqlite3ExpandSubquery(pParse, pFrom) ) return WRC_Abort;\n#endif\n    }else{\n      /* An ordinary table or view name in the FROM clause */\n      assert( pFrom->pTab==0 );\n      pFrom->pTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);\n      if( pTab==0 ) return WRC_Abort;\n      if( pTab->nTabRef>=0xffff ){\n        sqlite3ErrorMsg(pParse, \"too many references to \\\"%s\\\": max 65535\",\n           pTab->zName);\n        pFrom->pTab = 0;\n        return WRC_Abort;\n      }\n      pTab->nTabRef++;\n      if( !IsVirtual(pTab) && cannotBeFunction(pParse, pFrom) ){\n        return WRC_Abort;\n      }\n#if !defined(SQLITE_OMIT_VIEW) || !defined (SQLITE_OMIT_VIRTUALTABLE)\n      if( IsVirtual(pTab) || pTab->pSelect ){\n        i16 nCol;\n        u8 eCodeOrig = pWalker->eCode;\n        if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;\n        assert( pFrom->pSelect==0 );\n        if( pTab->pSelect && (db->flags & SQLITE_EnableView)==0 ){\n          sqlite3ErrorMsg(pParse, \"access to view \\\"%s\\\" prohibited\",\n              pTab->zName);\n        }\n        pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);\n        nCol = pTab->nCol;\n        pTab->nCol = -1;\n        pWalker->eCode = 1;  /* Turn on Select.selId renumbering */\n        sqlite3WalkSelect(pWalker, pFrom->pSelect);\n        pWalker->eCode = eCodeOrig;\n        pTab->nCol = nCol;\n      }\n#endif\n    }\n\n    /* Locate the index named by the INDEXED BY clause, if any. */\n    if( sqlite3IndexedByLookup(pParse, pFrom) ){\n      return WRC_Abort;\n    }\n  }\n\n  /* Process NATURAL keywords, and ON and USING clauses of joins.\n  */\n\n>>> [ INFILL ] <<<\n    return WRC_Abort;\n  }\n\n  /* For every \"*\" that occurs in the column list, insert the names of\n  ** all columns in all tables.  And for every TABLE.* insert the names\n  ** of all columns in TABLE.  The parser inserted a special expression\n  ** with the TK_ASTERISK operator for each \"*\" that it found in the column\n  ** list.  The following code just has to locate the TK_ASTERISK\n  ** expressions and expand each one to the list of all columns in\n  ** all tables.\n  **\n  ** The first loop just checks to see if there are any \"*\" operators\n  ** that need expanding.\n  */\n  for(k=0; k<pEList->nExpr; k++){\n    pE = pEList->a[k].pExpr;\n    if( pE->op==TK_ASTERISK ) break;\n    assert( pE->op!=TK_DOT || pE->pRight!=0 );\n    assert( pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) );\n    if( pE->op==TK_DOT && pE->pRight->op==TK_ASTERISK ) break;\n    elistFlags |= pE->flags;\n  }\n  if( k<pEList->nExpr ){\n    /*\n    ** If we get here it means the result set contains one or more \"*\"\n    ** operators that need to be expanded.  Loop through each expression\n    ** in the result set and expand them one by one.\n    */\n    struct ExprList_item *a = pEList->a;\n    ExprList *pNew = 0;\n    int flags = pParse->db->flags;\n    int longNames = (flags & SQLITE_FullColNames)!=0\n                      && (flags & SQLITE_ShortColNames)==0;\n\n    for(k=0; k<pEList->nExpr; k++){\n      pE = a[k].pExpr;\n      elistFlags |= pE->flags;\n      pRight = pE->pRight;\n      assert( pE->op!=TK_DOT || pRight!=0 );\n      if( pE->op!=TK_ASTERISK\n       && (pE->op!=TK_DOT || pRight->op!=TK_ASTERISK)\n      ){\n        /* This particular expression does not need to be expanded.\n        */\n        pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);\n        if( pNew ){\n          pNew->a[pNew->nExpr-1].zName = a[k].zName;\n          pNew->a[pNew->nExpr-1].zSpan = a[k].zSpan;\n          a[k].zName = 0;\n          a[k].zSpan = 0;\n        }\n        a[k].pExpr = 0;\n      }else{\n        /* This expression is a \"*\" or a \"TABLE.*\" and needs to be\n        ** expanded. */\n        int tableSeen = 0;      /* Set to 1 when TABLE matches */\n        char *zTName = 0;       /* text of name of TABLE */\n        if( pE->op==TK_DOT ){\n          assert( pE->pLeft!=0 );\n          assert( !ExprHasProperty(pE->pLeft, EP_IntValue) );\n          zTName = pE->pLeft->u.zToken;\n        }\n        for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n          Table *pTab = pFrom->pTab;\n          Select *pSub = pFrom->pSelect;\n          char *zTabName = pFrom->zAlias;\n          const char *zSchemaName = 0;\n          int iDb;\n          if( zTabName==0 ){\n            zTabName = pTab->zName;\n          }\n          if( db->mallocFailed ) break;\n          if( pSub==0 || (pSub->selFlags & SF_NestedFrom)==0 ){\n            pSub = 0;\n            if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){\n              continue;\n            }\n            iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n            zSchemaName = iDb>=0 ? db->aDb[iDb].zDbSName : \"*\";\n          }\n          for(j=0; j<pTab->nCol; j++){\n            char *zName = pTab->aCol[j].zName;\n            char *zColname;  /* The computed column name */\n            char *zToFree;   /* Malloced string that needs to be freed */\n            Token sColname;  /* Computed column name as a token */\n\n            assert( zName );\n            if( zTName && pSub\n             && sqlite3MatchSpanName(pSub->pEList->a[j].zSpan, 0, zTName, 0)==0\n            ){\n              continue;\n            }\n\n            /* If a column is marked as 'hidden', omit it from the expanded\n            ** result-set list unless the SELECT has the SF_IncludeHidden\n            ** bit set.\n            */\n            if( (p->selFlags & SF_IncludeHidden)==0\n             && IsHiddenColumn(&pTab->aCol[j]) \n            ){\n              continue;\n            }\n            tableSeen = 1;\n\n            if( i>0 && zTName==0 ){\n              if( (pFrom->fg.jointype & JT_NATURAL)!=0\n                && tableAndColumnIndex(pTabList, i, zName, 0, 0)\n              ){\n                /* In a NATURAL join, omit the join columns from the \n                ** table to the right of the join */\n                continue;\n              }\n              if( sqlite3IdListIndex(pFrom->pUsing, zName)>=0 ){\n                /* In a join with a USING clause, omit columns in the\n                ** using clause from the table on the right. */\n                continue;\n              }\n            }\n            pRight = sqlite3Expr(db, TK_ID, zName);\n            zColname = zName;\n            zToFree = 0;\n            if( longNames || pTabList->nSrc>1 ){\n              Expr *pLeft;\n              pLeft = sqlite3Expr(db, TK_ID, zTabName);\n              pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);\n              if( zSchemaName ){\n                pLeft = sqlite3Expr(db, TK_ID, zSchemaName);\n                pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pExpr);\n              }\n              if( longNames ){\n                zColname = sqlite3MPrintf(db, \"%s.%s\", zTabName, zName);\n                zToFree = zColname;\n              }\n            }else{\n              pExpr = pRight;\n            }\n            pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);\n            sqlite3TokenInit(&sColname, zColname);\n            sqlite3ExprListSetName(pParse, pNew, &sColname, 0);\n            if( pNew && (p->selFlags & SF_NestedFrom)!=0 ){\n              struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];\n              if( pSub ){\n                pX->zSpan = sqlite3DbStrDup(db, pSub->pEList->a[j].zSpan);\n                testcase( pX->zSpan==0 );\n              }else{\n                pX->zSpan = sqlite3MPrintf(db, \"%s.%s.%s\",\n                                           zSchemaName, zTabName, zColname);\n                testcase( pX->zSpan==0 );\n              }\n              pX->bSpanIsTab = 1;\n            }\n            sqlite3DbFree(db, zToFree);\n          }\n        }\n        if( !tableSeen ){\n          if( zTName ){\n            sqlite3ErrorMsg(pParse, \"no such table: %s\", zTName);\n          }else{\n            sqlite3ErrorMsg(pParse, \"no tables specified\");\n          }\n        }\n      }\n    }\n    sqlite3ExprListDelete(db, pEList);\n    p->pEList = pNew;\n  }\n  if( p->pEList ){\n    if( p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n      sqlite3ErrorMsg(pParse, \"too many columns in result set\");\n      return WRC_Abort;\n    }\n    if( (elistFlags & (EP_HasFunc|EP_Subquery))!=0 ){\n      p->selFlags |= SF_ComplexResult;\n    }\n  }\n  return WRC_Continue;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n\n```\n\n\n\nwith the following test error: warning: Error disabling address space randomization: Operation not permitted\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".\n[Detaching after fork from child process 42845]\nSQLite 2019-12-27 20:54:42 d29edef93451cc67a5d69c1cce1b1832d9ca8fff1f600afdd51338b74d077b92\n0 errors out of 71 tests on deef54515472 Linux 64-bit little-endian\nAll memory allocations freed - no leaks\nMemory used:          now          0  max     392328  max-size     120000\nAllocation count:     now          0  max        402\nPage-cache used:      now          0  max          0  max-size       1288\nPage-cache overflow:  now          0  max       6960\nMaximum memory usage: 392328 bytes\nCurrent memory usage: 0 bytes\nNumber of malloc()  : -1 calls\n[Inferior 1 (process 39996) exited normally]\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "a6c1a71cde082e09750465d5675699062922e387___select.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nBGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit, rightLimit;\n\tint i;\n\tint restoreAlphaBleding;\n\n\n>>> [ INFILL ] <<<\n\t\t/* Refuse to fill to a non-solid border */\n\t\treturn;\n\t}\n\n\tleftLimit = (-1);\n\n\trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\t\n\tfor (i = x; (i >= 0); i--) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == (-1)) {\n\t\tim->alphaBlendingFlag = restoreAlphaBleding;\n\t\treturn;\n\t}\n\t/* Seek right */\n\trightLimit = x;\n\tfor (i = (x + 1); (i < im->sx); i++) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t/* Look at lines above and below and start paints */\n\t/* Above */\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c;\n\t\t\tc = gdImageGetPixel (im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\t/* Below */\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c = gdImageGetPixel (im, i, y + 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBleding;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\tif (border < 0) {\n\n```\n\n\n\nwith the following test error: ====================================\n   GD 2.2.1: tests/test-suite.log\n====================================\n\n# TOTAL: 107\n# PASS:  103\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  4\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:35: Total pixels changed: 9 with a maximum channel difference of 255.\nReference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gdimagefilltoborder/github_bug_215\n========================================\n\nFAIL gdimagefilltoborder/github_bug_215 (exit status: 139)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\n(491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\nFAIL: gif/bug00006\n==================\n\ngif/bug00006.c:49: assert failed in <%s:%i>\nFAIL gif/bug00006 (exit status: 1)\n\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "77f619d48259383628c3ec4654b1ad578e9eb40e___gd.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nint read_image_tga( gdIOCtx *ctx, oTga *tga )\n{\n\tint pixel_block_size = (tga->bits / 8);\n\tint image_block_size = (tga->width * tga->height) * pixel_block_size;\n\tint* decompression_buffer = NULL;\n\tunsigned char* conversion_buffer = NULL;\n\tint buffer_caret = 0;\n\tint bitmap_caret = 0;\n\tint i = 0;\n\tint encoded_pixels;\n\tint rle_size;\n\n\tif(overflow2(tga->width, tga->height)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(tga->width * tga->height, pixel_block_size)) {\n\t\treturn -1;\n\t}\n\n\tif(overflow2(image_block_size, sizeof(int))) {\n\t\treturn -1;\n\t}\n\n\t/*! \\todo Add more image type support.\n\t */\n\tif (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)\n\t\treturn -1;\n\n\t/*!\t\\brief Allocate memmory for image block\n\t *  Allocate a chunk of memory for the image block to be passed into.\n\t */\n\ttga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));\n\tif (tga->bitmap == NULL)\n\t\treturn -1;\n\n\tswitch (tga->imagetype) {\n\tcase TGA_TYPE_RGB:\n\t\t/*! \\brief Read in uncompressed RGB TGA\n\t\t *  Chunk load the pixel data from an uncompressed RGB type TGA.\n\t\t */\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree(conversion_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\twhile (buffer_caret < image_block_size) {\n\t\t\ttga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tgdFree(conversion_buffer);\n\t\tbreak;\n\n\tcase TGA_TYPE_RGB_RLE:\n\t\t/*! \\brief Read in RLE compressed RGB TGA\n\t\t *  Chunk load the pixel data from an RLE compressed RGB type TGA.\n\t\t */\n\t\tdecompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));\n\t\tif (decompression_buffer == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tconversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));\n\t\tif (conversion_buffer == NULL) {\n\t\t\tgd_error(\"gd-tga: premature end of image data\\n\");\n\t\t\tgdFree( decompression_buffer );\n\t\t\treturn -1;\n\t\t}\n\n\t\trle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);\n\t\tif (rle_size <= 0) {\n\t\t\tgdFree(conversion_buffer);\n\t\t\tgdFree(decompression_buffer);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( buffer_caret < rle_size) {\n\t\t\tdecompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];\n\t\t\tbuffer_caret++;\n\t\t}\n\n\t\tbuffer_caret = 0;\n\n\t\twhile( bitmap_caret < image_block_size ) {\n\n>>> [ INFILL ] <<<\n\t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + pixel_block_size > rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n\t\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));\n\t\t\t\t\tbitmap_caret += pixel_block_size;\n\t\t\t\t}\n\t\t\t\tbuffer_caret += pixel_block_size;\n\n\t\t\t} else {\n\t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n\t\t\t\tbuffer_caret++;\n\n\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n\t\t\t\t\t\t|| buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {\n\t\t\t\t\tgdFree( decompression_buffer );\n\t\t\t\t\tgdFree( conversion_buffer );\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));\n\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n\t\t\t}\n\t\t}\n\t\tgdFree( decompression_buffer );\n\t\tgdFree( conversion_buffer );\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\t\n\n```\n\n\n\nwith the following test error: ========================================\n   GD 2.3.0-dev: tests/test-suite.log\n========================================\n\n# TOTAL: 155\n# PASS:  153\n# SKIP:  0\n# XFAIL: 0\n# FAIL:  2\n# XPASS: 0\n# ERROR: 0\n\n.. contents:: :depth: 2\n\nFAIL: freetype/bug00132\n=======================\n\nfreetype/bug00132.c:31: Total pixels changed: 9 with a maximum channel difference of 255.\nfreetype/bug00132.c:33: Reference image and destination differ\nFAIL freetype/bug00132 (exit status: 1)\n\nFAIL: gdimagestringft/gdimagestringft_bbox\n==========================================\n\ngdimagestringft/gdimagestringft_bbox.c:56: (491, 364) (613, 313) (602, 288) (481, 338) expected, but (491, 364) (613, 313) (602, 288) (480, 339)\nFAIL gdimagestringft/gdimagestringft_bbox (exit status: 1)\n\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "58b6dde319c301b0eae27d12e2a659e067d80558___gd_tga.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nSPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = Z_SPLDLLIST_P(getThis());\n\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\t/* $obj[] = ... */\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\t/* $obj[$foo] = ... */\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\n\t\tindex = spl_offset_convert_to_long(zindex);\n\n\t\tif (index < 0 || index >= intern->llist->count) {\n\n>>> [ INFILL ] <<<\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\n\t\tif (element != NULL) {\n\t\t\t/* call dtor on the old element as in spl_ptr_llist_pop */\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\n\t\t\t/* the element is replaced, delref the old one as in\n\t\t\t * SplDoublyLinkedList::pop() */\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\n\t\t\t/* new element, call ctor as in spl_ptr_llist_push */\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} /* }}} */\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\tzval_ptr_dtor(value);\n\n```\n\n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 7.0.6-dev ZEND_VERSION: 3.0.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5 More .INIs : CWD : /out/php___php-src/git_repo_dir_28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. FAIL Bug #71735 (Double-free in SplDoublyLinkedList::offsetSet) [ext/spl/tests/bug71735.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #71735 (Double-free in SplDoublyLinkedList::offsetSet) [ext/spl/tests/bug71735.phpt] =====================================================================\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5___spl_dllist.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic int exif_process_IFD_in_TIFF(image_info_type *ImageInfo, size_t dir_offset, int section_index TSRMLS_DC)\n{\n\tint i, sn, num_entries, sub_section_index = 0;\n\tunsigned char *dir_entry;\n\tchar tagname[64];\n\tsize_t ifd_size, dir_size, entry_offset, next_offset, entry_length, entry_value=0, fgot;\n\tint entry_tag , entry_type;\n\ttag_table_type tag_table = exif_get_tag_table(section_index);\n\n\tif (ImageInfo->ifd_nesting_level > MAX_IFD_NESTING_LEVEL) {\n                return FALSE;\n        }\n\n\tif (ImageInfo->FileSize >= dir_offset+2) {\n\t\tsn = exif_file_sections_add(ImageInfo, M_PSEUDO, 2, NULL);\n#ifdef EXIF_DEBUG\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: filesize(x%04X), IFD dir(x%04X + x%04X)\", ImageInfo->FileSize, dir_offset, 2);\n#endif\n\t\tphp_stream_seek(ImageInfo->infile, dir_offset, SEEK_SET); /* we do not know the order of sections */\n\t\tphp_stream_read(ImageInfo->infile, (char*)ImageInfo->file.list[sn].data, 2);\n\t\tnum_entries = php_ifd_get16u(ImageInfo->file.list[sn].data, ImageInfo->motorola_intel);\n\t\tdir_size = 2/*num dir entries*/ +12/*length of entry*/*num_entries +4/* offset to next ifd (points to thumbnail or NULL)*/;\n\t\tif (ImageInfo->FileSize >= dir_offset+dir_size) {\n#ifdef EXIF_DEBUG\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: filesize(x%04X), IFD dir(x%04X + x%04X), IFD entries(%d)\", ImageInfo->FileSize, dir_offset+2, dir_size-2, num_entries);\n#endif\n\t\t\tif (exif_file_sections_realloc(ImageInfo, sn, dir_size TSRMLS_CC)) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tphp_stream_read(ImageInfo->infile, (char*)(ImageInfo->file.list[sn].data+2), dir_size-2);\n\t\t\t/*exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Dump: %s\", exif_char_dump(ImageInfo->file.list[sn].data, dir_size, 0));*/\n\t\t\tnext_offset = php_ifd_get32u(ImageInfo->file.list[sn].data + dir_size - 4, ImageInfo->motorola_intel);\n#ifdef EXIF_DEBUG\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF done, next offset x%04X\", next_offset);\n#endif\n\t\t\t/* now we have the directory we can look how long it should be */\n\t\t\tifd_size = dir_size;\n\t\t\tfor(i=0;i<num_entries;i++) {\n\t\t\t\tdir_entry \t = ImageInfo->file.list[sn].data+2+i*12;\n\t\t\t\tentry_tag    = php_ifd_get16u(dir_entry+0, ImageInfo->motorola_intel);\n\t\t\t\tentry_type   = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);\n\t\t\t\tif (entry_type > NUM_FORMATS) {\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: tag(0x%04X,%12s): Illegal format code 0x%04X, switching to BYTE\", entry_tag, exif_get_tagname(entry_tag, tagname, -12, tag_table TSRMLS_CC), entry_type);\n\t\t\t\t\t/* Since this is repeated in exif_process_IFD_TAG make it a notice here */\n\t\t\t\t\t/* and make it a warning in the exif_process_IFD_TAG which is called    */\n\t\t\t\t\t/* elsewhere. */\n\t\t\t\t\tentry_type = TAG_FMT_BYTE;\n\t\t\t\t\t/*The next line would break the image on writeback: */\n\t\t\t\t\t/* php_ifd_set16u(dir_entry+2, entry_type, ImageInfo->motorola_intel);*/\n\t\t\t\t}\n\t\t\t\tentry_length = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel) * php_tiff_bytes_per_format[entry_type];\n\t\t\t\tif (entry_length <= 4) {\n\t\t\t\t\tswitch(entry_type) {\n\t\t\t\t\t\tcase TAG_FMT_USHORT:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get16u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_FMT_SSHORT:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get16s(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_FMT_ULONG:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_FMT_SLONG:\n\t\t\t\t\t\t\tentry_value  = php_ifd_get32s(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tswitch(entry_tag) {\n\t\t\t\t\t\tcase TAG_IMAGEWIDTH:\n\t\t\t\t\t\tcase TAG_COMP_IMAGE_WIDTH:\n\t\t\t\t\t\t\tImageInfo->Width  = entry_value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_IMAGEHEIGHT:\n\t\t\t\t\t\tcase TAG_COMP_IMAGE_HEIGHT:\n\t\t\t\t\t\t\tImageInfo->Height = entry_value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase TAG_PHOTOMETRIC_INTERPRETATION:\n\t\t\t\t\t\t\tswitch (entry_value) {\n\t\t\t\t\t\t\t\tcase PMI_BLACK_IS_ZERO:\n\t\t\t\t\t\t\t\tcase PMI_WHITE_IS_ZERO:\n\t\t\t\t\t\t\t\tcase PMI_TRANSPARENCY_MASK:\n\t\t\t\t\t\t\t\t\tImageInfo->IsColor = 0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase PMI_RGB:\n\t\t\t\t\t\t\t\tcase PMI_PALETTE_COLOR:\n\t\t\t\t\t\t\t\tcase PMI_SEPARATED:\n\t\t\t\t\t\t\t\tcase PMI_YCBCR:\n\t\t\t\t\t\t\t\tcase PMI_CIELAB:\n\t\t\t\t\t\t\t\t\tImageInfo->IsColor = 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tentry_offset = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n\t\t\t\t\t/* if entry needs expading ifd cache and entry is at end of current ifd cache. */\n\t\t\t\t\t/* otherwise there may be huge holes between two entries */\n\t\t\t\t\tif (entry_offset + entry_length > dir_offset + ifd_size\n\t\t\t\t\t  && entry_offset == dir_offset + ifd_size) {\n\t\t\t\t\t\tifd_size = entry_offset + entry_length - dir_offset;\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Resize struct: x%04X + x%04X - x%04X = x%04X\", entry_offset, entry_length, dir_offset, ifd_size);\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ImageInfo->FileSize >= dir_offset + ImageInfo->file.list[sn].size) {\n\t\t\t\tif (ifd_size > dir_size) {\n\t\t\t\t\tif (dir_offset + ifd_size > ImageInfo->FileSize) {\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than size of IFD(x%04X + x%04X)\", ImageInfo->FileSize, dir_offset, ifd_size);\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t\tif (exif_file_sections_realloc(ImageInfo, sn, ifd_size TSRMLS_CC)) {\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t\t\t/* read values not stored in directory itself */\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF: filesize(x%04X), IFD(x%04X + x%04X)\", ImageInfo->FileSize, dir_offset, ifd_size);\n#endif\n\t\t\t\t\tphp_stream_read(ImageInfo->infile, (char*)(ImageInfo->file.list[sn].data+dir_size), ifd_size-dir_size);\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read from TIFF, done\");\n#endif\n\t\t\t\t}\n\t\t\t\t/* now process the tags */\n\t\t\t\tfor(i=0;i<num_entries;i++) {\n\t\t\t\t\tdir_entry \t = ImageInfo->file.list[sn].data+2+i*12;\n\t\t\t\t\tentry_tag    = php_ifd_get16u(dir_entry+0, ImageInfo->motorola_intel);\n\t\t\t\t\tentry_type   = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);\n\t\t\t\t\t/*entry_length = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel);*/\n\t\t\t\t\tif (entry_tag == TAG_EXIF_IFD_POINTER ||\n\t\t\t\t\t\tentry_tag == TAG_INTEROP_IFD_POINTER ||\n\t\t\t\t\t\tentry_tag == TAG_GPS_IFD_POINTER ||\n\t\t\t\t\t\tentry_tag == TAG_SUB_IFD\n\t\t\t\t\t) {\n\t\t\t\t\t\tswitch(entry_tag) {\n\t\t\t\t\t\t\tcase TAG_EXIF_IFD_POINTER:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_EXIF;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_EXIF;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TAG_GPS_IFD_POINTER:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_GPS;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_GPS;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TAG_INTEROP_IFD_POINTER:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_INTEROP;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_INTEROP;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TAG_SUB_IFD:\n\t\t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_THUMBNAIL;\n\t\t\t\t\t\t\t\tsub_section_index = SECTION_THUMBNAIL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tentry_offset = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Next IFD: %s @x%04X\", exif_get_sectionname(sub_section_index), entry_offset);\n#endif\n\t\t\t\t\t\tImageInfo->ifd_nesting_level++;\n\t\t\t\t\t\texif_process_IFD_in_TIFF(ImageInfo, entry_offset, sub_section_index TSRMLS_CC);\n\t\t\t\t\t\tif (section_index!=SECTION_THUMBNAIL && entry_tag==TAG_SUB_IFD) {\n\t\t\t\t\t\t\tif (ImageInfo->Thumbnail.filetype != IMAGE_FILETYPE_UNKNOWN\n\t\t\t\t\t\t\t&&  ImageInfo->Thumbnail.size\n\t\t\t\t\t\t\t&&  ImageInfo->Thumbnail.offset\n\t\t\t\t\t\t\t&&  ImageInfo->read_thumbnail\n\t\t\t\t\t\t\t) {\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"%s THUMBNAIL @0x%04X + 0x%04X\", ImageInfo->Thumbnail.data ? \"Ignore\" : \"Read\", ImageInfo->Thumbnail.offset, ImageInfo->Thumbnail.size);\n#endif\n\t\t\t\t\t\t\t\tif (!ImageInfo->Thumbnail.data) {\n\t\t\t\t\t\t\t\t\tImageInfo->Thumbnail.data = safe_emalloc(ImageInfo->Thumbnail.size, 1, 0);\n\t\t\t\t\t\t\t\t\tphp_stream_seek(ImageInfo->infile, ImageInfo->Thumbnail.offset, SEEK_SET);\n\t\t\t\t\t\t\t\t\tfgot = php_stream_read(ImageInfo->infile, ImageInfo->Thumbnail.data, ImageInfo->Thumbnail.size);\n\t\t\t\t\t\t\t\t\tif (fgot < ImageInfo->Thumbnail.size) {\n\t\t\t\t\t\t\t\t\t\tEXIF_ERRLOG_THUMBEOF(ImageInfo)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\texif_thumbnail_build(ImageInfo TSRMLS_CC);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n#ifdef EXIF_DEBUG\n\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Next IFD: %s done\", exif_get_sectionname(sub_section_index));\n#endif\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!exif_process_IFD_TAG(ImageInfo, (char*)dir_entry,\n\t\t\t\t\t\t\t\t\t\t\t\t  (char*)(ImageInfo->file.list[sn].data-dir_offset),\n\t\t\t\t\t\t\t\t\t\t\t\t  ifd_size, 0, section_index, 0, tag_table TSRMLS_CC)) {\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* If we had a thumbnail in a SUB_IFD we have ANOTHER image in NEXT IFD */\n\t\t\t\tif (next_offset && section_index != SECTION_THUMBNAIL) {\n\t\t\t\t\t/* this should be a thumbnail IFD */\n\t\t\t\t\t/* the thumbnail itself is stored at Tag=StripOffsets */\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read next IFD (THUMBNAIL) at x%04X\", next_offset);\n#endif\n\t\t\t\t\tImageInfo->ifd_nesting_level++;\n\t\t\t\t\texif_process_IFD_in_TIFF(ImageInfo, next_offset, SECTION_THUMBNAIL TSRMLS_CC);\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"%s THUMBNAIL @0x%04X + 0x%04X\", ImageInfo->Thumbnail.data ? \"Ignore\" : \"Read\", ImageInfo->Thumbnail.offset, ImageInfo->Thumbnail.size);\n#endif\n\t\t\t\t\tif (!ImageInfo->Thumbnail.data && ImageInfo->Thumbnail.offset && ImageInfo->Thumbnail.size && ImageInfo->read_thumbnail) {\n\t\t\t\t\t\tImageInfo->Thumbnail.data = safe_emalloc(ImageInfo->Thumbnail.size, 1, 0);\n\t\t\t\t\t\tphp_stream_seek(ImageInfo->infile, ImageInfo->Thumbnail.offset, SEEK_SET);\n\t\t\t\t\t\tfgot = php_stream_read(ImageInfo->infile, ImageInfo->Thumbnail.data, ImageInfo->Thumbnail.size);\n\t\t\t\t\t\tif (fgot < ImageInfo->Thumbnail.size) {\n\t\t\t\t\t\t\tEXIF_ERRLOG_THUMBEOF(ImageInfo)\n\t\t\t\t\t\t}\n\n>>> [ INFILL ] <<<\n\t\t\t\t\t}\n#ifdef EXIF_DEBUG\n\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Read next IFD (THUMBNAIL) done\");\n#endif\n\t\t\t\t}\n\t\t\t\treturn TRUE;\n\t\t\t} else {\n\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than size of IFD(x%04X)\", ImageInfo->FileSize, dir_offset+ImageInfo->file.list[sn].size);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than size of IFD dir(x%04X)\", ImageInfo->FileSize, dir_offset+dir_size);\n\t\t\treturn FALSE;\n\t\t}\n\t} else {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Error in TIFF: filesize(x%04X) less than start of IFD dir(x%04X)\", ImageInfo->FileSize, dir_offset+2);\n\t\treturn FALSE;\n\t}\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\t\t\t\texif_thumbnail_build(ImageInfo TSRMLS_CC);\n\n```\n\n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.26-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_6dbb1ee46b5f4725cc6519abf91e512a2a10dfed More .INIs : CWD : /out/php___php-src/git_repo_dir_6dbb1ee46b5f4725cc6519abf91e512a2a10dfed Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/exif/tests/bug72627.phpt]\rFAIL Bug #72627 (Memory Leakage In exif_process_IFD_in_TIFF) [ext/exif/tests/bug72627.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 1 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72627 (Memory Leakage In exif_process_IFD_in_TIFF) [ext/exif/tests/bug72627.phpt] =====================================================================\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "6dbb1ee46b5f4725cc6519abf91e512a2a10dfed___exif.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\n>>> [ INFILL ] <<<\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n\n```\n\n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.27-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_b88393f08a558eec14964a55d3c680fe67407712 More .INIs : CWD : /out/php___php-src/git_repo_dir_b88393f08a558eec14964a55d3c680fe67407712 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/wddx/tests/bug72860.phpt]\r \r===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 0 ( 0.0%) ( 0.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 1 (100.0%) (100.0%) --------------------------------------------------------------------- Time taken : 0 seconds =====================================================================\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "b88393f08a558eec14964a55d3c680fe67407712___wddx.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit = -1, rightLimit;\n\tint i, restoreAlphaBlending = 0;\n\n\n>>> [ INFILL ] <<<\n\t\t/* Refuse to fill to a non-solid border */\n\t\treturn;\n\t}\n\n\tif (!im->trueColor) {\n\t\tif ((color > (im->colorsTotal - 1)) || (border > (im->colorsTotal - 1)) || (color < 0)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\trestoreAlphaBlending = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\n\tfor (i = x; i >= 0; i--) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == -1) {\n\t\tim->alphaBlendingFlag = restoreAlphaBlending;\n\t\treturn;\n\t}\n\t/* Seek right */\n\trightLimit = x;\n\tfor (i = (x + 1); i < im->sx; i++) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\trightLimit = i;\n\t}\n\t/* Look at lines above and below and start paints */\n\t/* Above */\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Below */\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y + 1);\n\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBlending;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\tif (border < 0) {\n\n```\n\n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.28-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_863d37ea66d5c960db08d6f4a2cbd2518f0f80d1 More .INIs : CWD : /out/php___php-src/git_repo_dir_863d37ea66d5c960db08d6f4a2cbd2518f0f80d1 Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/gd/tests/bug72696.phpt]\rFAIL Bug #72696 (imagefilltoborder stackoverflow on truecolor images) [ext/gd/tests/bug72696.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #72696 (imagefilltoborder stackoverflow on truecolor images) [ext/gd/tests/bug72696.phpt] =====================================================================\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "863d37ea66d5c960db08d6f4a2cbd2518f0f80d1___gd.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\n>>> [ INFILL ] <<<\n\t\t\t}\n\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\n\t\t/* Not sure if this is correct (never seen float used in Exif format) */\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n\n```\n\n\n\nwith the following test error: ===================================================================== PHP : sapi/cli/php PHP_SAPI : cli PHP_VERSION : 5.6.30-dev ZEND_VERSION: 2.6.0 PHP_OS : Linux - Linux deef54515472 4.15.0-220-generic #231-Ubuntu SMP Fri Nov 10 20:32:58 UTC 2023 x86_64 INI actual : /out/php___php-src/git_repo_dir_1cda0d7c2ffb62d8331c64e703131d9cabdc03ea More .INIs : CWD : /out/php___php-src/git_repo_dir_1cda0d7c2ffb62d8331c64e703131d9cabdc03ea Extra dirs : VALGRIND : Not used ===================================================================== Running selected tests. TEST 1/1 [ext/exif/tests/bug73737.phpt]\rFAIL Bug #73737 (Crash when parsing a tag format) [ext/exif/tests/bug73737.phpt] ===================================================================== Number of tests : 1 1 Tests skipped : 0 ( 0.0%) -------- Tests warned : 0 ( 0.0%) ( 0.0%) Tests failed : 1 (100.0%) (100.0%) Expected fail : 0 ( 0.0%) ( 0.0%) Tests passed : 0 ( 0.0%) ( 0.0%) --------------------------------------------------------------------- Time taken : 0 seconds ===================================================================== ===================================================================== FAILED TEST SUMMARY --------------------------------------------------------------------- Bug #73737 (Crash when parsing a tag format) [ext/exif/tests/bug73737.phpt] =====================================================================\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "1cda0d7c2ffb62d8331c64e703131d9cabdc03ea___exif.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic njs_int_t\nnjs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n\n    trail = 0;\n    length = info->name.length;\n\n    if (dir != NULL) {\n\n>>> [ INFILL ] <<<\n\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n\n        trail = (dir->start[dir->length - 1] != '/');\n\n        if (trail) {\n            length++;\n        }\n    }\n\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n\n    p = &src[0];\n\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n\n\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n\n    return NJS_OK;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        length = dir->length;\n\n```\n\n\n\nwith the following test error: =================================================================\n==34629==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7f1114001021 at pc 0x555b8d071436 bp 0x7ffcad5d4af0 sp 0x7ffcad5d42b8\nWRITE of size 4097 at 0x7f1114001021 thread T0\n    #0 0x555b8d071435 in __asan_memcpy /src/llvm-project/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:22:3\n    #1 0x555b8d135ab1 in njs_module_path /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_module.c:148:18\n    #2 0x555b8d135ab1 in njs_module_lookup /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_module.c:83:11\n    #3 0x555b8d135ab1 in njs_default_module_loader /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_module.c:377:11\n    #4 0x555b8d135119 in njs_parser_module /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_module.c:56:14\n    #5 0x555b8d172465 in njs_parser_import /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_parser.c:7793:24\n    #6 0x555b8d146bd1 in njs_parser /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_parser.c:598:23\n    #7 0x555b8d0c10fd in njs_vm_compile /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_vm.c:159:11\n    #8 0x555b8d0af293 in njs_process_script /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_shell.c:886:11\n    #9 0x555b8d0ae6a5 in njs_process_file /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_shell.c:619:11\n    #10 0x555b8d0ae6a5 in main /out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/src/njs_shell.c:303:15\n    #11 0x7f111602b082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #12 0x555b8cfd9abd in _start (/out/nginx___njs/git_repo_dir_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/build_ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1/njs+0x55abd)\n\nAddress 0x7f1114001021 is located in stack of th \nPlease provide the correct line following commit message at the infill location."}], "idx": "ab1702c7af9959366a5ddc4a75b4357d4e9ebdc1___njs_module.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic njs_int_t\nnjs_array_prototype_sort(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t                i, und, len, nlen, length;\n    njs_int_t              ret, fast_path;\n    njs_array_t            *array;\n    njs_value_t            *this, *comparefn, *start, *strings;\n    njs_array_sort_ctx_t   ctx;\n    njs_array_sort_slot_t  *p, *end, *slots, *nslots;\n\n    comparefn = njs_arg(args, nargs, 1);\n\n    if (njs_is_defined(comparefn)) {\n        if (njs_slow_path(!njs_is_function(comparefn))) {\n            njs_type_error(vm, \"comparefn must be callable or undefined\");\n            return NJS_ERROR;\n        }\n\n        ctx.function = njs_function(comparefn);\n\n    } else {\n        ctx.function = NULL;\n    }\n\n    this = njs_argument(args, 0);\n\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_value_length(vm, this, &length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    if (njs_slow_path(length < 2)) {\n        vm->retval = *this;\n        return NJS_OK;\n    }\n\n    slots = NULL;\n    ctx.vm = vm;\n    ctx.strings.separate = 0;\n    ctx.strings.pointer = 0;\n    ctx.exception = 0;\n\n    fast_path = njs_is_fast_array(this);\n\n    if (njs_fast_path(fast_path)) {\n        array = njs_array(this);\n        start = array->start;\n\n        slots = njs_mp_alloc(vm->mem_pool,\n                             sizeof(njs_array_sort_slot_t) * length);\n        if (njs_slow_path(slots == NULL)) {\n                return NJS_ERROR;\n        }\n\n        und = 0;\n        p = slots;\n\n        for (i = 0; i < length; i++) {\n            if (njs_slow_path(!njs_is_valid(&start[i]))) {\n                fast_path = 0;\n                njs_mp_free(vm->mem_pool, slots);\n                slots = NULL;\n                goto slow_path;\n            }\n\n            if (njs_slow_path(njs_is_undefined(&start[i]))) {\n                und++;\n                continue;\n            }\n\n            p->value = start[i];\n            p->pos = i;\n            p->str = NULL;\n            p++;\n        }\n\n        len = p - slots;\n\n    } else {\n\nslow_path:\n\n        und = 0;\n        p = NULL;\n        end = NULL;\n\n        for (i = 0; i < length; i++) {\n            if (p >= end) {\n                nlen = njs_min(njs_max((p - slots) * 2, 8), length);\n                nslots = njs_mp_alloc(vm->mem_pool,\n                                      sizeof(njs_array_sort_slot_t) * nlen);\n                if (njs_slow_path(nslots == NULL)) {\n                    njs_memory_error(vm);\n                    return NJS_ERROR;\n                }\n\n                if (slots != NULL) {\n                    p = (void *) njs_cpymem(nslots, slots,\n                                  sizeof(njs_array_sort_slot_t) * (p - slots));\n                    njs_mp_free(vm->mem_pool, slots);\n\n                } else {\n                    p = nslots;\n                }\n\n                slots = nslots;\n                end = slots + nlen;\n            }\n\n            ret = njs_value_property_i64(vm, this, i, &p->value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                ret = NJS_ERROR;\n                goto exception;\n            }\n\n            if (ret == NJS_DECLINED) {\n                continue;\n            }\n\n            if (njs_is_undefined(&p->value)) {\n                und++;\n                continue;\n            }\n\n            p->pos = i;\n            p->str = NULL;\n            p++;\n        }\n\n        len = p - slots;\n    }\n\n    strings = njs_arr_init(vm->mem_pool, &ctx.strings, NULL, len + 1,\n                           sizeof(njs_value_t));\n    if (njs_slow_path(strings == NULL)) {\n        ret = NJS_ERROR;\n        goto exception;\n    }\n\n    njs_qsort(slots, len, sizeof(njs_array_sort_slot_t), njs_array_compare,\n              &ctx);\n\n    if (ctx.exception) {\n        ret = NJS_ERROR;\n        goto exception;\n    }\n\n\n>>> [ INFILL ] <<<\n        array = njs_array(this);\n        start = array->start;\n\n        for (i = 0; i < len; i++) {\n            start[i] = slots[i].value;\n        }\n\n        for (i = len; und-- > 0; i++) {\n            start[i] = njs_value_undefined;\n        }\n\n    } else {\n        for (i = 0; i < len; i++) {\n            if (slots[i].pos != i) {\n                ret = njs_value_property_i64_set(vm, this, i, &slots[i].value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    goto exception;\n                }\n            }\n        }\n\n        for (i = len; und-- > 0; i++) {\n            ret = njs_value_property_i64_set(vm, this, i,\n                                          njs_value_arg(&njs_value_undefined));\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                goto exception;\n            }\n        }\n\n        for (; i < length; i++) {\n            ret = njs_value_property_i64_delete(vm, this, i, NULL);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                goto exception;\n            }\n        }\n    }\n\n    vm->retval = *this;\n\n    ret = NJS_OK;\n\nexception:\n\n    if (slots != NULL) {\n        njs_mp_free(vm->mem_pool, slots);\n    }\n\n    njs_arr_destroy(&ctx.strings);\n\n    return ret;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    if (njs_fast_path(fast_path)) {\n\n```\n\n\n\nwith the following test error: AddressSanitizer:DEADLYSIGNAL\n=================================================================\n==37996==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x7f3998c1eaf3 bp 0x7ffed53854f0 sp 0x7ffed5384ca8 T0)\n==37996==The signal is caused by a WRITE memory access.\n==37996==Hint: address points to the zero page.\n    #0 0x7f3998c1eaf3 in memcpy /build/glibc-wuryBv/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:144\n    #1 0x55da5fde01a3 in __asan_memcpy /src/llvm-project/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:22:3\n    #2 0x55da5fe7e39f in njs_array_prototype_sort /out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/src/njs_array.c:2704:33\n    #3 0x55da5fe92031 in njs_function_native_call /out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/src/njs_function.c:739:11\n    #4 0x55da5fe3f2cf in njs_vmcode_interpreter /out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/src/njs_vmcode.c:810:23\n    #5 0x55da5fe37caa in njs_vm_start /out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/src/njs_vm.c:553:11\n    #6 0x55da5fe1efb0 in njs_process_test /out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/src/test/njs_unit_test.c:21966:15\n    #7 0x55da5fe1efb0 in njs_unit_test /out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/src/test/njs_unit_test.c:22118:23\n    #8 0x55da5fe1e261 in main /out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/src/test/njs_unit_test.c:23608:15\n    #9 0x7f3998b87082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n    #10 0x55da5fd48acd in _start (/out/nginx___njs/git_repo_dir_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/build_8b39afdad9a0761e0a5d4af1a762bd9a6daef572/njs_unit_test+0x11eacd)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV /build/glibc-wuryBv/glibc-2.31/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:144 in memcpy\n== \nPlease provide the correct line following commit message at the infill location."}], "idx": "8b39afdad9a0761e0a5d4af1a762bd9a6daef572___njs_array.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid APar_ExtractDetails(FILE *isofile, uint8_t optional_output) {\n\n>>> [ INFILL ] <<<\n  Trackage track = {0};\n\n  AtomicInfo *mvhdAtom = APar_FindAtom(\"moov.mvhd\", false, VERSIONED_ATOM, 0);\n  if (mvhdAtom != NULL) {\n    APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom);\n    fprintf(stdout,\n            \"Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate \"\n            \"(*=approximate)\\n\",\n            movie_info.seconds,\n            secsTOtime(movie_info.seconds),\n            movie_info.simple_bitrate_calc);\n    if (optional_output & SHOW_DATE_INFO) {\n      fprintf(stdout,\n              \"  Presentation Creation Date (UTC):     %s\\n\",\n              APar_extract_UTC(movie_info.creation_time));\n      fprintf(stdout,\n              \"  Presentation Modification Date (UTC): %s\\n\",\n              APar_extract_UTC(movie_info.modified_time));\n    }\n  }\n\n  AtomicInfo *iodsAtom = APar_FindAtom(\"moov.iods\", false, VERSIONED_ATOM, 0);\n  if (iodsAtom != NULL) {\n    movie_info.contains_iods = true;\n    APar_Extract_iods_Info(isofile, iodsAtom);\n  }\n\n  if (optional_output & SHOW_TRACK_INFO) {\n    APar_TrackLevelInfo(&track,\n                        NULL); // With track_num set to 0, it will return the\n                               // total trak atom into total_tracks here.\n\n    fprintf(\n        stdout, \"Low-level details. Total tracks: %u\\n\", track.total_tracks);\n    fprintf(stdout,\n            \"Trk  Type  Handler                    Kind  Lang  Bytes\\n\");\n\n    if (track.total_tracks > 0) {\n      while (track.total_tracks > track.track_num) {\n        track.track_num += 1;\n        TrackInfo track_info = {0};\n\n        // tracknum, handler type, handler name\n        APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info);\n        uint16_t more_whitespace =\n            purge_extraneous_characters(track_info.track_hdlr_name);\n\n        if (strlen(track_info.track_hdlr_name) == 0) {\n          memcpy(track_info.track_hdlr_name, \"[none listed]\", 13);\n        }\n        fprintf(stdout,\n                \"%u    %s  %s\",\n                track.track_num,\n                uint32tochar4(track_info.track_type, uint32_buffer),\n                track_info.track_hdlr_name);\n\n        uint16_t handler_len = strlen(track_info.track_hdlr_name);\n        if (handler_len < 25 + more_whitespace) {\n          for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) {\n            fprintf(stdout, \" \");\n          }\n        }\n\n        // codec, language\n        fprintf(stdout,\n                \"  %s  %s   %\" PRIu64,\n                uint32tochar4(track_info.track_codec, uint32_buffer),\n                track_info.unpacked_lang,\n                track_info.sample_aggregate);\n\n        if (track_info.encoder_name[0] != 0 && track_info.contains_esds) {\n          purge_extraneous_characters(track_info.encoder_name);\n          fprintf(stdout, \"   Encoder: %s\", track_info.encoder_name);\n        }\n        if (track_info.type_of_track & DRM_PROTECTED_TRACK) {\n          fprintf(stdout,\n                  \" (protected %s)\",\n                  uint32tochar4(track_info.protected_codec, uint32_buffer));\n        }\n\n        fprintf(stdout, \"\\n\");\n        /*---------------------------------*/\n\n        if (track_info.type_of_track & VIDEO_TRACK ||\n            track_info.type_of_track & AUDIO_TRACK) {\n          APar_Print_TrackDetails(&track_info);\n        }\n\n        if (optional_output & SHOW_DATE_INFO) {\n          fprintf(stdout,\n                  \"       Creation Date (UTC):     %s\\n\",\n                  APar_extract_UTC(track_info.creation_time));\n          fprintf(stdout,\n                  \"       Modification Date (UTC): %s\\n\",\n                  APar_extract_UTC(track_info.modified_time));\n        }\n      }\n    }\n  }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  char uint32_buffer[5];\n\n```\n\n\n\nwith the following test error: ==36043==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7f637ec00225 at pc 0x55b16f893bc1 bp 0x7fff8a8c0340 sp 0x7fff8a8bfb10\nWRITE of size 8 at 0x7f637ec00225 thread T0\n    #0 0x55b16f893bc0 in __interceptor_fread /src/llvm-project/compiler-rt/lib/asan/../sanitizer_common/sanitizer_common_interceptors.inc:1091:16\n    #1 0x55b16f9a63ec in APar_read64(char*, _IO_FILE*, unsigned long) /out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/src/util.cpp:299:10\n    #2 0x55b16f952652 in APar_ExtractTrackDetails(char*, _IO_FILE*, Trackage*, TrackInfo*) /out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/src/extracts.cpp:1247:9\n    #3 0x55b16f954f00 in APar_ExtractDetails(_IO_FILE*, unsigned char) /out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/src/extracts.cpp:1635:9\n    #4 0x55b16f96e236 in real_main(int, char**) /out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/src/main.cpp\n    #5 0x7f6380f70082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: eebe5d5f4b608b8a53ec446b63981bba373ca0ca)\n    #6 0x55b16f87656d in _start (/out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/build_d72ccf06c98259d7261e0f3ac4fd8717778782c1/AtomicParsley+0x5f56d)\n\nAddress 0x7f637ec00225 is located in stack of thread T0 at offset 37 in frame\n    #0 0x55b16f954a9f in APar_ExtractDetails(_IO_FILE*, unsigned char) /out/wez___atomicparsley/git_repo_dir_d72ccf06c98259d7261e0f3ac4fd8717778782c1/src/extracts.cpp:1590\n\n  This frame has 3 object(s):\n    [32, 37) 'uint32_buffer' (line 1591) <== Memory access at offset 37 overflows this variable\n    [64, 68) 'track' (line 1592)\n    [80, 416) 'track_info' (line 1632)\nHINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n      (longjmp and C++ exceptions *are* supported)\nSUMMARY: AddressSanitizer: stack-buffer-overflow /src/llvm-project/compiler-rt/lib/asan/../sanitizer_common/ \nPlease provide the correct line following commit message at the infill location."}], "idx": "d72ccf06c98259d7261e0f3ac4fd8717778782c1___extracts.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic const char* jvp_literal_number_literal(jv n) {\n  assert(JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL));\n  decNumber *pdec = jvp_dec_number_ptr(n);\n  jvp_literal_number* plit = jvp_literal_number_ptr(n);\n\n  if (decNumberIsNaN(pdec)) {\n    return \"null\";\n  }\n\n  if (decNumberIsInfinite(pdec)) {\n    // We cannot preserve the literal data of numbers outside the limited\n    // range of exponent. Since `decNumberToString` returns \"Infinity\"\n    // (or \"-Infinity\"), and to reduce stack allocations as possible, we\n    // normalize infinities in the callers instead of printing the maximum\n    // (or minimum) double here.\n    return NULL;\n  }\n\n  if (plit->literal_data == NULL) {\n\n>>> [ INFILL ] <<<\n    plit->literal_data = jv_mem_alloc(len);\n\n    // Preserve the actual precision as we have parsed it\n    // don't do decNumberTrim(pdec);\n\n    decNumberToString(pdec, plit->literal_data);\n  }\n\n  return plit->literal_data;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    int len = jvp_dec_number_ptr(n)->digits + 14;\n\n```\n\n\n\nwith the following test error: + . ./setup\n+ [ -n  ]\n+ set -eu\n+ dirname ./xtest.sh\n+ cd .\n+ pwd\n+ JQTESTDIR=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests\n+ JQBASEDIR=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/..\n+ JQ=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/../jq\n+ [ -z  ]\n+ which valgrind\n+ VALGRIND=valgrind --error-exitcode=1 --leak-check=full                        --suppressions=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/onig.supp                        --suppressions=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/local.supp\n+ VG_EXIT0=--error-exitcode=0\n+ Q=-q\n+ mods=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/modules\n+ clean=true\n+ d=\n+ trap clean EXIT\n+ mktemp -d -t jqXXXXXX\n+ d=/tmp/jq0tafW2\n+ [ -z /tmp/jq0tafW2 ]\n+ msys=false\n+ mingw=false\n+ uname -s\n+ JQ_NO_B=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/../jq\n+ JQ=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/../jq -b\n+ valgrind --error-exitcode=1 --leak-check=full --suppressions=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/onig.supp --suppressions=/out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/local.supp -q /out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/tests/../jq -b .\n==49532== Invalid write of size 1\n==49532==    at 0x130E25: decToString (in /out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/jq)\n==49532==    by 0x1306DA: decNumberToString (in /out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/jq)\n==49532==    by 0x11BDCA: jv_number_get_literal (in /out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/jq)\n==49532==    by 0x12C8FD: jv_dump_term.30 (in /out/jqlang___jq/git_repo_dir_71c2ab509a8628dbbad4bc7b3f98a64aa90d3297/jq)\n==49532==    by 0x11473F: process (in /out/jqlang___jq/git_ \nPlease provide the correct line following commit message at the infill location."}], "idx": "71c2ab509a8628dbbad4bc7b3f98a64aa90d3297___jv.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n    current_element = object->child;\n    if (case_sensitive)\n    {\n\n>>> [ INFILL ] <<<\n        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n\n    return current_element;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n\n```\n\n\n\nwith the following test error: /out/DaveGamble___cJSON/git_repo_dir_be749d7efa7c9021da746e685bd6dec79f9dd99b/tests/../cJSON.c:1784:59: runtime error: null pointer passed as argument 2, which is declared to never be null\n/usr/include/string.h:138:33: note: nonnull attribute specified here\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /out/DaveGamble___cJSON/git_repo_dir_be749d7efa7c9021da746e685bd6dec79f9dd99b/tests/../cJSON.c:1784:59 in \n \nPlease provide the correct line following commit message at the infill location."}], "idx": "be749d7efa7c9021da746e685bd6dec79f9dd99b___cJSON.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nint yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n\n  int i;\n  int count;\n\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n\n  array = object_as_array(object);\n\n  if (array->items == NULL)\n  {\n\n>>> [ INFILL ] <<<\n\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n\n    array->items->count = count;\n  }\n\n  item->parent = object;\n  array->items->objects[index] = item;\n\n  return ERROR_SUCCESS;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    count = yr_max(64, (index + 1) * 2);\n\n```\n\n\n\nwith the following test error: FAIL: test-rules\n================\n\ntests/test-rules.c:1403: rule does not match (but should)\n\n=================================================================\n==63499==ERROR: LeakSanitizer: detected memory leaks\n\nDirect leak of 40 byte(s) in 1 object(s) allocated from:\n    #0 0x55be3b6b1bae in malloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:69:3\n    #1 0x55be3b709a90 in yr_object_create /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/object.c:90:22\n    #2 0x55be3b70c356 in yr_object_array_get_item /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/object.c:701:5\n    #3 0x55be3b70c356 in _yr_object_lookup /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/object.c:510:17\n    #4 0x55be3b70b0b6 in yr_object_set_integer /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/object.c:985:19\n    #5 0x55be3b72e5d0 in tests__load /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/modules/tests.c:179:3\n    #6 0x55be3b7624e2 in yr_execute_code /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/exec.c:847:18\n    #7 0x55be3b7269ac in yr_rules_scan_mem_blocks /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/rules.c:472:3\n    #8 0x55be3b72788b in yr_rules_scan_mem /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/libyara/rules.c:586:10\n    #9 0x55be3b6f7e5b in matches_blob /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/tests/util.c:122:21\n    #10 0x55be3b6f416d in test_modules /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/tests/test-rules.c:1377:3\n    #11 0x55be3b6f416d in main /out/VirusTotal___yara/git_repo_dir_4a342f01e5439b9bb901aff1c6c23c536baeeb3f/tests/test-rules.c:1699:3\n    #12 0x7f953fff9082 in __libc_start_main /build/glibc-wuryBv/glibc-2.31/csu/../csu/libc-start.c:308:16\n\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "4a342f01e5439b9bb901aff1c6c23c536baeeb3f___object.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic void compile_xclass_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\njump_list *found = NULL;\njump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks;\nsljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin;\nint compares, invertcmp, numberofcmps;\n#if defined SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\nBOOL utf = common->utf;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH == [8|16] */\n\n#ifdef SUPPORT_UNICODE\nsljit_u32 unicode_status = 0;\nint typereg = TMP1;\nconst sljit_u32 *other_cases;\nsljit_uw typeoffset;\n#endif /* SUPPORT_UNICODE */\n\n/* Scanning the necessary info. */\ncc++;\nccbegin = cc;\ncompares = 0;\n\nif (cc[-1] & XCL_MAP)\n  {\n  min = 0;\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\nwhile (*cc != XCL_END)\n  {\n  compares++;\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n    if (c < min) min = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c < min) min = c;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    cc++;\n\n>>> [ INFILL ] <<<\n      {\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n      while (*other_cases != NOTACHAR)\n        {\n        if (*other_cases > max) max = *other_cases;\n        if (*other_cases < min) min = *other_cases;\n        other_cases++;\n        }\n      }\n    else\n      {\n      max = READ_CHAR_MAX;\n      min = 0;\n      }\n\n    switch(*cc)\n      {\n      case PT_ANY:\n      /* Any either accepts everything or ignored. */\n      if (cc[-1] == XCL_PROP)\n        {\n        compile_char1_matchingpath(common, OP_ALLANY, cc, backtracks, FALSE);\n        if (list == backtracks)\n          add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n        return;\n        }\n      break;\n\n      case PT_LAMP:\n      case PT_GC:\n      case PT_PC:\n      case PT_ALNUM:\n      unicode_status |= XCLASS_HAS_TYPE;\n      break;\n\n      case PT_SCX:\n      unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;\n      if (cc[-1] == XCL_NOTPROP)\n        {\n        unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;\n        break;\n        }\n      compares++;\n      /* Fall through */ \n\n      case PT_SC:\n      unicode_status |= XCLASS_HAS_SCRIPT;\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      case PT_WORD:\n      case PT_PXGRAPH:\n      case PT_PXPRINT:\n      case PT_PXPUNCT:\n      unicode_status |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;\n      break;\n\n      case PT_CLIST:\n      case PT_UCNC:\n      unicode_status |= XCLASS_SAVE_CHAR;\n      break;\n\n      case PT_BOOL:\n      unicode_status |= XCLASS_HAS_BOOL;\n      break;\n\n      case PT_BIDICL:\n      unicode_status |= XCLASS_HAS_BIDICL;\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n  }\nSLJIT_ASSERT(compares > 0);\n\n/* We are not necessary in utf mode even in 8 bit mode. */\ncc = ccbegin;\nif ((cc[-1] & XCL_NOT) != 0)\n  read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\nelse\n  {\n#ifdef SUPPORT_UNICODE\n  read_char(common, min, max, (unicode_status & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0);\n#else /* !SUPPORT_UNICODE */\n  read_char(common, min, max, NULL, 0);\n#endif /* SUPPORT_UNICODE */\n  }\n\nif ((cc[-1] & XCL_HASPROP) == 0)\n  {\n  if ((cc[-1] & XCL_MAP) != 0)\n    {\n    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n    if (!optimize_class(common, (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))\n      {\n      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n      OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n      OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n      add_jump(compiler, &found, JUMP(SLJIT_NOT_ZERO));\n      }\n\n    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n    JUMPHERE(jump);\n\n    cc += 32 / sizeof(PCRE2_UCHAR);\n    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n    add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER, TMP2, 0, SLJIT_IMM, max - min));\n    }\n  }\nelse if ((cc[-1] & XCL_MAP) != 0)\n  {\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n#ifdef SUPPORT_UNICODE\n  unicode_status |= XCLASS_CHAR_SAVED;\n#endif /* SUPPORT_UNICODE */\n  if (!optimize_class(common, (const sljit_u8 *)cc, FALSE, TRUE, list))\n    {\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    jump = NULL;\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n\n    OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n    OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n    add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n\n#if PCRE2_CODE_UNIT_WIDTH == 8\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      JUMPHERE(jump);\n    }\n\n  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n  cc += 32 / sizeof(PCRE2_UCHAR);\n  }\n\n#ifdef SUPPORT_UNICODE\nif (unicode_status & XCLASS_NEEDS_UCD)\n  {\n  if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH == 32\n  if (!common->utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM, MAX_UTF_CODE_POINT + 1);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n    JUMPHERE(jump);\n    }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n  OP2(SLJIT_LSHR, TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1, 0, TMP2, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n  OP2(SLJIT_SHL, TMP1, 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  ccbegin = cc;\n\n  if (unicode_status & XCLASS_HAS_BIDICL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BIDICL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n          jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);\n          add_jump(compiler, compares > 0 ? list : backtracks, jump);\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_BOOL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, bprops));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BOOL)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT)\n    {\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        switch (*cc)\n          {\n          case PT_SCX:\n          if (cc[-1] == XCL_NOTPROP)\n            break;\n          /* Fall through */ \n\n          case PT_SC:\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));\n          }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)\n      {\n      if (unicode_status & XCLASS_HAS_TYPE)\n        {\n        if (unicode_status & XCLASS_SAVE_CHAR)\n          {\n          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP), LOCALS0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;\n          }\n        else\n          {\n          OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;\n          }\n        }\n      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, script));\n      }\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_SCX)\n          {\n          compares--;\n          invertcmp = (compares == 0 && list != backtracks);\n\n          jump = NULL;\n          if (cc[-1] == XCL_NOTPROP)\n            {\n            jump = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);\n            if (invertcmp)\n              {\n              add_jump(compiler, backtracks, jump);\n              jump = NULL;\n              }\n            invertcmp ^= 0x1;\n            }\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets) + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler, compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n\n          if (jump != NULL)\n            JUMPHERE(jump);\n          }\n        cc += 2;\n        }\n      }\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)\n      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n    else if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)\n      OP1(SLJIT_MOV, TMP2, 0, RETURN_ADDR, 0);\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_SAVE_CHAR)\n    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n\n  if (unicode_status & XCLASS_HAS_TYPE)\n    {\n    if (unicode_status & XCLASS_SAVE_CHAR)\n      typereg = RETURN_ADDR;\n\n    OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, chartype));\n    }\n  }\n#endif /* SUPPORT_UNICODE */\n\n/* Generating code. */\ncharoffset = 0;\nnumberofcmps = 0;\n#ifdef SUPPORT_UNICODE\ntypeoffset = 0;\n#endif /* SUPPORT_UNICODE */\n\nwhile (*cc != XCL_END)\n  {\n  compares--;\n  invertcmp = (compares == 0 && list != backtracks);\n  jump = NULL;\n\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n  else if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    SET_CHAR_OFFSET(c);\n    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n#ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    if (*cc == XCL_NOTPROP)\n      invertcmp ^= 0x1;\n    cc++;\n    switch(*cc)\n      {\n      case PT_ANY:\n      if (!invertcmp)\n        jump = JUMP(SLJIT_JUMP);\n      break;\n\n      case PT_LAMP:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lu - typeoffset);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_GC:\n      c = PRIV(ucp_typerange)[(int)cc[1] * 2];\n      SET_TYPE_OFFSET(c);\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);\n      break;\n\n      case PT_PC:\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM, (int)cc[1] - typeoffset);\n      break;\n\n      case PT_SC:\n      case PT_SCX:\n      case PT_BOOL:\n      case PT_BIDICL:\n      compares++;\n      /* Do nothing. */\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      SET_CHAR_OFFSET(9);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Zl);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Zl);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_WORD:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      /* Fall through. */\n\n      case PT_ALNUM:\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n      OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_TYPE_OFFSET(ucp_Nd);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_CLIST:\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n\n      /* At least three characters are required.\n         Otherwise this case would be handled by the normal code path. */\n      SLJIT_ASSERT(other_cases[0] != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);\n      SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);\n\n      /* Optimizing character pairs, if their difference is power of 2. */\n      if (is_powerof2(other_cases[1] ^ other_cases[0]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        other_cases += 2;\n        }\n      else if (is_powerof2(other_cases[2] ^ other_cases[1]))\n        {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[2] ^ other_cases[1]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));\n        OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n\n        other_cases += 3;\n        }\n      else\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        }\n\n      while (*other_cases != NOTACHAR)\n        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n        OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2, 0, SLJIT_EQUAL);\n        }\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_UCNC:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_CHAR_OFFSET(0xa0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1, 0, SLJIT_IMM, 0xe000 - 0);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_GREATER_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_PXGRAPH:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPRINT:\n      /* C and Z groups are the farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_GREATER);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Zs - ucp_Ll);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPUNCT:\n      SET_TYPE_OFFSET(ucp_Sc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x7f);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Pc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n\n  if (jump != NULL)\n    add_jump(compiler, compares > 0 ? list : backtracks, jump);\n  }\n\nif (found != NULL)\n  set_jumps(found, LABEL());\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    if (*cc == PT_CLIST)\n\n```\n\n\n\nwith the following test error: Running JIT regression tests\n  target CPU of SLJIT compiler: x86 64bit (little endian + unaligned)\n  in  8 bit mode with UTF-8  enabled:\n............................................................\n............................................................\n............................................................\n...................................................... \nPlease provide the correct line following commit message at the infill location."}], "idx": "50a51cb7e67268e6ad417eb07c9de9bfea5cc55a___pcre2_jit_compile.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nLY_ERR\nlyd_value_store(const struct ly_ctx *ctx, struct lyd_value *val, const struct lysc_type *type, const void *value,\n        size_t value_len, ly_bool *dynamic, LY_VALUE_FORMAT format, void *prefix_data, uint32_t hints,\n        const struct lysc_node *ctx_node, ly_bool *incomplete)\n{\n    LY_ERR ret;\n    struct ly_err_item *err = NULL;\n    uint32_t options = (dynamic && *dynamic ? LYPLG_TYPE_STORE_DYNAMIC : 0);\n\n    if (!value) {\n        value = \"\";\n    }\n    if (incomplete) {\n        *incomplete = 0;\n    }\n\n    ret = type->plugin->store(ctx, type, value, value_len, options, format, prefix_data, hints, ctx_node, val, NULL, &err);\n    if (dynamic) {\n        *dynamic = 0;\n    }\n\n    if (ret == LY_EINCOMPLETE) {\n        if (incomplete) {\n            *incomplete = 1;\n        }\n    } else if (ret) {\n        if (err) {\n            LOGVAL_ERRITEM(ctx, err);\n            ly_err_free(err);\n        } else {\n\n>>> [ INFILL ] <<<\n        }\n        return ret;\n    }\n\n    return LY_SUCCESS;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n            LOGVAL(ctx, LYVE_OTHER, \"Storing value \\\"%.*s\\\" failed.\", (int)value_len, value);\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_509d721c2b61088c1e491c330c48b0cc01dc191e/build_509d721c2b61088c1e491c330c48b0cc01dc191e\nTest project /out/CESNET___libyang/git_repo_dir_509d721c2b61088c1e491c330c48b0cc01dc191e/build_509d721c2b61088c1e491c330c48b0cc01dc191e\n    Start 13: utest_yang_types\n1/1 Test #13: utest_yang_types .................***Failed    0.03 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.04 sec\n\nThe following tests FAILED:\n\t 13 - utest_yang_types (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "509d721c2b61088c1e491c330c48b0cc01dc191e___tree_data.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nLY_ERR\nlys_compile_augment(struct lysc_ctx *ctx, struct lysp_augment *aug_p, const struct lysc_node *parent)\n{\n    LY_ERR ret = LY_SUCCESS;\n    struct lysp_node *node_p, *case_node_p;\n    struct lysc_node *target; /* target target of the augment */\n    struct lysc_node *node;\n    struct lysc_when **when, *when_shared;\n    int allow_mandatory = 0;\n    uint16_t flags = 0;\n    unsigned int u;\n    int opt_prev = ctx->options;\n\n    lysc_update_path(ctx, NULL, \"{augment}\");\n    lysc_update_path(ctx, NULL, aug_p->nodeid);\n\n    ret = lys_resolve_schema_nodeid(ctx, aug_p->nodeid, 0, parent, parent ? parent->module : ctx->mod_def,\n                                               LYS_CONTAINER | LYS_LIST | LYS_CHOICE | LYS_CASE | LYS_INOUT | LYS_NOTIF,\n                                               1, (const struct lysc_node**)&target, &flags);\n    if (ret != LY_SUCCESS) {\n        if (ret == LY_EDENIED) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Augment's %s-schema-nodeid \\\"%s\\\" refers to a %s node which is not an allowed augment's target.\",\n                   parent ? \"descendant\" : \"absolute\", aug_p->nodeid, lys_nodetype2str(target->nodetype));\n        }\n        return LY_EVALID;\n    }\n\n    /* check for mandatory nodes\n     * - new cases augmenting some choice can have mandatory nodes\n     * - mandatory nodes are allowed only in case the augmentation is made conditional with a when statement\n     */\n    if (aug_p->when || target->nodetype == LYS_CHOICE || ctx->mod == target->module) {\n        allow_mandatory = 1;\n    }\n\n    when_shared = NULL;\n    LY_LIST_FOR(aug_p->child, node_p) {\n        /* check if the subnode can be connected to the found target (e.g. case cannot be inserted into container) */\n        if (!(target->nodetype == LYS_CHOICE && node_p->nodetype == LYS_CASE)\n                && !((target->nodetype & (LYS_CONTAINER | LYS_LIST)) && (node_p->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF)))\n                && !(target->nodetype != LYS_CHOICE && node_p->nodetype == LYS_USES)\n                && !(node_p->nodetype & (LYS_ANYDATA | LYS_CONTAINER | LYS_CHOICE | LYS_LEAF | LYS_LIST | LYS_LEAFLIST))) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid augment of %s node which is not allowed to contain %s node \\\"%s\\\".\",\n                   lys_nodetype2str(target->nodetype), lys_nodetype2str(node_p->nodetype), node_p->name);\n            return LY_EVALID;\n        }\n\n        /* compile the children */\n        ctx->options |= flags;\n        if (node_p->nodetype != LYS_CASE) {\n            LY_CHECK_RET(lys_compile_node(ctx, node_p, target, 0));\n        } else {\n            LY_LIST_FOR(((struct lysp_node_case *)node_p)->child, case_node_p) {\n                LY_CHECK_RET(lys_compile_node(ctx, case_node_p, target, 0));\n            }\n        }\n        ctx->options = opt_prev;\n\n        /* since the augment node is not present in the compiled tree, we need to pass some of its statements to all its children,\n         * here we gets the last created node as last children of our parent */\n        if (target->nodetype == LYS_CASE) {\n            /* the compiled node is the last child of the target (but it is a case, so we have to be careful and stop) */\n            for (node = (struct lysc_node*)lysc_node_children(target, flags); node->next && node->next->parent == node->parent; node = node->next);\n        } else if (target->nodetype == LYS_CHOICE) {\n            /* to pass when statement, we need the last case no matter if it is explicit or implicit case */\n            node = ((struct lysc_node_choice*)target)->cases->prev;\n        } else {\n            /* the compiled node is the last child of the target */\n\n>>> [ INFILL ] <<<\n        }\n\n        if (!allow_mandatory && (node->flags & LYS_CONFIG_W) && (node->flags & LYS_MAND_TRUE)) {\n            node->flags &= ~LYS_MAND_TRUE;\n            lys_compile_mandatory_parents(target, 0);\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_SEMANTICS,\n                   \"Invalid augment adding mandatory node \\\"%s\\\" without making it conditional via when statement.\", node->name);\n            return LY_EVALID;\n        }\n\n        /* pass augment's when to all the children */\n        if (aug_p->when) {\n            LY_ARRAY_NEW_GOTO(ctx->ctx, node->when, when, ret, error);\n            if (!when_shared) {\n                ret = lys_compile_when(ctx, aug_p->when, aug_p->flags, target, when);\n                LY_CHECK_GOTO(ret, error);\n\n                if (!(ctx->options & LYSC_OPT_GROUPING)) {\n                    /* do not check \"when\" semantics in a grouping */\n                    ly_set_add(&ctx->unres, node, 0);\n                }\n\n                when_shared = *when;\n            } else {\n                ++when_shared->refcount;\n                (*when) = when_shared;\n\n                if (!(ctx->options & LYSC_OPT_GROUPING)) {\n                    /* in this case check \"when\" again for all children because of dummy node check */\n                    ly_set_add(&ctx->unres, node, 0);\n                }\n            }\n        }\n    }\n\n    ctx->options |= flags;\n    switch (target->nodetype) {\n    case LYS_CONTAINER:\n        COMPILE_ARRAY1_GOTO(ctx, aug_p->actions, ((struct lysc_node_container*)target)->actions, target,\n                            u, lys_compile_action, 0, ret, error);\n        COMPILE_ARRAY1_GOTO(ctx, aug_p->notifs, ((struct lysc_node_container*)target)->notifs, target,\n                            u, lys_compile_notif, 0, ret, error);\n        break;\n    case LYS_LIST:\n        COMPILE_ARRAY1_GOTO(ctx, aug_p->actions, ((struct lysc_node_list*)target)->actions, target,\n                            u, lys_compile_action, 0, ret, error);\n        COMPILE_ARRAY1_GOTO(ctx, aug_p->notifs, ((struct lysc_node_list*)target)->notifs, target,\n                            u, lys_compile_notif, 0, ret, error);\n        break;\n    default:\n        ctx->options = opt_prev;\n        if (aug_p->actions) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid augment of %s node which is not allowed to contain RPC/action node \\\"%s\\\".\",\n                   lys_nodetype2str(target->nodetype), aug_p->actions[0].name);\n            return LY_EVALID;\n        }\n        if (aug_p->notifs) {\n            LOGVAL(ctx->ctx, LY_VLOG_STR, ctx->path, LYVE_REFERENCE,\n                   \"Invalid augment of %s node which is not allowed to contain notification node \\\"%s\\\".\",\n                   lys_nodetype2str(target->nodetype), aug_p->notifs[0].name);\n            return LY_EVALID;\n        }\n    }\n\n    lysc_update_path(ctx, NULL, NULL);\n    lysc_update_path(ctx, NULL, NULL);\nerror:\n    ctx->options = opt_prev;\n    return ret;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n            node = lysc_node_children(target, flags)->prev;\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_7c7783df75b9a5dfc6cc22c70b9467d47aa913d2/build_7c7783df75b9a5dfc6cc22c70b9467d47aa913d2\nTest project /out/CESNET___libyang/git_repo_dir_7c7783df75b9a5dfc6cc22c70b9467d47aa913d2/build_7c7783df75b9a5dfc6cc22c70b9467d47aa913d2\n    Start 9: src_tree_schema_compile\n1/1 Test #9: src_tree_schema_compile ..........***Failed    0.12 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.13 sec\n\nThe following tests FAILED:\n\t  9 - src_tree_schema_compile (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "7c7783df75b9a5dfc6cc22c70b9467d47aa913d2___tree_schema_compile.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid\nly_vlog_build_path_reverse(enum LY_VLOG_ELEM elem_type, const void *elem, char *path, uint16_t *index)\n{\n    int i, j;\n    struct lys_node_list *slist;\n    struct lys_node *sparent = NULL;\n    struct lyd_node *dlist, *diter;\n    const struct lys_module *top_smodule = NULL;\n    const char *name, *prefix = NULL, *val_end, *val_start;\n    char *str;\n    size_t len;\n\n    while (elem) {\n        switch (elem_type) {\n        case LY_VLOG_XML:\n            name = ((struct lyxml_elem *)elem)->name;\n            prefix = ((struct lyxml_elem *)elem)->ns ? ((struct lyxml_elem *)elem)->ns->prefix : NULL;\n            elem = ((struct lyxml_elem *)elem)->parent;\n            break;\n        case LY_VLOG_LYS:\n            if (!top_smodule) {\n                /* remember the top module, it will act as the current module */\n                top_smodule = lys_node_module((struct lys_node *)elem);\n            }\n\n            if (((struct lys_node *)elem)->nodetype & (LYS_AUGMENT | LYS_GROUPING)) {\n                --(*index);\n                path[*index] = ']';\n\n                name = ((struct lys_node *)elem)->name;\n                len = strlen(name);\n                (*index) -= len;\n                memcpy(&path[*index], name, len);\n\n                if (((struct lys_node *)elem)->nodetype == LYS_GROUPING) {\n                    name = \"{grouping}[\";\n                } else { /* augment */\n                    name = \"{augment}[\";\n                }\n            } else if (((struct lys_node *)elem)->nodetype == LYS_EXT) {\n                name = ((struct lys_ext_instance *)elem)->def->name;\n            } else {\n                name = ((struct lys_node *)elem)->name;\n            }\n\n\n>>> [ INFILL ] <<<\n                prefix = lys_node_module((struct lys_node *)elem)->name;\n            } else {\n                prefix = NULL;\n            }\n            if (((struct lys_node *)elem)->nodetype == LYS_EXT) {\n                if (((struct lys_ext_instance*)elem)->parent_type == LYEXT_PAR_NODE) {\n                    elem = (struct lys_node*)((struct lys_ext_instance*)elem)->parent;\n                } else {\n                    sparent = NULL;\n                    elem = NULL;\n                }\n                break;\n            }\n\n            /* need to find the parent again because we don't want to skip augments */\n            do {\n                sparent = ((struct lys_node *)elem)->parent;\n                elem = lys_parent((struct lys_node *)elem);\n            } while (elem && (((struct lys_node *)elem)->nodetype == LYS_USES));\n            break;\n        case LY_VLOG_LYD:\n            name = ((struct lyd_node *)elem)->schema->name;\n            if (!((struct lyd_node *)elem)->parent ||\n                    lyd_node_module((struct lyd_node *)elem) != lyd_node_module(((struct lyd_node *)elem)->parent)) {\n                prefix = lyd_node_module((struct lyd_node *)elem)->name;\n            } else {\n                prefix = NULL;\n            }\n\n            /* handle predicates (keys) in case of lists */\n            if (((struct lyd_node *)elem)->schema->nodetype == LYS_LIST) {\n                dlist = (struct lyd_node *)elem;\n                slist = (struct lys_node_list *)((struct lyd_node *)elem)->schema;\n                if (slist->keys_size) {\n                    /* schema list with keys - use key values in predicates */\n                    for (i = slist->keys_size - 1; i > -1; i--) {\n                        LY_TREE_FOR(dlist->child, diter) {\n                            if (diter->schema == (struct lys_node *)slist->keys[i]) {\n                                break;\n                            }\n                        }\n                        if (diter && ((struct lyd_node_leaf_list *)diter)->value_str) {\n                            if (strchr(((struct lyd_node_leaf_list *)diter)->value_str, '\\'')) {\n                                val_start = \"=\\\"\";\n                                val_end = \"\\\"]\";\n                            } else {\n                                val_start = \"='\";\n                                val_end = \"']\";\n                            }\n\n                            (*index) -= 2;\n                            memcpy(&path[(*index)], val_end, 2);\n                            len = strlen(((struct lyd_node_leaf_list *)diter)->value_str);\n                            (*index) -= len;\n                            memcpy(&path[(*index)], ((struct lyd_node_leaf_list *)diter)->value_str, len);\n                            (*index) -= 2;\n                            memcpy(&path[(*index)], val_start, 2);\n                            len = strlen(diter->schema->name);\n                            (*index) -= len;\n                            memcpy(&path[(*index)], diter->schema->name, len);\n                            if (lyd_node_module(dlist) != lyd_node_module(diter)) {\n                                path[--(*index)] = ':';\n                                len = strlen(lyd_node_module(diter)->name);\n                                (*index) -= len;\n                                memcpy(&path[(*index)], lyd_node_module(diter)->name, len);\n                            }\n                            path[--(*index)] = '[';\n                        }\n                    }\n                } else {\n                    /* schema list without keys - use instance position */\n                    path[--(*index)] = ']';\n\n                    i = j = lyd_list_pos(dlist);\n                    len = 1;\n                    while (j > 9) {\n                        ++len;\n                        j /= 10;\n                    }\n\n                    str = malloc(len + 1);\n                    LY_CHECK_ERR_RETURN(!str, LOGMEM, );\n                    sprintf(str, \"%d\", i);\n\n                    (*index) -= len;\n                    strncpy(&path[(*index)], str, len);\n\n                    free(str);\n\n                    --(*index);\n                    path[*index] = '[';\n                }\n            } else if (((struct lyd_node *)elem)->schema->nodetype == LYS_LEAFLIST &&\n                    ((struct lyd_node_leaf_list *)elem)->value_str) {\n                if (strchr(((struct lyd_node_leaf_list *)elem)->value_str, '\\'')) {\n                    val_start = \"[.=\\\"\";\n                    val_end = \"\\\"]\";\n                } else {\n                    val_start = \"[.='\";\n                    val_end = \"']\";\n                }\n\n                (*index) -= 2;\n                memcpy(&path[(*index)], val_end, 2);\n                len = strlen(((struct lyd_node_leaf_list *)elem)->value_str);\n                (*index) -= len;\n                memcpy(&path[(*index)], ((struct lyd_node_leaf_list *)elem)->value_str, len);\n                (*index) -= 4;\n                memcpy(&path[(*index)], val_start, 4);\n            }\n\n            elem = ((struct lyd_node *)elem)->parent;\n            break;\n        case LY_VLOG_STR:\n            len = strlen((const char *)elem) + 1;\n            if (len > LY_BUF_SIZE) {\n                len = LY_BUF_SIZE - 1;\n            }\n            (*index) = LY_BUF_SIZE - len;\n            memcpy(&path[(*index)], (const char *)elem, len - 1);\n            return;\n        default:\n            /* shouldn't be here */\n            LOGINT;\n            return;\n        }\n        if (name) {\n            len = strlen(name);\n            (*index) -= len;\n            memcpy(&path[*index], name, len);\n            if (prefix) {\n                path[--(*index)] = ':';\n                len = strlen(prefix);\n                (*index) = (*index) - len;\n                memcpy(&path[(*index)], prefix, len);\n            }\n        }\n        path[--(*index)] = '/';\n        if (elem_type == LY_VLOG_LYS && !elem && sparent && sparent->nodetype == LYS_AUGMENT) {\n            len = strlen(((struct lys_node_augment *)sparent)->target_name);\n            (*index) = (*index) - len;\n            memcpy(&path[(*index)], ((struct lys_node_augment *)sparent)->target_name, len);\n        }\n    }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n            if (lys_node_module((struct lys_node *)elem) != top_smodule) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_cdcace7230352a25eb21a488e7f42d004b3de3e1/build_cdcace7230352a25eb21a488e7f42d004b3de3e1\nTest project /out/CESNET___libyang/git_repo_dir_cdcace7230352a25eb21a488e7f42d004b3de3e1/build_cdcace7230352a25eb21a488e7f42d004b3de3e1\n    Start 2: test_tree_schema\n1/1 Test #2: test_tree_schema .................***Failed    0.12 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.13 sec\n\nThe following tests FAILED:\n\t  2 - test_tree_schema (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "cdcace7230352a25eb21a488e7f42d004b3de3e1___log.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic LY_ERR\nlyjson_number(struct lyjson_ctx *jsonctx)\n{\n    size_t offset = 0, exponent = 0;\n    const char *in = jsonctx->in->current;\n    uint8_t minus = 0;\n\n    if (in[offset] == '-') {\n        ++offset;\n        minus = 1;\n    }\n\n    if (in[offset] == '0') {\n        ++offset;\n    } else if (isdigit(in[offset])) {\n        ++offset;\n        while (isdigit(in[offset])) {\n            ++offset;\n        }\n    } else {\ninvalid_character:\n        if (in[offset]) {\n            LOGVAL(jsonctx->ctx, LYVE_SYNTAX, \"Invalid character in JSON Number value (\\\"%c\\\").\", in[offset]);\n        } else {\n            LOGVAL(jsonctx->ctx, LY_VCODE_EOF);\n        }\n        return LY_EVALID;\n    }\n\n    if (in[offset] == '.') {\n        ++offset;\n        if (!isdigit(in[offset])) {\n            goto invalid_character;\n        }\n        while (isdigit(in[offset])) {\n            ++offset;\n        }\n    }\n\n    if ((in[offset] == 'e') || (in[offset] == 'E')) {\n        exponent = offset++;\n        if ((in[offset] == '+') || (in[offset] == '-')) {\n            ++offset;\n        }\n        if (!isdigit(in[offset])) {\n            goto invalid_character;\n        }\n        while (isdigit(in[offset])) {\n            ++offset;\n        }\n    }\n\n    if (exponent) {\n        /* convert JSON number with exponent into the representation used by YANG */\n        long int  e_val;\n        char *ptr, *dec_point, *num;\n        const char *e_ptr = &in[exponent + 1];\n        size_t num_len, i;\n        int64_t dp_position; /* final position of the deciaml point */\n\n        errno = 0;\n        e_val = strtol(e_ptr, &ptr, LY_BASE_DEC);\n        if (errno) {\n            LOGVAL(jsonctx->ctx, LYVE_SEMANTICS, \"Exponent out-of-bounds in a JSON Number value (%.*s).\",\n                    (int)(offset - minus - (e_ptr - in)), e_ptr);\n            return LY_EVALID;\n        }\n\n        if (!e_val) {\n            /* exponent is zero, so just cut the part with the exponent */\n            num_len = exponent;\n            LY_CHECK_RET(lyjson_get_buffer_for_number(jsonctx, num_len, &num));\n            memcpy(num, in, num_len);\n            num[num_len] = '\\0';\n            goto store_exp_number;\n        }\n\n        dec_point = ly_strnchr(in, '.', exponent);\n        if (!dec_point) {\n            /* value is integer, we are just ... */\n            if (e_val >= 0) {\n                /* adding zeros at the end */\n                num_len = exponent + e_val;\n                dp_position = num_len; /* decimal point is behind the actual value */\n\n>>> [ INFILL ] <<<\n                /* adding decimal point between the integer's digits */\n                num_len = exponent + 1;\n                dp_position = exponent + e_val;\n            } else {\n                /* adding decimal point before the integer with adding leading zero(s) */\n                num_len = labs(e_val) + 2 + minus;\n                dp_position = exponent + e_val;\n            }\n            dp_position -= minus;\n        } else {\n            /* value is decimal, we are moving the decimal point */\n            dp_position = dec_point - in + e_val - minus;\n            if (dp_position > (ssize_t)exponent) {\n                /* moving decimal point after the decimal value make the integer result */\n                num_len = dp_position;\n            } else if (dp_position < 0) {\n                /* moving decimal point before the decimal value requires additional zero(s)\n                 * (decimal point is already count in exponent value) */\n                num_len = exponent + labs(dp_position) + 1;\n            } else if (dp_position == 0) {\n                /* moving the decimal point exactly to the beginning will cause a zero character to be added. */\n                num_len = exponent + 1;\n            } else {\n                /* moving decimal point just inside the decimal value does not make any change in length */\n                num_len = exponent;\n            }\n        }\n\n        LY_CHECK_RET(lyjson_get_buffer_for_number(jsonctx, num_len, &num));\n\n        /* compose the resulting vlaue */\n        i = 0;\n        if (minus) {\n            num[i++] = '-';\n        }\n        /* add leading zeros */\n        if (dp_position <= 0) {\n            num[i++] = '0';\n            num[i++] = '.';\n            for ( ; dp_position; dp_position++) {\n                num[i++] = '0';\n            }\n        }\n        /* copy the value */\n        ly_bool dp_placed;\n        size_t j;\n        for (dp_placed = dp_position ? 0 : 1, j = minus; j < exponent; j++) {\n            if (in[j] == '.') {\n                continue;\n            }\n            if (!dp_placed) {\n                if (!dp_position) {\n                    num[i++] = '.';\n                    dp_placed = 1;\n                } else {\n                    dp_position--;\n                    if (in[j] == '0') {\n                        num_len--;\n                        continue;\n                    }\n                }\n            }\n\n            num[i++] = in[j];\n        }\n        /* trailing zeros */\n        while (dp_position--) {\n            num[i++] = '0';\n        }\n        /* terminating NULL byte */\n        num[i] = '\\0';\n\nstore_exp_number:\n        /* store the modified number */\n        lyjson_ctx_set_value(jsonctx, num, num_len, 1);\n    } else {\n        /* store the number */\n        lyjson_ctx_set_value(jsonctx, jsonctx->in->current, offset, 0);\n    }\n    ly_in_skip(jsonctx->in, offset);\n\n    JSON_PUSH_STATUS_RET(jsonctx, LYJSON_NUMBER);\n    LY_CHECK_RET(lyjson_check_next(jsonctx));\n\n    return LY_SUCCESS;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n            } else if ((size_t)labs(e_val) < exponent) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_350a6bf69e03d19fe996cba992b49556ae2ce8ab/build_350a6bf69e03d19fe996cba992b49556ae2ce8ab\nTest project /out/CESNET___libyang/git_repo_dir_350a6bf69e03d19fe996cba992b49556ae2ce8ab/build_350a6bf69e03d19fe996cba992b49556ae2ce8ab\n    Start 18: utest_json\n1/1 Test #18: utest_json .......................***Failed    0.03 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.03 sec\n\nThe following tests FAILED:\n\t 18 - utest_json (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "350a6bf69e03d19fe996cba992b49556ae2ce8ab___json.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic enum lyxp_node_type\nlyxp_get_root_type(const struct lyd_node *ctx_node, const struct lysc_node *ctx_scnode, uint32_t options)\n{\n    const struct lysc_node *op;\n\n    if (options & LYXP_SCNODE_ALL) {\n        /* schema */\n        for (op = ctx_scnode; op && !(op->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF)); op = op->parent) {}\n\n        if (op || (options & LYXP_SCNODE)) {\n            /* general root that can access everything */\n            return LYXP_NODE_ROOT;\n        } else if (!ctx_scnode || (ctx_scnode->flags & LYS_CONFIG_W)) {\n            /* root context node can access only config data (because we said so, it is unspecified) */\n            return LYXP_NODE_ROOT_CONFIG;\n        }\n        return LYXP_NODE_ROOT;\n    }\n\n    /* data */\n    op = ctx_node ? ctx_node->schema : NULL;\n    for ( ; op && !(op->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF)); op = op->parent) {}\n\n    if (op || !(options & LYXP_SCHEMA)) {\n        /* general root that can access everything */\n        return LYXP_NODE_ROOT;\n\n>>> [ INFILL ] <<<\n        /* root context node can access only config data (because we said so, it is unspecified) */\n        return LYXP_NODE_ROOT_CONFIG;\n    }\n    return LYXP_NODE_ROOT;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    } else if (!ctx_node || (ctx_node->schema->flags & LYS_CONFIG_W)) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_b6ecaeaa0391745ec9054cc4351ac4049317576c/build_b6ecaeaa0391745ec9054cc4351ac4049317576c\nTest project /out/CESNET___libyang/git_repo_dir_b6ecaeaa0391745ec9054cc4351ac4049317576c/build_b6ecaeaa0391745ec9054cc4351ac4049317576c\n    Start 25: utest_validation\n1/1 Test #25: utest_validation .................***Failed    0.12 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.12 sec\n\nThe following tests FAILED:\n\t 25 - utest_validation (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "b6ecaeaa0391745ec9054cc4351ac4049317576c___xpath.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic LY_ERR\nmoveto_axis_scnode_next(const struct lysc_node **iter, enum lyxp_node_type *iter_type, const struct lys_module **iter_mod,\n        uint32_t *iter_mod_idx, const struct lysc_node *scnode, enum lyxp_node_type node_type, enum lyxp_axis axis,\n        struct lyxp_set *set, uint32_t getnext_opts)\n{\n    const struct lysc_node *next = NULL, *dfs_stop;\n    enum lyxp_node_type next_type = 0;\n\n    if (!*iter_type) {\n        /* first returned node */\n        return moveto_axis_scnode_next_first(iter, iter_type, iter_mod, iter_mod_idx, scnode, node_type, axis, set,\n                getnext_opts);\n    }\n\n    switch (axis) {\n    case LYXP_AXIS_PARENT:\n    case LYXP_AXIS_SELF:\n        /* parent/self was returned before */\n        break;\n\n    case LYXP_AXIS_ANCESTOR_OR_SELF:\n        if ((*iter == scnode) && (*iter_type == node_type)) {\n            /* fake first ancestor, we returned self before */\n            *iter = NULL;\n            *iter_type = 0;\n            return moveto_axis_scnode_next_first(iter, iter_type, iter_mod, iter_mod_idx, scnode, node_type,\n                    LYXP_AXIS_ANCESTOR, set, getnext_opts);\n        } /* else continue ancestor */\n\n    /* fallthrough */\n    case LYXP_AXIS_ANCESTOR:\n        if (*iter_type == LYXP_NODE_ELEM) {\n            next = lysc_data_parent(*iter);\n            next_type = next ? LYXP_NODE_ELEM : set->root_type;\n        } /* else no ancestor */\n        break;\n\n    case LYXP_AXIS_DESCENDANT_OR_SELF:\n        if ((*iter == scnode) && (*iter_type == node_type)) {\n            /* fake first descendant, we returned self before */\n            *iter = NULL;\n            *iter_type = 0;\n            return moveto_axis_scnode_next_first(iter, iter_type, iter_mod, iter_mod_idx, scnode, node_type,\n                    LYXP_AXIS_DESCENDANT, set, getnext_opts);\n        } /* else DFS until context node */\n        dfs_stop = scnode;\n\n    /* fallthrough */\n    case LYXP_AXIS_DESCENDANT:\n        if (axis == LYXP_AXIS_DESCENDANT) {\n            /* DFS until the context node */\n            dfs_stop = scnode;\n        }\n\n    /* fallthrough */\n    case LYXP_AXIS_PRECEDING:\n        if (axis == LYXP_AXIS_PRECEDING) {\n            /* DFS until the previous sibling */\n            dfs_stop = moveto_axis_scnode_preceding_sibling(scnode, getnext_opts);\n            assert(dfs_stop);\n\n            if (*iter == dfs_stop) {\n                /* we are done */\n                break;\n            }\n        }\n\n    /* fallthrough */\n    case LYXP_AXIS_FOLLOWING:\n        if (axis == LYXP_AXIS_FOLLOWING) {\n            /* DFS through the whole module */\n            dfs_stop = NULL;\n        }\n\n        /* nested nodes */\n        assert(*iter);\n        next = moveto_axis_scnode_next_dfs_forward(*iter, dfs_stop, getnext_opts);\n        if (next) {\n            next_type = LYXP_NODE_ELEM;\n            break;\n        } /* else get next top-level node just like a child */\n\n    /* fallthrough */\n    case LYXP_AXIS_CHILD:\n    case LYXP_AXIS_FOLLOWING_SIBLING:\n        if (!*iter_mod) {\n            /* nodes from a single module */\n            if ((next = lys_getnext(*iter, lysc_data_parent(*iter), (*iter)->module->compiled, getnext_opts))) {\n                next_type = LYXP_NODE_ELEM;\n                break;\n            }\n\n            assert(scnode);\n\n>>> [ INFILL ] <<<\n                /* iterating over top-level nodes, find next */\n                while (lysc_data_parent(*iter)) {\n                    *iter = lysc_data_parent(*iter);\n                }\n                if ((next = lys_getnext(*iter, NULL, (*iter)->module->compiled, getnext_opts))) {\n                    next_type = LYXP_NODE_ELEM;\n                    break;\n                }\n            }\n        }\n\n        while (*iter_mod) {\n            /* module top-level nodes */\n            if ((next = lys_getnext(*iter, NULL, (*iter_mod)->compiled, getnext_opts))) {\n                next_type = LYXP_NODE_ELEM;\n                break;\n            }\n\n            /* get next module */\n            while ((*iter_mod = ly_ctx_get_module_iter(set->ctx, iter_mod_idx))) {\n                /* module may not be implemented or not compiled yet */\n                if ((*iter_mod)->compiled) {\n                    break;\n                }\n            }\n\n            /* new module, start over */\n            *iter = NULL;\n        }\n        break;\n\n    case LYXP_AXIS_PRECEDING_SIBLING:\n        assert(*iter);\n\n        /* next parent sibling until scnode */\n        next = lys_getnext(*iter, lysc_data_parent(*iter), (*iter)->module->compiled, getnext_opts);\n        if (next == scnode) {\n            /* no previous sibling */\n            next = NULL;\n        }\n        next_type = next ? LYXP_NODE_ELEM : 0;\n        break;\n\n    case LYXP_AXIS_ATTRIBUTE:\n        /* unreachable */\n        assert(0);\n        LOGINT(set->ctx);\n        break;\n    }\n\n    *iter = next;\n    *iter_type = next_type;\n    return next_type ? LY_SUCCESS : LY_ENOTFOUND;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n            if (!lysc_data_parent(scnode)) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_a353cce850560bea761d67a2fbcaf9cb271f586f/build_a353cce850560bea761d67a2fbcaf9cb271f586f\nTest project /out/CESNET___libyang/git_repo_dir_a353cce850560bea761d67a2fbcaf9cb271f586f/build_a353cce850560bea761d67a2fbcaf9cb271f586f\n    Start 34: utest_xpath\n1/1 Test #34: utest_xpath ......................***Failed    0.13 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.13 sec\n\nThe following tests FAILED:\n\t 34 - utest_xpath (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "a353cce850560bea761d67a2fbcaf9cb271f586f___xpath.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic LY_ERR\neval_predicate(const struct lyxp_expr *exp, uint16_t *tok_idx, struct lyxp_set *set, uint32_t options, ly_bool parent_pos_pred)\n{\n    LY_ERR rc;\n    uint16_t orig_exp;\n    uint32_t i, orig_pos, orig_size;\n    int32_t pred_in_ctx;\n\n>>> [ INFILL ] <<<\n    struct lyd_node *orig_parent;\n\n    /* '[' */\n    LOGDBG(LY_LDGXPATH, \"%-27s %s %s[%u]\", __func__, (options & LYXP_SKIP_EXPR ? \"skipped\" : \"parsed\"),\n            lyxp_print_token(exp->tokens[*tok_idx]), exp->tok_pos[*tok_idx]);\n    ++(*tok_idx);\n\n    if (options & LYXP_SKIP_EXPR) {\nonly_parse:\n        rc = eval_expr_select(exp, tok_idx, 0, set, options | LYXP_SKIP_EXPR);\n        LY_CHECK_RET(rc);\n    } else if (set->type == LYXP_SET_NODE_SET) {\n        /* we (possibly) need the set sorted, it can affect the result (if the predicate result is a number) */\n        assert(!set_sort(set));\n\n        /* empty set, nothing to evaluate */\n        if (!set->used) {\n            goto only_parse;\n        }\n\n        orig_exp = *tok_idx;\n        orig_pos = 0;\n        orig_size = set->used;\n        orig_parent = NULL;\n        for (i = 0; i < set->used; ++i) {\n            set_init(&set2, set);\n            set_insert_node(&set2, set->val.nodes[i].node, set->val.nodes[i].pos, set->val.nodes[i].type, 0);\n            /* remember the node context position for position() and context size for last(),\n             * predicates should always be evaluated with respect to the child axis (since we do\n             * not support explicit axes) so we assign positions based on their parents */\n            if (parent_pos_pred && (lyd_parent(set->val.nodes[i].node) != orig_parent)) {\n                orig_parent = lyd_parent(set->val.nodes[i].node);\n                orig_pos = 1;\n            } else {\n                ++orig_pos;\n            }\n\n            set2.ctx_pos = orig_pos;\n            set2.ctx_size = orig_size;\n            *tok_idx = orig_exp;\n\n            rc = eval_expr_select(exp, tok_idx, 0, &set2, options);\n            if (rc != LY_SUCCESS) {\n                lyxp_set_free_content(&set2);\n                return rc;\n            }\n\n            /* number is a position */\n            if (set2.type == LYXP_SET_NUMBER) {\n                if ((long long)set2.val.num == orig_pos) {\n                    set2.val.num = 1;\n                } else {\n                    set2.val.num = 0;\n                }\n            }\n            lyxp_set_cast(&set2, LYXP_SET_BOOLEAN);\n\n            /* predicate satisfied or not? */\n            if (!set2.val.bln) {\n                set_remove_node_none(set, i);\n            }\n        }\n        set_remove_nodes_none(set);\n\n    } else if (set->type == LYXP_SET_SCNODE_SET) {\n        for (i = 0; i < set->used; ++i) {\n            if (set->val.scnodes[i].in_ctx == LYXP_SET_SCNODE_ATOM_CTX) {\n                /* there is a currently-valid node */\n                break;\n            }\n        }\n        /* empty set, nothing to evaluate */\n        if (i == set->used) {\n            goto only_parse;\n        }\n\n        orig_exp = *tok_idx;\n\n        /* set special in_ctx to all the valid snodes */\n        pred_in_ctx = set_scnode_new_in_ctx(set);\n\n        /* use the valid snodes one-by-one */\n        for (i = 0; i < set->used; ++i) {\n            if (set->val.scnodes[i].in_ctx != pred_in_ctx) {\n                continue;\n            }\n            set->val.scnodes[i].in_ctx = LYXP_SET_SCNODE_ATOM_CTX;\n\n            *tok_idx = orig_exp;\n\n            rc = eval_expr_select(exp, tok_idx, 0, set, options);\n            LY_CHECK_RET(rc);\n\n            set->val.scnodes[i].in_ctx = pred_in_ctx;\n        }\n\n        /* restore the state as it was before the predicate */\n        for (i = 0; i < set->used; ++i) {\n            if (set->val.scnodes[i].in_ctx == LYXP_SET_SCNODE_ATOM_CTX) {\n                set->val.scnodes[i].in_ctx = LYXP_SET_SCNODE_ATOM_NODE;\n            } else if (set->val.scnodes[i].in_ctx == pred_in_ctx) {\n                set->val.scnodes[i].in_ctx = LYXP_SET_SCNODE_ATOM_CTX;\n            }\n        }\n\n    } else {\n        set2.type = LYXP_SET_NODE_SET;\n        set_fill_set(&set2, set);\n\n        rc = eval_expr_select(exp, tok_idx, 0, &set2, options);\n        if (rc != LY_SUCCESS) {\n            lyxp_set_free_content(&set2);\n            return rc;\n        }\n\n        lyxp_set_cast(&set2, LYXP_SET_BOOLEAN);\n        if (!set2.val.bln) {\n            lyxp_set_free_content(set);\n        }\n        lyxp_set_free_content(&set2);\n    }\n\n    /* ']' */\n    assert(exp->tokens[*tok_idx] == LYXP_TOKEN_BRACK2);\n    LOGDBG(LY_LDGXPATH, \"%-27s %s %s[%u]\", __func__, (options & LYXP_SKIP_EXPR ? \"skipped\" : \"parsed\"),\n            lyxp_print_token(exp->tokens[*tok_idx]), exp->tok_pos[*tok_idx]);\n    ++(*tok_idx);\n\n    return LY_SUCCESS;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    struct lyxp_set set2;\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_fff4dca0da454cdff4c8fab70b4a62c0674fb862/build_fff4dca0da454cdff4c8fab70b4a62c0674fb862\nTest project /out/CESNET___libyang/git_repo_dir_fff4dca0da454cdff4c8fab70b4a62c0674fb862/build_fff4dca0da454cdff4c8fab70b4a62c0674fb862\n    Start 34: utest_xpath\n1/1 Test #34: utest_xpath ......................***Failed    0.06 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.07 sec\n\nThe following tests FAILED:\n\t 34 - utest_xpath (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "fff4dca0da454cdff4c8fab70b4a62c0674fb862___xpath.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic LY_ERR\nlyd_parse_op_(const struct ly_ctx *ctx, const struct lysc_ext_instance *ext, struct lyd_node *parent,\n        struct ly_in *in, LYD_FORMAT format, enum lyd_type data_type, struct lyd_node **tree, struct lyd_node **op)\n{\n    LY_ERR rc = LY_SUCCESS;\n    struct lyd_ctx *lydctx = NULL;\n    struct ly_set parsed = {0};\n    struct lyd_node *first = NULL, *envp = NULL;\n    uint32_t i, parse_opts, val_opts;\n\n    if (!ctx) {\n        ctx = LYD_CTX(parent);\n    }\n    if (tree) {\n        *tree = NULL;\n    }\n    if (op) {\n        *op = NULL;\n    }\n\n    format = lyd_parse_get_format(in, format);\n\n    /* remember input position */\n    in->func_start = in->current;\n\n    /* check params based on the data type */\n    if ((data_type == LYD_TYPE_RPC_NETCONF) || (data_type == LYD_TYPE_NOTIF_NETCONF)) {\n        LY_CHECK_ARG_RET(ctx, format == LYD_XML, !parent, tree, op, LY_EINVAL);\n    } else if (data_type == LYD_TYPE_REPLY_NETCONF) {\n        LY_CHECK_ARG_RET(ctx, format == LYD_XML, parent, parent->schema->nodetype & (LYS_RPC | LYS_ACTION), tree, !op,\n                LY_EINVAL);\n    }\n\n>>> [ INFILL ] <<<\n    val_opts = 0;\n\n    /* parse the data */\n    switch (format) {\n    case LYD_XML:\n        rc = lyd_parse_xml(ctx, ext, parent, &first, in, parse_opts, val_opts, data_type, &envp, &parsed, NULL, &lydctx);\n        if (rc && envp) {\n            /* special situation when the envelopes were parsed successfully */\n            if (tree) {\n                *tree = envp;\n            }\n            ly_set_erase(&parsed, NULL);\n            return rc;\n        }\n        break;\n    case LYD_JSON:\n        rc = lyd_parse_json(ctx, ext, parent, &first, in, parse_opts, val_opts, data_type, &parsed, NULL, &lydctx);\n        break;\n    case LYD_LYB:\n        rc = lyd_parse_lyb(ctx, ext, parent, &first, in, parse_opts, val_opts, data_type, &parsed, NULL, &lydctx);\n        break;\n    case LYD_UNKNOWN:\n        LOGARG(ctx, format);\n        rc = LY_EINVAL;\n        break;\n    }\n    LY_CHECK_GOTO(rc, cleanup);\n\n    /* set out params correctly */\n    if (tree) {\n        if (envp) {\n            /* special out param meaning */\n            *tree = envp;\n        } else {\n            *tree = parent ? NULL : first;\n        }\n    }\n    if (op) {\n        *op = lydctx->op_node;\n    }\n\ncleanup:\n    if (lydctx) {\n        lydctx->free(lydctx);\n    }\n    if (rc) {\n        if (parent) {\n            /* free all the parsed subtrees */\n            for (i = 0; i < parsed.count; ++i) {\n                lyd_free_tree(parsed.dnodes[i]);\n            }\n        } else {\n            /* free everything (cannot occur in the current code, a safety) */\n            lyd_free_all(first);\n            if (tree) {\n                *tree = NULL;\n            }\n            if (op) {\n                *op = NULL;\n            }\n        }\n    }\n    ly_set_erase(&parsed, NULL);\n    return rc;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    parse_opts = LYD_PARSE_ONLY | LYD_PARSE_OPAQ;\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_140ede9c075c604632a87ee3bf0e881fb485d0e7/build_140ede9c075c604632a87ee3bf0e881fb485d0e7\nTest project /out/CESNET___libyang/git_repo_dir_140ede9c075c604632a87ee3bf0e881fb485d0e7/build_140ede9c075c604632a87ee3bf0e881fb485d0e7\n    Start 48: utest_validation\n1/1 Test #48: utest_validation .................***Failed    0.10 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.11 sec\n\nThe following tests FAILED:\n\t 48 - utest_validation (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "140ede9c075c604632a87ee3bf0e881fb485d0e7___tree_data.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic LY_ERR\nlydxml_data_skip(struct lyxml_ctx *xmlctx)\n{\n    uint32_t parents_count;\n\n    /* remember current number of parents */\n    parents_count = xmlctx->elements.count;\n\n    /* skip after the content */\n    while (xmlctx->status != LYXML_ELEM_CONTENT) {\n        LY_CHECK_RET(lyxml_ctx_next(xmlctx));\n    }\n    LY_CHECK_RET(lyxml_ctx_next(xmlctx));\n\n\n>>> [ INFILL ] <<<\n    while (parents_count < xmlctx->elements.count) {\n        LY_CHECK_RET(lyxml_ctx_next(xmlctx));\n    }\n\n    /* close element */\n    assert(xmlctx->status == LYXML_ELEM_CLOSE);\n    LY_CHECK_RET(lyxml_ctx_next(xmlctx));\n\n    return LY_SUCCESS;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    /* skip all children elements, recursively, if any */\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_9cdb9e6f60d6bae42675bc3b46f5741e50b62e68/build_9cdb9e6f60d6bae42675bc3b46f5741e50b62e68\nTest project /out/CESNET___libyang/git_repo_dir_9cdb9e6f60d6bae42675bc3b46f5741e50b62e68/build_9cdb9e6f60d6bae42675bc3b46f5741e50b62e68\n    Start 30: utest_parser_xml\n1/1 Test #30: utest_parser_xml .................***Failed    0.08 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.08 sec\n\nThe following tests FAILED:\n\t 30 - utest_parser_xml (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "9cdb9e6f60d6bae42675bc3b46f5741e50b62e68___parser_xml.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic LY_ERR\nmoveto_scnode_check(const struct lysc_node *node, const struct lysc_node *ctx_scnode, const struct lyxp_set *set,\n        const char *node_name, const struct lys_module *moveto_mod)\n{\n\n>>> [ INFILL ] <<<\n        switch (set->format) {\n        case LY_VALUE_SCHEMA:\n        case LY_VALUE_SCHEMA_RESOLVED:\n            /* use current module */\n            moveto_mod = set->cur_mod;\n            break;\n        case LY_VALUE_JSON:\n        case LY_VALUE_LYB:\n            /* inherit module of the context node, if any */\n            if (ctx_scnode) {\n                moveto_mod = ctx_scnode->module;\n            }\n            break;\n        case LY_VALUE_CANON:\n        case LY_VALUE_XML:\n            /* not defined */\n            LOGINT(set->ctx);\n            return LY_EINVAL;\n        }\n    }\n\n    /* module check */\n    if (moveto_mod && (node->module != moveto_mod)) {\n        return LY_ENOT;\n    }\n\n    /* context check */\n    if ((set->root_type == LYXP_NODE_ROOT_CONFIG) && (node->flags & LYS_CONFIG_R)) {\n        return LY_EINVAL;\n    } else if (set->context_op && (node->nodetype & (LYS_RPC | LYS_ACTION | LYS_NOTIF)) && (node != set->context_op)) {\n        return LY_EINVAL;\n    }\n\n    /* name check */\n    if (node_name && strcmp(node_name, \"*\") && (node->name != node_name)) {\n        return LY_ENOT;\n    }\n\n    /* match */\n    return LY_SUCCESS;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    if (!moveto_mod && (!node_name || strcmp(node_name, \"*\"))) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CESNET___libyang/git_repo_dir_24bd22f5e40f37fb6ae796bb8eebc9de58bae00e/build_24bd22f5e40f37fb6ae796bb8eebc9de58bae00e\nTest project /out/CESNET___libyang/git_repo_dir_24bd22f5e40f37fb6ae796bb8eebc9de58bae00e/build_24bd22f5e40f37fb6ae796bb8eebc9de58bae00e\n    Start 38: utest_tree_schema_compile\n1/1 Test #38: utest_tree_schema_compile ........***Failed    0.26 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.27 sec\n\nThe following tests FAILED:\n\t 38 - utest_tree_schema_compile (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "24bd22f5e40f37fb6ae796bb8eebc9de58bae00e___xpath.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstd::unique_ptr<BlobFetcher> CompactionIterator::CreateBlobFetcherIfNeeded(\n    const CompactionProxy* compaction) {\n  if (!compaction) {\n    return nullptr;\n  }\n\n  const Version* const version = compaction->input_version();\n  if (!version) {\n    return nullptr;\n  }\n\n\n>>> [ INFILL ] <<<\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  return std::unique_ptr<BlobFetcher>(new BlobFetcher(version, ReadOptions()));\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/facebook___rocksdb/git_repo_dir_cc8ded6152c51ac853d2915273eed3e6f9af029b/build_cc8ded6152c51ac853d2915273eed3e6f9af029b\nTest project /out/facebook___rocksdb/git_repo_dir_cc8ded6152c51ac853d2915273eed3e6f9af029b/build_cc8ded6152c51ac853d2915273eed3e6f9af029b\n    Start 523: DBBlobCompactionTest.CompactionDoNotFillCache\n1/1 Test #523: DBBlobCompactionTest.CompactionDoNotFillCache ...***Failed    0.14 sec\n\u001b[0;33mNote: Google Test filter = DBBlobCompactionTest.CompactionDoNotFillCache\n\u001b[m\u001b[0;32m[==========] \u001b[mRunning 1 test from 1 test case.\n\u001b[0;32m[----------] \u001b[mGlobal test environment set-up.\n\u001b[0;32m[----------] \u001b[m1 test from DBBlobCompactionTest\n\u001b[0;32m[ RUN      ] \u001b[mDBBlobCompactionTest.CompactionDoNotFillCache\n/out/facebook___rocksdb/git_repo_dir_cc8ded6152c51ac853d2915273eed3e6f9af029b/db/blob/db_blob_compaction_test.cc:832: Failure\nExpected equality of these values:\n  options.statistics->getTickerCount(BLOB_DB_CACHE_ADD)\n    Which is: 2\n  0\n\u001b[0;31m[  FAILED  ] \u001b[mDBBlobCompactionTest.CompactionDoNotFillCache (116 ms)\n\u001b[0;32m[----------] \u001b[m1 test from DBBlobCompactionTest (116 ms total)\n\n\u001b[0;32m[----------] \u001b[mGlobal test environment tear-down\n\u001b[0;32m[==========] \u001b[m1 test from 1 test case ran. (116 ms total)\n\u001b[0;32m[  PASSED  ] \u001b[m0 tests.\n\u001b[0;31m[  FAILED  ] \u001b[m1 test, listed below:\n\u001b[0;31m[  FAILED  ] \u001b[mDBBlobCompactionTest.CompactionDoNotFillCache\n\n 1 FAILED TEST\n\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.03 sec\n\nThe following tests FAILED:\n\t523 - DBBlobCompactionTest.CompactionDoNotFillCache (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "cc8ded6152c51ac853d2915273eed3e6f9af029b___compaction_iterator.cc"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid DBIter::SeekToLast() {\n  if (iterate_upper_bound_ != nullptr) {\n    // Seek to last key strictly less than ReadOptions.iterate_upper_bound.\n    SeekForPrev(*iterate_upper_bound_);\n    const bool is_ikey = (timestamp_size_ > 0 && timestamp_lb_ != nullptr);\n    Slice k = Valid() ? key() : Slice();\n\n>>> [ INFILL ] <<<\n      k.remove_suffix(kNumInternalBytes + timestamp_size_);\n    }\n    while (Valid() && 0 == user_comparator_.CompareWithoutTimestamp(\n                               *iterate_upper_bound_, /*a_has_ts=*/false, k,\n                               /*b_has_ts=*/false)) {\n      ReleaseTempPinnedData();\n      PrevInternal(nullptr);\n\n      k = key();\n      if (is_ikey) {\n        k.remove_suffix(kNumInternalBytes + timestamp_size_);\n      }\n    }\n    return;\n  }\n\n  PERF_CPU_TIMER_GUARD(iter_seek_cpu_nanos, clock_);\n  // Don't use iter_::Seek() if we set a prefix extractor\n  // because prefix seek will be used.\n  if (!expect_total_order_inner_iter()) {\n    max_skip_ = std::numeric_limits<uint64_t>::max();\n  }\n  status_ = Status::OK();\n  direction_ = kReverse;\n  ReleaseTempPinnedData();\n  ResetInternalKeysSkippedCounter();\n  ClearSavedValue();\n  is_key_seqnum_zero_ = false;\n\n  {\n    PERF_TIMER_GUARD(seek_internal_seek_time);\n    iter_.SeekToLast();\n    range_del_agg_.InvalidateRangeDelMapPositions();\n  }\n  PrevInternal(nullptr);\n  if (statistics_ != nullptr) {\n    RecordTick(statistics_, NUMBER_DB_SEEK);\n    if (valid_) {\n      RecordTick(statistics_, NUMBER_DB_SEEK_FOUND);\n      RecordTick(statistics_, ITER_BYTES_READ, key().size() + value().size());\n      PERF_COUNTER_ADD(iter_read_bytes, key().size() + value().size());\n    }\n  }\n  if (valid_ && prefix_same_as_start_) {\n    assert(prefix_extractor_ != nullptr);\n    prefix_.SetUserKey(prefix_extractor_->Transform(\n        StripTimestampFromUserKey(saved_key_.GetUserKey(), timestamp_size_)));\n  }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    if (is_ikey) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/facebook___rocksdb/git_repo_dir_b87c355772c0e1a643cbbd9799809d376073a6fe/build_b87c355772c0e1a643cbbd9799809d376073a6fe\nTest project /out/facebook___rocksdb/git_repo_dir_b87c355772c0e1a643cbbd9799809d376073a6fe/build_b87c355772c0e1a643cbbd9799809d376073a6fe\n    Start 985: DBBasicTestWithTimestamp.SimpleBackwardIterateLowerTsBound\n1/1 Test #985: DBBasicTestWithTimestamp.SimpleBackwardIterateLowerTsBound ...Subprocess aborted***Exception:   0.84 sec\n\u001b[0;33mNote: Google Test filter = DBBasicTestWithTimestamp.SimpleBackwardIterateLowerTsBound\n\u001b[m\u001b[0;32m[==========] \u001b[mRunning 1 test from 1 test case.\n\u001b[0;32m[----------] \u001b[mGlobal test environment set-up.\n\u001b[0;32m[----------] \u001b[m1 test from DBBasicTestWithTimestamp\n\u001b[0;32m[ RUN      ] \u001b[mDBBasicTestWithTimestamp.SimpleBackwardIterateLowerTsBound\ndb_with_timestamp_basic_test: /out/facebook___rocksdb/git_repo_dir_b87c355772c0e1a643cbbd9799809d376073a6fe/include/rocksdb/slice.h:86: void rocksdb::Slice::remove_suffix(size_t): Assertion `n <= size()' failed.\n\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   2.70 sec\n\nThe following tests FAILED:\n\t985 - DBBasicTestWithTimestamp.SimpleBackwardIterateLowerTsBound (Subprocess aborted)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "b87c355772c0e1a643cbbd9799809d376073a6fe___db_iter.cc"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nStatus RocksDBOptionsParser::EndSection(\n    const ConfigOptions& config_options, const OptionSection section,\n    const std::string& section_title, const std::string& section_arg,\n    const std::unordered_map<std::string, std::string>& opt_map) {\n  Status s;\n  if (section == kOptionSectionDBOptions) {\n    s = GetDBOptionsFromMap(config_options, DBOptions(), opt_map, &db_opt_);\n    if (!s.ok()) {\n      return s;\n    }\n    db_opt_map_ = opt_map;\n  } else if (section == kOptionSectionCFOptions) {\n    // This condition should be ensured earlier in ParseSection\n    // so we make an assertion here.\n    assert(GetCFOptions(section_arg) == nullptr);\n    cf_names_.emplace_back(section_arg);\n    cf_opts_.emplace_back();\n    s = GetColumnFamilyOptionsFromMap(config_options, ColumnFamilyOptions(),\n                                      opt_map, &cf_opts_.back());\n    if (!s.ok()) {\n      return s;\n    }\n    // keep the parsed string.\n    cf_opt_maps_.emplace_back(opt_map);\n  } else if (section == kOptionSectionTableOptions) {\n    assert(GetCFOptions(section_arg) != nullptr);\n    auto* cf_opt = GetCFOptionsImpl(section_arg);\n    if (cf_opt == nullptr) {\n      return Status::InvalidArgument(\n          \"The specified column family must be defined before the \"\n          \"TableOptions section:\",\n          section_arg);\n    }\n    // Ignore error as table factory deserialization is optional\n    s = TableFactory::CreateFromString(\n        config_options,\n        section_title.substr(\n            opt_section_titles[kOptionSectionTableOptions].size()),\n        &(cf_opt->table_factory));\n\n>>> [ INFILL ] <<<\n      s = cf_opt->table_factory->ConfigureFromMap(config_options, opt_map);\n      // Translate any errors (NotFound, NotSupported, to InvalidArgument\n      if (s.ok() || s.IsInvalidArgument()) {\n        return s;\n      } else {\n        return Status::InvalidArgument(s.getState());\n      }\n    } else {\n      // Return OK for not supported table factories as TableFactory\n      // Deserialization is optional.\n      cf_opt->table_factory.reset();\n      return Status::OK();\n    }\n  } else if (section == kOptionSectionVersion) {\n    for (const auto& pair : opt_map) {\n      if (pair.first == \"rocksdb_version\") {\n        s = ParseVersionNumber(pair.first, pair.second, 3, db_version);\n        if (!s.ok()) {\n          return s;\n        }\n      } else if (pair.first == \"options_file_version\") {\n        s = ParseVersionNumber(pair.first, pair.second, 2, opt_file_version);\n        if (!s.ok()) {\n          return s;\n        }\n        if (opt_file_version[0] < 1) {\n          return Status::InvalidArgument(\n              \"A valid options_file_version must be at least 1.\");\n        }\n      }\n    }\n  }\n  return s;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    if (s.ok()) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/facebook___rocksdb/git_repo_dir_1d2950b8dd38009d0719e4a857f5a42bb1bc9675/build_1d2950b8dd38009d0719e4a857f5a42bb1bc9675\nTest project /out/facebook___rocksdb/git_repo_dir_1d2950b8dd38009d0719e4a857f5a42bb1bc9675/build_1d2950b8dd38009d0719e4a857f5a42bb1bc9675\n    Start 6305: OptionsParserTest.DumpAndParse\n1/1 Test #6305: OptionsParserTest.DumpAndParse ...***Failed    0.04 sec\n\u001b[0;33mNote: Google Test filter = OptionsParserTest.DumpAndParse\n\u001b[m\u001b[0;32m[==========] \u001b[mRunning 1 test from 1 test case.\n\u001b[0;32m[----------] \u001b[mGlobal test environment set-up.\n\u001b[0;32m[----------] \u001b[m1 test from OptionsParserTest\n\u001b[0;32m[ RUN      ] \u001b[mOptionsParserTest.DumpAndParse\n/out/facebook___rocksdb/git_repo_dir_1d2950b8dd38009d0719e4a857f5a42bb1bc9675/options/options_test.cc:3692: Failure\nPersistRocksDBOptions(base_db_opt, cf_names, base_cf_opts, kOptionsFileName, fs_.get())\nCorruption: [RocksDBOptionsParser]: failed the verification on TableFactory->Name()\n\u001b[0;31m[  FAILED  ] \u001b[mOptionsParserTest.DumpAndParse (21 ms)\n\u001b[0;32m[----------] \u001b[m1 test from OptionsParserTest (21 ms total)\n\n\u001b[0;32m[----------] \u001b[mGlobal test environment tear-down\n\u001b[0;32m[==========] \u001b[m1 test from 1 test case ran. (21 ms total)\n\u001b[0;32m[  PASSED  ] \u001b[m0 tests.\n\u001b[0;31m[  FAILED  ] \u001b[m1 test, listed below:\n\u001b[0;31m[  FAILED  ] \u001b[mOptionsParserTest.DumpAndParse\n\n 1 FAILED TEST\n\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.02 sec\n\nThe following tests FAILED:\n\t6305 - OptionsParserTest.DumpAndParse (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "1d2950b8dd38009d0719e4a857f5a42bb1bc9675___options_parser.cc"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\n\n>>> [ INFILL ] <<<\n\n    uint8_t decode_value = BASE64_DECODING_TABLE[(size_t)to_decode];\n    if (decode_value != 0xDD && (decode_value != BASE64_SENTIANAL_VALUE || allow_sentinal)) {\n        *value = decode_value;\n        return AWS_OP_SUCCESS;\n    }\n\n    return AWS_OP_ERR;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\nstatic inline int s_base64_get_decoded_value(char to_decode, uint8_t *value, int8_t allow_sentinal) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/awslabs___aws-c-common/git_repo_dir_3367d5d13173664bc5018f5405adfa4d395c87ce/build_3367d5d13173664bc5018f5405adfa4d395c87ce\nTest project /out/awslabs___aws-c-common/git_repo_dir_3367d5d13173664bc5018f5405adfa4d395c87ce/build_3367d5d13173664bc5018f5405adfa4d395c87ce\n    Start 73: base64_encoding_highbyte_string_test\n1/1 Test #73: base64_encoding_highbyte_string_test ...***Failed    0.00 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.01 sec\n\nThe following tests FAILED:\n\t 73 - base64_encoding_highbyte_string_test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "3367d5d13173664bc5018f5405adfa4d395c87ce___encoding.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic int\nevent_process_active_single_queue(struct event_base *base,\n    struct evcallback_list *activeq,\n    int max_to_process, const struct timeval *endtime)\n{\n\tstruct event_callback *evcb;\n\tint count = 0;\n\n\tEVUTIL_ASSERT(activeq != NULL);\n\n\tfor (evcb = TAILQ_FIRST(activeq); evcb; evcb = TAILQ_FIRST(activeq)) {\n\t\tstruct event *ev=NULL;\n\t\tif (evcb->evcb_flags & EVLIST_INIT) {\n\t\t\tev = event_callback_to_event(evcb);\n\n\t\t\tif (ev->ev_events & EV_PERSIST || ev->ev_flags & EVLIST_FINALIZING)\n\t\t\t\tevent_queue_remove_active(base, evcb);\n\t\t\telse\n\t\t\t\tevent_del_nolock_(ev, EVENT_DEL_NOBLOCK);\n\t\t\tevent_debug((\n\t\t\t    \"event_process_active: event: %p, %s%s%scall %p\",\n\t\t\t    ev,\n\t\t\t    ev->ev_res & EV_READ ? \"EV_READ \" : \" \",\n\t\t\t    ev->ev_res & EV_WRITE ? \"EV_WRITE \" : \" \",\n\t\t\t    ev->ev_res & EV_CLOSED ? \"EV_CLOSED \" : \" \",\n\t\t\t    ev->ev_callback));\n\t\t} else {\n\t\t\tevent_queue_remove_active(base, evcb);\n\t\t\tevent_debug((\"event_process_active: event_callback %p, \"\n\t\t\t\t\"closure %d, call %p\",\n\t\t\t\tevcb, evcb->evcb_closure, evcb->evcb_cb_union.evcb_callback));\n\t\t}\n\n\t\tif (!(evcb->evcb_flags & EVLIST_INTERNAL))\n\t\t\t++count;\n\n\n\t\tbase->current_event = evcb;\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\t\tbase->current_event_waiters = 0;\n#endif\n\n\t\tswitch (evcb->evcb_closure) {\n\t\tcase EV_CLOSURE_EVENT_SIGNAL:\n\t\t\tEVUTIL_ASSERT(ev != NULL);\n\t\t\tevent_signal_closure(base, ev);\n\t\t\tbreak;\n\t\tcase EV_CLOSURE_EVENT_PERSIST:\n\t\t\tEVUTIL_ASSERT(ev != NULL);\n\t\t\tevent_persist_closure(base, ev);\n\t\t\tbreak;\n\t\tcase EV_CLOSURE_EVENT: {\n\t\t\tvoid (*evcb_callback)(evutil_socket_t, short, void *);\n\t\t\tshort res;\n\t\t\tEVUTIL_ASSERT(ev != NULL);\n\t\t\tevcb_callback = *ev->ev_callback;\n\t\t\tres = ev->ev_res;\n\t\t\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n\t\t\tevcb_callback(ev->ev_fd, res, ev->ev_arg);\n\t\t}\n\t\tbreak;\n\t\tcase EV_CLOSURE_CB_SELF: {\n\t\t\tvoid (*evcb_selfcb)(struct event_callback *, void *) = evcb->evcb_cb_union.evcb_selfcb;\n\t\t\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n\t\t\tevcb_selfcb(evcb, evcb->evcb_arg);\n\t\t}\n\t\tbreak;\n\t\tcase EV_CLOSURE_EVENT_FINALIZE:\n\t\tcase EV_CLOSURE_EVENT_FINALIZE_FREE: {\n\t\t\tvoid (*evcb_evfinalize)(struct event *, void *);\n\t\t\tint evcb_closure = evcb->evcb_closure;\n\t\t\tEVUTIL_ASSERT(ev != NULL);\n\t\t\tbase->current_event = NULL;\n\t\t\tevcb_evfinalize = ev->ev_evcallback.evcb_cb_union.evcb_evfinalize;\n\t\t\tEVUTIL_ASSERT((evcb->evcb_flags & EVLIST_FINALIZING));\n\t\t\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n\n>>> [ INFILL ] <<<\n\t\t\tevent_debug_note_teardown_(ev);\n\t\t\tif (evcb_closure == EV_CLOSURE_EVENT_FINALIZE_FREE)\n\t\t\t\tmm_free(ev);\n\t\t}\n\t\tbreak;\n\t\tcase EV_CLOSURE_CB_FINALIZE: {\n\t\t\tvoid (*evcb_cbfinalize)(struct event_callback *, void *) = evcb->evcb_cb_union.evcb_cbfinalize;\n\t\t\tbase->current_event = NULL;\n\t\t\tEVUTIL_ASSERT((evcb->evcb_flags & EVLIST_FINALIZING));\n\t\t\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n\t\t\tevcb_cbfinalize(evcb, evcb->evcb_arg);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\tEVUTIL_ASSERT(0);\n\t\t}\n\n\t\tEVBASE_ACQUIRE_LOCK(base, th_base_lock);\n\t\tbase->current_event = NULL;\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\t\tif (base->current_event_waiters) {\n\t\t\tbase->current_event_waiters = 0;\n\t\t\tEVTHREAD_COND_BROADCAST(base->current_event_cond);\n\t\t}\n#endif\n\n\t\tif (base->event_break)\n\t\t\treturn -1;\n\t\tif (count >= max_to_process)\n\t\t\treturn count;\n\t\tif (count && endtime) {\n\t\t\tstruct timeval now;\n\t\t\tupdate_time_cache(base);\n\t\t\tgettime(base, &now);\n\t\t\tif (evutil_timercmp(&now, endtime, >=))\n\t\t\t\treturn count;\n\t\t}\n\t\tif (base->event_continue)\n\t\t\tbreak;\n\t}\n\treturn count;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\t\t\tevcb_evfinalize(ev, ev->ev_arg);\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/libevent___libevent/git_repo_dir_445027a5dcfe0acce431b7d4065d2ac1f6b270d7/build_445027a5dcfe0acce431b7d4065d2ac1f6b270d7\nTest project /out/libevent___libevent/git_repo_dir_445027a5dcfe0acce431b7d4065d2ac1f6b270d7/build_445027a5dcfe0acce431b7d4065d2ac1f6b270d7\n      Start  8: regress__timerfd_EPOLL\n 1/10 Test  #8: regress__timerfd_EPOLL ....................***Failed   91.50 sec\n      Start  9: regress__timerfd_EPOLL_debug\n 2/10 Test  #9: regress__timerfd_EPOLL_debug ..............***Failed   92.80 sec\n      Start 17: regress__changelist_EPOLL\n 3/10 Test #17: regress__changelist_EPOLL .................***Failed   92.28 sec\n      Start 18: regress__changelist_EPOLL_debug\n 4/10 Test #18: regress__changelist_EPOLL_debug ...........***Failed   91.28 sec\n      Start 26: regress__timerfd_changelist_EPOLL\n 5/10 Test #26: regress__timerfd_changelist_EPOLL .........***Failed   89.68 sec\n      Start 27: regress__timerfd_changelist_EPOLL_debug\n 6/10 Test #27: regress__timerfd_changelist_EPOLL_debug ...***Failed   88.88 sec\n      Start 35: regress__SELECT\n 7/10 Test #35: regress__SELECT ...........................***Failed   89.06 sec\n      Start 36: regress__SELECT_debug\n 8/10 Test #36: regress__SELECT_debug .....................***Failed   89.13 sec\n      Start 44: regress__POLL\n 9/10 Test #44: regress__POLL .............................***Failed   91.51 sec\n      Start 45: regress__POLL_debug\n10/10 Test #45: regress__POLL_debug .......................***Failed   91.51 sec\n\n0% tests passed, 10 tests failed out of 10\n\nTotal Test time (real) = 907.66 sec\n\nThe following tests FAILED:\n\t  8 - regress__timerfd_EPOLL (Failed)\n\t  9 - regress__timerfd_EPOLL_debug (Failed)\n\t 17 - regress__changelist_EPOLL (Failed)\n\t 18 - regress__changelist_EPOLL_debug (Failed)\n\t 26 - regress__timerfd_changelist_EPOLL (Failed)\n\t 27 - regress__timerfd_changelist_EPOLL_debug (Failed)\n\t 35 - regress__SELECT (Failed)\n\t 36 - regress__SELECT_debug (Failed)\n\t 44 - regress__POLL (Failed)\n\t 45 - regress__POLL_debug \nPlease provide the correct line following commit message at the infill location."}], "idx": "445027a5dcfe0acce431b7d4065d2ac1f6b270d7___event.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic int\nepoll_dispatch(struct event_base *base, struct timeval *tv)\n{\n\tstruct epollop *epollop = base->evbase;\n\tstruct epoll_event *events = epollop->events;\n\tint i, res;\n\tlong timeout = -1;\n\n#ifdef USING_TIMERFD\n\tif (epollop->timerfd >= 0) {\n\t\tstruct itimerspec is;\n\t\tis.it_interval.tv_sec = 0;\n\t\tis.it_interval.tv_nsec = 0;\n\t\tif (tv == NULL) {\n\t\t\t/* No timeout; disarm the timer. */\n\t\t\tis.it_value.tv_sec = 0;\n\t\t\tis.it_value.tv_nsec = 0;\n\t\t} else {\n\t\t\tif (tv->tv_sec == 0 && tv->tv_usec == 0) {\n\t\t\t\t/* we need to exit immediately; timerfd can't\n\t\t\t\t * do that. */\n\t\t\t\ttimeout = 0;\n\t\t\t}\n\t\t\tis.it_value.tv_sec = tv->tv_sec;\n\t\t\tis.it_value.tv_nsec = tv->tv_usec * 1000;\n\t\t}\n\t\t/* TODO: we could avoid unnecessary syscalls here by only\n\t\t   calling timerfd_settime when the top timeout changes, or\n\t\t   when we're called with a different timeval.\n\t\t*/\n\t\tif (timerfd_settime(epollop->timerfd, 0, &is, NULL) < 0) {\n\t\t\tevent_warn(\"timerfd_settime\");\n\t\t}\n\t} else\n#endif\n\tif (tv != NULL) {\n\t\ttimeout = evutil_tv_to_msec_(tv);\n\t\tif (timeout < 0 || timeout > MAX_EPOLL_TIMEOUT_MSEC) {\n\t\t\t/* Linux kernels can wait forever if the timeout is\n\t\t\t * too big; see comment on MAX_EPOLL_TIMEOUT_MSEC. */\n\t\t\ttimeout = MAX_EPOLL_TIMEOUT_MSEC;\n\t\t}\n\t}\n\n\tepoll_apply_changes(base);\n\tevent_changelist_remove_all_(&base->changelist, base);\n\n\tEVBASE_RELEASE_LOCK(base, th_base_lock);\n\n\tres = epoll_wait(epollop->epfd, events, epollop->nevents, timeout);\n\n\tEVBASE_ACQUIRE_LOCK(base, th_base_lock);\n\n\tif (res == -1) {\n\t\tif (errno != EINTR) {\n\t\t\tevent_warn(\"epoll_wait\");\n\t\t\treturn (-1);\n\t\t}\n\n\t\treturn (0);\n\t}\n\n\tevent_debug((\"%s: epoll_wait reports %d\", __func__, res));\n\tEVUTIL_ASSERT(res <= epollop->nevents);\n\n\tfor (i = 0; i < res; i++) {\n\t\tint what = events[i].events;\n\t\tshort ev = 0;\n#ifdef USING_TIMERFD\n\t\tif (events[i].data.fd == epollop->timerfd)\n\t\t\tcontinue;\n#endif\n\n\n>>> [ INFILL ] <<<\n\t\t\tev = EV_READ | EV_WRITE;\n\t\t} else {\n\t\t\tif (what & EPOLLIN)\n\t\t\t\tev |= EV_READ;\n\t\t\tif (what & EPOLLOUT)\n\t\t\t\tev |= EV_WRITE;\n\t\t\tif (what & EPOLLRDHUP)\n\t\t\t\tev |= EV_CLOSED;\n\t\t}\n\n\t\tif (!ev)\n\t\t\tcontinue;\n\n\t\tevmap_io_active_(base, events[i].data.fd, ev | EV_ET);\n\t}\n\n\tif (res == epollop->nevents && epollop->nevents < MAX_NEVENT) {\n\t\t/* We used all of the event space this time.  We should\n\t\t   be ready for more events next time. */\n\t\tint new_nevents = epollop->nevents * 2;\n\t\tstruct epoll_event *new_events;\n\n\t\tnew_events = mm_realloc(epollop->events,\n\t\t    new_nevents * sizeof(struct epoll_event));\n\t\tif (new_events) {\n\t\t\tepollop->events = new_events;\n\t\t\tepollop->nevents = new_nevents;\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\t\tif (what & (EPOLLHUP|EPOLLERR)) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/libevent___libevent/git_repo_dir_972b456bf60e9a2f550ec45a14921c06e252c793/build_972b456bf60e9a2f550ec45a14921c06e252c793\nTest project /out/libevent___libevent/git_repo_dir_972b456bf60e9a2f550ec45a14921c06e252c793/build_972b456bf60e9a2f550ec45a14921c06e252c793\n    Start  9: regress__timerfd_EPOLL\n1/6 Test  #9: regress__timerfd_EPOLL ....................***Failed   93.38 sec\n    Start 10: regress__timerfd_EPOLL_debug\n2/6 Test #10: regress__timerfd_EPOLL_debug ..............***Failed   95.12 sec\n    Start 19: regress__changelist_EPOLL\n3/6 Test #19: regress__changelist_EPOLL .................***Failed   94.78 sec\n    Start 20: regress__changelist_EPOLL_debug\n4/6 Test #20: regress__changelist_EPOLL_debug ...........***Failed   95.68 sec\n    Start 29: regress__timerfd_changelist_EPOLL\n5/6 Test #29: regress__timerfd_changelist_EPOLL .........***Failed   93.83 sec\n    Start 30: regress__timerfd_changelist_EPOLL_debug\n6/6 Test #30: regress__timerfd_changelist_EPOLL_debug ...***Failed   92.92 sec\n\n0% tests passed, 6 tests failed out of 6\n\nTotal Test time (real) = 565.72 sec\n\nThe following tests FAILED:\n\t  9 - regress__timerfd_EPOLL (Failed)\n\t 10 - regress__timerfd_EPOLL_debug (Failed)\n\t 19 - regress__changelist_EPOLL (Failed)\n\t 20 - regress__changelist_EPOLL_debug (Failed)\n\t 29 - regress__timerfd_changelist_EPOLL (Failed)\n\t 30 - regress__timerfd_changelist_EPOLL_debug (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "972b456bf60e9a2f550ec45a14921c06e252c793___epoll.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\n  Status SelectIndices(liborc::RowReaderOptions* opts,\n                       const std::vector<int>& include_indices) {\n    std::list<uint64_t> include_indices_list;\n    for (auto it = include_indices.begin(); it != include_indices.end(); ++it) {\n      ARROW_RETURN_IF(*it < 0, Status::Invalid(\"Negative field index\"));\n      include_indices_list.push_back(*it);\n    }\n\n>>> [ INFILL ] <<<\n    return Status::OK();\n  }\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    opts->includeTypes(include_indices_list);\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_eea4a54f66a36137f4204876a68e6d5ed913cbc5/build_eea4a54f66a36137f4204876a68e6d5ed913cbc5\nTest project /out/apache___arrow/git_repo_dir_eea4a54f66a36137f4204876a68e6d5ed913cbc5/build_eea4a54f66a36137f4204876a68e6d5ed913cbc5\n    Start 40: arrow-orc-adapter-test\n1/1 Test #40: arrow-orc-adapter-test ...........***Failed    0.73 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow-tests    =   0.73 sec*proc (1 test)\nunittest       =   0.73 sec*proc (1 test)\n\nTotal Test time (real) =   0.74 sec\n\nThe following tests FAILED:\n\t 40 - arrow-orc-adapter-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "eea4a54f66a36137f4204876a68e6d5ed913cbc5___adapter.cc"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nStatus RecordBatchBuilder::Flush(bool reset_builders,\n                                 std::shared_ptr<RecordBatch>* batch) {\n  std::vector<std::shared_ptr<Array>> fields;\n  fields.resize(this->num_fields());\n\n  int64_t length = 0;\n  for (int i = 0; i < this->num_fields(); ++i) {\n    RETURN_NOT_OK(raw_field_builders_[i]->Finish(&fields[i]));\n    if (i > 0 && fields[i]->length() != length) {\n      return Status::Invalid(\"All fields must be same length when calling Flush\");\n    }\n    length = fields[i]->length();\n  }\n\n>>> [ INFILL ] <<<\n  if (reset_builders) {\n    return InitBuilders();\n  } else {\n    return Status::OK();\n  }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  *batch = RecordBatch::Make(schema_, length, std::move(fields));\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_0b4fa2a2bf80bf3a91f9f8f42fe313f78b8a1282/build_0b4fa2a2bf80bf3a91f9f8f42fe313f78b8a1282\nTest project /out/apache___arrow/git_repo_dir_0b4fa2a2bf80bf3a91f9f8f42fe313f78b8a1282/build_0b4fa2a2bf80bf3a91f9f8f42fe313f78b8a1282\n    Start 8: arrow-table-test\n1/1 Test #8: arrow-table-test .................***Failed    0.07 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow-tests    =   0.07 sec*proc (1 test)\nunittest       =   0.07 sec*proc (1 test)\n\nTotal Test time (real) =   0.07 sec\n\nThe following tests FAILED:\n\t  8 - arrow-table-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "0b4fa2a2bf80bf3a91f9f8f42fe313f78b8a1282___table_builder.cc"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nResult<PartitionPathFormat> HivePartitioning::FormatValues(\n    const ScalarVector& values) const {\n  std::vector<std::string> segments(static_cast<size_t>(schema_->num_fields()));\n\n  for (int i = 0; i < schema_->num_fields(); ++i) {\n    const std::string& name = schema_->field(i)->name();\n\n    if (values[i] == nullptr) {\n      segments[i] = \"\";\n    } else if (!values[i]->is_valid) {\n      // If no key is available just provide a placeholder segment to maintain the\n      // field_index <-> path nesting relation\n      segments[i] = name + \"=\" + hive_options_.null_fallback;\n    } else {\n\n>>> [ INFILL ] <<<\n    }\n  }\n\n  return PartitionPathFormat{fs::internal::JoinAbstractPath(std::move(segments)), \"\"};\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n      segments[i] = name + \"=\" + values[i]->ToString();\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_db004443e631fd72c0fd9a16a02294cd14b456e5/build_db004443e631fd72c0fd9a16a02294cd14b456e5\nTest project /out/apache___arrow/git_repo_dir_db004443e631fd72c0fd9a16a02294cd14b456e5/build_db004443e631fd72c0fd9a16a02294cd14b456e5\n    Start 42: arrow-dataset-partition-test\n1/1 Test #42: arrow-dataset-partition-test .....***Failed    0.08 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow_dataset    =   0.08 sec*proc (1 test)\nunittest         =   0.08 sec*proc (1 test)\n\nTotal Test time (real) =   0.08 sec\n\nThe following tests FAILED:\n\t 42 - arrow-dataset-partition-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "db004443e631fd72c0fd9a16a02294cd14b456e5___partition.cc"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid NullTake(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n  if (TakeState::Get(ctx).boundscheck) {\n    KERNEL_RETURN_IF_ERROR(ctx, CheckIndexBounds(*batch[1].array(), batch[0].length()));\n  }\n\n>>> [ INFILL ] <<<\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  out->value = std::make_shared<NullArray>(batch.length)->data();\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_171e8bfe5fe13467a1763227e495fae6bc5d011d/build_171e8bfe5fe13467a1763227e495fae6bc5d011d\nTest project /out/apache___arrow/git_repo_dir_171e8bfe5fe13467a1763227e495fae6bc5d011d/build_171e8bfe5fe13467a1763227e495fae6bc5d011d\n    Start 24: arrow-compute-vector-test\n1/1 Test #24: arrow-compute-vector-test ........***Failed    1.17 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow_compute    =   1.17 sec*proc (1 test)\nunittest         =   1.17 sec*proc (1 test)\n\nTotal Test time (real) =   1.17 sec\n\nThe following tests FAILED:\n\t 24 - arrow-compute-vector-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "171e8bfe5fe13467a1763227e495fae6bc5d011d___vector_selection.cc"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstruct ARROW_EXPORT Arity {\n  /// \\brief A function taking no arguments\n  static Arity Nullary() { return Arity(0, false); }\n\n  /// \\brief A function taking 1 argument\n  static Arity Unary() { return Arity(1, false); }\n\n  /// \\brief A function taking 2 arguments\n  static Arity Binary() { return Arity(2, false); }\n\n  /// \\brief A function taking 3 arguments\n  static Arity Ternary() { return Arity(3, false); }\n\n  /// \\brief A function taking a variable number of arguments\n\n>>> [ INFILL ] <<<\n\n  explicit Arity(int num_args, bool is_varargs = false)\n      : num_args(num_args), is_varargs(is_varargs) {}\n\n  /// The number of required arguments (or the minimum number for varargs\n  /// functions).\n  int num_args;\n\n  /// If true, then the num_args is the minimum number of required arguments.\n  bool is_varargs = false;\n};\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  static Arity VarArgs(int min_args = 1) { return Arity(min_args, true); }\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_4a7e19e118907d0b1c7e1505697a5b74a541c9f7/build_4a7e19e118907d0b1c7e1505697a5b74a541c9f7\nTest project /out/apache___arrow/git_repo_dir_4a7e19e118907d0b1c7e1505697a5b74a541c9f7/build_4a7e19e118907d0b1c7e1505697a5b74a541c9f7\n    Start 21: arrow-compute-internals-test\n1/1 Test #21: arrow-compute-internals-test .....***Failed    0.81 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow_compute    =   0.81 sec*proc (1 test)\nunittest         =   0.81 sec*proc (1 test)\n\nTotal Test time (real) =   0.82 sec\n\nThe following tests FAILED:\n\t 21 - arrow-compute-internals-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "4a7e19e118907d0b1c7e1505697a5b74a541c9f7___function.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nStatus EnsureDestinationValid(const FileSystemDatasetWriteOptions& options) {\n  if (options.existing_data_behavior == ExistingDataBehavior::kError) {\n    fs::FileSelector selector;\n    selector.base_dir = options.base_dir;\n    selector.recursive = true;\n    Result<std::vector<fs::FileInfo>> maybe_files =\n        options.filesystem->GetFileInfo(selector);\n    if (!maybe_files.ok()) {\n      // If the path doesn't exist then continue\n      return Status::OK();\n    }\n\n>>> [ INFILL ] <<<\n      return Status::Invalid(\n          \"Could not write to \", options.base_dir,\n          \" as the directory is not empty and existing_data_behavior is to error\");\n    }\n  }\n  return Status::OK();\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    if (maybe_files->size() > 1) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/apache___arrow/git_repo_dir_912e2bb3345536c271580e3a9e88baaffb7f2836/build_912e2bb3345536c271580e3a9e88baaffb7f2836\nTest project /out/apache___arrow/git_repo_dir_912e2bb3345536c271580e3a9e88baaffb7f2836/build_912e2bb3345536c271580e3a9e88baaffb7f2836\n    Start 36: arrow-dataset-dataset-writer-test\n1/1 Test #36: arrow-dataset-dataset-writer-test ...***Failed    0.08 sec\n\n0% tests passed, 1 tests failed out of 1\n\nLabel Time Summary:\narrow_dataset    =   0.08 sec*proc (1 test)\nunittest         =   0.08 sec*proc (1 test)\n\nTotal Test time (real) =   0.09 sec\n\nThe following tests FAILED:\n\t 36 - arrow-dataset-dataset-writer-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "912e2bb3345536c271580e3a9e88baaffb7f2836___dataset_writer.cc"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nFoldingRule CompositeConstructFeedingExtract() {\n  return [](IRContext* context, Instruction* inst,\n            const std::vector<const analysis::Constant*>&) {\n    // If the input to an OpCompositeExtract is an OpCompositeConstruct,\n    // then we can simply use the appropriate element in the construction.\n    assert(inst->opcode() == SpvOpCompositeExtract &&\n           \"Wrong opcode.  Should be OpCompositeExtract.\");\n    analysis::DefUseManager* def_use_mgr = context->get_def_use_mgr();\n    analysis::TypeManager* type_mgr = context->get_type_mgr();\n\n    // If there are no index operands, then this rule cannot do anything.\n    if (inst->NumInOperands() <= 1) {\n      return false;\n    }\n\n    uint32_t cid = inst->GetSingleWordInOperand(kExtractCompositeIdInIdx);\n    Instruction* cinst = def_use_mgr->GetDef(cid);\n\n    if (cinst->opcode() != SpvOpCompositeConstruct) {\n      return false;\n    }\n\n    std::vector<Operand> operands;\n    analysis::Type* composite_type = type_mgr->GetType(cinst->type_id());\n    if (composite_type->AsVector() == nullptr) {\n      // Get the element being extracted from the OpCompositeConstruct\n      // Since it is not a vector, it is simple to extract the single element.\n      uint32_t element_index = inst->GetSingleWordInOperand(1);\n      uint32_t element_id = cinst->GetSingleWordInOperand(element_index);\n      operands.push_back({SPV_OPERAND_TYPE_ID, {element_id}});\n\n      // Add the remaining indices for extraction.\n      for (uint32_t i = 2; i < inst->NumInOperands(); ++i) {\n        operands.push_back({SPV_OPERAND_TYPE_LITERAL_INTEGER,\n                            {inst->GetSingleWordInOperand(i)}});\n      }\n\n    } else {\n      // With vectors we have to handle the case where it is concatenating\n      // vectors.\n      assert(inst->NumInOperands() == 2 &&\n             \"Expecting a vector of scalar values.\");\n\n      uint32_t element_index = inst->GetSingleWordInOperand(1);\n      for (uint32_t construct_index = 0;\n           construct_index < cinst->NumInOperands(); ++construct_index) {\n        uint32_t element_id = cinst->GetSingleWordInOperand(construct_index);\n        Instruction* element_def = def_use_mgr->GetDef(element_id);\n        analysis::Vector* element_type =\n            type_mgr->GetType(element_def->type_id())->AsVector();\n        if (element_type) {\n          uint32_t vector_size = element_type->element_count();\n\n>>> [ INFILL ] <<<\n            // The element we want comes after this vector.\n            element_index -= vector_size;\n          } else {\n            // We want an element of this vector.\n            operands.push_back({SPV_OPERAND_TYPE_ID, {element_id}});\n            operands.push_back(\n                {SPV_OPERAND_TYPE_LITERAL_INTEGER, {element_index}});\n            break;\n          }\n        } else {\n          if (element_index == 0) {\n            // This is a scalar, and we this is the element we are extracting.\n            operands.push_back({SPV_OPERAND_TYPE_ID, {element_id}});\n            break;\n          } else {\n            // Skip over this scalar value.\n            --element_index;\n          }\n        }\n      }\n    }\n\n    // If there were no extra indices, then we have the final object.  No need\n    // to extract even more.\n    if (operands.size() == 1) {\n      inst->SetOpcode(SpvOpCopyObject);\n    }\n\n    inst->SetInOperands(std::move(operands));\n    return true;\n  };\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n          if (vector_size < element_index) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_948577c5df3a6f0d337ab417b26edcc344eb65e2/build_948577c5df3a6f0d337ab417b26edcc344eb65e2\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_948577c5df3a6f0d337ab417b26edcc344eb65e2/build_948577c5df3a6f0d337ab417b26edcc344eb65e2\n    Start 13: spirv-tools-test_opt\n1/2 Test #13: spirv-tools-test_opt .............***Exception: SegFault 24.12 sec\n    Start 15: spirv-tools-test_opt_loops\n2/2 Test #15: spirv-tools-test_opt_loops .......   Passed    4.84 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  28.97 sec\n\nThe following tests FAILED:\n\t 13 - spirv-tools-test_opt (SEGFAULT)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "948577c5df3a6f0d337ab417b26edcc344eb65e2___folding_rules.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstd::pair<bool, bool> UpgradeMemoryModel::CheckType(\n    uint32_t type_id, const std::vector<uint32_t>& indices) {\n  bool is_coherent = false;\n  bool is_volatile = false;\n  Instruction* type_inst = context()->get_def_use_mgr()->GetDef(type_id);\n  assert(type_inst->opcode() == SpvOpTypePointer);\n  Instruction* element_inst = context()->get_def_use_mgr()->GetDef(\n      type_inst->GetSingleWordInOperand(1u));\n  for (int i = (int)indices.size() - 1; i >= 0; --i) {\n    if (is_coherent && is_volatile) break;\n\n    if (element_inst->opcode() == SpvOpTypePointer) {\n      element_inst = context()->get_def_use_mgr()->GetDef(\n          element_inst->GetSingleWordInOperand(1u));\n    } else if (element_inst->opcode() == SpvOpTypeStruct) {\n      uint32_t index = indices.at(i);\n      Instruction* index_inst = context()->get_def_use_mgr()->GetDef(index);\n      assert(index_inst->opcode() == SpvOpConstant);\n      uint64_t value = GetIndexValue(index_inst);\n      is_coherent |= HasDecoration(element_inst, static_cast<uint32_t>(value),\n                                   SpvDecorationCoherent);\n      is_volatile |= HasDecoration(element_inst, static_cast<uint32_t>(value),\n                                   SpvDecorationVolatile);\n      element_inst = context()->get_def_use_mgr()->GetDef(\n          element_inst->GetSingleWordInOperand(static_cast<uint32_t>(value)));\n    } else {\n      assert(spvOpcodeIsComposite(element_inst->opcode()));\n      element_inst = context()->get_def_use_mgr()->GetDef(\n\n>>> [ INFILL ] <<<\n    }\n  }\n\n  if (!is_coherent || !is_volatile) {\n    bool remaining_coherent = false;\n    bool remaining_volatile = false;\n    std::tie(remaining_coherent, remaining_volatile) =\n        CheckAllTypes(element_inst);\n    is_coherent |= remaining_coherent;\n    is_volatile |= remaining_volatile;\n  }\n\n  return std::make_pair(is_coherent, is_volatile);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n          element_inst->GetSingleWordInOperand(1u));\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_ab3cdcaef56e9311f299eebfd044f9646100c9dc/build_ab3cdcaef56e9311f299eebfd044f9646100c9dc\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_ab3cdcaef56e9311f299eebfd044f9646100c9dc/build_ab3cdcaef56e9311f299eebfd044f9646100c9dc\n    Start 13: spirv-tools-test_opt\n1/2 Test #13: spirv-tools-test_opt .............Subprocess aborted***Exception:  15.87 sec\n    Start 15: spirv-tools-test_opt_loops\n2/2 Test #15: spirv-tools-test_opt_loops .......   Passed    4.88 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  20.76 sec\n\nThe following tests FAILED:\n\t 13 - spirv-tools-test_opt (Subprocess aborted)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ab3cdcaef56e9311f299eebfd044f9646100c9dc___upgrade_memory_model.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nSSAPropagator::PropStatus CCPPass::VisitAssignment(Instruction* instr) {\n  assert(instr->result_id() != 0 &&\n         \"Expecting an instruction that produces a result\");\n\n  // If this is a copy operation, and the RHS is a known constant, assign its\n  // value to the LHS.\n  if (instr->opcode() == SpvOpCopyObject) {\n    uint32_t rhs_id = instr->GetSingleWordInOperand(0);\n    auto it = values_.find(rhs_id);\n    if (it != values_.end()) {\n      if (IsVaryingValue(it->second)) {\n        return MarkInstructionVarying(instr);\n      } else {\n        values_[instr->result_id()] = it->second;\n        return SSAPropagator::kInteresting;\n      }\n    }\n    return SSAPropagator::kNotInteresting;\n  }\n\n  // Instructions with a RHS that cannot produce a constant are always varying.\n  if (!instr->IsFoldable()) {\n    return MarkInstructionVarying(instr);\n  }\n\n  // See if the RHS of the assignment folds into a constant value.\n  auto map_func = [this](uint32_t id) {\n    auto it = values_.find(id);\n    if (it == values_.end() || IsVaryingValue(it->second)) {\n      return id;\n    }\n    return it->second;\n  };\n  uint32_t next_id = context()->module()->IdBound();\n  Instruction* folded_inst =\n      context()->get_instruction_folder().FoldInstructionToConstant(instr,\n                                                                    map_func);\n  if (folded_inst != nullptr) {\n    // We do not want to change the body of the function by adding new\n    // instructions.  When folding we can only generate new constants.\n    assert(folded_inst->IsConstant() && \"CCP is only interested in constant.\");\n    values_[instr->result_id()] = folded_inst->result_id();\n\n    // If the folded instruction has just been created, its result ID will\n    // match the previous ID bound. When this happens, we need to indicate\n    // that CCP has modified the IR, independently of whether the constant is\n    // actually propagated. See\n    // https://github.com/KhronosGroup/SPIRV-Tools/issues/3636 for details.\n\n>>> [ INFILL ] <<<\n\n    return SSAPropagator::kInteresting;\n  }\n\n  // Conservatively mark this instruction as varying if any input id is varying.\n  if (!instr->WhileEachInId([this](uint32_t* op_id) {\n        auto iter = values_.find(*op_id);\n        if (iter != values_.end() && IsVaryingValue(iter->second)) return false;\n        return true;\n      })) {\n    return MarkInstructionVarying(instr);\n  }\n\n  // If not, see if there is a least one unknown operand to the instruction.  If\n  // so, we might be able to fold it later.\n  if (!instr->WhileEachInId([this](uint32_t* op_id) {\n        auto it = values_.find(*op_id);\n        if (it == values_.end()) return false;\n        return true;\n      })) {\n    return SSAPropagator::kNotInteresting;\n  }\n\n  // Otherwise, we will never be able to fold this instruction, so mark it\n  // varying.\n  return MarkInstructionVarying(instr);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    if (folded_inst->result_id() == next_id) created_new_constant_ = true;\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_286b3095dd187da747f85baf9ce3120580565df0/build_286b3095dd187da747f85baf9ce3120580565df0\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_286b3095dd187da747f85baf9ce3120580565df0/build_286b3095dd187da747f85baf9ce3120580565df0\n    Start 13: spirv-tools-test_opt\n1/2 Test #13: spirv-tools-test_opt .............***Failed   34.28 sec\n    Start 15: spirv-tools-test_opt_loops\n2/2 Test #15: spirv-tools-test_opt_loops .......   Passed    4.76 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  39.05 sec\n\nThe following tests FAILED:\n\t 13 - spirv-tools-test_opt (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "286b3095dd187da747f85baf9ce3120580565df0___ccp_pass.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nSSAPropagator::PropStatus CCPPass::VisitAssignment(Instruction* instr) {\n  assert(instr->result_id() != 0 &&\n         \"Expecting an instruction that produces a result\");\n\n  // If this is a copy operation, and the RHS is a known constant, assign its\n  // value to the LHS.\n  if (instr->opcode() == SpvOpCopyObject) {\n    uint32_t rhs_id = instr->GetSingleWordInOperand(0);\n    auto it = values_.find(rhs_id);\n    if (it != values_.end()) {\n      if (IsVaryingValue(it->second)) {\n        return MarkInstructionVarying(instr);\n      } else {\n        uint32_t new_val = ComputeLatticeMeet(instr, it->second);\n        values_[instr->result_id()] = new_val;\n        return IsVaryingValue(new_val) ? SSAPropagator::kVarying\n                                       : SSAPropagator::kInteresting;\n      }\n    }\n    return SSAPropagator::kNotInteresting;\n  }\n\n  // Instructions with a RHS that cannot produce a constant are always varying.\n  if (!instr->IsFoldable()) {\n    return MarkInstructionVarying(instr);\n  }\n\n  // See if the RHS of the assignment folds into a constant value.\n  auto map_func = [this](uint32_t id) {\n    auto it = values_.find(id);\n    if (it == values_.end() || IsVaryingValue(it->second)) {\n      return id;\n    }\n    return it->second;\n  };\n  Instruction* folded_inst =\n      context()->get_instruction_folder().FoldInstructionToConstant(instr,\n                                                                    map_func);\n\n  if (folded_inst != nullptr) {\n    // We do not want to change the body of the function by adding new\n    // instructions.  When folding we can only generate new constants.\n\n>>> [ INFILL ] <<<\n           \"CCP is only interested in constant values.\");\n    uint32_t new_val = ComputeLatticeMeet(instr, folded_inst->result_id());\n    values_[instr->result_id()] = new_val;\n    return IsVaryingValue(new_val) ? SSAPropagator::kVarying\n                                   : SSAPropagator::kInteresting;\n  }\n\n  // Conservatively mark this instruction as varying if any input id is varying.\n  if (!instr->WhileEachInId([this](uint32_t* op_id) {\n        auto iter = values_.find(*op_id);\n        if (iter != values_.end() && IsVaryingValue(iter->second)) return false;\n        return true;\n      })) {\n    return MarkInstructionVarying(instr);\n  }\n\n  // If not, see if there is a least one unknown operand to the instruction.  If\n  // so, we might be able to fold it later.\n  if (!instr->WhileEachInId([this](uint32_t* op_id) {\n        auto it = values_.find(*op_id);\n        if (it == values_.end()) return false;\n        return true;\n      })) {\n    return SSAPropagator::kNotInteresting;\n  }\n\n  // Otherwise, we will never be able to fold this instruction, so mark it\n  // varying.\n  return MarkInstructionVarying(instr);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    assert(folded_inst->IsConstant() &&\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_4fa1a6f9b497193e54a814112f17ab3c2cf58053/build_4fa1a6f9b497193e54a814112f17ab3c2cf58053\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_4fa1a6f9b497193e54a814112f17ab3c2cf58053/build_4fa1a6f9b497193e54a814112f17ab3c2cf58053\n    Start 18: spirv-tools-test_opt\n1/2 Test #18: spirv-tools-test_opt .............Subprocess aborted***Exception:   2.95 sec\n    Start 20: spirv-tools-test_opt_loops\n2/2 Test #20: spirv-tools-test_opt_loops .......   Passed    5.09 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =   8.04 sec\n\nThe following tests FAILED:\n\t 18 - spirv-tools-test_opt (Subprocess aborted)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "4fa1a6f9b497193e54a814112f17ab3c2cf58053___ccp_pass.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nFoldingRule VectorShuffleFeedingShuffle() {\n  return [](IRContext* context, Instruction* inst,\n            const std::vector<const analysis::Constant*>&) {\n    assert(inst->opcode() == SpvOpVectorShuffle &&\n           \"Wrong opcode.  Should be OpVectorShuffle.\");\n\n    analysis::DefUseManager* def_use_mgr = context->get_def_use_mgr();\n    analysis::TypeManager* type_mgr = context->get_type_mgr();\n\n    Instruction* feeding_shuffle_inst =\n        def_use_mgr->GetDef(inst->GetSingleWordInOperand(0));\n    analysis::Vector* op0_type =\n        type_mgr->GetType(feeding_shuffle_inst->type_id())->AsVector();\n    uint32_t op0_length = op0_type->element_count();\n\n    bool feeder_is_op0 = true;\n    if (feeding_shuffle_inst->opcode() != SpvOpVectorShuffle) {\n      feeding_shuffle_inst =\n          def_use_mgr->GetDef(inst->GetSingleWordInOperand(1));\n      feeder_is_op0 = false;\n    }\n\n    if (feeding_shuffle_inst->opcode() != SpvOpVectorShuffle) {\n      return false;\n    }\n\n    Instruction* feeder2 =\n        def_use_mgr->GetDef(feeding_shuffle_inst->GetSingleWordInOperand(0));\n    analysis::Vector* feeder_op0_type =\n        type_mgr->GetType(feeder2->type_id())->AsVector();\n    uint32_t feeder_op0_length = feeder_op0_type->element_count();\n\n    uint32_t new_feeder_id = 0;\n    std::vector<Operand> new_operands;\n    new_operands.resize(\n        2, {SPV_OPERAND_TYPE_ID, {0}});  // Place holders for vector operands.\n    const uint32_t undef_literal = 0xffffffff;\n    for (uint32_t op = 2; op < inst->NumInOperands(); ++op) {\n      uint32_t component_index = inst->GetSingleWordInOperand(op);\n\n      // Do not interpret the undefined value literal as coming from operand 1.\n      if (component_index != undef_literal &&\n          feeder_is_op0 == (component_index < op0_length)) {\n        // This component comes from the feeding_shuffle_inst.  Update\n        // |component_index| to be the index into the operand of the feeder.\n\n        // Adjust component_index to get the index into the operands of the\n        // feeding_shuffle_inst.\n        if (component_index >= op0_length) {\n          component_index -= op0_length;\n        }\n        component_index =\n            feeding_shuffle_inst->GetSingleWordInOperand(component_index + 2);\n\n        // Check if we are using a component from the first or second operand of\n        // the feeding instruction.\n        if (component_index < feeder_op0_length) {\n          if (new_feeder_id == 0) {\n            // First time through, save the id of the operand the element comes\n            // from.\n            new_feeder_id = feeding_shuffle_inst->GetSingleWordInOperand(0);\n          } else if (new_feeder_id !=\n                     feeding_shuffle_inst->GetSingleWordInOperand(0)) {\n            // We need both elements of the feeding_shuffle_inst, so we cannot\n            // fold.\n            return false;\n          }\n        } else if (component_index != undef_literal) {\n          if (new_feeder_id == 0) {\n            // First time through, save the id of the operand the element comes\n            // from.\n            new_feeder_id = feeding_shuffle_inst->GetSingleWordInOperand(1);\n          } else if (new_feeder_id !=\n                     feeding_shuffle_inst->GetSingleWordInOperand(1)) {\n            // We need both elements of the feeding_shuffle_inst, so we cannot\n            // fold.\n            return false;\n          }\n          component_index -= feeder_op0_length;\n        }\n\n        if (!feeder_is_op0 && component_index != undef_literal) {\n          component_index += op0_length;\n        }\n      }\n      new_operands.push_back(\n          {SPV_OPERAND_TYPE_LITERAL_INTEGER, {component_index}});\n    }\n\n    if (new_feeder_id == 0) {\n      analysis::ConstantManager* const_mgr = context->get_constant_mgr();\n      const analysis::Type* type =\n          type_mgr->GetType(feeding_shuffle_inst->type_id());\n      const analysis::Constant* null_const = const_mgr->GetConstant(type, {});\n      new_feeder_id =\n          const_mgr->GetDefiningInstruction(null_const, 0)->result_id();\n    }\n\n    if (feeder_is_op0) {\n      // If the size of the first vector operand changed then the indices\n      // referring to the second operand need to be adjusted.\n      Instruction* new_feeder_inst = def_use_mgr->GetDef(new_feeder_id);\n      analysis::Type* new_feeder_type =\n          type_mgr->GetType(new_feeder_inst->type_id());\n      uint32_t new_op0_size = new_feeder_type->AsVector()->element_count();\n      int32_t adjustment = op0_length - new_op0_size;\n\n      if (adjustment != 0) {\n        for (uint32_t i = 2; i < new_operands.size(); i++) {\n\n>>> [ INFILL ] <<<\n            new_operands[i].words[0] -= adjustment;\n          }\n        }\n      }\n\n      new_operands[0].words[0] = new_feeder_id;\n      new_operands[1] = inst->GetInOperand(1);\n    } else {\n      new_operands[1].words[0] = new_feeder_id;\n      new_operands[0] = inst->GetInOperand(0);\n    }\n\n    inst->SetInOperands(std::move(new_operands));\n    return true;\n  };\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n          if (inst->GetSingleWordInOperand(i) >= op0_length) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0a43a84e02245cca40ce187d1e427a5d0b4f3d13/build_0a43a84e02245cca40ce187d1e427a5d0b4f3d13\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0a43a84e02245cca40ce187d1e427a5d0b4f3d13/build_0a43a84e02245cca40ce187d1e427a5d0b4f3d13\n    Start 18: spirv-tools-test_opt\n1/2 Test #18: spirv-tools-test_opt .............***Failed   60.75 sec\n    Start 20: spirv-tools-test_opt_loops\n2/2 Test #20: spirv-tools-test_opt_loops .......   Passed    7.01 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  67.78 sec\n\nThe following tests FAILED:\n\t 18 - spirv-tools-test_opt (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "0a43a84e02245cca40ce187d1e427a5d0b4f3d13___folding_rules.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nuint32_t ValueNumberTable::AssignValueNumber(Instruction* inst) {\n  // If it already has a value return that.\n  uint32_t value = GetValueNumber(inst);\n  if (value != 0) {\n    return value;\n  }\n\n  // If the instruction has other side effects, then it must\n  // have its own value number.\n  // OpSampledImage and OpImage must remain in the same basic block in which\n  // they are used, because of this we will assign each one it own value number.\n  if (!context()->IsCombinatorInstruction(inst)) {\n    value = TakeNextValueNumber();\n    id_to_value_[inst->result_id()] = value;\n    return value;\n  }\n\n  switch (inst->opcode()) {\n    case SpvOpSampledImage:\n    case SpvOpImage:\n    case SpvOpVariable:\n      value = TakeNextValueNumber();\n      id_to_value_[inst->result_id()] = value;\n      return value;\n    default:\n      break;\n  }\n\n  // If it is a load from memory that can be modified, we have to assume the\n  // memory has been modified, so we give it a new value number.\n  //\n  // Note that this test will also handle volatile loads because they are not\n  // read only.  However, if this is ever relaxed because we analyze stores, we\n  // will have to add a new case for volatile loads.\n  if (inst->IsLoad() && !inst->IsReadOnlyLoad()) {\n    value = TakeNextValueNumber();\n    id_to_value_[inst->result_id()] = value;\n    return value;\n  }\n\n  analysis::DecorationManager* dec_mgr = context()->get_decoration_mgr();\n\n  // When we copy an object, the value numbers should be the same.\n  if (inst->opcode() == SpvOpCopyObject &&\n      dec_mgr->HaveTheSameDecorations(inst->result_id(),\n                                      inst->GetSingleWordInOperand(0))) {\n    value = GetValueNumber(inst->GetSingleWordInOperand(0));\n    if (value != 0) {\n      id_to_value_[inst->result_id()] = value;\n      return value;\n    }\n  }\n\n  // Phi nodes are a type of copy.  If all of the inputs have the same value\n  // number, then we can assign the result of the phi the same value number.\n\n>>> [ INFILL ] <<<\n      dec_mgr->HaveTheSameDecorations(inst->result_id(),\n                                      inst->GetSingleWordInOperand(0))) {\n    value = GetValueNumber(inst->GetSingleWordInOperand(0));\n    if (value != 0) {\n      for (uint32_t op = 2; op < inst->NumInOperands(); op += 2) {\n        if (value != GetValueNumber(inst->GetSingleWordInOperand(op))) {\n          value = 0;\n          break;\n        }\n      }\n      if (value != 0) {\n        id_to_value_[inst->result_id()] = value;\n        return value;\n      }\n    }\n  }\n\n  // Replace all of the operands by their value number.  The sign bit will be\n  // set to distinguish between an id and a value number.\n  Instruction value_ins(context(), inst->opcode(), inst->type_id(),\n                        inst->result_id(), {});\n  for (uint32_t o = 0; o < inst->NumInOperands(); ++o) {\n    const Operand& op = inst->GetInOperand(o);\n    if (spvIsIdType(op.type)) {\n      uint32_t id_value = op.words[0];\n      auto use_id_to_val = id_to_value_.find(id_value);\n      if (use_id_to_val != id_to_value_.end()) {\n        id_value = (1 << 31) | use_id_to_val->second;\n      }\n      value_ins.AddOperand(Operand(op.type, {id_value}));\n    } else {\n      value_ins.AddOperand(Operand(op.type, op.words));\n    }\n  }\n\n  // TODO: Implement a normal form for opcodes that commute like integer\n  // addition.  This will let us know that a+b is the same value as b+a.\n\n  // Otherwise, we check if this value has been computed before.\n  auto value_iterator = instruction_to_value_.find(value_ins);\n  if (value_iterator != instruction_to_value_.end()) {\n    value = id_to_value_[value_iterator->first.result_id()];\n    id_to_value_[inst->result_id()] = value;\n    return value;\n  }\n\n  // If not, assign it a new value number.\n  value = TakeNextValueNumber();\n  id_to_value_[inst->result_id()] = value;\n  instruction_to_value_[value_ins] = value;\n  return value;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  if (inst->opcode() == SpvOpPhi &&\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0391d0823ebfd7c37c07a54b8726cc417183a95f/build_0391d0823ebfd7c37c07a54b8726cc417183a95f\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0391d0823ebfd7c37c07a54b8726cc417183a95f/build_0391d0823ebfd7c37c07a54b8726cc417183a95f\n    Start 13: spirv-tools-test_opt\n1/2 Test #13: spirv-tools-test_opt .............Subprocess aborted***Exception:  16.33 sec\n    Start 15: spirv-tools-test_opt_loops\n2/2 Test #15: spirv-tools-test_opt_loops .......   Passed    5.51 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =  21.84 sec\n\nThe following tests FAILED:\n\t 13 - spirv-tools-test_opt (Subprocess aborted)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "0391d0823ebfd7c37c07a54b8726cc417183a95f___value_number_table.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid Differ::MatchConstants() {\n  // Bunch all of constant ids as potential matches.\n  PotentialIdMap potential_id_map;\n  auto get_result_id = [](const opt::Instruction& inst) {\n    return inst.result_id();\n  };\n  auto accept_type_ops = [](const opt::Instruction& inst) {\n    return spvOpcodeIsConstant(inst.opcode());\n  };\n\n  PoolPotentialIds(src_->types_values(), potential_id_map.src_ids,\n                   accept_type_ops, get_result_id);\n  PoolPotentialIds(dst_->types_values(), potential_id_map.dst_ids,\n                   accept_type_ops, get_result_id);\n\n  // Then match the ids.  Constants are matched exactly, except for float types\n  // that are first matched exactly, then leftovers are matched with a small\n  // error.\n  for (uint32_t flexibility = 0; flexibility < 2; ++flexibility) {\n    MatchIds(potential_id_map, [this, flexibility](\n                                   const opt::Instruction* src_inst,\n                                   const opt::Instruction* dst_inst) {\n      const SpvOp src_op = src_inst->opcode();\n      const SpvOp dst_op = dst_inst->opcode();\n\n      // Don't match if the opcode is not the same.\n      if (src_op != dst_op) {\n        return false;\n      }\n\n      switch (src_op) {\n        case SpvOpConstantTrue:\n        case SpvOpConstantFalse:\n          // true and false are unique, match them.\n          return true;\n        case SpvOpConstant:\n          return MatchOpConstant(src_inst, dst_inst, flexibility);\n        case SpvOpConstantComposite:\n          // Composite constants must match in type and value.\n          //\n          // TODO: match OpConstantNull with OpConstantComposite with all zeros\n          // at flexibility == 1\n          // TODO: match constants from structs that have been flexibly-matched.\n          if (src_inst->NumInOperandWords() != dst_inst->NumInOperandWords()) {\n            return false;\n\n>>> [ INFILL ] <<<\n          return DoesOperandMatch(src_inst->GetOperand(0),\n                                  dst_inst->GetOperand(0)) &&\n                 DoOperandsMatch(src_inst, dst_inst, 0,\n                                 src_inst->NumInOperandWords());\n        case SpvOpConstantSampler:\n          // Match sampler constants exactly.\n          // TODO: Allow flexibility in parameters to better diff shaders where\n          // the sampler param has changed.\n          assert(src_inst->NumInOperandWords() ==\n                 dst_inst->NumInOperandWords());\n          return DoOperandsMatch(src_inst, dst_inst, 0,\n                                 src_inst->NumInOperandWords());\n        case SpvOpConstantNull:\n          // Match null constants as long as the type matches.\n          return DoesOperandMatch(src_inst->GetOperand(0),\n                                  dst_inst->GetOperand(0));\n\n        case SpvOpSpecConstantTrue:\n        case SpvOpSpecConstantFalse:\n        case SpvOpSpecConstant:\n        case SpvOpSpecConstantComposite:\n        case SpvOpSpecConstantOp:\n          // Match spec constants by name if available, then by the SpecId\n          // decoration.\n          return MatchOpSpecConstant(src_inst, dst_inst);\n\n        default:\n          return false;\n      }\n    });\n  }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n          }\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0ad83f9139daf70a791560f5c72f94b0be5b8390/build_0ad83f9139daf70a791560f5c72f94b0be5b8390\nTest project /out/KhronosGroup___SPIRV-Tools/git_repo_dir_0ad83f9139daf70a791560f5c72f94b0be5b8390/build_0ad83f9139daf70a791560f5c72f94b0be5b8390\n    Start 15: spirv-tools-test_diff\n1/1 Test #15: spirv-tools-test_diff ............Subprocess aborted***Exception:   0.38 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.39 sec\n\nThe following tests FAILED:\n\t 15 - spirv-tools-test_diff (Subprocess aborted)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "0ad83f9139daf70a791560f5c72f94b0be5b8390___diff.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nbool LLParser::ParseInstructionMetadata(Instruction *Inst,\n                                        PerFunctionState *PFS) {\n  do {\n    if (Lex.getKind() != lltok::MetadataVar)\n      return TokError(\"expected metadata after comma\");\n\n    std::string Name = Lex.getStrVal();\n    unsigned MDK = M->getMDKindID(Name);\n    Lex.Lex();\n\n    MDNode *Node;\n    SMLoc Loc = Lex.getLoc();\n\n    if (ParseToken(lltok::exclaim, \"expected '!' here\"))\n      return true;\n\n    // This code is similar to that of ParseMetadataValue, however it needs to\n    // have special-case code for a forward reference; see the comments on\n    // ForwardRefInstMetadata for details. Also, MDStrings are not supported\n    // at the top level here.\n    if (Lex.getKind() == lltok::lbrace) {\n      ValID ID;\n      if (ParseMetadataListValue(ID, PFS))\n        return true;\n      assert(ID.Kind == ValID::t_MDNode);\n      if (ID.MDNodeVal->isFunctionLocal())\n\n>>> [ INFILL ] <<<\n      Inst->setMetadata(MDK, ID.MDNodeVal);\n    } else {\n      unsigned NodeID = 0;\n      if (ParseMDNodeID(Node, NodeID))\n        return true;\n      if (Node) {\n        // If we got the node, add it to the instruction.\n        Inst->setMetadata(MDK, Node);\n      } else {\n        MDRef R = { Loc, MDK, NodeID };\n        // Otherwise, remember that this should be resolved later.\n        ForwardRefInstMetadata[Inst].push_back(R);\n      }\n    }\n\n    if (MDK == LLVMContext::MD_tbaa)\n      InstsWithTBAATag.push_back(Inst);\n\n    // If this is the end of the list, we're done.\n  } while (EatIfPresent(lltok::comma));\n  return false;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        return TokError(\"unexpected function-local metadata\");\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Assembler/functionlocal-metadata-attachments.ll (1 of 1)\nTesting Time: 0.04s\n********************\nFailing Tests (1):\n    LLVM :: Assembler/functionlocal-metadata-attachments.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "545a9b0f51d105041b472f8649a8179550576c72___LLParser.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\n  uint32_t encodeCompactUnwindRegistersWithoutFrame(unsigned RegCount) const {\n    // The saved registers are numbered from 1 to 6. In order to encode the\n    // order in which they were saved, we re-number them according to their\n    // place in the register order. The re-numbering is relative to the last\n    // re-numbered register. E.g., if we have registers {6, 2, 4, 5} saved in\n    // that order:\n    //\n    //    Orig  Re-Num\n    //    ----  ------\n    //     6       6\n    //     2       2\n    //     4       3\n    //     5       3\n    //\n\n>>> [ INFILL ] <<<\n      int CUReg = getCompactUnwindRegNum(SavedRegs[i]);\n      if (CUReg == -1) return ~0U;\n      SavedRegs[i] = CUReg;\n    }\n\n    // Reverse the list.\n    std::reverse(&SavedRegs[0], &SavedRegs[CU_NUM_SAVED_REGS]);\n\n    uint32_t RenumRegs[CU_NUM_SAVED_REGS];\n    for (unsigned i = CU_NUM_SAVED_REGS - RegCount; i < CU_NUM_SAVED_REGS; ++i){\n      unsigned Countless = 0;\n      for (unsigned j = CU_NUM_SAVED_REGS - RegCount; j < i; ++j)\n        if (SavedRegs[j] < SavedRegs[i])\n          ++Countless;\n\n      RenumRegs[i] = SavedRegs[i] - Countless - 1;\n    }\n\n    // Take the renumbered values and encode them into a 10-bit number.\n    uint32_t permutationEncoding = 0;\n    switch (RegCount) {\n    case 6:\n      permutationEncoding |= 120 * RenumRegs[0] + 24 * RenumRegs[1]\n                             + 6 * RenumRegs[2] +  2 * RenumRegs[3]\n                             +     RenumRegs[4];\n      break;\n    case 5:\n      permutationEncoding |= 120 * RenumRegs[1] + 24 * RenumRegs[2]\n                             + 6 * RenumRegs[3] +  2 * RenumRegs[4]\n                             +     RenumRegs[5];\n      break;\n    case 4:\n      permutationEncoding |=  60 * RenumRegs[2] + 12 * RenumRegs[3]\n                             + 3 * RenumRegs[4] +      RenumRegs[5];\n      break;\n    case 3:\n      permutationEncoding |=  20 * RenumRegs[3] +  4 * RenumRegs[4]\n                             +     RenumRegs[5];\n      break;\n    case 2:\n      permutationEncoding |=   5 * RenumRegs[4] +      RenumRegs[5];\n      break;\n    case 1:\n      permutationEncoding |=       RenumRegs[5];\n      break;\n    }\n\n    assert((permutationEncoding & 0x3FF) == permutationEncoding &&\n           \"Invalid compact register encoding!\");\n    return permutationEncoding;\n  }\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    for (unsigned i = 0; i != CU_NUM_SAVED_REGS; ++i) {\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/compact-unwind.ll (1 of 1)\nTesting Time: 0.54s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/compact-unwind.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: CodeGen/X86/compact-unwind.ll (1 of 1)\nTesting Time: 0.54s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/compact-unwind.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "27de9b0f7001d3da9423e3e9b7b17565a38c1b51___X86AsmBackend.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid DecodeVPPERMMask(ArrayRef<uint64_t> RawMask,\n                      SmallVectorImpl<int> &ShuffleMask) {\n  assert(RawMask.size() == 16 && \"Illegal VPPERM shuffle mask size\");\n\n  // VPPERM Operation\n  // Bits[4:0] - Byte Index (0 - 31)\n  // Bits[7:5] - Permute Operation\n  //\n  // Permute Operation:\n  // 0 - Source byte (no logical operation).\n  // 1 - Invert source byte.\n  // 2 - Bit reverse of source byte.\n  // 3 - Bit reverse of inverted source byte.\n  // 4 - 00h (zero - fill).\n  // 5 - FFh (ones - fill).\n  // 6 - Most significant bit of source byte replicated in all bit positions.\n  // 7 - Invert most significant bit of source byte and replicate in all bit positions.\n  for (int i = 0, e = RawMask.size(); i < e; ++i) {\n    uint64_t M = RawMask[i];\n    if (M == (uint64_t)SM_SentinelUndef) {\n      ShuffleMask.push_back(M);\n      continue;\n    }\n\n\n>>> [ INFILL ] <<<\n    if (PermuteOp == 4) {\n      ShuffleMask.push_back(SM_SentinelZero);\n      continue;\n    }\n    if (PermuteOp != 0) {\n      ShuffleMask.clear();\n      return;\n    }\n\n    uint64_t Index = M & 0x1F;\n    ShuffleMask.push_back((int)Index);\n  }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    uint64_t PermuteOp = (M >> 5) & 0x3;\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/vector-shuffle-combining-xop.ll (1 of 1)\nTesting Time: 0.11s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/vector-shuffle-combining-xop.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "f379a6c684d47484fb1a0e47df4321fee21f4f6e___X86ShuffleDecode.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic AliasResult aliasSameBasePointerGEPs(const GEPOperator *GEP1,\n                                            uint64_t V1Size,\n                                            const GEPOperator *GEP2,\n                                            uint64_t V2Size,\n                                            const DataLayout &DL) {\n\n  assert(GEP1->getPointerOperand() == GEP2->getPointerOperand() &&\n         \"Expected GEPs with the same pointer operand\");\n\n  // Try to determine whether GEP1 and GEP2 index through arrays, into structs,\n  // such that the struct field accesses provably cannot alias.\n  // We also need at least two indices (the pointer, and the struct field).\n  if (GEP1->getNumIndices() != GEP2->getNumIndices() ||\n      GEP1->getNumIndices() < 2)\n    return MayAlias;\n\n  // If we don't know the size of the accesses through both GEPs, we can't\n  // determine whether the struct fields accessed can't alias.\n  if (V1Size == MemoryLocation::UnknownSize ||\n      V2Size == MemoryLocation::UnknownSize)\n    return MayAlias;\n\n  ConstantInt *C1 =\n      dyn_cast<ConstantInt>(GEP1->getOperand(GEP1->getNumOperands() - 1));\n  ConstantInt *C2 =\n      dyn_cast<ConstantInt>(GEP2->getOperand(GEP2->getNumOperands() - 1));\n\n  // If the last (struct) indices are constants and are equal, the other indices\n  // might be also be dynamically equal, so the GEPs can alias.\n\n>>> [ INFILL ] <<<\n    return MayAlias;\n\n  // Find the last-indexed type of the GEP, i.e., the type you'd get if\n  // you stripped the last index.\n  // On the way, look at each indexed type.  If there's something other\n  // than an array, different indices can lead to different final types.\n  SmallVector<Value *, 8> IntermediateIndices;\n\n  // Insert the first index; we don't need to check the type indexed\n  // through it as it only drops the pointer indirection.\n  assert(GEP1->getNumIndices() > 1 && \"Not enough GEP indices to examine\");\n  IntermediateIndices.push_back(GEP1->getOperand(1));\n\n  // Insert all the remaining indices but the last one.\n  // Also, check that they all index through arrays.\n  for (unsigned i = 1, e = GEP1->getNumIndices() - 1; i != e; ++i) {\n    if (!isa<ArrayType>(GetElementPtrInst::getIndexedType(\n            GEP1->getSourceElementType(), IntermediateIndices)))\n      return MayAlias;\n    IntermediateIndices.push_back(GEP1->getOperand(i + 1));\n  }\n\n  auto *Ty = GetElementPtrInst::getIndexedType(\n    GEP1->getSourceElementType(), IntermediateIndices);\n  StructType *LastIndexedStruct = dyn_cast<StructType>(Ty);\n\n  if (isa<SequentialType>(Ty)) {\n    // We know that:\n    // - both GEPs begin indexing from the exact same pointer;\n    // - the last indices in both GEPs are constants, indexing into a sequential\n    //   type (array or pointer);\n    // - both GEPs only index through arrays prior to that.\n    //\n    // Because array indices greater than the number of elements are valid in\n    // GEPs, unless we know the intermediate indices are identical between\n    // GEP1 and GEP2 we cannot guarantee that the last indexed arrays don't\n    // partially overlap. We also need to check that the loaded size matches\n    // the element size, otherwise we could still have overlap.\n    const uint64_t ElementSize =\n        DL.getTypeStoreSize(cast<SequentialType>(Ty)->getElementType());\n    if (V1Size != ElementSize || V2Size != ElementSize)\n      return MayAlias;\n\n    for (unsigned i = 0, e = GEP1->getNumIndices() - 1; i != e; ++i)\n      if (GEP1->getOperand(i + 1) != GEP2->getOperand(i + 1))\n        return MayAlias;\n\n    // Now we know that the array/pointer that GEP1 indexes into and that\n    // that GEP2 indexes into must either precisely overlap or be disjoint.\n    // Because they cannot partially overlap and because fields in an array\n    // cannot overlap, if we can prove the final indices are different between\n    // GEP1 and GEP2, we can conclude GEP1 and GEP2 don't alias.\n    \n    // If the last indices are constants, we've already checked they don't\n    // equal each other so we can exit early.\n    if (C1 && C2)\n      return NoAlias;\n    if (isKnownNonEqual(GEP1->getOperand(GEP1->getNumOperands() - 1),\n                        GEP2->getOperand(GEP2->getNumOperands() - 1),\n                        DL))\n      return NoAlias;\n    return MayAlias;\n  } else if (!LastIndexedStruct || !C1 || !C2) {\n    return MayAlias;\n  }\n\n  // We know that:\n  // - both GEPs begin indexing from the exact same pointer;\n  // - the last indices in both GEPs are constants, indexing into a struct;\n  // - said indices are different, hence, the pointed-to fields are different;\n  // - both GEPs only index through arrays prior to that.\n  //\n  // This lets us determine that the struct that GEP1 indexes into and the\n  // struct that GEP2 indexes into must either precisely overlap or be\n  // completely disjoint.  Because they cannot partially overlap, indexing into\n  // different non-overlapping fields of the struct will never alias.\n\n  // Therefore, the only remaining thing needed to show that both GEPs can't\n  // alias is that the fields are not overlapping.\n  const StructLayout *SL = DL.getStructLayout(LastIndexedStruct);\n  const uint64_t StructSize = SL->getSizeInBytes();\n  const uint64_t V1Off = SL->getElementOffset(C1->getZExtValue());\n  const uint64_t V2Off = SL->getElementOffset(C2->getZExtValue());\n\n  auto EltsDontOverlap = [StructSize](uint64_t V1Off, uint64_t V1Size,\n                                      uint64_t V2Off, uint64_t V2Size) {\n    return V1Off < V2Off && V1Off + V1Size <= V2Off &&\n           ((V2Off + V2Size <= StructSize) ||\n            (V2Off + V2Size - StructSize <= V1Off));\n  };\n\n  if (EltsDontOverlap(V1Off, V1Size, V2Off, V2Size) ||\n      EltsDontOverlap(V2Off, V2Size, V1Off, V1Size))\n    return NoAlias;\n\n  return MayAlias;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  if (C1 && C2 && C1 == C2)\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Analysis/BasicAA/struct-geps.ll (1 of 1)\nTesting Time: 0.16s\n********************\nFailing Tests (1):\n    LLVM :: Analysis/BasicAA/struct-geps.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ee20294af55e73f12829aefd0b6519cf81efe93d___BasicAliasAnalysis.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nbool MemsetRange::isProfitableToUseMemset(const DataLayout &DL) const {\n  // If we found more than 4 stores to merge or 16 bytes, use memset.\n  if (TheStores.size() >= 4 || End-Start >= 16) return true;\n\n  // If there is nothing to merge, don't do anything.\n  if (TheStores.size() < 2) return false;\n\n  // If any of the stores are a memset, then it is always good to extend the\n  // memset.\n  for (Instruction *SI : TheStores)\n    if (!isa<StoreInst>(SI))\n      return true;\n\n  // Assume that the code generator is capable of merging pairs of stores\n  // together if it wants to.\n  if (TheStores.size() == 2) return false;\n\n  // If we have fewer than 8 stores, it can still be worthwhile to do this.\n  // For example, merging 4 i8 stores into an i32 store is useful almost always.\n  // However, merging 2 32-bit stores isn't useful on a 32-bit architecture (the\n  // memset will be split into 2 32-bit stores anyway) and doing so can\n  // pessimize the llvm optimizer.\n  //\n  // Since we don't have perfect knowledge here, make some assumptions: assume\n  // the maximum GPR width is the same size as the largest legal integer\n  // size. If so, check to see whether we will end up actually reducing the\n  // number of stores used.\n  unsigned Bytes = unsigned(End-Start);\n\n>>> [ INFILL ] <<<\n  if (MaxIntSize == 0)\n    MaxIntSize = 1;\n  unsigned NumPointerStores = Bytes / MaxIntSize;\n\n  // Assume the remaining bytes if any are done a byte at a time.\n  unsigned NumByteStores = Bytes % MaxIntSize;\n\n  // If we will reduce the # stores (according to this heuristic), do the\n  // transformation.  This encourages merging 4 x i8 -> i32 and 2 x i16 -> i32\n  // etc.\n  return TheStores.size() > NumPointerStores+NumByteStores;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  unsigned MaxIntSize = DL.getLargestLegalIntTypeSize();\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/MemCpyOpt/profitable-memset.ll (1 of 1)\nTesting Time: 0.11s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/MemCpyOpt/profitable-memset.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "f28beac4196167b0ca6184625bece102b0589b03___MemCpyOptimizer.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid DwarfUnit::constructMemberDIE(DIE &Buffer, const DIDerivedType *DT) {\n  DIE &MemberDie = createAndAddDIE(DT->getTag(), Buffer);\n  StringRef Name = DT->getName();\n  if (!Name.empty())\n    addString(MemberDie, dwarf::DW_AT_name, Name);\n\n  addType(MemberDie, resolve(DT->getBaseType()));\n\n  addSourceLine(MemberDie, DT);\n\n  if (DT->getTag() == dwarf::DW_TAG_inheritance && DT->isVirtual()) {\n\n    // For C++, virtual base classes are not at fixed offset. Use following\n    // expression to extract appropriate offset from vtable.\n    // BaseAddr = ObAddr + *((*ObAddr) - Offset)\n\n    DIELoc *VBaseLocationDie = new (DIEValueAllocator) DIELoc;\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_dup);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_constu);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_udata, DT->getOffsetInBits());\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_minus);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus);\n\n    addBlock(MemberDie, dwarf::DW_AT_data_member_location, VBaseLocationDie);\n  } else {\n    uint64_t Size = DT->getSizeInBits();\n    uint64_t FieldSize = getBaseTypeSize(DD, DT);\n    uint64_t OffsetInBytes;\n\n    if (FieldSize && Size != FieldSize) {\n      // Handle bitfield, assume bytes are 8 bits.\n\n>>> [ INFILL ] <<<\n      addUInt(MemberDie, dwarf::DW_AT_bit_size, None, Size);\n\n      uint64_t Offset = DT->getOffsetInBits();\n      uint64_t Align = DT->getAlignInBits() ? DT->getAlignInBits() : FieldSize;\n      uint64_t AlignMask = ~(Align - 1);\n      // The bits from the start of the storage unit to the start of the field.\n      uint64_t StartBitOffset = Offset - (Offset & AlignMask);\n      // The byte offset of the field's aligned storage unit inside the struct.\n      OffsetInBytes = (Offset - StartBitOffset) / 8;\n\n      if (DD->getDwarfVersion() >= 4)\n        addUInt(MemberDie, dwarf::DW_AT_data_bit_offset, None, Offset);\n      else {\n        uint64_t HiMark = (Offset + FieldSize) & AlignMask;\n        uint64_t FieldOffset = (HiMark - FieldSize);\n        Offset -= FieldOffset;\n\n        // Maybe we need to work from the other end.\n        if (Asm->getDataLayout().isLittleEndian())\n          Offset = FieldSize - (Offset + Size);\n\n        addUInt(MemberDie, dwarf::DW_AT_bit_offset, None, Offset);\n        OffsetInBytes = FieldOffset >> 3;\n      }\n    } else\n      // This is not a bitfield.\n      OffsetInBytes = DT->getOffsetInBits() / 8;\n\n    if (DD->getDwarfVersion() <= 2) {\n      DIELoc *MemLocationDie = new (DIEValueAllocator) DIELoc;\n      addUInt(*MemLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus_uconst);\n      addUInt(*MemLocationDie, dwarf::DW_FORM_udata, OffsetInBytes);\n      addBlock(MemberDie, dwarf::DW_AT_data_member_location, MemLocationDie);\n    } else\n      addUInt(MemberDie, dwarf::DW_AT_data_member_location, None,\n              OffsetInBytes);\n  }\n\n  if (DT->isProtected())\n    addUInt(MemberDie, dwarf::DW_AT_accessibility, dwarf::DW_FORM_data1,\n            dwarf::DW_ACCESS_protected);\n  else if (DT->isPrivate())\n    addUInt(MemberDie, dwarf::DW_AT_accessibility, dwarf::DW_FORM_data1,\n            dwarf::DW_ACCESS_private);\n  // Otherwise C++ member and base classes are considered public.\n  else if (DT->isPublic())\n    addUInt(MemberDie, dwarf::DW_AT_accessibility, dwarf::DW_FORM_data1,\n            dwarf::DW_ACCESS_public);\n  if (DT->isVirtual())\n    addUInt(MemberDie, dwarf::DW_AT_virtuality, dwarf::DW_FORM_data1,\n            dwarf::DW_VIRTUALITY_virtual);\n\n  // Objective-C properties.\n  if (DINode *PNode = DT->getObjCProperty())\n    if (DIE *PDie = getDIE(PNode))\n      MemberDie.addValue(DIEValueAllocator, dwarf::DW_AT_APPLE_property,\n                         dwarf::DW_FORM_ref4, DIEEntry(*PDie));\n\n  if (DT->isArtificial())\n    addFlag(MemberDie, dwarf::DW_AT_artificial);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n      addUInt(MemberDie, dwarf::DW_AT_byte_size, None, FieldSize/8);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/X86/bitfields-dwarf4.ll (1 of 1)\nTesting Time: 0.06s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/bitfields-dwarf4.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "e7d833defb62c1e4a1944cbad740f540c0ab44d2___DwarfUnit.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic inline bool shouldRecordFunctionAddr(Function *F) {\n  // Check the linkage\n  if (!F->hasLinkOnceLinkage() && !F->hasLocalLinkage() &&\n      !F->hasAvailableExternallyLinkage())\n    return true;\n  // Prohibit function address recording if the function is both internal and\n  // COMDAT. This avoids the profile data variable referencing internal symbols\n  // in COMDAT.\n  if (F->hasLocalLinkage() && F->hasComdat())\n    return false;\n  // Check uses of this function for other than direct calls or invokes to it.\n\n>>> [ INFILL ] <<<\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  return F->hasAddressTaken();\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/PGOProfile/indirect_call_profile.ll (1 of 1)\nTesting Time: 0.20s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/PGOProfile/indirect_call_profile.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "7008ce3f989105a667eab5f34f7ba6fcdc1ba3d8___InstrProfiling.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nInstruction *InstCombiner::visitICmpInstWithCastAndCast(ICmpInst &ICI) {\n  const CastInst *LHSCI = cast<CastInst>(ICI.getOperand(0));\n  Value *LHSCIOp        = LHSCI->getOperand(0);\n  Type *SrcTy     = LHSCIOp->getType();\n  Type *DestTy    = LHSCI->getType();\n  Value *RHSCIOp;\n\n  // Turn icmp (ptrtoint x), (ptrtoint/c) into a compare of the input if the\n  // integer type is the same size as the pointer type.\n  if (LHSCI->getOpcode() == Instruction::PtrToInt &&\n      DL.getPointerTypeSizeInBits(SrcTy) == DestTy->getIntegerBitWidth()) {\n    Value *RHSOp = nullptr;\n    if (PtrToIntOperator *RHSC = dyn_cast<PtrToIntOperator>(ICI.getOperand(1))) {\n      Value *RHSCIOp = RHSC->getOperand(0);\n      if (RHSCIOp->getType()->getPointerAddressSpace() ==\n          LHSCIOp->getType()->getPointerAddressSpace()) {\n        RHSOp = RHSC->getOperand(0);\n        // If the pointer types don't match, insert a bitcast.\n        if (LHSCIOp->getType() != RHSOp->getType())\n          RHSOp = Builder->CreateBitCast(RHSOp, LHSCIOp->getType());\n      }\n    } else if (Constant *RHSC = dyn_cast<Constant>(ICI.getOperand(1)))\n      RHSOp = ConstantExpr::getIntToPtr(RHSC, SrcTy);\n\n    if (RHSOp)\n      return new ICmpInst(ICI.getPredicate(), LHSCIOp, RHSOp);\n  }\n\n  // The code below only handles extension cast instructions, so far.\n  // Enforce this.\n  if (LHSCI->getOpcode() != Instruction::ZExt &&\n      LHSCI->getOpcode() != Instruction::SExt)\n    return nullptr;\n\n  bool isSignedExt = LHSCI->getOpcode() == Instruction::SExt;\n  bool isSignedCmp = ICI.isSigned();\n\n  if (CastInst *CI = dyn_cast<CastInst>(ICI.getOperand(1))) {\n    // Not an extension from the same type?\n    RHSCIOp = CI->getOperand(0);\n    if (RHSCIOp->getType() != LHSCIOp->getType())\n      return nullptr;\n\n    // If the signedness of the two casts doesn't agree (i.e. one is a sext\n    // and the other is a zext), then we can't handle this.\n    if (CI->getOpcode() != LHSCI->getOpcode())\n      return nullptr;\n\n    // Deal with equality cases early.\n    if (ICI.isEquality())\n      return new ICmpInst(ICI.getPredicate(), LHSCIOp, RHSCIOp);\n\n    // A signed comparison of sign extended values simplifies into a\n    // signed comparison.\n    if (isSignedCmp && isSignedExt)\n      return new ICmpInst(ICI.getPredicate(), LHSCIOp, RHSCIOp);\n\n    // The other three cases all fold into an unsigned comparison.\n    return new ICmpInst(ICI.getUnsignedPredicate(), LHSCIOp, RHSCIOp);\n  }\n\n  // If we aren't dealing with a constant on the RHS, exit early.\n\n>>> [ INFILL ] <<<\n  if (!CI)\n    return nullptr;\n\n  // Compute the constant that would happen if we truncated to SrcTy then\n  // re-extended to DestTy.\n  Constant *Res1 = ConstantExpr::getTrunc(CI, SrcTy);\n  Constant *Res2 = ConstantExpr::getCast(LHSCI->getOpcode(), Res1, DestTy);\n\n  // If the re-extended constant didn't change...\n  if (Res2 == CI) {\n    // Deal with equality cases early.\n    if (ICI.isEquality())\n      return new ICmpInst(ICI.getPredicate(), LHSCIOp, Res1);\n\n    // A signed comparison of sign extended values simplifies into a\n    // signed comparison.\n    if (isSignedExt && isSignedCmp)\n      return new ICmpInst(ICI.getPredicate(), LHSCIOp, Res1);\n\n    // The other three cases all fold into an unsigned comparison.\n    return new ICmpInst(ICI.getUnsignedPredicate(), LHSCIOp, Res1);\n  }\n\n  // The re-extended constant changed so the constant cannot be represented\n  // in the shorter type. Consequently, we cannot emit a simple comparison.\n  // All the cases that fold to true or false will have already been handled\n  // by SimplifyICmpInst, so only deal with the tricky case.\n\n  if (isSignedCmp || !isSignedExt)\n    return nullptr;\n\n  // Evaluate the comparison for LT (we invert for GT below). LE and GE cases\n  // should have been folded away previously and not enter in here.\n\n  // We're performing an unsigned comp with a sign extended value.\n  // This is true if the input is >= 0. [aka >s -1]\n  Constant *NegOne = Constant::getAllOnesValue(SrcTy);\n  Value *Result = Builder->CreateICmpSGT(LHSCIOp, NegOne, ICI.getName());\n\n  // Finally, return the value computed.\n  if (ICI.getPredicate() == ICmpInst::ICMP_ULT)\n    return replaceInstUsesWith(ICI, Result);\n\n  assert(ICI.getPredicate() == ICmpInst::ICMP_UGT && \"ICmp should be folded!\");\n  return BinaryOperator::CreateNot(Result);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  auto *CI = dyn_cast<ConstantInt>(ICI.getOperand(1));\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/cast.ll (1 of 1)\nTesting Time: 0.24s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/cast.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Transforms/InstCombine/signed-comparison.ll (1 of 1)\nTesting Time: 0.07s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/signed-comparison.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ea8a2111690ab56450f7ab3cedcbcdbae17a87aa___InstCombineCompares.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid AsmPrinter::emitXRayTable() {\n  if (Sleds.empty())\n    return;\n\n  auto PrevSection = OutStreamer->getCurrentSectionOnly();\n  auto Fn = MF->getFunction();\n  MCSection *InstMap = nullptr;\n  MCSection *FnSledIndex = nullptr;\n  if (MF->getSubtarget().getTargetTriple().isOSBinFormatELF()) {\n\n>>> [ INFILL ] <<<\n    assert(Associated != nullptr);\n    auto Flags = ELF::SHF_WRITE | ELF::SHF_ALLOC | ELF::SHF_LINK_ORDER;\n    std::string GroupName;\n    if (Fn->hasComdat()) {\n      Flags |= ELF::SHF_GROUP;\n      GroupName = Fn->getComdat()->getName();\n    }\n\n    auto UniqueID = ++XRayFnUniqueID;\n    InstMap =\n        OutContext.getELFSection(\"xray_instr_map\", ELF::SHT_PROGBITS, Flags, 0,\n                                 GroupName, UniqueID, Associated);\n    FnSledIndex =\n        OutContext.getELFSection(\"xray_fn_idx\", ELF::SHT_PROGBITS, Flags, 0,\n                                 GroupName, UniqueID, Associated);\n  } else if (MF->getSubtarget().getTargetTriple().isOSBinFormatMachO()) {\n    InstMap = OutContext.getMachOSection(\"__DATA\", \"xray_instr_map\", 0,\n                                         SectionKind::getReadOnlyWithRel());\n    FnSledIndex = OutContext.getMachOSection(\"__DATA\", \"xray_fn_idx\", 0,\n                                             SectionKind::getReadOnlyWithRel());\n  } else {\n    llvm_unreachable(\"Unsupported target\");\n  }\n\n  auto WordSizeBytes = MAI->getCodePointerSize();\n\n  // Now we switch to the instrumentation map section. Because this is done\n  // per-function, we are able to create an index entry that will represent the\n  // range of sleds associated with a function.\n  MCSymbol *SledsStart = OutContext.createTempSymbol(\"xray_sleds_start\", true);\n  OutStreamer->SwitchSection(InstMap);\n  OutStreamer->EmitLabel(SledsStart);\n  for (const auto &Sled : Sleds)\n    Sled.emit(WordSizeBytes, OutStreamer.get(), CurrentFnSym);\n  MCSymbol *SledsEnd = OutContext.createTempSymbol(\"xray_sleds_end\", true);\n  OutStreamer->EmitLabel(SledsEnd);\n\n  // We then emit a single entry in the index per function. We use the symbols\n  // that bound the instrumentation map as the range for a specific function.\n  // Each entry here will be 2 * word size aligned, as we're writing down two\n  // pointers. This should work for both 32-bit and 64-bit platforms.\n  OutStreamer->SwitchSection(FnSledIndex);\n  OutStreamer->EmitCodeAlignment(2 * WordSizeBytes);\n  OutStreamer->EmitSymbolValue(SledsStart, WordSizeBytes, false);\n  OutStreamer->EmitSymbolValue(SledsEnd, WordSizeBytes, false);\n  OutStreamer->SwitchSection(PrevSection);\n  Sleds.clear();\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    auto Associated = dyn_cast<MCSymbolELF>(PrevSection->getBeginSymbol());\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/xray-section-group.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/xray-section-group.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "01fd7c8bd4fb3385215bff758b0bf68f179e842b___AsmPrinter.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic SDValue combineFneg(SDNode *N, SelectionDAG &DAG,\n                           const X86Subtarget &Subtarget) {\n  EVT OrigVT = N->getValueType(0);\n  SDValue Arg = isFNEG(N);\n  assert(Arg.getNode() && \"N is expected to be an FNEG node\");\n\n  EVT VT = Arg.getValueType();\n  EVT SVT = VT.getScalarType();\n  SDLoc DL(N);\n\n  // Let legalize expand this if it isn't a legal type yet.\n  if (!DAG.getTargetLoweringInfo().isTypeLegal(VT))\n    return SDValue();\n\n  // If we're negating a FMUL node on a target with FMA, then we can avoid the\n  // use of a constant by performing (-0 - A*B) instead.\n  // FIXME: Check rounding control flags as well once it becomes available.\n  if (Arg.getOpcode() == ISD::FMUL && (SVT == MVT::f32 || SVT == MVT::f64) &&\n      Arg->getFlags().hasNoSignedZeros() && Subtarget.hasAnyFMA()) {\n    SDValue Zero = DAG.getConstantFP(0.0, DL, VT);\n    SDValue NewNode = DAG.getNode(X86ISD::FNMSUB, DL, VT, Arg.getOperand(0),\n                                  Arg.getOperand(1), Zero);\n    return DAG.getBitcast(OrigVT, NewNode);\n  }\n\n  // If we're negating an FMA node, then we can adjust the\n  // instruction to include the extra negation.\n  unsigned NewOpcode = 0;\n\n>>> [ INFILL ] <<<\n    switch (Arg.getOpcode()) {\n    case ISD::FMA:             NewOpcode = X86ISD::FNMSUB;       break;\n    case X86ISD::FMSUB:        NewOpcode = X86ISD::FNMADD;       break;\n    case X86ISD::FNMADD:       NewOpcode = X86ISD::FMSUB;        break;\n    case X86ISD::FNMSUB:       NewOpcode = ISD::FMA;             break;\n    case X86ISD::FMADD_RND:    NewOpcode = X86ISD::FNMSUB_RND;   break;\n    case X86ISD::FMSUB_RND:    NewOpcode = X86ISD::FNMADD_RND;   break;\n    case X86ISD::FNMADD_RND:   NewOpcode = X86ISD::FMSUB_RND;    break;\n    case X86ISD::FNMSUB_RND:   NewOpcode = X86ISD::FMADD_RND;    break;\n    // We can't handle scalar intrinsic node here because it would only\n    // invert one element and not the whole vector. But we could try to handle\n    // a negation of the lower element only.\n    }\n  }\n  if (NewOpcode)\n    return DAG.getBitcast(OrigVT, DAG.getNode(NewOpcode, DL, VT,\n                                              Arg.getNode()->ops()));\n\n  return SDValue();\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  if (Arg.hasOneUse()) {\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/pr36553.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/pr36553.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ccfa5257a659cf1f54dd3f8518c8c42218369c41___X86ISelLowering.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nSDValue\nX86TargetLowering::LowerMemArgument(SDValue Chain, CallingConv::ID CallConv,\n                                    const SmallVectorImpl<ISD::InputArg> &Ins,\n                                    const SDLoc &dl, SelectionDAG &DAG,\n                                    const CCValAssign &VA,\n                                    MachineFrameInfo &MFI, unsigned i) const {\n  // Create the nodes corresponding to a load from this parameter slot.\n  ISD::ArgFlagsTy Flags = Ins[i].Flags;\n  bool AlwaysUseMutable = shouldGuaranteeTCO(\n      CallConv, DAG.getTarget().Options.GuaranteedTailCallOpt);\n  bool isImmutable = !AlwaysUseMutable && !Flags.isByVal();\n  EVT ValVT;\n  MVT PtrVT = getPointerTy(DAG.getDataLayout());\n\n  // If value is passed by pointer we have address passed instead of the value\n  // itself. No need to extend if the mask value and location share the same\n  // absolute size.\n  bool ExtendedInMem =\n      VA.isExtInLoc() && VA.getValVT().getScalarType() == MVT::i1 &&\n      VA.getValVT().getSizeInBits() != VA.getLocVT().getSizeInBits();\n\n  if (VA.getLocInfo() == CCValAssign::Indirect || ExtendedInMem)\n    ValVT = VA.getLocVT();\n  else\n    ValVT = VA.getValVT();\n\n  // Calculate SP offset of interrupt parameter, re-arrange the slot normally\n  // taken by a return address.\n  int Offset = 0;\n  if (CallConv == CallingConv::X86_INTR) {\n    // X86 interrupts may take one or two arguments.\n    // On the stack there will be no return address as in regular call.\n    // Offset of last argument need to be set to -4/-8 bytes.\n    // Where offset of the first argument out of two, should be set to 0 bytes.\n    Offset = (Subtarget.is64Bit() ? 8 : 4) * ((i + 1) % Ins.size() - 1);\n    if (Subtarget.is64Bit() && Ins.size() == 2) {\n      // The stack pointer needs to be realigned for 64 bit handlers with error\n      // code, so the argument offset changes by 8 bytes.\n      Offset += 8;\n    }\n  }\n\n  // FIXME: For now, all byval parameter objects are marked mutable. This can be\n  // changed with more analysis.\n  // In case of tail call optimization mark all arguments mutable. Since they\n  // could be overwritten by lowering of arguments in case of a tail call.\n  if (Flags.isByVal()) {\n    unsigned Bytes = Flags.getByValSize();\n    if (Bytes == 0) Bytes = 1; // Don't create zero-sized stack objects.\n\n>>> [ INFILL ] <<<\n    // Adjust SP offset of interrupt parameter.\n    if (CallConv == CallingConv::X86_INTR) {\n      MFI.setObjectOffset(FI, Offset);\n    }\n    return DAG.getFrameIndex(FI, PtrVT);\n  }\n\n  // This is an argument in memory. We might be able to perform copy elision.\n  if (Flags.isCopyElisionCandidate()) {\n    EVT ArgVT = Ins[i].ArgVT;\n    SDValue PartAddr;\n    if (Ins[i].PartOffset == 0) {\n      // If this is a one-part value or the first part of a multi-part value,\n      // create a stack object for the entire argument value type and return a\n      // load from our portion of it. This assumes that if the first part of an\n      // argument is in memory, the rest will also be in memory.\n      int FI = MFI.CreateFixedObject(ArgVT.getStoreSize(), VA.getLocMemOffset(),\n                                     /*Immutable=*/false);\n      PartAddr = DAG.getFrameIndex(FI, PtrVT);\n      return DAG.getLoad(\n          ValVT, dl, Chain, PartAddr,\n          MachinePointerInfo::getFixedStack(DAG.getMachineFunction(), FI));\n    } else {\n      // This is not the first piece of an argument in memory. See if there is\n      // already a fixed stack object including this offset. If so, assume it\n      // was created by the PartOffset == 0 branch above and create a load from\n      // the appropriate offset into it.\n      int64_t PartBegin = VA.getLocMemOffset();\n      int64_t PartEnd = PartBegin + ValVT.getSizeInBits() / 8;\n      int FI = MFI.getObjectIndexBegin();\n      for (; MFI.isFixedObjectIndex(FI); ++FI) {\n        int64_t ObjBegin = MFI.getObjectOffset(FI);\n        int64_t ObjEnd = ObjBegin + MFI.getObjectSize(FI);\n        if (ObjBegin <= PartBegin && PartEnd <= ObjEnd)\n          break;\n      }\n      if (MFI.isFixedObjectIndex(FI)) {\n        SDValue Addr =\n            DAG.getNode(ISD::ADD, dl, PtrVT, DAG.getFrameIndex(FI, PtrVT),\n                        DAG.getIntPtrConstant(Ins[i].PartOffset, dl));\n        return DAG.getLoad(\n            ValVT, dl, Chain, Addr,\n            MachinePointerInfo::getFixedStack(DAG.getMachineFunction(), FI,\n                                              Ins[i].PartOffset));\n      }\n    }\n  }\n\n  int FI = MFI.CreateFixedObject(ValVT.getSizeInBits() / 8,\n                                 VA.getLocMemOffset(), isImmutable);\n\n  // Set SExt or ZExt flag.\n  if (VA.getLocInfo() == CCValAssign::ZExt) {\n    MFI.setObjectZExt(FI, true);\n  } else if (VA.getLocInfo() == CCValAssign::SExt) {\n    MFI.setObjectSExt(FI, true);\n  }\n\n  // Adjust SP offset of interrupt parameter.\n  if (CallConv == CallingConv::X86_INTR) {\n    MFI.setObjectOffset(FI, Offset);\n  }\n\n  SDValue FIN = DAG.getFrameIndex(FI, PtrVT);\n  SDValue Val = DAG.getLoad(\n      ValVT, dl, Chain, FIN,\n      MachinePointerInfo::getFixedStack(DAG.getMachineFunction(), FI));\n  return ExtendedInMem\n             ? (VA.getValVT().isVector()\n                    ? DAG.getNode(ISD::SCALAR_TO_VECTOR, dl, VA.getValVT(), Val)\n                    : DAG.getNode(ISD::TRUNCATE, dl, VA.getValVT(), Val))\n             : Val;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    int FI = MFI.CreateFixedObject(Bytes, VA.getLocMemOffset(), isImmutable);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/pr30290.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/pr30290.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "4f799c027e09dafa0d1188509b256f75da3609a5___X86ISelLowering.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid SelectionDAG::ReplaceAllUsesWith(SDNode *From, const SDValue *To) {\n  if (From->getNumValues() == 1)  // Handle the simple case efficiently.\n    return ReplaceAllUsesWith(SDValue(From, 0), To[0]);\n\n  // Preserve Debug Info.\n  for (unsigned i = 0, e = From->getNumValues(); i != e; ++i)\n\n>>> [ INFILL ] <<<\n\n  // Iterate over just the existing users of From. See the comments in\n  // the ReplaceAllUsesWith above.\n  SDNode::use_iterator UI = From->use_begin(), UE = From->use_end();\n  RAUWUpdateListener Listener(*this, UI, UE);\n  while (UI != UE) {\n    SDNode *User = *UI;\n\n    // This node is about to morph, remove its old self from the CSE maps.\n    RemoveNodeFromCSEMaps(User);\n\n    // A user can appear in a use list multiple times, and when this happens the\n    // uses are usually next to each other in the list.  To help reduce the\n    // number of CSE and divergence recomputations, process all the uses of this\n    // user that we can find this way.\n    bool To_IsDivergent = false;\n    do {\n      SDUse &Use = UI.getUse();\n      const SDValue &ToOp = To[Use.getResNo()];\n      ++UI;\n      Use.set(ToOp);\n      To_IsDivergent |= ToOp->isDivergent();\n    } while (UI != UE && *UI == User);\n\n    if (To_IsDivergent != From->isDivergent())\n      updateDivergence(User);\n\n    // Now that we have modified User, add it back to the CSE maps.  If it\n    // already exists there, recursively merge the results together.\n    AddModifiedNodeToCSEMaps(User);\n  }\n\n  // If we just RAUW'd the root, take note.\n  if (From == getRoot().getNode())\n    setRoot(SDValue(To[getRoot().getResNo()]));\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    transferDbgValues(SDValue(From, i), *To);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/X86/sdag-legalize-multires.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/sdag-legalize-multires.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "16f58d18506bf3c0bf89cf24e3fea88d5a8154dc___SelectionDAG.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic bool canTransformToMemCmp(CallInst *CI, Value *Str, uint64_t Len,\n                                 const DataLayout &DL) {\n  if (!isOnlyUsedInComparisonWithZero(CI))\n    return false;\n\n  if (!isDereferenceableAndAlignedPointer(Str, 1, APInt(64, Len), DL))\n    return false;\n\n>>> [ INFILL ] <<<\n  return true;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    \n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/strcmp-memcmp.ll (1 of 1)\nTesting Time: 1.25s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/strcmp-memcmp.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "e62fc3d0b6ce923dcbc29eeb6ebc5808e6724f90___SimplifyLibCalls.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid MachineBasicBlock::print(raw_ostream &OS, ModuleSlotTracker &MST,\n                              const SlotIndexes *Indexes,\n                              bool IsStandalone) const {\n  const MachineFunction *MF = getParent();\n  if (!MF) {\n    OS << \"Can't print out MachineBasicBlock because parent MachineFunction\"\n       << \" is null\\n\";\n    return;\n  }\n\n  if (Indexes)\n    OS << Indexes->getMBBStartIdx(this) << '\\t';\n\n  OS << \"bb.\" << getNumber();\n  bool HasAttributes = false;\n  if (const auto *BB = getBasicBlock()) {\n    if (BB->hasName()) {\n      OS << \".\" << BB->getName();\n    } else {\n      HasAttributes = true;\n      OS << \" (\";\n      int Slot = MST.getLocalSlot(BB);\n      if (Slot == -1)\n        OS << \"<ir-block badref>\";\n      else\n        OS << (Twine(\"%ir-block.\") + Twine(Slot)).str();\n    }\n  }\n\n  if (hasAddressTaken()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"address-taken\";\n    HasAttributes = true;\n  }\n  if (isEHPad()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"landing-pad\";\n    HasAttributes = true;\n  }\n  if (getAlignment()) {\n    OS << (HasAttributes ? \", \" : \" (\");\n    OS << \"align \" << getAlignment();\n    HasAttributes = true;\n  }\n  if (HasAttributes)\n    OS << \")\";\n  OS << \":\\n\";\n\n  const TargetRegisterInfo *TRI = MF->getSubtarget().getRegisterInfo();\n  const MachineRegisterInfo &MRI = MF->getRegInfo();\n  const TargetInstrInfo &TII = *getParent()->getSubtarget().getInstrInfo();\n  bool HasLineAttributes = false;\n\n  // Print the preds of this block according to the CFG.\n  if (!pred_empty() && IsStandalone) {\n    if (Indexes) OS << '\\t';\n    // Don't indent(2), align with previous line attributes.\n    OS << \"; predecessors: \";\n    for (auto I = pred_begin(), E = pred_end(); I != E; ++I) {\n      if (I != pred_begin())\n        OS << \", \";\n      OS << printMBBReference(**I);\n    }\n    OS << '\\n';\n    HasLineAttributes = true;\n  }\n\n  if (!succ_empty()) {\n    if (Indexes) OS << '\\t';\n    // Print the successors\n    OS.indent(2) << \"successors: \";\n    for (auto I = succ_begin(), E = succ_end(); I != E; ++I) {\n      if (I != succ_begin())\n        OS << \", \";\n      OS << printMBBReference(**I);\n      if (!Probs.empty())\n        OS << '('\n           << format(\"0x%08\" PRIx32, getSuccProbability(I).getNumerator())\n           << ')';\n    }\n    if (!Probs.empty() && IsStandalone) {\n      // Print human readable probabilities as comments.\n      OS << \"; \";\n      for (auto I = succ_begin(), E = succ_end(); I != E; ++I) {\n\n>>> [ INFILL ] <<<\n        if (I != succ_begin())\n          OS << \", \";\n        OS << printMBBReference(**I) << '('\n           << format(\"%.2f%%\",\n                     rint(((double)BP.getNumerator() / BP.getDenominator()) *\n                          100.0 * 100.0) /\n                         100.0)\n           << ')';\n      }\n    }\n\n    OS << '\\n';\n    HasLineAttributes = true;\n  }\n\n  if (!livein_empty() && MRI.tracksLiveness()) {\n    if (Indexes) OS << '\\t';\n    OS.indent(2) << \"liveins: \";\n\n    bool First = true;\n    for (const auto &LI : liveins()) {\n      if (!First)\n        OS << \", \";\n      First = false;\n      OS << printReg(LI.PhysReg, TRI);\n      if (!LI.LaneMask.all())\n        OS << \":0x\" << PrintLaneMask(LI.LaneMask);\n    }\n    HasLineAttributes = true;\n  }\n\n  if (HasLineAttributes)\n    OS << '\\n';\n\n  bool IsInBundle = false;\n  for (const MachineInstr &MI : instrs()) {\n    if (Indexes) {\n      if (Indexes->hasIndex(MI))\n        OS << Indexes->getInstructionIndex(MI);\n      OS << '\\t';\n    }\n\n    if (IsInBundle && !MI.isInsideBundle()) {\n      OS.indent(2) << \"}\\n\";\n      IsInBundle = false;\n    }\n\n    OS.indent(IsInBundle ? 4 : 2);\n    MI.print(OS, MST, IsStandalone, /*SkipOpers=*/false, /*SkipDebugLoc=*/false,\n             /*AddNewLine=*/false, &TII);\n\n    if (!IsInBundle && MI.getFlag(MachineInstr::BundledSucc)) {\n      OS << \" {\";\n      IsInBundle = true;\n    }\n    OS << '\\n';\n  }\n\n  if (IsInBundle)\n    OS.indent(2) << \"}\\n\";\n\n  if (IrrLoopHeaderWeight && IsStandalone) {\n    if (Indexes) OS << '\\t';\n    OS.indent(2) << \"; Irreducible loop header weight: \"\n                 << IrrLoopHeaderWeight.getValue() << '\\n';\n  }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        const BranchProbability &BP = *getProbabilityIterator(I);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Other/X86/mbb-dump.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: Other/X86/mbb-dump.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "69bfa402006fa7fabe6eaf1660c9ecacb763a966___MachineBasicBlock.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid MachineLICMBase::ProcessMI(MachineInstr *MI,\n                                BitVector &PhysRegDefs,\n                                BitVector &PhysRegClobbers,\n                                SmallSet<int, 32> &StoredFIs,\n                                SmallVectorImpl<CandidateInfo> &Candidates) {\n  bool RuledOut = false;\n  bool HasNonInvariantUse = false;\n  unsigned Def = 0;\n  for (const MachineOperand &MO : MI->operands()) {\n    if (MO.isFI()) {\n      // Remember if the instruction stores to the frame index.\n      int FI = MO.getIndex();\n      if (!StoredFIs.count(FI) &&\n          MFI->isSpillSlotObjectIndex(FI) &&\n          InstructionStoresToFI(MI, FI))\n        StoredFIs.insert(FI);\n      HasNonInvariantUse = true;\n      continue;\n    }\n\n    // We can't hoist an instruction defining a physreg that is clobbered in\n    // the loop.\n    if (MO.isRegMask()) {\n      PhysRegClobbers.setBitsNotInMask(MO.getRegMask());\n      continue;\n    }\n\n    if (!MO.isReg())\n      continue;\n    unsigned Reg = MO.getReg();\n    if (!Reg)\n      continue;\n    assert(TargetRegisterInfo::isPhysicalRegister(Reg) &&\n           \"Not expecting virtual register!\");\n\n    if (!MO.isDef()) {\n      if (Reg && (PhysRegDefs.test(Reg) || PhysRegClobbers.test(Reg)))\n        // If it's using a non-loop-invariant register, then it's obviously not\n        // safe to hoist.\n        HasNonInvariantUse = true;\n      continue;\n    }\n\n    if (MO.isImplicit()) {\n      for (MCRegAliasIterator AI(Reg, TRI, true); AI.isValid(); ++AI)\n        PhysRegClobbers.set(*AI);\n      if (!MO.isDead())\n        // Non-dead implicit def? This cannot be hoisted.\n        RuledOut = true;\n      // No need to check if a dead implicit def is also defined by\n      // another instruction.\n      continue;\n    }\n\n    // FIXME: For now, avoid instructions with multiple defs, unless\n    // it's a dead implicit def.\n    if (Def)\n      RuledOut = true;\n    else\n      Def = Reg;\n\n    // If we have already seen another instruction that defines the same\n    // register, then this is not safe.  Two defs is indicated by setting a\n    // PhysRegClobbers bit.\n    for (MCRegAliasIterator AS(Reg, TRI, true); AS.isValid(); ++AS) {\n      if (PhysRegDefs.test(*AS))\n        PhysRegClobbers.set(*AS);\n\n>>> [ INFILL ] <<<\n    }\n    if (PhysRegClobbers.test(Reg))\n      // MI defined register is seen defined by another instruction in\n      // the loop, it cannot be a LICM candidate.\n      RuledOut = true;\n  }\n\n  // Only consider reloads for now and remats which do not have register\n  // operands. FIXME: Consider unfold load folding instructions.\n  if (Def && !RuledOut) {\n    int FI = std::numeric_limits<int>::min();\n    if ((!HasNonInvariantUse && IsLICMCandidate(*MI)) ||\n        (TII->isLoadFromStackSlot(*MI, FI) && MFI->isSpillSlotObjectIndex(FI)))\n      Candidates.push_back(CandidateInfo(MI, Def, FI));\n  }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n      PhysRegDefs.set(*AS);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/atomic_mi.ll (1 of 1)\nTesting Time: 4.19s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/atomic_mi.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "6934202dc04ffa5ff336a1cca9ace8dae44c29d4___MachineLICM.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid X86AvoidSFBPass::breakBlockedCopies(\n    MachineInstr *LoadInst, MachineInstr *StoreInst,\n    const DisplacementSizeMap &BlockingStoresDispSizeMap) {\n  int64_t LdDispImm = getDispOperand(LoadInst).getImm();\n  int64_t StDispImm = getDispOperand(StoreInst).getImm();\n  int64_t LMMOffset = 0;\n  int64_t SMMOffset = 0;\n\n  int64_t LdDisp1 = LdDispImm;\n  int64_t LdDisp2 = 0;\n  int64_t StDisp1 = StDispImm;\n  int64_t StDisp2 = 0;\n  unsigned Size1 = 0;\n  unsigned Size2 = 0;\n  int64_t LdStDelta = StDispImm - LdDispImm;\n\n  for (auto DispSizePair : BlockingStoresDispSizeMap) {\n    LdDisp2 = DispSizePair.first;\n    StDisp2 = DispSizePair.first + LdStDelta;\n    Size2 = DispSizePair.second;\n    // Avoid copying overlapping areas.\n    if (LdDisp2 < LdDisp1) {\n      int OverlapDelta = LdDisp1 - LdDisp2;\n      LdDisp2 += OverlapDelta;\n      StDisp2 += OverlapDelta;\n      Size2 -= OverlapDelta;\n    }\n\n>>> [ INFILL ] <<<\n\n    // Build a copy for the point until the current blocking store's\n    // displacement.\n    buildCopies(Size1, LoadInst, LdDisp1, StoreInst, StDisp1, LMMOffset,\n                SMMOffset);\n    // Build a copy for the current blocking store.\n    buildCopies(Size2, LoadInst, LdDisp2, StoreInst, StDisp2, LMMOffset + Size1,\n                SMMOffset + Size1);\n    LdDisp1 = LdDisp2 + Size2;\n    StDisp1 = StDisp2 + Size2;\n    LMMOffset += Size1 + Size2;\n    SMMOffset += Size1 + Size2;\n  }\n  unsigned Size3 = (LdDispImm + getRegSizeInBytes(LoadInst)) - LdDisp1;\n  buildCopies(Size3, LoadInst, LdDisp1, StoreInst, StDisp1, LMMOffset,\n              LMMOffset);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    Size1 = std::abs(std::abs(LdDisp2) - std::abs(LdDisp1));\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/pr39926.ll (1 of 1)\nTesting Time: 0.21s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/pr39926.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "e79477895e1af4425aecaded2881e3b3c878faf5___X86AvoidStoreForwardingBlocks.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic inline void EraseInstruction(Instruction *CI) {\n  Value *OldArg = cast<CallInst>(CI)->getArgOperand(0);\n\n  bool Unused = CI->use_empty();\n\n  if (!Unused) {\n    // Replace the return value with the argument.\n    assert((IsForwarding(GetBasicARCInstKind(CI)) ||\n            (IsNoopOnNull(GetBasicARCInstKind(CI)) &&\n\n>>> [ INFILL ] <<<\n           \"Can't delete non-forwarding instruction with users!\");\n    CI->replaceAllUsesWith(OldArg);\n  }\n\n  CI->eraseFromParent();\n\n  if (Unused)\n    RecursivelyDeleteTriviallyDeadInstructions(OldArg);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n             isa<ConstantPointerNull>(OldArg))) &&\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/ObjCARC/rv.ll (1 of 1)\nTesting Time: 0.91s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/ObjCARC/rv.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "8d5804802498efe95bb3b81d2fdab607e7d1e02b___ObjCARC.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nValue *LibCallSimplifier::optimizeMemChr(CallInst *CI, IRBuilder<> &B) {\n  Value *SrcStr = CI->getArgOperand(0);\n  ConstantInt *CharC = dyn_cast<ConstantInt>(CI->getArgOperand(1));\n  ConstantInt *LenC = dyn_cast<ConstantInt>(CI->getArgOperand(2));\n\n  // memchr(x, y, 0) -> null\n  if (LenC && LenC->isZero())\n    return Constant::getNullValue(CI->getType());\n\n  // From now on we need at least constant length and string.\n  StringRef Str;\n  if (!LenC || !getConstantStringInfo(SrcStr, Str, 0, /*TrimAtNul=*/false))\n    return nullptr;\n\n  // Truncate the string to LenC. If Str is smaller than LenC we will still only\n  // scan the string, as reading past the end of it is undefined and we can just\n  // return null if we don't find the char.\n  Str = Str.substr(0, LenC->getZExtValue());\n\n  // If the char is variable but the input str and length are not we can turn\n  // this memchr call into a simple bit field test. Of course this only works\n  // when the return value is only checked against null.\n  //\n  // It would be really nice to reuse switch lowering here but we can't change\n  // the CFG at this point.\n  //\n  // memchr(\"\\r\\n\", C, 2) != nullptr -> (C & ((1 << '\\r') | (1 << '\\n'))) != 0\n  //   after bounds check.\n  if (!CharC && !Str.empty() && isOnlyUsedInZeroEqualityComparison(CI)) {\n    unsigned char Max =\n        *std::max_element(reinterpret_cast<const unsigned char *>(Str.begin()),\n                          reinterpret_cast<const unsigned char *>(Str.end()));\n\n    // Make sure the bit field we're about to create fits in a register on the\n    // target.\n    // FIXME: On a 64 bit architecture this prevents us from using the\n    // interesting range of alpha ascii chars. We could do better by emitting\n    // two bitfields or shifting the range by 64 if no lower chars are used.\n    if (!DL.fitsInLegalInteger(Max + 1))\n      return nullptr;\n\n    // For the bit field use a power-of-2 type with at least 8 bits to avoid\n    // creating unnecessary illegal types.\n    unsigned char Width = NextPowerOf2(std::max((unsigned char)7, Max));\n\n    // Now build the bit field.\n    APInt Bitfield(Width, 0);\n    for (char C : Str)\n      Bitfield.setBit((unsigned char)C);\n    Value *BitfieldC = B.getInt(Bitfield);\n\n\n>>> [ INFILL ] <<<\n    Value *C = B.CreateZExtOrTrunc(CI->getArgOperand(1), BitfieldC->getType());\n    Value *Bounds = B.CreateICmp(ICmpInst::ICMP_ULT, C, B.getIntN(Width, Width),\n                                 \"memchr.bounds\");\n\n    // Create code that checks if the given bit is set in the field.\n    Value *Shl = B.CreateShl(B.getIntN(Width, 1ULL), C);\n    Value *Bits = B.CreateIsNotNull(B.CreateAnd(Shl, BitfieldC), \"memchr.bits\");\n\n    // Finally merge both checks and cast to pointer type. The inttoptr\n    // implicitly zexts the i1 to intptr type.\n    return B.CreateIntToPtr(B.CreateAnd(Bounds, Bits, \"memchr\"), CI->getType());\n  }\n\n  // Check if all arguments are constants.  If so, we can constant fold.\n  if (!CharC)\n    return nullptr;\n\n  // Compute the offset.\n  size_t I = Str.find(CharC->getSExtValue() & 0xFF);\n  if (I == StringRef::npos) // Didn't find the char.  memchr returns null.\n    return Constant::getNullValue(CI->getType());\n\n  // memchr(s+n,c,l) -> gep(s+n+i,c)\n  return B.CreateGEP(B.getInt8Ty(), SrcStr, B.getInt64(I), \"memchr\");\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    // First check that the bit field access is within bounds.\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/memchr.ll (1 of 1)\nTesting Time: 0.31s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/memchr.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: Transforms/InstCombine/strchr-1.ll (1 of 1)\nTesting Time: 0.12s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/strchr-1.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "d4e7a0d83ca785925a4f8c82d114377f5b156bbf___SimplifyLibCalls.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic bool FoldCondBranchOnPHI(BranchInst *BI, const DataLayout &DL,\n                                AssumptionCache *AC) {\n  BasicBlock *BB = BI->getParent();\n  PHINode *PN = dyn_cast<PHINode>(BI->getCondition());\n  // NOTE: we currently cannot transform this case if the PHI node is used\n  // outside of the block.\n  if (!PN || PN->getParent() != BB || !PN->hasOneUse())\n    return false;\n\n  // Degenerate case of a single entry PHI.\n  if (PN->getNumIncomingValues() == 1) {\n    FoldSingleEntryPHINodes(PN->getParent());\n    return true;\n  }\n\n  // Now we know that this block has multiple preds and two succs.\n  if (!BlockIsSimpleEnoughToThreadThrough(BB))\n    return false;\n\n  // Can't fold blocks that contain noduplicate or convergent calls.\n  if (any_of(*BB, [](const Instruction &I) {\n        const CallInst *CI = dyn_cast<CallInst>(&I);\n        return CI && (CI->cannotDuplicate() || CI->isConvergent());\n      }))\n    return false;\n\n  // Okay, this is a simple enough basic block.  See if any phi values are\n  // constants.\n  for (unsigned i = 0, e = PN->getNumIncomingValues(); i != e; ++i) {\n    ConstantInt *CB = dyn_cast<ConstantInt>(PN->getIncomingValue(i));\n    if (!CB || !CB->getType()->isIntegerTy(1))\n      continue;\n\n    // Okay, we now know that all edges from PredBB should be revectored to\n    // branch to RealDest.\n    BasicBlock *PredBB = PN->getIncomingBlock(i);\n    BasicBlock *RealDest = BI->getSuccessor(!CB->getZExtValue());\n\n    if (RealDest == BB)\n      continue; // Skip self loops.\n    // Skip if the predecessor's terminator is an indirect branch.\n    if (isa<IndirectBrInst>(PredBB->getTerminator()))\n      continue;\n\n    // The dest block might have PHI nodes, other predecessors and other\n    // difficult cases.  Instead of being smart about this, just insert a new\n    // block that jumps to the destination block, effectively splitting\n    // the edge we are about to create.\n    BasicBlock *EdgeBB =\n        BasicBlock::Create(BB->getContext(), RealDest->getName() + \".critedge\",\n                           RealDest->getParent(), RealDest);\n\n>>> [ INFILL ] <<<\n\n    // Update PHI nodes.\n    AddPredecessorToBlock(RealDest, EdgeBB, BB);\n\n    // BB may have instructions that are being threaded over.  Clone these\n    // instructions into EdgeBB.  We know that there will be no uses of the\n    // cloned instructions outside of EdgeBB.\n    BasicBlock::iterator InsertPt = EdgeBB->begin();\n    DenseMap<Value *, Value *> TranslateMap; // Track translated values.\n    for (BasicBlock::iterator BBI = BB->begin(); &*BBI != BI; ++BBI) {\n      if (PHINode *PN = dyn_cast<PHINode>(BBI)) {\n        TranslateMap[PN] = PN->getIncomingValueForBlock(PredBB);\n        continue;\n      }\n      // Clone the instruction.\n      Instruction *N = BBI->clone();\n      if (BBI->hasName())\n        N->setName(BBI->getName() + \".c\");\n\n      // Update operands due to translation.\n      for (User::op_iterator i = N->op_begin(), e = N->op_end(); i != e; ++i) {\n        DenseMap<Value *, Value *>::iterator PI = TranslateMap.find(*i);\n        if (PI != TranslateMap.end())\n          *i = PI->second;\n      }\n\n      // Check for trivial simplification.\n      if (Value *V = SimplifyInstruction(N, {DL, nullptr, nullptr, AC})) {\n        if (!BBI->use_empty())\n          TranslateMap[&*BBI] = V;\n        if (!N->mayHaveSideEffects()) {\n          N->deleteValue(); // Instruction folded away, don't need actual inst\n          N = nullptr;\n        }\n      } else {\n        if (!BBI->use_empty())\n          TranslateMap[&*BBI] = N;\n      }\n      // Insert the new instruction into its new home.\n      if (N)\n        EdgeBB->getInstList().insert(InsertPt, N);\n\n      // Register the new instruction with the assumption cache if necessary.\n      if (auto *II = dyn_cast_or_null<IntrinsicInst>(N))\n        if (II->getIntrinsicID() == Intrinsic::assume)\n          AC->registerAssumption(II);\n    }\n\n    // Loop over all of the edges from PredBB to BB, changing them to branch\n    // to EdgeBB instead.\n    Instruction *PredBBTI = PredBB->getTerminator();\n    for (unsigned i = 0, e = PredBBTI->getNumSuccessors(); i != e; ++i)\n      if (PredBBTI->getSuccessor(i) == BB) {\n        BB->removePredecessor(PredBB);\n        PredBBTI->setSuccessor(i, EdgeBB);\n      }\n\n    // Recurse, simplifying any other constants.\n    return FoldCondBranchOnPHI(BI, DL, AC) || true;\n  }\n\n  return false;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    BranchInst::Create(RealDest, EdgeBB);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/SimplifyCFG/debug-info-thread-phi.ll (1 of 1)\nTesting Time: 0.19s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/SimplifyCFG/debug-info-thread-phi.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "90ede5f4bfe66a0c1b3f4616bb0cc50a6629c4ac___SimplifyCFG.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nbool LoopPredication::isLoopInvariantValue(const SCEV* S) { \n  // Handling expressions which produce invariant results, but *haven't* yet\n  // been removed from the loop serves two important purposes.\n  // 1) Most importantly, it resolves a pass ordering cycle which would\n  // otherwise need us to iteration licm, loop-predication, and either\n  // loop-unswitch or loop-peeling to make progress on examples with lots of\n  // predicable range checks in a row.  (Since, in the general case,  we can't\n  // hoist the length checks until the dominating checks have been discharged\n  // as we can't prove doing so is safe.)\n  // 2) As a nice side effect, this exposes the value of peeling or unswitching\n  // much more obviously in the IR.  Otherwise, the cost modeling for other\n  // transforms would end up needing to duplicate all of this logic to model a\n  // check which becomes predictable based on a modeled peel or unswitch.\n  // \n  // The cost of doing so in the worst case is an extra fill from the stack  in\n  // the loop to materialize the loop invariant test value instead of checking\n  // against the original IV which is presumable in a register inside the loop.\n  // Such cases are presumably rare, and hint at missing oppurtunities for\n  // other passes. \n\n  if (SE->isLoopInvariant(S, L))\n    // Note: This the SCEV variant, so the original Value* may be within the\n    // loop even though SCEV has proven it is loop invariant.\n    return true;\n\n  // Handle a particular important case which SCEV doesn't yet know about which\n  // shows up in range checks on arrays with immutable lengths.  \n  // TODO: This should be sunk inside SCEV.\n  if (const SCEVUnknown *U = dyn_cast<SCEVUnknown>(S))\n    if (const auto *LI = dyn_cast<LoadInst>(U->getValue()))\n\n>>> [ INFILL ] <<<\n        if (AA->pointsToConstantMemory(LI->getOperand(0)) ||\n            LI->getMetadata(LLVMContext::MD_invariant_load) != nullptr)\n          return true;\n  return false;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n      if (LI->isUnordered())\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/LoopPredication/invariant_load.ll (1 of 1)\nTesting Time: 0.26s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/LoopPredication/invariant_load.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "adf288c5d93e60a91fe226ae2dcebad0f760a259___LoopPredication.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic void collectCallSiteParameters(const MachineInstr *CallMI,\n                                      ParamSet &Params) {\n  auto *MF = CallMI->getMF();\n  auto CalleesMap = MF->getCallSitesInfo();\n  auto CallFwdRegsInfo = CalleesMap.find(CallMI);\n\n  // There is no information for the call instruction.\n  if (CallFwdRegsInfo == CalleesMap.end())\n    return;\n\n  auto *MBB = CallMI->getParent();\n  const auto &TRI = MF->getSubtarget().getRegisterInfo();\n  const auto &TII = MF->getSubtarget().getInstrInfo();\n  const auto &TLI = MF->getSubtarget().getTargetLowering();\n\n  // Skip the call instruction.\n  auto I = std::next(CallMI->getReverseIterator());\n\n  DenseSet<unsigned> ForwardedRegWorklist;\n  // Add all the forwarding registers into the ForwardedRegWorklist.\n  for (auto ArgReg : CallFwdRegsInfo->second) {\n    bool InsertedReg = ForwardedRegWorklist.insert(ArgReg.Reg).second;\n    assert(InsertedReg && \"Single register used to forward two arguments?\");\n    (void)InsertedReg;\n  }\n\n  // We erase, from the ForwardedRegWorklist, those forwarding registers for\n  // which we successfully describe a loaded value (by using\n  // the describeLoadedValue()). For those remaining arguments in the working\n  // list, for which we do not describe a loaded value by\n  // the describeLoadedValue(), we try to generate an entry value expression\n  // for their call site value desctipion, if the call is within the entry MBB.\n  // The RegsForEntryValues maps a forwarding register into the register holding\n  // the entry value.\n  // TODO: Handle situations when call site parameter value can be described\n  // as the entry value within basic blocks other then the first one.\n  bool ShouldTryEmitEntryVals = MBB->getIterator() == MF->begin();\n  DenseMap<unsigned, unsigned> RegsForEntryValues;\n\n  // If the MI is an instruction defining one or more parameters' forwarding\n  // registers, add those defines. We can currently only describe forwarded\n  // registers that are explicitly defined, but keep track of implicit defines\n  // also to remove those registers from the work list.\n  auto getForwardingRegsDefinedByMI = [&](const MachineInstr &MI,\n                                          SmallVectorImpl<unsigned> &Explicit,\n                                          SmallVectorImpl<unsigned> &Implicit) {\n    if (MI.isDebugInstr())\n      return;\n\n    for (const MachineOperand &MO : MI.operands()) {\n      if (MO.isReg() && MO.isDef() &&\n          Register::isPhysicalRegister(MO.getReg())) {\n        for (auto FwdReg : ForwardedRegWorklist) {\n          if (TRI->regsOverlap(FwdReg, MO.getReg())) {\n            if (MO.isImplicit())\n              Implicit.push_back(FwdReg);\n            else\n              Explicit.push_back(FwdReg);\n            break;\n          }\n        }\n      }\n    }\n  };\n\n  auto finishCallSiteParam = [&](DbgValueLoc DbgLocVal, unsigned Reg) {\n    unsigned FwdReg = Reg;\n    if (ShouldTryEmitEntryVals) {\n      auto EntryValReg = RegsForEntryValues.find(Reg);\n      if (EntryValReg != RegsForEntryValues.end())\n        FwdReg = EntryValReg->second;\n    }\n\n    DbgCallSiteParam CSParm(FwdReg, DbgLocVal);\n    Params.push_back(CSParm);\n    ++NumCSParams;\n  };\n\n  // Search for a loading value in forwaring registers.\n  for (; I != MBB->rend(); ++I) {\n    // If the next instruction is a call we can not interpret parameter's\n    // forwarding registers or we finished the interpretation of all parameters.\n    if (I->isCall())\n      return;\n\n    if (ForwardedRegWorklist.empty())\n      return;\n\n    SmallVector<unsigned, 4> ExplicitFwdRegDefs;\n    SmallVector<unsigned, 4> ImplicitFwdRegDefs;\n    getForwardingRegsDefinedByMI(*I, ExplicitFwdRegDefs, ImplicitFwdRegDefs);\n    if (ExplicitFwdRegDefs.empty() && ImplicitFwdRegDefs.empty())\n      continue;\n\n    // If the MI clobbers more then one forwarding register we must remove\n    // all of them from the working list.\n    for (auto Reg : concat<unsigned>(ExplicitFwdRegDefs, ImplicitFwdRegDefs))\n      ForwardedRegWorklist.erase(Reg);\n\n    // The describeLoadedValue() hook currently does not have any information\n    // about which register it should describe in case of multiple defines, so\n    // for now we only handle instructions where a forwarded register is (at\n    // least partially) defined by the instruction's single explicit define.\n    if (I->getNumExplicitDefs() != 1 || ExplicitFwdRegDefs.empty())\n      continue;\n    unsigned Reg = ExplicitFwdRegDefs[0];\n\n    if (auto ParamValue = TII->describeLoadedValue(*I)) {\n      if (ParamValue->first.isImm()) {\n\n>>> [ INFILL ] <<<\n        DbgValueLoc DbgLocVal(ParamValue->second, Val);\n        finishCallSiteParam(DbgLocVal, Reg);\n      } else if (ParamValue->first.isReg()) {\n        Register RegLoc = ParamValue->first.getReg();\n        unsigned SP = TLI->getStackPointerRegisterToSaveRestore();\n        Register FP = TRI->getFrameRegister(*MF);\n        bool IsSPorFP = (RegLoc == SP) || (RegLoc == FP);\n        if (TRI->isCalleeSavedPhysReg(RegLoc, *MF) || IsSPorFP) {\n          DbgValueLoc DbgLocVal(ParamValue->second,\n                                MachineLocation(RegLoc,\n                                                /*IsIndirect=*/IsSPorFP));\n          finishCallSiteParam(DbgLocVal, Reg);\n        } else if (ShouldTryEmitEntryVals) {\n          ForwardedRegWorklist.insert(RegLoc);\n          RegsForEntryValues[RegLoc] = Reg;\n        }\n      }\n    }\n  }\n\n  // Emit the call site parameter's value as an entry value.\n  if (ShouldTryEmitEntryVals) {\n    // Create an entry value expression where the expression following\n    // the 'DW_OP_entry_value' will be the size of 1 (a register operation).\n    DIExpression *EntryExpr = DIExpression::get(MF->getFunction().getContext(),\n                                                {dwarf::DW_OP_entry_value, 1});\n    for (auto RegEntry : ForwardedRegWorklist) {\n      unsigned FwdReg = RegEntry;\n      auto EntryValReg = RegsForEntryValues.find(RegEntry);\n        if (EntryValReg != RegsForEntryValues.end())\n          FwdReg = EntryValReg->second;\n\n      DbgValueLoc DbgLocVal(EntryExpr, MachineLocation(RegEntry));\n      DbgCallSiteParam CSParm(FwdReg, DbgLocVal);\n      Params.push_back(CSParm);\n      ++NumCSParams;\n    }\n  }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        unsigned Val = ParamValue->first.getImm();\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/X86/dbgcall-site-64-bit-imms.ll (1 of 1)\nTesting Time: 0.76s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/dbgcall-site-64-bit-imms.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "8535bed79504ffe3ed7f2de8c158a17e79e54736___DwarfDebug.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nint X86FrameLowering::getWin64EHFrameIndexRef(const MachineFunction &MF,\n                                              int FI, unsigned &FrameReg) const {\n  const MachineFrameInfo &MFI = MF.getFrameInfo();\n  const X86MachineFunctionInfo *X86FI = MF.getInfo<X86MachineFunctionInfo>();\n  const auto& WinEHXMMSlotInfo = X86FI->getWinEHXMMSlotInfo();\n  const auto it = WinEHXMMSlotInfo.find(FI);\n\n  if (it == WinEHXMMSlotInfo.end())\n    return getFrameIndexReference(MF, FI, FrameReg);\n\n  FrameReg = TRI->getStackRegister();\n\n>>> [ INFILL ] <<<\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  return alignTo(MFI.getMaxCallFrameSize(), getStackAlignment()) + it->second;\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/win64-funclet-savexmm.ll (1 of 1)\n\nTesting Time: 0.50s\n********************\nFailing Tests (1):\n    LLVM :: CodeGen/X86/win64-funclet-savexmm.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "8723b95cefa4f2a891c2b496dca79f1734cf1d1c___X86FrameLowering.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nPreservedAnalyses JumpThreadingPass::run(Function &F,\n                                         FunctionAnalysisManager &AM) {\n  auto &TLI = AM.getResult<TargetLibraryAnalysis>(F);\n  // Get DT analysis before LVI. When LVI is initialized it conditionally adds\n  // DT if it's available.\n  auto &DT = AM.getResult<DominatorTreeAnalysis>(F);\n  auto &LVI = AM.getResult<LazyValueAnalysis>(F);\n  auto &AA = AM.getResult<AAManager>(F);\n  DomTreeUpdater DTU(DT, DomTreeUpdater::UpdateStrategy::Lazy);\n\n  std::unique_ptr<BlockFrequencyInfo> BFI;\n  std::unique_ptr<BranchProbabilityInfo> BPI;\n  if (F.hasProfileData()) {\n    LoopInfo LI{DominatorTree(F)};\n    BPI.reset(new BranchProbabilityInfo(F, LI, &TLI));\n    BFI.reset(new BlockFrequencyInfo(F, *BPI, LI));\n  }\n\n\n>>> [ INFILL ] <<<\n                         std::move(BFI), std::move(BPI));\n\n  if (!Changed)\n    return PreservedAnalyses::all();\n  PreservedAnalyses PA;\n  PA.preserve<GlobalsAA>();\n  PA.preserve<DominatorTreeAnalysis>();\n  PA.preserve<LazyValueAnalysis>();\n  return PA;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  bool Changed = runImpl(F, &TLI, &LVI, &AA, &DTU, HasProfileData,\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/JumpThreading/update-edge-weight.ll (1 of 1)\n\nTesting Time: 0.37s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/JumpThreading/update-edge-weight.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "1a58be2ac58ca078c91c9d1700220d88091b256f___JumpThreading.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid FunctionImportGlobalProcessing::processGlobalForThinLTO(GlobalValue &GV) {\n\n  ValueInfo VI;\n  if (GV.hasName()) {\n    VI = ImportIndex.getValueInfo(GV.getGUID());\n    // Set synthetic function entry counts.\n    if (VI && ImportIndex.hasSyntheticEntryCounts()) {\n      if (Function *F = dyn_cast<Function>(&GV)) {\n        if (!F->isDeclaration()) {\n          for (auto &S : VI.getSummaryList()) {\n            auto *FS = cast<FunctionSummary>(S->getBaseObject());\n            if (FS->modulePath() == M.getModuleIdentifier()) {\n              F->setEntryCount(Function::ProfileCount(FS->entryCount(),\n                                                      Function::PCT_Synthetic));\n              break;\n            }\n          }\n        }\n      }\n    }\n    // Check the summaries to see if the symbol gets resolved to a known local\n    // definition.\n    if (VI && VI.isDSOLocal()) {\n      GV.setDSOLocal(true);\n      if (GV.hasDLLImportStorageClass())\n        GV.setDLLStorageClass(GlobalValue::DefaultStorageClass);\n    }\n  }\n\n  // We should always have a ValueInfo (i.e. GV in index) for definitions when\n  // we are exporting, and also when importing that value.\n  assert(VI || GV.isDeclaration() ||\n         (isPerformingImport() && !doImportAsDefinition(&GV)));\n\n  // Mark read/write-only variables which can be imported with specific\n  // attribute. We can't internalize them now because IRMover will fail\n  // to link variable definitions to their external declarations during\n  // ThinLTO import. We'll internalize read-only variables later, after\n  // import is finished. See internalizeGVsAfterImport.\n  //\n  // If global value dead stripping is not enabled in summary then\n  // propagateConstants hasn't been run. We can't internalize GV\n  // in such case.\n  if (!GV.isDeclaration() && VI && ImportIndex.withAttributePropagation()) {\n    if (GlobalVariable *V = dyn_cast<GlobalVariable>(&GV)) {\n      // We can have more than one local with the same GUID, in the case of\n      // same-named locals in different but same-named source files that were\n      // compiled in their respective directories (so the source file name\n      // and resulting GUID is the same). Find the one in this module.\n      // Handle the case where there is no summary found in this module. That\n      // can happen in the distributed ThinLTO backend, because the index only\n      // contains summaries from the source modules if they are being imported.\n      // We might have a non-null VI and get here even in that case if the name\n      // matches one in this module (e.g. weak or appending linkage).\n      auto *GVS = dyn_cast_or_null<GlobalVarSummary>(\n          ImportIndex.findSummaryInModule(VI, M.getModuleIdentifier()));\n      if (GVS &&\n          (ImportIndex.isReadOnly(GVS) || ImportIndex.isWriteOnly(GVS))) {\n        V->addAttribute(\"thinlto-internalize\");\n        // Objects referenced by writeonly GV initializer should not be\n        // promoted, because there is no any kind of read access to them\n        // on behalf of this writeonly GV. To avoid promotion we convert\n        // GV initializer to 'zeroinitializer'. This effectively drops\n        // references in IR module (not in combined index), so we can\n        // ignore them when computing import. We do not export references\n        // of writeonly object. See computeImportForReferencedGlobals\n\n>>> [ INFILL ] <<<\n          V->setInitializer(Constant::getNullValue(V->getValueType()));\n      }\n    }\n  }\n\n  if (GV.hasLocalLinkage() && shouldPromoteLocalToGlobal(&GV, VI)) {\n    // Save the original name string before we rename GV below.\n    auto Name = GV.getName().str();\n    GV.setName(getPromotedName(&GV));\n    GV.setLinkage(getLinkage(&GV, /* DoPromote */ true));\n    assert(!GV.hasLocalLinkage());\n    GV.setVisibility(GlobalValue::HiddenVisibility);\n\n    // If we are renaming a COMDAT leader, ensure that we record the COMDAT\n    // for later renaming as well. This is required for COFF.\n    if (const auto *C = GV.getComdat())\n      if (C->getName() == Name)\n        RenamedComdats.try_emplace(C, M.getOrInsertComdat(GV.getName()));\n  } else\n    GV.setLinkage(getLinkage(&GV, /* DoPromote */ false));\n\n  // Remove functions imported as available externally defs from comdats,\n  // as this is a declaration for the linker, and will be dropped eventually.\n  // It is illegal for comdats to contain declarations.\n  auto *GO = dyn_cast<GlobalObject>(&GV);\n  if (GO && GO->isDeclarationForLinker() && GO->hasComdat()) {\n    // The IRMover should not have placed any imported declarations in\n    // a comdat, so the only declaration that should be in a comdat\n    // at this point would be a definition imported as available_externally.\n    assert(GO->hasAvailableExternallyLinkage() &&\n           \"Expected comdat on definition (possibly available external)\");\n    GO->setComdat(nullptr);\n  }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        if (ImportIndex.isWriteOnly(GVS) && GVS->refs().size())\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: ThinLTO/X86/index-const-prop2.ll (1 of 1)\n\nTesting Time: 1.09s\n********************\nFailing Tests (1):\n    LLVM :: ThinLTO/X86/index-const-prop2.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: ThinLTO/X86/writeonly-with-refs.ll (1 of 1)\n\nTesting Time: 0.58s\n********************\nFailing Tests (1):\n    LLVM :: ThinLTO/X86/writeonly-with-refs.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: ThinLTO/X86/writeonly.ll (1 of 1)\n\nTesting Time: 0.40s\n********************\nFailing Tests (1):\n    LLVM :: ThinLTO/X86/writeonly.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: ThinLTO/X86/writeonly2.ll (1 of 1)\n\nTesting Time: 0.44s\n********************\nFailing Tests (1):\n    LLVM :: ThinLTO/X86/writeonly2.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "e420c0c78eb0700989c8ba80e845b6306d66bb5f___FunctionImportUtils.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid llvm::calculateDbgEntityHistory(const MachineFunction *MF,\n                                     const TargetRegisterInfo *TRI,\n                                     DbgValueHistoryMap &DbgValues,\n                                     DbgLabelInstrMap &DbgLabels) {\n  const TargetLowering *TLI = MF->getSubtarget().getTargetLowering();\n  unsigned SP = TLI->getStackPointerRegisterToSaveRestore();\n  Register FrameReg = TRI->getFrameRegister(*MF);\n  RegDescribedVarsMap RegVars;\n  DbgValueEntriesMap LiveEntries;\n  for (const auto &MBB : *MF) {\n    for (const auto &MI : MBB) {\n      if (MI.isDebugValue()) {\n        assert(MI.getNumOperands() > 1 && \"Invalid DBG_VALUE instruction!\");\n        // Use the base variable (without any DW_OP_piece expressions)\n        // as index into History. The full variables including the\n        // piece expressions are attached to the MI.\n        const DILocalVariable *RawVar = MI.getDebugVariable();\n        assert(RawVar->isValidLocationForIntrinsic(MI.getDebugLoc()) &&\n               \"Expected inlined-at fields to agree\");\n        InlinedEntity Var(RawVar, MI.getDebugLoc()->getInlinedAt());\n\n        handleNewDebugValue(Var, MI, RegVars, LiveEntries, DbgValues);\n      } else if (MI.isDebugLabel()) {\n        assert(MI.getNumOperands() == 1 && \"Invalid DBG_LABEL instruction!\");\n        const DILabel *RawLabel = MI.getDebugLabel();\n        assert(RawLabel->isValidLocationForIntrinsic(MI.getDebugLoc()) &&\n            \"Expected inlined-at fields to agree\");\n        // When collecting debug information for labels, there is no MCSymbol\n        // generated for it. So, we keep MachineInstr in DbgLabels in order\n        // to query MCSymbol afterward.\n        InlinedEntity L(RawLabel, MI.getDebugLoc()->getInlinedAt());\n        DbgLabels.addInstr(L, MI);\n      }\n\n\n>>> [ INFILL ] <<<\n        continue;\n\n      // Not a DBG_VALUE instruction. It may clobber registers which describe\n      // some variables.\n      for (const MachineOperand &MO : MI.operands()) {\n        if (MO.isReg() && MO.isDef() && MO.getReg()) {\n          // Ignore call instructions that claim to clobber SP. The AArch64\n          // backend does this for aggregate function arguments.\n          if (MI.isCall() && MO.getReg() == SP)\n            continue;\n          // If this is a virtual register, only clobber it since it doesn't\n          // have aliases.\n          if (Register::isVirtualRegister(MO.getReg()))\n            clobberRegisterUses(RegVars, MO.getReg(), DbgValues, LiveEntries,\n                                MI);\n          // If this is a register def operand, it may end a debug value\n          // range. Ignore frame-register defs in the epilogue and prologue,\n          // we expect debuggers to understand that stack-locations are\n          // invalid outside of the function body.\n          else if (MO.getReg() != FrameReg ||\n                   (!MI.getFlag(MachineInstr::FrameDestroy) &&\n                   !MI.getFlag(MachineInstr::FrameSetup))) {\n            for (MCRegAliasIterator AI(MO.getReg(), TRI, true); AI.isValid();\n                 ++AI)\n              clobberRegisterUses(RegVars, *AI, DbgValues, LiveEntries, MI);\n          }\n        } else if (MO.isRegMask()) {\n          // If this is a register mask operand, clobber all debug values in\n          // non-CSRs.\n          SmallVector<unsigned, 32> RegsToClobber;\n          // Don't consider SP to be clobbered by register masks.\n          for (auto It : RegVars) {\n            unsigned int Reg = It.first;\n            if (Reg != SP && Register::isPhysicalRegister(Reg) &&\n                MO.clobbersPhysReg(Reg))\n              RegsToClobber.push_back(Reg);\n          }\n\n          for (unsigned Reg : RegsToClobber) {\n            clobberRegisterUses(RegVars, Reg, DbgValues, LiveEntries, MI);\n          }\n        }\n      } // End MO loop.\n    }   // End instr loop.\n\n    // Make sure locations for all variables are valid only until the end of\n    // the basic block (unless it's the last basic block, in which case let\n    // their liveness run off to the end of the function).\n    if (!MBB.empty() && &MBB != &MF->back()) {\n      // Iterate over all variables that have open debug values.\n      for (auto &Pair : LiveEntries) {\n        if (Pair.second.empty())\n          continue;\n\n        // Create a clobbering entry.\n        EntryIndex ClobIdx = DbgValues.startClobber(Pair.first, MBB.back());\n\n        // End all entries.\n        for (EntryIndex Idx : Pair.second) {\n          DbgValueHistoryMap::Entry &Ent = DbgValues.getEntry(Pair.first, Idx);\n          assert(Ent.isDbgValue() && !Ent.isClosed());\n          Ent.endEntry(ClobIdx);\n        }\n      }\n\n      LiveEntries.clear();\n      RegVars.clear();\n    }\n  }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n      if (MI.isDebugInstr())\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/COFF/pieces.ll (1 of 1)\n\nTesting Time: 0.80s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/COFF/pieces.ll\n\n  Unexpected Failures: 1\nFAIL: LLVM :: DebugInfo/X86/pieces-3.ll (1 of 1)\n\nTesting Time: 0.53s\n********************\nFailing Tests (1):\n    LLVM :: DebugInfo/X86/pieces-3.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "453dc4d7ec5a3c3d8f54fc358bc5673834516d48___DbgEntityHistoryCalculator.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nInstruction *InstCombiner::commonCastTransforms(CastInst &CI) {\n  Value *Src = CI.getOperand(0);\n\n  // Try to eliminate a cast of a cast.\n  if (auto *CSrc = dyn_cast<CastInst>(Src)) {   // A->B->C cast\n    if (Instruction::CastOps NewOpc = isEliminableCastPair(CSrc, &CI)) {\n      // The first cast (CSrc) is eliminable so we need to fix up or replace\n      // the second cast (CI). CSrc will then have a good chance of being dead.\n      auto *Ty = CI.getType();\n      auto *Res = CastInst::Create(NewOpc, CSrc->getOperand(0), Ty);\n      // Point debug users of the dying cast to the new one.\n      if (CSrc->hasOneUse())\n        replaceAllDbgUsesWith(*CSrc, *Res, CI, DT);\n      return Res;\n    }\n  }\n\n  if (auto *Sel = dyn_cast<SelectInst>(Src)) {\n    // We are casting a select. Try to fold the cast into the select if the\n    // select does not have a compare instruction with matching operand types\n    // or the select is likely better done in a narrow type.\n    // Creating a select with operands that are different sizes than its\n    // condition may inhibit other folds and lead to worse codegen.\n    auto *Cmp = dyn_cast<CmpInst>(Sel->getCondition());\n    if (!Cmp || Cmp->getOperand(0)->getType() != Sel->getType() ||\n        (CI.getOpcode() == Instruction::Trunc &&\n         shouldChangeType(CI.getSrcTy(), CI.getType()))) {\n      if (Instruction *NV = FoldOpIntoSelect(CI, Sel)) {\n        replaceAllDbgUsesWith(*Sel, *NV, CI, DT);\n        return NV;\n      }\n    }\n  }\n\n  // If we are casting a PHI, then fold the cast into the PHI.\n  if (auto *PN = dyn_cast<PHINode>(Src)) {\n    // Don't do this if it would create a PHI node with an illegal type from a\n    // legal type.\n    if (!Src->getType()->isIntegerTy() || !CI.getType()->isIntegerTy() ||\n\n>>> [ INFILL ] <<<\n      if (Instruction *NV = foldOpIntoPhi(CI, PN))\n        return NV;\n  }\n\n  return nullptr;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        shouldChangeType(CI.getType(), Src->getType()))\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/cast_phi.ll (1 of 1)\n\nTesting Time: 1.03s\n********************\nFailing Tests (1):\n    LLVM :: Transforms/InstCombine/cast_phi.ll\n\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "0cf0be993c382f15c277de6d0db8be6a236c7c50___InstCombineCasts.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic Value *SimplifyOrInst(Value *Op0, Value *Op1, const SimplifyQuery &Q,\n                             unsigned MaxRecurse) {\n  if (Constant *C = foldOrCommuteConstant(Instruction::Or, Op0, Op1, Q))\n    return C;\n\n  // X | undef -> -1\n  // X | -1 = -1\n  // Do not return Op1 because it may contain undef elements if it's a vector.\n  if (match(Op1, m_Undef()) || match(Op1, m_AllOnes()))\n    return Constant::getAllOnesValue(Op0->getType());\n\n  // X | X = X\n  // X | 0 = X\n  if (Op0 == Op1 || match(Op1, m_Zero()))\n    return Op0;\n\n  // A | ~A  =  ~A | A  =  -1\n  if (match(Op0, m_Not(m_Specific(Op1))) ||\n      match(Op1, m_Not(m_Specific(Op0))))\n    return Constant::getAllOnesValue(Op0->getType());\n\n  // (A & ?) | A = A\n  if (match(Op0, m_c_And(m_Specific(Op1), m_Value())))\n    return Op1;\n\n  // A | (A & ?) = A\n  if (match(Op1, m_c_And(m_Specific(Op0), m_Value())))\n    return Op0;\n\n  // ~(A & ?) | A = -1\n  if (match(Op0, m_Not(m_c_And(m_Specific(Op1), m_Value()))))\n    return Constant::getAllOnesValue(Op1->getType());\n\n  // A | ~(A & ?) = -1\n\n>>> [ INFILL ] <<<\n    return Constant::getAllOnesValue(Op0->getType());\n\n  Value *A, *B;\n  // (A & ~B) | (A ^ B) -> (A ^ B)\n  // (~B & A) | (A ^ B) -> (A ^ B)\n  // (A & ~B) | (B ^ A) -> (B ^ A)\n  // (~B & A) | (B ^ A) -> (B ^ A)\n  if (match(Op1, m_Xor(m_Value(A), m_Value(B))) &&\n      (match(Op0, m_c_And(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op0, m_c_And(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op1;\n\n  // Commute the 'or' operands.\n  // (A ^ B) | (A & ~B) -> (A ^ B)\n  // (A ^ B) | (~B & A) -> (A ^ B)\n  // (B ^ A) | (A & ~B) -> (B ^ A)\n  // (B ^ A) | (~B & A) -> (B ^ A)\n  if (match(Op0, m_Xor(m_Value(A), m_Value(B))) &&\n      (match(Op1, m_c_And(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op1, m_c_And(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op0;\n\n  // (A & B) | (~A ^ B) -> (~A ^ B)\n  // (B & A) | (~A ^ B) -> (~A ^ B)\n  // (A & B) | (B ^ ~A) -> (B ^ ~A)\n  // (B & A) | (B ^ ~A) -> (B ^ ~A)\n  if (match(Op0, m_And(m_Value(A), m_Value(B))) &&\n      (match(Op1, m_c_Xor(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op1, m_c_Xor(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op1;\n\n  // (~A ^ B) | (A & B) -> (~A ^ B)\n  // (~A ^ B) | (B & A) -> (~A ^ B)\n  // (B ^ ~A) | (A & B) -> (B ^ ~A)\n  // (B ^ ~A) | (B & A) -> (B ^ ~A)\n  if (match(Op1, m_And(m_Value(A), m_Value(B))) &&\n      (match(Op0, m_c_Xor(m_Specific(A), m_Not(m_Specific(B)))) ||\n       match(Op0, m_c_Xor(m_Not(m_Specific(A)), m_Specific(B)))))\n    return Op0;\n\n  if (Value *V = simplifyAndOrOfCmps(Q, Op0, Op1, false))\n    return V;\n\n  // If we have a multiplication overflow check that is being 'and'ed with a\n  // check that one of the multipliers is not zero, we can omit the 'and', and\n  // only keep the overflow check.\n  if (Value *V = omitCheckForZeroBeforeInvertedMulWithOverflow(Op0, Op1))\n    return V;\n  if (Value *V = omitCheckForZeroBeforeInvertedMulWithOverflow(Op1, Op0))\n    return V;\n\n  // Try some generic simplifications for associative operations.\n  if (Value *V = SimplifyAssociativeBinOp(Instruction::Or, Op0, Op1, Q,\n                                          MaxRecurse))\n    return V;\n\n  // Or distributes over And.  Try some generic simplifications based on this.\n  if (Value *V = ExpandBinOp(Instruction::Or, Op0, Op1, Instruction::And, Q,\n                             MaxRecurse))\n    return V;\n\n  // If the operation is with the result of a select instruction, check whether\n  // operating on either branch of the select always yields the same value.\n  if (isa<SelectInst>(Op0) || isa<SelectInst>(Op1))\n    if (Value *V = ThreadBinOpOverSelect(Instruction::Or, Op0, Op1, Q,\n                                         MaxRecurse))\n      return V;\n\n  // (A & C1)|(B & C2)\n  const APInt *C1, *C2;\n  if (match(Op0, m_And(m_Value(A), m_APInt(C1))) &&\n      match(Op1, m_And(m_Value(B), m_APInt(C2)))) {\n    if (*C1 == ~*C2) {\n      // (A & C1)|(B & C2)\n      // If we have: ((V + N) & C1) | (V & C2)\n      // .. and C2 = ~C1 and C2 is 0+1+ and (N & C2) == 0\n      // replace with V+N.\n      Value *N;\n      if (C2->isMask() && // C2 == 0+1+\n          match(A, m_c_Add(m_Specific(B), m_Value(N)))) {\n        // Add commutes, try both ways.\n        if (MaskedValueIsZero(N, *C2, Q.DL, 0, Q.AC, Q.CxtI, Q.DT))\n          return A;\n      }\n      // Or commutes, try both ways.\n      if (C1->isMask() &&\n          match(B, m_c_Add(m_Specific(A), m_Value(N)))) {\n        // Add commutes, try both ways.\n        if (MaskedValueIsZero(N, *C1, Q.DL, 0, Q.AC, Q.CxtI, Q.DT))\n          return B;\n      }\n    }\n  }\n\n  // If the operation is with the result of a phi instruction, check whether\n  // operating on all incoming values of the phi always yields the same value.\n  if (isa<PHINode>(Op0) || isa<PHINode>(Op1))\n    if (Value *V = ThreadBinOpOverPHI(Instruction::Or, Op0, Op1, Q, MaxRecurse))\n      return V;\n\n  return nullptr;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  if (match(Op1, m_Not(m_c_And(m_Specific(Op1), m_Value()))))\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstSimplify/or.ll (1 of 1)\n********************\nFailing Tests (1):\n  LLVM :: Transforms/InstSimplify/or.ll\n\n\nTesting Time: 1.43s\n  Unexpected Failures: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "a9fe69c359de653015c39e413e48630d069abe27___InstructionSimplify.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nRetainedKnowledge\nllvm::getKnowledgeForValue(const Value *V,\n                           ArrayRef<Attribute::AttrKind> AttrKinds,\n                           AssumptionCache *AC,\n                           function_ref<bool(RetainedKnowledge, Instruction *,\n                                             const CallBase::BundleOpInfo *)>\n                               Filter) {\n  NumAssumeQueries++;\n  if (!DebugCounter::shouldExecute(AssumeQueryCounter))\n    return RetainedKnowledge::none();\n  if (AC) {\n    for (AssumptionCache::ResultElem &Elem : AC->assumptionsFor(V)) {\n      IntrinsicInst *II = cast_or_null<IntrinsicInst>(Elem.Assume);\n      if (!II || Elem.Index == AssumptionCache::ExprResultIdx)\n        continue;\n      if (RetainedKnowledge RK = getKnowledgeFromBundle(\n\n>>> [ INFILL ] <<<\n        if (is_contained(AttrKinds, RK.AttrKind) &&\n            Filter(RK, II, &II->bundle_op_info_begin()[Elem.Index])) {\n          NumUsefullAssumeQueries++;\n          return RK;\n        }\n    }\n    return RetainedKnowledge::none();\n  }\n  for (const auto &U : V->uses()) {\n    CallInst::BundleOpInfo* Bundle = getBundleFromUse(&U);\n    if (!Bundle)\n      continue;\n    if (RetainedKnowledge RK =\n            getKnowledgeFromBundle(*cast<CallInst>(U.getUser()), *Bundle))\n      if (is_contained(AttrKinds, RK.AttrKind) &&\n          Filter(RK, cast<Instruction>(U.getUser()), Bundle)) {\n        NumUsefullAssumeQueries++;\n        return RK;\n      }\n  }\n  return RetainedKnowledge::none();\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n              *II, II->bundle_op_info_begin()[Elem.Index]))\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/PhaseOrdering/d83507-knowledge-retention-bug.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/PhaseOrdering/d83507-knowledge-retention-bug.ll\n\n\nTesting Time: 0.42s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "a79e604462ea26c73b6869d71b41667819f90281___AssumeBundleQueries.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid BasicBlock::print(raw_ostream &ROS, AssemblyAnnotationWriter *AAW,\n                     bool ShouldPreserveUseListOrder,\n                     bool IsForDebug) const {\n\n>>> [ INFILL ] <<<\n  formatted_raw_ostream OS(ROS);\n  AssemblyWriter W(OS, SlotTable, this->getModule(), AAW,\n                   IsForDebug,\n                   ShouldPreserveUseListOrder);\n  W.printBasicBlock(this);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  SlotTracker SlotTable(this->getModule());\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Other/bb-badref.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Other/bb-badref.ll\n\n\nTesting Time: 0.41s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "96f372c1e7402595edd2ae9f86b9bdfa22dc1045___AsmWriter.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid ObjCARCOpt::OptimizeReturns(Function &F) {\n  if (!F.getReturnType()->isPointerTy())\n    return;\n\n  LLVM_DEBUG(dbgs() << \"\\n== ObjCARCOpt::OptimizeReturns ==\\n\");\n\n  SmallPtrSet<Instruction *, 4> DependingInstructions;\n  SmallPtrSet<const BasicBlock *, 4> Visited;\n  for (BasicBlock &BB: F) {\n    ReturnInst *Ret = dyn_cast<ReturnInst>(&BB.back());\n    if (!Ret)\n      continue;\n\n    LLVM_DEBUG(dbgs() << \"Visiting: \" << *Ret << \"\\n\");\n\n    const Value *Arg = GetRCIdentityRoot(Ret->getOperand(0));\n\n    // Look for an ``autorelease'' instruction that is a predecessor of Ret and\n    // dependent on Arg such that there are no instructions dependent on Arg\n    // that need a positive ref count in between the autorelease and Ret.\n    CallInst *Autorelease =\n        FindPredecessorAutoreleaseWithSafePath(Arg, &BB, Ret, Visited, PA);\n    Visited.clear();\n\n    if (!Autorelease)\n      continue;\n\n    CallInst *Retain = FindPredecessorRetainWithSafePath(\n        Arg, Autorelease->getParent(), Autorelease, Visited, PA);\n    Visited.clear();\n\n    if (!Retain)\n      continue;\n\n    // Check that there is nothing that can affect the reference count\n    // between the retain and the call.  Note that Retain need not be in BB.\n    bool HasSafePathToCall = HasSafePathToPredecessorCall(Arg, Retain,\n                                                          DependingInstructions,\n                                                          Visited, PA);\n\n    // Don't remove retainRV/autoreleaseRV pairs if the call isn't a tail call.\n    if (HasSafePathToCall &&\n        GetBasicARCInstKind(Retain) == ARCInstKind::RetainRV &&\n        GetBasicARCInstKind(Autorelease) == ARCInstKind::AutoreleaseRV &&\n\n>>> [ INFILL ] <<<\n      continue;\n\n    DependingInstructions.clear();\n    Visited.clear();\n\n    if (!HasSafePathToCall)\n      continue;\n\n    // If so, we can zap the retain and autorelease.\n    Changed = true;\n    ++NumRets;\n    LLVM_DEBUG(dbgs() << \"Erasing: \" << *Retain << \"\\nErasing: \" << *Autorelease\n                      << \"\\n\");\n    EraseInstruction(Retain);\n    EraseInstruction(Autorelease);\n  }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        !cast<CallInst>(*DependingInstructions.begin())->isTailCall())\n\n```\n\n\n\nwith the following test error:  \nPlease provide the correct line following commit message at the infill location."}], "idx": "09266e4af04ec2dc3a3afc19a3f9d5658d482a44___ObjCARCOpts.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nFunctionPassManager\nPassBuilder::buildFunctionSimplificationPipeline(OptimizationLevel Level,\n                                                 ThinLTOPhase Phase) {\n  assert(Level != OptimizationLevel::O0 && \"Must request optimizations!\");\n\n  // The O1 pipeline has a separate pipeline creation function to simplify\n  // construction readability.\n  if (Level.getSpeedupLevel() == 1)\n    return buildO1FunctionSimplificationPipeline(Level, Phase);\n\n  FunctionPassManager FPM(DebugLogging);\n\n  // Form SSA out of local memory accesses after breaking apart aggregates into\n  // scalars.\n  FPM.addPass(SROA());\n\n  // Catch trivial redundancies\n  FPM.addPass(EarlyCSEPass(true /* Enable mem-ssa. */));\n  if (EnableKnowledgeRetention)\n    FPM.addPass(AssumeSimplifyPass());\n\n  // Hoisting of scalars and load expressions.\n  if (EnableGVNHoist)\n    FPM.addPass(GVNHoistPass());\n\n  // Global value numbering based sinking.\n  if (EnableGVNSink) {\n    FPM.addPass(GVNSinkPass());\n    FPM.addPass(SimplifyCFGPass());\n  }\n\n  if (EnableConstraintElimination)\n    FPM.addPass(ConstraintEliminationPass());\n\n  // Speculative execution if the target has divergent branches; otherwise nop.\n  FPM.addPass(SpeculativeExecutionPass(/* OnlyIfDivergentTarget =*/true));\n\n  // Optimize based on known information about branches, and cleanup afterward.\n  FPM.addPass(JumpThreadingPass());\n  FPM.addPass(CorrelatedValuePropagationPass());\n\n  FPM.addPass(SimplifyCFGPass());\n  if (Level == OptimizationLevel::O3)\n    FPM.addPass(AggressiveInstCombinePass());\n  FPM.addPass(InstCombinePass());\n\n  if (!Level.isOptimizingForSize())\n    FPM.addPass(LibCallsShrinkWrapPass());\n\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  // For PGO use pipeline, try to optimize memory intrinsics such as memcpy\n  // using the size value profile. Don't perform this when optimizing for size.\n  if (PGOOpt && PGOOpt->Action == PGOOptions::IRUse &&\n      !Level.isOptimizingForSize())\n    FPM.addPass(PGOMemOPSizeOpt());\n\n  FPM.addPass(TailCallElimPass());\n  FPM.addPass(SimplifyCFGPass());\n\n  // Form canonically associated expression trees, and simplify the trees using\n  // basic mathematical properties. For example, this will form (nearly)\n  // minimal multiplication trees.\n  FPM.addPass(ReassociatePass());\n\n  // Add the primary loop simplification pipeline.\n  // FIXME: Currently this is split into two loop pass pipelines because we run\n  // some function passes in between them. These can and should be removed\n  // and/or replaced by scheduling the loop pass equivalents in the correct\n  // positions. But those equivalent passes aren't powerful enough yet.\n  // Specifically, `SimplifyCFGPass` and `InstCombinePass` are currently still\n  // used. We have `LoopSimplifyCFGPass` which isn't yet powerful enough yet to\n  // fully replace `SimplifyCFGPass`, and the closest to the other we have is\n  // `LoopInstSimplify`.\n  LoopPassManager LPM1(DebugLogging), LPM2(DebugLogging);\n\n  // Simplify the loop body. We do this initially to clean up after other loop\n  // passes run, either when iterating on a loop or on inner loops with\n  // implications on the outer loop.\n  LPM1.addPass(LoopInstSimplifyPass());\n  LPM1.addPass(LoopSimplifyCFGPass());\n\n  // Disable header duplication in loop rotation at -Oz.\n  LPM1.addPass(LoopRotatePass(Level != OptimizationLevel::Oz));\n  // TODO: Investigate promotion cap for O1.\n  LPM1.addPass(LICMPass(PTO.LicmMssaOptCap, PTO.LicmMssaNoAccForPromotionCap));\n\n>>> [ INFILL ] <<<\n  LPM2.addPass(LoopIdiomRecognizePass());\n  LPM2.addPass(IndVarSimplifyPass());\n\n  for (auto &C : LateLoopOptimizationsEPCallbacks)\n    C(LPM2, Level);\n\n  LPM2.addPass(LoopDeletionPass());\n  // Do not enable unrolling in PreLinkThinLTO phase during sample PGO\n  // because it changes IR to makes profile annotation in back compile\n  // inaccurate. The normal unroller doesn't pay attention to forced full unroll\n  // attributes so we need to make sure and allow the full unroll pass to pay\n  // attention to it.\n  if (Phase != ThinLTOPhase::PreLink || !PGOOpt ||\n      PGOOpt->Action != PGOOptions::SampleUse)\n    LPM2.addPass(LoopFullUnrollPass(Level.getSpeedupLevel(),\n                                    /* OnlyWhenForced= */ !PTO.LoopUnrolling,\n                                    PTO.ForgetAllSCEVInLoopUnroll));\n\n  for (auto &C : LoopOptimizerEndEPCallbacks)\n    C(LPM2, Level);\n\n  // We provide the opt remark emitter pass for LICM to use. We only need to do\n  // this once as it is immutable.\n  FPM.addPass(\n      RequireAnalysisPass<OptimizationRemarkEmitterAnalysis, Function>());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      std::move(LPM1), EnableMSSALoopDependency, /*UseBlockFrequencyInfo=*/true,\n      DebugLogging));\n  FPM.addPass(SimplifyCFGPass());\n  FPM.addPass(InstCombinePass());\n  // The loop passes in LPM2 (LoopIdiomRecognizePass, IndVarSimplifyPass,\n  // LoopDeletionPass and LoopFullUnrollPass) do not preserve MemorySSA.\n  // *All* loop passes must preserve it, in order to be able to use it.\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      std::move(LPM2), /*UseMemorySSA=*/false, /*UseBlockFrequencyInfo=*/false,\n      DebugLogging));\n\n  // Delete small array after loop unroll.\n  FPM.addPass(SROA());\n\n  // Eliminate redundancies.\n  FPM.addPass(MergedLoadStoreMotionPass());\n  if (RunNewGVN)\n    FPM.addPass(NewGVNPass());\n  else\n    FPM.addPass(GVN());\n\n  // Specially optimize memory movement as it doesn't look like dataflow in SSA.\n  FPM.addPass(MemCpyOptPass());\n\n  // Sparse conditional constant propagation.\n  // FIXME: It isn't clear why we do this *after* loop passes rather than\n  // before...\n  FPM.addPass(SCCPPass());\n\n  // Delete dead bit computations (instcombine runs after to fold away the dead\n  // computations, and then ADCE will run later to exploit any new DCE\n  // opportunities that creates).\n  FPM.addPass(BDCEPass());\n\n  // Run instcombine after redundancy and dead bit elimination to exploit\n  // opportunities opened up by them.\n  FPM.addPass(InstCombinePass());\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  // Re-consider control flow based optimizations after redundancy elimination,\n  // redo DCE, etc.\n  FPM.addPass(JumpThreadingPass());\n  FPM.addPass(CorrelatedValuePropagationPass());\n\n  // Finally, do an expensive DCE pass to catch all the dead code exposed by\n  // the simplifications and basic cleanup after all the simplifications.\n  // TODO: Investigate if this is too expensive.\n  FPM.addPass(ADCEPass());\n\n  FPM.addPass(DSEPass());\n  FPM.addPass(createFunctionToLoopPassAdaptor(\n      LICMPass(PTO.LicmMssaOptCap, PTO.LicmMssaNoAccForPromotionCap),\n      EnableMSSALoopDependency, /*UseBlockFrequencyInfo=*/true, DebugLogging));\n\n  if (PTO.Coroutines)\n    FPM.addPass(CoroElidePass());\n\n  for (auto &C : ScalarOptimizerLateEPCallbacks)\n    C(FPM, Level);\n\n  FPM.addPass(SimplifyCFGPass());\n  FPM.addPass(InstCombinePass());\n  invokePeepholeEPCallbacks(FPM, Level);\n\n  if (EnableCHR && Level == OptimizationLevel::O3 && PGOOpt &&\n      (PGOOpt->Action == PGOOptions::IRUse ||\n       PGOOpt->Action == PGOOptions::SampleUse))\n    FPM.addPass(ControlHeightReductionPass());\n\n  return FPM;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  LPM1.addPass(SimpleLoopUnswitchPass());\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/LoopUnroll/opt-levels.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopUnroll/opt-levels.ll\n\n\nTesting Time: 0.27s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/SimpleLoopUnswitch/pipeline.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SimpleLoopUnswitch/pipeline.ll\n\n\nTesting Time: 0.18s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "f748e92295515ea7b39cd687a718915b559de6ec___PassBuilder.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nMemDepResult\nMemoryDependenceResults::getInvariantGroupPointerDependency(LoadInst *LI,\n                                                            BasicBlock *BB) {\n\n  if (!LI->hasMetadata(LLVMContext::MD_invariant_group))\n    return MemDepResult::getUnknown();\n\n  // Take the ptr operand after all casts and geps 0. This way we can search\n  // cast graph down only.\n  Value *LoadOperand = LI->getPointerOperand()->stripPointerCasts();\n\n  // It's is not safe to walk the use list of global value, because function\n  // passes aren't allowed to look outside their functions.\n  // FIXME: this could be fixed by filtering instructions from outside\n  // of current function.\n  if (isa<GlobalValue>(LoadOperand))\n    return MemDepResult::getUnknown();\n\n  // Queue to process all pointers that are equivalent to load operand.\n  SmallVector<const Value *, 8> LoadOperandsQueue;\n  LoadOperandsQueue.push_back(LoadOperand);\n\n  Instruction *ClosestDependency = nullptr;\n  // Order of instructions in uses list is unpredictible. In order to always\n  // get the same result, we will look for the closest dominance.\n  auto GetClosestDependency = [this](Instruction *Best, Instruction *Other) {\n    assert(Other && \"Must call it with not null instruction\");\n    if (Best == nullptr || DT.dominates(Best, Other))\n      return Other;\n    return Best;\n  };\n\n  // FIXME: This loop is O(N^2) because dominates can be O(n) and in worst case\n  // we will see all the instructions. This should be fixed in MSSA.\n  while (!LoadOperandsQueue.empty()) {\n    const Value *Ptr = LoadOperandsQueue.pop_back_val();\n    assert(Ptr && !isa<GlobalValue>(Ptr) &&\n           \"Null or GlobalValue should not be inserted\");\n\n    for (const Use &Us : Ptr->uses()) {\n      auto *U = dyn_cast<Instruction>(Us.getUser());\n      if (!U || U == LI || !DT.dominates(U, LI))\n        continue;\n\n      // Bitcast or gep with zeros are using Ptr. Add to queue to check it's\n      // users.      U = bitcast Ptr\n      if (isa<BitCastInst>(U)) {\n        LoadOperandsQueue.push_back(U);\n        continue;\n      }\n      // Gep with zeros is equivalent to bitcast.\n      // FIXME: we are not sure if some bitcast should be canonicalized to gep 0\n      // or gep 0 to bitcast because of SROA, so there are 2 forms. When\n      // typeless pointers will be ready then both cases will be gone\n      // (and this BFS also won't be needed).\n      if (auto *GEP = dyn_cast<GetElementPtrInst>(U))\n        if (GEP->hasAllZeroIndices()) {\n          LoadOperandsQueue.push_back(U);\n          continue;\n        }\n\n      // If we hit load/store with the same invariant.group metadata (and the\n      // same pointer operand) we can assume that value pointed by pointer\n      // operand didn't change.\n\n>>> [ INFILL ] <<<\n          U->hasMetadata(LLVMContext::MD_invariant_group))\n        ClosestDependency = GetClosestDependency(ClosestDependency, U);\n    }\n  }\n\n  if (!ClosestDependency)\n    return MemDepResult::getUnknown();\n  if (ClosestDependency->getParent() == BB)\n    return MemDepResult::getDef(ClosestDependency);\n  // Def(U) can't be returned here because it is non-local. If local\n  // dependency won't be found then return nonLocal counting that the\n  // user will call getNonLocalPointerDependency, which will return cached\n  // result.\n  NonLocalDefsCache.try_emplace(\n      LI, NonLocalDepResult(ClosestDependency->getParent(),\n                            MemDepResult::getDef(ClosestDependency), nullptr));\n  ReverseNonLocalDefsCache[ClosestDependency].insert(LI);\n  return MemDepResult::getNonLocal();\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n      if ((isa<LoadInst>(U) || isa<StoreInst>(U)) &&\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/GVN/storeinvgroup.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/GVN/storeinvgroup.ll\n\n\nTesting Time: 0.42s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "875891a10d50a791d3f076c9259e60af6c9af18c___MemoryDependenceAnalysis.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nbool BasicAAResult::constantOffsetHeuristic(\n    const SmallVectorImpl<VariableGEPIndex> &VarIndices,\n    LocationSize MaybeV1Size, LocationSize MaybeV2Size, const APInt &BaseOffset,\n    AssumptionCache *AC, DominatorTree *DT) {\n  if (VarIndices.size() != 2 || !MaybeV1Size.hasValue() ||\n      !MaybeV2Size.hasValue())\n    return false;\n\n  const uint64_t V1Size = MaybeV1Size.getValue();\n  const uint64_t V2Size = MaybeV2Size.getValue();\n\n  const VariableGEPIndex &Var0 = VarIndices[0], &Var1 = VarIndices[1];\n\n  if (Var0.ZExtBits != Var1.ZExtBits || Var0.SExtBits != Var1.SExtBits ||\n\n>>> [ INFILL ] <<<\n    return false;\n\n  // We'll strip off the Extensions of Var0 and Var1 and do another round\n  // of GetLinearExpression decomposition. In the example above, if Var0\n  // is zext(%x + 1) we should get V1 == %x and V1Offset == 1.\n\n  LinearExpression E0 =\n      GetLinearExpression(ExtendedValue(Var0.V), DL, 0, AC, DT);\n  LinearExpression E1 =\n      GetLinearExpression(ExtendedValue(Var1.V), DL, 0, AC, DT);\n  if (E0.Scale != E1.Scale || E0.Val.ZExtBits != E1.Val.ZExtBits ||\n      E0.Val.SExtBits != E1.Val.SExtBits ||\n      !isValueEqualInPotentialCycles(E0.Val.V, E1.Val.V))\n    return false;\n\n  // We have a hit - Var0 and Var1 only differ by a constant offset!\n\n  // If we've been sext'ed then zext'd the maximum difference between Var0 and\n  // Var1 is possible to calculate, but we're just interested in the absolute\n  // minimum difference between the two. The minimum distance may occur due to\n  // wrapping; consider \"add i3 %i, 5\": if %i == 7 then 7 + 5 mod 8 == 4, and so\n  // the minimum distance between %i and %i + 5 is 3.\n  APInt MinDiff = E0.Offset - E1.Offset, Wrapped = -MinDiff;\n  MinDiff = APIntOps::umin(MinDiff, Wrapped);\n  APInt MinDiffBytes =\n    MinDiff.zextOrTrunc(Var0.Scale.getBitWidth()) * Var0.Scale.abs();\n\n  // We can't definitely say whether GEP1 is before or after V2 due to wrapping\n  // arithmetic (i.e. for some values of GEP1 and V2 GEP1 < V2, and for other\n  // values GEP1 > V2). We'll therefore only declare NoAlias if both V1Size and\n  // V2Size can fit in the MinDiffBytes gap.\n  return MinDiffBytes.uge(V1Size + BaseOffset.abs()) &&\n         MinDiffBytes.uge(V2Size + BaseOffset.abs());\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n      Var0.Scale != -Var1.Scale)\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Analysis/BasicAA/q.bad.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Analysis/BasicAA/q.bad.ll\n\n\nTesting Time: 3.12s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ce066da81c3e6175a02fa7ae831931b5e4126a2b___BasicAliasAnalysis.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic SDValue combineSetCCMOVMSK(SDValue EFLAGS, X86::CondCode &CC,\n                                  SelectionDAG &DAG,\n                                  const X86Subtarget &Subtarget) {\n  // Handle eq/ne against zero (any_of).\n  // Handle eq/ne against -1 (all_of).\n  if (!(CC == X86::COND_E || CC == X86::COND_NE))\n    return SDValue();\n  if (EFLAGS.getValueType() != MVT::i32)\n    return SDValue();\n  unsigned CmpOpcode = EFLAGS.getOpcode();\n  if (CmpOpcode != X86ISD::CMP && CmpOpcode != X86ISD::SUB)\n    return SDValue();\n  auto *CmpConstant = dyn_cast<ConstantSDNode>(EFLAGS.getOperand(1));\n  if (!CmpConstant)\n    return SDValue();\n  const APInt &CmpVal = CmpConstant->getAPIntValue();\n\n  SDValue CmpOp = EFLAGS.getOperand(0);\n  unsigned CmpBits = CmpOp.getValueSizeInBits();\n  assert(CmpBits == CmpVal.getBitWidth() && \"Value size mismatch\");\n\n  // Peek through any truncate.\n  if (CmpOp.getOpcode() == ISD::TRUNCATE)\n    CmpOp = CmpOp.getOperand(0);\n\n  // Bail if we don't find a MOVMSK.\n  if (CmpOp.getOpcode() != X86ISD::MOVMSK)\n    return SDValue();\n\n  SDValue Vec = CmpOp.getOperand(0);\n  MVT VecVT = Vec.getSimpleValueType();\n  assert((VecVT.is128BitVector() || VecVT.is256BitVector()) &&\n         \"Unexpected MOVMSK operand\");\n  unsigned NumElts = VecVT.getVectorNumElements();\n  unsigned NumEltBits = VecVT.getScalarSizeInBits();\n\n  bool IsAnyOf = CmpOpcode == X86ISD::CMP && CmpVal.isNullValue();\n  bool IsAllOf = CmpOpcode == X86ISD::SUB && NumElts <= CmpBits &&\n                 CmpVal.isMask(NumElts);\n  if (!IsAnyOf && !IsAllOf)\n    return SDValue();\n\n  // See if we can peek through to a vector with a wider element type, if the\n  // signbits extend down to all the sub-elements as well.\n  // Calling MOVMSK with the wider type, avoiding the bitcast, helps expose\n  // potential SimplifyDemandedBits/Elts cases.\n  if (Vec.getOpcode() == ISD::BITCAST) {\n    SDValue BC = peekThroughBitcasts(Vec);\n    MVT BCVT = BC.getSimpleValueType();\n    unsigned BCNumElts = BCVT.getVectorNumElements();\n    unsigned BCNumEltBits = BCVT.getScalarSizeInBits();\n    if ((BCNumEltBits == 32 || BCNumEltBits == 64) &&\n        BCNumEltBits > NumEltBits &&\n        DAG.ComputeNumSignBits(BC) > (BCNumEltBits - NumEltBits)) {\n      SDLoc DL(EFLAGS);\n      unsigned CmpMask = IsAnyOf ? 0 : ((1 << BCNumElts) - 1);\n      return DAG.getNode(X86ISD::CMP, DL, MVT::i32,\n                         DAG.getNode(X86ISD::MOVMSK, DL, MVT::i32, BC),\n                         DAG.getConstant(CmpMask, DL, MVT::i32));\n    }\n  }\n\n  // MOVMSK(PCMPEQ(X,0)) == -1 -> PTESTZ(X,X).\n  // MOVMSK(PCMPEQ(X,0)) != -1 -> !PTESTZ(X,X).\n  if (IsAllOf && Subtarget.hasSSE41()) {\n    SDValue BC = peekThroughBitcasts(Vec);\n    if (BC.getOpcode() == X86ISD::PCMPEQ &&\n        ISD::isBuildVectorAllZeros(BC.getOperand(1).getNode())) {\n      MVT TestVT = VecVT.is128BitVector() ? MVT::v2i64 : MVT::v4i64;\n      SDValue V = DAG.getBitcast(TestVT, BC.getOperand(0));\n      return DAG.getNode(X86ISD::PTEST, SDLoc(EFLAGS), MVT::i32, V, V);\n    }\n  }\n\n  // See if we can avoid a PACKSS by calling MOVMSK on the sources.\n  // For vXi16 cases we can use a v2Xi8 PMOVMSKB. We must mask out\n  // sign bits prior to the comparison with zero unless we know that\n  // the vXi16 splats the sign bit down to the lower i8 half.\n  // TODO: Handle all_of patterns.\n  if (Vec.getOpcode() == X86ISD::PACKSS && VecVT == MVT::v16i8) {\n    SDValue VecOp0 = Vec.getOperand(0);\n    SDValue VecOp1 = Vec.getOperand(1);\n    bool SignExt0 = DAG.ComputeNumSignBits(VecOp0) > 8;\n    bool SignExt1 = DAG.ComputeNumSignBits(VecOp1) > 8;\n    // PMOVMSKB(PACKSSBW(X, undef)) -> PMOVMSKB(BITCAST_v16i8(X)) & 0xAAAA.\n    if (IsAnyOf && CmpBits == 8 && VecOp1.isUndef()) {\n      SDLoc DL(EFLAGS);\n      SDValue Result = DAG.getBitcast(MVT::v16i8, VecOp0);\n      Result = DAG.getNode(X86ISD::MOVMSK, DL, MVT::i32, Result);\n      Result = DAG.getZExtOrTrunc(Result, DL, MVT::i16);\n      if (!SignExt0) {\n        Result = DAG.getNode(ISD::AND, DL, MVT::i16, Result,\n                             DAG.getConstant(0xAAAA, DL, MVT::i16));\n      }\n      return DAG.getNode(X86ISD::CMP, DL, MVT::i32, Result,\n                         DAG.getConstant(0, DL, MVT::i16));\n    }\n    // PMOVMSKB(PACKSSBW(LO(X), HI(X)))\n    // -> PMOVMSKB(BITCAST_v32i8(X)) & 0xAAAAAAAA.\n\n>>> [ INFILL ] <<<\n        VecOp0.getOpcode() == ISD::EXTRACT_SUBVECTOR &&\n        VecOp1.getOpcode() == ISD::EXTRACT_SUBVECTOR &&\n        VecOp0.getOperand(0) == VecOp1.getOperand(0) &&\n        VecOp0.getConstantOperandAPInt(1) == 0 &&\n        VecOp1.getConstantOperandAPInt(1) == 8 &&\n        (IsAnyOf || (SignExt0 && SignExt1))) {\n      SDLoc DL(EFLAGS);\n      SDValue Result = DAG.getBitcast(MVT::v32i8, VecOp0.getOperand(0));\n      Result = DAG.getNode(X86ISD::MOVMSK, DL, MVT::i32, Result);\n      unsigned CmpMask = IsAnyOf ? 0 : 0xFFFFFFFF;\n      if (!SignExt0 || !SignExt1) {\n        assert(IsAnyOf && \"Only perform v16i16 signmasks for any_of patterns\");\n        Result = DAG.getNode(ISD::AND, DL, MVT::i32, Result,\n                             DAG.getConstant(0xAAAAAAAA, DL, MVT::i32));\n      }\n      return DAG.getNode(X86ISD::CMP, DL, MVT::i32, Result,\n                         DAG.getConstant(CmpMask, DL, MVT::i32));\n    }\n  }\n\n  // MOVMSK(SHUFFLE(X,u)) -> MOVMSK(X) iff every element is referenced.\n  SmallVector<int, 32> ShuffleMask;\n  SmallVector<SDValue, 2> ShuffleInputs;\n  if (NumElts == CmpBits &&\n      getTargetShuffleInputs(peekThroughBitcasts(Vec), ShuffleInputs,\n                             ShuffleMask, DAG) &&\n      ShuffleInputs.size() == 1 && !isAnyZeroOrUndef(ShuffleMask) &&\n      ShuffleInputs[0].getValueSizeInBits() == VecVT.getSizeInBits()) {\n    unsigned NumShuffleElts = ShuffleMask.size();\n    APInt DemandedElts = APInt::getNullValue(NumShuffleElts);\n    for (int M : ShuffleMask) {\n      assert(0 <= M && M < (int)NumShuffleElts && \"Bad unary shuffle index\");\n      DemandedElts.setBit(M);\n    }\n    if (DemandedElts.isAllOnesValue()) {\n      SDLoc DL(EFLAGS);\n      SDValue Result = DAG.getBitcast(VecVT, ShuffleInputs[0]);\n      Result = DAG.getNode(X86ISD::MOVMSK, DL, MVT::i32, Result);\n      Result =\n          DAG.getZExtOrTrunc(Result, DL, EFLAGS.getOperand(0).getValueType());\n      return DAG.getNode(X86ISD::CMP, DL, MVT::i32, Result,\n                         EFLAGS.getOperand(1));\n    }\n  }\n\n  return SDValue();\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    if (CmpBits == 16 && Subtarget.hasInt256() &&\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/vector-compare-all_of.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-compare-all_of.ll\n\n\nTesting Time: 1.01s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-compare-any_of.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-compare-any_of.ll\n\n\nTesting Time: 1.57s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "74f98391a7a42eccd7aa96546892cb9b65a39edb___X86ISelLowering.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic bool inferAllPrototypeAttributes(\n    Module &M, function_ref<TargetLibraryInfo &(Function &)> GetTLI) {\n  bool Changed = false;\n\n  for (Function &F : M.functions())\n    // We only infer things using the prototype and the name; we don't need\n    // definitions.  This ensures libfuncs are annotated and also allows our\n    // CGSCC inference to avoid needing to duplicate the inference from other\n    // attribute logic on all calls to declarations (as declarations aren't\n    // explicitly visited by CGSCC passes in the new pass manager.)\n    if (F.isDeclaration() && !F.hasOptNone()) {\n\n>>> [ INFILL ] <<<\n      Changed |= inferAttributesFromOthers(F);\n    }\n\n  return Changed;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n      Changed |= inferLibFuncAttributes(F, GetTLI(F));\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InferFunctionAttrs/nobuiltin.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InferFunctionAttrs/nobuiltin.ll\n\n\nTesting Time: 0.15s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "11707435ccb44a9377bfed407453e0646a159636___InferFunctionAttrs.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nValue *LibCallSimplifier::optimizeMemChr(CallInst *CI, IRBuilderBase &B) {\n  Value *SrcStr = CI->getArgOperand(0);\n  Value *Size = CI->getArgOperand(2);\n  annotateNonNullAndDereferenceable(CI, 0, Size, DL);\n  ConstantInt *CharC = dyn_cast<ConstantInt>(CI->getArgOperand(1));\n  ConstantInt *LenC = dyn_cast<ConstantInt>(Size);\n\n  // memchr(x, y, 0) -> null\n  if (LenC) {\n    if (LenC->isZero())\n      return Constant::getNullValue(CI->getType());\n  } else {\n    // From now on we need at least constant length and string.\n    return nullptr;\n  }\n\n  StringRef Str;\n  if (!getConstantStringInfo(SrcStr, Str, 0, /*TrimAtNul=*/false))\n    return nullptr;\n\n  // Truncate the string to LenC. If Str is smaller than LenC we will still only\n  // scan the string, as reading past the end of it is undefined and we can just\n  // return null if we don't find the char.\n  Str = Str.substr(0, LenC->getZExtValue());\n\n  // If the char is variable but the input str and length are not we can turn\n  // this memchr call into a simple bit field test. Of course this only works\n  // when the return value is only checked against null.\n  //\n  // It would be really nice to reuse switch lowering here but we can't change\n  // the CFG at this point.\n  //\n  // memchr(\"\\r\\n\", C, 2) != nullptr -> (1 << C & ((1 << '\\r') | (1 << '\\n')))\n  // != 0\n  //   after bounds check.\n  if (!CharC && !Str.empty() && isOnlyUsedInZeroEqualityComparison(CI)) {\n    unsigned char Max =\n        *std::max_element(reinterpret_cast<const unsigned char *>(Str.begin()),\n                          reinterpret_cast<const unsigned char *>(Str.end()));\n\n    // Make sure the bit field we're about to create fits in a register on the\n    // target.\n    // FIXME: On a 64 bit architecture this prevents us from using the\n    // interesting range of alpha ascii chars. We could do better by emitting\n    // two bitfields or shifting the range by 64 if no lower chars are used.\n    if (!DL.fitsInLegalInteger(Max + 1))\n      return nullptr;\n\n    // For the bit field use a power-of-2 type with at least 8 bits to avoid\n    // creating unnecessary illegal types.\n    unsigned char Width = NextPowerOf2(std::max((unsigned char)7, Max));\n\n    // Now build the bit field.\n    APInt Bitfield(Width, 0);\n    for (char C : Str)\n      Bitfield.setBit((unsigned char)C);\n    Value *BitfieldC = B.getInt(Bitfield);\n\n    // Adjust width of \"C\" to the bitfield width, then mask off the high bits.\n    Value *C = B.CreateZExtOrTrunc(CI->getArgOperand(1), BitfieldC->getType());\n    C = B.CreateAnd(C, B.getIntN(Width, 0xFF));\n\n    // First check that the bit field access is within bounds.\n    Value *Bounds = B.CreateICmp(ICmpInst::ICMP_ULT, C, B.getIntN(Width, Width),\n                                 \"memchr.bounds\");\n\n    // Create code that checks if the given bit is set in the field.\n    Value *Shl = B.CreateShl(B.getIntN(Width, 1ULL), C);\n    Value *Bits = B.CreateIsNotNull(B.CreateAnd(Shl, BitfieldC), \"memchr.bits\");\n\n    // Finally merge both checks and cast to pointer type. The inttoptr\n    // implicitly zexts the i1 to intptr type.\n\n>>> [ INFILL ] <<<\n  }\n\n  // Check if all arguments are constants.  If so, we can constant fold.\n  if (!CharC)\n    return nullptr;\n\n  // Compute the offset.\n  size_t I = Str.find(CharC->getSExtValue() & 0xFF);\n  if (I == StringRef::npos) // Didn't find the char.  memchr returns null.\n    return Constant::getNullValue(CI->getType());\n\n  // memchr(s+n,c,l) -> gep(s+n+i,c)\n  return B.CreateGEP(B.getInt8Ty(), SrcStr, B.getInt64(I), \"memchr\");\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    return B.CreateIntToPtr(B.CreateAnd(Bounds, Bits, \"memchr\"), CI->getType());\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/memchr.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/memchr.ll\n\n\nTesting Time: 1.22s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/InstCombine/strchr-1.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/strchr-1.ll\n\n\nTesting Time: 0.14s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "160559344026824ee0b510741c7906c0e165f9a7___SimplifyLibCalls.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid FunctionImportGlobalProcessing::processGlobalForThinLTO(GlobalValue &GV) {\n\n  ValueInfo VI;\n  if (GV.hasName()) {\n    VI = ImportIndex.getValueInfo(GV.getGUID());\n    // Set synthetic function entry counts.\n    if (VI && ImportIndex.hasSyntheticEntryCounts()) {\n      if (Function *F = dyn_cast<Function>(&GV)) {\n        if (!F->isDeclaration()) {\n          for (auto &S : VI.getSummaryList()) {\n            auto *FS = cast<FunctionSummary>(S->getBaseObject());\n            if (FS->modulePath() == M.getModuleIdentifier()) {\n              F->setEntryCount(Function::ProfileCount(FS->entryCount(),\n                                                      Function::PCT_Synthetic));\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // We should always have a ValueInfo (i.e. GV in index) for definitions when\n  // we are exporting, and also when importing that value.\n  assert(VI || GV.isDeclaration() ||\n         (isPerformingImport() && !doImportAsDefinition(&GV)));\n\n  // Mark read/write-only variables which can be imported with specific\n  // attribute. We can't internalize them now because IRMover will fail\n  // to link variable definitions to their external declarations during\n  // ThinLTO import. We'll internalize read-only variables later, after\n  // import is finished. See internalizeGVsAfterImport.\n  //\n  // If global value dead stripping is not enabled in summary then\n  // propagateConstants hasn't been run. We can't internalize GV\n  // in such case.\n  if (!GV.isDeclaration() && VI && ImportIndex.withAttributePropagation()) {\n    if (GlobalVariable *V = dyn_cast<GlobalVariable>(&GV)) {\n      // We can have more than one local with the same GUID, in the case of\n      // same-named locals in different but same-named source files that were\n      // compiled in their respective directories (so the source file name\n      // and resulting GUID is the same). Find the one in this module.\n      // Handle the case where there is no summary found in this module. That\n      // can happen in the distributed ThinLTO backend, because the index only\n      // contains summaries from the source modules if they are being imported.\n      // We might have a non-null VI and get here even in that case if the name\n      // matches one in this module (e.g. weak or appending linkage).\n      auto *GVS = dyn_cast_or_null<GlobalVarSummary>(\n          ImportIndex.findSummaryInModule(VI, M.getModuleIdentifier()));\n      if (GVS &&\n          (ImportIndex.isReadOnly(GVS) || ImportIndex.isWriteOnly(GVS))) {\n        V->addAttribute(\"thinlto-internalize\");\n        // Objects referenced by writeonly GV initializer should not be\n        // promoted, because there is no any kind of read access to them\n        // on behalf of this writeonly GV. To avoid promotion we convert\n        // GV initializer to 'zeroinitializer'. This effectively drops\n        // references in IR module (not in combined index), so we can\n        // ignore them when computing import. We do not export references\n        // of writeonly object. See computeImportForReferencedGlobals\n        if (ImportIndex.isWriteOnly(GVS))\n          V->setInitializer(Constant::getNullValue(V->getValueType()));\n      }\n    }\n  }\n\n  if (GV.hasLocalLinkage() && shouldPromoteLocalToGlobal(&GV, VI)) {\n    // Save the original name string before we rename GV below.\n    auto Name = GV.getName().str();\n    GV.setName(getPromotedName(&GV));\n    GV.setLinkage(getLinkage(&GV, /* DoPromote */ true));\n    assert(!GV.hasLocalLinkage());\n    GV.setVisibility(GlobalValue::HiddenVisibility);\n\n    // If we are renaming a COMDAT leader, ensure that we record the COMDAT\n    // for later renaming as well. This is required for COFF.\n    if (const auto *C = GV.getComdat())\n      if (C->getName() == Name)\n        RenamedComdats.try_emplace(C, M.getOrInsertComdat(GV.getName()));\n  } else\n    GV.setLinkage(getLinkage(&GV, /* DoPromote */ false));\n\n  // When ClearDSOLocalOnDeclarations is true, clear dso_local if GV is\n  // converted to a declaration, to disable direct access. Don't do this if GV\n  // is implicitly dso_local due to a non-default visibility.\n\n>>> [ INFILL ] <<<\n      !GV.isImplicitDSOLocal()) {\n    GV.setDSOLocal(false);\n  } else if (VI && VI.isDSOLocal(ImportIndex.withDSOLocalPropagation())) {\n    // If all summaries are dso_local, symbol gets resolved to a known local\n    // definition.\n    GV.setDSOLocal(true);\n    if (GV.hasDLLImportStorageClass())\n      GV.setDLLStorageClass(GlobalValue::DefaultStorageClass);\n  }\n\n  // Remove functions imported as available externally defs from comdats,\n  // as this is a declaration for the linker, and will be dropped eventually.\n  // It is illegal for comdats to contain declarations.\n  auto *GO = dyn_cast<GlobalObject>(&GV);\n  if (GO && GO->isDeclarationForLinker() && GO->hasComdat()) {\n    // The IRMover should not have placed any imported declarations in\n    // a comdat, so the only declaration that should be in a comdat\n    // at this point would be a definition imported as available_externally.\n    assert(GO->hasAvailableExternallyLinkage() &&\n           \"Expected comdat on definition (possibly available external)\");\n    GO->setComdat(nullptr);\n  }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  if (ClearDSOLocalOnDeclarations && GV.isDeclarationForLinker() &&\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: ThinLTO/X86/import-dsolocal.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: ThinLTO/X86/import-dsolocal.ll\n\n\nTesting Time: 0.65s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: ThinLTO/X86/index-const-prop-linkage.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: ThinLTO/X86/index-const-prop-linkage.ll\n\n\nTesting Time: 0.29s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "252a1eecc04080d852ba58c6727970c688eb1619___FunctionImportUtils.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nbool SimplifyCFGOpt::simplifyOnceImpl(BasicBlock *BB) {\n  bool Changed = false;\n\n  assert(BB && BB->getParent() && \"Block not embedded in function!\");\n  assert(BB->getTerminator() && \"Degenerate basic block encountered!\");\n\n  // Remove basic blocks that have no predecessors (except the entry block)...\n  // or that just have themself as a predecessor.  These are unreachable.\n  if ((pred_empty(BB) && BB != &BB->getParent()->getEntryBlock()) ||\n      BB->getSinglePredecessor() == BB) {\n    LLVM_DEBUG(dbgs() << \"Removing BB: \\n\" << *BB);\n    DeleteDeadBlock(BB, DTU);\n    return true;\n  }\n\n  // Check to see if we can constant propagate this terminator instruction\n  // away...\n  Changed |= ConstantFoldTerminator(BB, /*DeleteDeadConditions=*/true,\n                                    /*TLI=*/nullptr, DTU);\n\n  // Check for and eliminate duplicate PHI nodes in this block.\n  Changed |= EliminateDuplicatePHINodes(BB);\n\n  // Check for and remove branches that will always cause undefined behavior.\n\n>>> [ INFILL ] <<<\n\n  // Merge basic blocks into their predecessor if there is only one distinct\n  // pred, and if there is only one distinct successor of the predecessor, and\n  // if there are no PHI nodes.\n  if (MergeBlockIntoPredecessor(BB, DTU))\n    return true;\n\n  if (SinkCommon && Options.SinkCommonInsts)\n    if (SinkCommonCodeFromPredecessors(BB, DTU)) {\n      // SinkCommonCodeFromPredecessors() does not automatically CSE PHI's,\n      // so we may now how duplicate PHI's.\n      // Let's rerun EliminateDuplicatePHINodes() first,\n      // before FoldTwoEntryPHINode() potentially converts them into select's,\n      // after which we'd need a whole EarlyCSE pass run to cleanup them.\n      return true;\n    }\n\n  IRBuilder<> Builder(BB);\n\n  if (Options.FoldTwoEntryPHINode) {\n    // If there is a trivial two-entry PHI node in this basic block, and we can\n    // eliminate it, do so now.\n    if (auto *PN = dyn_cast<PHINode>(BB->begin()))\n      if (PN->getNumIncomingValues() == 2)\n        if (FoldTwoEntryPHINode(PN, TTI, DTU, DL))\n          return true;\n  }\n\n  Instruction *Terminator = BB->getTerminator();\n  Builder.SetInsertPoint(Terminator);\n  switch (Terminator->getOpcode()) {\n  case Instruction::Br:\n    Changed |= simplifyBranch(cast<BranchInst>(Terminator), Builder);\n    break;\n  case Instruction::Resume:\n    Changed |= simplifyResume(cast<ResumeInst>(Terminator), Builder);\n    break;\n  case Instruction::CleanupRet:\n    Changed |= simplifyCleanupReturn(cast<CleanupReturnInst>(Terminator));\n    break;\n  case Instruction::Switch:\n    Changed |= simplifySwitch(cast<SwitchInst>(Terminator), Builder);\n    break;\n  case Instruction::Unreachable:\n    Changed |= simplifyUnreachable(cast<UnreachableInst>(Terminator));\n    break;\n  case Instruction::IndirectBr:\n    Changed |= simplifyIndirectBr(cast<IndirectBrInst>(Terminator));\n    break;\n  }\n\n  return Changed;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  Changed |= removeUndefIntroducingPredecessor(BB, DTU);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/SimplifyCFG/tautological-conditional-branch.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SimplifyCFG/tautological-conditional-branch.ll\n\n\nTesting Time: 0.31s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "2702fb11484a6f5d99c712a0e92c221288955c56___SimplifyCFG.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic bool canBeUnquotedInDirective(char C) {\n\n>>> [ INFILL ] <<<\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  return isAlnum(C) || C == '_' || C == '$' || C == '.' || C == '@';\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/dllexport.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/dllexport.ll\n\n\nTesting Time: 0.44s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ea8539111d444ffb93ab09c5865d9a1a0927cb2c___Mangler.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic SDValue LowerScalarImmediateShift(SDValue Op, SelectionDAG &DAG,\n                                         const X86Subtarget &Subtarget) {\n  MVT VT = Op.getSimpleValueType();\n  SDLoc dl(Op);\n  SDValue R = Op.getOperand(0);\n  SDValue Amt = Op.getOperand(1);\n  unsigned X86Opc = getTargetVShiftUniformOpcode(Op.getOpcode(), false);\n\n  auto ArithmeticShiftRight64 = [&](uint64_t ShiftAmt) {\n    assert((VT == MVT::v2i64 || VT == MVT::v4i64) && \"Unexpected SRA type\");\n    MVT ExVT = MVT::getVectorVT(MVT::i32, VT.getVectorNumElements() * 2);\n    SDValue Ex = DAG.getBitcast(ExVT, R);\n\n    // ashr(R, 63) === cmp_slt(R, 0)\n    if (ShiftAmt == 63 && Subtarget.hasSSE42()) {\n      assert((VT != MVT::v4i64 || Subtarget.hasInt256()) &&\n             \"Unsupported PCMPGT op\");\n      return DAG.getNode(X86ISD::PCMPGT, dl, VT, DAG.getConstant(0, dl, VT), R);\n    }\n\n    if (ShiftAmt >= 32) {\n      // Splat sign to upper i32 dst, and SRA upper i32 src to lower i32.\n      SDValue Upper =\n          getTargetVShiftByConstNode(X86ISD::VSRAI, dl, ExVT, Ex, 31, DAG);\n      SDValue Lower = getTargetVShiftByConstNode(X86ISD::VSRAI, dl, ExVT, Ex,\n                                                 ShiftAmt - 32, DAG);\n      if (VT == MVT::v2i64)\n        Ex = DAG.getVectorShuffle(ExVT, dl, Upper, Lower, {5, 1, 7, 3});\n      if (VT == MVT::v4i64)\n        Ex = DAG.getVectorShuffle(ExVT, dl, Upper, Lower,\n                                  {9, 1, 11, 3, 13, 5, 15, 7});\n    } else {\n      // SRA upper i32, SRL whole i64 and select lower i32.\n      SDValue Upper = getTargetVShiftByConstNode(X86ISD::VSRAI, dl, ExVT, Ex,\n                                                 ShiftAmt, DAG);\n      SDValue Lower =\n          getTargetVShiftByConstNode(X86ISD::VSRLI, dl, VT, R, ShiftAmt, DAG);\n      Lower = DAG.getBitcast(ExVT, Lower);\n      if (VT == MVT::v2i64)\n        Ex = DAG.getVectorShuffle(ExVT, dl, Upper, Lower, {4, 1, 6, 3});\n      if (VT == MVT::v4i64)\n        Ex = DAG.getVectorShuffle(ExVT, dl, Upper, Lower,\n                                  {8, 1, 10, 3, 12, 5, 14, 7});\n    }\n    return DAG.getBitcast(VT, Ex);\n  };\n\n  // Optimize shl/srl/sra with constant shift amount.\n  APInt APIntShiftAmt;\n  if (!X86::isConstantSplat(Amt, APIntShiftAmt))\n    return SDValue();\n\n  // If the shift amount is out of range, return undef.\n  if (APIntShiftAmt.uge(VT.getScalarSizeInBits()))\n    return DAG.getUNDEF(VT);\n\n  uint64_t ShiftAmt = APIntShiftAmt.getZExtValue();\n\n  if (SupportedVectorShiftWithImm(VT, Subtarget, Op.getOpcode()))\n    return getTargetVShiftByConstNode(X86Opc, dl, VT, R, ShiftAmt, DAG);\n\n  // i64 SRA needs to be performed as partial shifts.\n  if (((!Subtarget.hasXOP() && VT == MVT::v2i64) ||\n       (Subtarget.hasInt256() && VT == MVT::v4i64)) &&\n      Op.getOpcode() == ISD::SRA)\n    return ArithmeticShiftRight64(ShiftAmt);\n\n  if (VT == MVT::v16i8 || (Subtarget.hasInt256() && VT == MVT::v32i8) ||\n      (Subtarget.hasBWI() && VT == MVT::v64i8)) {\n    unsigned NumElts = VT.getVectorNumElements();\n    MVT ShiftVT = MVT::getVectorVT(MVT::i16, NumElts / 2);\n\n    // Simple i8 add case\n\n>>> [ INFILL ] <<<\n      return DAG.getNode(ISD::ADD, dl, VT, R, R);\n\n    // ashr(R, 7)  === cmp_slt(R, 0)\n    if (Op.getOpcode() == ISD::SRA && ShiftAmt == 7) {\n      SDValue Zeros = DAG.getConstant(0, dl, VT);\n      if (VT.is512BitVector()) {\n        assert(VT == MVT::v64i8 && \"Unexpected element type!\");\n        SDValue CMP = DAG.getSetCC(dl, MVT::v64i1, Zeros, R, ISD::SETGT);\n        return DAG.getNode(ISD::SIGN_EXTEND, dl, VT, CMP);\n      }\n      return DAG.getNode(X86ISD::PCMPGT, dl, VT, Zeros, R);\n    }\n\n    // XOP can shift v16i8 directly instead of as shift v8i16 + mask.\n    if (VT == MVT::v16i8 && Subtarget.hasXOP())\n      return SDValue();\n\n    if (Op.getOpcode() == ISD::SHL) {\n      // Make a large shift.\n      SDValue SHL = getTargetVShiftByConstNode(X86ISD::VSHLI, dl, ShiftVT, R,\n                                               ShiftAmt, DAG);\n      SHL = DAG.getBitcast(VT, SHL);\n      // Zero out the rightmost bits.\n      APInt Mask = APInt::getHighBitsSet(8, 8 - ShiftAmt);\n      return DAG.getNode(ISD::AND, dl, VT, SHL, DAG.getConstant(Mask, dl, VT));\n    }\n    if (Op.getOpcode() == ISD::SRL) {\n      // Make a large shift.\n      SDValue SRL = getTargetVShiftByConstNode(X86ISD::VSRLI, dl, ShiftVT, R,\n                                               ShiftAmt, DAG);\n      SRL = DAG.getBitcast(VT, SRL);\n      // Zero out the leftmost bits.\n      APInt Mask = APInt::getLowBitsSet(8, 8 - ShiftAmt);\n      return DAG.getNode(ISD::AND, dl, VT, SRL, DAG.getConstant(Mask, dl, VT));\n    }\n    if (Op.getOpcode() == ISD::SRA) {\n      // ashr(R, Amt) === sub(xor(lshr(R, Amt), Mask), Mask)\n      SDValue Res = DAG.getNode(ISD::SRL, dl, VT, R, Amt);\n\n      SDValue Mask = DAG.getConstant(128 >> ShiftAmt, dl, VT);\n      Res = DAG.getNode(ISD::XOR, dl, VT, Res, Mask);\n      Res = DAG.getNode(ISD::SUB, dl, VT, Res, Mask);\n      return Res;\n    }\n    llvm_unreachable(\"Unknown shift opcode.\");\n  }\n\n  return SDValue();\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    if (Op.getOpcode() == ISD::SHL && ShiftAmt == 1)\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/bitreverse.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/bitreverse.ll\n\n\nTesting Time: 1.35s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/combine-bitreverse.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/combine-bitreverse.ll\n\n\nTesting Time: 0.24s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-bitreverse.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-bitreverse.ll\n\n\nTesting Time: 1.37s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-fshl-rot-128.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-fshl-rot-128.ll\n\n\nTesting Time: 0.30s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-fshl-rot-256.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-fshl-rot-256.ll\n\n\nTesting Time: 0.59s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-fshl-rot-512.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-fshl-rot-512.ll\n\n\nTesting Time: 1.14s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-fshr-128.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-fshr-128.ll\n\n\nTesting Time: 0.36s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-fshr-256.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-fshr-256.ll\n\n\nTesting Time: 2.80s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-fshr-rot-128.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-fshr-rot-128.ll\n\n\nTesting Time: 0.30s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/vector-fshr-rot-256.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/vector-fshr-rot-256.ll\n\n\nTesting Time: 0.60s\n  Failed: 1\n-- Testing: 1 tests,  \nPlease provide the correct line following commit message at the infill location."}], "idx": "307890f85b33bc190b563bcb3daeb232b8ecaa73___X86ISelLowering.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid X86AsmPrinter::emitAsanReportError(Module &M, unsigned Reg,\n                                        const ASanAccessInfo &AccessInfo,\n                                        MCSubtargetInfo &STI) {\n  std::string Name = AccessInfo.IsWrite ? \"store\" : \"load\";\n  MCSymbol *ReportError = OutContext.getOrCreateSymbol(\n      \"__asan_report_\" + Name + utostr(1ULL << AccessInfo.AccessSizeIndex));\n  OutStreamer->emitInstruction(MCInstBuilder(X86::MOV64rr)\n                                   .addReg(X86::RDI)\n                                   .addReg(X86::NoRegister + Reg),\n                               STI);\n  OutStreamer->emitInstruction(\n      MCInstBuilder(X86::JMP_1)\n\n>>> [ INFILL ] <<<\n      STI);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n          .addExpr(MCSymbolRefExpr::create(ReportError, OutContext)),\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/asan-check-memaccess-add.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/asan-check-memaccess-add.ll\n\n\nTesting Time: 0.19s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/asan-check-memaccess-or.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/asan-check-memaccess-or.ll\n\n\nTesting Time: 0.13s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "cf53c6c9710617ea465863e117dda695af2c3ebb___X86MCInstLower.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nbool IndVarSimplify::run(Loop *L) {\n  // We need (and expect!) the incoming loop to be in LCSSA.\n  assert(L->isRecursivelyLCSSAForm(*DT, *LI) &&\n         \"LCSSA required to run indvars!\");\n\n  // If LoopSimplify form is not available, stay out of trouble. Some notes:\n  //  - LSR currently only supports LoopSimplify-form loops. Indvars'\n  //    canonicalization can be a pessimization without LSR to \"clean up\"\n  //    afterwards.\n  //  - We depend on having a preheader; in particular,\n  //    Loop::getCanonicalInductionVariable only supports loops with preheaders,\n  //    and we're in trouble if we can't find the induction variable even when\n  //    we've manually inserted one.\n  //  - LFTR relies on having a single backedge.\n  if (!L->isLoopSimplifyForm())\n    return false;\n\n#ifndef NDEBUG\n  // Used below for a consistency check only\n  // Note: Since the result returned by ScalarEvolution may depend on the order\n  // in which previous results are added to its cache, the call to\n  // getBackedgeTakenCount() may change following SCEV queries.\n  const SCEV *BackedgeTakenCount;\n  if (VerifyIndvars)\n    BackedgeTakenCount = SE->getBackedgeTakenCount(L);\n#endif\n\n  bool Changed = false;\n  // If there are any floating-point recurrences, attempt to\n  // transform them to use integer recurrences.\n  Changed |= rewriteNonIntegerIVs(L);\n\n  // Create a rewriter object which we'll use to transform the code with.\n  SCEVExpander Rewriter(*SE, DL, \"indvars\");\n#ifndef NDEBUG\n  Rewriter.setDebugType(DEBUG_TYPE);\n#endif\n\n  // Eliminate redundant IV users.\n  //\n  // Simplification works best when run before other consumers of SCEV. We\n  // attempt to avoid evaluating SCEVs for sign/zero extend operations until\n  // other expressions involving loop IVs have been evaluated. This helps SCEV\n  // set no-wrap flags before normalizing sign/zero extension.\n  Rewriter.disableCanonicalMode();\n  Changed |= simplifyAndExtend(L, Rewriter, LI);\n\n  // Check to see if we can compute the final value of any expressions\n  // that are recurrent in the loop, and substitute the exit values from the\n  // loop into any instructions outside of the loop that use the final values\n  // of the current expressions.\n  if (ReplaceExitValue != NeverRepl) {\n    if (int Rewrites = rewriteLoopExitValues(L, LI, TLI, SE, TTI, Rewriter, DT,\n                                             ReplaceExitValue, DeadInsts)) {\n      NumReplaced += Rewrites;\n      Changed = true;\n    }\n  }\n\n  // Eliminate redundant IV cycles.\n\n>>> [ INFILL ] <<<\n\n  // Try to convert exit conditions to unsigned and rotate computation\n  // out of the loop.  Note: Handles invalidation internally if needed.\n  Changed |= canonicalizeExitCondition(L);\n\n  // Try to eliminate loop exits based on analyzeable exit counts\n  if (optimizeLoopExits(L, Rewriter))  {\n    Changed = true;\n    // Given we've changed exit counts, notify SCEV\n    // Some nested loops may share same folded exit basic block,\n    // thus we need to notify top most loop.\n    SE->forgetTopmostLoop(L);\n  }\n\n  // Try to form loop invariant tests for loop exits by changing how many\n  // iterations of the loop run when that is unobservable.\n  if (predicateLoopExits(L, Rewriter)) {\n    Changed = true;\n    // Given we've changed exit counts, notify SCEV\n    SE->forgetLoop(L);\n  }\n\n  // If we have a trip count expression, rewrite the loop's exit condition\n  // using it.\n  if (!DisableLFTR) {\n    BasicBlock *PreHeader = L->getLoopPreheader();\n    BranchInst *PreHeaderBR = cast<BranchInst>(PreHeader->getTerminator());\n\n    SmallVector<BasicBlock*, 16> ExitingBlocks;\n    L->getExitingBlocks(ExitingBlocks);\n    for (BasicBlock *ExitingBB : ExitingBlocks) {\n      // Can't rewrite non-branch yet.\n      if (!isa<BranchInst>(ExitingBB->getTerminator()))\n        continue;\n\n      // If our exitting block exits multiple loops, we can only rewrite the\n      // innermost one.  Otherwise, we're changing how many times the innermost\n      // loop runs before it exits.\n      if (LI->getLoopFor(ExitingBB) != L)\n        continue;\n\n      if (!needsLFTR(L, ExitingBB))\n        continue;\n\n      const SCEV *ExitCount = SE->getExitCount(L, ExitingBB);\n      if (isa<SCEVCouldNotCompute>(ExitCount))\n        continue;\n\n      // This was handled above, but as we form SCEVs, we can sometimes refine\n      // existing ones; this allows exit counts to be folded to zero which\n      // weren't when optimizeLoopExits saw them.  Arguably, we should iterate\n      // until stable to handle cases like this better.\n      if (ExitCount->isZero())\n        continue;\n\n      PHINode *IndVar = FindLoopCounter(L, ExitingBB, ExitCount, SE, DT);\n      if (!IndVar)\n        continue;\n\n      // Avoid high cost expansions.  Note: This heuristic is questionable in\n      // that our definition of \"high cost\" is not exactly principled.\n      if (Rewriter.isHighCostExpansion(ExitCount, L, SCEVCheapExpansionBudget,\n                                       TTI, PreHeaderBR))\n        continue;\n\n      // Check preconditions for proper SCEVExpander operation. SCEV does not\n      // express SCEVExpander's dependencies, such as LoopSimplify. Instead\n      // any pass that uses the SCEVExpander must do it. This does not work\n      // well for loop passes because SCEVExpander makes assumptions about\n      // all loops, while LoopPassManager only forces the current loop to be\n      // simplified.\n      //\n      // FIXME: SCEV expansion has no way to bail out, so the caller must\n      // explicitly check any assumptions made by SCEV. Brittle.\n      const SCEVAddRecExpr *AR = dyn_cast<SCEVAddRecExpr>(ExitCount);\n      if (!AR || AR->getLoop()->getLoopPreheader())\n        Changed |= linearFunctionTestReplace(L, ExitingBB,\n                                             ExitCount, IndVar,\n                                             Rewriter);\n    }\n  }\n  // Clear the rewriter cache, because values that are in the rewriter's cache\n  // can be deleted in the loop below, causing the AssertingVH in the cache to\n  // trigger.\n  Rewriter.clear();\n\n  // Now that we're done iterating through lists, clean up any instructions\n  // which are now dead.\n  while (!DeadInsts.empty()) {\n    Value *V = DeadInsts.pop_back_val();\n\n    if (PHINode *PHI = dyn_cast_or_null<PHINode>(V))\n      Changed |= RecursivelyDeleteDeadPHINode(PHI, TLI, MSSAU.get());\n    else if (Instruction *Inst = dyn_cast_or_null<Instruction>(V))\n      Changed |=\n          RecursivelyDeleteTriviallyDeadInstructions(Inst, TLI, MSSAU.get());\n  }\n\n  // The Rewriter may not be used from this point on.\n\n  // Loop-invariant instructions in the preheader that aren't used in the\n  // loop may be sunk below the loop to reduce register pressure.\n  Changed |= sinkUnusedInvariants(L);\n\n  // rewriteFirstIterationLoopExitValues does not rely on the computation of\n  // trip count and therefore can further simplify exit values in addition to\n  // rewriteLoopExitValues.\n  Changed |= rewriteFirstIterationLoopExitValues(L);\n\n  // Clean up dead instructions.\n  Changed |= DeleteDeadPHIs(L->getHeader(), TLI, MSSAU.get());\n\n  // Check a post-condition.\n  assert(L->isRecursivelyLCSSAForm(*DT, *LI) &&\n         \"Indvars did not preserve LCSSA!\");\n\n  // Verify that LFTR, and any other change have not interfered with SCEV's\n  // ability to compute trip count.  We may have *changed* the exit count, but\n  // only by reducing it.\n#ifndef NDEBUG\n  if (VerifyIndvars && !isa<SCEVCouldNotCompute>(BackedgeTakenCount)) {\n    SE->forgetLoop(L);\n    const SCEV *NewBECount = SE->getBackedgeTakenCount(L);\n    if (SE->getTypeSizeInBits(BackedgeTakenCount->getType()) <\n        SE->getTypeSizeInBits(NewBECount->getType()))\n      NewBECount = SE->getTruncateOrNoop(NewBECount,\n                                         BackedgeTakenCount->getType());\n    else\n      BackedgeTakenCount = SE->getTruncateOrNoop(BackedgeTakenCount,\n                                                 NewBECount->getType());\n    assert(!SE->isKnownPredicate(ICmpInst::ICMP_ULT, BackedgeTakenCount,\n                                 NewBECount) && \"indvars must preserve SCEV\");\n  }\n  if (VerifyMemorySSA && MSSAU)\n    MSSAU->getMemorySSA()->verifyMemorySSA();\n#endif\n\n  return Changed;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  NumElimIV += Rewriter.replaceCongruentIVs(L, DT, DeadInsts);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/LoopVectorize/X86/gather_scatter.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/LoopVectorize/X86/gather_scatter.ll\n\n\nTesting Time: 3.98s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/IndVarSimplify/X86/pr27133.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/IndVarSimplify/X86/pr27133.ll\n\n\nTesting Time: 0.12s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/PhaseOrdering/X86/pixel-splat.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/PhaseOrdering/X86/pixel-splat.ll\n\n\nTesting Time: 0.16s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Transforms/PhaseOrdering/X86/vdiv.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/PhaseOrdering/X86/vdiv.ll\n\n\nTesting Time: 0.23s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "5ec23863320ca12bfabb6dcff1d0425cb614b7a5___IndVarSimplify.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid DwarfCompileUnit::createBaseTypeDIEs() {\n  // Insert the base_type DIEs directly after the CU so that their offsets will\n  // fit in the fixed size ULEB128 used inside the location expressions.\n  // Maintain order by iterating backwards and inserting to the front of CU\n  // child list.\n  for (auto &Btr : reverse(ExprRefedBaseTypes)) {\n    DIE &Die = getUnitDie().addChildFront(\n      DIE::get(DIEValueAllocator, dwarf::DW_TAG_base_type));\n    SmallString<32> Str;\n    addString(Die, dwarf::DW_AT_name,\n              Twine(dwarf::AttributeEncodingString(Btr.Encoding) +\n                    \"_\" + Twine(Btr.BitSize)).toStringRef(Str));\n    addUInt(Die, dwarf::DW_AT_encoding, dwarf::DW_FORM_data1, Btr.Encoding);\n\n>>> [ INFILL ] <<<\n\n    Btr.Die = &Die;\n  }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    addUInt(Die, dwarf::DW_AT_byte_size, None, Btr.BitSize / 8);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/X86/base-type-size.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: DebugInfo/X86/base-type-size.ll\n\n\nTesting Time: 0.35s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "b6a41fddcfd375ce30487ef87ca2cd65a6be0bcc___DwarfCompileUnit.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nbool StructurizeCFG::run(Region *R, DominatorTree *DT) {\n  if (R->isTopLevelRegion())\n    return false;\n\n  this->DT = DT;\n\n  Func = R->getEntry()->getParent();\n  ParentRegion = R;\n\n  orderNodes();\n  collectInfos();\n  createFlow();\n  insertConditions(false);\n  insertConditions(true);\n\n>>> [ INFILL ] <<<\n  setPhiValues();\n  simplifyAffectedPhis();\n  rebuildSSA();\n\n  // Cleanup\n  Order.clear();\n  Visited.clear();\n  DeletedPhis.clear();\n  AddedPhis.clear();\n  Predicates.clear();\n  Conditions.clear();\n  Loops.clear();\n  LoopPreds.clear();\n  LoopConds.clear();\n\n  return true;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  simplifyConditions();\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/StructurizeCFG/invert-condition.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/StructurizeCFG/invert-condition.ll\n\n\nTesting Time: 0.30s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "0e74d75a295729bc145724ffa0495fee4d1b598c___StructurizeCFG.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nbool MemCpyOptPass::processMemCpy(MemCpyInst *M, BasicBlock::iterator &BBI) {\n  // We can only optimize non-volatile memcpy's.\n  if (M->isVolatile()) return false;\n\n  // If the source and destination of the memcpy are the same, then zap it.\n  if (M->getSource() == M->getDest()) {\n    ++BBI;\n    eraseInstruction(M);\n    return true;\n  }\n\n  // If copying from a constant, try to turn the memcpy into a memset.\n  if (auto *GV = dyn_cast<GlobalVariable>(M->getSource()))\n    if (GV->isConstant() && GV->hasDefinitiveInitializer())\n      if (Value *ByteVal = isBytewiseValue(GV->getInitializer(),\n                                           M->getModule()->getDataLayout())) {\n        IRBuilder<> Builder(M);\n        Instruction *NewM =\n            Builder.CreateMemSet(M->getRawDest(), ByteVal, M->getLength(),\n                                 MaybeAlign(M->getDestAlignment()), false);\n        auto *LastDef =\n            cast<MemoryDef>(MSSAU->getMemorySSA()->getMemoryAccess(M));\n        auto *NewAccess =\n            MSSAU->createMemoryAccessAfter(NewM, LastDef, LastDef);\n        MSSAU->insertDef(cast<MemoryDef>(NewAccess), /*RenameUses=*/true);\n\n        eraseInstruction(M);\n        ++NumCpyToSet;\n        return true;\n      }\n\n  MemoryUseOrDef *MA = MSSA->getMemoryAccess(M);\n\n>>> [ INFILL ] <<<\n  MemoryLocation DestLoc = MemoryLocation::getForDest(M);\n  const MemoryAccess *DestClobber =\n      MSSA->getWalker()->getClobberingMemoryAccess(AnyClobber, DestLoc);\n\n  // Try to turn a partially redundant memset + memcpy into\n  // memcpy + smaller memset.  We don't need the memcpy size for this.\n  // The memcpy most post-dom the memset, so limit this to the same basic\n  // block. A non-local generalization is likely not worthwhile.\n  if (auto *MD = dyn_cast<MemoryDef>(DestClobber))\n    if (auto *MDep = dyn_cast_or_null<MemSetInst>(MD->getMemoryInst()))\n      if (DestClobber->getBlock() == M->getParent())\n        if (processMemSetMemCpyDependence(M, MDep))\n          return true;\n\n  MemoryAccess *SrcClobber = MSSA->getWalker()->getClobberingMemoryAccess(\n      AnyClobber, MemoryLocation::getForSource(M));\n\n  // There are four possible optimizations we can do for memcpy:\n  //   a) memcpy-memcpy xform which exposes redundance for DSE.\n  //   b) call-memcpy xform for return slot optimization.\n  //   c) memcpy from freshly alloca'd space or space that has just started\n  //      its lifetime copies undefined data, and we can therefore eliminate\n  //      the memcpy in favor of the data that was already at the destination.\n  //   d) memcpy from a just-memset'd source can be turned into memset.\n  if (auto *MD = dyn_cast<MemoryDef>(SrcClobber)) {\n    if (Instruction *MI = MD->getMemoryInst()) {\n      if (auto *CopySize = dyn_cast<ConstantInt>(M->getLength())) {\n        if (auto *C = dyn_cast<CallInst>(MI)) {\n          // FIXME: Can we pass in either of dest/src alignment here instead\n          // of conservatively taking the minimum?\n          Align Alignment = std::min(M->getDestAlign().valueOrOne(),\n                                     M->getSourceAlign().valueOrOne());\n          if (performCallSlotOptzn(\n                  M, M, M->getDest(), M->getSource(),\n                  TypeSize::getFixed(CopySize->getZExtValue()), Alignment,\n                  [C]() -> CallInst * { return C; })) {\n            LLVM_DEBUG(dbgs() << \"Performed call slot optimization:\\n\"\n                              << \"    call: \" << *C << \"\\n\"\n                              << \"    memcpy: \" << *M << \"\\n\");\n            eraseInstruction(M);\n            ++NumMemCpyInstr;\n            return true;\n          }\n        }\n      }\n      if (auto *MDep = dyn_cast<MemCpyInst>(MI))\n        return processMemCpyMemCpyDependence(M, MDep);\n      if (auto *MDep = dyn_cast<MemSetInst>(MI)) {\n        if (performMemCpyToMemSetOptzn(M, MDep)) {\n          LLVM_DEBUG(dbgs() << \"Converted memcpy to memset\\n\");\n          eraseInstruction(M);\n          ++NumCpyToSet;\n          return true;\n        }\n      }\n    }\n\n    if (hasUndefContents(MSSA, AA, M->getSource(), MD, M->getLength())) {\n      LLVM_DEBUG(dbgs() << \"Removed memcpy from undef\\n\");\n      eraseInstruction(M);\n      ++NumMemCpyInstr;\n      return true;\n    }\n  }\n\n  return false;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  MemoryAccess *AnyClobber = MSSA->getWalker()->getClobberingMemoryAccess(MA);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/MemCpyOpt/pr54682.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/MemCpyOpt/pr54682.ll\n\n\nTesting Time: 0.32s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "a5c3b5748c1176c11bdc041271ead5392295742d___MemCpyOptimizer.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nDIE &DwarfUnit::constructMemberDIE(DIE &Buffer, const DIDerivedType *DT) {\n  DIE &MemberDie = createAndAddDIE(DT->getTag(), Buffer);\n  StringRef Name = DT->getName();\n  if (!Name.empty())\n    addString(MemberDie, dwarf::DW_AT_name, Name);\n\n  addAnnotation(MemberDie, DT->getAnnotations());\n\n  if (DIType *Resolved = DT->getBaseType())\n    addType(MemberDie, Resolved);\n\n  addSourceLine(MemberDie, DT);\n\n  if (DT->getTag() == dwarf::DW_TAG_inheritance && DT->isVirtual()) {\n\n    // For C++, virtual base classes are not at fixed offset. Use following\n    // expression to extract appropriate offset from vtable.\n    // BaseAddr = ObAddr + *((*ObAddr) - Offset)\n\n    DIELoc *VBaseLocationDie = new (DIEValueAllocator) DIELoc;\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_dup);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_constu);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_udata, DT->getOffsetInBits());\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_minus);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus);\n\n    addBlock(MemberDie, dwarf::DW_AT_data_member_location, VBaseLocationDie);\n  } else {\n    uint64_t Size = DT->getSizeInBits();\n    uint64_t FieldSize = DD->getBaseTypeSize(DT);\n    uint32_t AlignInBytes = DT->getAlignInBytes();\n    uint64_t OffsetInBytes;\n\n\n>>> [ INFILL ] <<<\n    if (IsBitfield) {\n      // Handle bitfield, assume bytes are 8 bits.\n      if (DD->useDWARF2Bitfields())\n        addUInt(MemberDie, dwarf::DW_AT_byte_size, None, FieldSize/8);\n      addUInt(MemberDie, dwarf::DW_AT_bit_size, None, Size);\n\n      uint64_t Offset = DT->getOffsetInBits();\n      // We can't use DT->getAlignInBits() here: AlignInBits for member type\n      // is non-zero if and only if alignment was forced (e.g. _Alignas()),\n      // which can't be done with bitfields. Thus we use FieldSize here.\n      uint32_t AlignInBits = FieldSize;\n      uint32_t AlignMask = ~(AlignInBits - 1);\n      // The bits from the start of the storage unit to the start of the field.\n      uint64_t StartBitOffset = Offset - (Offset & AlignMask);\n      // The byte offset of the field's aligned storage unit inside the struct.\n      OffsetInBytes = (Offset - StartBitOffset) / 8;\n\n      if (DD->useDWARF2Bitfields()) {\n        uint64_t HiMark = (Offset + FieldSize) & AlignMask;\n        uint64_t FieldOffset = (HiMark - FieldSize);\n        Offset -= FieldOffset;\n\n        // Maybe we need to work from the other end.\n        if (Asm->getDataLayout().isLittleEndian())\n          Offset = FieldSize - (Offset + Size);\n\n        addUInt(MemberDie, dwarf::DW_AT_bit_offset, None, Offset);\n        OffsetInBytes = FieldOffset >> 3;\n      } else {\n        addUInt(MemberDie, dwarf::DW_AT_data_bit_offset, None, Offset);\n      }\n    } else {\n      // This is not a bitfield.\n      OffsetInBytes = DT->getOffsetInBits() / 8;\n      if (AlignInBytes)\n        addUInt(MemberDie, dwarf::DW_AT_alignment, dwarf::DW_FORM_udata,\n                AlignInBytes);\n    }\n\n    if (DD->getDwarfVersion() <= 2) {\n      DIELoc *MemLocationDie = new (DIEValueAllocator) DIELoc;\n      addUInt(*MemLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus_uconst);\n      addUInt(*MemLocationDie, dwarf::DW_FORM_udata, OffsetInBytes);\n      addBlock(MemberDie, dwarf::DW_AT_data_member_location, MemLocationDie);\n    } else if (!IsBitfield || DD->useDWARF2Bitfields()) {\n      // In DWARF v3, DW_FORM_data4/8 in DW_AT_data_member_location are\n      // interpreted as location-list pointers. Interpreting constants as\n      // pointers is not expected, so we use DW_FORM_udata to encode the\n      // constants here.\n      if (DD->getDwarfVersion() == 3)\n        addUInt(MemberDie, dwarf::DW_AT_data_member_location,\n                dwarf::DW_FORM_udata, OffsetInBytes);\n      else\n        addUInt(MemberDie, dwarf::DW_AT_data_member_location, None,\n                OffsetInBytes);\n    }\n  }\n\n  addAccess(MemberDie, DT->getFlags());\n\n  if (DT->isVirtual())\n    addUInt(MemberDie, dwarf::DW_AT_virtuality, dwarf::DW_FORM_data1,\n            dwarf::DW_VIRTUALITY_virtual);\n\n  // Objective-C properties.\n  if (DINode *PNode = DT->getObjCProperty())\n    if (DIE *PDie = getDIE(PNode))\n      addAttribute(MemberDie, dwarf::DW_AT_APPLE_property,\n                   dwarf::DW_FORM_ref4, DIEEntry(*PDie));\n\n  if (DT->isArtificial())\n    addFlag(MemberDie, dwarf::DW_AT_artificial);\n\n  return MemberDie;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    bool IsBitfield = FieldSize && Size != FieldSize;\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/X86/packed_bitfields2.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: DebugInfo/X86/packed_bitfields2.ll\n\n\nTesting Time: 0.11s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "059d1f84d2d59093300a81c246de81b1c1da767b___DwarfUnit.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic bool isSafeToMove(Instruction *Inst, AliasAnalysis &AA,\n                         SmallPtrSetImpl<Instruction *> &Stores) {\n\n  if (Inst->mayWriteToMemory()) {\n    Stores.insert(Inst);\n    return false;\n  }\n\n  if (LoadInst *L = dyn_cast<LoadInst>(Inst)) {\n    MemoryLocation Loc = MemoryLocation::get(L);\n    for (Instruction *S : Stores)\n      if (isModSet(AA.getModRefInfo(S, Loc)))\n        return false;\n  }\n\n  if (Inst->isTerminator() || isa<PHINode>(Inst) || Inst->isEHPad() ||\n\n>>> [ INFILL ] <<<\n    return false;\n\n  if (auto *Call = dyn_cast<CallBase>(Inst)) {\n    // Convergent operations cannot be made control-dependent on additional\n    // values.\n    if (Call->isConvergent())\n      return false;\n\n    for (Instruction *S : Stores)\n      if (isModSet(AA.getModRefInfo(S, Call)))\n        return false;\n  }\n\n  return true;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n      Inst->mayThrow())\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/Sink/call.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/Sink/call.ll\n\n\nTesting Time: 0.22s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "e22af03a794d633915d0b51c15e05bb9cb9b4ec9___Sink.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic SDValue combineOr(SDNode *N, SelectionDAG &DAG,\n                         TargetLowering::DAGCombinerInfo &DCI,\n                         const X86Subtarget &Subtarget) {\n  SDValue N0 = N->getOperand(0);\n  SDValue N1 = N->getOperand(1);\n  EVT VT = N->getValueType(0);\n  SDLoc dl(N);\n  const TargetLowering &TLI = DAG.getTargetLoweringInfo();\n\n  // If this is SSE1 only convert to FOR to avoid scalarization.\n  if (Subtarget.hasSSE1() && !Subtarget.hasSSE2() && VT == MVT::v4i32) {\n    return DAG.getBitcast(MVT::v4i32,\n                          DAG.getNode(X86ISD::FOR, dl, MVT::v4f32,\n                                      DAG.getBitcast(MVT::v4f32, N0),\n                                      DAG.getBitcast(MVT::v4f32, N1)));\n  }\n\n  // Match any-of bool scalar reductions into a bitcast/movmsk + cmp.\n  // TODO: Support multiple SrcOps.\n  if (VT == MVT::i1) {\n    SmallVector<SDValue, 2> SrcOps;\n    SmallVector<APInt, 2> SrcPartials;\n    if (matchScalarReduction(SDValue(N, 0), ISD::OR, SrcOps, &SrcPartials) &&\n        SrcOps.size() == 1) {\n      unsigned NumElts = SrcOps[0].getValueType().getVectorNumElements();\n      EVT MaskVT = EVT::getIntegerVT(*DAG.getContext(), NumElts);\n      SDValue Mask = combineBitcastvxi1(DAG, MaskVT, SrcOps[0], dl, Subtarget);\n      if (!Mask && TLI.isTypeLegal(SrcOps[0].getValueType()))\n        Mask = DAG.getBitcast(MaskVT, SrcOps[0]);\n      if (Mask) {\n        assert(SrcPartials[0].getBitWidth() == NumElts &&\n               \"Unexpected partial reduction mask\");\n        SDValue ZeroBits = DAG.getConstant(0, dl, MaskVT);\n        SDValue PartialBits = DAG.getConstant(SrcPartials[0], dl, MaskVT);\n        Mask = DAG.getNode(ISD::AND, dl, MaskVT, Mask, PartialBits);\n        return DAG.getSetCC(dl, MVT::i1, Mask, ZeroBits, ISD::SETNE);\n      }\n    }\n  }\n\n  if (SDValue R = combineBitOpWithMOVMSK(N, DAG))\n    return R;\n\n  if (SDValue R = combineBitOpWithShift(N, DAG))\n    return R;\n\n  if (SDValue FPLogic = convertIntLogicToFPLogic(N, DAG, DCI, Subtarget))\n    return FPLogic;\n\n  if (DCI.isBeforeLegalizeOps())\n    return SDValue();\n\n  if (SDValue R = combineCompareEqual(N, DAG, DCI, Subtarget))\n    return R;\n\n  if (SDValue R = canonicalizeBitSelect(N, DAG, Subtarget))\n    return R;\n\n  if (SDValue R = combineLogicBlendIntoPBLENDV(N, DAG, Subtarget))\n    return R;\n\n  // (0 - SetCC) | C -> (zext (not SetCC)) * (C + 1) - 1 if we can get a LEA out of it.\n  if ((VT == MVT::i32 || VT == MVT::i64) &&\n      N0.getOpcode() == ISD::SUB && N0.hasOneUse() &&\n      isNullConstant(N0.getOperand(0))) {\n    SDValue Cond = N0.getOperand(1);\n    if (Cond.getOpcode() == ISD::ZERO_EXTEND && Cond.hasOneUse())\n      Cond = Cond.getOperand(0);\n\n    if (Cond.getOpcode() == X86ISD::SETCC && Cond.hasOneUse()) {\n      if (auto *CN = dyn_cast<ConstantSDNode>(N1)) {\n\n>>> [ INFILL ] <<<\n        if (Val == 1 || Val == 2 || Val == 3 || Val == 4 || Val == 7 || Val == 8) {\n          X86::CondCode CCode = (X86::CondCode)Cond.getConstantOperandVal(0);\n          CCode = X86::GetOppositeBranchCondition(CCode);\n          SDValue NotCond = getSETCC(CCode, Cond.getOperand(1), SDLoc(Cond), DAG);\n\n          SDValue R = DAG.getZExtOrTrunc(NotCond, dl, VT);\n          R = DAG.getNode(ISD::MUL, dl, VT, R, DAG.getConstant(Val + 1, dl, VT));\n          R = DAG.getNode(ISD::SUB, dl, VT, R, DAG.getConstant(1, dl, VT));\n          return R;\n        }\n      }\n    }\n  }\n\n  // Combine OR(X,KSHIFTL(Y,Elts/2)) -> CONCAT_VECTORS(X,Y) == KUNPCK(X,Y).\n  // Combine OR(KSHIFTL(X,Elts/2),Y) -> CONCAT_VECTORS(Y,X) == KUNPCK(Y,X).\n  // iff the upper elements of the non-shifted arg are zero.\n  // KUNPCK require 16+ bool vector elements.\n  if (N0.getOpcode() == X86ISD::KSHIFTL || N1.getOpcode() == X86ISD::KSHIFTL) {\n    unsigned NumElts = VT.getVectorNumElements();\n    unsigned HalfElts = NumElts / 2;\n    APInt UpperElts = APInt::getHighBitsSet(NumElts, HalfElts);\n    if (NumElts >= 16 && N1.getOpcode() == X86ISD::KSHIFTL &&\n        N1.getConstantOperandAPInt(1) == HalfElts &&\n        DAG.MaskedVectorIsZero(N0, UpperElts)) {\n      return DAG.getNode(\n          ISD::CONCAT_VECTORS, dl, VT,\n          extractSubVector(N0, 0, DAG, dl, HalfElts),\n          extractSubVector(N1.getOperand(0), 0, DAG, dl, HalfElts));\n    }\n    if (NumElts >= 16 && N0.getOpcode() == X86ISD::KSHIFTL &&\n        N0.getConstantOperandAPInt(1) == HalfElts &&\n        DAG.MaskedVectorIsZero(N1, UpperElts)) {\n      return DAG.getNode(\n          ISD::CONCAT_VECTORS, dl, VT,\n          extractSubVector(N1, 0, DAG, dl, HalfElts),\n          extractSubVector(N0.getOperand(0), 0, DAG, dl, HalfElts));\n    }\n  }\n\n  if (VT.isVector() && (VT.getScalarSizeInBits() % 8) == 0) {\n    // Attempt to recursively combine an OR of shuffles.\n    SDValue Op(N, 0);\n    if (SDValue Res = combineX86ShufflesRecursively(Op, DAG, Subtarget))\n      return Res;\n\n    // If either operand is a constant mask, then only the elements that aren't\n    // allones are actually demanded by the other operand.\n    auto SimplifyUndemandedElts = [&](SDValue Op, SDValue OtherOp) {\n      APInt UndefElts;\n      SmallVector<APInt> EltBits;\n      int NumElts = VT.getVectorNumElements();\n      int EltSizeInBits = VT.getScalarSizeInBits();\n      if (!getTargetConstantBitsFromNode(Op, EltSizeInBits, UndefElts, EltBits))\n        return false;\n\n      APInt DemandedElts = APInt::getZero(NumElts);\n      for (int I = 0; I != NumElts; ++I)\n        if (!EltBits[I].isAllOnes())\n          DemandedElts.setBit(I);\n\n      return TLI.SimplifyDemandedVectorElts(OtherOp, DemandedElts, DCI);\n    };\n    if (SimplifyUndemandedElts(N0, N1) || SimplifyUndemandedElts(N1, N0)) {\n      if (N->getOpcode() != ISD::DELETED_NODE)\n        DCI.AddToWorklist(N);\n      return SDValue(N, 0);\n    }\n  }\n\n  // We should fold \"masked merge\" patterns when `andn` is not available.\n  if (!Subtarget.hasBMI() && VT.isScalarInteger() && VT != MVT::i1)\n    if (SDValue R = foldMaskedMerge(N, DAG))\n      return R;\n\n  return SDValue();\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        unsigned Val = CN->getZExtValue();\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/or-lea.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/or-lea.ll\n\n\nTesting Time: 0.63s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "0513b0305acde91a0a5f7f5ea4061476011f0d1d___X86ISelLowering.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nDIE &DwarfUnit::constructMemberDIE(DIE &Buffer, const DIDerivedType *DT) {\n  DIE &MemberDie = createAndAddDIE(DT->getTag(), Buffer);\n  StringRef Name = DT->getName();\n  if (!Name.empty())\n    addString(MemberDie, dwarf::DW_AT_name, Name);\n\n  addAnnotation(MemberDie, DT->getAnnotations());\n\n  if (DIType *Resolved = DT->getBaseType())\n    addType(MemberDie, Resolved);\n\n  addSourceLine(MemberDie, DT);\n\n  if (DT->getTag() == dwarf::DW_TAG_inheritance && DT->isVirtual()) {\n\n    // For C++, virtual base classes are not at fixed offset. Use following\n    // expression to extract appropriate offset from vtable.\n    // BaseAddr = ObAddr + *((*ObAddr) - Offset)\n\n    DIELoc *VBaseLocationDie = new (DIEValueAllocator) DIELoc;\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_dup);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_constu);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_udata, DT->getOffsetInBits());\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_minus);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_deref);\n    addUInt(*VBaseLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus);\n\n    addBlock(MemberDie, dwarf::DW_AT_data_member_location, VBaseLocationDie);\n  } else {\n    uint64_t Size = DT->getSizeInBits();\n    uint64_t FieldSize = DD->getBaseTypeSize(DT);\n    uint32_t AlignInBytes = DT->getAlignInBytes();\n    uint64_t OffsetInBytes;\n\n\n>>> [ INFILL ] <<<\n    if (IsBitfield) {\n      // Handle bitfield, assume bytes are 8 bits.\n      if (DD->useDWARF2Bitfields())\n        addUInt(MemberDie, dwarf::DW_AT_byte_size, std::nullopt, FieldSize / 8);\n      addUInt(MemberDie, dwarf::DW_AT_bit_size, std::nullopt, Size);\n\n      uint64_t Offset = DT->getOffsetInBits();\n      // We can't use DT->getAlignInBits() here: AlignInBits for member type\n      // is non-zero if and only if alignment was forced (e.g. _Alignas()),\n      // which can't be done with bitfields. Thus we use FieldSize here.\n      uint32_t AlignInBits = FieldSize;\n      uint32_t AlignMask = ~(AlignInBits - 1);\n      // The bits from the start of the storage unit to the start of the field.\n      uint64_t StartBitOffset = Offset - (Offset & AlignMask);\n      // The byte offset of the field's aligned storage unit inside the struct.\n      OffsetInBytes = (Offset - StartBitOffset) / 8;\n\n      if (DD->useDWARF2Bitfields()) {\n        uint64_t HiMark = (Offset + FieldSize) & AlignMask;\n        uint64_t FieldOffset = (HiMark - FieldSize);\n        Offset -= FieldOffset;\n\n        // Maybe we need to work from the other end.\n        if (Asm->getDataLayout().isLittleEndian())\n          Offset = FieldSize - (Offset + Size);\n\n        addUInt(MemberDie, dwarf::DW_AT_bit_offset, std::nullopt, Offset);\n        OffsetInBytes = FieldOffset >> 3;\n      } else {\n        addUInt(MemberDie, dwarf::DW_AT_data_bit_offset, std::nullopt, Offset);\n      }\n    } else {\n      // This is not a bitfield.\n      OffsetInBytes = DT->getOffsetInBits() / 8;\n      if (AlignInBytes)\n        addUInt(MemberDie, dwarf::DW_AT_alignment, dwarf::DW_FORM_udata,\n                AlignInBytes);\n    }\n\n    if (DD->getDwarfVersion() <= 2) {\n      DIELoc *MemLocationDie = new (DIEValueAllocator) DIELoc;\n      addUInt(*MemLocationDie, dwarf::DW_FORM_data1, dwarf::DW_OP_plus_uconst);\n      addUInt(*MemLocationDie, dwarf::DW_FORM_udata, OffsetInBytes);\n      addBlock(MemberDie, dwarf::DW_AT_data_member_location, MemLocationDie);\n    } else if (!IsBitfield || DD->useDWARF2Bitfields()) {\n      // In DWARF v3, DW_FORM_data4/8 in DW_AT_data_member_location are\n      // interpreted as location-list pointers. Interpreting constants as\n      // pointers is not expected, so we use DW_FORM_udata to encode the\n      // constants here.\n      if (DD->getDwarfVersion() == 3)\n        addUInt(MemberDie, dwarf::DW_AT_data_member_location,\n                dwarf::DW_FORM_udata, OffsetInBytes);\n      else\n        addUInt(MemberDie, dwarf::DW_AT_data_member_location, std::nullopt,\n                OffsetInBytes);\n    }\n  }\n\n  addAccess(MemberDie, DT->getFlags());\n\n  if (DT->isVirtual())\n    addUInt(MemberDie, dwarf::DW_AT_virtuality, dwarf::DW_FORM_data1,\n            dwarf::DW_VIRTUALITY_virtual);\n\n  // Objective-C properties.\n  if (DINode *PNode = DT->getObjCProperty())\n    if (DIE *PDie = getDIE(PNode))\n      addAttribute(MemberDie, dwarf::DW_AT_APPLE_property,\n                   dwarf::DW_FORM_ref4, DIEEntry(*PDie));\n\n  if (DT->isArtificial())\n    addFlag(MemberDie, dwarf::DW_AT_artificial);\n\n  return MemberDie;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    bool IsBitfield = FieldSize && Size != FieldSize;\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: DebugInfo/X86/packed_bitfields2.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: DebugInfo/X86/packed_bitfields2.ll\n\n\nTesting Time: 0.12s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "dd881c9dbf5d940eedff7d23395141454c5a26b9___DwarfUnit.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\n\n>>> [ INFILL ] <<<\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  ArrayRef<int64_t> getLastConstraint() { return Constraints[0]; }\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/ConstraintElimination/debug.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/ConstraintElimination/debug.ll\n\n\nTesting Time: 0.37s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "9497680067cc5a2e7d4e0bf657b23d57c06e5e97___ConstraintSystem.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid GVNHoist::checkSafety(CHIArgs C, BasicBlock *BB, GVNHoist::InsKind K,\n                           SmallVectorImpl<CHIArg> &Safe) {\n  int NumBBsOnAllPaths = MaxNumberOfBBSInPath;\n  for (auto CHI : C) {\n    Instruction *Insn = CHI.I;\n    if (!Insn) // No instruction was inserted in this CHI.\n      continue;\n    if (K == InsKind::Scalar) {\n      if (safeToHoistScalar(BB, Insn->getParent(), NumBBsOnAllPaths))\n        Safe.push_back(CHI);\n    } else {\n\n>>> [ INFILL ] <<<\n      if (MemoryUseOrDef *UD = MSSA->getMemoryAccess(Insn))\n        if (safeToHoistLdSt(T, Insn, UD, K, NumBBsOnAllPaths))\n          Safe.push_back(CHI);\n    }\n  }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n      auto *T = BB->getTerminator();\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/GVNHoist/hoist-call.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/GVNHoist/hoist-call.ll\n\n\nTesting Time: 1.96s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "831e99fee90e9406c7260ca66d688ec353110183___GVNHoist.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid AsmPrinter::emitXRayTable() {\n  if (Sleds.empty())\n    return;\n\n  auto PrevSection = OutStreamer->getCurrentSectionOnly();\n  const Function &F = MF->getFunction();\n  MCSection *InstMap = nullptr;\n  MCSection *FnSledIndex = nullptr;\n  const Triple &TT = TM.getTargetTriple();\n  // Use PC-relative addresses on all targets.\n  if (TT.isOSBinFormatELF()) {\n    auto LinkedToSym = cast<MCSymbolELF>(CurrentFnSym);\n    auto Flags = ELF::SHF_ALLOC | ELF::SHF_LINK_ORDER;\n    StringRef GroupName;\n    if (F.hasComdat()) {\n      Flags |= ELF::SHF_GROUP;\n      GroupName = F.getComdat()->getName();\n    }\n    InstMap = OutContext.getELFSection(\"xray_instr_map\", ELF::SHT_PROGBITS,\n                                       Flags, 0, GroupName, F.hasComdat(),\n                                       MCSection::NonUniqueID, LinkedToSym);\n\n    if (TM.Options.XRayFunctionIndex)\n      FnSledIndex = OutContext.getELFSection(\n          \"xray_fn_idx\", ELF::SHT_PROGBITS, Flags, 0, GroupName, F.hasComdat(),\n          MCSection::NonUniqueID, LinkedToSym);\n  } else if (MF->getSubtarget().getTargetTriple().isOSBinFormatMachO()) {\n    InstMap = OutContext.getMachOSection(\"__DATA\", \"xray_instr_map\",\n                                         MachO::S_ATTR_LIVE_SUPPORT,\n                                         SectionKind::getReadOnlyWithRel());\n    if (TM.Options.XRayFunctionIndex)\n      FnSledIndex = OutContext.getMachOSection(\"__DATA\", \"xray_fn_idx\",\n                                               MachO::S_ATTR_LIVE_SUPPORT,\n                                               SectionKind::getReadOnly());\n  } else {\n    llvm_unreachable(\"Unsupported target\");\n  }\n\n  auto WordSizeBytes = MAI->getCodePointerSize();\n\n  // Now we switch to the instrumentation map section. Because this is done\n  // per-function, we are able to create an index entry that will represent the\n  // range of sleds associated with a function.\n  auto &Ctx = OutContext;\n\n>>> [ INFILL ] <<<\n  OutStreamer->switchSection(InstMap);\n  OutStreamer->emitLabel(SledsStart);\n  for (const auto &Sled : Sleds) {\n    MCSymbol *Dot = Ctx.createTempSymbol();\n    OutStreamer->emitLabel(Dot);\n    OutStreamer->emitValueImpl(\n        MCBinaryExpr::createSub(MCSymbolRefExpr::create(Sled.Sled, Ctx),\n                                MCSymbolRefExpr::create(Dot, Ctx), Ctx),\n        WordSizeBytes);\n    OutStreamer->emitValueImpl(\n        MCBinaryExpr::createSub(\n            MCSymbolRefExpr::create(CurrentFnBegin, Ctx),\n            MCBinaryExpr::createAdd(MCSymbolRefExpr::create(Dot, Ctx),\n                                    MCConstantExpr::create(WordSizeBytes, Ctx),\n                                    Ctx),\n            Ctx),\n        WordSizeBytes);\n    Sled.emit(WordSizeBytes, OutStreamer.get());\n  }\n  MCSymbol *SledsEnd = OutContext.createTempSymbol(\"xray_sleds_end\", true);\n  OutStreamer->emitLabel(SledsEnd);\n\n  // We then emit a single entry in the index per function. We use the symbols\n  // that bound the instrumentation map as the range for a specific function.\n  // Each entry here will be 2 * word size aligned, as we're writing down two\n  // pointers. This should work for both 32-bit and 64-bit platforms.\n  if (FnSledIndex) {\n    OutStreamer->switchSection(FnSledIndex);\n    OutStreamer->emitCodeAlignment(Align(2 * WordSizeBytes),\n                                   &getSubtargetInfo());\n    // For Mach-O, use an \"l\" symbol as the atom of this subsection. The label\n    // difference uses a SUBTRACTOR external relocation which references the\n    // symbol.\n    MCSymbol *Dot = Ctx.createLinkerPrivateSymbol(\"xray_fn_idx\");\n    OutStreamer->emitLabel(Dot);\n    OutStreamer->emitValueImpl(\n        MCBinaryExpr::createSub(MCSymbolRefExpr::create(SledsStart, Ctx),\n                                MCSymbolRefExpr::create(Dot, Ctx), Ctx),\n        WordSizeBytes);\n    OutStreamer->emitValueImpl(MCConstantExpr::create(Sleds.size(), Ctx),\n                               WordSizeBytes);\n    OutStreamer->switchSection(PrevSection);\n  }\n  Sleds.clear();\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n  MCSymbol *SledsStart = OutContext.createTempSymbol(\"xray_sleds_start\", true);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: CodeGen/X86/xray-attribute-instrumentation.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/xray-attribute-instrumentation.ll\n\n\nTesting Time: 0.38s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/xray-log-args.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/xray-log-args.ll\n\n\nTesting Time: 0.21s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/xray-partial-instrumentation-skip-entry.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/xray-partial-instrumentation-skip-entry.ll\n\n\nTesting Time: 0.30s\n  Failed: 1\n-- Testing: 1 tests, 1 workers --\nPASS: LLVM :: CodeGen/X86/xray-partial-instrumentation-skip-exit.ll (1 of 1)\n\nTesting Time: 0.27s\n  Passed: 1\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: CodeGen/X86/xray-tail-call-sled.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: CodeGen/X86/xray-tail-call-sled.ll\n\n\nTesting Time: 0.21s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "bef8294650f0119238830d73a7527023c7c8a97f___AsmPrinter.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nInstruction *\nInstCombinerImpl::foldBinOpOfSelectAndCastOfSelectCondition(BinaryOperator &I) {\n  // TODO: this simplification may be extended to any speculatable instruction,\n  // not just binops, and would possibly be handled better in FoldOpIntoSelect.\n  Instruction::BinaryOps Opc = I.getOpcode();\n  Value *LHS = I.getOperand(0), *RHS = I.getOperand(1);\n  Value *A, *CondVal, *TrueVal, *FalseVal;\n  Value *CastOp;\n\n  auto MatchSelectAndCast = [&](Value *CastOp, Value *SelectOp) {\n    return match(CastOp, m_ZExtOrSExt(m_Value(A))) &&\n           A->getType()->getScalarSizeInBits() == 1 &&\n           match(SelectOp, m_Select(m_Value(CondVal), m_Value(TrueVal),\n                                    m_Value(FalseVal)));\n  };\n\n  // Make sure one side of the binop is a select instruction, and the other is a\n  // zero/sign extension operating on a i1.\n  if (MatchSelectAndCast(LHS, RHS))\n    CastOp = LHS;\n  else if (MatchSelectAndCast(RHS, LHS))\n    CastOp = RHS;\n  else\n    return nullptr;\n\n  auto NewFoldedConst = [&](bool IsTrueArm, Value *V) {\n    bool IsCastOpRHS = (CastOp == RHS);\n\n>>> [ INFILL ] <<<\n    Constant *C;\n\n    if (IsTrueArm) {\n      C = Constant::getNullValue(V->getType());\n    } else if (IsZExt) {\n      unsigned BitWidth = V->getType()->getScalarSizeInBits();\n      C = Constant::getIntegerValue(V->getType(), APInt(BitWidth, 1));\n    } else {\n      C = Constant::getAllOnesValue(V->getType());\n    }\n\n    return IsCastOpRHS ? Builder.CreateBinOp(Opc, V, C)\n                       : Builder.CreateBinOp(Opc, C, V);\n  };\n\n  // If the value used in the zext/sext is the select condition, or the negated\n  // of the select condition, the binop can be simplified.\n  if (CondVal == A) {\n    Value *NewTrueVal = NewFoldedConst(false, TrueVal);\n    return SelectInst::Create(CondVal, NewTrueVal,\n                              NewFoldedConst(true, FalseVal));\n  }\n\n  if (match(A, m_Not(m_Specific(CondVal)))) {\n    Value *NewTrueVal = NewFoldedConst(true, TrueVal);\n    return SelectInst::Create(CondVal, NewTrueVal,\n                              NewFoldedConst(false, FalseVal));\n  }\n\n  return nullptr;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    bool IsZExt = isa<ZExtInst>(CastOp);\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/binop-select-cast-of-select-cond.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/binop-select-cast-of-select-cond.ll\n\n\nTesting Time: 0.34s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "c15ccfb24afa67d3c3f54e52cc1d1afa564715ed___InstructionCombining.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\n  bool visitLoadInst(LoadInst &LI) {\n    LLVM_DEBUG(dbgs() << \"    original: \" << LI << \"\\n\");\n    Value *OldOp = LI.getOperand(0);\n    assert(OldOp == OldPtr);\n\n    AAMDNodes AATags = LI.getAAMetadata();\n\n    unsigned AS = LI.getPointerAddressSpace();\n\n    Type *TargetTy = IsSplit ? Type::getIntNTy(LI.getContext(), SliceSize * 8)\n                             : LI.getType();\n    const bool IsLoadPastEnd =\n        DL.getTypeStoreSize(TargetTy).getFixedValue() > SliceSize;\n    bool IsPtrAdjusted = false;\n    Value *V;\n    if (VecTy) {\n      V = rewriteVectorizedLoadInst(LI);\n    } else if (IntTy && LI.getType()->isIntegerTy()) {\n      V = rewriteIntegerLoad(LI);\n    } else if (NewBeginOffset == NewAllocaBeginOffset &&\n               NewEndOffset == NewAllocaEndOffset &&\n               (canConvertValue(DL, NewAllocaTy, TargetTy) ||\n                (IsLoadPastEnd && NewAllocaTy->isIntegerTy() &&\n\n>>> [ INFILL ] <<<\n      Value *NewPtr =\n          getPtrToNewAI(LI.getPointerAddressSpace(), LI.isVolatile());\n      LoadInst *NewLI = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), NewPtr,\n                                              NewAI.getAlign(), LI.isVolatile(),\n                                              LI.getName());\n      if (LI.isVolatile())\n        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());\n      if (NewLI->isAtomic())\n        NewLI->setAlignment(LI.getAlign());\n\n      // Copy any metadata that is valid for the new load. This may require\n      // conversion to a different kind of metadata, e.g. !nonnull might change\n      // to !range or vice versa.\n      copyMetadataForLoad(*NewLI, LI);\n\n      // Do this after copyMetadataForLoad() to preserve the TBAA shift.\n      if (AATags)\n        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));\n\n      // Try to preserve nonnull metadata\n      V = NewLI;\n\n      // If this is an integer load past the end of the slice (which means the\n      // bytes outside the slice are undef or this load is dead) just forcibly\n      // fix the integer size with correct handling of endianness.\n      if (auto *AITy = dyn_cast<IntegerType>(NewAllocaTy))\n        if (auto *TITy = dyn_cast<IntegerType>(TargetTy))\n          if (AITy->getBitWidth() < TITy->getBitWidth()) {\n            V = IRB.CreateZExt(V, TITy, \"load.ext\");\n            if (DL.isBigEndian())\n              V = IRB.CreateShl(V, TITy->getBitWidth() - AITy->getBitWidth(),\n                                \"endian_shift\");\n          }\n    } else {\n      Type *LTy = TargetTy->getPointerTo(AS);\n      LoadInst *NewLI =\n          IRB.CreateAlignedLoad(TargetTy, getNewAllocaSlicePtr(IRB, LTy),\n                                getSliceAlign(), LI.isVolatile(), LI.getName());\n      if (AATags)\n        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));\n      if (LI.isVolatile())\n        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());\n      NewLI->copyMetadata(LI, {LLVMContext::MD_mem_parallel_loop_access,\n                               LLVMContext::MD_access_group});\n\n      V = NewLI;\n      IsPtrAdjusted = true;\n    }\n    V = convertValue(DL, IRB, V, TargetTy);\n\n    if (IsSplit) {\n      assert(!LI.isVolatile());\n      assert(LI.getType()->isIntegerTy() &&\n             \"Only integer type loads and stores are split\");\n      assert(SliceSize < DL.getTypeStoreSize(LI.getType()).getFixedValue() &&\n             \"Split load isn't smaller than original load\");\n      assert(DL.typeSizeEqualsStoreSize(LI.getType()) &&\n             \"Non-byte-multiple bit width\");\n      // Move the insertion point just past the load so that we can refer to it.\n      IRB.SetInsertPoint(&*std::next(BasicBlock::iterator(&LI)));\n      // Create a placeholder value with the same type as LI to use as the\n      // basis for the new value. This allows us to replace the uses of LI with\n      // the computed value, and then replace the placeholder with LI, leaving\n      // LI only used for this computation.\n      Value *Placeholder = new LoadInst(\n          LI.getType(), PoisonValue::get(LI.getType()->getPointerTo(AS)), \"\",\n          false, Align(1));\n      V = insertInteger(DL, IRB, Placeholder, V, NewBeginOffset - BeginOffset,\n                        \"insert\");\n      LI.replaceAllUsesWith(V);\n      Placeholder->replaceAllUsesWith(&LI);\n      Placeholder->deleteValue();\n    } else {\n      LI.replaceAllUsesWith(V);\n    }\n\n    Pass.DeadInsts.push_back(&LI);\n    deleteIfTriviallyDead(OldOp);\n    LLVM_DEBUG(dbgs() << \"          to: \" << *V << \"\\n\");\n    return !LI.isVolatile() && !IsPtrAdjusted;\n  }\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                 TargetTy->isIntegerTy()))) {\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/SROA/basictest.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/SROA/basictest.ll\n\n\nTesting Time: 2.89s\n  Failed: 1\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "57a554800b804a0d849858972822142e1f75d37f___SROA.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nPreservedAnalyses FunctionToLoopPassAdaptor::run(Function &F,\n                                                 FunctionAnalysisManager &AM) {\n  // Before we even compute any loop analyses, first run a miniature function\n  // pass pipeline to put loops into their canonical form. Note that we can\n  // directly build up function analyses after this as the function pass\n  // manager handles all the invalidation at that layer.\n  PassInstrumentation PI = AM.getResult<PassInstrumentationAnalysis>(F);\n\n  PreservedAnalyses PA = PreservedAnalyses::all();\n  // Check the PassInstrumentation's BeforePass callbacks before running the\n  // canonicalization pipeline.\n  if (PI.runBeforePass<Function>(LoopCanonicalizationFPM, F)) {\n    PA = LoopCanonicalizationFPM.run(F, AM);\n    PI.runAfterPass<Function>(LoopCanonicalizationFPM, F, PA);\n  }\n\n  // Get the loop structure for this function\n  LoopInfo &LI = AM.getResult<LoopAnalysis>(F);\n\n  // If there are no loops, there is nothing to do here.\n  if (LI.empty())\n    return PA;\n\n  // Get the analysis results needed by loop passes.\n  MemorySSA *MSSA =\n      UseMemorySSA ? (&AM.getResult<MemorySSAAnalysis>(F).getMSSA()) : nullptr;\n  BlockFrequencyInfo *BFI = UseBlockFrequencyInfo && F.hasProfileData()\n                                ? (&AM.getResult<BlockFrequencyAnalysis>(F))\n                                : nullptr;\n  BranchProbabilityInfo *BPI =\n      UseBranchProbabilityInfo && F.hasProfileData()\n          ? (&AM.getResult<BranchProbabilityAnalysis>(F))\n          : nullptr;\n  LoopStandardAnalysisResults LAR = {AM.getResult<AAManager>(F),\n                                     AM.getResult<AssumptionAnalysis>(F),\n                                     AM.getResult<DominatorTreeAnalysis>(F),\n                                     AM.getResult<LoopAnalysis>(F),\n                                     AM.getResult<ScalarEvolutionAnalysis>(F),\n                                     AM.getResult<TargetLibraryAnalysis>(F),\n                                     AM.getResult<TargetIRAnalysis>(F),\n                                     BFI,\n                                     BPI,\n                                     MSSA};\n\n  // Setup the loop analysis manager from its proxy. It is important that\n  // this is only done when there are loops to process and we have built the\n  // LoopStandardAnalysisResults object. The loop analyses cached in this\n  // manager have access to those analysis results and so it must invalidate\n  // itself when they go away.\n  auto &LAMFP = AM.getResult<LoopAnalysisManagerFunctionProxy>(F);\n  if (UseMemorySSA)\n    LAMFP.markMSSAUsed();\n  LoopAnalysisManager &LAM = LAMFP.getManager();\n\n  // A postorder worklist of loops to process.\n  SmallPriorityWorklist<Loop *, 4> Worklist;\n\n  // Register the worklist and loop analysis manager so that loop passes can\n  // update them when they mutate the loop nest structure.\n  LPMUpdater Updater(Worklist, LAM, LoopNestMode);\n\n  // Add the loop nests in the reverse order of LoopInfo. See method\n  // declaration.\n  if (!LoopNestMode) {\n    appendLoopsToWorklist(LI, Worklist);\n  } else {\n    for (Loop *L : LI)\n      Worklist.insert(L);\n  }\n\n#ifndef NDEBUG\n  PI.pushBeforeNonSkippedPassCallback([&LAR, &LI](StringRef PassID, Any IR) {\n    if (isSpecialPass(PassID, {\"PassManager\"}))\n      return;\n    assert(llvm::any_cast<const Loop *>(&IR) ||\n           llvm::any_cast<const LoopNest *>(&IR));\n    const Loop **LPtr = llvm::any_cast<const Loop *>(&IR);\n    const Loop *L = LPtr ? *LPtr : nullptr;\n    if (!L)\n      L = &llvm::any_cast<const LoopNest *>(IR)->getOutermostLoop();\n    assert(L && \"Loop should be valid for printing\");\n\n    // Verify the loop structure and LCSSA form before visiting the loop.\n    L->verifyLoop();\n    assert(L->isRecursivelyLCSSAForm(LAR.DT, LI) &&\n           \"Loops must remain in LCSSA form!\");\n  });\n#endif\n\n  do {\n    Loop *L = Worklist.pop_back_val();\n    assert(!(LoopNestMode && L->getParentLoop()) &&\n           \"L should be a top-level loop in loop-nest mode.\");\n\n    // Reset the update structure for this loop.\n    Updater.CurrentL = L;\n    Updater.SkipCurrentLoop = false;\n\n#ifndef NDEBUG\n    // Save a parent loop pointer for asserts.\n    Updater.ParentL = L->getParentLoop();\n#endif\n    // Check the PassInstrumentation's BeforePass callbacks before running the\n    // pass, skip its execution completely if asked to (callback returns\n    // false).\n    if (!PI.runBeforePass<Loop>(*Pass, *L))\n      continue;\n\n    PreservedAnalyses PassPA = Pass->run(*L, LAM, LAR, Updater);\n\n    // Do not pass deleted Loop into the instrumentation.\n    if (Updater.skipCurrentLoop())\n      PI.runAfterPassInvalidated<Loop>(*Pass, PassPA);\n    else\n      PI.runAfterPass<Loop>(*Pass, *L, PassPA);\n\n    if (LAR.MSSA && !PassPA.getChecker<MemorySSAAnalysis>().preserved())\n      report_fatal_error(\"Loop pass manager using MemorySSA contains a pass \"\n\n>>> [ INFILL ] <<<\n\n#ifndef NDEBUG\n    // LoopAnalysisResults should always be valid.\n    if (VerifyDomInfo)\n      LAR.DT.verify();\n    if (VerifyLoopInfo)\n      LAR.LI.verify(LAR.DT);\n    if (VerifySCEV)\n      LAR.SE.verify();\n    if (LAR.MSSA && VerifyMemorySSA)\n      LAR.MSSA->verifyMemorySSA();\n#endif\n\n    // If the loop hasn't been deleted, we need to handle invalidation here.\n    if (!Updater.skipCurrentLoop())\n      // We know that the loop pass couldn't have invalidated any other\n      // loop's analyses (that's the contract of a loop pass), so directly\n      // handle the loop analysis manager's invalidation here.\n      LAM.invalidate(*L, PassPA);\n\n    // Then intersect the preserved set so that invalidation of module\n    // analyses will eventually occur when the module pass completes.\n    PA.intersect(std::move(PassPA));\n  } while (!Worklist.empty());\n\n#ifndef NDEBUG\n  PI.popBeforeNonSkippedPassCallback();\n#endif\n\n  // By definition we preserve the proxy. We also preserve all analyses on\n  // Loops. This precludes *any* invalidation of loop analyses by the proxy,\n  // but that's OK because we've taken care to invalidate analyses in the\n  // loop analysis manager incrementally above.\n  PA.preserveSet<AllAnalysesOn<Loop>>();\n  PA.preserve<LoopAnalysisManagerFunctionProxy>();\n  // We also preserve the set of standard analyses.\n  PA.preserve<DominatorTreeAnalysis>();\n  PA.preserve<LoopAnalysis>();\n  PA.preserve<ScalarEvolutionAnalysis>();\n  if (UseBlockFrequencyInfo && F.hasProfileData())\n    PA.preserve<BlockFrequencyAnalysis>();\n  if (UseBranchProbabilityInfo && F.hasProfileData())\n    PA.preserve<BranchProbabilityAnalysis>();\n  if (UseMemorySSA)\n    PA.preserve<MemorySSAAnalysis>();\n  return PA;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                         \"that does not preserve MemorySSA\");\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Other/loop-mssa-not-preserved.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Other/loop-mssa-not-preserved.ll\n\n\nTesting Time: 6.82s\n\nTotal Discovered Tests: 1\n  Failed: 1 (100.00%)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "6d2dfd37bd50b21ed90427052198bd1f06c761f8___LoopPassManager.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic bool isKnownNonNullFromDominatingCondition(const Value *V,\n                                                  const Instruction *CtxI,\n                                                  const DominatorTree *DT) {\n  assert(!isa<Constant>(V) && \"Called for constant?\");\n\n  if (!CtxI || !DT)\n    return false;\n\n  unsigned NumUsesExplored = 0;\n  for (const auto *U : V->users()) {\n    // Avoid massive lists\n    if (NumUsesExplored >= DomConditionsMaxUses)\n      break;\n    NumUsesExplored++;\n\n    // If the value is used as an argument to a call or invoke, then argument\n    // attributes may provide an answer about null-ness.\n    if (const auto *CB = dyn_cast<CallBase>(U))\n      if (auto *CalledFunc = CB->getCalledFunction())\n        for (const Argument &Arg : CalledFunc->args())\n          if (CB->getArgOperand(Arg.getArgNo()) == V &&\n              Arg.hasNonNullAttr(/* AllowUndefOrPoison */ false) &&\n              DT->dominates(CB, CtxI))\n            return true;\n\n    // If the value is used as a load/store, then the pointer must be non null.\n    if (V == getLoadStorePointerOperand(U)) {\n      const Instruction *I = cast<Instruction>(U);\n      if (!NullPointerIsDefined(I->getFunction(),\n                                V->getType()->getPointerAddressSpace()) &&\n          DT->dominates(I, CtxI))\n        return true;\n    }\n\n\n>>> [ INFILL ] <<<\n        isValidAssumeForContext(cast<Instruction>(U), CtxI, DT))\n      return true;\n\n    // Consider only compare instructions uniquely controlling a branch\n    Value *RHS;\n    CmpInst::Predicate Pred;\n    if (!match(U, m_c_ICmp(Pred, m_Specific(V), m_Value(RHS))))\n      continue;\n\n    bool NonNullIfTrue;\n    if (cmpExcludesZero(Pred, RHS))\n      NonNullIfTrue = true;\n    else if (cmpExcludesZero(CmpInst::getInversePredicate(Pred), RHS))\n      NonNullIfTrue = false;\n    else\n      continue;\n\n    SmallVector<const User *, 4> WorkList;\n    SmallPtrSet<const User *, 4> Visited;\n    for (const auto *CmpU : U->users()) {\n      assert(WorkList.empty() && \"Should be!\");\n      if (Visited.insert(CmpU).second)\n        WorkList.push_back(CmpU);\n\n      while (!WorkList.empty()) {\n        auto *Curr = WorkList.pop_back_val();\n\n        // If a user is an AND, add all its users to the work list. We only\n        // propagate \"pred != null\" condition through AND because it is only\n        // correct to assume that all conditions of AND are met in true branch.\n        // TODO: Support similar logic of OR and EQ predicate?\n        if (NonNullIfTrue)\n          if (match(Curr, m_LogicalAnd(m_Value(), m_Value()))) {\n            for (const auto *CurrU : Curr->users())\n              if (Visited.insert(CurrU).second)\n                WorkList.push_back(CurrU);\n            continue;\n          }\n\n        if (const BranchInst *BI = dyn_cast<BranchInst>(Curr)) {\n          assert(BI->isConditional() && \"uses a comparison!\");\n\n          BasicBlock *NonNullSuccessor =\n              BI->getSuccessor(NonNullIfTrue ? 0 : 1);\n          BasicBlockEdge Edge(BI->getParent(), NonNullSuccessor);\n          if (Edge.isSingleEdge() && DT->dominates(Edge, CtxI->getParent()))\n            return true;\n        } else if (NonNullIfTrue && isGuard(Curr) &&\n                   DT->dominates(cast<Instruction>(Curr), CtxI)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    if (match(U, m_IDiv(m_Value(), m_Specific(V))) &&\n\n```\n\n\n\nwith the following test error: FAIL: LLVM :: Transforms/InstCombine/zext-or-icmp.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Transforms/InstCombine/zext-or-icmp.ll\n\n\nTesting Time: 0.36s\n\nTotal Discovered Tests: 1\n  Failed: 1 (100.00%)\n-- Testing: 1 tests, 1 workers --\nFAIL: LLVM :: Analysis/ValueTracking/select-known-non-zero.ll (1 of 1)\n********************\nFailed Tests (1):\n  LLVM :: Analysis/ValueTracking/select-known-non-zero.ll\n\n\nTesting Time: 0.15s\n\nTotal Discovered Tests: 1\n  Failed: 1 (100.00%)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ab3fdbdfbe7edc62049c602d87be91c3ad3f5e3b___ValueTracking.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstd::string AnalyzerInformation::getAnalyzerInfoFile(const std::string &buildDir, const std::string &sourcefile, const std::string &cfg)\n{\n    std::ifstream fin(Path::join(buildDir, \"files.txt\"));\n    if (fin.is_open()) {\n        const std::string& ret = getAnalyzerInfoFileFromFilesTxt(fin, sourcefile, cfg);\n        if (!ret.empty())\n            return Path::join(buildDir, ret);\n    }\n\n    const std::string::size_type pos = sourcefile.rfind('/');\n    std::string filename;\n\n>>> [ INFILL ] <<<\n        filename = sourcefile;\n    else\n        filename = sourcefile.substr(pos + 1);\n    return Path::join(buildDir, filename) + \".analyzerinfo\";\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    if (pos != std::string::npos)\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_caa6ff7c2a6ef64df53e04701944aaa4712a1915/build_caa6ff7c2a6ef64df53e04701944aaa4712a1915\nTest project /out/danmar___cppcheck/git_repo_dir_caa6ff7c2a6ef64df53e04701944aaa4712a1915/build_caa6ff7c2a6ef64df53e04701944aaa4712a1915\n    Start 2: TestAnalyzerInformation\n1/1 Test #2: TestAnalyzerInformation ..........***Failed    0.00 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.01 sec\n\nThe following tests FAILED:\n\t  2 - TestAnalyzerInformation (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "caa6ff7c2a6ef64df53e04701944aaa4712a1915___analyzerinfo.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid CheckLeakAutoVar::functionCall(const Token *tokName, const Token *tokOpeningPar, VarInfo *varInfo, const VarInfo::AllocInfo& allocation, const Library::AllocFunc* af)\n{\n    // Ignore function call?\n    if (mSettings->library.isLeakIgnore(tokName->str()))\n        return;\n    if (mSettings->library.getReallocFuncInfo(tokName))\n        return;\n\n    const Token * const tokFirstArg = tokOpeningPar->next();\n    if (!tokFirstArg || tokFirstArg->str() == \")\") {\n        // no arguments\n        return;\n    }\n\n    int argNr = 1;\n\n>>> [ INFILL ] <<<\n        if (mTokenizer->isCPP() && arg->str() == \"new\") {\n            arg = arg->next();\n            if (Token::simpleMatch(arg, \"( std :: nothrow )\"))\n                arg = arg->tokAt(5);\n        }\n\n        // Skip casts\n        while (arg && arg->isCast())\n            arg = arg->astOperand2() ? arg->astOperand2() : arg->astOperand1();\n        const Token * const argTypeStartTok = arg;\n\n        while (Token::Match(arg, \"%name% .|:: %name%\"))\n            arg = arg->tokAt(2);\n\n        if (Token::Match(arg, \"%var% [-,)] !!.\") || Token::Match(arg, \"& %var%\")) {\n            // goto variable\n            if (arg->str() == \"&\")\n                arg = arg->next();\n\n            const bool isnull = arg->hasKnownIntValue() && arg->values().front().intvalue == 0;\n\n            // Is variable allocated?\n            if (!isnull && (!af || af->arg == argNr))\n                changeAllocStatus(varInfo, allocation, tokName, arg);\n        }\n        // Check smart pointer\n        else if (Token::Match(arg, \"%name% < %type%\") && mSettings->library.isSmartPointer(argTypeStartTok)) {\n            const Token * typeEndTok = arg->linkAt(1);\n            const Token * allocTok = nullptr;\n            if (!Token::Match(typeEndTok, \"> {|( %var% ,|)|}\"))\n                continue;\n\n            bool arrayDelete = false;\n            if (Token::findsimplematch(arg->next(), \"[ ]\", typeEndTok))\n                arrayDelete = true;\n\n            // Check deleter\n            const Token * deleterToken = nullptr;\n            const Token * endDeleterToken = nullptr;\n            const Library::AllocFunc* sp_af = nullptr;\n            if (Token::Match(arg, \"unique_ptr < %type% ,\")) {\n                deleterToken = arg->tokAt(4);\n                endDeleterToken = typeEndTok;\n            } else if (Token::Match(typeEndTok, \"> {|( %var% ,\")) {\n                deleterToken = typeEndTok->tokAt(4);\n                endDeleterToken = typeEndTok->linkAt(1);\n            }\n            if (deleterToken) {\n                // Check if its a pointer to a function\n                const Token * dtok = Token::findmatch(deleterToken, \"& %name%\", endDeleterToken);\n                if (dtok) {\n                    sp_af = mSettings->library.getDeallocFuncInfo(dtok->tokAt(1));\n                } else {\n                    // If the deleter is a class, check if class calls the dealloc function\n                    dtok = Token::findmatch(deleterToken, \"%type%\", endDeleterToken);\n                    if (dtok && dtok->type()) {\n                        const Scope * tscope = dtok->type()->classScope;\n                        for (const Token *tok2 = tscope->bodyStart; tok2 != tscope->bodyEnd; tok2 = tok2->next()) {\n                            sp_af = mSettings->library.getDeallocFuncInfo(tok2);\n                            if (sp_af) {\n                                allocTok = tok2;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            const Token * vtok = typeEndTok->tokAt(2);\n            const VarInfo::AllocInfo sp_allocation(sp_af ? sp_af->groupId : (arrayDelete ? NEW_ARRAY : NEW), VarInfo::OWNED, allocTok);\n            changeAllocStatus(varInfo, sp_allocation, vtok, vtok);\n        } else {\n            checkTokenInsideExpression(arg, varInfo);\n        }\n        // TODO: check each token in argument expression (could contain multiple variables)\n        argNr++;\n    }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    for (const Token *arg = tokFirstArg; arg; arg = arg->nextArgument()) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_4996ec190ecf27a4bf018eb0dcd12e2a51fd550e/build_4996ec190ecf27a4bf018eb0dcd12e2a51fd550e\nTest project /out/danmar___cppcheck/git_repo_dir_4996ec190ecf27a4bf018eb0dcd12e2a51fd550e/build_4996ec190ecf27a4bf018eb0dcd12e2a51fd550e\n    Start 27: TestLeakAutoVar\n1/3 Test #27: TestLeakAutoVar ..................***Failed    4.53 sec\n    Start 62: TestLeakAutoVarStrcpy\n2/3 Test #62: TestLeakAutoVarStrcpy ............   Passed    0.05 sec\n    Start 63: TestLeakAutoVarWindows\n3/3 Test #63: TestLeakAutoVarWindows ...........   Passed    0.08 sec\n\n67% tests passed, 1 tests failed out of 3\n\nTotal Test time (real) =   4.67 sec\n\nThe following tests FAILED:\n\t 27 - TestLeakAutoVar (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "4996ec190ecf27a4bf018eb0dcd12e2a51fd550e___checkleakautovar.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid CheckCondition::checkCompareValueOutOfTypeRange()\n{\n    if (!mSettings->severity.isEnabled(Severity::style))\n        return;\n\n    if (mSettings->platformType == cppcheck::Platform::PlatformType::Native ||\n        mSettings->platformType == cppcheck::Platform::PlatformType::Unspecified)\n        return;\n\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n    for (const Scope * scope : symbolDatabase->functionScopes) {\n        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {\n            if (!tok->isComparisonOp() || !tok->isBinaryOp())\n                continue;\n\n            for (int i = 0; i < 2; ++i) {\n                const Token * const valueTok = (i == 0) ? tok->astOperand1() : tok->astOperand2();\n                const Token * const typeTok = valueTok->astSibling();\n                if (!valueTok->hasKnownIntValue() || !typeTok->valueType() || typeTok->valueType()->pointer)\n                    continue;\n                if (valueTok->getKnownIntValue() < 0 && valueTok->valueType() && valueTok->valueType()->sign != ValueType::Sign::SIGNED)\n                    continue;\n                int bits = 0;\n                switch (typeTok->valueType()->type) {\n                case ValueType::Type::BOOL:\n                    bits = 1;\n                    break;\n                case ValueType::Type::CHAR:\n                    bits = mSettings->char_bit;\n                    break;\n                case ValueType::Type::SHORT:\n                    bits = mSettings->short_bit;\n                    break;\n                case ValueType::Type::INT:\n                    bits = mSettings->int_bit;\n                    break;\n                case ValueType::Type::LONG:\n                    bits = mSettings->long_bit;\n                    break;\n                case ValueType::Type::LONGLONG:\n                    bits = mSettings->long_long_bit;\n                    break;\n                default:\n                    break;\n                };\n                if (bits == 0 || bits >= 64)\n                    continue;\n\n                const auto typeMinValue = (typeTok->valueType()->sign == ValueType::Sign::SIGNED) ? (-(1LL << (bits-1))) : 0;\n                const auto unsignedTypeMaxValue = (1LL << bits) - 1LL;\n\n>>> [ INFILL ] <<<\n\n                if (valueTok->getKnownIntValue() < typeMinValue)\n                    compareValueOutOfTypeRangeError(valueTok, typeTok->valueType()->str(), valueTok->getKnownIntValue());\n                else if (valueTok->getKnownIntValue() > typeMaxValue)\n                    compareValueOutOfTypeRangeError(valueTok, typeTok->valueType()->str(), valueTok->getKnownIntValue());\n            }\n        }\n    }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                const auto typeMaxValue = (typeTok->valueType()->sign == ValueType::Sign::SIGNED) ? (unsignedTypeMaxValue / 2) : unsignedTypeMaxValue;\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_d0b6079a832d5c156af1e51274e09f28ee8677a7/build_d0b6079a832d5c156af1e51274e09f28ee8677a7\nTest project /out/danmar___cppcheck/git_repo_dir_d0b6079a832d5c156af1e51274e09f28ee8677a7/build_d0b6079a832d5c156af1e51274e09f28ee8677a7\n    Start 14: TestCondition\n1/1 Test #14: TestCondition ....................***Failed    2.95 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   2.96 sec\n\nThe following tests FAILED:\n\t 14 - TestCondition (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "d0b6079a832d5c156af1e51274e09f28ee8677a7___checkcondition.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstd::string Preprocessor::getcode(const simplecpp::TokenList &tokens1, const std::string &cfg, std::vector<std::string> &files, const bool writeLocations)\n{\n    const simplecpp::DUI dui = createDUI(_settings, cfg, files[0]);\n\n    simplecpp::OutputList outputList;\n    std::list<simplecpp::MacroUsage> macroUsage;\n    simplecpp::TokenList tokens2(files);\n    simplecpp::preprocess(tokens2, tokens1, files, tokenlists, dui, &outputList, &macroUsage);\n\n    bool showerror = (!_settings.userDefines.empty() && !_settings.force);\n    reportOutput(outputList, showerror);\n    if (hasErrors(outputList))\n        return \"\";\n\n    // ensure that guessed define macros without value are not used in the code\n    if (!validateCfg(cfg, macroUsage))\n        return \"\";\n\n    // assembler code locations..\n    std::set<simplecpp::Location> assemblerLocations;\n    for (std::list<Directive>::const_iterator dirIt = directives.begin(); dirIt != directives.end(); ++dirIt) {\n        const Directive &d1 = *dirIt;\n        if (d1.str.compare(0, 11, \"#pragma asm\") != 0)\n            continue;\n        std::list<Directive>::const_iterator dirIt2 = dirIt;\n        ++dirIt2;\n        if (dirIt2 == directives.end())\n            continue;\n\n        const Directive &d2 = *dirIt2;\n        if (d2.str.compare(0,14,\"#pragma endasm\") != 0 || d1.file != d2.file)\n            continue;\n\n        simplecpp::Location loc(files);\n        loc.fileIndex = ~0U;\n        loc.col = 0U;\n        for (unsigned int i = 0; i < files.size(); ++i) {\n            if (files[i] == d1.file) {\n                loc.fileIndex = i;\n                break;\n            }\n        }\n\n        for (unsigned int linenr = d1.linenr + 1U; linenr < d2.linenr; linenr++) {\n            loc.line = linenr;\n            assemblerLocations.insert(loc);\n        }\n    }\n\n    unsigned int prevfile = 0;\n    unsigned int line = 1;\n    std::ostringstream ret;\n    for (const simplecpp::Token *tok = tokens2.cfront(); tok; tok = tok->next) {\n        if (writeLocations && tok->location.fileIndex != prevfile) {\n            ret << \"\\n#line \" << tok->location.line << \" \\\"\" << tok->location.file() << \"\\\"\\n\";\n            prevfile = tok->location.fileIndex;\n            line = tok->location.line;\n        }\n\n\n>>> [ INFILL ] <<<\n            ret << ' ';\n        bool newline = false;\n        while (tok->location.line > line) {\n            ret << '\\n';\n            line++;\n            newline = true;\n        }\n        if (newline) {\n            simplecpp::Location loc = tok->location;\n            loc.col = 0U;\n            if (assemblerLocations.find(loc) != assemblerLocations.end()) {\n                ret << \"asm();\";\n                while (assemblerLocations.find(loc) != assemblerLocations.end()) {\n                    loc.line++;\n                }\n                while (tok && tok->location.line < loc.line)\n                    tok = tok->next;\n                if (!tok)\n                    break;\n                while (line < tok->location.line) {\n                    ret << '\\n';\n                    ++line;\n                }\n            }\n        }\n        if (!tok->macro.empty())\n            ret << Preprocessor::macroChar;\n        ret << tok->str;\n    }\n\n    return ret.str();\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        if (tok->previous && line == tok->location.line)\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_2daf7f5430f11def5fd1d67598487369f97c42f4/build_2daf7f5430f11def5fd1d67598487369f97c42f4\nTest project /out/danmar___cppcheck/git_repo_dir_2daf7f5430f11def5fd1d67598487369f97c42f4/build_2daf7f5430f11def5fd1d67598487369f97c42f4\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   17.97 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  17.98 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "2daf7f5430f11def5fd1d67598487369f97c42f4___preprocessor.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid CheckLeakAutoVar::ret(const Token *tok, const VarInfo &varInfo)\n{\n    const std::map<int, VarInfo::AllocInfo> &alloctype = varInfo.alloctype;\n    const std::map<int, std::string> &possibleUsage = varInfo.possibleUsage;\n\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n    for (std::map<int, VarInfo::AllocInfo>::const_iterator it = alloctype.begin(); it != alloctype.end(); ++it) {\n        // don't warn if variable is conditionally allocated\n        if (!it->second.managed() && varInfo.conditionalAlloc.find(it->first) != varInfo.conditionalAlloc.end())\n            continue;\n\n        // don't warn if there is a reference of the variable\n        if (varInfo.referenced.find(it->first) != varInfo.referenced.end())\n            continue;\n\n        const int varid = it->first;\n        const Variable *var = symbolDatabase->getVariableFromVarId(varid);\n        if (var) {\n            bool used = false;\n            for (const Token *tok2 = tok; tok2; tok2 = tok2->next()) {\n                if (tok2->str() == \";\" || Token::simpleMatch(tok2, \"return ;\"))\n                    break;\n                if (!Token::Match(tok2, \"return|(|{|,\"))\n                    continue;\n\n                tok2 = tok2->next();\n\n>>> [ INFILL ] <<<\n                    tok2 = tok2->astOperand2() ? tok2->astOperand2() : tok2->astOperand1();\n                if (Token::Match(tok2, \"%varid%\", varid))\n                    tok2 = tok2->next();\n                else if (Token::Match(tok2, \"& %varid% . %name%\", varid))\n                    tok2 = tok2->tokAt(4);\n                else\n                    continue;\n                if (Token::Match(tok2, \"[});,]\")) {\n                    used = true;\n                    break;\n                }\n            }\n\n            // return deallocated pointer\n            if (used && it->second.status == VarInfo::DEALLOC)\n                deallocReturnError(tok, var->name());\n\n            else if (!used && !it->second.managed()) {\n                const std::map<int, std::string>::const_iterator use = possibleUsage.find(varid);\n                if (use == possibleUsage.end()) {\n                    leakError(tok, var->name(), it->second.type);\n                } else {\n                    configurationInfo(tok, use->second);\n                }\n            }\n        }\n    }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                while (tok2 && tok2->isCast() && (tok2->valueType() && (tok2->valueType()->pointer || (tok2->valueType()->typeSize(*mSettings) >= mSettings->sizeof_pointer))))\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_46ac0d79c1036afb0c565e2bc330d9eb5ffa9eb1/build_46ac0d79c1036afb0c565e2bc330d9eb5ffa9eb1\nTest project /out/danmar___cppcheck/git_repo_dir_46ac0d79c1036afb0c565e2bc330d9eb5ffa9eb1/build_46ac0d79c1036afb0c565e2bc330d9eb5ffa9eb1\n    Start 24: TestLeakAutoVar\n1/1 Test #24: TestLeakAutoVar ..................***Failed    4.36 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   4.36 sec\n\nThe following tests FAILED:\n\t 24 - TestLeakAutoVar (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "46ac0d79c1036afb0c565e2bc330d9eb5ffa9eb1___checkleakautovar.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nbool TemplateSimplifier::simplifyTemplateInstantiations(\n    const TokenAndName &templateDeclaration,\n    const std::list<const Token *> &specializations,\n    const std::time_t maxtime,\n    std::set<std::string> &expandedtemplates)\n{\n    // this variable is not used at the moment. The intention was to\n    // allow continuous instantiations until all templates has been expanded\n    //bool done = false;\n\n    // Contains tokens such as \"T\"\n    std::vector<const Token *> typeParametersInDeclaration;\n    const Token * const tok = getTemplateParametersInDeclaration(templateDeclaration.token->tokAt(2), typeParametersInDeclaration);\n\n    // bail out if the end of the file was reached\n    if (!tok)\n        return false;\n\n    const bool printDebug = mSettings->debugwarnings;\n\n    // get the position of the template name\n    const int namepos = getTemplateNamePosition(tok);\n    if (namepos == -1) {\n        // debug message that we bail out..\n        if (printDebug && mErrorLogger) {\n            const std::list<const Token *> callstack(1, tok);\n            mErrorLogger->reportErr(ErrorLogger::ErrorMessage(callstack, &mTokenList, Severity::debug, \"debug\", \"simplifyTemplates: bailing out\", false));\n        }\n        return false;\n    }\n\n    const bool specialized = Token::simpleMatch(templateDeclaration.token, \"template < >\");\n    bool isfunc = false;\n\n    if (tok->strAt(namepos + 1) == \"(\")\n        isfunc = true;\n    else if (tok->strAt(namepos + 1) == \"<\") {\n        const Token *tok1 = tok->tokAt(namepos + 1)->findClosingBracket();\n        if (tok1 && tok1->strAt(1) == \"(\")\n            isfunc = true;\n    }\n\n    // locate template usage..\n    std::string::size_type numberOfTemplateInstantiations = mTemplateInstantiations.size();\n    unsigned int recursiveCount = 0;\n\n    bool instantiated = false;\n\n    for (const TokenAndName &instantiation : mTemplateInstantiations) {\n        if (numberOfTemplateInstantiations != mTemplateInstantiations.size()) {\n            numberOfTemplateInstantiations = mTemplateInstantiations.size();\n            simplifyCalculations();\n            ++recursiveCount;\n            if (recursiveCount > 100) {\n                // bail out..\n                break;\n            }\n        }\n\n        // already simplified\n        if (!Token::Match(instantiation.token, \"%name% <\"))\n            continue;\n\n        if (instantiation.name != templateDeclaration.name)\n            continue;\n\n        if (!matchSpecialization(tok->tokAt(namepos), instantiation.token, specializations))\n            continue;\n\n        Token * const tok2 = instantiation.token;\n        if (mErrorLogger && !mTokenList.getFiles().empty())\n            mErrorLogger->reportProgress(mTokenList.getFiles()[0], \"TemplateSimplifier::simplifyTemplateInstantiations()\", tok2->progressValue());\n#ifdef MAXTIME\n        if (std::time(0) > maxtime)\n            return false;\n#else\n        (void)maxtime;\n#endif\n        assert(mTokenList.validateToken(tok2)); // that assertion fails on examples from #6021\n\n        const Token *startToken = tok2;\n        while (Token::Match(startToken->tokAt(-2), \"%name% :: %name%\") ||\n               Token::Match(startToken->tokAt(-2), \"> :: %name%\")) {\n            if (startToken->strAt(-2) == \">\") {\n                const Token * tok3 = startToken->tokAt(-2)->findOpeningBracket();\n                if (tok3)\n                    startToken = tok3->previous();\n                else\n                    break;\n            } else\n                startToken = startToken->tokAt(-2);\n        }\n\n        if (Token::Match(startToken->previous(), \"[;{}=]\") &&\n            (!specialized && !instantiateMatch(tok2, typeParametersInDeclaration.size(), isfunc ? \"(\" : \"*| %name%\")))\n            continue;\n\n        // New type..\n        mTypesUsedInTemplateInstantiation.clear();\n        std::list<std::string> typeStringsUsedInTemplateInstantiation;\n        std::string typeForNewName = getNewName(tok2, typeStringsUsedInTemplateInstantiation);\n\n        if (typeForNewName.empty() || (!typeParametersInDeclaration.empty() && typeParametersInDeclaration.size() != mTypesUsedInTemplateInstantiation.size())) {\n            if (printDebug && mErrorLogger) {\n                std::list<const Token *> callstack(1, tok2);\n                mErrorLogger->reportErr(ErrorLogger::ErrorMessage(callstack, &mTokenList, Severity::debug, \"debug\",\n                                        \"Failed to instantiate template \\\"\" + instantiation.name + \"\\\". The checking continues anyway.\", false));\n            }\n            if (typeForNewName.empty())\n                continue;\n            break;\n        }\n\n        // New classname/funcname..\n        const std::string newName(templateDeclaration.name + \" < \" + typeForNewName + \" >\");\n\n        if (expandedtemplates.find(newName) == expandedtemplates.end()) {\n            expandedtemplates.insert(newName);\n            expandTemplate(tok, instantiation.name, typeParametersInDeclaration, newName, !specialized);\n            instantiated = true;\n        }\n\n        // Replace all these template usages..\n        replaceTemplateUsage(tok2, instantiation.name, typeStringsUsedInTemplateInstantiation, newName);\n    }\n\n    // process uninstantiated templates\n    // TODO: remove the specialized check and handle all uninstantiated templates someday.\n\n>>> [ INFILL ] <<<\n        simplifyCalculations();\n\n        Token * tok2 = const_cast<Token *>(tok->tokAt(namepos));\n        if (mErrorLogger && !mTokenList.getFiles().empty())\n            mErrorLogger->reportProgress(mTokenList.getFiles()[0], \"TemplateSimplifier::simplifyTemplateInstantiations()\", tok2->progressValue());\n#ifdef MAXTIME\n        if (std::time(0) > maxtime)\n            return false;\n#else\n        (void)maxtime;\n#endif\n        assert(mTokenList.validateToken(tok2)); // that assertion fails on examples from #6021\n\n        Token *startToken = tok2;\n        while (Token::Match(startToken->tokAt(-2), \"%name% :: %name%\") ||\n               Token::Match(startToken->tokAt(-2), \"> :: %name%\")) {\n            if (startToken->strAt(-2) == \">\") {\n                const Token * tok3 = startToken->tokAt(-2)->findOpeningBracket();\n                if (tok3)\n                    startToken = tok3->previous();\n                else\n                    break;\n            } else\n                startToken = startToken->tokAt(-2);\n        }\n\n        if (Token::Match(startToken->previous(), \"[;{}=]\") &&\n            (!specialized && !instantiateMatch(tok2, typeParametersInDeclaration.size(), isfunc ? \"(\" : \"*| %name%\")))\n            return false;\n\n        // already simplified\n        if (!Token::Match(startToken, \"%name% <\"))\n            return false;\n\n        if (templateDeclaration.scope.empty()) {\n            if (startToken->str() != templateDeclaration.name)\n                return false;\n        } else {\n            std::string name = templateDeclaration.scope + \" :: \" + startToken->str();\n            if (name != templateDeclaration.name)\n                return false;\n        }\n\n        if (!matchSpecialization(tok->tokAt(namepos), startToken, specializations))\n            return false;\n\n        tok2 = startToken;\n\n        // New type..\n        mTypesUsedInTemplateInstantiation.clear();\n        std::list<std::string> typeStringsUsedInTemplateInstantiation;\n        std::string typeForNewName = getNewName(tok2, typeStringsUsedInTemplateInstantiation);\n\n        if (typeForNewName.empty()) {\n            if (printDebug && mErrorLogger) {\n                std::list<const Token *> callstack(1, tok2);\n                mErrorLogger->reportErr(ErrorLogger::ErrorMessage(callstack, &mTokenList, Severity::debug, \"debug\",\n                                        \"Failed to instantiate template \\\"\" + templateDeclaration.name + \"\\\". The checking continues anyway.\", false));\n            }\n            return false;\n        }\n\n        // New classname/funcname..\n        const std::string newName(templateDeclaration.name + \" < \" + typeForNewName + \" >\");\n        if (expandedtemplates.find(newName) == expandedtemplates.end()) {\n            expandedtemplates.insert(newName);\n            expandTemplate(tok, templateDeclaration.name, typeParametersInDeclaration, newName, !specialized);\n            instantiated = true;\n        }\n\n        // Replace all these template usages..\n        replaceTemplateUsage(startToken, templateDeclaration.name, typeStringsUsedInTemplateInstantiation, newName);\n    }\n\n    // Template has been instantiated .. then remove the template declaration\n    return instantiated;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    if (mTemplateInstantiations.empty() && specialized) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_290563b9640505d140684587e5c21e887d510495/build_290563b9640505d140684587e5c21e887d510495\nTest project /out/danmar___cppcheck/git_repo_dir_290563b9640505d140684587e5c21e887d510495/build_290563b9640505d140684587e5c21e887d510495\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   24.03 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  24.04 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "290563b9640505d140684587e5c21e887d510495___templatesimplifier.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid CheckLeakAutoVar::functionCall(const Token *tokName, const Token *tokOpeningPar, VarInfo *varInfo, const VarInfo::AllocInfo& allocation, const Library::AllocFunc* af)\n{\n    // Ignore function call?\n    if (mSettings->library.isLeakIgnore(tokName->str()))\n        return;\n    if (mSettings->library.getReallocFuncInfo(tokName))\n        return;\n\n    const Token * const tokFirstArg = tokOpeningPar->next();\n    if (!tokFirstArg || tokFirstArg->str() == \")\") {\n        // no arguments\n        return;\n    }\n\n    int argNr = 1;\n\n>>> [ INFILL ] <<<\n        if (mTokenizer->isCPP() && arg->str() == \"new\") {\n            arg = arg->next();\n            if (Token::simpleMatch(arg, \"( std :: nothrow )\"))\n                arg = arg->tokAt(5);\n        }\n\n        // Skip casts\n        while (arg && arg->isCast())\n            arg = arg->astOperand2() ? arg->astOperand2() : arg->astOperand1();\n        const Token * const argTypeStartTok = arg;\n\n        while (Token::Match(arg, \"%name% .|:: %name%\"))\n            arg = arg->tokAt(2);\n\n        if (Token::Match(arg, \"%var% [-,)] !!.\") || Token::Match(arg, \"& %var%\")) {\n            // goto variable\n            if (arg->str() == \"&\")\n                arg = arg->next();\n\n            const bool isnull = arg->hasKnownIntValue() && arg->values().front().intvalue == 0;\n\n            // Is variable allocated?\n            if (!isnull && (!af || af->arg == argNr))\n                changeAllocStatus(varInfo, allocation, tokName, arg);\n        }\n        // Check smart pointer\n        else if (Token::Match(arg, \"%name% < %type%\") && mSettings->library.isSmartPointer(argTypeStartTok)) {\n            const Token * typeEndTok = arg->linkAt(1);\n            const Token * allocTok = nullptr;\n            if (!Token::Match(typeEndTok, \"> {|( %var% ,|)|}\"))\n                continue;\n\n            bool arrayDelete = false;\n            if (Token::findsimplematch(arg->next(), \"[ ]\", typeEndTok))\n                arrayDelete = true;\n\n            // Check deleter\n            const Token * deleterToken = nullptr;\n            const Token * endDeleterToken = nullptr;\n            const Library::AllocFunc* sp_af = nullptr;\n            if (Token::Match(arg, \"unique_ptr < %type% ,\")) {\n                deleterToken = arg->tokAt(4);\n                endDeleterToken = typeEndTok;\n            } else if (Token::Match(typeEndTok, \"> {|( %var% ,\")) {\n                deleterToken = typeEndTok->tokAt(4);\n                endDeleterToken = typeEndTok->linkAt(1);\n            }\n            if (deleterToken) {\n                // Check if its a pointer to a function\n                const Token * dtok = Token::findmatch(deleterToken, \"& %name%\", endDeleterToken);\n                if (dtok) {\n                    sp_af = mSettings->library.getDeallocFuncInfo(dtok->tokAt(1));\n                } else {\n                    // If the deleter is a class, check if class calls the dealloc function\n                    dtok = Token::findmatch(deleterToken, \"%type%\", endDeleterToken);\n                    if (dtok && dtok->type()) {\n                        const Scope * tscope = dtok->type()->classScope;\n                        for (const Token *tok2 = tscope->bodyStart; tok2 != tscope->bodyEnd; tok2 = tok2->next()) {\n                            sp_af = mSettings->library.getDeallocFuncInfo(tok2);\n                            if (sp_af) {\n                                allocTok = tok2;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n\n            const Token * vtok = typeEndTok->tokAt(2);\n            const VarInfo::AllocInfo sp_allocation(sp_af ? sp_af->groupId : (arrayDelete ? NEW_ARRAY : NEW), VarInfo::OWNED, allocTok);\n            changeAllocStatus(varInfo, sp_allocation, vtok, vtok);\n        } else {\n            checkTokenInsideExpression(arg, varInfo);\n        }\n        // TODO: check each token in argument expression (could contain multiple variables)\n        argNr++;\n    }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    for (const Token *arg = tokFirstArg; arg; arg = arg->nextArgument()) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_0c6aabe4445f097539a5d1f2a73815e69ce3d52f/build_0c6aabe4445f097539a5d1f2a73815e69ce3d52f\nTest project /out/danmar___cppcheck/git_repo_dir_0c6aabe4445f097539a5d1f2a73815e69ce3d52f/build_0c6aabe4445f097539a5d1f2a73815e69ce3d52f\n    Start 27: TestLeakAutoVar\n1/3 Test #27: TestLeakAutoVar ..................***Failed    4.25 sec\n    Start 62: TestLeakAutoVarStrcpy\n2/3 Test #62: TestLeakAutoVarStrcpy ............   Passed    0.05 sec\n    Start 63: TestLeakAutoVarWindows\n3/3 Test #63: TestLeakAutoVarWindows ...........   Passed    0.06 sec\n\n67% tests passed, 1 tests failed out of 3\n\nTotal Test time (real) =   4.37 sec\n\nThe following tests FAILED:\n\t 27 - TestLeakAutoVar (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "0c6aabe4445f097539a5d1f2a73815e69ce3d52f___checkleakautovar.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstd::vector<LifetimeToken> getLifetimeTokens(const Token* tok, bool escape, ValueFlow::Value::ErrorPath errorPath, int depth)\n{\n    if (!tok)\n        return std::vector<LifetimeToken> {};\n    const Variable *var = tok->variable();\n    if (depth < 0)\n        return {{tok, std::move(errorPath)}};\n    if (var && var->declarationId() == tok->varId()) {\n        if (var->isReference() || var->isRValueReference()) {\n            if (!var->declEndToken())\n                return {{tok, true, std::move(errorPath)}};\n            if (var->isArgument()) {\n                errorPath.emplace_back(var->declEndToken(), \"Passed to reference.\");\n                return {{tok, true, std::move(errorPath)}};\n            } else if (Token::simpleMatch(var->declEndToken(), \"=\")) {\n                errorPath.emplace_back(var->declEndToken(), \"Assigned to reference.\");\n                const Token *vartok = var->declEndToken()->astOperand2();\n\n>>> [ INFILL ] <<<\n                const bool nonlocal = var->isStatic() || var->isGlobal();\n                if (vartok == tok || (nonlocal && temporary) || (!escape && (var->isConst() || var->isRValueReference()) && temporary))\n                    return {{tok, true, std::move(errorPath)}};\n                if (vartok)\n                    return getLifetimeTokens(vartok, escape, std::move(errorPath), depth - 1);\n            } else if (Token::simpleMatch(var->nameToken()->astParent(), \":\") &&\n                       var->nameToken()->astParent()->astParent() &&\n                       Token::simpleMatch(var->nameToken()->astParent()->astParent()->previous(), \"for (\")) {\n                errorPath.emplace_back(var->nameToken(), \"Assigned to reference.\");\n                const Token* vartok = var->nameToken();\n                if (vartok == tok)\n                    return {{tok, true, std::move(errorPath)}};\n                const Token* contok = var->nameToken()->astParent()->astOperand2();\n                if (contok)\n                    return getLifetimeTokens(contok, escape, std::move(errorPath), depth - 1);\n            } else {\n                return std::vector<LifetimeToken> {};\n            }\n        }\n    } else if (Token::Match(tok->previous(), \"%name% (\")) {\n        const Function *f = tok->previous()->function();\n        if (f) {\n            if (!Function::returnsReference(f))\n                return {{tok, std::move(errorPath)}};\n            std::vector<LifetimeToken> result;\n            std::vector<const Token*> returns = Function::findReturns(f);\n            for (const Token* returnTok : returns) {\n                if (returnTok == tok)\n                    continue;\n                for (LifetimeToken& lt : getLifetimeTokens(returnTok, escape, std::move(errorPath), depth - 1)) {\n                    const Token* argvarTok = lt.token;\n                    const Variable* argvar = argvarTok->variable();\n                    if (!argvar)\n                        continue;\n                    if (argvar->isArgument() && (argvar->isReference() || argvar->isRValueReference())) {\n                        int n = getArgumentPos(argvar, f);\n                        if (n < 0)\n                            return std::vector<LifetimeToken> {};\n                        std::vector<const Token*> args = getArguments(tok->previous());\n                        // TODO: Track lifetimes of default parameters\n                        if (n >= args.size())\n                            return std::vector<LifetimeToken> {};\n                        const Token* argTok = args[n];\n                        lt.errorPath.emplace_back(returnTok, \"Return reference.\");\n                        lt.errorPath.emplace_back(tok->previous(), \"Called function passing '\" + argTok->expressionString() + \"'.\");\n                        std::vector<LifetimeToken> arglts = LifetimeToken::setInconclusive(\n                                                                getLifetimeTokens(argTok, escape, std::move(lt.errorPath), depth - 1), returns.size() > 1);\n                        result.insert(result.end(), arglts.begin(), arglts.end());\n                    }\n                }\n            }\n            return result;\n        } else if (Token::Match(tok->tokAt(-2), \". %name% (\") && tok->tokAt(-2)->originalName() != \"->\" && astIsContainer(tok->tokAt(-2)->astOperand1())) {\n            const Library::Container* library = getLibraryContainer(tok->tokAt(-2)->astOperand1());\n            Library::Container::Yield y = library->getYield(tok->previous()->str());\n            if (y == Library::Container::Yield::AT_INDEX || y == Library::Container::Yield::ITEM) {\n                errorPath.emplace_back(tok->previous(), \"Accessing container.\");\n                return LifetimeToken::setAddressOf(\n                           getLifetimeTokens(tok->tokAt(-2)->astOperand1(), escape, std::move(errorPath), depth - 1), false);\n            }\n        }\n    } else if (Token::Match(tok, \".|::|[\")) {\n        const Token *vartok = tok;\n        while (vartok) {\n            if (vartok->str() == \"[\" || vartok->originalName() == \"->\")\n                vartok = vartok->astOperand1();\n            else if (vartok->str() == \".\" || vartok->str() == \"::\")\n                vartok = vartok->astOperand2();\n            else\n                break;\n        }\n\n        if (!vartok)\n            return {{tok, std::move(errorPath)}};\n        const Variable *tokvar = vartok->variable();\n        if (!astIsContainer(vartok) && !(tokvar && tokvar->isArray() && !tokvar->isArgument()) &&\n            (Token::Match(vartok->astParent(), \"[|*\") || vartok->astParent()->originalName() == \"->\")) {\n            for (const ValueFlow::Value &v : vartok->values()) {\n                if (!v.isLocalLifetimeValue())\n                    continue;\n                if (v.tokvalue == tok)\n                    continue;\n                errorPath.insert(errorPath.end(), v.errorPath.begin(), v.errorPath.end());\n                return getLifetimeTokens(v.tokvalue, escape, std::move(errorPath), depth - 1);\n            }\n        } else {\n            return LifetimeToken::setAddressOf(getLifetimeTokens(vartok, escape, std::move(errorPath), depth - 1),\n                                               !(astIsContainer(vartok) && Token::simpleMatch(vartok->astParent(), \"[\")));\n        }\n    }\n    return {{tok, std::move(errorPath)}};\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                const bool temporary = isTemporary(true, vartok, nullptr, true);\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_53734a3da1dd394aee9398127692b0e38e9ffa9f/build_53734a3da1dd394aee9398127692b0e38e9ffa9f\nTest project /out/danmar___cppcheck/git_repo_dir_53734a3da1dd394aee9398127692b0e38e9ffa9f/build_53734a3da1dd394aee9398127692b0e38e9ffa9f\n    Start 5: TestAutoVariables\n1/1 Test #5: TestAutoVariables ................***Failed    0.92 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.92 sec\n\nThe following tests FAILED:\n\t  5 - TestAutoVariables (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "53734a3da1dd394aee9398127692b0e38e9ffa9f___valueflow.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\n    Progress updateRange(Token* start, const Token* end) {\n        for (Token* tok = start; tok && tok != end; tok = tok->next()) {\n            Token* next = nullptr;\n\n            if (tok->link()) {\n                // Skip casts..\n                if (tok->str() == \"(\" && !tok->astOperand2() && tok->isCast()) {\n                    tok = tok->link();\n                    continue;\n                }\n                // Skip template arguments..\n                if (tok->str() == \"<\") {\n                    tok = tok->link();\n                    continue;\n                }\n            }\n\n            // Evaluate RHS of assignment before LHS\n            if (Token* assignTok = assignExpr(tok)) {\n                if (updateRecursive(assignTok->astOperand2()) == Progress::Break)\n                    return Progress::Break;\n                if (updateRecursive(assignTok->astOperand1()) == Progress::Break)\n                    return Progress::Break;\n                if (update(assignTok) == Progress::Break)\n                    return Progress::Break;\n                tok = nextAfterAstRightmostLeaf(assignTok);\n                if (!tok)\n                    return Progress::Break;\n            } else if (tok->str() ==  \"break\") {\n                const Scope* scope = findBreakScope(tok->scope());\n                if (!scope)\n                    return Progress::Break;\n                tok = skipTo(tok, scope->bodyEnd, end);\n                if (!analyzer->lowerToPossible())\n                    return Progress::Break;\n                // TODO: Don't break, instead move to the outer scope\n                if (!tok)\n                    return Progress::Break;\n            } else if (Token::Match(tok, \"%name% :\") || tok->str() == \"case\") {\n                if (!analyzer->lowerToPossible())\n                    return Progress::Break;\n            } else if (tok->link() && tok->str() == \"}\") {\n                if (Token::Match(tok->link()->previous(), \")|else {\")) {\n                    const bool inElse = Token::simpleMatch(tok->link()->previous(), \"else {\");\n                    const Token* condTok = getCondTokFromEnd(tok);\n                    if (!condTok)\n                        return Progress::Break;\n                    if (!condTok->hasKnownIntValue()) {\n                        if (!analyzer->lowerToPossible())\n                            return Progress::Break;\n\n>>> [ INFILL ] <<<\n                        return Progress::Break;\n                    }\n                    analyzer->assume(condTok, !inElse, tok);\n                    if (Token::simpleMatch(tok, \"} else {\"))\n                        tok = tok->linkAt(2);\n                } else if (Token::simpleMatch(tok->link()->previous(), \"try {\")) {\n                    if (!analyzer->lowerToPossible())\n                        return Progress::Break;\n                } else if (Token::simpleMatch(tok->next(), \"else {\")) {\n                    tok = tok->linkAt(2);\n                }\n            } else if (tok->isControlFlowKeyword() && Token::Match(tok, \"if|while|for (\") && Token::simpleMatch(tok->next()->link(), \") {\")) {\n                Token* endCond = tok->next()->link();\n                Token* endBlock = endCond->next()->link();\n                Token* condTok = getCondTok(tok);\n                Token* initTok = getInitTok(tok);\n                if (!condTok)\n                    return Progress::Break;\n                if (initTok && updateRecursive(initTok) == Progress::Break)\n                    return Progress::Break;\n                if (Token::Match(tok, \"for|while (\")) {\n                    Token* stepTok = getStepTok(tok);\n                    if (updateLoop(endBlock, condTok, initTok, stepTok) == Progress::Break)\n                        return Progress::Break;\n                    tok = endBlock;\n                } else {\n                    // Traverse condition\n                    if (updateRecursive(condTok) == Progress::Break)\n                        return Progress::Break;\n                    // Check if condition is true or false\n                    bool checkThen, checkElse;\n                    std::tie(checkThen, checkElse) = evalCond(condTok);\n                    ForwardAnalyzer::Action thenAction = ForwardAnalyzer::Action::None;\n                    ForwardAnalyzer::Action elseAction = ForwardAnalyzer::Action::None;\n                    bool hasElse = Token::simpleMatch(endBlock, \"} else {\");\n                    bool bail = false;\n\n                    // Traverse then block\n                    bool returnThen = isEscapeScope(endBlock, true);\n                    bool returnElse = false;\n                    if (checkThen) {\n                        if (updateRange(endCond->next(), endBlock) == Progress::Break)\n                            return Progress::Break;\n                    } else if (!checkElse) {\n                        thenAction = checkScope(endBlock);\n                        if (hasGoto(endBlock))\n                            bail = true;\n                    }\n                    // Traverse else block\n                    if (hasElse) {\n                        returnElse = isEscapeScope(endBlock->linkAt(2), true);\n                        if (checkElse) {\n                            Progress result = updateRange(endBlock->tokAt(2), endBlock->linkAt(2));\n                            if (result == Progress::Break)\n                                return Progress::Break;\n                        } else if (!checkThen) {\n                            elseAction = checkScope(endBlock->linkAt(2));\n                            if (hasGoto(endBlock))\n                                bail = true;\n                        }\n                        tok = endBlock->linkAt(2);\n                    } else {\n                        tok = endBlock;\n                    }\n                    if (bail)\n                        return Progress::Break;\n                    if (returnThen && returnElse)\n                        return Progress::Break;\n                    else if (thenAction.isModified() && elseAction.isModified())\n                        return Progress::Break;\n                    else if ((returnThen || returnElse) && (thenAction.isModified() || elseAction.isModified()))\n                        return Progress::Break;\n                    // Conditional return\n                    if (returnThen && !hasElse) {\n                        if (checkThen) {\n                            return Progress::Break;\n                        } else {\n                            if (analyzer->isConditional())\n                                return Progress::Break;\n                            analyzer->assume(condTok, false);\n                        }\n                    }\n                    if (thenAction.isInconclusive() || elseAction.isInconclusive()) {\n                        if (!analyzer->lowerToInconclusive())\n                            return Progress::Break;\n                    } else if (thenAction.isModified() || elseAction.isModified()) {\n                        if (!hasElse && analyzer->isConditional())\n                            return Progress::Break;\n                        if (!analyzer->lowerToPossible())\n                            return Progress::Break;\n                        analyzer->assume(condTok, elseAction.isModified());\n                    }\n                }\n            } else if (Token::simpleMatch(tok, \"try {\")) {\n                Token* endBlock = tok->next()->link();\n                ForwardAnalyzer::Action a = analyzeScope(endBlock);\n                if (updateRange(tok->next(), endBlock) == Progress::Break)\n                    return Progress::Break;\n                if (a.isModified())\n                    analyzer->lowerToPossible();\n                tok = endBlock;\n            } else if (Token::simpleMatch(tok, \"do {\")) {\n                Token* endBlock = tok->next()->link();\n                if (updateLoop(endBlock, nullptr) == Progress::Break)\n                    return Progress::Break;\n                tok = endBlock;\n            } else if (Token::Match(tok, \"assert|ASSERT (\")) {\n                const Token* condTok = tok->next()->astOperand2();\n                bool checkThen, checkElse;\n                std::tie(checkThen, checkElse) = evalCond(condTok);\n                if (checkElse)\n                    return Progress::Break;\n                if (!checkThen)\n                    analyzer->assume(condTok, true, tok);\n            } else if (Token::simpleMatch(tok, \"switch (\")) {\n                if (updateRecursive(tok->next()->astOperand2()) == Progress::Break)\n                    return Progress::Break;\n                return Progress::Break;\n            } else {\n                if (updateTok(tok, &next) == Progress::Break)\n                    return Progress::Break;\n                if (next) {\n                    if (precedes(next, end))\n                        tok = next->previous();\n                    else\n                        return Progress::Break;\n                }\n            }\n            // Prevent infinite recursion\n            if (tok->next() == start)\n                break;\n        }\n        return Progress::Continue;\n    }\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                    } else if (condTok->values().front().intvalue == !inElse) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_0c659a149953b9a67901a5b30259b7ef534bbaad/build_0c659a149953b9a67901a5b30259b7ef534bbaad\nTest project /out/danmar___cppcheck/git_repo_dir_0c659a149953b9a67901a5b30259b7ef534bbaad/build_0c659a149953b9a67901a5b30259b7ef534bbaad\n    Start 59: TestValueFlow\n1/1 Test #59: TestValueFlow ....................***Failed    1.27 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.28 sec\n\nThe following tests FAILED:\n\t 59 - TestValueFlow (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "0c659a149953b9a67901a5b30259b7ef534bbaad___forwardanalyzer.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid Variable::evaluate(const Library* lib)\n{\n    if (_name)\n        setFlag(fIsArray, arrayDimensions(lib));\n\n    const Token* tok = _start;\n    while (tok && tok->previous() && tok->previous()->isName())\n        tok = tok->previous();\n\n>>> [ INFILL ] <<<\n        if (tok->str() == \"static\")\n            setFlag(fIsStatic, true);\n        else if (tok->str() == \"extern\")\n            setFlag(fIsExtern, true);\n        else if (tok->str() == \"volatile\")\n            setFlag(fIsVolatile, true);\n        else if (tok->str() == \"mutable\")\n            setFlag(fIsMutable, true);\n        else if (tok->str() == \"const\")\n            setFlag(fIsConst, true);\n        else if (tok->str() == \"*\") {\n            setFlag(fIsPointer, !isArray() || Token::Match(tok->previous(), \"( * %name% )\"));\n            setFlag(fIsConst, false); // Points to const, isn't necessarily const itself\n        } else if (tok->str() == \"&\") {\n            if (isReference())\n                setFlag(fIsRValueRef, true);\n            setFlag(fIsReference, true);\n        } else if (tok->str() == \"&&\") { // Before simplification, && isn't split up\n            setFlag(fIsRValueRef, true);\n            setFlag(fIsReference, true); // Set also fIsReference\n        }\n\n        if (tok->str() == \"<\" && tok->link())\n            tok = tok->link();\n        else\n            tok = tok->next();\n    }\n\n    while (Token::Match(_start, \"static|const %any%\"))\n        _start = _start->next();\n    while (_end && _end->previous() && _end->str() == \"const\")\n        _end = _end->previous();\n\n    if (_start) {\n        std::string strtype = _start->str();\n        for (const Token *typeToken = _start; Token::Match(typeToken, \"%type% :: %type%\"); typeToken = typeToken->tokAt(2))\n            strtype += \"::\" + typeToken->strAt(2);\n        setFlag(fIsClass, !lib->podtype(strtype) && !_start->isStandardType() && !isPointer() && !isReference());\n        setFlag(fIsStlType, Token::simpleMatch(_start, \"std ::\"));\n        setFlag(fIsStlString, isStlType() && (Token::Match(_start->tokAt(2), \"string|wstring|u16string|u32string !!::\") || (Token::simpleMatch(_start->tokAt(2), \"basic_string <\") && !Token::simpleMatch(_start->linkAt(3), \"> ::\"))));\n    }\n    if (_access == Argument) {\n        tok = _name;\n        if (!tok) {\n            // Argument without name\n            tok = _end;\n            // back up to start of array dimensions\n            while (tok && tok->str() == \"]\")\n                tok = tok->link()->previous();\n            // add array dimensions if present\n            if (tok && tok->next()->str() == \"[\")\n                setFlag(fIsArray, arrayDimensions(lib));\n        }\n        if (!tok)\n            return;\n        tok = tok->next();\n        while (tok->str() == \"[\")\n            tok = tok->link();\n        setFlag(fHasDefault, tok->str() == \"=\");\n    }\n    // check for C++11 member initialization\n    if (_scope && _scope->isClassOrStruct()) {\n        // type var = x or\n        // type var = {x}\n        // type var = x; gets simplified to: type var ; var = x ;\n        Token const * declEnd = declEndToken();\n        if ((Token::Match(declEnd, \"; %name% =\") && declEnd->strAt(1) == _name->str()) ||\n            Token::Match(declEnd, \"=|{\"))\n            setFlag(fHasDefault, true);\n    }\n\n    if (_start) {\n        if (Token::Match(_start, \"float|double\"))\n            setFlag(fIsFloatType, true);\n    }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    for (const Token* const end = _name?_name:_end; tok != end;) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_68d77b73da0d86b8d18bf6fcbbf45e77a29a6b26/build_68d77b73da0d86b8d18bf6fcbbf45e77a29a6b26\nTest project /out/danmar___cppcheck/git_repo_dir_68d77b73da0d86b8d18bf6fcbbf45e77a29a6b26/build_68d77b73da0d86b8d18bf6fcbbf45e77a29a6b26\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   24.73 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  24.73 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "68d77b73da0d86b8d18bf6fcbbf45e77a29a6b26___symboldatabase.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid CheckCondition::checkCompareValueOutOfTypeRange()\n{\n    if (!mSettings->severity.isEnabled(Severity::style))\n        return;\n\n    if (mSettings->platformType == cppcheck::Platform::PlatformType::Native ||\n        mSettings->platformType == cppcheck::Platform::PlatformType::Unspecified)\n        return;\n\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n    for (const Scope * scope : symbolDatabase->functionScopes) {\n        for (const Token* tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {\n            if (!tok->isComparisonOp() || !tok->isBinaryOp())\n                continue;\n\n            for (int i = 0; i < 2; ++i) {\n                const Token * const valueTok = (i == 0) ? tok->astOperand1() : tok->astOperand2();\n                const Token * const typeTok = valueTok->astSibling();\n                if (!valueTok->hasKnownIntValue() || !typeTok->valueType() || typeTok->valueType()->pointer)\n                    continue;\n                if (valueTok->getKnownIntValue() < 0 && valueTok->valueType() && valueTok->valueType()->sign != ValueType::Sign::SIGNED)\n                    continue;\n                int bits = 0;\n                switch (typeTok->valueType()->type) {\n                case ValueType::Type::BOOL:\n                    bits = 1;\n                    break;\n                case ValueType::Type::CHAR:\n                    bits = mSettings->char_bit;\n                    break;\n                case ValueType::Type::SHORT:\n                    bits = mSettings->short_bit;\n                    break;\n                case ValueType::Type::INT:\n                    bits = mSettings->int_bit;\n                    break;\n                case ValueType::Type::LONG:\n                    bits = mSettings->long_bit;\n                    break;\n                case ValueType::Type::LONGLONG:\n                    bits = mSettings->long_long_bit;\n                    break;\n                default:\n                    break;\n                };\n                if (bits == 0 || bits >= 64)\n                    continue;\n\n                const auto typeMinValue = (typeTok->valueType()->sign == ValueType::Sign::SIGNED) ? (-(1LL << (bits-1))) : 0;\n\n>>> [ INFILL ] <<<\n                const auto typeMaxValue = (typeTok->valueType()->sign == ValueType::Sign::SIGNED) ? (unsignedTypeMaxValue / 2) : unsignedTypeMaxValue;\n\n                if (valueTok->getKnownIntValue() < typeMinValue)\n                    compareValueOutOfTypeRangeError(valueTok, typeTok->valueType()->str(), valueTok->getKnownIntValue());\n                else if (valueTok->getKnownIntValue() > typeMaxValue)\n                    compareValueOutOfTypeRangeError(valueTok, typeTok->valueType()->str(), valueTok->getKnownIntValue());\n            }\n        }\n    }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                const auto unsignedTypeMaxValue = (1LL << (bits-1)) - 1LL;\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_797de4ef920dda5c569e5fd74e27731bc32053dd/build_797de4ef920dda5c569e5fd74e27731bc32053dd\nTest project /out/danmar___cppcheck/git_repo_dir_797de4ef920dda5c569e5fd74e27731bc32053dd/build_797de4ef920dda5c569e5fd74e27731bc32053dd\n    Start 14: TestCondition\n1/1 Test #14: TestCondition ....................***Failed    1.91 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.92 sec\n\nThe following tests FAILED:\n\t 14 - TestCondition (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "797de4ef920dda5c569e5fd74e27731bc32053dd___checkcondition.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid CheckCondition::alwaysTrueFalse()\n{\n    if (!mSettings->isEnabled(Settings::STYLE))\n        return;\n\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n    for (const Scope * scope : symbolDatabase->functionScopes) {\n        for (const Token* tok = scope->bodyStart->next(); tok != scope->bodyEnd; tok = tok->next()) {\n\n            if (tok->link()) // don't write false positives when templates are used\n                continue;\n            if (!tok->hasKnownIntValue())\n                continue;\n            // Skip already diagnosed values\n            if (diag(tok, false))\n                continue;\n            if (Token::Match(tok, \"%num%|%bool%|%char%\"))\n                continue;\n            if (Token::Match(tok, \"! %num%|%bool%|%char%\"))\n                continue;\n            if (Token::Match(tok, \"%oror%|&&|:\"))\n                continue;\n            if (Token::Match(tok, \"%comp%\") && isSameExpression(mTokenizer->isCPP(), true, tok->astOperand1(), tok->astOperand2(), mSettings->library, true, true))\n                continue;\n\n            const bool constIfWhileExpression =\n                tok->astParent() && Token::Match(tok->astTop()->astOperand1(), \"if|while\") &&\n                (Token::Match(tok->astParent(), \"%oror%|&&\") || Token::Match(tok->astParent()->astOperand1(), \"if|while\"));\n            const bool constValExpr = tok->isNumber() && Token::Match(tok->astParent(),\"%oror%|&&|?\"); // just one number in boolean expression\n            const bool compExpr = Token::Match(tok, \"%comp%|!\"); // a compare expression\n            const bool returnStatement = Token::simpleMatch(tok->astTop(), \"return\") &&\n                                         Token::Match(tok->astParent(), \"%oror%|&&|return\");\n\n            if (!(constIfWhileExpression || constValExpr || compExpr || returnStatement))\n                continue;\n\n\n>>> [ INFILL ] <<<\n                continue;\n\n            if (returnStatement && isConstVarExpression(tok))\n                continue;\n\n            if (returnStatement && Token::simpleMatch(tok->astParent(), \"return\") && tok->variable() && (\n                    !tok->variable()->isLocal() ||\n                    tok->variable()->isReference() ||\n                    tok->variable()->isConst() ||\n                    !isVariableChanged(tok->variable(), mSettings, mTokenizer->isCPP())))\n                continue;\n\n            // Don't warn in assertions. Condition is often 'always true' by intention.\n            // If platform,defines,etc cause 'always false' then that is not dangerous neither.\n            bool assertFound = false;\n            for (const Token * tok2 = tok->astParent(); tok2 ; tok2 = tok2->astParent()) { // move backwards and try to find \"assert\"\n                if (tok2->str() == \"(\" && tok2->astOperand2()) {\n                    const std::string& str = tok2->previous()->str();\n                    if ((str.find(\"assert\")!=std::string::npos || str.find(\"ASSERT\")!=std::string::npos))\n                        assertFound = true;\n                    break;\n                }\n            }\n            if (assertFound)\n                continue;\n\n            // Don't warn when there are expanded macros..\n            bool isExpandedMacro = false;\n            std::stack<const Token*> tokens;\n            tokens.push(tok);\n            while (!tokens.empty()) {\n                const Token *tok2 = tokens.top();\n                tokens.pop();\n                if (!tok2)\n                    continue;\n                tokens.push(tok2->astOperand1());\n                tokens.push(tok2->astOperand2());\n                if (tok2->isExpandedMacro()) {\n                    isExpandedMacro = true;\n                    break;\n                }\n            }\n            if (isExpandedMacro)\n                continue;\n            for (const Token *parent = tok; parent; parent = parent->astParent()) {\n                if (parent->isExpandedMacro()) {\n                    isExpandedMacro = true;\n                    break;\n                }\n            }\n            if (isExpandedMacro)\n                continue;\n\n            // don't warn when condition checks sizeof result\n            bool hasSizeof = false;\n            tokens.push(tok);\n            while (!tokens.empty()) {\n                const Token *tok2 = tokens.top();\n                tokens.pop();\n                if (!tok2)\n                    continue;\n                if (tok2->isNumber())\n                    continue;\n                if (Token::simpleMatch(tok2->previous(), \"sizeof (\")) {\n                    hasSizeof = true;\n                    continue;\n                }\n                if (tok2->isComparisonOp() || tok2->isArithmeticalOp()) {\n                    tokens.push(tok2->astOperand1());\n                    tokens.push(tok2->astOperand2());\n                } else\n                    break;\n            }\n            if (tokens.empty() && hasSizeof)\n                continue;\n\n            alwaysTrueFalseError(tok, &tok->values().front());\n        }\n    }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n            if (returnStatement && scope->function && !Token::simpleMatch(scope->function->retDef, \"bool\"))\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_0ee3f678b52d0203d4b84abf65e5cac92f26a553/build_0ee3f678b52d0203d4b84abf65e5cac92f26a553\nTest project /out/danmar___cppcheck/git_repo_dir_0ee3f678b52d0203d4b84abf65e5cac92f26a553/build_0ee3f678b52d0203d4b84abf65e5cac92f26a553\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   27.67 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  27.68 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "0ee3f678b52d0203d4b84abf65e5cac92f26a553___checkcondition.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nbool isOppositeExpression(bool cpp, const Token * const tok1, const Token * const tok2, const Library& library, bool pure)\n{\n    if (!tok1 || !tok2)\n        return false;\n    if (isOppositeCond(true, cpp, tok1, tok2, library, pure))\n        return true;\n    if (tok1->str() == \"-\" && !tok1->astOperand2())\n        return isSameExpression(cpp, true, tok1->astOperand1(), tok2, library, pure);\n\n>>> [ INFILL ] <<<\n        return isSameExpression(cpp, true, tok2->astOperand1(), tok1, library, pure);\n    return false;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    if (tok2->str() == \"-\" && !tok1->astOperand2())\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_f5dbfce8ffb3132bb49a155527a620c98e61b4a1/build_f5dbfce8ffb3132bb49a155527a620c98e61b4a1\nTest project /out/danmar___cppcheck/git_repo_dir_f5dbfce8ffb3132bb49a155527a620c98e61b4a1/build_f5dbfce8ffb3132bb49a155527a620c98e61b4a1\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   19.67 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  19.67 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "f5dbfce8ffb3132bb49a155527a620c98e61b4a1___astutils.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstd::string Preprocessor::getcode(const simplecpp::TokenList &tokens1, const std::string &cfg, std::vector<std::string> &files, const bool writeLocations)\n{\n    const simplecpp::DUI dui = createDUI(_settings, cfg, files[0]);\n\n    simplecpp::OutputList outputList;\n    std::list<simplecpp::MacroUsage> macroUsage;\n    simplecpp::TokenList tokens2(files);\n    simplecpp::preprocess(tokens2, tokens1, files, tokenlists, dui, &outputList, &macroUsage);\n\n    bool showerror = (!_settings.userDefines.empty() && !_settings.force);\n    reportOutput(outputList, showerror);\n    if (hasErrors(outputList))\n        return \"\";\n\n    // ensure that guessed define macros without value are not used in the code\n    if (!validateCfg(cfg, macroUsage))\n        return \"\";\n\n    // assembler code locations..\n    std::set<simplecpp::Location> assemblerLocations;\n    for (std::list<Directive>::const_iterator dirIt = directives.begin(); dirIt != directives.end(); ++dirIt) {\n        const Directive &d1 = *dirIt;\n        if (d1.str.compare(0, 11, \"#pragma asm\") != 0)\n            continue;\n        std::list<Directive>::const_iterator dirIt2 = dirIt;\n        ++dirIt2;\n        if (dirIt2 == directives.end())\n            continue;\n\n        const Directive &d2 = *dirIt2;\n        if (d2.str.compare(0,14,\"#pragma endasm\") != 0 || d1.file != d2.file)\n            continue;\n\n        simplecpp::Location loc(files);\n        loc.fileIndex = ~0U;\n        loc.col = 0U;\n        for (unsigned int i = 0; i < files.size(); ++i) {\n            if (files[i] == d1.file) {\n                loc.fileIndex = i;\n                break;\n            }\n        }\n\n        for (unsigned int linenr = d1.linenr + 1U; linenr < d2.linenr; linenr++) {\n            loc.line = linenr;\n            assemblerLocations.insert(loc);\n        }\n    }\n\n    unsigned int prevfile = 0;\n    unsigned int line = 1;\n    std::ostringstream ret;\n    for (const simplecpp::Token *tok = tokens2.cfront(); tok; tok = tok->next) {\n        if (writeLocations && tok->location.fileIndex != prevfile) {\n            ret << \"\\n#line \" << tok->location.line << \" \\\"\" << tok->location.file() << \"\\\"\\n\";\n            prevfile = tok->location.fileIndex;\n            line = tok->location.line;\n        }\n\n\n>>> [ INFILL ] <<<\n            ret << ' ';\n        bool newline = false;\n        while (tok->location.line > line) {\n            ret << '\\n';\n            line++;\n            newline = true;\n        }\n        if (newline) {\n            simplecpp::Location loc = tok->location;\n            loc.col = 0U;\n            if (assemblerLocations.find(loc) != assemblerLocations.end()) {\n                ret << \"asm();\";\n                while (assemblerLocations.find(loc) != assemblerLocations.end()) {\n                    loc.line++;\n                }\n                while (tok && tok->location.line < loc.line)\n                    tok = tok->next;\n                if (!tok)\n                    break;\n                while (line < tok->location.line) {\n                    ret << '\\n';\n                    ++line;\n                }\n            }\n        }\n        if (!tok->macro.empty())\n            ret << Preprocessor::macroChar;\n        ret << tok->str;\n    }\n\n    return ret.str();\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        if (tok->previous && line == tok->location.line)\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_43e4364675d4d47125b0d919039ba73dd4f6376e/build_43e4364675d4d47125b0d919039ba73dd4f6376e\nTest project /out/danmar___cppcheck/git_repo_dir_43e4364675d4d47125b0d919039ba73dd4f6376e/build_43e4364675d4d47125b0d919039ba73dd4f6376e\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   11.49 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  11.49 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "43e4364675d4d47125b0d919039ba73dd4f6376e___preprocessor.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nbool ErrorLogger::reportUnmatchedSuppressions(const std::list<Suppressions::Suppression> &unmatched)\n{\n    bool err = false;\n    // Report unmatched suppressions\n    for (const Suppressions::Suppression &s : unmatched) {\n        // don't report \"unmatchedSuppression\" as unmatched\n        if (s.errorId == \"unmatchedSuppression\")\n            continue;\n\n        // check if this unmatched suppression is suppressed\n        bool suppressed = false;\n        for (const Suppressions::Suppression &s2 : unmatched) {\n            if (s2.errorId == \"unmatchedSuppression\") {\n\n>>> [ INFILL ] <<<\n                    (s2.lineNumber == Suppressions::Suppression::NO_LINE || s2.lineNumber == s.lineNumber)) {\n                    suppressed = true;\n                    break;\n                }\n            }\n        }\n\n        if (suppressed)\n            continue;\n\n        std::list<ErrorLogger::ErrorMessage::FileLocation> callStack;\n        if (!s.fileName.empty())\n            callStack.emplace_back(s.fileName, s.lineNumber, 0);\n        reportErr(ErrorLogger::ErrorMessage(callStack, emptyString, Severity::information, \"Unmatched suppression: \" + s.errorId, \"unmatchedSuppression\", false));\n        err = true;\n    }\n    return err;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                if ((s2.fileName == \"*\" || s2.fileName == s.fileName) &&\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_6f2879a59b2c71b1fdb472471412c4b73184fea0/build_6f2879a59b2c71b1fdb472471412c4b73184fea0\nTest project /out/danmar___cppcheck/git_repo_dir_6f2879a59b2c71b1fdb472471412c4b73184fea0/build_6f2879a59b2c71b1fdb472471412c4b73184fea0\n    Start 14: TestErrorLogger\n1/1 Test #14: TestErrorLogger ..................***Failed    0.00 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.01 sec\n\nThe following tests FAILED:\n\t 14 - TestErrorLogger (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "6f2879a59b2c71b1fdb472471412c4b73184fea0___errorlogger.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\n    bool usingMatch(\n        const Token *nameToken,\n        const std::string &scope,\n        Token **tok,\n        const std::string &scope1,\n        const ScopeInfo3 *currentScope,\n        const ScopeInfo3 *memberClassScope)\n    {\n        Token *tok1 = *tok;\n\n        if (tok1 && tok1->str() != nameToken->str())\n            return false;\n\n        // skip this using\n        if (tok1 == nameToken) {\n            *tok = findSemicolon(tok1);\n            return false;\n        }\n\n        // skip other using with this name\n        if (tok1->strAt(-1) == \"using\") {\n            // fixme: this is wrong\n            // skip to end of scope\n            if (currentScope->bodyEnd)\n                *tok = currentScope->bodyEnd->previous();\n            return false;\n        }\n\n        if (Token::Match(tok1->tokAt(-1), \"class|struct|union|enum|namespace\")) {\n            // fixme\n            return false;\n        }\n\n        // get qualification\n        std::string qualification;\n        const Token* tok2 = tok1;\n        std::string::size_type index = scope.size();\n        std::string::size_type new_index = std::string::npos;\n        bool match = true;\n        while (Token::Match(tok2->tokAt(-2), \"%name% ::\") && !tok2->tokAt(-2)->isKeyword()) {\n            std::string last;\n            if (match && !scope1.empty()) {\n                new_index = scope1.rfind(' ', index - 1);\n                if (new_index != std::string::npos)\n                    last = scope1.substr(new_index, index - new_index);\n                else if (!qualification.empty())\n                    last.clear();\n                else\n                    last = scope1;\n            } else\n                match = false;\n            if (match && tok2->strAt(-2) == last)\n                index = new_index;\n            else {\n                if (!qualification.empty())\n                    qualification = \" :: \" + qualification;\n                qualification = tok2->strAt(-2) + qualification;\n            }\n            tok2 = tok2->tokAt(-2);\n        }\n\n        std::string fullScope1 = scope1;\n        if (!scope1.empty() && !qualification.empty())\n            fullScope1 += \" :: \";\n        fullScope1 += qualification;\n\n        if (scope == fullScope1)\n            return true;\n\n        const ScopeInfo3 *scopeInfo = memberClassScope ? memberClassScope : currentScope;\n\n        // check in base types\n\n>>> [ INFILL ] <<<\n            return true;\n\n        // check using namespace\n        const ScopeInfo3 * tempScope = scopeInfo;\n        while (tempScope) {\n            //if (!tempScope->parent->usingNamespaces.empty()) {\n            if (!tempScope->usingNamespaces.empty()) {\n                if (qualification.empty()) {\n                    if (tempScope->usingNamespaces.find(scope) != tempScope->usingNamespaces.end())\n                        return true;\n                } else {\n                    for (const auto &ns : tempScope->usingNamespaces) {\n                        if (scope == ns + \" :: \" + qualification)\n                            return true;\n                    }\n                }\n            }\n            tempScope = tempScope->parent;\n        }\n\n        std::string newScope1 = scope1;\n\n        // scopes didn't match so try higher scopes\n        index = newScope1.size();\n        while (!newScope1.empty()) {\n            std::string::size_type separator = newScope1.rfind(\" :: \", index - 1);\n            if (separator != std::string::npos)\n                newScope1 = newScope1.substr(0, separator);\n            else\n                newScope1.clear();\n\n            std::string newFullScope1 = newScope1;\n            if (!newScope1.empty() && !qualification.empty())\n                newFullScope1 += \" :: \";\n            newFullScope1 += qualification;\n\n            if (scope == newFullScope1)\n                return true;\n        }\n\n        return false;\n    }\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        if (scopeInfo->findTypeInBase(scope))\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_c4dcfef38564e97442fb6c122f5e67c908e0c665/build_c4dcfef38564e97442fb6c122f5e67c908e0c665\nTest project /out/danmar___cppcheck/git_repo_dir_c4dcfef38564e97442fb6c122f5e67c908e0c665/build_c4dcfef38564e97442fb6c122f5e67c908e0c665\n    Start 48: TestSymbolDatabase\n1/1 Test #48: TestSymbolDatabase ...............***Failed    1.50 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   1.53 sec\n\nThe following tests FAILED:\n\t 48 - TestSymbolDatabase (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "c4dcfef38564e97442fb6c122f5e67c908e0c665___tokenize.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid CheckBufferOverrun::arrayIndex()\n{\n    for (const Token *tok = mTokenizer->tokens(); tok; tok = tok->next()) {\n        if (tok->str() != \"[\")\n            continue;\n        const Token *array = tok->astOperand1();\n        while (Token::Match(array, \".|::\"))\n            array = array->astOperand2();\n        if (!array|| !array->variable() || array->variable()->nameToken() == array)\n            continue;\n        if (!array->scope()->isExecutable()) {\n            // LHS in non-executable scope => This is just a definition\n            const Token *parent = tok;\n            while (parent && !Token::simpleMatch(parent->astParent(), \"=\"))\n                parent = parent->astParent();\n\n>>> [ INFILL ] <<<\n                continue;\n        }\n\n        const Token *indexToken = tok->astOperand2();\n        if (!indexToken)\n            continue;\n\n        const Token *stringLiteral = nullptr;\n\n        if (!array->variable()->isArray() && array->variable()->dimensions().empty()) {\n            stringLiteral = array->getValueTokenMinStrSize();\n            if (!stringLiteral)\n                continue;\n        }\n\n        const MathLib::bigint dim = stringLiteral ? Token::getStrSize(stringLiteral) : array->variable()->dimensions()[0].num;\n\n        // Positive index\n        if (stringLiteral || dim > 1) { // TODO check arrays with dim 1 also\n            for (int cond = 0; cond < 2; cond++) {\n                const ValueFlow::Value *value = indexToken->getMaxValue(cond == 1);\n                if (!value)\n                    continue;\n                const MathLib::bigint index = value->intvalue;\n                if (index < dim)\n                    continue;\n                if (index == dim) {\n                    const Token *parent = tok;\n                    while (Token::simpleMatch(parent, \"[\"))\n                        parent = parent->astParent();\n                    if (parent->isUnaryOp(\"&\"))\n                        continue;\n                }\n                arrayIndexError(tok, array->variable(), value);\n            }\n        }\n\n        // Negative index\n        const ValueFlow::Value *negativeValue = indexToken->getValueLE(-1, mSettings);\n        if (negativeValue) {\n            negativeIndexError(tok, array->variable(), negativeValue);\n        }\n    }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n            if (parent && parent == parent->astParent()->astOperand1())\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_81a1d744c6e9d13f2fac894c380caafb270741df/build_81a1d744c6e9d13f2fac894c380caafb270741df\nTest project /out/danmar___cppcheck/git_repo_dir_81a1d744c6e9d13f2fac894c380caafb270741df/build_81a1d744c6e9d13f2fac894c380caafb270741df\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   23.14 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  23.14 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "81a1d744c6e9d13f2fac894c380caafb270741df___checkbufferoverrun.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstd::string TemplateSimplifier::getNewName(\n    Token *tok2,\n    std::list<std::string> &typeStringsUsedInTemplateInstantiation)\n{\n    std::string typeForNewName;\n    unsigned int indentlevel = 0;\n    const Token * endToken = tok2->next()->findClosingBracket();\n    for (Token *tok3 = tok2->tokAt(2); tok3 != endToken && (indentlevel > 0 || tok3->str() != \">\"); tok3 = tok3->next()) {\n        // #2721 - unhandled [ => bail out\n        if (tok3->str() == \"[\" && !Token::Match(tok3->next(), \"%num%| ]\")) {\n            typeForNewName.clear();\n            break;\n        }\n        if (!tok3->next()) {\n            typeForNewName.clear();\n            break;\n        }\n        if (Token::Match(tok3->tokAt(-2), \"<|,|:: %name% <\") && (tok3->strAt(1) == \">\" || templateParameters(tok3)))\n            ++indentlevel;\n        else if (indentlevel > 0 && Token::Match(tok3, \"> ,|>|::\"))\n            --indentlevel;\n\n>>> [ INFILL ] <<<\n            mTypesUsedInTemplateInstantiation.emplace_back(tok3, \"\");\n        }\n        if (Token::Match(tok3, \"(|[\"))\n            ++indentlevel;\n        else if (Token::Match(tok3, \")|]\"))\n            --indentlevel;\n        const bool constconst = tok3->str() == \"const\" && tok3->strAt(1) == \"const\";\n        if (!constconst) {\n            if (tok3->isUnsigned())\n                typeStringsUsedInTemplateInstantiation.emplace_back(\"unsigned\");\n            else if (tok3->isSigned())\n                typeStringsUsedInTemplateInstantiation.emplace_back(\"signed\");\n            if (tok3->isLong())\n                typeStringsUsedInTemplateInstantiation.emplace_back(\"long\");\n            typeStringsUsedInTemplateInstantiation.push_back(tok3->str());\n        }\n        // add additional type information\n        if (!constconst && !Token::Match(tok3, \"class|struct|enum\")) {\n            if (!typeForNewName.empty())\n                typeForNewName += ' ';\n            if (tok3->isUnsigned())\n                typeForNewName += \"unsigned \";\n            else if (tok3->isSigned())\n                typeForNewName += \"signed \";\n            if (tok3->isLong()) {\n                typeForNewName += \"long \";\n            }\n            typeForNewName += tok3->str();\n        }\n    }\n\n    return typeForNewName;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        if (indentlevel == 0 && Token::Match(tok3->previous(), \"[<,]\")) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_4779f0e1725c5807b329798e12dbeaddbf568b65/build_4779f0e1725c5807b329798e12dbeaddbf568b65\nTest project /out/danmar___cppcheck/git_repo_dir_4779f0e1725c5807b329798e12dbeaddbf568b65/build_4779f0e1725c5807b329798e12dbeaddbf568b65\n    Start 55: TestThreadExecutor\n1/3 Test #55: TestThreadExecutor ...............   Passed    7.45 sec\n    Start 44: TestProcessExecutor\n2/3 Test #44: TestProcessExecutor ..............   Passed    6.89 sec\n    Start 45: TestSimplifyTemplate\n3/3 Test #45: TestSimplifyTemplate .............***Failed    0.93 sec\n\n67% tests passed, 1 tests failed out of 3\n\nTotal Test time (real) =  15.28 sec\n\nThe following tests FAILED:\n\t 45 - TestSimplifyTemplate (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "4779f0e1725c5807b329798e12dbeaddbf568b65___templatesimplifier.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\n    void traverse(Token* start) {\n        for (Token* tok = start->previous(); tok; tok = tok->previous()) {\n            if (tok == start || (tok->str() == \"{\" && (tok->scope()->type == Scope::ScopeType::eFunction ||\n                                 tok->scope()->type == Scope::ScopeType::eLambda))) {\n                break;\n            }\n            if (Token::Match(tok, \"return|break|continue\"))\n                break;\n            if (Token::Match(tok, \"%name% :\"))\n                break;\n            // Evaluate LHS of assignment before RHS\n            if (Token* assignTok = assignExpr(tok)) {\n                // If assignTok has broken ast then stop\n                if (!assignTok->astOperand1() || !assignTok->astOperand2())\n                    break;\n                Token* assignTop = assignTok;\n                bool continueB = true;\n                while (assignTop->isAssignmentOp()) {\n                    if (!Token::Match(assignTop->astOperand1(), \"%assign%\")) {\n                        continueB &= updateRecursive(assignTop->astOperand1());\n                    }\n                    if (!assignTop->astParent())\n                        break;\n                    assignTop = assignTop->astParent();\n                }\n                // Is assignment in dead code\n                if (Token* parent = isDeadCode(assignTok)) {\n                    tok = parent;\n                    continue;\n                }\n                // Simple assign\n                if (assignTok->astParent() == assignTop || assignTok == assignTop) {\n                    Analyzer::Action rhsAction =\n                        analyzer->analyze(assignTok->astOperand2(), Analyzer::Direction::Reverse);\n                    Analyzer::Action lhsAction =\n                        analyzer->analyze(assignTok->astOperand1(), Analyzer::Direction::Reverse);\n                    // Assignment from\n                    if (rhsAction.isRead()) {\n                        const std::string info = \"Assignment from '\" + assignTok->expressionString() + \"'\";\n                        ValuePtr<Analyzer> a = analyzer->reanalyze(assignTok->astOperand1(), info);\n                        if (a) {\n                            valueFlowGenericForward(nextAfterAstRightmostLeaf(assignTok->astOperand2()),\n                                                    assignTok->astOperand2()->scope()->bodyEnd,\n                                                    a,\n                                                    settings);\n                        }\n                        // Assignment to\n                    } else if (lhsAction.matches() && !assignTok->astOperand2()->hasKnownValue()) {\n                        const std::string info = \"Assignment to '\" + assignTok->expressionString() + \"'\";\n                        ValuePtr<Analyzer> a = analyzer->reanalyze(assignTok->astOperand2(), info);\n                        if (a) {\n                            valueFlowGenericForward(nextAfterAstRightmostLeaf(assignTok->astOperand2()),\n                                                    assignTok->astOperand2()->scope()->bodyEnd,\n                                                    a,\n                                                    settings);\n                            valueFlowGenericReverse(assignTok->astOperand1()->previous(), a, settings);\n                        }\n                    }\n                }\n                if (!continueB)\n                    break;\n\n>>> [ INFILL ] <<<\n                tok = previousBeforeAstLeftmostLeaf(assignTop)->next();\n                continue;\n            }\n            if (tok->str() == \"}\") {\n                Token* condTok = getCondTokFromEnd(tok);\n                if (!condTok)\n                    break;\n                Analyzer::Action condAction = analyzeRecursive(condTok);\n                const bool inLoop = condTok->astTop() && Token::Match(condTok->astTop()->previous(), \"for|while (\");\n                // Evaluate condition of for and while loops first\n                if (inLoop) {\n                    if (condAction.isModified())\n                        break;\n                    valueFlowGenericForward(condTok, analyzer, settings);\n                }\n                Token* thenEnd;\n                const bool hasElse = Token::simpleMatch(tok->link()->tokAt(-2), \"} else {\");\n                if (hasElse) {\n                    thenEnd = tok->link()->tokAt(-2);\n                } else {\n                    thenEnd = tok;\n                }\n\n                Analyzer::Action thenAction = analyzeRange(thenEnd->link(), thenEnd);\n                Analyzer::Action elseAction = Analyzer::Action::None;\n                if (hasElse) {\n                    elseAction = analyzeRange(tok->link(), tok);\n                }\n                if (thenAction.isModified() && inLoop)\n                    break;\n                else if (thenAction.isModified() && !elseAction.isModified())\n                    analyzer->assume(condTok, hasElse, condTok);\n                else if (elseAction.isModified() && !thenAction.isModified())\n                    analyzer->assume(condTok, !hasElse, condTok);\n                // Bail if one of the branches are read to avoid FPs due to over constraints\n                else if (thenAction.isIdempotent() || elseAction.isIdempotent() || thenAction.isRead() ||\n                         elseAction.isRead())\n                    break;\n                if (thenAction.isInvalid() || elseAction.isInvalid())\n                    break;\n\n                if (!thenAction.isModified() && !elseAction.isModified())\n                    valueFlowGenericForward(condTok, analyzer, settings);\n                else if (condAction.isRead())\n                    break;\n                // If the condition modifies the variable then bail\n                if (condAction.isModified())\n                    break;\n                tok = condTok->astTop()->previous();\n                continue;\n            }\n            if (tok->str() == \"{\") {\n                if (tok->previous() &&\n                    (Token::simpleMatch(tok->previous(), \"do\") ||\n                     (tok->strAt(-1) == \")\" && Token::Match(tok->linkAt(-1)->previous(), \"for|while (\")))) {\n                    Analyzer::Action action = analyzeRange(tok, tok->link());\n                    if (action.isModified())\n                        break;\n                }\n                if (Token::simpleMatch(tok->tokAt(-2), \"} else {\"))\n                    tok = tok->linkAt(-2);\n                if (Token::simpleMatch(tok->previous(), \") {\"))\n                    tok = tok->previous()->link();\n                continue;\n            }\n            if (Token* next = isUnevaluated(tok)) {\n                tok = next;\n                continue;\n            }\n            if (Token* parent = isDeadCode(tok)) {\n                tok = parent;\n                continue;\n            }\n            if (!update(tok))\n                break;\n        }\n    }\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                valueFlowGenericForward(assignTop->astOperand2(), analyzer, settings);\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_f1169bf2b43fc1beab0da21e430adaa0a7a9eb49/build_f1169bf2b43fc1beab0da21e430adaa0a7a9eb49\nTest project /out/danmar___cppcheck/git_repo_dir_f1169bf2b43fc1beab0da21e430adaa0a7a9eb49/build_f1169bf2b43fc1beab0da21e430adaa0a7a9eb49\n    Start 31: TestNullPointer\n1/1 Test #31: TestNullPointer ..................***Failed    0.73 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.74 sec\n\nThe following tests FAILED:\n\t 31 - TestNullPointer (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "f1169bf2b43fc1beab0da21e430adaa0a7a9eb49___reverseanalyzer.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic void valueFlowDynamicBufferSize(TokenList *tokenlist, SymbolDatabase *symboldatabase, ErrorLogger *errorLogger, const Settings *settings)\n{\n    for (const Scope *functionScope : symboldatabase->functionScopes) {\n        for (const Token *tok = functionScope->bodyStart; tok != functionScope->bodyEnd; tok = tok->next()) {\n            if (!Token::Match(tok, \"[;{}] %var% =\"))\n                continue;\n\n            if (!tok->next()->variable())\n                continue;\n\n            const Token *rhs = tok->tokAt(2)->astOperand2();\n            while (rhs && rhs->isCast())\n                rhs = rhs->astOperand2() ? rhs->astOperand2() : rhs->astOperand1();\n            if (!rhs)\n                continue;\n\n            if (!Token::Match(rhs->previous(), \"%name% (\"))\n                continue;\n\n            const Library::AllocFunc *allocFunc = settings->library.alloc(rhs->previous());\n            if (!allocFunc || allocFunc->bufferSize == Library::AllocFunc::BufferSize::none)\n                continue;\n\n            const std::vector<const Token *> args = getArguments(rhs->previous());\n\n            const Token * const arg1 = (args.size() >= allocFunc->bufferSizeArg1) ? args[allocFunc->bufferSizeArg1 - 1] : nullptr;\n            const Token * const arg2 = (args.size() >= allocFunc->bufferSizeArg2) ? args[allocFunc->bufferSizeArg2 - 1] : nullptr;\n\n            MathLib::bigint sizeValue = -1;\n            switch (allocFunc->bufferSize) {\n            case Library::AllocFunc::BufferSize::none:\n                break;\n            case Library::AllocFunc::BufferSize::malloc:\n                if (arg1 && arg1->hasKnownIntValue())\n                    sizeValue = arg1->getKnownIntValue();\n                break;\n            case Library::AllocFunc::BufferSize::calloc:\n                if (arg1 && arg2 && arg1->hasKnownIntValue() && arg2->hasKnownIntValue())\n                    sizeValue = arg1->getKnownIntValue() * arg2->getKnownIntValue();\n                break;\n            case Library::AllocFunc::BufferSize::strdup:\n                if (arg1 && arg1->hasKnownValue()) {\n                    const ValueFlow::Value &value = arg1->values().back();\n                    if (value.isTokValue() && value.tokvalue->tokType() == Token::eString)\n\n>>> [ INFILL ] <<<\n                }\n                break;\n            };\n            if (sizeValue < 0)\n                continue;\n\n            ValueFlow::Value value(sizeValue);\n            value.errorPath.emplace_back(tok->tokAt(2), \"Assign \" + tok->strAt(1) + \", buffer with size \" + MathLib::toString(sizeValue));\n            value.valueType = ValueFlow::Value::ValueType::BUFFER_SIZE;\n            value.setKnown();\n            const std::list<ValueFlow::Value> values{value};\n            valueFlowForward(const_cast<Token *>(rhs),\n                             functionScope->bodyEnd,\n                             tok->next()->variable(),\n                             tok->next()->varId(),\n                             values,\n                             true,\n                             false,\n                             tokenlist,\n                             errorLogger,\n                             settings);\n        }\n    }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                        sizeValue = Token::getStrLength(value.tokvalue);\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_d909ac856569e39cb2f53b158c6246ac82d461b7/build_d909ac856569e39cb2f53b158c6246ac82d461b7\nTest project /out/danmar___cppcheck/git_repo_dir_d909ac856569e39cb2f53b158c6246ac82d461b7/build_d909ac856569e39cb2f53b158c6246ac82d461b7\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   27.64 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  27.65 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "d909ac856569e39cb2f53b158c6246ac82d461b7___valueflow.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid CheckClass::checkExplicitConstructors()\n{\n    if (!mSettings->isEnabled(Settings::STYLE))\n        return;\n\n    for (const Scope * scope : mSymbolDatabase->classAndStructScopes) {\n        // Do not perform check, if the class/struct has not any constructors\n        if (scope->numConstructors == 0)\n            continue;\n\n        // Is class abstract? Maybe this test is over-simplification, but it will suffice for simple cases,\n        // and it will avoid false positives.\n        bool isAbstractClass = false;\n        for (const Function &func : scope->functionList) {\n            if (func.isPure()) {\n                isAbstractClass = true;\n                break;\n            }\n        }\n\n        // Abstract classes can't be instantiated. But if there is C++11\n        // \"misuse\" by derived classes then these constructors must be explicit.\n        if (isAbstractClass && mSettings->standards.cpp != Standards::CPP11)\n            continue;\n\n        for (const Function &func : scope->functionList) {\n\n            // We are looking for constructors, which are meeting following criteria:\n            //  1) Constructor is declared with a single parameter\n            //  2) Constructor is not declared as explicit\n            //  3) It is not a copy/move constructor of non-abstract class\n            //  4) Constructor is not marked as delete (programmer can mark the default constructor as deleted, which is ok)\n            if (!func.isConstructor() || func.isDelete() || (!func.hasBody() && func.access == Private))\n                continue;\n\n            if (!func.isExplicit() &&\n\n>>> [ INFILL ] <<<\n                func.type != Function::eCopyConstructor &&\n                func.type != Function::eMoveConstructor) {\n                noExplicitConstructorError(func.tokenDef, scope->className, scope->type == Scope::eStruct);\n            }\n        }\n    }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                func.argCount() == 1 &&\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_272760f9cac187bd16ab4a596a0cab870ceb42be/build_272760f9cac187bd16ab4a596a0cab870ceb42be\nTest project /out/danmar___cppcheck/git_repo_dir_272760f9cac187bd16ab4a596a0cab870ceb42be/build_272760f9cac187bd16ab4a596a0cab870ceb42be\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   34.37 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  34.38 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "272760f9cac187bd16ab4a596a0cab870ceb42be___checkclass.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\n    virtual std::vector<Condition> parse(const Token* tok, const Settings*) const OVERRIDE {\n        Condition cond;\n\n        ValueFlow::Value true_value;\n        ValueFlow::Value false_value;\n\n        if (Token::Match(tok, \"==|!=\")) {\n            if (!tok->astOperand1() || !tok->astOperand2())\n                return {};\n\n            ValueFlow::Value::ValueKind kind = ValueFlow::Value::ValueKind::Known;\n            std::list<ValueFlow::Value> values = getIteratorValues(tok->astOperand1()->values(), &kind);\n            if (!values.empty()) {\n                cond.vartok = tok->astOperand2();\n            } else {\n\n>>> [ INFILL ] <<<\n                if (!values.empty())\n                    cond.vartok = tok->astOperand1();\n            }\n            for (ValueFlow::Value& v:values) {\n                v.setPossible();\n                v.assumeCondition(tok);\n            }\n            cond.true_values = values;\n            cond.false_values = values;\n        }\n\n        return {cond};\n    }\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                values = getIteratorValues(tok->astOperand2()->values());\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_398fa280213771a0fa7a649a54dd6e6625d48e20/build_398fa280213771a0fa7a649a54dd6e6625d48e20\nTest project /out/danmar___cppcheck/git_repo_dir_398fa280213771a0fa7a649a54dd6e6625d48e20/build_398fa280213771a0fa7a649a54dd6e6625d48e20\n    Start 44: TestStl\n1/1 Test #44: TestStl ..........................***Failed    4.16 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   4.17 sec\n\nThe following tests FAILED:\n\t 44 - TestStl (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "398fa280213771a0fa7a649a54dd6e6625d48e20___valueflow.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid CheckUnusedVar::checkFunctionVariableUsage()\n{\n    if (!mSettings->isEnabled(Settings::STYLE))\n        return;\n\n    // Parse all executing scopes..\n    const SymbolDatabase *symbolDatabase = mTokenizer->getSymbolDatabase();\n\n    // only check functions\n    for (const Scope * scope : symbolDatabase->functionScopes) {\n        // Bailout when there are lambdas or inline functions\n        // TODO: Handle lambdas and inline functions properly\n        if (scope->hasInlineOrLambdaFunction())\n            continue;\n\n        for (const Token *tok = scope->bodyStart; tok != scope->bodyEnd; tok = tok->next()) {\n            if (findLambdaEndToken(tok))\n                // todo: handle lambdas\n                break;\n            if (Token::simpleMatch(tok, \"try {\"))\n                // todo: check try blocks\n                tok = tok->linkAt(1);\n            const Token *varDecl = nullptr;\n            if (tok->variable() && tok->variable()->nameToken() == tok) {\n                const Token * eq = tok->next();\n                while (Token::simpleMatch(eq, \"[\"))\n                    eq = eq->link()->next();\n                if (Token::simpleMatch(eq, \"=\")) {\n                    varDecl = tok;\n                    tok = eq;\n                }\n            }\n            // not assignment/initialization => continue\n            if ((!tok->isAssignmentOp() || !tok->astOperand1()) && !(Token::Match(tok, \"%var% (\") && tok->variable() && tok->variable()->nameToken() == tok))\n                continue;\n            if (tok->isName()) {\n                if (mTokenizer->isCPP()) {\n                    // do not check RAII/scope_lock objects\n                    if (!tok->valueType())\n                        continue;\n                    bool check = false;\n                    switch (tok->valueType()->type) {\n                    case ValueType::Type::UNKNOWN_TYPE:\n                    case ValueType::Type::NONSTD:\n                    case ValueType::Type::RECORD:\n\n>>> [ INFILL ] <<<\n                        break;\n                    case ValueType::Type::CONTAINER:\n                    case ValueType::Type::ITERATOR:\n                    case ValueType::Type::VOID:\n                    case ValueType::Type::BOOL:\n                    case ValueType::Type::CHAR:\n                    case ValueType::Type::SHORT:\n                    case ValueType::Type::WCHAR_T:\n                    case ValueType::Type::INT:\n                    case ValueType::Type::LONG:\n                    case ValueType::Type::LONGLONG:\n                    case ValueType::Type::UNKNOWN_INT:\n                    case ValueType::Type::FLOAT:\n                    case ValueType::Type::DOUBLE:\n                    case ValueType::Type::LONGDOUBLE:\n                        check = true;\n                        break;\n                    };\n                    if (!check)\n                        continue;\n                }\n                tok = tok->next();\n            }\n            if (tok->astParent() && tok->str() != \"(\") {\n                const Token *parent = tok->astParent();\n                while (Token::Match(parent, \"%oror%|%comp%|!|&&\"))\n                    parent = parent->astParent();\n                if (!parent)\n                    continue;\n                if (!Token::simpleMatch(parent->previous(), \"if (\"))\n                    continue;\n            }\n            // Do not warn about assignment with NULL\n            if (FwdAnalysis::isNullOperand(tok->astOperand2()))\n                continue;\n\n            if (tok->astOperand1()->variable() && tok->astOperand1()->variable()->isReference() && tok->astOperand1()->variable()->nameToken() != tok->astOperand1())\n                // todo: check references\n                continue;\n\n            if (tok->astOperand1()->variable() && tok->astOperand1()->variable()->isStatic())\n                // todo: check static variables\n                continue;\n\n            if (tok->astOperand1()->variable() && tok->astOperand1()->variable()->nameToken()->isAttributeUnused())\n                continue;\n\n            // Is there a redundant assignment?\n            const Token *start = tok->findExpressionStartEndTokens().second->next();\n\n            const Token *expr = varDecl ? varDecl : tok->astOperand1();\n\n            FwdAnalysis fwdAnalysis(mTokenizer->isCPP(), mSettings->library);\n            if (fwdAnalysis.unusedValue(expr, start, scope->bodyEnd))\n                // warn\n                unreadVariableError(tok, expr->expressionString(), false);\n        }\n\n        // varId, usage {read, write, modified}\n        Variables variables;\n\n        checkFunctionVariableUsage_iterateScopes(scope, variables);\n\n\n        // Check usage of all variables in the current scope..\n        for (std::map<unsigned int, Variables::VariableUsage>::const_iterator it = variables.varUsage().begin();\n             it != variables.varUsage().end();\n             ++it) {\n            const Variables::VariableUsage &usage = it->second;\n\n            // variable has been marked as unused so ignore it\n            if (usage._var->nameToken()->isAttributeUnused() || usage._var->nameToken()->isAttributeUsed())\n                continue;\n\n            // skip things that are only partially implemented to prevent false positives\n            if (usage.mType == Variables::pointerPointer ||\n                usage.mType == Variables::pointerArray ||\n                usage.mType == Variables::referenceArray)\n                continue;\n\n            const std::string &varname = usage._var->name();\n            const Variable* var = symbolDatabase->getVariableFromVarId(it->first);\n\n            // variable has had memory allocated for it, but hasn't done\n            // anything with that memory other than, perhaps, freeing it\n            if (usage.unused() && !usage._modified && usage._allocateMemory)\n                allocatedButUnusedVariableError(usage._lastAccess, varname);\n\n            // variable has not been written, read, or modified\n            else if (usage.unused() && !usage._modified)\n                unusedVariableError(usage._var->nameToken(), varname);\n\n            // variable has not been written but has been modified\n            else if (usage._modified && !usage._write && !usage._allocateMemory && var && !var->isStlType())\n                unassignedVariableError(usage._var->nameToken(), varname);\n\n            // variable has been read but not written\n            else if (!usage._write && !usage._allocateMemory && var && !var->isStlType() && !isEmptyType(var->type()))\n                unassignedVariableError(usage._var->nameToken(), varname);\n        }\n    }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n                        check = tok->valueType()->typeScope && tok->valueType()->typeScope->getDestructor();\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_d2284ddbcd2a70b4a39047ae32b1c5662060407f/build_d2284ddbcd2a70b4a39047ae32b1c5662060407f\nTest project /out/danmar___cppcheck/git_repo_dir_d2284ddbcd2a70b4a39047ae32b1c5662060407f/build_d2284ddbcd2a70b4a39047ae32b1c5662060407f\n    Start 1: testrunner\n1/1 Test #1: testrunner .......................***Failed   24.84 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =  24.84 sec\n\nThe following tests FAILED:\n\t  1 - testrunner (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "d2284ddbcd2a70b4a39047ae32b1c5662060407f___checkunusedvar.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid Tokenizer::arraySize()\n{\n    auto getStrTok = [](Token* tok, bool addLength, Token** endStmt) -> Token* {\n        if (addLength) {\n\n>>> [ INFILL ] <<<\n            return tok->tokAt(4);\n        }\n        if (Token::Match(tok, \"%var% [ ] =\")) {\n            tok = tok->tokAt(4);\n            int parCount = 0;\n            while (Token::simpleMatch(tok, \"(\")) {\n                ++parCount;\n                tok = tok->next();\n            }\n            if (Token::Match(tok, \"%str%\")) {\n                *endStmt = tok->tokAt(parCount + 1);\n                return tok;\n            }\n        }\n        return nullptr;\n    };\n\n    for (Token *tok = list.front(); tok; tok = tok->next()) {\n        if (!tok->isName() || !Token::Match(tok, \"%var% [ ] =\"))\n            continue;\n        bool addlength = false;\n        if (Token::Match(tok->previous(), \"!!* %var% [ ] = { %str% } ;\")) {\n            Token *t = tok->tokAt(3);\n            t->deleteNext();\n            t->next()->deleteNext();\n            addlength = true;\n        }\n\n        Token* endStmt{};\n        if (const Token* strTok = getStrTok(tok, addlength, &endStmt)) {\n            const int sz = Token::getStrArraySize(strTok);\n            tok->next()->insertToken(MathLib::toString(sz));\n            tok = endStmt;\n        }\n\n        else if (Token::Match(tok, \"%var% [ ] = {\")) {\n            MathLib::biguint sz = 1;\n            tok = tok->next();\n            Token *end = tok->linkAt(3);\n            for (Token *tok2 = tok->tokAt(4); tok2 && tok2 != end; tok2 = tok2->next()) {\n                if (tok2->link() && Token::Match(tok2, \"{|(|[|<\")) {\n                    if (tok2->str() == \"[\" && tok2->link()->strAt(1) == \"=\") { // designated initializer\n                        if (Token::Match(tok2, \"[ %num% ]\"))\n                            sz = std::max(sz, MathLib::toULongNumber(tok2->strAt(1)) + 1U);\n                        else {\n                            sz = 0;\n                            break;\n                        }\n                    }\n                    tok2 = tok2->link();\n                } else if (tok2->str() == \",\") {\n                    if (!Token::Match(tok2->next(), \"[},]\"))\n                        ++sz;\n                    else {\n                        tok2 = tok2->previous();\n                        tok2->deleteNext();\n                    }\n                }\n            }\n\n            if (sz != 0)\n                tok->insertToken(MathLib::toString(sz));\n\n            tok = end->next() ? end->next() : end;\n        }\n    }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n            *endStmt = tok->tokAt(6);\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_192c30ab1d3ec97ae7c6955d8953fac133b8e4ff/build_192c30ab1d3ec97ae7c6955d8953fac133b8e4ff\nTest project /out/danmar___cppcheck/git_repo_dir_192c30ab1d3ec97ae7c6955d8953fac133b8e4ff/build_192c30ab1d3ec97ae7c6955d8953fac133b8e4ff\n    Start 55: TestThreadExecutor\n1/2 Test #55: TestThreadExecutor ...............   Passed    8.50 sec\n    Start 58: TestTokenizer\n2/2 Test #58: TestTokenizer ....................***Exception: SegFault  1.12 sec\n\n50% tests passed, 1 tests failed out of 2\n\nTotal Test time (real) =   9.63 sec\n\nThe following tests FAILED:\n\t 58 - TestTokenizer (SEGFAULT)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "192c30ab1d3ec97ae7c6955d8953fac133b8e4ff___tokenize.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic void compilePrecedence2(Token *&tok, AST_state& state)\n{\n    compileScope(tok, state);\n    while (tok) {\n        if (tok->tokType() == Token::eIncDecOp && !isPrefixUnary(tok, state.cpp)) {\n            compileUnaryOp(tok, state, compileScope);\n        } else if (tok->str() == \"...\") {\n            state.op.push(tok);\n            tok = tok->next();\n            break;\n        } else if (tok->str() == \".\" && tok->strAt(1) != \"*\") {\n            if (tok->strAt(1) == \".\") {\n                state.op.push(tok);\n                tok = tok->tokAt(3);\n                break;\n            } else\n                compileBinOp(tok, state, compileScope);\n        } else if (tok->str() == \"[\") {\n            if (state.cpp && isPrefixUnary(tok, state.cpp) && Token::Match(tok->link(), \"] (|{\")) { // Lambda\n                // What we do here:\n                // - Nest the round bracket under the square bracket.\n                // - Nest what follows the lambda (if anything) with the lambda opening [\n                // - Compile the content of the lambda function as separate tree (this is done later)\n                // this must be consistent with isLambdaCaptureList\n                Token* const squareBracket = tok;\n                if (Token::simpleMatch(squareBracket->link(), \"] (\")) {\n                    Token* const roundBracket = squareBracket->link()->next();\n                    Token* curlyBracket = roundBracket->link()->next();\n                    if (Token::Match(curlyBracket, \"mutable|const\"))\n                        curlyBracket = curlyBracket->next();\n                    if (curlyBracket && curlyBracket->originalName() == \"->\") {\n                        while (Token::Match(curlyBracket, \"%name%|.|::|&|*\"))\n                            curlyBracket = curlyBracket->next();\n                        if (curlyBracket && curlyBracket->str() == \"<\" && curlyBracket->link())\n                            curlyBracket = curlyBracket->link()->next();\n                    }\n                    if (curlyBracket && curlyBracket->str() == \"{\") {\n                        squareBracket->astOperand1(roundBracket);\n                        roundBracket->astOperand1(curlyBracket);\n                        state.op.push(squareBracket);\n                        tok = curlyBracket->link()->next();\n                        continue;\n                    }\n                } else {\n                    Token* const curlyBracket = squareBracket->link()->next();\n                    squareBracket->astOperand1(curlyBracket);\n                    state.op.push(squareBracket);\n                    tok = curlyBracket->link()->next();\n                    continue;\n                }\n            }\n\n            const Token* const tok2 = tok;\n            if (tok->strAt(1) != \"]\")\n                compileBinOp(tok, state, compileExpression);\n            else\n                compileUnaryOp(tok, state, compileExpression);\n            tok = tok2->link()->next();\n        } else if (tok->str() == \"(\" && (!iscast(tok) || Token::Match(tok->previous(), \"if|while|for|switch|catch\"))) {\n            Token* tok2 = tok;\n            tok = tok->next();\n            const bool opPrevTopSquare = !state.op.empty() && state.op.top() && state.op.top()->str() == \"[\";\n            const std::size_t oldOpSize = state.op.size();\n            compileExpression(tok, state);\n            tok = tok2;\n            if ((tok->previous() && tok->previous()->isName() && (!Token::Match(tok->previous(), \"return|case\") && (!state.cpp || !Token::Match(tok->previous(), \"throw|delete\"))))\n                || (tok->strAt(-1) == \"]\" && (!state.cpp || !Token::Match(tok->linkAt(-1)->previous(), \"new|delete\")))\n                || (tok->strAt(-1) == \">\" && tok->linkAt(-1))\n                || (tok->strAt(-1) == \")\" && !iscast(tok->linkAt(-1))) // Don't treat brackets to clarify precedence as function calls\n                || (tok->strAt(-1) == \"}\" && opPrevTopSquare)) {\n                const bool operandInside = oldOpSize < state.op.size();\n                if (operandInside)\n                    compileBinOp(tok, state, nullptr);\n                else\n                    compileUnaryOp(tok, state, nullptr);\n            }\n            tok = tok->link()->next();\n        } else if (iscast(tok) && Token::simpleMatch(tok->link(), \") {\") && Token::simpleMatch(tok->link()->linkAt(1), \"} [\")) {\n            Token *cast = tok;\n            tok = tok->link()->next();\n            Token *tok1 = tok;\n            compileUnaryOp(tok, state, compileExpression);\n            cast->astOperand1(tok1);\n            tok = tok1->link()->next();\n        } else if (state.cpp && tok->str() == \"{\" && iscpp11init(tok)) {\n            if (Token::simpleMatch(tok, \"{ }\"))\n                compileUnaryOp(tok, state, compileExpression);\n            else\n                compileBinOp(tok, state, compileExpression);\n\n>>> [ INFILL ] <<<\n                tok = tok->next();\n        } else break;\n    }\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n            if (Token::simpleMatch(tok, \"}\"))\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/danmar___cppcheck/git_repo_dir_ea2916a3e49934d482cd9b30b520c7873db4de82/build_ea2916a3e49934d482cd9b30b520c7873db4de82\nTest project /out/danmar___cppcheck/git_repo_dir_ea2916a3e49934d482cd9b30b520c7873db4de82/build_ea2916a3e49934d482cd9b30b520c7873db4de82\n    Start 49: TestTokenizer\n1/1 Test #49: TestTokenizer ....................***Failed    3.57 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   3.57 sec\n\nThe following tests FAILED:\n\t 49 - TestTokenizer (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ea2916a3e49934d482cd9b30b520c7873db4de82___tokenlist.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\n    bool _parse_single_config(const ConfigItem &item, std::size_t level = 0) {\n        if(level < item.parents.size()) {\n            try {\n                auto subcom = get_subcommand(item.parents.at(level));\n                auto result = subcom->_parse_single_config(item, level + 1);\n\n                return result;\n            } catch(const OptionNotFound &) {\n                return false;\n            }\n        }\n        // check for section open\n        if(item.name == \"++\") {\n            if(configurable_) {\n                increment_parsed();\n                _trigger_pre_parse(2);\n                if(parent_ != nullptr) {\n                    parent_->parsed_subcommands_.push_back(this);\n                }\n            }\n            return true;\n        }\n        // check for section close\n        if(item.name == \"--\") {\n\n>>> [ INFILL ] <<<\n                _process_callbacks();\n                _process_requirements();\n                run_callback();\n            }\n            return true;\n        }\n        Option *op = get_option_no_throw(\"--\" + item.name);\n        if(op == nullptr) {\n            if(item.name.size() == 1) {\n                op = get_option_no_throw(\"-\" + item.name);\n            }\n        }\n        if(op == nullptr) {\n            op = get_option_no_throw(item.name);\n        }\n        if(op == nullptr) {\n            // If the option was not present\n            if(get_allow_config_extras() == config_extras_mode::capture)\n                // Should we worry about classifying the extras properly?\n                missing_.emplace_back(detail::Classifier::NONE, item.fullname());\n            return false;\n        }\n\n        if(!op->get_configurable()) {\n            if(get_allow_config_extras() == config_extras_mode::ignore_all) {\n                return false;\n            }\n            throw ConfigError::NotConfigurable(item.fullname());\n        }\n\n        if(op->empty()) {\n\n            if(op->get_expected_min() == 0) {\n                // Flag parsing\n                auto res = config_formatter_->to_flag(item);\n                res = op->get_flag_value(item.name, res);\n\n                op->add_result(res);\n\n            } else {\n                op->add_result(item.inputs);\n                op->run_callback();\n            }\n        }\n\n        return true;\n    }\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n            if(configurable_) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CLIUtils___CLI11/git_repo_dir_de215ef978104a0e9efdc7b78a9d58cd529cf17a/build_de215ef978104a0e9efdc7b78a9d58cd529cf17a\nTest project /out/CLIUtils___CLI11/git_repo_dir_de215ef978104a0e9efdc7b78a9d58cd529cf17a/build_de215ef978104a0e9efdc7b78a9d58cd529cf17a\n\nCLI11 information:\n  C++ standard: 11\n  __has_include: yes\n  No optional library found\n\n    Start 2: ConfigFileTest\n1/1 Test #2: ConfigFileTest ...................***Failed    0.03 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.03 sec\n\nThe following tests FAILED:\n\t  2 - ConfigFileTest (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "de215ef978104a0e9efdc7b78a9d58cd529cf17a___App.hpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\ninline std::pair<std::string, std::string> split_program_name(std::string commandline) {\n    // try to determine the programName\n    std::pair<std::string, std::string> vals;\n    trim(commandline);\n    auto esp = commandline.find_first_of(' ', 1);\n    while(detail::check_path(commandline.substr(0, esp).c_str()) != path_type::file) {\n        esp = commandline.find_first_of(' ', esp + 1);\n        if(esp == std::string::npos) {\n            // if we have reached the end and haven't found a valid file just assume the first argument is the\n            // program name\n            if(commandline[0] == '\"' || commandline[0] == '\\'' || commandline[0] == '`') {\n                bool embeddedQuote = false;\n                auto keyChar = commandline[0];\n                auto end = commandline.find_first_of(keyChar, 1);\n                while((end != std::string::npos) && (commandline[end - 1] == '\\\\')) {  // deal with escaped quotes\n                    end = commandline.find_first_of(keyChar, end + 1);\n                    embeddedQuote = true;\n                }\n                if(end != std::string::npos) {\n                    vals.first = commandline.substr(1, end - 1);\n                    esp = end + 1;\n                    if(embeddedQuote) {\n                        vals.first = find_and_replace(vals.first, std::string(\"\\\\\") + keyChar, std::string(1, keyChar));\n                    }\n                } else {\n                    esp = commandline.find_first_of(' ', 1);\n                }\n            } else {\n                esp = commandline.find_first_of(' ', 1);\n            }\n\n            break;\n        }\n    }\n    if(vals.first.empty()) {\n        vals.first = commandline.substr(0, esp);\n        rtrim(vals.first);\n    }\n\n    // strip the program name\n\n>>> [ INFILL ] <<<\n    ltrim(vals.second);\n    return vals;\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    vals.second = (esp != std::string::npos) ? commandline.substr(esp + 1) : std::string{};\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/CLIUtils___CLI11/git_repo_dir_020a21afc65fe843efca5b2f74e3d5b502425f76/build_020a21afc65fe843efca5b2f74e3d5b502425f76\nTest project /out/CLIUtils___CLI11/git_repo_dir_020a21afc65fe843efca5b2f74e3d5b502425f76/build_020a21afc65fe843efca5b2f74e3d5b502425f76\n\nCLI11 information:\n  C++ standard: 11\n  __has_include: yes\n  No optional library found\n\n    Start 15: StringParseTest\n1/1 Test #15: StringParseTest ..................***Failed    0.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.02 sec\n\nThe following tests FAILED:\n\t 15 - StringParseTest (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "020a21afc65fe843efca5b2f74e3d5b502425f76___Validators.hpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nchunk_t *align_assign(chunk_t *first, size_t span, size_t thresh, size_t *p_nl_count)\n{\n   LOG_FUNC_ENTRY();\n\n   if (first == nullptr)\n   {\n      return(nullptr);\n   }\n   size_t my_level = first->level;\n\n   LOG_FMT(LALASS, \"%s(%d): [my_level is %zu]: start checking with '%s', on orig_line %zu, span is %zu, thresh is %zu\\n\",\n           __func__, __LINE__, my_level, first->text(), first->orig_line, span, thresh);\n\n   // If we are aligning on a tabstop, we shouldn't right-align\n   AlignStack as;    // regular assigns\n   as.Start(span, thresh);\n   as.m_right_align = !cpd.settings[UO_align_on_tabstop].b;\n\n   AlignStack vdas;  // variable def assigns\n   vdas.Start(span, thresh);\n   vdas.m_right_align = as.m_right_align;\n\n   size_t  var_def_cnt = 0;\n   size_t  equ_count   = 0;\n   size_t  tmp;\n   chunk_t *pc = first;\n   while (pc != nullptr)\n   {\n      LOG_FMT(LALASS, \"%s(%d): orig_line is %zu, check pc->text() '%s'\\n\",\n              __func__, __LINE__, pc->orig_line, pc->text());\n      // Don't check inside PAREN or SQUARE groups\n      if (  pc->type == CT_SPAREN_OPEN\n\n>>> [ INFILL ] <<<\n         || pc->type == CT_SQUARE_OPEN\n         || pc->type == CT_PAREN_OPEN)\n      {\n         LOG_FMT(LALASS, \"%s(%d): Don't check inside PAREN or SQUARE groups, type is %s\\n\",\n                 __func__, __LINE__, get_token_name(pc->type));\n         tmp = pc->orig_line;\n         pc  = chunk_skip_to_match(pc);\n         if (pc != nullptr)\n         {\n            as.NewLines(pc->orig_line - tmp);\n            vdas.NewLines(pc->orig_line - tmp);\n         }\n         continue;\n      }\n\n      // Recurse if a brace set is found\n      if (pc->type == CT_BRACE_OPEN || pc->type == CT_VBRACE_OPEN)\n      {\n         size_t myspan;\n         size_t mythresh;\n\n         size_t sub_nl_count = 0;\n\n         if (pc->parent_type == CT_ENUM)\n         {\n            myspan   = cpd.settings[UO_align_enum_equ_span].u;\n            mythresh = cpd.settings[UO_align_enum_equ_thresh].u;\n         }\n         else\n         {\n            myspan   = cpd.settings[UO_align_assign_span].u;\n            mythresh = cpd.settings[UO_align_assign_thresh].u;\n         }\n\n         pc = align_assign(chunk_get_next_ncnl(pc), myspan, mythresh, &sub_nl_count);\n         if (sub_nl_count > 0)\n         {\n            as.NewLines(sub_nl_count);\n            vdas.NewLines(sub_nl_count);\n            if (p_nl_count != nullptr)\n            {\n               *p_nl_count += sub_nl_count;\n            }\n         }\n         continue;\n      }\n\n      // Done with this brace set?\n      if (pc->type == CT_BRACE_CLOSE || pc->type == CT_VBRACE_CLOSE)\n      {\n         pc = chunk_get_next(pc);\n         break;\n      }\n\n      if (chunk_is_newline(pc))\n      {\n         as.NewLines(pc->nl_count);\n         vdas.NewLines(pc->nl_count);\n         if (p_nl_count != nullptr)\n         {\n            *p_nl_count += pc->nl_count;\n         }\n\n         var_def_cnt = 0;\n         equ_count   = 0;\n      }\n      else if (pc->flags & PCF_VAR_DEF)\n      {\n         var_def_cnt++;\n      }\n      else if (var_def_cnt > 1)\n      {\n         // we hit the second variable def - don't look for assigns, don't align\n         vdas.Reset();\n      }\n      else if (  equ_count == 0\n              && pc->type == CT_ASSIGN\n              && ((pc->flags & PCF_IN_TEMPLATE) == 0))  // Issue #999\n      {\n         equ_count++;\n         if (var_def_cnt != 0)\n         {\n            vdas.Add(pc);\n         }\n         else\n         {\n            as.Add(pc);\n         }\n      }\n\n      pc = chunk_get_next(pc);\n   }\n\n   as.End();\n   vdas.End();\n\n   if (pc != nullptr)\n   {\n      LOG_FMT(LALASS, \"%s(%d): done on '%s' on orig_line %zu\\n\",\n              __func__, __LINE__, pc->text(), pc->orig_line);\n   }\n   else\n   {\n      LOG_FMT(LALASS, \"%s(%d): done on NULL\\n\", __func__, __LINE__);\n   }\n\n   return(pc);\n} // align_assign\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n         || pc->type == CT_FPAREN_OPEN\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/uncrustify___uncrustify/git_repo_dir_059898e80d55dbe8d5c5eca6e6c1b10668553f92/build_059898e80d55dbe8d5c5eca6e6c1b10668553f92\nTest project /out/uncrustify___uncrustify/git_repo_dir_059898e80d55dbe8d5c5eca6e6c1b10668553f92/build_059898e80d55dbe8d5c5eca6e6c1b10668553f92\n    Start 283: cpp_30023\n1/2 Test #283: cpp_30023 ........................***Failed    0.06 sec\n    Start 350: cpp_30220\n2/2 Test #350: cpp_30220 ........................***Failed    0.02 sec\n\n0% tests passed, 2 tests failed out of 2\n\nLabel Time Summary:\ncpp    =   0.08 sec*proc (2 tests)\n\nTotal Test time (real) =   0.13 sec\n\nThe following tests FAILED:\n\t283 - cpp_30023 (Failed)\n\t350 - cpp_30220 (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "059898e80d55dbe8d5c5eca6e6c1b10668553f92___align.cpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\n    [[nodiscard]] static bool erase(void *container, meta_any key) {\n        bool ret = false;\n\n        if(const auto *k_ptr = key.try_cast<typename meta_associative_container_traits<Type>::key_type>(); k_ptr) {\n            ret = meta_associative_container_traits<Type>::erase(*static_cast<Type *>(container), *k_ptr);\n        }\n\n        return ret;\n    }\n\n    [[nodiscard]] static iterator find(void *container, meta_any key) {\n        iterator ret{};\n\n        if(const auto *k_ptr = key.try_cast<typename meta_associative_container_traits<Type>::key_type>(); k_ptr) {\n            ret = iterator{std::in_place_type<Type>, meta_associative_container_traits<Type>::find(*static_cast<Type *>(container), *k_ptr)};\n        }\n\n        return ret;\n    }\n};\n\n\n/**\n * @brief Construct a proxy object for associative containers.\n * @tparam Type Type of container to wrap.\n * @param container The container to wrap.\n */\ntemplate<typename Type>\nmeta_associative_container::meta_associative_container(Type &container)\n\n>>> [ INFILL ] <<<\n      key_type_fn{&meta_associative_container_proxy<Type>::key_type},\n      mapped_type_fn{&meta_associative_container_proxy<Type>::mapped_type},\n      value_type_fn{&meta_associative_container_proxy<Type>::value_type},\n      size_fn{&meta_associative_container_proxy<Type>::size},\n      clear_fn{&meta_associative_container_proxy<Type>::clear},\n      begin_fn{&meta_associative_container_proxy<Type>::begin},\n      end_fn{&meta_associative_container_proxy<Type>::end},\n      insert_fn{&meta_associative_container_proxy<Type>::insert},\n      erase_fn{&meta_associative_container_proxy<Type>::erase},\n      find_fn{&meta_associative_container_proxy<Type>::find},\n      instance{&container}\n{}\n\n\n/*! @brief Default constructor. */\ninline meta_associative_container::meta_associative_container()\n    : key_only_container{false},\n      key_type_fn{nullptr},\n      mapped_type_fn{nullptr},\n      value_type_fn{nullptr},\n      size_fn{nullptr},\n      clear_fn{nullptr},\n      begin_fn{nullptr},\n      end_fn{nullptr},\n      insert_fn{nullptr},\n      erase_fn{nullptr},\n      find_fn{nullptr},\n      instance{nullptr}\n{}\n\n\n/**\n * @brief Returns true if the associative container is also key-only, false\n * otherwise.\n * @return True if the associative container is also key-only, false otherwise.\n */\n[[nodiscard]] inline bool meta_associative_container::key_only() const ENTT_NOEXCEPT {\n    return key_only_container;\n}\n\n\n/**\n * @brief Returns the key meta type of the wrapped container type.\n * @return The key meta type of the wrapped container type.\n */\n[[nodiscard]] inline meta_type meta_associative_container::key_type() const ENTT_NOEXCEPT {\n    return key_type_fn();\n}\n\n\n/**\n * @brief Returns the mapped meta type of the wrapped container type.\n * @return The mapped meta type of the wrapped container type.\n */\n[[nodiscard]] inline meta_type meta_associative_container::mapped_type() const ENTT_NOEXCEPT {\n    return mapped_type_fn();\n}\n\n\n/*! @copydoc meta_sequence_container::value_type */\n[[nodiscard]] inline meta_type meta_associative_container::value_type() const ENTT_NOEXCEPT {\n    return value_type_fn();\n}\n\n\n/*! @copydoc meta_sequence_container::size */\n[[nodiscard]] inline meta_associative_container::size_type meta_associative_container::size() const ENTT_NOEXCEPT {\n    return size_fn(instance);\n}\n\n\n/*! @copydoc meta_sequence_container::clear */\ninline bool meta_associative_container::clear() {\n    return clear_fn(instance);\n}\n\n\n/*! @copydoc meta_sequence_container::begin */\n[[nodiscard]] inline meta_associative_container::iterator meta_associative_container::begin() {\n    return begin_fn(instance);\n}\n\n\n/*! @copydoc meta_sequence_container::end */\n[[nodiscard]] inline meta_associative_container::iterator meta_associative_container::end() {\n    return end_fn(instance);\n}\n\n\n/**\n * @brief Inserts an element (a key/value pair) into the wrapped container.\n * @param key The key of the element to insert.\n * @param value The value of the element to insert.\n * @return A bool denoting whether the insertion took place.\n */\ninline bool meta_associative_container::insert(meta_any key, meta_any value = {}) {\n    return insert_fn(instance, key.ref(), value.ref());\n}\n\n\n/**\n * @brief Removes the specified element from the wrapped container.\n * @param key The key of the element to remove.\n * @return A bool denoting whether the removal took place.\n */\ninline bool meta_associative_container::erase(meta_any key) {\n    return erase_fn(instance, key.ref());\n}\n\n\n/**\n * @brief Returns an iterator to the element with key equivalent to a given\n * one, if any.\n * @param key The key of the element to search.\n * @return An iterator to the element with the given key, if any.\n */\n[[nodiscard]] inline meta_associative_container::iterator meta_associative_container::find(meta_any key) {\n    return find_fn(instance, key.ref());\n}\n\n\n/**\n * @brief Returns false if a proxy is invalid, true otherwise.\n * @return False if the proxy is invalid, true otherwise.\n */\n[[nodiscard]] inline meta_associative_container::operator bool() const ENTT_NOEXCEPT {\n    return (instance != nullptr);\n}\n\n\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    : key_only_container{!is_key_only_meta_associative_container_v<Type>},\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/skypjack___entt/git_repo_dir_ad5bb5198bae3e41beafc96a0a509725df0d3f79/build_ad5bb5198bae3e41beafc96a0a509725df0d3f79\nTest project /out/skypjack___entt/git_repo_dir_ad5bb5198bae3e41beafc96a0a509725df0d3f79/build_ad5bb5198bae3e41beafc96a0a509725df0d3f79\n    Start 23: meta_container\n1/1 Test #23: meta_container ...................***Failed    0.05 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.06 sec\n\nThe following tests FAILED:\n\t 23 - meta_container (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "ad5bb5198bae3e41beafc96a0a509725df0d3f79___meta.hpp"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nint\nnn_setsockopt(int s, int nnlevel, int nnopt, const void *valp, size_t sz)\n{\n\tconst char *name                             = NULL;\n\tint (*set)(nng_socket, const void *, size_t) = NULL;\n\tint rv;\n\n\tfor (unsigned i = 0; i < sizeof(options) / sizeof(options[0]); i++) {\n\t\tif ((options[i].nnlevel == nnlevel) &&\n\t\t    (options[i].nnopt == nnopt)) {\n\n\t\t\tset  = options[i].set;\n\t\t\tname = options[i].opt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set != NULL) {\n\t\treturn (set((nng_socket) s, valp, sz));\n\t}\n\n\tif (name == NULL) {\n\n>>> [ INFILL ] <<<\n\t}\n\n\tif ((rv = nng_setopt((nng_socket) s, name, valp, sz)) != 0) {\n\t\tnn_seterror(rv);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\t\treturn (ENOPROTOOPT);\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/nanomsg___nng/git_repo_dir_e3b8f31b044e4fe7d47439467fc1622266b5335c/build_e3b8f31b044e4fe7d47439467fc1622266b5335c\nUpdateCTestConfiguration  from :/out/nanomsg___nng/git_repo_dir_e3b8f31b044e4fe7d47439467fc1622266b5335c/build_e3b8f31b044e4fe7d47439467fc1622266b5335c/DartConfiguration.tcl\nUpdateCTestConfiguration  from :/out/nanomsg___nng/git_repo_dir_e3b8f31b044e4fe7d47439467fc1622266b5335c/build_e3b8f31b044e4fe7d47439467fc1622266b5335c/DartConfiguration.tcl\nTest project /out/nanomsg___nng/git_repo_dir_e3b8f31b044e4fe7d47439467fc1622266b5335c/build_e3b8f31b044e4fe7d47439467fc1622266b5335c\nConstructing a list of tests\nDone constructing a list of tests\nUpdating test list for fixtures\nAdded 0 tests to meet fixture requirements\nChecking test dependency graph...\nChecking test dependency graph end\ntest 8\n    Start  8: httpserver\n\n8: Test command: /out/nanomsg___nng/git_repo_dir_e3b8f31b044e4fe7d47439467fc1622266b5335c/build_e3b8f31b044e4fe7d47439467fc1622266b5335c/tests/httpserver \"-v\" \"-p\" \"TEST_PORT=12220\"\n8: Working Directory: /out/nanomsg___nng/git_repo_dir_e3b8f31b044e4fe7d47439467fc1622266b5335c/build_e3b8f31b044e4fe7d47439467fc1622266b5335c/tests\n8: Test timeout computed to be: 30\n8: === RUN: HTTP Server\n8: \n8:   We can start an HTTP server \u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\n8:     We can connect a client to it \u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\n8:       404 works \u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\n8:       Valid data works \u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\n8:   Directory serving works \u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m\u2714\u001b[0m\u001b[32m \nPlease provide the correct line following commit message at the infill location."}], "idx": "e3b8f31b044e4fe7d47439467fc1622266b5335c___nn.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nstatic int\nnni_chunk_insert(nni_chunk *ch, const void *data, size_t len)\n{\n\tint rv;\n\n\tif (ch->ch_ptr == NULL) {\n\t\tch->ch_ptr = ch->ch_buf;\n\t}\n\n\tif ((ch->ch_ptr >= ch->ch_buf) &&\n\t    (ch->ch_ptr < (ch->ch_buf + ch->ch_cap)) &&\n\t    (len <= (size_t)(ch->ch_ptr - ch->ch_buf))) {\n\t\t// There is already enough room at the beginning.\n\t\tch->ch_ptr -= len;\n\t} else if ((ch->ch_len + len) <= ch->ch_cap) {\n\t\t// We had enough capacity, just shuffle data down.\n\n>>> [ INFILL ] <<<\n\t} else if ((rv = nni_chunk_grow(ch, 0, len)) == 0) {\n\t\t// We grew the chunk, so adjust.\n\t\tch->ch_ptr -= len;\n\t} else {\n\t\t// Couldn't grow the chunk either.  Error.\n\t\treturn (rv);\n\t}\n\n\tch->ch_len += len;\n\tif (data != NULL) {\n\t\tmemcpy(ch->ch_ptr, data, len);\n\t}\n\n\treturn (0);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n\t\tmemmove(ch->ch_ptr + len, ch->ch_ptr, ch->ch_len);\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/nanomsg___nng/git_repo_dir_111b241473ceeecee1f1c232d3c9879fb850361d/build_111b241473ceeecee1f1c232d3c9879fb850361d\nTest project /out/nanomsg___nng/git_repo_dir_111b241473ceeecee1f1c232d3c9879fb850361d/build_111b241473ceeecee1f1c232d3c9879fb850361d\n    Start 60: nng.pipe\n1/1 Test #60: nng.pipe .........................   Passed    0.33 sec\n\n100% tests passed, 0 tests failed out of 1\n\nTotal Test time (real) =   0.34 sec\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "111b241473ceeecee1f1c232d3c9879fb850361d___message.c"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\n  FMT_CONSTEXPR void on_sign(sign_t s) {\n    require_numeric_argument();\n    if (is_integral_type(arg_type_) && arg_type_ != type::int_type &&\n\n>>> [ INFILL ] <<<\n      this->on_error(\"format specifier requires signed argument\");\n    }\n    Handler::on_sign(s);\n  }\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n        arg_type_ != type::long_long_type && arg_type_ != type::char_type) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_6a1346405949ca1cf5befc5e83c6c66c86e4f9d1/build_6a1346405949ca1cf5befc5e83c6c66c86e4f9d1\nTest project /out/fmtlib___fmt/git_repo_dir_6a1346405949ca1cf5befc5e83c6c66c86e4f9d1/build_6a1346405949ca1cf5befc5e83c6c66c86e4f9d1\n    Start 7: format-test\n1/1 Test #7: format-test ......................***Failed    0.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.02 sec\n\nThe following tests FAILED:\n\t  7 - format-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "6a1346405949ca1cf5befc5e83c6c66c86e4f9d1___core.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\n    void on_oct() {\n      int num_digits = internal::count_digits<3>(abs_value);\n\n>>> [ INFILL ] <<<\n        // Octal prefix '0' is counted as a digit, so only add it if precision\n        // is not greater than the number of digits.\n        prefix[prefix_size++] = '0';\n      }\n      writer.write_int(num_digits, get_prefix(), specs,\n                       bin_writer<3>{abs_value, num_digits});\n    }\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n      if (specs.alt && specs.precision <= num_digits) {\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_611cf0b3c644d33b9d347b824bf06bd594bfa564/build_611cf0b3c644d33b9d347b824bf06bd594bfa564\nTest project /out/fmtlib___fmt/git_repo_dir_611cf0b3c644d33b9d347b824bf06bd594bfa564/build_611cf0b3c644d33b9d347b824bf06bd594bfa564\n    Start 7: format-test\n1/1 Test #7: format-test ......................***Failed    0.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.02 sec\n\nThe following tests FAILED:\n\t  7 - format-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "611cf0b3c644d33b9d347b824bf06bd594bfa564___format.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\ntemplate <typename Context> class basic_format_args {\n public:\n  using size_type = int;\n  using format_arg = basic_format_arg<Context>;\n\n private:\n  // A descriptor that contains information about formatting arguments.\n  // If the number of arguments is less or equal to max_packed_args then\n  // argument types are passed in the descriptor. This reduces binary code size\n  // per formatting function call.\n  unsigned long long desc_;\n  union {\n    // If is_packed() returns true then argument values are stored in values_;\n    // otherwise they are stored in args_. This is done to improve cache\n    // locality and reduce compiled code size since storing larger objects\n    // may require more code (at least on x86-64) even if the same amount of\n    // data is actually copied to stack. It saves ~10% on the bloat test.\n    const detail::value<Context>* values_;\n    const format_arg* args_;\n  };\n\n  bool is_packed() const { return (desc_ & detail::is_unpacked_bit) == 0; }\n  bool has_named_args() const {\n    return (desc_ & detail::has_named_args_bit) != 0;\n  }\n\n  detail::type type(int index) const {\n    int shift = index * detail::packed_arg_bits;\n    unsigned int mask = (1 << detail::packed_arg_bits) - 1;\n    return static_cast<detail::type>((desc_ >> shift) & mask);\n  }\n\n  basic_format_args(unsigned long long desc,\n                    const detail::value<Context>* values)\n      : desc_(desc), values_(values) {}\n  basic_format_args(unsigned long long desc, const format_arg* args)\n      : desc_(desc), args_(args) {}\n\n public:\n  basic_format_args() : desc_(0) {}\n\n  /**\n   \\rst\n   Constructs a `basic_format_args` object from `~fmt::format_arg_store`.\n   \\endrst\n   */\n  template <typename... Args>\n  FMT_INLINE basic_format_args(const format_arg_store<Context, Args...>& store)\n      : basic_format_args(store.desc, store.data_.args()) {}\n\n  /**\n   \\rst\n   Constructs a `basic_format_args` object from\n   `~fmt::dynamic_format_arg_store`.\n   \\endrst\n   */\n  FMT_INLINE basic_format_args(const dynamic_format_arg_store<Context>& store)\n      : basic_format_args(store.get_types(), store.data()) {}\n\n  /**\n   \\rst\n   Constructs a `basic_format_args` object from a dynamic set of arguments.\n   \\endrst\n   */\n  basic_format_args(const format_arg* args, int count)\n      : basic_format_args(detail::is_unpacked_bit | detail::to_unsigned(count),\n                          args) {}\n\n  /** Returns the argument with the specified id. */\n  format_arg get(int id) const {\n    format_arg arg;\n    if (!is_packed()) {\n      if (id < max_size()) arg = args_[id];\n      return arg;\n    }\n    if (id >= detail::max_packed_args) return arg;\n    arg.type_ = type(id);\n    if (arg.type_ == detail::type::none_type) return arg;\n    arg.value_ = values_[id];\n    return arg;\n  }\n\n  template <typename Char> format_arg get(basic_string_view<Char> name) const {\n    int id = get_id(name);\n    return id >= 0 ? get(id) : format_arg();\n  }\n\n  template <typename Char> int get_id(basic_string_view<Char> name) const {\n\n>>> [ INFILL ] <<<\n    const auto& named_args =\n        (is_packed() ? values_[-1] : args_[-1].value_).named_args;\n    for (size_t i = 0; i < named_args.size; ++i) {\n      if (named_args.data[i].name == name) return named_args.data[i].id;\n    }\n    return -1;\n  }\n\n  int max_size() const {\n    unsigned long long max_packed = detail::max_packed_args;\n    return static_cast<int>(is_packed() ? max_packed\n                                        : desc_ & ~detail::is_unpacked_bit);\n  }\n};\n\n/** An alias to ``basic_format_args<context>``. */\n// It is a separate type rather than an alias to make symbols readable.\nstruct format_args : basic_format_args<format_context> {\n  template <typename... Args>\n  FMT_INLINE format_args(const Args&... args) : basic_format_args(args...) {}\n};\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    if (!has_named_args()) return {};\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_0cc73ebf79ec39ba74f3d31a76c0acb2df824908/build_0cc73ebf79ec39ba74f3d31a76c0acb2df824908\nTest project /out/fmtlib___fmt/git_repo_dir_0cc73ebf79ec39ba74f3d31a76c0acb2df824908/build_0cc73ebf79ec39ba74f3d31a76c0acb2df824908\n    Start 7: format-test\n1/1 Test #7: format-test ......................***Failed    0.03 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.03 sec\n\nThe following tests FAILED:\n\t  7 - format-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "0cc73ebf79ec39ba74f3d31a76c0acb2df824908___core.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nvoid basic_writer<Range>::write_double(T value, const format_specs &spec) {\n  // Check type.\n  float_spec_handler<char_type> handler(spec.type());\n  internal::handle_float_type_spec(spec.type(), handler);\n\n  char sign = 0;\n  // Use isnegative instead of value < 0 because the latter is always\n  // false for NaN.\n  if (internal::fputil::isnegative(static_cast<double>(value))) {\n    sign = '-';\n    value = -value;\n  } else if (spec.flag(SIGN_FLAG)) {\n    sign = spec.flag(PLUS_FLAG) ? '+' : ' ';\n  }\n\n  struct write_inf_or_nan_t {\n    basic_writer &writer;\n    format_specs spec;\n    char sign;\n    void operator()(const char *str) const {\n      writer.write_padded(INF_SIZE + (sign ? 1 : 0), spec,\n                          inf_or_nan_writer{sign, str});\n    }\n  } write_inf_or_nan = {*this, spec, sign};\n\n  // Format NaN and ininity ourselves because sprintf's output is not consistent\n  // across platforms.\n  if (internal::fputil::isnotanumber(value))\n    return write_inf_or_nan(handler.upper ? \"NAN\" : \"nan\");\n  if (internal::fputil::isinfinity(value))\n    return write_inf_or_nan(handler.upper ? \"INF\" : \"inf\");\n\n  basic_memory_buffer<char_type> buffer;\n  if (FMT_USE_GRISU && sizeof(T) <= sizeof(double) &&\n      std::numeric_limits<double>::is_iec559) {\n    internal::fp fp_value(static_cast<double>(value));\n    fp_value.normalize();\n    // Find a cached power of 10 close to 1 / fp_value.\n    int dec_exp = 0;\n    const int min_exp = -60;\n    auto dec_pow = internal::get_cached_power(\n        min_exp - (fp_value.e + internal::fp::significand_size), dec_exp);\n    internal::fp product = fp_value * dec_pow;\n    // Generate output.\n    internal::fp one(1ull << -product.e, product.e);\n    uint64_t hi = product.f >> -one.e;\n    uint64_t f = product.f & (one.f - 1);\n    typedef back_insert_range<internal::basic_buffer<char_type>> range;\n    basic_writer<range> w{range(buffer)};\n    w.write(hi);\n    size_t digits = buffer.size();\n    w.write('.');\n    const unsigned max_digits = 18;\n    while (digits++ < max_digits) {\n      f *= 10;\n      w.write(static_cast<char>('0' + (f >> -one.e)));\n      f &= one.f - 1;\n    }\n    w.write('e');\n    w.write(-dec_exp);\n  } else {\n    format_specs normalized_spec(spec);\n    normalized_spec.type_ = handler.type;\n    write_double_sprintf(value, normalized_spec, buffer);\n  }\n  size_t n = buffer.size();\n  align_spec as = spec;\n  if (spec.align() == ALIGN_NUMERIC) {\n    if (sign) {\n\n>>> [ INFILL ] <<<\n      sign = 0;\n      if (as.width_)\n        --as.width_;\n    }\n    as.align_ = ALIGN_RIGHT;\n  } else {\n    if (spec.align() == ALIGN_DEFAULT)\n      as.align_ = ALIGN_RIGHT;\n    if (sign)\n      ++n;\n  }\n  write_padded(n, as, double_writer{n, sign, buffer});\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n      *reserve(1) = sign;\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_fc6e0fe992156935bfb66bb2121c62ee8446758e/build_fc6e0fe992156935bfb66bb2121c62ee8446758e\nTest project /out/fmtlib___fmt/git_repo_dir_fc6e0fe992156935bfb66bb2121c62ee8446758e/build_fc6e0fe992156935bfb66bb2121c62ee8446758e\n    Start 3: format-test\n1/1 Test #3: format-test ......................***Failed    0.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.02 sec\n\nThe following tests FAILED:\n\t  3 - format-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "fc6e0fe992156935bfb66bb2121c62ee8446758e___format.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\nclass printf_arg_formatter : public detail::arg_formatter_base<Range> {\n public:\n  using iterator = typename Range::iterator;\n\n private:\n  using char_type = typename Range::value_type;\n  using base = detail::arg_formatter_base<Range>;\n  using context_type = basic_printf_context<iterator, char_type>;\n\n  context_type& context_;\n\n  void write_null_pointer(char) {\n    this->specs()->type = 0;\n    this->write(\"(nil)\");\n  }\n\n  void write_null_pointer(wchar_t) {\n    this->specs()->type = 0;\n    this->write(L\"(nil)\");\n  }\n\n public:\n  using format_specs = typename base::format_specs;\n\n  /**\n    \\rst\n    Constructs an argument formatter object.\n    *buffer* is a reference to the output buffer and *specs* contains format\n    specifier information for standard argument types.\n    \\endrst\n   */\n  printf_arg_formatter(iterator iter, format_specs& specs, context_type& ctx)\n      : base(Range(iter), &specs, detail::locale_ref()), context_(ctx) {}\n\n  template <typename T, FMT_ENABLE_IF(fmt::detail::is_integral<T>::value)>\n  iterator operator()(T value) {\n    // MSVC2013 fails to compile separate overloads for bool and char_type so\n    // use std::is_same instead.\n    if (std::is_same<T, bool>::value) {\n      format_specs& fmt_specs = *this->specs();\n      if (fmt_specs.type != 's') return base::operator()(value ? 1 : 0);\n      fmt_specs.type = 0;\n      this->write(value != 0);\n    } else if (std::is_same<T, char_type>::value) {\n      format_specs& fmt_specs = *this->specs();\n      if (fmt_specs.type && fmt_specs.type != 'c')\n        return (*this)(static_cast<int>(value));\n      fmt_specs.sign = sign::none;\n      fmt_specs.alt = false;\n\n>>> [ INFILL ] <<<\n      return base::operator()(value);\n    } else {\n      return base::operator()(value);\n    }\n    return this->out();\n  }\n\n  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>\n  iterator operator()(T value) {\n    return base::operator()(value);\n  }\n\n  /** Formats a null-terminated C string. */\n  iterator operator()(const char* value) {\n    if (value)\n      base::operator()(value);\n    else if (this->specs()->type == 'p')\n      write_null_pointer(char_type());\n    else\n      this->write(\"(null)\");\n    return this->out();\n  }\n\n  /** Formats a null-terminated wide C string. */\n  iterator operator()(const wchar_t* value) {\n    if (value)\n      base::operator()(value);\n    else if (this->specs()->type == 'p')\n      write_null_pointer(char_type());\n    else\n      this->write(L\"(null)\");\n    return this->out();\n  }\n\n  iterator operator()(basic_string_view<char_type> value) {\n    return base::operator()(value);\n  }\n\n  iterator operator()(monostate value) { return base::operator()(value); }\n\n  /** Formats a pointer. */\n  iterator operator()(const void* value) {\n    if (value) return base::operator()(value);\n    this->specs()->type = 0;\n    write_null_pointer(char_type());\n    return this->out();\n  }\n\n  /** Formats an argument of a custom (user-defined) type. */\n  iterator operator()(typename basic_format_arg<context_type>::handle handle) {\n    handle.format(context_.parse_context(), context_);\n    return this->out();\n  }\n};\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n      fmt_specs.align = align::right;\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_96c18b26c28bbdb8305b79be4eacfb28ee4aa872/build_96c18b26c28bbdb8305b79be4eacfb28ee4aa872\nTest project /out/fmtlib___fmt/git_repo_dir_96c18b26c28bbdb8305b79be4eacfb28ee4aa872/build_96c18b26c28bbdb8305b79be4eacfb28ee4aa872\n    Start 12: printf-test\n1/1 Test #12: printf-test ......................***Failed    0.01 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.01 sec\n\nThe following tests FAILED:\n\t 12 - printf-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "96c18b26c28bbdb8305b79be4eacfb28ee4aa872___printf.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\n  void on_second(numeric_system ns) {\n    if (handle_nan_inf()) return;\n\n    if (ns == numeric_system::standard) {\n      if (std::is_floating_point<rep>::value) {\n        auto buf = memory_buffer();\n        write_floating_seconds(buf, std::chrono::duration<rep, Period>(val));\n        if (negative) *out++ = '-';\n        if (buf.size() < 2 || buf[1] == '.') *out++ = '0';\n        out = std::copy(buf.begin(), buf.end(), out);\n      } else {\n        write(second(), 2);\n        write_fractional_seconds<char_type>(\n\n>>> [ INFILL ] <<<\n      }\n      return;\n    }\n    auto time = tm();\n    time.tm_sec = to_nonnegative_int(second(), 60);\n    format_tm(time, &tm_writer_type::on_second, ns);\n  }\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n            out, std::chrono::duration<Rep, Period>(val));\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_cd7202e0399677942a5428a7db9dec1d3c8b5c45/build_cd7202e0399677942a5428a7db9dec1d3c8b5c45\nTest project /out/fmtlib___fmt/git_repo_dir_cd7202e0399677942a5428a7db9dec1d3c8b5c45/build_cd7202e0399677942a5428a7db9dec1d3c8b5c45\n    Start 3: chrono-test\n1/1 Test #3: chrono-test ......................***Failed    0.11 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.11 sec\n\nThe following tests FAILED:\n\t  3 - chrono-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "cd7202e0399677942a5428a7db9dec1d3c8b5c45___chrono.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\n                     int& exp10) {\n  bigint numerator;    // 2 * R in (FPP)^2.\n  bigint denominator;  // 2 * S in (FPP)^2.\n  // lower and upper are differences between value and corresponding boundaries.\n  bigint lower;             // (M^- in (FPP)^2).\n  bigint upper_store;       // upper's value if different from lower.\n  bigint* upper = nullptr;  // (M^+ in (FPP)^2).\n  fp value;\n  // Shift numerator and denominator by an extra bit or two (if lower boundary\n  // is closer) to make lower and upper integers. This eliminates multiplication\n  // by 2 during later computations.\n  const bool is_predecessor_closer =\n      binary32 ? value.assign(static_cast<float>(d)) : value.assign(d);\n  int shift = is_predecessor_closer ? 2 : 1;\n  uint64_t significand = value.f << shift;\n  if (value.e >= 0) {\n    numerator.assign(significand);\n    numerator <<= value.e;\n    lower.assign(1);\n    lower <<= value.e;\n    if (shift != 1) {\n      upper_store.assign(1);\n      upper_store <<= value.e + 1;\n      upper = &upper_store;\n    }\n    denominator.assign_pow10(exp10);\n\n>>> [ INFILL ] <<<\n  } else if (exp10 < 0) {\n    numerator.assign_pow10(-exp10);\n    lower.assign(numerator);\n    if (shift != 1) {\n      upper_store.assign(numerator);\n      upper_store <<= 1;\n      upper = &upper_store;\n    }\n    numerator *= significand;\n    denominator.assign(1);\n    denominator <<= shift - value.e;\n  } else {\n    numerator.assign(significand);\n    denominator.assign_pow10(exp10);\n    denominator <<= shift - value.e;\n    lower.assign(1);\n    if (shift != 1) {\n      upper_store.assign(1ULL << 1);\n      upper = &upper_store;\n    }\n  }\n  // Invariant: value == (numerator / denominator) * pow(10, exp10).\n  if (num_digits < 0) {\n    // Generate the shortest representation.\n    if (!upper) upper = &lower;\n    bool even = (value.f & 1) == 0;\n    num_digits = 0;\n    char* data = buf.data();\n    for (;;) {\n      int digit = numerator.divmod_assign(denominator);\n      bool low = compare(numerator, lower) - even < 0;  // numerator <[=] lower.\n      // numerator + upper >[=] pow10:\n      bool high = add_compare(numerator, *upper, denominator) + even > 0;\n      data[num_digits++] = static_cast<char>('0' + digit);\n      if (low || high) {\n        if (!low) {\n          ++data[num_digits - 1];\n        } else if (high) {\n          int result = add_compare(numerator, numerator, denominator);\n          // Round half to even.\n          if (result > 0 || (result == 0 && (digit % 2) != 0))\n            ++data[num_digits - 1];\n        }\n        buf.try_resize(to_unsigned(num_digits));\n        exp10 -= num_digits - 1;\n        return;\n      }\n      numerator *= 10;\n      lower *= 10;\n      if (upper != &lower) *upper *= 10;\n    }\n  }\n  // Generate the given number of digits.\n  exp10 -= num_digits - 1;\n  if (num_digits == 0) {\n    buf.try_resize(1);\n    denominator *= 10;\n    buf[0] = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';\n    return;\n  }\n  buf.try_resize(to_unsigned(num_digits));\n  for (int i = 0; i < num_digits - 1; ++i) {\n    int digit = numerator.divmod_assign(denominator);\n    buf[i] = static_cast<char>('0' + digit);\n    numerator *= 10;\n  }\n  int digit = numerator.divmod_assign(denominator);\n  auto result = add_compare(numerator, numerator, denominator);\n  if (result > 0 || (result == 0 && (digit % 2) != 0)) {\n    if (digit == 9) {\n      const auto overflow = '0' + 10;\n      buf[num_digits - 1] = overflow;\n      // Propagate the carry.\n      for (int i = num_digits - 1; i > 0 && buf[i] == overflow; --i) {\n        buf[i] = '0';\n        ++buf[i - 1];\n      }\n      if (buf[0] == overflow) {\n        buf[0] = '1';\n        ++exp10;\n      }\n      return;\n    }\n    ++digit;\n  }\n  buf[num_digits - 1] = static_cast<char>('0' + digit);\n}\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    denominator <<= 1;\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_6b7bfed40c559c06d2a4e074427dbc24819bd447/build_6b7bfed40c559c06d2a4e074427dbc24819bd447\nTest project /out/fmtlib___fmt/git_repo_dir_6b7bfed40c559c06d2a4e074427dbc24819bd447/build_6b7bfed40c559c06d2a4e074427dbc24819bd447\n    Start 6: format-test\n1/1 Test #6: format-test ......................***Failed    0.02 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.02 sec\n\nThe following tests FAILED:\n\t  6 - format-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "6b7bfed40c559c06d2a4e074427dbc24819bd447___format-inl.h"}
{"temperature": 0.01, "prompt": [{"role": "system", "content": "You are a C/CPP code program repair expert"}, {"role": "user", "content": "\nThe following code contains a buggy line that has been removed.\n```cpp\ntemplate <typename OutputIt, typename Char, typename UInt> struct int_writer {\n  OutputIt out;\n  locale_ref locale;\n  const basic_format_specs<Char>& specs;\n  UInt abs_value;\n  char prefix[4];\n  unsigned prefix_size;\n\n  using iterator =\n      remove_reference_t<decltype(reserve(std::declval<OutputIt&>(), 0))>;\n\n  string_view get_prefix() const { return string_view(prefix, prefix_size); }\n\n  template <typename Int>\n  int_writer(OutputIt output, locale_ref loc, Int value,\n             const basic_format_specs<Char>& s)\n      : out(output),\n        locale(loc),\n        specs(s),\n        abs_value(static_cast<UInt>(value)),\n        prefix_size(0) {\n    static_assert(std::is_same<uint32_or_64_or_128_t<Int>, UInt>::value, \"\");\n    if (is_negative(value)) {\n      prefix[0] = '-';\n      ++prefix_size;\n      abs_value = 0 - abs_value;\n    } else if (specs.sign != sign::none && specs.sign != sign::minus) {\n      prefix[0] = specs.sign == sign::plus ? '+' : ' ';\n      ++prefix_size;\n    }\n  }\n\n  void on_dec() {\n    auto num_digits = count_digits(abs_value);\n    out = write_int(\n        out, num_digits, get_prefix(), specs, [this, num_digits](iterator it) {\n          return format_decimal<Char>(it, abs_value, num_digits).end;\n        });\n  }\n\n  void on_hex() {\n    if (specs.alt) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = specs.type;\n    }\n    int num_digits = count_digits<4>(abs_value);\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<4, Char>(it, abs_value, num_digits,\n                                                  specs.type != 'x');\n                    });\n  }\n\n  void on_bin() {\n    if (specs.alt) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = static_cast<char>(specs.type);\n    }\n    int num_digits = count_digits<1>(abs_value);\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<1, Char>(it, abs_value, num_digits);\n                    });\n  }\n\n  void on_oct() {\n    int num_digits = count_digits<3>(abs_value);\n    if (specs.alt && specs.precision <= num_digits && abs_value != 0) {\n      // Octal prefix '0' is counted as a digit, so only add it if precision\n      // is not greater than the number of digits.\n      prefix[prefix_size++] = '0';\n    }\n    out = write_int(out, num_digits, get_prefix(), specs,\n                    [this, num_digits](iterator it) {\n                      return format_uint<3, Char>(it, abs_value, num_digits);\n                    });\n  }\n\n  enum { sep_size = 1 };\n\n  void on_num() {\n    std::string groups = grouping<Char>(locale);\n    if (groups.empty()) return on_dec();\n    auto sep = thousands_sep<Char>(locale);\n    if (!sep) return on_dec();\n    int num_digits = count_digits(abs_value);\n    int size = num_digits, n = num_digits;\n    std::string::const_iterator group = groups.cbegin();\n\n>>> [ INFILL ] <<<\n           *group != max_value<char>()) {\n      size += sep_size;\n      n -= *group;\n      ++group;\n    }\n    if (group == groups.cend()) size += sep_size * ((n - 1) / groups.back());\n    char digits[40];\n    format_decimal(digits, abs_value, num_digits);\n    basic_memory_buffer<Char> buffer;\n    size += prefix_size;\n    buffer.resize(size);\n    basic_string_view<Char> s(&sep, sep_size);\n    // Index of a decimal digit with the least significant digit having index 0.\n    int digit_index = 0;\n    group = groups.cbegin();\n    auto p = buffer.data() + size;\n    for (int i = num_digits - 1; i >= 0; --i) {\n      *--p = static_cast<Char>(digits[i]);\n      if (*group <= 0 || ++digit_index % *group != 0 ||\n          *group == max_value<char>())\n        continue;\n      if (group + 1 != groups.cend()) {\n        digit_index = 0;\n        ++group;\n      }\n      p -= s.size();\n      std::uninitialized_copy(s.data(), s.data() + s.size(),\n                              make_checked(p, s.size()));\n    }\n    if (prefix_size != 0) p[-1] = static_cast<Char>('-');\n    write(out, basic_string_view<Char>(buffer.data(), buffer.size()), specs);\n  }\n\n  void on_chr() { *out++ = static_cast<Char>(abs_value); }\n\n  FMT_NORETURN void on_error() {\n    FMT_THROW(format_error(\"invalid type specifier\"));\n  }\n};\n\n```\nThis was the original buggy line which was removed by the infill location\n```cpp\n// buggy hunk\n    while (group != groups.cend() && num_digits > *group && *group > 0 &&\n\n```\n\n\n\nwith the following test error: Internal ctest changing into directory: /out/fmtlib___fmt/git_repo_dir_2b7a146fa1f91ee3d7ebc6a782663185543bc373/build_2b7a146fa1f91ee3d7ebc6a782663185543bc373\nTest project /out/fmtlib___fmt/git_repo_dir_2b7a146fa1f91ee3d7ebc6a782663185543bc373/build_2b7a146fa1f91ee3d7ebc6a782663185543bc373\n    Start 9: locale-test\n1/1 Test #9: locale-test ......................***Failed    0.00 sec\n\n0% tests passed, 1 tests failed out of 1\n\nTotal Test time (real) =   0.00 sec\n\nThe following tests FAILED:\n\t  9 - locale-test (Failed)\n \nPlease provide the correct line following commit message at the infill location."}], "idx": "2b7a146fa1f91ee3d7ebc6a782663185543bc373___format.h"}
